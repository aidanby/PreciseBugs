{"buggy_code": ["/*\n *\tAdaptec AAC series RAID controller driver\n *\t(c) Copyright 2001 Red Hat Inc.\n *\n * based on the old aacraid driver that is..\n * Adaptec aacraid device driver for Linux.\n *\n * Copyright (c) 2000-2010 Adaptec, Inc.\n *               2010 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; see the file COPYING.  If not, write to\n * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n * Module Name:\n *   linit.c\n *\n * Abstract: Linux Driver entry module for Adaptec RAID Array Controller\n */\n\n\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/pci-aspm.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsicam.h>\n#include <scsi/scsi_eh.h>\n\n#include \"aacraid.h\"\n\n#define AAC_DRIVER_VERSION\t\t\"1.2-0\"\n#ifndef AAC_DRIVER_BRANCH\n#define AAC_DRIVER_BRANCH\t\t\"\"\n#endif\n#define AAC_DRIVERNAME\t\t\t\"aacraid\"\n\n#ifdef AAC_DRIVER_BUILD\n#define _str(x) #x\n#define str(x) _str(x)\n#define AAC_DRIVER_FULL_VERSION\tAAC_DRIVER_VERSION \"[\" str(AAC_DRIVER_BUILD) \"]\" AAC_DRIVER_BRANCH\n#else\n#define AAC_DRIVER_FULL_VERSION\tAAC_DRIVER_VERSION AAC_DRIVER_BRANCH\n#endif\n\nMODULE_AUTHOR(\"Red Hat Inc and Adaptec\");\nMODULE_DESCRIPTION(\"Dell PERC2, 2/Si, 3/Si, 3/Di, \"\n\t\t   \"Adaptec Advanced Raid Products, \"\n\t\t   \"HP NetRAID-4M, IBM ServeRAID & ICP SCSI driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(AAC_DRIVER_FULL_VERSION);\n\nstatic DEFINE_MUTEX(aac_mutex);\nstatic LIST_HEAD(aac_devices);\nstatic int aac_cfg_major = -1;\nchar aac_driver_version[] = AAC_DRIVER_FULL_VERSION;\n\n/*\n * Because of the way Linux names scsi devices, the order in this table has\n * become important.  Check for on-board Raid first, add-in cards second.\n *\n * Note: The last field is used to index into aac_drivers below.\n */\nstatic const struct pci_device_id aac_pci_tbl[] = {\n\t{ 0x1028, 0x0001, 0x1028, 0x0001, 0, 0, 0 }, /* PERC 2/Si (Iguana/PERC2Si) */\n\t{ 0x1028, 0x0002, 0x1028, 0x0002, 0, 0, 1 }, /* PERC 3/Di (Opal/PERC3Di) */\n\t{ 0x1028, 0x0003, 0x1028, 0x0003, 0, 0, 2 }, /* PERC 3/Si (SlimFast/PERC3Si */\n\t{ 0x1028, 0x0004, 0x1028, 0x00d0, 0, 0, 3 }, /* PERC 3/Di (Iguana FlipChip/PERC3DiF */\n\t{ 0x1028, 0x0002, 0x1028, 0x00d1, 0, 0, 4 }, /* PERC 3/Di (Viper/PERC3DiV) */\n\t{ 0x1028, 0x0002, 0x1028, 0x00d9, 0, 0, 5 }, /* PERC 3/Di (Lexus/PERC3DiL) */\n\t{ 0x1028, 0x000a, 0x1028, 0x0106, 0, 0, 6 }, /* PERC 3/Di (Jaguar/PERC3DiJ) */\n\t{ 0x1028, 0x000a, 0x1028, 0x011b, 0, 0, 7 }, /* PERC 3/Di (Dagger/PERC3DiD) */\n\t{ 0x1028, 0x000a, 0x1028, 0x0121, 0, 0, 8 }, /* PERC 3/Di (Boxster/PERC3DiB) */\n\t{ 0x9005, 0x0283, 0x9005, 0x0283, 0, 0, 9 }, /* catapult */\n\t{ 0x9005, 0x0284, 0x9005, 0x0284, 0, 0, 10 }, /* tomcat */\n\t{ 0x9005, 0x0285, 0x9005, 0x0286, 0, 0, 11 }, /* Adaptec 2120S (Crusader) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0285, 0, 0, 12 }, /* Adaptec 2200S (Vulcan) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0287, 0, 0, 13 }, /* Adaptec 2200S (Vulcan-2m) */\n\t{ 0x9005, 0x0285, 0x17aa, 0x0286, 0, 0, 14 }, /* Legend S220 (Legend Crusader) */\n\t{ 0x9005, 0x0285, 0x17aa, 0x0287, 0, 0, 15 }, /* Legend S230 (Legend Vulcan) */\n\n\t{ 0x9005, 0x0285, 0x9005, 0x0288, 0, 0, 16 }, /* Adaptec 3230S (Harrier) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0289, 0, 0, 17 }, /* Adaptec 3240S (Tornado) */\n\t{ 0x9005, 0x0285, 0x9005, 0x028a, 0, 0, 18 }, /* ASR-2020ZCR SCSI PCI-X ZCR (Skyhawk) */\n\t{ 0x9005, 0x0285, 0x9005, 0x028b, 0, 0, 19 }, /* ASR-2025ZCR SCSI SO-DIMM PCI-X ZCR (Terminator) */\n\t{ 0x9005, 0x0286, 0x9005, 0x028c, 0, 0, 20 }, /* ASR-2230S + ASR-2230SLP PCI-X (Lancer) */\n\t{ 0x9005, 0x0286, 0x9005, 0x028d, 0, 0, 21 }, /* ASR-2130S (Lancer) */\n\t{ 0x9005, 0x0286, 0x9005, 0x029b, 0, 0, 22 }, /* AAR-2820SA (Intruder) */\n\t{ 0x9005, 0x0286, 0x9005, 0x029c, 0, 0, 23 }, /* AAR-2620SA (Intruder) */\n\t{ 0x9005, 0x0286, 0x9005, 0x029d, 0, 0, 24 }, /* AAR-2420SA (Intruder) */\n\t{ 0x9005, 0x0286, 0x9005, 0x029e, 0, 0, 25 }, /* ICP9024RO (Lancer) */\n\t{ 0x9005, 0x0286, 0x9005, 0x029f, 0, 0, 26 }, /* ICP9014RO (Lancer) */\n\t{ 0x9005, 0x0286, 0x9005, 0x02a0, 0, 0, 27 }, /* ICP9047MA (Lancer) */\n\t{ 0x9005, 0x0286, 0x9005, 0x02a1, 0, 0, 28 }, /* ICP9087MA (Lancer) */\n\t{ 0x9005, 0x0286, 0x9005, 0x02a3, 0, 0, 29 }, /* ICP5445AU (Hurricane44) */\n\t{ 0x9005, 0x0285, 0x9005, 0x02a4, 0, 0, 30 }, /* ICP9085LI (Marauder-X) */\n\t{ 0x9005, 0x0285, 0x9005, 0x02a5, 0, 0, 31 }, /* ICP5085BR (Marauder-E) */\n\t{ 0x9005, 0x0286, 0x9005, 0x02a6, 0, 0, 32 }, /* ICP9067MA (Intruder-6) */\n\t{ 0x9005, 0x0287, 0x9005, 0x0800, 0, 0, 33 }, /* Themisto Jupiter Platform */\n\t{ 0x9005, 0x0200, 0x9005, 0x0200, 0, 0, 33 }, /* Themisto Jupiter Platform */\n\t{ 0x9005, 0x0286, 0x9005, 0x0800, 0, 0, 34 }, /* Callisto Jupiter Platform */\n\t{ 0x9005, 0x0285, 0x9005, 0x028e, 0, 0, 35 }, /* ASR-2020SA SATA PCI-X ZCR (Skyhawk) */\n\t{ 0x9005, 0x0285, 0x9005, 0x028f, 0, 0, 36 }, /* ASR-2025SA SATA SO-DIMM PCI-X ZCR (Terminator) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0290, 0, 0, 37 }, /* AAR-2410SA PCI SATA 4ch (Jaguar II) */\n\t{ 0x9005, 0x0285, 0x1028, 0x0291, 0, 0, 38 }, /* CERC SATA RAID 2 PCI SATA 6ch (DellCorsair) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0292, 0, 0, 39 }, /* AAR-2810SA PCI SATA 8ch (Corsair-8) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0293, 0, 0, 40 }, /* AAR-21610SA PCI SATA 16ch (Corsair-16) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0294, 0, 0, 41 }, /* ESD SO-DIMM PCI-X SATA ZCR (Prowler) */\n\t{ 0x9005, 0x0285, 0x103C, 0x3227, 0, 0, 42 }, /* AAR-2610SA PCI SATA 6ch */\n\t{ 0x9005, 0x0285, 0x9005, 0x0296, 0, 0, 43 }, /* ASR-2240S (SabreExpress) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0297, 0, 0, 44 }, /* ASR-4005 */\n\t{ 0x9005, 0x0285, 0x1014, 0x02F2, 0, 0, 45 }, /* IBM 8i (AvonPark) */\n\t{ 0x9005, 0x0285, 0x1014, 0x0312, 0, 0, 45 }, /* IBM 8i (AvonPark Lite) */\n\t{ 0x9005, 0x0286, 0x1014, 0x9580, 0, 0, 46 }, /* IBM 8k/8k-l8 (Aurora) */\n\t{ 0x9005, 0x0286, 0x1014, 0x9540, 0, 0, 47 }, /* IBM 8k/8k-l4 (Aurora Lite) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0298, 0, 0, 48 }, /* ASR-4000 (BlackBird) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0299, 0, 0, 49 }, /* ASR-4800SAS (Marauder-X) */\n\t{ 0x9005, 0x0285, 0x9005, 0x029a, 0, 0, 50 }, /* ASR-4805SAS (Marauder-E) */\n\t{ 0x9005, 0x0286, 0x9005, 0x02a2, 0, 0, 51 }, /* ASR-3800 (Hurricane44) */\n\n\t{ 0x9005, 0x0285, 0x1028, 0x0287, 0, 0, 52 }, /* Perc 320/DC*/\n\t{ 0x1011, 0x0046, 0x9005, 0x0365, 0, 0, 53 }, /* Adaptec 5400S (Mustang)*/\n\t{ 0x1011, 0x0046, 0x9005, 0x0364, 0, 0, 54 }, /* Adaptec 5400S (Mustang)*/\n\t{ 0x1011, 0x0046, 0x9005, 0x1364, 0, 0, 55 }, /* Dell PERC2/QC */\n\t{ 0x1011, 0x0046, 0x103c, 0x10c2, 0, 0, 56 }, /* HP NetRAID-4M */\n\n\t{ 0x9005, 0x0285, 0x1028, PCI_ANY_ID, 0, 0, 57 }, /* Dell Catchall */\n\t{ 0x9005, 0x0285, 0x17aa, PCI_ANY_ID, 0, 0, 58 }, /* Legend Catchall */\n\t{ 0x9005, 0x0285, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 59 }, /* Adaptec Catch All */\n\t{ 0x9005, 0x0286, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 60 }, /* Adaptec Rocket Catch All */\n\t{ 0x9005, 0x0288, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 61 }, /* Adaptec NEMER/ARK Catch All */\n\t{ 0x9005, 0x028b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 62 }, /* Adaptec PMC Series 6 (Tupelo) */\n\t{ 0x9005, 0x028c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 63 }, /* Adaptec PMC Series 7 (Denali) */\n\t{ 0x9005, 0x028d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 64 }, /* Adaptec PMC Series 8 */\n\t{ 0x9005, 0x028f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 65 }, /* Adaptec PMC Series 9 */\n\t{ 0,}\n};\nMODULE_DEVICE_TABLE(pci, aac_pci_tbl);\n\n/*\n * dmb - For now we add the number of channels to this structure.\n * In the future we should add a fib that reports the number of channels\n * for the card.  At that time we can remove the channels from here\n */\nstatic struct aac_driver_ident aac_drivers[] = {\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 2/Si (Iguana/PERC2Si) */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Opal/PERC3Di) */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Si (SlimFast/PERC3Si */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Iguana FlipChip/PERC3DiF */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Viper/PERC3DiV) */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Lexus/PERC3DiL) */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 1, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Jaguar/PERC3DiJ) */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Dagger/PERC3DiD) */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Boxster/PERC3DiB) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"catapult        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* catapult */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"tomcat          \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* tomcat */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 2120S   \", 1, AAC_QUIRK_31BIT | AAC_QUIRK_34SG },\t\t      /* Adaptec 2120S (Crusader) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 2200S   \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG },\t\t      /* Adaptec 2200S (Vulcan) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 2200S   \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* Adaptec 2200S (Vulcan-2m) */\n\t{ aac_rx_init, \"aacraid\",  \"Legend  \", \"Legend S220     \", 1, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* Legend S220 (Legend Crusader) */\n\t{ aac_rx_init, \"aacraid\",  \"Legend  \", \"Legend S230     \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* Legend S230 (Legend Vulcan) */\n\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 3230S   \", 2 }, /* Adaptec 3230S (Harrier) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 3240S   \", 2 }, /* Adaptec 3240S (Tornado) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2020ZCR     \", 2 }, /* ASR-2020ZCR SCSI PCI-X ZCR (Skyhawk) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2025ZCR     \", 2 }, /* ASR-2025ZCR SCSI SO-DIMM PCI-X ZCR (Terminator) */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2230S PCI-X \", 2 }, /* ASR-2230S + ASR-2230SLP PCI-X (Lancer) */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2130S PCI-X \", 1 }, /* ASR-2130S (Lancer) */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2820SA      \", 1 }, /* AAR-2820SA (Intruder) */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2620SA      \", 1 }, /* AAR-2620SA (Intruder) */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2420SA      \", 1 }, /* AAR-2420SA (Intruder) */\n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9024RO       \", 2 }, /* ICP9024RO (Lancer) */\n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9014RO       \", 1 }, /* ICP9014RO (Lancer) */\n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9047MA       \", 1 }, /* ICP9047MA (Lancer) */\n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9087MA       \", 1 }, /* ICP9087MA (Lancer) */\n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP5445AU       \", 1 }, /* ICP5445AU (Hurricane44) */\n\t{ aac_rx_init, \"aacraid\",  \"ICP     \", \"ICP9085LI       \", 1 }, /* ICP9085LI (Marauder-X) */\n\t{ aac_rx_init, \"aacraid\",  \"ICP     \", \"ICP5085BR       \", 1 }, /* ICP5085BR (Marauder-E) */\n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9067MA       \", 1 }, /* ICP9067MA (Intruder-6) */\n\t{ NULL        , \"aacraid\",  \"ADAPTEC \", \"Themisto        \", 0, AAC_QUIRK_SLAVE }, /* Jupiter Platform */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"Callisto        \", 2, AAC_QUIRK_MASTER }, /* Jupiter Platform */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2020SA       \", 1 }, /* ASR-2020SA SATA PCI-X ZCR (Skyhawk) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2025SA       \", 1 }, /* ASR-2025SA SATA SO-DIMM PCI-X ZCR (Terminator) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2410SA SATA \", 1, AAC_QUIRK_17SG }, /* AAR-2410SA PCI SATA 4ch (Jaguar II) */\n\t{ aac_rx_init, \"aacraid\",  \"DELL    \", \"CERC SR2        \", 1, AAC_QUIRK_17SG }, /* CERC SATA RAID 2 PCI SATA 6ch (DellCorsair) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2810SA SATA \", 1, AAC_QUIRK_17SG }, /* AAR-2810SA PCI SATA 8ch (Corsair-8) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"AAR-21610SA SATA\", 1, AAC_QUIRK_17SG }, /* AAR-21610SA PCI SATA 16ch (Corsair-16) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2026ZCR     \", 1 }, /* ESD SO-DIMM PCI-X SATA ZCR (Prowler) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2610SA      \", 1 }, /* SATA 6Ch (Bearcat) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2240S       \", 1 }, /* ASR-2240S (SabreExpress) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-4005        \", 1 }, /* ASR-4005 */\n\t{ aac_rx_init, \"ServeRAID\",\"IBM     \", \"ServeRAID 8i    \", 1 }, /* IBM 8i (AvonPark) */\n\t{ aac_rkt_init, \"ServeRAID\",\"IBM     \", \"ServeRAID 8k-l8 \", 1 }, /* IBM 8k/8k-l8 (Aurora) */\n\t{ aac_rkt_init, \"ServeRAID\",\"IBM     \", \"ServeRAID 8k-l4 \", 1 }, /* IBM 8k/8k-l4 (Aurora Lite) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-4000        \", 1 }, /* ASR-4000 (BlackBird & AvonPark) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-4800SAS     \", 1 }, /* ASR-4800SAS (Marauder-X) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-4805SAS     \", 1 }, /* ASR-4805SAS (Marauder-E) */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"ASR-3800        \", 1 }, /* ASR-3800 (Hurricane44) */\n\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERC 320/DC     \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG }, /* Perc 320/DC*/\n\t{ aac_sa_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 5400S   \", 4, AAC_QUIRK_34SG }, /* Adaptec 5400S (Mustang)*/\n\t{ aac_sa_init, \"aacraid\",  \"ADAPTEC \", \"AAC-364         \", 4, AAC_QUIRK_34SG }, /* Adaptec 5400S (Mustang)*/\n\t{ aac_sa_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 4, AAC_QUIRK_34SG }, /* Dell PERC2/QC */\n\t{ aac_sa_init, \"hpnraid\",  \"HP      \", \"NetRAID         \", 4, AAC_QUIRK_34SG }, /* HP NetRAID-4M */\n\n\t{ aac_rx_init, \"aacraid\",  \"DELL    \", \"RAID            \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* Dell Catchall */\n\t{ aac_rx_init, \"aacraid\",  \"Legend  \", \"RAID            \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* Legend Catchall */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"RAID            \", 2 }, /* Adaptec Catch All */\n\t{ aac_rkt_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2 }, /* Adaptec Rocket Catch All */\n\t{ aac_nark_init, \"aacraid\", \"ADAPTEC \", \"RAID           \", 2 }, /* Adaptec NEMER/ARK Catch All */\n\t{ aac_src_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2 }, /* Adaptec PMC Series 6 (Tupelo) */\n\t{ aac_srcv_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2 }, /* Adaptec PMC Series 7 (Denali) */\n\t{ aac_srcv_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2 }, /* Adaptec PMC Series 8 */\n\t{ aac_srcv_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2 } /* Adaptec PMC Series 9 */\n};\n\n/**\n *\taac_queuecommand\t-\tqueue a SCSI command\n *\t@cmd:\t\tSCSI command to queue\n *\t@done:\t\tFunction to call on command completion\n *\n *\tQueues a command for execution by the associated Host Adapter.\n *\n *\tTODO: unify with aac_scsi_cmd().\n */\n\nstatic int aac_queuecommand_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))\n{\n\tstruct Scsi_Host *host = cmd->device->host;\n\tstruct aac_dev *dev = (struct aac_dev *)host->hostdata;\n\tu32 count = 0;\n\tcmd->scsi_done = done;\n\tfor (; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\n\t\tstruct fib * fib = &dev->fibs[count];\n\t\tstruct scsi_cmnd * command;\n\t\tif (fib->hw_fib_va->header.XferState &&\n\t\t    ((command = fib->callback_data)) &&\n\t\t    (command == cmd) &&\n\t\t    (cmd->SCp.phase == AAC_OWNER_FIRMWARE))\n\t\t\treturn 0; /* Already owned by Adapter */\n\t}\n\tcmd->SCp.phase = AAC_OWNER_LOWLEVEL;\n\treturn (aac_scsi_cmd(cmd) ? FAILED : 0);\n}\n\nstatic DEF_SCSI_QCMD(aac_queuecommand)\n\n/**\n *\taac_info\t\t-\tReturns the host adapter name\n *\t@shost:\t\tScsi host to report on\n *\n *\tReturns a static string describing the device in question\n */\n\nstatic const char *aac_info(struct Scsi_Host *shost)\n{\n\tstruct aac_dev *dev = (struct aac_dev *)shost->hostdata;\n\treturn aac_drivers[dev->cardtype].name;\n}\n\n/**\n *\taac_get_driver_ident\n *\t@devtype: index into lookup table\n *\n *\tReturns a pointer to the entry in the driver lookup table.\n */\n\nstruct aac_driver_ident* aac_get_driver_ident(int devtype)\n{\n\treturn &aac_drivers[devtype];\n}\n\n/**\n *\taac_biosparm\t-\treturn BIOS parameters for disk\n *\t@sdev: The scsi device corresponding to the disk\n *\t@bdev: the block device corresponding to the disk\n *\t@capacity: the sector capacity of the disk\n *\t@geom: geometry block to fill in\n *\n *\tReturn the Heads/Sectors/Cylinders BIOS Disk Parameters for Disk.\n *\tThe default disk geometry is 64 heads, 32 sectors, and the appropriate\n *\tnumber of cylinders so as not to exceed drive capacity.  In order for\n *\tdisks equal to or larger than 1 GB to be addressable by the BIOS\n *\twithout exceeding the BIOS limitation of 1024 cylinders, Extended\n *\tTranslation should be enabled.   With Extended Translation enabled,\n *\tdrives between 1 GB inclusive and 2 GB exclusive are given a disk\n *\tgeometry of 128 heads and 32 sectors, and drives above 2 GB inclusive\n *\tare given a disk geometry of 255 heads and 63 sectors.  However, if\n *\tthe BIOS detects that the Extended Translation setting does not match\n *\tthe geometry in the partition table, then the translation inferred\n *\tfrom the partition table will be used by the BIOS, and a warning may\n *\tbe displayed.\n */\n\nstatic int aac_biosparm(struct scsi_device *sdev, struct block_device *bdev,\n\t\t\tsector_t capacity, int *geom)\n{\n\tstruct diskparm *param = (struct diskparm *)geom;\n\tunsigned char *buf;\n\n\tdprintk((KERN_DEBUG \"aac_biosparm.\\n\"));\n\n\t/*\n\t *\tAssuming extended translation is enabled - #REVISIT#\n\t */\n\tif (capacity >= 2 * 1024 * 1024) { /* 1 GB in 512 byte sectors */\n\t\tif(capacity >= 4 * 1024 * 1024) { /* 2 GB in 512 byte sectors */\n\t\t\tparam->heads = 255;\n\t\t\tparam->sectors = 63;\n\t\t} else {\n\t\t\tparam->heads = 128;\n\t\t\tparam->sectors = 32;\n\t\t}\n\t} else {\n\t\tparam->heads = 64;\n\t\tparam->sectors = 32;\n\t}\n\n\tparam->cylinders = cap_to_cyls(capacity, param->heads * param->sectors);\n\n\t/*\n\t *\tRead the first 1024 bytes from the disk device, if the boot\n\t *\tsector partition table is valid, search for a partition table\n\t *\tentry whose end_head matches one of the standard geometry\n\t *\ttranslations ( 64/32, 128/32, 255/63 ).\n\t */\n\tbuf = scsi_bios_ptable(bdev);\n\tif (!buf)\n\t\treturn 0;\n\tif(*(__le16 *)(buf + 0x40) == cpu_to_le16(0xaa55)) {\n\t\tstruct partition *first = (struct partition * )buf;\n\t\tstruct partition *entry = first;\n\t\tint saved_cylinders = param->cylinders;\n\t\tint num;\n\t\tunsigned char end_head, end_sec;\n\n\t\tfor(num = 0; num < 4; num++) {\n\t\t\tend_head = entry->end_head;\n\t\t\tend_sec = entry->end_sector & 0x3f;\n\n\t\t\tif(end_head == 63) {\n\t\t\t\tparam->heads = 64;\n\t\t\t\tparam->sectors = 32;\n\t\t\t\tbreak;\n\t\t\t} else if(end_head == 127) {\n\t\t\t\tparam->heads = 128;\n\t\t\t\tparam->sectors = 32;\n\t\t\t\tbreak;\n\t\t\t} else if(end_head == 254) {\n\t\t\t\tparam->heads = 255;\n\t\t\t\tparam->sectors = 63;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry++;\n\t\t}\n\n\t\tif (num == 4) {\n\t\t\tend_head = first->end_head;\n\t\t\tend_sec = first->end_sector & 0x3f;\n\t\t}\n\n\t\tparam->cylinders = cap_to_cyls(capacity, param->heads * param->sectors);\n\t\tif (num < 4 && end_sec == param->sectors) {\n\t\t\tif (param->cylinders != saved_cylinders)\n\t\t\t\tdprintk((KERN_DEBUG \"Adopting geometry: heads=%d, sectors=%d from partition table %d.\\n\",\n\t\t\t\t\tparam->heads, param->sectors, num));\n\t\t} else if (end_head > 0 || end_sec > 0) {\n\t\t\tdprintk((KERN_DEBUG \"Strange geometry: heads=%d, sectors=%d in partition table %d.\\n\",\n\t\t\t\tend_head + 1, end_sec, num));\n\t\t\tdprintk((KERN_DEBUG \"Using geometry: heads=%d, sectors=%d.\\n\",\n\t\t\t\t\tparam->heads, param->sectors));\n\t\t}\n\t}\n\tkfree(buf);\n\treturn 0;\n}\n\n/**\n *\taac_slave_configure\t\t-\tcompute queue depths\n *\t@sdev:\tSCSI device we are considering\n *\n *\tSelects queue depths for each target device based on the host adapter's\n *\ttotal capacity and the queue depth supported by the target device.\n *\tA queue depth of one automatically disables tagged queueing.\n */\n\nstatic int aac_slave_configure(struct scsi_device *sdev)\n{\n\tstruct aac_dev *aac = (struct aac_dev *)sdev->host->hostdata;\n\tif (aac->jbod && (sdev->type == TYPE_DISK))\n\t\tsdev->removable = 1;\n\tif ((sdev->type == TYPE_DISK) &&\n\t\t\t(sdev_channel(sdev) != CONTAINER_CHANNEL) &&\n\t\t\t(!aac->jbod || sdev->inq_periph_qual) &&\n\t\t\t(!aac->raid_scsi_mode || (sdev_channel(sdev) != 2))) {\n\t\tif (expose_physicals == 0)\n\t\t\treturn -ENXIO;\n\t\tif (expose_physicals < 0)\n\t\t\tsdev->no_uld_attach = 1;\n\t}\n\tif (sdev->tagged_supported && (sdev->type == TYPE_DISK) &&\n\t\t\t(!aac->raid_scsi_mode || (sdev_channel(sdev) != 2)) &&\n\t\t\t!sdev->no_uld_attach) {\n\t\tstruct scsi_device * dev;\n\t\tstruct Scsi_Host *host = sdev->host;\n\t\tunsigned num_lsu = 0;\n\t\tunsigned num_one = 0;\n\t\tunsigned depth;\n\t\tunsigned cid;\n\n\t\t/*\n\t\t * Firmware has an individual device recovery time typically\n\t\t * of 35 seconds, give us a margin.\n\t\t */\n\t\tif (sdev->request_queue->rq_timeout < (45 * HZ))\n\t\t\tblk_queue_rq_timeout(sdev->request_queue, 45*HZ);\n\t\tfor (cid = 0; cid < aac->maximum_num_containers; ++cid)\n\t\t\tif (aac->fsa_dev[cid].valid)\n\t\t\t\t++num_lsu;\n\t\t__shost_for_each_device(dev, host) {\n\t\t\tif (dev->tagged_supported && (dev->type == TYPE_DISK) &&\n\t\t\t\t\t(!aac->raid_scsi_mode ||\n\t\t\t\t\t\t(sdev_channel(sdev) != 2)) &&\n\t\t\t\t\t!dev->no_uld_attach) {\n\t\t\t\tif ((sdev_channel(dev) != CONTAINER_CHANNEL)\n\t\t\t\t || !aac->fsa_dev[sdev_id(dev)].valid)\n\t\t\t\t\t++num_lsu;\n\t\t\t} else\n\t\t\t\t++num_one;\n\t\t}\n\t\tif (num_lsu == 0)\n\t\t\t++num_lsu;\n\t\tdepth = (host->can_queue - num_one) / num_lsu;\n\t\tif (depth > 256)\n\t\t\tdepth = 256;\n\t\telse if (depth < 2)\n\t\t\tdepth = 2;\n\t\tscsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG, depth);\n\t} else\n\t\tscsi_adjust_queue_depth(sdev, 0, 1);\n\n\treturn 0;\n}\n\n/**\n *\taac_change_queue_depth\t\t-\talter queue depths\n *\t@sdev:\tSCSI device we are considering\n *\t@depth:\tdesired queue depth\n *\n *\tAlters queue depths for target device based on the host adapter's\n *\ttotal capacity and the queue depth supported by the target device.\n */\n\nstatic int aac_change_queue_depth(struct scsi_device *sdev, int depth,\n\t\t\t\t  int reason)\n{\n\tif (reason != SCSI_QDEPTH_DEFAULT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sdev->tagged_supported && (sdev->type == TYPE_DISK) &&\n\t    (sdev_channel(sdev) == CONTAINER_CHANNEL)) {\n\t\tstruct scsi_device * dev;\n\t\tstruct Scsi_Host *host = sdev->host;\n\t\tunsigned num = 0;\n\n\t\t__shost_for_each_device(dev, host) {\n\t\t\tif (dev->tagged_supported && (dev->type == TYPE_DISK) &&\n\t\t\t    (sdev_channel(dev) == CONTAINER_CHANNEL))\n\t\t\t\t++num;\n\t\t\t++num;\n\t\t}\n\t\tif (num >= host->can_queue)\n\t\t\tnum = host->can_queue - 1;\n\t\tif (depth > (host->can_queue - num))\n\t\t\tdepth = host->can_queue - num;\n\t\tif (depth > 256)\n\t\t\tdepth = 256;\n\t\telse if (depth < 2)\n\t\t\tdepth = 2;\n\t\tscsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG, depth);\n\t} else\n\t\tscsi_adjust_queue_depth(sdev, 0, 1);\n\treturn sdev->queue_depth;\n}\n\nstatic ssize_t aac_show_raid_level(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct aac_dev *aac = (struct aac_dev *)(sdev->host->hostdata);\n\tif (sdev_channel(sdev) != CONTAINER_CHANNEL)\n\t\treturn snprintf(buf, PAGE_SIZE, sdev->no_uld_attach\n\t\t  ? \"Hidden\\n\" :\n\t\t  ((aac->jbod && (sdev->type == TYPE_DISK)) ? \"JBOD\\n\" : \"\"));\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t  get_container_type(aac->fsa_dev[sdev_id(sdev)].type));\n}\n\nstatic struct device_attribute aac_raid_level_attr = {\n\t.attr = {\n\t\t.name = \"level\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_raid_level\n};\n\nstatic struct device_attribute *aac_dev_attrs[] = {\n\t&aac_raid_level_attr,\n\tNULL,\n};\n\nstatic int aac_ioctl(struct scsi_device *sdev, int cmd, void __user * arg)\n{\n\tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\treturn aac_do_ioctl(dev, cmd, arg);\n}\n\nstatic int aac_eh_abort(struct scsi_cmnd* cmd)\n{\n\tstruct scsi_device * dev = cmd->device;\n\tstruct Scsi_Host * host = dev->host;\n\tstruct aac_dev * aac = (struct aac_dev *)host->hostdata;\n\tint count;\n\tint ret = FAILED;\n\n\tprintk(KERN_ERR \"%s: Host adapter abort request (%d,%d,%d,%d)\\n\",\n\t\tAAC_DRIVERNAME,\n\t\thost->host_no, sdev_channel(dev), sdev_id(dev), dev->lun);\n\tswitch (cmd->cmnd[0]) {\n\tcase SERVICE_ACTION_IN:\n\t\tif (!(aac->raw_io_interface) ||\n\t\t    !(aac->raw_io_64) ||\n\t\t    ((cmd->cmnd[1] & 0x1f) != SAI_READ_CAPACITY_16))\n\t\t\tbreak;\n\tcase INQUIRY:\n\tcase READ_CAPACITY:\n\t\t/* Mark associated FIB to not complete, eh handler does this */\n\t\tfor (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\n\t\t\tstruct fib * fib = &aac->fibs[count];\n\t\t\tif (fib->hw_fib_va->header.XferState &&\n\t\t\t  (fib->flags & FIB_CONTEXT_FLAG) &&\n\t\t\t  (fib->callback_data == cmd)) {\n\t\t\t\tfib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;\n\t\t\t\tcmd->SCp.phase = AAC_OWNER_ERROR_HANDLER;\n\t\t\t\tret = SUCCESS;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase TEST_UNIT_READY:\n\t\t/* Mark associated FIB to not complete, eh handler does this */\n\t\tfor (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\n\t\t\tstruct scsi_cmnd * command;\n\t\t\tstruct fib * fib = &aac->fibs[count];\n\t\t\tif ((fib->hw_fib_va->header.XferState & cpu_to_le32(Async | NoResponseExpected)) &&\n\t\t\t  (fib->flags & FIB_CONTEXT_FLAG) &&\n\t\t\t  ((command = fib->callback_data)) &&\n\t\t\t  (command->device == cmd->device)) {\n\t\t\t\tfib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;\n\t\t\t\tcommand->SCp.phase = AAC_OWNER_ERROR_HANDLER;\n\t\t\t\tif (command == cmd)\n\t\t\t\t\tret = SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\n *\taac_eh_reset\t- Reset command handling\n *\t@scsi_cmd:\tSCSI command block causing the reset\n *\n */\nstatic int aac_eh_reset(struct scsi_cmnd* cmd)\n{\n\tstruct scsi_device * dev = cmd->device;\n\tstruct Scsi_Host * host = dev->host;\n\tstruct scsi_cmnd * command;\n\tint count;\n\tstruct aac_dev * aac = (struct aac_dev *)host->hostdata;\n\tunsigned long flags;\n\n\t/* Mark the associated FIB to not complete, eh handler does this */\n\tfor (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\n\t\tstruct fib * fib = &aac->fibs[count];\n\t\tif (fib->hw_fib_va->header.XferState &&\n\t\t  (fib->flags & FIB_CONTEXT_FLAG) &&\n\t\t  (fib->callback_data == cmd)) {\n\t\t\tfib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;\n\t\t\tcmd->SCp.phase = AAC_OWNER_ERROR_HANDLER;\n\t\t}\n\t}\n\tprintk(KERN_ERR \"%s: Host adapter reset request. SCSI hang ?\\n\",\n\t\t\t\t\tAAC_DRIVERNAME);\n\n\tif ((count = aac_check_health(aac)))\n\t\treturn count;\n\t/*\n\t * Wait for all commands to complete to this specific\n\t * target (block maximum 60 seconds).\n\t */\n\tfor (count = 60; count; --count) {\n\t\tint active = aac->in_reset;\n\n\t\tif (active == 0)\n\t\t__shost_for_each_device(dev, host) {\n\t\t\tspin_lock_irqsave(&dev->list_lock, flags);\n\t\t\tlist_for_each_entry(command, &dev->cmd_list, list) {\n\t\t\t\tif ((command != cmd) &&\n\t\t\t\t    (command->SCp.phase == AAC_OWNER_FIRMWARE)) {\n\t\t\t\t\tactive++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&dev->list_lock, flags);\n\t\t\tif (active)\n\t\t\t\tbreak;\n\n\t\t}\n\t\t/*\n\t\t * We can exit If all the commands are complete\n\t\t */\n\t\tif (active == 0)\n\t\t\treturn SUCCESS;\n\t\tssleep(1);\n\t}\n\tprintk(KERN_ERR \"%s: SCSI bus appears hung\\n\", AAC_DRIVERNAME);\n\t/*\n\t * This adapter needs a blind reset, only do so for Adapters that\n\t * support a register, instead of a commanded, reset.\n\t */\n\tif (((aac->supplement_adapter_info.SupportedOptions2 &\n\t  AAC_OPTION_MU_RESET) ||\n\t  (aac->supplement_adapter_info.SupportedOptions2 &\n\t  AAC_OPTION_DOORBELL_RESET)) &&\n\t  aac_check_reset &&\n\t  ((aac_check_reset != 1) ||\n\t   !(aac->supplement_adapter_info.SupportedOptions2 &\n\t    AAC_OPTION_IGNORE_RESET)))\n\t\taac_reset_adapter(aac, 2); /* Bypass wait for command quiesce */\n\treturn SUCCESS; /* Cause an immediate retry of the command with a ten second delay after successful tur */\n}\n\n/**\n *\taac_cfg_open\t\t-\topen a configuration file\n *\t@inode: inode being opened\n *\t@file: file handle attached\n *\n *\tCalled when the configuration device is opened. Does the needed\n *\tset up on the handle and then returns\n *\n *\tBugs: This needs extending to check a given adapter is present\n *\tso we can support hot plugging, and to ref count adapters.\n */\n\nstatic int aac_cfg_open(struct inode *inode, struct file *file)\n{\n\tstruct aac_dev *aac;\n\tunsigned minor_number = iminor(inode);\n\tint err = -ENODEV;\n\n\tmutex_lock(&aac_mutex);  /* BKL pushdown: nothing else protects this list */\n\tlist_for_each_entry(aac, &aac_devices, entry) {\n\t\tif (aac->id == minor_number) {\n\t\t\tfile->private_data = aac;\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&aac_mutex);\n\n\treturn err;\n}\n\n/**\n *\taac_cfg_ioctl\t\t-\tAAC configuration request\n *\t@inode: inode of device\n *\t@file: file handle\n *\t@cmd: ioctl command code\n *\t@arg: argument\n *\n *\tHandles a configuration ioctl. Currently this involves wrapping it\n *\tup and feeding it into the nasty windowsalike glue layer.\n *\n *\tBugs: Needs locking against parallel ioctls lower down\n *\tBugs: Needs to handle hot plugging\n */\n\nstatic long aac_cfg_ioctl(struct file *file,\n\t\tunsigned int cmd, unsigned long arg)\n{\n\tint ret;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tmutex_lock(&aac_mutex);\n\tret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);\n\tmutex_unlock(&aac_mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long aac_compat_do_ioctl(struct aac_dev *dev, unsigned cmd, unsigned long arg)\n{\n\tlong ret;\n\tmutex_lock(&aac_mutex);\n\tswitch (cmd) {\n\tcase FSACTL_MINIPORT_REV_CHECK:\n\tcase FSACTL_SENDFIB:\n\tcase FSACTL_OPEN_GET_ADAPTER_FIB:\n\tcase FSACTL_CLOSE_GET_ADAPTER_FIB:\n\tcase FSACTL_SEND_RAW_SRB:\n\tcase FSACTL_GET_PCI_INFO:\n\tcase FSACTL_QUERY_DISK:\n\tcase FSACTL_DELETE_DISK:\n\tcase FSACTL_FORCE_DELETE_DISK:\n\tcase FSACTL_GET_CONTAINERS:\n\tcase FSACTL_SEND_LARGE_FIB:\n\t\tret = aac_do_ioctl(dev, cmd, (void __user *)arg);\n\t\tbreak;\n\n\tcase FSACTL_GET_NEXT_ADAPTER_FIB: {\n\t\tstruct fib_ioctl __user *f;\n\n\t\tf = compat_alloc_user_space(sizeof(*f));\n\t\tret = 0;\n\t\tif (clear_user(f, sizeof(*f)))\n\t\t\tret = -EFAULT;\n\t\tif (copy_in_user(f, (void __user *)arg, sizeof(struct fib_ioctl) - sizeof(u32)))\n\t\t\tret = -EFAULT;\n\t\tif (!ret)\n\t\t\tret = aac_do_ioctl(dev, cmd, f);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\tmutex_unlock(&aac_mutex);\n\treturn ret;\n}\n\nstatic int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n{\n\tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n\treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n}\n\nstatic long aac_compat_cfg_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\treturn aac_compat_do_ioctl(file->private_data, cmd, arg);\n}\n#endif\n\nstatic ssize_t aac_show_model(struct device *device,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len;\n\n\tif (dev->supplement_adapter_info.AdapterTypeText[0]) {\n\t\tchar * cp = dev->supplement_adapter_info.AdapterTypeText;\n\t\twhile (*cp && *cp != ' ')\n\t\t\t++cp;\n\t\twhile (*cp == ' ')\n\t\t\t++cp;\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%s\\n\", cp);\n\t} else\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t  aac_drivers[dev->cardtype].model);\n\treturn len;\n}\n\nstatic ssize_t aac_show_vendor(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len;\n\n\tif (dev->supplement_adapter_info.AdapterTypeText[0]) {\n\t\tchar * cp = dev->supplement_adapter_info.AdapterTypeText;\n\t\twhile (*cp && *cp != ' ')\n\t\t\t++cp;\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%.*s\\n\",\n\t\t  (int)(cp - (char *)dev->supplement_adapter_info.AdapterTypeText),\n\t\t  dev->supplement_adapter_info.AdapterTypeText);\n\t} else\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t  aac_drivers[dev->cardtype].vname);\n\treturn len;\n}\n\nstatic ssize_t aac_show_flags(struct device *cdev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tint len = 0;\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(cdev)->hostdata;\n\n\tif (nblank(dprintk(x)))\n\t\tlen = snprintf(buf, PAGE_SIZE, \"dprintk\\n\");\n#ifdef AAC_DETAILED_STATUS_INFO\n\tlen += snprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"AAC_DETAILED_STATUS_INFO\\n\");\n#endif\n\tif (dev->raw_io_interface && dev->raw_io_64)\n\t\tlen += snprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"SAI_READ_CAPACITY_16\\n\");\n\tif (dev->jbod)\n\t\tlen += snprintf(buf + len, PAGE_SIZE - len, \"SUPPORTED_JBOD\\n\");\n\tif (dev->supplement_adapter_info.SupportedOptions2 &\n\t\tAAC_OPTION_POWER_MANAGEMENT)\n\t\tlen += snprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"SUPPORTED_POWER_MANAGEMENT\\n\");\n\tif (dev->msi)\n\t\tlen += snprintf(buf + len, PAGE_SIZE - len, \"PCI_HAS_MSI\\n\");\n\treturn len;\n}\n\nstatic ssize_t aac_show_kernel_version(struct device *device,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len, tmp;\n\n\ttmp = le32_to_cpu(dev->adapter_info.kernelrev);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d.%d-%d[%d]\\n\",\n\t  tmp >> 24, (tmp >> 16) & 0xff, tmp & 0xff,\n\t  le32_to_cpu(dev->adapter_info.kernelbuild));\n\treturn len;\n}\n\nstatic ssize_t aac_show_monitor_version(struct device *device,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len, tmp;\n\n\ttmp = le32_to_cpu(dev->adapter_info.monitorrev);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d.%d-%d[%d]\\n\",\n\t  tmp >> 24, (tmp >> 16) & 0xff, tmp & 0xff,\n\t  le32_to_cpu(dev->adapter_info.monitorbuild));\n\treturn len;\n}\n\nstatic ssize_t aac_show_bios_version(struct device *device,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len, tmp;\n\n\ttmp = le32_to_cpu(dev->adapter_info.biosrev);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d.%d-%d[%d]\\n\",\n\t  tmp >> 24, (tmp >> 16) & 0xff, tmp & 0xff,\n\t  le32_to_cpu(dev->adapter_info.biosbuild));\n\treturn len;\n}\n\nstatic ssize_t aac_show_serial_number(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len = 0;\n\n\tif (le32_to_cpu(dev->adapter_info.serial[0]) != 0xBAD0)\n\t\tlen = snprintf(buf, 16, \"%06X\\n\",\n\t\t  le32_to_cpu(dev->adapter_info.serial[0]));\n\tif (len &&\n\t  !memcmp(&dev->supplement_adapter_info.MfgPcbaSerialNo[\n\t    sizeof(dev->supplement_adapter_info.MfgPcbaSerialNo)-len],\n\t  buf, len-1))\n\t\tlen = snprintf(buf, 16, \"%.*s\\n\",\n\t\t  (int)sizeof(dev->supplement_adapter_info.MfgPcbaSerialNo),\n\t\t  dev->supplement_adapter_info.MfgPcbaSerialNo);\n\n\treturn min(len, 16);\n}\n\nstatic ssize_t aac_show_max_channel(struct device *device,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t  class_to_shost(device)->max_channel);\n}\n\nstatic ssize_t aac_show_max_id(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t  class_to_shost(device)->max_id);\n}\n\nstatic ssize_t aac_store_reset_adapter(struct device *device,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tint retval = -EACCES;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn retval;\n\tretval = aac_reset_adapter((struct aac_dev*)class_to_shost(device)->hostdata, buf[0] == '!');\n\tif (retval >= 0)\n\t\tretval = count;\n\treturn retval;\n}\n\nstatic ssize_t aac_show_reset_adapter(struct device *device,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len, tmp;\n\n\ttmp = aac_adapter_check_health(dev);\n\tif ((tmp == 0) && dev->in_reset)\n\t\ttmp = -EBUSY;\n\tlen = snprintf(buf, PAGE_SIZE, \"0x%x\\n\", tmp);\n\treturn len;\n}\n\nstatic struct device_attribute aac_model = {\n\t.attr = {\n\t\t.name = \"model\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_model,\n};\nstatic struct device_attribute aac_vendor = {\n\t.attr = {\n\t\t.name = \"vendor\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_vendor,\n};\nstatic struct device_attribute aac_flags = {\n\t.attr = {\n\t\t.name = \"flags\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_flags,\n};\nstatic struct device_attribute aac_kernel_version = {\n\t.attr = {\n\t\t.name = \"hba_kernel_version\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_kernel_version,\n};\nstatic struct device_attribute aac_monitor_version = {\n\t.attr = {\n\t\t.name = \"hba_monitor_version\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_monitor_version,\n};\nstatic struct device_attribute aac_bios_version = {\n\t.attr = {\n\t\t.name = \"hba_bios_version\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_bios_version,\n};\nstatic struct device_attribute aac_serial_number = {\n\t.attr = {\n\t\t.name = \"serial_number\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_serial_number,\n};\nstatic struct device_attribute aac_max_channel = {\n\t.attr = {\n\t\t.name = \"max_channel\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_max_channel,\n};\nstatic struct device_attribute aac_max_id = {\n\t.attr = {\n\t\t.name = \"max_id\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_max_id,\n};\nstatic struct device_attribute aac_reset = {\n\t.attr = {\n\t\t.name = \"reset_host\",\n\t\t.mode = S_IWUSR|S_IRUGO,\n\t},\n\t.store = aac_store_reset_adapter,\n\t.show = aac_show_reset_adapter,\n};\n\nstatic struct device_attribute *aac_attrs[] = {\n\t&aac_model,\n\t&aac_vendor,\n\t&aac_flags,\n\t&aac_kernel_version,\n\t&aac_monitor_version,\n\t&aac_bios_version,\n\t&aac_serial_number,\n\t&aac_max_channel,\n\t&aac_max_id,\n\t&aac_reset,\n\tNULL\n};\n\nssize_t aac_get_serial_number(struct device *device, char *buf)\n{\n\treturn aac_show_serial_number(device, &aac_serial_number, buf);\n}\n\nstatic const struct file_operations aac_cfg_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= aac_cfg_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = aac_compat_cfg_ioctl,\n#endif\n\t.open\t\t= aac_cfg_open,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct scsi_host_template aac_driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= \"AAC\",\n\t.proc_name\t\t\t= AAC_DRIVERNAME,\n\t.info\t\t\t\t= aac_info,\n\t.ioctl\t\t\t\t= aac_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t\t= aac_compat_ioctl,\n#endif\n\t.queuecommand\t\t\t= aac_queuecommand,\n\t.bios_param\t\t\t= aac_biosparm,\n\t.shost_attrs\t\t\t= aac_attrs,\n\t.slave_configure\t\t= aac_slave_configure,\n\t.change_queue_depth\t\t= aac_change_queue_depth,\n\t.sdev_attrs\t\t\t= aac_dev_attrs,\n\t.eh_abort_handler\t\t= aac_eh_abort,\n\t.eh_host_reset_handler\t\t= aac_eh_reset,\n\t.can_queue\t\t\t= AAC_NUM_IO_FIB,\n\t.this_id\t\t\t= MAXIMUM_NUM_CONTAINERS,\n\t.sg_tablesize\t\t\t= 16,\n\t.max_sectors\t\t\t= 128,\n#if (AAC_NUM_IO_FIB > 256)\n\t.cmd_per_lun\t\t\t= 256,\n#else\n\t.cmd_per_lun\t\t\t= AAC_NUM_IO_FIB,\n#endif\n\t.use_clustering\t\t\t= ENABLE_CLUSTERING,\n\t.emulated\t\t\t= 1,\n};\n\nstatic void __aac_shutdown(struct aac_dev * aac)\n{\n\tif (aac->aif_thread) {\n\t\tint i;\n\t\t/* Clear out events first */\n\t\tfor (i = 0; i < (aac->scsi_host_ptr->can_queue + AAC_NUM_MGT_FIB); i++) {\n\t\t\tstruct fib *fib = &aac->fibs[i];\n\t\t\tif (!(fib->hw_fib_va->header.XferState & cpu_to_le32(NoResponseExpected | Async)) &&\n\t\t\t    (fib->hw_fib_va->header.XferState & cpu_to_le32(ResponseExpected)))\n\t\t\t\tup(&fib->event_wait);\n\t\t}\n\t\tkthread_stop(aac->thread);\n\t}\n\taac_send_shutdown(aac);\n\taac_adapter_disable_int(aac);\n\tfree_irq(aac->pdev->irq, aac);\n\tif (aac->msi)\n\t\tpci_disable_msi(aac->pdev);\n}\n\nstatic int aac_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tunsigned index = id->driver_data;\n\tstruct Scsi_Host *shost;\n\tstruct aac_dev *aac;\n\tstruct list_head *insert = &aac_devices;\n\tint error = -ENODEV;\n\tint unique_id = 0;\n\tu64 dmamask;\n\textern int aac_sync_mode;\n\n\tlist_for_each_entry(aac, &aac_devices, entry) {\n\t\tif (aac->id > unique_id)\n\t\t\tbreak;\n\t\tinsert = &aac->entry;\n\t\tunique_id++;\n\t}\n\n\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |\n\t\t\t       PCIE_LINK_STATE_CLKPM);\n\n\terror = pci_enable_device(pdev);\n\tif (error)\n\t\tgoto out;\n\terror = -ENODEV;\n\n\t/*\n\t * If the quirk31 bit is set, the adapter needs adapter\n\t * to driver communication memory to be allocated below 2gig\n\t */\n\tif (aac_drivers[index].quirks & AAC_QUIRK_31BIT)\n\t\tdmamask = DMA_BIT_MASK(31);\n\telse\n\t\tdmamask = DMA_BIT_MASK(32);\n\n\tif (pci_set_dma_mask(pdev, dmamask) ||\n\t\t\tpci_set_consistent_dma_mask(pdev, dmamask))\n\t\tgoto out_disable_pdev;\n\n\tpci_set_master(pdev);\n\n\tshost = scsi_host_alloc(&aac_driver_template, sizeof(struct aac_dev));\n\tif (!shost)\n\t\tgoto out_disable_pdev;\n\n\tshost->irq = pdev->irq;\n\tshost->unique_id = unique_id;\n\tshost->max_cmd_len = 16;\n\n\taac = (struct aac_dev *)shost->hostdata;\n\taac->base_start = pci_resource_start(pdev, 0);\n\taac->scsi_host_ptr = shost;\n\taac->pdev = pdev;\n\taac->name = aac_driver_template.name;\n\taac->id = shost->unique_id;\n\taac->cardtype = index;\n\tINIT_LIST_HEAD(&aac->entry);\n\n\taac->fibs = kzalloc(sizeof(struct fib) * (shost->can_queue + AAC_NUM_MGT_FIB), GFP_KERNEL);\n\tif (!aac->fibs)\n\t\tgoto out_free_host;\n\tspin_lock_init(&aac->fib_lock);\n\n\t/*\n\t *\tMap in the registers from the adapter.\n\t */\n\taac->base_size = AAC_MIN_FOOTPRINT_SIZE;\n\tif ((*aac_drivers[index].init)(aac))\n\t\tgoto out_unmap;\n\n\tif (aac->sync_mode) {\n\t\tif (aac_sync_mode)\n\t\t\tprintk(KERN_INFO \"%s%d: Sync. mode enforced \"\n\t\t\t\t\"by driver parameter. This will cause \"\n\t\t\t\t\"a significant performance decrease!\\n\",\n\t\t\t\taac->name,\n\t\t\t\taac->id);\n\t\telse\n\t\t\tprintk(KERN_INFO \"%s%d: Async. mode not supported \"\n\t\t\t\t\"by current driver, sync. mode enforced.\"\n\t\t\t\t\"\\nPlease update driver to get full performance.\\n\",\n\t\t\t\taac->name,\n\t\t\t\taac->id);\n\t}\n\n\t/*\n\t *\tStart any kernel threads needed\n\t */\n\taac->thread = kthread_run(aac_command_thread, aac, AAC_DRIVERNAME);\n\tif (IS_ERR(aac->thread)) {\n\t\tprintk(KERN_ERR \"aacraid: Unable to create command thread.\\n\");\n\t\terror = PTR_ERR(aac->thread);\n\t\taac->thread = NULL;\n\t\tgoto out_deinit;\n\t}\n\n\t/*\n\t * If we had set a smaller DMA mask earlier, set it to 4gig\n\t * now since the adapter can dma data to at least a 4gig\n\t * address space.\n\t */\n\tif (aac_drivers[index].quirks & AAC_QUIRK_31BIT)\n\t\tif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)))\n\t\t\tgoto out_deinit;\n\n\taac->maximum_num_channels = aac_drivers[index].channels;\n\terror = aac_get_adapter_info(aac);\n\tif (error < 0)\n\t\tgoto out_deinit;\n\n\t/*\n\t * Lets override negotiations and drop the maximum SG limit to 34\n\t */\n\tif ((aac_drivers[index].quirks & AAC_QUIRK_34SG) &&\n\t\t\t(shost->sg_tablesize > 34)) {\n\t\tshost->sg_tablesize = 34;\n\t\tshost->max_sectors = (shost->sg_tablesize * 8) + 112;\n\t}\n\n\tif ((aac_drivers[index].quirks & AAC_QUIRK_17SG) &&\n\t\t\t(shost->sg_tablesize > 17)) {\n\t\tshost->sg_tablesize = 17;\n\t\tshost->max_sectors = (shost->sg_tablesize * 8) + 112;\n\t}\n\n\terror = pci_set_dma_max_seg_size(pdev,\n\t\t(aac->adapter_info.options & AAC_OPT_NEW_COMM) ?\n\t\t\t(shost->max_sectors << 9) : 65536);\n\tif (error)\n\t\tgoto out_deinit;\n\n\t/*\n\t * Firmware printf works only with older firmware.\n\t */\n\tif (aac_drivers[index].quirks & AAC_QUIRK_34SG)\n\t\taac->printf_enabled = 1;\n\telse\n\t\taac->printf_enabled = 0;\n\n\t/*\n\t * max channel will be the physical channels plus 1 virtual channel\n\t * all containers are on the virtual channel 0 (CONTAINER_CHANNEL)\n\t * physical channels are address by their actual physical number+1\n\t */\n\tif (aac->nondasd_support || expose_physicals || aac->jbod)\n\t\tshost->max_channel = aac->maximum_num_channels;\n\telse\n\t\tshost->max_channel = 0;\n\n\taac_get_config_status(aac, 0);\n\taac_get_containers(aac);\n\tlist_add(&aac->entry, insert);\n\n\tshost->max_id = aac->maximum_num_containers;\n\tif (shost->max_id < aac->maximum_num_physicals)\n\t\tshost->max_id = aac->maximum_num_physicals;\n\tif (shost->max_id < MAXIMUM_NUM_CONTAINERS)\n\t\tshost->max_id = MAXIMUM_NUM_CONTAINERS;\n\telse\n\t\tshost->this_id = shost->max_id;\n\n\t/*\n\t * dmb - we may need to move the setting of these parms somewhere else once\n\t * we get a fib that can report the actual numbers\n\t */\n\tshost->max_lun = AAC_MAX_LUN;\n\n\tpci_set_drvdata(pdev, shost);\n\n\terror = scsi_add_host(shost, &pdev->dev);\n\tif (error)\n\t\tgoto out_deinit;\n\tscsi_scan_host(shost);\n\n\treturn 0;\n\n out_deinit:\n\t__aac_shutdown(aac);\n out_unmap:\n\taac_fib_map_free(aac);\n\tif (aac->comm_addr)\n\t\tpci_free_consistent(aac->pdev, aac->comm_size, aac->comm_addr,\n\t\t  aac->comm_phys);\n\tkfree(aac->queues);\n\taac_adapter_ioremap(aac, 0);\n\tkfree(aac->fibs);\n\tkfree(aac->fsa_dev);\n out_free_host:\n\tscsi_host_put(shost);\n out_disable_pdev:\n\tpci_disable_device(pdev);\n out:\n\treturn error;\n}\n\nstatic void aac_shutdown(struct pci_dev *dev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(dev);\n\tscsi_block_requests(shost);\n\t__aac_shutdown((struct aac_dev *)shost->hostdata);\n}\n\nstatic void aac_remove_one(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\tstruct aac_dev *aac = (struct aac_dev *)shost->hostdata;\n\n\tscsi_remove_host(shost);\n\n\t__aac_shutdown(aac);\n\taac_fib_map_free(aac);\n\tpci_free_consistent(aac->pdev, aac->comm_size, aac->comm_addr,\n\t\t\taac->comm_phys);\n\tkfree(aac->queues);\n\n\taac_adapter_ioremap(aac, 0);\n\n\tkfree(aac->fibs);\n\tkfree(aac->fsa_dev);\n\n\tlist_del(&aac->entry);\n\tscsi_host_put(shost);\n\tpci_disable_device(pdev);\n\tif (list_empty(&aac_devices)) {\n\t\tunregister_chrdev(aac_cfg_major, \"aac\");\n\t\taac_cfg_major = -1;\n\t}\n}\n\nstatic struct pci_driver aac_pci_driver = {\n\t.name\t\t= AAC_DRIVERNAME,\n\t.id_table\t= aac_pci_tbl,\n\t.probe\t\t= aac_probe_one,\n\t.remove\t\t= aac_remove_one,\n\t.shutdown\t= aac_shutdown,\n};\n\nstatic int __init aac_init(void)\n{\n\tint error;\n\n\tprintk(KERN_INFO \"Adaptec %s driver %s\\n\",\n\t  AAC_DRIVERNAME, aac_driver_version);\n\n\terror = pci_register_driver(&aac_pci_driver);\n\tif (error < 0)\n\t\treturn error;\n\n\taac_cfg_major = register_chrdev( 0, \"aac\", &aac_cfg_fops);\n\tif (aac_cfg_major < 0) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"aacraid: unable to register \\\"aac\\\" device.\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit aac_exit(void)\n{\n\tif (aac_cfg_major > -1)\n\t\tunregister_chrdev(aac_cfg_major, \"aac\");\n\tpci_unregister_driver(&aac_pci_driver);\n}\n\nmodule_init(aac_init);\nmodule_exit(aac_exit);\n"], "fixing_code": ["/*\n *\tAdaptec AAC series RAID controller driver\n *\t(c) Copyright 2001 Red Hat Inc.\n *\n * based on the old aacraid driver that is..\n * Adaptec aacraid device driver for Linux.\n *\n * Copyright (c) 2000-2010 Adaptec, Inc.\n *               2010 PMC-Sierra, Inc. (aacraid@pmc-sierra.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; see the file COPYING.  If not, write to\n * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n * Module Name:\n *   linit.c\n *\n * Abstract: Linux Driver entry module for Adaptec RAID Array Controller\n */\n\n\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/pci-aspm.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include <scsi/scsicam.h>\n#include <scsi/scsi_eh.h>\n\n#include \"aacraid.h\"\n\n#define AAC_DRIVER_VERSION\t\t\"1.2-0\"\n#ifndef AAC_DRIVER_BRANCH\n#define AAC_DRIVER_BRANCH\t\t\"\"\n#endif\n#define AAC_DRIVERNAME\t\t\t\"aacraid\"\n\n#ifdef AAC_DRIVER_BUILD\n#define _str(x) #x\n#define str(x) _str(x)\n#define AAC_DRIVER_FULL_VERSION\tAAC_DRIVER_VERSION \"[\" str(AAC_DRIVER_BUILD) \"]\" AAC_DRIVER_BRANCH\n#else\n#define AAC_DRIVER_FULL_VERSION\tAAC_DRIVER_VERSION AAC_DRIVER_BRANCH\n#endif\n\nMODULE_AUTHOR(\"Red Hat Inc and Adaptec\");\nMODULE_DESCRIPTION(\"Dell PERC2, 2/Si, 3/Si, 3/Di, \"\n\t\t   \"Adaptec Advanced Raid Products, \"\n\t\t   \"HP NetRAID-4M, IBM ServeRAID & ICP SCSI driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(AAC_DRIVER_FULL_VERSION);\n\nstatic DEFINE_MUTEX(aac_mutex);\nstatic LIST_HEAD(aac_devices);\nstatic int aac_cfg_major = -1;\nchar aac_driver_version[] = AAC_DRIVER_FULL_VERSION;\n\n/*\n * Because of the way Linux names scsi devices, the order in this table has\n * become important.  Check for on-board Raid first, add-in cards second.\n *\n * Note: The last field is used to index into aac_drivers below.\n */\nstatic const struct pci_device_id aac_pci_tbl[] = {\n\t{ 0x1028, 0x0001, 0x1028, 0x0001, 0, 0, 0 }, /* PERC 2/Si (Iguana/PERC2Si) */\n\t{ 0x1028, 0x0002, 0x1028, 0x0002, 0, 0, 1 }, /* PERC 3/Di (Opal/PERC3Di) */\n\t{ 0x1028, 0x0003, 0x1028, 0x0003, 0, 0, 2 }, /* PERC 3/Si (SlimFast/PERC3Si */\n\t{ 0x1028, 0x0004, 0x1028, 0x00d0, 0, 0, 3 }, /* PERC 3/Di (Iguana FlipChip/PERC3DiF */\n\t{ 0x1028, 0x0002, 0x1028, 0x00d1, 0, 0, 4 }, /* PERC 3/Di (Viper/PERC3DiV) */\n\t{ 0x1028, 0x0002, 0x1028, 0x00d9, 0, 0, 5 }, /* PERC 3/Di (Lexus/PERC3DiL) */\n\t{ 0x1028, 0x000a, 0x1028, 0x0106, 0, 0, 6 }, /* PERC 3/Di (Jaguar/PERC3DiJ) */\n\t{ 0x1028, 0x000a, 0x1028, 0x011b, 0, 0, 7 }, /* PERC 3/Di (Dagger/PERC3DiD) */\n\t{ 0x1028, 0x000a, 0x1028, 0x0121, 0, 0, 8 }, /* PERC 3/Di (Boxster/PERC3DiB) */\n\t{ 0x9005, 0x0283, 0x9005, 0x0283, 0, 0, 9 }, /* catapult */\n\t{ 0x9005, 0x0284, 0x9005, 0x0284, 0, 0, 10 }, /* tomcat */\n\t{ 0x9005, 0x0285, 0x9005, 0x0286, 0, 0, 11 }, /* Adaptec 2120S (Crusader) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0285, 0, 0, 12 }, /* Adaptec 2200S (Vulcan) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0287, 0, 0, 13 }, /* Adaptec 2200S (Vulcan-2m) */\n\t{ 0x9005, 0x0285, 0x17aa, 0x0286, 0, 0, 14 }, /* Legend S220 (Legend Crusader) */\n\t{ 0x9005, 0x0285, 0x17aa, 0x0287, 0, 0, 15 }, /* Legend S230 (Legend Vulcan) */\n\n\t{ 0x9005, 0x0285, 0x9005, 0x0288, 0, 0, 16 }, /* Adaptec 3230S (Harrier) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0289, 0, 0, 17 }, /* Adaptec 3240S (Tornado) */\n\t{ 0x9005, 0x0285, 0x9005, 0x028a, 0, 0, 18 }, /* ASR-2020ZCR SCSI PCI-X ZCR (Skyhawk) */\n\t{ 0x9005, 0x0285, 0x9005, 0x028b, 0, 0, 19 }, /* ASR-2025ZCR SCSI SO-DIMM PCI-X ZCR (Terminator) */\n\t{ 0x9005, 0x0286, 0x9005, 0x028c, 0, 0, 20 }, /* ASR-2230S + ASR-2230SLP PCI-X (Lancer) */\n\t{ 0x9005, 0x0286, 0x9005, 0x028d, 0, 0, 21 }, /* ASR-2130S (Lancer) */\n\t{ 0x9005, 0x0286, 0x9005, 0x029b, 0, 0, 22 }, /* AAR-2820SA (Intruder) */\n\t{ 0x9005, 0x0286, 0x9005, 0x029c, 0, 0, 23 }, /* AAR-2620SA (Intruder) */\n\t{ 0x9005, 0x0286, 0x9005, 0x029d, 0, 0, 24 }, /* AAR-2420SA (Intruder) */\n\t{ 0x9005, 0x0286, 0x9005, 0x029e, 0, 0, 25 }, /* ICP9024RO (Lancer) */\n\t{ 0x9005, 0x0286, 0x9005, 0x029f, 0, 0, 26 }, /* ICP9014RO (Lancer) */\n\t{ 0x9005, 0x0286, 0x9005, 0x02a0, 0, 0, 27 }, /* ICP9047MA (Lancer) */\n\t{ 0x9005, 0x0286, 0x9005, 0x02a1, 0, 0, 28 }, /* ICP9087MA (Lancer) */\n\t{ 0x9005, 0x0286, 0x9005, 0x02a3, 0, 0, 29 }, /* ICP5445AU (Hurricane44) */\n\t{ 0x9005, 0x0285, 0x9005, 0x02a4, 0, 0, 30 }, /* ICP9085LI (Marauder-X) */\n\t{ 0x9005, 0x0285, 0x9005, 0x02a5, 0, 0, 31 }, /* ICP5085BR (Marauder-E) */\n\t{ 0x9005, 0x0286, 0x9005, 0x02a6, 0, 0, 32 }, /* ICP9067MA (Intruder-6) */\n\t{ 0x9005, 0x0287, 0x9005, 0x0800, 0, 0, 33 }, /* Themisto Jupiter Platform */\n\t{ 0x9005, 0x0200, 0x9005, 0x0200, 0, 0, 33 }, /* Themisto Jupiter Platform */\n\t{ 0x9005, 0x0286, 0x9005, 0x0800, 0, 0, 34 }, /* Callisto Jupiter Platform */\n\t{ 0x9005, 0x0285, 0x9005, 0x028e, 0, 0, 35 }, /* ASR-2020SA SATA PCI-X ZCR (Skyhawk) */\n\t{ 0x9005, 0x0285, 0x9005, 0x028f, 0, 0, 36 }, /* ASR-2025SA SATA SO-DIMM PCI-X ZCR (Terminator) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0290, 0, 0, 37 }, /* AAR-2410SA PCI SATA 4ch (Jaguar II) */\n\t{ 0x9005, 0x0285, 0x1028, 0x0291, 0, 0, 38 }, /* CERC SATA RAID 2 PCI SATA 6ch (DellCorsair) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0292, 0, 0, 39 }, /* AAR-2810SA PCI SATA 8ch (Corsair-8) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0293, 0, 0, 40 }, /* AAR-21610SA PCI SATA 16ch (Corsair-16) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0294, 0, 0, 41 }, /* ESD SO-DIMM PCI-X SATA ZCR (Prowler) */\n\t{ 0x9005, 0x0285, 0x103C, 0x3227, 0, 0, 42 }, /* AAR-2610SA PCI SATA 6ch */\n\t{ 0x9005, 0x0285, 0x9005, 0x0296, 0, 0, 43 }, /* ASR-2240S (SabreExpress) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0297, 0, 0, 44 }, /* ASR-4005 */\n\t{ 0x9005, 0x0285, 0x1014, 0x02F2, 0, 0, 45 }, /* IBM 8i (AvonPark) */\n\t{ 0x9005, 0x0285, 0x1014, 0x0312, 0, 0, 45 }, /* IBM 8i (AvonPark Lite) */\n\t{ 0x9005, 0x0286, 0x1014, 0x9580, 0, 0, 46 }, /* IBM 8k/8k-l8 (Aurora) */\n\t{ 0x9005, 0x0286, 0x1014, 0x9540, 0, 0, 47 }, /* IBM 8k/8k-l4 (Aurora Lite) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0298, 0, 0, 48 }, /* ASR-4000 (BlackBird) */\n\t{ 0x9005, 0x0285, 0x9005, 0x0299, 0, 0, 49 }, /* ASR-4800SAS (Marauder-X) */\n\t{ 0x9005, 0x0285, 0x9005, 0x029a, 0, 0, 50 }, /* ASR-4805SAS (Marauder-E) */\n\t{ 0x9005, 0x0286, 0x9005, 0x02a2, 0, 0, 51 }, /* ASR-3800 (Hurricane44) */\n\n\t{ 0x9005, 0x0285, 0x1028, 0x0287, 0, 0, 52 }, /* Perc 320/DC*/\n\t{ 0x1011, 0x0046, 0x9005, 0x0365, 0, 0, 53 }, /* Adaptec 5400S (Mustang)*/\n\t{ 0x1011, 0x0046, 0x9005, 0x0364, 0, 0, 54 }, /* Adaptec 5400S (Mustang)*/\n\t{ 0x1011, 0x0046, 0x9005, 0x1364, 0, 0, 55 }, /* Dell PERC2/QC */\n\t{ 0x1011, 0x0046, 0x103c, 0x10c2, 0, 0, 56 }, /* HP NetRAID-4M */\n\n\t{ 0x9005, 0x0285, 0x1028, PCI_ANY_ID, 0, 0, 57 }, /* Dell Catchall */\n\t{ 0x9005, 0x0285, 0x17aa, PCI_ANY_ID, 0, 0, 58 }, /* Legend Catchall */\n\t{ 0x9005, 0x0285, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 59 }, /* Adaptec Catch All */\n\t{ 0x9005, 0x0286, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 60 }, /* Adaptec Rocket Catch All */\n\t{ 0x9005, 0x0288, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 61 }, /* Adaptec NEMER/ARK Catch All */\n\t{ 0x9005, 0x028b, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 62 }, /* Adaptec PMC Series 6 (Tupelo) */\n\t{ 0x9005, 0x028c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 63 }, /* Adaptec PMC Series 7 (Denali) */\n\t{ 0x9005, 0x028d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 64 }, /* Adaptec PMC Series 8 */\n\t{ 0x9005, 0x028f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 65 }, /* Adaptec PMC Series 9 */\n\t{ 0,}\n};\nMODULE_DEVICE_TABLE(pci, aac_pci_tbl);\n\n/*\n * dmb - For now we add the number of channels to this structure.\n * In the future we should add a fib that reports the number of channels\n * for the card.  At that time we can remove the channels from here\n */\nstatic struct aac_driver_ident aac_drivers[] = {\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 2/Si (Iguana/PERC2Si) */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Opal/PERC3Di) */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Si (SlimFast/PERC3Si */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Iguana FlipChip/PERC3DiF */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Viper/PERC3DiV) */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Lexus/PERC3DiL) */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 1, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Jaguar/PERC3DiJ) */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Dagger/PERC3DiD) */\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* PERC 3/Di (Boxster/PERC3DiB) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"catapult        \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* catapult */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"tomcat          \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* tomcat */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 2120S   \", 1, AAC_QUIRK_31BIT | AAC_QUIRK_34SG },\t\t      /* Adaptec 2120S (Crusader) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 2200S   \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG },\t\t      /* Adaptec 2200S (Vulcan) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 2200S   \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* Adaptec 2200S (Vulcan-2m) */\n\t{ aac_rx_init, \"aacraid\",  \"Legend  \", \"Legend S220     \", 1, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* Legend S220 (Legend Crusader) */\n\t{ aac_rx_init, \"aacraid\",  \"Legend  \", \"Legend S230     \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* Legend S230 (Legend Vulcan) */\n\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 3230S   \", 2 }, /* Adaptec 3230S (Harrier) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 3240S   \", 2 }, /* Adaptec 3240S (Tornado) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2020ZCR     \", 2 }, /* ASR-2020ZCR SCSI PCI-X ZCR (Skyhawk) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2025ZCR     \", 2 }, /* ASR-2025ZCR SCSI SO-DIMM PCI-X ZCR (Terminator) */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2230S PCI-X \", 2 }, /* ASR-2230S + ASR-2230SLP PCI-X (Lancer) */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2130S PCI-X \", 1 }, /* ASR-2130S (Lancer) */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2820SA      \", 1 }, /* AAR-2820SA (Intruder) */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2620SA      \", 1 }, /* AAR-2620SA (Intruder) */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2420SA      \", 1 }, /* AAR-2420SA (Intruder) */\n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9024RO       \", 2 }, /* ICP9024RO (Lancer) */\n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9014RO       \", 1 }, /* ICP9014RO (Lancer) */\n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9047MA       \", 1 }, /* ICP9047MA (Lancer) */\n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9087MA       \", 1 }, /* ICP9087MA (Lancer) */\n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP5445AU       \", 1 }, /* ICP5445AU (Hurricane44) */\n\t{ aac_rx_init, \"aacraid\",  \"ICP     \", \"ICP9085LI       \", 1 }, /* ICP9085LI (Marauder-X) */\n\t{ aac_rx_init, \"aacraid\",  \"ICP     \", \"ICP5085BR       \", 1 }, /* ICP5085BR (Marauder-E) */\n\t{ aac_rkt_init, \"aacraid\",  \"ICP     \", \"ICP9067MA       \", 1 }, /* ICP9067MA (Intruder-6) */\n\t{ NULL        , \"aacraid\",  \"ADAPTEC \", \"Themisto        \", 0, AAC_QUIRK_SLAVE }, /* Jupiter Platform */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"Callisto        \", 2, AAC_QUIRK_MASTER }, /* Jupiter Platform */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2020SA       \", 1 }, /* ASR-2020SA SATA PCI-X ZCR (Skyhawk) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2025SA       \", 1 }, /* ASR-2025SA SATA SO-DIMM PCI-X ZCR (Terminator) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2410SA SATA \", 1, AAC_QUIRK_17SG }, /* AAR-2410SA PCI SATA 4ch (Jaguar II) */\n\t{ aac_rx_init, \"aacraid\",  \"DELL    \", \"CERC SR2        \", 1, AAC_QUIRK_17SG }, /* CERC SATA RAID 2 PCI SATA 6ch (DellCorsair) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2810SA SATA \", 1, AAC_QUIRK_17SG }, /* AAR-2810SA PCI SATA 8ch (Corsair-8) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"AAR-21610SA SATA\", 1, AAC_QUIRK_17SG }, /* AAR-21610SA PCI SATA 16ch (Corsair-16) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2026ZCR     \", 1 }, /* ESD SO-DIMM PCI-X SATA ZCR (Prowler) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"AAR-2610SA      \", 1 }, /* SATA 6Ch (Bearcat) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-2240S       \", 1 }, /* ASR-2240S (SabreExpress) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-4005        \", 1 }, /* ASR-4005 */\n\t{ aac_rx_init, \"ServeRAID\",\"IBM     \", \"ServeRAID 8i    \", 1 }, /* IBM 8i (AvonPark) */\n\t{ aac_rkt_init, \"ServeRAID\",\"IBM     \", \"ServeRAID 8k-l8 \", 1 }, /* IBM 8k/8k-l8 (Aurora) */\n\t{ aac_rkt_init, \"ServeRAID\",\"IBM     \", \"ServeRAID 8k-l4 \", 1 }, /* IBM 8k/8k-l4 (Aurora Lite) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-4000        \", 1 }, /* ASR-4000 (BlackBird & AvonPark) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-4800SAS     \", 1 }, /* ASR-4800SAS (Marauder-X) */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"ASR-4805SAS     \", 1 }, /* ASR-4805SAS (Marauder-E) */\n\t{ aac_rkt_init, \"aacraid\",  \"ADAPTEC \", \"ASR-3800        \", 1 }, /* ASR-3800 (Hurricane44) */\n\n\t{ aac_rx_init, \"percraid\", \"DELL    \", \"PERC 320/DC     \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG }, /* Perc 320/DC*/\n\t{ aac_sa_init, \"aacraid\",  \"ADAPTEC \", \"Adaptec 5400S   \", 4, AAC_QUIRK_34SG }, /* Adaptec 5400S (Mustang)*/\n\t{ aac_sa_init, \"aacraid\",  \"ADAPTEC \", \"AAC-364         \", 4, AAC_QUIRK_34SG }, /* Adaptec 5400S (Mustang)*/\n\t{ aac_sa_init, \"percraid\", \"DELL    \", \"PERCRAID        \", 4, AAC_QUIRK_34SG }, /* Dell PERC2/QC */\n\t{ aac_sa_init, \"hpnraid\",  \"HP      \", \"NetRAID         \", 4, AAC_QUIRK_34SG }, /* HP NetRAID-4M */\n\n\t{ aac_rx_init, \"aacraid\",  \"DELL    \", \"RAID            \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* Dell Catchall */\n\t{ aac_rx_init, \"aacraid\",  \"Legend  \", \"RAID            \", 2, AAC_QUIRK_31BIT | AAC_QUIRK_34SG | AAC_QUIRK_SCSI_32 }, /* Legend Catchall */\n\t{ aac_rx_init, \"aacraid\",  \"ADAPTEC \", \"RAID            \", 2 }, /* Adaptec Catch All */\n\t{ aac_rkt_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2 }, /* Adaptec Rocket Catch All */\n\t{ aac_nark_init, \"aacraid\", \"ADAPTEC \", \"RAID           \", 2 }, /* Adaptec NEMER/ARK Catch All */\n\t{ aac_src_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2 }, /* Adaptec PMC Series 6 (Tupelo) */\n\t{ aac_srcv_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2 }, /* Adaptec PMC Series 7 (Denali) */\n\t{ aac_srcv_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2 }, /* Adaptec PMC Series 8 */\n\t{ aac_srcv_init, \"aacraid\", \"ADAPTEC \", \"RAID            \", 2 } /* Adaptec PMC Series 9 */\n};\n\n/**\n *\taac_queuecommand\t-\tqueue a SCSI command\n *\t@cmd:\t\tSCSI command to queue\n *\t@done:\t\tFunction to call on command completion\n *\n *\tQueues a command for execution by the associated Host Adapter.\n *\n *\tTODO: unify with aac_scsi_cmd().\n */\n\nstatic int aac_queuecommand_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmnd *))\n{\n\tstruct Scsi_Host *host = cmd->device->host;\n\tstruct aac_dev *dev = (struct aac_dev *)host->hostdata;\n\tu32 count = 0;\n\tcmd->scsi_done = done;\n\tfor (; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\n\t\tstruct fib * fib = &dev->fibs[count];\n\t\tstruct scsi_cmnd * command;\n\t\tif (fib->hw_fib_va->header.XferState &&\n\t\t    ((command = fib->callback_data)) &&\n\t\t    (command == cmd) &&\n\t\t    (cmd->SCp.phase == AAC_OWNER_FIRMWARE))\n\t\t\treturn 0; /* Already owned by Adapter */\n\t}\n\tcmd->SCp.phase = AAC_OWNER_LOWLEVEL;\n\treturn (aac_scsi_cmd(cmd) ? FAILED : 0);\n}\n\nstatic DEF_SCSI_QCMD(aac_queuecommand)\n\n/**\n *\taac_info\t\t-\tReturns the host adapter name\n *\t@shost:\t\tScsi host to report on\n *\n *\tReturns a static string describing the device in question\n */\n\nstatic const char *aac_info(struct Scsi_Host *shost)\n{\n\tstruct aac_dev *dev = (struct aac_dev *)shost->hostdata;\n\treturn aac_drivers[dev->cardtype].name;\n}\n\n/**\n *\taac_get_driver_ident\n *\t@devtype: index into lookup table\n *\n *\tReturns a pointer to the entry in the driver lookup table.\n */\n\nstruct aac_driver_ident* aac_get_driver_ident(int devtype)\n{\n\treturn &aac_drivers[devtype];\n}\n\n/**\n *\taac_biosparm\t-\treturn BIOS parameters for disk\n *\t@sdev: The scsi device corresponding to the disk\n *\t@bdev: the block device corresponding to the disk\n *\t@capacity: the sector capacity of the disk\n *\t@geom: geometry block to fill in\n *\n *\tReturn the Heads/Sectors/Cylinders BIOS Disk Parameters for Disk.\n *\tThe default disk geometry is 64 heads, 32 sectors, and the appropriate\n *\tnumber of cylinders so as not to exceed drive capacity.  In order for\n *\tdisks equal to or larger than 1 GB to be addressable by the BIOS\n *\twithout exceeding the BIOS limitation of 1024 cylinders, Extended\n *\tTranslation should be enabled.   With Extended Translation enabled,\n *\tdrives between 1 GB inclusive and 2 GB exclusive are given a disk\n *\tgeometry of 128 heads and 32 sectors, and drives above 2 GB inclusive\n *\tare given a disk geometry of 255 heads and 63 sectors.  However, if\n *\tthe BIOS detects that the Extended Translation setting does not match\n *\tthe geometry in the partition table, then the translation inferred\n *\tfrom the partition table will be used by the BIOS, and a warning may\n *\tbe displayed.\n */\n\nstatic int aac_biosparm(struct scsi_device *sdev, struct block_device *bdev,\n\t\t\tsector_t capacity, int *geom)\n{\n\tstruct diskparm *param = (struct diskparm *)geom;\n\tunsigned char *buf;\n\n\tdprintk((KERN_DEBUG \"aac_biosparm.\\n\"));\n\n\t/*\n\t *\tAssuming extended translation is enabled - #REVISIT#\n\t */\n\tif (capacity >= 2 * 1024 * 1024) { /* 1 GB in 512 byte sectors */\n\t\tif(capacity >= 4 * 1024 * 1024) { /* 2 GB in 512 byte sectors */\n\t\t\tparam->heads = 255;\n\t\t\tparam->sectors = 63;\n\t\t} else {\n\t\t\tparam->heads = 128;\n\t\t\tparam->sectors = 32;\n\t\t}\n\t} else {\n\t\tparam->heads = 64;\n\t\tparam->sectors = 32;\n\t}\n\n\tparam->cylinders = cap_to_cyls(capacity, param->heads * param->sectors);\n\n\t/*\n\t *\tRead the first 1024 bytes from the disk device, if the boot\n\t *\tsector partition table is valid, search for a partition table\n\t *\tentry whose end_head matches one of the standard geometry\n\t *\ttranslations ( 64/32, 128/32, 255/63 ).\n\t */\n\tbuf = scsi_bios_ptable(bdev);\n\tif (!buf)\n\t\treturn 0;\n\tif(*(__le16 *)(buf + 0x40) == cpu_to_le16(0xaa55)) {\n\t\tstruct partition *first = (struct partition * )buf;\n\t\tstruct partition *entry = first;\n\t\tint saved_cylinders = param->cylinders;\n\t\tint num;\n\t\tunsigned char end_head, end_sec;\n\n\t\tfor(num = 0; num < 4; num++) {\n\t\t\tend_head = entry->end_head;\n\t\t\tend_sec = entry->end_sector & 0x3f;\n\n\t\t\tif(end_head == 63) {\n\t\t\t\tparam->heads = 64;\n\t\t\t\tparam->sectors = 32;\n\t\t\t\tbreak;\n\t\t\t} else if(end_head == 127) {\n\t\t\t\tparam->heads = 128;\n\t\t\t\tparam->sectors = 32;\n\t\t\t\tbreak;\n\t\t\t} else if(end_head == 254) {\n\t\t\t\tparam->heads = 255;\n\t\t\t\tparam->sectors = 63;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry++;\n\t\t}\n\n\t\tif (num == 4) {\n\t\t\tend_head = first->end_head;\n\t\t\tend_sec = first->end_sector & 0x3f;\n\t\t}\n\n\t\tparam->cylinders = cap_to_cyls(capacity, param->heads * param->sectors);\n\t\tif (num < 4 && end_sec == param->sectors) {\n\t\t\tif (param->cylinders != saved_cylinders)\n\t\t\t\tdprintk((KERN_DEBUG \"Adopting geometry: heads=%d, sectors=%d from partition table %d.\\n\",\n\t\t\t\t\tparam->heads, param->sectors, num));\n\t\t} else if (end_head > 0 || end_sec > 0) {\n\t\t\tdprintk((KERN_DEBUG \"Strange geometry: heads=%d, sectors=%d in partition table %d.\\n\",\n\t\t\t\tend_head + 1, end_sec, num));\n\t\t\tdprintk((KERN_DEBUG \"Using geometry: heads=%d, sectors=%d.\\n\",\n\t\t\t\t\tparam->heads, param->sectors));\n\t\t}\n\t}\n\tkfree(buf);\n\treturn 0;\n}\n\n/**\n *\taac_slave_configure\t\t-\tcompute queue depths\n *\t@sdev:\tSCSI device we are considering\n *\n *\tSelects queue depths for each target device based on the host adapter's\n *\ttotal capacity and the queue depth supported by the target device.\n *\tA queue depth of one automatically disables tagged queueing.\n */\n\nstatic int aac_slave_configure(struct scsi_device *sdev)\n{\n\tstruct aac_dev *aac = (struct aac_dev *)sdev->host->hostdata;\n\tif (aac->jbod && (sdev->type == TYPE_DISK))\n\t\tsdev->removable = 1;\n\tif ((sdev->type == TYPE_DISK) &&\n\t\t\t(sdev_channel(sdev) != CONTAINER_CHANNEL) &&\n\t\t\t(!aac->jbod || sdev->inq_periph_qual) &&\n\t\t\t(!aac->raid_scsi_mode || (sdev_channel(sdev) != 2))) {\n\t\tif (expose_physicals == 0)\n\t\t\treturn -ENXIO;\n\t\tif (expose_physicals < 0)\n\t\t\tsdev->no_uld_attach = 1;\n\t}\n\tif (sdev->tagged_supported && (sdev->type == TYPE_DISK) &&\n\t\t\t(!aac->raid_scsi_mode || (sdev_channel(sdev) != 2)) &&\n\t\t\t!sdev->no_uld_attach) {\n\t\tstruct scsi_device * dev;\n\t\tstruct Scsi_Host *host = sdev->host;\n\t\tunsigned num_lsu = 0;\n\t\tunsigned num_one = 0;\n\t\tunsigned depth;\n\t\tunsigned cid;\n\n\t\t/*\n\t\t * Firmware has an individual device recovery time typically\n\t\t * of 35 seconds, give us a margin.\n\t\t */\n\t\tif (sdev->request_queue->rq_timeout < (45 * HZ))\n\t\t\tblk_queue_rq_timeout(sdev->request_queue, 45*HZ);\n\t\tfor (cid = 0; cid < aac->maximum_num_containers; ++cid)\n\t\t\tif (aac->fsa_dev[cid].valid)\n\t\t\t\t++num_lsu;\n\t\t__shost_for_each_device(dev, host) {\n\t\t\tif (dev->tagged_supported && (dev->type == TYPE_DISK) &&\n\t\t\t\t\t(!aac->raid_scsi_mode ||\n\t\t\t\t\t\t(sdev_channel(sdev) != 2)) &&\n\t\t\t\t\t!dev->no_uld_attach) {\n\t\t\t\tif ((sdev_channel(dev) != CONTAINER_CHANNEL)\n\t\t\t\t || !aac->fsa_dev[sdev_id(dev)].valid)\n\t\t\t\t\t++num_lsu;\n\t\t\t} else\n\t\t\t\t++num_one;\n\t\t}\n\t\tif (num_lsu == 0)\n\t\t\t++num_lsu;\n\t\tdepth = (host->can_queue - num_one) / num_lsu;\n\t\tif (depth > 256)\n\t\t\tdepth = 256;\n\t\telse if (depth < 2)\n\t\t\tdepth = 2;\n\t\tscsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG, depth);\n\t} else\n\t\tscsi_adjust_queue_depth(sdev, 0, 1);\n\n\treturn 0;\n}\n\n/**\n *\taac_change_queue_depth\t\t-\talter queue depths\n *\t@sdev:\tSCSI device we are considering\n *\t@depth:\tdesired queue depth\n *\n *\tAlters queue depths for target device based on the host adapter's\n *\ttotal capacity and the queue depth supported by the target device.\n */\n\nstatic int aac_change_queue_depth(struct scsi_device *sdev, int depth,\n\t\t\t\t  int reason)\n{\n\tif (reason != SCSI_QDEPTH_DEFAULT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sdev->tagged_supported && (sdev->type == TYPE_DISK) &&\n\t    (sdev_channel(sdev) == CONTAINER_CHANNEL)) {\n\t\tstruct scsi_device * dev;\n\t\tstruct Scsi_Host *host = sdev->host;\n\t\tunsigned num = 0;\n\n\t\t__shost_for_each_device(dev, host) {\n\t\t\tif (dev->tagged_supported && (dev->type == TYPE_DISK) &&\n\t\t\t    (sdev_channel(dev) == CONTAINER_CHANNEL))\n\t\t\t\t++num;\n\t\t\t++num;\n\t\t}\n\t\tif (num >= host->can_queue)\n\t\t\tnum = host->can_queue - 1;\n\t\tif (depth > (host->can_queue - num))\n\t\t\tdepth = host->can_queue - num;\n\t\tif (depth > 256)\n\t\t\tdepth = 256;\n\t\telse if (depth < 2)\n\t\t\tdepth = 2;\n\t\tscsi_adjust_queue_depth(sdev, MSG_ORDERED_TAG, depth);\n\t} else\n\t\tscsi_adjust_queue_depth(sdev, 0, 1);\n\treturn sdev->queue_depth;\n}\n\nstatic ssize_t aac_show_raid_level(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tstruct aac_dev *aac = (struct aac_dev *)(sdev->host->hostdata);\n\tif (sdev_channel(sdev) != CONTAINER_CHANNEL)\n\t\treturn snprintf(buf, PAGE_SIZE, sdev->no_uld_attach\n\t\t  ? \"Hidden\\n\" :\n\t\t  ((aac->jbod && (sdev->type == TYPE_DISK)) ? \"JBOD\\n\" : \"\"));\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t  get_container_type(aac->fsa_dev[sdev_id(sdev)].type));\n}\n\nstatic struct device_attribute aac_raid_level_attr = {\n\t.attr = {\n\t\t.name = \"level\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_raid_level\n};\n\nstatic struct device_attribute *aac_dev_attrs[] = {\n\t&aac_raid_level_attr,\n\tNULL,\n};\n\nstatic int aac_ioctl(struct scsi_device *sdev, int cmd, void __user * arg)\n{\n\tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\treturn aac_do_ioctl(dev, cmd, arg);\n}\n\nstatic int aac_eh_abort(struct scsi_cmnd* cmd)\n{\n\tstruct scsi_device * dev = cmd->device;\n\tstruct Scsi_Host * host = dev->host;\n\tstruct aac_dev * aac = (struct aac_dev *)host->hostdata;\n\tint count;\n\tint ret = FAILED;\n\n\tprintk(KERN_ERR \"%s: Host adapter abort request (%d,%d,%d,%d)\\n\",\n\t\tAAC_DRIVERNAME,\n\t\thost->host_no, sdev_channel(dev), sdev_id(dev), dev->lun);\n\tswitch (cmd->cmnd[0]) {\n\tcase SERVICE_ACTION_IN:\n\t\tif (!(aac->raw_io_interface) ||\n\t\t    !(aac->raw_io_64) ||\n\t\t    ((cmd->cmnd[1] & 0x1f) != SAI_READ_CAPACITY_16))\n\t\t\tbreak;\n\tcase INQUIRY:\n\tcase READ_CAPACITY:\n\t\t/* Mark associated FIB to not complete, eh handler does this */\n\t\tfor (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\n\t\t\tstruct fib * fib = &aac->fibs[count];\n\t\t\tif (fib->hw_fib_va->header.XferState &&\n\t\t\t  (fib->flags & FIB_CONTEXT_FLAG) &&\n\t\t\t  (fib->callback_data == cmd)) {\n\t\t\t\tfib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;\n\t\t\t\tcmd->SCp.phase = AAC_OWNER_ERROR_HANDLER;\n\t\t\t\tret = SUCCESS;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase TEST_UNIT_READY:\n\t\t/* Mark associated FIB to not complete, eh handler does this */\n\t\tfor (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\n\t\t\tstruct scsi_cmnd * command;\n\t\t\tstruct fib * fib = &aac->fibs[count];\n\t\t\tif ((fib->hw_fib_va->header.XferState & cpu_to_le32(Async | NoResponseExpected)) &&\n\t\t\t  (fib->flags & FIB_CONTEXT_FLAG) &&\n\t\t\t  ((command = fib->callback_data)) &&\n\t\t\t  (command->device == cmd->device)) {\n\t\t\t\tfib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;\n\t\t\t\tcommand->SCp.phase = AAC_OWNER_ERROR_HANDLER;\n\t\t\t\tif (command == cmd)\n\t\t\t\t\tret = SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n/*\n *\taac_eh_reset\t- Reset command handling\n *\t@scsi_cmd:\tSCSI command block causing the reset\n *\n */\nstatic int aac_eh_reset(struct scsi_cmnd* cmd)\n{\n\tstruct scsi_device * dev = cmd->device;\n\tstruct Scsi_Host * host = dev->host;\n\tstruct scsi_cmnd * command;\n\tint count;\n\tstruct aac_dev * aac = (struct aac_dev *)host->hostdata;\n\tunsigned long flags;\n\n\t/* Mark the associated FIB to not complete, eh handler does this */\n\tfor (count = 0; count < (host->can_queue + AAC_NUM_MGT_FIB); ++count) {\n\t\tstruct fib * fib = &aac->fibs[count];\n\t\tif (fib->hw_fib_va->header.XferState &&\n\t\t  (fib->flags & FIB_CONTEXT_FLAG) &&\n\t\t  (fib->callback_data == cmd)) {\n\t\t\tfib->flags |= FIB_CONTEXT_FLAG_TIMED_OUT;\n\t\t\tcmd->SCp.phase = AAC_OWNER_ERROR_HANDLER;\n\t\t}\n\t}\n\tprintk(KERN_ERR \"%s: Host adapter reset request. SCSI hang ?\\n\",\n\t\t\t\t\tAAC_DRIVERNAME);\n\n\tif ((count = aac_check_health(aac)))\n\t\treturn count;\n\t/*\n\t * Wait for all commands to complete to this specific\n\t * target (block maximum 60 seconds).\n\t */\n\tfor (count = 60; count; --count) {\n\t\tint active = aac->in_reset;\n\n\t\tif (active == 0)\n\t\t__shost_for_each_device(dev, host) {\n\t\t\tspin_lock_irqsave(&dev->list_lock, flags);\n\t\t\tlist_for_each_entry(command, &dev->cmd_list, list) {\n\t\t\t\tif ((command != cmd) &&\n\t\t\t\t    (command->SCp.phase == AAC_OWNER_FIRMWARE)) {\n\t\t\t\t\tactive++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&dev->list_lock, flags);\n\t\t\tif (active)\n\t\t\t\tbreak;\n\n\t\t}\n\t\t/*\n\t\t * We can exit If all the commands are complete\n\t\t */\n\t\tif (active == 0)\n\t\t\treturn SUCCESS;\n\t\tssleep(1);\n\t}\n\tprintk(KERN_ERR \"%s: SCSI bus appears hung\\n\", AAC_DRIVERNAME);\n\t/*\n\t * This adapter needs a blind reset, only do so for Adapters that\n\t * support a register, instead of a commanded, reset.\n\t */\n\tif (((aac->supplement_adapter_info.SupportedOptions2 &\n\t  AAC_OPTION_MU_RESET) ||\n\t  (aac->supplement_adapter_info.SupportedOptions2 &\n\t  AAC_OPTION_DOORBELL_RESET)) &&\n\t  aac_check_reset &&\n\t  ((aac_check_reset != 1) ||\n\t   !(aac->supplement_adapter_info.SupportedOptions2 &\n\t    AAC_OPTION_IGNORE_RESET)))\n\t\taac_reset_adapter(aac, 2); /* Bypass wait for command quiesce */\n\treturn SUCCESS; /* Cause an immediate retry of the command with a ten second delay after successful tur */\n}\n\n/**\n *\taac_cfg_open\t\t-\topen a configuration file\n *\t@inode: inode being opened\n *\t@file: file handle attached\n *\n *\tCalled when the configuration device is opened. Does the needed\n *\tset up on the handle and then returns\n *\n *\tBugs: This needs extending to check a given adapter is present\n *\tso we can support hot plugging, and to ref count adapters.\n */\n\nstatic int aac_cfg_open(struct inode *inode, struct file *file)\n{\n\tstruct aac_dev *aac;\n\tunsigned minor_number = iminor(inode);\n\tint err = -ENODEV;\n\n\tmutex_lock(&aac_mutex);  /* BKL pushdown: nothing else protects this list */\n\tlist_for_each_entry(aac, &aac_devices, entry) {\n\t\tif (aac->id == minor_number) {\n\t\t\tfile->private_data = aac;\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&aac_mutex);\n\n\treturn err;\n}\n\n/**\n *\taac_cfg_ioctl\t\t-\tAAC configuration request\n *\t@inode: inode of device\n *\t@file: file handle\n *\t@cmd: ioctl command code\n *\t@arg: argument\n *\n *\tHandles a configuration ioctl. Currently this involves wrapping it\n *\tup and feeding it into the nasty windowsalike glue layer.\n *\n *\tBugs: Needs locking against parallel ioctls lower down\n *\tBugs: Needs to handle hot plugging\n */\n\nstatic long aac_cfg_ioctl(struct file *file,\n\t\tunsigned int cmd, unsigned long arg)\n{\n\tint ret;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tmutex_lock(&aac_mutex);\n\tret = aac_do_ioctl(file->private_data, cmd, (void __user *)arg);\n\tmutex_unlock(&aac_mutex);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long aac_compat_do_ioctl(struct aac_dev *dev, unsigned cmd, unsigned long arg)\n{\n\tlong ret;\n\tmutex_lock(&aac_mutex);\n\tswitch (cmd) {\n\tcase FSACTL_MINIPORT_REV_CHECK:\n\tcase FSACTL_SENDFIB:\n\tcase FSACTL_OPEN_GET_ADAPTER_FIB:\n\tcase FSACTL_CLOSE_GET_ADAPTER_FIB:\n\tcase FSACTL_SEND_RAW_SRB:\n\tcase FSACTL_GET_PCI_INFO:\n\tcase FSACTL_QUERY_DISK:\n\tcase FSACTL_DELETE_DISK:\n\tcase FSACTL_FORCE_DELETE_DISK:\n\tcase FSACTL_GET_CONTAINERS:\n\tcase FSACTL_SEND_LARGE_FIB:\n\t\tret = aac_do_ioctl(dev, cmd, (void __user *)arg);\n\t\tbreak;\n\n\tcase FSACTL_GET_NEXT_ADAPTER_FIB: {\n\t\tstruct fib_ioctl __user *f;\n\n\t\tf = compat_alloc_user_space(sizeof(*f));\n\t\tret = 0;\n\t\tif (clear_user(f, sizeof(*f)))\n\t\t\tret = -EFAULT;\n\t\tif (copy_in_user(f, (void __user *)arg, sizeof(struct fib_ioctl) - sizeof(u32)))\n\t\t\tret = -EFAULT;\n\t\tif (!ret)\n\t\t\tret = aac_do_ioctl(dev, cmd, f);\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t\tbreak;\n\t}\n\tmutex_unlock(&aac_mutex);\n\treturn ret;\n}\n\nstatic int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n{\n\tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n}\n\nstatic long aac_compat_cfg_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\treturn aac_compat_do_ioctl(file->private_data, cmd, arg);\n}\n#endif\n\nstatic ssize_t aac_show_model(struct device *device,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len;\n\n\tif (dev->supplement_adapter_info.AdapterTypeText[0]) {\n\t\tchar * cp = dev->supplement_adapter_info.AdapterTypeText;\n\t\twhile (*cp && *cp != ' ')\n\t\t\t++cp;\n\t\twhile (*cp == ' ')\n\t\t\t++cp;\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%s\\n\", cp);\n\t} else\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t  aac_drivers[dev->cardtype].model);\n\treturn len;\n}\n\nstatic ssize_t aac_show_vendor(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len;\n\n\tif (dev->supplement_adapter_info.AdapterTypeText[0]) {\n\t\tchar * cp = dev->supplement_adapter_info.AdapterTypeText;\n\t\twhile (*cp && *cp != ' ')\n\t\t\t++cp;\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%.*s\\n\",\n\t\t  (int)(cp - (char *)dev->supplement_adapter_info.AdapterTypeText),\n\t\t  dev->supplement_adapter_info.AdapterTypeText);\n\t} else\n\t\tlen = snprintf(buf, PAGE_SIZE, \"%s\\n\",\n\t\t  aac_drivers[dev->cardtype].vname);\n\treturn len;\n}\n\nstatic ssize_t aac_show_flags(struct device *cdev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tint len = 0;\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(cdev)->hostdata;\n\n\tif (nblank(dprintk(x)))\n\t\tlen = snprintf(buf, PAGE_SIZE, \"dprintk\\n\");\n#ifdef AAC_DETAILED_STATUS_INFO\n\tlen += snprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"AAC_DETAILED_STATUS_INFO\\n\");\n#endif\n\tif (dev->raw_io_interface && dev->raw_io_64)\n\t\tlen += snprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"SAI_READ_CAPACITY_16\\n\");\n\tif (dev->jbod)\n\t\tlen += snprintf(buf + len, PAGE_SIZE - len, \"SUPPORTED_JBOD\\n\");\n\tif (dev->supplement_adapter_info.SupportedOptions2 &\n\t\tAAC_OPTION_POWER_MANAGEMENT)\n\t\tlen += snprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"SUPPORTED_POWER_MANAGEMENT\\n\");\n\tif (dev->msi)\n\t\tlen += snprintf(buf + len, PAGE_SIZE - len, \"PCI_HAS_MSI\\n\");\n\treturn len;\n}\n\nstatic ssize_t aac_show_kernel_version(struct device *device,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len, tmp;\n\n\ttmp = le32_to_cpu(dev->adapter_info.kernelrev);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d.%d-%d[%d]\\n\",\n\t  tmp >> 24, (tmp >> 16) & 0xff, tmp & 0xff,\n\t  le32_to_cpu(dev->adapter_info.kernelbuild));\n\treturn len;\n}\n\nstatic ssize_t aac_show_monitor_version(struct device *device,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len, tmp;\n\n\ttmp = le32_to_cpu(dev->adapter_info.monitorrev);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d.%d-%d[%d]\\n\",\n\t  tmp >> 24, (tmp >> 16) & 0xff, tmp & 0xff,\n\t  le32_to_cpu(dev->adapter_info.monitorbuild));\n\treturn len;\n}\n\nstatic ssize_t aac_show_bios_version(struct device *device,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len, tmp;\n\n\ttmp = le32_to_cpu(dev->adapter_info.biosrev);\n\tlen = snprintf(buf, PAGE_SIZE, \"%d.%d-%d[%d]\\n\",\n\t  tmp >> 24, (tmp >> 16) & 0xff, tmp & 0xff,\n\t  le32_to_cpu(dev->adapter_info.biosbuild));\n\treturn len;\n}\n\nstatic ssize_t aac_show_serial_number(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len = 0;\n\n\tif (le32_to_cpu(dev->adapter_info.serial[0]) != 0xBAD0)\n\t\tlen = snprintf(buf, 16, \"%06X\\n\",\n\t\t  le32_to_cpu(dev->adapter_info.serial[0]));\n\tif (len &&\n\t  !memcmp(&dev->supplement_adapter_info.MfgPcbaSerialNo[\n\t    sizeof(dev->supplement_adapter_info.MfgPcbaSerialNo)-len],\n\t  buf, len-1))\n\t\tlen = snprintf(buf, 16, \"%.*s\\n\",\n\t\t  (int)sizeof(dev->supplement_adapter_info.MfgPcbaSerialNo),\n\t\t  dev->supplement_adapter_info.MfgPcbaSerialNo);\n\n\treturn min(len, 16);\n}\n\nstatic ssize_t aac_show_max_channel(struct device *device,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t  class_to_shost(device)->max_channel);\n}\n\nstatic ssize_t aac_show_max_id(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t  class_to_shost(device)->max_id);\n}\n\nstatic ssize_t aac_store_reset_adapter(struct device *device,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tint retval = -EACCES;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn retval;\n\tretval = aac_reset_adapter((struct aac_dev*)class_to_shost(device)->hostdata, buf[0] == '!');\n\tif (retval >= 0)\n\t\tretval = count;\n\treturn retval;\n}\n\nstatic ssize_t aac_show_reset_adapter(struct device *device,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct aac_dev *dev = (struct aac_dev*)class_to_shost(device)->hostdata;\n\tint len, tmp;\n\n\ttmp = aac_adapter_check_health(dev);\n\tif ((tmp == 0) && dev->in_reset)\n\t\ttmp = -EBUSY;\n\tlen = snprintf(buf, PAGE_SIZE, \"0x%x\\n\", tmp);\n\treturn len;\n}\n\nstatic struct device_attribute aac_model = {\n\t.attr = {\n\t\t.name = \"model\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_model,\n};\nstatic struct device_attribute aac_vendor = {\n\t.attr = {\n\t\t.name = \"vendor\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_vendor,\n};\nstatic struct device_attribute aac_flags = {\n\t.attr = {\n\t\t.name = \"flags\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_flags,\n};\nstatic struct device_attribute aac_kernel_version = {\n\t.attr = {\n\t\t.name = \"hba_kernel_version\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_kernel_version,\n};\nstatic struct device_attribute aac_monitor_version = {\n\t.attr = {\n\t\t.name = \"hba_monitor_version\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_monitor_version,\n};\nstatic struct device_attribute aac_bios_version = {\n\t.attr = {\n\t\t.name = \"hba_bios_version\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_bios_version,\n};\nstatic struct device_attribute aac_serial_number = {\n\t.attr = {\n\t\t.name = \"serial_number\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_serial_number,\n};\nstatic struct device_attribute aac_max_channel = {\n\t.attr = {\n\t\t.name = \"max_channel\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_max_channel,\n};\nstatic struct device_attribute aac_max_id = {\n\t.attr = {\n\t\t.name = \"max_id\",\n\t\t.mode = S_IRUGO,\n\t},\n\t.show = aac_show_max_id,\n};\nstatic struct device_attribute aac_reset = {\n\t.attr = {\n\t\t.name = \"reset_host\",\n\t\t.mode = S_IWUSR|S_IRUGO,\n\t},\n\t.store = aac_store_reset_adapter,\n\t.show = aac_show_reset_adapter,\n};\n\nstatic struct device_attribute *aac_attrs[] = {\n\t&aac_model,\n\t&aac_vendor,\n\t&aac_flags,\n\t&aac_kernel_version,\n\t&aac_monitor_version,\n\t&aac_bios_version,\n\t&aac_serial_number,\n\t&aac_max_channel,\n\t&aac_max_id,\n\t&aac_reset,\n\tNULL\n};\n\nssize_t aac_get_serial_number(struct device *device, char *buf)\n{\n\treturn aac_show_serial_number(device, &aac_serial_number, buf);\n}\n\nstatic const struct file_operations aac_cfg_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.unlocked_ioctl\t= aac_cfg_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl   = aac_compat_cfg_ioctl,\n#endif\n\t.open\t\t= aac_cfg_open,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct scsi_host_template aac_driver_template = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.name\t\t\t\t= \"AAC\",\n\t.proc_name\t\t\t= AAC_DRIVERNAME,\n\t.info\t\t\t\t= aac_info,\n\t.ioctl\t\t\t\t= aac_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl\t\t\t= aac_compat_ioctl,\n#endif\n\t.queuecommand\t\t\t= aac_queuecommand,\n\t.bios_param\t\t\t= aac_biosparm,\n\t.shost_attrs\t\t\t= aac_attrs,\n\t.slave_configure\t\t= aac_slave_configure,\n\t.change_queue_depth\t\t= aac_change_queue_depth,\n\t.sdev_attrs\t\t\t= aac_dev_attrs,\n\t.eh_abort_handler\t\t= aac_eh_abort,\n\t.eh_host_reset_handler\t\t= aac_eh_reset,\n\t.can_queue\t\t\t= AAC_NUM_IO_FIB,\n\t.this_id\t\t\t= MAXIMUM_NUM_CONTAINERS,\n\t.sg_tablesize\t\t\t= 16,\n\t.max_sectors\t\t\t= 128,\n#if (AAC_NUM_IO_FIB > 256)\n\t.cmd_per_lun\t\t\t= 256,\n#else\n\t.cmd_per_lun\t\t\t= AAC_NUM_IO_FIB,\n#endif\n\t.use_clustering\t\t\t= ENABLE_CLUSTERING,\n\t.emulated\t\t\t= 1,\n};\n\nstatic void __aac_shutdown(struct aac_dev * aac)\n{\n\tif (aac->aif_thread) {\n\t\tint i;\n\t\t/* Clear out events first */\n\t\tfor (i = 0; i < (aac->scsi_host_ptr->can_queue + AAC_NUM_MGT_FIB); i++) {\n\t\t\tstruct fib *fib = &aac->fibs[i];\n\t\t\tif (!(fib->hw_fib_va->header.XferState & cpu_to_le32(NoResponseExpected | Async)) &&\n\t\t\t    (fib->hw_fib_va->header.XferState & cpu_to_le32(ResponseExpected)))\n\t\t\t\tup(&fib->event_wait);\n\t\t}\n\t\tkthread_stop(aac->thread);\n\t}\n\taac_send_shutdown(aac);\n\taac_adapter_disable_int(aac);\n\tfree_irq(aac->pdev->irq, aac);\n\tif (aac->msi)\n\t\tpci_disable_msi(aac->pdev);\n}\n\nstatic int aac_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tunsigned index = id->driver_data;\n\tstruct Scsi_Host *shost;\n\tstruct aac_dev *aac;\n\tstruct list_head *insert = &aac_devices;\n\tint error = -ENODEV;\n\tint unique_id = 0;\n\tu64 dmamask;\n\textern int aac_sync_mode;\n\n\tlist_for_each_entry(aac, &aac_devices, entry) {\n\t\tif (aac->id > unique_id)\n\t\t\tbreak;\n\t\tinsert = &aac->entry;\n\t\tunique_id++;\n\t}\n\n\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |\n\t\t\t       PCIE_LINK_STATE_CLKPM);\n\n\terror = pci_enable_device(pdev);\n\tif (error)\n\t\tgoto out;\n\terror = -ENODEV;\n\n\t/*\n\t * If the quirk31 bit is set, the adapter needs adapter\n\t * to driver communication memory to be allocated below 2gig\n\t */\n\tif (aac_drivers[index].quirks & AAC_QUIRK_31BIT)\n\t\tdmamask = DMA_BIT_MASK(31);\n\telse\n\t\tdmamask = DMA_BIT_MASK(32);\n\n\tif (pci_set_dma_mask(pdev, dmamask) ||\n\t\t\tpci_set_consistent_dma_mask(pdev, dmamask))\n\t\tgoto out_disable_pdev;\n\n\tpci_set_master(pdev);\n\n\tshost = scsi_host_alloc(&aac_driver_template, sizeof(struct aac_dev));\n\tif (!shost)\n\t\tgoto out_disable_pdev;\n\n\tshost->irq = pdev->irq;\n\tshost->unique_id = unique_id;\n\tshost->max_cmd_len = 16;\n\n\taac = (struct aac_dev *)shost->hostdata;\n\taac->base_start = pci_resource_start(pdev, 0);\n\taac->scsi_host_ptr = shost;\n\taac->pdev = pdev;\n\taac->name = aac_driver_template.name;\n\taac->id = shost->unique_id;\n\taac->cardtype = index;\n\tINIT_LIST_HEAD(&aac->entry);\n\n\taac->fibs = kzalloc(sizeof(struct fib) * (shost->can_queue + AAC_NUM_MGT_FIB), GFP_KERNEL);\n\tif (!aac->fibs)\n\t\tgoto out_free_host;\n\tspin_lock_init(&aac->fib_lock);\n\n\t/*\n\t *\tMap in the registers from the adapter.\n\t */\n\taac->base_size = AAC_MIN_FOOTPRINT_SIZE;\n\tif ((*aac_drivers[index].init)(aac))\n\t\tgoto out_unmap;\n\n\tif (aac->sync_mode) {\n\t\tif (aac_sync_mode)\n\t\t\tprintk(KERN_INFO \"%s%d: Sync. mode enforced \"\n\t\t\t\t\"by driver parameter. This will cause \"\n\t\t\t\t\"a significant performance decrease!\\n\",\n\t\t\t\taac->name,\n\t\t\t\taac->id);\n\t\telse\n\t\t\tprintk(KERN_INFO \"%s%d: Async. mode not supported \"\n\t\t\t\t\"by current driver, sync. mode enforced.\"\n\t\t\t\t\"\\nPlease update driver to get full performance.\\n\",\n\t\t\t\taac->name,\n\t\t\t\taac->id);\n\t}\n\n\t/*\n\t *\tStart any kernel threads needed\n\t */\n\taac->thread = kthread_run(aac_command_thread, aac, AAC_DRIVERNAME);\n\tif (IS_ERR(aac->thread)) {\n\t\tprintk(KERN_ERR \"aacraid: Unable to create command thread.\\n\");\n\t\terror = PTR_ERR(aac->thread);\n\t\taac->thread = NULL;\n\t\tgoto out_deinit;\n\t}\n\n\t/*\n\t * If we had set a smaller DMA mask earlier, set it to 4gig\n\t * now since the adapter can dma data to at least a 4gig\n\t * address space.\n\t */\n\tif (aac_drivers[index].quirks & AAC_QUIRK_31BIT)\n\t\tif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)))\n\t\t\tgoto out_deinit;\n\n\taac->maximum_num_channels = aac_drivers[index].channels;\n\terror = aac_get_adapter_info(aac);\n\tif (error < 0)\n\t\tgoto out_deinit;\n\n\t/*\n\t * Lets override negotiations and drop the maximum SG limit to 34\n\t */\n\tif ((aac_drivers[index].quirks & AAC_QUIRK_34SG) &&\n\t\t\t(shost->sg_tablesize > 34)) {\n\t\tshost->sg_tablesize = 34;\n\t\tshost->max_sectors = (shost->sg_tablesize * 8) + 112;\n\t}\n\n\tif ((aac_drivers[index].quirks & AAC_QUIRK_17SG) &&\n\t\t\t(shost->sg_tablesize > 17)) {\n\t\tshost->sg_tablesize = 17;\n\t\tshost->max_sectors = (shost->sg_tablesize * 8) + 112;\n\t}\n\n\terror = pci_set_dma_max_seg_size(pdev,\n\t\t(aac->adapter_info.options & AAC_OPT_NEW_COMM) ?\n\t\t\t(shost->max_sectors << 9) : 65536);\n\tif (error)\n\t\tgoto out_deinit;\n\n\t/*\n\t * Firmware printf works only with older firmware.\n\t */\n\tif (aac_drivers[index].quirks & AAC_QUIRK_34SG)\n\t\taac->printf_enabled = 1;\n\telse\n\t\taac->printf_enabled = 0;\n\n\t/*\n\t * max channel will be the physical channels plus 1 virtual channel\n\t * all containers are on the virtual channel 0 (CONTAINER_CHANNEL)\n\t * physical channels are address by their actual physical number+1\n\t */\n\tif (aac->nondasd_support || expose_physicals || aac->jbod)\n\t\tshost->max_channel = aac->maximum_num_channels;\n\telse\n\t\tshost->max_channel = 0;\n\n\taac_get_config_status(aac, 0);\n\taac_get_containers(aac);\n\tlist_add(&aac->entry, insert);\n\n\tshost->max_id = aac->maximum_num_containers;\n\tif (shost->max_id < aac->maximum_num_physicals)\n\t\tshost->max_id = aac->maximum_num_physicals;\n\tif (shost->max_id < MAXIMUM_NUM_CONTAINERS)\n\t\tshost->max_id = MAXIMUM_NUM_CONTAINERS;\n\telse\n\t\tshost->this_id = shost->max_id;\n\n\t/*\n\t * dmb - we may need to move the setting of these parms somewhere else once\n\t * we get a fib that can report the actual numbers\n\t */\n\tshost->max_lun = AAC_MAX_LUN;\n\n\tpci_set_drvdata(pdev, shost);\n\n\terror = scsi_add_host(shost, &pdev->dev);\n\tif (error)\n\t\tgoto out_deinit;\n\tscsi_scan_host(shost);\n\n\treturn 0;\n\n out_deinit:\n\t__aac_shutdown(aac);\n out_unmap:\n\taac_fib_map_free(aac);\n\tif (aac->comm_addr)\n\t\tpci_free_consistent(aac->pdev, aac->comm_size, aac->comm_addr,\n\t\t  aac->comm_phys);\n\tkfree(aac->queues);\n\taac_adapter_ioremap(aac, 0);\n\tkfree(aac->fibs);\n\tkfree(aac->fsa_dev);\n out_free_host:\n\tscsi_host_put(shost);\n out_disable_pdev:\n\tpci_disable_device(pdev);\n out:\n\treturn error;\n}\n\nstatic void aac_shutdown(struct pci_dev *dev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(dev);\n\tscsi_block_requests(shost);\n\t__aac_shutdown((struct aac_dev *)shost->hostdata);\n}\n\nstatic void aac_remove_one(struct pci_dev *pdev)\n{\n\tstruct Scsi_Host *shost = pci_get_drvdata(pdev);\n\tstruct aac_dev *aac = (struct aac_dev *)shost->hostdata;\n\n\tscsi_remove_host(shost);\n\n\t__aac_shutdown(aac);\n\taac_fib_map_free(aac);\n\tpci_free_consistent(aac->pdev, aac->comm_size, aac->comm_addr,\n\t\t\taac->comm_phys);\n\tkfree(aac->queues);\n\n\taac_adapter_ioremap(aac, 0);\n\n\tkfree(aac->fibs);\n\tkfree(aac->fsa_dev);\n\n\tlist_del(&aac->entry);\n\tscsi_host_put(shost);\n\tpci_disable_device(pdev);\n\tif (list_empty(&aac_devices)) {\n\t\tunregister_chrdev(aac_cfg_major, \"aac\");\n\t\taac_cfg_major = -1;\n\t}\n}\n\nstatic struct pci_driver aac_pci_driver = {\n\t.name\t\t= AAC_DRIVERNAME,\n\t.id_table\t= aac_pci_tbl,\n\t.probe\t\t= aac_probe_one,\n\t.remove\t\t= aac_remove_one,\n\t.shutdown\t= aac_shutdown,\n};\n\nstatic int __init aac_init(void)\n{\n\tint error;\n\n\tprintk(KERN_INFO \"Adaptec %s driver %s\\n\",\n\t  AAC_DRIVERNAME, aac_driver_version);\n\n\terror = pci_register_driver(&aac_pci_driver);\n\tif (error < 0)\n\t\treturn error;\n\n\taac_cfg_major = register_chrdev( 0, \"aac\", &aac_cfg_fops);\n\tif (aac_cfg_major < 0) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"aacraid: unable to register \\\"aac\\\" device.\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit aac_exit(void)\n{\n\tif (aac_cfg_major > -1)\n\t\tunregister_chrdev(aac_cfg_major, \"aac\");\n\tpci_unregister_driver(&aac_pci_driver);\n}\n\nmodule_init(aac_init);\nmodule_exit(aac_exit);\n"], "filenames": ["drivers/scsi/aacraid/linit.c"], "buggy_code_start_loc": [773], "buggy_code_end_loc": [773], "fixing_code_start_loc": [774], "fixing_code_end_loc": [776], "type": "CWE-264", "message": "The aac_compat_ioctl function in drivers/scsi/aacraid/linit.c in the Linux kernel before 3.11.8 does not require the CAP_SYS_RAWIO capability, which allows local users to bypass intended access restrictions via a crafted ioctl call.", "other": {"cve": {"id": "CVE-2013-6383", "sourceIdentifier": "secalert@redhat.com", "published": "2013-11-27T04:43:33.247", "lastModified": "2023-02-13T04:49:49.903", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The aac_compat_ioctl function in drivers/scsi/aacraid/linit.c in the Linux kernel before 3.11.8 does not require the CAP_SYS_RAWIO capability, which allows local users to bypass intended access restrictions via a crafted ioctl call."}, {"lang": "es", "value": "La funci\u00f3n aac_compat_ioctl en drivers/scsi/aacraid/linit.c del kernel de Linux anterior a la versi\u00f3n 3.11.8 no requiere la capacidad CAP_SYS_RAWIO, lo que permite a usuarios locales evadir restricciones de acceso intencionadas a trav\u00e9s de una llamada ioctl manipulada."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.11.7", "matchCriteriaId": "74676759-D357-4224-9C07-7FCAB195A0CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "0A498D90-BB99-405E-9FA6-1FBFE179787E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "D0D32776-8ADB-4E79-846A-C0C99FED19E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B7D01673-D13F-487F-81B6-1279C187277E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "ADB27A3E-78E4-40F7-9716-A1099B0D85FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "16E7136A-A8A6-4BF5-AF5D-AFB5C7A10712"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "6FE127AC-E61D-427A-B998-D60DF5AABA21"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "3819FF99-AEC5-4466-8542-D395419E4308"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "E621FA1A-464B-4D2A-A0D6-EDA475A3709B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "B760B422-EA11-43AB-B6D2-CA54E7229663"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "D2CA7BBC-917C-4F31-A442-465C30444836"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "AE778000-4FD5-4032-86CE-5930EF4CB7C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "B3344EEB-F037-48FE-81DC-67F6384F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "0244B0CA-9C67-4F06-BFBA-1F257112AC08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.13:*:*:*:*:*:*:*", "matchCriteriaId": "2148C13F-4BB0-4D46-A688-F7C726D12497"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.14:*:*:*:*:*:*:*", "matchCriteriaId": "9871AF57-9158-4A41-8340-596B4463289A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.15:*:*:*:*:*:*:*", "matchCriteriaId": "2A875207-DF01-4240-8895-49B62693D27B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.16:*:*:*:*:*:*:*", "matchCriteriaId": "FE04A172-6F3B-4E3B-8D4D-564740FABAAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.17:*:*:*:*:*:*:*", "matchCriteriaId": "CFEEF8C4-7DC2-4230-B58C-337F39A4DFAF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.18:*:*:*:*:*:*:*", "matchCriteriaId": "9F74DB5C-5096-438C-8C8A-6D337A2FD06A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "639E3A57-A9E7-40E6-8929-81CCC0060EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "07012ADD-F521-40A8-B067-E87C2238A3D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3F5FF393-3F89-4274-B82B-F671358072ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "E348698F-54D1-4F5E-B701-CFAF50881E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "932205D9-3514-4289-9B55-C7A169276930"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "2ECB2D33-F517-480F-8A6F-99D9D6C49596"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.6:*:*:*:*:*:*:*", "matchCriteriaId": "D16F68DD-E2D4-4AA4-AB81-3796C2947E37"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=f856567b930dfcdbc3323261bf77240ccdde01f5", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0100.html", "source": "secalert@redhat.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2014-0285.html", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.11.8", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2013/11/22/5", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2066-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2067-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2068-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2069-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2070-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2071-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2072-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2073-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2074-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2075-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2076-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2107-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2108-1", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1033530", "source": "secalert@redhat.com"}, {"url": "https://github.com/torvalds/linux/commit/f856567b930dfcdbc3323261bf77240ccdde01f5", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/f856567b930dfcdbc3323261bf77240ccdde01f5"}}