{"buggy_code": ["Flask-Security Changelog\n========================\n\nHere you can see the full list of changes between each Flask-Security release.\n\nVersion 4.0.0\n-------------\n\nRelease Target 2020\n\n- Removal of python 2.7 and <3.6 support\n- Removal of token caching feature (a relatively new feature that has some systemic issues)\n- Other possible breaking changes tracked `here`_\n\n.. _here: https://github.com/Flask-Middleware/flask-security/issues/85\n\nVersion 3.4.4\n--------------\n\nReleased July 26, 2020\n\nBug/regression fixes.\n\nFixed\n+++++\n\n- (:issue:`359`) Basic Auth broken. When the unauthenticated handler was changed to provide a more\n  uniform/consistent response - it broke using Basic Auth from a browser, since it always redirected rather than\n  returning 401. Now, if the response headers contain  ``WWW-Authenticate``\n  (which is set if ``basic`` @auth_required method is used), a 401 is returned. See below\n  for backwards compatibility concerns.\n\n- (:pr:`362`) As part of figuring out issue 359 - a redirect loop was found. In release 3.3.0 code was put\n  in to redirect to :py:data:`SECURITY_POST_LOGIN_VIEW` when GET or POST was called and the caller was already authenticated. The\n  method used would honor the request ``next`` query parameter. This could cause redirect loops. The pre-3.3.0 behavior\n  of redirecting to :py:data:`SECURITY_POST_LOGIN_VIEW` and ignoring the ``next`` parameter has been restored.\n\n- (:issue:`347`) Fix peewee. Turns out - due to lack of unit tests - peewee hasn't worked since 'permissions' were added in 3.3.\n  Furthermore, changes in 3.4 around get_id and alternative tokens also didn't work since peewee defines its own get_id.\n\n- (:pr:`xx`) Backport the reset_access CLI command from 4.0 - this is really useful for administrators.\n\nCompatibility Concerns\n++++++++++++++++++++++\n\nIn 3.3.0, :func:`.auth_required` was changed to add a default argument if none was given. The default\ninclude all current methods - ``session``, ``token``, and ``basic``. However ``basic`` really isn't like the others\nand requires that we send back a ``WWW-Authenticate`` header if authentication fails (and return a 401 and not redirect).\n``basic`` has been removed from the default set and must once again be explicitly requested.\n\nVersion 3.4.3\n-------------\n\nReleased June 14, 2020\n\nMinor fixes for a regression and a couple other minor changes\n\nFixed\n+++++\n\n- (:issue:`340`) Fix regression where tf_phone_number was required, even if SMS wasn't configured.\n- (:pr:`342`) Pick up some small documentation fixes from 4.0.0.\n\nVersion 3.4.2\n-------------\n\nReleased May 2, 2020\n\nOnly change is to move repo to the Flask-Middleware github organization.\n\nVersion 3.4.1\n--------------\n\nReleased April 22, 2020\n\nFix a bunch of bugs in new unified sign in along with a couple other major issues.\n\nFixed\n+++++\n- (:issue:`298`) Alternative ID feature ran afoul of postgres/psycopg2 finickiness.\n- (:issue:`300`) JSON 401 responses had WWW-Authenticate Header attached - that caused\n  browsers to pop up their own login/password form. Not what applications want.\n- (:issue:`280`) Allow admin/api to setup TFA (and unified sign in) out of band.\n  Please see :meth:`.UserDatastore.tf_set`, :meth:`.UserDatastore.tf_reset`,\n  :meth:`.UserDatastore.us_set`, :meth:`.UserDatastore.us_reset` and\n  :meth:`.UserDatastore.reset_user_access`.\n- (:pr:`305`) We used form._errors which wasn't very pythonic, and it was\n  removed in WTForms 2.3.0.\n- (:pr:`310`) WTForms 2.3.0 made email_validator optional - we need it.\n\n\nVersion 3.4.0\n-------------\n\nReleased March 31, 2020\n\nFeatures\n++++++++\n- (:pr:`257`) Support a unified sign in feature. Please see :ref:`unified-sign-in`.\n- (:pr:`265`) Add phone number validation class. This is used in both unified sign in\n  as well as two-factor when using ``sms``.\n- (:pr:`274`) Add support for 'freshness' of caller's authentication. This permits endpoints\n  to be additionally protected by ensuring a recent authentication.\n- (:issue:`99`, :issue:`195`) Support pluggable password validators. Provide a default\n  validator that offers complexity and breached support.\n- (:issue:`266`) Provide interface to two-factor send_token so that applications\n  can provide error mitigation. Defaults to returning errors if can't send the verification code.\n- (:pr:`247`) Updated all-inclusive data models (fsqlaV2). Add fields necessary for the new unified sign in feature\n  and changed 'username' to be unique (but not required).\n- (:pr:`245`) Use fs_uniquifier as the default Flask-Login 'alternative token'. Basically\n  this means that changing the fs_uniquifier will cause outstanding auth tokens, session and remember me\n  cookies to be invalidated. So if an account gets compromised, an admin can easily stop access. Prior to this\n  cookies were storing the 'id' which is the user's primary key - difficult to change! (kishi85)\n\nFixed\n+++++\n- (:issue:`273`) Don't allow reset password for accounts that are disabled.\n- (:issue:`282`) Add configuration that disallows GET for logout. Allowing GET can\n  cause some denial of service issues. The default still allows GET for backwards\n  compatibility. (kantorii)\n- (:issue:`258`) Reset password wasn't integrated into the two-factor feature and therefore\n  two-factor auth could be bypassed.\n- (:issue:`254`) Allow lists and sets as underlying permissions. (pffs)\n- (:issue:`251`) Allow a registration form to have additional fields that aren't part of the user model\n  that are just passed to the user_registered.send signal, where the application can perform arbitrary\n  additional actions required during registration. (kuba-lilz)\n- (:issue:`249`) Add configuration to disable the 'role-joining' optimization for SQLAlchemy. (pffs)\n- (:issue:`238`) Fix more issues with atomically setting the new TOTP secret when setting up two-factor. (kishi85)\n- (:pr:`240`) Fix Quart Compatibility. (ristellise)\n- (:issue:`232`) CSRF Cookie not being set when using 'Remember Me' cookie to re-sign in. (kishi85)\n- (:issue:`229`) Two-factor enabled accounts didn't work with the Remember Me feature. (kishi85)\n\nAs part of adding unified sign in, there were many similarities with two-factor.\nSome refactoring was done to unify naming, configuration variables etc.\nIt should all be backwards compatible.\n\n- In TWO_FACTOR_ENABLED_METHODS \"mail\" was changed to \"email\". \"mail\" will still\n  be honored if already stored in DB. Also \"google_authenticator\" is now just \"authenticator\".\n- TWO_FACTOR_SECRET, TWO_FACTOR_URI_SERVICE_NAME, TWO_FACTOR_SMS_SERVICE, and TWO_FACTOR_SMS_SERVICE_CONFIG\n  have all been deprecated in favor of names that are the same for two-factor and unified sign in.\n\nOther changes with possible backwards compatibility issues:\n\n- ``/tf-setup`` never did any phone number validation. Now it does.\n- ``two_factor_setup.html`` template - the chosen_method check was changed to ``email``.\n  If you have your own custom template - be sure make that change.\n\nVersion 3.3.3\n-------------\n\nReleased February 11, 2020\n\nMinor changes required to work with latest released Werkzeug and Flask-Login.\n\nVersion 3.3.2\n-------------\n\nReleased December 7, 2019\n\n- (:issue:`215`) Fixed 2FA totp secret regeneration bug (kishi85)\n- (:issue:`172`) Fixed 'next' redirect error in login view\n- (:issue:`221`) Fixed regressions in login view when already authenticated user\n  again does a GET or POST.\n- (:issue:`219`) Added example code for unit testing FS protected routes.\n- (:issue:`223`) Integrated two-factor auth into registration and confirmation.\n\nThanks to kuba-lilz and kishi85 for finding and providing detailed issue reports.\n\nIn Flask-Security 3.3.0 the login view was changed to allow already authenticated\nusers to access the view. Prior to 3.3.0, the login view was protected with\n@anonymous_user_required - so any access (via GET or POST) would simply redirect\nthe user to the ``POST_LOGIN_VIEW``. With the 3.3.0 changes, both GET and POST\nbehaved oddly. GET simply returned the login template, and POST attempted to\nlog out the current user, and log in the new user. This was problematic since\nthis couldn't possibly work with CSRF.\nThe old behavior has been restored, with the subtle change that older Flask-Security\nreleases did not look at \"next\" in the form or request for the redirect,\nand now, all redirects from the login view will honor \"next\" (N.B. see 3.4.4 - the\nhandling of \"next\" has been removed due to redirect loops).\n\nVersion 3.3.1\n-------------\n\nReleased November 16, 2019\n\n- (:pr:`197`) Add `Quart <https://gitlab.com/pgjones/quart/>`_ compatibility (Ristellise)\n- (:pr:`194`) Add Python 3.8 support into CI (jdevera)\n- (:pr:`196`) Improve docs around Single Page Applications and React (acidjunk)\n- (:issue:`201`) fsqla model was added to __init__.py making Sqlalchemy a required package.\n  That is wrong and has been removed. Applications must now explicitly import from ``flask_security.models``\n- (:pr:`204`) Fix/improve examples and quickstart to show one MUST call hash_password() when\n  creating users programmatically. Also show real SECRET_KEYs and PASSWORD_SALTs and how to generate them.\n- (:pr:`209`) Add argon2 as an allowable password hash.\n- (:pr:`210`) Improve integration with Flask-Admin. Actually - this PR improves localization support\n  by adding a method ``_fsdomain`` to jinja2's global environment. Added documentation\n  around localization.\n\n\nVersion 3.3.0\n-------------\n\nReleased September 26, 2019\n\n**There are several default behavior changes that might break existing applications.\nMost have configuration variables that restore prior behavior**.\n\n**If you use Authentication Tokens (rather than session cookies) you MUST make a (small) change.\nPlease see below for details.**\n\n- (:pr:`120`) Native support for Permissions as part of Roles. Endpoints can be\n  protected via permissions that are evaluated based on role(s) that the user has.\n- (:issue:`126`, :issue:`93`, :issue:`96`) Revamp entire CSRF handling. This adds support for Single Page Applications\n  and having CSRF protection for browser(session) authentication but ignored for\n  token based authentication. Add extensive documentation about all the options.\n- (:issue:`156`) Token authentication is slow. Please see below for details on how to enable a new, fast implementation.\n- (:issue:`130`) Enable applications to provide their own :meth:`.render_json` method so that they can create\n  unified API responses.\n- (:issue:`121`) Unauthorization callback not quite right. Split into 2 different callbacks - one for\n  unauthorized and one for unauthenticated. Made default unauthenticated handler use Flask-Login's unauthenticated\n  method to make everything uniform. Extensive documentation added. `.Security.unauthorized_callback` has been deprecated.\n- (:pr:`120`) Add complete User and Role model mixins that support all features. Modify tests and Quickstart documentation\n  to show how to use these. Please see :ref:`responsetopic` for details.\n- Improve documentation for :meth:`.UserDatastore.create_user` to make clear that hashed password\n  should be passed in.\n- Improve documentation for :class:`.UserDatastore` and :func:`.verify_and_update_password`\n  to make clear that caller must commit changes to DB if using a session based datastore.\n- (:issue:`122`) Clarify when to use ``confirm_register_form`` rather than ``register_form``.\n- Fix bug in 2FA that didn't commit DB after using `verify_and_update_password`.\n- Fix bug(s) in UserDatastore where changes to user ``active`` flag weren't being added to DB.\n- (:issue:`127`) JSON response was failing due to LazyStrings in error response.\n- (:issue:`117`) Making a user inactive should stop all access immediately.\n- (:issue:`134`) Confirmation token can no longer be reused. Added\n  *SECURITY_AUTO_LOGIN_AFTER_CONFIRM* option for applications that don't want the user\n  to be automatically logged in after confirmation (defaults to True - existing behavior).\n- (:issue:`159`) The ``/register`` endpoint returned the Authentication Token even though\n  confirmation was required. This was a huge security hole - it has been fixed.\n- (:issue:`160`) The 2FA totp_secret would be regenerated upon submission, making QRCode not work. (malware-watch)\n- (:issue:`166`) `default_render_json` uses ``flask.make_response`` and forces the Content-Type to JSON for generating the response (koekie)\n- (:issue:`166`) *SECURITY_MSG_UNAUTHENTICATED* added to the configuration.\n- (:pr:`168`) When using the @auth_required or @auth_token_required decorators, the token\n  would be verified twice, and the DB would be queried twice for the user. Given how slow\n  token verification is - this was a significant issue. That has been fixed.\n- (:issue:`84`) The :func:`.anonymous_user_required` was not JSON friendly - always\n  performing a redirect. Now, if the request 'wants' a JSON response - it will receive a 400 with an error\n  message defined by *SECURITY_MSG_ANONYMOUS_USER_REQUIRED*.\n- (:pr:`145`) Improve 2FA templates to that they can be localized. (taavie)\n- (:issue:`173`) *SECURITY_UNAUTHORIZED_VIEW* didn't accept a url (just an endpoint). All other view\n  configurations did. That has been fixed.\n\nPossible compatibility issues\n+++++++++++++++++++++++++++++\n\n- (:pr:`164`) In prior releases, the Authentication Token was returned as part of the JSON response to each\n  successful call to `/login`, `/change`, or `/reset/{token}` API call. This is not a great idea since\n  for browser-based UIs that used JSON request/response, and used session based authentication - they would\n  be sent this token - even though it was likely ignored. Since these tokens by default have no expiration time\n  this exposed a needless security hole. The new default behavior is to ONLY return the Authentication Token from those APIs\n  if the query param ``include_auth_token`` is added to the request. Prior behavior can be restored by setting\n  the *SECURITY_BACKWARDS_COMPAT_AUTH_TOKEN* configuration variable.\n\n- (:pr:`120`) :class:`.RoleMixin` now has a method :meth:`.get_permissions` which is called as part\n  each request to add Permissions to the authenticated user. It checks if the RoleModel\n  has a property ``permissions`` and assumes it is a comma separated string of permissions.\n  If your model already has such a property this will likely fail. You need to override :meth:`.get_permissions`\n  and simply return an emtpy set.\n\n- (:issue:`121`) Changes the default (failure) behavior for views protected with @auth_required, @token_auth_required,\n  or @http_auth_required. Before, a 401 was returned with some stock html. Now, Flask-Login.unauthorized() is\n  called (the same as @login_required does) - which by default redirects to a login page/view. If you had provided your own\n  `.Security.unauthorized_callback` there are no changes - that will still be called first. The old default\n  behavior can be restored by setting *SECURITY_BACKWARDS_COMPAT_UNAUTHN* to True. Please see :ref:`responsetopic` for details.\n\n- (:issue:`127`) Fix for LazyStrings in json error response. The fix for this has Flask-Security registering\n  its own JsonEncoder on its blueprint. If you registered your own JsonEncoder for your app - it will no\n  longer be called when serializing responses to Flask-Security endpoints. You can register your JsonEncoder\n  on Flask-Security's blueprint by sending it as `json_encoder_cls` as part of initialization. Be aware that your\n  JsonEncoder needs to handle LazyStrings (see speaklater).\n\n- (:issue:`84`) Prior to this fix - anytime the decorator :func:`.anonymous_user_required` failed, it caused a redirect to\n  the post_login_view. Now, if the caller wanted a JSON response, it will return a 400.\n\n- (:issue:`156`) Faster Authentication Token introduced the following non-backwards compatible behavior change:\n\n    * Since the old Authentication Token algorithm used the (hashed) user's password, those tokens would be invalidated\n      whenever the user changed their password. This is not likely to be what most users expect. Since the new\n      Authentication Token algorithm doesn't refer to the user's password, changing the user's password won't invalidate\n      outstanding Authentication Tokens. The method :meth:`.UserDatastore.set_uniquifier` can be used by an administrator\n      to change a user's ``fs_uniquifier`` - but nothing the user themselves can do to invalidate their Authentication Tokens.\n      Setting the *SECURITY_BACKWARDS_COMPAT_AUTH_TOKEN_INVALIDATE* configuration variable will cause the user's ``fs_uniquifier`` to\n      be changed when they change their password, thus restoring prior behavior.\n\n\nNew fast authentication token implementation\n++++++++++++++++++++++++++++++++++++++++++++\nCurrent auth tokens are slow because they use the user's password (hashed) as a uniquifier (the\nuser id isn't really enough since it might be reused). This requires checking the (hashed) password against\nwhat is in the token on EVERY request - however hashing is (on purpose) slow. So this can add almost a whole second\nto every request.\n\nTo solve this, a new attribute in the User model was added - ``fs_uniquifier``. If this is present in your\nUser model, then it will be used instead of the password for ensuring the token corresponds to the correct user.\nThis is very fast. If that attribute is NOT present - then the behavior falls back to the existing (slow) method.\n\n\nDB Migration\n~~~~~~~~~~~~\n\nTo use the new UserModel mixins or to add the column ``user.fs_uniquifier`` to speed up token\nauthentication, a schema AND data migration needs to happen. If you are using Alembic the schema migration is\neasy - but you need to add ``fs_uniquifier`` values to all your existing data. You can\nadd code like this to your migrations::update method::\n\n    # be sure to MODIFY this line to make nullable=True:\n    op.add_column('user', sa.Column('fs_uniquifier', sa.String(length=64), nullable=True))\n\n    # update existing rows with unique fs_uniquifier\n    import uuid\n    user_table = sa.Table('user', sa.MetaData(), sa.Column('id', sa.Integer, primary_key=True),\n                          sa.Column('fs_uniquifier', sa.String))\n    conn = op.get_bind()\n    for row in conn.execute(sa.select([user_table.c.id])):\n        conn.execute(user_table.update().values(fs_uniquifier=uuid.uuid4().hex).where(user_table.c.id == row['id']))\n\n    # finally - set nullable to false\n    op.alter_column('user', 'fs_uniquifier', nullable=False)\n\n\nVersion 3.2.0\n-------------\n\nReleased June 26th 2019\n\n- (opr #839) Support caching of authentication token (eregnier).\n  This adds a new configuration variable *SECURITY_USE_VERIFY_PASSWORD_CACHE*\n  which enables a cache (with configurable TTL) for authentication tokens.\n  This is a big performance boost for those accessing Flask-Security via token\n  as opposed to session.\n- (:pr:`81`) Support for JSON/Single-Page-Application. This completes support\n  for non-form based access to Flask-Security. See PR for details. (jwag956)\n- (:pr:`79` Add POST logout to enhance JSON usage (jwag956).\n- (:pr:`73`) Fix get_user for various DBs (jwag956).\n  This is a more complete fix than in opr #633.\n- (:pr:`78`, :pr:`103`) Add formal openapi API spec (jwag956).\n- (:pr:`86`, :pr:`94`, :pr:`98`, :pr:`101`, :pr:`104`) Add Two-factor authentication (opr #842) (baurt, jwag956).\n- (:issue:`108`) Fix form field label translations (jwag956)\n- (:issue:`115`) Fix form error message translations (upstream #801) (jwag956)\n- (:issue:`87`) Convert entire repo to Black (baurt)\n\nVersion 3.1.0\n-------------\n\nReleased never\n\n- (opr #487) Use Security.render_template in mails too (noirbizarre)\n- (opr #679) Optimize DB accesses by using an SQL JOIN when retrieving a user. (nfvs)\n- (opr #697) Add base template to security templates (grihabor)\n- (opr #633) datastore: get user by numeric identity attribute (jirikuncar)\n- (opr #703) bugfix: support application factory pattern (briancappello)\n- (opr #714) Make SECURITY_PASSWORD_SINGLE_HASH a list of scheme ignoring double hash (noirbizarre )\n- (opr #717) Allow custom login_manager to be passed in to Flask-Security (jaza)\n- (opr #727) Docs for OAauth2-based custom login manager (jaza)\n- (opr #779) core: make the User model check the password (mklassen)\n- (opr #730) Customizable send_mail (abulte)\n- (opr #726) core: fix default for UNAUTHORIZED_VIEW (jirijunkar)\n\nThese should all be backwards compatible.\n\nPossible compatibility issues:\n\n- #487 - prior to this, render_template() was overiddable for views, but not\n  emails. If anyone actually relied on this behavior, this has changed.\n- #703 - get factory pattern working again. There was a very complex dance between\n  Security() instantiation and init_app regarding kwargs. This has been rationalized (hopefully).\n- #679 - SqlAlchemy SQL improvement. It is possible you will get the following error::\n\n    Got exception during processing: <class 'sqlalchemy.exc.InvalidRequestError'> -\n    'User.roles' does not support object population - eager loading cannot be applied.\n\n  This is likely solveable by removing ``lazy='dynamic'`` from your Role definition.\n\n\nPerformance improvements:\n\n- #679 - for sqlalchemy, for each request, there would be 2 DB accesses - now\n  there is one.\n\nTesting:\nFor datastores operations, Sqlalchemy, peewee, pony were all tested against sqlite,\npostgres, and mysql real databases.\n\n\nVersion 3.0.2\n-------------\n\nReleased April 30th 2019\n\n- (opr #439) HTTP Auth respects SECURITY_USER_IDENTITY_ATTRIBUTES (pnpnpn)\n- (opr #660) csrf_enabled` deprecation fix (abulte)\n- (opr #671) Fix referrer loop in _get_unauthorized_view(). (nfvs)\n- (opr #675) Fix AttributeError in _request_loader (sbagan)\n- (opr #676) Fix timing attack on login form (cript0nauta)\n- (opr #683) Close db connection after running tests (reambus)\n- (opr #691) docs: add password salt to SQLAlchemy app example (KshitijKarthick)\n- (opr #692) utils: fix incorrect email sender type (switowski)\n- (opr #696) Fixed broken Click link (williamhatcher)\n- (opr #722) Fix password recovery confirmation on deleted user (kesara)\n- (opr #747) Update login_user.html (rickwest)\n- (opr #748) i18n: configurable the dirname domain (escudero)\n- (opr #835) adds relevant user to reset password form for validation purposes (fuhrysteve)\n\nThese are bug fixes and a couple very small additions.\nNo change in behavior and no new functionality.\n'opr#' is the original pull request from https://github.com/mattupstate/flask-security\n\nVersion 3.0.1\n--------------\n\nReleased April 28th 2019\n\n- Support 3.7 as part of CI\n- Rebrand to this forked repo\n- (#15) Build docs and translations as part of CI\n- (#17) Move to msgcheck from pytest-translations\n- (opr #669) Fix for Read the Docs (jirikuncar)\n- (opr #710) Spanish translation (maukoquiroga)\n- (opr #712) i18n: improvements of German translations (eseifert)\n- (opr #713) i18n: add Portuguese (Brazilian) translation (dinorox)\n- (opr #719) docs: fix anchor links and typos (kesara)\n- (opr #751) i18n: fix missing space (abulte)\n- (opr #762) docs: fixed proxy import (lsmith)\n- (opr #767) Update customizing.rst (allanice001)\n- (opr #776) i18n: add Portuguese (Portugal) translation (micael-grilo)\n- (opr #791) Fix documentation for mattupstate#781 (fmerges)\n- (opr #796) Chinese translations (Steinkuo)\n- (opr #808) Clarify that a commit is needed after login_user (christophertull)\n- (opr #823) Add Turkish translation (Admicos)\n- (opr #831) Catalan translation (miceno)\n\nThese are all documentation and i18n changes - NO code changes. All except the last 3 were accepted and reviewed by\nthe original Flask-Security team.\nThanks as always to all the contributors.\n\nVersion 3.0.0\n-------------\n\nReleased May 29th 2017\n\n- Fixed a bug when user clicking confirmation link after confirmation\n  and expiration causes confirmation email to resend. (see #556)\n- Added support for I18N.\n- Added options `SECURITY_EMAIL_PLAINTEXT` and `SECURITY_EMAIL_HTML`\n  for sending respecively plaintext and HTML version of email.\n- Fixed validation when missing login information.\n- Fixed condition for token extraction from JSON body.\n- Better support for universal bdist wheel.\n- Added port of CLI using Click configurable using options\n  `SECURITY_CLI_USERS_NAME` and `SECURITY_CLI_ROLES_NAME`.\n- Added new configuration option `SECURITY_DATETIME_FACTORY` which can\n  be used to force default timezone for newly created datetimes.\n  (see mattupstate/flask-security#466)\n- Better IP tracking if using Flask 0.12.\n- Renamed deprecated Flask-WFT base form class.\n- Added tests for custom forms configured using app config.\n- Added validation and tests for next argument in logout endpoint. (see #499)\n- Bumped minimal required versions of several packages.\n- Extended test matric on Travis CI for minimal and released package versions.\n- Added of .editorconfig and forced tests for code style.\n- Fixed a security bug when validating a confirmation token, also checks\n  if the email that the token was created with matches the user's current email.\n- Replaced token loader with request loader.\n- Changed trackable behavior of `login_user` when IP can not be detected from a request from 'untrackable' to `None` value.\n- Use ProxyFix instead of inspecting X-Forwarded-For header.\n- Fix identical problem with app as with datastore.\n- Removed always-failing assertion.\n- Fixed failure of init_app to set self.datastore.\n- Changed to new style flask imports.\n- Added proper error code when returning JSON response.\n- Changed obsolette Required validator from WTForms to DataRequired. Bumped Flask-WTF to 0.13.\n- Fixed missing `SECURITY_SUBDOMAIN` in config docs.\n- Added cascade delete in PeeweeDatastore.\n- Added notes to docs about `SECURITY_USER_IDENTITY_ATTRIBUTES`.\n- Inspect value of `SECURITY_UNAUTHORIZED_VIEW`.\n- Send password reset instructions if an attempt has expired.\n- Added \"Forgot password?\" link to LoginForm description.\n- Upgraded passlib, and removed bcrypt version restriction.\n- Removed a duplicate line ('retype_password': 'Retype Password') in forms.py.\n- Various documentation improvement.\n\nVersion 1.7.5\n-------------\n\nReleased December 2nd 2015\n\n- Added `SECURITY_TOKEN_MAX_AGE` configuration setting\n- Fixed calls to `SQLAlchemyUserDatastore.get_user(None)` (this now returns `False` instead of raising a `TypeError`\n- Fixed URL generation adding extra slashes in some cases (see GitHub #343)\n- Fixed handling of trackable IP addresses when the `X-Forwarded-For` header contains multiple values\n- Include WWW-Authenticate headers in `@auth_required` authentication checks\n- Fixed error when `check_token` function is used with a json list\n- Added support for custom `AnonymousUser` classes\n- Restricted `forgot_password` endpoint to anonymous users\n- Allowed unauthorized callback to be overridden\n- Fixed issue where passwords cannot be reset if currently set to `None`\n- Ensured that password reset tokens are invalidated after use\n- Updated `is_authenticated` and `is_active` functions to support Flask-Login changes\n- Various documentation improvements\n\n\nVersion 1.7.4\n-------------\n\nReleased October 13th 2014\n\n- Fixed a bug related to changing existing passwords from plaintext to hashed\n- Fixed a bug in form validation that did not enforce case insensivitiy\n- Fixed a bug with validating redirects\n\n\nVersion 1.7.3\n-------------\n\nReleased June 10th 2014\n\n- Fixed a bug where redirection to `SECURITY_POST_LOGIN_VIEW` was not respected\n- Fixed string encoding in various places to be friendly to unicode\n- Now using `werkzeug.security.safe_str_cmp` to check tokens\n- Removed user information from JSON output on `/reset` responses\n- Added Python 3.4 support\n\n\nVersion 1.7.2\n-------------\n\nReleased May 6th 2014\n\n- Updated IP tracking to check for `X-Forwarded-For` header\n- Fixed a bug regarding the re-hashing of passwords with a new algorithm\n- Fixed a bug regarding the `password_changed` signal.\n\n\nVersion 1.7.1\n-------------\n\nReleased January 14th 2014\n\n- Fixed a bug where passwords would fail to verify when specifying a password hash algorithm\n\n\nVersion 1.7.0\n-------------\n\nReleased January 10th 2014\n\n- Python 3.3 support!\n- Dependency updates\n- Fixed a bug when `SECURITY_LOGIN_WITHOUT_CONFIRMATION = True` did not allow users to log in\n- Added `SECURITY_SEND_PASSWORD_RESET_NOTICE_EMAIL` configuraiton option to optionally send password reset notice emails\n- Add documentation for `@security.send_mail_task`\n- Move to `request.get_json` as `request.json` is now deprecated in Flask\n- Fixed a bug when using AJAX to change a user's password\n- Added documentation for select functions in the `flask_security.utils` module\n- Fixed a bug in `flask_security.forms.NextFormMixin`\n- Added `CHANGE_PASSWORD_TEMPLATE` configuration option to optionally specify a different change password template\n- Added the ability to specify addtional fields on the user model to be used for identifying the user via the `USER_IDENTITY_ATTRIBUTES` configuration option\n- An error is now shown if a user tries to change their password and the password is the same as before. The message can be customed with the `SECURITY_MSG_PASSWORD_IS_SAME` configuration option\n- Fixed a bug in `MongoEngineUserDatastore` where user model would not be updated when using the `add_role_to_user` method\n- Added `SECURITY_SEND_PASSWORD_CHANGE_EMAIL` configuration option to optionally disable password change email from being sent\n- Fixed a bug in the `find_or_create_role` method of the PeeWee datastore\n- Removed pypy tests\n- Fixed some tests\n- Include CHANGES and LICENSE in MANIFEST.in\n- A bit of documentation cleanup\n- A bit of code cleanup including removal of unnecessary utcnow call and simplification of get_max_age method\n\n\nVersion 1.6.9\n-------------\n\nReleased August 20th 2013\n\n- Fix bug in SQLAlchemy datastore's `get_user` function\n- Fix bug in PeeWee datastore's `remove_role_from_user` function\n- Fixed import error caused by new Flask-WTF release\n\n\nVersion 1.6.8\n-------------\n\nReleased August 1st 2013\n\n- Fixed bug with case sensitivity of email address during login\n- Code cleanup regarding token_callback\n- Ignore validation errors in find_user function for MongoEngineUserDatastore\n\n\nVersion 1.6.7\n-------------\n\nReleased July 11th 2013\n\n- Made password length form error message configurable\n- Fixed email confirmation bug that prevented logged in users from confirming their email\n\n\nVersion 1.6.6\n-------------\n\nReleased June 28th 2013\n\n- Fixed dependency versions\n\n\nVersion 1.6.5\n-------------\n\nReleased June 20th 2013\n\n- Fixed bug in `flask.ext.security.confirmable.generate_confirmation_link`\n\n\nVersion 1.6.4\n-------------\n\nReleased June 18th 2013\n\n- Added `SECURITY_DEFAULT_REMEMBER_ME` configuration value to unify behavior between endpoints\n- Fixed Flask-Login dependency problem\n- Added optional `next` parameter to registration endpoint, similar to that of login\n\n\nVersion 1.6.3\n-------------\n\nReleased May 8th 2013\n\n- Fixed bug in regards to imports with latest version of MongoEngine\n\n\nVersion 1.6.2\n-------------\n\nReleased April 4th 2013\n\n- Fixed bug with http basic auth\n\n\nVersion 1.6.1\n-------------\n\nReleased April 3rd 2013\n\n- Fixed bug with signals\n\n\nVersion 1.6.0\n-------------\n\nReleased March 13th 2013\n\n- Added Flask-Pewee support\n- Password hashing is now more flexible and can be changed to a different type at will\n- Flask-Login messages are configurable\n- AJAX requests must now send a CSRF token for security reasons\n- Form messages are now configurable\n- Forms can now be extended with more fields\n- Added change password endpoint\n- Added the user to the request context when successfully authenticated via http basic and token auth\n- The Flask-Security blueprint subdomain is now configurable\n- Redirects to other domains are now not allowed during requests that may redirect\n- Template paths can be configured\n- The welcome/register email can now optionally be sent to the user\n- Passwords can now contain non-latin characters\n- Fixed a bug when confirming an account but the account has been deleted\n\n\nVersion 1.5.4\n-------------\n\nReleased January 6th 2013\n\n- Fix bug in forms with `csrf_enabled` parameter not accounting attempts to login using JSON data\n\n\nVersion 1.5.3\n-------------\n\nReleased December 23rd 2012\n\n- Change dependency requirement\n\nVersion 1.5.2\n-------------\n\nReleased December 11th 2012\n\n- Fix a small bug in `flask_security.utils.login_user` method\n\nVersion 1.5.1\n-------------\n\nReleased November 26th 2012\n\n- Fixed bug with `next` form variable\n- Added better documentation regarding Flask-Mail configuration\n- Added ability to configure email subjects\n\nVersion 1.5.0\n-------------\n\nReleased October 11th 2012\n\n- Major release. Upgrading from previous versions will require a bit of work to\n  accomodate API changes. See documentation for a list of new features and for\n  help on how to upgrade.\n\nVersion 1.2.3\n-------------\n\nReleased June 12th 2012\n\n- Fixed a bug in the RoleMixin eq/ne functions\n\nVersion 1.2.2\n-------------\n\nReleased April 27th 2012\n\n- Fixed bug where `roles_required` and `roles_accepted` did not pass the next\n  argument to the login view\n\nVersion 1.2.1\n-------------\n\nReleased March 28th 2012\n\n- Added optional user model mixin parameter for datastores\n- Added CreateRoleCommand to available Flask-Script commands\n\nVersion 1.2.0\n-------------\n\nReleased March 12th 2012\n\n- Added configuration option `SECURITY_FLASH_MESSAGES` which can be set to a\n  boolean value to specify if Flask-Security should flash messages or not.\n\nVersion 1.1.0\n-------------\n\nInitial release\n", "openapi: 3.0.0\ninfo:\n  description: |\n    Default API for Flask-Security.\n\n    __N.B. This is preliminary.__\n\n    Since Flask-Security is middleware, with many possible configurations this is a\n    guide to how the APIs will behave using standard defaults.\n\n    By default, all POST requests require a CSRF token. This is handled automatically\n    if you render the form from your Flask application. If you send JSON, then you must include a request header (configured via __SECURITY_CSRF_HEADER__).\n    Please read the online documentation to find out details on how CSRF can be confifgured.\n\n    _Be aware that the current renderer is great! but has some limitations._\n    In particular\n    it can't represent both form input and JSON input - but all APIs take both.\n\n    You can download the latest spec from: https://github.com/Flask-Middleware/flask-security/blob/master/docs/openapi.yaml\n  version: 1.0.0\n  title: \"Flask-Security External API\"\n  contact:\n    name: Flask-Security-Too\n    url: https://github.com/Flask-Middleware/flask-security\n  license:\n    name: MIT\n    url: https://github.com/Flask-Middleware/flask-security/blob/master/LICENSE\npaths:\n  /login:\n    get:\n      summary: Retrieve login form and/or user information\n      parameters:\n        - $ref: \"#/components/parameters/include_auth_token\"\n      responses:\n        200:\n          description: >\n            Login form or user information. The JSON response will always\n            carry the csrf_token information. If the caller is logged in, then\n            additional information is returned. This can be very useful for single-page applications where during a force refresh, all state is lost.\n            By performing this GET, the session cookie will authenticate the user and the response will contain user information.\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_LOGIN_USER_TEMPLATE)\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n        302:\n          description: Response when already logged in (non-JSON request)\n          headers:\n            Location:\n              schema:\n                type: string\n                example: redirect(SECURITY_POST_LOGIN_VIEW)\n    post:\n      summary: Login to application\n      description: Supports both json and form request types. If the caller is already logged in, then in the form case, they are redirected to SECURITY_POST_LOGIN_VIEW, for a json request, a 400 is returned.\n      parameters:\n        - name: next\n          in: query\n          description: >\n              URL to redirect to on successful login. Ignored for json request.\n          schema:\n            type: string\n        - $ref: \"#/components/parameters/include_auth_token\"\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/Login\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/Login\"\n      responses:\n        200:\n          description: Login response\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n            text/html:\n              schema:\n                description: Unsuccessful login\n                type: string\n                example: render_template(SECURITY_LOGIN_USER_TEMPLATE) with error values\n        302:\n          description: >\n            If the caller already authenticated, the form contents is ignored and a\n            redirect is done: redirect(next) or redirect(SECURITY_POST_LOGIN_VIEW).\n\n            If the caller is NOT already authenticated, and the form contents are\n            validated the caller will be redirected to:\n            redirect(next) or redirect(SECURITY_POST_LOGIN_VIEW)\n          headers:\n            Location:\n              description: redirect\n              schema:\n                type: string\n                example: redirect(SECURITY_POST_LOGIN_VIEW)\n        400:\n          description: Errors while validating login, or caller already authenticated/logged in.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /login(passwordless):\n    get:\n      summary: Return passwordless login form\n      responses:\n        200:\n          description: Passwordless login form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_SEND_LOGIN_TEMPLATE)\n    post:\n      summary: Send passwordless login instructions email\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/EmailLink\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/EmailLink\"\n      responses:\n        200:\n          description: >\n            Passwordless login response. For forms both success and validation errors.\n          content:\n            text/html:\n              schema:\n                description: Passwordless login form - with errors.\n                type: string\n                example: render_template(SECURITY_SEND_LOGIN_TEMPLATE)\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n        400:\n          description: Errors while validating form\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /login(passwordless)/{token}:\n    parameters:\n      - name: token\n        in: path\n        required: true\n        schema:\n          type: string\n    get:\n      summary: Login via token\n      description: >\n        This is the result of getting a passwordless login token and is usually\n        the result of clicking the link from a passwordless email.\n        This ALWAYS results in a 302 redirect.\n      responses:\n        302:\n          description: >\n            Redirects depending on success/error and whether\n            __SECURITY_REDIRECT_BEHAVIOR__ == 'spa'.\n          headers:\n            Location:\n              description: |\n                On spa-success: SECURITY_POST_LOGIN_VIEW?email={email}\n\n                On spa-error-expired: SECURITY_LOGIN_ERROR_VIEW?error={msg}&email={email}\n\n                On spa-error-invalid-token: SECURITY_LOGIN_ERROR_VIEW?error={msg}\n\n                On form-success: SECURITY_POST_LOGIN_VIEW\n\n                On form-error-expired: SECURITY_LOGIN_VIEW\n\n                On form-error-invalid-token: SECURITY_LOGIN_VIEW\n              schema:\n                type: string\n  /logout:\n    get:\n      summary: Log out current user\n      responses:\n        302:\n          description: Successful logout\n          headers:\n            Location:\n              description: redirect(SECURITY_POST_LOGOUT_VIEW)\n              schema:\n                example: redirect(SECURITY_POST_LOGOUT_VIEW)\n    post:\n      summary: Log out current user\n      responses:\n        200:\n          description: Successful logout\n          content:\n            application/json:\n              schema:\n                type: object\n                required: [meta]\n                properties:\n                  meta:\n                    type: object\n                    required: [code]\n                    properties:\n                      code:\n                        type: integer\n                        example: 200\n                        description: Http status code\n  /register:\n    get:\n      summary: Return register form\n      responses:\n        200:\n          description: Register form\n          content:\n            text/html:\n              schema:\n                type: string\n                example: render_template(SECURITY_REGISTER_USER_TEMPLATE)\n        302:\n          description: Response when already logged in\n          headers:\n            Location:\n              schema:\n                type: string\n                example: redirect(SECURITY_POST_LOGIN_VIEW)\n    post:\n      summary: Register with application\n      description: Supports both json and form request types\n      parameters:\n        - name: next\n          in: query\n          description: >\n              URL to redirect to on successful registration. Ignored for json request.\n          schema:\n            type: string\n\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/Register\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/RegisterForm\"\n      responses:\n        200:\n          description: Register response\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n            text/html:\n              schema:\n                description: Unsuccessful registration\n                type: string\n                example: render_template(SECURITY_REGISTER_USER_TEMPLATE) with error values\n        302:\n          description: >\n            Successful registration with form data body.\n          headers:\n            Location:\n              description: redirect to (next) or (SECURITY_POST_REGISTER_VIEW)\n              schema:\n                type: string\n        400:\n          description: Errors while validating registration form\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /change:\n    get:\n      summary: Return change password form\n      responses:\n        200:\n          description: change password form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_CHANGE_PASSWORD_TEMPLATE)\n    post:\n      summary: Change password\n      parameters:\n        - name: X-XSRF-Token\n          in: header\n          schema:\n            $ref: \"#/components/headers/X-CSRF-Token\"\n        - $ref: '#/components/parameters/include_auth_token'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/ChangePassword\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/ChangePassword\"\n      responses:\n        200:\n          description: Change password response.\n          content:\n            text/html:\n              schema:\n                description: Change form validation error.\n                type: string\n                example: render_template(SECURITY_CHANGE_PASSWORD_TEMPLATE) with error values\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n        302:\n          description: Password has been changed (non-json)\n          headers:\n            Location:\n              description: |\n                On success: redirect(SECURITY_POST_CHANGE_VIEW) or\n                            redirect(SECURITY_POST_LOGIN_VIEW)\n              schema:\n                type: string\n        400:\n          description: Errors while validating form\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /reset:\n    get:\n      summary: Return reset password form\n      responses:\n        200:\n          description: Reset password form\n          content:\n            text/html:\n              schema:\n                type: string\n                example: render_template(SECURITY_FORGOT_PASSWORD_TEMPLATE)\n        302:\n          description: Response when already logged in\n          headers:\n            Location:\n              schema:\n                type: string\n                example: redirect(SECURITY_POST_LOGIN_VIEW)\n    post:\n      summary: Send reset password instructions email\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/EmailLink\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/EmailLink\"\n      responses:\n        200:\n          description: >\n            Reset password response. For forms both success and validation errors.\n          content:\n            text/html:\n              schema:\n                description: Forgot password form - with errors.\n                type: string\n                example: render_template(SECURITY_FORGOT_PASSWORD_TEMPLATE)\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n        400:\n          description: Errors while validating form\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /reset/{token}:\n    parameters:\n      - name: token\n        in: path\n        required: true\n        schema:\n          type: string\n    get:\n      summary: Request to reset password\n      description: >\n        This is the result of getting a reset-password token and is usually\n        the result of clicking the link from a reset-password email.\n        If __SECURITY_REDIRECT_BEHAVIOR__ == 'spa' then a 302 is always returned.\n      responses:\n        200:\n          description: Reset password form\n          content:\n            text/html:\n              schema:\n                type: string\n                example: render_template(SECURITY_RESET_PASSWORD_TEMPLATE)\n        302:\n          description: >\n            Redirects depending on success/error and whether\n            __SECURITY_REDIRECT_BEHAVIOR__ == 'spa'.\n          headers:\n            Location:\n              description: |\n                On spa-success: SECURITY_RESET_VIEW?token={token}&email={email}\n\n                On spa-error-expired: SECURITY_RESET_ERROR_VIEW?error={msg}&email={email}\n\n                On spa-error-invalid-token: SECURITY_RESET_ERROR_VIEW?error={msg}\n\n                On default-error: redirect(SECURITY_FORGOT_PASSWORD)\n              schema:\n                type: string\n              examples:\n                spa-success:\n                  value: SECURITY_RESET_VIEW?token={token}&email={email}\n                spa-error-expired:\n                  value: SECURITY_RESET_ERROR_VIEW?error={msg}&email={email}\n                spa-error-invalid-token:\n                  value: SECURITY_RESET_ERROR_VIEW?error={msg}\n                default-error:\n                  value: redirect(SECURITY_FORGOT_PASSWORD)\n    post:\n      summary: Reset password\n      parameters:\n        - $ref: '#/components/parameters/include_auth_token'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/ResetPassword\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/ResetPassword\"\n      responses:\n        200:\n          description: Reset response\n          content:\n            text/html:\n              schema:\n                description: Reset form validation error.\n                type: string\n                example: render_template(SECURITY_RESET_PASSWORD_TEMPLATE) with error values\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n        302:\n          description: Password has been reset or validation error (non-json)\n          headers:\n            Location:\n              description: |\n                On success: redirect(SECURITY_POST_RESET_VIEW) or\n                    redirect(SECURITY_POST_LOGIN_VIEW)\n\n                On invalid/expired token: redirect(SECURITY_FORGOT_PASSWORD)\n              schema:\n                type: string\n              examples:\n                success:\n                  value: redirect(SECURITY_POST_RESET_VIEW) or\n                    redirect(SECURITY_POST_LOGIN_VIEW)\n                invalid/expired-token:\n                  value: redirect(SECURITY_FORGOT_PASSWORD)\n        400:\n          description: Errors while validating form\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /confirm:\n    get:\n      summary: Return send confirmation form\n      responses:\n        200:\n          description: Confirmation form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_SEND_CONFIRMATION_TEMPLATE)\n    post:\n      summary: Send confirmation email\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/EmailLink\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/EmailLink\"\n      responses:\n        200:\n          description: >\n            Confirmation response. For forms both success and validation errors.\n          content:\n            text/html:\n              schema:\n                description: Confirmation form - with errors.\n                type: string\n                example: render_template(SECURITY_SEND_CONFIRMATION_TEMPLATE)\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n        400:\n          description: Errors while validating form\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /confirm/{token}:\n    parameters:\n      - name: token\n        in: path\n        required: true\n        schema:\n          type: string\n    get:\n      summary: Request to confirm account\n      description: >\n        This is the result of getting a confirmation token and is usually\n        the result of clicking the link from a confirmation email.\n        This ALWAYS results in a 302 redirect.\n        By default (unless __SECURITY_AUTO_LOGIN_AFTER_CONFIRM__ == False), the user\n        denoted by the token is logged in as a side-effect.\n      responses:\n        302:\n          description: >\n            Redirects depending on success/error and whether\n            __SECURITY_REDIRECT_BEHAVIOR__ == 'spa'.\n          headers:\n            Location:\n              description: |\n                On spa-success: SECURITY_POST_CONFIRM_VIEW?email={email}&{level}={msg}\n\n                On spa-error-expired: SECURITY_CONFIRM_ERROR_VIEW?error={msg}&email={email}\n\n                On spa-error-invalid-token: SECURITY_CONFIRM_ERROR_VIEW?error={msg}\n\n                On form-success: SECURITY_POST_CONFIRM_VIEW or\n                                 SECURITY_POST_LOGIN_VIEW\n\n                On form-success (no auto-login): SECURITY_POST_CONFIRM_VIEW or\n                                 SECURITY_LOGIN_URL\n\n                On form-error-expired: SECURITY_CONFIRM_ERROR_VIEW or\n                                       SECURITY_CONFIRM_URL\n\n                On form-error-invalid-token: SECURITY_CONFIRM_ERROR_VIEW or\n                                             SECURITY_CONFIRM_URL\n              schema:\n                type: string\n  /us-signin:\n    get:\n      summary: Unified Sign In.\n      responses:\n        200:\n          description: Sign in form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_US_SIGNIN_TEMPLATE)\n            application/json:\n              schema:\n                type: object\n                properties:\n                  available_methods:\n                    type: string\n                    description: Config setting SECURITY_US_ENABLED_METHODS\n                  code_methods:\n                    type: string\n                    description: All SECURITY_US_ENABLED_METHODS that require a code to be generated and sent.\n                  identity_attributes:\n                    type: string\n                    description: Configuration setting SECURITY_USER_IDENTITY_ATTRIBUTES\n    post:\n      summary: Unified Sign In.\n      parameters:\n        - $ref: '#/components/parameters/include_auth_token'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/UsSignin\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/UsSignin\"\n      responses:\n        200:\n          description: Unified Sign In response\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/UsSigninJsonResponse\"\n            text/html:\n              schema:\n                description: Unsuccessful sign in\n                type: string\n                example: render_template(SECURITY_US_SIGNIN_TEMPLATE) with error values\n        302:\n          description: >\n            If the caller already authenticated, the form contents is ignored and a\n            redirect is done: redirect(next) or redirect(SECURITY_POST_LOGIN_VIEW).\n\n            If the caller is NOT already authenticated, and the form contents are\n            validated the caller will be redirected to:\n            redirect(next) or redirect(SECURITY_POST_LOGIN_VIEW)\n          headers:\n            Location:\n              description: redirect\n              schema:\n                type: string\n                example: redirect(SECURITY_POST_LOGIN_VIEW)\n        400:\n          description: Errors while validating attributes, or caller already authenticated/logged in.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /us-signin/send-code:\n    get:\n      summary: Unified Sign In send authentication code\n      responses:\n        200:\n          description: Send Code form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_US_SIGNIN_TEMPLATE)\n            application/json:\n              schema:\n                type: object\n                properties:\n                  methods:\n                    type: string\n                    description: Config setting SECURITY_US_ENABLED_METHODS\n                  code_methods:\n                    type: string\n                    description: All SECURITY_US_ENABLED_METHODS that require a code to be generated and sent.\n                  identity_attributes:\n                    type: string\n                    description: Configuration setting SECURITY_USER_IDENTITY_ATTRIBUTES\n    post:\n      summary: Send Code for unified sign in.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/UsSigninSendCode\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/UsSigninSendCode\"\n      responses:\n        200:\n          description: Send code response\n          content:\n            application/json:\n              schema:\n                  description: Code successfully sent\n            text/html:\n              schema:\n                description: Validation error, code send error, or code successfully sent\n                type: string\n                example: render_template(SECURITY_US_SIGNIN_TEMPLATE) with error values\n        400:\n          description: Errors while validating attributes.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n        500:\n          description: Error when trying to send code.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n\n  /us-verify:\n    get:\n      summary: Unified sign in re-authentication.\n      description: >\n        If an endpoint is protected with @auth_required() with a freshness declaration\n        this endpoint will be called to request an already signed in user to re-authenticate.\n      responses:\n        200:\n          description: Verify/re-authenticate form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_US_VERIFY_TEMPLATE)\n            application/json:\n              schema:\n                type: object\n                properties:\n                  available_methods:\n                    type: string\n                    description: Config setting SECURITY_US_ENABLED_METHODS\n                  code_methods:\n                    type: string\n                    description: All SECURITY_US_ENABLED_METHODS that require a code to be generated and sent.\n    post:\n      summary: Unified sign in re-authentication\n      parameters:\n        - $ref: '#/components/parameters/include_auth_token'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/UsSigninVerify\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/UsSigninVerify\"\n      responses:\n        200:\n          description: Verify/re-authenticate response.\n          content:\n            application/json:\n              schema:\n                allOf:\n                  - description: >\n                      The user successfully re-authenticated.\n                  - $ref: \"#/components/schemas/DefaultJsonResponse\"\n            text/html:\n              schema:\n                description: Unsuccessful re-authentication.\n                type: string\n                example: render_template(SECURITY_US_VERIFY_TEMPLATE) with error values\n        302:\n          description: User successfully re-authenticated when using form based request.\n          headers:\n            Location:\n              description: redirect\n              schema:\n                type: string\n                example: redirect(next) or redirect(SECURITY_POST_VERIFY_VIEW)\n        400:\n          description: Errors while validating attributes.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /us-verify/send-code:\n    get:\n      summary: Unified sign in verify/re-authenticate send authentication code\n      responses:\n        200:\n          description: Send Code form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_US_VERIFY_TEMPLATE)\n            application/json:\n              schema:\n                type: object\n                properties:\n                  methods:\n                    type: string\n                    description: Config setting SECURITY_US_ENABLED_METHODS\n                  code_methods:\n                    type: string\n                    description: All SECURITY_US_ENABLED_METHODS that require a code to be generated and sent.\n    post:\n      summary: Send Code for unified sign in verify.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/UsSigninVerifySendCode\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/UsSigninVerifySendCode\"\n      responses:\n        200:\n          description: Send code response\n          content:\n            application/json:\n              schema:\n                  description: Code successfully sent\n            text/html:\n              schema:\n                description: Validation error, code send error, or code successfully sent\n                type: string\n                example: render_template(SECURITY_US_VERIFY_TEMPLATE) with error values\n        400:\n          description: Errors while validating attributes.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n        500:\n          description: Error when trying to send code.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /us-setup:\n    get:\n      summary: Unified sign in setup passcode options.\n      responses:\n        200:\n          description: Setup form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_US_SETUP_TEMPLATE)\n            application/json:\n              schema:\n                type: object\n                properties:\n                  available_methods:\n                    type: string\n                    description: Config setting SECURITY_US_ENABLED_METHODS\n                  active_methods:\n                    type: string\n                    description: Methods that have already been setup.\n                  setup_methods:\n                    type: string\n                    description: All SECURITY_US_ENABLED_METHODS that require setup.\n                  identity_attributes:\n                    type: string\n                    description: Configuration setting SECURITY_USER_IDENTITY_ATTRIBUTES\n                  phone:\n                    type: string\n                    description: existing configured phone number\n    post:\n      summary: Unified sign in setup.\n      description: >\n        An authenticated user can call this endpoint to update or add additional methods for authenticating (e.g. sms, authenticator app). This is controlled by application configuration settings SECURITY_US_ENABLED_METHODS. This endpoint is protected by a 'freshness' check - meaning the caller will be required to have authenticated recently. In addition, to ensure correctness, the newly setup method must be verified by sending and entering a code prior to it being permanently stored. This verification process is also time-limited.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/UsSetup\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/UsSetup\"\n      responses:\n        200:\n          description: Unified sign in setup response.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/UsSetupJsonResponse\"\n            text/html:\n              schema:\n                description: Invalid form values or verification code sent successfully and should be entered into the form.\n                type: string\n                example: render_template(SECURITY_US_SETUP_TEMPLATE) with error values\n        400:\n          description: Errors while validating attributes.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n        500:\n          description: Error when trying to send code.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /us-setup/{token}:\n    parameters:\n      - name: token\n        in: path\n        required: true\n        schema:\n          type: string\n    get:\n      summary: Validate unified sign in setup request.\n      description: >\n        This does nothing but redirect back to the setup form.\n      responses:\n        200:\n          description: Get form.\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_US_SETUP_TEMPLATE)\n\n    post:\n      summary: Validate passcode sent and store setup method.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/UsSetupValidateRequest\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/UsSetupValidateRequest\"\n      responses:\n        200:\n          description: Successfully validated and persisted sign in method.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/UsSetupValidateJsonResponse\"\n        302:\n          description: Successfuly validated and persisted sign in method.\n          headers:\n            Location:\n              description: |\n                On form-success: SECURITY_POST_SETUP_VIEW or\n                                 SECURITY_POST_LOGIN_VIEW\n              schema:\n                type: string\n        400:\n          description: Validation failed.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /us-verify-link:\n    parameters:\n      - name: email\n        in: query\n        required: true\n        schema:\n          type: string\n      - name: code\n        in: query\n        required: true\n        schema:\n          type: string\n    get:\n      summary: A magic link to authenticate (instead of manually entering a code).\n      description: >\n        This is the result of getting a passcode link and is usually\n        the result of clicking the link from an email.\n        This ALWAYS results in a 302 redirect.\n        N.B. Magic link with 2FA enabled does not work and the SPA will get a redirect to the login error page with tf_required. Must use code option instead.\n      responses:\n        302:\n          description: >\n            Redirects depending on success/error and whether\n            __SECURITY_REDIRECT_BEHAVIOR__ == 'spa'. Also, if Two-Factor authentication has been enabled, further authentication/redirects might be required.\n          headers:\n            Location:\n              description: |\n                On spa-success: SECURITY_POST_LOGIN_VIEW?email={email}\n\n                On spa-error-expired: SECURITY_LOGIN_ERROR_VIEW?error={msg}\n\n                On spa-error-invalid-token: SECURITY_LOGIN_ERROR_VIEW?error={msg}\n\n                On spa-two-factor-required: SECURITY_LOGIN_ERROR_VIEW?tf_required=1\n\n                On form-success: SECURITY_POST_LOGIN_VIEW\n\n                On form-error-expired: SECURITY_US_SIGNIN_URL\n\n                On form-error-invalid-token: SECURITY_US_SIGNIN_URL\n\n                On form-success and two-factor: SECURITY_TWO_FACTOR_TOKEN_VALIDATION_URL or SECURITY_TWO_FACTOR_SETUP_URL\n              schema:\n                type: string\n  /us-qrcode/{token}:\n    parameters:\n      - name: token\n        in: path\n        required: true\n        schema:\n          type: string\n    get:\n      summary: Display a QRCode for setting up an authenticator app.\n      responses:\n        200:\n          description: Display QRCode.\n          content:\n            image/svg+xml:\n              schema:\n                description: QRCode\n        400:\n          description: Token invalid or expired.\n        404:\n          description: authenticator not configured.\n\ncomponents:\n  schemas:\n    Login:\n      type: object\n      required: [email, password]\n      properties:\n        email:\n          type: string\n          description: >\n            user identifier. This is by default an email address, but can be any (unique)\n            field that is part of the User model and is defined in the __SECURITY_USER_IDENTITY_ATTRIBUTES__ configuration variable. It will also match against numeric User model fields.\n        password:\n          type: string\n          description: Password\n        remember_me:\n          type: boolean\n          description: >\n            If true, will remember userid as part of cookie. There is a configuration variable DEFAULT_REMEMBER_ME that can be set. This field will override that.\n    DefaultJsonResponse:\n      type: object\n      properties:\n        user:\n          type: object\n          required: [id]\n          description: >\n            By default just 'id' is returned. However by overriding _User::get_security_payload()_ any attributes of the User model can be returned.\n          properties:\n            id:\n              type: integer\n              example: 42\n              description: Unique user id (primary key)\n            authentication_token:\n              type: string\n              description: >\n                Token to be used in future token-based API calls.\n                Note this only returned from those APIs that accept a\n                'include_auth_token' query param.\n        csrf_token:\n          type: string\n          description: Session CSRF token\n    DefaultJsonErrorResponse:\n      type: object\n      required: [meta, response]\n      properties:\n        meta:\n          type: object\n          required: [code]\n          properties:\n            code:\n              type: integer\n              example: 400\n              description: Http status code\n        response:\n          type: object\n          description: >\n            For form validation errors, the 'errors' key will be set with a list of errors per\n            invalid form input field. For non-form related errors, the 'error' key will be set\n            with a single (localized) error string.\n          properties:\n            errors:\n              type: object\n              description: >\n                Errors per input/form field ('email' below is just an example)\n              properties:\n                email:\n                  type: array\n                  items:\n                    type: string\n                    example: Email issues.\n                    description: Error message (localized)\n            error:\n              type: string\n              example: \"Unauthenticated\"\n              description: Error message (localized)\n    Register:\n      type: object\n      required: [email, password]\n      properties:\n        email:\n          type: string\n          description: >\n            user identifier. This is by default an email address, but can be any (unique)\n            field that is part of the User model and is defined in the __SECURITY_USER_IDENTITY_ATTRIBUTES__ configuration variable. It will also match against numeric User model fields.\n        password:\n          type: string\n          description: Password\n    RegisterForm:\n      type: object\n      required: [email, password]\n      properties:\n        email:\n          type: string\n          description: >\n            user identifier. This is by default an email address, but can be any (unique)\n            field that is part of the User model and is defined in the __SECURITY_USER_IDENTITY_ATTRIBUTES__ configuration variable. It will also match against numeric User model fields.\n        password:\n          type: string\n          description: Password\n        password_confirm:\n          type: string\n          description: >\n            If present, must re-type in password. This will not be present if the __SECURITY_CONFIRM__ configuration is true.\n        next:\n          type: string\n          description: >\n            Redirect URL. Overrides __SECURITY_POST_REGISTER_VIEW__.\n    ResetPassword:\n      type: object\n      required: [password, password_confirm]\n      properties:\n        password:\n          type: string\n          description: Password\n        password_confirm:\n          type: string\n          description: Password - again\n    ChangePassword:\n      type: object\n      required: [password, new_password, new_password_confirm]\n      properties:\n        password:\n          type: string\n          description: Password\n        new_password:\n          type: string\n          description: New password\n        new_password_confirm:\n          type: string\n          description: New password - again\n    EmailLink:\n      type: object\n      required: [email]\n      properties:\n        email:\n          type: string\n          description: >\n            Email address to send link email to.\n    UsSignin:\n      type: object\n      required: [identity, passcode]\n      properties:\n        identity:\n          type: string\n          description: Configured by SECURITY_USER_IDENTITY_ATTRIBUTES\n          example: me@you.com, +16505551212\n        passcode:\n          type: string\n          description: password or code\n        remember_me:\n          type: boolean\n    UsSigninJsonResponse:\n      type: object\n      description: >\n        The user successfully signed in. Note that depending on SECURITY_TWO_FACTOR and SECURITY_US_MFA_REQUIRED configuration variables, a second form of authentication might be required.\n      required: [meta, response]\n      properties:\n        meta:\n          type: object\n          required: [code]\n          properties:\n            code:\n              type: integer\n              example: 200\n              description: Http status code\n        response:\n          type: object\n          properties:\n            tf_required:\n              type: boolean\n              description: If two-factor authentication is required for caller.\n            tf_state:\n              type: string\n              description: if \"setup_from_login\" then the caller must go through two-factor setup endpoint. If \"ready\" then a code has been sent and should be supplied to SECURITY_TWO_FACTOR_TOKEN_VALIDATION_URL.\n            tf_primary_method:\n              type: string\n              description: Which method was used to send code.\n    UsSigninSendCode:\n      type: object\n      required: [identity, chosen_method]\n      properties:\n        identity:\n          type: string\n          description: Configured by SECURITY_USER_IDENTITY_ATTRIBUTES\n          example: me@you.com, +16505551212\n        chosen_method:\n          type: string\n          description: which method should be used to send the code, as configured with SECURITY_US_ENABLED_METHODS\n    UsSigninVerify:\n      type: object\n      required: [passcode]\n      properties:\n        passcode:\n          type: string\n          description: password or code\n    UsSigninVerifySendCode:\n      type: object\n      required: [chosen_method]\n      properties:\n        chosen_method:\n          type: string\n          description: which method should be used to send the code, as configured with SECURITY_US_ENABLED_METHODS\n    UsSetup:\n      type: object\n      required: [chosen_method]\n      properties:\n        chosen_method:\n          type: string\n          description: which method should be used to send the code, as configured with SECURITY_US_ENABLED_METHODS\n        phone:\n          type: string\n          description: phone number (this will be normalized). Required if chosen_method == \"sms\".\n    UsSetupJsonResponse:\n      type: object\n      required: [meta, response]\n      properties:\n        meta:\n          type: object\n          required: [code]\n          properties:\n            code:\n              type: integer\n              example: 200\n              description: Http status code\n        response:\n          type: object\n          properties:\n            chosen_method:\n              type: string\n              description: The chosen_method as passed into API.\n            state:\n              type: string\n              description: Opaque blob that must be pass to /us-setup/<state>. This is a signed, timed token.\n    UsSetupValidateRequest:\n      type: object\n      required: [passcode]\n      properties:\n        passcode:\n          type: string\n          description: Code/Passcode as received from method being setup.\n    UsSetupValidateJsonResponse:\n      type: object\n      required: [meta, response]\n      properties:\n        meta:\n          type: object\n          required: [code]\n          properties:\n            code:\n              type: integer\n              example: 200\n              description: Http status code\n        response:\n          type: object\n          properties:\n            chosen_method:\n              type: string\n              description: The chosen_method as passed into API.\n            phone:\n              type: string\n              description: Phone number if set.\n\n  headers:\n    X-CSRF-Token:\n      description: CSRF token\n      schema:\n        type: string\n  parameters:\n    include_auth_token:\n      name: include_auth_token\n      description: If set/sent, will return an Authentication Token for user\n      in: query\n      schema:\n        type: string\n\n", "# -*- coding: utf-8 -*-\n\"\"\"\n    flask_security.views\n    ~~~~~~~~~~~~~~~~~~~~\n\n    Flask-Security views module\n\n    :copyright: (c) 2012 by Matt Wright.\n    :copyright: (c) 2019-2020 by J. Christopher Wagner (jwag).\n    :license: MIT, see LICENSE for more details.\n\n    CSRF is tricky. By default all our forms have CSRF protection built in via\n    Flask-WTF. This is regardless of authentication method or whether the request\n    is Form or JSON based. Form-based 'just works' since when rendering the form\n    (on GET), the CSRF token is automatically populated.\n    We want to handle:\n        - JSON requests where CSRF token is in a header (e.g. X-CSRF-Token)\n        - Option to skip CSRF when using a token to authenticate (rather than session)\n          (CSRF_PROTECT_MECHANISMS)\n        - Option to skip CSRF for 'login'/unauthenticated requests\n          (CSRF_IGNORE_UNAUTH_ENDPOINTS)\n    This is complicated by the fact that the only way to disable form CSRF is to\n    pass in meta={csrf: false} at form instantiation time.\n\n    Be aware that for CSRF to work, caller MUST pass in session cookie. So\n    for pure API, and no session cookie - there is no way to support CSRF-Login\n    so app must set CSRF_IGNORE_UNAUTH_ENDPOINTS (or use CSRF/session cookie for logging\n    in then once they have a token, no need for cookie).\n\n    TODO: two-factor routes such as tf_setup need work. They seem to support both\n    authenticated (via session?) as well as unauthenticated access.\n\"\"\"\n\nimport sys\nimport time\n\nfrom flask import (\n    Blueprint,\n    abort,\n    after_this_request,\n    current_app,\n    jsonify,\n    request,\n    session,\n)\nfrom flask_login import current_user\nfrom werkzeug.datastructures import MultiDict\nfrom werkzeug.local import LocalProxy\n\nfrom .changeable import change_user_password\nfrom .confirmable import (\n    confirm_email_token_status,\n    confirm_user,\n    send_confirmation_instructions,\n)\nfrom .decorators import anonymous_user_required, auth_required, unauth_csrf\nfrom .passwordless import login_token_status, send_login_instructions\nfrom .quart_compat import get_quart_status\nfrom .unified_signin import (\n    us_signin,\n    us_signin_send_code,\n    us_qrcode,\n    us_setup,\n    us_setup_validate,\n    us_verify,\n    us_verify_link,\n    us_verify_send_code,\n)\nfrom .recoverable import (\n    reset_password_token_status,\n    send_reset_password_instructions,\n    update_password,\n)\nfrom .registerable import register_user\nfrom .twofactor import (\n    complete_two_factor_process,\n    tf_clean_session,\n    tf_disable,\n    tf_login,\n)\nfrom .utils import (\n    base_render_json,\n    config_value,\n    do_flash,\n    get_message,\n    get_post_login_redirect,\n    get_post_logout_redirect,\n    get_post_register_redirect,\n    get_post_verify_redirect,\n    get_url,\n    json_error_response,\n    login_user,\n    logout_user,\n    slash_url_suffix,\n    suppress_form_csrf,\n    url_for_security,\n)\n\nif get_quart_status():  # pragma: no cover\n    from quart import make_response, redirect\nelse:\n    from flask import make_response, redirect\n\n# Convenient references\n_security = LocalProxy(lambda: current_app.extensions[\"security\"])\n_datastore = LocalProxy(lambda: _security.datastore)\n\n\ndef default_render_json(payload, code, headers, user):\n    \"\"\" Default JSON response handler.\n    \"\"\"\n    # Force Content-Type header to json.\n    if headers is None:\n        headers = dict()\n    headers[\"Content-Type\"] = \"application/json\"\n    payload = dict(meta=dict(code=code), response=payload)\n    return make_response(jsonify(payload), code, headers)\n\n\nPY3 = sys.version_info[0] == 3\nif PY3 and get_quart_status():  # pragma: no cover\n    from .async_compat import _commit  # noqa: F401\nelse:\n\n    def _commit(response=None):\n        _datastore.commit()\n        return response\n\n\ndef _ctx(endpoint):\n    return _security._run_ctx_processor(endpoint)\n\n\n@unauth_csrf(fall_through=True)\ndef login():\n    \"\"\"View function for login view\n\n    Allow already authenticated users. For GET this is useful for\n    single-page-applications on refresh - session still active but need to\n    access user info and csrf-token.\n    For POST - redirects to POST_LOGIN_VIEW (forms) or returns 400 (json).\n    \"\"\"\n\n    if current_user.is_authenticated and request.method == \"POST\":\n        # Just redirect current_user to POST_LOGIN_VIEW.\n        # While its tempting to try to logout the current user and login the\n        # new requested user - that simply doesn't work with CSRF.\n\n        # This does NOT use get_post_login_redirect() so that it doesn't look at\n        # 'next' - which can cause infinite redirect loops\n        # (see test_common::test_authenticated_loop)\n        if _security._want_json(request):\n            payload = json_error_response(\n                errors=get_message(\"ANONYMOUS_USER_REQUIRED\")[0]\n            )\n            return _security._render_json(payload, 400, None, None)\n        else:\n            return redirect(get_url(_security.post_login_view))\n\n    form_class = _security.login_form\n\n    if request.is_json:\n        # Allow GET so we can return csrf_token for pre-login.\n        if request.content_length:\n            form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n        else:\n            form = form_class(MultiDict([]), meta=suppress_form_csrf())\n    else:\n        form = form_class(request.form, meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        remember_me = form.remember.data if \"remember\" in form else None\n        if config_value(\"TWO_FACTOR\") and (\n            config_value(\"TWO_FACTOR_REQUIRED\")\n            or (form.user.tf_totp_secret and form.user.tf_primary_method)\n        ):\n            return tf_login(\n                form.user, remember=remember_me, primary_authn_via=\"password\"\n            )\n\n        login_user(form.user, remember=remember_me, authn_via=[\"password\"])\n        after_this_request(_commit)\n\n        if not _security._want_json(request):\n            return redirect(get_post_login_redirect())\n\n    if _security._want_json(request):\n        if current_user.is_authenticated:\n            form.user = current_user\n        return base_render_json(form, include_auth_token=True)\n\n    if current_user.is_authenticated:\n        return redirect(get_url(_security.post_login_view))\n    else:\n        return _security.render_template(\n            config_value(\"LOGIN_USER_TEMPLATE\"), login_user_form=form, **_ctx(\"login\")\n        )\n\n\n@auth_required()\ndef verify():\n    \"\"\"View function which handles a authentication verification request.\n    \"\"\"\n    form_class = _security.verify_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        # form may have called verify_and_update_password()\n        after_this_request(_commit)\n\n        # verified - so set freshness time.\n        session[\"fs_paa\"] = time.time()\n\n        if _security._want_json(request):\n            return base_render_json(form)\n        do_flash(*get_message(\"REAUTHENTICATION_SUCCESSFUL\"))\n        return redirect(get_post_verify_redirect())\n\n    if _security._want_json(request):\n        assert form.user == current_user\n        return base_render_json(form)\n\n    return _security.render_template(\n        config_value(\"VERIFY_TEMPLATE\"), verify_form=form, **_ctx(\"verify\")\n    )\n\n\ndef logout():\n    \"\"\"View function which handles a logout request.\"\"\"\n    tf_clean_session()\n\n    if current_user.is_authenticated:\n        logout_user()\n\n    # No body is required - so if a POST and json - return OK\n    if request.method == \"POST\" and _security._want_json(request):\n        return _security._render_json({}, 200, headers=None, user=None)\n\n    return redirect(get_post_logout_redirect())\n\n\n@anonymous_user_required\ndef register():\n    \"\"\"View function which handles a registration request.\"\"\"\n\n    # For some unknown historic reason - if you don't require confirmation\n    # (via email) then you need to type in your password twice. That might\n    # make sense if you can't reset your password but in modern (2020) UX models\n    # don't ask twice.\n    if _security.confirmable or request.is_json:\n        form_class = _security.confirm_register_form\n    else:\n        form_class = _security.register_form\n\n    if request.is_json:\n        form_data = MultiDict(request.get_json())\n    else:\n        form_data = request.form\n\n    form = form_class(form_data, meta=suppress_form_csrf())\n    if form.validate_on_submit():\n        did_login = False\n        user = register_user(form)\n        form.user = user\n\n        # The 'auto-login' feature probably should be removed - I can't imagine\n        # an application that would want random email accounts. It has been like this\n        # since the beginning. Note that we still enforce 2FA - however for unified\n        # signin - we adhere to historic behavior.\n        if not _security.confirmable or _security.login_without_confirmation:\n            if config_value(\"TWO_FACTOR\") and config_value(\"TWO_FACTOR_REQUIRED\"):\n                return tf_login(user, primary_authn_via=\"register\")\n            after_this_request(_commit)\n            login_user(user, authn_via=[\"register\"])\n            did_login = True\n\n        if not _security._want_json(request):\n            return redirect(get_post_register_redirect())\n\n        # Only include auth token if in fact user is permitted to login\n        return base_render_json(form, include_auth_token=did_login)\n    if _security._want_json(request):\n        return base_render_json(form)\n\n    return _security.render_template(\n        config_value(\"REGISTER_USER_TEMPLATE\"),\n        register_user_form=form,\n        **_ctx(\"register\")\n    )\n\n\n@unauth_csrf(fall_through=True)\ndef send_login():\n    \"\"\"View function that sends login instructions for passwordless login\"\"\"\n\n    form_class = _security.passwordless_login_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        send_login_instructions(form.user)\n        if not _security._want_json(request):\n            do_flash(*get_message(\"LOGIN_EMAIL_SENT\", email=form.user.email))\n\n    if _security._want_json(request):\n        return base_render_json(form)\n\n    return _security.render_template(\n        config_value(\"SEND_LOGIN_TEMPLATE\"), send_login_form=form, **_ctx(\"send_login\")\n    )\n\n\n@anonymous_user_required\ndef token_login(token):\n    \"\"\"View function that handles passwordless login via a token\n    Like reset-password and confirm - this is usually a GET via an email\n    so from the request we can't differentiate form-based apps from non.\n    \"\"\"\n\n    expired, invalid, user = login_token_status(token)\n\n    if not user or invalid:\n        m, c = get_message(\"INVALID_LOGIN_TOKEN\")\n        if _security.redirect_behavior == \"spa\":\n            return redirect(get_url(_security.login_error_view, qparams={c: m}))\n        do_flash(m, c)\n        return redirect(url_for_security(\"login\"))\n    if expired:\n        send_login_instructions(user)\n        m, c = get_message(\n            \"LOGIN_EXPIRED\", email=user.email, within=_security.login_within\n        )\n        if _security.redirect_behavior == \"spa\":\n            return redirect(\n                get_url(\n                    _security.login_error_view,\n                    qparams=user.get_redirect_qparams({c: m}),\n                )\n            )\n        do_flash(m, c)\n        return redirect(url_for_security(\"login\"))\n\n    login_user(user, authn_via=[\"token\"])\n    after_this_request(_commit)\n    if _security.redirect_behavior == \"spa\":\n        return redirect(\n            get_url(_security.post_login_view, qparams=user.get_redirect_qparams())\n        )\n\n    do_flash(*get_message(\"PASSWORDLESS_LOGIN_SUCCESSFUL\"))\n\n    return redirect(get_post_login_redirect())\n\n\n@unauth_csrf(fall_through=True)\ndef send_confirmation():\n    \"\"\"View function which sends confirmation instructions.\"\"\"\n\n    form_class = _security.send_confirmation_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        send_confirmation_instructions(form.user)\n        if not _security._want_json(request):\n            do_flash(*get_message(\"CONFIRMATION_REQUEST\", email=form.user.email))\n\n    if _security._want_json(request):\n        return base_render_json(form)\n\n    return _security.render_template(\n        config_value(\"SEND_CONFIRMATION_TEMPLATE\"),\n        send_confirmation_form=form,\n        **_ctx(\"send_confirmation\")\n    )\n\n\ndef confirm_email(token):\n    \"\"\"View function which handles a email confirmation request.\"\"\"\n\n    expired, invalid, user = confirm_email_token_status(token)\n\n    if not user or invalid:\n        m, c = get_message(\"INVALID_CONFIRMATION_TOKEN\")\n        if _security.redirect_behavior == \"spa\":\n            return redirect(get_url(_security.confirm_error_view, qparams={c: m}))\n        do_flash(m, c)\n        return redirect(\n            get_url(_security.confirm_error_view)\n            or url_for_security(\"send_confirmation\")\n        )\n\n    already_confirmed = user.confirmed_at is not None\n\n    if expired or already_confirmed:\n        if already_confirmed:\n            m, c = get_message(\"ALREADY_CONFIRMED\")\n        else:\n            send_confirmation_instructions(user)\n            m, c = get_message(\n                \"CONFIRMATION_EXPIRED\",\n                email=user.email,\n                within=_security.confirm_email_within,\n            )\n\n        if _security.redirect_behavior == \"spa\":\n            return redirect(\n                get_url(\n                    _security.confirm_error_view,\n                    qparams=user.get_redirect_qparams({c: m}),\n                )\n            )\n\n        do_flash(m, c)\n        return redirect(\n            get_url(_security.confirm_error_view)\n            or url_for_security(\"send_confirmation\")\n        )\n\n    confirm_user(user)\n    after_this_request(_commit)\n\n    if user != current_user:\n        logout_user()\n        if config_value(\"AUTO_LOGIN_AFTER_CONFIRM\"):\n            # N.B. this is a (small) security risk if email went to wrong place.\n            # and you have the LOGIN_WITH_CONFIRMATION flag since in that case\n            # you can be logged in and doing stuff - but another person could\n            # get the email.\n            if config_value(\"TWO_FACTOR\") and config_value(\"TWO_FACTOR_REQUIRED\"):\n                return tf_login(user, primary_authn_via=\"confirm\")\n            login_user(user, authn_via=[\"confirm\"])\n\n    m, c = get_message(\"EMAIL_CONFIRMED\")\n    if _security.redirect_behavior == \"spa\":\n        return redirect(\n            get_url(\n                _security.post_confirm_view, qparams=user.get_redirect_qparams({c: m})\n            )\n        )\n    do_flash(m, c)\n    return redirect(\n        get_url(_security.post_confirm_view)\n        or get_url(\n            _security.post_login_view\n            if config_value(\"AUTO_LOGIN_AFTER_CONFIRM\")\n            else _security.login_url\n        )\n    )\n\n\n@anonymous_user_required\n@unauth_csrf(fall_through=True)\ndef forgot_password():\n    \"\"\"View function that handles a forgotten password request.\"\"\"\n\n    form_class = _security.forgot_password_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        send_reset_password_instructions(form.user)\n        if not _security._want_json(request):\n            do_flash(*get_message(\"PASSWORD_RESET_REQUEST\", email=form.user.email))\n\n    if _security._want_json(request):\n        return base_render_json(form, include_user=False)\n\n    return _security.render_template(\n        config_value(\"FORGOT_PASSWORD_TEMPLATE\"),\n        forgot_password_form=form,\n        **_ctx(\"forgot_password\")\n    )\n\n\n@anonymous_user_required\n@unauth_csrf(fall_through=True)\ndef reset_password(token):\n    \"\"\"View function that handles a reset password request.\n\n    This is usually called via GET as part of an email link and redirects to\n    a reset-password form\n    It is called via POST to actually update the password (and then redirects to\n    a post reset/login view)\n    If in either case the token is either invalid or expired it redirects to\n    the 'forgot-password' form.\n\n    In the case of non-form based configuration:\n    For GET normal case - redirect to RESET_VIEW?token={token}&email={email}\n    For GET invalid case - redirect to RESET_ERROR_VIEW?error={error}&email={email}\n    For POST normal/successful case - return 200 with new authentication token\n    For POST error case return 400 with form.errors\n    \"\"\"\n\n    expired, invalid, user = reset_password_token_status(token)\n    form_class = _security.reset_password_form\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n    form.user = user\n\n    if request.method == \"GET\":\n        if not user or invalid:\n            m, c = get_message(\"INVALID_RESET_PASSWORD_TOKEN\")\n            if _security.redirect_behavior == \"spa\":\n                return redirect(get_url(_security.reset_error_view, qparams={c: m}))\n            do_flash(m, c)\n            return redirect(url_for_security(\"forgot_password\"))\n        if expired:\n            send_reset_password_instructions(user)\n            m, c = get_message(\n                \"PASSWORD_RESET_EXPIRED\",\n                email=user.email,\n                within=_security.reset_password_within,\n            )\n            if _security.redirect_behavior == \"spa\":\n                return redirect(\n                    get_url(\n                        _security.reset_error_view,\n                        qparams=user.get_redirect_qparams({c: m}),\n                    )\n                )\n            do_flash(m, c)\n            return redirect(url_for_security(\"forgot_password\"))\n\n        # All good - for SPA - redirect to the ``reset_view``\n        if _security.redirect_behavior == \"spa\":\n            return redirect(\n                get_url(\n                    _security.reset_view,\n                    qparams=user.get_redirect_qparams({\"token\": token}),\n                )\n            )\n        # for forms - render the reset password form\n        return _security.render_template(\n            config_value(\"RESET_PASSWORD_TEMPLATE\"),\n            reset_password_form=form,\n            reset_password_token=token,\n            **_ctx(\"reset_password\")\n        )\n\n    # This is the POST case.\n    m = None\n    if not user or invalid:\n        invalid = True\n        m, c = get_message(\"INVALID_RESET_PASSWORD_TOKEN\")\n        if not _security._want_json(request):\n            do_flash(m, c)\n\n    if expired:\n        send_reset_password_instructions(user)\n        m, c = get_message(\n            \"PASSWORD_RESET_EXPIRED\",\n            email=user.email,\n            within=_security.reset_password_within,\n        )\n        if not _security._want_json(request):\n            do_flash(m, c)\n\n    if invalid or expired:\n        if _security._want_json(request):\n            return _security._render_json(json_error_response(m), 400, None, None)\n        else:\n            return redirect(url_for_security(\"forgot_password\"))\n\n    if form.validate_on_submit():\n        after_this_request(_commit)\n        update_password(user, form.password.data)\n        if config_value(\"TWO_FACTOR\") and (\n            config_value(\"TWO_FACTOR_REQUIRED\")\n            or (form.user.tf_totp_secret and form.user.tf_primary_method)\n        ):\n            return tf_login(user, primary_authn_via=\"reset\")\n        login_user(user, authn_via=[\"reset\"])\n        if _security._want_json(request):\n            login_form = _security.login_form(MultiDict({\"email\": user.email}))\n            setattr(login_form, \"user\", user)\n            return base_render_json(login_form, include_auth_token=True)\n        else:\n            do_flash(*get_message(\"PASSWORD_RESET\"))\n            return redirect(\n                get_url(_security.post_reset_view) or get_url(_security.post_login_view)\n            )\n\n    # validation failure case - for forms - we try again including the token\n    # for non-forms -  we just return errors and assume caller remembers token.\n    if _security._want_json(request):\n        return base_render_json(form)\n    return _security.render_template(\n        config_value(\"RESET_PASSWORD_TEMPLATE\"),\n        reset_password_form=form,\n        reset_password_token=token,\n        **_ctx(\"reset_password\")\n    )\n\n\n@auth_required(\"basic\", \"token\", \"session\")\ndef change_password():\n    \"\"\"View function which handles a change password request.\"\"\"\n\n    form_class = _security.change_password_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        after_this_request(_commit)\n        change_user_password(current_user._get_current_object(), form.new_password.data)\n        if not _security._want_json(request):\n            do_flash(*get_message(\"PASSWORD_CHANGE\"))\n            return redirect(\n                get_url(_security.post_change_view)\n                or get_url(_security.post_login_view)\n            )\n\n    if _security._want_json(request):\n        form.user = current_user\n        return base_render_json(form, include_auth_token=True)\n\n    return _security.render_template(\n        config_value(\"CHANGE_PASSWORD_TEMPLATE\"),\n        change_password_form=form,\n        **_ctx(\"change_password\")\n    )\n\n\n@unauth_csrf(fall_through=True)\ndef two_factor_setup():\n    \"\"\"View function for two-factor setup.\n\n    This is used both for GET to fetch forms and POST to actually set configuration\n    (and send token).\n\n    There are 3 cases for setting up:\n    1) initial login and application requires 2FA\n    2) changing existing 2FA information\n    3) user wanting to enable or disable 2FA (assuming application doesn't require it)\n\n    In order to CHANGE/ENABLE/DISABLE a 2FA information, user must be properly logged in\n    AND must perform a fresh password validation by\n    calling POST /tf-confirm (which sets 'tf_confirmed' in the session).\n\n    For initial login when 2FA required of course user can't be logged in - in this\n    case we need to have been sent some\n    state via the session as part of login to show a) who and b) that they successfully\n    authenticated.\n    \"\"\"\n    form_class = _security.two_factor_setup_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if not current_user.is_authenticated:\n        # This is the initial login case\n        # We can also get here from setup if they want to change\n        if not all(k in session for k in [\"tf_user_id\", \"tf_state\"]) or session[\n            \"tf_state\"\n        ] not in [\"setup_from_login\", \"validating_profile\"]:\n            # illegal call on this endpoint\n            tf_clean_session()\n            return _tf_illegal_state(form, _security.login_url)\n\n        user = _datastore.get_user(session[\"tf_user_id\"])\n        if not user:\n            tf_clean_session()\n            return _tf_illegal_state(form, _security.login_url)\n\n    else:\n        # all other cases require user to be logged in and have performed\n        # additional password verification as signified by 'tf_confirmed'\n        # in the session.\n        if \"tf_confirmed\" not in session:\n            tf_clean_session()\n            return _tf_illegal_state(form, _security.two_factor_confirm_url)\n        user = current_user\n\n    if form.validate_on_submit():\n        # Before storing in DB and therefore requiring 2FA we need to\n        # make sure it actually works.\n        # Requiring 2FA is triggered by having BOTH tf_totp_secret and\n        # tf_primary_method in the user record (or having the application\n        # global config TWO_FACTOR_REQUIRED)\n        # Until we correctly validate the 2FA - we don't set primary_method in\n        # user model but use the session to store it.\n        pm = form.setup.data\n        if pm == \"disable\":\n            tf_disable(user)\n            after_this_request(_commit)\n            do_flash(*get_message(\"TWO_FACTOR_DISABLED\"))\n            if not _security._want_json(request):\n                return redirect(get_url(_security.post_login_view))\n            else:\n                return base_render_json(form)\n\n        # Regenerate the TOTP secret on every call of 2FA setup unless it is\n        # within the same session and method (e.g. upon entering the phone number)\n        if pm != session.get(\"tf_primary_method\", None):\n            session[\"tf_totp_secret\"] = _security._totp_factory.generate_totp_secret()\n\n        session[\"tf_primary_method\"] = pm\n        session[\"tf_state\"] = \"validating_profile\"\n        new_phone = form.phone.data if len(form.phone.data) > 0 else None\n        if new_phone:\n            user.tf_phone_number = new_phone\n            _datastore.put(user)\n            after_this_request(_commit)\n\n        # This form is sort of bizarre - for SMS and authenticator\n        # you select, then get more info, and submit again.\n        # For authenticator of course, we don't actually send anything\n        # and for SMS it is the second time around that we get the phone number\n        if pm == \"email\" or (pm == \"sms\" and new_phone):\n            msg = user.tf_send_security_token(\n                method=pm,\n                totp_secret=session[\"tf_totp_secret\"],\n                phone_number=getattr(user, \"tf_phone_number\", None),\n            )\n            if msg:\n                # send code didn't work\n                form.setup.errors = list()\n                form.setup.errors.append(msg)\n                if _security._want_json(request):\n                    return base_render_json(\n                        form, include_user=False, error_status_code=500\n                    )\n        code_form = _security.two_factor_verify_code_form()\n        if not _security._want_json(request):\n            return _security.render_template(\n                config_value(\"TWO_FACTOR_SETUP_TEMPLATE\"),\n                two_factor_setup_form=form,\n                two_factor_verify_code_form=code_form,\n                choices=config_value(\"TWO_FACTOR_ENABLED_METHODS\"),\n                chosen_method=pm,\n                **_ctx(\"tf_setup\")\n            )\n\n    # We get here on GET and POST with failed validation.\n    # For things like phone number - we've already done one POST\n    # that succeeded and now if failed - so retain the initial info\n    if _security._want_json(request):\n        return base_render_json(form, include_user=False)\n\n    code_form = _security.two_factor_verify_code_form()\n    choices = config_value(\"TWO_FACTOR_ENABLED_METHODS\")\n    if not config_value(\"TWO_FACTOR_REQUIRED\"):\n        choices.append(\"disable\")\n\n    return _security.render_template(\n        config_value(\"TWO_FACTOR_SETUP_TEMPLATE\"),\n        two_factor_setup_form=form,\n        two_factor_verify_code_form=code_form,\n        choices=choices,\n        chosen_method=form.setup.data,\n        two_factor_required=config_value(\"TWO_FACTOR_REQUIRED\"),\n        **_ctx(\"tf_setup\")\n    )\n\n\n@unauth_csrf(fall_through=True)\ndef two_factor_token_validation():\n    \"\"\"View function for two-factor token validation\n\n    Two cases:\n    1) normal login case - everything setup correctly; normal 2FA validation\n       In this case - user not logged in -\n       but 'tf_state' == 'ready' or 'validating_profile'\n    2) validating after CHANGE/ENABLE 2FA. In this case user logged in/authenticated\n       they must have 'tf_confirmed' set meaning they re-entered their passwd\n\n    \"\"\"\n\n    form_class = _security.two_factor_verify_code_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    changing = current_user.is_authenticated\n    if not changing:\n        # This is the normal login case\n        if (\n            not all(k in session for k in [\"tf_user_id\", \"tf_state\"])\n            or session[\"tf_state\"] not in [\"ready\", \"validating_profile\"]\n            or (\n                session[\"tf_state\"] == \"validating_profile\"\n                and \"tf_primary_method\" not in session\n            )\n        ):\n            # illegal call on this endpoint\n            tf_clean_session()\n            return _tf_illegal_state(form, _security.login_url)\n\n        user = _datastore.get_user(session[\"tf_user_id\"])\n        form.user = user\n        if not user:\n            tf_clean_session()\n            return _tf_illegal_state(form, _security.login_url)\n\n        if session[\"tf_state\"] == \"ready\":\n            pm = user.tf_primary_method\n            totp_secret = user.tf_totp_secret\n        else:\n            pm = session[\"tf_primary_method\"]\n            totp_secret = session[\"tf_totp_secret\"]\n    else:\n        if (\n            not all(\n                k in session for k in [\"tf_confirmed\", \"tf_state\", \"tf_primary_method\"]\n            )\n            or session[\"tf_state\"] != \"validating_profile\"\n        ):\n            tf_clean_session()\n            # logout since this seems like attack-ish/logic error\n            logout_user()\n            return _tf_illegal_state(form, _security.login_url)\n        pm = session[\"tf_primary_method\"]\n        totp_secret = session[\"tf_totp_secret\"]\n        form.user = current_user\n\n    setattr(form, \"primary_method\", pm)\n    setattr(form, \"tf_totp_secret\", totp_secret)\n    if form.validate_on_submit():\n        # Success - log in user and clear all session variables\n        completion_message = complete_two_factor_process(\n            form.user, pm, totp_secret, changing, session.pop(\"tf_remember_login\", None)\n        )\n        after_this_request(_commit)\n        if not _security._want_json(request):\n            do_flash(*get_message(completion_message))\n            return redirect(get_post_login_redirect())\n\n    # GET or not successful POST\n    if _security._want_json(request):\n        return base_render_json(form)\n\n    # if we were trying to validate a new method\n    if changing:\n        setup_form = _security.two_factor_setup_form()\n\n        return _security.render_template(\n            config_value(\"TWO_FACTOR_SETUP_TEMPLATE\"),\n            two_factor_setup_form=setup_form,\n            two_factor_verify_code_form=form,\n            choices=config_value(\"TWO_FACTOR_ENABLED_METHODS\"),\n            **_ctx(\"tf_setup\")\n        )\n\n    # if we were trying to validate an existing method\n    else:\n        rescue_form = _security.two_factor_rescue_form()\n\n        return _security.render_template(\n            config_value(\"TWO_FACTOR_VERIFY_CODE_TEMPLATE\"),\n            two_factor_rescue_form=rescue_form,\n            two_factor_verify_code_form=form,\n            problem=None,\n            **_ctx(\"tf_token_validation\")\n        )\n\n\n@anonymous_user_required\n@unauth_csrf(fall_through=True)\ndef two_factor_rescue():\n    \"\"\" Function that handles a situation where user can't\n    enter his two-factor validation code\n\n    User must have already provided valid username/password.\n    User must have already established 2FA\n\n    \"\"\"\n\n    form_class = _security.two_factor_rescue_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if (\n        not all(k in session for k in [\"tf_user_id\", \"tf_state\"])\n        or session[\"tf_state\"] != \"ready\"\n    ):\n        tf_clean_session()\n        return _tf_illegal_state(form, _security.login_url)\n\n    user = _datastore.get_user(session[\"tf_user_id\"])\n    form.user = user\n    if not user:\n        tf_clean_session()\n        return _tf_illegal_state(form, _security.login_url)\n\n    rproblem = \"\"\n    if form.validate_on_submit():\n        problem = form.data[\"help_setup\"]\n        rproblem = problem\n        # if the problem is that user can't access his device, w\n        # e send him code through mail\n        if problem == \"lost_device\":\n            msg = form.user.tf_send_security_token(\n                method=\"email\",\n                totp_secret=form.user.tf_totp_secret,\n                phone_number=getattr(form.user, \"tf_phone_number\", None),\n            )\n            if msg:\n                rproblem = \"\"\n                form.help_setup.errors.append(msg)\n                if _security._want_json(request):\n                    return base_render_json(\n                        form, include_user=False, error_status_code=500\n                    )\n        # send app provider a mail message regarding trouble\n        elif problem == \"no_mail_access\":\n            _security._send_mail(\n                config_value(\"EMAIL_SUBJECT_TWO_FACTOR_RESCUE\"),\n                config_value(\"TWO_FACTOR_RESCUE_MAIL\"),\n                \"two_factor_rescue\",\n                user=form.user,\n            )\n        else:\n            return \"\", 404\n\n    if _security._want_json(request):\n        return base_render_json(form, include_user=False)\n\n    code_form = _security.two_factor_verify_code_form()\n    return _security.render_template(\n        config_value(\"TWO_FACTOR_VERIFY_CODE_TEMPLATE\"),\n        two_factor_verify_code_form=code_form,\n        two_factor_rescue_form=form,\n        rescue_mail=config_value(\"TWO_FACTOR_RESCUE_MAIL\"),\n        problem=rproblem,\n        **_ctx(\"tf_token_validation\")\n    )\n\n\n@auth_required(\"basic\", \"session\", \"token\")\ndef two_factor_verify_password():\n    \"\"\"View function which handles a password verification request.\"\"\"\n    form_class = _security.two_factor_verify_password_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        # form called verify_and_update_password()\n        after_this_request(_commit)\n        session[\"tf_confirmed\"] = True\n        m, c = get_message(\"TWO_FACTOR_PASSWORD_CONFIRMATION_DONE\")\n        if not _security._want_json(request):\n            do_flash(m, c)\n            return redirect(url_for_security(\"two_factor_setup\"))\n        else:\n            return _security._render_json(json_error_response(m), 400, None, None)\n\n    if _security._want_json(request):\n        assert form.user == current_user\n        # form.user = current_user\n        return base_render_json(form)\n\n    return _security.render_template(\n        config_value(\"TWO_FACTOR_VERIFY_PASSWORD_TEMPLATE\"),\n        two_factor_verify_password_form=form,\n        **_ctx(\"tf_verify_password\")\n    )\n\n\n@unauth_csrf(fall_through=True)\ndef two_factor_qrcode():\n    if current_user.is_authenticated:\n        user = current_user\n    else:\n        if \"tf_user_id\" not in session:\n            abort(404)\n        user = _datastore.get_user(session[\"tf_user_id\"])\n        if not user:\n            # Seems like we should be careful here if user_id is gone.\n            tf_clean_session()\n            abort(404)\n\n    if \"authenticator\" not in config_value(\"TWO_FACTOR_ENABLED_METHODS\"):\n        return abort(404)\n    if (\n        \"tf_primary_method\" not in session\n        or session[\"tf_primary_method\"] != \"authenticator\"\n    ):\n        return abort(404)\n\n    totp = user.tf_totp_secret\n    if \"tf_totp_secret\" in session:\n        totp = session[\"tf_totp_secret\"]\n    try:\n        import pyqrcode\n\n        # By convention, the URI should have the username that the user\n        # logs in with.\n        username = user.calc_username()\n        url = pyqrcode.create(\n            _security._totp_factory.get_totp_uri(\n                username if username else \"Unknown\", totp\n            )\n        )\n    except ImportError:\n        # For TWO_FACTOR - this should have been checked at app init.\n        raise\n    from io import BytesIO\n\n    stream = BytesIO()\n    url.svg(stream, scale=3)\n    return (\n        stream.getvalue(),\n        200,\n        {\n            \"Content-Type\": \"image/svg+xml\",\n            \"Cache-Control\": \"no-cache, no-store, must-revalidate\",\n            \"Pragma\": \"no-cache\",\n            \"Expires\": \"0\",\n        },\n    )\n\n\ndef _tf_illegal_state(form, redirect_to):\n    m, c = get_message(\"TWO_FACTOR_PERMISSION_DENIED\")\n    if not _security._want_json(request):\n        do_flash(m, c)\n        return redirect(get_url(redirect_to))\n    else:\n        return _security._render_json(json_error_response(m), 400, None, None)\n\n\ndef create_blueprint(app, state, import_name, json_encoder=None):\n    \"\"\"Creates the security extension blueprint\"\"\"\n\n    bp = Blueprint(\n        state.blueprint_name,\n        import_name,\n        url_prefix=state.url_prefix,\n        subdomain=state.subdomain,\n        template_folder=\"templates\",\n    )\n    if json_encoder:\n        bp.json_encoder = json_encoder\n\n    if state.logout_methods is not None:\n        bp.route(state.logout_url, methods=state.logout_methods, endpoint=\"logout\")(\n            logout\n        )\n\n    if state.passwordless:\n        bp.route(state.login_url, methods=[\"GET\", \"POST\"], endpoint=\"login\")(send_login)\n        bp.route(\n            state.login_url + slash_url_suffix(state.login_url, \"<token>\"),\n            endpoint=\"token_login\",\n        )(token_login)\n    elif config_value(\"US_SIGNIN_REPLACES_LOGIN\", app=app):\n        bp.route(state.login_url, methods=[\"GET\", \"POST\"], endpoint=\"login\")(us_signin)\n\n    else:\n        bp.route(state.login_url, methods=[\"GET\", \"POST\"], endpoint=\"login\")(login)\n\n    bp.route(state.verify_url, methods=[\"GET\", \"POST\"], endpoint=\"verify\")(verify)\n\n    if state.unified_signin:\n        bp.route(state.us_signin_url, methods=[\"GET\", \"POST\"], endpoint=\"us_signin\")(\n            us_signin\n        )\n        bp.route(\n            state.us_signin_send_code_url,\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"us_signin_send_code\",\n        )(us_signin_send_code)\n        bp.route(state.us_setup_url, methods=[\"GET\", \"POST\"], endpoint=\"us_setup\")(\n            us_setup\n        )\n        bp.route(\n            state.us_setup_url + slash_url_suffix(state.us_setup_url, \"<token>\"),\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"us_setup_validate\",\n        )(us_setup_validate)\n\n        # Freshness verification\n        if config_value(\"FRESHNESS\", app=app).total_seconds() >= 0:\n            bp.route(\n                state.us_verify_url, methods=[\"GET\", \"POST\"], endpoint=\"us_verify\"\n            )(us_verify)\n            bp.route(\n                state.us_verify_send_code_url,\n                methods=[\"GET\", \"POST\"],\n                endpoint=\"us_verify_send_code\",\n            )(us_verify_send_code)\n\n        bp.route(state.us_verify_link_url, methods=[\"GET\"], endpoint=\"us_verify_link\")(\n            us_verify_link\n        )\n        bp.route(\n            state.us_qrcode_url + slash_url_suffix(state.us_setup_url, \"<token>\"),\n            endpoint=\"us_qrcode\",\n        )(us_qrcode)\n\n    if state.two_factor:\n        tf_token_validation = \"two_factor_token_validation\"\n        tf_qrcode = \"two_factor_qrcode\"\n        bp.route(\n            state.two_factor_setup_url,\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"two_factor_setup\",\n        )(two_factor_setup)\n        bp.route(\n            state.two_factor_token_validation_url,\n            methods=[\"GET\", \"POST\"],\n            endpoint=tf_token_validation,\n        )(two_factor_token_validation)\n        bp.route(state.two_factor_qrcode_url, endpoint=tf_qrcode)(two_factor_qrcode)\n        bp.route(\n            state.two_factor_rescue_url,\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"two_factor_rescue\",\n        )(two_factor_rescue)\n        bp.route(\n            state.two_factor_confirm_url,\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"two_factor_verify_password\",\n        )(two_factor_verify_password)\n\n    if state.registerable:\n        bp.route(state.register_url, methods=[\"GET\", \"POST\"], endpoint=\"register\")(\n            register\n        )\n\n    if state.recoverable:\n        bp.route(state.reset_url, methods=[\"GET\", \"POST\"], endpoint=\"forgot_password\")(\n            forgot_password\n        )\n        bp.route(\n            state.reset_url + slash_url_suffix(state.reset_url, \"<token>\"),\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"reset_password\",\n        )(reset_password)\n\n    if state.changeable:\n        bp.route(state.change_url, methods=[\"GET\", \"POST\"], endpoint=\"change_password\")(\n            change_password\n        )\n\n    if state.confirmable:\n        bp.route(\n            state.confirm_url, methods=[\"GET\", \"POST\"], endpoint=\"send_confirmation\"\n        )(send_confirmation)\n        bp.route(\n            state.confirm_url + slash_url_suffix(state.confirm_url, \"<token>\"),\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"confirm_email\",\n        )(confirm_email)\n\n    return bp\n", "[pytest]\naddopts = -rs --cov flask_security --cov-report term-missing --black --flake8 --cache-clear\nflake8-max-line-length = 88\nflake8-ignore =\n    tests/view_scaffold.py E402\n    async_compat.py ALL\n", "# -*- coding: utf-8 -*-\n\n\"\"\"Simple security for Flask apps.\"\"\"\n\nimport io\nimport re\nfrom setuptools import find_packages, setup\n\nwith io.open(\"README.rst\", \"rt\", encoding=\"utf8\") as f:\n    readme = f.read()\n\nwith io.open(\"flask_security/__init__.py\", \"rt\", encoding=\"utf8\") as f:\n    version = re.search(r'__version__ = \"(.*?)\"', f.read()).group(1)\n\ntests_require = [\n    \"Flask-Mongoengine>=0.9.5\",\n    \"peewee>=3.11.2\",\n    \"Flask-SQLAlchemy>=2.3\",\n    \"argon2_cffi>=19.1.0\",\n    \"bcrypt>=3.1.5\",\n    \"cachetools>=3.1.0\",\n    \"check-manifest>=0.25\",\n    \"coverage>=4.5.4\",\n    \"cryptography>=2.3.1\",\n    \"isort>=4.2.2\",\n    \"mock>=1.3.0\",\n    \"mongoengine>=0.15.3\",\n    \"mongomock>=3.14.0\",\n    \"msgcheck>=2.9\",\n    \"pony>=0.7.11\",\n    \"phonenumberslite>=8.11.1\",\n    \"psycopg2>=2.8.4\",\n    \"pydocstyle>=1.0.0\",\n    \"pymysql>=0.9.3\",\n    \"pyqrcode>=1.2\",\n    \"pytest==4.6.11\",\n    \"pytest-black>=0.3.8\",\n    \"pytest-cache>=1.0\",\n    \"pytest-cov>=2.5.1\",\n    \"pytest-flake8>=1.0.6\",\n    \"pytest-mongo>=1.2.1\",\n    \"pytest>=3.5.1\",\n    \"sqlalchemy>=1.2.6\",\n    \"sqlalchemy-utils>=0.33.0\",\n    \"werkzeug>=0.15.5\",\n    \"zxcvbn~=4.4.28\",\n]\n\nextras_require = {\n    \"docs\": [\"Pallets-Sphinx-Themes>=1.2.0\", \"Sphinx>=1.8.5\", \"sphinx-issues>=1.2.0\"],\n    \"tests\": tests_require,\n}\n\nextras_require[\"all\"] = []\nfor reqs in extras_require.values():\n    extras_require[\"all\"].extend(reqs)\n\nsetup_requires = [\"Babel>=1.3\", \"pytest-runner>=2.6.2\", \"twine\", \"wheel\"]\n\ninstall_requires = [\n    \"Flask>=1.0.2\",\n    \"Flask-Login>=0.4.1\",\n    \"Flask-Mail>=0.9.1\",\n    \"Flask-Principal>=0.4.0\",\n    \"Flask-WTF>=0.14.2\",\n    \"Flask-BabelEx>=0.9.3\",\n    \"email-validator>=1.0.5\",\n    \"itsdangerous>=1.1.0\",\n    \"passlib>=1.7.1\",\n]\n\npackages = find_packages()\n\nsetup(\n    name=\"Flask-Security-Too\",\n    version=version,\n    description=__doc__,\n    long_description=readme,\n    keywords=\"flask security\",\n    license=\"MIT\",\n    author=\"Matt Wright & Chris Wagner\",\n    author_email=\"jwag.wagner+github@gmail.com\",\n    url=\"https://github.com/Flask-Middleware/flask-security\",\n    project_urls={\n        \"Documentation\": \"https://flask-security-too.readthedocs.io\",\n        \"Releases\": \"https://pypi.org/project/Flask-Security-Too/\",\n        \"Code\": \"https://github.com/Flask-Middleware/flask-security\",\n        \"Issue tracker\": \"https://github.com/Flask-Middleware/flask-security/issues\",\n    },\n    packages=packages,\n    zip_safe=False,\n    include_package_data=True,\n    platforms=\"any\",\n    python_requires=\">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*\",\n    extras_require=extras_require,\n    install_requires=install_requires,\n    setup_requires=setup_requires,\n    tests_require=tests_require,\n    classifiers=[\n        \"Environment :: Web Environment\",\n        \"Framework :: Flask\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python\",\n        \"Topic :: Internet :: WWW/HTTP :: Dynamic Content\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Programming Language :: Python :: 2\",\n        \"Programming Language :: Python :: 2.7\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.5\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Programming Language :: Python :: Implementation :: PyPy\",\n        \"Development Status :: 4 - Beta\",\n    ],\n)\n", "# -*- coding: utf-8 -*-\n\"\"\"\n    test_common\n    ~~~~~~~~~~~\n\n    Test common functionality\n\n    :copyright: (c) 2019 by J. Christopher Wagner (jwag).\n    :license: MIT, see LICENSE for more details.\n\"\"\"\n\nimport base64\nimport json\nimport pytest\n\nfrom flask import Blueprint\n\nfrom utils import (\n    authenticate,\n    json_authenticate,\n    get_num_queries,\n    logout,\n    populate_data,\n    verify_token,\n)\n\ntry:\n    from cookielib import Cookie\nexcept ImportError:\n    from http.cookiejar import Cookie\n\n\ndef test_login_view(client):\n    response = client.get(\"/login\")\n    assert b\"<h1>Login</h1>\" in response.data\n\n\ndef test_authenticate(client):\n    response = authenticate(client)\n    assert response.status_code == 302\n    response = authenticate(client, follow_redirects=True)\n    assert b\"Welcome matt@lp.com\" in response.data\n\n\ndef test_authenticate_with_next(client):\n    data = dict(email=\"matt@lp.com\", password=\"password\")\n    response = client.post(\"/login?next=/page1\", data=data, follow_redirects=True)\n    assert b\"Page 1\" in response.data\n\n\ndef test_authenticate_with_next_bp(app, client):\n    api = Blueprint(\"api\", __name__)\n\n    @api.route(\"/info\")\n    def info():\n        pass\n\n    app.register_blueprint(api, url_prefix=\"/api\")\n    data = dict(email=\"matt@lp.com\", password=\"password\")\n    response = client.post(\"/login?next=api.info\", data=data, follow_redirects=False)\n    assert response.status_code == 302\n    assert \"api/info\" in response.location\n\n\ndef test_authenticate_with_invalid_next(client, get_message):\n    data = dict(email=\"matt@lp.com\", password=\"password\")\n    response = client.post(\"/login?next=http://google.com\", data=data)\n    assert get_message(\"INVALID_REDIRECT\") in response.data\n\n\ndef test_authenticate_with_invalid_malformed_next(client, get_message):\n    data = dict(email=\"matt@lp.com\", password=\"password\")\n    response = client.post(\"/login?next=http:///google.com\", data=data)\n    assert get_message(\"INVALID_REDIRECT\") in response.data\n\n\ndef test_authenticate_case_insensitive_email(app, client):\n    response = authenticate(client, \"MATT@lp.com\", follow_redirects=True)\n    assert b\"Welcome matt@lp.com\" in response.data\n\n\ndef test_authenticate_with_invalid_input(client, get_message):\n    response = client.post(\n        \"/login\", data=\"{}\", headers={\"Content-Type\": \"application/json\"}\n    )\n    assert get_message(\"EMAIL_NOT_PROVIDED\") in response.data\n\n\n@pytest.mark.settings(post_login_view=\"/post_login\")\ndef test_get_already_authenticated(client):\n    response = authenticate(client, follow_redirects=True)\n    assert b\"Welcome matt@lp.com\" in response.data\n    response = client.get(\"/login\", follow_redirects=True)\n    assert b\"Post Login\" in response.data\n\n\n@pytest.mark.settings(post_login_view=\"/post_login\")\ndef test_get_already_authenticated_next(client):\n    response = authenticate(client, follow_redirects=True)\n    assert b\"Welcome matt@lp.com\" in response.data\n    # This should NOT override post_login_view due to potential redirect loops.\n    response = client.get(\"/login?next=/page1\", follow_redirects=True)\n    assert b\"Post Login\" in response.data\n\n\n@pytest.mark.settings(post_login_view=\"/post_login\")\ndef test_post_already_authenticated(client):\n    response = authenticate(client, follow_redirects=True)\n    assert b\"Welcome matt@lp.com\" in response.data\n    data = dict(email=\"matt@lp.com\", password=\"password\")\n    response = client.post(\"/login\", data=data, follow_redirects=True)\n    assert b\"Post Login\" in response.data\n    # This should NOT override post_login_view due to potential redirect loops.\n    response = client.post(\"/login?next=/page1\", data=data, follow_redirects=True)\n    assert b\"Post Login\" in response.data\n\n\ndef test_login_form(client):\n    response = client.post(\"/login\", data={\"email\": \"matt@lp.com\"})\n    assert b\"matt@lp.com\" in response.data\n\n\ndef test_unprovided_username(client, get_message):\n    response = authenticate(client, \"\")\n    assert get_message(\"EMAIL_NOT_PROVIDED\") in response.data\n\n\ndef test_unprovided_password(client, get_message):\n    response = authenticate(client, password=\"\")\n    assert get_message(\"PASSWORD_NOT_PROVIDED\") in response.data\n\n\ndef test_invalid_user(client, get_message):\n    response = authenticate(client, email=\"bogus@bogus.com\")\n    assert get_message(\"USER_DOES_NOT_EXIST\") in response.data\n\n\ndef test_bad_password(client, get_message):\n    response = authenticate(client, password=\"bogus\")\n    assert get_message(\"INVALID_PASSWORD\") in response.data\n\n\ndef test_inactive_user(client, get_message):\n    response = authenticate(client, \"tiya@lp.com\", \"password\")\n    assert get_message(\"DISABLED_ACCOUNT\") in response.data\n\n\ndef test_inactive_forbids(app, client, get_message):\n    \"\"\" Make sure that existing session doesn't work after\n    user marked inactive\n    \"\"\"\n    response = authenticate(client, follow_redirects=True)\n    assert response.status_code == 200\n    # make sure can access restricted page\n    response = client.get(\"/profile\", follow_redirects=True)\n    assert b\"Profile Page\" in response.data\n\n    # deactivate matt\n    with app.test_request_context(\"/\"):\n        user = app.security.datastore.find_user(email=\"matt@lp.com\")\n        app.security.datastore.deactivate_user(user)\n        app.security.datastore.commit()\n\n    response = client.get(\"/profile\", follow_redirects=True)\n    # should be thrown back to login page.\n    assert response.status_code == 200\n    assert b\"Please log in to access this page\" in response.data\n\n\n@pytest.mark.settings(unauthorized_view=None)\ndef test_inactive_forbids_token(app, client_nc, get_message):\n    \"\"\" Make sure that existing token doesn't work after\n    user marked inactive\n    \"\"\"\n    response = json_authenticate(client_nc)\n    assert response.status_code == 200\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    headers = {\"Authentication-Token\": token}\n    # make sure can access restricted page\n    response = client_nc.get(\"/token\", headers=headers)\n    assert b\"Token Authentication\" in response.data\n\n    # deactivate matt\n    with app.test_request_context(\"/\"):\n        user = app.security.datastore.find_user(email=\"matt@lp.com\")\n        app.security.datastore.deactivate_user(user)\n        app.security.datastore.commit()\n\n    response = client_nc.get(\"/token\", content_type=\"application/json\", headers=headers)\n    assert response.status_code == 401\n\n\ndef test_unset_password(client, get_message):\n    response = authenticate(client, \"jess@lp.com\", \"password\")\n    assert get_message(\"PASSWORD_NOT_SET\") in response.data\n\n\ndef test_logout(client):\n    authenticate(client)\n    response = logout(client, follow_redirects=True)\n    assert b\"Home Page\" in response.data\n\n\ndef test_logout_post(client):\n    authenticate(client)\n    response = client.post(\"/logout\", content_type=\"application/json\")\n    assert response.status_code == 200\n    assert response.json[\"meta\"][\"code\"] == 200\n\n\ndef test_logout_with_next_invalid(client, get_message):\n    authenticate(client)\n    response = client.get(\"/logout?next=http://google.com\")\n    assert \"google.com\" not in response.location\n\n\ndef test_logout_with_next(client):\n    authenticate(client)\n    response = client.get(\"/logout?next=/page1\", follow_redirects=True)\n    assert b\"Page 1\" in response.data\n\n\ndef test_missing_session_access(client, get_message):\n    response = client.get(\"/profile\", follow_redirects=True)\n    assert get_message(\"LOGIN\") in response.data\n\n\ndef test_has_session_access(client):\n    authenticate(client)\n    response = client.get(\"/profile\", follow_redirects=True)\n    assert b\"profile\" in response.data\n\n\ndef test_authorized_access(client):\n    authenticate(client)\n    response = client.get(\"/admin\")\n    assert b\"Admin Page\" in response.data\n\n\ndef test_unauthorized_access(client, get_message):\n    authenticate(client, \"joe@lp.com\")\n    response = client.get(\"/admin\", follow_redirects=True)\n    assert response.status_code == 403\n\n\n@pytest.mark.settings(unauthorized_view=lambda: None)\ndef test_unauthorized_access_with_referrer(client, get_message):\n    authenticate(client, \"joe@lp.com\")\n    response = client.get(\"/admin\", headers={\"referer\": \"/admin\"})\n    assert response.headers[\"Location\"] != \"/admin\"\n    client.get(response.headers[\"Location\"])\n\n    response = client.get(\n        \"/admin?a=b\", headers={\"referer\": \"http://localhost/admin?x=y\"}\n    )\n    assert response.headers[\"Location\"] == \"http://localhost/\"\n    client.get(response.headers[\"Location\"])\n\n    response = client.get(\n        \"/admin\", headers={\"referer\": \"/admin\"}, follow_redirects=True\n    )\n    assert response.data.count(get_message(\"UNAUTHORIZED\")) == 1\n\n    # When referrer is from another path and unauthorized,\n    # we expect a temp redirect (302) to the referer\n    response = client.get(\"/admin?w=s\", headers={\"referer\": \"/profile\"})\n    assert response.status_code == 302\n    assert response.headers[\"Location\"] == \"http://localhost/profile\"\n\n\n@pytest.mark.settings(unauthorized_view=\"/unauthz\")\ndef test_roles_accepted(clients):\n    # This specificaly tests that we can pass a URL for unauthorized_view.\n    for user in (\"matt@lp.com\", \"joe@lp.com\"):\n        authenticate(clients, user)\n        response = clients.get(\"/admin_or_editor\")\n        assert b\"Admin or Editor Page\" in response.data\n        logout(clients)\n\n    authenticate(clients, \"jill@lp.com\")\n    response = clients.get(\"/admin_or_editor\", follow_redirects=True)\n    assert b\"Unauthorized\" in response.data\n\n\n@pytest.mark.settings(unauthorized_view=\"unauthz\")\ndef test_permissions_accepted(clients):\n    for user in (\"matt@lp.com\", \"joe@lp.com\"):\n        authenticate(clients, user)\n        response = clients.get(\"/admin_perm\")\n        assert b\"Admin Page with full-write or super\" in response.data\n        logout(clients)\n\n    authenticate(clients, \"jill@lp.com\")\n    response = clients.get(\"/admin_perm\", follow_redirects=True)\n    assert b\"Unauthorized\" in response.data\n\n\n@pytest.mark.settings(unauthorized_view=\"unauthz\")\ndef test_permissions_required(clients):\n    for user in [\"matt@lp.com\"]:\n        authenticate(clients, user)\n        response = clients.get(\"/admin_perm_required\")\n        assert b\"Admin Page required\" in response.data\n        logout(clients)\n\n    authenticate(clients, \"joe@lp.com\")\n    response = clients.get(\"/admin_perm_required\", follow_redirects=True)\n    assert b\"Unauthorized\" in response.data\n\n\n@pytest.mark.settings(unauthorized_view=\"unauthz\")\ndef test_unauthenticated_role_required(client, get_message):\n    response = client.get(\"/admin\", follow_redirects=True)\n    assert get_message(\"UNAUTHORIZED\") in response.data\n\n\n@pytest.mark.settings(unauthorized_view=\"unauthz\")\ndef test_multiple_role_required(clients):\n    for user in (\"matt@lp.com\", \"joe@lp.com\"):\n        authenticate(clients, user)\n        response = clients.get(\"/admin_and_editor\", follow_redirects=True)\n        assert b\"Unauthorized\" in response.data\n        clients.get(\"/logout\")\n\n    authenticate(clients, \"dave@lp.com\")\n    response = clients.get(\"/admin_and_editor\", follow_redirects=True)\n    assert b\"Admin and Editor Page\" in response.data\n\n\ndef test_ok_json_auth(client):\n    response = json_authenticate(client)\n    assert response.json[\"meta\"][\"code\"] == 200\n    assert \"authentication_token\" in response.json[\"response\"][\"user\"]\n\n\ndef test_invalid_json_auth(client):\n    response = json_authenticate(client, password=\"junk\")\n    assert b'\"code\": 400' in response.data\n\n\ndef test_token_auth_via_querystring_valid_token(client):\n    response = json_authenticate(client)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    response = client.get(\"/token?auth_token=\" + token)\n    assert b\"Token Authentication\" in response.data\n\n\ndef test_token_auth_via_header_valid_token(client):\n    response = json_authenticate(client)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    headers = {\"Authentication-Token\": token}\n    response = client.get(\"/token\", headers=headers)\n    assert b\"Token Authentication\" in response.data\n\n\ndef test_token_auth_via_querystring_invalid_token(client):\n    response = client.get(\"/token?auth_token=X\", headers={\"Accept\": \"application/json\"})\n    assert response.status_code == 401\n\n\ndef test_token_auth_via_header_invalid_token(client):\n    response = client.get(\n        \"/token\", headers={\"Authentication-Token\": \"X\", \"Accept\": \"application/json\"}\n    )\n    assert response.status_code == 401\n\n\ndef test_http_auth(client):\n    # browsers expect 401 response with WWW-Authenticate header - which will prompt\n    # them to pop up a login form.\n    response = client.get(\"/http\", headers={})\n    assert response.status_code == 401\n    assert b\"You are not authenticated\" in response.data\n    assert \"WWW-Authenticate\" in response.headers\n    assert 'Basic realm=\"Login Required\"' == response.headers[\"WWW-Authenticate\"]\n\n    # Now provide correct credentials\n    response = client.get(\n        \"/http\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"joe@lp.com:password\").decode(\"utf-8\")\n        },\n    )\n    assert b\"HTTP Authentication\" in response.data\n\n\n@pytest.mark.settings(USER_IDENTITY_ATTRIBUTES=(\"email\", \"username\"))\ndef test_http_auth_username(client):\n    response = client.get(\n        \"/http\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"jill:password\").decode(\"utf-8\")\n        },\n    )\n    assert b\"HTTP Authentication\" in response.data\n\n\ndef test_http_auth_no_authorization(client):\n    response = client.get(\n        \"/http_admin_required\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"joe@lp.com:password\").decode(\"utf-8\")\n        },\n    )\n    assert response.status_code == 403\n\n\ndef test_http_auth_no_authorization_json(client, get_message):\n    response = client.get(\n        \"/http_admin_required\",\n        headers={\n            \"accept\": \"application/json\",\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"joe@lp.com:password\").decode(\"utf-8\"),\n        },\n    )\n    assert response.status_code == 403\n    assert response.headers[\"Content-Type\"] == \"application/json\"\n\n\n@pytest.mark.settings(backwards_compat_unauthn=True)\ndef test_http_auth_no_authentication(client, get_message):\n    response = client.get(\"/http\", headers={})\n    assert response.status_code == 401\n    assert b\"<h1>Unauthorized</h1>\" in response.data\n    assert \"WWW-Authenticate\" in response.headers\n    assert 'Basic realm=\"Login Required\"' == response.headers[\"WWW-Authenticate\"]\n\n\n@pytest.mark.settings(backwards_compat_unauthn=False)\ndef test_http_auth_no_authentication_json(client, get_message):\n    response = client.get(\"/http\", headers={\"accept\": \"application/json\"})\n    assert response.status_code == 401\n    assert response.json[\"response\"][\"error\"].encode(\"utf-8\") == get_message(\n        \"UNAUTHENTICATED\"\n    )\n    assert response.headers[\"Content-Type\"] == \"application/json\"\n    assert \"WWW-Authenticate\" not in response.headers\n\n\n@pytest.mark.settings(backwards_compat_unauthn=True)\ndef test_invalid_http_auth_invalid_username(client):\n    response = client.get(\n        \"/http\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"bogus:bogus\").decode(\"utf-8\")\n        },\n    )\n    assert b\"<h1>Unauthorized</h1>\" in response.data\n    assert \"WWW-Authenticate\" in response.headers\n    assert 'Basic realm=\"Login Required\"' == response.headers[\"WWW-Authenticate\"]\n\n\n@pytest.mark.settings(backwards_compat_unauthn=False)\ndef test_invalid_http_auth_invalid_username_json(client, get_message):\n    # While Basic auth is allowed with JSON - we never expect a WWW-Authenticate\n    # header - since that is captured by most browsers and they pop up a\n    # login form.\n    response = client.get(\n        \"/http\",\n        headers={\n            \"accept\": \"application/json\",\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"bogus:bogus\").decode(\"utf-8\"),\n        },\n    )\n    assert response.status_code == 401\n    assert response.json[\"response\"][\"error\"].encode(\"utf-8\") == get_message(\n        \"UNAUTHENTICATED\"\n    )\n    assert response.headers[\"Content-Type\"] == \"application/json\"\n    assert \"WWW-Authenticate\" not in response.headers\n\n\n@pytest.mark.settings(backwards_compat_unauthn=True)\ndef test_invalid_http_auth_bad_password(client):\n    response = client.get(\n        \"/http\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"joe@lp.com:bogus\").decode(\"utf-8\")\n        },\n    )\n    assert b\"<h1>Unauthorized</h1>\" in response.data\n    assert \"WWW-Authenticate\" in response.headers\n    assert 'Basic realm=\"Login Required\"' == response.headers[\"WWW-Authenticate\"]\n\n\n@pytest.mark.settings(backwards_compat_unauthn=True)\ndef test_custom_http_auth_realm(client):\n    response = client.get(\n        \"/http_custom_realm\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"joe@lp.com:bogus\").decode(\"utf-8\")\n        },\n    )\n    assert b\"<h1>Unauthorized</h1>\" in response.data\n    assert \"WWW-Authenticate\" in response.headers\n    assert 'Basic realm=\"My Realm\"' == response.headers[\"WWW-Authenticate\"]\n\n\ndef test_multi_auth_basic(client):\n    response = client.get(\n        \"/multi_auth\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"joe@lp.com:password\").decode(\"utf-8\")\n        },\n    )\n    assert b\"Basic\" in response.data\n\n    response = client.get(\"/multi_auth\")\n    # Default unauthn with basic is to return 401 with WWW-Authenticate Header\n    # so that browser pops up a username/password dialog\n    assert response.status_code == 401\n    assert \"WWW-Authenticate\" in response.headers\n\n\n@pytest.mark.settings(backwards_compat_unauthn=True)\ndef test_multi_auth_basic_invalid(client):\n    response = client.get(\n        \"/multi_auth\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"bogus:bogus\").decode(\"utf-8\")\n        },\n    )\n    assert b\"<h1>Unauthorized</h1>\" in response.data\n    assert \"WWW-Authenticate\" in response.headers\n    assert 'Basic realm=\"Login Required\"' == response.headers[\"WWW-Authenticate\"]\n\n    response = client.get(\"/multi_auth\")\n    assert response.status_code == 401\n\n\ndef test_multi_auth_token(client):\n    response = json_authenticate(client)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    response = client.get(\"/multi_auth?auth_token=\" + token)\n    assert b\"Token\" in response.data\n\n\ndef test_multi_auth_session(client):\n    authenticate(client)\n    response = client.get(\"/multi_auth\")\n    assert b\"Session\" in response.data\n\n\ndef test_authenticated_loop(client):\n    # If user is already authenticated say via session, and then hits an endpoint\n    # protected with @auth_token_required() - then they will be redirected to the login\n    # page which will simply note the current user is already logged in and redirect\n    # to POST_LOGIN_VIEW. Between 3.3.0 and 3.4.4 - this redirect would honor the 'next'\n    # parameter - thus redirecting back to the endpoint that caused the redirect in the\n    # first place - thus an infinite loop.\n    authenticate(client)\n\n    response = client.get(\"/token\", follow_redirects=True)\n    assert response.status_code == 200\n    assert b\"Home Page\" in response.data\n\n\ndef test_user_deleted_during_session_reverts_to_anonymous_user(app, client):\n    authenticate(client)\n\n    with app.test_request_context(\"/\"):\n        user = app.security.datastore.find_user(email=\"matt@lp.com\")\n        app.security.datastore.delete_user(user)\n        app.security.datastore.commit()\n\n    response = client.get(\"/\")\n    assert b\"Hello matt@lp.com\" not in response.data\n\n\ndef test_remember_token(client):\n    response = authenticate(client, follow_redirects=False)\n    client.cookie_jar.clear_session_cookies()\n    response = client.get(\"/profile\")\n    assert b\"profile\" in response.data\n\n\ndef test_request_loader_does_not_fail_with_invalid_token(client):\n    c = Cookie(\n        version=0,\n        name=\"remember_token\",\n        value=\"None\",\n        port=None,\n        port_specified=False,\n        domain=\"www.example.com\",\n        domain_specified=False,\n        domain_initial_dot=False,\n        path=\"/\",\n        path_specified=True,\n        secure=False,\n        expires=None,\n        discard=True,\n        comment=None,\n        comment_url=None,\n        rest={\"HttpOnly\": None},\n        rfc2109=False,\n    )\n\n    client.cookie_jar.set_cookie(c)\n    response = client.get(\"/\")\n    assert b\"BadSignature\" not in response.data\n\n\ndef test_sending_auth_token_with_json(client):\n    response = json_authenticate(client)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    data = '{\"auth_token\": \"%s\"}' % token\n    response = client.post(\n        \"/token\", data=data, headers={\"Content-Type\": \"application/json\"}\n    )\n    assert b\"Token Authentication\" in response.data\n\n\ndef test_json_not_dict(client):\n    response = client.post(\n        \"/json\",\n        data=json.dumps([\"thing1\", \"thing2\"]),\n        headers={\"Content-Type\": \"application/json\"},\n    )\n    assert response.status_code == 200\n\n\ndef test_login_info(client):\n    # Make sure we can get user info when logged in already.\n\n    json_authenticate(client)\n    response = client.get(\"/login\", headers={\"Content-Type\": \"application/json\"})\n    assert response.status_code == 200\n    assert response.json[\"response\"][\"user\"][\"id\"] == \"1\"\n    assert \"last_update\" in response.json[\"response\"][\"user\"]\n\n    response = client.get(\"/login\", headers={\"Accept\": \"application/json\"})\n    assert response.status_code == 200\n    assert response.json[\"response\"][\"user\"][\"id\"] == \"1\"\n    assert \"last_update\" in response.json[\"response\"][\"user\"]\n\n\n@pytest.mark.registerable()\n@pytest.mark.settings(post_login_view=\"/anon_required\")\ndef test_anon_required(client, get_message):\n    \"\"\" If logged in, should get 'anonymous_user_required' redirect \"\"\"\n    response = authenticate(client, follow_redirects=False)\n    response = client.get(\"/register\")\n    assert \"location\" in response.headers\n    assert \"/anon_required\" in response.location\n\n\n@pytest.mark.registerable()\n@pytest.mark.settings(post_login_view=\"/anon_required\")\ndef test_anon_required_json(client, get_message):\n    \"\"\" If logged in, should get 'anonymous_user_required' response \"\"\"\n    authenticate(client, follow_redirects=False)\n    response = client.get(\"/register\", headers={\"Accept\": \"application/json\"})\n    assert response.status_code == 400\n    assert response.json[\"response\"][\"error\"].encode(\"utf-8\") == get_message(\n        \"ANONYMOUS_USER_REQUIRED\"\n    )\n\n\n@pytest.mark.settings(security_hashing_schemes=[\"sha256_crypt\"])\n@pytest.mark.skip\ndef test_auth_token_speed(app, client_nc):\n    # To run with old algorithm you have to comment out fs_uniquifier check in UserMixin\n    import timeit\n\n    response = json_authenticate(client_nc)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n\n    def time_get():\n        rp = client_nc.get(\n            \"/login\",\n            data={},\n            headers={\"Content-Type\": \"application/json\", \"Authentication-Token\": token},\n        )\n        assert rp.status_code == 200\n\n    t = timeit.timeit(time_get, number=50)\n    print(\"Time for 50 iterations: \", t)\n\n\ndef test_change_uniquifier(app, client_nc):\n    # make sure that existing token no longer works once we change the uniquifier\n\n    response = json_authenticate(client_nc)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    verify_token(client_nc, token)\n\n    # now change uniquifier\n    with app.test_request_context(\"/\"):\n        user = app.security.datastore.find_user(email=\"matt@lp.com\")\n        app.security.datastore.reset_user_access(user)\n        app.security.datastore.commit()\n\n    verify_token(client_nc, token, status=401)\n\n    # get new token and verify it works\n    response = json_authenticate(client_nc)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    verify_token(client_nc, token)\n\n\ndef test_token_query(in_app_context):\n    # Verify that when authenticating with auth token (and not session)\n    # that there is just one DB query to get user.\n    app = in_app_context\n    populate_data(app)\n    client_nc = app.test_client(use_cookies=False)\n\n    response = json_authenticate(client_nc)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    current_nqueries = get_num_queries(app.security.datastore)\n\n    response = client_nc.get(\n        \"/token\",\n        headers={\"Content-Type\": \"application/json\", \"Authentication-Token\": token},\n    )\n    assert response.status_code == 200\n    end_nqueries = get_num_queries(app.security.datastore)\n    assert current_nqueries is None or end_nqueries == (current_nqueries + 1)\n\n\ndef test_session_query(in_app_context):\n    # Verify that when authenticating with auth token (but also sending session)\n    # that there are 2 DB queries to get user.\n    # This is since the session will load one - but auth_token_required needs to\n    # verify that the TOKEN is valid (and it is possible that the user_id in the\n    # session is different that the one in the token (huh?)\n    app = in_app_context\n    populate_data(app)\n    client = app.test_client()\n\n    response = json_authenticate(client)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    current_nqueries = get_num_queries(app.security.datastore)\n\n    response = client.get(\n        \"/token\",\n        headers={\"Content-Type\": \"application/json\", \"Authentication-Token\": token},\n    )\n    assert response.status_code == 200\n    end_nqueries = get_num_queries(app.security.datastore)\n    assert current_nqueries is None or end_nqueries == (current_nqueries + 2)\n"], "fixing_code": ["Flask-Security Changelog\n========================\n\nHere you can see the full list of changes between each Flask-Security release.\n\nVersion 4.0.0\n-------------\n\nRelease Target 2020\n\n- Removal of python 2.7 and <3.6 support\n- Removal of token caching feature (a relatively new feature that has some systemic issues)\n- Other possible breaking changes tracked `here`_\n\n.. _here: https://github.com/Flask-Middleware/flask-security/issues/85\n\nVersion 3.4.5\n--------------\n\nRelease January x, 2021\n\nSecurity Vulnerability Fix.\n\nTwo CSRF vulnerabilities were reported: `qrcode`_ and `login`_. This release\nfixes the more severe of the 2 - the /login vulnerability. The QRcode issue\nhas a much smaller risk profile since a) it is only for two-factor authentication\nusing an authenticator app b) the qrcode is only available during the time\nthe user is first setting up their authentication app and c) there isn't\nan obvious backward compatible fix.\nThis issue has been fixed in 4.0.\n\n.. _qrcode: https://github.com/Flask-Middleware/flask-security/issues/418\n.. _login: https://github.com/Flask-Middleware/flask-security/issues/421\n\nFixed\n+++++\n\n- (:issue:`421`) GET on /login and /change could return the callers authentication_token. This is a security\n  concern since GETs don't have CSRF protection. This bug was introduced in 3.3.0.\n\nBackwards Compatibility Concerns\n++++++++++++++++++++++++++++++++\n\n- (:issue:`421`) Fix CSRF vulnerability on /login and /change that could return the callers authentication token.\n  Now, callers can only get the authentication token on successful POST calls.\n\n\nVersion 3.4.4\n--------------\n\nReleased July 26, 2020\n\nBug/regression fixes.\n\nFixed\n+++++\n\n- (:issue:`359`) Basic Auth broken. When the unauthenticated handler was changed to provide a more\n  uniform/consistent response - it broke using Basic Auth from a browser, since it always redirected rather than\n  returning 401. Now, if the response headers contain  ``WWW-Authenticate``\n  (which is set if ``basic`` @auth_required method is used), a 401 is returned. See below\n  for backwards compatibility concerns.\n\n- (:pr:`362`) As part of figuring out issue 359 - a redirect loop was found. In release 3.3.0 code was put\n  in to redirect to :py:data:`SECURITY_POST_LOGIN_VIEW` when GET or POST was called and the caller was already authenticated. The\n  method used would honor the request ``next`` query parameter. This could cause redirect loops. The pre-3.3.0 behavior\n  of redirecting to :py:data:`SECURITY_POST_LOGIN_VIEW` and ignoring the ``next`` parameter has been restored.\n\n- (:issue:`347`) Fix peewee. Turns out - due to lack of unit tests - peewee hasn't worked since 'permissions' were added in 3.3.\n  Furthermore, changes in 3.4 around get_id and alternative tokens also didn't work since peewee defines its own get_id.\n\n- (:pr:`xx`) Backport the reset_access CLI command from 4.0 - this is really useful for administrators.\n\nCompatibility Concerns\n++++++++++++++++++++++\n\nIn 3.3.0, :func:`.auth_required` was changed to add a default argument if none was given. The default\ninclude all current methods - ``session``, ``token``, and ``basic``. However ``basic`` really isn't like the others\nand requires that we send back a ``WWW-Authenticate`` header if authentication fails (and return a 401 and not redirect).\n``basic`` has been removed from the default set and must once again be explicitly requested.\n\nVersion 3.4.3\n-------------\n\nReleased June 14, 2020\n\nMinor fixes for a regression and a couple other minor changes\n\nFixed\n+++++\n\n- (:issue:`340`) Fix regression where tf_phone_number was required, even if SMS wasn't configured.\n- (:pr:`342`) Pick up some small documentation fixes from 4.0.0.\n\nVersion 3.4.2\n-------------\n\nReleased May 2, 2020\n\nOnly change is to move repo to the Flask-Middleware github organization.\n\nVersion 3.4.1\n--------------\n\nReleased April 22, 2020\n\nFix a bunch of bugs in new unified sign in along with a couple other major issues.\n\nFixed\n+++++\n- (:issue:`298`) Alternative ID feature ran afoul of postgres/psycopg2 finickiness.\n- (:issue:`300`) JSON 401 responses had WWW-Authenticate Header attached - that caused\n  browsers to pop up their own login/password form. Not what applications want.\n- (:issue:`280`) Allow admin/api to setup TFA (and unified sign in) out of band.\n  Please see :meth:`.UserDatastore.tf_set`, :meth:`.UserDatastore.tf_reset`,\n  :meth:`.UserDatastore.us_set`, :meth:`.UserDatastore.us_reset` and\n  :meth:`.UserDatastore.reset_user_access`.\n- (:pr:`305`) We used form._errors which wasn't very pythonic, and it was\n  removed in WTForms 2.3.0.\n- (:pr:`310`) WTForms 2.3.0 made email_validator optional - we need it.\n\n\nVersion 3.4.0\n-------------\n\nReleased March 31, 2020\n\nFeatures\n++++++++\n- (:pr:`257`) Support a unified sign in feature. Please see :ref:`unified-sign-in`.\n- (:pr:`265`) Add phone number validation class. This is used in both unified sign in\n  as well as two-factor when using ``sms``.\n- (:pr:`274`) Add support for 'freshness' of caller's authentication. This permits endpoints\n  to be additionally protected by ensuring a recent authentication.\n- (:issue:`99`, :issue:`195`) Support pluggable password validators. Provide a default\n  validator that offers complexity and breached support.\n- (:issue:`266`) Provide interface to two-factor send_token so that applications\n  can provide error mitigation. Defaults to returning errors if can't send the verification code.\n- (:pr:`247`) Updated all-inclusive data models (fsqlaV2). Add fields necessary for the new unified sign in feature\n  and changed 'username' to be unique (but not required).\n- (:pr:`245`) Use fs_uniquifier as the default Flask-Login 'alternative token'. Basically\n  this means that changing the fs_uniquifier will cause outstanding auth tokens, session and remember me\n  cookies to be invalidated. So if an account gets compromised, an admin can easily stop access. Prior to this\n  cookies were storing the 'id' which is the user's primary key - difficult to change! (kishi85)\n\nFixed\n+++++\n- (:issue:`273`) Don't allow reset password for accounts that are disabled.\n- (:issue:`282`) Add configuration that disallows GET for logout. Allowing GET can\n  cause some denial of service issues. The default still allows GET for backwards\n  compatibility. (kantorii)\n- (:issue:`258`) Reset password wasn't integrated into the two-factor feature and therefore\n  two-factor auth could be bypassed.\n- (:issue:`254`) Allow lists and sets as underlying permissions. (pffs)\n- (:issue:`251`) Allow a registration form to have additional fields that aren't part of the user model\n  that are just passed to the user_registered.send signal, where the application can perform arbitrary\n  additional actions required during registration. (kuba-lilz)\n- (:issue:`249`) Add configuration to disable the 'role-joining' optimization for SQLAlchemy. (pffs)\n- (:issue:`238`) Fix more issues with atomically setting the new TOTP secret when setting up two-factor. (kishi85)\n- (:pr:`240`) Fix Quart Compatibility. (ristellise)\n- (:issue:`232`) CSRF Cookie not being set when using 'Remember Me' cookie to re-sign in. (kishi85)\n- (:issue:`229`) Two-factor enabled accounts didn't work with the Remember Me feature. (kishi85)\n\nAs part of adding unified sign in, there were many similarities with two-factor.\nSome refactoring was done to unify naming, configuration variables etc.\nIt should all be backwards compatible.\n\n- In TWO_FACTOR_ENABLED_METHODS \"mail\" was changed to \"email\". \"mail\" will still\n  be honored if already stored in DB. Also \"google_authenticator\" is now just \"authenticator\".\n- TWO_FACTOR_SECRET, TWO_FACTOR_URI_SERVICE_NAME, TWO_FACTOR_SMS_SERVICE, and TWO_FACTOR_SMS_SERVICE_CONFIG\n  have all been deprecated in favor of names that are the same for two-factor and unified sign in.\n\nOther changes with possible backwards compatibility issues:\n\n- ``/tf-setup`` never did any phone number validation. Now it does.\n- ``two_factor_setup.html`` template - the chosen_method check was changed to ``email``.\n  If you have your own custom template - be sure make that change.\n\nVersion 3.3.3\n-------------\n\nReleased February 11, 2020\n\nMinor changes required to work with latest released Werkzeug and Flask-Login.\n\nVersion 3.3.2\n-------------\n\nReleased December 7, 2019\n\n- (:issue:`215`) Fixed 2FA totp secret regeneration bug (kishi85)\n- (:issue:`172`) Fixed 'next' redirect error in login view\n- (:issue:`221`) Fixed regressions in login view when already authenticated user\n  again does a GET or POST.\n- (:issue:`219`) Added example code for unit testing FS protected routes.\n- (:issue:`223`) Integrated two-factor auth into registration and confirmation.\n\nThanks to kuba-lilz and kishi85 for finding and providing detailed issue reports.\n\nIn Flask-Security 3.3.0 the login view was changed to allow already authenticated\nusers to access the view. Prior to 3.3.0, the login view was protected with\n@anonymous_user_required - so any access (via GET or POST) would simply redirect\nthe user to the ``POST_LOGIN_VIEW``. With the 3.3.0 changes, both GET and POST\nbehaved oddly. GET simply returned the login template, and POST attempted to\nlog out the current user, and log in the new user. This was problematic since\nthis couldn't possibly work with CSRF.\nThe old behavior has been restored, with the subtle change that older Flask-Security\nreleases did not look at \"next\" in the form or request for the redirect,\nand now, all redirects from the login view will honor \"next\" (N.B. see 3.4.4 - the\nhandling of \"next\" has been removed due to redirect loops).\n\nVersion 3.3.1\n-------------\n\nReleased November 16, 2019\n\n- (:pr:`197`) Add `Quart <https://gitlab.com/pgjones/quart/>`_ compatibility (Ristellise)\n- (:pr:`194`) Add Python 3.8 support into CI (jdevera)\n- (:pr:`196`) Improve docs around Single Page Applications and React (acidjunk)\n- (:issue:`201`) fsqla model was added to __init__.py making Sqlalchemy a required package.\n  That is wrong and has been removed. Applications must now explicitly import from ``flask_security.models``\n- (:pr:`204`) Fix/improve examples and quickstart to show one MUST call hash_password() when\n  creating users programmatically. Also show real SECRET_KEYs and PASSWORD_SALTs and how to generate them.\n- (:pr:`209`) Add argon2 as an allowable password hash.\n- (:pr:`210`) Improve integration with Flask-Admin. Actually - this PR improves localization support\n  by adding a method ``_fsdomain`` to jinja2's global environment. Added documentation\n  around localization.\n\n\nVersion 3.3.0\n-------------\n\nReleased September 26, 2019\n\n**There are several default behavior changes that might break existing applications.\nMost have configuration variables that restore prior behavior**.\n\n**If you use Authentication Tokens (rather than session cookies) you MUST make a (small) change.\nPlease see below for details.**\n\n- (:pr:`120`) Native support for Permissions as part of Roles. Endpoints can be\n  protected via permissions that are evaluated based on role(s) that the user has.\n- (:issue:`126`, :issue:`93`, :issue:`96`) Revamp entire CSRF handling. This adds support for Single Page Applications\n  and having CSRF protection for browser(session) authentication but ignored for\n  token based authentication. Add extensive documentation about all the options.\n- (:issue:`156`) Token authentication is slow. Please see below for details on how to enable a new, fast implementation.\n- (:issue:`130`) Enable applications to provide their own :meth:`.render_json` method so that they can create\n  unified API responses.\n- (:issue:`121`) Unauthorization callback not quite right. Split into 2 different callbacks - one for\n  unauthorized and one for unauthenticated. Made default unauthenticated handler use Flask-Login's unauthenticated\n  method to make everything uniform. Extensive documentation added. `.Security.unauthorized_callback` has been deprecated.\n- (:pr:`120`) Add complete User and Role model mixins that support all features. Modify tests and Quickstart documentation\n  to show how to use these. Please see :ref:`responsetopic` for details.\n- Improve documentation for :meth:`.UserDatastore.create_user` to make clear that hashed password\n  should be passed in.\n- Improve documentation for :class:`.UserDatastore` and :func:`.verify_and_update_password`\n  to make clear that caller must commit changes to DB if using a session based datastore.\n- (:issue:`122`) Clarify when to use ``confirm_register_form`` rather than ``register_form``.\n- Fix bug in 2FA that didn't commit DB after using `verify_and_update_password`.\n- Fix bug(s) in UserDatastore where changes to user ``active`` flag weren't being added to DB.\n- (:issue:`127`) JSON response was failing due to LazyStrings in error response.\n- (:issue:`117`) Making a user inactive should stop all access immediately.\n- (:issue:`134`) Confirmation token can no longer be reused. Added\n  *SECURITY_AUTO_LOGIN_AFTER_CONFIRM* option for applications that don't want the user\n  to be automatically logged in after confirmation (defaults to True - existing behavior).\n- (:issue:`159`) The ``/register`` endpoint returned the Authentication Token even though\n  confirmation was required. This was a huge security hole - it has been fixed.\n- (:issue:`160`) The 2FA totp_secret would be regenerated upon submission, making QRCode not work. (malware-watch)\n- (:issue:`166`) `default_render_json` uses ``flask.make_response`` and forces the Content-Type to JSON for generating the response (koekie)\n- (:issue:`166`) *SECURITY_MSG_UNAUTHENTICATED* added to the configuration.\n- (:pr:`168`) When using the @auth_required or @auth_token_required decorators, the token\n  would be verified twice, and the DB would be queried twice for the user. Given how slow\n  token verification is - this was a significant issue. That has been fixed.\n- (:issue:`84`) The :func:`.anonymous_user_required` was not JSON friendly - always\n  performing a redirect. Now, if the request 'wants' a JSON response - it will receive a 400 with an error\n  message defined by *SECURITY_MSG_ANONYMOUS_USER_REQUIRED*.\n- (:pr:`145`) Improve 2FA templates to that they can be localized. (taavie)\n- (:issue:`173`) *SECURITY_UNAUTHORIZED_VIEW* didn't accept a url (just an endpoint). All other view\n  configurations did. That has been fixed.\n\nPossible compatibility issues\n+++++++++++++++++++++++++++++\n\n- (:pr:`164`) In prior releases, the Authentication Token was returned as part of the JSON response to each\n  successful call to `/login`, `/change`, or `/reset/{token}` API call. This is not a great idea since\n  for browser-based UIs that used JSON request/response, and used session based authentication - they would\n  be sent this token - even though it was likely ignored. Since these tokens by default have no expiration time\n  this exposed a needless security hole. The new default behavior is to ONLY return the Authentication Token from those APIs\n  if the query param ``include_auth_token`` is added to the request. Prior behavior can be restored by setting\n  the *SECURITY_BACKWARDS_COMPAT_AUTH_TOKEN* configuration variable.\n\n- (:pr:`120`) :class:`.RoleMixin` now has a method :meth:`.get_permissions` which is called as part\n  each request to add Permissions to the authenticated user. It checks if the RoleModel\n  has a property ``permissions`` and assumes it is a comma separated string of permissions.\n  If your model already has such a property this will likely fail. You need to override :meth:`.get_permissions`\n  and simply return an emtpy set.\n\n- (:issue:`121`) Changes the default (failure) behavior for views protected with @auth_required, @token_auth_required,\n  or @http_auth_required. Before, a 401 was returned with some stock html. Now, Flask-Login.unauthorized() is\n  called (the same as @login_required does) - which by default redirects to a login page/view. If you had provided your own\n  `.Security.unauthorized_callback` there are no changes - that will still be called first. The old default\n  behavior can be restored by setting *SECURITY_BACKWARDS_COMPAT_UNAUTHN* to True. Please see :ref:`responsetopic` for details.\n\n- (:issue:`127`) Fix for LazyStrings in json error response. The fix for this has Flask-Security registering\n  its own JsonEncoder on its blueprint. If you registered your own JsonEncoder for your app - it will no\n  longer be called when serializing responses to Flask-Security endpoints. You can register your JsonEncoder\n  on Flask-Security's blueprint by sending it as `json_encoder_cls` as part of initialization. Be aware that your\n  JsonEncoder needs to handle LazyStrings (see speaklater).\n\n- (:issue:`84`) Prior to this fix - anytime the decorator :func:`.anonymous_user_required` failed, it caused a redirect to\n  the post_login_view. Now, if the caller wanted a JSON response, it will return a 400.\n\n- (:issue:`156`) Faster Authentication Token introduced the following non-backwards compatible behavior change:\n\n    * Since the old Authentication Token algorithm used the (hashed) user's password, those tokens would be invalidated\n      whenever the user changed their password. This is not likely to be what most users expect. Since the new\n      Authentication Token algorithm doesn't refer to the user's password, changing the user's password won't invalidate\n      outstanding Authentication Tokens. The method :meth:`.UserDatastore.set_uniquifier` can be used by an administrator\n      to change a user's ``fs_uniquifier`` - but nothing the user themselves can do to invalidate their Authentication Tokens.\n      Setting the *SECURITY_BACKWARDS_COMPAT_AUTH_TOKEN_INVALIDATE* configuration variable will cause the user's ``fs_uniquifier`` to\n      be changed when they change their password, thus restoring prior behavior.\n\n\nNew fast authentication token implementation\n++++++++++++++++++++++++++++++++++++++++++++\nCurrent auth tokens are slow because they use the user's password (hashed) as a uniquifier (the\nuser id isn't really enough since it might be reused). This requires checking the (hashed) password against\nwhat is in the token on EVERY request - however hashing is (on purpose) slow. So this can add almost a whole second\nto every request.\n\nTo solve this, a new attribute in the User model was added - ``fs_uniquifier``. If this is present in your\nUser model, then it will be used instead of the password for ensuring the token corresponds to the correct user.\nThis is very fast. If that attribute is NOT present - then the behavior falls back to the existing (slow) method.\n\n\nDB Migration\n~~~~~~~~~~~~\n\nTo use the new UserModel mixins or to add the column ``user.fs_uniquifier`` to speed up token\nauthentication, a schema AND data migration needs to happen. If you are using Alembic the schema migration is\neasy - but you need to add ``fs_uniquifier`` values to all your existing data. You can\nadd code like this to your migrations::update method::\n\n    # be sure to MODIFY this line to make nullable=True:\n    op.add_column('user', sa.Column('fs_uniquifier', sa.String(length=64), nullable=True))\n\n    # update existing rows with unique fs_uniquifier\n    import uuid\n    user_table = sa.Table('user', sa.MetaData(), sa.Column('id', sa.Integer, primary_key=True),\n                          sa.Column('fs_uniquifier', sa.String))\n    conn = op.get_bind()\n    for row in conn.execute(sa.select([user_table.c.id])):\n        conn.execute(user_table.update().values(fs_uniquifier=uuid.uuid4().hex).where(user_table.c.id == row['id']))\n\n    # finally - set nullable to false\n    op.alter_column('user', 'fs_uniquifier', nullable=False)\n\n\nVersion 3.2.0\n-------------\n\nReleased June 26th 2019\n\n- (opr #839) Support caching of authentication token (eregnier).\n  This adds a new configuration variable *SECURITY_USE_VERIFY_PASSWORD_CACHE*\n  which enables a cache (with configurable TTL) for authentication tokens.\n  This is a big performance boost for those accessing Flask-Security via token\n  as opposed to session.\n- (:pr:`81`) Support for JSON/Single-Page-Application. This completes support\n  for non-form based access to Flask-Security. See PR for details. (jwag956)\n- (:pr:`79` Add POST logout to enhance JSON usage (jwag956).\n- (:pr:`73`) Fix get_user for various DBs (jwag956).\n  This is a more complete fix than in opr #633.\n- (:pr:`78`, :pr:`103`) Add formal openapi API spec (jwag956).\n- (:pr:`86`, :pr:`94`, :pr:`98`, :pr:`101`, :pr:`104`) Add Two-factor authentication (opr #842) (baurt, jwag956).\n- (:issue:`108`) Fix form field label translations (jwag956)\n- (:issue:`115`) Fix form error message translations (upstream #801) (jwag956)\n- (:issue:`87`) Convert entire repo to Black (baurt)\n\nVersion 3.1.0\n-------------\n\nReleased never\n\n- (opr #487) Use Security.render_template in mails too (noirbizarre)\n- (opr #679) Optimize DB accesses by using an SQL JOIN when retrieving a user. (nfvs)\n- (opr #697) Add base template to security templates (grihabor)\n- (opr #633) datastore: get user by numeric identity attribute (jirikuncar)\n- (opr #703) bugfix: support application factory pattern (briancappello)\n- (opr #714) Make SECURITY_PASSWORD_SINGLE_HASH a list of scheme ignoring double hash (noirbizarre )\n- (opr #717) Allow custom login_manager to be passed in to Flask-Security (jaza)\n- (opr #727) Docs for OAauth2-based custom login manager (jaza)\n- (opr #779) core: make the User model check the password (mklassen)\n- (opr #730) Customizable send_mail (abulte)\n- (opr #726) core: fix default for UNAUTHORIZED_VIEW (jirijunkar)\n\nThese should all be backwards compatible.\n\nPossible compatibility issues:\n\n- #487 - prior to this, render_template() was overiddable for views, but not\n  emails. If anyone actually relied on this behavior, this has changed.\n- #703 - get factory pattern working again. There was a very complex dance between\n  Security() instantiation and init_app regarding kwargs. This has been rationalized (hopefully).\n- #679 - SqlAlchemy SQL improvement. It is possible you will get the following error::\n\n    Got exception during processing: <class 'sqlalchemy.exc.InvalidRequestError'> -\n    'User.roles' does not support object population - eager loading cannot be applied.\n\n  This is likely solveable by removing ``lazy='dynamic'`` from your Role definition.\n\n\nPerformance improvements:\n\n- #679 - for sqlalchemy, for each request, there would be 2 DB accesses - now\n  there is one.\n\nTesting:\nFor datastores operations, Sqlalchemy, peewee, pony were all tested against sqlite,\npostgres, and mysql real databases.\n\n\nVersion 3.0.2\n-------------\n\nReleased April 30th 2019\n\n- (opr #439) HTTP Auth respects SECURITY_USER_IDENTITY_ATTRIBUTES (pnpnpn)\n- (opr #660) csrf_enabled` deprecation fix (abulte)\n- (opr #671) Fix referrer loop in _get_unauthorized_view(). (nfvs)\n- (opr #675) Fix AttributeError in _request_loader (sbagan)\n- (opr #676) Fix timing attack on login form (cript0nauta)\n- (opr #683) Close db connection after running tests (reambus)\n- (opr #691) docs: add password salt to SQLAlchemy app example (KshitijKarthick)\n- (opr #692) utils: fix incorrect email sender type (switowski)\n- (opr #696) Fixed broken Click link (williamhatcher)\n- (opr #722) Fix password recovery confirmation on deleted user (kesara)\n- (opr #747) Update login_user.html (rickwest)\n- (opr #748) i18n: configurable the dirname domain (escudero)\n- (opr #835) adds relevant user to reset password form for validation purposes (fuhrysteve)\n\nThese are bug fixes and a couple very small additions.\nNo change in behavior and no new functionality.\n'opr#' is the original pull request from https://github.com/mattupstate/flask-security\n\nVersion 3.0.1\n--------------\n\nReleased April 28th 2019\n\n- Support 3.7 as part of CI\n- Rebrand to this forked repo\n- (#15) Build docs and translations as part of CI\n- (#17) Move to msgcheck from pytest-translations\n- (opr #669) Fix for Read the Docs (jirikuncar)\n- (opr #710) Spanish translation (maukoquiroga)\n- (opr #712) i18n: improvements of German translations (eseifert)\n- (opr #713) i18n: add Portuguese (Brazilian) translation (dinorox)\n- (opr #719) docs: fix anchor links and typos (kesara)\n- (opr #751) i18n: fix missing space (abulte)\n- (opr #762) docs: fixed proxy import (lsmith)\n- (opr #767) Update customizing.rst (allanice001)\n- (opr #776) i18n: add Portuguese (Portugal) translation (micael-grilo)\n- (opr #791) Fix documentation for mattupstate#781 (fmerges)\n- (opr #796) Chinese translations (Steinkuo)\n- (opr #808) Clarify that a commit is needed after login_user (christophertull)\n- (opr #823) Add Turkish translation (Admicos)\n- (opr #831) Catalan translation (miceno)\n\nThese are all documentation and i18n changes - NO code changes. All except the last 3 were accepted and reviewed by\nthe original Flask-Security team.\nThanks as always to all the contributors.\n\nVersion 3.0.0\n-------------\n\nReleased May 29th 2017\n\n- Fixed a bug when user clicking confirmation link after confirmation\n  and expiration causes confirmation email to resend. (see #556)\n- Added support for I18N.\n- Added options `SECURITY_EMAIL_PLAINTEXT` and `SECURITY_EMAIL_HTML`\n  for sending respecively plaintext and HTML version of email.\n- Fixed validation when missing login information.\n- Fixed condition for token extraction from JSON body.\n- Better support for universal bdist wheel.\n- Added port of CLI using Click configurable using options\n  `SECURITY_CLI_USERS_NAME` and `SECURITY_CLI_ROLES_NAME`.\n- Added new configuration option `SECURITY_DATETIME_FACTORY` which can\n  be used to force default timezone for newly created datetimes.\n  (see mattupstate/flask-security#466)\n- Better IP tracking if using Flask 0.12.\n- Renamed deprecated Flask-WFT base form class.\n- Added tests for custom forms configured using app config.\n- Added validation and tests for next argument in logout endpoint. (see #499)\n- Bumped minimal required versions of several packages.\n- Extended test matric on Travis CI for minimal and released package versions.\n- Added of .editorconfig and forced tests for code style.\n- Fixed a security bug when validating a confirmation token, also checks\n  if the email that the token was created with matches the user's current email.\n- Replaced token loader with request loader.\n- Changed trackable behavior of `login_user` when IP can not be detected from a request from 'untrackable' to `None` value.\n- Use ProxyFix instead of inspecting X-Forwarded-For header.\n- Fix identical problem with app as with datastore.\n- Removed always-failing assertion.\n- Fixed failure of init_app to set self.datastore.\n- Changed to new style flask imports.\n- Added proper error code when returning JSON response.\n- Changed obsolette Required validator from WTForms to DataRequired. Bumped Flask-WTF to 0.13.\n- Fixed missing `SECURITY_SUBDOMAIN` in config docs.\n- Added cascade delete in PeeweeDatastore.\n- Added notes to docs about `SECURITY_USER_IDENTITY_ATTRIBUTES`.\n- Inspect value of `SECURITY_UNAUTHORIZED_VIEW`.\n- Send password reset instructions if an attempt has expired.\n- Added \"Forgot password?\" link to LoginForm description.\n- Upgraded passlib, and removed bcrypt version restriction.\n- Removed a duplicate line ('retype_password': 'Retype Password') in forms.py.\n- Various documentation improvement.\n\nVersion 1.7.5\n-------------\n\nReleased December 2nd 2015\n\n- Added `SECURITY_TOKEN_MAX_AGE` configuration setting\n- Fixed calls to `SQLAlchemyUserDatastore.get_user(None)` (this now returns `False` instead of raising a `TypeError`\n- Fixed URL generation adding extra slashes in some cases (see GitHub #343)\n- Fixed handling of trackable IP addresses when the `X-Forwarded-For` header contains multiple values\n- Include WWW-Authenticate headers in `@auth_required` authentication checks\n- Fixed error when `check_token` function is used with a json list\n- Added support for custom `AnonymousUser` classes\n- Restricted `forgot_password` endpoint to anonymous users\n- Allowed unauthorized callback to be overridden\n- Fixed issue where passwords cannot be reset if currently set to `None`\n- Ensured that password reset tokens are invalidated after use\n- Updated `is_authenticated` and `is_active` functions to support Flask-Login changes\n- Various documentation improvements\n\n\nVersion 1.7.4\n-------------\n\nReleased October 13th 2014\n\n- Fixed a bug related to changing existing passwords from plaintext to hashed\n- Fixed a bug in form validation that did not enforce case insensivitiy\n- Fixed a bug with validating redirects\n\n\nVersion 1.7.3\n-------------\n\nReleased June 10th 2014\n\n- Fixed a bug where redirection to `SECURITY_POST_LOGIN_VIEW` was not respected\n- Fixed string encoding in various places to be friendly to unicode\n- Now using `werkzeug.security.safe_str_cmp` to check tokens\n- Removed user information from JSON output on `/reset` responses\n- Added Python 3.4 support\n\n\nVersion 1.7.2\n-------------\n\nReleased May 6th 2014\n\n- Updated IP tracking to check for `X-Forwarded-For` header\n- Fixed a bug regarding the re-hashing of passwords with a new algorithm\n- Fixed a bug regarding the `password_changed` signal.\n\n\nVersion 1.7.1\n-------------\n\nReleased January 14th 2014\n\n- Fixed a bug where passwords would fail to verify when specifying a password hash algorithm\n\n\nVersion 1.7.0\n-------------\n\nReleased January 10th 2014\n\n- Python 3.3 support!\n- Dependency updates\n- Fixed a bug when `SECURITY_LOGIN_WITHOUT_CONFIRMATION = True` did not allow users to log in\n- Added `SECURITY_SEND_PASSWORD_RESET_NOTICE_EMAIL` configuraiton option to optionally send password reset notice emails\n- Add documentation for `@security.send_mail_task`\n- Move to `request.get_json` as `request.json` is now deprecated in Flask\n- Fixed a bug when using AJAX to change a user's password\n- Added documentation for select functions in the `flask_security.utils` module\n- Fixed a bug in `flask_security.forms.NextFormMixin`\n- Added `CHANGE_PASSWORD_TEMPLATE` configuration option to optionally specify a different change password template\n- Added the ability to specify addtional fields on the user model to be used for identifying the user via the `USER_IDENTITY_ATTRIBUTES` configuration option\n- An error is now shown if a user tries to change their password and the password is the same as before. The message can be customed with the `SECURITY_MSG_PASSWORD_IS_SAME` configuration option\n- Fixed a bug in `MongoEngineUserDatastore` where user model would not be updated when using the `add_role_to_user` method\n- Added `SECURITY_SEND_PASSWORD_CHANGE_EMAIL` configuration option to optionally disable password change email from being sent\n- Fixed a bug in the `find_or_create_role` method of the PeeWee datastore\n- Removed pypy tests\n- Fixed some tests\n- Include CHANGES and LICENSE in MANIFEST.in\n- A bit of documentation cleanup\n- A bit of code cleanup including removal of unnecessary utcnow call and simplification of get_max_age method\n\n\nVersion 1.6.9\n-------------\n\nReleased August 20th 2013\n\n- Fix bug in SQLAlchemy datastore's `get_user` function\n- Fix bug in PeeWee datastore's `remove_role_from_user` function\n- Fixed import error caused by new Flask-WTF release\n\n\nVersion 1.6.8\n-------------\n\nReleased August 1st 2013\n\n- Fixed bug with case sensitivity of email address during login\n- Code cleanup regarding token_callback\n- Ignore validation errors in find_user function for MongoEngineUserDatastore\n\n\nVersion 1.6.7\n-------------\n\nReleased July 11th 2013\n\n- Made password length form error message configurable\n- Fixed email confirmation bug that prevented logged in users from confirming their email\n\n\nVersion 1.6.6\n-------------\n\nReleased June 28th 2013\n\n- Fixed dependency versions\n\n\nVersion 1.6.5\n-------------\n\nReleased June 20th 2013\n\n- Fixed bug in `flask.ext.security.confirmable.generate_confirmation_link`\n\n\nVersion 1.6.4\n-------------\n\nReleased June 18th 2013\n\n- Added `SECURITY_DEFAULT_REMEMBER_ME` configuration value to unify behavior between endpoints\n- Fixed Flask-Login dependency problem\n- Added optional `next` parameter to registration endpoint, similar to that of login\n\n\nVersion 1.6.3\n-------------\n\nReleased May 8th 2013\n\n- Fixed bug in regards to imports with latest version of MongoEngine\n\n\nVersion 1.6.2\n-------------\n\nReleased April 4th 2013\n\n- Fixed bug with http basic auth\n\n\nVersion 1.6.1\n-------------\n\nReleased April 3rd 2013\n\n- Fixed bug with signals\n\n\nVersion 1.6.0\n-------------\n\nReleased March 13th 2013\n\n- Added Flask-Pewee support\n- Password hashing is now more flexible and can be changed to a different type at will\n- Flask-Login messages are configurable\n- AJAX requests must now send a CSRF token for security reasons\n- Form messages are now configurable\n- Forms can now be extended with more fields\n- Added change password endpoint\n- Added the user to the request context when successfully authenticated via http basic and token auth\n- The Flask-Security blueprint subdomain is now configurable\n- Redirects to other domains are now not allowed during requests that may redirect\n- Template paths can be configured\n- The welcome/register email can now optionally be sent to the user\n- Passwords can now contain non-latin characters\n- Fixed a bug when confirming an account but the account has been deleted\n\n\nVersion 1.5.4\n-------------\n\nReleased January 6th 2013\n\n- Fix bug in forms with `csrf_enabled` parameter not accounting attempts to login using JSON data\n\n\nVersion 1.5.3\n-------------\n\nReleased December 23rd 2012\n\n- Change dependency requirement\n\nVersion 1.5.2\n-------------\n\nReleased December 11th 2012\n\n- Fix a small bug in `flask_security.utils.login_user` method\n\nVersion 1.5.1\n-------------\n\nReleased November 26th 2012\n\n- Fixed bug with `next` form variable\n- Added better documentation regarding Flask-Mail configuration\n- Added ability to configure email subjects\n\nVersion 1.5.0\n-------------\n\nReleased October 11th 2012\n\n- Major release. Upgrading from previous versions will require a bit of work to\n  accomodate API changes. See documentation for a list of new features and for\n  help on how to upgrade.\n\nVersion 1.2.3\n-------------\n\nReleased June 12th 2012\n\n- Fixed a bug in the RoleMixin eq/ne functions\n\nVersion 1.2.2\n-------------\n\nReleased April 27th 2012\n\n- Fixed bug where `roles_required` and `roles_accepted` did not pass the next\n  argument to the login view\n\nVersion 1.2.1\n-------------\n\nReleased March 28th 2012\n\n- Added optional user model mixin parameter for datastores\n- Added CreateRoleCommand to available Flask-Script commands\n\nVersion 1.2.0\n-------------\n\nReleased March 12th 2012\n\n- Added configuration option `SECURITY_FLASH_MESSAGES` which can be set to a\n  boolean value to specify if Flask-Security should flash messages or not.\n\nVersion 1.1.0\n-------------\n\nInitial release\n", "openapi: 3.0.0\ninfo:\n  description: |\n    Default API for Flask-Security.\n\n    __N.B. This is preliminary.__\n\n    Since Flask-Security is middleware, with many possible configurations this is a\n    guide to how the APIs will behave using standard defaults.\n\n    By default, all POST requests require a CSRF token. This is handled automatically\n    if you render the form from your Flask application. If you send JSON, then you must include a request header (configured via __SECURITY_CSRF_HEADER__).\n    Please read the online documentation to find out details on how CSRF can be configured.\n\n    _Be aware that the current renderer is great! but has some limitations._\n    In particular\n    it can't represent both form input and JSON input - but all APIs take both.\n\n    You can download the latest spec from: https://github.com/Flask-Middleware/flask-security/blob/master/docs/openapi.yaml\n  version: 1.0.0\n  title: \"Flask-Security External API\"\n  contact:\n    name: Flask-Security-Too\n    url: https://github.com/Flask-Middleware/flask-security\n  license:\n    name: MIT\n    url: https://github.com/Flask-Middleware/flask-security/blob/master/LICENSE\npaths:\n  /login:\n    get:\n      summary: Retrieve login form and/or user information\n      responses:\n        200:\n          description: >\n            Login form or user information. The JSON response will always\n            carry the csrf_token information. If the caller is logged in, then\n            additional information is returned. This can be very useful for single-page applications where during a force refresh, all state is lost.\n            By performing this GET, the session cookie will authenticate the user and the response will contain user information.\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_LOGIN_USER_TEMPLATE)\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n        302:\n          description: Response when already logged in (non-JSON request)\n          headers:\n            Location:\n              schema:\n                type: string\n                example: redirect(SECURITY_POST_LOGIN_VIEW)\n    post:\n      summary: Login to application\n      description: Supports both json and form request types. If the caller is already logged in, then in the form case, they are redirected to SECURITY_POST_LOGIN_VIEW, for a json request, a 400 is returned.\n      parameters:\n        - name: next\n          in: query\n          description: >\n              URL to redirect to on successful login. Ignored for json request.\n          schema:\n            type: string\n        - $ref: \"#/components/parameters/include_auth_token\"\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/Login\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/Login\"\n      responses:\n        200:\n          description: Login response\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n            text/html:\n              schema:\n                description: Unsuccessful login\n                type: string\n                example: render_template(SECURITY_LOGIN_USER_TEMPLATE) with error values\n        302:\n          description: >\n            If the caller already authenticated, the form contents is ignored and a\n            redirect is done: redirect(next) or redirect(SECURITY_POST_LOGIN_VIEW).\n\n            If the caller is NOT already authenticated, and the form contents are\n            validated the caller will be redirected to:\n            redirect(next) or redirect(SECURITY_POST_LOGIN_VIEW)\n          headers:\n            Location:\n              description: redirect\n              schema:\n                type: string\n                example: redirect(SECURITY_POST_LOGIN_VIEW)\n        400:\n          description: Errors while validating login, or caller already authenticated/logged in.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /login(passwordless):\n    get:\n      summary: Return passwordless login form\n      responses:\n        200:\n          description: Passwordless login form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_SEND_LOGIN_TEMPLATE)\n    post:\n      summary: Send passwordless login instructions email\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/EmailLink\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/EmailLink\"\n      responses:\n        200:\n          description: >\n            Passwordless login response. For forms both success and validation errors.\n          content:\n            text/html:\n              schema:\n                description: Passwordless login form - with errors.\n                type: string\n                example: render_template(SECURITY_SEND_LOGIN_TEMPLATE)\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n        400:\n          description: Errors while validating form\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /login(passwordless)/{token}:\n    parameters:\n      - name: token\n        in: path\n        required: true\n        schema:\n          type: string\n    get:\n      summary: Login via token\n      description: >\n        This is the result of getting a passwordless login token and is usually\n        the result of clicking the link from a passwordless email.\n        This ALWAYS results in a 302 redirect.\n      responses:\n        302:\n          description: >\n            Redirects depending on success/error and whether\n            __SECURITY_REDIRECT_BEHAVIOR__ == 'spa'.\n          headers:\n            Location:\n              description: |\n                On spa-success: SECURITY_POST_LOGIN_VIEW?email={email}\n\n                On spa-error-expired: SECURITY_LOGIN_ERROR_VIEW?error={msg}&email={email}\n\n                On spa-error-invalid-token: SECURITY_LOGIN_ERROR_VIEW?error={msg}\n\n                On form-success: SECURITY_POST_LOGIN_VIEW\n\n                On form-error-expired: SECURITY_LOGIN_VIEW\n\n                On form-error-invalid-token: SECURITY_LOGIN_VIEW\n              schema:\n                type: string\n  /logout:\n    get:\n      summary: Log out current user\n      responses:\n        302:\n          description: Successful logout\n          headers:\n            Location:\n              description: redirect(SECURITY_POST_LOGOUT_VIEW)\n              schema:\n                example: redirect(SECURITY_POST_LOGOUT_VIEW)\n    post:\n      summary: Log out current user\n      responses:\n        200:\n          description: Successful logout\n          content:\n            application/json:\n              schema:\n                type: object\n                required: [meta]\n                properties:\n                  meta:\n                    type: object\n                    required: [code]\n                    properties:\n                      code:\n                        type: integer\n                        example: 200\n                        description: Http status code\n  /register:\n    get:\n      summary: Return register form\n      responses:\n        200:\n          description: Register form\n          content:\n            text/html:\n              schema:\n                type: string\n                example: render_template(SECURITY_REGISTER_USER_TEMPLATE)\n        302:\n          description: Response when already logged in\n          headers:\n            Location:\n              schema:\n                type: string\n                example: redirect(SECURITY_POST_LOGIN_VIEW)\n    post:\n      summary: Register with application\n      description: Supports both json and form request types\n      parameters:\n        - name: next\n          in: query\n          description: >\n              URL to redirect to on successful registration. Ignored for json request.\n          schema:\n            type: string\n\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/Register\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/RegisterForm\"\n      responses:\n        200:\n          description: Register response\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n            text/html:\n              schema:\n                description: Unsuccessful registration\n                type: string\n                example: render_template(SECURITY_REGISTER_USER_TEMPLATE) with error values\n        302:\n          description: >\n            Successful registration with form data body.\n          headers:\n            Location:\n              description: redirect to (next) or (SECURITY_POST_REGISTER_VIEW)\n              schema:\n                type: string\n        400:\n          description: Errors while validating registration form\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /change:\n    get:\n      summary: Return change password form\n      responses:\n        200:\n          description: change password form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_CHANGE_PASSWORD_TEMPLATE)\n    post:\n      summary: Change password\n      parameters:\n        - name: X-XSRF-Token\n          in: header\n          schema:\n            $ref: \"#/components/headers/X-CSRF-Token\"\n        - $ref: '#/components/parameters/include_auth_token'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/ChangePassword\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/ChangePassword\"\n      responses:\n        200:\n          description: Change password response.\n          content:\n            text/html:\n              schema:\n                description: Change form validation error.\n                type: string\n                example: render_template(SECURITY_CHANGE_PASSWORD_TEMPLATE) with error values\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n        302:\n          description: Password has been changed (non-json)\n          headers:\n            Location:\n              description: |\n                On success: redirect(SECURITY_POST_CHANGE_VIEW) or\n                            redirect(SECURITY_POST_LOGIN_VIEW)\n              schema:\n                type: string\n        400:\n          description: Errors while validating form\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /reset:\n    get:\n      summary: Return reset password form\n      responses:\n        200:\n          description: Reset password form\n          content:\n            text/html:\n              schema:\n                type: string\n                example: render_template(SECURITY_FORGOT_PASSWORD_TEMPLATE)\n        302:\n          description: Response when already logged in\n          headers:\n            Location:\n              schema:\n                type: string\n                example: redirect(SECURITY_POST_LOGIN_VIEW)\n    post:\n      summary: Send reset password instructions email\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/EmailLink\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/EmailLink\"\n      responses:\n        200:\n          description: >\n            Reset password response. For forms both success and validation errors.\n          content:\n            text/html:\n              schema:\n                description: Forgot password form - with errors.\n                type: string\n                example: render_template(SECURITY_FORGOT_PASSWORD_TEMPLATE)\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n        400:\n          description: Errors while validating form\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /reset/{token}:\n    parameters:\n      - name: token\n        in: path\n        required: true\n        schema:\n          type: string\n    get:\n      summary: Request to reset password\n      description: >\n        This is the result of getting a reset-password token and is usually\n        the result of clicking the link from a reset-password email.\n        If __SECURITY_REDIRECT_BEHAVIOR__ == 'spa' then a 302 is always returned.\n      responses:\n        200:\n          description: Reset password form\n          content:\n            text/html:\n              schema:\n                type: string\n                example: render_template(SECURITY_RESET_PASSWORD_TEMPLATE)\n        302:\n          description: >\n            Redirects depending on success/error and whether\n            __SECURITY_REDIRECT_BEHAVIOR__ == 'spa'.\n          headers:\n            Location:\n              description: |\n                On spa-success: SECURITY_RESET_VIEW?token={token}&email={email}\n\n                On spa-error-expired: SECURITY_RESET_ERROR_VIEW?error={msg}&email={email}\n\n                On spa-error-invalid-token: SECURITY_RESET_ERROR_VIEW?error={msg}\n\n                On default-error: redirect(SECURITY_FORGOT_PASSWORD)\n              schema:\n                type: string\n              examples:\n                spa-success:\n                  value: SECURITY_RESET_VIEW?token={token}&email={email}\n                spa-error-expired:\n                  value: SECURITY_RESET_ERROR_VIEW?error={msg}&email={email}\n                spa-error-invalid-token:\n                  value: SECURITY_RESET_ERROR_VIEW?error={msg}\n                default-error:\n                  value: redirect(SECURITY_FORGOT_PASSWORD)\n    post:\n      summary: Reset password\n      parameters:\n        - $ref: '#/components/parameters/include_auth_token'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/ResetPassword\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/ResetPassword\"\n      responses:\n        200:\n          description: Reset response\n          content:\n            text/html:\n              schema:\n                description: Reset form validation error.\n                type: string\n                example: render_template(SECURITY_RESET_PASSWORD_TEMPLATE) with error values\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n        302:\n          description: Password has been reset or validation error (non-json)\n          headers:\n            Location:\n              description: |\n                On success: redirect(SECURITY_POST_RESET_VIEW) or\n                    redirect(SECURITY_POST_LOGIN_VIEW)\n\n                On invalid/expired token: redirect(SECURITY_FORGOT_PASSWORD)\n              schema:\n                type: string\n              examples:\n                success:\n                  value: redirect(SECURITY_POST_RESET_VIEW) or\n                    redirect(SECURITY_POST_LOGIN_VIEW)\n                invalid/expired-token:\n                  value: redirect(SECURITY_FORGOT_PASSWORD)\n        400:\n          description: Errors while validating form\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /confirm:\n    get:\n      summary: Return send confirmation form\n      responses:\n        200:\n          description: Confirmation form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_SEND_CONFIRMATION_TEMPLATE)\n    post:\n      summary: Send confirmation email\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/EmailLink\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/EmailLink\"\n      responses:\n        200:\n          description: >\n            Confirmation response. For forms both success and validation errors.\n          content:\n            text/html:\n              schema:\n                description: Confirmation form - with errors.\n                type: string\n                example: render_template(SECURITY_SEND_CONFIRMATION_TEMPLATE)\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonResponse\"\n        400:\n          description: Errors while validating form\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /confirm/{token}:\n    parameters:\n      - name: token\n        in: path\n        required: true\n        schema:\n          type: string\n    get:\n      summary: Request to confirm account\n      description: >\n        This is the result of getting a confirmation token and is usually\n        the result of clicking the link from a confirmation email.\n        This ALWAYS results in a 302 redirect.\n        By default (unless __SECURITY_AUTO_LOGIN_AFTER_CONFIRM__ == False), the user\n        denoted by the token is logged in as a side-effect.\n      responses:\n        302:\n          description: >\n            Redirects depending on success/error and whether\n            __SECURITY_REDIRECT_BEHAVIOR__ == 'spa'.\n          headers:\n            Location:\n              description: |\n                On spa-success: SECURITY_POST_CONFIRM_VIEW?email={email}&{level}={msg}\n\n                On spa-error-expired: SECURITY_CONFIRM_ERROR_VIEW?error={msg}&email={email}\n\n                On spa-error-invalid-token: SECURITY_CONFIRM_ERROR_VIEW?error={msg}\n\n                On form-success: SECURITY_POST_CONFIRM_VIEW or\n                                 SECURITY_POST_LOGIN_VIEW\n\n                On form-success (no auto-login): SECURITY_POST_CONFIRM_VIEW or\n                                 SECURITY_LOGIN_URL\n\n                On form-error-expired: SECURITY_CONFIRM_ERROR_VIEW or\n                                       SECURITY_CONFIRM_URL\n\n                On form-error-invalid-token: SECURITY_CONFIRM_ERROR_VIEW or\n                                             SECURITY_CONFIRM_URL\n              schema:\n                type: string\n  /us-signin:\n    get:\n      summary: Unified Sign In.\n      responses:\n        200:\n          description: Sign in form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_US_SIGNIN_TEMPLATE)\n            application/json:\n              schema:\n                type: object\n                properties:\n                  available_methods:\n                    type: string\n                    description: Config setting SECURITY_US_ENABLED_METHODS\n                  code_methods:\n                    type: string\n                    description: All SECURITY_US_ENABLED_METHODS that require a code to be generated and sent.\n                  identity_attributes:\n                    type: string\n                    description: Configuration setting SECURITY_USER_IDENTITY_ATTRIBUTES\n    post:\n      summary: Unified Sign In.\n      parameters:\n        - $ref: '#/components/parameters/include_auth_token'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/UsSignin\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/UsSignin\"\n      responses:\n        200:\n          description: Unified Sign In response\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/UsSigninJsonResponse\"\n            text/html:\n              schema:\n                description: Unsuccessful sign in\n                type: string\n                example: render_template(SECURITY_US_SIGNIN_TEMPLATE) with error values\n        302:\n          description: >\n            If the caller already authenticated, the form contents is ignored and a\n            redirect is done: redirect(next) or redirect(SECURITY_POST_LOGIN_VIEW).\n\n            If the caller is NOT already authenticated, and the form contents are\n            validated the caller will be redirected to:\n            redirect(next) or redirect(SECURITY_POST_LOGIN_VIEW)\n          headers:\n            Location:\n              description: redirect\n              schema:\n                type: string\n                example: redirect(SECURITY_POST_LOGIN_VIEW)\n        400:\n          description: Errors while validating attributes, or caller already authenticated/logged in.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /us-signin/send-code:\n    get:\n      summary: Unified Sign In send authentication code\n      responses:\n        200:\n          description: Send Code form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_US_SIGNIN_TEMPLATE)\n            application/json:\n              schema:\n                type: object\n                properties:\n                  methods:\n                    type: string\n                    description: Config setting SECURITY_US_ENABLED_METHODS\n                  code_methods:\n                    type: string\n                    description: All SECURITY_US_ENABLED_METHODS that require a code to be generated and sent.\n                  identity_attributes:\n                    type: string\n                    description: Configuration setting SECURITY_USER_IDENTITY_ATTRIBUTES\n    post:\n      summary: Send Code for unified sign in.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/UsSigninSendCode\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/UsSigninSendCode\"\n      responses:\n        200:\n          description: Send code response\n          content:\n            application/json:\n              schema:\n                  description: Code successfully sent\n            text/html:\n              schema:\n                description: Validation error, code send error, or code successfully sent\n                type: string\n                example: render_template(SECURITY_US_SIGNIN_TEMPLATE) with error values\n        400:\n          description: Errors while validating attributes.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n        500:\n          description: Error when trying to send code.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n\n  /us-verify:\n    get:\n      summary: Unified sign in re-authentication.\n      description: >\n        If an endpoint is protected with @auth_required() with a freshness declaration\n        this endpoint will be called to request an already signed in user to re-authenticate.\n      responses:\n        200:\n          description: Verify/re-authenticate form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_US_VERIFY_TEMPLATE)\n            application/json:\n              schema:\n                type: object\n                properties:\n                  available_methods:\n                    type: string\n                    description: Config setting SECURITY_US_ENABLED_METHODS\n                  code_methods:\n                    type: string\n                    description: All SECURITY_US_ENABLED_METHODS that require a code to be generated and sent.\n    post:\n      summary: Unified sign in re-authentication\n      parameters:\n        - $ref: '#/components/parameters/include_auth_token'\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/UsSigninVerify\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/UsSigninVerify\"\n      responses:\n        200:\n          description: Verify/re-authenticate response.\n          content:\n            application/json:\n              schema:\n                allOf:\n                  - description: >\n                      The user successfully re-authenticated.\n                  - $ref: \"#/components/schemas/DefaultJsonResponse\"\n            text/html:\n              schema:\n                description: Unsuccessful re-authentication.\n                type: string\n                example: render_template(SECURITY_US_VERIFY_TEMPLATE) with error values\n        302:\n          description: User successfully re-authenticated when using form based request.\n          headers:\n            Location:\n              description: redirect\n              schema:\n                type: string\n                example: redirect(next) or redirect(SECURITY_POST_VERIFY_VIEW)\n        400:\n          description: Errors while validating attributes.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /us-verify/send-code:\n    get:\n      summary: Unified sign in verify/re-authenticate send authentication code\n      responses:\n        200:\n          description: Send Code form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_US_VERIFY_TEMPLATE)\n            application/json:\n              schema:\n                type: object\n                properties:\n                  methods:\n                    type: string\n                    description: Config setting SECURITY_US_ENABLED_METHODS\n                  code_methods:\n                    type: string\n                    description: All SECURITY_US_ENABLED_METHODS that require a code to be generated and sent.\n    post:\n      summary: Send Code for unified sign in verify.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/UsSigninVerifySendCode\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/UsSigninVerifySendCode\"\n      responses:\n        200:\n          description: Send code response\n          content:\n            application/json:\n              schema:\n                  description: Code successfully sent\n            text/html:\n              schema:\n                description: Validation error, code send error, or code successfully sent\n                type: string\n                example: render_template(SECURITY_US_VERIFY_TEMPLATE) with error values\n        400:\n          description: Errors while validating attributes.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n        500:\n          description: Error when trying to send code.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /us-setup:\n    get:\n      summary: Unified sign in setup passcode options.\n      responses:\n        200:\n          description: Setup form\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_US_SETUP_TEMPLATE)\n            application/json:\n              schema:\n                type: object\n                properties:\n                  available_methods:\n                    type: string\n                    description: Config setting SECURITY_US_ENABLED_METHODS\n                  active_methods:\n                    type: string\n                    description: Methods that have already been setup.\n                  setup_methods:\n                    type: string\n                    description: All SECURITY_US_ENABLED_METHODS that require setup.\n                  identity_attributes:\n                    type: string\n                    description: Configuration setting SECURITY_USER_IDENTITY_ATTRIBUTES\n                  phone:\n                    type: string\n                    description: existing configured phone number\n    post:\n      summary: Unified sign in setup.\n      description: >\n        An authenticated user can call this endpoint to update or add additional methods for authenticating (e.g. sms, authenticator app). This is controlled by application configuration settings SECURITY_US_ENABLED_METHODS. This endpoint is protected by a 'freshness' check - meaning the caller will be required to have authenticated recently. In addition, to ensure correctness, the newly setup method must be verified by sending and entering a code prior to it being permanently stored. This verification process is also time-limited.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/UsSetup\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/UsSetup\"\n      responses:\n        200:\n          description: Unified sign in setup response.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/UsSetupJsonResponse\"\n            text/html:\n              schema:\n                description: Invalid form values or verification code sent successfully and should be entered into the form.\n                type: string\n                example: render_template(SECURITY_US_SETUP_TEMPLATE) with error values\n        400:\n          description: Errors while validating attributes.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n        500:\n          description: Error when trying to send code.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /us-setup/{token}:\n    parameters:\n      - name: token\n        in: path\n        required: true\n        schema:\n          type: string\n    get:\n      summary: Validate unified sign in setup request.\n      description: >\n        This does nothing but redirect back to the setup form.\n      responses:\n        200:\n          description: Get form.\n          content:\n            text/html:\n              schema:\n                example: render_template(SECURITY_US_SETUP_TEMPLATE)\n\n    post:\n      summary: Validate passcode sent and store setup method.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: \"#/components/schemas/UsSetupValidateRequest\"\n          application/x-www-form-urlencoded:\n            schema:\n              $ref: \"#/components/schemas/UsSetupValidateRequest\"\n      responses:\n        200:\n          description: Successfully validated and persisted sign in method.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/UsSetupValidateJsonResponse\"\n        302:\n          description: Successfuly validated and persisted sign in method.\n          headers:\n            Location:\n              description: |\n                On form-success: SECURITY_POST_SETUP_VIEW or\n                                 SECURITY_POST_LOGIN_VIEW\n              schema:\n                type: string\n        400:\n          description: Validation failed.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/DefaultJsonErrorResponse\"\n  /us-verify-link:\n    parameters:\n      - name: email\n        in: query\n        required: true\n        schema:\n          type: string\n      - name: code\n        in: query\n        required: true\n        schema:\n          type: string\n    get:\n      summary: A magic link to authenticate (instead of manually entering a code).\n      description: >\n        This is the result of getting a passcode link and is usually\n        the result of clicking the link from an email.\n        This ALWAYS results in a 302 redirect.\n        N.B. Magic link with 2FA enabled does not work and the SPA will get a redirect to the login error page with tf_required. Must use code option instead.\n      responses:\n        302:\n          description: >\n            Redirects depending on success/error and whether\n            __SECURITY_REDIRECT_BEHAVIOR__ == 'spa'. Also, if Two-Factor authentication has been enabled, further authentication/redirects might be required.\n          headers:\n            Location:\n              description: |\n                On spa-success: SECURITY_POST_LOGIN_VIEW?email={email}\n\n                On spa-error-expired: SECURITY_LOGIN_ERROR_VIEW?error={msg}\n\n                On spa-error-invalid-token: SECURITY_LOGIN_ERROR_VIEW?error={msg}\n\n                On spa-two-factor-required: SECURITY_LOGIN_ERROR_VIEW?tf_required=1\n\n                On form-success: SECURITY_POST_LOGIN_VIEW\n\n                On form-error-expired: SECURITY_US_SIGNIN_URL\n\n                On form-error-invalid-token: SECURITY_US_SIGNIN_URL\n\n                On form-success and two-factor: SECURITY_TWO_FACTOR_TOKEN_VALIDATION_URL or SECURITY_TWO_FACTOR_SETUP_URL\n              schema:\n                type: string\n  /us-qrcode/{token}:\n    parameters:\n      - name: token\n        in: path\n        required: true\n        schema:\n          type: string\n    get:\n      summary: Display a QRCode for setting up an authenticator app.\n      responses:\n        200:\n          description: Display QRCode.\n          content:\n            image/svg+xml:\n              schema:\n                description: QRCode\n        400:\n          description: Token invalid or expired.\n        404:\n          description: authenticator not configured.\n\ncomponents:\n  schemas:\n    Login:\n      type: object\n      required: [email, password]\n      properties:\n        email:\n          type: string\n          description: >\n            user identifier. This is by default an email address, but can be any (unique)\n            field that is part of the User model and is defined in the __SECURITY_USER_IDENTITY_ATTRIBUTES__ configuration variable. It will also match against numeric User model fields.\n        password:\n          type: string\n          description: Password\n        remember_me:\n          type: boolean\n          description: >\n            If true, will remember userid as part of cookie. There is a configuration variable DEFAULT_REMEMBER_ME that can be set. This field will override that.\n    DefaultJsonResponse:\n      type: object\n      properties:\n        user:\n          type: object\n          required: [id]\n          description: >\n            By default just 'id' is returned. However by overriding _User::get_security_payload()_ any attributes of the User model can be returned.\n          properties:\n            id:\n              type: integer\n              example: 42\n              description: Unique user id (primary key)\n            authentication_token:\n              type: string\n              description: >\n                Token to be used in future token-based API calls.\n                Note this only returned from those APIs that accept a\n                'include_auth_token' query param.\n        csrf_token:\n          type: string\n          description: Session CSRF token\n    DefaultJsonErrorResponse:\n      type: object\n      required: [meta, response]\n      properties:\n        meta:\n          type: object\n          required: [code]\n          properties:\n            code:\n              type: integer\n              example: 400\n              description: Http status code\n        response:\n          type: object\n          description: >\n            For form validation errors, the 'errors' key will be set with a list of errors per\n            invalid form input field. For non-form related errors, the 'error' key will be set\n            with a single (localized) error string.\n          properties:\n            errors:\n              type: object\n              description: >\n                Errors per input/form field ('email' below is just an example)\n              properties:\n                email:\n                  type: array\n                  items:\n                    type: string\n                    example: Email issues.\n                    description: Error message (localized)\n            error:\n              type: string\n              example: \"Unauthenticated\"\n              description: Error message (localized)\n    Register:\n      type: object\n      required: [email, password]\n      properties:\n        email:\n          type: string\n          description: >\n            user identifier. This is by default an email address, but can be any (unique)\n            field that is part of the User model and is defined in the __SECURITY_USER_IDENTITY_ATTRIBUTES__ configuration variable. It will also match against numeric User model fields.\n        password:\n          type: string\n          description: Password\n    RegisterForm:\n      type: object\n      required: [email, password]\n      properties:\n        email:\n          type: string\n          description: >\n            user identifier. This is by default an email address, but can be any (unique)\n            field that is part of the User model and is defined in the __SECURITY_USER_IDENTITY_ATTRIBUTES__ configuration variable. It will also match against numeric User model fields.\n        password:\n          type: string\n          description: Password\n        password_confirm:\n          type: string\n          description: >\n            If present, must re-type in password. This will not be present if the __SECURITY_CONFIRM__ configuration is true.\n        next:\n          type: string\n          description: >\n            Redirect URL. Overrides __SECURITY_POST_REGISTER_VIEW__.\n    ResetPassword:\n      type: object\n      required: [password, password_confirm]\n      properties:\n        password:\n          type: string\n          description: Password\n        password_confirm:\n          type: string\n          description: Password - again\n    ChangePassword:\n      type: object\n      required: [password, new_password, new_password_confirm]\n      properties:\n        password:\n          type: string\n          description: Password\n        new_password:\n          type: string\n          description: New password\n        new_password_confirm:\n          type: string\n          description: New password - again\n    EmailLink:\n      type: object\n      required: [email]\n      properties:\n        email:\n          type: string\n          description: >\n            Email address to send link email to.\n    UsSignin:\n      type: object\n      required: [identity, passcode]\n      properties:\n        identity:\n          type: string\n          description: Configured by SECURITY_USER_IDENTITY_ATTRIBUTES\n          example: me@you.com, +16505551212\n        passcode:\n          type: string\n          description: password or code\n        remember_me:\n          type: boolean\n    UsSigninJsonResponse:\n      type: object\n      description: >\n        The user successfully signed in. Note that depending on SECURITY_TWO_FACTOR and SECURITY_US_MFA_REQUIRED configuration variables, a second form of authentication might be required.\n      required: [meta, response]\n      properties:\n        meta:\n          type: object\n          required: [code]\n          properties:\n            code:\n              type: integer\n              example: 200\n              description: Http status code\n        response:\n          type: object\n          properties:\n            tf_required:\n              type: boolean\n              description: If two-factor authentication is required for caller.\n            tf_state:\n              type: string\n              description: if \"setup_from_login\" then the caller must go through two-factor setup endpoint. If \"ready\" then a code has been sent and should be supplied to SECURITY_TWO_FACTOR_TOKEN_VALIDATION_URL.\n            tf_primary_method:\n              type: string\n              description: Which method was used to send code.\n    UsSigninSendCode:\n      type: object\n      required: [identity, chosen_method]\n      properties:\n        identity:\n          type: string\n          description: Configured by SECURITY_USER_IDENTITY_ATTRIBUTES\n          example: me@you.com, +16505551212\n        chosen_method:\n          type: string\n          description: which method should be used to send the code, as configured with SECURITY_US_ENABLED_METHODS\n    UsSigninVerify:\n      type: object\n      required: [passcode]\n      properties:\n        passcode:\n          type: string\n          description: password or code\n    UsSigninVerifySendCode:\n      type: object\n      required: [chosen_method]\n      properties:\n        chosen_method:\n          type: string\n          description: which method should be used to send the code, as configured with SECURITY_US_ENABLED_METHODS\n    UsSetup:\n      type: object\n      required: [chosen_method]\n      properties:\n        chosen_method:\n          type: string\n          description: which method should be used to send the code, as configured with SECURITY_US_ENABLED_METHODS\n        phone:\n          type: string\n          description: phone number (this will be normalized). Required if chosen_method == \"sms\".\n    UsSetupJsonResponse:\n      type: object\n      required: [meta, response]\n      properties:\n        meta:\n          type: object\n          required: [code]\n          properties:\n            code:\n              type: integer\n              example: 200\n              description: Http status code\n        response:\n          type: object\n          properties:\n            chosen_method:\n              type: string\n              description: The chosen_method as passed into API.\n            state:\n              type: string\n              description: Opaque blob that must be pass to /us-setup/<state>. This is a signed, timed token.\n    UsSetupValidateRequest:\n      type: object\n      required: [passcode]\n      properties:\n        passcode:\n          type: string\n          description: Code/Passcode as received from method being setup.\n    UsSetupValidateJsonResponse:\n      type: object\n      required: [meta, response]\n      properties:\n        meta:\n          type: object\n          required: [code]\n          properties:\n            code:\n              type: integer\n              example: 200\n              description: Http status code\n        response:\n          type: object\n          properties:\n            chosen_method:\n              type: string\n              description: The chosen_method as passed into API.\n            phone:\n              type: string\n              description: Phone number if set.\n\n  headers:\n    X-CSRF-Token:\n      description: CSRF token\n      schema:\n        type: string\n  parameters:\n    include_auth_token:\n      name: include_auth_token\n      description: If set/sent, will return an Authentication Token for user\n      in: query\n      schema:\n        type: string\n\n", "# -*- coding: utf-8 -*-\n\"\"\"\n    flask_security.views\n    ~~~~~~~~~~~~~~~~~~~~\n\n    Flask-Security views module\n\n    :copyright: (c) 2012 by Matt Wright.\n    :copyright: (c) 2019-2020 by J. Christopher Wagner (jwag).\n    :license: MIT, see LICENSE for more details.\n\n    CSRF is tricky. By default all our forms have CSRF protection built in via\n    Flask-WTF. This is regardless of authentication method or whether the request\n    is Form or JSON based. Form-based 'just works' since when rendering the form\n    (on GET), the CSRF token is automatically populated.\n    We want to handle:\n        - JSON requests where CSRF token is in a header (e.g. X-CSRF-Token)\n        - Option to skip CSRF when using a token to authenticate (rather than session)\n          (CSRF_PROTECT_MECHANISMS)\n        - Option to skip CSRF for 'login'/unauthenticated requests\n          (CSRF_IGNORE_UNAUTH_ENDPOINTS)\n    This is complicated by the fact that the only way to disable form CSRF is to\n    pass in meta={csrf: false} at form instantiation time.\n\n    Be aware that for CSRF to work, caller MUST pass in session cookie. So\n    for pure API, and no session cookie - there is no way to support CSRF-Login\n    so app must set CSRF_IGNORE_UNAUTH_ENDPOINTS (or use CSRF/session cookie for logging\n    in then once they have a token, no need for cookie).\n\n    TODO: two-factor routes such as tf_setup need work. They seem to support both\n    authenticated (via session?) as well as unauthenticated access.\n\"\"\"\n\nimport sys\nimport time\n\nfrom flask import (\n    Blueprint,\n    abort,\n    after_this_request,\n    current_app,\n    jsonify,\n    request,\n    session,\n)\nfrom flask_login import current_user\nfrom werkzeug.datastructures import MultiDict\nfrom werkzeug.local import LocalProxy\n\nfrom .changeable import change_user_password\nfrom .confirmable import (\n    confirm_email_token_status,\n    confirm_user,\n    send_confirmation_instructions,\n)\nfrom .decorators import anonymous_user_required, auth_required, unauth_csrf\nfrom .passwordless import login_token_status, send_login_instructions\nfrom .quart_compat import get_quart_status\nfrom .unified_signin import (\n    us_signin,\n    us_signin_send_code,\n    us_qrcode,\n    us_setup,\n    us_setup_validate,\n    us_verify,\n    us_verify_link,\n    us_verify_send_code,\n)\nfrom .recoverable import (\n    reset_password_token_status,\n    send_reset_password_instructions,\n    update_password,\n)\nfrom .registerable import register_user\nfrom .twofactor import (\n    complete_two_factor_process,\n    tf_clean_session,\n    tf_disable,\n    tf_login,\n)\nfrom .utils import (\n    base_render_json,\n    config_value,\n    do_flash,\n    get_message,\n    get_post_login_redirect,\n    get_post_logout_redirect,\n    get_post_register_redirect,\n    get_post_verify_redirect,\n    get_url,\n    json_error_response,\n    login_user,\n    logout_user,\n    slash_url_suffix,\n    suppress_form_csrf,\n    url_for_security,\n)\n\nif get_quart_status():  # pragma: no cover\n    from quart import make_response, redirect\nelse:\n    from flask import make_response, redirect\n\n# Convenient references\n_security = LocalProxy(lambda: current_app.extensions[\"security\"])\n_datastore = LocalProxy(lambda: _security.datastore)\n\n\ndef default_render_json(payload, code, headers, user):\n    \"\"\" Default JSON response handler.\n    \"\"\"\n    # Force Content-Type header to json.\n    if headers is None:\n        headers = dict()\n    headers[\"Content-Type\"] = \"application/json\"\n    payload = dict(meta=dict(code=code), response=payload)\n    return make_response(jsonify(payload), code, headers)\n\n\nPY3 = sys.version_info[0] == 3\nif PY3 and get_quart_status():  # pragma: no cover\n    from .async_compat import _commit  # noqa: F401\nelse:\n\n    def _commit(response=None):\n        _datastore.commit()\n        return response\n\n\ndef _ctx(endpoint):\n    return _security._run_ctx_processor(endpoint)\n\n\n@unauth_csrf(fall_through=True)\ndef login():\n    \"\"\"View function for login view\n\n    Allow already authenticated users. For GET this is useful for\n    single-page-applications on refresh - session still active but need to\n    access user info and csrf-token.\n    For POST - redirects to POST_LOGIN_VIEW (forms) or returns 400 (json).\n    \"\"\"\n\n    if current_user.is_authenticated and request.method == \"POST\":\n        # Just redirect current_user to POST_LOGIN_VIEW.\n        # While its tempting to try to logout the current user and login the\n        # new requested user - that simply doesn't work with CSRF.\n\n        # This does NOT use get_post_login_redirect() so that it doesn't look at\n        # 'next' - which can cause infinite redirect loops\n        # (see test_common::test_authenticated_loop)\n        if _security._want_json(request):\n            payload = json_error_response(\n                errors=get_message(\"ANONYMOUS_USER_REQUIRED\")[0]\n            )\n            return _security._render_json(payload, 400, None, None)\n        else:\n            return redirect(get_url(_security.post_login_view))\n\n    form_class = _security.login_form\n\n    if request.is_json:\n        # Allow GET so we can return csrf_token for pre-login.\n        if request.content_length:\n            form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n        else:\n            form = form_class(MultiDict([]), meta=suppress_form_csrf())\n    else:\n        form = form_class(request.form, meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        remember_me = form.remember.data if \"remember\" in form else None\n        if config_value(\"TWO_FACTOR\") and (\n            config_value(\"TWO_FACTOR_REQUIRED\")\n            or (form.user.tf_totp_secret and form.user.tf_primary_method)\n        ):\n            return tf_login(\n                form.user, remember=remember_me, primary_authn_via=\"password\"\n            )\n\n        login_user(form.user, remember=remember_me, authn_via=[\"password\"])\n        after_this_request(_commit)\n\n        if _security._want_json(request):\n            return base_render_json(form, include_auth_token=True)\n        return redirect(get_post_login_redirect())\n\n    if _security._want_json(request):\n        if current_user.is_authenticated:\n            form.user = current_user\n        return base_render_json(form)\n\n    if current_user.is_authenticated:\n        return redirect(get_url(_security.post_login_view))\n    else:\n        return _security.render_template(\n            config_value(\"LOGIN_USER_TEMPLATE\"), login_user_form=form, **_ctx(\"login\")\n        )\n\n\n@auth_required()\ndef verify():\n    \"\"\"View function which handles a authentication verification request.\n    \"\"\"\n    form_class = _security.verify_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        # form may have called verify_and_update_password()\n        after_this_request(_commit)\n\n        # verified - so set freshness time.\n        session[\"fs_paa\"] = time.time()\n\n        if _security._want_json(request):\n            return base_render_json(form)\n        do_flash(*get_message(\"REAUTHENTICATION_SUCCESSFUL\"))\n        return redirect(get_post_verify_redirect())\n\n    if _security._want_json(request):\n        assert form.user == current_user\n        return base_render_json(form)\n\n    return _security.render_template(\n        config_value(\"VERIFY_TEMPLATE\"), verify_form=form, **_ctx(\"verify\")\n    )\n\n\ndef logout():\n    \"\"\"View function which handles a logout request.\"\"\"\n    tf_clean_session()\n\n    if current_user.is_authenticated:\n        logout_user()\n\n    # No body is required - so if a POST and json - return OK\n    if request.method == \"POST\" and _security._want_json(request):\n        return _security._render_json({}, 200, headers=None, user=None)\n\n    return redirect(get_post_logout_redirect())\n\n\n@anonymous_user_required\ndef register():\n    \"\"\"View function which handles a registration request.\"\"\"\n\n    # For some unknown historic reason - if you don't require confirmation\n    # (via email) then you need to type in your password twice. That might\n    # make sense if you can't reset your password but in modern (2020) UX models\n    # don't ask twice.\n    if _security.confirmable or request.is_json:\n        form_class = _security.confirm_register_form\n    else:\n        form_class = _security.register_form\n\n    if request.is_json:\n        form_data = MultiDict(request.get_json())\n    else:\n        form_data = request.form\n\n    form = form_class(form_data, meta=suppress_form_csrf())\n    if form.validate_on_submit():\n        did_login = False\n        user = register_user(form)\n        form.user = user\n\n        # The 'auto-login' feature probably should be removed - I can't imagine\n        # an application that would want random email accounts. It has been like this\n        # since the beginning. Note that we still enforce 2FA - however for unified\n        # signin - we adhere to historic behavior.\n        if not _security.confirmable or _security.login_without_confirmation:\n            if config_value(\"TWO_FACTOR\") and config_value(\"TWO_FACTOR_REQUIRED\"):\n                return tf_login(user, primary_authn_via=\"register\")\n            after_this_request(_commit)\n            login_user(user, authn_via=[\"register\"])\n            did_login = True\n\n        if not _security._want_json(request):\n            return redirect(get_post_register_redirect())\n\n        # Only include auth token if in fact user is permitted to login\n        return base_render_json(form, include_auth_token=did_login)\n    if _security._want_json(request):\n        return base_render_json(form)\n\n    return _security.render_template(\n        config_value(\"REGISTER_USER_TEMPLATE\"),\n        register_user_form=form,\n        **_ctx(\"register\")\n    )\n\n\n@unauth_csrf(fall_through=True)\ndef send_login():\n    \"\"\"View function that sends login instructions for passwordless login\"\"\"\n\n    form_class = _security.passwordless_login_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        send_login_instructions(form.user)\n        if not _security._want_json(request):\n            do_flash(*get_message(\"LOGIN_EMAIL_SENT\", email=form.user.email))\n\n    if _security._want_json(request):\n        return base_render_json(form)\n\n    return _security.render_template(\n        config_value(\"SEND_LOGIN_TEMPLATE\"), send_login_form=form, **_ctx(\"send_login\")\n    )\n\n\n@anonymous_user_required\ndef token_login(token):\n    \"\"\"View function that handles passwordless login via a token\n    Like reset-password and confirm - this is usually a GET via an email\n    so from the request we can't differentiate form-based apps from non.\n    \"\"\"\n\n    expired, invalid, user = login_token_status(token)\n\n    if not user or invalid:\n        m, c = get_message(\"INVALID_LOGIN_TOKEN\")\n        if _security.redirect_behavior == \"spa\":\n            return redirect(get_url(_security.login_error_view, qparams={c: m}))\n        do_flash(m, c)\n        return redirect(url_for_security(\"login\"))\n    if expired:\n        send_login_instructions(user)\n        m, c = get_message(\n            \"LOGIN_EXPIRED\", email=user.email, within=_security.login_within\n        )\n        if _security.redirect_behavior == \"spa\":\n            return redirect(\n                get_url(\n                    _security.login_error_view,\n                    qparams=user.get_redirect_qparams({c: m}),\n                )\n            )\n        do_flash(m, c)\n        return redirect(url_for_security(\"login\"))\n\n    login_user(user, authn_via=[\"token\"])\n    after_this_request(_commit)\n    if _security.redirect_behavior == \"spa\":\n        return redirect(\n            get_url(_security.post_login_view, qparams=user.get_redirect_qparams())\n        )\n\n    do_flash(*get_message(\"PASSWORDLESS_LOGIN_SUCCESSFUL\"))\n\n    return redirect(get_post_login_redirect())\n\n\n@unauth_csrf(fall_through=True)\ndef send_confirmation():\n    \"\"\"View function which sends confirmation instructions.\"\"\"\n\n    form_class = _security.send_confirmation_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        send_confirmation_instructions(form.user)\n        if not _security._want_json(request):\n            do_flash(*get_message(\"CONFIRMATION_REQUEST\", email=form.user.email))\n\n    if _security._want_json(request):\n        return base_render_json(form)\n\n    return _security.render_template(\n        config_value(\"SEND_CONFIRMATION_TEMPLATE\"),\n        send_confirmation_form=form,\n        **_ctx(\"send_confirmation\")\n    )\n\n\ndef confirm_email(token):\n    \"\"\"View function which handles a email confirmation request.\"\"\"\n\n    expired, invalid, user = confirm_email_token_status(token)\n\n    if not user or invalid:\n        m, c = get_message(\"INVALID_CONFIRMATION_TOKEN\")\n        if _security.redirect_behavior == \"spa\":\n            return redirect(get_url(_security.confirm_error_view, qparams={c: m}))\n        do_flash(m, c)\n        return redirect(\n            get_url(_security.confirm_error_view)\n            or url_for_security(\"send_confirmation\")\n        )\n\n    already_confirmed = user.confirmed_at is not None\n\n    if expired or already_confirmed:\n        if already_confirmed:\n            m, c = get_message(\"ALREADY_CONFIRMED\")\n        else:\n            send_confirmation_instructions(user)\n            m, c = get_message(\n                \"CONFIRMATION_EXPIRED\",\n                email=user.email,\n                within=_security.confirm_email_within,\n            )\n\n        if _security.redirect_behavior == \"spa\":\n            return redirect(\n                get_url(\n                    _security.confirm_error_view,\n                    qparams=user.get_redirect_qparams({c: m}),\n                )\n            )\n\n        do_flash(m, c)\n        return redirect(\n            get_url(_security.confirm_error_view)\n            or url_for_security(\"send_confirmation\")\n        )\n\n    confirm_user(user)\n    after_this_request(_commit)\n\n    if user != current_user:\n        logout_user()\n        if config_value(\"AUTO_LOGIN_AFTER_CONFIRM\"):\n            # N.B. this is a (small) security risk if email went to wrong place.\n            # and you have the LOGIN_WITH_CONFIRMATION flag since in that case\n            # you can be logged in and doing stuff - but another person could\n            # get the email.\n            if config_value(\"TWO_FACTOR\") and config_value(\"TWO_FACTOR_REQUIRED\"):\n                return tf_login(user, primary_authn_via=\"confirm\")\n            login_user(user, authn_via=[\"confirm\"])\n\n    m, c = get_message(\"EMAIL_CONFIRMED\")\n    if _security.redirect_behavior == \"spa\":\n        return redirect(\n            get_url(\n                _security.post_confirm_view, qparams=user.get_redirect_qparams({c: m})\n            )\n        )\n    do_flash(m, c)\n    return redirect(\n        get_url(_security.post_confirm_view)\n        or get_url(\n            _security.post_login_view\n            if config_value(\"AUTO_LOGIN_AFTER_CONFIRM\")\n            else _security.login_url\n        )\n    )\n\n\n@anonymous_user_required\n@unauth_csrf(fall_through=True)\ndef forgot_password():\n    \"\"\"View function that handles a forgotten password request.\"\"\"\n\n    form_class = _security.forgot_password_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        send_reset_password_instructions(form.user)\n        if not _security._want_json(request):\n            do_flash(*get_message(\"PASSWORD_RESET_REQUEST\", email=form.user.email))\n\n    if _security._want_json(request):\n        return base_render_json(form, include_user=False)\n\n    return _security.render_template(\n        config_value(\"FORGOT_PASSWORD_TEMPLATE\"),\n        forgot_password_form=form,\n        **_ctx(\"forgot_password\")\n    )\n\n\n@anonymous_user_required\n@unauth_csrf(fall_through=True)\ndef reset_password(token):\n    \"\"\"View function that handles a reset password request.\n\n    This is usually called via GET as part of an email link and redirects to\n    a reset-password form\n    It is called via POST to actually update the password (and then redirects to\n    a post reset/login view)\n    If in either case the token is either invalid or expired it redirects to\n    the 'forgot-password' form.\n\n    In the case of non-form based configuration:\n    For GET normal case - redirect to RESET_VIEW?token={token}&email={email}\n    For GET invalid case - redirect to RESET_ERROR_VIEW?error={error}&email={email}\n    For POST normal/successful case - return 200 with new authentication token\n    For POST error case return 400 with form.errors\n    \"\"\"\n\n    expired, invalid, user = reset_password_token_status(token)\n    form_class = _security.reset_password_form\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n    form.user = user\n\n    if request.method == \"GET\":\n        if not user or invalid:\n            m, c = get_message(\"INVALID_RESET_PASSWORD_TOKEN\")\n            if _security.redirect_behavior == \"spa\":\n                return redirect(get_url(_security.reset_error_view, qparams={c: m}))\n            do_flash(m, c)\n            return redirect(url_for_security(\"forgot_password\"))\n        if expired:\n            send_reset_password_instructions(user)\n            m, c = get_message(\n                \"PASSWORD_RESET_EXPIRED\",\n                email=user.email,\n                within=_security.reset_password_within,\n            )\n            if _security.redirect_behavior == \"spa\":\n                return redirect(\n                    get_url(\n                        _security.reset_error_view,\n                        qparams=user.get_redirect_qparams({c: m}),\n                    )\n                )\n            do_flash(m, c)\n            return redirect(url_for_security(\"forgot_password\"))\n\n        # All good - for SPA - redirect to the ``reset_view``\n        if _security.redirect_behavior == \"spa\":\n            return redirect(\n                get_url(\n                    _security.reset_view,\n                    qparams=user.get_redirect_qparams({\"token\": token}),\n                )\n            )\n        # for forms - render the reset password form\n        return _security.render_template(\n            config_value(\"RESET_PASSWORD_TEMPLATE\"),\n            reset_password_form=form,\n            reset_password_token=token,\n            **_ctx(\"reset_password\")\n        )\n\n    # This is the POST case.\n    m = None\n    if not user or invalid:\n        invalid = True\n        m, c = get_message(\"INVALID_RESET_PASSWORD_TOKEN\")\n        if not _security._want_json(request):\n            do_flash(m, c)\n\n    if expired:\n        send_reset_password_instructions(user)\n        m, c = get_message(\n            \"PASSWORD_RESET_EXPIRED\",\n            email=user.email,\n            within=_security.reset_password_within,\n        )\n        if not _security._want_json(request):\n            do_flash(m, c)\n\n    if invalid or expired:\n        if _security._want_json(request):\n            return _security._render_json(json_error_response(m), 400, None, None)\n        else:\n            return redirect(url_for_security(\"forgot_password\"))\n\n    if form.validate_on_submit():\n        after_this_request(_commit)\n        update_password(user, form.password.data)\n        if config_value(\"TWO_FACTOR\") and (\n            config_value(\"TWO_FACTOR_REQUIRED\")\n            or (form.user.tf_totp_secret and form.user.tf_primary_method)\n        ):\n            return tf_login(user, primary_authn_via=\"reset\")\n        login_user(user, authn_via=[\"reset\"])\n        if _security._want_json(request):\n            login_form = _security.login_form(MultiDict({\"email\": user.email}))\n            setattr(login_form, \"user\", user)\n            return base_render_json(login_form, include_auth_token=True)\n        else:\n            do_flash(*get_message(\"PASSWORD_RESET\"))\n            return redirect(\n                get_url(_security.post_reset_view) or get_url(_security.post_login_view)\n            )\n\n    # validation failure case - for forms - we try again including the token\n    # for non-forms -  we just return errors and assume caller remembers token.\n    if _security._want_json(request):\n        return base_render_json(form)\n    return _security.render_template(\n        config_value(\"RESET_PASSWORD_TEMPLATE\"),\n        reset_password_form=form,\n        reset_password_token=token,\n        **_ctx(\"reset_password\")\n    )\n\n\n@auth_required(\"basic\", \"token\", \"session\")\ndef change_password():\n    \"\"\"View function which handles a change password request.\"\"\"\n\n    form_class = _security.change_password_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        after_this_request(_commit)\n        change_user_password(current_user._get_current_object(), form.new_password.data)\n        if _security._want_json(request):\n            form.user = current_user\n            return base_render_json(form, include_auth_token=True)\n\n        do_flash(*get_message(\"PASSWORD_CHANGE\"))\n        return redirect(\n            get_url(_security.post_change_view) or get_url(_security.post_login_view)\n        )\n\n    if _security._want_json(request):\n        form.user = current_user\n        return base_render_json(form)\n\n    return _security.render_template(\n        config_value(\"CHANGE_PASSWORD_TEMPLATE\"),\n        change_password_form=form,\n        **_ctx(\"change_password\")\n    )\n\n\n@unauth_csrf(fall_through=True)\ndef two_factor_setup():\n    \"\"\"View function for two-factor setup.\n\n    This is used both for GET to fetch forms and POST to actually set configuration\n    (and send token).\n\n    There are 3 cases for setting up:\n    1) initial login and application requires 2FA\n    2) changing existing 2FA information\n    3) user wanting to enable or disable 2FA (assuming application doesn't require it)\n\n    In order to CHANGE/ENABLE/DISABLE a 2FA information, user must be properly logged in\n    AND must perform a fresh password validation by\n    calling POST /tf-confirm (which sets 'tf_confirmed' in the session).\n\n    For initial login when 2FA required of course user can't be logged in - in this\n    case we need to have been sent some\n    state via the session as part of login to show a) who and b) that they successfully\n    authenticated.\n    \"\"\"\n    form_class = _security.two_factor_setup_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if not current_user.is_authenticated:\n        # This is the initial login case\n        # We can also get here from setup if they want to change\n        if not all(k in session for k in [\"tf_user_id\", \"tf_state\"]) or session[\n            \"tf_state\"\n        ] not in [\"setup_from_login\", \"validating_profile\"]:\n            # illegal call on this endpoint\n            tf_clean_session()\n            return _tf_illegal_state(form, _security.login_url)\n\n        user = _datastore.get_user(session[\"tf_user_id\"])\n        if not user:\n            tf_clean_session()\n            return _tf_illegal_state(form, _security.login_url)\n\n    else:\n        # all other cases require user to be logged in and have performed\n        # additional password verification as signified by 'tf_confirmed'\n        # in the session.\n        if \"tf_confirmed\" not in session:\n            tf_clean_session()\n            return _tf_illegal_state(form, _security.two_factor_confirm_url)\n        user = current_user\n\n    if form.validate_on_submit():\n        # Before storing in DB and therefore requiring 2FA we need to\n        # make sure it actually works.\n        # Requiring 2FA is triggered by having BOTH tf_totp_secret and\n        # tf_primary_method in the user record (or having the application\n        # global config TWO_FACTOR_REQUIRED)\n        # Until we correctly validate the 2FA - we don't set primary_method in\n        # user model but use the session to store it.\n        pm = form.setup.data\n        if pm == \"disable\":\n            tf_disable(user)\n            after_this_request(_commit)\n            do_flash(*get_message(\"TWO_FACTOR_DISABLED\"))\n            if not _security._want_json(request):\n                return redirect(get_url(_security.post_login_view))\n            else:\n                return base_render_json(form)\n\n        # Regenerate the TOTP secret on every call of 2FA setup unless it is\n        # within the same session and method (e.g. upon entering the phone number)\n        if pm != session.get(\"tf_primary_method\", None):\n            session[\"tf_totp_secret\"] = _security._totp_factory.generate_totp_secret()\n\n        session[\"tf_primary_method\"] = pm\n        session[\"tf_state\"] = \"validating_profile\"\n        new_phone = form.phone.data if len(form.phone.data) > 0 else None\n        if new_phone:\n            user.tf_phone_number = new_phone\n            _datastore.put(user)\n            after_this_request(_commit)\n\n        # This form is sort of bizarre - for SMS and authenticator\n        # you select, then get more info, and submit again.\n        # For authenticator of course, we don't actually send anything\n        # and for SMS it is the second time around that we get the phone number\n        if pm == \"email\" or (pm == \"sms\" and new_phone):\n            msg = user.tf_send_security_token(\n                method=pm,\n                totp_secret=session[\"tf_totp_secret\"],\n                phone_number=getattr(user, \"tf_phone_number\", None),\n            )\n            if msg:\n                # send code didn't work\n                form.setup.errors = list()\n                form.setup.errors.append(msg)\n                if _security._want_json(request):\n                    return base_render_json(\n                        form, include_user=False, error_status_code=500\n                    )\n        code_form = _security.two_factor_verify_code_form()\n        if not _security._want_json(request):\n            return _security.render_template(\n                config_value(\"TWO_FACTOR_SETUP_TEMPLATE\"),\n                two_factor_setup_form=form,\n                two_factor_verify_code_form=code_form,\n                choices=config_value(\"TWO_FACTOR_ENABLED_METHODS\"),\n                chosen_method=pm,\n                **_ctx(\"tf_setup\")\n            )\n\n    # We get here on GET and POST with failed validation.\n    # For things like phone number - we've already done one POST\n    # that succeeded and now if failed - so retain the initial info\n    if _security._want_json(request):\n        return base_render_json(form, include_user=False)\n\n    code_form = _security.two_factor_verify_code_form()\n    choices = config_value(\"TWO_FACTOR_ENABLED_METHODS\")\n    if not config_value(\"TWO_FACTOR_REQUIRED\"):\n        choices.append(\"disable\")\n\n    return _security.render_template(\n        config_value(\"TWO_FACTOR_SETUP_TEMPLATE\"),\n        two_factor_setup_form=form,\n        two_factor_verify_code_form=code_form,\n        choices=choices,\n        chosen_method=form.setup.data,\n        two_factor_required=config_value(\"TWO_FACTOR_REQUIRED\"),\n        **_ctx(\"tf_setup\")\n    )\n\n\n@unauth_csrf(fall_through=True)\ndef two_factor_token_validation():\n    \"\"\"View function for two-factor token validation\n\n    Two cases:\n    1) normal login case - everything setup correctly; normal 2FA validation\n       In this case - user not logged in -\n       but 'tf_state' == 'ready' or 'validating_profile'\n    2) validating after CHANGE/ENABLE 2FA. In this case user logged in/authenticated\n       they must have 'tf_confirmed' set meaning they re-entered their passwd\n\n    \"\"\"\n\n    form_class = _security.two_factor_verify_code_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    changing = current_user.is_authenticated\n    if not changing:\n        # This is the normal login case\n        if (\n            not all(k in session for k in [\"tf_user_id\", \"tf_state\"])\n            or session[\"tf_state\"] not in [\"ready\", \"validating_profile\"]\n            or (\n                session[\"tf_state\"] == \"validating_profile\"\n                and \"tf_primary_method\" not in session\n            )\n        ):\n            # illegal call on this endpoint\n            tf_clean_session()\n            return _tf_illegal_state(form, _security.login_url)\n\n        user = _datastore.get_user(session[\"tf_user_id\"])\n        form.user = user\n        if not user:\n            tf_clean_session()\n            return _tf_illegal_state(form, _security.login_url)\n\n        if session[\"tf_state\"] == \"ready\":\n            pm = user.tf_primary_method\n            totp_secret = user.tf_totp_secret\n        else:\n            pm = session[\"tf_primary_method\"]\n            totp_secret = session[\"tf_totp_secret\"]\n    else:\n        if (\n            not all(\n                k in session for k in [\"tf_confirmed\", \"tf_state\", \"tf_primary_method\"]\n            )\n            or session[\"tf_state\"] != \"validating_profile\"\n        ):\n            tf_clean_session()\n            # logout since this seems like attack-ish/logic error\n            logout_user()\n            return _tf_illegal_state(form, _security.login_url)\n        pm = session[\"tf_primary_method\"]\n        totp_secret = session[\"tf_totp_secret\"]\n        form.user = current_user\n\n    setattr(form, \"primary_method\", pm)\n    setattr(form, \"tf_totp_secret\", totp_secret)\n    if form.validate_on_submit():\n        # Success - log in user and clear all session variables\n        completion_message = complete_two_factor_process(\n            form.user, pm, totp_secret, changing, session.pop(\"tf_remember_login\", None)\n        )\n        after_this_request(_commit)\n        if not _security._want_json(request):\n            do_flash(*get_message(completion_message))\n            return redirect(get_post_login_redirect())\n\n    # GET or not successful POST\n    if _security._want_json(request):\n        return base_render_json(form)\n\n    # if we were trying to validate a new method\n    if changing:\n        setup_form = _security.two_factor_setup_form()\n\n        return _security.render_template(\n            config_value(\"TWO_FACTOR_SETUP_TEMPLATE\"),\n            two_factor_setup_form=setup_form,\n            two_factor_verify_code_form=form,\n            choices=config_value(\"TWO_FACTOR_ENABLED_METHODS\"),\n            **_ctx(\"tf_setup\")\n        )\n\n    # if we were trying to validate an existing method\n    else:\n        rescue_form = _security.two_factor_rescue_form()\n\n        return _security.render_template(\n            config_value(\"TWO_FACTOR_VERIFY_CODE_TEMPLATE\"),\n            two_factor_rescue_form=rescue_form,\n            two_factor_verify_code_form=form,\n            problem=None,\n            **_ctx(\"tf_token_validation\")\n        )\n\n\n@anonymous_user_required\n@unauth_csrf(fall_through=True)\ndef two_factor_rescue():\n    \"\"\" Function that handles a situation where user can't\n    enter his two-factor validation code\n\n    User must have already provided valid username/password.\n    User must have already established 2FA\n\n    \"\"\"\n\n    form_class = _security.two_factor_rescue_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if (\n        not all(k in session for k in [\"tf_user_id\", \"tf_state\"])\n        or session[\"tf_state\"] != \"ready\"\n    ):\n        tf_clean_session()\n        return _tf_illegal_state(form, _security.login_url)\n\n    user = _datastore.get_user(session[\"tf_user_id\"])\n    form.user = user\n    if not user:\n        tf_clean_session()\n        return _tf_illegal_state(form, _security.login_url)\n\n    rproblem = \"\"\n    if form.validate_on_submit():\n        problem = form.data[\"help_setup\"]\n        rproblem = problem\n        # if the problem is that user can't access his device, w\n        # e send him code through mail\n        if problem == \"lost_device\":\n            msg = form.user.tf_send_security_token(\n                method=\"email\",\n                totp_secret=form.user.tf_totp_secret,\n                phone_number=getattr(form.user, \"tf_phone_number\", None),\n            )\n            if msg:\n                rproblem = \"\"\n                form.help_setup.errors.append(msg)\n                if _security._want_json(request):\n                    return base_render_json(\n                        form, include_user=False, error_status_code=500\n                    )\n        # send app provider a mail message regarding trouble\n        elif problem == \"no_mail_access\":\n            _security._send_mail(\n                config_value(\"EMAIL_SUBJECT_TWO_FACTOR_RESCUE\"),\n                config_value(\"TWO_FACTOR_RESCUE_MAIL\"),\n                \"two_factor_rescue\",\n                user=form.user,\n            )\n        else:\n            return \"\", 404\n\n    if _security._want_json(request):\n        return base_render_json(form, include_user=False)\n\n    code_form = _security.two_factor_verify_code_form()\n    return _security.render_template(\n        config_value(\"TWO_FACTOR_VERIFY_CODE_TEMPLATE\"),\n        two_factor_verify_code_form=code_form,\n        two_factor_rescue_form=form,\n        rescue_mail=config_value(\"TWO_FACTOR_RESCUE_MAIL\"),\n        problem=rproblem,\n        **_ctx(\"tf_token_validation\")\n    )\n\n\n@auth_required(\"basic\", \"session\", \"token\")\ndef two_factor_verify_password():\n    \"\"\"View function which handles a password verification request.\"\"\"\n    form_class = _security.two_factor_verify_password_form\n\n    if request.is_json:\n        form = form_class(MultiDict(request.get_json()), meta=suppress_form_csrf())\n    else:\n        form = form_class(meta=suppress_form_csrf())\n\n    if form.validate_on_submit():\n        # form called verify_and_update_password()\n        after_this_request(_commit)\n        session[\"tf_confirmed\"] = True\n        m, c = get_message(\"TWO_FACTOR_PASSWORD_CONFIRMATION_DONE\")\n        if not _security._want_json(request):\n            do_flash(m, c)\n            return redirect(url_for_security(\"two_factor_setup\"))\n        else:\n            return _security._render_json(json_error_response(m), 400, None, None)\n\n    if _security._want_json(request):\n        assert form.user == current_user\n        # form.user = current_user\n        return base_render_json(form)\n\n    return _security.render_template(\n        config_value(\"TWO_FACTOR_VERIFY_PASSWORD_TEMPLATE\"),\n        two_factor_verify_password_form=form,\n        **_ctx(\"tf_verify_password\")\n    )\n\n\n@unauth_csrf(fall_through=True)\ndef two_factor_qrcode():\n    if current_user.is_authenticated:\n        user = current_user\n    else:\n        if \"tf_user_id\" not in session:\n            abort(404)\n        user = _datastore.get_user(session[\"tf_user_id\"])\n        if not user:\n            # Seems like we should be careful here if user_id is gone.\n            tf_clean_session()\n            abort(404)\n\n    if \"authenticator\" not in config_value(\"TWO_FACTOR_ENABLED_METHODS\"):\n        return abort(404)\n    if (\n        \"tf_primary_method\" not in session\n        or session[\"tf_primary_method\"] != \"authenticator\"\n    ):\n        return abort(404)\n\n    totp = user.tf_totp_secret\n    if \"tf_totp_secret\" in session:\n        totp = session[\"tf_totp_secret\"]\n    try:\n        import pyqrcode\n\n        # By convention, the URI should have the username that the user\n        # logs in with.\n        username = user.calc_username()\n        url = pyqrcode.create(\n            _security._totp_factory.get_totp_uri(\n                username if username else \"Unknown\", totp\n            )\n        )\n    except ImportError:\n        # For TWO_FACTOR - this should have been checked at app init.\n        raise\n    from io import BytesIO\n\n    stream = BytesIO()\n    url.svg(stream, scale=3)\n    return (\n        stream.getvalue(),\n        200,\n        {\n            \"Content-Type\": \"image/svg+xml\",\n            \"Cache-Control\": \"no-cache, no-store, must-revalidate\",\n            \"Pragma\": \"no-cache\",\n            \"Expires\": \"0\",\n        },\n    )\n\n\ndef _tf_illegal_state(form, redirect_to):\n    m, c = get_message(\"TWO_FACTOR_PERMISSION_DENIED\")\n    if not _security._want_json(request):\n        do_flash(m, c)\n        return redirect(get_url(redirect_to))\n    else:\n        return _security._render_json(json_error_response(m), 400, None, None)\n\n\ndef create_blueprint(app, state, import_name, json_encoder=None):\n    \"\"\"Creates the security extension blueprint\"\"\"\n\n    bp = Blueprint(\n        state.blueprint_name,\n        import_name,\n        url_prefix=state.url_prefix,\n        subdomain=state.subdomain,\n        template_folder=\"templates\",\n    )\n    if json_encoder:\n        bp.json_encoder = json_encoder\n\n    if state.logout_methods is not None:\n        bp.route(state.logout_url, methods=state.logout_methods, endpoint=\"logout\")(\n            logout\n        )\n\n    if state.passwordless:\n        bp.route(state.login_url, methods=[\"GET\", \"POST\"], endpoint=\"login\")(send_login)\n        bp.route(\n            state.login_url + slash_url_suffix(state.login_url, \"<token>\"),\n            endpoint=\"token_login\",\n        )(token_login)\n    elif config_value(\"US_SIGNIN_REPLACES_LOGIN\", app=app):\n        bp.route(state.login_url, methods=[\"GET\", \"POST\"], endpoint=\"login\")(us_signin)\n\n    else:\n        bp.route(state.login_url, methods=[\"GET\", \"POST\"], endpoint=\"login\")(login)\n\n    bp.route(state.verify_url, methods=[\"GET\", \"POST\"], endpoint=\"verify\")(verify)\n\n    if state.unified_signin:\n        bp.route(state.us_signin_url, methods=[\"GET\", \"POST\"], endpoint=\"us_signin\")(\n            us_signin\n        )\n        bp.route(\n            state.us_signin_send_code_url,\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"us_signin_send_code\",\n        )(us_signin_send_code)\n        bp.route(state.us_setup_url, methods=[\"GET\", \"POST\"], endpoint=\"us_setup\")(\n            us_setup\n        )\n        bp.route(\n            state.us_setup_url + slash_url_suffix(state.us_setup_url, \"<token>\"),\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"us_setup_validate\",\n        )(us_setup_validate)\n\n        # Freshness verification\n        if config_value(\"FRESHNESS\", app=app).total_seconds() >= 0:\n            bp.route(\n                state.us_verify_url, methods=[\"GET\", \"POST\"], endpoint=\"us_verify\"\n            )(us_verify)\n            bp.route(\n                state.us_verify_send_code_url,\n                methods=[\"GET\", \"POST\"],\n                endpoint=\"us_verify_send_code\",\n            )(us_verify_send_code)\n\n        bp.route(state.us_verify_link_url, methods=[\"GET\"], endpoint=\"us_verify_link\")(\n            us_verify_link\n        )\n        bp.route(\n            state.us_qrcode_url + slash_url_suffix(state.us_setup_url, \"<token>\"),\n            endpoint=\"us_qrcode\",\n        )(us_qrcode)\n\n    if state.two_factor:\n        tf_token_validation = \"two_factor_token_validation\"\n        tf_qrcode = \"two_factor_qrcode\"\n        bp.route(\n            state.two_factor_setup_url,\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"two_factor_setup\",\n        )(two_factor_setup)\n        bp.route(\n            state.two_factor_token_validation_url,\n            methods=[\"GET\", \"POST\"],\n            endpoint=tf_token_validation,\n        )(two_factor_token_validation)\n        bp.route(state.two_factor_qrcode_url, endpoint=tf_qrcode)(two_factor_qrcode)\n        bp.route(\n            state.two_factor_rescue_url,\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"two_factor_rescue\",\n        )(two_factor_rescue)\n        bp.route(\n            state.two_factor_confirm_url,\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"two_factor_verify_password\",\n        )(two_factor_verify_password)\n\n    if state.registerable:\n        bp.route(state.register_url, methods=[\"GET\", \"POST\"], endpoint=\"register\")(\n            register\n        )\n\n    if state.recoverable:\n        bp.route(state.reset_url, methods=[\"GET\", \"POST\"], endpoint=\"forgot_password\")(\n            forgot_password\n        )\n        bp.route(\n            state.reset_url + slash_url_suffix(state.reset_url, \"<token>\"),\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"reset_password\",\n        )(reset_password)\n\n    if state.changeable:\n        bp.route(state.change_url, methods=[\"GET\", \"POST\"], endpoint=\"change_password\")(\n            change_password\n        )\n\n    if state.confirmable:\n        bp.route(\n            state.confirm_url, methods=[\"GET\", \"POST\"], endpoint=\"send_confirmation\"\n        )(send_confirmation)\n        bp.route(\n            state.confirm_url + slash_url_suffix(state.confirm_url, \"<token>\"),\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"confirm_email\",\n        )(confirm_email)\n\n    return bp\n", "[pytest]\naddopts = -rs --cov flask_security --cov-report term-missing --flake8 --cache-clear\nflake8-max-line-length = 88\nflake8-ignore =\n    tests/view_scaffold.py E402\n    async_compat.py ALL\n", "# -*- coding: utf-8 -*-\n\n\"\"\"Simple security for Flask apps.\"\"\"\n\nimport io\nimport re\nfrom setuptools import find_packages, setup\n\nwith io.open(\"README.rst\", \"rt\", encoding=\"utf8\") as f:\n    readme = f.read()\n\nwith io.open(\"flask_security/__init__.py\", \"rt\", encoding=\"utf8\") as f:\n    version = re.search(r'__version__ = \"(.*?)\"', f.read()).group(1)\n\ntests_require = [\n    \"Flask-Mongoengine~=0.9.5\",\n    \"peewee>=3.11.2\",\n    \"Flask-SQLAlchemy>=2.3\",\n    \"argon2_cffi>=19.1.0\",\n    \"bcrypt>=3.1.5\",\n    \"cachetools>=3.1.0\",\n    \"check-manifest>=0.25\",\n    \"coverage>=4.5.4\",\n    \"cryptography>=2.3.1\",\n    \"isort>=4.2.2\",\n    \"mock>=1.3.0\",\n    \"mongoengine~=0.19.1\",\n    \"mongomock~=3.19.0\",\n    \"msgcheck>=2.9\",\n    \"pony>=0.7.11\",\n    \"phonenumberslite>=8.11.1\",\n    \"psycopg2>=2.8.4\",\n    \"pydocstyle>=1.0.0\",\n    \"pymysql>=0.9.3\",\n    \"pyqrcode>=1.2\",\n    \"pytest==4.6.11\",\n    \"pytest-black>=0.3.8\",\n    \"pytest-cache>=1.0\",\n    \"pytest-cov>=2.5.1\",\n    \"pytest-flake8>=1.0.6\",\n    \"pytest-mongo>=1.2.1\",\n    \"pytest>=3.5.1\",\n    \"sqlalchemy>=1.2.6\",\n    \"sqlalchemy-utils>=0.33.0\",\n    \"werkzeug>=0.15.5\",\n    \"zxcvbn~=4.4.28\",\n]\n\nextras_require = {\n    \"docs\": [\"Pallets-Sphinx-Themes>=1.2.0\", \"Sphinx>=1.8.5\", \"sphinx-issues>=1.2.0\"],\n    \"tests\": tests_require,\n}\n\nextras_require[\"all\"] = []\nfor reqs in extras_require.values():\n    extras_require[\"all\"].extend(reqs)\n\nsetup_requires = [\"Babel>=1.3\", \"pytest-runner>=2.6.2\", \"twine\", \"wheel\"]\n\ninstall_requires = [\n    \"Flask>=1.0.2\",\n    \"Flask-Login>=0.4.1\",\n    \"Flask-Mail>=0.9.1\",\n    \"Flask-Principal>=0.4.0\",\n    \"Flask-WTF>=0.14.2\",\n    \"Flask-BabelEx>=0.9.3\",\n    \"email-validator>=1.0.5\",\n    \"itsdangerous>=1.1.0\",\n    \"passlib>=1.7.1\",\n]\n\npackages = find_packages()\n\nsetup(\n    name=\"Flask-Security-Too\",\n    version=version,\n    description=__doc__,\n    long_description=readme,\n    keywords=\"flask security\",\n    license=\"MIT\",\n    author=\"Matt Wright & Chris Wagner\",\n    author_email=\"jwag.wagner+github@gmail.com\",\n    url=\"https://github.com/Flask-Middleware/flask-security\",\n    project_urls={\n        \"Documentation\": \"https://flask-security-too.readthedocs.io\",\n        \"Releases\": \"https://pypi.org/project/Flask-Security-Too/\",\n        \"Code\": \"https://github.com/Flask-Middleware/flask-security\",\n        \"Issue tracker\": \"https://github.com/Flask-Middleware/flask-security/issues\",\n    },\n    packages=packages,\n    zip_safe=False,\n    include_package_data=True,\n    platforms=\"any\",\n    python_requires=\">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*\",\n    extras_require=extras_require,\n    install_requires=install_requires,\n    setup_requires=setup_requires,\n    tests_require=tests_require,\n    classifiers=[\n        \"Environment :: Web Environment\",\n        \"Framework :: Flask\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python\",\n        \"Topic :: Internet :: WWW/HTTP :: Dynamic Content\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n        \"Programming Language :: Python :: 2\",\n        \"Programming Language :: Python :: 2.7\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.5\",\n        \"Programming Language :: Python :: 3.6\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: Implementation :: CPython\",\n        \"Programming Language :: Python :: Implementation :: PyPy\",\n        \"Development Status :: 4 - Beta\",\n    ],\n)\n", "# -*- coding: utf-8 -*-\n\"\"\"\n    test_common\n    ~~~~~~~~~~~\n\n    Test common functionality\n\n    :copyright: (c) 2019 by J. Christopher Wagner (jwag).\n    :license: MIT, see LICENSE for more details.\n\"\"\"\n\nimport base64\nimport json\nimport pytest\n\nfrom flask import Blueprint\n\nfrom utils import (\n    authenticate,\n    json_authenticate,\n    get_num_queries,\n    logout,\n    populate_data,\n    verify_token,\n)\n\ntry:\n    from cookielib import Cookie\nexcept ImportError:\n    from http.cookiejar import Cookie\n\n\ndef test_login_view(client):\n    response = client.get(\"/login\")\n    assert b\"<h1>Login</h1>\" in response.data\n\n\ndef test_authenticate(client):\n    response = authenticate(client)\n    assert response.status_code == 302\n    response = authenticate(client, follow_redirects=True)\n    assert b\"Welcome matt@lp.com\" in response.data\n\n\ndef test_authenticate_with_next(client):\n    data = dict(email=\"matt@lp.com\", password=\"password\")\n    response = client.post(\"/login?next=/page1\", data=data, follow_redirects=True)\n    assert b\"Page 1\" in response.data\n\n\ndef test_authenticate_with_next_bp(app, client):\n    api = Blueprint(\"api\", __name__)\n\n    @api.route(\"/info\")\n    def info():\n        pass\n\n    app.register_blueprint(api, url_prefix=\"/api\")\n    data = dict(email=\"matt@lp.com\", password=\"password\")\n    response = client.post(\"/login?next=api.info\", data=data, follow_redirects=False)\n    assert response.status_code == 302\n    assert \"api/info\" in response.location\n\n\ndef test_authenticate_with_invalid_next(client, get_message):\n    data = dict(email=\"matt@lp.com\", password=\"password\")\n    response = client.post(\"/login?next=http://google.com\", data=data)\n    assert get_message(\"INVALID_REDIRECT\") in response.data\n\n\ndef test_authenticate_with_invalid_malformed_next(client, get_message):\n    data = dict(email=\"matt@lp.com\", password=\"password\")\n    response = client.post(\"/login?next=http:///google.com\", data=data)\n    assert get_message(\"INVALID_REDIRECT\") in response.data\n\n\ndef test_authenticate_case_insensitive_email(app, client):\n    response = authenticate(client, \"MATT@lp.com\", follow_redirects=True)\n    assert b\"Welcome matt@lp.com\" in response.data\n\n\ndef test_authenticate_with_invalid_input(client, get_message):\n    response = client.post(\n        \"/login\", data=\"{}\", headers={\"Content-Type\": \"application/json\"}\n    )\n    assert get_message(\"EMAIL_NOT_PROVIDED\") in response.data\n\n\n@pytest.mark.settings(post_login_view=\"/post_login\")\ndef test_get_already_authenticated(client):\n    response = authenticate(client, follow_redirects=True)\n    assert b\"Welcome matt@lp.com\" in response.data\n    response = client.get(\"/login\", follow_redirects=True)\n    assert b\"Post Login\" in response.data\n\n\n@pytest.mark.settings(post_login_view=\"/post_login\")\ndef test_get_already_authenticated_next(client):\n    response = authenticate(client, follow_redirects=True)\n    assert b\"Welcome matt@lp.com\" in response.data\n    # This should NOT override post_login_view due to potential redirect loops.\n    response = client.get(\"/login?next=/page1\", follow_redirects=True)\n    assert b\"Post Login\" in response.data\n\n\n@pytest.mark.settings(post_login_view=\"/post_login\")\ndef test_post_already_authenticated(client):\n    response = authenticate(client, follow_redirects=True)\n    assert b\"Welcome matt@lp.com\" in response.data\n    data = dict(email=\"matt@lp.com\", password=\"password\")\n    response = client.post(\"/login\", data=data, follow_redirects=True)\n    assert b\"Post Login\" in response.data\n    # This should NOT override post_login_view due to potential redirect loops.\n    response = client.post(\"/login?next=/page1\", data=data, follow_redirects=True)\n    assert b\"Post Login\" in response.data\n\n\ndef test_login_form(client):\n    response = client.post(\"/login\", data={\"email\": \"matt@lp.com\"})\n    assert b\"matt@lp.com\" in response.data\n\n\ndef test_unprovided_username(client, get_message):\n    response = authenticate(client, \"\")\n    assert get_message(\"EMAIL_NOT_PROVIDED\") in response.data\n\n\ndef test_unprovided_password(client, get_message):\n    response = authenticate(client, password=\"\")\n    assert get_message(\"PASSWORD_NOT_PROVIDED\") in response.data\n\n\ndef test_invalid_user(client, get_message):\n    response = authenticate(client, email=\"bogus@bogus.com\")\n    assert get_message(\"USER_DOES_NOT_EXIST\") in response.data\n\n\ndef test_bad_password(client, get_message):\n    response = authenticate(client, password=\"bogus\")\n    assert get_message(\"INVALID_PASSWORD\") in response.data\n\n\ndef test_inactive_user(client, get_message):\n    response = authenticate(client, \"tiya@lp.com\", \"password\")\n    assert get_message(\"DISABLED_ACCOUNT\") in response.data\n\n\ndef test_inactive_forbids(app, client, get_message):\n    \"\"\" Make sure that existing session doesn't work after\n    user marked inactive\n    \"\"\"\n    response = authenticate(client, follow_redirects=True)\n    assert response.status_code == 200\n    # make sure can access restricted page\n    response = client.get(\"/profile\", follow_redirects=True)\n    assert b\"Profile Page\" in response.data\n\n    # deactivate matt\n    with app.test_request_context(\"/\"):\n        user = app.security.datastore.find_user(email=\"matt@lp.com\")\n        app.security.datastore.deactivate_user(user)\n        app.security.datastore.commit()\n\n    response = client.get(\"/profile\", follow_redirects=True)\n    # should be thrown back to login page.\n    assert response.status_code == 200\n    assert b\"Please log in to access this page\" in response.data\n\n\n@pytest.mark.settings(unauthorized_view=None)\ndef test_inactive_forbids_token(app, client_nc, get_message):\n    \"\"\" Make sure that existing token doesn't work after\n    user marked inactive\n    \"\"\"\n    response = json_authenticate(client_nc)\n    assert response.status_code == 200\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    headers = {\"Authentication-Token\": token}\n    # make sure can access restricted page\n    response = client_nc.get(\"/token\", headers=headers)\n    assert b\"Token Authentication\" in response.data\n\n    # deactivate matt\n    with app.test_request_context(\"/\"):\n        user = app.security.datastore.find_user(email=\"matt@lp.com\")\n        app.security.datastore.deactivate_user(user)\n        app.security.datastore.commit()\n\n    response = client_nc.get(\"/token\", content_type=\"application/json\", headers=headers)\n    assert response.status_code == 401\n\n\ndef test_unset_password(client, get_message):\n    response = authenticate(client, \"jess@lp.com\", \"password\")\n    assert get_message(\"PASSWORD_NOT_SET\") in response.data\n\n\ndef test_logout(client):\n    authenticate(client)\n    response = logout(client, follow_redirects=True)\n    assert b\"Home Page\" in response.data\n\n\ndef test_logout_post(client):\n    authenticate(client)\n    response = client.post(\"/logout\", content_type=\"application/json\")\n    assert response.status_code == 200\n    assert response.json[\"meta\"][\"code\"] == 200\n\n\ndef test_logout_with_next_invalid(client, get_message):\n    authenticate(client)\n    response = client.get(\"/logout?next=http://google.com\")\n    assert \"google.com\" not in response.location\n\n\ndef test_logout_with_next(client):\n    authenticate(client)\n    response = client.get(\"/logout?next=/page1\", follow_redirects=True)\n    assert b\"Page 1\" in response.data\n\n\ndef test_missing_session_access(client, get_message):\n    response = client.get(\"/profile\", follow_redirects=True)\n    assert get_message(\"LOGIN\") in response.data\n\n\ndef test_has_session_access(client):\n    authenticate(client)\n    response = client.get(\"/profile\", follow_redirects=True)\n    assert b\"profile\" in response.data\n\n\ndef test_authorized_access(client):\n    authenticate(client)\n    response = client.get(\"/admin\")\n    assert b\"Admin Page\" in response.data\n\n\ndef test_unauthorized_access(client, get_message):\n    authenticate(client, \"joe@lp.com\")\n    response = client.get(\"/admin\", follow_redirects=True)\n    assert response.status_code == 403\n\n\n@pytest.mark.settings(unauthorized_view=lambda: None)\ndef test_unauthorized_access_with_referrer(client, get_message):\n    authenticate(client, \"joe@lp.com\")\n    response = client.get(\"/admin\", headers={\"referer\": \"/admin\"})\n    assert response.headers[\"Location\"] != \"/admin\"\n    client.get(response.headers[\"Location\"])\n\n    response = client.get(\n        \"/admin?a=b\", headers={\"referer\": \"http://localhost/admin?x=y\"}\n    )\n    assert response.headers[\"Location\"] == \"http://localhost/\"\n    client.get(response.headers[\"Location\"])\n\n    response = client.get(\n        \"/admin\", headers={\"referer\": \"/admin\"}, follow_redirects=True\n    )\n    assert response.data.count(get_message(\"UNAUTHORIZED\")) == 1\n\n    # When referrer is from another path and unauthorized,\n    # we expect a temp redirect (302) to the referer\n    response = client.get(\"/admin?w=s\", headers={\"referer\": \"/profile\"})\n    assert response.status_code == 302\n    assert response.headers[\"Location\"] == \"http://localhost/profile\"\n\n\n@pytest.mark.settings(unauthorized_view=\"/unauthz\")\ndef test_roles_accepted(clients):\n    # This specificaly tests that we can pass a URL for unauthorized_view.\n    for user in (\"matt@lp.com\", \"joe@lp.com\"):\n        authenticate(clients, user)\n        response = clients.get(\"/admin_or_editor\")\n        assert b\"Admin or Editor Page\" in response.data\n        logout(clients)\n\n    authenticate(clients, \"jill@lp.com\")\n    response = clients.get(\"/admin_or_editor\", follow_redirects=True)\n    assert b\"Unauthorized\" in response.data\n\n\n@pytest.mark.settings(unauthorized_view=\"unauthz\")\ndef test_permissions_accepted(clients):\n    for user in (\"matt@lp.com\", \"joe@lp.com\"):\n        authenticate(clients, user)\n        response = clients.get(\"/admin_perm\")\n        assert b\"Admin Page with full-write or super\" in response.data\n        logout(clients)\n\n    authenticate(clients, \"jill@lp.com\")\n    response = clients.get(\"/admin_perm\", follow_redirects=True)\n    assert b\"Unauthorized\" in response.data\n\n\n@pytest.mark.settings(unauthorized_view=\"unauthz\")\ndef test_permissions_required(clients):\n    for user in [\"matt@lp.com\"]:\n        authenticate(clients, user)\n        response = clients.get(\"/admin_perm_required\")\n        assert b\"Admin Page required\" in response.data\n        logout(clients)\n\n    authenticate(clients, \"joe@lp.com\")\n    response = clients.get(\"/admin_perm_required\", follow_redirects=True)\n    assert b\"Unauthorized\" in response.data\n\n\n@pytest.mark.settings(unauthorized_view=\"unauthz\")\ndef test_unauthenticated_role_required(client, get_message):\n    response = client.get(\"/admin\", follow_redirects=True)\n    assert get_message(\"UNAUTHORIZED\") in response.data\n\n\n@pytest.mark.settings(unauthorized_view=\"unauthz\")\ndef test_multiple_role_required(clients):\n    for user in (\"matt@lp.com\", \"joe@lp.com\"):\n        authenticate(clients, user)\n        response = clients.get(\"/admin_and_editor\", follow_redirects=True)\n        assert b\"Unauthorized\" in response.data\n        clients.get(\"/logout\")\n\n    authenticate(clients, \"dave@lp.com\")\n    response = clients.get(\"/admin_and_editor\", follow_redirects=True)\n    assert b\"Admin and Editor Page\" in response.data\n\n\ndef test_ok_json_auth(client):\n    response = json_authenticate(client)\n    assert response.json[\"meta\"][\"code\"] == 200\n    assert \"authentication_token\" in response.json[\"response\"][\"user\"]\n\n\ndef test_invalid_json_auth(client):\n    response = json_authenticate(client, password=\"junk\")\n    assert b'\"code\": 400' in response.data\n\n\ndef test_token_auth_via_querystring_valid_token(client):\n    response = json_authenticate(client)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    response = client.get(\"/token?auth_token=\" + token)\n    assert b\"Token Authentication\" in response.data\n\n\ndef test_token_auth_via_header_valid_token(client):\n    response = json_authenticate(client)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    headers = {\"Authentication-Token\": token}\n    response = client.get(\"/token\", headers=headers)\n    assert b\"Token Authentication\" in response.data\n\n\ndef test_token_auth_via_querystring_invalid_token(client):\n    response = client.get(\"/token?auth_token=X\", headers={\"Accept\": \"application/json\"})\n    assert response.status_code == 401\n\n\ndef test_token_auth_via_header_invalid_token(client):\n    response = client.get(\n        \"/token\", headers={\"Authentication-Token\": \"X\", \"Accept\": \"application/json\"}\n    )\n    assert response.status_code == 401\n\n\ndef test_http_auth(client):\n    # browsers expect 401 response with WWW-Authenticate header - which will prompt\n    # them to pop up a login form.\n    response = client.get(\"/http\", headers={})\n    assert response.status_code == 401\n    assert b\"You are not authenticated\" in response.data\n    assert \"WWW-Authenticate\" in response.headers\n    assert 'Basic realm=\"Login Required\"' == response.headers[\"WWW-Authenticate\"]\n\n    # Now provide correct credentials\n    response = client.get(\n        \"/http\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"joe@lp.com:password\").decode(\"utf-8\")\n        },\n    )\n    assert b\"HTTP Authentication\" in response.data\n\n\n@pytest.mark.settings(USER_IDENTITY_ATTRIBUTES=(\"email\", \"username\"))\ndef test_http_auth_username(client):\n    response = client.get(\n        \"/http\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"jill:password\").decode(\"utf-8\")\n        },\n    )\n    assert b\"HTTP Authentication\" in response.data\n\n\ndef test_http_auth_no_authorization(client):\n    response = client.get(\n        \"/http_admin_required\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"joe@lp.com:password\").decode(\"utf-8\")\n        },\n    )\n    assert response.status_code == 403\n\n\ndef test_http_auth_no_authorization_json(client, get_message):\n    response = client.get(\n        \"/http_admin_required\",\n        headers={\n            \"accept\": \"application/json\",\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"joe@lp.com:password\").decode(\"utf-8\"),\n        },\n    )\n    assert response.status_code == 403\n    assert response.headers[\"Content-Type\"] == \"application/json\"\n\n\n@pytest.mark.settings(backwards_compat_unauthn=True)\ndef test_http_auth_no_authentication(client, get_message):\n    response = client.get(\"/http\", headers={})\n    assert response.status_code == 401\n    assert b\"<h1>Unauthorized</h1>\" in response.data\n    assert \"WWW-Authenticate\" in response.headers\n    assert 'Basic realm=\"Login Required\"' == response.headers[\"WWW-Authenticate\"]\n\n\n@pytest.mark.settings(backwards_compat_unauthn=False)\ndef test_http_auth_no_authentication_json(client, get_message):\n    response = client.get(\"/http\", headers={\"accept\": \"application/json\"})\n    assert response.status_code == 401\n    assert response.json[\"response\"][\"error\"].encode(\"utf-8\") == get_message(\n        \"UNAUTHENTICATED\"\n    )\n    assert response.headers[\"Content-Type\"] == \"application/json\"\n    assert \"WWW-Authenticate\" not in response.headers\n\n\n@pytest.mark.settings(backwards_compat_unauthn=True)\ndef test_invalid_http_auth_invalid_username(client):\n    response = client.get(\n        \"/http\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"bogus:bogus\").decode(\"utf-8\")\n        },\n    )\n    assert b\"<h1>Unauthorized</h1>\" in response.data\n    assert \"WWW-Authenticate\" in response.headers\n    assert 'Basic realm=\"Login Required\"' == response.headers[\"WWW-Authenticate\"]\n\n\n@pytest.mark.settings(backwards_compat_unauthn=False)\ndef test_invalid_http_auth_invalid_username_json(client, get_message):\n    # While Basic auth is allowed with JSON - we never expect a WWW-Authenticate\n    # header - since that is captured by most browsers and they pop up a\n    # login form.\n    response = client.get(\n        \"/http\",\n        headers={\n            \"accept\": \"application/json\",\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"bogus:bogus\").decode(\"utf-8\"),\n        },\n    )\n    assert response.status_code == 401\n    assert response.json[\"response\"][\"error\"].encode(\"utf-8\") == get_message(\n        \"UNAUTHENTICATED\"\n    )\n    assert response.headers[\"Content-Type\"] == \"application/json\"\n    assert \"WWW-Authenticate\" not in response.headers\n\n\n@pytest.mark.settings(backwards_compat_unauthn=True)\ndef test_invalid_http_auth_bad_password(client):\n    response = client.get(\n        \"/http\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"joe@lp.com:bogus\").decode(\"utf-8\")\n        },\n    )\n    assert b\"<h1>Unauthorized</h1>\" in response.data\n    assert \"WWW-Authenticate\" in response.headers\n    assert 'Basic realm=\"Login Required\"' == response.headers[\"WWW-Authenticate\"]\n\n\n@pytest.mark.settings(backwards_compat_unauthn=True)\ndef test_custom_http_auth_realm(client):\n    response = client.get(\n        \"/http_custom_realm\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"joe@lp.com:bogus\").decode(\"utf-8\")\n        },\n    )\n    assert b\"<h1>Unauthorized</h1>\" in response.data\n    assert \"WWW-Authenticate\" in response.headers\n    assert 'Basic realm=\"My Realm\"' == response.headers[\"WWW-Authenticate\"]\n\n\ndef test_multi_auth_basic(client):\n    response = client.get(\n        \"/multi_auth\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"joe@lp.com:password\").decode(\"utf-8\")\n        },\n    )\n    assert b\"Basic\" in response.data\n\n    response = client.get(\"/multi_auth\")\n    # Default unauthn with basic is to return 401 with WWW-Authenticate Header\n    # so that browser pops up a username/password dialog\n    assert response.status_code == 401\n    assert \"WWW-Authenticate\" in response.headers\n\n\n@pytest.mark.settings(backwards_compat_unauthn=True)\ndef test_multi_auth_basic_invalid(client):\n    response = client.get(\n        \"/multi_auth\",\n        headers={\n            \"Authorization\": \"Basic %s\"\n            % base64.b64encode(b\"bogus:bogus\").decode(\"utf-8\")\n        },\n    )\n    assert b\"<h1>Unauthorized</h1>\" in response.data\n    assert \"WWW-Authenticate\" in response.headers\n    assert 'Basic realm=\"Login Required\"' == response.headers[\"WWW-Authenticate\"]\n\n    response = client.get(\"/multi_auth\")\n    assert response.status_code == 401\n\n\ndef test_multi_auth_token(client):\n    response = json_authenticate(client)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    response = client.get(\"/multi_auth?auth_token=\" + token)\n    assert b\"Token\" in response.data\n\n\ndef test_multi_auth_session(client):\n    authenticate(client)\n    response = client.get(\"/multi_auth\")\n    assert b\"Session\" in response.data\n\n\ndef test_authenticated_loop(client):\n    # If user is already authenticated say via session, and then hits an endpoint\n    # protected with @auth_token_required() - then they will be redirected to the login\n    # page which will simply note the current user is already logged in and redirect\n    # to POST_LOGIN_VIEW. Between 3.3.0 and 3.4.4 - this redirect would honor the 'next'\n    # parameter - thus redirecting back to the endpoint that caused the redirect in the\n    # first place - thus an infinite loop.\n    authenticate(client)\n\n    response = client.get(\"/token\", follow_redirects=True)\n    assert response.status_code == 200\n    assert b\"Home Page\" in response.data\n\n\ndef test_user_deleted_during_session_reverts_to_anonymous_user(app, client):\n    authenticate(client)\n\n    with app.test_request_context(\"/\"):\n        user = app.security.datastore.find_user(email=\"matt@lp.com\")\n        app.security.datastore.delete_user(user)\n        app.security.datastore.commit()\n\n    response = client.get(\"/\")\n    assert b\"Hello matt@lp.com\" not in response.data\n\n\ndef test_remember_token(client):\n    response = authenticate(client, follow_redirects=False)\n    client.cookie_jar.clear_session_cookies()\n    response = client.get(\"/profile\")\n    assert b\"profile\" in response.data\n\n\ndef test_request_loader_does_not_fail_with_invalid_token(client):\n    c = Cookie(\n        version=0,\n        name=\"remember_token\",\n        value=\"None\",\n        port=None,\n        port_specified=False,\n        domain=\"www.example.com\",\n        domain_specified=False,\n        domain_initial_dot=False,\n        path=\"/\",\n        path_specified=True,\n        secure=False,\n        expires=None,\n        discard=True,\n        comment=None,\n        comment_url=None,\n        rest={\"HttpOnly\": None},\n        rfc2109=False,\n    )\n\n    client.cookie_jar.set_cookie(c)\n    response = client.get(\"/\")\n    assert b\"BadSignature\" not in response.data\n\n\ndef test_sending_auth_token_with_json(client):\n    response = json_authenticate(client)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    data = '{\"auth_token\": \"%s\"}' % token\n    response = client.post(\n        \"/token\", data=data, headers={\"Content-Type\": \"application/json\"}\n    )\n    assert b\"Token Authentication\" in response.data\n\n\ndef test_json_not_dict(client):\n    response = client.post(\n        \"/json\",\n        data=json.dumps([\"thing1\", \"thing2\"]),\n        headers={\"Content-Type\": \"application/json\"},\n    )\n    assert response.status_code == 200\n\n\ndef test_login_info(client):\n    # Make sure we can get user info when logged in already.\n\n    json_authenticate(client)\n    response = client.get(\"/login\", headers={\"Content-Type\": \"application/json\"})\n    assert response.status_code == 200\n    assert response.json[\"response\"][\"user\"][\"id\"] == \"1\"\n    assert \"last_update\" in response.json[\"response\"][\"user\"]\n\n    response = client.get(\"/login\", headers={\"Accept\": \"application/json\"})\n    assert response.status_code == 200\n    assert response.json[\"response\"][\"user\"][\"id\"] == \"1\"\n    assert \"last_update\" in response.json[\"response\"][\"user\"]\n\n\n@pytest.mark.registerable()\n@pytest.mark.settings(post_login_view=\"/anon_required\")\ndef test_anon_required(client, get_message):\n    \"\"\" If logged in, should get 'anonymous_user_required' redirect \"\"\"\n    response = authenticate(client, follow_redirects=False)\n    response = client.get(\"/register\")\n    assert \"location\" in response.headers\n    assert \"/anon_required\" in response.location\n\n\n@pytest.mark.registerable()\n@pytest.mark.settings(post_login_view=\"/anon_required\")\ndef test_anon_required_json(client, get_message):\n    \"\"\" If logged in, should get 'anonymous_user_required' response \"\"\"\n    authenticate(client, follow_redirects=False)\n    response = client.get(\"/register\", headers={\"Accept\": \"application/json\"})\n    assert response.status_code == 400\n    assert response.json[\"response\"][\"error\"].encode(\"utf-8\") == get_message(\n        \"ANONYMOUS_USER_REQUIRED\"\n    )\n\n\n@pytest.mark.settings(security_hashing_schemes=[\"sha256_crypt\"])\n@pytest.mark.skip\ndef test_auth_token_speed(app, client_nc):\n    # To run with old algorithm you have to comment out fs_uniquifier check in UserMixin\n    import timeit\n\n    response = json_authenticate(client_nc)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n\n    def time_get():\n        rp = client_nc.get(\n            \"/login\",\n            data={},\n            headers={\"Content-Type\": \"application/json\", \"Authentication-Token\": token},\n        )\n        assert rp.status_code == 200\n\n    t = timeit.timeit(time_get, number=50)\n    print(\"Time for 50 iterations: \", t)\n\n\ndef test_change_uniquifier(app, client_nc):\n    # make sure that existing token no longer works once we change the uniquifier\n\n    response = json_authenticate(client_nc)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    verify_token(client_nc, token)\n\n    # now change uniquifier\n    with app.test_request_context(\"/\"):\n        user = app.security.datastore.find_user(email=\"matt@lp.com\")\n        app.security.datastore.reset_user_access(user)\n        app.security.datastore.commit()\n\n    verify_token(client_nc, token, status=401)\n\n    # get new token and verify it works\n    response = json_authenticate(client_nc)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    verify_token(client_nc, token)\n\n\ndef test_token_query(in_app_context):\n    # Verify that when authenticating with auth token (and not session)\n    # that there is just one DB query to get user.\n    app = in_app_context\n    populate_data(app)\n    client_nc = app.test_client(use_cookies=False)\n\n    response = json_authenticate(client_nc)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    current_nqueries = get_num_queries(app.security.datastore)\n\n    response = client_nc.get(\n        \"/token\",\n        headers={\"Content-Type\": \"application/json\", \"Authentication-Token\": token},\n    )\n    assert response.status_code == 200\n    end_nqueries = get_num_queries(app.security.datastore)\n    assert current_nqueries is None or end_nqueries == (current_nqueries + 1)\n\n\ndef test_session_query(in_app_context):\n    # Verify that when authenticating with auth token (but also sending session)\n    # that there are 2 DB queries to get user.\n    # This is since the session will load one - but auth_token_required needs to\n    # verify that the TOKEN is valid (and it is possible that the user_id in the\n    # session is different that the one in the token (huh?)\n    app = in_app_context\n    populate_data(app)\n    client = app.test_client()\n\n    response = json_authenticate(client)\n    token = response.json[\"response\"][\"user\"][\"authentication_token\"]\n    current_nqueries = get_num_queries(app.security.datastore)\n\n    response = client.get(\n        \"/token\",\n        headers={\"Content-Type\": \"application/json\", \"Authentication-Token\": token},\n    )\n    assert response.status_code == 200\n    end_nqueries = get_num_queries(app.security.datastore)\n    assert current_nqueries is None or end_nqueries == (current_nqueries + 2)\n\n\n@pytest.mark.changeable()\ndef test_no_get_auth_token(app, client):\n    # Test that GETs don't return an auth token. This is a security issue since\n    # GETs aren't protected with CSRF\n    authenticate(client)\n    response = client.get(\n        \"/login?include_auth_token\", headers={\"Content-Type\": \"application/json\"}\n    )\n    assert \"authentication_token\" not in response.json[\"response\"][\"user\"]\n\n    data = dict(\n        password=\"password\",\n        new_password=\"new strong password\",\n        new_password_confirm=\"new strong password\",\n    )\n    response = client.get(\n        \"/change?include_auth_token\",\n        json=data,\n        headers={\"Content-Type\": \"application/json\"},\n    )\n    assert \"authentication_token\" not in response.json[\"response\"][\"user\"]\n"], "filenames": ["CHANGES.rst", "docs/openapi.yaml", "flask_security/views.py", "pytest.ini", "setup.py", "tests/test_common.py"], "buggy_code_start_loc": [15, 13, 184, 2, 16, 751], "buggy_code_end_loc": [15, 34, 635, 3, 29, 751], "fixing_code_start_loc": [16, 13, 184, 2, 16, 752], "fixing_code_end_loc": [47, 31, 638, 3, 29, 775], "type": "CWE-352", "message": "The Python \"Flask-Security-Too\" package is used for adding security features to your Flask application. It is an is a independently maintained version of Flask-Security based on the 3.0.0 version of Flask-Security. In Flask-Security-Too from version 3.3.0 and before version 3.4.5, the /login and /change endpoints can return the authenticated user's authentication token in response to a GET request. Since GET requests aren't protected with a CSRF token, this could lead to a malicious 3rd party site acquiring the authentication token. Version 3.4.5 and version 4.0.0 are patched. As a workaround, if you aren't using authentication tokens - you can set the SECURITY_TOKEN_MAX_AGE to \"0\" (seconds) which should make the token unusable.", "other": {"cve": {"id": "CVE-2021-21241", "sourceIdentifier": "security-advisories@github.com", "published": "2021-01-11T21:15:13.377", "lastModified": "2021-01-19T15:43:12.123", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Python \"Flask-Security-Too\" package is used for adding security features to your Flask application. It is an is a independently maintained version of Flask-Security based on the 3.0.0 version of Flask-Security. In Flask-Security-Too from version 3.3.0 and before version 3.4.5, the /login and /change endpoints can return the authenticated user's authentication token in response to a GET request. Since GET requests aren't protected with a CSRF token, this could lead to a malicious 3rd party site acquiring the authentication token. Version 3.4.5 and version 4.0.0 are patched. As a workaround, if you aren't using authentication tokens - you can set the SECURITY_TOKEN_MAX_AGE to \"0\" (seconds) which should make the token unusable."}, {"lang": "es", "value": "El paquete Python \"Flask-Security-Too\" es usado para agregar funcionalidades de seguridad a su aplicaci\u00f3n Flask.&#xa0;Es una versi\u00f3n mantenida independientemente de Flask-Security basada en la versi\u00f3n 3.0.0 de Flask-Security.&#xa0;En Flask-Security-Too desde la versi\u00f3n 3.3.0 y versiones anteriores a 3.4.5, los endpoints /login y /change pueden devolver el token de autenticaci\u00f3n del usuario autenticado en respuesta a una petici\u00f3n GET.&#xa0;Dado que las peticiones GET no est\u00e1n protegidas con un token CSRF, esto podr\u00eda conllevar a que un sitio de terceros malicioso adquiera el token de autenticaci\u00f3n.&#xa0;La versi\u00f3n 3.4.5 y la versi\u00f3n 4.0.0 est\u00e1n parcheadas.&#xa0;Como soluci\u00f3n temporal, si no est\u00e1 utilizando tokens de autenticaci\u00f3n, puede establecer el SECURITY_TOKEN_MAX_AGE en \"0\" (segundos), lo que deber\u00eda inutilizar el token"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flask-security-too_project:flask-security-too:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3.0", "versionEndExcluding": "3.4.5", "matchCriteriaId": "6955F0BE-FEE7-4B0E-B488-FA537F6B068C"}]}]}], "references": [{"url": "https://github.com/Flask-Middleware/flask-security/commit/61d313150b5f620d0b800896c4f2199005e84b1f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Flask-Middleware/flask-security/commit/6d50ee9169acf813257c37b75babe9c28e83542a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Flask-Middleware/flask-security/pull/422", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Flask-Middleware/flask-security/releases/tag/3.4.5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/Flask-Middleware/flask-security/security/advisories/GHSA-hh7m-rx4f-4vpv", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://pypi.org/project/Flask-Security-Too", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Flask-Middleware/flask-security/commit/61d313150b5f620d0b800896c4f2199005e84b1f"}}