{"buggy_code": ["# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nExceptions raised by the Horizon code and the machinery for handling them.\n\"\"\"\n\nimport logging\nimport sys\n\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.utils.translation import ugettext as _\nfrom cloudfiles import errors as swiftclient\nfrom glanceclient.common import exceptions as glanceclient\nfrom keystoneclient import exceptions as keystoneclient\nfrom novaclient import exceptions as novaclient\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonException(Exception):\n    \"\"\" Base exception class for distinguishing our own exception classes. \"\"\"\n    pass\n\n\nclass Http302(HorizonException):\n    \"\"\"\n    Error class which can be raised from within a handler to cause an\n    early bailout and redirect at the middleware level.\n    \"\"\"\n    status_code = 302\n\n    def __init__(self, location, message=None):\n        self.location = location\n        self.message = message\n\n\nclass NotAuthorized(HorizonException):\n    \"\"\"\n    Raised whenever a user attempts to access a resource which they do not\n    have role-based access to (such as when failing the\n    :func:`~horizon.decorators.require_roles` decorator).\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthorized`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 401\n\n\nclass NotAuthenticated(HorizonException):\n    \"\"\"\n    Raised when a user is trying to make requests and they are not logged in.\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthenticated`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 403\n\n\nclass NotFound(HorizonException):\n    \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\"\n    status_code = 404\n\n\nclass RecoverableError(HorizonException):\n    \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\"\n    status_code = 100  # HTTP status code \"Continue\"\n\n\nclass ServiceCatalogException(HorizonException):\n    \"\"\"\n    Raised when a requested service is not available in the ``ServiceCatalog``\n    returned by Keystone.\n    \"\"\"\n    def __init__(self, service_name):\n        message = 'Invalid service catalog service: %s' % service_name\n        super(ServiceCatalogException, self).__init__(message)\n\n\nclass AlreadyExists(HorizonException):\n    \"\"\"\n    Exception to be raised when trying to create an API resource which\n    already exists.\n    \"\"\"\n    def __init__(self, name, resource_type):\n        self.attrs = {\"name\": name, \"resource\": resource_type}\n        self.msg = 'A %(resource)s with the name \"%(name)s\" already exists.'\n\n    def __repr__(self):\n        return self.msg % self.attrs\n\n    def __unicode__(self):\n        return _(self.msg) % self.attrs\n\n\nclass HandledException(HorizonException):\n    \"\"\"\n    Used internally to track exceptions that have gone through\n    :func:`horizon.exceptions.handle` more than once.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n\nHORIZON_CONFIG = getattr(settings, \"HORIZON_CONFIG\", {})\nEXCEPTION_CONFIG = HORIZON_CONFIG.get(\"exceptions\", {})\n\n\nUNAUTHORIZED = (keystoneclient.Unauthorized,\n                keystoneclient.Forbidden,\n                novaclient.Unauthorized,\n                novaclient.Forbidden,\n                glanceclient.AuthorizationFailure,\n                glanceclient.Unauthorized,\n                swiftclient.AuthenticationFailed,\n                swiftclient.AuthenticationError)\nUNAUTHORIZED += tuple(EXCEPTION_CONFIG.get('unauthorized', []))\n\nNOT_FOUND = (keystoneclient.NotFound,\n             novaclient.NotFound,\n             glanceclient.NotFound,\n             swiftclient.NoSuchContainer,\n             swiftclient.NoSuchObject)\nNOT_FOUND += tuple(EXCEPTION_CONFIG.get('not_found', []))\n\n\n# NOTE(gabriel): This is very broad, and may need to be dialed in.\nRECOVERABLE = (keystoneclient.ClientException,\n               # AuthorizationFailure is raised when Keystone is \"unavailable\".\n               keystoneclient.AuthorizationFailure,\n               novaclient.ClientException,\n               glanceclient.ClientException,\n               swiftclient.Error,\n               AlreadyExists)\nRECOVERABLE += tuple(EXCEPTION_CONFIG.get('recoverable', []))\n\n\ndef handle(request, message=None, redirect=None, ignore=False, escalate=False):\n    \"\"\" Centralized error handling for Horizon.\n\n    Because Horizon consumes so many different APIs with completely\n    different ``Exception`` types, it's necessary to have a centralized\n    place for handling exceptions which may be raised.\n\n    Exceptions are roughly divided into 3 types:\n\n    #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization\n       problems. These result in being logged out and sent to the login screen.\n    #. ``NOT_FOUND``: Errors resulting from objects which could not be\n       located via the API. These generally result in a user-facing error\n       message, but are otherwise returned to the normal code flow. Optionally\n       a redirect value may be passed to the error handler so users are\n       returned to a different view than the one requested in addition to the\n       error message.\n    #. RECOVERABLE: Generic API errors which generate a user-facing message\n       but drop directly back to the regular code flow.\n\n    All other exceptions bubble the stack as normal unless the ``ignore``\n    argument is passed in as ``True``, in which case only unrecognized\n    errors are bubbled.\n\n    If the exception is not re-raised, an appropriate wrapper exception\n    class indicating the type of exception that was encountered will be\n    returned.\n    \"\"\"\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n\n    # Because the same exception may travel through this method more than\n    # once (if it's re-raised) we may want to treat it differently\n    # the second time (e.g. no user messages/logging).\n    handled = issubclass(exc_type, HandledException)\n    wrap = False\n\n    # Restore our original exception information, but re-wrap it at the end\n    if handled:\n        exc_type, exc_value, exc_traceback = exc_value.wrapped\n        wrap = True\n\n    # We trust messages from our own exceptions\n    if issubclass(exc_type, HorizonException):\n        message = exc_value\n    # If the message has a placeholder for the exception, fill it in\n    elif message and \"%(exc)s\" in message:\n        message = message % {\"exc\": exc_value}\n\n    if issubclass(exc_type, UNAUTHORIZED):\n        if ignore:\n            return NotAuthorized\n        request.session.clear()\n        if not handled:\n            LOG.debug(\"Unauthorized: %s\" % exc_value)\n            # We get some pretty useless error messages back from\n            # some clients, so let's define our own fallback.\n            fallback = _(\"Unauthorized. Please try logging in again.\")\n            messages.error(request, message or fallback, extra_tags=\"login\")\n        raise NotAuthorized  # Redirect handled in middleware\n\n    if issubclass(exc_type, NOT_FOUND):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Not Found: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return NotFound  # return to normal code flow\n\n    if issubclass(exc_type, RECOVERABLE):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Recoverable error: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return RecoverableError  # return to normal code flow\n\n    # If we've gotten here, time to wrap and/or raise our exception.\n    if wrap:\n        raise HandledException([exc_type, exc_value, exc_traceback])\n    raise exc_type, exc_value, exc_traceback\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nMiddleware provided and used by Horizon.\n\"\"\"\n\nimport logging\n\nfrom django import http\nfrom django import shortcuts\n\nfrom django.core.urlresolvers import reverse\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.encoding import iri_to_uri\n\nfrom horizon import exceptions\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonMiddleware(object):\n    \"\"\" The main Horizon middleware class. Required for use of Horizon. \"\"\"\n\n    def process_request(self, request):\n        \"\"\" Adds data necessary for Horizon to function to the request.\n\n        Adds the current \"active\" :class:`~horizon.Dashboard` and\n        :class:`~horizon.Panel` to ``request.horizon``.\n\n        Adds a :class:`~horizon.users.User` object to ``request.user``.\n        \"\"\"\n        request.__class__.user = users.LazyUser()\n        request.horizon = {'dashboard': None, 'panel': None}\n\n    def process_exception(self, request, exception):\n        \"\"\"\n        Catches internal Horizon exception classes such as NotAuthorized,\n        NotFound and Http302 and handles them gracefully.\n        \"\"\"\n        if isinstance(exception,\n                (exceptions.NotAuthorized, exceptions.NotAuthenticated)):\n            auth_url = reverse(\"horizon:auth_login\")\n            next_url = iri_to_uri(request.get_full_path())\n            if next_url != auth_url:\n                param = \"?%s=%s\" % (REDIRECT_FIELD_NAME, next_url)\n                redirect_to = \"\".join((auth_url, param))\n            else:\n                redirect_to = auth_url\n            messages.error(request, unicode(exception))\n            if request.is_ajax():\n                response_401 = http.HttpResponse(status=401)\n                response_401['X-Horizon-Location'] = redirect_to\n                return response_401\n            return shortcuts.redirect(redirect_to)\n\n        # If an internal \"NotFound\" error gets this far, return a real 404.\n        if isinstance(exception, exceptions.NotFound):\n            raise http.Http404(exception)\n\n        if isinstance(exception, exceptions.Http302):\n            if exception.message:\n                messages.error(request, exception.message)\n            return shortcuts.redirect(exception.location)\n\n    def process_response(self, request, response):\n        \"\"\"\n        Convert HttpResponseRedirect to HttpResponse if request is via ajax\n        to allow ajax request to redirect url\n        \"\"\"\n        if request.is_ajax():\n            if type(response) == http.HttpResponseRedirect:\n                redirect_response = http.HttpResponse()\n                redirect_response['X-Horizon-Location'] = response['location']\n                return redirect_response\n        return response\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nfrom django import http\nfrom django.core.urlresolvers import reverse\nfrom keystoneclient import exceptions as keystone_exceptions\nfrom mox import IsA\n\nfrom horizon import api\nfrom horizon import test\n\n\nSYSPANEL_INDEX_URL = reverse('horizon:syspanel:overview:index')\nDASH_INDEX_URL = reverse('horizon:nova:overview:index')\n\n\nclass AuthViewTests(test.TestCase):\n    def setUp(self):\n        super(AuthViewTests, self).setUp()\n        self.setActiveUser()\n\n    def test_login_index(self):\n        res = self.client.get(reverse('horizon:auth_login'))\n        self.assertTemplateUsed(res, 'horizon/auth/login.html')\n\n    def test_login_user_logged_in(self):\n        self.setActiveUser(self.tokens.first().id,\n                           self.user.name,\n                           self.tenant.id,\n                           False,\n                           self.service_catalog)\n        # Hitting the login URL directly should always give you a login page.\n        res = self.client.get(reverse('horizon:auth_login'))\n        self.assertTemplateUsed(res, 'horizon/auth/login.html')\n\n    def test_login_no_tenants(self):\n        aToken = self.tokens.first()\n\n        self.mox.StubOutWithMock(api, 'token_create')\n        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n                         self.user.password).AndReturn(aToken)\n        api.tenant_list_for_token(IsA(http.HttpRequest), aToken.id).\\\n                                  AndReturn([])\n\n        self.mox.ReplayAll()\n\n        form_data = {'method': 'Login',\n                    'region': 'http://localhost:5000/v2.0',\n                    'password': self.user.password,\n                    'username': self.user.name}\n        res = self.client.post(reverse('horizon:auth_login'), form_data)\n\n        self.assertTemplateUsed(res, 'horizon/auth/login.html')\n\n    def test_login(self):\n        form_data = {'method': 'Login',\n                     'region': 'http://localhost:5000/v2.0',\n                     'password': self.user.password,\n                     'username': self.user.name}\n\n        self.mox.StubOutWithMock(api, 'token_create')\n        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n        self.mox.StubOutWithMock(api, 'token_create_scoped')\n\n        aToken = self.tokens.unscoped_token\n        bToken = self.tokens.scoped_token\n\n        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n                         self.user.password).AndReturn(aToken)\n        api.tenant_list_for_token(IsA(http.HttpRequest),\n                                  aToken.id).AndReturn([self.tenants.first()])\n        api.token_create_scoped(IsA(http.HttpRequest),\n                                self.tenant.id,\n                                aToken.id).AndReturn(bToken)\n\n        self.mox.ReplayAll()\n\n        res = self.client.post(reverse('horizon:auth_login'), form_data)\n        self.assertRedirectsNoFollow(res, DASH_INDEX_URL)\n\n    def test_login_first_tenant_invalid(self):\n        form_data = {'method': 'Login',\n                     'region': 'http://localhost:5000/v2.0',\n                     'password': self.user.password,\n                     'username': self.user.name}\n\n        self.mox.StubOutWithMock(api, 'token_create')\n        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n        self.mox.StubOutWithMock(api, 'token_create_scoped')\n\n        aToken = self.tokens.unscoped_token\n        bToken = self.tokens.scoped_token\n        disabled_tenant = self.tenants.get(name=\"disabled_tenant\")\n        tenant = self.tenants.get(name=\"test_tenant\")\n        tenants = [tenant, disabled_tenant]\n        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n                         self.user.password).AndReturn(aToken)\n        api.tenant_list_for_token(IsA(http.HttpRequest),\n                                  aToken.id).AndReturn(tenants)\n        exc = keystone_exceptions.Unauthorized(\"Not authorized.\")\n        api.token_create_scoped(IsA(http.HttpRequest),\n                                disabled_tenant.id,\n                                aToken.id).AndRaise(exc)\n        api.token_create_scoped(IsA(http.HttpRequest),\n                                tenant.id,\n                                aToken.id).AndReturn(bToken)\n\n        self.mox.ReplayAll()\n\n        res = self.client.post(reverse('horizon:auth_login'), form_data)\n        self.assertNoFormErrors(res)\n        self.assertNoMessages()\n        self.assertRedirectsNoFollow(res, DASH_INDEX_URL)\n\n    def test_login_invalid_credentials(self):\n        self.mox.StubOutWithMock(api, 'token_create')\n        unauthorized = keystone_exceptions.Unauthorized(\"Invalid\")\n        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n                         self.user.password).AndRaise(unauthorized)\n\n        self.mox.ReplayAll()\n\n        form_data = {'method': 'Login',\n                     'region': 'http://localhost:5000/v2.0',\n                     'password': self.user.password,\n                     'username': self.user.name}\n        res = self.client.post(reverse('horizon:auth_login'),\n                               form_data,\n                               follow=True)\n\n        self.assertTemplateUsed(res, 'horizon/auth/login.html')\n\n    def test_login_exception(self):\n        self.mox.StubOutWithMock(api, 'token_create')\n        ex = keystone_exceptions.BadRequest('Cannot talk to keystone')\n        api.token_create(IsA(http.HttpRequest),\n                         \"\",\n                         self.user.name,\n                         self.user.password).AndRaise(ex)\n\n        self.mox.ReplayAll()\n\n        form_data = {'method': 'Login',\n                    'region': 'http://localhost:5000/v2.0',\n                    'password': self.user.password,\n                    'username': self.user.name}\n        res = self.client.post(reverse('horizon:auth_login'), form_data)\n\n        self.assertTemplateUsed(res, 'horizon/auth/login.html')\n\n    def test_switch_tenants_index(self):\n        res = self.client.get(reverse('horizon:auth_switch',\n                                      args=[self.tenant.id]))\n\n        self.assertRedirects(res, reverse(\"horizon:auth_login\"))\n\n    def test_switch_tenants(self):\n        tenants = self.tenants.list()\n\n        tenant = self.tenants.first()\n        token = self.tokens.unscoped_token\n        scoped_token = self.tokens.scoped_token\n        switch_to = scoped_token.tenant['id']\n        user = self.users.first()\n\n        self.setActiveUser(id=user.id,\n                           token=token.id,\n                           username=user.name,\n                           tenant_id=tenant.id,\n                           service_catalog=self.service_catalog,\n                           authorized_tenants=tenants)\n\n        self.mox.StubOutWithMock(api, 'token_create')\n        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n\n        api.token_create(IsA(http.HttpRequest),\n                         switch_to,\n                         user.name,\n                         user.password).AndReturn(scoped_token)\n        api.tenant_list_for_token(IsA(http.HttpRequest),\n                                  token.id).AndReturn(tenants)\n        self.mox.ReplayAll()\n\n        form_data = {'method': 'LoginWithTenant',\n                     'region': 'http://localhost:5000/v2.0',\n                     'username': user.name,\n                     'password': user.password,\n                     'tenant': switch_to}\n        switch_url = reverse('horizon:auth_switch', args=[switch_to])\n        res = self.client.post(switch_url, form_data)\n        self.assertRedirectsNoFollow(res, DASH_INDEX_URL)\n        self.assertEqual(self.client.session['tenant'],\n                         scoped_token.tenant['name'])\n\n    def test_logout(self):\n        KEY = 'arbitraryKeyString'\n        VALUE = 'arbitraryKeyValue'\n        self.assertNotIn(KEY, self.client.session)\n        self.client.session[KEY] = VALUE\n\n        res = self.client.get(reverse('horizon:auth_logout'))\n\n        self.assertRedirectsNoFollow(res, reverse('splash'))\n        self.assertNotIn(KEY, self.client.session)\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nClasses and methods related to user handling in Horizon.\n\"\"\"\n\nimport logging\n\nfrom django.utils.translation import ugettext as _\n\nfrom horizon import api\nfrom horizon import exceptions\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef get_user_from_request(request):\n    \"\"\" Checks the current session and returns a :class:`~horizon.users.User`.\n\n    If the session contains user data the User will be treated as\n    authenticated and the :class:`~horizon.users.User` will have all\n    its attributes set.\n\n    If not, the :class:`~horizon.users.User` will have no attributes set.\n\n    If the session contains invalid data,\n    :exc:`~horizon.exceptions.NotAuthorized` will be raised.\n    \"\"\"\n    if 'user_id' not in request.session:\n        return User()\n    try:\n        return User(id=request.session['user_id'],\n                    token=request.session['token'],\n                    user=request.session['user_name'],\n                    tenant_id=request.session['tenant_id'],\n                    tenant_name=request.session['tenant'],\n                    service_catalog=request.session['serviceCatalog'],\n                    roles=request.session['roles'],\n                    request=request)\n    except KeyError:\n        # If any of those keys are missing from the session it is\n        # overwhelmingly likely that we're dealing with an outdated session.\n        LOG.exception(\"Error while creating User from session.\")\n        request.session.clear()\n        raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                         \"Please log in again.\"))\n\n\nclass LazyUser(object):\n    def __get__(self, request, obj_type=None):\n        if not hasattr(request, '_cached_user'):\n            request._cached_user = get_user_from_request(request)\n        return request._cached_user\n\n\nclass User(object):\n    \"\"\" The main user class which Horizon expects.\n\n    .. attribute:: token\n\n        The id of the Keystone token associated with the current user/tenant.\n\n    .. attribute:: username\n\n        The name of the current user.\n\n    .. attribute:: tenant_id\n\n        The id of the Keystone tenant for the current user/token.\n\n    .. attribute:: tenant_name\n\n        The name of the Keystone tenant for the current user/token.\n\n    .. attribute:: service_catalog\n\n        The ``ServiceCatalog`` data returned by Keystone.\n\n    .. attribute:: roles\n\n        A list of dictionaries containing role names and ids as returned\n        by Keystone.\n\n    .. attribute:: admin\n\n        Boolean value indicating whether or not this user has admin\n        privileges. Internally mapped to :meth:`horizon.users.User.is_admin`.\n    \"\"\"\n    def __init__(self, id=None, token=None, user=None, tenant_id=None,\n                    service_catalog=None, tenant_name=None, roles=None,\n                    authorized_tenants=None, request=None):\n        self.id = id\n        self.token = token\n        self.username = user\n        self.tenant_id = tenant_id\n        self.tenant_name = tenant_name\n        self.service_catalog = service_catalog\n        self.roles = roles or []\n        self._authorized_tenants = authorized_tenants\n        # Store the request for lazy fetching of auth'd tenants\n        self._request = request\n\n    def is_authenticated(self):\n        \"\"\"\n        Evaluates whether this :class:`.User` instance has been authenticated.\n        Returns ``True`` or ``False``.\n        \"\"\"\n        # TODO: deal with token expiration\n        return self.token\n\n    @property\n    def admin(self):\n        return self.is_admin()\n\n    def is_admin(self):\n        \"\"\"\n        Evaluates whether this user has admin privileges. Returns\n        ``True`` or ``False``.\n        \"\"\"\n        for role in self.roles:\n            if role['name'].lower() == 'admin':\n                return True\n        return False\n\n    def get_and_delete_messages(self):\n        \"\"\"\n        Placeholder function for parity with\n        ``django.contrib.auth.models.User``.\n        \"\"\"\n        return []\n\n    @property\n    def authorized_tenants(self):\n        if self.is_authenticated() and self._authorized_tenants is None:\n            try:\n                token = self._request.session.get(\"unscoped_token\", self.token)\n                authd = api.tenant_list_for_token(self._request, token)\n            except:\n                authd = []\n                LOG.exception('Could not retrieve tenant list.')\n            self._authorized_tenants = authd\n        return self._authorized_tenants\n\n    @authorized_tenants.setter\n    def authorized_tenants(self, tenant_list):\n        self._authorized_tenants = tenant_list\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\n\nimport horizon\nfrom horizon import api\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\nfrom horizon.base import Horizon\nfrom horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef user_home(request):\n    \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\"\n    return shortcuts.redirect(horizon.get_user_home(request.user))\n\n\nclass LoginView(forms.ModalFormView):\n    \"\"\"\n    Logs in a user and redirects them to the URL specified by\n    :func:`horizon.get_user_home`.\n    \"\"\"\n    form_class = Login\n    template_name = \"horizon/auth/login.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LoginView, self).get_context_data(**kwargs)\n        redirect_to = self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n        context[\"redirect_field_name\"] = REDIRECT_FIELD_NAME\n        context[\"next\"] = redirect_to\n        return context\n\n    def get_initial(self):\n        initial = super(LoginView, self).get_initial()\n        current_region = self.request.session.get('region_endpoint', None)\n        requested_region = self.request.GET.get('region', None)\n        regions = dict(getattr(settings, \"AVAILABLE_REGIONS\", []))\n        if requested_region in regions and requested_region != current_region:\n            initial.update({'region': requested_region})\n        return initial\n\n\ndef switch_tenants(request, tenant_id):\n    \"\"\"\n    Swaps a user from one tenant to another using the unscoped token from\n    Keystone to exchange scoped tokens for the new tenant.\n    \"\"\"\n    form, handled = LoginWithTenant.maybe_handle(\n            request, initial={'tenant': tenant_id,\n                              'username': request.user.username})\n    if handled:\n        return handled\n\n    unscoped_token = request.session.get('unscoped_token', None)\n    if unscoped_token:\n        try:\n            token = api.token_create_scoped(request,\n                                            tenant_id,\n                                            unscoped_token)\n            _set_session_data(request, token)\n            user = users.User(users.get_user_from_request(request))\n            return shortcuts.redirect(Horizon.get_user_home(user))\n        except:\n            exceptions.handle(request,\n                              _(\"You are not authorized for that tenant.\"))\n\n    return shortcuts.redirect(\"horizon:auth_login\")\n\n\ndef logout(request):\n    \"\"\" Clears the session and logs the current user out. \"\"\"\n    request.session.clear()\n    # FIXME(gabriel): we don't ship a view named splash\n    return shortcuts.redirect('splash')\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.session.clear()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"], "fixing_code": ["# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nExceptions raised by the Horizon code and the machinery for handling them.\n\"\"\"\n\nimport logging\nimport sys\n\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.utils.translation import ugettext as _\nfrom cloudfiles import errors as swiftclient\nfrom glanceclient.common import exceptions as glanceclient\nfrom keystoneclient import exceptions as keystoneclient\nfrom novaclient import exceptions as novaclient\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonException(Exception):\n    \"\"\" Base exception class for distinguishing our own exception classes. \"\"\"\n    pass\n\n\nclass Http302(HorizonException):\n    \"\"\"\n    Error class which can be raised from within a handler to cause an\n    early bailout and redirect at the middleware level.\n    \"\"\"\n    status_code = 302\n\n    def __init__(self, location, message=None):\n        self.location = location\n        self.message = message\n\n\nclass NotAuthorized(HorizonException):\n    \"\"\"\n    Raised whenever a user attempts to access a resource which they do not\n    have role-based access to (such as when failing the\n    :func:`~horizon.decorators.require_roles` decorator).\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthorized`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 401\n\n\nclass NotAuthenticated(HorizonException):\n    \"\"\"\n    Raised when a user is trying to make requests and they are not logged in.\n\n    The included :class:`~horizon.middleware.HorizonMiddleware` catches\n    ``NotAuthenticated`` and handles it gracefully by displaying an error\n    message and redirecting the user to a login page.\n    \"\"\"\n    status_code = 403\n\n\nclass NotFound(HorizonException):\n    \"\"\" Generic error to replace all \"Not Found\"-type API errors. \"\"\"\n    status_code = 404\n\n\nclass RecoverableError(HorizonException):\n    \"\"\" Generic error to replace any \"Recoverable\"-type API errors. \"\"\"\n    status_code = 100  # HTTP status code \"Continue\"\n\n\nclass ServiceCatalogException(HorizonException):\n    \"\"\"\n    Raised when a requested service is not available in the ``ServiceCatalog``\n    returned by Keystone.\n    \"\"\"\n    def __init__(self, service_name):\n        message = 'Invalid service catalog service: %s' % service_name\n        super(ServiceCatalogException, self).__init__(message)\n\n\nclass AlreadyExists(HorizonException):\n    \"\"\"\n    Exception to be raised when trying to create an API resource which\n    already exists.\n    \"\"\"\n    def __init__(self, name, resource_type):\n        self.attrs = {\"name\": name, \"resource\": resource_type}\n        self.msg = 'A %(resource)s with the name \"%(name)s\" already exists.'\n\n    def __repr__(self):\n        return self.msg % self.attrs\n\n    def __unicode__(self):\n        return _(self.msg) % self.attrs\n\n\nclass HandledException(HorizonException):\n    \"\"\"\n    Used internally to track exceptions that have gone through\n    :func:`horizon.exceptions.handle` more than once.\n    \"\"\"\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n\n\nHORIZON_CONFIG = getattr(settings, \"HORIZON_CONFIG\", {})\nEXCEPTION_CONFIG = HORIZON_CONFIG.get(\"exceptions\", {})\n\n\nUNAUTHORIZED = (keystoneclient.Unauthorized,\n                keystoneclient.Forbidden,\n                novaclient.Unauthorized,\n                novaclient.Forbidden,\n                glanceclient.AuthorizationFailure,\n                glanceclient.Unauthorized,\n                swiftclient.AuthenticationFailed,\n                swiftclient.AuthenticationError)\nUNAUTHORIZED += tuple(EXCEPTION_CONFIG.get('unauthorized', []))\n\nNOT_FOUND = (keystoneclient.NotFound,\n             novaclient.NotFound,\n             glanceclient.NotFound,\n             swiftclient.NoSuchContainer,\n             swiftclient.NoSuchObject)\nNOT_FOUND += tuple(EXCEPTION_CONFIG.get('not_found', []))\n\n\n# NOTE(gabriel): This is very broad, and may need to be dialed in.\nRECOVERABLE = (keystoneclient.ClientException,\n               # AuthorizationFailure is raised when Keystone is \"unavailable\".\n               keystoneclient.AuthorizationFailure,\n               novaclient.ClientException,\n               glanceclient.ClientException,\n               swiftclient.Error,\n               AlreadyExists)\nRECOVERABLE += tuple(EXCEPTION_CONFIG.get('recoverable', []))\n\n\ndef handle(request, message=None, redirect=None, ignore=False, escalate=False):\n    \"\"\" Centralized error handling for Horizon.\n\n    Because Horizon consumes so many different APIs with completely\n    different ``Exception`` types, it's necessary to have a centralized\n    place for handling exceptions which may be raised.\n\n    Exceptions are roughly divided into 3 types:\n\n    #. ``UNAUTHORIZED``: Errors resulting from authentication or authorization\n       problems. These result in being logged out and sent to the login screen.\n    #. ``NOT_FOUND``: Errors resulting from objects which could not be\n       located via the API. These generally result in a user-facing error\n       message, but are otherwise returned to the normal code flow. Optionally\n       a redirect value may be passed to the error handler so users are\n       returned to a different view than the one requested in addition to the\n       error message.\n    #. RECOVERABLE: Generic API errors which generate a user-facing message\n       but drop directly back to the regular code flow.\n\n    All other exceptions bubble the stack as normal unless the ``ignore``\n    argument is passed in as ``True``, in which case only unrecognized\n    errors are bubbled.\n\n    If the exception is not re-raised, an appropriate wrapper exception\n    class indicating the type of exception that was encountered will be\n    returned.\n    \"\"\"\n    exc_type, exc_value, exc_traceback = sys.exc_info()\n\n    # Because the same exception may travel through this method more than\n    # once (if it's re-raised) we may want to treat it differently\n    # the second time (e.g. no user messages/logging).\n    handled = issubclass(exc_type, HandledException)\n    wrap = False\n\n    # Restore our original exception information, but re-wrap it at the end\n    if handled:\n        exc_type, exc_value, exc_traceback = exc_value.wrapped\n        wrap = True\n\n    # We trust messages from our own exceptions\n    if issubclass(exc_type, HorizonException):\n        message = exc_value\n    # If the message has a placeholder for the exception, fill it in\n    elif message and \"%(exc)s\" in message:\n        message = message % {\"exc\": exc_value}\n\n    if issubclass(exc_type, UNAUTHORIZED):\n        if ignore:\n            return NotAuthorized\n        request.user_logout()\n        if not handled:\n            LOG.debug(\"Unauthorized: %s\" % exc_value)\n            # We get some pretty useless error messages back from\n            # some clients, so let's define our own fallback.\n            fallback = _(\"Unauthorized. Please try logging in again.\")\n            messages.error(request, message or fallback, extra_tags=\"login\")\n        raise NotAuthorized  # Redirect handled in middleware\n\n    if issubclass(exc_type, NOT_FOUND):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Not Found: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return NotFound  # return to normal code flow\n\n    if issubclass(exc_type, RECOVERABLE):\n        wrap = True\n        if not ignore and not handled:\n            LOG.debug(\"Recoverable error: %s\" % exc_value)\n            messages.error(request, message or exc_value)\n        if redirect:\n            raise Http302(redirect)\n        if not escalate:\n            return RecoverableError  # return to normal code flow\n\n    # If we've gotten here, time to wrap and/or raise our exception.\n    if wrap:\n        raise HandledException([exc_type, exc_value, exc_traceback])\n    raise exc_type, exc_value, exc_traceback\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nMiddleware provided and used by Horizon.\n\"\"\"\n\nimport logging\n\nfrom django import http\nfrom django import shortcuts\n\nfrom django.core.urlresolvers import reverse\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.encoding import iri_to_uri\n\nfrom horizon import exceptions\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\nclass HorizonMiddleware(object):\n    \"\"\" The main Horizon middleware class. Required for use of Horizon. \"\"\"\n\n    def process_request(self, request):\n        \"\"\" Adds data necessary for Horizon to function to the request.\n\n        Adds the current \"active\" :class:`~horizon.Dashboard` and\n        :class:`~horizon.Panel` to ``request.horizon``.\n\n        Adds a :class:`~horizon.users.User` object to ``request.user``.\n        \"\"\"\n        # A quick and dirty way to log users out\n        def user_logout(request):\n            if hasattr(request, '_cached_user'):\n                del request._cached_user\n            # Use flush instead of clear, so we rotate session keys in\n            # addition to clearing all the session data\n            request.session.flush()\n        request.__class__.user_logout = user_logout\n\n        request.__class__.user = users.LazyUser()\n        request.horizon = {'dashboard': None, 'panel': None}\n\n    def process_exception(self, request, exception):\n        \"\"\"\n        Catches internal Horizon exception classes such as NotAuthorized,\n        NotFound and Http302 and handles them gracefully.\n        \"\"\"\n        if isinstance(exception,\n                (exceptions.NotAuthorized, exceptions.NotAuthenticated)):\n            auth_url = reverse(\"horizon:auth_login\")\n            next_url = iri_to_uri(request.get_full_path())\n            if next_url != auth_url:\n                param = \"?%s=%s\" % (REDIRECT_FIELD_NAME, next_url)\n                redirect_to = \"\".join((auth_url, param))\n            else:\n                redirect_to = auth_url\n            messages.error(request, unicode(exception))\n            if request.is_ajax():\n                response_401 = http.HttpResponse(status=401)\n                response_401['X-Horizon-Location'] = redirect_to\n                return response_401\n            return shortcuts.redirect(redirect_to)\n\n        # If an internal \"NotFound\" error gets this far, return a real 404.\n        if isinstance(exception, exceptions.NotFound):\n            raise http.Http404(exception)\n\n        if isinstance(exception, exceptions.Http302):\n            if exception.message:\n                messages.error(request, exception.message)\n            return shortcuts.redirect(exception.location)\n\n    def process_response(self, request, response):\n        \"\"\"\n        Convert HttpResponseRedirect to HttpResponse if request is via ajax\n        to allow ajax request to redirect url\n        \"\"\"\n        if request.is_ajax():\n            if type(response) == http.HttpResponseRedirect:\n                redirect_response = http.HttpResponse()\n                redirect_response['X-Horizon-Location'] = response['location']\n                return redirect_response\n        return response\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport time\n\nfrom django import http\nfrom django.core.urlresolvers import reverse\nfrom keystoneclient import exceptions as keystone_exceptions\nfrom mox import IsA\n\nfrom horizon import api\nfrom horizon import test\n\n\nSYSPANEL_INDEX_URL = reverse('horizon:syspanel:overview:index')\nDASH_INDEX_URL = reverse('horizon:nova:overview:index')\n\n\nclass AuthViewTests(test.TestCase):\n    def setUp(self):\n        super(AuthViewTests, self).setUp()\n        self.setActiveUser()\n\n    def test_login_index(self):\n        res = self.client.get(reverse('horizon:auth_login'))\n        self.assertTemplateUsed(res, 'horizon/auth/login.html')\n\n    def test_login_user_logged_in(self):\n        self.setActiveUser(self.tokens.first().id,\n                           self.user.name,\n                           self.tenant.id,\n                           False,\n                           self.service_catalog)\n        # Hitting the login URL directly should always give you a login page.\n        res = self.client.get(reverse('horizon:auth_login'))\n        self.assertTemplateUsed(res, 'horizon/auth/login.html')\n\n    def test_login_no_tenants(self):\n        aToken = self.tokens.first()\n\n        self.mox.StubOutWithMock(api, 'token_create')\n        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n                         self.user.password).AndReturn(aToken)\n        api.tenant_list_for_token(IsA(http.HttpRequest), aToken.id).\\\n                                  AndReturn([])\n\n        self.mox.ReplayAll()\n\n        form_data = {'method': 'Login',\n                    'region': 'http://localhost:5000/v2.0',\n                    'password': self.user.password,\n                    'username': self.user.name}\n        res = self.client.post(reverse('horizon:auth_login'), form_data)\n\n        self.assertTemplateUsed(res, 'horizon/auth/login.html')\n\n    def test_login(self):\n        form_data = {'method': 'Login',\n                     'region': 'http://localhost:5000/v2.0',\n                     'password': self.user.password,\n                     'username': self.user.name}\n\n        self.mox.StubOutWithMock(api, 'token_create')\n        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n        self.mox.StubOutWithMock(api, 'token_create_scoped')\n\n        aToken = self.tokens.unscoped_token\n        bToken = self.tokens.scoped_token\n\n        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n                         self.user.password).AndReturn(aToken)\n        api.tenant_list_for_token(IsA(http.HttpRequest),\n                                  aToken.id).AndReturn([self.tenants.first()])\n        api.token_create_scoped(IsA(http.HttpRequest),\n                                self.tenant.id,\n                                aToken.id).AndReturn(bToken)\n\n        self.mox.ReplayAll()\n\n        res = self.client.post(reverse('horizon:auth_login'), form_data)\n        self.assertRedirectsNoFollow(res, DASH_INDEX_URL)\n\n    def test_login_first_tenant_invalid(self):\n        form_data = {'method': 'Login',\n                     'region': 'http://localhost:5000/v2.0',\n                     'password': self.user.password,\n                     'username': self.user.name}\n\n        self.mox.StubOutWithMock(api, 'token_create')\n        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n        self.mox.StubOutWithMock(api, 'token_create_scoped')\n\n        aToken = self.tokens.unscoped_token\n        bToken = self.tokens.scoped_token\n        disabled_tenant = self.tenants.get(name=\"disabled_tenant\")\n        tenant = self.tenants.get(name=\"test_tenant\")\n        tenants = [tenant, disabled_tenant]\n        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n                         self.user.password).AndReturn(aToken)\n        api.tenant_list_for_token(IsA(http.HttpRequest),\n                                  aToken.id).AndReturn(tenants)\n        exc = keystone_exceptions.Unauthorized(\"Not authorized.\")\n        api.token_create_scoped(IsA(http.HttpRequest),\n                                disabled_tenant.id,\n                                aToken.id).AndRaise(exc)\n        api.token_create_scoped(IsA(http.HttpRequest),\n                                tenant.id,\n                                aToken.id).AndReturn(bToken)\n\n        self.mox.ReplayAll()\n\n        res = self.client.post(reverse('horizon:auth_login'), form_data)\n        self.assertNoFormErrors(res)\n        self.assertNoMessages()\n        self.assertRedirectsNoFollow(res, DASH_INDEX_URL)\n\n    def test_login_invalid_credentials(self):\n        self.mox.StubOutWithMock(api, 'token_create')\n        unauthorized = keystone_exceptions.Unauthorized(\"Invalid\")\n        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n                         self.user.password).AndRaise(unauthorized)\n\n        self.mox.ReplayAll()\n\n        form_data = {'method': 'Login',\n                     'region': 'http://localhost:5000/v2.0',\n                     'password': self.user.password,\n                     'username': self.user.name}\n        res = self.client.post(reverse('horizon:auth_login'),\n                               form_data,\n                               follow=True)\n\n        self.assertTemplateUsed(res, 'horizon/auth/login.html')\n\n    def test_login_exception(self):\n        self.mox.StubOutWithMock(api, 'token_create')\n        ex = keystone_exceptions.BadRequest('Cannot talk to keystone')\n        api.token_create(IsA(http.HttpRequest),\n                         \"\",\n                         self.user.name,\n                         self.user.password).AndRaise(ex)\n\n        self.mox.ReplayAll()\n\n        form_data = {'method': 'Login',\n                    'region': 'http://localhost:5000/v2.0',\n                    'password': self.user.password,\n                    'username': self.user.name}\n        res = self.client.post(reverse('horizon:auth_login'), form_data)\n\n        self.assertTemplateUsed(res, 'horizon/auth/login.html')\n\n    def test_switch_tenants_index(self):\n        res = self.client.get(reverse('horizon:auth_switch',\n                                      args=[self.tenant.id]))\n\n        self.assertRedirects(res, reverse(\"horizon:auth_login\"))\n\n    def test_switch_tenants(self):\n        tenants = self.tenants.list()\n\n        tenant = self.tenants.first()\n        token = self.tokens.unscoped_token\n        scoped_token = self.tokens.scoped_token\n        switch_to = scoped_token.tenant['id']\n        user = self.users.first()\n\n        self.setActiveUser(id=user.id,\n                           token=token.id,\n                           username=user.name,\n                           tenant_id=tenant.id,\n                           service_catalog=self.service_catalog,\n                           authorized_tenants=tenants)\n\n        self.mox.StubOutWithMock(api, 'token_create')\n        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n\n        api.token_create(IsA(http.HttpRequest),\n                         switch_to,\n                         user.name,\n                         user.password).AndReturn(scoped_token)\n        api.tenant_list_for_token(IsA(http.HttpRequest),\n                                  token.id).AndReturn(tenants)\n        self.mox.ReplayAll()\n\n        form_data = {'method': 'LoginWithTenant',\n                     'region': 'http://localhost:5000/v2.0',\n                     'username': user.name,\n                     'password': user.password,\n                     'tenant': switch_to}\n        switch_url = reverse('horizon:auth_switch', args=[switch_to])\n        res = self.client.post(switch_url, form_data)\n        self.assertRedirectsNoFollow(res, DASH_INDEX_URL)\n        self.assertEqual(self.client.session['tenant'],\n                         scoped_token.tenant['name'])\n\n    def test_logout(self):\n        KEY = 'arbitraryKeyString'\n        VALUE = 'arbitraryKeyValue'\n        self.assertNotIn(KEY, self.client.session)\n        self.client.session[KEY] = VALUE\n\n        res = self.client.get(reverse('horizon:auth_logout'))\n\n        self.assertRedirectsNoFollow(res, reverse('splash'))\n        self.assertNotIn(KEY, self.client.session)\n\n    def test_session_fixation(self):\n        session_ids = []\n        form_data = {'method': 'Login',\n                     'region': 'http://localhost:5000/v2.0',\n                     'password': self.user.password,\n                     'username': self.user.name}\n\n        self.mox.StubOutWithMock(api, 'token_create')\n        self.mox.StubOutWithMock(api, 'tenant_list_for_token')\n        self.mox.StubOutWithMock(api, 'token_create_scoped')\n\n        aToken = self.tokens.unscoped_token\n        bToken = self.tokens.scoped_token\n\n        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n                         self.user.password).AndReturn(aToken)\n        api.tenant_list_for_token(IsA(http.HttpRequest),\n                                  aToken.id).AndReturn([self.tenants.first()])\n        api.token_create_scoped(IsA(http.HttpRequest),\n                                self.tenant.id,\n                                aToken.id).AndReturn(bToken)\n\n        api.token_create(IsA(http.HttpRequest), \"\", self.user.name,\n                         self.user.password).AndReturn(aToken)\n        api.tenant_list_for_token(IsA(http.HttpRequest),\n                                  aToken.id).AndReturn([self.tenants.first()])\n        api.token_create_scoped(IsA(http.HttpRequest),\n                                self.tenant.id,\n                                aToken.id).AndReturn(bToken)\n        self.mox.ReplayAll()\n\n        res = self.client.get(reverse('horizon:auth_login'))\n        self.assertEqual(res.cookies.get('sessionid'), None)\n        res = self.client.post(reverse('horizon:auth_login'), form_data)\n        session_ids.append(res.cookies['sessionid'].value)\n\n        self.assertEquals(self.client.session['user_name'],\n                          self.user.name)\n        self.client.session['foobar'] = 'MY TEST VALUE'\n        res = self.client.get(reverse('horizon:auth_logout'))\n        session_ids.append(res.cookies['sessionid'].value)\n        self.assertEqual(len(self.client.session.items()), 0)\n        # Sleep for 1 second so the session values are different if\n        # using the signed_cookies backend.\n        time.sleep(1)\n        res = self.client.post(reverse('horizon:auth_login'), form_data)\n        session_ids.append(res.cookies['sessionid'].value)\n        # Make sure all 3 session id values are different\n        self.assertEqual(len(session_ids), len(set(session_ids)))\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\"\"\"\nClasses and methods related to user handling in Horizon.\n\"\"\"\n\nimport logging\n\nfrom django.utils.translation import ugettext as _\n\nfrom horizon import api\nfrom horizon import exceptions\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef get_user_from_request(request):\n    \"\"\" Checks the current session and returns a :class:`~horizon.users.User`.\n\n    If the session contains user data the User will be treated as\n    authenticated and the :class:`~horizon.users.User` will have all\n    its attributes set.\n\n    If not, the :class:`~horizon.users.User` will have no attributes set.\n\n    If the session contains invalid data,\n    :exc:`~horizon.exceptions.NotAuthorized` will be raised.\n    \"\"\"\n    if 'user_id' not in request.session:\n        return User()\n    try:\n        return User(id=request.session['user_id'],\n                    token=request.session['token'],\n                    user=request.session['user_name'],\n                    tenant_id=request.session['tenant_id'],\n                    tenant_name=request.session['tenant'],\n                    service_catalog=request.session['serviceCatalog'],\n                    roles=request.session['roles'],\n                    request=request)\n    except KeyError:\n        # If any of those keys are missing from the session it is\n        # overwhelmingly likely that we're dealing with an outdated session.\n        LOG.exception(\"Error while creating User from session.\")\n        request.user_logout()\n        raise exceptions.NotAuthorized(_(\"Your session has expired. \"\n                                         \"Please log in again.\"))\n\n\nclass LazyUser(object):\n    def __get__(self, request, obj_type=None):\n        if not hasattr(request, '_cached_user'):\n            request._cached_user = get_user_from_request(request)\n        return request._cached_user\n\n\nclass User(object):\n    \"\"\" The main user class which Horizon expects.\n\n    .. attribute:: token\n\n        The id of the Keystone token associated with the current user/tenant.\n\n    .. attribute:: username\n\n        The name of the current user.\n\n    .. attribute:: tenant_id\n\n        The id of the Keystone tenant for the current user/token.\n\n    .. attribute:: tenant_name\n\n        The name of the Keystone tenant for the current user/token.\n\n    .. attribute:: service_catalog\n\n        The ``ServiceCatalog`` data returned by Keystone.\n\n    .. attribute:: roles\n\n        A list of dictionaries containing role names and ids as returned\n        by Keystone.\n\n    .. attribute:: admin\n\n        Boolean value indicating whether or not this user has admin\n        privileges. Internally mapped to :meth:`horizon.users.User.is_admin`.\n    \"\"\"\n    def __init__(self, id=None, token=None, user=None, tenant_id=None,\n                    service_catalog=None, tenant_name=None, roles=None,\n                    authorized_tenants=None, request=None):\n        self.id = id\n        self.token = token\n        self.username = user\n        self.tenant_id = tenant_id\n        self.tenant_name = tenant_name\n        self.service_catalog = service_catalog\n        self.roles = roles or []\n        self._authorized_tenants = authorized_tenants\n        # Store the request for lazy fetching of auth'd tenants\n        self._request = request\n\n    def is_authenticated(self):\n        \"\"\"\n        Evaluates whether this :class:`.User` instance has been authenticated.\n        Returns ``True`` or ``False``.\n        \"\"\"\n        # TODO: deal with token expiration\n        return self.token\n\n    @property\n    def admin(self):\n        return self.is_admin()\n\n    def is_admin(self):\n        \"\"\"\n        Evaluates whether this user has admin privileges. Returns\n        ``True`` or ``False``.\n        \"\"\"\n        for role in self.roles:\n            if role['name'].lower() == 'admin':\n                return True\n        return False\n\n    def get_and_delete_messages(self):\n        \"\"\"\n        Placeholder function for parity with\n        ``django.contrib.auth.models.User``.\n        \"\"\"\n        return []\n\n    @property\n    def authorized_tenants(self):\n        if self.is_authenticated() and self._authorized_tenants is None:\n            try:\n                token = self._request.session.get(\"unscoped_token\", self.token)\n                authd = api.tenant_list_for_token(self._request, token)\n            except:\n                authd = []\n                LOG.exception('Could not retrieve tenant list.')\n            self._authorized_tenants = authd\n        return self._authorized_tenants\n\n    @authorized_tenants.setter\n    def authorized_tenants(self, tenant_list):\n        self._authorized_tenants = tenant_list\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\n\nimport horizon\nfrom horizon import api\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\nfrom horizon.base import Horizon\nfrom horizon.views.auth_forms import Login, LoginWithTenant, _set_session_data\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef user_home(request):\n    \"\"\" Reversible named view to direct a user to the appropriate homepage. \"\"\"\n    return shortcuts.redirect(horizon.get_user_home(request.user))\n\n\nclass LoginView(forms.ModalFormView):\n    \"\"\"\n    Logs in a user and redirects them to the URL specified by\n    :func:`horizon.get_user_home`.\n    \"\"\"\n    form_class = Login\n    template_name = \"horizon/auth/login.html\"\n\n    def get_context_data(self, **kwargs):\n        context = super(LoginView, self).get_context_data(**kwargs)\n        redirect_to = self.request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n        context[\"redirect_field_name\"] = REDIRECT_FIELD_NAME\n        context[\"next\"] = redirect_to\n        return context\n\n    def get_initial(self):\n        initial = super(LoginView, self).get_initial()\n        current_region = self.request.session.get('region_endpoint', None)\n        requested_region = self.request.GET.get('region', None)\n        regions = dict(getattr(settings, \"AVAILABLE_REGIONS\", []))\n        if requested_region in regions and requested_region != current_region:\n            initial.update({'region': requested_region})\n        return initial\n\n\ndef switch_tenants(request, tenant_id):\n    \"\"\"\n    Swaps a user from one tenant to another using the unscoped token from\n    Keystone to exchange scoped tokens for the new tenant.\n    \"\"\"\n    form, handled = LoginWithTenant.maybe_handle(\n            request, initial={'tenant': tenant_id,\n                              'username': request.user.username})\n    if handled:\n        return handled\n\n    unscoped_token = request.session.get('unscoped_token', None)\n    if unscoped_token:\n        try:\n            token = api.token_create_scoped(request,\n                                            tenant_id,\n                                            unscoped_token)\n            _set_session_data(request, token)\n            user = users.User(users.get_user_from_request(request))\n            return shortcuts.redirect(Horizon.get_user_home(user))\n        except:\n            exceptions.handle(request,\n                              _(\"You are not authorized for that tenant.\"))\n\n    return shortcuts.redirect(\"horizon:auth_login\")\n\n\ndef logout(request):\n    \"\"\" Clears the session and logs the current user out. \"\"\"\n    request.user_logout()\n    # FIXME(gabriel): we don't ship a view named splash\n    return shortcuts.redirect('splash')\n", "# vim: tabstop=4 shiftwidth=4 softtabstop=4\n\n# Copyright 2012 United States Government as represented by the\n# Administrator of the National Aeronautics and Space Administration.\n# All Rights Reserved.\n#\n# Copyright 2012 Nebula, Inc.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n#    not use this file except in compliance with the License. You may obtain\n#    a copy of the License at\n#\n#         http://www.apache.org/licenses/LICENSE-2.0\n#\n#    Unless required by applicable law or agreed to in writing, software\n#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n#    License for the specific language governing permissions and limitations\n#    under the License.\n\n\"\"\"\nForms used for Horizon's auth mechanisms.\n\"\"\"\n\nimport logging\n\nfrom django import shortcuts\nfrom django.conf import settings\nfrom django.contrib import messages\nfrom django.contrib.auth import REDIRECT_FIELD_NAME\nfrom django.utils.translation import ugettext as _\nfrom keystoneclient import exceptions as keystone_exceptions\n\nfrom horizon import api\nfrom horizon import base\nfrom horizon import exceptions\nfrom horizon import forms\nfrom horizon import users\n\n\nLOG = logging.getLogger(__name__)\n\n\ndef _set_session_data(request, token):\n    request.session['serviceCatalog'] = token.serviceCatalog\n    request.session['tenant'] = token.tenant['name']\n    request.session['tenant_id'] = token.tenant['id']\n    request.session['token'] = token.id\n    request.session['user_name'] = token.user['name']\n    request.session['user_id'] = token.user['id']\n    request.session['roles'] = token.user['roles']\n\n\nclass Login(forms.SelfHandlingForm):\n    \"\"\" Form used for logging in a user.\n\n    Handles authentication with Keystone, choosing a tenant, and fetching\n    a scoped token token for that tenant. Redirects to the URL returned\n    by :meth:`horizon.get_user_home` if successful.\n\n    Subclass of :class:`~horizon.forms.SelfHandlingForm`.\n    \"\"\"\n    region = forms.ChoiceField(label=_(\"Region\"), required=False)\n    username = forms.CharField(label=_(\"User Name\"))\n    password = forms.CharField(label=_(\"Password\"),\n                               widget=forms.PasswordInput(render_value=False))\n\n    def __init__(self, *args, **kwargs):\n        super(Login, self).__init__(*args, **kwargs)\n        # FIXME(gabriel): When we switch to region-only settings, we can\n        # remove this default region business.\n        default_region = (settings.OPENSTACK_KEYSTONE_URL, \"Default Region\")\n        regions = getattr(settings, 'AVAILABLE_REGIONS', [default_region])\n        self.fields['region'].choices = regions\n        if len(regions) == 1:\n            self.fields['region'].initial = default_region[0]\n            self.fields['region'].widget = forms.widgets.HiddenInput()\n\n    def handle(self, request, data):\n        if 'user_name' in request.session:\n            if request.session['user_name'] != data['username']:\n                # To avoid reusing another user's session, create a\n                # new, empty session if the existing session\n                # corresponds to a different authenticated user.\n                request.session.flush()\n        # Always cycle the session key when viewing the login form to\n        # prevent session fixation\n        request.session.cycle_key()\n\n        # For now we'll allow fallback to OPENSTACK_KEYSTONE_URL if the\n        # form post doesn't include a region.\n        endpoint = data.get('region', None) or settings.OPENSTACK_KEYSTONE_URL\n        region_name = dict(self.fields['region'].choices)[endpoint]\n        request.session['region_endpoint'] = endpoint\n        request.session['region_name'] = region_name\n\n        redirect_to = request.REQUEST.get(REDIRECT_FIELD_NAME, \"\")\n\n        if data.get('tenant', None):\n            try:\n                token = api.token_create(request,\n                                         data.get('tenant'),\n                                         data['username'],\n                                         data['password'])\n                tenants = api.tenant_list_for_token(request, token.id)\n            except:\n                msg = _('Unable to authenticate for that project.')\n                exceptions.handle(request,\n                                  message=msg,\n                                  escalate=True)\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n            redirect = redirect_to or base.Horizon.get_user_home(user)\n            return shortcuts.redirect(redirect)\n\n        elif data.get('username', None):\n            try:\n                unscoped_token = api.token_create(request,\n                                                  '',\n                                                  data['username'],\n                                                  data['password'])\n            except keystone_exceptions.Unauthorized:\n                exceptions.handle(request,\n                                  _('Invalid user name or password.'))\n            except:\n                # If we get here we don't want to show a stack trace to the\n                # user. However, if we fail here, there may be bad session\n                # data that's been cached already.\n                request.user_logout()\n                exceptions.handle(request,\n                                  message=_(\"An error occurred authenticating.\"\n                                            \" Please try again later.\"),\n                                  escalate=True)\n\n            # Unscoped token\n            request.session['unscoped_token'] = unscoped_token.id\n            request.user.username = data['username']\n\n            # Get the tenant list, and log in using first tenant\n            # FIXME (anthony): add tenant chooser here?\n            try:\n                tenants = api.tenant_list_for_token(request, unscoped_token.id)\n            except:\n                exceptions.handle(request)\n                tenants = []\n\n            # Abort if there are no valid tenants for this user\n            if not tenants:\n                messages.error(request,\n                               _('You are not authorized for any projects.') %\n                                {\"user\": data['username']},\n                               extra_tags=\"login\")\n                return\n\n            # Create a token.\n            # NOTE(gabriel): Keystone can return tenants that you're\n            # authorized to administer but not to log into as a user, so in\n            # the case of an Unauthorized error we should iterate through\n            # the tenants until one succeeds or we've failed them all.\n            while tenants:\n                tenant = tenants.pop()\n                try:\n                    token = api.token_create_scoped(request,\n                                                    tenant.id,\n                                                    unscoped_token.id)\n                    break\n                except:\n                    # This will continue for recognized Unauthorized\n                    # exceptions from keystoneclient.\n                    exceptions.handle(request, ignore=True)\n                    token = None\n            if token is None:\n                raise exceptions.NotAuthorized(\n                    _(\"You are not authorized for any available projects.\"))\n\n            _set_session_data(request, token)\n            user = users.get_user_from_request(request)\n        redirect = redirect_to or base.Horizon.get_user_home(user)\n        return shortcuts.redirect(redirect)\n\n\nclass LoginWithTenant(Login):\n    \"\"\"\n    Exactly like :class:`.Login` but includes the tenant id as a field\n    so that the process of choosing a default tenant is bypassed.\n    \"\"\"\n    region = forms.ChoiceField(required=False)\n    username = forms.CharField(max_length=\"20\",\n                       widget=forms.TextInput(attrs={'readonly': 'readonly'}))\n    tenant = forms.CharField(widget=forms.HiddenInput())\n"], "filenames": ["horizon/exceptions.py", "horizon/middleware.py", "horizon/tests/auth_tests.py", "horizon/users.py", "horizon/views/auth.py", "horizon/views/auth_forms.py"], "buggy_code_start_loc": [206, 51, 19, 62, 99, 79], "buggy_code_end_loc": [207, 51, 222, 63, 100, 120], "fixing_code_start_loc": [206, 52, 20, 62, 99, 80], "fixing_code_end_loc": [207, 61, 275, 63, 100, 130], "type": "NVD-CWE-Other", "message": "Session fixation vulnerability in OpenStack Dashboard (Horizon) folsom-1 and 2012.1 allows remote attackers to hijack web sessions via the sessionid cookie.", "other": {"cve": {"id": "CVE-2012-2144", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-05T22:55:11.233", "lastModified": "2017-08-29T01:31:31.383", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Session fixation vulnerability in OpenStack Dashboard (Horizon) folsom-1 and 2012.1 allows remote attackers to hijack web sessions via the sessionid cookie."}, {"lang": "es", "value": "Vulnerabilidad de fijaci\u00f3n de sesi\u00f3n en OpenStack Dashboard (Horizon) Folsom-1 y v2012.1 permite a atacantes remotos secuestrar sesiones web a trav\u00e9s de la cookie SessionID."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openstack:horizon:2012.1:*:*:*:*:*:*:*", "matchCriteriaId": "8FC7F2DB-92EA-4074-8882-367721CC1705"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openstack:horizon:folsom-1:*:*:*:*:*:*:*", "matchCriteriaId": "1E72EACB-1FA6-4F1D-A3C8-D255C705AAAD"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2012-May/081173.html", "source": "secalert@redhat.com"}, {"url": "http://ubuntu.com/usn/usn-1439-1", "source": "secalert@redhat.com"}, {"url": "http://www.openwall.com/lists/oss-security/2012/05/05/1", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/53399", "source": "secalert@redhat.com"}, {"url": "https://bugs.launchpad.net/horizon/+bug/978896", "source": "secalert@redhat.com"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/75423", "source": "secalert@redhat.com"}, {"url": "https://github.com/openstack/horizon/commit/041b1c44c7d6cf5429505067c32f8f35166a8bab", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/openstack/horizon/commit/041b1c44c7d6cf5429505067c32f8f35166a8bab"}}