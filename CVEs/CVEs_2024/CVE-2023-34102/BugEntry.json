{"buggy_code": ["module Avo\n  module Fields\n    # The field can be in multiple scenarios where it needs different types of data and displays the state differently.\n    # For example the non-polymorphic, non-searchable variant is the easiest to support. You only need to populate a simple select with the ID of the associated record and the list of records.\n    # For the searchable polymorphic variant you need to provide the type of the association (Post, Project, Team), the label of the associated record (\"Cool post title\") and the ID of that record.\n    # Furthermore, the way Avo works, it needs to do some queries on the back-end to fetch the required information.\n    #\n    # Field scenarios:\n    # 1. Create new record\n    #   List of records\n    # 2. Create new record as association\n    #   List of records, the ID\n    # 3. Create new searchable record\n    #   Nothing really. The records will be fetched from the search API\n    # 4. Create new searchable record as association\n    #   The associated record label and ID. The records will be fetched from the search API\n    # 5. Create new polymorphic record\n    #   Type & ID\n    # 6. Create new polymorphic record as association\n    #   Type, list of records, and ID\n    # 7. Create new polymorphic searchable record\n    #   Type, Label and ID\n    # 8. Create new polymorphic searchable record as association\n    #   Type, Label and ID\n    # 9. Edit a record\n    #   List of records & ID\n    # 10. Edit a record as searchable\n    #   Label and ID\n    # 11. Edit a record as an association\n    #   List and ID\n    # 12. Edit a record as an searchable association\n    #   Label and ID\n    # 13. Edit a polymorphic record\n    #   Type, List of records & ID\n    # 14. Edit a polymorphic record as searchable\n    #   Type, Label and ID\n    # 15. Edit a polymorphic record as an association\n    #   Type, List and ID\n    # 16. Edit a polymorphic record as an searchable association\n    #   Type, Label and ID\n    # Also all of the above with a namespaced model `Course/Link`\n\n    # Variants\n    # 1. Select belongs to\n    # 2. Searchable belongs to\n    # 3. Select Polymorphic belongs to\n    # 4. Searchable Polymorphic belongs to\n\n    # Requirements\n    # - list\n    # - ID\n    # - label\n    # - Type\n    # - foreign_key\n    # - foreign_key for poly type\n    # - foreign_key for poly id\n    # - is_disabled?\n\n    class BelongsToField < BaseField\n      include Avo::Fields::Concerns::UseResource\n\n      attr_accessor :target\n\n      attr_reader :polymorphic_as\n      attr_reader :relation_method\n      attr_reader :types # for Polymorphic associations\n      attr_reader :allow_via_detaching\n      attr_reader :attach_scope\n      attr_reader :polymorphic_help\n\n      def initialize(id, **args, &block)\n        args[:placeholder] ||= I18n.t(\"avo.choose_an_option\")\n\n        super(id, **args, &block)\n\n        @searchable = args[:searchable] == true\n        @polymorphic_as = args[:polymorphic_as]\n        @types = args[:types]\n        @relation_method = id.to_s.parameterize.underscore\n        @allow_via_detaching = args[:allow_via_detaching] == true\n        @attach_scope = args[:attach_scope]\n        @polymorphic_help = args[:polymorphic_help]\n        @target = args[:target]\n        @use_resource = args[:use_resource] || nil\n      end\n\n      def searchable\n        @searchable && ::Avo::App.license.has_with_trial(:searchable_associations)\n      end\n\n      def value\n        if is_polymorphic?\n          # Get the value from the pre-filled assoociation record\n          super(polymorphic_as)\n        else\n          # Get the value from the pre-filled assoociation record\n          super(relation_method)\n        end\n      end\n\n      # The value\n      def field_value\n        value.send(database_value)\n      rescue\n        nil\n      end\n\n      # What the user sees in the text field\n      def field_label\n        value.send(target_resource.class.title)\n      rescue\n        nil\n      end\n\n      def options\n        values_for_type\n      end\n\n      def values_for_type(model = nil)\n        resource = target_resource\n        resource = App.get_resource_by_model_name model if model.present?\n\n        query = resource.class.query_scope\n\n        if attach_scope.present?\n          query = Avo::Hosts::AssociationScopeHost.new(block: attach_scope, query: query, parent: get_model).handle\n        end\n\n        query.all.map do |model|\n          [model.send(resource.class.title), model.id]\n        end\n      end\n\n      def database_value\n        target_resource.id\n      rescue\n        nil\n      end\n\n      def type_input_foreign_key\n        if is_polymorphic?\n          \"#{foreign_key}_type\"\n        end\n      end\n\n      def id_input_foreign_key\n        if is_polymorphic?\n          \"#{foreign_key}_id\"\n        else\n          foreign_key\n        end\n      end\n\n      def is_polymorphic?\n        polymorphic_as.present?\n      rescue\n        false\n      end\n\n      def foreign_key\n        return polymorphic_as if polymorphic_as.present?\n\n        if @model.present?\n          get_model_class(@model).reflections[@relation_method].foreign_key\n        elsif @resource.present? && @resource.model_class.reflections[@relation_method].present?\n          @resource.model_class.reflections[@relation_method].foreign_key\n        end\n      end\n\n      def reflection_for_key(key)\n        get_model_class(get_model).reflections[key.to_s]\n      rescue\n        nil\n      end\n\n      # Get the model reflection instance\n      def reflection\n        reflection_for_key(id)\n      rescue\n        nil\n      end\n\n      def relation_model_class\n        @resource.model_class\n      end\n\n      def label\n        value.send(target_resource.class.title)\n      end\n\n      def to_permitted_param\n        if polymorphic_as.present?\n          return [\"#{polymorphic_as}_type\".to_sym, \"#{polymorphic_as}_id\".to_sym]\n        end\n\n        foreign_key.to_sym\n      end\n\n      def fill_field(model, key, value, params)\n        return model unless model.methods.include? key.to_sym\n\n        if polymorphic_as.present?\n          model.send(\"#{polymorphic_as}_type=\", params[\"#{polymorphic_as}_type\"])\n\n          # If the type is blank, reset the id too.\n          if params[\"#{polymorphic_as}_type\"].blank?\n            model.send(\"#{polymorphic_as}_id=\", nil)\n          else\n            model.send(\"#{polymorphic_as}_id=\", params[\"#{polymorphic_as}_id\"])\n          end\n        else\n          model.send(\"#{key}=\", value)\n        end\n\n        model\n      end\n\n      def database_id\n        # If the field is a polymorphic value, return the polymorphic_type as key and pre-fill the _id in fill_field.\n        return \"#{polymorphic_as}_type\" if polymorphic_as.present?\n\n        foreign_key\n      rescue\n        id\n      end\n\n      def target_resource\n        return use_resource if use_resource.present?\n\n        if is_polymorphic?\n          if value.present?\n            return App.get_resource_by_model_name(value.class)\n          else\n            return nil\n          end\n        end\n\n        reflection_key = polymorphic_as || id\n\n        if @model._reflections[reflection_key.to_s].klass.present?\n          App.get_resource_by_model_name @model._reflections[reflection_key.to_s].klass.to_s\n        elsif @model._reflections[reflection_key.to_s].options[:class_name].present?\n          App.get_resource_by_model_name @model._reflections[reflection_key.to_s].options[:class_name]\n        else\n          App.get_resource_by_name reflection_key.to_s\n        end\n      end\n\n      def get_model\n        return @model if @model.present?\n\n        @resource.model\n      rescue\n        nil\n      end\n\n      def name\n        return polymorphic_as.to_s.humanize if polymorphic_as.present? && view == :index\n\n        super\n      end\n\n      private\n\n      def get_model_class(model)\n        if model.instance_of?(Class)\n          model\n        else\n          model.class\n        end\n      end\n    end\n  end\nend\n"], "fixing_code": ["module Avo\n  module Fields\n    # The field can be in multiple scenarios where it needs different types of data and displays the state differently.\n    # For example the non-polymorphic, non-searchable variant is the easiest to support. You only need to populate a simple select with the ID of the associated record and the list of records.\n    # For the searchable polymorphic variant you need to provide the type of the association (Post, Project, Team), the label of the associated record (\"Cool post title\") and the ID of that record.\n    # Furthermore, the way Avo works, it needs to do some queries on the back-end to fetch the required information.\n    #\n    # Field scenarios:\n    # 1. Create new record\n    #   List of records\n    # 2. Create new record as association\n    #   List of records, the ID\n    # 3. Create new searchable record\n    #   Nothing really. The records will be fetched from the search API\n    # 4. Create new searchable record as association\n    #   The associated record label and ID. The records will be fetched from the search API\n    # 5. Create new polymorphic record\n    #   Type & ID\n    # 6. Create new polymorphic record as association\n    #   Type, list of records, and ID\n    # 7. Create new polymorphic searchable record\n    #   Type, Label and ID\n    # 8. Create new polymorphic searchable record as association\n    #   Type, Label and ID\n    # 9. Edit a record\n    #   List of records & ID\n    # 10. Edit a record as searchable\n    #   Label and ID\n    # 11. Edit a record as an association\n    #   List and ID\n    # 12. Edit a record as an searchable association\n    #   Label and ID\n    # 13. Edit a polymorphic record\n    #   Type, List of records & ID\n    # 14. Edit a polymorphic record as searchable\n    #   Type, Label and ID\n    # 15. Edit a polymorphic record as an association\n    #   Type, List and ID\n    # 16. Edit a polymorphic record as an searchable association\n    #   Type, Label and ID\n    # Also all of the above with a namespaced model `Course/Link`\n\n    # Variants\n    # 1. Select belongs to\n    # 2. Searchable belongs to\n    # 3. Select Polymorphic belongs to\n    # 4. Searchable Polymorphic belongs to\n\n    # Requirements\n    # - list\n    # - ID\n    # - label\n    # - Type\n    # - foreign_key\n    # - foreign_key for poly type\n    # - foreign_key for poly id\n    # - is_disabled?\n\n    class BelongsToField < BaseField\n      include Avo::Fields::Concerns::UseResource\n\n      attr_accessor :target\n\n      attr_reader :polymorphic_as\n      attr_reader :relation_method\n      attr_reader :types # for Polymorphic associations\n      attr_reader :allow_via_detaching\n      attr_reader :attach_scope\n      attr_reader :polymorphic_help\n\n      def initialize(id, **args, &block)\n        args[:placeholder] ||= I18n.t(\"avo.choose_an_option\")\n\n        super(id, **args, &block)\n\n        @searchable = args[:searchable] == true\n        @polymorphic_as = args[:polymorphic_as]\n        @types = args[:types]\n        @relation_method = id.to_s.parameterize.underscore\n        @allow_via_detaching = args[:allow_via_detaching] == true\n        @attach_scope = args[:attach_scope]\n        @polymorphic_help = args[:polymorphic_help]\n        @target = args[:target]\n        @use_resource = args[:use_resource] || nil\n      end\n\n      def searchable\n        @searchable && ::Avo::App.license.has_with_trial(:searchable_associations)\n      end\n\n      def value\n        if is_polymorphic?\n          # Get the value from the pre-filled assoociation record\n          super(polymorphic_as)\n        else\n          # Get the value from the pre-filled assoociation record\n          super(relation_method)\n        end\n      end\n\n      # The value\n      def field_value\n        value.send(database_value)\n      rescue\n        nil\n      end\n\n      # What the user sees in the text field\n      def field_label\n        value.send(target_resource.class.title)\n      rescue\n        nil\n      end\n\n      def options\n        values_for_type\n      end\n\n      def values_for_type(model = nil)\n        resource = target_resource\n        resource = App.get_resource_by_model_name model if model.present?\n\n        query = resource.class.query_scope\n\n        if attach_scope.present?\n          query = Avo::Hosts::AssociationScopeHost.new(block: attach_scope, query: query, parent: get_model).handle\n        end\n\n        query.all.map do |model|\n          [model.send(resource.class.title), model.id]\n        end\n      end\n\n      def database_value\n        target_resource.id\n      rescue\n        nil\n      end\n\n      def type_input_foreign_key\n        if is_polymorphic?\n          \"#{foreign_key}_type\"\n        end\n      end\n\n      def id_input_foreign_key\n        if is_polymorphic?\n          \"#{foreign_key}_id\"\n        else\n          foreign_key\n        end\n      end\n\n      def is_polymorphic?\n        polymorphic_as.present?\n      rescue\n        false\n      end\n\n      def foreign_key\n        return polymorphic_as if polymorphic_as.present?\n\n        if @model.present?\n          get_model_class(@model).reflections[@relation_method].foreign_key\n        elsif @resource.present? && @resource.model_class.reflections[@relation_method].present?\n          @resource.model_class.reflections[@relation_method].foreign_key\n        end\n      end\n\n      def reflection_for_key(key)\n        get_model_class(get_model).reflections[key.to_s]\n      rescue\n        nil\n      end\n\n      # Get the model reflection instance\n      def reflection\n        reflection_for_key(id)\n      rescue\n        nil\n      end\n\n      def relation_model_class\n        @resource.model_class\n      end\n\n      def label\n        value.send(target_resource.class.title)\n      end\n\n      def to_permitted_param\n        if polymorphic_as.present?\n          return [\"#{polymorphic_as}_type\".to_sym, \"#{polymorphic_as}_id\".to_sym]\n        end\n\n        foreign_key.to_sym\n      end\n\n      def fill_field(model, key, value, params)\n        return model unless model.methods.include? key.to_sym\n\n        valid_model_class = valid_polymorphic_class params[\"#{polymorphic_as}_type\"]\n\n        if polymorphic_as.present?\n          model.send(\"#{polymorphic_as}_type=\", valid_model_class)\n\n          # If the type is blank, reset the id too.\n          if valid_model_class.blank?\n            model.send(\"#{polymorphic_as}_id=\", nil)\n          else\n            model.send(\"#{polymorphic_as}_id=\", params[\"#{polymorphic_as}_id\"])\n          end\n        else\n          model.send(\"#{key}=\", value)\n        end\n\n        model\n      end\n\n      def valid_polymorphic_class(possible_class)\n        types.find do |type|\n          type.to_s == possible_class.to_s\n        end\n      end\n\n      def database_id\n        # If the field is a polymorphic value, return the polymorphic_type as key and pre-fill the _id in fill_field.\n        return \"#{polymorphic_as}_type\" if polymorphic_as.present?\n\n        foreign_key\n      rescue\n        id\n      end\n\n      def target_resource\n        return use_resource if use_resource.present?\n\n        if is_polymorphic?\n          if value.present?\n            return App.get_resource_by_model_name(value.class)\n          else\n            return nil\n          end\n        end\n\n        reflection_key = polymorphic_as || id\n\n        if @model._reflections[reflection_key.to_s].klass.present?\n          App.get_resource_by_model_name @model._reflections[reflection_key.to_s].klass.to_s\n        elsif @model._reflections[reflection_key.to_s].options[:class_name].present?\n          App.get_resource_by_model_name @model._reflections[reflection_key.to_s].options[:class_name]\n        else\n          App.get_resource_by_name reflection_key.to_s\n        end\n      end\n\n      def get_model\n        return @model if @model.present?\n\n        @resource.model\n      rescue\n        nil\n      end\n\n      def name\n        return polymorphic_as.to_s.humanize if polymorphic_as.present? && view == :index\n\n        super\n      end\n\n      private\n\n      def get_model_class(model)\n        if model.instance_of?(Class)\n          model\n        else\n          model.class\n        end\n      end\n    end\n  end\nend\n"], "filenames": ["lib/avo/fields/belongs_to_field.rb"], "buggy_code_start_loc": [201], "buggy_code_end_loc": [215], "fixing_code_start_loc": [202], "fixing_code_end_loc": [224], "type": "CWE-470", "message": "Avo is an open source ruby on rails admin panel creation framework. The polymorphic field type stores the classes to operate on when updating a record with user input, and does not validate them in the back end. This can lead to unexpected behavior, remote code execution, or application crashes when viewing a manipulated record. This issue has been addressed in commit `ec117882d` which is expected to be included in subsequent releases. Users are advised to limit access to untrusted users until a new release is made.", "other": {"cve": {"id": "CVE-2023-34102", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-05T23:15:12.220", "lastModified": "2023-06-12T16:46:32.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Avo is an open source ruby on rails admin panel creation framework. The polymorphic field type stores the classes to operate on when updating a record with user input, and does not validate them in the back end. This can lead to unexpected behavior, remote code execution, or application crashes when viewing a manipulated record. This issue has been addressed in commit `ec117882d` which is expected to be included in subsequent releases. Users are advised to limit access to untrusted users until a new release is made."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-470"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:avohq:avo:*:*:*:*:*:ruby:*:*", "versionEndIncluding": "2.33.2", "matchCriteriaId": "27594A1A-CFFC-4741-9F4F-45532F8FFCFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:avohq:avo:3.0.0:pre12:*:*:*:ruby:*:*", "matchCriteriaId": "33F74798-D928-4FA3-B890-81C43DAC8F91"}]}]}], "references": [{"url": "https://github.com/avo-hq/avo/commit/ec117882ddb1b519481bdd046dc3cfa4474e6e17", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/avo-hq/avo/security/advisories/GHSA-86h2-2g4g-29qx", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/avo-hq/avo/commit/ec117882ddb1b519481bdd046dc3cfa4474e6e17"}}