{"buggy_code": ["module FormHelper\n  def text_f(f, attr, options = {})\n    field(f, attr, options) do\n      addClass options, \"form-control\"\n      options[:focus_on_load] ||= attr.to_s == 'name'\n      f.text_field attr, options\n    end\n  end\n\n  def textarea_f(f, attr, options = {})\n    field(f, attr, options) do\n      options[:rows] = line_count(f, attr) if options[:rows] == :auto\n      addClass options, \"form-control\"\n      f.text_area(attr, options)\n    end\n  end\n\n  def button_input_group(content, options = {}, glyph = nil)\n    options[:type] ||= 'button'\n    options[:herf] ||= '#'\n    options[:class] ||= 'btn btn-default'\n    content_tag :span, class: 'input-group-btn' do\n      content_tag :button, content, options  do\n        content_tag :span,content, :class => glyph\n      end\n    end\n  end\n\n  def password_f(f, attr, options = {})\n    unset_button = options.delete(:unset)\n    password_field_tag(:fakepassword, nil, :style => 'display: none') +\n        field(f, attr, options) do\n          options[:autocomplete]   ||= 'off'\n          options[:placeholder]    ||= password_placeholder(f.object, attr)\n          options[:disabled] = true if unset_button\n          addClass options, 'form-control'\n          pass = f.password_field(attr, options) +\n              '<span class=\"glyphicon glyphicon-warning-sign input-addon\"\n             title=\"'.html_safe + _('Caps lock ON') +\n              '\" style=\"display:none\"></span>'.html_safe\n          if unset_button\n            button = button_input_group '', {:id => 'disable-pass-btn', :onclick => \"toggle_input_group(this)\", :title => _(\"Change the password\")}, 'glyphicon glyphicon-pencil'\n            input_group pass, button\n          else\n            pass\n          end\n        end\n  end\n\n  def checkbox_f(f, attr, options = {}, checked_value = \"1\", unchecked_value = \"0\")\n    text = options.delete(:help_text)\n    inline = options.delete(:help_inline)\n    field(f, attr, options) do\n      help_inline = inline.blank? ? '' : content_tag(:span, inline, :class => \"help-inline\")\n      f.check_box(attr, options, checked_value, unchecked_value) + \" #{text} \" + help_inline.html_safe\n    end\n  end\n\n  def multiple_checkboxes(f, attr, klass, associations, options = {}, html_options = {})\n    if associations.count > 5\n      associated_obj = klass.send(ActiveModel::Naming.plural(associations.first))\n      selected_ids = associated_obj.select(\"#{associations.first.class.table_name}.id\").map(&:id)\n      multiple_selects(f, attr, associations, selected_ids, options, html_options)\n    else\n      field(f, attr, options) do\n        authorized_edit_habtm klass, associations, options[:prefix], html_options\n      end\n    end\n  end\n\n  # add hidden field for options[:disabled]\n  def multiple_selects(f, attr, associations, selected_ids, options = {}, html_options = {})\n    options.merge!(:size => \"col-md-10\")\n    authorized = AssociationAuthorizer.authorized_associations(associations).all\n\n    # select2.js breaks the multiselects disabled items location\n    # http://projects.theforeman.org/issues/12028\n    html_options[\"class\"] ||= \"\"\n    html_options[\"class\"] += \" without_select2\"\n    html_options[\"class\"].strip!\n\n    unauthorized = selected_ids.blank? ? [] : selected_ids - authorized.map(&:id)\n    field(f, attr, options) do\n      attr_ids = (attr.to_s.singularize+\"_ids\").to_sym\n      hidden_fields = ''\n      html_options[\"data-useds\"] ||= \"[]\"\n      JSON.parse(html_options[\"data-useds\"]).each do |disabled_value|\n        hidden_fields += f.hidden_field(attr_ids, :multiple => true, :value => disabled_value, :id=>'')\n      end\n      unauthorized.each do |unauthorized_value|\n        hidden_fields += f.hidden_field(attr_ids, :multiple => true, :value => unauthorized_value, :id=>'')\n      end\n      hidden_fields + f.collection_select(attr_ids, authorized.sort_by { |a| a.to_s },\n                                          :id, :to_label, options.merge(:selected => selected_ids),\n                                          html_options.merge(:multiple => true))\n    end\n  end\n\n  def line_count(f, attr)\n    rows = f.object.try(attr).to_s.lines.count rescue 1\n    rows == 0 ? 1 : rows\n  end\n\n  def radio_button_f(f, attr, options = {})\n    text = options.delete(:text)\n    value = options.delete(:value)\n    label_tag('', :class=>\"radio-inline\") do\n      f.radio_button(attr, value, options) + \" #{text} \"\n    end\n  end\n\n  def select_f(f, attr, array, id, method, select_options = {}, html_options = {})\n    array = array.to_a.dup\n    disable_button = select_options.delete(:disable_button)\n    include_blank = select_options.delete(:include_blank)\n    disable_button_enabled = select_options.delete(:disable_button_enabled)\n    user_set = !!select_options.delete(:user_set)\n\n    if include_blank\n      blank_value = include_blank.is_a?(TrueClass) ? nil : include_blank\n      blank_option = OpenStruct.new({id => '', method => blank_value })\n      # if the method is to_s, OpenStruct will respond with its own version.\n      # in this case, I need to undefine its own alias to to_s, and use the attribute\n      # that was defined in the struct.\n      blank_option.instance_eval('undef to_s') if method.to_s == 'to_s' || id.to_s == 'to_s'\n      array.insert(0, blank_option)\n    end\n\n    select_options[:disabled] = '' if select_options[:disabled] == include_blank\n    html_options.merge!(:disabled => true) if disable_button_enabled\n\n    html_options.merge!(:size => 'col-md-10') if html_options[:multiple]\n    field(f, attr, html_options) do\n      addClass html_options, \"form-control\"\n\n      collection_select = f.collection_select(attr, array, id, method, select_options, html_options)\n\n      if disable_button\n        button_part =\n            content_tag :span, class: 'input-group-btn' do\n              content_tag(:button, disable_button, :type => 'button', :href => '#',\n                          :name => 'is_overridden_btn',\n                          :onclick => \"disableButtonToggle(this)\",\n                          :class => 'btn btn-default btn-can-disable' + (disable_button_enabled ? ' active' : ''),\n                          :data => { :toggle => 'button', :explicit => user_set })\n            end\n\n        input_group collection_select, button_part\n      else\n        collection_select\n      end\n    end\n  end\n\n  def addClass(options = {}, new_class = '')\n    options[:class] = \"#{new_class} #{options[:class]}\"\n  end\n\n  def input_group(*controls)\n    content_tag :div, class: 'input-group' do\n      controls.map { |control_html| concat(control_html) }\n    end\n  end\n\n  def input_group_btn(*controls)\n    content_tag :span, class: 'input-group-btn' do\n      controls.join(' ').html_safe\n    end\n  end\n\n  def time_zone_select_f(f, attr, default_timezone, select_options = {}, html_options = {})\n    field(f, attr, html_options) do\n      addClass html_options, \"form-control\"\n      f.time_zone_select(attr, [default_timezone], select_options, html_options)\n    end\n  end\n\n  def selectable_f(f, attr, array, select_options = {}, html_options = {})\n    html_options.merge!(:size => 'col-md-10') if html_options[:multiple]\n    field(f, attr, html_options) do\n      addClass html_options, \"form-control\"\n      f.select attr, array, select_options, html_options\n    end\n  end\n\n  def file_field_f(f, attr, options = {})\n    field(f, attr, options) do\n      f.file_field attr, options\n    end\n  end\n\n  def autocomplete_f(f, attr, options = {})\n    field(f, attr, options) do\n      path = options.delete(:path) || send(\"#{f.object.class.pluralize.underscore}_path\") if options[:full_path].nil?\n      auto_complete_search(attr,\n                           f.object.send(attr).try(:squeeze, \" \"),\n                           options.merge(\n                               :placeholder => _(\"Filter\") + ' ...',\n                               :path        => path,\n                               :name        => \"#{f.object_name}[#{attr}]\"\n                           )\n      ).html_safe\n    end\n  end\n\n  def form_to_submit_id(f)\n    object = f.object.respond_to?(:to_model) ? f.object.to_model : f.object\n    key = if object.present?\n            object.persisted? ? :update : :create\n          else\n            :submit\n          end\n    model = if object.class.respond_to?(:humanize_class_name)\n              object.class.humanize_class_name.downcase\n            elsif object.class.respond_to?(:model_name)\n              object.class.model_name.human.downcase\n            else\n              f.object_name.to_s\n            end.gsub(/\\W+/, '_')\n    \"aid_#{key}_#{model}\"\n  end\n\n  def submit_or_cancel(f, overwrite = false, args = { })\n    args[:cancel_path] ||= send(\"#{controller_name}_path\")\n    content_tag(:div, :class => \"clearfix\") do\n      content_tag(:div, :class => \"form-actions\") do\n        text    = overwrite ? _(\"Overwrite\") : _(\"Submit\")\n        options = {}\n        options[:class] = \"btn btn-#{overwrite ? 'danger' : 'primary'} remove_form_templates\"\n        options.merge! :'data-id' => form_to_submit_id(f) unless options.has_key?(:'data-id')\n        link_to(_(\"Cancel\"), args[:cancel_path], :class => \"btn btn-default\") + \" \" + f.submit(text, options)\n      end\n    end\n  end\n\n  def add_help_to_label(size_class, label, help_inline)\n    label.html_safe +\n        content_tag(:div, :class => size_class) do\n          yield\n        end.html_safe + help_inline.html_safe\n  end\n\n  def is_required?(f, attr)\n    return false unless f && f.object.class.respond_to?(:validators_on)\n    f.object.class.validators_on(attr).any? do |validator|\n      options = validator.options.keys.map(&:to_s)\n      validator.is_a?(ActiveModel::Validations::PresenceValidator) && !options.include?('if') && !options.include?('unless')\n    end\n  end\n\n  def form_for(record_or_name_or_array, *args, &proc)\n    if args.last.is_a?(Hash)\n      args.last[:html] = {:class=>\"form-horizontal well\"}.merge(args.last[:html]||{})\n    else\n      args << {:html=>{:class=>\"form-horizontal well\"}}\n    end\n    super record_or_name_or_array, *args, &proc\n  end\n\n  def number_f(f, attr, options = {})\n    field(f, attr, options) do\n      addClass options, \"form-control\"\n      f.number_field attr, options\n    end\n  end\n\n  def help_inline(inline, error)\n    help_inline = error.empty? ? inline : content_tag(:span, error.to_sentence.html_safe, :class => 'error-message')\n    case help_inline\n      when blank?\n        \"\"\n      when :indicator\n        content_tag(:span, content_tag(:div, '', :class => 'hide spinner spinner-xs'),\n                    :class => 'help-block').html_safe\n      else\n        content_tag(:span, help_inline, :class => \"help-block help-inline\")\n    end\n  end\n\n  def add_label options, f, attr\n    label_size = options.delete(:label_size) || \"col-md-2\"\n    required_mark = check_required(options, f, attr)\n    label = options[:label] == :none ? '' : options.delete(:label)\n    label ||= ((clazz = f.object.class).respond_to?(:gettext_translation_for_attribute_name) &&\n        s_(clazz.gettext_translation_for_attribute_name attr)) if f\n    label = label.present? ? label_tag(attr, \"#{label}#{required_mark}\".html_safe, :class => label_size + \" control-label\") : ''\n    label\n  end\n\n  def check_required options, f, attr\n    required = options.delete(:required) # we don't want to use html5 required attr so we delete the option\n    return ' *' if required.nil? ? is_required?(f, attr) : required\n  end\n\n  def blank_or_inherit_f(f, attr)\n    return true unless f.object.respond_to?(:parent_id) && f.object.parent_id\n    inherited_value   = f.object.send(attr).try(:name_method)\n    inherited_value ||= _(\"no value\")\n    _(\"Inherit parent (%s)\") % inherited_value\n  end\n\n  def link_to_remove_fields(name, f, options = {})\n    f.hidden_field(:_destroy) + link_to_function(icon_text('close', name, :kind => 'pficon'), \"remove_fields(this)\", options.merge(:title => _(\"Remove Parameter\")))\n  end\n\n  # Creates a link to a javascript function that creates field entries for the association on the web page\n  # +name+       : String containing links's text\n  # +f+          : FormBuiler object\n  # +association : The field are created to allow entry into this association\n  # +partial+    : String containing an optional partial into which we render\n  def link_to_add_fields(name, f, association, partial = nil, options = {})\n    new_object = f.object.class.reflect_on_association(association).klass.new\n    fields = f.fields_for(association, new_object, :child_index => \"new_#{association}\") do |builder|\n      render((partial.nil? ? association.to_s.singularize + \"_fields\" : partial), :f => builder)\n    end\n    options[:class] = \"btn btn-primary #{options[:class]}\"\n    link_to_function(name, (\"add_fields('#{options[:target]}', '#{association}', '#{escape_javascript(fields)}')\").html_safe, options)\n  end\n\n  def field(f, attr, options = {})\n    table_field = options.delete(:table_field)\n    error       = options.delete(:error) || f.object.errors[attr] if f && f.object.respond_to?(:errors)\n    help_inline = help_inline(options.delete(:help_inline), error)\n    size_class  = options.delete(:size) || \"col-md-4\"\n    wrapper_class = options.delete(:wrapper_class) || \"form-group\"\n\n    label = options[:no_label] ? \"\" : add_label(options, f, attr)\n\n    if table_field\n      add_help_to_label(size_class, label, help_inline) do\n        yield\n      end.html_safe\n    else\n      help_block = content_tag(:span, options.delete(:help_block), :class => \"help-block\")\n\n      content_tag(:div, :class => \"clearfix\") do\n        content_tag(:div, :class => \"#{wrapper_class} #{error.empty? ? '' : 'has-error'}\",\n                    :id => options.delete(:control_group_id)) do\n          input = capture do\n            if options[:fullscreen]\n              content_tag(:div, yield.html_safe + fullscreen_input, :class => \"input-group\")\n            else\n              yield.html_safe\n            end\n          end\n          add_help_to_label(size_class, label, help_inline) do\n            input + help_block.html_safe\n          end\n        end.html_safe\n      end\n    end\n  end\nend\n"], "fixing_code": ["module FormHelper\n  def text_f(f, attr, options = {})\n    field(f, attr, options) do\n      addClass options, \"form-control\"\n      options[:focus_on_load] ||= attr.to_s == 'name'\n      f.text_field attr, options\n    end\n  end\n\n  def textarea_f(f, attr, options = {})\n    field(f, attr, options) do\n      options[:rows] = line_count(f, attr) if options[:rows] == :auto\n      addClass options, \"form-control\"\n      f.text_area(attr, options)\n    end\n  end\n\n  def button_input_group(content, options = {}, glyph = nil)\n    options[:type] ||= 'button'\n    options[:herf] ||= '#'\n    options[:class] ||= 'btn btn-default'\n    content_tag :span, class: 'input-group-btn' do\n      content_tag :button, content, options  do\n        content_tag :span,content, :class => glyph\n      end\n    end\n  end\n\n  def password_f(f, attr, options = {})\n    unset_button = options.delete(:unset)\n    password_field_tag(:fakepassword, nil, :style => 'display: none') +\n        field(f, attr, options) do\n          options[:autocomplete]   ||= 'off'\n          options[:placeholder]    ||= password_placeholder(f.object, attr)\n          options[:disabled] = true if unset_button\n          addClass options, 'form-control'\n          pass = f.password_field(attr, options) +\n              '<span class=\"glyphicon glyphicon-warning-sign input-addon\"\n             title=\"'.html_safe + _('Caps lock ON') +\n              '\" style=\"display:none\"></span>'.html_safe\n          if unset_button\n            button = button_input_group '', {:id => 'disable-pass-btn', :onclick => \"toggle_input_group(this)\", :title => _(\"Change the password\")}, 'glyphicon glyphicon-pencil'\n            input_group pass, button\n          else\n            pass\n          end\n        end\n  end\n\n  def checkbox_f(f, attr, options = {}, checked_value = \"1\", unchecked_value = \"0\")\n    text = options.delete(:help_text)\n    inline = options.delete(:help_inline)\n    field(f, attr, options) do\n      help_inline = inline.blank? ? '' : content_tag(:span, inline, :class => \"help-inline\")\n      f.check_box(attr, options, checked_value, unchecked_value) + \" #{text} \" + help_inline.html_safe\n    end\n  end\n\n  def multiple_checkboxes(f, attr, klass, associations, options = {}, html_options = {})\n    if associations.count > 5\n      associated_obj = klass.send(ActiveModel::Naming.plural(associations.first))\n      selected_ids = associated_obj.select(\"#{associations.first.class.table_name}.id\").map(&:id)\n      multiple_selects(f, attr, associations, selected_ids, options, html_options)\n    else\n      field(f, attr, options) do\n        authorized_edit_habtm klass, associations, options[:prefix], html_options\n      end\n    end\n  end\n\n  # add hidden field for options[:disabled]\n  def multiple_selects(f, attr, associations, selected_ids, options = {}, html_options = {})\n    options.merge!(:size => \"col-md-10\")\n    authorized = AssociationAuthorizer.authorized_associations(associations).all\n\n    # select2.js breaks the multiselects disabled items location\n    # http://projects.theforeman.org/issues/12028\n    html_options[\"class\"] ||= \"\"\n    html_options[\"class\"] += \" without_select2\"\n    html_options[\"class\"].strip!\n\n    unauthorized = selected_ids.blank? ? [] : selected_ids - authorized.map(&:id)\n    field(f, attr, options) do\n      attr_ids = (attr.to_s.singularize+\"_ids\").to_sym\n      hidden_fields = ''\n      html_options[\"data-useds\"] ||= \"[]\"\n      JSON.parse(html_options[\"data-useds\"]).each do |disabled_value|\n        hidden_fields += f.hidden_field(attr_ids, :multiple => true, :value => disabled_value, :id=>'')\n      end\n      unauthorized.each do |unauthorized_value|\n        hidden_fields += f.hidden_field(attr_ids, :multiple => true, :value => unauthorized_value, :id=>'')\n      end\n      hidden_fields + f.collection_select(attr_ids, authorized.sort_by { |a| a.to_s },\n                                          :id, :to_label, options.merge(:selected => selected_ids),\n                                          html_options.merge(:multiple => true))\n    end\n  end\n\n  def line_count(f, attr)\n    rows = f.object.try(attr).to_s.lines.count rescue 1\n    rows == 0 ? 1 : rows\n  end\n\n  def radio_button_f(f, attr, options = {})\n    text = options.delete(:text)\n    value = options.delete(:value)\n    label_tag('', :class=>\"radio-inline\") do\n      f.radio_button(attr, value, options) + \" #{text} \"\n    end\n  end\n\n  def select_f(f, attr, array, id, method, select_options = {}, html_options = {})\n    array = array.to_a.dup\n    disable_button = select_options.delete(:disable_button)\n    include_blank = select_options.delete(:include_blank)\n    disable_button_enabled = select_options.delete(:disable_button_enabled)\n    user_set = !!select_options.delete(:user_set)\n\n    if include_blank\n      blank_value = include_blank.is_a?(TrueClass) ? nil : include_blank\n      blank_option = OpenStruct.new({id => '', method => blank_value })\n      # if the method is to_s, OpenStruct will respond with its own version.\n      # in this case, I need to undefine its own alias to to_s, and use the attribute\n      # that was defined in the struct.\n      blank_option.instance_eval('undef to_s') if method.to_s == 'to_s' || id.to_s == 'to_s'\n      array.insert(0, blank_option)\n    end\n\n    select_options[:disabled] = '' if select_options[:disabled] == include_blank\n    html_options.merge!(:disabled => true) if disable_button_enabled\n\n    html_options.merge!(:size => 'col-md-10') if html_options[:multiple]\n    field(f, attr, html_options) do\n      addClass html_options, \"form-control\"\n\n      collection_select = f.collection_select(attr, array, id, method, select_options, html_options)\n\n      if disable_button\n        button_part =\n            content_tag :span, class: 'input-group-btn' do\n              content_tag(:button, disable_button, :type => 'button', :href => '#',\n                          :name => 'is_overridden_btn',\n                          :onclick => \"disableButtonToggle(this)\",\n                          :class => 'btn btn-default btn-can-disable' + (disable_button_enabled ? ' active' : ''),\n                          :data => { :toggle => 'button', :explicit => user_set })\n            end\n\n        input_group collection_select, button_part\n      else\n        collection_select\n      end\n    end\n  end\n\n  def addClass(options = {}, new_class = '')\n    options[:class] = \"#{new_class} #{options[:class]}\"\n  end\n\n  def input_group(*controls)\n    content_tag :div, class: 'input-group' do\n      controls.map { |control_html| concat(control_html) }\n    end\n  end\n\n  def input_group_btn(*controls)\n    content_tag :span, class: 'input-group-btn' do\n      controls.join(' ').html_safe\n    end\n  end\n\n  def time_zone_select_f(f, attr, default_timezone, select_options = {}, html_options = {})\n    field(f, attr, html_options) do\n      addClass html_options, \"form-control\"\n      f.time_zone_select(attr, [default_timezone], select_options, html_options)\n    end\n  end\n\n  def selectable_f(f, attr, array, select_options = {}, html_options = {})\n    html_options.merge!(:size => 'col-md-10') if html_options[:multiple]\n    field(f, attr, html_options) do\n      addClass html_options, \"form-control\"\n      f.select attr, array, select_options, html_options\n    end\n  end\n\n  def file_field_f(f, attr, options = {})\n    field(f, attr, options) do\n      f.file_field attr, options\n    end\n  end\n\n  def autocomplete_f(f, attr, options = {})\n    field(f, attr, options) do\n      path = options.delete(:path) || send(\"#{f.object.class.pluralize.underscore}_path\") if options[:full_path].nil?\n      auto_complete_search(attr,\n                           f.object.send(attr).try(:squeeze, \" \"),\n                           options.merge(\n                               :placeholder => _(\"Filter\") + ' ...',\n                               :path        => path,\n                               :name        => \"#{f.object_name}[#{attr}]\"\n                           )\n      ).html_safe\n    end\n  end\n\n  def form_to_submit_id(f)\n    object = f.object.respond_to?(:to_model) ? f.object.to_model : f.object\n    key = if object.present?\n            object.persisted? ? :update : :create\n          else\n            :submit\n          end\n    model = if object.class.respond_to?(:humanize_class_name)\n              object.class.humanize_class_name.downcase\n            elsif object.class.respond_to?(:model_name)\n              object.class.model_name.human.downcase\n            else\n              f.object_name.to_s\n            end.gsub(/\\W+/, '_')\n    \"aid_#{key}_#{model}\"\n  end\n\n  def submit_or_cancel(f, overwrite = false, args = { })\n    args[:cancel_path] ||= send(\"#{controller_name}_path\")\n    content_tag(:div, :class => \"clearfix\") do\n      content_tag(:div, :class => \"form-actions\") do\n        text    = overwrite ? _(\"Overwrite\") : _(\"Submit\")\n        options = {}\n        options[:class] = \"btn btn-#{overwrite ? 'danger' : 'primary'} remove_form_templates\"\n        options.merge! :'data-id' => form_to_submit_id(f) unless options.has_key?(:'data-id')\n        link_to(_(\"Cancel\"), args[:cancel_path], :class => \"btn btn-default\") + \" \" + f.submit(text, options)\n      end\n    end\n  end\n\n  def add_help_to_label(size_class, label, help_inline)\n    label.html_safe +\n        content_tag(:div, :class => size_class) do\n          yield\n        end.html_safe + help_inline.html_safe\n  end\n\n  def is_required?(f, attr)\n    return false unless f && f.object.class.respond_to?(:validators_on)\n    f.object.class.validators_on(attr).any? do |validator|\n      options = validator.options.keys.map(&:to_s)\n      validator.is_a?(ActiveModel::Validations::PresenceValidator) && !options.include?('if') && !options.include?('unless')\n    end\n  end\n\n  def form_for(record_or_name_or_array, *args, &proc)\n    if args.last.is_a?(Hash)\n      args.last[:html] = {:class=>\"form-horizontal well\"}.merge(args.last[:html]||{})\n    else\n      args << {:html=>{:class=>\"form-horizontal well\"}}\n    end\n    super record_or_name_or_array, *args, &proc\n  end\n\n  def number_f(f, attr, options = {})\n    field(f, attr, options) do\n      addClass options, \"form-control\"\n      f.number_field attr, options\n    end\n  end\n\n  def help_inline(inline, error)\n    help_inline = error.empty? ? inline : content_tag(:span, error.to_sentence.html_safe, :class => 'error-message')\n    case help_inline\n      when blank?\n        \"\"\n      when :indicator\n        content_tag(:span, content_tag(:div, '', :class => 'hide spinner spinner-xs'),\n                    :class => 'help-block').html_safe\n      else\n        content_tag(:span, help_inline, :class => \"help-block help-inline\")\n    end\n  end\n\n  def add_label options, f, attr\n    label_size = options.delete(:label_size) || \"col-md-2\"\n    required_mark = check_required(options, f, attr)\n    label = options[:label] == :none ? '' : options.delete(:label)\n    label ||= ((clazz = f.object.class).respond_to?(:gettext_translation_for_attribute_name) &&\n        s_(clazz.gettext_translation_for_attribute_name attr)) if f\n    label = label.present? ? label_tag(attr, \"#{label}#{required_mark}\", :class => label_size + \" control-label\") : ''\n    label\n  end\n\n  def check_required options, f, attr\n    required = options.delete(:required) # we don't want to use html5 required attr so we delete the option\n    return ' *' if required.nil? ? is_required?(f, attr) : required\n  end\n\n  def blank_or_inherit_f(f, attr)\n    return true unless f.object.respond_to?(:parent_id) && f.object.parent_id\n    inherited_value   = f.object.send(attr).try(:name_method)\n    inherited_value ||= _(\"no value\")\n    _(\"Inherit parent (%s)\") % inherited_value\n  end\n\n  def link_to_remove_fields(name, f, options = {})\n    f.hidden_field(:_destroy) + link_to_function(icon_text('close', name, :kind => 'pficon'), \"remove_fields(this)\", options.merge(:title => _(\"Remove Parameter\")))\n  end\n\n  # Creates a link to a javascript function that creates field entries for the association on the web page\n  # +name+       : String containing links's text\n  # +f+          : FormBuiler object\n  # +association : The field are created to allow entry into this association\n  # +partial+    : String containing an optional partial into which we render\n  def link_to_add_fields(name, f, association, partial = nil, options = {})\n    new_object = f.object.class.reflect_on_association(association).klass.new\n    fields = f.fields_for(association, new_object, :child_index => \"new_#{association}\") do |builder|\n      render((partial.nil? ? association.to_s.singularize + \"_fields\" : partial), :f => builder)\n    end\n    options[:class] = \"btn btn-primary #{options[:class]}\"\n    link_to_function(name, (\"add_fields('#{options[:target]}', '#{association}', '#{escape_javascript(fields)}')\").html_safe, options)\n  end\n\n  def field(f, attr, options = {})\n    table_field = options.delete(:table_field)\n    error       = options.delete(:error) || f.object.errors[attr] if f && f.object.respond_to?(:errors)\n    help_inline = help_inline(options.delete(:help_inline), error)\n    size_class  = options.delete(:size) || \"col-md-4\"\n    wrapper_class = options.delete(:wrapper_class) || \"form-group\"\n\n    label = options[:no_label] ? \"\" : add_label(options, f, attr)\n\n    if table_field\n      add_help_to_label(size_class, label, help_inline) do\n        yield\n      end.html_safe\n    else\n      help_block = content_tag(:span, options.delete(:help_block), :class => \"help-block\")\n\n      content_tag(:div, :class => \"clearfix\") do\n        content_tag(:div, :class => \"#{wrapper_class} #{error.empty? ? '' : 'has-error'}\",\n                    :id => options.delete(:control_group_id)) do\n          input = capture do\n            if options[:fullscreen]\n              content_tag(:div, yield.html_safe + fullscreen_input, :class => \"input-group\")\n            else\n              yield.html_safe\n            end\n          end\n          add_help_to_label(size_class, label, help_inline) do\n            input + help_block.html_safe\n          end\n        end.html_safe\n      end\n    end\n  end\nend\n"], "filenames": ["app/helpers/form_helper.rb"], "buggy_code_start_loc": [286], "buggy_code_end_loc": [287], "fixing_code_start_loc": [286], "fixing_code_end_loc": [287], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in app/helpers/form_helper.rb in Foreman before 1.12.2, as used by Remote Execution and possibly other plugins, allows remote attackers to inject arbitrary web script or HTML via the label parameter.", "other": {"cve": {"id": "CVE-2016-6319", "sourceIdentifier": "secalert@redhat.com", "published": "2016-08-19T21:59:14.277", "lastModified": "2023-02-13T04:50:11.787", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in app/helpers/form_helper.rb in Foreman before 1.12.2, as used by Remote Execution and possibly other plugins, allows remote attackers to inject arbitrary web script or HTML via the label parameter."}, {"lang": "es", "value": "Vulnerabilidad de XSS en app/helpers/form_helper.rb en Foreman en versiones anteriores a 1.12.2, como se utiliza en Remote Execution y posiblemente otros plugins, permite a atacantes remotos inyectar secuencias de comandos web o HTML arbitrarios a trav\u00e9s del par\u00e1metro de etiqueta."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:theforeman:foreman:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.12.1", "matchCriteriaId": "A05803BC-E1D8-4EC0-8054-AA76B42D2D2B"}]}]}], "references": [{"url": "http://projects.theforeman.org/issues/16019", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "http://projects.theforeman.org/issues/16024", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/92429", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:0336", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1365815", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/theforeman/foreman/commit/0f35fe14acf0d0d3b55e9337bc5e2b9640ff2372", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://theforeman.org/security.html#2016-6319", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/theforeman/foreman/commit/0f35fe14acf0d0d3b55e9337bc5e2b9640ff2372"}}