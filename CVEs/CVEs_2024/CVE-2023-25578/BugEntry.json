{"buggy_code": ["from datetime import date, datetime, time, timedelta\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Dict, List, Optional, Type, Union, cast\n\nfrom pydantic_openapi_schema import construct_open_api_with_schema_class\nfrom typing_extensions import TypedDict\n\nfrom starlite.asgi import ASGIRouter\nfrom starlite.asgi.utils import get_route_handlers, wrap_in_exception_handler\nfrom starlite.config import AllowedHostsConfig, AppConfig, CacheConfig, OpenAPIConfig\nfrom starlite.config.logging import LoggingConfig, get_logger_placeholder\nfrom starlite.connection import Request, WebSocket\nfrom starlite.datastructures.state import State\nfrom starlite.exceptions import (\n    ImproperlyConfiguredException,\n    NoRouteMatchFoundException,\n)\nfrom starlite.handlers.http import HTTPRouteHandler\nfrom starlite.middleware.cors import CORSMiddleware\nfrom starlite.openapi.path_item import create_path_item\nfrom starlite.router import Router\nfrom starlite.routes import ASGIRoute, HTTPRoute, WebSocketRoute\nfrom starlite.signature import create_signature_model\nfrom starlite.types import Empty\nfrom starlite.types.internal_types import PathParameterDefinition\nfrom starlite.utils import (\n    as_async_callable_list,\n    async_partial,\n    is_async_callable,\n    join_paths,\n    unique,\n)\n\nif TYPE_CHECKING:\n    from pydantic_openapi_schema.v3_1_0 import SecurityRequirement\n    from pydantic_openapi_schema.v3_1_0.open_api import OpenAPI\n\n    from starlite.config import (\n        BaseLoggingConfig,\n        CompressionConfig,\n        CORSConfig,\n        CSRFConfig,\n        StaticFilesConfig,\n        TemplateConfig,\n    )\n    from starlite.datastructures import CacheControlHeader, ETag, Provide\n    from starlite.handlers.base import BaseRouteHandler\n    from starlite.plugins.base import PluginProtocol\n    from starlite.types import (\n        AfterExceptionHookHandler,\n        AfterRequestHookHandler,\n        AfterResponseHookHandler,\n        ASGIApp,\n        BeforeMessageSendHookHandler,\n        BeforeRequestHookHandler,\n        ControllerRouterHandler,\n        EmptyType,\n        ExceptionHandlersMap,\n        Guard,\n        LifeSpanHandler,\n        LifeSpanHookHandler,\n        LifeSpanReceive,\n        LifeSpanScope,\n        LifeSpanSend,\n        Logger,\n        Message,\n        Middleware,\n        OnAppInitHandler,\n        ParametersMap,\n        Receive,\n        ResponseCookies,\n        ResponseHeadersMap,\n        ResponseType,\n        RouteHandlerType,\n        Scope,\n        Send,\n        SingleOrList,\n        TypeEncodersMap,\n    )\n    from starlite.types.callable_types import AnyCallable, GetLogger\n    from starlite.types.composite_types import InitialStateType\n\nDEFAULT_OPENAPI_CONFIG = OpenAPIConfig(title=\"Starlite API\", version=\"1.0.0\")\n\"\"\"The default OpenAPI config used if not configuration is explicitly passed to the :class:`Starlite\n<starlite.app.Starlite>` instance constructor.\n\"\"\"\nDEFAULT_CACHE_CONFIG = CacheConfig()\n\"\"\"The default cache config used if not configuration is explicitly passed to the :class:`Starlite\n<starlite.app.Starlite>` instance constructor.\n\"\"\"\n\n\nclass HandlerIndex(TypedDict):\n    \"\"\"Map route handler names to a mapping of paths + route handler.\n\n    It's returned from the 'get_handler_index_by_name' utility method.\n    \"\"\"\n\n    paths: List[str]\n    \"\"\"Full route paths to the route handler.\"\"\"\n    handler: \"RouteHandlerType\"\n    \"\"\"Route handler instance.\"\"\"\n    identifier: str\n    \"\"\"Unique identifier of the handler.\n\n    Either equal to the 'name' attribute or the ``__str__`` value of the handler.\n    \"\"\"\n\n\nclass Starlite(Router):\n    \"\"\"The Starlite application.\n\n    ``Starlite`` is the root level of the app - it has the base path of \"/\" and all root level\n    Controllers, Routers and Route Handlers should be registered on it.\n\n    Inherits from the :class:`Router <starlite.router.Router>` class\n    \"\"\"\n\n    __slots__ = (\n        \"after_exception\",\n        \"after_shutdown\",\n        \"after_startup\",\n        \"allowed_hosts\",\n        \"asgi_handler\",\n        \"asgi_router\",\n        \"before_send\",\n        \"before_shutdown\",\n        \"before_startup\",\n        \"cache\",\n        \"compression_config\",\n        \"cors_config\",\n        \"csrf_config\",\n        \"debug\",\n        \"get_logger\",\n        \"logger\",\n        \"logging_config\",\n        \"on_shutdown\",\n        \"on_startup\",\n        \"openapi_config\",\n        \"openapi_schema\",\n        \"plugins\",\n        \"request_class\",\n        \"route_map\",\n        \"state\",\n        \"static_files_config\",\n        \"template_engine\",\n        \"websocket_class\",\n    )\n\n    def __init__(\n        self,\n        route_handlers: List[\"ControllerRouterHandler\"],\n        *,\n        after_exception: Optional[\"SingleOrList[AfterExceptionHookHandler]\"] = None,\n        after_request: Optional[\"AfterRequestHookHandler\"] = None,\n        after_response: Optional[\"AfterResponseHookHandler\"] = None,\n        after_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n        after_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n        allowed_hosts: Optional[Union[List[str], \"AllowedHostsConfig\"]] = None,\n        before_request: Optional[\"BeforeRequestHookHandler\"] = None,\n        before_send: Optional[\"SingleOrList[BeforeMessageSendHookHandler]\"] = None,\n        before_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n        before_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n        cache_config: CacheConfig = DEFAULT_CACHE_CONFIG,\n        cache_control: Optional[\"CacheControlHeader\"] = None,\n        compression_config: Optional[\"CompressionConfig\"] = None,\n        cors_config: Optional[\"CORSConfig\"] = None,\n        csrf_config: Optional[\"CSRFConfig\"] = None,\n        debug: bool = False,\n        dependencies: Optional[Dict[str, \"Provide\"]] = None,\n        etag: Optional[\"ETag\"] = None,\n        exception_handlers: Optional[\"ExceptionHandlersMap\"] = None,\n        guards: Optional[List[\"Guard\"]] = None,\n        initial_state: Optional[\"InitialStateType\"] = None,\n        logging_config: Union[\"BaseLoggingConfig\", \"EmptyType\", None] = Empty,\n        middleware: Optional[List[\"Middleware\"]] = None,\n        on_app_init: Optional[List[\"OnAppInitHandler\"]] = None,\n        on_shutdown: Optional[List[\"LifeSpanHandler\"]] = None,\n        on_startup: Optional[List[\"LifeSpanHandler\"]] = None,\n        openapi_config: Optional[OpenAPIConfig] = DEFAULT_OPENAPI_CONFIG,\n        opt: Optional[Dict[str, Any]] = None,\n        parameters: Optional[\"ParametersMap\"] = None,\n        plugins: Optional[List[\"PluginProtocol\"]] = None,\n        request_class: Optional[Type[\"Request\"]] = None,\n        response_class: Optional[\"ResponseType\"] = None,\n        response_cookies: Optional[\"ResponseCookies\"] = None,\n        response_headers: Optional[\"ResponseHeadersMap\"] = None,\n        security: Optional[List[\"SecurityRequirement\"]] = None,\n        static_files_config: Optional[Union[\"StaticFilesConfig\", List[\"StaticFilesConfig\"]]] = None,\n        tags: Optional[List[str]] = None,\n        template_config: Optional[\"TemplateConfig\"] = None,\n        type_encoders: Optional[\"TypeEncodersMap\"] = None,\n        websocket_class: Optional[Type[\"WebSocket\"]] = None,\n    ) -> None:\n        \"\"\"Initialize a ``Starlite`` application.\n\n        Args:\n            after_exception: An application level :class:`exception hook handler <starlite.types.AfterExceptionHookHandler>`\n                or list thereof.This hook is called after an exception occurs. In difference to exception handlers,\n                it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.).\n            after_request: A sync or async function executed after the route handler function returned and the response\n                object has been resolved. Receives the response object.\n            after_response: A sync or async function called after the response has been awaited. It receives the\n                :class:`Request <starlite.connection.Request>` object and should not return any values.\n            after_shutdown: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or\n                list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown'\n                list have been called.\n            after_startup: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or\n                list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup'\n                list have been called.\n            allowed_hosts: A list of allowed hosts - enables the builtin allowed hosts middleware.\n            before_request: A sync or async function called immediately before calling the route handler.\n                Receives the :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is\n                used for the response, bypassing the route handler.\n            before_send: An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or\n                list thereof. This hook is called when the ASGI send function is called.\n            before_shutdown: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or\n                list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown'\n                list have been called.\n            before_startup: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or\n                list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup'\n                list have been called.\n            cache_config: Configures caching behavior of the application.\n            cache_control: A ``cache-control`` header of type\n                :class:`CacheControlHeader <starlite.datastructures.CacheControlHeader>` to add to route handlers of this app.\n                Can be overridden by route handlers.\n            compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n                defined Compression middleware.\n            cors_config: If set this enables the builtin CORS middleware.\n            csrf_config: If set this enables the builtin CSRF middleware.\n            debug: If ``True``, app errors rendered as HTML with a stack trace.\n            dependencies: A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.\n            etag: An ``etag`` header of type :class:`ETag <datastructures.ETag>` to add to route handlers of this app.\n                Can be overridden by route handlers.\n            exception_handlers: A dictionary that maps handler functions to status codes and/or exception types.\n            guards: A list of :class:`Guard <starlite.types.Guard>` callables.\n            initial_state: An object from which to initialize the app state.\n            logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`.\n            middleware: A list of :class:`Middleware <starlite.types.Middleware>`.\n            on_app_init: A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive\n                an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with\n                the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more\n                than one handler is registered they are called in the order they are provided.\n            on_shutdown: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during\n                application shutdown.\n            on_startup: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during\n                application startup.\n            openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`\n            opt: A string keyed dictionary of arbitrary values that can be accessed in :class:`Guards <starlite.types.Guard>` or wherever you\n                have access to :class:`Request <starlite.connection.request.Request>` or :class:`ASGI Scope <starlite.types.Scope>`.\n            parameters: A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all\n                application paths.\n            plugins: List of plugins.\n            request_class: An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for\n                http connections.\n            response_class: A custom subclass of [starlite.response.Response] to be used as the app's default response.\n            response_cookies: A list of [Cookie](starlite.datastructures.Cookie] instances.\n            response_headers: A string keyed dictionary mapping :class:`ResponseHeader <starlite.datastructures.ResponseHeader>`\n                instances.\n            route_handlers: A required list of route handlers, which can include instances of\n                :class:`Router <starlite.router.Router>`, subclasses of :class:`Controller <starlite.controller.Controller>` or\n                any function decorated by the route handler decorators.\n            security: A list of dictionaries that will be added to the schema of all route handlers in the application.\n                See :class:`SecurityRequirement <pydantic_openapi_schema.v3_1_0.security_requirement.SecurityRequirement>` for details.\n            static_files_config: An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`\n            tags: A list of string tags that will be appended to the schema of all route handlers under the application.\n            template_config: An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`\n            type_encoders: A mapping of types to callables that transform them into types supported for serialization.\n            websocket_class: An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for\n                websocket connections.\n        \"\"\"\n        self.openapi_schema: Optional[\"OpenAPI\"] = None\n        self.get_logger: \"GetLogger\" = get_logger_placeholder\n        self.logger: Optional[\"Logger\"] = None\n        self.routes: List[Union[\"HTTPRoute\", \"ASGIRoute\", \"WebSocketRoute\"]] = []\n        self.asgi_router = ASGIRouter(app=self)\n\n        config = AppConfig(\n            after_exception=after_exception or [],\n            after_request=after_request,\n            after_response=after_response,\n            after_shutdown=after_shutdown or [],\n            after_startup=after_startup or [],\n            allowed_hosts=allowed_hosts or [],\n            before_request=before_request,\n            before_send=before_send or [],\n            before_shutdown=before_shutdown or [],\n            before_startup=before_startup or [],\n            cache_config=cache_config,\n            cache_control=cache_control,\n            compression_config=compression_config,\n            cors_config=cors_config,\n            csrf_config=csrf_config,\n            debug=debug,\n            dependencies=dependencies or {},\n            etag=etag,\n            exception_handlers=exception_handlers or {},\n            guards=guards or [],\n            initial_state=initial_state or {},\n            logging_config=logging_config if logging_config is not Empty else LoggingConfig() if debug else None,  # type: ignore[arg-type]\n            middleware=middleware or [],\n            on_shutdown=on_shutdown or [],\n            on_startup=on_startup or [],\n            openapi_config=openapi_config,\n            opt=opt or {},\n            parameters=parameters or {},\n            plugins=plugins or [],\n            request_class=request_class,\n            response_class=response_class,\n            response_cookies=response_cookies or [],\n            response_headers=response_headers or {},\n            route_handlers=route_handlers,\n            security=security or [],\n            static_files_config=static_files_config or [],\n            tags=tags or [],\n            template_config=template_config,\n            type_encoders=type_encoders,\n            websocket_class=websocket_class,\n        )\n        for handler in on_app_init or []:\n            config = handler(config)\n\n        self.allowed_hosts = cast(\"Optional[AllowedHostsConfig]\", config.allowed_hosts)\n        self.after_exception = as_async_callable_list(config.after_exception)\n        self.after_shutdown = as_async_callable_list(config.after_shutdown)\n        self.after_startup = as_async_callable_list(config.after_startup)\n        self.before_send = as_async_callable_list(config.before_send)\n        self.before_shutdown = as_async_callable_list(config.before_shutdown)\n        self.before_startup = as_async_callable_list(config.before_startup)\n        self.cache = config.cache_config.to_cache()\n        self.compression_config = config.compression_config\n        self.cors_config = config.cors_config\n        self.csrf_config = config.csrf_config\n        self.debug = config.debug\n        self.logging_config = config.logging_config\n        self.on_shutdown = config.on_shutdown\n        self.on_startup = config.on_startup\n        self.openapi_config = config.openapi_config\n        self.plugins = config.plugins\n        self.request_class = config.request_class or Request\n        self.state = State(config.initial_state, deep_copy=True)\n        self.static_files_config = config.static_files_config\n        self.template_engine = config.template_config.engine_instance if config.template_config else None\n        self.websocket_class = config.websocket_class or WebSocket\n\n        super().__init__(\n            after_request=config.after_request,\n            after_response=config.after_response,\n            before_request=config.before_request,\n            cache_control=config.cache_control,\n            dependencies=config.dependencies,\n            etag=config.etag,\n            exception_handlers=config.exception_handlers,\n            guards=config.guards,\n            middleware=config.middleware,\n            opt=config.opt,\n            parameters=config.parameters,\n            path=\"\",\n            response_class=config.response_class,\n            response_cookies=config.response_cookies,\n            response_headers=config.response_headers,\n            # route handlers are registered below\n            route_handlers=[],\n            security=config.security,\n            tags=config.tags,\n            type_encoders=config.type_encoders,\n        )\n        for plugin in self.plugins:\n            plugin.on_app_init(app=self)\n\n        for route_handler in config.route_handlers:\n            self.register(route_handler)\n\n        if self.debug and isinstance(self.logging_config, LoggingConfig):\n            self.logging_config.loggers[\"starlite\"][\"level\"] = \"DEBUG\"\n\n        if self.logging_config:\n            self.get_logger = self.logging_config.configure()\n            self.logger = self.get_logger(\"starlite\")\n\n        if self.openapi_config:\n            self.openapi_schema = self.openapi_config.to_openapi_schema()\n            self.update_openapi_schema()\n            self.register(self.openapi_config.openapi_controller)\n\n        for static_config in (\n            self.static_files_config if isinstance(self.static_files_config, list) else [self.static_files_config]\n        ):\n            self.register(static_config.to_static_files_app())\n\n        self.asgi_handler = self._create_asgi_handler()\n\n    async def __call__(\n        self,\n        scope: Union[\"Scope\", \"LifeSpanScope\"],\n        receive: Union[\"Receive\", \"LifeSpanReceive\"],\n        send: Union[\"Send\", \"LifeSpanSend\"],\n    ) -> None:\n        \"\"\"Application entry point.\n\n        Lifespan events (startup / shutdown) are sent to the lifespan handler, otherwise the ASGI handler is used\n\n        Args:\n            scope: The ASGI connection scope.\n            receive: The ASGI receive function.\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\n        scope[\"app\"] = self\n        if scope[\"type\"] == \"lifespan\":\n            await self.asgi_router.lifespan(receive=receive, send=send)  # type: ignore[arg-type]\n            return\n        scope[\"state\"] = {}\n        await self.asgi_handler(scope, receive, self._wrap_send(send=send, scope=scope))  # type: ignore[arg-type]\n\n    def register(self, value: \"ControllerRouterHandler\", add_to_openapi_schema: bool = False) -> None:  # type: ignore[override]\n        \"\"\"Register a route handler on the app.\n\n        This method can be used to dynamically add endpoints to an application.\n\n        Args:\n            value: an instance of :class:`Router <starlite.router.Router>`, a subclass of\n                :class:`Controller <starlite.controller.Controller>` or any function decorated by the route handler decorators.\n            add_to_openapi_schema: Whether to add the registered route to the OpenAPI Schema. This affects only HTTP route\n                handlers.\n\n        Returns:\n            None\n        \"\"\"\n        routes = super().register(value=value)\n\n        should_add_to_openapi_schema = False\n\n        for route in routes:\n            route_handlers = get_route_handlers(route)\n\n            for route_handler in route_handlers:\n                self._create_handler_signature_model(route_handler=route_handler)\n                self._set_runtime_callables(route_handler=route_handler)\n                route_handler.resolve_guards()\n                route_handler.resolve_middleware()\n                route_handler.resolve_opts()\n\n                if isinstance(route_handler, HTTPRouteHandler):\n                    route_handler.resolve_before_request()\n                    route_handler.resolve_after_response()\n                    route_handler.resolve_response_handler()\n                    should_add_to_openapi_schema = add_to_openapi_schema\n\n            if isinstance(route, HTTPRoute):\n                route.create_handler_map()\n\n            elif isinstance(route, WebSocketRoute):\n                route.handler_parameter_model = route.create_handler_kwargs_model(route.route_handler)\n\n        self.asgi_router.construct_routing_trie()\n\n        if should_add_to_openapi_schema:\n            self.update_openapi_schema()\n\n    def get_handler_index_by_name(self, name: str) -> Optional[HandlerIndex]:\n        \"\"\"Receives a route handler name and returns an optional dictionary containing the route handler instance and\n        list of paths sorted lexically.\n\n        Examples:\n            .. code-block: python\n\n                from starlite import Starlite, get\n\n\n                @get(\"/\", name=\"my-handler\")\n                def handler() -> None:\n                    pass\n\n\n                app = Starlite(route_handlers=[handler])\n\n                handler_index = app.get_handler_index_by_name(\"my-handler\")\n\n                # { \"paths\": [\"/\"], \"handler\" ... }\n\n        Args:\n            name: A route handler unique name.\n\n        Returns:\n            A :class:`HandlerIndex <starlite.app.HandlerIndex>` instance or None.\n        \"\"\"\n        handler = self.asgi_router.route_handler_index.get(name)\n        if not handler:\n            return None\n\n        identifier = handler.name or str(handler)\n        routes = self.asgi_router.route_mapping[identifier]\n        paths = sorted(unique([route.path for route in routes]))\n\n        return HandlerIndex(handler=handler, paths=paths, identifier=identifier)\n\n    def route_reverse(self, name: str, **path_parameters: Any) -> str:\n        \"\"\"Receives a route handler name, path parameter values and returns url path to the handler with filled path\n        parameters.\n\n        Examples:\n            .. code-block: python\n\n                from starlite import Starlite, get\n\n\n                @get(\"/group/{group_id:int}/user/{user_id:int}\", name=\"get_membership_details\")\n                def get_membership_details(group_id: int, user_id: int) -> None:\n                    pass\n\n\n                app = Starlite(route_handlers=[get_membership_details])\n\n                path = app.route_reverse(\"get_membership_details\", user_id=100, group_id=10)\n\n                # /group/10/user/100\n\n        Args:\n            name: A route handler unique name.\n            **path_parameters: Actual values for path parameters in the route.\n\n        Raises:\n            NoRouteMatchFoundException: If route with 'name' does not exist, path parameters are missing in\n                ``**path_parameters or have wrong type``.\n\n        Returns:\n            A fully formatted url path.\n        \"\"\"\n        handler_index = self.get_handler_index_by_name(name)\n        if handler_index is None:\n            raise NoRouteMatchFoundException(f\"Route {name} can not be found\")\n\n        allow_str_instead = {datetime, date, time, timedelta, float, Path}\n        output: List[str] = []\n\n        routes = sorted(\n            self.asgi_router.route_mapping[handler_index[\"identifier\"]],\n            key=lambda r: len(r.path_parameters),\n            reverse=True,\n        )\n        passed_parameters = set(path_parameters.keys())\n\n        selected_route = routes[-1]\n        for route in routes:\n            if passed_parameters.issuperset({param.name for param in route.path_parameters}):\n                selected_route = route\n                break\n\n        for component in selected_route.path_components:\n            if isinstance(component, PathParameterDefinition):\n                val = path_parameters.get(component.name)\n                if not (\n                    isinstance(val, component.type) or (component.type in allow_str_instead and isinstance(val, str))\n                ):\n                    raise NoRouteMatchFoundException(\n                        f\"Received type for path parameter {component.name} doesn't match declared type {component.type}\"\n                    )\n                output.append(str(val))\n            else:\n                output.append(component)\n\n        return join_paths(output)\n\n    def url_for_static_asset(self, name: str, file_path: str) -> str:\n        \"\"\"Receives a static files handler name, an asset file path and returns resolved url path to the asset.\n\n        Examples:\n            .. code-block: python\n\n                from starlite import Starlite, StaticFilesConfig\n\n                app = Starlite(\n                    static_files_config=StaticFilesConfig(directories=[\"css\"], path=\"/static/css\")\n                )\n\n                path = app.url_for_static_asset(\"css\", \"main.css\")\n\n                # /static/css/main.css\n\n        Args:\n            name: A static handler unique name.\n            file_path: a string containing path to an asset.\n\n        Raises:\n            NoRouteMatchFoundException: If static files handler with 'name' does not exist.\n\n        Returns:\n            A url path to the asset.\n        \"\"\"\n        from starlite.static_files.base import StaticFiles\n\n        handler_index = self.get_handler_index_by_name(name)\n        if handler_index is None:\n            raise NoRouteMatchFoundException(f\"Static handler {name} can not be found\")\n\n        handler_fn = cast(\"AnyCallable\", handler_index[\"handler\"].fn.value)\n        if not isinstance(handler_fn, StaticFiles):\n            raise NoRouteMatchFoundException(f\"Handler with name {name} is not a static files handler\")\n\n        return join_paths([handler_index[\"paths\"][0], file_path])  # type: ignore[unreachable]\n\n    @property\n    def route_handler_method_view(self) -> Dict[str, List[str]]:\n        \"\"\"Map route handlers to paths.\n\n        Returns:\n            A dictionary of router handlers and lists of paths as strings\n        \"\"\"\n        route_map: Dict[str, List[str]] = {}\n        for handler, routes in self.asgi_router.route_mapping.items():\n            route_map[handler] = [route.path for route in routes]\n\n        return route_map\n\n    def _create_asgi_handler(self) -> \"ASGIApp\":\n        \"\"\"Create an ASGIApp that wraps the ASGI router inside an exception handler.\n\n        If CORS or TrustedHost configs are provided to the constructor, they will wrap the router as well.\n        \"\"\"\n        asgi_handler: \"ASGIApp\" = self.asgi_router\n        if self.cors_config:\n            asgi_handler = CORSMiddleware(app=asgi_handler, config=self.cors_config)\n\n        return wrap_in_exception_handler(\n            debug=self.debug, app=asgi_handler, exception_handlers=self.exception_handlers or {}\n        )\n\n    @staticmethod\n    def _set_runtime_callables(route_handler: \"BaseRouteHandler\") -> None:\n        \"\"\"Optimize the route_handler.fn and any provider.dependency callables for runtime by doing the following:\n\n        1. ensure that the ``self`` argument is preserved by binding it using partial.\n        2. ensure sync functions are wrapped in AsyncCallable for sync_to_thread handlers.\n\n        Args:\n            route_handler: A route handler to process.\n\n        Returns:\n            None\n        \"\"\"\n        from starlite.controller import Controller\n\n        if isinstance(route_handler.owner, Controller) and not hasattr(route_handler.fn.value, \"func\"):\n            route_handler.fn.value = partial(route_handler.fn.value, route_handler.owner)\n\n        if isinstance(route_handler, HTTPRouteHandler):\n            route_handler.has_sync_callable = False\n            if not is_async_callable(route_handler.fn.value):\n                if route_handler.sync_to_thread:\n                    route_handler.fn.value = async_partial(route_handler.fn.value)\n                else:\n                    route_handler.has_sync_callable = True\n\n        for provider in route_handler.resolve_dependencies().values():\n            if not is_async_callable(provider.dependency.value):\n                provider.has_sync_callable = False\n                if provider.sync_to_thread:\n                    provider.dependency.value = async_partial(provider.dependency.value)\n                else:\n                    provider.has_sync_callable = True\n\n    def _create_handler_signature_model(self, route_handler: \"BaseRouteHandler\") -> None:\n        \"\"\"Create function signature models for all route handler functions and provider dependencies.\"\"\"\n        if not route_handler.signature_model:\n            route_handler.signature_model = create_signature_model(\n                fn=cast(\"AnyCallable\", route_handler.fn.value),\n                plugins=self.plugins,\n                dependency_name_set=route_handler.dependency_name_set,\n            )\n\n        for provider in route_handler.resolve_dependencies().values():\n            if not getattr(provider, \"signature_model\", None):\n                provider.signature_model = create_signature_model(\n                    fn=provider.dependency.value,\n                    plugins=self.plugins,\n                    dependency_name_set=route_handler.dependency_name_set,\n                )\n\n    def _wrap_send(self, send: \"Send\", scope: \"Scope\") -> \"Send\":\n        \"\"\"Wrap the ASGI send and handles any 'before send' hooks.\n\n        Args:\n            send: The ASGI send function.\n\n        Returns:\n            An ASGI send function.\n        \"\"\"\n        if self.before_send:\n\n            async def wrapped_send(message: \"Message\") -> None:\n                for hook in self.before_send:\n                    if hook.num_expected_args > 2:\n                        await hook(message, self.state, scope)\n                    else:\n                        await hook(message, self.state)\n                await send(message)\n\n            return wrapped_send\n        return send\n\n    def update_openapi_schema(self) -> None:\n        \"\"\"Update the OpenAPI schema to reflect the route handlers registered on the app.\n\n        Returns:\n            None\n        \"\"\"\n        if not self.openapi_config or not self.openapi_schema or self.openapi_schema.paths is None:\n            raise ImproperlyConfiguredException(\"Cannot generate OpenAPI schema without initializing an OpenAPIConfig\")\n\n        for route in self.routes:\n            if (\n                isinstance(route, HTTPRoute)\n                and any(route_handler.include_in_schema for route_handler, _ in route.route_handler_map.values())\n                and (route.path_format or \"/\") not in self.openapi_schema.paths\n            ):\n                self.openapi_schema.paths[route.path_format or \"/\"] = create_path_item(\n                    route=route,\n                    create_examples=self.openapi_config.create_examples,\n                    plugins=self.plugins,\n                    use_handler_docstrings=self.openapi_config.use_handler_docstrings,\n                )\n        self.openapi_schema = construct_open_api_with_schema_class(\n            open_api_schema=self.openapi_schema, by_alias=self.openapi_config.by_alias\n        )\n", "from typing import Any, Dict, List, Optional, Type, Union\n\nfrom pydantic import BaseConfig, BaseModel, validator\nfrom pydantic_openapi_schema.v3_1_0 import SecurityRequirement\n\nfrom starlite.connection import Request, WebSocket\nfrom starlite.datastructures import CacheControlHeader, ETag, Provide\nfrom starlite.plugins.base import PluginProtocol\nfrom starlite.types import (\n    AfterExceptionHookHandler,\n    AfterRequestHookHandler,\n    AfterResponseHookHandler,\n    BeforeMessageSendHookHandler,\n    BeforeRequestHookHandler,\n    ControllerRouterHandler,\n    ExceptionHandlersMap,\n    Guard,\n    LifeSpanHandler,\n    LifeSpanHookHandler,\n    Middleware,\n    ParametersMap,\n    ResponseCookies,\n    ResponseHeadersMap,\n    ResponseType,\n    SingleOrList,\n    TypeEncodersMap,\n)\nfrom starlite.types.composite_types import InitialStateType\n\nfrom . import AllowedHostsConfig\nfrom .cache import CacheConfig\nfrom .compression import CompressionConfig\nfrom .cors import CORSConfig\nfrom .csrf import CSRFConfig\nfrom .logging import BaseLoggingConfig\nfrom .openapi import OpenAPIConfig\nfrom .static_files import StaticFilesConfig\nfrom .template import TemplateConfig\n\n\nclass AppConfig(BaseModel):\n    \"\"\"The parameters provided to the ``Starlite`` app are used to instantiate an instance, and then the instance is\n    passed to any callbacks registered to ``on_app_init`` in the order they are provided.\n\n    The final attribute values are used to instantiate the application object.\n    \"\"\"\n\n    class Config(BaseConfig):\n        arbitrary_types_allowed = True\n\n    after_exception: SingleOrList[AfterExceptionHookHandler]\n    \"\"\"An application level :class:`exception hook handler <starlite.types.AfterExceptionHookHandler>` or list thereof.\n\n    This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a\n    response - only to process the exception (e.g. log it, send it to Sentry etc.).\n    \"\"\"\n    after_request: Optional[AfterRequestHookHandler]\n    \"\"\"A sync or async function executed after the route handler function returned and the response object has been\n    resolved.\n\n    Receives the response object which may be any subclass of :class:`Response <starlite.response.Response>`.\n    \"\"\"\n    after_response: Optional[AfterResponseHookHandler]\n    \"\"\"A sync or async function called after the response has been awaited. It receives the.\n\n    :class:`Request <starlite.connection.Request>` object and should not return any values.\n    \"\"\"\n    after_shutdown: SingleOrList[LifeSpanHookHandler]\n    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.\n\n    This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called.\n    \"\"\"\n    after_startup: SingleOrList[LifeSpanHookHandler]\n    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.\n\n    This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called.\n    \"\"\"\n    allowed_hosts: Optional[Union[List[str], AllowedHostsConfig]]\n    \"\"\"If set enables the builtin allowed hosts middleware.\"\"\"\n    before_request: Optional[BeforeRequestHookHandler]\n    \"\"\"A sync or async function called immediately before calling the route handler. Receives the.\n\n    :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is used for the response, bypassing\n    the route handler.\n    \"\"\"\n    before_send: SingleOrList[BeforeMessageSendHookHandler]\n    \"\"\"An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or list thereof.\n\n    This hook is called when the ASGI send function is called.\n    \"\"\"\n    before_shutdown: SingleOrList[LifeSpanHookHandler]\n    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.\n\n    This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called.\n    \"\"\"\n    before_startup: SingleOrList[LifeSpanHookHandler]\n    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.\n\n    This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called.\n    \"\"\"\n    cache_config: CacheConfig\n    \"\"\"Configures caching behavior of the application.\"\"\"\n    cache_control: Optional[CacheControlHeader]\n    \"\"\"A ``cache-control`` header of type :class:`CacheControlHeader <starlite.datastructures.CacheControlHeader>` to add to route\n    handlers of this app.\n\n    Can be overridden by route handlers.\n    \"\"\"\n    compression_config: Optional[CompressionConfig]\n    \"\"\"Configures compression behaviour of the application, this enabled a builtin or user defined Compression\n    middleware.\n    \"\"\"\n    cors_config: Optional[CORSConfig]\n    \"\"\"If set this enables the builtin CORS middleware.\"\"\"\n    csrf_config: Optional[CSRFConfig]\n    \"\"\"If set this enables the builtin CSRF middleware.\"\"\"\n    debug: bool\n    \"\"\"If ``True``, app errors rendered as HTML with a stack trace.\"\"\"\n    dependencies: Dict[str, Provide]\n    \"\"\"A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.\"\"\"\n    etag: Optional[ETag]\n    \"\"\"An ``etag`` header of type :class:`ETag <starlite.datastructures.ETag>` to add to route handlers of this app.\n\n    Can be overridden by route handlers.\n    \"\"\"\n    exception_handlers: ExceptionHandlersMap\n    \"\"\"A dictionary that maps handler functions to status codes and/or exception types.\"\"\"\n    guards: List[Guard]\n    \"\"\"A list of :class:`Guard <starlite.types.Guard>` callables.\"\"\"\n    initial_state: InitialStateType\n    \"\"\"An object from which to initialize the app state.\"\"\"\n    logging_config: Optional[BaseLoggingConfig]\n    \"\"\"An instance of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>` subclass.\"\"\"\n    middleware: List[Middleware]\n    \"\"\"A list of :class:`Middleware <starlite.types.Middleware>`.\"\"\"\n    on_shutdown: List[LifeSpanHandler]\n    \"\"\"A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during application shutdown.\"\"\"\n    on_startup: List[LifeSpanHandler]\n    \"\"\"A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during application startup.\"\"\"\n    openapi_config: Optional[OpenAPIConfig]\n    \"\"\"Defaults to :data:`DEFAULT_OPENAPI_CONFIG <starlite.app.DEFAULT_OPENAPI_CONFIG>`\"\"\"\n    opt: Dict[str, Any]\n    \"\"\"A string keyed dictionary of arbitrary values that can be accessed in :class:`Guards <starlite.types.Guard>` or\n    wherever you have access to :class:`Request <starlite.connection.request.Request>` or :class:`ASGI Scope <starlite.types.Scope>`.\n\n    Can be overridden by routers and router handlers.\n    \"\"\"\n    parameters: ParametersMap\n    \"\"\"A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all application paths.\"\"\"\n    plugins: List[PluginProtocol]\n    \"\"\"List of :class:`PluginProtocol <starlite.plugins.base.PluginProtocol>`.\"\"\"\n    request_class: Optional[Type[Request]]\n    \"\"\"An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for http connections.\"\"\"\n    response_class: Optional[ResponseType]\n    \"\"\"A custom subclass of [starlite.response.Response] to be used as the app's default response.\"\"\"\n    response_cookies: ResponseCookies\n    \"\"\"A list of [Cookie](starlite.datastructures.Cookie] instances.\"\"\"\n    response_headers: ResponseHeadersMap\n    \"\"\"A string keyed dictionary mapping :class:`ResponseHeader <starlite.datastructures.ResponseHeader>` instances.\"\"\"\n    route_handlers: List[ControllerRouterHandler]\n    \"\"\"A required list of route handlers, which can include instances of :class:`Router <starlite.router.Router>`, subclasses\n    of.\n\n    :class:`Controller <starlite.controller.Controller>` or any function decorated by the route handler decorators.\n    \"\"\"\n    security: List[SecurityRequirement]\n    \"\"\"A list of dictionaries that will be added to the schema of all route handlers in the application. See.\n\n    :class:`SecurityRequirement <pydantic_openapi_schema.v3_1_0.security_requirement.SecurityRequirement>` for details.\n    \"\"\"\n    static_files_config: SingleOrList[StaticFilesConfig]\n    \"\"\"An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`.\"\"\"\n    tags: List[str]\n    \"\"\"A list of string tags that will be appended to the schema of all route handlers under the application.\"\"\"\n    template_config: Optional[TemplateConfig]\n    \"\"\"An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`.\"\"\"\n    type_encoders: Optional[TypeEncodersMap] = None\n    \"\"\"A mapping of types to callables that transform them into types supported for serialization.\"\"\"\n    websocket_class: Optional[Type[WebSocket]]\n    \"\"\"An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for websocket connections.\"\"\"\n\n    @validator(\"allowed_hosts\", always=True)\n    def validate_allowed_hosts(  # pylint: disable=no-self-argument\n        cls, value: Optional[Union[List[str], AllowedHostsConfig]]\n    ) -> Optional[AllowedHostsConfig]:\n        \"\"\"Normalize the allowed hosts to be a config or None.\n\n        Args:\n            value: Optional a list of hosts or allowed hosts config\n\n        Returns:\n            Optional config.\n        \"\"\"\n        if value:\n            if isinstance(value, list):\n                return AllowedHostsConfig(allowed_hosts=value)\n            return value\n        return None\n", "from typing import TYPE_CHECKING, Any, AsyncGenerator, Dict, Generic, Tuple, cast\n\nfrom starlite.connection.base import (\n    ASGIConnection,\n    Auth,\n    User,\n    empty_receive,\n    empty_send,\n)\nfrom starlite.datastructures.multi_dicts import FormMultiDict\nfrom starlite.enums import RequestEncodingType\nfrom starlite.exceptions import InternalServerException\nfrom starlite.multipart import parse_content_header, parse_multipart_form\nfrom starlite.parsers import parse_url_encoded_form_data\nfrom starlite.types import Empty\nfrom starlite.utils.serialization import decode_json, decode_msgpack\n\nif TYPE_CHECKING:\n    from starlite.handlers.http import HTTPRouteHandler  # noqa: F401\n    from starlite.types.asgi_types import HTTPScope, Method, Receive, Scope, Send\n\n\nSERVER_PUSH_HEADERS = {\n    \"accept\",\n    \"accept-encoding\",\n    \"accept-language\",\n    \"cache-control\",\n    \"user-agent\",\n}\n\n\nclass Request(Generic[User, Auth], ASGIConnection[\"HTTPRouteHandler\", User, Auth]):\n    \"\"\"The Starlite Request class.\"\"\"\n\n    __slots__ = (\"_json\", \"_form\", \"_body\", \"_msgpack\", \"_content_type\", \"is_connected\")\n\n    scope: \"HTTPScope\"\n    \"\"\"The ASGI scope attached to the connection.\"\"\"\n    receive: \"Receive\"\n    \"\"\"The ASGI receive function.\"\"\"\n    send: \"Send\"\n    \"\"\"The ASGI send function.\"\"\"\n\n    def __init__(self, scope: \"Scope\", receive: \"Receive\" = empty_receive, send: \"Send\" = empty_send) -> None:\n        \"\"\"Initialize ``Request``.\n\n        Args:\n            scope: The ASGI connection scope.\n            receive: The ASGI receive function.\n            send: The ASGI send function.\n        \"\"\"\n        super().__init__(scope, receive, send)\n        self.is_connected: bool = True\n        self._body: Any = scope.get(\"_body\", Empty)\n        self._form: Any = scope.get(\"_form\", Empty)\n        self._json: Any = scope.get(\"_json\", Empty)\n        self._msgpack: Any = scope.get(\"_msgpack\", Empty)\n        self._content_type: Any = scope.get(\"_content_type\", Empty)\n\n    @property\n    def method(self) -> \"Method\":\n        \"\"\"Return the request method.\n\n        Returns:\n            The request :class:`Method <starlite.types.Method>`\n        \"\"\"\n        return self.scope[\"method\"]\n\n    @property\n    def content_type(self) -> Tuple[str, Dict[str, str]]:\n        \"\"\"Parse the request's 'Content-Type' header, returning the header value and any options as a dictionary.\n\n        Returns:\n            A tuple with the parsed value and a dictionary containing any options send in it.\n        \"\"\"\n        if self._content_type is Empty:\n            self._content_type = self.scope[\"_content_type\"] = parse_content_header(self.headers.get(\"Content-Type\", \"\"))  # type: ignore[typeddict-item]\n        return cast(\"Tuple[str, Dict[str, str]]\", self._content_type)\n\n    async def json(self) -> Any:\n        \"\"\"Retrieve the json request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\n        if self._json is Empty:\n            body = await self.body()\n            self._json = self.scope[\"_json\"] = decode_json(body or b\"null\")  # type: ignore[typeddict-item]\n        return self._json\n\n    async def msgpack(self) -> Any:\n        \"\"\"Retrieve the MessagePack request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\n        if self._msgpack is Empty:\n            body = await self.body()\n            self._msgpack = self.scope[\"_msgpack\"] = decode_msgpack(body or b\"\\xc0\")  # type: ignore[typeddict-item]\n        return self._msgpack\n\n    async def stream(self) -> AsyncGenerator[bytes, None]:\n        \"\"\"Return an async generator that streams chunks of bytes.\n\n        Returns:\n            An async generator.\n\n        Raises:\n            RuntimeError: if the stream is already consumed\n        \"\"\"\n        if self._body is Empty:\n            if self.is_connected:\n                while event := await self.receive():\n                    if event[\"type\"] == \"http.request\":\n                        if event[\"body\"]:\n                            yield event[\"body\"]\n                        if not event.get(\"more_body\", False):\n                            break\n                    if event[\"type\"] == \"http.disconnect\":\n                        raise InternalServerException(\"client disconnected prematurely\")\n\n                self.is_connected = False\n                yield b\"\"\n            else:\n                raise InternalServerException(\"stream consumed\")\n        else:\n            yield self._body\n            yield b\"\"\n            return\n\n    async def body(self) -> bytes:\n        \"\"\"Return the body of the request.\n\n        Returns:\n            A byte-string representing the body of the request.\n        \"\"\"\n        if self._body is Empty:\n            self._body = self.scope[\"_body\"] = b\"\".join([c async for c in self.stream()])  # type: ignore[typeddict-item]\n        return cast(\"bytes\", self._body)\n\n    async def form(self) -> FormMultiDict:\n        \"\"\"Retrieve form data from the request. If the request is either a 'multipart/form-data' or an\n        'application/x-www-form- urlencoded', return a FormMultiDict instance populated with the values sent in the\n        request, otherwise, an empty instance.\n\n        Returns:\n            A FormMultiDict instance\n        \"\"\"\n        if self._form is Empty:\n            content_type, options = self.content_type\n            if content_type == RequestEncodingType.MULTI_PART:\n                self._form = self.scope[\"_form\"] = form_values = parse_multipart_form(  # type: ignore[typeddict-item]\n                    body=await self.body(), boundary=options.get(\"boundary\", \"\").encode()\n                )\n                return FormMultiDict(form_values)\n            if content_type == RequestEncodingType.URL_ENCODED:\n                self._form = self.scope[\"_form\"] = form_values = parse_url_encoded_form_data(  # type: ignore[typeddict-item]\n                    await self.body(),\n                )\n                return FormMultiDict(form_values)\n            return FormMultiDict()\n        return FormMultiDict(self._form)\n\n    async def send_push_promise(self, path: str) -> None:\n        \"\"\"Send a push promise.\n\n        This method requires the `http.response.push` extension to be sent from the ASGI server.\n\n        Args:\n            path: Path to send the promise to.\n\n        Returns:\n            None\n        \"\"\"\n        extensions: Dict[str, Dict[Any, Any]] = self.scope.get(\"extensions\") or {}\n        if \"http.response.push\" in extensions:\n            raw_headers = []\n            for name in SERVER_PUSH_HEADERS:\n                for value in self.headers.getall(name, []):\n                    raw_headers.append((name.encode(\"latin-1\"), value.encode(\"latin-1\")))\n            await self.send({\"type\": \"http.response.push\", \"path\": path, \"headers\": raw_headers})\n", "from collections import defaultdict\nfrom functools import lru_cache\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Coroutine,\n    DefaultDict,\n    Dict,\n    List,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom starlite.datastructures.upload_file import UploadFile\nfrom starlite.enums import ParamType, RequestEncodingType\nfrom starlite.exceptions import ValidationException\nfrom starlite.multipart import parse_multipart_form\nfrom starlite.parsers import (\n    parse_headers,\n    parse_query_string,\n    parse_url_encoded_form_data,\n)\nfrom starlite.types import Empty\n\nif TYPE_CHECKING:\n    from starlite.connection import ASGIConnection, Request\n    from starlite.kwargs import KwargsModel\n    from starlite.kwargs.parameter_definition import ParameterDefinition\n    from starlite.signature.models import SignatureField\n\n\ndef create_connection_value_extractor(\n    kwargs_model: \"KwargsModel\",\n    connection_key: str,\n    expected_params: Set[\"ParameterDefinition\"],\n    parser: Optional[Callable[[\"ASGIConnection\", \"KwargsModel\"], Dict[str, Any]]] = None,\n) -> Callable[[Dict[str, Any], \"ASGIConnection\"], None]:\n    \"\"\"Create a kwargs extractor function.\n\n    Args:\n        kwargs_model: The KwargsModel instance.\n        connection_key: The attribute key to use.\n        expected_params: The set of expected params.\n        parser: An optional parser function.\n\n    Returns:\n        An extractor function.\n    \"\"\"\n\n    alias_and_key_tuple = tuple(\n        (p.field_alias.lower() if p.param_type == ParamType.HEADER else p.field_alias, p.field_name)\n        for p in expected_params\n    )\n    alias_defaults = {\n        p.field_alias.lower() if p.param_type == ParamType.HEADER else p.field_alias: p.default_value\n        for p in expected_params\n        if not (p.is_required or p.default_value is Ellipsis)\n    }\n\n    def extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n        data = parser(connection, kwargs_model) if parser else getattr(connection, connection_key, {})\n\n        try:\n            connection_mapping: Dict[str, Any] = {\n                key: data[alias] if alias in data else alias_defaults[alias] for alias, key in alias_and_key_tuple\n            }\n            values.update(connection_mapping)\n        except KeyError as e:\n            raise ValidationException(f\"Missing required parameter {e.args[0]} for url {connection.url}\") from e\n\n    return extractor\n\n\n@lru_cache(1024)\ndef create_query_default_dict(\n    parsed_query: Tuple[Tuple[str, str], ...], sequence_query_parameter_names: Tuple[str, ...]\n) -> DefaultDict[str, Union[List[str], str]]:\n    \"\"\"Transform a list of tuples into a default dict. Ensures non-list values are not wrapped in a list.\n\n    Args:\n        parsed_query: The parsed query list of tuples.\n        sequence_query_parameter_names: A set of query parameters that should be wrapped in list.\n\n    Returns:\n        A default dict\n    \"\"\"\n    output: DefaultDict[str, Union[List[str], str]] = defaultdict(list)\n\n    for k, v in parsed_query:\n        if k in sequence_query_parameter_names:\n            output[k].append(v)  # type: ignore\n        else:\n            output[k] = v\n\n    return output\n\n\ndef parse_connection_query_params(connection: \"ASGIConnection\", kwargs_model: \"KwargsModel\") -> Dict[str, Any]:\n    \"\"\"Parse query params and cache the result in scope.\n\n    Args:\n        connection: The ASGI connection instance.\n        kwargs_model: The KwargsModel instance.\n\n    Returns:\n        A dictionary of parsed values.\n    \"\"\"\n    parsed_query = connection.scope[\"_parsed_query\"] = (  # type: ignore\n        connection._parsed_query\n        if connection._parsed_query is not Empty\n        else parse_query_string(connection.scope.get(\"query_string\", b\"\"))\n    )\n    return create_query_default_dict(\n        parsed_query=parsed_query, sequence_query_parameter_names=kwargs_model.sequence_query_parameter_names\n    )\n\n\ndef parse_connection_headers(connection: \"ASGIConnection\", _: \"KwargsModel\") -> Dict[str, Any]:\n    \"\"\"Parse header parameters and cache the result in scope.\n\n    Args:\n        connection: The ASGI connection instance.\n        _: The KwargsModel instance.\n\n    Returns:\n        A dictionary of parsed values\n    \"\"\"\n    parsed_headers = connection.scope[\"_headers\"] = (  # type: ignore\n        connection._headers if connection._headers is not Empty else parse_headers(tuple(connection.scope[\"headers\"]))\n    )\n    return cast(\"Dict[str, Any]\", parsed_headers)\n\n\ndef state_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Extract the app state from the connection and insert it to the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"state\"] = connection.app.state._state\n\n\ndef headers_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Extract the headers from the connection and insert them to the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"headers\"] = connection.headers\n\n\ndef cookies_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Extract the cookies from the connection and insert them to the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"cookies\"] = connection.cookies\n\n\ndef query_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Extract the query params from the connection and insert them to the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"query\"] = connection.query_params\n\n\ndef scope_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Extract the scope from the connection and insert it into the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"scope\"] = connection.scope\n\n\ndef request_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Set the connection instance as the 'request' value in the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"request\"] = connection\n\n\ndef socket_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Set the connection instance as the 'socket' value in the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"socket\"] = connection\n\n\ndef body_extractor(\n    values: Dict[str, Any],\n    connection: \"Request[Any, Any]\",\n) -> None:\n    \"\"\"Extract the body from the request instance.\n\n    Notes:\n        - this extractor sets a Coroutine as the value in the kwargs. These are resolved at a later stage.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        The Body value.\n    \"\"\"\n    values[\"body\"] = connection.body()\n\n\nasync def json_extractor(\n    connection: \"Request[Any, Any]\",\n) -> Any:\n    \"\"\"Extract the data from request and insert it into the kwargs injected to the handler.\n\n    Notes:\n        - this extractor sets a Coroutine as the value in the kwargs. These are resolved at a later stage.\n\n    Args:\n        connection: The ASGI connection instance.\n\n    Returns:\n        The JSON value.\n    \"\"\"\n    return await connection.json()\n\n\nasync def msgpack_extractor(connection: \"Request[Any, Any]\") -> Any:\n    \"\"\"Extract the data from request and insert it into the kwargs injected to the handler.\n\n    Notes:\n        - this extractor sets a Coroutine as the value in the kwargs. These are resolved at a later stage.\n\n    Args:\n        connection: The ASGI connection instance.\n\n    Returns:\n        The MessagePack value.\n    \"\"\"\n    return await connection.msgpack()\n\n\ndef create_multipart_extractor(\n    signature_field: \"SignatureField\", is_data_optional: bool\n) -> Callable[[\"ASGIConnection[Any, Any, Any]\"], Coroutine[Any, Any, Any]]:\n    \"\"\"Create a multipart form-data extractor.\n\n    Args:\n        signature_field: A SignatureField instance.\n        is_data_optional: Boolean dictating whether the field is optional.\n\n    Returns:\n        An extractor function.\n    \"\"\"\n\n    async def extract_multipart(\n        connection: \"Request[Any, Any]\",\n    ) -> Any:\n        connection.scope[\"_form\"] = form_values = (  # type: ignore[typeddict-item]\n            connection.scope[\"_form\"]  # type: ignore[typeddict-item]\n            if \"_form\" in connection.scope\n            else parse_multipart_form(\n                body=await connection.body(), boundary=connection.content_type[-1].get(\"boundary\", \"\").encode()\n            )\n        )\n\n        if signature_field.is_non_string_sequence:\n            return list(form_values.values())\n        if signature_field.is_simple_type and signature_field.field_type is UploadFile and form_values:\n            return [v for v in form_values.values() if isinstance(v, UploadFile)][0]\n\n        return form_values if form_values or not is_data_optional else None\n\n    return cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", extract_multipart)\n\n\ndef create_url_encoded_data_extractor(\n    is_data_optional: bool,\n) -> Callable[[\"ASGIConnection[Any, Any, Any]\"], Coroutine[Any, Any, Any]]:\n    \"\"\"Create extractor for url encoded form-data.\n\n    Args:\n        is_data_optional: Boolean dictating whether the field is optional.\n\n    Returns:\n        An extractor function.\n    \"\"\"\n\n    async def extract_url_encoded_extractor(\n        connection: \"Request[Any, Any]\",\n    ) -> Any:\n        connection.scope[\"_form\"] = form_values = (  # type: ignore[typeddict-item]\n            connection.scope[\"_form\"]  # type: ignore[typeddict-item]\n            if \"_form\" in connection.scope\n            else parse_url_encoded_form_data(await connection.body())\n        )\n        return form_values if form_values or not is_data_optional else None\n\n    return cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", extract_url_encoded_extractor)\n\n\ndef create_data_extractor(kwargs_model: \"KwargsModel\") -> Callable[[Dict[str, Any], \"ASGIConnection\"], None]:\n    \"\"\"Create an extractor for a request's body.\n\n    Args:\n        kwargs_model: The KwargsModel instance.\n\n    Returns:\n        An extractor for the request's body.\n    \"\"\"\n\n    if kwargs_model.expected_form_data:\n        media_type, signature_field = kwargs_model.expected_form_data\n\n        if media_type == RequestEncodingType.MULTI_PART:\n            data_extractor = create_multipart_extractor(\n                signature_field=signature_field,\n                is_data_optional=kwargs_model.is_data_optional,\n            )\n        else:\n            data_extractor = create_url_encoded_data_extractor(is_data_optional=kwargs_model.is_data_optional)\n    elif kwargs_model.expected_msgpack_data:\n        data_extractor = cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", msgpack_extractor)\n    else:\n        data_extractor = cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", json_extractor)\n\n    def extractor(\n        values: Dict[str, Any],\n        connection: \"ASGIConnection[Any, Any, Any]\",\n    ) -> None:\n        values[\"data\"] = data_extractor(connection)\n\n    return extractor\n", "\"\"\"The contents of this file were adapted from sanic.\n\nMIT License\n\nCopyright (c) 2016-present Sanic Community\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\n\nimport re\nfrom collections import defaultdict\nfrom email.utils import decode_rfc2231\nfrom typing import Any, DefaultDict, Dict, List, Tuple\nfrom urllib.parse import unquote\n\nfrom starlite.datastructures.upload_file import UploadFile\nfrom starlite.exceptions import SerializationException\nfrom starlite.utils.serialization import decode_json\n\n_token, _quoted = r\"([\\w!#$%&'*+\\-.^_`|~]+)\", r'\"([^\"]*)\"'\n_param = re.compile(rf\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')\n\n\ndef parse_content_header(value: str) -> Tuple[str, Dict[str, str]]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    Args:\n        value: A header string value to parse.\n\n    Returns:\n        A tuple containing the normalized header string and a dictionary of parameters.\n    \"\"\"\n    value = _firefox_quote_escape.sub(\"%22\", value)\n    pos = value.find(\";\")\n    if pos == -1:\n        options: Dict[str, str] = {}\n    else:\n        options = {\n            m.group(1).lower(): m.group(2) or m.group(3).replace(\"%22\", '\"') for m in _param.finditer(value[pos:])\n        }\n        value = value[:pos]\n    return value.strip().lower(), options\n\n\ndef parse_multipart_form(body: bytes, boundary: bytes) -> Dict[str, Any]:\n    \"\"\"Parse multipart form data.\n\n    Args:\n        body: Body of the request.\n        boundary: Boundary of the multipart message.\n\n    Returns:\n        A dictionary of parsed results.\n    \"\"\"\n\n    fields: DefaultDict[str, List[Any]] = defaultdict(list)\n\n    if body and boundary:\n        form_parts = body.split(boundary)\n        for form_part in form_parts[1:-1]:\n            file_name = None\n            content_type = \"text/plain\"\n            content_charset = \"utf-8\"\n            field_name = None\n            line_index = 2\n            line_end_index = 0\n            headers: List[Tuple[str, str]] = []\n\n            while line_end_index != -1:\n                line_end_index = form_part.find(b\"\\r\\n\", line_index)\n                form_line = form_part[line_index:line_end_index].decode(\"utf-8\")\n\n                if not form_line:\n                    break\n\n                line_index = line_end_index + 2\n                colon_index = form_line.index(\":\")\n                current_idx = colon_index + 2\n                form_header_field = form_line[0:colon_index].lower()\n                form_header_value, form_parameters = parse_content_header(form_line[current_idx:])\n\n                if form_header_field == \"content-disposition\":\n                    field_name = form_parameters.get(\"name\")\n                    file_name = form_parameters.get(\"filename\")\n\n                    if file_name is None and (filename_with_asterisk := form_parameters.get(\"filename*\")):\n                        encoding, _, value = decode_rfc2231(filename_with_asterisk)\n                        file_name = unquote(value, encoding=encoding or content_charset)\n\n                elif form_header_field == \"content-type\":\n                    content_type = form_header_value\n                    content_charset = form_parameters.get(\"charset\", \"utf-8\")\n                headers.append((form_header_field, form_header_value))\n\n            if field_name:\n                post_data = form_part[line_index:-4].lstrip(b\"\\r\\n\")\n                if file_name:\n                    form_file = UploadFile(\n                        content_type=content_type, filename=file_name, file_data=post_data, headers=dict(headers)\n                    )\n                    fields[field_name].append(form_file)\n                else:\n                    try:\n                        fields[field_name].append(decode_json(post_data))\n                    except SerializationException:\n                        fields[field_name].append(post_data.decode(content_charset))\n\n    return {k: v if len(v) > 1 else v[0] for k, v in fields.items()}\n", "from dataclasses import asdict, dataclass, field\nfrom typing import TYPE_CHECKING, Any, Hashable, List, Optional, Union\n\nfrom starlite.enums import RequestEncodingType\nfrom starlite.types import Empty\n\nif TYPE_CHECKING:\n    from pydantic_openapi_schema.v3_1_0.example import Example\n    from pydantic_openapi_schema.v3_1_0.external_documentation import (\n        ExternalDocumentation,\n    )\n\n\n@dataclass(frozen=True)\nclass ParameterKwarg:\n    \"\"\"Data container representing a parameter.\"\"\"\n\n    value_type: Any = field(default=Empty)\n    \"\"\"The field value - `Empty` by default.\"\"\"\n    header: Optional[str] = field(default=None)\n    \"\"\"The header parameter key - required for header parameters.\"\"\"\n    cookie: Optional[str] = field(default=None)\n    \"\"\"The cookie parameter key - required for cookie parameters.\"\"\"\n    query: Optional[str] = field(default=None)\n    \"\"\"The query parameter key for this parameter.\"\"\"\n    examples: Optional[List[\"Example\"]] = field(default=None)\n    \"\"\"A list of Example models.\"\"\"\n    external_docs: Optional[\"ExternalDocumentation\"] = field(default=None)\n    \"\"\"A url pointing at external documentation for the given parameter.\"\"\"\n    content_encoding: Optional[str] = field(default=None)\n    \"\"\"The content encoding of the value.\n\n    Applicable on to string values. See OpenAPI 3.1 for details.\n    \"\"\"\n    required: Optional[bool] = field(default=None)\n    \"\"\"A boolean flag dictating whether this parameter is required.\n\n    If set to False, None values will be allowed. Defaults to True.\n    \"\"\"\n    default: Any = field(default=Empty)\n    \"\"\"A default value.\n\n    If const is true, this value is required.\n    \"\"\"\n    title: Optional[str] = field(default=None)\n    \"\"\"String value used in the title section of the OpenAPI schema for the given parameter.\"\"\"\n    description: Optional[str] = field(default=None)\n    \"\"\"String value used in the description section of the OpenAPI schema for the given parameter.\"\"\"\n    const: Optional[bool] = field(default=None)\n    \"\"\"A boolean flag dictating whether this parameter is a constant.\n\n    If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to\n    be populated with the default value.\n    \"\"\"\n    gt: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be greater than a given float or int.\n\n    Equivalent to exclusiveMinimum in the OpenAPI specification.\n    \"\"\"\n    ge: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be greater or equal to a given float or int.\n\n    Equivalent to minimum in the OpenAPI specification.\n    \"\"\"\n    lt: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be less than a given float or int.\n\n    Equivalent to exclusiveMaximum in the OpenAPI specification.\n    \"\"\"\n    le: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be less or equal to a given float or int.\n\n    Equivalent to maximum in the OpenAPI specification.\n    \"\"\"\n    multiple_of: Optional[float] = field(default=None)\n    \"\"\"Constrict value to a multiple of a given float or int.\n\n    Equivalent to multipleOf in the OpenAPI specification.\n    \"\"\"\n    min_items: Optional[int] = field(default=None)\n    \"\"\"Constrict a set or a list to have a minimum number of items.\n\n    Equivalent to minItems in the OpenAPI specification.\n    \"\"\"\n    max_items: Optional[int] = field(default=None)\n    \"\"\"Constrict a set or a list to have a maximum number of items.\n\n    Equivalent to maxItems in the OpenAPI specification.\n    \"\"\"\n    min_length: Optional[int] = field(default=None)\n    \"\"\"Constrict a string or bytes value to have a minimum length.\n\n    Equivalent to minLength in the OpenAPI specification.\n    \"\"\"\n    max_length: Optional[int] = field(default=None)\n    \"\"\"Constrict a string or bytes value to have a maximum length.\n\n    Equivalent to maxLength in the OpenAPI specification.\n    \"\"\"\n    regex: Optional[str] = field(default=None)\n    \"\"\"A string representing a regex against which the given string will be matched.\n\n    Equivalent to pattern in the OpenAPI specification.\n    \"\"\"\n\n    def __hash__(self) -> int:  # pragma: no cover\n        \"\"\"Hash the dataclass in a safe way.\n\n        Returns:\n            A hash\n        \"\"\"\n        return sum(hash(v) for v in asdict(self) if isinstance(v, Hashable))\n\n\ndef Parameter(\n    value_type: Any = Empty,\n    *,\n    header: Optional[str] = None,\n    cookie: Optional[str] = None,\n    query: Optional[str] = None,\n    examples: Optional[List[\"Example\"]] = None,\n    external_docs: Optional[\"ExternalDocumentation\"] = None,\n    content_encoding: Optional[str] = None,\n    required: Optional[bool] = None,\n    default: Any = Empty,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    const: Optional[bool] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    multiple_of: Optional[float] = None,\n    min_items: Optional[int] = None,\n    max_items: Optional[int] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None\n) -> Any:\n    \"\"\"Create an extended parameter kwarg definition.\n\n    Args:\n        value_type: `Empty` by default.\n        header: The header parameter key - required for header parameters.\n        cookie: The cookie parameter key - required for cookie parameters.\n        query: The query parameter key for this parameter.\n        examples: A list of Example models.\n        external_docs: A url pointing at external documentation for the given\n            parameter.\n        content_encoding: The content encoding of the value. Applicable on to string values. See\n            OpenAPI 3.1 for details.\n        required: A boolean flag dictating whether this parameter is required. If set to False, None\n            values will be allowed. Defaults to True.\n        default: A default value. If const is true, this value is required.\n        title: String value used in the title section of the OpenAPI schema for the given\n            parameter.\n        description: String value used in the description section of the OpenAPI schema for the\n            given parameter.\n        const: A boolean flag dictating whether this parameter is a constant. If True, the value passed\n            to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with\n            the default value.\n        gt: Constrict value to be greater than a given float or int. Equivalent to\n            exclusiveMinimum in the OpenAPI specification.\n        ge: Constrict value to be greater or equal to a given float or int. Equivalent to\n            minimum in the OpenAPI specification.\n        lt: Constrict value to be less than a given float or int. Equivalent to\n            exclusiveMaximum in the OpenAPI specification.\n        le: Constrict value to be less or equal to a given float or int. Equivalent to maximum\n            in the OpenAPI specification.\n        multiple_of: Constrict value to a multiple of a given float or int. Equivalent to\n            multipleOf in the OpenAPI specification.\n        min_items: Constrict a set or a list to have a minimum number of items. Equivalent to\n            minItems in the OpenAPI specification.\n        max_items: Constrict a set or a list to have a maximum number of items. Equivalent to\n            maxItems in the OpenAPI specification.\n        min_length: Constrict a string or bytes value to have a minimum length. Equivalent to\n            minLength in the OpenAPI specification.\n        max_length: Constrict a string or bytes value to have a maximum length. Equivalent to\n            maxLength in the OpenAPI specification.\n        regex: A string representing a regex against which the given string will be matched.\n            Equivalent to pattern in the OpenAPI specification.\n    \"\"\"\n    return ParameterKwarg(\n        value_type=value_type,\n        header=header,\n        cookie=cookie,\n        query=query,\n        examples=examples,\n        external_docs=external_docs,\n        content_encoding=content_encoding,\n        required=required,\n        default=default,\n        title=title,\n        description=description,\n        const=const,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        multiple_of=multiple_of,\n        min_items=min_items,\n        max_items=max_items,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n    )\n\n\n@dataclass(frozen=True)\nclass BodyKwarg:\n    \"\"\"Data container representing a request body.\"\"\"\n\n    media_type: Union[str, \"RequestEncodingType\"] = field(default=RequestEncodingType.JSON)\n    \"\"\"Media-Type of the body.\"\"\"\n    examples: Optional[List[\"Example\"]] = field(default=None)\n    \"\"\"A list of Example models.\"\"\"\n    external_docs: Optional[\"ExternalDocumentation\"] = field(default=None)\n    \"\"\"A url pointing at external documentation for the given parameter.\"\"\"\n    content_encoding: Optional[str] = field(default=None)\n    \"\"\"The content encoding of the value.\n\n    Applicable on to string values. See OpenAPI 3.1 for details.\n    \"\"\"\n    default: Any = field(default=Empty)\n    \"\"\"A default value.\n\n    If const is true, this value is required.\n    \"\"\"\n    title: Optional[str] = field(default=None)\n    \"\"\"String value used in the title section of the OpenAPI schema for the given parameter.\"\"\"\n    description: Optional[str] = field(default=None)\n    \"\"\"String value used in the description section of the OpenAPI schema for the given parameter.\"\"\"\n    const: Optional[bool] = field(default=None)\n    \"\"\"A boolean flag dictating whether this parameter is a constant.\n\n    If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to\n    be populated with the default value.\n    \"\"\"\n    gt: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be greater than a given float or int.\n\n    Equivalent to exclusiveMinimum in the OpenAPI specification.\n    \"\"\"\n    ge: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be greater or equal to a given float or int.\n\n    Equivalent to minimum in the OpenAPI specification.\n    \"\"\"\n    lt: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be less than a given float or int.\n\n    Equivalent to exclusiveMaximum in the OpenAPI specification.\n    \"\"\"\n    le: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be less or equal to a given float or int.\n\n    Equivalent to maximum in the OpenAPI specification.\n    \"\"\"\n    multiple_of: Optional[float] = field(default=None)\n    \"\"\"Constrict value to a multiple of a given float or int.\n\n    Equivalent to multipleOf in the OpenAPI specification.\n    \"\"\"\n    min_items: Optional[int] = field(default=None)\n    \"\"\"Constrict a set or a list to have a minimum number of items.\n\n    Equivalent to minItems in the OpenAPI specification.\n    \"\"\"\n    max_items: Optional[int] = field(default=None)\n    \"\"\"Constrict a set or a list to have a maximum number of items.\n\n    Equivalent to maxItems in the OpenAPI specification.\n    \"\"\"\n    min_length: Optional[int] = field(default=None)\n    \"\"\"Constrict a string or bytes value to have a minimum length.\n\n    Equivalent to minLength in the OpenAPI specification.\n    \"\"\"\n    max_length: Optional[int] = field(default=None)\n    \"\"\"Constrict a string or bytes value to have a maximum length.\n\n    Equivalent to maxLength in the OpenAPI specification.\n    \"\"\"\n    regex: Optional[str] = field(default=None)\n    \"\"\"A string representing a regex against which the given string will be matched.\n\n    Equivalent to pattern in the OpenAPI specification.\n    \"\"\"\n\n    def __hash__(self) -> int:  # pragma: no cover\n        \"\"\"Hash the dataclass in a safe way.\n\n        Returns:\n            A hash\n        \"\"\"\n        return sum(hash(v) for v in asdict(self) if isinstance(v, Hashable))\n\n\ndef Body(\n    *,\n    media_type: Union[str, \"RequestEncodingType\"] = RequestEncodingType.JSON,\n    examples: Optional[List[\"Example\"]] = None,\n    external_docs: Optional[\"ExternalDocumentation\"] = None,\n    content_encoding: Optional[str] = None,\n    default: Any = Empty,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    const: Optional[bool] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    multiple_of: Optional[float] = None,\n    min_items: Optional[int] = None,\n    max_items: Optional[int] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None\n) -> Any:\n    \"\"\"Create an extended request body kwarg definition.\n\n    Args:\n        media_type: Defaults to RequestEncodingType.JSON.\n        examples: A list of Example models.\n        external_docs: A url pointing at external documentation for the given\n            parameter.\n        content_encoding: The content encoding of the value. Applicable on to string values. See\n            OpenAPI 3.1 for details.\n        default: A default value. If const is true, this value is required.\n        title: String value used in the title section of the OpenAPI schema for the given\n            parameter.\n        description: String value used in the description section of the OpenAPI schema for the\n            given parameter.\n        const: A boolean flag dictating whether this parameter is a constant. If True, the value passed\n            to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with\n            the default value.\n        gt: Constrict value to be greater than a given float or int. Equivalent to\n            exclusiveMinimum in the OpenAPI specification.\n        ge: Constrict value to be greater or equal to a given float or int. Equivalent to\n            minimum in the OpenAPI specification.\n        lt: Constrict value to be less than a given float or int. Equivalent to\n            exclusiveMaximum in the OpenAPI specification.\n        le: Constrict value to be less or equal to a given float or int. Equivalent to maximum\n            in the OpenAPI specification.\n        multiple_of: Constrict value to a multiple of a given float or int. Equivalent to\n            multipleOf in the OpenAPI specification.\n        min_items: Constrict a set or a list to have a minimum number of items. Equivalent to\n            minItems in the OpenAPI specification.\n        max_items: Constrict a set or a list to have a maximum number of items. Equivalent to\n            maxItems in the OpenAPI specification.\n        min_length: Constrict a string or bytes value to have a minimum length. Equivalent to\n            minLength in the OpenAPI specification.\n        max_length: Constrict a string or bytes value to have a maximum length. Equivalent to\n            maxLength in the OpenAPI specification.\n        regex: A string representing a regex against which the given string will be matched.\n            Equivalent to pattern in the OpenAPI specification.\n    \"\"\"\n    return BodyKwarg(\n        media_type=media_type,\n        examples=examples,\n        external_docs=external_docs,\n        content_encoding=content_encoding,\n        default=default,\n        title=title,\n        description=description,\n        const=const,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        multiple_of=multiple_of,\n        min_items=min_items,\n        max_items=max_items,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n    )\n\n\n@dataclass(frozen=True)\nclass DependencyKwarg:\n    \"\"\"Data container representing a dependency.\"\"\"\n\n    default: Any = field(default=Empty)\n    \"\"\"A default value.\"\"\"\n    skip_validation: bool = field(default=False)\n    \"\"\"Flag dictating whether to skip validation.\"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"Hash the dataclass in a safe way.\n\n        Returns:\n            A hash\n        \"\"\"\n        return sum(hash(v) for v in asdict(self) if isinstance(v, Hashable))\n\n\ndef Dependency(*, default: Any = Empty, skip_validation: bool = False) -> Any:\n    \"\"\"Create a dependency kwarg definition.\n\n    Args:\n        default: A default value to use in case a dependency is not provided.\n        skip_validation: If `True` provided dependency values are not validated by signature model.\n    \"\"\"\n    return DependencyKwarg(default=default, skip_validation=skip_validation)\n", "from typing import (\n    TYPE_CHECKING,\n    Any,\n    Dict,\n    Iterable,\n    List,\n    Literal,\n    Optional,\n    Tuple,\n    Type,\n    Union,\n    cast,\n)\n\nfrom starlite.app import DEFAULT_CACHE_CONFIG, Starlite\nfrom starlite.testing.client.sync_client import TestClient\n\nif TYPE_CHECKING:\n    from starlite import (\n        BaseLoggingConfig,\n        CacheConfig,\n        CompressionConfig,\n        CORSConfig,\n        CSRFConfig,\n        OpenAPIConfig,\n        PluginProtocol,\n        Request,\n        StaticFilesConfig,\n        TemplateConfig,\n        WebSocket,\n    )\n    from starlite.config import AllowedHostsConfig\n    from starlite.datastructures.state import ImmutableState\n    from starlite.middleware.session.base import BaseBackendConfig\n    from starlite.types import (\n        AfterExceptionHookHandler,\n        AfterRequestHookHandler,\n        AfterResponseHookHandler,\n        BeforeMessageSendHookHandler,\n        BeforeRequestHookHandler,\n        ControllerRouterHandler,\n        Dependencies,\n        ExceptionHandlersMap,\n        Guard,\n        LifeSpanHandler,\n        LifeSpanHookHandler,\n        Middleware,\n        OnAppInitHandler,\n        ParametersMap,\n        ResponseType,\n        SingleOrList,\n    )\n\n\ndef create_test_client(\n    route_handlers: Union[\"ControllerRouterHandler\", List[\"ControllerRouterHandler\"]],\n    *,\n    after_exception: Optional[\"SingleOrList[AfterExceptionHookHandler]\"] = None,\n    after_request: Optional[\"AfterRequestHookHandler\"] = None,\n    after_response: Optional[\"AfterResponseHookHandler\"] = None,\n    after_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n    after_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n    allowed_hosts: Optional[Union[List[str], \"AllowedHostsConfig\"]] = None,\n    backend: Literal[\"asyncio\", \"trio\"] = \"asyncio\",\n    backend_options: Optional[Dict[str, Any]] = None,\n    base_url: str = \"http://testserver.local\",\n    before_request: Optional[\"BeforeRequestHookHandler\"] = None,\n    before_send: Optional[\"SingleOrList[BeforeMessageSendHookHandler]\"] = None,\n    before_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n    before_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n    cache_config: \"CacheConfig\" = DEFAULT_CACHE_CONFIG,\n    compression_config: Optional[\"CompressionConfig\"] = None,\n    cors_config: Optional[\"CORSConfig\"] = None,\n    csrf_config: Optional[\"CSRFConfig\"] = None,\n    dependencies: Optional[\"Dependencies\"] = None,\n    exception_handlers: Optional[\"ExceptionHandlersMap\"] = None,\n    guards: Optional[List[\"Guard\"]] = None,\n    initial_state: Optional[Union[\"ImmutableState\", Dict[str, Any], Iterable[Tuple[str, Any]]]] = None,\n    logging_config: Optional[\"BaseLoggingConfig\"] = None,\n    middleware: Optional[List[\"Middleware\"]] = None,\n    on_app_init: Optional[List[\"OnAppInitHandler\"]] = None,\n    on_shutdown: Optional[List[\"LifeSpanHandler\"]] = None,\n    on_startup: Optional[List[\"LifeSpanHandler\"]] = None,\n    openapi_config: Optional[\"OpenAPIConfig\"] = None,\n    parameters: Optional[\"ParametersMap\"] = None,\n    plugins: Optional[List[\"PluginProtocol\"]] = None,\n    raise_server_exceptions: bool = True,\n    request_class: Optional[Type[\"Request\"]] = None,\n    response_class: Optional[\"ResponseType\"] = None,\n    root_path: str = \"\",\n    session_config: Optional[\"BaseBackendConfig\"] = None,\n    static_files_config: Optional[Union[\"StaticFilesConfig\", List[\"StaticFilesConfig\"]]] = None,\n    template_config: Optional[\"TemplateConfig\"] = None,\n    websocket_class: Optional[Type[\"WebSocket\"]] = None,\n) -> TestClient[\"Starlite\"]:\n    \"\"\"Create a Starlite app instance and initializes it.\n\n    :class:`TestClient <starlite.testing.TestClient>` with it.\n\n    Notes:\n        - This function should be called as a context manager to ensure async startup and shutdown are\n            handled correctly.\n\n    Examples:\n        .. code-block: python\n\n            from starlite import get, create_test_client\n\n\n            @get(\"/some-path\")\n            def my_handler() -> dict[str, str]:\n                return {\"hello\": \"world\"}\n\n\n            def test_my_handler() -> None:\n                with create_test_client(my_handler) as client:\n                    response == client.get(\"/some-path\")\n                    assert response.json() == {\"hello\": \"world\"}\n\n\n    Args:\n        route_handlers: A single handler or a list of route handlers, which can include instances of\n            :class:`Router <starlite.router.Router>`, subclasses of :class:`Controller <starlite.controller.Controller>` or\n            any function decorated by the route handler decorators.\n        after_exception: An application level :class:`exception event handler <starlite.types.AfterExceptionHookHandler>`.\n            This hook is called after an exception occurs. In difference to exception handlers, it is not meant to\n            return a response - only to process the exception (e.g. log it, send it to Sentry etc.).\n        after_request: A sync or async function executed after the route handler function returned and the response\n            object has been resolved. Receives the response object which may be any subclass of\n            :class:`Response <starlite.response.Response>`.\n        after_response: A sync or async function called after the response has been awaited. It receives the\n            :class:`Request <starlite.connection.Request>` object and should not return any values.\n        after_shutdown: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`.\n            This hook is called during the ASGI shutdown, after all callables in the ``on_shutdown``\n            list have been called.\n        after_startup: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`.\n            This hook is called during the ASGI startup, after all callables in the ``on_startup``\n            list have been called.\n        allowed_hosts: A list of allowed hosts - enables the builtin allowed hosts middleware.\n        backend: The async backend to use, options are \"asyncio\" or \"trio\".\n        backend_options: ``anyio`` options.\n        base_url: URL scheme and domain for test request paths, e.g. 'http://testserver'.\n        before_request: A sync or async function called immediately before calling the route handler.\n            Receives the :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is\n            used for the response, bypassing the route handler.\n        before_send: An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or\n            list thereof. This hook is called when the ASGI send function is called.\n        before_shutdown: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`. This hook is\n            called during the ASGI shutdown, before any callables in the ``on_shutdown`` list have been called.\n        before_startup: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`. This hook is\n            called during the ASGI startup, before any callables in the ``on_startup`` list have been called.\n        cache_config: Configures caching behavior of the application.\n        compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n            defined Compression middleware.\n        cors_config: If set this enables the builtin CORS middleware.\n        csrf_config: If set this enables the builtin CSRF middleware.\n        dependencies: A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.\n        exception_handlers: A dictionary that maps handler functions to status codes and/or exception types.\n        guards: A list of :class:`Guard <starlite.types.Guard>` callables.\n        initial_state: An object from which to initialize the app state.\n        logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`.\n        middleware: A list of :class:`Middleware <starlite.types.Middleware>`.\n        on_app_init:  A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive\n                an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with\n                the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more\n                than one handler is registered they are called in the order they are provided.\n        on_shutdown: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during\n            application shutdown.\n        on_startup: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during\n            application startup.\n        openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG <starlite.app.DEFAULT_OPENAPI_CONFIG>`\n        parameters: A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all\n            application paths.\n        plugins: List of plugins.\n        request_class: An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for\n            http connections.\n        raise_server_exceptions: Flag for underlying the test client to raise server exceptions instead of\n            wrapping them in an HTTP response.\n        response_class: A custom subclass of [starlite.response.Response] to be used as the app's default response.\n        root_path: Path prefix for requests.\n        static_files_config: An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`\n        session_config: Configuration for Session Middleware class to create raw session cookies for request to the\n            route handlers.\n        template_config: An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`\n        websocket_class: An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for\n            websocket connections.\n\n    Returns:\n        An instance of :class:`TestClient <starlite.testing.TestClient>` with a created app instance.\n    \"\"\"\n    return TestClient[Starlite](\n        app=Starlite(\n            after_exception=after_exception,\n            after_request=after_request,\n            after_response=after_response,\n            after_shutdown=after_shutdown,\n            after_startup=after_startup,\n            allowed_hosts=allowed_hosts,\n            before_request=before_request,\n            before_send=before_send,\n            before_shutdown=before_shutdown,\n            before_startup=before_startup,\n            cache_config=cache_config,\n            compression_config=compression_config,\n            cors_config=cors_config,\n            csrf_config=csrf_config,\n            dependencies=dependencies,\n            exception_handlers=exception_handlers,\n            guards=guards,\n            initial_state=initial_state,\n            logging_config=logging_config,\n            middleware=middleware,\n            on_app_init=on_app_init,\n            on_shutdown=on_shutdown,\n            on_startup=on_startup,\n            openapi_config=openapi_config,\n            parameters=parameters,\n            plugins=plugins,\n            request_class=request_class,\n            response_class=response_class,\n            route_handlers=cast(\"Any\", route_handlers if isinstance(route_handlers, list) else [route_handlers]),\n            static_files_config=static_files_config,\n            template_config=template_config,\n            websocket_class=websocket_class,\n        ),\n        backend=backend,\n        backend_options=backend_options,\n        base_url=base_url,\n        raise_server_exceptions=raise_server_exceptions,\n        root_path=root_path,\n        session_config=session_config,\n    )\n", "import inspect\nfrom typing import List\nfrom unittest.mock import MagicMock, PropertyMock\n\nimport pytest\n\nfrom starlite import LoggingConfig\nfrom starlite.app import DEFAULT_CACHE_CONFIG, Starlite\nfrom starlite.config.app import AppConfig\nfrom starlite.router import Router\n\n\n@pytest.fixture()\ndef app_config_object() -> AppConfig:\n    return AppConfig(\n        after_exception=[],\n        after_request=None,\n        after_response=None,\n        after_shutdown=[],\n        after_startup=[],\n        allowed_hosts=[],\n        before_request=None,\n        before_send=[],\n        before_shutdown=[],\n        before_startup=[],\n        cache_config=DEFAULT_CACHE_CONFIG,\n        cache_control=None,\n        compression_config=None,\n        cors_config=None,\n        csrf_config=None,\n        debug=False,\n        dependencies={},\n        exception_handlers={},\n        guards=[],\n        initial_state={},\n        logging_config=None,\n        middleware=[],\n        on_shutdown=[],\n        on_startup=[],\n        openapi_config=None,\n        opt={},\n        parameters={},\n        plugins=[],\n        response_class=None,\n        response_cookies=[],\n        response_headers={},\n        route_handlers=[],\n        security=[],\n        static_files_config=[],\n        tags=[],\n        template_config=None,\n        request_class=None,\n        websocket_class=None,\n        etag=None,\n    )\n\n\ndef test_app_params_defined_on_app_config_object() -> None:\n    \"\"\"Ensures that all parameters to the `Starlite` constructor are present on the `AppConfig` object.\"\"\"\n    starlite_signature = inspect.signature(Starlite)\n    app_config_fields = AppConfig.__fields__\n    for name in starlite_signature.parameters:\n        if name in (\"on_app_init\", \"initial_state\"):\n            continue\n        assert name in app_config_fields\n    # ensure there are not fields defined on AppConfig that aren't in the Starlite signature\n    assert not (app_config_fields.keys() - starlite_signature.parameters.keys())\n\n\ndef test_app_config_object_used(app_config_object: AppConfig, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Ensure that the properties on the `AppConfig` object are accessed within the `Starlite` constructor.\n\n    In the test we replace every field on the `AppConfig` type with a property mock so that we can check that it has at\n    least been accessed. It doesn't actually check that we do the right thing with it, but is a guard against the case\n    of adding a parameter to the `Starlite` signature and to the `AppConfig` object, and using the value from the\n    parameter downstream from construction of the `AppConfig` object.\n    \"\"\"\n\n    # replace each field on the `AppConfig` object with a `PropertyMock`, this allows us to assert that the properties\n    # have been accessed during app instantiation.\n    property_mocks: List[PropertyMock] = []\n    for name in AppConfig.__fields__:\n        if name == \"cache_config\":\n            property_mock = PropertyMock(return_value=DEFAULT_CACHE_CONFIG)\n        else:\n            # default iterable return value allows the mock properties that need to be iterated over in\n            # `Starlite.__init__()` to not blow up, for other properties it shouldn't matter what the value is for the\n            # sake of this test.\n            property_mock = PropertyMock(return_value=[])\n        property_mocks.append(property_mock)\n        monkeypatch.setattr(type(app_config_object), name, property_mock, raising=False)\n\n    # Things that we don't actually need to call for this test\n    monkeypatch.setattr(Starlite, \"register\", MagicMock())\n    monkeypatch.setattr(Starlite, \"_create_asgi_handler\", MagicMock())\n    monkeypatch.setattr(Router, \"__init__\", MagicMock())\n\n    # instantiates the app with an `on_app_config` that returns our patched `AppConfig` object.\n    Starlite(route_handlers=[], on_app_init=[MagicMock(return_value=app_config_object)])\n\n    # this ensures that each of the properties of the `AppConfig` object have been accessed within `Starlite.__init__()`\n    for mock in property_mocks:\n        mock.assert_called()\n\n\ndef test_app_debug_create_logger() -> None:\n    app = Starlite([], debug=True)\n\n    assert app.logging_config\n    assert app.logging_config.loggers[\"starlite\"][\"level\"] == \"DEBUG\"  # type: ignore[attr-defined]\n\n\ndef test_app_debug_explicitly_disable_logging() -> None:\n    app = Starlite([], debug=True, logging_config=None)\n\n    assert not app.logging_config\n\n\ndef test_app_debug_update_logging_config() -> None:\n    logging_config = LoggingConfig()\n    app = Starlite([], debug=True, logging_config=logging_config)\n\n    assert app.logging_config is logging_config\n    assert app.logging_config.loggers[\"starlite\"][\"level\"] == \"DEBUG\"  # type: ignore[attr-defined]\n\n\ndef test_set_initial_state() -> None:\n    def set_initial_state_in_hook(app_config: AppConfig) -> AppConfig:\n        assert isinstance(app_config.initial_state, dict)\n        app_config.initial_state[\"c\"] = \"D\"  # pyright:ignore\n        app_config.initial_state[\"e\"] = \"f\"  # pyright:ignore\n        return app_config\n\n    app = Starlite(route_handlers=[], initial_state={\"a\": \"b\", \"c\": \"d\"}, on_app_init=[set_initial_state_in_hook])\n    assert app.state._state == {\"a\": \"b\", \"c\": \"D\", \"e\": \"f\"}\n", "# flake8: noqa\nfrom collections import defaultdict\nfrom os import path\nfrom os.path import dirname, join, realpath\nfrom pathlib import Path\nfrom typing import Any, DefaultDict, Dict, List, Optional, Type\n\nimport pytest\nfrom pydantic import BaseConfig, BaseModel\n\nfrom starlite import Body, Request, RequestEncodingType, post\nfrom starlite.datastructures import UploadFile\nfrom starlite.status_codes import HTTP_201_CREATED\nfrom starlite.testing import create_test_client\nfrom tests import Person, PersonFactory\nfrom tests.kwargs import Form\n\n\nclass FormData(BaseModel):\n    name: UploadFile\n    age: UploadFile\n    programmer: UploadFile\n\n    class Config(BaseConfig):\n        arbitrary_types_allowed = True\n\n\n@post(\"/form\")\nasync def form_handler(request: Request) -> Dict[str, Any]:\n    data = await request.form()\n    output = {}\n    for key, value in data.items():\n        if isinstance(value, UploadFile):\n            content = await value.read()\n            output[key] = {\n                \"filename\": value.filename,\n                \"content\": content.decode(),\n                \"content_type\": value.content_type,\n            }\n        else:\n            output[key] = value\n    return output\n\n\n@post(\"/form\")\nasync def form_multi_item_handler(request: Request) -> DefaultDict[str, list]:\n    data = await request.form()\n    output: DefaultDict[str, list] = defaultdict(list)\n    for key, value in data.multi_items():\n        for v in value:\n            if isinstance(v, UploadFile):\n                content = await v.read()\n                output[key].append(\n                    {\n                        \"filename\": v.filename,\n                        \"content\": content.decode(),\n                        \"content_type\": v.content_type,\n                    }\n                )\n            else:\n                output[key].append(v)\n    return output\n\n\n@post(\"/form\")\nasync def form_with_headers_handler(request: Request) -> Dict[str, Any]:\n    data = await request.form()\n    output = {}\n    for key, value in data.items():\n        if isinstance(value, UploadFile):\n            content = await value.read()\n            output[key] = {\n                \"filename\": value.filename,\n                \"content\": content.decode(),\n                \"content_type\": value.content_type,\n                \"headers\": [[name.lower(), value] for name, value in value.headers.items()],\n            }\n        else:\n            output[key] = value\n    return output\n\n\n@pytest.mark.parametrize(\"t_type\", [FormData, Dict[str, UploadFile], List[UploadFile], UploadFile])\ndef test_request_body_multi_part(t_type: Type[Any]) -> None:\n    body = Body(media_type=RequestEncodingType.MULTI_PART)\n\n    test_path = \"/test\"\n    data = Form(name=\"Moishe Zuchmir\", age=30, programmer=True).dict()\n\n    @post(path=test_path)\n    def test_method(data: t_type = body) -> None:  # type: ignore\n        assert data\n\n    with create_test_client(test_method) as client:\n        response = client.post(test_path, files={k: str(v).encode(\"utf-8\") for k, v in data.items()})\n        assert response.status_code == HTTP_201_CREATED\n\n\ndef test_request_body_multi_part_mixed_field_content_types() -> None:\n    person = PersonFactory.build()\n\n    class MultiPartFormWithMixedFields(BaseModel):\n        class Config(BaseConfig):\n            arbitrary_types_allowed = True\n\n        image: UploadFile\n        tags: List[str]\n        profile: Person\n\n    @post(path=\"/form\")\n    async def test_method(data: MultiPartFormWithMixedFields = Body(media_type=RequestEncodingType.MULTI_PART)) -> None:\n        file_data = await data.image.read()\n        assert file_data == b\"data\"\n        assert data.tags == [\"1\", \"2\", \"3\"]\n        assert data.profile == person\n\n    with create_test_client(test_method) as client:\n        response = client.post(\n            \"/form\",\n            files={\"image\": (\"image.png\", b\"data\")},\n            data={\"tags\": [\"1\", \"2\", \"3\"], \"profile\": person.json()},\n        )\n        assert response.status_code == HTTP_201_CREATED\n\n\ndef test_multipart_request_files(tmpdir: Any) -> None:\n    path1 = path.join(tmpdir, \"test.txt\")\n    Path(path1).write_bytes(b\"<file content>\")\n\n    with create_test_client(form_handler) as client, open(path1, \"rb\") as f:\n        response = client.post(\"/form\", files={\"test\": f})\n        assert response.json() == {\n            \"test\": {\n                \"filename\": \"test.txt\",\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            }\n        }\n\n\ndef test_multipart_request_files_with_content_type(tmpdir: Any) -> None:\n    path1 = path.join(tmpdir, \"test.txt\")\n    Path(path1).write_bytes(b\"<file content>\")\n\n    with create_test_client(form_handler) as client, open(path1, \"rb\") as f:\n        response = client.post(\"/form\", files={\"test\": (\"test.txt\", f, \"text/plain\")})\n        assert response.json() == {\n            \"test\": {\n                \"filename\": \"test.txt\",\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            }\n        }\n\n\ndef test_multipart_request_multiple_files(tmpdir: Any) -> None:\n    path1 = path.join(tmpdir, \"test1.txt\")\n    Path(path1).write_bytes(b\"<file1 content>\")\n\n    path2 = path.join(tmpdir, \"test2.txt\")\n    Path(path2).write_bytes(b\"<file2 content>\")\n\n    with create_test_client(form_handler) as client, open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\"/form\", files={\"test1\": f1, \"test2\": (\"test2.txt\", f2, \"text/plain\")})\n        assert response.json() == {\n            \"test1\": {\"filename\": \"test1.txt\", \"content\": \"<file1 content>\", \"content_type\": \"text/plain\"},\n            \"test2\": {\"filename\": \"test2.txt\", \"content\": \"<file2 content>\", \"content_type\": \"text/plain\"},\n        }\n\n\ndef test_multipart_request_multiple_files_with_headers(tmpdir: Any) -> None:\n    path1 = path.join(tmpdir, \"test1.txt\")\n    Path(path1).write_bytes(b\"<file1 content>\")\n\n    path2 = path.join(tmpdir, \"test2.txt\")\n    Path(path2).write_bytes(b\"<file2 content>\")\n\n    with create_test_client(form_with_headers_handler) as client, open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\n            \"/form\",\n            files=[\n                (\"test1\", (None, f1)),\n                (\"test2\", (\"test2.txt\", f2, \"text/plain\", {\"x-custom\": \"f2\"})),\n            ],\n        )\n        assert response.json() == {\n            \"test1\": \"<file1 content>\",\n            \"test2\": {\n                \"filename\": \"test2.txt\",\n                \"content\": \"<file2 content>\",\n                \"content_type\": \"text/plain\",\n                \"headers\": [[\"content-disposition\", \"form-data\"], [\"x-custom\", \"f2\"], [\"content-type\", \"text/plain\"]],\n            },\n        }\n\n\ndef test_multi_items(tmpdir: Any) -> None:\n    path1 = path.join(tmpdir, \"test1.txt\")\n    Path(path1).write_bytes(b\"<file1 content>\")\n\n    path2 = path.join(tmpdir, \"test2.txt\")\n    Path(path2).write_bytes(b\"<file2 content>\")\n\n    with create_test_client(form_multi_item_handler) as client, open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\n            \"/form\",\n            data={\"test1\": \"abc\"},\n            files=[(\"test1\", f1), (\"test1\", (\"test2.txt\", f2, \"text/plain\"))],\n        )\n        assert response.json() == {\n            \"test1\": [\n                \"abc\",\n                {\"filename\": \"test1.txt\", \"content\": \"<file1 content>\", \"content_type\": \"text/plain\"},\n                {\"filename\": \"test2.txt\", \"content\": \"<file2 content>\", \"content_type\": \"text/plain\"},\n            ]\n        }\n\n\ndef test_multipart_request_mixed_files_and_data() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\n            \"/form\",\n            content=(\n                # data\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b'Content-Disposition: form-data; name=\"field0\"\\r\\n\\r\\n'\n                b\"value0\\r\\n\"\n                # file\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"file.txt\"\\r\\n'\n                b\"Content-Type: text/plain\\r\\n\\r\\n\"\n                b\"<file content>\\r\\n\"\n                # data\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b'Content-Disposition: form-data; name=\"field1\"\\r\\n\\r\\n'\n                b\"value1\\r\\n\"\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"},\n        )\n        assert response.json() == {\n            \"file\": {\n                \"filename\": \"file.txt\",\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            },\n            \"field0\": \"value0\",\n            \"field1\": \"value1\",\n        }\n\n\ndef test_multipart_request_with_charset_for_filename() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\n            \"/form\",\n            content=(\n                # file\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe6\\x96\\x87\\xe6\\x9b\\xb8.txt\"\\r\\n'  # noqa: E501\n                b\"Content-Type: text/plain\\r\\n\\r\\n\"\n                b\"<file content>\\r\\n\"\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; charset=utf-8; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"},\n        )\n        assert response.json() == {\n            \"file\": {\n                \"filename\": \"\u6587\u66f8.txt\",\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            }\n        }\n\n\ndef test_multipart_request_without_charset_for_filename() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\n            \"/form\",\n            content=(\n                # file\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe7\\x94\\xbb\\xe5\\x83\\x8f.jpg\"\\r\\n'  # noqa: E501\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\"\n                b\"<file content>\\r\\n\"\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"},\n        )\n        assert response.json() == {\n            \"file\": {\n                \"filename\": \"\u753b\u50cf.jpg\",\n                \"content\": \"<file content>\",\n                \"content_type\": \"image/jpeg\",\n            }\n        }\n\n\ndef test_multipart_request_with_asterisks_filename() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\n            \"/form\",\n            content=(\n                # file\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b\"Content-Disposition: form-data; name='file'; filename*=utf-8''Na%C3%AFve%20file.jpg\\r\\n\"  # noqa: E501\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\"\n                b\"<file content>\\r\\n\"\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"},\n        )\n        assert response.json() == {\n            \"'file'\": {\"filename\": \"Na\u00efve file.jpg\", \"content\": \"<file content>\", \"content_type\": \"image/jpeg\"}\n        }\n\n\ndef test_multipart_request_with_encoded_value() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\n            \"/form\",\n            content=(\n                b\"--20b303e711c4ab8c443184ac833ab00f\\r\\n\"\n                b\"Content-Disposition: form-data; \"\n                b'name=\"value\"\\r\\n\\r\\n'\n                b\"Transf\\xc3\\xa9rer\\r\\n\"\n                b\"--20b303e711c4ab8c443184ac833ab00f--\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; charset=utf-8; boundary=20b303e711c4ab8c443184ac833ab00f\"},\n        )\n        assert response.json() == {\"value\": \"Transf\u00e9rer\"}\n\n\ndef test_urlencoded_request_data() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\"/form\", data={\"some\": \"data\"})\n        assert response.json() == {\"some\": \"data\"}\n\n\ndef test_no_request_data() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\"/form\")\n        assert response.json() == {}\n\n\ndef test_urlencoded_percent_encoding() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\"/form\", data={\"some\": \"da ta\"})\n        assert response.json() == {\"some\": \"da ta\"}\n\n\ndef test_urlencoded_percent_encoding_keys() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\"/form\", data={\"so me\": \"data\"})\n        assert response.json() == {\"so me\": \"data\"}\n\n\ndef test_postman_multipart_form_data() -> None:\n    postman_body = b'----------------------------850116600781883365617864\\r\\nContent-Disposition: form-data; name=\"attributes\"; filename=\"test-attribute_5.tsv\"\\r\\nContent-Type: text/tab-separated-values\\r\\n\\r\\n\"Campaign ID\"\\t\"Plate Set ID\"\\t\"No\"\\n\\r\\n----------------------------850116600781883365617864\\r\\nContent-Disposition: form-data; name=\"fasta\"; filename=\"test-sequence_correct_5.fasta\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n>P23G01_IgG1-1411:H:Q10C3:1/1:NID18\\r\\nCAGGTATTGAA\\r\\n\\r\\n----------------------------850116600781883365617864--\\r\\n'  # noqa: E501\n    postman_headers = {\n        \"Content-Type\": \"multipart/form-data; boundary=--------------------------850116600781883365617864\",  # noqa: E501\n        \"user-agent\": \"PostmanRuntime/7.26.0\",\n        \"accept\": \"*/*\",\n        \"cache-control\": \"no-cache\",\n        \"host\": \"10.0.5.13:80\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"connection\": \"keep-alive\",\n        \"content-length\": \"2455\",\n    }\n\n    with create_test_client(form_handler) as client:\n        response = client.post(\"/form\", content=postman_body, headers=postman_headers)\n        assert response.json() == {\n            \"attributes\": {\n                \"filename\": \"test-attribute_5.tsv\",\n                \"content\": '\"Campaign ID\"\\t\"Plate Set ID\"\\t\"No\"\\n',\n                \"content_type\": \"text/tab-separated-values\",\n            },\n            \"fasta\": {\n                \"filename\": \"test-sequence_correct_5.fasta\",\n                \"content\": \">P23G01_IgG1-1411:H:Q10C3:1/1:NID18\\r\\nCAGGTATTGAA\\r\\n\",\n                \"content_type\": \"application/octet-stream\",\n            },\n        }\n\n\ndef test_image_upload() -> None:\n    @post(\"/\")\n    async def hello_world(data: UploadFile = Body(media_type=RequestEncodingType.MULTI_PART)) -> None:\n        await data.read()\n\n    with open(join(dirname(realpath(__file__)), \"flower.jpeg\"), \"rb\") as f, create_test_client(\n        route_handlers=[hello_world]\n    ) as client:\n        data = f.read()\n        response = client.post(\"/\", files={\"data\": data})\n        assert response.status_code == HTTP_201_CREATED\n\n\ndef test_optional_formdata() -> None:\n    @post(\"/\")\n    async def hello_world(data: Optional[UploadFile] = Body(media_type=RequestEncodingType.MULTI_PART)) -> None:\n        if data is not None:\n            await data.read()\n\n    with create_test_client(route_handlers=[hello_world]) as client:\n        response = client.post(\"/\")\n        assert response.status_code == HTTP_201_CREATED\n"], "fixing_code": ["from datetime import date, datetime, time, timedelta\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Dict, List, Optional, Type, Union, cast\n\nfrom pydantic_openapi_schema import construct_open_api_with_schema_class\nfrom typing_extensions import TypedDict\n\nfrom starlite.asgi import ASGIRouter\nfrom starlite.asgi.utils import get_route_handlers, wrap_in_exception_handler\nfrom starlite.config import AllowedHostsConfig, AppConfig, CacheConfig, OpenAPIConfig\nfrom starlite.config.logging import LoggingConfig, get_logger_placeholder\nfrom starlite.connection import Request, WebSocket\nfrom starlite.datastructures.state import State\nfrom starlite.exceptions import (\n    ImproperlyConfiguredException,\n    NoRouteMatchFoundException,\n)\nfrom starlite.handlers.http import HTTPRouteHandler\nfrom starlite.middleware.cors import CORSMiddleware\nfrom starlite.openapi.path_item import create_path_item\nfrom starlite.router import Router\nfrom starlite.routes import ASGIRoute, HTTPRoute, WebSocketRoute\nfrom starlite.signature import create_signature_model\nfrom starlite.types import Empty\nfrom starlite.types.internal_types import PathParameterDefinition\nfrom starlite.utils import (\n    as_async_callable_list,\n    async_partial,\n    is_async_callable,\n    join_paths,\n    unique,\n)\n\nif TYPE_CHECKING:\n    from pydantic_openapi_schema.v3_1_0 import SecurityRequirement\n    from pydantic_openapi_schema.v3_1_0.open_api import OpenAPI\n\n    from starlite.config import (\n        BaseLoggingConfig,\n        CompressionConfig,\n        CORSConfig,\n        CSRFConfig,\n        StaticFilesConfig,\n        TemplateConfig,\n    )\n    from starlite.datastructures import CacheControlHeader, ETag, Provide\n    from starlite.handlers.base import BaseRouteHandler\n    from starlite.plugins.base import PluginProtocol\n    from starlite.types import (\n        AfterExceptionHookHandler,\n        AfterRequestHookHandler,\n        AfterResponseHookHandler,\n        ASGIApp,\n        BeforeMessageSendHookHandler,\n        BeforeRequestHookHandler,\n        ControllerRouterHandler,\n        EmptyType,\n        ExceptionHandlersMap,\n        Guard,\n        LifeSpanHandler,\n        LifeSpanHookHandler,\n        LifeSpanReceive,\n        LifeSpanScope,\n        LifeSpanSend,\n        Logger,\n        Message,\n        Middleware,\n        OnAppInitHandler,\n        ParametersMap,\n        Receive,\n        ResponseCookies,\n        ResponseHeadersMap,\n        ResponseType,\n        RouteHandlerType,\n        Scope,\n        Send,\n        SingleOrList,\n        TypeEncodersMap,\n    )\n    from starlite.types.callable_types import AnyCallable, GetLogger\n    from starlite.types.composite_types import InitialStateType\n\nDEFAULT_OPENAPI_CONFIG = OpenAPIConfig(title=\"Starlite API\", version=\"1.0.0\")\n\"\"\"The default OpenAPI config used if not configuration is explicitly passed to the :class:`Starlite\n<starlite.app.Starlite>` instance constructor.\n\"\"\"\nDEFAULT_CACHE_CONFIG = CacheConfig()\n\"\"\"The default cache config used if not configuration is explicitly passed to the :class:`Starlite\n<starlite.app.Starlite>` instance constructor.\n\"\"\"\n\n\nclass HandlerIndex(TypedDict):\n    \"\"\"Map route handler names to a mapping of paths + route handler.\n\n    It's returned from the 'get_handler_index_by_name' utility method.\n    \"\"\"\n\n    paths: List[str]\n    \"\"\"Full route paths to the route handler.\"\"\"\n    handler: \"RouteHandlerType\"\n    \"\"\"Route handler instance.\"\"\"\n    identifier: str\n    \"\"\"Unique identifier of the handler.\n\n    Either equal to the 'name' attribute or the ``__str__`` value of the handler.\n    \"\"\"\n\n\nclass Starlite(Router):\n    \"\"\"The Starlite application.\n\n    ``Starlite`` is the root level of the app - it has the base path of \"/\" and all root level\n    Controllers, Routers and Route Handlers should be registered on it.\n\n    Inherits from the :class:`Router <starlite.router.Router>` class\n    \"\"\"\n\n    __slots__ = (\n        \"after_exception\",\n        \"after_shutdown\",\n        \"after_startup\",\n        \"allowed_hosts\",\n        \"asgi_handler\",\n        \"asgi_router\",\n        \"before_send\",\n        \"before_shutdown\",\n        \"before_startup\",\n        \"cache\",\n        \"compression_config\",\n        \"cors_config\",\n        \"csrf_config\",\n        \"debug\",\n        \"get_logger\",\n        \"logger\",\n        \"logging_config\",\n        \"multipart_form_part_limit\",\n        \"on_shutdown\",\n        \"on_startup\",\n        \"openapi_config\",\n        \"openapi_schema\",\n        \"plugins\",\n        \"request_class\",\n        \"route_map\",\n        \"state\",\n        \"static_files_config\",\n        \"template_engine\",\n        \"websocket_class\",\n    )\n\n    def __init__(\n        self,\n        route_handlers: List[\"ControllerRouterHandler\"],\n        *,\n        after_exception: Optional[\"SingleOrList[AfterExceptionHookHandler]\"] = None,\n        after_request: Optional[\"AfterRequestHookHandler\"] = None,\n        after_response: Optional[\"AfterResponseHookHandler\"] = None,\n        after_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n        after_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n        allowed_hosts: Optional[Union[List[str], \"AllowedHostsConfig\"]] = None,\n        before_request: Optional[\"BeforeRequestHookHandler\"] = None,\n        before_send: Optional[\"SingleOrList[BeforeMessageSendHookHandler]\"] = None,\n        before_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n        before_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n        cache_config: CacheConfig = DEFAULT_CACHE_CONFIG,\n        cache_control: Optional[\"CacheControlHeader\"] = None,\n        compression_config: Optional[\"CompressionConfig\"] = None,\n        cors_config: Optional[\"CORSConfig\"] = None,\n        csrf_config: Optional[\"CSRFConfig\"] = None,\n        debug: bool = False,\n        dependencies: Optional[Dict[str, \"Provide\"]] = None,\n        etag: Optional[\"ETag\"] = None,\n        exception_handlers: Optional[\"ExceptionHandlersMap\"] = None,\n        guards: Optional[List[\"Guard\"]] = None,\n        initial_state: Optional[\"InitialStateType\"] = None,\n        logging_config: Union[\"BaseLoggingConfig\", \"EmptyType\", None] = Empty,\n        middleware: Optional[List[\"Middleware\"]] = None,\n        multipart_form_part_limit: int = 1000,\n        on_app_init: Optional[List[\"OnAppInitHandler\"]] = None,\n        on_shutdown: Optional[List[\"LifeSpanHandler\"]] = None,\n        on_startup: Optional[List[\"LifeSpanHandler\"]] = None,\n        openapi_config: Optional[OpenAPIConfig] = DEFAULT_OPENAPI_CONFIG,\n        opt: Optional[Dict[str, Any]] = None,\n        parameters: Optional[\"ParametersMap\"] = None,\n        plugins: Optional[List[\"PluginProtocol\"]] = None,\n        request_class: Optional[Type[\"Request\"]] = None,\n        response_class: Optional[\"ResponseType\"] = None,\n        response_cookies: Optional[\"ResponseCookies\"] = None,\n        response_headers: Optional[\"ResponseHeadersMap\"] = None,\n        security: Optional[List[\"SecurityRequirement\"]] = None,\n        static_files_config: Optional[Union[\"StaticFilesConfig\", List[\"StaticFilesConfig\"]]] = None,\n        tags: Optional[List[str]] = None,\n        template_config: Optional[\"TemplateConfig\"] = None,\n        type_encoders: Optional[\"TypeEncodersMap\"] = None,\n        websocket_class: Optional[Type[\"WebSocket\"]] = None,\n    ) -> None:\n        \"\"\"Initialize a ``Starlite`` application.\n\n        Args:\n            after_exception: An application level :class:`exception hook handler <starlite.types.AfterExceptionHookHandler>`\n                or list thereof.This hook is called after an exception occurs. In difference to exception handlers,\n                it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.).\n            after_request: A sync or async function executed after the route handler function returned and the response\n                object has been resolved. Receives the response object.\n            after_response: A sync or async function called after the response has been awaited. It receives the\n                :class:`Request <starlite.connection.Request>` object and should not return any values.\n            after_shutdown: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or\n                list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown'\n                list have been called.\n            after_startup: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or\n                list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup'\n                list have been called.\n            allowed_hosts: A list of allowed hosts - enables the builtin allowed hosts middleware.\n            before_request: A sync or async function called immediately before calling the route handler.\n                Receives the :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is\n                used for the response, bypassing the route handler.\n            before_send: An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or\n                list thereof. This hook is called when the ASGI send function is called.\n            before_shutdown: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or\n                list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown'\n                list have been called.\n            before_startup: An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or\n                list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup'\n                list have been called.\n            cache_config: Configures caching behavior of the application.\n            cache_control: A ``cache-control`` header of type\n                :class:`CacheControlHeader <starlite.datastructures.CacheControlHeader>` to add to route handlers of this app.\n                Can be overridden by route handlers.\n            compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n                defined Compression middleware.\n            cors_config: If set this enables the builtin CORS middleware.\n            csrf_config: If set this enables the builtin CSRF middleware.\n            debug: If ``True``, app errors rendered as HTML with a stack trace.\n            dependencies: A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.\n            etag: An ``etag`` header of type :class:`ETag <datastructures.ETag>` to add to route handlers of this app.\n                Can be overridden by route handlers.\n            exception_handlers: A dictionary that maps handler functions to status codes and/or exception types.\n            guards: A list of :class:`Guard <starlite.types.Guard>` callables.\n            initial_state: An object from which to initialize the app state.\n            logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`.\n            middleware: A list of :class:`Middleware <starlite.types.Middleware>`.\n            multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request.\n                This limit is intended to protect from DoS attacks.\n            on_app_init: A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive\n                an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with\n                the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more\n                than one handler is registered they are called in the order they are provided.\n            on_shutdown: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during\n                application shutdown.\n            on_startup: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during\n                application startup.\n            openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`\n            opt: A string keyed dictionary of arbitrary values that can be accessed in :class:`Guards <starlite.types.Guard>` or wherever you\n                have access to :class:`Request <starlite.connection.request.Request>` or :class:`ASGI Scope <starlite.types.Scope>`.\n            parameters: A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all\n                application paths.\n            plugins: List of plugins.\n            request_class: An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for\n                http connections.\n            response_class: A custom subclass of [starlite.response.Response] to be used as the app's default response.\n            response_cookies: A list of [Cookie](starlite.datastructures.Cookie] instances.\n            response_headers: A string keyed dictionary mapping :class:`ResponseHeader <starlite.datastructures.ResponseHeader>`\n                instances.\n            route_handlers: A required list of route handlers, which can include instances of\n                :class:`Router <starlite.router.Router>`, subclasses of :class:`Controller <starlite.controller.Controller>` or\n                any function decorated by the route handler decorators.\n            security: A list of dictionaries that will be added to the schema of all route handlers in the application.\n                See :class:`SecurityRequirement <pydantic_openapi_schema.v3_1_0.security_requirement.SecurityRequirement>` for details.\n            static_files_config: An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`\n            tags: A list of string tags that will be appended to the schema of all route handlers under the application.\n            template_config: An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`\n            type_encoders: A mapping of types to callables that transform them into types supported for serialization.\n            websocket_class: An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for\n                websocket connections.\n        \"\"\"\n        self.openapi_schema: Optional[\"OpenAPI\"] = None\n        self.get_logger: \"GetLogger\" = get_logger_placeholder\n        self.logger: Optional[\"Logger\"] = None\n        self.routes: List[Union[\"HTTPRoute\", \"ASGIRoute\", \"WebSocketRoute\"]] = []\n        self.asgi_router = ASGIRouter(app=self)\n\n        config = AppConfig(\n            after_exception=after_exception or [],\n            after_request=after_request,\n            after_response=after_response,\n            after_shutdown=after_shutdown or [],\n            after_startup=after_startup or [],\n            allowed_hosts=allowed_hosts or [],\n            before_request=before_request,\n            before_send=before_send or [],\n            before_shutdown=before_shutdown or [],\n            before_startup=before_startup or [],\n            cache_config=cache_config,\n            cache_control=cache_control,\n            compression_config=compression_config,\n            cors_config=cors_config,\n            csrf_config=csrf_config,\n            debug=debug,\n            dependencies=dependencies or {},\n            etag=etag,\n            exception_handlers=exception_handlers or {},\n            guards=guards or [],\n            initial_state=initial_state or {},\n            logging_config=logging_config if logging_config is not Empty else LoggingConfig() if debug else None,  # type: ignore[arg-type]\n            middleware=middleware or [],\n            multipart_form_part_limit=multipart_form_part_limit,\n            on_shutdown=on_shutdown or [],\n            on_startup=on_startup or [],\n            openapi_config=openapi_config,\n            opt=opt or {},\n            parameters=parameters or {},\n            plugins=plugins or [],\n            request_class=request_class,\n            response_class=response_class,\n            response_cookies=response_cookies or [],\n            response_headers=response_headers or {},\n            route_handlers=route_handlers,\n            security=security or [],\n            static_files_config=static_files_config or [],\n            tags=tags or [],\n            template_config=template_config,\n            type_encoders=type_encoders,\n            websocket_class=websocket_class,\n        )\n        for handler in on_app_init or []:\n            config = handler(config)\n\n        self.allowed_hosts = cast(\"Optional[AllowedHostsConfig]\", config.allowed_hosts)\n        self.after_exception = as_async_callable_list(config.after_exception)\n        self.after_shutdown = as_async_callable_list(config.after_shutdown)\n        self.after_startup = as_async_callable_list(config.after_startup)\n        self.before_send = as_async_callable_list(config.before_send)\n        self.before_shutdown = as_async_callable_list(config.before_shutdown)\n        self.before_startup = as_async_callable_list(config.before_startup)\n        self.cache = config.cache_config.to_cache()\n        self.compression_config = config.compression_config\n        self.cors_config = config.cors_config\n        self.csrf_config = config.csrf_config\n        self.debug = config.debug\n        self.logging_config = config.logging_config\n        self.on_shutdown = config.on_shutdown\n        self.on_startup = config.on_startup\n        self.openapi_config = config.openapi_config\n        self.plugins = config.plugins\n        self.request_class = config.request_class or Request\n        self.state = State(config.initial_state, deep_copy=True)\n        self.static_files_config = config.static_files_config\n        self.template_engine = config.template_config.engine_instance if config.template_config else None\n        self.websocket_class = config.websocket_class or WebSocket\n        self.multipart_form_part_limit = config.multipart_form_part_limit\n\n        super().__init__(\n            after_request=config.after_request,\n            after_response=config.after_response,\n            before_request=config.before_request,\n            cache_control=config.cache_control,\n            dependencies=config.dependencies,\n            etag=config.etag,\n            exception_handlers=config.exception_handlers,\n            guards=config.guards,\n            middleware=config.middleware,\n            opt=config.opt,\n            parameters=config.parameters,\n            path=\"\",\n            response_class=config.response_class,\n            response_cookies=config.response_cookies,\n            response_headers=config.response_headers,\n            # route handlers are registered below\n            route_handlers=[],\n            security=config.security,\n            tags=config.tags,\n            type_encoders=config.type_encoders,\n        )\n        for plugin in self.plugins:\n            plugin.on_app_init(app=self)\n\n        for route_handler in config.route_handlers:\n            self.register(route_handler)\n\n        if self.debug and isinstance(self.logging_config, LoggingConfig):\n            self.logging_config.loggers[\"starlite\"][\"level\"] = \"DEBUG\"\n\n        if self.logging_config:\n            self.get_logger = self.logging_config.configure()\n            self.logger = self.get_logger(\"starlite\")\n\n        if self.openapi_config:\n            self.openapi_schema = self.openapi_config.to_openapi_schema()\n            self.update_openapi_schema()\n            self.register(self.openapi_config.openapi_controller)\n\n        for static_config in (\n            self.static_files_config if isinstance(self.static_files_config, list) else [self.static_files_config]\n        ):\n            self.register(static_config.to_static_files_app())\n\n        self.asgi_handler = self._create_asgi_handler()\n\n    async def __call__(\n        self,\n        scope: Union[\"Scope\", \"LifeSpanScope\"],\n        receive: Union[\"Receive\", \"LifeSpanReceive\"],\n        send: Union[\"Send\", \"LifeSpanSend\"],\n    ) -> None:\n        \"\"\"Application entry point.\n\n        Lifespan events (startup / shutdown) are sent to the lifespan handler, otherwise the ASGI handler is used\n\n        Args:\n            scope: The ASGI connection scope.\n            receive: The ASGI receive function.\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\n        scope[\"app\"] = self\n        if scope[\"type\"] == \"lifespan\":\n            await self.asgi_router.lifespan(receive=receive, send=send)  # type: ignore[arg-type]\n            return\n        scope[\"state\"] = {}\n        await self.asgi_handler(scope, receive, self._wrap_send(send=send, scope=scope))  # type: ignore[arg-type]\n\n    def register(self, value: \"ControllerRouterHandler\", add_to_openapi_schema: bool = False) -> None:  # type: ignore[override]\n        \"\"\"Register a route handler on the app.\n\n        This method can be used to dynamically add endpoints to an application.\n\n        Args:\n            value: an instance of :class:`Router <starlite.router.Router>`, a subclass of\n                :class:`Controller <starlite.controller.Controller>` or any function decorated by the route handler decorators.\n            add_to_openapi_schema: Whether to add the registered route to the OpenAPI Schema. This affects only HTTP route\n                handlers.\n\n        Returns:\n            None\n        \"\"\"\n        routes = super().register(value=value)\n\n        should_add_to_openapi_schema = False\n\n        for route in routes:\n            route_handlers = get_route_handlers(route)\n\n            for route_handler in route_handlers:\n                self._create_handler_signature_model(route_handler=route_handler)\n                self._set_runtime_callables(route_handler=route_handler)\n                route_handler.resolve_guards()\n                route_handler.resolve_middleware()\n                route_handler.resolve_opts()\n\n                if isinstance(route_handler, HTTPRouteHandler):\n                    route_handler.resolve_before_request()\n                    route_handler.resolve_after_response()\n                    route_handler.resolve_response_handler()\n                    should_add_to_openapi_schema = add_to_openapi_schema\n\n            if isinstance(route, HTTPRoute):\n                route.create_handler_map()\n\n            elif isinstance(route, WebSocketRoute):\n                route.handler_parameter_model = route.create_handler_kwargs_model(route.route_handler)\n\n        self.asgi_router.construct_routing_trie()\n\n        if should_add_to_openapi_schema:\n            self.update_openapi_schema()\n\n    def get_handler_index_by_name(self, name: str) -> Optional[HandlerIndex]:\n        \"\"\"Receives a route handler name and returns an optional dictionary containing the route handler instance and\n        list of paths sorted lexically.\n\n        Examples:\n            .. code-block: python\n\n                from starlite import Starlite, get\n\n\n                @get(\"/\", name=\"my-handler\")\n                def handler() -> None:\n                    pass\n\n\n                app = Starlite(route_handlers=[handler])\n\n                handler_index = app.get_handler_index_by_name(\"my-handler\")\n\n                # { \"paths\": [\"/\"], \"handler\" ... }\n\n        Args:\n            name: A route handler unique name.\n\n        Returns:\n            A :class:`HandlerIndex <starlite.app.HandlerIndex>` instance or None.\n        \"\"\"\n        handler = self.asgi_router.route_handler_index.get(name)\n        if not handler:\n            return None\n\n        identifier = handler.name or str(handler)\n        routes = self.asgi_router.route_mapping[identifier]\n        paths = sorted(unique([route.path for route in routes]))\n\n        return HandlerIndex(handler=handler, paths=paths, identifier=identifier)\n\n    def route_reverse(self, name: str, **path_parameters: Any) -> str:\n        \"\"\"Receives a route handler name, path parameter values and returns url path to the handler with filled path\n        parameters.\n\n        Examples:\n            .. code-block: python\n\n                from starlite import Starlite, get\n\n\n                @get(\"/group/{group_id:int}/user/{user_id:int}\", name=\"get_membership_details\")\n                def get_membership_details(group_id: int, user_id: int) -> None:\n                    pass\n\n\n                app = Starlite(route_handlers=[get_membership_details])\n\n                path = app.route_reverse(\"get_membership_details\", user_id=100, group_id=10)\n\n                # /group/10/user/100\n\n        Args:\n            name: A route handler unique name.\n            **path_parameters: Actual values for path parameters in the route.\n\n        Raises:\n            NoRouteMatchFoundException: If route with 'name' does not exist, path parameters are missing in\n                ``**path_parameters or have wrong type``.\n\n        Returns:\n            A fully formatted url path.\n        \"\"\"\n        handler_index = self.get_handler_index_by_name(name)\n        if handler_index is None:\n            raise NoRouteMatchFoundException(f\"Route {name} can not be found\")\n\n        allow_str_instead = {datetime, date, time, timedelta, float, Path}\n        output: List[str] = []\n\n        routes = sorted(\n            self.asgi_router.route_mapping[handler_index[\"identifier\"]],\n            key=lambda r: len(r.path_parameters),\n            reverse=True,\n        )\n        passed_parameters = set(path_parameters.keys())\n\n        selected_route = routes[-1]\n        for route in routes:\n            if passed_parameters.issuperset({param.name for param in route.path_parameters}):\n                selected_route = route\n                break\n\n        for component in selected_route.path_components:\n            if isinstance(component, PathParameterDefinition):\n                val = path_parameters.get(component.name)\n                if not (\n                    isinstance(val, component.type) or (component.type in allow_str_instead and isinstance(val, str))\n                ):\n                    raise NoRouteMatchFoundException(\n                        f\"Received type for path parameter {component.name} doesn't match declared type {component.type}\"\n                    )\n                output.append(str(val))\n            else:\n                output.append(component)\n\n        return join_paths(output)\n\n    def url_for_static_asset(self, name: str, file_path: str) -> str:\n        \"\"\"Receives a static files handler name, an asset file path and returns resolved url path to the asset.\n\n        Examples:\n            .. code-block: python\n\n                from starlite import Starlite, StaticFilesConfig\n\n                app = Starlite(\n                    static_files_config=StaticFilesConfig(directories=[\"css\"], path=\"/static/css\")\n                )\n\n                path = app.url_for_static_asset(\"css\", \"main.css\")\n\n                # /static/css/main.css\n\n        Args:\n            name: A static handler unique name.\n            file_path: a string containing path to an asset.\n\n        Raises:\n            NoRouteMatchFoundException: If static files handler with 'name' does not exist.\n\n        Returns:\n            A url path to the asset.\n        \"\"\"\n        from starlite.static_files.base import StaticFiles\n\n        handler_index = self.get_handler_index_by_name(name)\n        if handler_index is None:\n            raise NoRouteMatchFoundException(f\"Static handler {name} can not be found\")\n\n        handler_fn = cast(\"AnyCallable\", handler_index[\"handler\"].fn.value)\n        if not isinstance(handler_fn, StaticFiles):\n            raise NoRouteMatchFoundException(f\"Handler with name {name} is not a static files handler\")\n\n        return join_paths([handler_index[\"paths\"][0], file_path])  # type: ignore[unreachable]\n\n    @property\n    def route_handler_method_view(self) -> Dict[str, List[str]]:\n        \"\"\"Map route handlers to paths.\n\n        Returns:\n            A dictionary of router handlers and lists of paths as strings\n        \"\"\"\n        route_map: Dict[str, List[str]] = {}\n        for handler, routes in self.asgi_router.route_mapping.items():\n            route_map[handler] = [route.path for route in routes]\n\n        return route_map\n\n    def _create_asgi_handler(self) -> \"ASGIApp\":\n        \"\"\"Create an ASGIApp that wraps the ASGI router inside an exception handler.\n\n        If CORS or TrustedHost configs are provided to the constructor, they will wrap the router as well.\n        \"\"\"\n        asgi_handler: \"ASGIApp\" = self.asgi_router\n        if self.cors_config:\n            asgi_handler = CORSMiddleware(app=asgi_handler, config=self.cors_config)\n\n        return wrap_in_exception_handler(\n            debug=self.debug, app=asgi_handler, exception_handlers=self.exception_handlers or {}\n        )\n\n    @staticmethod\n    def _set_runtime_callables(route_handler: \"BaseRouteHandler\") -> None:\n        \"\"\"Optimize the route_handler.fn and any provider.dependency callables for runtime by doing the following:\n\n        1. ensure that the ``self`` argument is preserved by binding it using partial.\n        2. ensure sync functions are wrapped in AsyncCallable for sync_to_thread handlers.\n\n        Args:\n            route_handler: A route handler to process.\n\n        Returns:\n            None\n        \"\"\"\n        from starlite.controller import Controller\n\n        if isinstance(route_handler.owner, Controller) and not hasattr(route_handler.fn.value, \"func\"):\n            route_handler.fn.value = partial(route_handler.fn.value, route_handler.owner)\n\n        if isinstance(route_handler, HTTPRouteHandler):\n            route_handler.has_sync_callable = False\n            if not is_async_callable(route_handler.fn.value):\n                if route_handler.sync_to_thread:\n                    route_handler.fn.value = async_partial(route_handler.fn.value)\n                else:\n                    route_handler.has_sync_callable = True\n\n        for provider in route_handler.resolve_dependencies().values():\n            if not is_async_callable(provider.dependency.value):\n                provider.has_sync_callable = False\n                if provider.sync_to_thread:\n                    provider.dependency.value = async_partial(provider.dependency.value)\n                else:\n                    provider.has_sync_callable = True\n\n    def _create_handler_signature_model(self, route_handler: \"BaseRouteHandler\") -> None:\n        \"\"\"Create function signature models for all route handler functions and provider dependencies.\"\"\"\n        if not route_handler.signature_model:\n            route_handler.signature_model = create_signature_model(\n                fn=cast(\"AnyCallable\", route_handler.fn.value),\n                plugins=self.plugins,\n                dependency_name_set=route_handler.dependency_name_set,\n            )\n\n        for provider in route_handler.resolve_dependencies().values():\n            if not getattr(provider, \"signature_model\", None):\n                provider.signature_model = create_signature_model(\n                    fn=provider.dependency.value,\n                    plugins=self.plugins,\n                    dependency_name_set=route_handler.dependency_name_set,\n                )\n\n    def _wrap_send(self, send: \"Send\", scope: \"Scope\") -> \"Send\":\n        \"\"\"Wrap the ASGI send and handles any 'before send' hooks.\n\n        Args:\n            send: The ASGI send function.\n\n        Returns:\n            An ASGI send function.\n        \"\"\"\n        if self.before_send:\n\n            async def wrapped_send(message: \"Message\") -> None:\n                for hook in self.before_send:\n                    if hook.num_expected_args > 2:\n                        await hook(message, self.state, scope)\n                    else:\n                        await hook(message, self.state)\n                await send(message)\n\n            return wrapped_send\n        return send\n\n    def update_openapi_schema(self) -> None:\n        \"\"\"Update the OpenAPI schema to reflect the route handlers registered on the app.\n\n        Returns:\n            None\n        \"\"\"\n        if not self.openapi_config or not self.openapi_schema or self.openapi_schema.paths is None:\n            raise ImproperlyConfiguredException(\"Cannot generate OpenAPI schema without initializing an OpenAPIConfig\")\n\n        for route in self.routes:\n            if (\n                isinstance(route, HTTPRoute)\n                and any(route_handler.include_in_schema for route_handler, _ in route.route_handler_map.values())\n                and (route.path_format or \"/\") not in self.openapi_schema.paths\n            ):\n                self.openapi_schema.paths[route.path_format or \"/\"] = create_path_item(\n                    route=route,\n                    create_examples=self.openapi_config.create_examples,\n                    plugins=self.plugins,\n                    use_handler_docstrings=self.openapi_config.use_handler_docstrings,\n                )\n        self.openapi_schema = construct_open_api_with_schema_class(\n            open_api_schema=self.openapi_schema, by_alias=self.openapi_config.by_alias\n        )\n", "from typing import Any, Dict, List, Optional, Type, Union\n\nfrom pydantic import BaseConfig, BaseModel, validator\nfrom pydantic_openapi_schema.v3_1_0 import SecurityRequirement\n\nfrom starlite.connection import Request, WebSocket\nfrom starlite.datastructures import CacheControlHeader, ETag, Provide\nfrom starlite.plugins.base import PluginProtocol\nfrom starlite.types import (\n    AfterExceptionHookHandler,\n    AfterRequestHookHandler,\n    AfterResponseHookHandler,\n    BeforeMessageSendHookHandler,\n    BeforeRequestHookHandler,\n    ControllerRouterHandler,\n    ExceptionHandlersMap,\n    Guard,\n    LifeSpanHandler,\n    LifeSpanHookHandler,\n    Middleware,\n    ParametersMap,\n    ResponseCookies,\n    ResponseHeadersMap,\n    ResponseType,\n    SingleOrList,\n    TypeEncodersMap,\n)\nfrom starlite.types.composite_types import InitialStateType\n\nfrom . import AllowedHostsConfig\nfrom .cache import CacheConfig\nfrom .compression import CompressionConfig\nfrom .cors import CORSConfig\nfrom .csrf import CSRFConfig\nfrom .logging import BaseLoggingConfig\nfrom .openapi import OpenAPIConfig\nfrom .static_files import StaticFilesConfig\nfrom .template import TemplateConfig\n\n\nclass AppConfig(BaseModel):\n    \"\"\"The parameters provided to the ``Starlite`` app are used to instantiate an instance, and then the instance is\n    passed to any callbacks registered to ``on_app_init`` in the order they are provided.\n\n    The final attribute values are used to instantiate the application object.\n    \"\"\"\n\n    class Config(BaseConfig):\n        arbitrary_types_allowed = True\n\n    after_exception: SingleOrList[AfterExceptionHookHandler]\n    \"\"\"An application level :class:`exception hook handler <starlite.types.AfterExceptionHookHandler>` or list thereof.\n\n    This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a\n    response - only to process the exception (e.g. log it, send it to Sentry etc.).\n    \"\"\"\n    after_request: Optional[AfterRequestHookHandler]\n    \"\"\"A sync or async function executed after the route handler function returned and the response object has been\n    resolved.\n\n    Receives the response object which may be any subclass of :class:`Response <starlite.response.Response>`.\n    \"\"\"\n    after_response: Optional[AfterResponseHookHandler]\n    \"\"\"A sync or async function called after the response has been awaited. It receives the.\n\n    :class:`Request <starlite.connection.Request>` object and should not return any values.\n    \"\"\"\n    after_shutdown: SingleOrList[LifeSpanHookHandler]\n    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.\n\n    This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called.\n    \"\"\"\n    after_startup: SingleOrList[LifeSpanHookHandler]\n    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.\n\n    This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called.\n    \"\"\"\n    allowed_hosts: Optional[Union[List[str], AllowedHostsConfig]]\n    \"\"\"If set enables the builtin allowed hosts middleware.\"\"\"\n    before_request: Optional[BeforeRequestHookHandler]\n    \"\"\"A sync or async function called immediately before calling the route handler. Receives the.\n\n    :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is used for the response, bypassing\n    the route handler.\n    \"\"\"\n    before_send: SingleOrList[BeforeMessageSendHookHandler]\n    \"\"\"An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or list thereof.\n\n    This hook is called when the ASGI send function is called.\n    \"\"\"\n    before_shutdown: SingleOrList[LifeSpanHookHandler]\n    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.\n\n    This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called.\n    \"\"\"\n    before_startup: SingleOrList[LifeSpanHookHandler]\n    \"\"\"An application level :class:`life-span hook handler <starlite.types.LifeSpanHookHandler>` or list thereof.\n\n    This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called.\n    \"\"\"\n    cache_config: CacheConfig\n    \"\"\"Configures caching behavior of the application.\"\"\"\n    cache_control: Optional[CacheControlHeader]\n    \"\"\"A ``cache-control`` header of type :class:`CacheControlHeader <starlite.datastructures.CacheControlHeader>` to add to route\n    handlers of this app.\n\n    Can be overridden by route handlers.\n    \"\"\"\n    compression_config: Optional[CompressionConfig]\n    \"\"\"Configures compression behaviour of the application, this enabled a builtin or user defined Compression\n    middleware.\n    \"\"\"\n    cors_config: Optional[CORSConfig]\n    \"\"\"If set this enables the builtin CORS middleware.\"\"\"\n    csrf_config: Optional[CSRFConfig]\n    \"\"\"If set this enables the builtin CSRF middleware.\"\"\"\n    debug: bool\n    \"\"\"If ``True``, app errors rendered as HTML with a stack trace.\"\"\"\n    dependencies: Dict[str, Provide]\n    \"\"\"A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.\"\"\"\n    etag: Optional[ETag]\n    \"\"\"An ``etag`` header of type :class:`ETag <starlite.datastructures.ETag>` to add to route handlers of this app.\n\n    Can be overridden by route handlers.\n    \"\"\"\n    exception_handlers: ExceptionHandlersMap\n    \"\"\"A dictionary that maps handler functions to status codes and/or exception types.\"\"\"\n    guards: List[Guard]\n    \"\"\"A list of :class:`Guard <starlite.types.Guard>` callables.\"\"\"\n    initial_state: InitialStateType\n    \"\"\"An object from which to initialize the app state.\"\"\"\n    logging_config: Optional[BaseLoggingConfig]\n    \"\"\"An instance of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>` subclass.\"\"\"\n    middleware: List[Middleware]\n    \"\"\"A list of :class:`Middleware <starlite.types.Middleware>`.\"\"\"\n    on_shutdown: List[LifeSpanHandler]\n    \"\"\"A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during application shutdown.\"\"\"\n    on_startup: List[LifeSpanHandler]\n    \"\"\"A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during application startup.\"\"\"\n    openapi_config: Optional[OpenAPIConfig]\n    \"\"\"Defaults to :data:`DEFAULT_OPENAPI_CONFIG <starlite.app.DEFAULT_OPENAPI_CONFIG>`\"\"\"\n    opt: Dict[str, Any]\n    \"\"\"A string keyed dictionary of arbitrary values that can be accessed in :class:`Guards <starlite.types.Guard>` or\n    wherever you have access to :class:`Request <starlite.connection.request.Request>` or :class:`ASGI Scope <starlite.types.Scope>`.\n\n    Can be overridden by routers and router handlers.\n    \"\"\"\n    parameters: ParametersMap\n    \"\"\"A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all application paths.\"\"\"\n    plugins: List[PluginProtocol]\n    \"\"\"List of :class:`PluginProtocol <starlite.plugins.base.PluginProtocol>`.\"\"\"\n    request_class: Optional[Type[Request]]\n    \"\"\"An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for http connections.\"\"\"\n    response_class: Optional[ResponseType]\n    \"\"\"A custom subclass of [starlite.response.Response] to be used as the app's default response.\"\"\"\n    response_cookies: ResponseCookies\n    \"\"\"A list of [Cookie](starlite.datastructures.Cookie] instances.\"\"\"\n    response_headers: ResponseHeadersMap\n    \"\"\"A string keyed dictionary mapping :class:`ResponseHeader <starlite.datastructures.ResponseHeader>` instances.\"\"\"\n    route_handlers: List[ControllerRouterHandler]\n    \"\"\"A required list of route handlers, which can include instances of :class:`Router <starlite.router.Router>`, subclasses\n    of.\n\n    :class:`Controller <starlite.controller.Controller>` or any function decorated by the route handler decorators.\n    \"\"\"\n    security: List[SecurityRequirement]\n    \"\"\"A list of dictionaries that will be added to the schema of all route handlers in the application. See.\n\n    :class:`SecurityRequirement <pydantic_openapi_schema.v3_1_0.security_requirement.SecurityRequirement>` for details.\n    \"\"\"\n    static_files_config: SingleOrList[StaticFilesConfig]\n    \"\"\"An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`.\"\"\"\n    tags: List[str]\n    \"\"\"A list of string tags that will be appended to the schema of all route handlers under the application.\"\"\"\n    template_config: Optional[TemplateConfig]\n    \"\"\"An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`.\"\"\"\n    type_encoders: Optional[TypeEncodersMap] = None\n    \"\"\"A mapping of types to callables that transform them into types supported for serialization.\"\"\"\n    websocket_class: Optional[Type[WebSocket]]\n    \"\"\"An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for websocket connections.\"\"\"\n    multipart_form_part_limit: int\n    \"\"\"The maximal number of allowed parts in a multipart/formdata request. This limit is intended to protect from DoS attacks.\"\"\"\n\n    @validator(\"allowed_hosts\", always=True)\n    def validate_allowed_hosts(  # pylint: disable=no-self-argument\n        cls, value: Optional[Union[List[str], AllowedHostsConfig]]\n    ) -> Optional[AllowedHostsConfig]:\n        \"\"\"Normalize the allowed hosts to be a config or None.\n\n        Args:\n            value: Optional a list of hosts or allowed hosts config\n\n        Returns:\n            Optional config.\n        \"\"\"\n        if value:\n            if isinstance(value, list):\n                return AllowedHostsConfig(allowed_hosts=value)\n            return value\n        return None\n", "from typing import TYPE_CHECKING, Any, AsyncGenerator, Dict, Generic, Tuple, cast\n\nfrom starlite.connection.base import (\n    ASGIConnection,\n    Auth,\n    User,\n    empty_receive,\n    empty_send,\n)\nfrom starlite.datastructures.multi_dicts import FormMultiDict\nfrom starlite.enums import RequestEncodingType\nfrom starlite.exceptions import InternalServerException\nfrom starlite.multipart import parse_content_header, parse_multipart_form\nfrom starlite.parsers import parse_url_encoded_form_data\nfrom starlite.types import Empty\nfrom starlite.utils.serialization import decode_json, decode_msgpack\n\nif TYPE_CHECKING:\n    from starlite.handlers.http import HTTPRouteHandler  # noqa: F401\n    from starlite.types.asgi_types import HTTPScope, Method, Receive, Scope, Send\n\n\nSERVER_PUSH_HEADERS = {\n    \"accept\",\n    \"accept-encoding\",\n    \"accept-language\",\n    \"cache-control\",\n    \"user-agent\",\n}\n\n\nclass Request(Generic[User, Auth], ASGIConnection[\"HTTPRouteHandler\", User, Auth]):\n    \"\"\"The Starlite Request class.\"\"\"\n\n    __slots__ = (\"_json\", \"_form\", \"_body\", \"_msgpack\", \"_content_type\", \"is_connected\")\n\n    scope: \"HTTPScope\"\n    \"\"\"The ASGI scope attached to the connection.\"\"\"\n    receive: \"Receive\"\n    \"\"\"The ASGI receive function.\"\"\"\n    send: \"Send\"\n    \"\"\"The ASGI send function.\"\"\"\n\n    def __init__(self, scope: \"Scope\", receive: \"Receive\" = empty_receive, send: \"Send\" = empty_send) -> None:\n        \"\"\"Initialize ``Request``.\n\n        Args:\n            scope: The ASGI connection scope.\n            receive: The ASGI receive function.\n            send: The ASGI send function.\n        \"\"\"\n        super().__init__(scope, receive, send)\n        self.is_connected: bool = True\n        self._body: Any = scope.get(\"_body\", Empty)\n        self._form: Any = scope.get(\"_form\", Empty)\n        self._json: Any = scope.get(\"_json\", Empty)\n        self._msgpack: Any = scope.get(\"_msgpack\", Empty)\n        self._content_type: Any = scope.get(\"_content_type\", Empty)\n\n    @property\n    def method(self) -> \"Method\":\n        \"\"\"Return the request method.\n\n        Returns:\n            The request :class:`Method <starlite.types.Method>`\n        \"\"\"\n        return self.scope[\"method\"]\n\n    @property\n    def content_type(self) -> Tuple[str, Dict[str, str]]:\n        \"\"\"Parse the request's 'Content-Type' header, returning the header value and any options as a dictionary.\n\n        Returns:\n            A tuple with the parsed value and a dictionary containing any options send in it.\n        \"\"\"\n        if self._content_type is Empty:\n            self._content_type = self.scope[\"_content_type\"] = parse_content_header(self.headers.get(\"Content-Type\", \"\"))  # type: ignore[typeddict-item]\n        return cast(\"Tuple[str, Dict[str, str]]\", self._content_type)\n\n    async def json(self) -> Any:\n        \"\"\"Retrieve the json request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\n        if self._json is Empty:\n            body = await self.body()\n            self._json = self.scope[\"_json\"] = decode_json(body or b\"null\")  # type: ignore[typeddict-item]\n        return self._json\n\n    async def msgpack(self) -> Any:\n        \"\"\"Retrieve the MessagePack request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\n        if self._msgpack is Empty:\n            body = await self.body()\n            self._msgpack = self.scope[\"_msgpack\"] = decode_msgpack(body or b\"\\xc0\")  # type: ignore[typeddict-item]\n        return self._msgpack\n\n    async def stream(self) -> AsyncGenerator[bytes, None]:\n        \"\"\"Return an async generator that streams chunks of bytes.\n\n        Returns:\n            An async generator.\n\n        Raises:\n            RuntimeError: if the stream is already consumed\n        \"\"\"\n        if self._body is Empty:\n            if self.is_connected:\n                while event := await self.receive():\n                    if event[\"type\"] == \"http.request\":\n                        if event[\"body\"]:\n                            yield event[\"body\"]\n                        if not event.get(\"more_body\", False):\n                            break\n                    if event[\"type\"] == \"http.disconnect\":\n                        raise InternalServerException(\"client disconnected prematurely\")\n\n                self.is_connected = False\n                yield b\"\"\n            else:\n                raise InternalServerException(\"stream consumed\")\n        else:\n            yield self._body\n            yield b\"\"\n            return\n\n    async def body(self) -> bytes:\n        \"\"\"Return the body of the request.\n\n        Returns:\n            A byte-string representing the body of the request.\n        \"\"\"\n        if self._body is Empty:\n            self._body = self.scope[\"_body\"] = b\"\".join([c async for c in self.stream()])  # type: ignore[typeddict-item]\n        return cast(\"bytes\", self._body)\n\n    async def form(self) -> FormMultiDict:\n        \"\"\"Retrieve form data from the request. If the request is either a 'multipart/form-data' or an\n        'application/x-www-form- urlencoded', return a FormMultiDict instance populated with the values sent in the\n        request, otherwise, an empty instance.\n\n        Returns:\n            A FormMultiDict instance\n        \"\"\"\n        if self._form is Empty:\n            content_type, options = self.content_type\n            if content_type == RequestEncodingType.MULTI_PART:\n                self._form = self.scope[\"_form\"] = form_values = parse_multipart_form(  # type: ignore[typeddict-item]\n                    body=await self.body(),\n                    boundary=options.get(\"boundary\", \"\").encode(),\n                    multipart_form_part_limit=self.app.multipart_form_part_limit,\n                )\n                return FormMultiDict(form_values)\n            if content_type == RequestEncodingType.URL_ENCODED:\n                self._form = self.scope[\"_form\"] = form_values = parse_url_encoded_form_data(  # type: ignore[typeddict-item]\n                    await self.body(),\n                )\n                return FormMultiDict(form_values)\n            return FormMultiDict()\n        return FormMultiDict(self._form)\n\n    async def send_push_promise(self, path: str) -> None:\n        \"\"\"Send a push promise.\n\n        This method requires the `http.response.push` extension to be sent from the ASGI server.\n\n        Args:\n            path: Path to send the promise to.\n\n        Returns:\n            None\n        \"\"\"\n        extensions: Dict[str, Dict[Any, Any]] = self.scope.get(\"extensions\") or {}\n        if \"http.response.push\" in extensions:\n            raw_headers = []\n            for name in SERVER_PUSH_HEADERS:\n                for value in self.headers.getall(name, []):\n                    raw_headers.append((name.encode(\"latin-1\"), value.encode(\"latin-1\")))\n            await self.send({\"type\": \"http.response.push\", \"path\": path, \"headers\": raw_headers})\n", "from collections import defaultdict\nfrom functools import lru_cache\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Coroutine,\n    DefaultDict,\n    Dict,\n    List,\n    Optional,\n    Set,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom starlite.datastructures.upload_file import UploadFile\nfrom starlite.enums import ParamType, RequestEncodingType\nfrom starlite.exceptions import ValidationException\nfrom starlite.multipart import parse_multipart_form\nfrom starlite.params import BodyKwarg\nfrom starlite.parsers import (\n    parse_headers,\n    parse_query_string,\n    parse_url_encoded_form_data,\n)\nfrom starlite.types import Empty\n\nif TYPE_CHECKING:\n    from starlite.connection import ASGIConnection, Request\n    from starlite.kwargs import KwargsModel\n    from starlite.kwargs.parameter_definition import ParameterDefinition\n    from starlite.signature.models import SignatureField\n\n\ndef create_connection_value_extractor(\n    kwargs_model: \"KwargsModel\",\n    connection_key: str,\n    expected_params: Set[\"ParameterDefinition\"],\n    parser: Optional[Callable[[\"ASGIConnection\", \"KwargsModel\"], Dict[str, Any]]] = None,\n) -> Callable[[Dict[str, Any], \"ASGIConnection\"], None]:\n    \"\"\"Create a kwargs extractor function.\n\n    Args:\n        kwargs_model: The KwargsModel instance.\n        connection_key: The attribute key to use.\n        expected_params: The set of expected params.\n        parser: An optional parser function.\n\n    Returns:\n        An extractor function.\n    \"\"\"\n\n    alias_and_key_tuple = tuple(\n        (p.field_alias.lower() if p.param_type == ParamType.HEADER else p.field_alias, p.field_name)\n        for p in expected_params\n    )\n    alias_defaults = {\n        p.field_alias.lower() if p.param_type == ParamType.HEADER else p.field_alias: p.default_value\n        for p in expected_params\n        if not (p.is_required or p.default_value is Ellipsis)\n    }\n\n    def extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n        data = parser(connection, kwargs_model) if parser else getattr(connection, connection_key, {})\n\n        try:\n            connection_mapping: Dict[str, Any] = {\n                key: data[alias] if alias in data else alias_defaults[alias] for alias, key in alias_and_key_tuple\n            }\n            values.update(connection_mapping)\n        except KeyError as e:\n            raise ValidationException(f\"Missing required parameter {e.args[0]} for url {connection.url}\") from e\n\n    return extractor\n\n\n@lru_cache(1024)\ndef create_query_default_dict(\n    parsed_query: Tuple[Tuple[str, str], ...], sequence_query_parameter_names: Tuple[str, ...]\n) -> DefaultDict[str, Union[List[str], str]]:\n    \"\"\"Transform a list of tuples into a default dict. Ensures non-list values are not wrapped in a list.\n\n    Args:\n        parsed_query: The parsed query list of tuples.\n        sequence_query_parameter_names: A set of query parameters that should be wrapped in list.\n\n    Returns:\n        A default dict\n    \"\"\"\n    output: DefaultDict[str, Union[List[str], str]] = defaultdict(list)\n\n    for k, v in parsed_query:\n        if k in sequence_query_parameter_names:\n            output[k].append(v)  # type: ignore\n        else:\n            output[k] = v\n\n    return output\n\n\ndef parse_connection_query_params(connection: \"ASGIConnection\", kwargs_model: \"KwargsModel\") -> Dict[str, Any]:\n    \"\"\"Parse query params and cache the result in scope.\n\n    Args:\n        connection: The ASGI connection instance.\n        kwargs_model: The KwargsModel instance.\n\n    Returns:\n        A dictionary of parsed values.\n    \"\"\"\n    parsed_query = connection.scope[\"_parsed_query\"] = (  # type: ignore\n        connection._parsed_query\n        if connection._parsed_query is not Empty\n        else parse_query_string(connection.scope.get(\"query_string\", b\"\"))\n    )\n    return create_query_default_dict(\n        parsed_query=parsed_query, sequence_query_parameter_names=kwargs_model.sequence_query_parameter_names\n    )\n\n\ndef parse_connection_headers(connection: \"ASGIConnection\", _: \"KwargsModel\") -> Dict[str, Any]:\n    \"\"\"Parse header parameters and cache the result in scope.\n\n    Args:\n        connection: The ASGI connection instance.\n        _: The KwargsModel instance.\n\n    Returns:\n        A dictionary of parsed values\n    \"\"\"\n    parsed_headers = connection.scope[\"_headers\"] = (  # type: ignore\n        connection._headers if connection._headers is not Empty else parse_headers(tuple(connection.scope[\"headers\"]))\n    )\n    return cast(\"Dict[str, Any]\", parsed_headers)\n\n\ndef state_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Extract the app state from the connection and insert it to the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"state\"] = connection.app.state._state\n\n\ndef headers_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Extract the headers from the connection and insert them to the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"headers\"] = connection.headers\n\n\ndef cookies_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Extract the cookies from the connection and insert them to the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"cookies\"] = connection.cookies\n\n\ndef query_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Extract the query params from the connection and insert them to the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"query\"] = connection.query_params\n\n\ndef scope_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Extract the scope from the connection and insert it into the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"scope\"] = connection.scope\n\n\ndef request_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Set the connection instance as the 'request' value in the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"request\"] = connection\n\n\ndef socket_extractor(values: Dict[str, Any], connection: \"ASGIConnection\") -> None:\n    \"\"\"Set the connection instance as the 'socket' value in the kwargs injected to the handler.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        None\n    \"\"\"\n    values[\"socket\"] = connection\n\n\ndef body_extractor(\n    values: Dict[str, Any],\n    connection: \"Request[Any, Any]\",\n) -> None:\n    \"\"\"Extract the body from the request instance.\n\n    Notes:\n        - this extractor sets a Coroutine as the value in the kwargs. These are resolved at a later stage.\n\n    Args:\n        connection: The ASGI connection instance.\n        values: The kwargs that are extracted from the connection and will be injected into the handler.\n\n    Returns:\n        The Body value.\n    \"\"\"\n    values[\"body\"] = connection.body()\n\n\nasync def json_extractor(\n    connection: \"Request[Any, Any]\",\n) -> Any:\n    \"\"\"Extract the data from request and insert it into the kwargs injected to the handler.\n\n    Notes:\n        - this extractor sets a Coroutine as the value in the kwargs. These are resolved at a later stage.\n\n    Args:\n        connection: The ASGI connection instance.\n\n    Returns:\n        The JSON value.\n    \"\"\"\n    return await connection.json()\n\n\nasync def msgpack_extractor(connection: \"Request[Any, Any]\") -> Any:\n    \"\"\"Extract the data from request and insert it into the kwargs injected to the handler.\n\n    Notes:\n        - this extractor sets a Coroutine as the value in the kwargs. These are resolved at a later stage.\n\n    Args:\n        connection: The ASGI connection instance.\n\n    Returns:\n        The MessagePack value.\n    \"\"\"\n    return await connection.msgpack()\n\n\ndef create_multipart_extractor(\n    signature_field: \"SignatureField\", is_data_optional: bool\n) -> Callable[[\"ASGIConnection[Any, Any, Any]\"], Coroutine[Any, Any, Any]]:\n    \"\"\"Create a multipart form-data extractor.\n\n    Args:\n        signature_field: A SignatureField instance.\n        is_data_optional: Boolean dictating whether the field is optional.\n\n    Returns:\n        An extractor function.\n    \"\"\"\n    body_kwarg_multipart_form_part_limit: Optional[int] = None\n    if signature_field.kwarg_model and isinstance(signature_field.kwarg_model, BodyKwarg):\n        body_kwarg_multipart_form_part_limit = signature_field.kwarg_model.multipart_form_part_limit\n\n    async def extract_multipart(\n        connection: \"Request[Any, Any]\",\n    ) -> Any:\n        multipart_form_part_limit = (\n            body_kwarg_multipart_form_part_limit\n            if body_kwarg_multipart_form_part_limit is not None\n            else connection.app.multipart_form_part_limit\n        )\n        connection.scope[\"_form\"] = form_values = (  # type: ignore[typeddict-item]\n            connection.scope[\"_form\"]  # type: ignore[typeddict-item]\n            if \"_form\" in connection.scope\n            else parse_multipart_form(\n                body=await connection.body(),\n                boundary=connection.content_type[-1].get(\"boundary\", \"\").encode(),\n                multipart_form_part_limit=multipart_form_part_limit,\n            )\n        )\n\n        if signature_field.is_non_string_sequence:\n            return list(form_values.values())\n        if signature_field.is_simple_type and signature_field.field_type is UploadFile and form_values:\n            return [v for v in form_values.values() if isinstance(v, UploadFile)][0]\n\n        return form_values if form_values or not is_data_optional else None\n\n    return cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", extract_multipart)\n\n\ndef create_url_encoded_data_extractor(\n    is_data_optional: bool,\n) -> Callable[[\"ASGIConnection[Any, Any, Any]\"], Coroutine[Any, Any, Any]]:\n    \"\"\"Create extractor for url encoded form-data.\n\n    Args:\n        is_data_optional: Boolean dictating whether the field is optional.\n\n    Returns:\n        An extractor function.\n    \"\"\"\n\n    async def extract_url_encoded_extractor(\n        connection: \"Request[Any, Any]\",\n    ) -> Any:\n        connection.scope[\"_form\"] = form_values = (  # type: ignore[typeddict-item]\n            connection.scope[\"_form\"]  # type: ignore[typeddict-item]\n            if \"_form\" in connection.scope\n            else parse_url_encoded_form_data(await connection.body())\n        )\n        return form_values if form_values or not is_data_optional else None\n\n    return cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", extract_url_encoded_extractor)\n\n\ndef create_data_extractor(kwargs_model: \"KwargsModel\") -> Callable[[Dict[str, Any], \"ASGIConnection\"], None]:\n    \"\"\"Create an extractor for a request's body.\n\n    Args:\n        kwargs_model: The KwargsModel instance.\n\n    Returns:\n        An extractor for the request's body.\n    \"\"\"\n\n    if kwargs_model.expected_form_data:\n        media_type, signature_field = kwargs_model.expected_form_data\n\n        if media_type == RequestEncodingType.MULTI_PART:\n            data_extractor = create_multipart_extractor(\n                signature_field=signature_field,\n                is_data_optional=kwargs_model.is_data_optional,\n            )\n        else:\n            data_extractor = create_url_encoded_data_extractor(is_data_optional=kwargs_model.is_data_optional)\n    elif kwargs_model.expected_msgpack_data:\n        data_extractor = cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", msgpack_extractor)\n    else:\n        data_extractor = cast(\"Callable[[ASGIConnection[Any, Any, Any]], Coroutine[Any, Any, Any]]\", json_extractor)\n\n    def extractor(\n        values: Dict[str, Any],\n        connection: \"ASGIConnection[Any, Any, Any]\",\n    ) -> None:\n        values[\"data\"] = data_extractor(connection)\n\n    return extractor\n", "\"\"\"The contents of this file were adapted from sanic.\n\nMIT License\n\nCopyright (c) 2016-present Sanic Community\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\n\nimport re\nfrom collections import defaultdict\nfrom email.utils import decode_rfc2231\nfrom typing import Any, DefaultDict, Dict, List, Tuple\nfrom urllib.parse import unquote\n\nfrom starlite.datastructures.upload_file import UploadFile\nfrom starlite.exceptions import SerializationException, ValidationException\nfrom starlite.utils.serialization import decode_json\n\n_token = r\"([\\w!#$%&'*+\\-.^_`|~]+)\"\n_quoted = r'\"([^\"]*)\"'\n_param = re.compile(rf\";\\s*{_token}=(?:{_token}|{_quoted})\", re.ASCII)\n_firefox_quote_escape = re.compile(r'\\\\\"(?!; |\\s*$)')\n\n\ndef parse_content_header(value: str) -> Tuple[str, Dict[str, str]]:\n    \"\"\"Parse content-type and content-disposition header values.\n\n    Args:\n        value: A header string value to parse.\n\n    Returns:\n        A tuple containing the normalized header string and a dictionary of parameters.\n    \"\"\"\n    value = _firefox_quote_escape.sub(\"%22\", value)\n    pos = value.find(\";\")\n    if pos == -1:\n        options: Dict[str, str] = {}\n    else:\n        options = {\n            m.group(1).lower(): m.group(2) or m.group(3).replace(\"%22\", '\"') for m in _param.finditer(value[pos:])\n        }\n        value = value[:pos]\n    return value.strip().lower(), options\n\n\ndef parse_body(body: bytes, boundary: bytes, multipart_form_part_limit: int) -> List[bytes]:\n    \"\"\"Split the body using the boundary\n        and validate the number of form parts is within the allowed limit.\n\n    :param body: The form body.\n    :param boundary: The boundary used to separate form components.\n    :param multipart_form_part_limit: The limit of allowed form components\n    :return:\n        A list of form components.\n    \"\"\"\n    if not (body and boundary):\n        return []\n\n    form_parts = body.split(boundary, multipart_form_part_limit + 3)[1:-1]\n\n    if len(form_parts) > multipart_form_part_limit:\n        raise ValidationException(\n            f\"number of multipart components exceeds the allowed limit of {multipart_form_part_limit}, \"\n            f\"this potentially indicates a DoS attack\"\n        )\n\n    return form_parts\n\n\ndef parse_multipart_form(body: bytes, boundary: bytes, multipart_form_part_limit: int = 1000) -> Dict[str, Any]:\n    \"\"\"Parse multipart form data.\n\n    Args:\n        body: Body of the request.\n        boundary: Boundary of the multipart message.\n        multipart_form_part_limit: Limit of the number of parts allowed.\n\n    Returns:\n        A dictionary of parsed results.\n    \"\"\"\n\n    fields: DefaultDict[str, List[Any]] = defaultdict(list)\n\n    for form_part in parse_body(body=body, boundary=boundary, multipart_form_part_limit=multipart_form_part_limit):\n        file_name = None\n        content_type = \"text/plain\"\n        content_charset = \"utf-8\"\n        field_name = None\n        line_index = 2\n        line_end_index = 0\n        headers: List[Tuple[str, str]] = []\n\n        while line_end_index != -1:\n            line_end_index = form_part.find(b\"\\r\\n\", line_index)\n            form_line = form_part[line_index:line_end_index].decode(\"utf-8\")\n\n            if not form_line:\n                break\n\n            line_index = line_end_index + 2\n            colon_index = form_line.index(\":\")\n            current_idx = colon_index + 2\n            form_header_field = form_line[0:colon_index].lower()\n            form_header_value, form_parameters = parse_content_header(form_line[current_idx:])\n\n            if form_header_field == \"content-disposition\":\n                field_name = form_parameters.get(\"name\")\n                file_name = form_parameters.get(\"filename\")\n\n                if file_name is None and (filename_with_asterisk := form_parameters.get(\"filename*\")):\n                    encoding, _, value = decode_rfc2231(filename_with_asterisk)\n                    file_name = unquote(value, encoding=encoding or content_charset)\n\n            elif form_header_field == \"content-type\":\n                content_type = form_header_value\n                content_charset = form_parameters.get(\"charset\", \"utf-8\")\n            headers.append((form_header_field, form_header_value))\n\n        if field_name:\n            post_data = form_part[line_index:-4].lstrip(b\"\\r\\n\")\n            if file_name:\n                form_file = UploadFile(\n                    content_type=content_type, filename=file_name, file_data=post_data, headers=dict(headers)\n                )\n                fields[field_name].append(form_file)\n            else:\n                try:\n                    fields[field_name].append(decode_json(post_data))\n                except SerializationException:\n                    fields[field_name].append(post_data.decode(content_charset))\n\n    return {k: v if len(v) > 1 else v[0] for k, v in fields.items()}\n", "from dataclasses import asdict, dataclass, field\nfrom typing import TYPE_CHECKING, Any, Hashable, List, Optional, Union\n\nfrom starlite.enums import RequestEncodingType\nfrom starlite.types import Empty\n\nif TYPE_CHECKING:\n    from pydantic_openapi_schema.v3_1_0.example import Example\n    from pydantic_openapi_schema.v3_1_0.external_documentation import (\n        ExternalDocumentation,\n    )\n\n\n@dataclass(frozen=True)\nclass ParameterKwarg:\n    \"\"\"Data container representing a parameter.\"\"\"\n\n    value_type: Any = field(default=Empty)\n    \"\"\"The field value - `Empty` by default.\"\"\"\n    header: Optional[str] = field(default=None)\n    \"\"\"The header parameter key - required for header parameters.\"\"\"\n    cookie: Optional[str] = field(default=None)\n    \"\"\"The cookie parameter key - required for cookie parameters.\"\"\"\n    query: Optional[str] = field(default=None)\n    \"\"\"The query parameter key for this parameter.\"\"\"\n    examples: Optional[List[\"Example\"]] = field(default=None)\n    \"\"\"A list of Example models.\"\"\"\n    external_docs: Optional[\"ExternalDocumentation\"] = field(default=None)\n    \"\"\"A url pointing at external documentation for the given parameter.\"\"\"\n    content_encoding: Optional[str] = field(default=None)\n    \"\"\"The content encoding of the value.\n\n    Applicable on to string values. See OpenAPI 3.1 for details.\n    \"\"\"\n    required: Optional[bool] = field(default=None)\n    \"\"\"A boolean flag dictating whether this parameter is required.\n\n    If set to False, None values will be allowed. Defaults to True.\n    \"\"\"\n    default: Any = field(default=Empty)\n    \"\"\"A default value.\n\n    If const is true, this value is required.\n    \"\"\"\n    title: Optional[str] = field(default=None)\n    \"\"\"String value used in the title section of the OpenAPI schema for the given parameter.\"\"\"\n    description: Optional[str] = field(default=None)\n    \"\"\"String value used in the description section of the OpenAPI schema for the given parameter.\"\"\"\n    const: Optional[bool] = field(default=None)\n    \"\"\"A boolean flag dictating whether this parameter is a constant.\n\n    If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to\n    be populated with the default value.\n    \"\"\"\n    gt: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be greater than a given float or int.\n\n    Equivalent to exclusiveMinimum in the OpenAPI specification.\n    \"\"\"\n    ge: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be greater or equal to a given float or int.\n\n    Equivalent to minimum in the OpenAPI specification.\n    \"\"\"\n    lt: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be less than a given float or int.\n\n    Equivalent to exclusiveMaximum in the OpenAPI specification.\n    \"\"\"\n    le: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be less or equal to a given float or int.\n\n    Equivalent to maximum in the OpenAPI specification.\n    \"\"\"\n    multiple_of: Optional[float] = field(default=None)\n    \"\"\"Constrict value to a multiple of a given float or int.\n\n    Equivalent to multipleOf in the OpenAPI specification.\n    \"\"\"\n    min_items: Optional[int] = field(default=None)\n    \"\"\"Constrict a set or a list to have a minimum number of items.\n\n    Equivalent to minItems in the OpenAPI specification.\n    \"\"\"\n    max_items: Optional[int] = field(default=None)\n    \"\"\"Constrict a set or a list to have a maximum number of items.\n\n    Equivalent to maxItems in the OpenAPI specification.\n    \"\"\"\n    min_length: Optional[int] = field(default=None)\n    \"\"\"Constrict a string or bytes value to have a minimum length.\n\n    Equivalent to minLength in the OpenAPI specification.\n    \"\"\"\n    max_length: Optional[int] = field(default=None)\n    \"\"\"Constrict a string or bytes value to have a maximum length.\n\n    Equivalent to maxLength in the OpenAPI specification.\n    \"\"\"\n    regex: Optional[str] = field(default=None)\n    \"\"\"A string representing a regex against which the given string will be matched.\n\n    Equivalent to pattern in the OpenAPI specification.\n    \"\"\"\n\n    def __hash__(self) -> int:  # pragma: no cover\n        \"\"\"Hash the dataclass in a safe way.\n\n        Returns:\n            A hash\n        \"\"\"\n        return sum(hash(v) for v in asdict(self) if isinstance(v, Hashable))\n\n\ndef Parameter(\n    value_type: Any = Empty,\n    *,\n    header: Optional[str] = None,\n    cookie: Optional[str] = None,\n    query: Optional[str] = None,\n    examples: Optional[List[\"Example\"]] = None,\n    external_docs: Optional[\"ExternalDocumentation\"] = None,\n    content_encoding: Optional[str] = None,\n    required: Optional[bool] = None,\n    default: Any = Empty,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    const: Optional[bool] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    multiple_of: Optional[float] = None,\n    min_items: Optional[int] = None,\n    max_items: Optional[int] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None\n) -> Any:\n    \"\"\"Create an extended parameter kwarg definition.\n\n    Args:\n        value_type: `Empty` by default.\n        header: The header parameter key - required for header parameters.\n        cookie: The cookie parameter key - required for cookie parameters.\n        query: The query parameter key for this parameter.\n        examples: A list of Example models.\n        external_docs: A url pointing at external documentation for the given\n            parameter.\n        content_encoding: The content encoding of the value. Applicable on to string values. See\n            OpenAPI 3.1 for details.\n        required: A boolean flag dictating whether this parameter is required. If set to False, None\n            values will be allowed. Defaults to True.\n        default: A default value. If const is true, this value is required.\n        title: String value used in the title section of the OpenAPI schema for the given\n            parameter.\n        description: String value used in the description section of the OpenAPI schema for the\n            given parameter.\n        const: A boolean flag dictating whether this parameter is a constant. If True, the value passed\n            to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with\n            the default value.\n        gt: Constrict value to be greater than a given float or int. Equivalent to\n            exclusiveMinimum in the OpenAPI specification.\n        ge: Constrict value to be greater or equal to a given float or int. Equivalent to\n            minimum in the OpenAPI specification.\n        lt: Constrict value to be less than a given float or int. Equivalent to\n            exclusiveMaximum in the OpenAPI specification.\n        le: Constrict value to be less or equal to a given float or int. Equivalent to maximum\n            in the OpenAPI specification.\n        multiple_of: Constrict value to a multiple of a given float or int. Equivalent to\n            multipleOf in the OpenAPI specification.\n        min_items: Constrict a set or a list to have a minimum number of items. Equivalent to\n            minItems in the OpenAPI specification.\n        max_items: Constrict a set or a list to have a maximum number of items. Equivalent to\n            maxItems in the OpenAPI specification.\n        min_length: Constrict a string or bytes value to have a minimum length. Equivalent to\n            minLength in the OpenAPI specification.\n        max_length: Constrict a string or bytes value to have a maximum length. Equivalent to\n            maxLength in the OpenAPI specification.\n        regex: A string representing a regex against which the given string will be matched.\n            Equivalent to pattern in the OpenAPI specification.\n    \"\"\"\n    return ParameterKwarg(\n        value_type=value_type,\n        header=header,\n        cookie=cookie,\n        query=query,\n        examples=examples,\n        external_docs=external_docs,\n        content_encoding=content_encoding,\n        required=required,\n        default=default,\n        title=title,\n        description=description,\n        const=const,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        multiple_of=multiple_of,\n        min_items=min_items,\n        max_items=max_items,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n    )\n\n\n@dataclass(frozen=True)\nclass BodyKwarg:\n    \"\"\"Data container representing a request body.\"\"\"\n\n    media_type: Union[str, \"RequestEncodingType\"] = field(default=RequestEncodingType.JSON)\n    \"\"\"Media-Type of the body.\"\"\"\n    examples: Optional[List[\"Example\"]] = field(default=None)\n    \"\"\"A list of Example models.\"\"\"\n    external_docs: Optional[\"ExternalDocumentation\"] = field(default=None)\n    \"\"\"A url pointing at external documentation for the given parameter.\"\"\"\n    content_encoding: Optional[str] = field(default=None)\n    \"\"\"The content encoding of the value.\n\n    Applicable on to string values. See OpenAPI 3.1 for details.\n    \"\"\"\n    default: Any = field(default=Empty)\n    \"\"\"A default value.\n\n    If const is true, this value is required.\n    \"\"\"\n    title: Optional[str] = field(default=None)\n    \"\"\"String value used in the title section of the OpenAPI schema for the given parameter.\"\"\"\n    description: Optional[str] = field(default=None)\n    \"\"\"String value used in the description section of the OpenAPI schema for the given parameter.\"\"\"\n    const: Optional[bool] = field(default=None)\n    \"\"\"A boolean flag dictating whether this parameter is a constant.\n\n    If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to\n    be populated with the default value.\n    \"\"\"\n    gt: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be greater than a given float or int.\n\n    Equivalent to exclusiveMinimum in the OpenAPI specification.\n    \"\"\"\n    ge: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be greater or equal to a given float or int.\n\n    Equivalent to minimum in the OpenAPI specification.\n    \"\"\"\n    lt: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be less than a given float or int.\n\n    Equivalent to exclusiveMaximum in the OpenAPI specification.\n    \"\"\"\n    le: Optional[float] = field(default=None)\n    \"\"\"Constrict value to be less or equal to a given float or int.\n\n    Equivalent to maximum in the OpenAPI specification.\n    \"\"\"\n    multiple_of: Optional[float] = field(default=None)\n    \"\"\"Constrict value to a multiple of a given float or int.\n\n    Equivalent to multipleOf in the OpenAPI specification.\n    \"\"\"\n    min_items: Optional[int] = field(default=None)\n    \"\"\"Constrict a set or a list to have a minimum number of items.\n\n    Equivalent to minItems in the OpenAPI specification.\n    \"\"\"\n    max_items: Optional[int] = field(default=None)\n    \"\"\"Constrict a set or a list to have a maximum number of items.\n\n    Equivalent to maxItems in the OpenAPI specification.\n    \"\"\"\n    min_length: Optional[int] = field(default=None)\n    \"\"\"Constrict a string or bytes value to have a minimum length.\n\n    Equivalent to minLength in the OpenAPI specification.\n    \"\"\"\n    max_length: Optional[int] = field(default=None)\n    \"\"\"Constrict a string or bytes value to have a maximum length.\n\n    Equivalent to maxLength in the OpenAPI specification.\n    \"\"\"\n    regex: Optional[str] = field(default=None)\n    \"\"\"A string representing a regex against which the given string will be matched.\n\n    Equivalent to pattern in the OpenAPI specification.\n    \"\"\"\n    multipart_form_part_limit: Optional[int] = field(default=None)\n    \"\"\"The maximal number of allowed parts in a multipart/formdata request. This limit is intended to protect from DoS attacks.\"\"\"\n\n    def __hash__(self) -> int:  # pragma: no cover\n        \"\"\"Hash the dataclass in a safe way.\n\n        Returns:\n            A hash\n        \"\"\"\n        return sum(hash(v) for v in asdict(self) if isinstance(v, Hashable))\n\n\ndef Body(\n    *,\n    media_type: Union[str, \"RequestEncodingType\"] = RequestEncodingType.JSON,\n    examples: Optional[List[\"Example\"]] = None,\n    external_docs: Optional[\"ExternalDocumentation\"] = None,\n    content_encoding: Optional[str] = None,\n    default: Any = Empty,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    const: Optional[bool] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    multiple_of: Optional[float] = None,\n    min_items: Optional[int] = None,\n    max_items: Optional[int] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    regex: Optional[str] = None,\n    multipart_form_part_limit: Optional[int] = None\n) -> Any:\n    \"\"\"Create an extended request body kwarg definition.\n\n    Args:\n        media_type: Defaults to RequestEncodingType.JSON.\n        examples: A list of Example models.\n        external_docs: A url pointing at external documentation for the given\n            parameter.\n        content_encoding: The content encoding of the value. Applicable on to string values. See\n            OpenAPI 3.1 for details.\n        default: A default value. If const is true, this value is required.\n        title: String value used in the title section of the OpenAPI schema for the given\n            parameter.\n        description: String value used in the description section of the OpenAPI schema for the\n            given parameter.\n        const: A boolean flag dictating whether this parameter is a constant. If True, the value passed\n            to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with\n            the default value.\n        gt: Constrict value to be greater than a given float or int. Equivalent to\n            exclusiveMinimum in the OpenAPI specification.\n        ge: Constrict value to be greater or equal to a given float or int. Equivalent to\n            minimum in the OpenAPI specification.\n        lt: Constrict value to be less than a given float or int. Equivalent to\n            exclusiveMaximum in the OpenAPI specification.\n        le: Constrict value to be less or equal to a given float or int. Equivalent to maximum\n            in the OpenAPI specification.\n        multiple_of: Constrict value to a multiple of a given float or int. Equivalent to\n            multipleOf in the OpenAPI specification.\n        min_items: Constrict a set or a list to have a minimum number of items. Equivalent to\n            minItems in the OpenAPI specification.\n        max_items: Constrict a set or a list to have a maximum number of items. Equivalent to\n            maxItems in the OpenAPI specification.\n        min_length: Constrict a string or bytes value to have a minimum length. Equivalent to\n            minLength in the OpenAPI specification.\n        max_length: Constrict a string or bytes value to have a maximum length. Equivalent to\n            maxLength in the OpenAPI specification.\n        regex: A string representing a regex against which the given string will be matched.\n            Equivalent to pattern in the OpenAPI specification.\n        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request.\n            This limit is intended to protect from DoS attacks.\n    \"\"\"\n    return BodyKwarg(\n        media_type=media_type,\n        examples=examples,\n        external_docs=external_docs,\n        content_encoding=content_encoding,\n        default=default,\n        title=title,\n        description=description,\n        const=const,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        multiple_of=multiple_of,\n        min_items=min_items,\n        max_items=max_items,\n        min_length=min_length,\n        max_length=max_length,\n        regex=regex,\n        multipart_form_part_limit=multipart_form_part_limit,\n    )\n\n\n@dataclass(frozen=True)\nclass DependencyKwarg:\n    \"\"\"Data container representing a dependency.\"\"\"\n\n    default: Any = field(default=Empty)\n    \"\"\"A default value.\"\"\"\n    skip_validation: bool = field(default=False)\n    \"\"\"Flag dictating whether to skip validation.\"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"Hash the dataclass in a safe way.\n\n        Returns:\n            A hash\n        \"\"\"\n        return sum(hash(v) for v in asdict(self) if isinstance(v, Hashable))\n\n\ndef Dependency(*, default: Any = Empty, skip_validation: bool = False) -> Any:\n    \"\"\"Create a dependency kwarg definition.\n\n    Args:\n        default: A default value to use in case a dependency is not provided.\n        skip_validation: If `True` provided dependency values are not validated by signature model.\n    \"\"\"\n    return DependencyKwarg(default=default, skip_validation=skip_validation)\n", "from typing import (\n    TYPE_CHECKING,\n    Any,\n    Dict,\n    Iterable,\n    List,\n    Literal,\n    Optional,\n    Tuple,\n    Type,\n    Union,\n    cast,\n)\n\nfrom starlite.app import DEFAULT_CACHE_CONFIG, Starlite\nfrom starlite.testing.client.sync_client import TestClient\n\nif TYPE_CHECKING:\n    from starlite import (\n        BaseLoggingConfig,\n        CacheConfig,\n        CompressionConfig,\n        CORSConfig,\n        CSRFConfig,\n        OpenAPIConfig,\n        PluginProtocol,\n        Request,\n        StaticFilesConfig,\n        TemplateConfig,\n        WebSocket,\n    )\n    from starlite.config import AllowedHostsConfig\n    from starlite.datastructures.state import ImmutableState\n    from starlite.middleware.session.base import BaseBackendConfig\n    from starlite.types import (\n        AfterExceptionHookHandler,\n        AfterRequestHookHandler,\n        AfterResponseHookHandler,\n        BeforeMessageSendHookHandler,\n        BeforeRequestHookHandler,\n        ControllerRouterHandler,\n        Dependencies,\n        ExceptionHandlersMap,\n        Guard,\n        LifeSpanHandler,\n        LifeSpanHookHandler,\n        Middleware,\n        OnAppInitHandler,\n        ParametersMap,\n        ResponseType,\n        SingleOrList,\n    )\n\n\ndef create_test_client(\n    route_handlers: Union[\"ControllerRouterHandler\", List[\"ControllerRouterHandler\"]],\n    *,\n    after_exception: Optional[\"SingleOrList[AfterExceptionHookHandler]\"] = None,\n    after_request: Optional[\"AfterRequestHookHandler\"] = None,\n    after_response: Optional[\"AfterResponseHookHandler\"] = None,\n    after_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n    after_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n    allowed_hosts: Optional[Union[List[str], \"AllowedHostsConfig\"]] = None,\n    backend: Literal[\"asyncio\", \"trio\"] = \"asyncio\",\n    backend_options: Optional[Dict[str, Any]] = None,\n    base_url: str = \"http://testserver.local\",\n    before_request: Optional[\"BeforeRequestHookHandler\"] = None,\n    before_send: Optional[\"SingleOrList[BeforeMessageSendHookHandler]\"] = None,\n    before_shutdown: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n    before_startup: Optional[\"SingleOrList[LifeSpanHookHandler]\"] = None,\n    cache_config: \"CacheConfig\" = DEFAULT_CACHE_CONFIG,\n    compression_config: Optional[\"CompressionConfig\"] = None,\n    cors_config: Optional[\"CORSConfig\"] = None,\n    csrf_config: Optional[\"CSRFConfig\"] = None,\n    dependencies: Optional[\"Dependencies\"] = None,\n    exception_handlers: Optional[\"ExceptionHandlersMap\"] = None,\n    guards: Optional[List[\"Guard\"]] = None,\n    initial_state: Optional[Union[\"ImmutableState\", Dict[str, Any], Iterable[Tuple[str, Any]]]] = None,\n    logging_config: Optional[\"BaseLoggingConfig\"] = None,\n    middleware: Optional[List[\"Middleware\"]] = None,\n    multipart_form_part_limit: int = 1000,\n    on_app_init: Optional[List[\"OnAppInitHandler\"]] = None,\n    on_shutdown: Optional[List[\"LifeSpanHandler\"]] = None,\n    on_startup: Optional[List[\"LifeSpanHandler\"]] = None,\n    openapi_config: Optional[\"OpenAPIConfig\"] = None,\n    parameters: Optional[\"ParametersMap\"] = None,\n    plugins: Optional[List[\"PluginProtocol\"]] = None,\n    raise_server_exceptions: bool = True,\n    request_class: Optional[Type[\"Request\"]] = None,\n    response_class: Optional[\"ResponseType\"] = None,\n    root_path: str = \"\",\n    session_config: Optional[\"BaseBackendConfig\"] = None,\n    static_files_config: Optional[Union[\"StaticFilesConfig\", List[\"StaticFilesConfig\"]]] = None,\n    template_config: Optional[\"TemplateConfig\"] = None,\n    websocket_class: Optional[Type[\"WebSocket\"]] = None,\n) -> TestClient[\"Starlite\"]:\n    \"\"\"Create a Starlite app instance and initializes it.\n\n    :class:`TestClient <starlite.testing.TestClient>` with it.\n\n    Notes:\n        - This function should be called as a context manager to ensure async startup and shutdown are\n            handled correctly.\n\n    Examples:\n        .. code-block: python\n\n            from starlite import get, create_test_client\n\n\n            @get(\"/some-path\")\n            def my_handler() -> dict[str, str]:\n                return {\"hello\": \"world\"}\n\n\n            def test_my_handler() -> None:\n                with create_test_client(my_handler) as client:\n                    response == client.get(\"/some-path\")\n                    assert response.json() == {\"hello\": \"world\"}\n\n\n    Args:\n        route_handlers: A single handler or a list of route handlers, which can include instances of\n            :class:`Router <starlite.router.Router>`, subclasses of :class:`Controller <starlite.controller.Controller>` or\n            any function decorated by the route handler decorators.\n        after_exception: An application level :class:`exception event handler <starlite.types.AfterExceptionHookHandler>`.\n            This hook is called after an exception occurs. In difference to exception handlers, it is not meant to\n            return a response - only to process the exception (e.g. log it, send it to Sentry etc.).\n        after_request: A sync or async function executed after the route handler function returned and the response\n            object has been resolved. Receives the response object which may be any subclass of\n            :class:`Response <starlite.response.Response>`.\n        after_response: A sync or async function called after the response has been awaited. It receives the\n            :class:`Request <starlite.connection.Request>` object and should not return any values.\n        after_shutdown: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`.\n            This hook is called during the ASGI shutdown, after all callables in the ``on_shutdown``\n            list have been called.\n        after_startup: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`.\n            This hook is called during the ASGI startup, after all callables in the ``on_startup``\n            list have been called.\n        allowed_hosts: A list of allowed hosts - enables the builtin allowed hosts middleware.\n        backend: The async backend to use, options are \"asyncio\" or \"trio\".\n        backend_options: ``anyio`` options.\n        base_url: URL scheme and domain for test request paths, e.g. 'http://testserver'.\n        before_request: A sync or async function called immediately before calling the route handler.\n            Receives the :class:`Request <starlite.connection.Request>` instance and any non-``None`` return value is\n            used for the response, bypassing the route handler.\n        before_send: An application level :class:`before send hook handler <starlite.types.BeforeMessageSendHookHandler>` or\n            list thereof. This hook is called when the ASGI send function is called.\n        before_shutdown: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`. This hook is\n            called during the ASGI shutdown, before any callables in the ``on_shutdown`` list have been called.\n        before_startup: An application level :class:`LifeSpan hook handler <starlite.types.LifeSpanHookHandler>`. This hook is\n            called during the ASGI startup, before any callables in the ``on_startup`` list have been called.\n        cache_config: Configures caching behavior of the application.\n        compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n            defined Compression middleware.\n        cors_config: If set this enables the builtin CORS middleware.\n        csrf_config: If set this enables the builtin CSRF middleware.\n        dependencies: A string keyed dictionary of dependency :class:`Provider <starlite.datastructures.Provide>` instances.\n        exception_handlers: A dictionary that maps handler functions to status codes and/or exception types.\n        guards: A list of :class:`Guard <starlite.types.Guard>` callables.\n        initial_state: An object from which to initialize the app state.\n        logging_config: A subclass of :class:`BaseLoggingConfig <starlite.config.logging.BaseLoggingConfig>`.\n        middleware: A list of :class:`Middleware <starlite.types.Middleware>`.\n        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request.\n            This limit is intended to protect from DoS attacks.\n        on_app_init:  A sequence of :class:`OnAppInitHandler <starlite.types.OnAppInitHandler>` instances. Handlers receive\n                an instance of :class:`AppConfig <starlite.config.app.AppConfig>` that will have been initially populated with\n                the parameters passed to :class:`Starlite <starlite.app.Starlite>`, and must return an instance of same. If more\n                than one handler is registered they are called in the order they are provided.\n        on_shutdown: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during\n            application shutdown.\n        on_startup: A list of :class:`LifeSpanHandler <starlite.types.LifeSpanHandler>` called during\n            application startup.\n        openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG <starlite.app.DEFAULT_OPENAPI_CONFIG>`\n        parameters: A mapping of :class:`Parameter <starlite.params.Parameter>` definitions available to all\n            application paths.\n        plugins: List of plugins.\n        request_class: An optional subclass of :class:`Request <starlite.connection.request.Request>` to use for\n            http connections.\n        raise_server_exceptions: Flag for underlying the test client to raise server exceptions instead of\n            wrapping them in an HTTP response.\n        response_class: A custom subclass of [starlite.response.Response] to be used as the app's default response.\n        root_path: Path prefix for requests.\n        static_files_config: An instance or list of :class:`StaticFilesConfig <starlite.config.StaticFilesConfig>`\n        session_config: Configuration for Session Middleware class to create raw session cookies for request to the\n            route handlers.\n        template_config: An instance of :class:`TemplateConfig <starlite.config.TemplateConfig>`\n        websocket_class: An optional subclass of :class:`WebSocket <starlite.connection.websocket.WebSocket>` to use for\n            websocket connections.\n\n    Returns:\n        An instance of :class:`TestClient <starlite.testing.TestClient>` with a created app instance.\n    \"\"\"\n    return TestClient[Starlite](\n        app=Starlite(\n            after_exception=after_exception,\n            after_request=after_request,\n            after_response=after_response,\n            after_shutdown=after_shutdown,\n            after_startup=after_startup,\n            allowed_hosts=allowed_hosts,\n            before_request=before_request,\n            before_send=before_send,\n            before_shutdown=before_shutdown,\n            before_startup=before_startup,\n            cache_config=cache_config,\n            compression_config=compression_config,\n            cors_config=cors_config,\n            csrf_config=csrf_config,\n            dependencies=dependencies,\n            exception_handlers=exception_handlers,\n            guards=guards,\n            initial_state=initial_state,\n            logging_config=logging_config,\n            middleware=middleware,\n            multipart_form_part_limit=multipart_form_part_limit,\n            on_app_init=on_app_init,\n            on_shutdown=on_shutdown,\n            on_startup=on_startup,\n            openapi_config=openapi_config,\n            parameters=parameters,\n            plugins=plugins,\n            request_class=request_class,\n            response_class=response_class,\n            route_handlers=cast(\"Any\", route_handlers if isinstance(route_handlers, list) else [route_handlers]),\n            static_files_config=static_files_config,\n            template_config=template_config,\n            websocket_class=websocket_class,\n        ),\n        backend=backend,\n        backend_options=backend_options,\n        base_url=base_url,\n        raise_server_exceptions=raise_server_exceptions,\n        root_path=root_path,\n        session_config=session_config,\n    )\n", "import inspect\nfrom typing import List\nfrom unittest.mock import MagicMock, PropertyMock\n\nimport pytest\n\nfrom starlite import LoggingConfig\nfrom starlite.app import DEFAULT_CACHE_CONFIG, Starlite\nfrom starlite.config.app import AppConfig\nfrom starlite.router import Router\n\n\n@pytest.fixture()\ndef app_config_object() -> AppConfig:\n    return AppConfig(\n        after_exception=[],\n        after_request=None,\n        after_response=None,\n        after_shutdown=[],\n        after_startup=[],\n        allowed_hosts=[],\n        before_request=None,\n        before_send=[],\n        before_shutdown=[],\n        before_startup=[],\n        cache_config=DEFAULT_CACHE_CONFIG,\n        cache_control=None,\n        compression_config=None,\n        cors_config=None,\n        csrf_config=None,\n        debug=False,\n        dependencies={},\n        exception_handlers={},\n        guards=[],\n        initial_state={},\n        logging_config=None,\n        middleware=[],\n        multipart_form_part_limit=1000,\n        on_shutdown=[],\n        on_startup=[],\n        openapi_config=None,\n        opt={},\n        parameters={},\n        plugins=[],\n        response_class=None,\n        response_cookies=[],\n        response_headers={},\n        route_handlers=[],\n        security=[],\n        static_files_config=[],\n        tags=[],\n        template_config=None,\n        request_class=None,\n        websocket_class=None,\n        etag=None,\n    )\n\n\ndef test_app_params_defined_on_app_config_object() -> None:\n    \"\"\"Ensures that all parameters to the `Starlite` constructor are present on the `AppConfig` object.\"\"\"\n    starlite_signature = inspect.signature(Starlite)\n    app_config_fields = AppConfig.__fields__\n    for name in starlite_signature.parameters:\n        if name in (\"on_app_init\", \"initial_state\"):\n            continue\n        assert name in app_config_fields\n    # ensure there are not fields defined on AppConfig that aren't in the Starlite signature\n    assert not (app_config_fields.keys() - starlite_signature.parameters.keys())\n\n\ndef test_app_config_object_used(app_config_object: AppConfig, monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Ensure that the properties on the `AppConfig` object are accessed within the `Starlite` constructor.\n\n    In the test we replace every field on the `AppConfig` type with a property mock so that we can check that it has at\n    least been accessed. It doesn't actually check that we do the right thing with it, but is a guard against the case\n    of adding a parameter to the `Starlite` signature and to the `AppConfig` object, and using the value from the\n    parameter downstream from construction of the `AppConfig` object.\n    \"\"\"\n\n    # replace each field on the `AppConfig` object with a `PropertyMock`, this allows us to assert that the properties\n    # have been accessed during app instantiation.\n    property_mocks: List[PropertyMock] = []\n    for name in AppConfig.__fields__:\n        if name == \"cache_config\":\n            property_mock = PropertyMock(return_value=DEFAULT_CACHE_CONFIG)\n        else:\n            # default iterable return value allows the mock properties that need to be iterated over in\n            # `Starlite.__init__()` to not blow up, for other properties it shouldn't matter what the value is for the\n            # sake of this test.\n            property_mock = PropertyMock(return_value=[])\n        property_mocks.append(property_mock)\n        monkeypatch.setattr(type(app_config_object), name, property_mock, raising=False)\n\n    # Things that we don't actually need to call for this test\n    monkeypatch.setattr(Starlite, \"register\", MagicMock())\n    monkeypatch.setattr(Starlite, \"_create_asgi_handler\", MagicMock())\n    monkeypatch.setattr(Router, \"__init__\", MagicMock())\n\n    # instantiates the app with an `on_app_config` that returns our patched `AppConfig` object.\n    Starlite(route_handlers=[], on_app_init=[MagicMock(return_value=app_config_object)])\n\n    # this ensures that each of the properties of the `AppConfig` object have been accessed within `Starlite.__init__()`\n    for mock in property_mocks:\n        mock.assert_called()\n\n\ndef test_app_debug_create_logger() -> None:\n    app = Starlite([], debug=True)\n\n    assert app.logging_config\n    assert app.logging_config.loggers[\"starlite\"][\"level\"] == \"DEBUG\"  # type: ignore[attr-defined]\n\n\ndef test_app_debug_explicitly_disable_logging() -> None:\n    app = Starlite([], debug=True, logging_config=None)\n\n    assert not app.logging_config\n\n\ndef test_app_debug_update_logging_config() -> None:\n    logging_config = LoggingConfig()\n    app = Starlite([], debug=True, logging_config=logging_config)\n\n    assert app.logging_config is logging_config\n    assert app.logging_config.loggers[\"starlite\"][\"level\"] == \"DEBUG\"  # type: ignore[attr-defined]\n\n\ndef test_set_initial_state() -> None:\n    def set_initial_state_in_hook(app_config: AppConfig) -> AppConfig:\n        assert isinstance(app_config.initial_state, dict)\n        app_config.initial_state[\"c\"] = \"D\"  # pyright:ignore\n        app_config.initial_state[\"e\"] = \"f\"  # pyright:ignore\n        return app_config\n\n    app = Starlite(route_handlers=[], initial_state={\"a\": \"b\", \"c\": \"d\"}, on_app_init=[set_initial_state_in_hook])\n    assert app.state._state == {\"a\": \"b\", \"c\": \"D\", \"e\": \"f\"}\n", "# flake8: noqa\nfrom collections import defaultdict\nfrom os import path\nfrom os.path import dirname, join, realpath\nfrom pathlib import Path\nfrom typing import Any, DefaultDict, Dict, List, Optional, Type\n\nimport pytest\nfrom pydantic import BaseConfig, BaseModel\n\nfrom starlite import Body, Request, RequestEncodingType, post\nfrom starlite.datastructures import UploadFile\nfrom starlite.status_codes import HTTP_201_CREATED, HTTP_400_BAD_REQUEST\nfrom starlite.testing import create_test_client\nfrom tests import Person, PersonFactory\nfrom tests.kwargs import Form\n\n\nclass FormData(BaseModel):\n    name: UploadFile\n    age: UploadFile\n    programmer: UploadFile\n\n    class Config(BaseConfig):\n        arbitrary_types_allowed = True\n\n\n@post(\"/form\")\nasync def form_handler(request: Request) -> Dict[str, Any]:\n    data = await request.form()\n    output = {}\n    for key, value in data.items():\n        if isinstance(value, UploadFile):\n            content = await value.read()\n            output[key] = {\n                \"filename\": value.filename,\n                \"content\": content.decode(),\n                \"content_type\": value.content_type,\n            }\n        else:\n            output[key] = value\n    return output\n\n\n@post(\"/form\")\nasync def form_multi_item_handler(request: Request) -> DefaultDict[str, list]:\n    data = await request.form()\n    output: DefaultDict[str, list] = defaultdict(list)\n    for key, value in data.multi_items():\n        for v in value:\n            if isinstance(v, UploadFile):\n                content = await v.read()\n                output[key].append(\n                    {\n                        \"filename\": v.filename,\n                        \"content\": content.decode(),\n                        \"content_type\": v.content_type,\n                    }\n                )\n            else:\n                output[key].append(v)\n    return output\n\n\n@post(\"/form\")\nasync def form_with_headers_handler(request: Request) -> Dict[str, Any]:\n    data = await request.form()\n    output = {}\n    for key, value in data.items():\n        if isinstance(value, UploadFile):\n            content = await value.read()\n            output[key] = {\n                \"filename\": value.filename,\n                \"content\": content.decode(),\n                \"content_type\": value.content_type,\n                \"headers\": [[name.lower(), value] for name, value in value.headers.items()],\n            }\n        else:\n            output[key] = value\n    return output\n\n\n@pytest.mark.parametrize(\"t_type\", [FormData, Dict[str, UploadFile], List[UploadFile], UploadFile])\ndef test_request_body_multi_part(t_type: Type[Any]) -> None:\n    body = Body(media_type=RequestEncodingType.MULTI_PART)\n\n    test_path = \"/test\"\n    data = Form(name=\"Moishe Zuchmir\", age=30, programmer=True).dict()\n\n    @post(path=test_path)\n    def test_method(data: t_type = body) -> None:  # type: ignore\n        assert data\n\n    with create_test_client(test_method) as client:\n        response = client.post(test_path, files={k: str(v).encode(\"utf-8\") for k, v in data.items()})\n        assert response.status_code == HTTP_201_CREATED\n\n\ndef test_request_body_multi_part_mixed_field_content_types() -> None:\n    person = PersonFactory.build()\n\n    class MultiPartFormWithMixedFields(BaseModel):\n        class Config(BaseConfig):\n            arbitrary_types_allowed = True\n\n        image: UploadFile\n        tags: List[str]\n        profile: Person\n\n    @post(path=\"/form\")\n    async def test_method(data: MultiPartFormWithMixedFields = Body(media_type=RequestEncodingType.MULTI_PART)) -> None:\n        file_data = await data.image.read()\n        assert file_data == b\"data\"\n        assert data.tags == [\"1\", \"2\", \"3\"]\n        assert data.profile == person\n\n    with create_test_client(test_method) as client:\n        response = client.post(\n            \"/form\",\n            files={\"image\": (\"image.png\", b\"data\")},\n            data={\"tags\": [\"1\", \"2\", \"3\"], \"profile\": person.json()},\n        )\n        assert response.status_code == HTTP_201_CREATED\n\n\ndef test_multipart_request_files(tmpdir: Any) -> None:\n    path1 = path.join(tmpdir, \"test.txt\")\n    Path(path1).write_bytes(b\"<file content>\")\n\n    with create_test_client(form_handler) as client, open(path1, \"rb\") as f:\n        response = client.post(\"/form\", files={\"test\": f})\n        assert response.json() == {\n            \"test\": {\n                \"filename\": \"test.txt\",\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            }\n        }\n\n\ndef test_multipart_request_files_with_content_type(tmpdir: Any) -> None:\n    path1 = path.join(tmpdir, \"test.txt\")\n    Path(path1).write_bytes(b\"<file content>\")\n\n    with create_test_client(form_handler) as client, open(path1, \"rb\") as f:\n        response = client.post(\"/form\", files={\"test\": (\"test.txt\", f, \"text/plain\")})\n        assert response.json() == {\n            \"test\": {\n                \"filename\": \"test.txt\",\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            }\n        }\n\n\ndef test_multipart_request_multiple_files(tmpdir: Any) -> None:\n    path1 = path.join(tmpdir, \"test1.txt\")\n    Path(path1).write_bytes(b\"<file1 content>\")\n\n    path2 = path.join(tmpdir, \"test2.txt\")\n    Path(path2).write_bytes(b\"<file2 content>\")\n\n    with create_test_client(form_handler) as client, open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\"/form\", files={\"test1\": f1, \"test2\": (\"test2.txt\", f2, \"text/plain\")})\n        assert response.json() == {\n            \"test1\": {\"filename\": \"test1.txt\", \"content\": \"<file1 content>\", \"content_type\": \"text/plain\"},\n            \"test2\": {\"filename\": \"test2.txt\", \"content\": \"<file2 content>\", \"content_type\": \"text/plain\"},\n        }\n\n\ndef test_multipart_request_multiple_files_with_headers(tmpdir: Any) -> None:\n    path1 = path.join(tmpdir, \"test1.txt\")\n    Path(path1).write_bytes(b\"<file1 content>\")\n\n    path2 = path.join(tmpdir, \"test2.txt\")\n    Path(path2).write_bytes(b\"<file2 content>\")\n\n    with create_test_client(form_with_headers_handler) as client, open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\n            \"/form\",\n            files=[\n                (\"test1\", (None, f1)),\n                (\"test2\", (\"test2.txt\", f2, \"text/plain\", {\"x-custom\": \"f2\"})),\n            ],\n        )\n        assert response.json() == {\n            \"test1\": \"<file1 content>\",\n            \"test2\": {\n                \"filename\": \"test2.txt\",\n                \"content\": \"<file2 content>\",\n                \"content_type\": \"text/plain\",\n                \"headers\": [[\"content-disposition\", \"form-data\"], [\"x-custom\", \"f2\"], [\"content-type\", \"text/plain\"]],\n            },\n        }\n\n\ndef test_multi_items(tmpdir: Any) -> None:\n    path1 = path.join(tmpdir, \"test1.txt\")\n    Path(path1).write_bytes(b\"<file1 content>\")\n\n    path2 = path.join(tmpdir, \"test2.txt\")\n    Path(path2).write_bytes(b\"<file2 content>\")\n\n    with create_test_client(form_multi_item_handler) as client, open(path1, \"rb\") as f1, open(path2, \"rb\") as f2:\n        response = client.post(\n            \"/form\",\n            data={\"test1\": \"abc\"},\n            files=[(\"test1\", f1), (\"test1\", (\"test2.txt\", f2, \"text/plain\"))],\n        )\n        assert response.json() == {\n            \"test1\": [\n                \"abc\",\n                {\"filename\": \"test1.txt\", \"content\": \"<file1 content>\", \"content_type\": \"text/plain\"},\n                {\"filename\": \"test2.txt\", \"content\": \"<file2 content>\", \"content_type\": \"text/plain\"},\n            ]\n        }\n\n\ndef test_multipart_request_mixed_files_and_data() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\n            \"/form\",\n            content=(\n                # data\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b'Content-Disposition: form-data; name=\"field0\"\\r\\n\\r\\n'\n                b\"value0\\r\\n\"\n                # file\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"file.txt\"\\r\\n'\n                b\"Content-Type: text/plain\\r\\n\\r\\n\"\n                b\"<file content>\\r\\n\"\n                # data\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b'Content-Disposition: form-data; name=\"field1\"\\r\\n\\r\\n'\n                b\"value1\\r\\n\"\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"},\n        )\n        assert response.json() == {\n            \"file\": {\n                \"filename\": \"file.txt\",\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            },\n            \"field0\": \"value0\",\n            \"field1\": \"value1\",\n        }\n\n\ndef test_multipart_request_with_charset_for_filename() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\n            \"/form\",\n            content=(\n                # file\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe6\\x96\\x87\\xe6\\x9b\\xb8.txt\"\\r\\n'  # noqa: E501\n                b\"Content-Type: text/plain\\r\\n\\r\\n\"\n                b\"<file content>\\r\\n\"\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; charset=utf-8; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"},\n        )\n        assert response.json() == {\n            \"file\": {\n                \"filename\": \"\u6587\u66f8.txt\",\n                \"content\": \"<file content>\",\n                \"content_type\": \"text/plain\",\n            }\n        }\n\n\ndef test_multipart_request_without_charset_for_filename() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\n            \"/form\",\n            content=(\n                # file\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b'Content-Disposition: form-data; name=\"file\"; filename=\"\\xe7\\x94\\xbb\\xe5\\x83\\x8f.jpg\"\\r\\n'  # noqa: E501\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\"\n                b\"<file content>\\r\\n\"\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"},\n        )\n        assert response.json() == {\n            \"file\": {\n                \"filename\": \"\u753b\u50cf.jpg\",\n                \"content\": \"<file content>\",\n                \"content_type\": \"image/jpeg\",\n            }\n        }\n\n\ndef test_multipart_request_with_asterisks_filename() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\n            \"/form\",\n            content=(\n                # file\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c\\r\\n\"\n                b\"Content-Disposition: form-data; name='file'; filename*=utf-8''Na%C3%AFve%20file.jpg\\r\\n\"  # noqa: E501\n                b\"Content-Type: image/jpeg\\r\\n\\r\\n\"\n                b\"<file content>\\r\\n\"\n                b\"--a7f7ac8d4e2e437c877bb7b8d7cc549c--\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; boundary=a7f7ac8d4e2e437c877bb7b8d7cc549c\"},\n        )\n        assert response.json() == {\n            \"'file'\": {\"filename\": \"Na\u00efve file.jpg\", \"content\": \"<file content>\", \"content_type\": \"image/jpeg\"}\n        }\n\n\ndef test_multipart_request_with_encoded_value() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\n            \"/form\",\n            content=(\n                b\"--20b303e711c4ab8c443184ac833ab00f\\r\\n\"\n                b\"Content-Disposition: form-data; \"\n                b'name=\"value\"\\r\\n\\r\\n'\n                b\"Transf\\xc3\\xa9rer\\r\\n\"\n                b\"--20b303e711c4ab8c443184ac833ab00f--\\r\\n\"\n            ),\n            headers={\"Content-Type\": \"multipart/form-data; charset=utf-8; boundary=20b303e711c4ab8c443184ac833ab00f\"},\n        )\n        assert response.json() == {\"value\": \"Transf\u00e9rer\"}\n\n\ndef test_urlencoded_request_data() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\"/form\", data={\"some\": \"data\"})\n        assert response.json() == {\"some\": \"data\"}\n\n\ndef test_no_request_data() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\"/form\")\n        assert response.json() == {}\n\n\ndef test_urlencoded_percent_encoding() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\"/form\", data={\"some\": \"da ta\"})\n        assert response.json() == {\"some\": \"da ta\"}\n\n\ndef test_urlencoded_percent_encoding_keys() -> None:\n    with create_test_client(form_handler) as client:\n        response = client.post(\"/form\", data={\"so me\": \"data\"})\n        assert response.json() == {\"so me\": \"data\"}\n\n\ndef test_postman_multipart_form_data() -> None:\n    postman_body = b'----------------------------850116600781883365617864\\r\\nContent-Disposition: form-data; name=\"attributes\"; filename=\"test-attribute_5.tsv\"\\r\\nContent-Type: text/tab-separated-values\\r\\n\\r\\n\"Campaign ID\"\\t\"Plate Set ID\"\\t\"No\"\\n\\r\\n----------------------------850116600781883365617864\\r\\nContent-Disposition: form-data; name=\"fasta\"; filename=\"test-sequence_correct_5.fasta\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n>P23G01_IgG1-1411:H:Q10C3:1/1:NID18\\r\\nCAGGTATTGAA\\r\\n\\r\\n----------------------------850116600781883365617864--\\r\\n'  # noqa: E501\n    postman_headers = {\n        \"Content-Type\": \"multipart/form-data; boundary=--------------------------850116600781883365617864\",  # noqa: E501\n        \"user-agent\": \"PostmanRuntime/7.26.0\",\n        \"accept\": \"*/*\",\n        \"cache-control\": \"no-cache\",\n        \"host\": \"10.0.5.13:80\",\n        \"accept-encoding\": \"gzip, deflate, br\",\n        \"connection\": \"keep-alive\",\n        \"content-length\": \"2455\",\n    }\n\n    with create_test_client(form_handler) as client:\n        response = client.post(\"/form\", content=postman_body, headers=postman_headers)\n        assert response.json() == {\n            \"attributes\": {\n                \"filename\": \"test-attribute_5.tsv\",\n                \"content\": '\"Campaign ID\"\\t\"Plate Set ID\"\\t\"No\"\\n',\n                \"content_type\": \"text/tab-separated-values\",\n            },\n            \"fasta\": {\n                \"filename\": \"test-sequence_correct_5.fasta\",\n                \"content\": \">P23G01_IgG1-1411:H:Q10C3:1/1:NID18\\r\\nCAGGTATTGAA\\r\\n\",\n                \"content_type\": \"application/octet-stream\",\n            },\n        }\n\n\ndef test_image_upload() -> None:\n    @post(\"/\")\n    async def hello_world(data: UploadFile = Body(media_type=RequestEncodingType.MULTI_PART)) -> None:\n        await data.read()\n\n    with open(join(dirname(realpath(__file__)), \"flower.jpeg\"), \"rb\") as f, create_test_client(\n        route_handlers=[hello_world]\n    ) as client:\n        data = f.read()\n        response = client.post(\"/\", files={\"data\": data})\n        assert response.status_code == HTTP_201_CREATED\n\n\ndef test_optional_formdata() -> None:\n    @post(\"/\")\n    async def hello_world(data: Optional[UploadFile] = Body(media_type=RequestEncodingType.MULTI_PART)) -> None:\n        if data is not None:\n            await data.read()\n\n    with create_test_client(route_handlers=[hello_world]) as client:\n        response = client.post(\"/\")\n        assert response.status_code == HTTP_201_CREATED\n\n\n@pytest.mark.parametrize(\"limit\", (1000, 100, 10))\ndef test_multipart_form_part_limit(limit: int) -> None:\n    @post(\"/\")\n    async def hello_world(data: List[UploadFile] = Body(media_type=RequestEncodingType.MULTI_PART)) -> None:\n        assert len(data) == limit\n\n    with create_test_client(route_handlers=[hello_world], multipart_form_part_limit=limit) as client:\n        data = {str(i): \"a\" for i in range(limit)}\n        response = client.post(\"/\", files=data)\n        assert response.status_code == HTTP_201_CREATED\n\n        data = {str(i): \"a\" for i in range(limit)}\n        data[str(limit + 1)] = \"b\"\n        response = client.post(\"/\", files=data)\n        assert response.status_code == HTTP_400_BAD_REQUEST\n\n\ndef test_multipart_form_part_limit_body_param_precedence() -> None:\n    app_limit = 100\n    route_limit = 10\n\n    @post(\"/\")\n    async def hello_world(\n        data: List[UploadFile] = Body(media_type=RequestEncodingType.MULTI_PART, multipart_form_part_limit=route_limit)\n    ) -> None:\n        assert len(data) == route_limit\n\n    with create_test_client(route_handlers=[hello_world], multipart_form_part_limit=app_limit) as client:\n        data = {str(i): \"a\" for i in range(route_limit)}\n        response = client.post(\"/\", files=data)\n        assert response.status_code == HTTP_201_CREATED\n\n        data = {str(i): \"a\" for i in range(route_limit + 1)}\n        response = client.post(\"/\", files=data)\n        assert response.status_code == HTTP_400_BAD_REQUEST\n"], "filenames": ["starlite/app.py", "starlite/config/app.py", "starlite/connection/request.py", "starlite/kwargs/extractors.py", "starlite/multipart.py", "starlite/params.py", "starlite/testing/create_test_client.py", "tests/app/test_app_config.py", "tests/kwargs/test_multipart_data.py"], "buggy_code_start_loc": [137, 180, 153, 21, 33, 288, 80, 37, 13], "buggy_code_end_loc": [345, 180, 154, 301, 124, 376, 212, 37, 407], "fixing_code_start_loc": [138, 181, 153, 22, 33, 289, 81, 38, 13], "fixing_code_end_loc": [352, 183, 156, 312, 148, 383, 217, 39, 445], "type": "CWE-770", "message": "Starlite is an Asynchronous Server Gateway Interface (ASGI) framework. Prior to version 1.5.2, the request body parsing in `starlite` allows a potentially unauthenticated attacker to consume a large amount of CPU time and RAM. The multipart body parser processes an unlimited number of file parts and an unlimited number of field parts. This is a remote, potentially unauthenticated Denial of Service vulnerability. This vulnerability affects applications with a request handler that accepts a `Body(media_type=RequestEncodingType.MULTI_PART)`. The large amount of CPU time required for processing requests can block all available worker processes and significantly delay or slow down the processing of legitimate user requests. The large amount of RAM accumulated while processing requests can lead to Out-Of-Memory kills. Complete DoS is achievable by sending many concurrent multipart requests in a loop. Version 1.51.2 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2023-25578", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-15T15:15:11.883", "lastModified": "2023-02-24T16:16:25.270", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Starlite is an Asynchronous Server Gateway Interface (ASGI) framework. Prior to version 1.5.2, the request body parsing in `starlite` allows a potentially unauthenticated attacker to consume a large amount of CPU time and RAM. The multipart body parser processes an unlimited number of file parts and an unlimited number of field parts. This is a remote, potentially unauthenticated Denial of Service vulnerability. This vulnerability affects applications with a request handler that accepts a `Body(media_type=RequestEncodingType.MULTI_PART)`. The large amount of CPU time required for processing requests can block all available worker processes and significantly delay or slow down the processing of legitimate user requests. The large amount of RAM accumulated while processing requests can lead to Out-Of-Memory kills. Complete DoS is achievable by sending many concurrent multipart requests in a loop. Version 1.51.2 contains a patch for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:starliteproject:starlite:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.51.2", "matchCriteriaId": "25F2731E-8C59-43E0-9F2F-1A5257FC77E0"}]}]}], "references": [{"url": "https://github.com/starlite-api/starlite/commit/9674fe803628f986c03fe60769048cbc55b5bf83", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/starlite-api/starlite/releases/tag/v1.51.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/starlite-api/starlite/security/advisories/GHSA-p24m-863f-fm6q", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/starlite-api/starlite/commit/9674fe803628f986c03fe60769048cbc55b5bf83"}}