{"buggy_code": ["/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/*  Fluent Bit\n *  ==========\n *  Copyright (C) 2019-2020 The Fluent Bit Authors\n *  Copyright (C) 2015-2018 Treasure Data Inc.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n#include <fluent-bit/flb_info.h>\n#include <fluent-bit/flb_mem.h>\n#include <fluent-bit/flb_log.h>\n#include <fluent-bit/flb_gzip.h>\n#include <miniz/miniz.h>\n\n#define FLB_GZIP_HEADER_OFFSET 10\n\ntypedef enum {\n    FTEXT    = 1,\n    FHCRC    = 2,\n    FEXTRA   = 4,\n    FNAME    = 8,\n    FCOMMENT = 16\n} flb_tinf_gzip_flag;\n\nstatic unsigned int read_le16(const unsigned char *p)\n{\n    return ((unsigned int) p[0]) | ((unsigned int) p[1] << 8);\n}\n\nstatic unsigned int read_le32(const unsigned char *p)\n{\n    return ((unsigned int) p[0])\n        | ((unsigned int) p[1] << 8)\n        | ((unsigned int) p[2] << 16)\n        | ((unsigned int) p[3] << 24);\n}\n\nstatic inline void gzip_header(void *buf)\n{\n    uint8_t *p;\n\n    /* GZip Magic bytes */\n    p = buf;\n    *p++ = 0x1F;\n    *p++ = 0x8B;\n    *p++ = 8;\n    *p++ = 0;\n    *p++ = 0;\n    *p++ = 0;\n    *p++ = 0;\n    *p++ = 0;\n    *p++ = 0;\n    *p++ = 0xFF;\n}\n\nint flb_gzip_compress(void *in_data, size_t in_len,\n                      void **out_data, size_t *out_len)\n{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n    out_size = in_len + 32;\n    out_buf = flb_malloc(out_size);\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;\n    strm.opaque    = Z_NULL;\n    strm.next_in   = in_data;\n    strm.avail_in  = in_len;\n    strm.total_out = 0;\n\n    /* Deflate mode */\n    deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                 Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n\n    /*\n     * Miniz don't support GZip format directly, instead we will:\n     *\n     * - append manual GZip magic bytes\n     * - deflate raw content\n     * - append manual CRC32 data\n     */\n    gzip_header(out_buf);\n\n    /* Header offset */\n    pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n\n    flush = Z_NO_FLUSH;\n    while (1) {\n        strm.next_out  = pb + strm.total_out;\n        strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n\n        if (strm.avail_in == 0) {\n            flush = Z_FINISH;\n        }\n\n        status = deflate(&strm, flush);\n        if (status == Z_STREAM_END) {\n            break;\n        }\n        else if (status != Z_OK) {\n            deflateEnd(&strm);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&strm) != Z_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n    *out_len = strm.total_out;\n\n    /* Construct the gzip checksum (CRC32 footer) */\n    footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n    pb = (uint8_t *) out_buf + footer_start;\n\n    crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n    *pb++ = crc & 0xFF;\n    *pb++ = (crc >> 8) & 0xFF;\n    *pb++ = (crc >> 16) & 0xFF;\n    *pb++ = (crc >> 24) & 0xFF;\n    *pb++ = in_len & 0xFF;\n    *pb++ = (in_len >> 8) & 0xFF;\n    *pb++ = (in_len >> 16) & 0xFF;\n    *pb++ = (in_len >> 24) & 0xFF;\n\n    /* Set the real buffer size for the caller */\n    *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n    *out_data = out_buf;\n\n    return 0;\n}\n\n/* Uncompress (inflate) GZip data */\nint flb_gzip_uncompress(void *in_data, size_t in_len,\n                        void **out_data, size_t *out_len)\n{\n    int status;\n    uint8_t *p;\n    void *out_buf;\n    size_t out_size = 0;\n    void *zip_data;\n    size_t zip_len;\n    unsigned char flg;\n    unsigned int xlen, hcrc;\n    unsigned int dlen, crc;\n    mz_ulong crc_out;\n    mz_stream stream;\n    const unsigned char *start;\n\n    /* Minimal length: header + crc32 */\n    if (in_len < 18) {\n        flb_error(\"[gzip] unexpected content length\");\n        return -1;\n    }\n\n    /* Magic bytes */\n    p = in_data;\n    if (p[0] != 0x1F || p[1] != 0x8B) {\n        flb_error(\"[gzip] invalid magic bytes\");\n        return -1;\n    }\n\n    if (p[2] != 8) {\n        flb_error(\"[gzip] invalid method\");\n        return -1;\n    }\n\n    /* Flag byte */\n    flg = p[3];\n\n    /* Reserved bits */\n    if (flg & 0xE0) {\n        flb_error(\"[gzip] invalid flag\");\n        return -1;\n    }\n\n    /* Skip base header of 10 bytes */\n    start = p + FLB_GZIP_HEADER_OFFSET;\n\n    /* Skip extra data if present */\n    if (flg & FEXTRA) {\n        xlen = read_le16(start);\n        if (xlen > in_len - 12) {\n            flb_error(\"[gzip] invalid gzip data\");\n            return -1;\n        }\n        start += xlen + 2;\n    }\n\n    /* Skip file name if present */\n    if (flg & FNAME) {\n        do {\n            if (start - p >= in_len) {\n                flb_error(\"[gzip] invalid gzip data (FNAME)\");\n                return -1;\n            }\n        } while (*start++);\n    }\n\n    /* Skip file comment if present */\n    if (flg & FCOMMENT) {\n        do {\n            if (start - p >= in_len) {\n                flb_error(\"[gzip] invalid gzip data (FCOMMENT)\");\n                return -1;\n            }\n        } while (*start++);\n    }\n\n    /* Check header crc if present */\n    if (flg & FHCRC) {\n        if (start - p > in_len - 2) {\n            flb_error(\"[gzip] invalid gzip data (FHRC)\");\n            return -1;\n        }\n\n        hcrc = read_le16(start);\n        crc = mz_crc32(MZ_CRC32_INIT, p, start - p) & 0x0000FFFF;\n        if (hcrc != crc) {\n            flb_error(\"[gzip] invalid gzip header CRC\");\n            return -1;\n        }\n        start += 2;\n    }\n\n    /* Get decompressed length */\n    dlen = read_le32(&p[in_len - 4]);\n\n    /* Get CRC32 checksum of original data */\n    crc = read_le32(&p[in_len - 8]);\n\n    /* Decompress data */\n    if ((p + in_len) - p < 8) {\n        flb_error(\"[gzip] invalid gzip CRC32 checksum\");\n        return -1;\n    }\n\n    /* Allocate outgoing buffer */\n    out_buf = flb_malloc(dlen);\n    if (!out_buf) {\n        flb_errno();\n        return -1;\n    }\n    out_size = dlen;\n\n    /* Map zip content */\n    zip_data = (uint8_t *) start;\n    zip_len = (p + in_len) - start - 8;\n\n    memset(&stream, 0, sizeof(stream));\n    stream.next_in = zip_data;\n    stream.avail_in = zip_len;\n    stream.next_out = out_buf;\n    stream.avail_out = out_size;\n\n    status = mz_inflateInit2(&stream, -Z_DEFAULT_WINDOW_BITS);\n    if (status != MZ_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n\n    status = mz_inflate(&stream, MZ_FINISH);\n    if (status != MZ_STREAM_END) {\n        mz_inflateEnd(&stream);\n        flb_free(out_buf);\n        return -1;\n    }\n\n    if (stream.total_out != dlen) {\n        mz_inflateEnd(&stream);\n        flb_free(out_buf);\n        flb_error(\"[gzip] invalid gzip data size\");\n        return -1;\n    }\n\n    /* terminate the stream, it's not longer required */\n    mz_inflateEnd(&stream);\n\n    /* Validate message CRC vs inflated data CRC */\n    crc_out = mz_crc32(MZ_CRC32_INIT, out_buf, dlen);\n    if (crc_out != crc) {\n        flb_free(out_buf);\n        flb_error(\"[gzip] invalid GZip checksum (CRC32)\");\n        return -1;\n    }\n\n    /* set the uncompressed data */\n    *out_len = dlen;\n    *out_data = out_buf;\n\n    return 0;\n}\n"], "fixing_code": ["/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n\n/*  Fluent Bit\n *  ==========\n *  Copyright (C) 2019-2020 The Fluent Bit Authors\n *  Copyright (C) 2015-2018 Treasure Data Inc.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n#include <fluent-bit/flb_info.h>\n#include <fluent-bit/flb_mem.h>\n#include <fluent-bit/flb_log.h>\n#include <fluent-bit/flb_gzip.h>\n#include <miniz/miniz.h>\n\n#define FLB_GZIP_HEADER_OFFSET 10\n\ntypedef enum {\n    FTEXT    = 1,\n    FHCRC    = 2,\n    FEXTRA   = 4,\n    FNAME    = 8,\n    FCOMMENT = 16\n} flb_tinf_gzip_flag;\n\nstatic unsigned int read_le16(const unsigned char *p)\n{\n    return ((unsigned int) p[0]) | ((unsigned int) p[1] << 8);\n}\n\nstatic unsigned int read_le32(const unsigned char *p)\n{\n    return ((unsigned int) p[0])\n        | ((unsigned int) p[1] << 8)\n        | ((unsigned int) p[2] << 16)\n        | ((unsigned int) p[3] << 24);\n}\n\nstatic inline void gzip_header(void *buf)\n{\n    uint8_t *p;\n\n    /* GZip Magic bytes */\n    p = buf;\n    *p++ = 0x1F;\n    *p++ = 0x8B;\n    *p++ = 8;\n    *p++ = 0;\n    *p++ = 0;\n    *p++ = 0;\n    *p++ = 0;\n    *p++ = 0;\n    *p++ = 0;\n    *p++ = 0xFF;\n}\n\nint flb_gzip_compress(void *in_data, size_t in_len,\n                      void **out_data, size_t *out_len)\n{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n\n    /*\n     * GZIP relies on an algorithm with worst-case expansion\n     * of 5 bytes per 32KB data. This means we need to create a variable\n     * length output, that depends on the input length.\n     * See RFC 1951 for details.\n     */\n    int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;\n\n    /*\n     * Max compressed size is equal to sum of:\n     *   10 byte header\n     *   8 byte foot\n     *   max input expansion\n     *   size of input\n     */\n    out_size = 10 + 8 + max_input_expansion + in_len;\n    out_buf = flb_malloc(out_size);\n\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;\n    strm.opaque    = Z_NULL;\n    strm.next_in   = in_data;\n    strm.avail_in  = in_len;\n    strm.total_out = 0;\n\n    /* Deflate mode */\n    deflateInit2(&strm, Z_DEFAULT_COMPRESSION,\n                 Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY);\n\n    /*\n     * Miniz don't support GZip format directly, instead we will:\n     *\n     * - append manual GZip magic bytes\n     * - deflate raw content\n     * - append manual CRC32 data\n     */\n    gzip_header(out_buf);\n\n    /* Header offset */\n    pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET;\n\n    flush = Z_NO_FLUSH;\n    while (1) {\n        strm.next_out  = pb + strm.total_out;\n        strm.avail_out = out_size - (pb - (uint8_t *) out_buf);\n\n        if (strm.avail_in == 0) {\n            flush = Z_FINISH;\n        }\n\n        status = deflate(&strm, flush);\n        if (status == Z_STREAM_END) {\n            break;\n        }\n        else if (status != Z_OK) {\n            deflateEnd(&strm);\n            return -1;\n        }\n    }\n\n    if (deflateEnd(&strm) != Z_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n    *out_len = strm.total_out;\n\n    /* Construct the gzip checksum (CRC32 footer) */\n    footer_start = FLB_GZIP_HEADER_OFFSET + *out_len;\n    pb = (uint8_t *) out_buf + footer_start;\n\n    crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len);\n    *pb++ = crc & 0xFF;\n    *pb++ = (crc >> 8) & 0xFF;\n    *pb++ = (crc >> 16) & 0xFF;\n    *pb++ = (crc >> 24) & 0xFF;\n    *pb++ = in_len & 0xFF;\n    *pb++ = (in_len >> 8) & 0xFF;\n    *pb++ = (in_len >> 16) & 0xFF;\n    *pb++ = (in_len >> 24) & 0xFF;\n\n    /* Set the real buffer size for the caller */\n    *out_len += FLB_GZIP_HEADER_OFFSET + 8;\n    *out_data = out_buf;\n\n    return 0;\n}\n\n/* Uncompress (inflate) GZip data */\nint flb_gzip_uncompress(void *in_data, size_t in_len,\n                        void **out_data, size_t *out_len)\n{\n    int status;\n    uint8_t *p;\n    void *out_buf;\n    size_t out_size = 0;\n    void *zip_data;\n    size_t zip_len;\n    unsigned char flg;\n    unsigned int xlen, hcrc;\n    unsigned int dlen, crc;\n    mz_ulong crc_out;\n    mz_stream stream;\n    const unsigned char *start;\n\n    /* Minimal length: header + crc32 */\n    if (in_len < 18) {\n        flb_error(\"[gzip] unexpected content length\");\n        return -1;\n    }\n\n    /* Magic bytes */\n    p = in_data;\n    if (p[0] != 0x1F || p[1] != 0x8B) {\n        flb_error(\"[gzip] invalid magic bytes\");\n        return -1;\n    }\n\n    if (p[2] != 8) {\n        flb_error(\"[gzip] invalid method\");\n        return -1;\n    }\n\n    /* Flag byte */\n    flg = p[3];\n\n    /* Reserved bits */\n    if (flg & 0xE0) {\n        flb_error(\"[gzip] invalid flag\");\n        return -1;\n    }\n\n    /* Skip base header of 10 bytes */\n    start = p + FLB_GZIP_HEADER_OFFSET;\n\n    /* Skip extra data if present */\n    if (flg & FEXTRA) {\n        xlen = read_le16(start);\n        if (xlen > in_len - 12) {\n            flb_error(\"[gzip] invalid gzip data\");\n            return -1;\n        }\n        start += xlen + 2;\n    }\n\n    /* Skip file name if present */\n    if (flg & FNAME) {\n        do {\n            if (start - p >= in_len) {\n                flb_error(\"[gzip] invalid gzip data (FNAME)\");\n                return -1;\n            }\n        } while (*start++);\n    }\n\n    /* Skip file comment if present */\n    if (flg & FCOMMENT) {\n        do {\n            if (start - p >= in_len) {\n                flb_error(\"[gzip] invalid gzip data (FCOMMENT)\");\n                return -1;\n            }\n        } while (*start++);\n    }\n\n    /* Check header crc if present */\n    if (flg & FHCRC) {\n        if (start - p > in_len - 2) {\n            flb_error(\"[gzip] invalid gzip data (FHRC)\");\n            return -1;\n        }\n\n        hcrc = read_le16(start);\n        crc = mz_crc32(MZ_CRC32_INIT, p, start - p) & 0x0000FFFF;\n        if (hcrc != crc) {\n            flb_error(\"[gzip] invalid gzip header CRC\");\n            return -1;\n        }\n        start += 2;\n    }\n\n    /* Get decompressed length */\n    dlen = read_le32(&p[in_len - 4]);\n\n    /* Get CRC32 checksum of original data */\n    crc = read_le32(&p[in_len - 8]);\n\n    /* Decompress data */\n    if ((p + in_len) - p < 8) {\n        flb_error(\"[gzip] invalid gzip CRC32 checksum\");\n        return -1;\n    }\n\n    /* Allocate outgoing buffer */\n    out_buf = flb_malloc(dlen);\n    if (!out_buf) {\n        flb_errno();\n        return -1;\n    }\n    out_size = dlen;\n\n    /* Map zip content */\n    zip_data = (uint8_t *) start;\n    zip_len = (p + in_len) - start - 8;\n\n    memset(&stream, 0, sizeof(stream));\n    stream.next_in = zip_data;\n    stream.avail_in = zip_len;\n    stream.next_out = out_buf;\n    stream.avail_out = out_size;\n\n    status = mz_inflateInit2(&stream, -Z_DEFAULT_WINDOW_BITS);\n    if (status != MZ_OK) {\n        flb_free(out_buf);\n        return -1;\n    }\n\n    status = mz_inflate(&stream, MZ_FINISH);\n    if (status != MZ_STREAM_END) {\n        mz_inflateEnd(&stream);\n        flb_free(out_buf);\n        return -1;\n    }\n\n    if (stream.total_out != dlen) {\n        mz_inflateEnd(&stream);\n        flb_free(out_buf);\n        flb_error(\"[gzip] invalid gzip data size\");\n        return -1;\n    }\n\n    /* terminate the stream, it's not longer required */\n    mz_inflateEnd(&stream);\n\n    /* Validate message CRC vs inflated data CRC */\n    crc_out = mz_crc32(MZ_CRC32_INIT, out_buf, dlen);\n    if (crc_out != crc) {\n        flb_free(out_buf);\n        flb_error(\"[gzip] invalid GZip checksum (CRC32)\");\n        return -1;\n    }\n\n    /* set the uncompressed data */\n    *out_len = dlen;\n    *out_data = out_buf;\n\n    return 0;\n}\n"], "filenames": ["src/flb_gzip.c"], "buggy_code_start_loc": [80], "buggy_code_end_loc": [81], "fixing_code_start_loc": [80], "fixing_code_end_loc": [99], "type": "CWE-787", "message": "flb_gzip_compress in flb_gzip.c in Fluent Bit before 1.6.4 has an out-of-bounds write because it does not use the correct calculation of the maximum gzip data-size expansion.", "other": {"cve": {"id": "CVE-2020-35963", "sourceIdentifier": "cve@mitre.org", "published": "2021-01-03T19:15:11.673", "lastModified": "2021-01-08T13:45:14.530", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "flb_gzip_compress in flb_gzip.c in Fluent Bit before 1.6.4 has an out-of-bounds write because it does not use the correct calculation of the maximum gzip data-size expansion."}, {"lang": "es", "value": "La funci\u00f3n flb_gzip_compress en el archivo flb_gzip.c en Fluent Bit versiones anteriores a 1.6.4, presenta una escritura fuera de l\u00edmites porque no usa el c\u00e1lculo correcto de la expansi\u00f3n m\u00e1xima de tama\u00f1o de datos gzip."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:treasuredata:fluent_bit:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.4", "matchCriteriaId": "A63D12E6-252A-4091-90AD-AB3DFE6EBEB0"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=27261", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://fluentbit.io/announcements/v1.6.4/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/fluent/fluent-bit/commit/cadff53c093210404aed01c4cf586adb8caa07af", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fluent/fluent-bit/commit/cadff53c093210404aed01c4cf586adb8caa07af"}}