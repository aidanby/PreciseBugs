{"buggy_code": ["'use strict';\n// @ts-check\n// ==================================================================================\n// internet.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2020\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 12. Internet\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// --------------------------\n// check if external site is available\n\nfunction inetChecksite(url, callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let urlSanitized = '';\n      const s = util.sanitizeShellString(url);\n      for (i = 0; i <= 2000; i++) {\n        if (!(s[i] === undefined ||\n          s[i] === ' ' ||\n          s[i] === '{' ||\n          s[i] === '}')) {\n          const sl = s[i].toLowerCase();\n          if (sl[0] && !sl[1]) {\n            urlSanitized = urlSanitized + sl[i];\n          }\n        }\n      }\n      let result = {\n        url: urlSanitized,\n        ok: false,\n        status: 404,\n        ms: -1\n      };\n      if (urlSanitized && !util.isPrototypePolluted()) {\n        let t = Date.now();\n        if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {\n          let args = ' -I --connect-timeout 5 -m 5 ' + urlSanitized + ' 2>/dev/null | head -n 1 | cut -d \" \" -f2';\n          let cmd = 'curl';\n          exec(cmd + args, function (error, stdout) {\n            let statusCode = parseInt(stdout.toString());\n            result.status = statusCode || 404;\n            result.ok = !error && (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n            result.ms = (result.ok ? Date.now() - t : -1);\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        }\n        if (_windows) {   // if this is stable, this can be used for all OS types\n          const http = (urlSanitized.startsWith('https:') ? require('https') : require('http'));\n          try {\n            http.get(urlSanitized, (res) => {\n              const statusCode = res.statusCode;\n\n              result.status = statusCode || 404;\n              result.ok = (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n\n              if (statusCode !== 200) {\n                res.resume();\n                result.ms = (result.ok ? Date.now() - t : -1);\n                if (callback) { callback(result); }\n                resolve(result);\n              } else {\n                res.on('data', () => { });\n                res.on('end', () => {\n                  result.ms = (result.ok ? Date.now() - t : -1);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                });\n              }\n            }).on('error', () => {\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          } catch (err) {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        }\n      } else {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.inetChecksite = inetChecksite;\n\n// --------------------------\n// check inet latency\n\nfunction inetLatency(host, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(host) && !callback) {\n    callback = host;\n    host = '';\n  }\n\n  host = host || '8.8.8.8';\n  const hostSanitized = util.isPrototypePolluted() ? '8.8.8.8' : util.sanitizeShellString(host);\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let cmd;\n      if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n        if (_linux) {\n          cmd = 'ping -c 2 -w 3 ' + hostSanitized + ' | grep rtt';\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          cmd = 'ping -c 2 -t 3 ' + hostSanitized + ' | grep round-trip';\n        }\n        if (_darwin) {\n          cmd = 'ping -c 2 -t 3 ' + hostSanitized + ' | grep avg';\n        }\n\n        exec(cmd, function (error, stdout) {\n          let result = -1;\n          if (!error) {\n            const line = stdout.toString().split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1]);\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        exec('ping -s -a ' + hostSanitized + ' 56 2 | grep avg', { timeout: 3000 }, function (error, stdout) {\n          let result = -1;\n          if (!error) {\n            const line = stdout.toString().split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1].replace(',', '.'));\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        let result = -1;\n        try {\n          exec('ping ' + hostSanitized + ' -n 1', util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\r\\n');\n              lines.shift();\n              lines.forEach(function (line) {\n                if ((line.toLowerCase().match(/ms/g) || []).length === 3) {\n                  let l = line.replace(/ +/g, ' ').split(' ');\n                  if (l.length > 6) {\n                    result = parseFloat(l[l.length - 1]);\n                  }\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.inetLatency = inetLatency;\n", "'use strict';\n// @ts-check\n// ==================================================================================\n// network.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2020\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 9. Network\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _network = {};\nlet _default_iface = '';\nlet _ifaces = {};\nlet _dhcpNics = [];\nlet _networkInterfaces = [];\nlet _mac = {};\nlet pathToIp;\n\nfunction getDefaultNetworkInterface() {\n\n  let ifaces = os.networkInterfaces();\n  let ifacename = '';\n  let ifacenameFirst = '';\n\n  let scopeid = 9999;\n\n  // fallback - \"first\" external interface (sorted by scopeid)\n  for (let dev in ifaces) {\n    if ({}.hasOwnProperty.call(ifaces, dev)) {\n      ifaces[dev].forEach(function (details) {\n        if (details && details.internal === false) {\n          ifacenameFirst = ifacenameFirst || dev; // fallback if no scopeid\n          if (details.scopeid && details.scopeid < scopeid) {\n            ifacename = dev;\n            scopeid = details.scopeid;\n          }\n        }\n      });\n    }\n  }\n  ifacename = ifacename || ifacenameFirst || '';\n\n  try {\n    if (_windows) {\n      // https://www.inetdaemon.com/tutorials/internet/ip/routing/default_route.shtml\n      let defaultIp = '';\n      const cmd = 'netstat -r';\n      const result = execSync(cmd);\n      const lines = result.toString().split(os.EOL);\n      lines.forEach(line => {\n        line = line.replace(/\\s+/g, ' ').trim();\n        if (line.indexOf('0.0.0.0 0.0.0.0') > -1 && !(/[a-zA-Z]/.test(line))) {\n          const parts = line.split(' ');\n          if (parts.length >= 5) {\n            defaultIp = parts[parts.length - 2];\n          }\n        }\n      });\n      if (defaultIp) {\n        for (let dev in ifaces) {\n          if ({}.hasOwnProperty.call(ifaces, dev)) {\n            ifaces[dev].forEach(function (details) {\n              if (details && details.address && details.address === defaultIp) {\n                ifacename = dev;\n              }\n            });\n          }\n        }\n      }\n    }\n    if (_linux) {\n      let cmd = 'ip route 2> /dev/null | grep default';\n      let result = execSync(cmd);\n      let parts = result.toString().split('\\n')[0].split(/\\s+/);\n      if (parts[0] === 'none' && parts[5]) {\n        ifacename = parts[5];\n      } else if (parts[4]) {\n        ifacename = parts[4];\n      }\n\n      if (ifacename.indexOf(':') > -1) {\n        ifacename = ifacename.split(':')[1].trim();\n      }\n    }\n    if (_darwin || _freebsd || _openbsd || _netbsd || _sunos) {\n      let cmd = '';\n      if (_linux) cmd = 'ip route 2> /dev/null | grep default | awk \\'{print $5}\\'';\n      if (_darwin) cmd = 'route -n get default 2>/dev/null | grep interface: | awk \\'{print $2}\\'';\n      if (_freebsd || _openbsd || _netbsd || _sunos) cmd = 'route get 0.0.0.0 | grep interface:';\n      let result = execSync(cmd);\n      ifacename = result.toString().split('\\n')[0];\n      if (ifacename.indexOf(':') > -1) {\n        ifacename = ifacename.split(':')[1].trim();\n      }\n    }\n  } catch (e) {\n    util.noop();\n  }\n  if (ifacename) _default_iface = ifacename;\n  return _default_iface;\n}\n\nexports.getDefaultNetworkInterface = getDefaultNetworkInterface;\n\nfunction getMacAddresses() {\n  let iface = '';\n  let mac = '';\n  let result = {};\n  if (_linux || _freebsd || _openbsd || _netbsd) {\n    if (typeof pathToIp === 'undefined') {\n      try {\n        const lines = execSync('which ip').toString().split('\\n');\n        if (lines.length && lines[0].indexOf(':') === -1 && lines[0].indexOf('/') === 0) {\n          pathToIp = lines[0];\n        } else {\n          pathToIp = '';\n        }\n      } catch (e) {\n        pathToIp = '';\n      }\n    }\n    try {\n      const cmd = 'export LC_ALL=C; ' + ((pathToIp) ? pathToIp + ' link show up' : '/sbin/ifconfig') + '; unset LC_ALL';\n      let res = execSync(cmd);\n      const lines = res.toString().split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i][0] !== ' ') {\n          if (pathToIp) {\n            let nextline = lines[i + 1].trim().split(' ');\n            if (nextline[0] === 'link/ether') {\n              iface = lines[i].split(' ')[1];\n              iface = iface.slice(0, iface.length - 1);\n              mac = nextline[1];\n            }\n          } else {\n            iface = lines[i].split(' ')[0];\n            mac = lines[i].split('HWaddr ')[1];\n          }\n\n          if (iface && mac) {\n            result[iface] = mac.trim();\n            iface = '';\n            mac = '';\n          }\n        }\n      }\n    } catch (e) {\n      util.noop();\n    }\n  }\n  if (_darwin) {\n    try {\n      const cmd = '/sbin/ifconfig';\n      let res = execSync(cmd);\n      const lines = res.toString().split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i][0] !== '\\t' && lines[i].indexOf(':') > 0) {\n          iface = lines[i].split(':')[0];\n        } else if (lines[i].indexOf('\\tether ') === 0) {\n          mac = lines[i].split('\\tether ')[1];\n          if (iface && mac) {\n            result[iface] = mac.trim();\n            iface = '';\n            mac = '';\n          }\n        }\n      }\n    } catch (e) {\n      util.noop();\n    }\n  }\n  return result;\n}\n\nfunction networkInterfaceDefault(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = getDefaultNetworkInterface();\n      if (callback) { callback(result); }\n      resolve(result);\n    });\n  });\n}\n\nexports.networkInterfaceDefault = networkInterfaceDefault;\n\n// --------------------------\n// NET - interfaces\n\nfunction parseLinesWindowsNics(sections, nconfigsections) {\n  let nics = [];\n  for (let i in sections) {\n    if ({}.hasOwnProperty.call(sections, i)) {\n\n      if (sections[i].trim() !== '') {\n\n        let lines = sections[i].trim().split('\\r\\n');\n        let linesNicConfig = nconfigsections[i].trim().split('\\r\\n');\n        let netEnabled = util.getValue(lines, 'NetEnabled', '=');\n\n        if (netEnabled !== '') {\n          const speed = parseInt(util.getValue(lines, 'speed', '=').trim(), 10) / 1000000;\n          nics.push({\n            mac: util.getValue(lines, 'MACAddress', '=').toLowerCase(),\n            dhcp: util.getValue(linesNicConfig, 'dhcpEnabled', '=').toLowerCase(),\n            name: util.getValue(lines, 'Name', '=').replace(/\\]/g, ')').replace(/\\[/g, '('),\n            netEnabled: netEnabled === 'TRUE',\n            speed: isNaN(speed) ? -1 : speed,\n            operstate: util.getValue(lines, 'NetConnectionStatus', '=') === '2' ? 'up' : 'down',\n            type: util.getValue(lines, 'AdapterTypeID', '=') === '9' ? 'wireless' : 'wired'\n          });\n        }\n      }\n    }\n  }\n  return nics;\n}\n\nfunction getWindowsNics() {\n  const cmd = util.getWmic() + ' nic get MACAddress, name, NetEnabled, Speed, NetConnectionStatus, AdapterTypeId /value';\n  const cmdnicconfig = util.getWmic() + ' nicconfig get dhcpEnabled /value';\n  try {\n    const nsections = execSync(cmd, util.execOptsWin).split(/\\n\\s*\\n/);\n    const nconfigsections = execSync(cmdnicconfig, util.execOptsWin).split(/\\n\\s*\\n/);\n    return (parseLinesWindowsNics(nsections, nconfigsections));\n  } catch (e) {\n    return [];\n  }\n}\n\nfunction getWindowsDNSsuffixes() {\n\n  let iface = {};\n\n  let dnsSuffixes = {\n    primaryDNS: '',\n    exitCode: 0,\n    ifaces: [],\n  };\n\n  try {\n    const ipconfig = execSync('ipconfig /all', util.execOptsWin);\n    const ipconfigArray = ipconfig.split('\\r\\n\\r\\n');\n\n    ipconfigArray.forEach((element, index) => {\n\n      if (index == 1) {\n        const longPrimaryDNS = element.split('\\r\\n').filter((element) => {\n          return element.toUpperCase().includes('DNS');\n        });\n        const primaryDNS = longPrimaryDNS[0].substring(longPrimaryDNS[0].lastIndexOf(':') + 1);\n        dnsSuffixes.primaryDNS = primaryDNS.trim();\n        if (!dnsSuffixes.primaryDNS) dnsSuffixes.primaryDNS = 'Not defined';\n      }\n      if (index > 1) {\n        if (index % 2 == 0) {\n          const name = element.substring(element.lastIndexOf(' ') + 1).replace(':', '');\n          iface.name = name;\n        } else {\n          const connectionSpecificDNS = element.split('\\r\\n').filter((element) => {\n            return element.toUpperCase().includes('DNS');\n          });\n          const dnsSuffix = connectionSpecificDNS[0].substring(connectionSpecificDNS[0].lastIndexOf(':') + 1);\n          iface.dnsSuffix = dnsSuffix.trim();\n          dnsSuffixes.ifaces.push(iface);\n          iface = {};\n        }\n      }\n    });\n\n    return dnsSuffixes;\n  } catch (error) {\n    // console.log('An error occurred trying to bring the Connection-specific DNS suffix', error.message);\n    return {\n      primaryDNS: '',\n      exitCode: 0,\n      ifaces: [],\n    };\n  }\n}\n\nfunction getWindowsIfaceDNSsuffix(ifaces, ifacename) {\n  let dnsSuffix = '';\n  // Adding (.) to ensure ifacename compatibility when duplicated iface-names\n  const interfaceName = ifacename + '.';\n  try {\n    const connectionDnsSuffix = ifaces.filter((iface) => {\n      return interfaceName.includes(iface.name + '.');\n    }).map((iface) => iface.dnsSuffix);\n    if (connectionDnsSuffix[0]) {\n      dnsSuffix = connectionDnsSuffix[0];\n    }\n    if (!dnsSuffix) dnsSuffix = '';\n    return dnsSuffix;\n  } catch (error) {\n    // console.log('Error getting Connection-specific DNS suffix: ', error.message);\n    return 'Unknown';\n  }\n}\n\nfunction getWindowsWiredProfilesInformation() {\n  try {\n    const result = execSync('netsh lan show profiles', util.execOptsWin);\n    const profileList = result.split('\\r\\nProfile on interface');\n    return profileList;\n  } catch (error) {\n    if (error.status === 1 && error.stdout.includes('AutoConfig')) {\n      return 'Disabled';\n    }\n    return [];\n  }\n}\n\nfunction getWindowsWirelessIfaceSSID(interfaceName) {\n  try {\n    const result = execSync(`netsh wlan show  interface name=\"${interfaceName}\" | findstr \"SSID\"`, util.execOptsWin);\n    const SSID = result.split('\\r\\n').shift();\n    const parseSSID = SSID.split(':').pop();\n    return parseSSID;\n  } catch (error) {\n    return 'Unknown';\n  }\n}\nfunction getWindowsIEEE8021x(connectionType, iface, ifaces) {\n  let i8021x = {\n    state: 'Unknown',\n    protocol: 'Unknown',\n  };\n\n  if (ifaces === 'Disabled') {\n    i8021x.state = 'Disabled';\n    i8021x.protocol = 'Not defined';\n    return i8021x;\n  }\n\n  if (connectionType == 'wired' && ifaces.length > 0) {\n    try {\n      // Get 802.1x information by interface name\n      const iface8021xInfo = ifaces.find((element) => {\n        return element.includes(iface + '\\r\\n');\n      });\n      const arrayIface8021xInfo = iface8021xInfo.split('\\r\\n');\n      const state8021x = arrayIface8021xInfo.find((element) => {\n        return element.includes('802.1x');\n      });\n\n      if (state8021x.includes('Disabled')) {\n        i8021x.state = 'Disabled';\n        i8021x.protocol = 'Not defined';\n      } else if (state8021x.includes('Enabled')) {\n        const protocol8021x = arrayIface8021xInfo.find((element) => {\n          return element.includes('EAP');\n        });\n        i8021x.protocol = protocol8021x.split(':').pop();\n        i8021x.state = 'Enabled';\n      }\n    } catch (error) {\n      // console.log('Error getting wired information:', error);\n      return i8021x;\n    }\n  } else if (connectionType == 'wireless') {\n\n    let i8021xState = '';\n    let i8021xProtocol = '';\n\n\n\n    try {\n      const SSID = getWindowsWirelessIfaceSSID(iface);\n      if (SSID !== 'Unknown') {\n        i8021xState = execSync(`netsh wlan show profiles \"${SSID}\" | findstr \"802.1X\"`, util.execOptsWin);\n        i8021xProtocol = execSync(`netsh wlan show profiles \"${SSID}\" | findstr \"EAP\"`, util.execOptsWin);\n      }\n\n      if (i8021xState.includes(':') && i8021xProtocol.includes(':')) {\n        i8021x.state = i8021xState.split(':').pop();\n        i8021x.protocol = i8021xProtocol.split(':').pop();\n      }\n    } catch (error) {\n      // console.log('Error getting wireless information:', error);\n      if (error.status === 1 && error.stdout.includes('AutoConfig')) {\n        i8021x.state = 'Disabled';\n        i8021x.protocol = 'Not defined';\n      }\n      return i8021x;\n    }\n  }\n\n  return i8021x;\n}\n\nfunction splitSectionsNics(lines) {\n  const result = [];\n  let section = [];\n  lines.forEach(function (line) {\n    if (!line.startsWith('\\t') && !line.startsWith(' ')) {\n      if (section.length) {\n        result.push(section);\n        section = [];\n      }\n    }\n    section.push(line);\n  });\n  if (section.length) {\n    result.push(section);\n  }\n  return result;\n}\n\nfunction parseLinesDarwinNics(sections) {\n  let nics = [];\n  sections.forEach(section => {\n    let nic = {\n      iface: '',\n      mtu: -1,\n      mac: '',\n      ip6: '',\n      ip4: '',\n      speed: -1,\n      type: '',\n      operstate: '',\n      duplex: '',\n      internal: false\n    };\n    const first = section[0];\n    nic.iface = first.split(':')[0].trim();\n    let parts = first.split('> mtu');\n    nic.mtu = parts.length > 1 ? parseInt(parts[1], 10) : -1;\n    if (isNaN(nic.mtu)) {\n      nic.mtu = -1;\n    }\n    nic.internal = parts[0].toLowerCase().indexOf('loopback') > -1;\n    section.forEach(line => {\n      if (line.trim().startsWith('ether ')) {\n        nic.mac = line.split('ether ')[1].toLowerCase().trim();\n      }\n      if (line.trim().startsWith('inet6 ') && !nic.ip6) {\n        nic.ip6 = line.split('inet6 ')[1].toLowerCase().split('%')[0].split(' ')[0];\n      }\n      if (line.trim().startsWith('inet ') && !nic.ip4) {\n        nic.ip4 = line.split('inet ')[1].toLowerCase().split(' ')[0];\n      }\n    });\n    let speed = util.getValue(section, 'link rate');\n    nic.speed = speed ? parseFloat(speed) : -1;\n    if (nic.speed === -1) {\n      speed = util.getValue(section, 'uplink rate');\n      nic.speed = speed ? parseFloat(speed) : -1;\n      if (nic.speed > -1 && speed.toLowerCase().indexOf('gbps') >= 0) {\n        nic.speed = nic.speed * 1000;\n      }\n    } else {\n      if (speed.toLowerCase().indexOf('gbps') >= 0) {\n        nic.speed = nic.speed * 1000;\n      }\n    }\n    nic.type = util.getValue(section, 'type').toLowerCase().indexOf('wi-fi') > -1 ? 'wireless' : 'wired';\n    nic.operstate = util.getValue(section, 'status').toLowerCase().indexOf('active') > -1 ? 'up' : 'down';\n    nic.duplex = util.getValue(section, 'media').toLowerCase().indexOf('half-duplex') > -1 ? 'half' : 'full';\n    if (nic.ip6 || nic.ip4 || nic.mac) {\n      nics.push(nic);\n    }\n  });\n  return nics;\n}\n\nfunction getDarwinNics() {\n  const cmd = '/sbin/ifconfig -v';\n  try {\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n    const nsections = splitSectionsNics(lines);\n    return (parseLinesDarwinNics(nsections));\n  } catch (e) {\n    return [];\n  }\n}\n\nfunction getLinuxIfaceConnectionName(interfaceName) {\n  const cmd = `nmcli device status 2>/dev/null | grep ${interfaceName}`;\n\n  try {\n    const result = execSync(cmd).toString();\n    const resultFormat = result.replace(/\\s+/g, ' ').trim();\n    const connectionNameLines = resultFormat.split(' ').slice(3);\n    const connectionName = connectionNameLines.join(' ');\n    return connectionName != '--' ? connectionName : '';\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction checkLinuxDCHPInterfaces(file) {\n  let result = [];\n  try {\n    let cmd = `cat ${file} 2> /dev/null | grep 'iface\\\\|source'`;\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n\n    lines.forEach(line => {\n      const parts = line.replace(/\\s+/g, ' ').trim().split(' ');\n      if (parts.length >= 4) {\n        if (line.toLowerCase().indexOf(' inet ') >= 0 && line.toLowerCase().indexOf('dhcp') >= 0) {\n          result.push(parts[1]);\n        }\n      }\n      if (line.toLowerCase().includes('source')) {\n        let file = line.split(' ')[1];\n        result = result.concat(checkLinuxDCHPInterfaces(file));\n      }\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getLinuxDHCPNics() {\n  // alternate methods getting interfaces using DHCP\n  let cmd = 'ip a 2> /dev/null';\n  let result = [];\n  try {\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n    const nsections = splitSectionsNics(lines);\n    result = (parseLinuxDHCPNics(nsections));\n  } catch (e) {\n    util.noop();\n  }\n  try {\n    result = checkLinuxDCHPInterfaces('/etc/network/interfaces');\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction parseLinuxDHCPNics(sections) {\n  const result = [];\n  if (sections && sections.length) {\n    sections.forEach(lines => {\n      if (lines && lines.length) {\n        const parts = lines[0].split(':');\n        if (parts.length > 2) {\n          for (let line of lines) {\n            if (line.indexOf(' inet ') >= 0 && line.indexOf(' dynamic ') >= 0) {\n              const parts2 = line.split(' ');\n              const nic = parts2[parts2.length - 1].trim();\n              result.push(nic);\n              break;\n            }\n          }\n        }\n      }\n    });\n  }\n  return result;\n}\n\nfunction getLinuxIfaceDHCPstatus(iface, connectionName, DHCPNics) {\n  let result = false;\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null \\| grep ipv4.method;`;\n    try {\n      const lines = execSync(cmd).toString();\n      const resultFormat = lines.replace(/\\s+/g, ' ').trim();\n\n      let dhcStatus = resultFormat.split(' ').slice(1).toString();\n      switch (dhcStatus) {\n        case 'auto':\n          result = true;\n          break;\n\n        default:\n          result = false;\n          break;\n      }\n      return result;\n    } catch (e) {\n      return (DHCPNics.indexOf(iface) >= 0);\n    }\n  } else {\n    return (DHCPNics.indexOf(iface) >= 0);\n  }\n}\n\nfunction getDarwinIfaceDHCPstatus(iface) {\n  let result = false;\n  const cmd = `ipconfig getpacket \"${iface}\" 2>/dev/null \\| grep lease_time;`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    if (lines.length && lines[0].startsWith('lease_time')) {\n      result = true;\n    }\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getLinuxIfaceDNSsuffix(connectionName) {\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null \\| grep ipv4.dns-search;`;\n    try {\n      const result = execSync(cmd).toString();\n      const resultFormat = result.replace(/\\s+/g, ' ').trim();\n      const dnsSuffix = resultFormat.split(' ').slice(1).toString();\n      return dnsSuffix == '--' ? 'Not defined' : dnsSuffix;\n    } catch (e) {\n      return 'Unknown';\n    }\n  } else {\n    return 'Unknown';\n  }\n}\n\nfunction getLinuxIfaceIEEE8021xAuth(connectionName) {\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null \\| grep 802-1x.eap;`;\n    try {\n      const result = execSync(cmd).toString();\n      const resultFormat = result.replace(/\\s+/g, ' ').trim();\n      const authenticationProtocol = resultFormat.split(' ').slice(1).toString();\n\n\n      return authenticationProtocol == '--' ? '' : authenticationProtocol;\n    } catch (e) {\n      return 'Not defined';\n    }\n  } else {\n    return 'Not defined';\n  }\n}\n\nfunction getLinuxIfaceIEEE8021xState(authenticationProtocol) {\n  if (authenticationProtocol) {\n    if (authenticationProtocol == 'Not defined') {\n      return 'Disabled';\n    }\n    return 'Enabled';\n  } else {\n    return 'Unknown';\n  }\n}\n\nfunction testVirtualNic(iface, ifaceName, mac) {\n  const virtualMacs = ['00:00:00:00:00:00', '00:03:FF', '00:05:69', '00:0C:29', '00:0F:4B', '00:0F:4B', '00:13:07', '00:13:BE', '00:15:5d', '00:16:3E', '00:1C:42', '00:21:F6', '00:21:F6', '00:24:0B', '00:24:0B', '00:50:56', '00:A0:B1', '00:E0:C8', '08:00:27', '0A:00:27', '18:92:2C', '16:DF:49', '3C:F3:92', '54:52:00', 'FC:15:97'];\n  if (mac) {\n    return virtualMacs.filter(item => { return mac.toUpperCase().toUpperCase().startsWith(item.substr(0, mac.length)); }).length > 0 ||\n      iface.toLowerCase().indexOf(' virtual ') > -1 ||\n      ifaceName.toLowerCase().indexOf(' virtual ') > -1 ||\n      iface.toLowerCase().indexOf('vethernet ') > -1 ||\n      ifaceName.toLowerCase().indexOf('vethernet ') > -1 ||\n      iface.toLowerCase().startsWith('veth') ||\n      ifaceName.toLowerCase().startsWith('veth') ||\n      iface.toLowerCase().startsWith('vboxnet') ||\n      ifaceName.toLowerCase().startsWith('vboxnet');\n  } else return false;\n}\n\nfunction networkInterfaces(callback, rescan = true) {\n\n  if (typeof callback === 'boolean') {\n    rescan = callback;\n    callback = null;\n  }\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let ifaces = os.networkInterfaces();\n\n      let result = [];\n      let nics = [];\n      let dnsSuffixes = [];\n      let nics8021xInfo = [];\n      // seperate handling in OSX\n      if (_darwin || _freebsd || _openbsd || _netbsd) {\n        nics = getDarwinNics();\n\n\n        nics.forEach(nic => {\n\n          if ({}.hasOwnProperty.call(ifaces, nic.iface)) {\n            ifaces[nic.iface].forEach(function (details) {\n              if (details.family === 'IPv4') {\n                nic.ip4subnet = details.netmask;\n              }\n              if (details.family === 'IPv6') {\n                nic.ip6subnet = details.netmask;\n              }\n            });\n          }\n\n          result.push({\n            iface: nic.iface,\n            ifaceName: nic.iface,\n            ip4: nic.ip4,\n            ip4subnet: nic.ip4subnet || '',\n            ip6: nic.ip6,\n            ip6subnet: nic.ip6subnet || '',\n            mac: nic.mac,\n            internal: nic.internal,\n            virtual: nic.internal ? false : testVirtualNic(nic.iface, nic.iface, nic.mac),\n            operstate: nic.operstate,\n            type: nic.type,\n            duplex: nic.duplex,\n            mtu: nic.mtu,\n            speed: nic.speed,\n            dhcp: getDarwinIfaceDHCPstatus(nic.iface),\n            dnsSuffix: '',\n            ieee8021xAuth: '',\n            ieee8021xState: '',\n            carrierChanges: 0\n          });\n        });\n        _networkInterfaces = result;\n        if (callback) { callback(result); }\n        resolve(result);\n      } else {\n        if ((JSON.stringify(ifaces) === JSON.stringify(_ifaces)) && !rescan) {\n          // no changes - just return object\n          result = _networkInterfaces;\n\n          if (callback) { callback(result); }\n          resolve(result);\n        } else {\n          _ifaces = Object.assign({}, ifaces);\n\n          if (_windows) {\n            nics = getWindowsNics();\n            nics.forEach(nic => {\n              let found = false;\n              Object.keys(ifaces).forEach(key => {\n                if (!found) {\n                  ifaces[key].forEach(value => {\n                    if (Object.keys(value).indexOf('mac') >= 0) {\n                      found = value['mac'] === nic.mac;\n                    }\n                  });\n                }\n              });\n\n              if (!found) {\n                ifaces[nic.name] = [{ mac: nic.mac }];\n              }\n            });\n\n            nics8021xInfo = getWindowsWiredProfilesInformation();\n            dnsSuffixes = getWindowsDNSsuffixes();\n          }\n          if (_linux) {\n            _dhcpNics = getLinuxDHCPNics();\n          }\n          for (let dev in ifaces) {\n            let ip4 = '';\n            let ip4subnet = '';\n            let ip6 = '';\n            let ip6subnet = '';\n            let mac = '';\n            let duplex = '';\n            let mtu = '';\n            let speed = -1;\n            let carrierChanges = 0;\n            let operstate = 'down';\n            let dhcp = false;\n            let dnsSuffix = '';\n            let ieee8021xAuth = '';\n            let ieee8021xState = '';\n            let type = '';\n\n            if ({}.hasOwnProperty.call(ifaces, dev)) {\n              let ifaceName = dev;\n              ifaces[dev].forEach(function (details) {\n                if (details.family === 'IPv4') {\n                  ip4 = details.address;\n                  ip4subnet = details.netmask;\n                }\n                if (details.family === 'IPv6') {\n                  if (!ip6 || ip6.match(/^fe80::/i)) {\n                    ip6 = details.address;\n                    ip6subnet = details.netmask;\n                  }\n                }\n                mac = details.mac;\n                // fallback due to https://github.com/nodejs/node/issues/13581 (node 8.1 - node 8.2)\n                if (mac.indexOf('00:00:0') > -1 && (_linux || _darwin) && parseInt(process.versions.node.split('.'), 10) === 8) {\n                  if (Object.keys(_mac).length === 0) {\n                    _mac = getMacAddresses();\n                  }\n                  mac = _mac[dev] || '';\n                }\n              });\n              if (_linux) {\n                let iface = dev.split(':')[0].trim().toLowerCase();\n                const cmd = `echo -n \"addr_assign_type: \"; cat /sys/class/net/${iface}/addr_assign_type 2>/dev/null; echo;\n            echo -n \"address: \"; cat /sys/class/net/${iface}/address 2>/dev/null; echo;\n            echo -n \"addr_len: \"; cat /sys/class/net/${iface}/addr_len 2>/dev/null; echo;\n            echo -n \"broadcast: \"; cat /sys/class/net/${iface}/broadcast 2>/dev/null; echo;\n            echo -n \"carrier: \"; cat /sys/class/net/${iface}/carrier 2>/dev/null; echo;\n            echo -n \"carrier_changes: \"; cat /sys/class/net/${iface}/carrier_changes 2>/dev/null; echo;\n            echo -n \"dev_id: \"; cat /sys/class/net/${iface}/dev_id 2>/dev/null; echo;\n            echo -n \"dev_port: \"; cat /sys/class/net/${iface}/dev_port 2>/dev/null; echo;\n            echo -n \"dormant: \"; cat /sys/class/net/${iface}/dormant 2>/dev/null; echo;\n            echo -n \"duplex: \"; cat /sys/class/net/${iface}/duplex 2>/dev/null; echo;\n            echo -n \"flags: \"; cat /sys/class/net/${iface}/flags 2>/dev/null; echo;\n            echo -n \"gro_flush_timeout: \"; cat /sys/class/net/${iface}/gro_flush_timeout 2>/dev/null; echo;\n            echo -n \"ifalias: \"; cat /sys/class/net/${iface}/ifalias 2>/dev/null; echo;\n            echo -n \"ifindex: \"; cat /sys/class/net/${iface}/ifindex 2>/dev/null; echo;\n            echo -n \"iflink: \"; cat /sys/class/net/${iface}/iflink 2>/dev/null; echo;\n            echo -n \"link_mode: \"; cat /sys/class/net/${iface}/link_mode 2>/dev/null; echo;\n            echo -n \"mtu: \"; cat /sys/class/net/${iface}/mtu 2>/dev/null; echo;\n            echo -n \"netdev_group: \"; cat /sys/class/net/${iface}/netdev_group 2>/dev/null; echo;\n            echo -n \"operstate: \"; cat /sys/class/net/${iface}/operstate 2>/dev/null; echo;\n            echo -n \"proto_down: \"; cat /sys/class/net/${iface}/proto_down 2>/dev/null; echo;\n            echo -n \"speed: \"; cat /sys/class/net/${iface}/speed 2>/dev/null; echo;\n            echo -n \"tx_queue_len: \"; cat /sys/class/net/${iface}/tx_queue_len 2>/dev/null; echo;\n            echo -n \"type: \"; cat /sys/class/net/${iface}/type 2>/dev/null; echo;\n            echo -n \"wireless: \"; cat /proc/net/wireless 2>/dev/null \\| grep ${iface}; echo;\n            echo -n \"wirelessspeed: \"; iw dev ${iface} link 2>&1 \\| grep bitrate; echo;`;\n\n                let lines = [];\n                try {\n                  lines = execSync(cmd).toString().split('\\n');\n                  const connectionName = getLinuxIfaceConnectionName(iface);\n                  dhcp = getLinuxIfaceDHCPstatus(iface, connectionName, _dhcpNics);\n                  dnsSuffix = getLinuxIfaceDNSsuffix(connectionName);\n                  ieee8021xAuth = getLinuxIfaceIEEE8021xAuth(connectionName);\n                  ieee8021xState = getLinuxIfaceIEEE8021xState(ieee8021xAuth);\n                } catch (e) {\n                  util.noop();\n                }\n                duplex = util.getValue(lines, 'duplex');\n                duplex = duplex.startsWith('cat') ? '' : duplex;\n                mtu = parseInt(util.getValue(lines, 'mtu'), 10);\n                let myspeed = parseInt(util.getValue(lines, 'speed'), 10);\n                speed = isNaN(myspeed) ? -1 : myspeed;\n                let wirelessspeed = util.getValue(lines, 'wirelessspeed').split('tx bitrate: ');\n                if (speed === -1 && wirelessspeed.length === 2) {\n                  myspeed = parseFloat(wirelessspeed[1]);\n                  speed = isNaN(myspeed) ? -1 : myspeed;\n                }\n                carrierChanges = parseInt(util.getValue(lines, 'carrier_changes'), 10);\n                operstate = util.getValue(lines, 'operstate');\n                type = operstate === 'up' ? (util.getValue(lines, 'wireless').trim() ? 'wireless' : 'wired') : 'unknown';\n                if (iface === 'lo' || iface.startsWith('bond')) { type = 'virtual'; }\n              }\n              if (_windows) {\n\n\n                dnsSuffix = getWindowsIfaceDNSsuffix(dnsSuffixes.ifaces, dev);\n                nics.forEach(detail => {\n                  if (detail.mac === mac) {\n                    ifaceName = detail.name;\n                    dhcp = detail.dhcp;\n                    operstate = detail.operstate;\n                    speed = detail.speed;\n                    type = detail.type;\n                  }\n                });\n\n                if (dev.toLowerCase().indexOf('wlan') >= 0 || ifaceName.toLowerCase().indexOf('wlan') >= 0 || ifaceName.toLowerCase().indexOf('802.11n') >= 0 || ifaceName.toLowerCase().indexOf('wireless') >= 0 || ifaceName.toLowerCase().indexOf('wi-fi') >= 0 || ifaceName.toLowerCase().indexOf('wifi') >= 0) {\n                  type = 'wireless';\n                }\n\n                const IEEE8021x = getWindowsIEEE8021x(type, dev, nics8021xInfo);\n                ieee8021xAuth = IEEE8021x.protocol;\n                ieee8021xState = IEEE8021x.state;\n              }\n              let internal = (ifaces[dev] && ifaces[dev][0]) ? ifaces[dev][0].internal : false;\n              if (dev.toLowerCase().indexOf('loopback') > -1 || ifaceName.toLowerCase().indexOf('loopback') > -1) {\n                internal = true;\n              }\n              const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);\n              result.push({\n                iface: dev,\n                ifaceName,\n                ip4,\n                ip4subnet,\n                ip6,\n                ip6subnet,\n                mac,\n                internal,\n                virtual,\n                operstate,\n                type,\n                duplex,\n                mtu,\n                speed,\n                dhcp,\n                dnsSuffix,\n                ieee8021xAuth,\n                ieee8021xState,\n                carrierChanges,\n              });\n            }\n          }\n          _networkInterfaces = result;\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkInterfaces = networkInterfaces;\n\n// --------------------------\n// NET - Speed\n\nfunction calcNetworkSpeed(iface, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors) {\n  let result = {\n    iface,\n    operstate,\n    rx_bytes,\n    rx_dropped,\n    rx_errors,\n    tx_bytes,\n    tx_dropped,\n    tx_errors,\n    rx_sec: -1,\n    tx_sec: -1,\n    ms: 0\n  };\n\n  if (_network[iface] && _network[iface].ms) {\n    result.ms = Date.now() - _network[iface].ms;\n    result.rx_sec = (rx_bytes - _network[iface].rx_bytes) >= 0 ? (rx_bytes - _network[iface].rx_bytes) / (result.ms / 1000) : 0;\n    result.tx_sec = (tx_bytes - _network[iface].tx_bytes) >= 0 ? (tx_bytes - _network[iface].tx_bytes) / (result.ms / 1000) : 0;\n    _network[iface].rx_bytes = rx_bytes;\n    _network[iface].tx_bytes = tx_bytes;\n    _network[iface].rx_sec = result.rx_sec;\n    _network[iface].tx_sec = result.tx_sec;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = result.ms;\n    _network[iface].operstate = operstate;\n  } else {\n    if (!_network[iface]) _network[iface] = {};\n    _network[iface].rx_bytes = rx_bytes;\n    _network[iface].tx_bytes = tx_bytes;\n    _network[iface].rx_sec = -1;\n    _network[iface].tx_sec = -1;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = 0;\n    _network[iface].operstate = operstate;\n  }\n  return result;\n}\n\nfunction networkStats(ifaces, callback) {\n\n  let ifacesArray = [];\n  // fallback - if only callback is given\n  if (util.isFunction(ifaces) && !callback) {\n    callback = ifaces;\n    ifacesArray = [getDefaultNetworkInterface()];\n  } else {\n    ifaces = ifaces || getDefaultNetworkInterface();\n    ifaces = ifaces.trim().toLowerCase().replace(/,+/g, '|');\n    ifacesArray = ifaces.split('|');\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      const result = [];\n\n      const workload = [];\n      if (ifacesArray.length && ifacesArray[0].trim() === '*') {\n        ifacesArray = [];\n        networkInterfaces(false).then(allIFaces => {\n          for (let iface of allIFaces) {\n            ifacesArray.push(iface.iface);\n          }\n          networkStats(ifacesArray.join(',')).then(result => {\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        });\n      } else {\n        for (let iface of ifacesArray) {\n          workload.push(networkStatsSingle(iface.trim()));\n        }\n        if (workload.length) {\n          Promise.all(\n            workload\n          ).then(data => {\n            if (callback) { callback(data); }\n            resolve(data);\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nfunction networkStatsSingle(iface) {\n\n  function parseLinesWindowsPerfData(sections) {\n    let perfData = [];\n    for (let i in sections) {\n      if ({}.hasOwnProperty.call(sections, i)) {\n        if (sections[i].trim() !== '') {\n          let lines = sections[i].trim().split('\\r\\n');\n          perfData.push({\n            name: util.getValue(lines, 'Name', '=').replace(/[()\\[\\] ]+/g, '').replace('#', '_').toLowerCase(),\n            rx_bytes: parseInt(util.getValue(lines, 'BytesReceivedPersec', '='), 10),\n            rx_errors: parseInt(util.getValue(lines, 'PacketsReceivedErrors', '='), 10),\n            rx_dropped: parseInt(util.getValue(lines, 'PacketsReceivedDiscarded', '='), 10),\n            tx_bytes: parseInt(util.getValue(lines, 'BytesSentPersec', '='), 10),\n            tx_errors: parseInt(util.getValue(lines, 'PacketsOutboundErrors', '='), 10),\n            tx_dropped: parseInt(util.getValue(lines, 'PacketsOutboundDiscarded', '='), 10)\n          });\n        }\n      }\n    }\n    return perfData;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      const ifaceSanitized = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(iface);\n\n      let result = {\n        iface: ifaceSanitized,\n        operstate: 'unknown',\n        rx_bytes: 0,\n        rx_dropped: 0,\n        rx_errors: 0,\n        tx_bytes: 0,\n        tx_dropped: 0,\n        tx_errors: 0,\n        rx_sec: -1,\n        tx_sec: -1,\n        ms: 0\n      };\n\n      let operstate = 'unknown';\n      let rx_bytes = 0;\n      let tx_bytes = 0;\n      let rx_dropped = 0;\n      let rx_errors = 0;\n      let tx_dropped = 0;\n      let tx_errors = 0;\n\n      let cmd, lines, stats;\n      if (!_network[ifaceSanitized] || (_network[ifaceSanitized] && !_network[ifaceSanitized].ms) || (_network[ifaceSanitized] && _network[ifaceSanitized].ms && Date.now() - _network[ifaceSanitized].ms >= 500)) {\n        if (_linux) {\n          if (fs.existsSync('/sys/class/net/' + ifaceSanitized)) {\n            cmd =\n              'cat /sys/class/net/' + ifaceSanitized + '/operstate; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_bytes; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_bytes; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_dropped; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_errors; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_dropped; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_errors; ';\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                operstate = lines[0].trim();\n                rx_bytes = parseInt(lines[1], 10);\n                tx_bytes = parseInt(lines[2], 10);\n                rx_dropped = parseInt(lines[3], 10);\n                rx_errors = parseInt(lines[4], 10);\n                tx_dropped = parseInt(lines[5], 10);\n                tx_errors = parseInt(lines[6], 10);\n\n                result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n\n              }\n              resolve(result);\n            });\n          } else {\n            resolve(result);\n          }\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          cmd = 'netstat -ibndI ' + ifaceSanitized;\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              lines = stdout.toString().split('\\n');\n              for (let i = 1; i < lines.length; i++) {\n                const line = lines[i].replace(/ +/g, ' ').split(' ');\n                if (line && line[0] && line[7] && line[10]) {\n                  rx_bytes = rx_bytes + parseInt(line[7]);\n                  if (line[6].trim() !== '-') { rx_dropped = rx_dropped + parseInt(line[6]); }\n                  if (line[5].trim() !== '-') { rx_errors = rx_errors + parseInt(line[5]); }\n                  tx_bytes = tx_bytes + parseInt(line[10]);\n                  if (line[12].trim() !== '-') { tx_dropped = tx_dropped + parseInt(line[12]); }\n                  if (line[9].trim() !== '-') { tx_errors = tx_errors + parseInt(line[9]); }\n                  operstate = 'up';\n                }\n              }\n              result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n            }\n            resolve(result);\n          });\n        }\n        if (_darwin) {\n          cmd = 'ifconfig ' + ifaceSanitized + ' | grep \"status\"';\n          exec(cmd, function (error, stdout) {\n            result.operstate = (stdout.toString().split(':')[1] || '').trim();\n            result.operstate = (result.operstate || '').toLowerCase();\n            result.operstate = (result.operstate === 'active' ? 'up' : (result.operstate === 'inactive' ? 'down' : 'unknown'));\n            cmd = 'netstat -bdI ' + ifaceSanitized;\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                // if there is less than 2 lines, no information for this interface was found\n                if (lines.length > 1 && lines[1].trim() !== '') {\n                  // skip header line\n                  // use the second line because it is tied to the NIC instead of the ipv4 or ipv6 address\n                  stats = lines[1].replace(/ +/g, ' ').split(' ');\n                  rx_bytes = parseInt(stats[6]);\n                  rx_dropped = parseInt(stats[11]);\n                  rx_errors = parseInt(stats[5]);\n                  tx_bytes = parseInt(stats[9]);\n                  tx_dropped = parseInt(stats[11]);\n                  tx_errors = parseInt(stats[8]);\n\n                  result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, result.operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n                }\n              }\n              resolve(result);\n            });\n          });\n        }\n        if (_windows) {\n          let perfData = [];\n          let ifaceName = ifaceSanitized;\n\n          // Performance Data\n          util.wmic('path Win32_PerfRawData_Tcpip_NetworkInterface Get name,BytesReceivedPersec,BytesSentPersec,BytesTotalPersec,PacketsOutboundDiscarded,PacketsOutboundErrors,PacketsReceivedDiscarded,PacketsReceivedErrors /value').then((stdout, error) => {\n            if (!error) {\n              const psections = stdout.toString().split(/\\n\\s*\\n/);\n              perfData = parseLinesWindowsPerfData(psections);\n            }\n\n            // Network Interfaces\n            networkInterfaces(false).then(interfaces => {\n              // get bytes sent, received from perfData by name\n              rx_bytes = 0;\n              tx_bytes = 0;\n              perfData.forEach(detail => {\n                interfaces.forEach(det => {\n                  if ((det.iface.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.mac.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ip4.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ip6.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ifaceName.replace(/[()\\[\\] ]+/g, '').replace('#', '_').toLowerCase() === ifaceSanitized.replace(/[()\\[\\] ]+/g, '').replace('#', '_').toLowerCase()) &&\n                    (det.ifaceName.replace(/[()\\[\\] ]+/g, '').replace('#', '_').toLowerCase() === detail.name)) {\n                    ifaceName = det.iface;\n                    rx_bytes = detail.rx_bytes;\n                    rx_dropped = detail.rx_dropped;\n                    rx_errors = detail.rx_errors;\n                    tx_bytes = detail.tx_bytes;\n                    tx_dropped = detail.tx_dropped;\n                    tx_errors = detail.tx_errors;\n                    operstate = det.operstate;\n                  }\n                });\n              });\n              if (rx_bytes && tx_bytes) {\n                result = calcNetworkSpeed(ifaceName, parseInt(rx_bytes), parseInt(tx_bytes), operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n              }\n              resolve(result);\n            });\n          });\n        }\n      } else {\n        result.rx_bytes = _network[ifaceSanitized].rx_bytes;\n        result.tx_bytes = _network[ifaceSanitized].tx_bytes;\n        result.rx_sec = _network[ifaceSanitized].rx_sec;\n        result.tx_sec = _network[ifaceSanitized].tx_sec;\n        result.ms = _network[ifaceSanitized].last_ms;\n        result.operstate = _network[ifaceSanitized].operstate;\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.networkStats = networkStats;\n\n// --------------------------\n// NET - connections (sockets)\n\nfunction networkConnections(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'export LC_ALL=C; netstat -tunap | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"; unset LC_ALL';\n        if (_freebsd || _openbsd || _netbsd) cmd = 'export LC_ALL=C; netstat -na | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"; unset LC_ALL';\n        exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          if (!error && (lines.length > 1 || lines[0] != '')) {\n            lines.forEach(function (line) {\n              line = line.replace(/ +/g, ' ').split(' ');\n              if (line.length >= 7) {\n                let localip = line[3];\n                let localport = '';\n                let localaddress = line[3].split(':');\n                if (localaddress.length > 1) {\n                  localport = localaddress[localaddress.length - 1];\n                  localaddress.pop();\n                  localip = localaddress.join(':');\n                }\n                let peerip = line[4];\n                let peerport = '';\n                let peeraddress = line[4].split(':');\n                if (peeraddress.length > 1) {\n                  peerport = peeraddress[peeraddress.length - 1];\n                  peeraddress.pop();\n                  peerip = peeraddress.join(':');\n                }\n                let connstate = line[5];\n                // if (connstate === 'VERBUNDEN') connstate = 'ESTABLISHED';\n                let proc = line[6].split('/');\n\n                if (connstate) {\n                  result.push({\n                    protocol: line[0],\n                    localaddress: localip,\n                    localport: localport,\n                    peeraddress: peerip,\n                    peerport: peerport,\n                    state: connstate,\n                    pid: proc[0] && proc[0] !== '-' ? parseInt(proc[0], 10) : -1,\n                    process: proc[1] ? proc[1].split(' ')[0] : ''\n                  });\n                }\n              }\n            });\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          } else {\n            cmd = 'ss -tunap | grep \"ESTAB\\\\|SYN-SENT\\\\|SYN-RECV\\\\|FIN-WAIT1\\\\|FIN-WAIT2\\\\|TIME-WAIT\\\\|CLOSE\\\\|CLOSE-WAIT\\\\|LAST-ACK\\\\|LISTEN\\\\|CLOSING\"';\n            exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                lines.forEach(function (line) {\n                  line = line.replace(/ +/g, ' ').split(' ');\n                  if (line.length >= 6) {\n                    let localip = line[4];\n                    let localport = '';\n                    let localaddress = line[4].split(':');\n                    if (localaddress.length > 1) {\n                      localport = localaddress[localaddress.length - 1];\n                      localaddress.pop();\n                      localip = localaddress.join(':');\n                    }\n                    let peerip = line[5];\n                    let peerport = '';\n                    let peeraddress = line[5].split(':');\n                    if (peeraddress.length > 1) {\n                      peerport = peeraddress[peeraddress.length - 1];\n                      peeraddress.pop();\n                      peerip = peeraddress.join(':');\n                    }\n                    let connstate = line[1];\n                    if (connstate === 'ESTAB') connstate = 'ESTABLISHED';\n                    if (connstate === 'TIME-WAIT') connstate = 'TIME_WAIT';\n                    let pid = -1;\n                    let process = '';\n                    if (line.length >= 7 && line[6].indexOf('users:') > -1) {\n                      let proc = line[6].replace('users:((\"', '').replace(/\"/g, '').split(',');\n                      if (proc.length > 2) {\n                        process = proc[0].split(' ')[0];\n                        pid = parseInt(proc[1], 10);\n                      }\n                    }\n                    if (connstate) {\n                      result.push({\n                        protocol: line[0],\n                        localaddress: localip,\n                        localport: localport,\n                        peeraddress: peerip,\n                        peerport: peerport,\n                        state: connstate,\n                        pid,\n                        process\n                      });\n                    }\n                  }\n                });\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          }\n        });\n      }\n      if (_darwin) {\n        let cmd = 'netstat -natv | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"';\n        exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n          if (!error) {\n\n            let lines = stdout.toString().split('\\n');\n\n            lines.forEach(function (line) {\n              line = line.replace(/ +/g, ' ').split(' ');\n              if (line.length >= 8) {\n                let localip = line[3];\n                let localport = '';\n                let localaddress = line[3].split('.');\n                if (localaddress.length > 1) {\n                  localport = localaddress[localaddress.length - 1];\n                  localaddress.pop();\n                  localip = localaddress.join('.');\n                }\n                let peerip = line[4];\n                let peerport = '';\n                let peeraddress = line[4].split('.');\n                if (peeraddress.length > 1) {\n                  peerport = peeraddress[peeraddress.length - 1];\n                  peeraddress.pop();\n                  peerip = peeraddress.join('.');\n                }\n                let connstate = line[5];\n                let pid = parseInt(line[8], 10);\n                if (connstate) {\n                  result.push({\n                    protocol: line[0],\n                    localaddress: localip,\n                    localport: localport,\n                    peeraddress: peerip,\n                    peerport: peerport,\n                    state: connstate,\n                    pid: pid,\n                    process: ''\n                  });\n                }\n              }\n            });\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          }\n        });\n      }\n      if (_windows) {\n        let cmd = 'netstat -nao';\n        try {\n          exec(cmd, util.execOptsWin, function (error, stdout) {\n            if (!error) {\n\n              let lines = stdout.toString().split('\\r\\n');\n\n              lines.forEach(function (line) {\n                line = line.trim().replace(/ +/g, ' ').split(' ');\n                if (line.length >= 4) {\n                  let localip = line[1];\n                  let localport = '';\n                  let localaddress = line[1].split(':');\n                  if (localaddress.length > 1) {\n                    localport = localaddress[localaddress.length - 1];\n                    localaddress.pop();\n                    localip = localaddress.join(':');\n                  }\n                  let peerip = line[2];\n                  let peerport = '';\n                  let peeraddress = line[2].split(':');\n                  if (peeraddress.length > 1) {\n                    peerport = peeraddress[peeraddress.length - 1];\n                    peeraddress.pop();\n                    peerip = peeraddress.join(':');\n                  }\n                  let pid = line[4];\n                  let connstate = line[3];\n                  if (connstate === 'HERGESTELLT') connstate = 'ESTABLISHED';\n                  if (connstate.startsWith('ABH')) connstate = 'LISTEN';\n                  if (connstate === 'SCHLIESSEN_WARTEN') connstate = 'CLOSE_WAIT';\n                  if (connstate === 'WARTEND') connstate = 'TIME_WAIT';\n                  if (connstate === 'SYN_GESENDET') connstate = 'SYN_SENT';\n\n                  if (connstate === 'LISTENING') connstate = 'LISTEN';\n                  if (connstate === 'SYN_RECEIVED') connstate = 'SYN_RECV';\n                  if (connstate === 'FIN_WAIT_1') connstate = 'FIN_WAIT1';\n                  if (connstate === 'FIN_WAIT_2') connstate = 'FIN_WAIT2';\n                  if (connstate) {\n                    result.push({\n                      protocol: line[0].toLowerCase(),\n                      localaddress: localip,\n                      localport: localport,\n                      peeraddress: peerip,\n                      peerport: peerport,\n                      state: connstate,\n                      pid,\n                      process: ''\n                    });\n                  }\n                }\n              });\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkConnections = networkConnections;\n\nfunction networkGatewayDefault(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = '';\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'ip route get 1';\n        try {\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              const line = lines && lines[0] ? lines[0] : '';\n              let parts = line.split(' via ');\n              if (parts && parts[1]) {\n                parts = parts[1].split(' ');\n                result = parts[0];\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_darwin) {\n        let cmd = 'route -n get default';\n        try {\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n').map(line => line.trim());\n              result = util.getValue(lines, 'gateway');\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_windows) {\n        try {\n          exec('netstat -r', util.execOptsWin, function (error, stdout) {\n            const lines = stdout.toString().split(os.EOL);\n            lines.forEach(line => {\n              line = line.replace(/\\s+/g, ' ').trim();\n              if (line.indexOf('0.0.0.0 0.0.0.0') > -1 && !(/[a-zA-Z]/.test(line))) {\n                const parts = line.split(' ');\n                if (parts.length >= 5 && (parts[parts.length - 3]).indexOf('.') > -1) {\n                  result = parts[parts.length - 3];\n                }\n              }\n            });\n            if (!result) {\n              util.powerShell('Get-CimInstance -ClassName Win32_IP4RouteTable | Where-Object { $_.Destination -eq \\'0.0.0.0\\' -and $_.Mask -eq \\'0.0.0.0\\' }')\n                .then(data => {\n                  let lines = data.toString().split('\\r\\n');\n                  if (lines.length > 1 && !result) {\n                    result = util.getValue(lines, 'NextHop');\n                    if (callback) {\n                      callback(result);\n                    }\n                    resolve(result);\n                    // } else {\n                    //   exec('ipconfig', util.execOptsWin, function (error, stdout) {\n                    //     let lines = stdout.toString().split('\\r\\n');\n                    //     lines.forEach(function (line) {\n                    //       line = line.trim().replace(/\\. /g, '');\n                    //       line = line.trim().replace(/ +/g, '');\n                    //       const parts = line.split(':');\n                    //       if ((parts[0].toLowerCase().startsWith('standardgate') || parts[0].toLowerCase().indexOf('gateway') > -1 || parts[0].toLowerCase().indexOf('enlace') > -1) && parts[1]) {\n                    //         result = parts[1];\n                    //       }\n                    //     });\n                    //     if (callback) { callback(result); }\n                    //     resolve(result);\n                    //   });\n                  }\n                });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkGatewayDefault = networkGatewayDefault;\n", "'use strict';\n// @ts-check\n// ==================================================================================\n// utils.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2020\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 0. helper functions\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst spawn = require('child_process').spawn;\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('util');\n\nlet _platform = process.platform;\nconst _linux = (_platform === 'linux');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\n// const _sunos = (_platform === 'sunos');\n\nlet _cores = 0;\nlet wmicPath = '';\nlet codepage = '';\n\nconst execOptsWin = {\n  windowsHide: true,\n  maxBuffer: 1024 * 20000,\n  encoding: 'UTF-8',\n  env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n};\n\nfunction toInt(value) {\n  let result = parseInt(value, 10);\n  if (isNaN(result)) {\n    result = 0;\n  }\n  return result;\n}\n\nfunction isFunction(functionToCheck) {\n  let getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\nfunction unique(obj) {\n  let uniques = [];\n  let stringify = {};\n  for (let i = 0; i < obj.length; i++) {\n    let keys = Object.keys(obj[i]);\n    keys.sort(function (a, b) { return a - b; });\n    let str = '';\n    for (let j = 0; j < keys.length; j++) {\n      str += JSON.stringify(keys[j]);\n      str += JSON.stringify(obj[i][keys[j]]);\n    }\n    if (!{}.hasOwnProperty.call(stringify, str)) {\n      uniques.push(obj[i]);\n      stringify[str] = true;\n    }\n  }\n  return uniques;\n}\n\nfunction sortByKey(array, keys) {\n  return array.sort(function (a, b) {\n    let x = '';\n    let y = '';\n    keys.forEach(function (key) {\n      x = x + a[key]; y = y + b[key];\n    });\n    return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n  });\n}\n\nfunction cores() {\n  if (_cores === 0) {\n    _cores = os.cpus().length;\n  }\n  return _cores;\n}\n\nfunction getValue(lines, property, separator, trimmed) {\n  separator = separator || ':';\n  property = property.toLowerCase();\n  trimmed = trimmed || false;\n  for (let i = 0; i < lines.length; i++) {\n    let line = lines[i].toLowerCase().replace(/\\t/g, '');\n    if (trimmed) {\n      line = line.trim();\n    }\n    if (line.startsWith(property)) {\n      const parts = lines[i].split(separator);\n      if (parts.length >= 2) {\n        parts.shift();\n        return parts.join(separator).trim();\n      } else {\n        return '';\n      }\n    }\n  }\n  return '';\n}\n\nfunction decodeEscapeSequence(str, base) {\n  base = base || 16;\n  return str.replace(/\\\\x([0-9A-Fa-f]{2})/g, function () {\n    return String.fromCharCode(parseInt(arguments[1], base));\n  });\n}\n\nfunction detectSplit(str) {\n  let seperator = '';\n  let part = 0;\n  str.split('').forEach(element => {\n    if (element >= '0' && element <= '9') {\n      if (part === 1) { part++; }\n    } else {\n      if (part === 0) { part++; }\n      if (part === 1) {\n        seperator += element;\n      }\n    }\n  });\n  return seperator;\n}\n\nfunction parseTime(t, pmDesignator) {\n  pmDesignator = pmDesignator || '';\n  t = t.toUpperCase();\n  let hour = 0;\n  let min = 0;\n  let splitter = detectSplit(t);\n  let parts = t.split(splitter);\n  if (parts.length >= 2) {\n    if (parts[2]) {\n      parts[1] += parts[2];\n    }\n    let isPM = (parts[1] && (parts[1].toLowerCase().indexOf('pm') > -1) || (parts[1].toLowerCase().indexOf('p.m.') > -1) || (parts[1].toLowerCase().indexOf('p. m.') > -1) || (parts[1].toLowerCase().indexOf('n') > -1) || (parts[1].toLowerCase().indexOf('ch') > -1) || (parts[1].toLowerCase().indexOf('\u00f6s') > -1) || (pmDesignator && parts[1].toLowerCase().indexOf(pmDesignator) > -1));\n    hour = parseInt(parts[0], 10);\n    min = parseInt(parts[1], 10);\n    hour = isPM && hour < 12 ? hour + 12 : hour;\n    return ('0' + hour).substr(-2) + ':' + ('0' + min).substr(-2);\n  }\n}\n\nfunction parseDateTime(dt, culture) {\n  const result = {\n    date: '',\n    time: ''\n  };\n  culture = culture || {};\n  let dateFormat = (culture.dateFormat || '').toLowerCase();\n  let pmDesignator = (culture.pmDesignator || '');\n\n  const parts = dt.split(' ');\n  if (parts[0]) {\n    if (parts[0].indexOf('/') >= 0) {\n      // Dateformat: mm/dd/yyyy or dd/mm/yyyy or dd/mm/yy or yyyy/mm/dd\n      const dtparts = parts[0].split('/');\n      if (dtparts.length === 3) {\n        if (dtparts[0].length === 4) {\n          // Dateformat: yyyy/mm/dd\n          result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n        } else if (dtparts[2].length === 2) {\n          if ((dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1)) {\n            // Dateformat: mm/dd/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        } else {\n          // Dateformat: mm/dd/yyyy or dd/mm/yyyy\n          const isEN = ((dt.toLowerCase().indexOf('pm') > -1) || (dt.toLowerCase().indexOf('p.m.') > -1) || (dt.toLowerCase().indexOf('p. m.') > -1) || (dt.toLowerCase().indexOf('am') > -1) || (dt.toLowerCase().indexOf('a.m.') > -1) || (dt.toLowerCase().indexOf('a. m.') > -1));\n          if ((isEN || dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1) && dateFormat.indexOf('dd/') !== 0) {\n            // Dateformat: mm/dd/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        }\n      }\n    }\n    if (parts[0].indexOf('.') >= 0) {\n      const dtparts = parts[0].split('.');\n      if (dtparts.length === 3) {\n        if (dateFormat.indexOf('.d.') > -1 || dateFormat.indexOf('.dd.') > -1) {\n          // Dateformat: mm.dd.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n        } else {\n          // Dateformat: dd.mm.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n        }\n      }\n    }\n    if (parts[0].indexOf('-') >= 0) {\n      // Dateformat: yyyy-mm-dd\n      const dtparts = parts[0].split('-');\n      if (dtparts.length === 3) {\n        result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n      }\n    }\n  }\n  if (parts[1]) {\n    parts.shift();\n    let time = parts.join(' ');\n    result.time = parseTime(time, pmDesignator);\n  }\n  return result;\n}\n\nfunction parseHead(head, rights) {\n  let space = (rights > 0);\n  let count = 1;\n  let from = 0;\n  let to = 0;\n  let result = [];\n  for (let i = 0; i < head.length; i++) {\n    if (count <= rights) {\n      // if (head[i] === ' ' && !space) {\n      if (/\\s/.test(head[i]) && !space) {\n        to = i - 1;\n        result.push({\n          from: from,\n          to: to + 1,\n          cap: head.substring(from, to + 1)\n        });\n        from = to + 2;\n        count++;\n      }\n      space = head[i] === ' ';\n    } else {\n      if (!/\\s/.test(head[i]) && space) {\n        to = i - 1;\n        if (from < to) {\n          result.push({\n            from: from,\n            to: to,\n            cap: head.substring(from, to)\n          });\n        }\n        from = to + 1;\n        count++;\n      }\n      space = head[i] === ' ';\n    }\n  }\n  to = 1000;\n  result.push({\n    from: from,\n    to: to,\n    cap: head.substring(from, to)\n  });\n  let len = result.length;\n  for (var i = 0; i < len; i++) {\n    if (result[i].cap.replace(/\\s/g, '').length === 0) {\n      if (i + 1 < len) {\n        result[i].to = result[i + 1].to;\n        result[i].cap = result[i].cap + result[i + 1].cap;\n        result.splice(i + 1, 1);\n        len = len - 1;\n      }\n    }\n  }\n  return result;\n}\n\nfunction findObjectByKey(array, key, value) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i][key] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction getWmic() {\n  if (os.type() === 'Windows_NT' && !wmicPath) {\n    wmicPath = process.env.WINDIR + '\\\\system32\\\\wbem\\\\wmic.exe';\n    if (!fs.existsSync(wmicPath)) {\n      try {\n        const wmicPathArray = execSync('WHERE WMIC').toString().split('\\r\\n');\n        if (wmicPathArray && wmicPathArray.length) {\n          wmicPath = wmicPathArray[0];\n        } else {\n          wmicPath = 'wmic';\n        }\n      } catch (e) {\n        wmicPath = 'wmic';\n      }\n    }\n  }\n  return wmicPath;\n}\n\nfunction wmic(command, options) {\n  options = options || execOptsWin;\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        exec(process.env.WINDIR + '\\\\system32\\\\chcp.com 65001 | ' + getWmic() + ' ' + command, options, function (error, stdout) {\n          resolve(stdout, error);\n        }).stdin.end();\n      } catch (e) {\n        resolve('', e);\n      }\n    });\n  });\n}\n\nfunction getVboxmanage() {\n  return _windows ? process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH + '\\\\VBoxManage.exe' + '\" ' : 'vboxmanage';\n}\n\nfunction powerShell(cmd) {\n\n  let result = '';\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        const child = spawn('powershell.exe', ['-NoLogo', '-InputFormat', 'Text', '-NoExit', '-ExecutionPolicy', 'Unrestricted', '-Command', '-'], {\n          stdio: 'pipe',\n          windowsHide: true,\n          maxBuffer: 1024 * 20000,\n          encoding: 'UTF-8',\n          env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n        });\n\n        if (child && !child.pid) {\n          child.on('error', function () {\n            resolve(result);\n          });\n        }\n        if (child && child.pid) {\n          child.stdout.on('data', function (data) {\n            result = result + data.toString('utf8');\n          });\n          child.stderr.on('data', function () {\n            child.kill();\n            resolve(result);\n          });\n          child.on('close', function () {\n            child.kill();\n            resolve(result);\n          });\n          child.on('error', function () {\n            child.kill();\n            resolve(result);\n          });\n          try {\n            child.stdin.write(cmd + os.EOL);\n            child.stdin.write('exit' + os.EOL);\n            child.stdin.end();\n          } catch (e) {\n            child.kill();\n            resolve(result);\n          }\n        } else {\n          resolve(result);\n        }\n      } catch (e) {\n        resolve(result);\n      }\n    });\n  });\n}\n\nfunction getCodepage() {\n  if (_windows) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('chcp');\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split(':');\n        codepage = parts.length > 1 ? parts[1].replace('.', '') : '';\n      } catch (err) {\n        codepage = '437';\n      }\n    }\n    return codepage;\n  }\n  if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('echo $LANG');\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split('.');\n        codepage = parts.length > 1 ? parts[1].trim() : '';\n        if (!codepage) {\n          codepage = 'UTF-8';\n        }\n      } catch (err) {\n        codepage = 'UTF-8';\n      }\n    }\n    return codepage;\n  }\n}\n\nfunction isRaspberry() {\n  const PI_MODEL_NO = [\n    'BCM2708',\n    'BCM2709',\n    'BCM2710',\n    'BCM2835',\n    'BCM2837B0'\n  ];\n  let cpuinfo = [];\n  try {\n    cpuinfo = fs.readFileSync('/proc/cpuinfo', { encoding: 'utf8' }).split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const hardware = getValue(cpuinfo, 'hardware');\n  return (hardware && PI_MODEL_NO.indexOf(hardware) > -1);\n}\n\nfunction isRaspbian() {\n  let osrelease = [];\n  try {\n    osrelease = fs.readFileSync('/etc/os-release', { encoding: 'utf8' }).split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const id = getValue(osrelease, 'id');\n  return (id && id.indexOf('raspbian') > -1);\n}\n\nfunction execWin(cmd, opts, callback) {\n  if (!callback) {\n    callback = opts;\n    opts = execOptsWin;\n  }\n  let newCmd = 'chcp 65001 > nul && cmd /C ' + cmd + ' && chcp ' + codepage + ' > nul';\n  exec(newCmd, opts, function (error, stdout) {\n    callback(error, stdout);\n  });\n}\n\nfunction darwinXcodeExists() {\n  const cmdLineToolsExists = fs.existsSync('/Library/Developer/CommandLineTools/usr/bin/');\n  const xcodeAppExists = fs.existsSync('/Applications/Xcode.app/Contents/Developer/Tools');\n  const xcodeExists = fs.existsSync('/Library/Developer/Xcode/');\n  return (cmdLineToolsExists || xcodeExists || xcodeAppExists);\n}\n\nfunction nanoSeconds() {\n  const time = process.hrtime();\n  if (!Array.isArray(time) || time.length !== 2) {\n    return 0;\n  }\n  return +time[0] * 1e9 + +time[1];\n}\n\nfunction countUniqueLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      if (uniqueLines.indexOf(line) === -1) {\n        uniqueLines.push(line);\n      }\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction countLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      uniqueLines.push(line);\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction sanitizeShellString(str) {\n  const s = str || '';\n  let result = '';\n  for (i = 0; i <= 2000; i++) {\n    if (!(s[i] === undefined ||\n      s[i] === '>' ||\n      s[i] === '<' ||\n      s[i] === '*' ||\n      s[i] === '?' ||\n      s[i] === '[' ||\n      s[i] === ']' ||\n      s[i] === '|' ||\n      s[i] === '\u02da' ||\n      s[i] === '$' ||\n      s[i] === ';' ||\n      s[i] === '&' ||\n      s[i] === '(' ||\n      s[i] === ')' ||\n      s[i] === ']' ||\n      s[i] === '#' ||\n      s[i] === '\\\\' ||\n      s[i] === '\\t' ||\n      s[i] === '\\n' ||\n      s[i] === '\"')) {\n      result = result + s[i];\n    }\n  }\n  return result;\n}\n\nfunction isPrototypePolluted() {\n  s = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let notPolluted = true;\n  let st = '';\n  notPolluted = notPolluted || !(s.length === 62)\n  const ms = Date.now();\n  if (typeof ms === 'number' && ms > 1600000000000) {\n    const l = ms % 100 + 15;\n    let c = 0;\n    for (i = 0; i < l; i++) {\n      const r = Math.random() * 61.99999999 + 1;\n      const rs = parseInt(Math.floor(r).toString(), 10)\n      const rs2 = parseInt(r.toString().split('.')[0], 10);\n      const q = Math.random() * 61.99999999 + 1;\n      const qs = parseInt(Math.floor(q).toString(), 10)\n      const qs2 = parseInt(q.toString().split('.')[0], 10);\n      notPolluted = notPolluted && !(r === q);\n      notPolluted = notPolluted && rs === rs2 && qs === qs2;\n      st += s[rs - 1];\n    }\n    notPolluted = notPolluted && st.length === l;\n    // string manipulation\n    let p = Math.random() * l * 0.9999999999;\n    let stm = st.substr(0, p) + ' ' + st.substr(p, 2000);\n    let sto = stm.replace(/ /g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '{' + st.substr(p, 2000);\n    sto = stm.replace(/{/g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '*' + st.substr(p, 2000);\n    sto = stm.replace(/\\*/g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '$' + st.substr(p, 2000);\n    sto = stm.replace(/\\$/g, '');\n    notPolluted = notPolluted && st === sto;\n\n    // lower\n    const stl = st.toLowerCase();\n    notPolluted = notPolluted && (stl.length === l) && stl[l - 1] && !(stl[l])\n    for (i = 0; i < l; i++) {\n      const s1 = st[i];\n      const s2 = stl[i];\n      const s1l = s1.toLowerCase();\n      notPolluted = notPolluted && s1l[0] === s2 && s1l[0] && !(s1l[1]);\n    }\n  }\n  return !notPolluted;\n}\n\nfunction hex2bin(hex) {\n  return (\"00000000\" + (parseInt(hex, 16)).toString(2)).substr(-8);\n}\n\nfunction decodePiCpuinfo(lines) {\n\n  // https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md\n\n  const oldRevisionCodes = {\n    '0002': {\n      type: 'B',\n      revision: '1.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0003': {\n      type: 'B',\n      revision: '1.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0004': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0005': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Qisda',\n      processor: 'BCM2835'\n    },\n    '0006': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0007': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0008': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0009': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Qisda',\n      processor: 'BCM2835'\n    },\n    '000d': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '000e': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '000f': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0010': {\n      type: 'B+',\n      revision: '1.2',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0011': {\n      type: 'CM1',\n      revision: '1.0',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0012': {\n      type: 'A+',\n      revision: '1.1',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0013': {\n      type: 'B+',\n      revision: '1.2',\n      memory: 512,\n      manufacturer: 'Embest',\n      processor: 'BCM2835'\n    },\n    '0014': {\n      type: 'CM1',\n      revision: '1.0',\n      memory: 512,\n      manufacturer: 'Embest',\n      processor: 'BCM2835'\n    },\n    '0015': {\n      type: 'A+',\n      revision: '1.1',\n      memory: 256,\n      manufacturer: '512MB\tEmbest',\n      processor: 'BCM2835'\n    }\n  }\n\n  const processorList = [\n    'BMC2835',\n    'BMC2836',\n    'BMC2837',\n    'BMC2711',\n  ];\n  const manufacturerList = [\n    'Sony UK',\n    'Egoman',\n    'Embest',\n    'Sony Japan',\n    'Embest',\n    'Stadium'\n  ];\n  const typeList = {\n    '00': 'A',\n    '01': 'B',\n    '02': 'A+',\n    '03': 'B+',\n    '04': '2B',\n    '05': 'Alpha (early prototype)',\n    '06': 'CM1',\n    '08': '3B',\n    '09': 'Zero',\n    '0a': 'CM3',\n    '0c': 'Zero W',\n    '0d': '3B+',\n    '0e': '3A+',\n    '0f': 'Internal use only',\n    '10': 'CM3+',\n    '11': '4B',\n    '13': '400',\n    '14': 'CM4'\n  };\n\n  const revisionCode = getValue(lines, 'revision', ':', true);\n  const model = getValue(lines, 'model:', ':', true);\n  const serial = getValue(lines, 'serial', ':', true);\n\n  let result = {};\n  if (oldRevisionCodes.hasOwnProperty(revisionCode)) {\n    // old revision codes\n    result = {\n      model,\n      serial,\n      revisionCode,\n      memory: oldRevisionCodes[revisionCode].memory,\n      manufacturer: oldRevisionCodes[revisionCode].manufacturer,\n      processor: oldRevisionCodes[revisionCode].processor,\n      type: oldRevisionCodes[revisionCode].type,\n      revision: oldRevisionCodes[revisionCode].revision,\n    }\n\n  } else {\n    // new revision code\n    const revision = ('00000000' + getValue(lines, 'revision', ':', true).toLowerCase()).substr(-8);\n    // const revisionStyleNew = hex2bin(revision.substr(2, 1)).substr(4, 1) === '1';\n    const memSizeCode = parseInt(hex2bin(revision.substr(2, 1)).substr(5, 3), 2) || 0;\n    const manufacturer = manufacturerList[parseInt(revision.substr(3, 1), 10)];\n    const processor = processorList[parseInt(revision.substr(4, 1), 10)];\n    const typeCode = revision.substr(5, 2);\n\n\n    result = {\n      model,\n      serial,\n      revisionCode,\n      memory: 256 * Math.pow(2, memSizeCode),\n      manufacturer,\n      processor,\n      type: typeList.hasOwnProperty(typeCode) ? typeList[typeCode] : '',\n      revision: '1.' + revision.substr(7, 1),\n    }\n  }\n  return result;\n}\n\nfunction noop() { }\n\nexports.toInt = toInt;\nexports.execOptsWin = execOptsWin;\nexports.getCodepage = getCodepage;\nexports.execWin = execWin;\nexports.isFunction = isFunction;\nexports.unique = unique;\nexports.sortByKey = sortByKey;\nexports.cores = cores;\nexports.getValue = getValue;\nexports.decodeEscapeSequence = decodeEscapeSequence;\nexports.parseDateTime = parseDateTime;\nexports.parseHead = parseHead;\nexports.findObjectByKey = findObjectByKey;\nexports.getWmic = getWmic;\nexports.wmic = wmic;\nexports.darwinXcodeExists = darwinXcodeExists;\nexports.getVboxmanage = getVboxmanage;\nexports.powerShell = powerShell;\nexports.nanoSeconds = nanoSeconds;\nexports.countUniqueLines = countUniqueLines;\nexports.countLines = countLines;\nexports.noop = noop;\nexports.isRaspberry = isRaspberry;\nexports.isRaspbian = isRaspbian;\nexports.sanitizeShellString = sanitizeShellString;\nexports.isPrototypePolluted = isPrototypePolluted;\nexports.decodePiCpuinfo = decodePiCpuinfo;\n"], "fixing_code": ["'use strict';\n// @ts-check\n// ==================================================================================\n// internet.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2020\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 12. Internet\n// ----------------------------------------------------------------------------------\n\nconst exec = require('child_process').exec;\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\n// --------------------------\n// check if external site is available\n\nfunction inetChecksite(url, callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let urlSanitized = '';\n      const s = util.sanitizeShellString(url);\n      for (let i = 0; i <= 2000; i++) {\n        if (!(s[i] === undefined ||\n          s[i] === ' ' ||\n          s[i] === '{' ||\n          s[i] === '}')) {\n          const sl = s[i].toLowerCase();\n          if (sl[0] && !sl[1]) {\n            urlSanitized = urlSanitized + sl[0];\n          }\n        }\n      }\n      let result = {\n        url: urlSanitized,\n        ok: false,\n        status: 404,\n        ms: -1\n      };\n      if (urlSanitized && !util.isPrototypePolluted()) {\n        let t = Date.now();\n        if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {\n          let args = ' -I --connect-timeout 5 -m 5 ' + urlSanitized + ' 2>/dev/null | head -n 1 | cut -d \" \" -f2';\n          let cmd = 'curl';\n          exec(cmd + args, function (error, stdout) {\n            let statusCode = parseInt(stdout.toString());\n            result.status = statusCode || 404;\n            result.ok = !error && (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n            result.ms = (result.ok ? Date.now() - t : -1);\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        }\n        if (_windows) {   // if this is stable, this can be used for all OS types\n          const http = (urlSanitized.startsWith('https:') ? require('https') : require('http'));\n          try {\n            http.get(urlSanitized, (res) => {\n              const statusCode = res.statusCode;\n\n              result.status = statusCode || 404;\n              result.ok = (statusCode === 200 || statusCode === 301 || statusCode === 302 || statusCode === 304);\n\n              if (statusCode !== 200) {\n                res.resume();\n                result.ms = (result.ok ? Date.now() - t : -1);\n                if (callback) { callback(result); }\n                resolve(result);\n              } else {\n                res.on('data', () => { });\n                res.on('end', () => {\n                  result.ms = (result.ok ? Date.now() - t : -1);\n                  if (callback) { callback(result); }\n                  resolve(result);\n                });\n              }\n            }).on('error', () => {\n              if (callback) { callback(result); }\n              resolve(result);\n            });\n          } catch (err) {\n            if (callback) { callback(result); }\n            resolve(result);\n          }\n        }\n      } else {\n        if (callback) { callback(result); }\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.inetChecksite = inetChecksite;\n\n// --------------------------\n// check inet latency\n\nfunction inetLatency(host, callback) {\n\n  // fallback - if only callback is given\n  if (util.isFunction(host) && !callback) {\n    callback = host;\n    host = '';\n  }\n\n  host = host || '8.8.8.8';\n  const hostSanitized = util.isPrototypePolluted() ? '8.8.8.8' : util.sanitizeShellString(host);\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let cmd;\n      if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {\n        if (_linux) {\n          cmd = 'ping -c 2 -w 3 ' + hostSanitized + ' | grep rtt';\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          cmd = 'ping -c 2 -t 3 ' + hostSanitized + ' | grep round-trip';\n        }\n        if (_darwin) {\n          cmd = 'ping -c 2 -t 3 ' + hostSanitized + ' | grep avg';\n        }\n\n        exec(cmd, function (error, stdout) {\n          let result = -1;\n          if (!error) {\n            const line = stdout.toString().split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1]);\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_sunos) {\n        exec('ping -s -a ' + hostSanitized + ' 56 2 | grep avg', { timeout: 3000 }, function (error, stdout) {\n          let result = -1;\n          if (!error) {\n            const line = stdout.toString().split('=');\n            if (line.length > 1) {\n              const parts = line[1].split('/');\n              if (parts.length > 1) {\n                result = parseFloat(parts[1].replace(',', '.'));\n              }\n            }\n          }\n          if (callback) { callback(result); }\n          resolve(result);\n        });\n      }\n      if (_windows) {\n        let result = -1;\n        try {\n          exec('ping ' + hostSanitized + ' -n 1', util.execOptsWin, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\r\\n');\n              lines.shift();\n              lines.forEach(function (line) {\n                if ((line.toLowerCase().match(/ms/g) || []).length === 3) {\n                  let l = line.replace(/ +/g, ' ').split(' ');\n                  if (l.length > 6) {\n                    result = parseFloat(l[l.length - 1]);\n                  }\n                }\n              });\n            }\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.inetLatency = inetLatency;\n", "'use strict';\n// @ts-check\n// ==================================================================================\n// network.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2020\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 9. Network\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst fs = require('fs');\nconst util = require('./util');\n\nlet _platform = process.platform;\n\nconst _linux = (_platform === 'linux');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\nconst _sunos = (_platform === 'sunos');\n\nlet _network = {};\nlet _default_iface = '';\nlet _ifaces = {};\nlet _dhcpNics = [];\nlet _networkInterfaces = [];\nlet _mac = {};\nlet pathToIp;\n\nfunction getDefaultNetworkInterface() {\n\n  let ifaces = os.networkInterfaces();\n  let ifacename = '';\n  let ifacenameFirst = '';\n\n  let scopeid = 9999;\n\n  // fallback - \"first\" external interface (sorted by scopeid)\n  for (let dev in ifaces) {\n    if ({}.hasOwnProperty.call(ifaces, dev)) {\n      ifaces[dev].forEach(function (details) {\n        if (details && details.internal === false) {\n          ifacenameFirst = ifacenameFirst || dev; // fallback if no scopeid\n          if (details.scopeid && details.scopeid < scopeid) {\n            ifacename = dev;\n            scopeid = details.scopeid;\n          }\n        }\n      });\n    }\n  }\n  ifacename = ifacename || ifacenameFirst || '';\n\n  try {\n    if (_windows) {\n      // https://www.inetdaemon.com/tutorials/internet/ip/routing/default_route.shtml\n      let defaultIp = '';\n      const cmd = 'netstat -r';\n      const result = execSync(cmd);\n      const lines = result.toString().split(os.EOL);\n      lines.forEach(line => {\n        line = line.replace(/\\s+/g, ' ').trim();\n        if (line.indexOf('0.0.0.0 0.0.0.0') > -1 && !(/[a-zA-Z]/.test(line))) {\n          const parts = line.split(' ');\n          if (parts.length >= 5) {\n            defaultIp = parts[parts.length - 2];\n          }\n        }\n      });\n      if (defaultIp) {\n        for (let dev in ifaces) {\n          if ({}.hasOwnProperty.call(ifaces, dev)) {\n            ifaces[dev].forEach(function (details) {\n              if (details && details.address && details.address === defaultIp) {\n                ifacename = dev;\n              }\n            });\n          }\n        }\n      }\n    }\n    if (_linux) {\n      let cmd = 'ip route 2> /dev/null | grep default';\n      let result = execSync(cmd);\n      let parts = result.toString().split('\\n')[0].split(/\\s+/);\n      if (parts[0] === 'none' && parts[5]) {\n        ifacename = parts[5];\n      } else if (parts[4]) {\n        ifacename = parts[4];\n      }\n\n      if (ifacename.indexOf(':') > -1) {\n        ifacename = ifacename.split(':')[1].trim();\n      }\n    }\n    if (_darwin || _freebsd || _openbsd || _netbsd || _sunos) {\n      let cmd = '';\n      if (_linux) cmd = 'ip route 2> /dev/null | grep default | awk \\'{print $5}\\'';\n      if (_darwin) cmd = 'route -n get default 2>/dev/null | grep interface: | awk \\'{print $2}\\'';\n      if (_freebsd || _openbsd || _netbsd || _sunos) cmd = 'route get 0.0.0.0 | grep interface:';\n      let result = execSync(cmd);\n      ifacename = result.toString().split('\\n')[0];\n      if (ifacename.indexOf(':') > -1) {\n        ifacename = ifacename.split(':')[1].trim();\n      }\n    }\n  } catch (e) {\n    util.noop();\n  }\n  if (ifacename) _default_iface = ifacename;\n  return _default_iface;\n}\n\nexports.getDefaultNetworkInterface = getDefaultNetworkInterface;\n\nfunction getMacAddresses() {\n  let iface = '';\n  let mac = '';\n  let result = {};\n  if (_linux || _freebsd || _openbsd || _netbsd) {\n    if (typeof pathToIp === 'undefined') {\n      try {\n        const lines = execSync('which ip').toString().split('\\n');\n        if (lines.length && lines[0].indexOf(':') === -1 && lines[0].indexOf('/') === 0) {\n          pathToIp = lines[0];\n        } else {\n          pathToIp = '';\n        }\n      } catch (e) {\n        pathToIp = '';\n      }\n    }\n    try {\n      const cmd = 'export LC_ALL=C; ' + ((pathToIp) ? pathToIp + ' link show up' : '/sbin/ifconfig') + '; unset LC_ALL';\n      let res = execSync(cmd);\n      const lines = res.toString().split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i][0] !== ' ') {\n          if (pathToIp) {\n            let nextline = lines[i + 1].trim().split(' ');\n            if (nextline[0] === 'link/ether') {\n              iface = lines[i].split(' ')[1];\n              iface = iface.slice(0, iface.length - 1);\n              mac = nextline[1];\n            }\n          } else {\n            iface = lines[i].split(' ')[0];\n            mac = lines[i].split('HWaddr ')[1];\n          }\n\n          if (iface && mac) {\n            result[iface] = mac.trim();\n            iface = '';\n            mac = '';\n          }\n        }\n      }\n    } catch (e) {\n      util.noop();\n    }\n  }\n  if (_darwin) {\n    try {\n      const cmd = '/sbin/ifconfig';\n      let res = execSync(cmd);\n      const lines = res.toString().split('\\n');\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i] && lines[i][0] !== '\\t' && lines[i].indexOf(':') > 0) {\n          iface = lines[i].split(':')[0];\n        } else if (lines[i].indexOf('\\tether ') === 0) {\n          mac = lines[i].split('\\tether ')[1];\n          if (iface && mac) {\n            result[iface] = mac.trim();\n            iface = '';\n            mac = '';\n          }\n        }\n      }\n    } catch (e) {\n      util.noop();\n    }\n  }\n  return result;\n}\n\nfunction networkInterfaceDefault(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = getDefaultNetworkInterface();\n      if (callback) { callback(result); }\n      resolve(result);\n    });\n  });\n}\n\nexports.networkInterfaceDefault = networkInterfaceDefault;\n\n// --------------------------\n// NET - interfaces\n\nfunction parseLinesWindowsNics(sections, nconfigsections) {\n  let nics = [];\n  for (let i in sections) {\n    if ({}.hasOwnProperty.call(sections, i)) {\n\n      if (sections[i].trim() !== '') {\n\n        let lines = sections[i].trim().split('\\r\\n');\n        let linesNicConfig = nconfigsections[i].trim().split('\\r\\n');\n        let netEnabled = util.getValue(lines, 'NetEnabled', '=');\n\n        if (netEnabled !== '') {\n          const speed = parseInt(util.getValue(lines, 'speed', '=').trim(), 10) / 1000000;\n          nics.push({\n            mac: util.getValue(lines, 'MACAddress', '=').toLowerCase(),\n            dhcp: util.getValue(linesNicConfig, 'dhcpEnabled', '=').toLowerCase(),\n            name: util.getValue(lines, 'Name', '=').replace(/\\]/g, ')').replace(/\\[/g, '('),\n            netEnabled: netEnabled === 'TRUE',\n            speed: isNaN(speed) ? -1 : speed,\n            operstate: util.getValue(lines, 'NetConnectionStatus', '=') === '2' ? 'up' : 'down',\n            type: util.getValue(lines, 'AdapterTypeID', '=') === '9' ? 'wireless' : 'wired'\n          });\n        }\n      }\n    }\n  }\n  return nics;\n}\n\nfunction getWindowsNics() {\n  const cmd = util.getWmic() + ' nic get MACAddress, name, NetEnabled, Speed, NetConnectionStatus, AdapterTypeId /value';\n  const cmdnicconfig = util.getWmic() + ' nicconfig get dhcpEnabled /value';\n  try {\n    const nsections = execSync(cmd, util.execOptsWin).split(/\\n\\s*\\n/);\n    const nconfigsections = execSync(cmdnicconfig, util.execOptsWin).split(/\\n\\s*\\n/);\n    return (parseLinesWindowsNics(nsections, nconfigsections));\n  } catch (e) {\n    return [];\n  }\n}\n\nfunction getWindowsDNSsuffixes() {\n\n  let iface = {};\n\n  let dnsSuffixes = {\n    primaryDNS: '',\n    exitCode: 0,\n    ifaces: [],\n  };\n\n  try {\n    const ipconfig = execSync('ipconfig /all', util.execOptsWin);\n    const ipconfigArray = ipconfig.split('\\r\\n\\r\\n');\n\n    ipconfigArray.forEach((element, index) => {\n\n      if (index == 1) {\n        const longPrimaryDNS = element.split('\\r\\n').filter((element) => {\n          return element.toUpperCase().includes('DNS');\n        });\n        const primaryDNS = longPrimaryDNS[0].substring(longPrimaryDNS[0].lastIndexOf(':') + 1);\n        dnsSuffixes.primaryDNS = primaryDNS.trim();\n        if (!dnsSuffixes.primaryDNS) dnsSuffixes.primaryDNS = 'Not defined';\n      }\n      if (index > 1) {\n        if (index % 2 == 0) {\n          const name = element.substring(element.lastIndexOf(' ') + 1).replace(':', '');\n          iface.name = name;\n        } else {\n          const connectionSpecificDNS = element.split('\\r\\n').filter((element) => {\n            return element.toUpperCase().includes('DNS');\n          });\n          const dnsSuffix = connectionSpecificDNS[0].substring(connectionSpecificDNS[0].lastIndexOf(':') + 1);\n          iface.dnsSuffix = dnsSuffix.trim();\n          dnsSuffixes.ifaces.push(iface);\n          iface = {};\n        }\n      }\n    });\n\n    return dnsSuffixes;\n  } catch (error) {\n    // console.log('An error occurred trying to bring the Connection-specific DNS suffix', error.message);\n    return {\n      primaryDNS: '',\n      exitCode: 0,\n      ifaces: [],\n    };\n  }\n}\n\nfunction getWindowsIfaceDNSsuffix(ifaces, ifacename) {\n  let dnsSuffix = '';\n  // Adding (.) to ensure ifacename compatibility when duplicated iface-names\n  const interfaceName = ifacename + '.';\n  try {\n    const connectionDnsSuffix = ifaces.filter((iface) => {\n      return interfaceName.includes(iface.name + '.');\n    }).map((iface) => iface.dnsSuffix);\n    if (connectionDnsSuffix[0]) {\n      dnsSuffix = connectionDnsSuffix[0];\n    }\n    if (!dnsSuffix) dnsSuffix = '';\n    return dnsSuffix;\n  } catch (error) {\n    // console.log('Error getting Connection-specific DNS suffix: ', error.message);\n    return 'Unknown';\n  }\n}\n\nfunction getWindowsWiredProfilesInformation() {\n  try {\n    const result = execSync('netsh lan show profiles', util.execOptsWin);\n    const profileList = result.split('\\r\\nProfile on interface');\n    return profileList;\n  } catch (error) {\n    if (error.status === 1 && error.stdout.includes('AutoConfig')) {\n      return 'Disabled';\n    }\n    return [];\n  }\n}\n\nfunction getWindowsWirelessIfaceSSID(interfaceName) {\n  try {\n    const result = execSync(`netsh wlan show  interface name=\"${interfaceName}\" | findstr \"SSID\"`, util.execOptsWin);\n    const SSID = result.split('\\r\\n').shift();\n    const parseSSID = SSID.split(':').pop();\n    return parseSSID;\n  } catch (error) {\n    return 'Unknown';\n  }\n}\nfunction getWindowsIEEE8021x(connectionType, iface, ifaces) {\n  let i8021x = {\n    state: 'Unknown',\n    protocol: 'Unknown',\n  };\n\n  if (ifaces === 'Disabled') {\n    i8021x.state = 'Disabled';\n    i8021x.protocol = 'Not defined';\n    return i8021x;\n  }\n\n  if (connectionType == 'wired' && ifaces.length > 0) {\n    try {\n      // Get 802.1x information by interface name\n      const iface8021xInfo = ifaces.find((element) => {\n        return element.includes(iface + '\\r\\n');\n      });\n      const arrayIface8021xInfo = iface8021xInfo.split('\\r\\n');\n      const state8021x = arrayIface8021xInfo.find((element) => {\n        return element.includes('802.1x');\n      });\n\n      if (state8021x.includes('Disabled')) {\n        i8021x.state = 'Disabled';\n        i8021x.protocol = 'Not defined';\n      } else if (state8021x.includes('Enabled')) {\n        const protocol8021x = arrayIface8021xInfo.find((element) => {\n          return element.includes('EAP');\n        });\n        i8021x.protocol = protocol8021x.split(':').pop();\n        i8021x.state = 'Enabled';\n      }\n    } catch (error) {\n      // console.log('Error getting wired information:', error);\n      return i8021x;\n    }\n  } else if (connectionType == 'wireless') {\n\n    let i8021xState = '';\n    let i8021xProtocol = '';\n\n\n\n    try {\n      const SSID = getWindowsWirelessIfaceSSID(iface);\n      if (SSID !== 'Unknown') {\n        i8021xState = execSync(`netsh wlan show profiles \"${SSID}\" | findstr \"802.1X\"`, util.execOptsWin);\n        i8021xProtocol = execSync(`netsh wlan show profiles \"${SSID}\" | findstr \"EAP\"`, util.execOptsWin);\n      }\n\n      if (i8021xState.includes(':') && i8021xProtocol.includes(':')) {\n        i8021x.state = i8021xState.split(':').pop();\n        i8021x.protocol = i8021xProtocol.split(':').pop();\n      }\n    } catch (error) {\n      // console.log('Error getting wireless information:', error);\n      if (error.status === 1 && error.stdout.includes('AutoConfig')) {\n        i8021x.state = 'Disabled';\n        i8021x.protocol = 'Not defined';\n      }\n      return i8021x;\n    }\n  }\n\n  return i8021x;\n}\n\nfunction splitSectionsNics(lines) {\n  const result = [];\n  let section = [];\n  lines.forEach(function (line) {\n    if (!line.startsWith('\\t') && !line.startsWith(' ')) {\n      if (section.length) {\n        result.push(section);\n        section = [];\n      }\n    }\n    section.push(line);\n  });\n  if (section.length) {\n    result.push(section);\n  }\n  return result;\n}\n\nfunction parseLinesDarwinNics(sections) {\n  let nics = [];\n  sections.forEach(section => {\n    let nic = {\n      iface: '',\n      mtu: -1,\n      mac: '',\n      ip6: '',\n      ip4: '',\n      speed: -1,\n      type: '',\n      operstate: '',\n      duplex: '',\n      internal: false\n    };\n    const first = section[0];\n    nic.iface = first.split(':')[0].trim();\n    let parts = first.split('> mtu');\n    nic.mtu = parts.length > 1 ? parseInt(parts[1], 10) : -1;\n    if (isNaN(nic.mtu)) {\n      nic.mtu = -1;\n    }\n    nic.internal = parts[0].toLowerCase().indexOf('loopback') > -1;\n    section.forEach(line => {\n      if (line.trim().startsWith('ether ')) {\n        nic.mac = line.split('ether ')[1].toLowerCase().trim();\n      }\n      if (line.trim().startsWith('inet6 ') && !nic.ip6) {\n        nic.ip6 = line.split('inet6 ')[1].toLowerCase().split('%')[0].split(' ')[0];\n      }\n      if (line.trim().startsWith('inet ') && !nic.ip4) {\n        nic.ip4 = line.split('inet ')[1].toLowerCase().split(' ')[0];\n      }\n    });\n    let speed = util.getValue(section, 'link rate');\n    nic.speed = speed ? parseFloat(speed) : -1;\n    if (nic.speed === -1) {\n      speed = util.getValue(section, 'uplink rate');\n      nic.speed = speed ? parseFloat(speed) : -1;\n      if (nic.speed > -1 && speed.toLowerCase().indexOf('gbps') >= 0) {\n        nic.speed = nic.speed * 1000;\n      }\n    } else {\n      if (speed.toLowerCase().indexOf('gbps') >= 0) {\n        nic.speed = nic.speed * 1000;\n      }\n    }\n    nic.type = util.getValue(section, 'type').toLowerCase().indexOf('wi-fi') > -1 ? 'wireless' : 'wired';\n    nic.operstate = util.getValue(section, 'status').toLowerCase().indexOf('active') > -1 ? 'up' : 'down';\n    nic.duplex = util.getValue(section, 'media').toLowerCase().indexOf('half-duplex') > -1 ? 'half' : 'full';\n    if (nic.ip6 || nic.ip4 || nic.mac) {\n      nics.push(nic);\n    }\n  });\n  return nics;\n}\n\nfunction getDarwinNics() {\n  const cmd = '/sbin/ifconfig -v';\n  try {\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n    const nsections = splitSectionsNics(lines);\n    return (parseLinesDarwinNics(nsections));\n  } catch (e) {\n    return [];\n  }\n}\n\nfunction getLinuxIfaceConnectionName(interfaceName) {\n  const cmd = `nmcli device status 2>/dev/null | grep ${interfaceName}`;\n\n  try {\n    const result = execSync(cmd).toString();\n    const resultFormat = result.replace(/\\s+/g, ' ').trim();\n    const connectionNameLines = resultFormat.split(' ').slice(3);\n    const connectionName = connectionNameLines.join(' ');\n    return connectionName != '--' ? connectionName : '';\n  } catch (e) {\n    return '';\n  }\n}\n\nfunction checkLinuxDCHPInterfaces(file) {\n  let result = [];\n  try {\n    let cmd = `cat ${file} 2> /dev/null | grep 'iface\\\\|source'`;\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n\n    lines.forEach(line => {\n      const parts = line.replace(/\\s+/g, ' ').trim().split(' ');\n      if (parts.length >= 4) {\n        if (line.toLowerCase().indexOf(' inet ') >= 0 && line.toLowerCase().indexOf('dhcp') >= 0) {\n          result.push(parts[1]);\n        }\n      }\n      if (line.toLowerCase().includes('source')) {\n        let file = line.split(' ')[1];\n        result = result.concat(checkLinuxDCHPInterfaces(file));\n      }\n    });\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getLinuxDHCPNics() {\n  // alternate methods getting interfaces using DHCP\n  let cmd = 'ip a 2> /dev/null';\n  let result = [];\n  try {\n    const lines = execSync(cmd, { maxBuffer: 1024 * 20000 }).toString().split('\\n');\n    const nsections = splitSectionsNics(lines);\n    result = (parseLinuxDHCPNics(nsections));\n  } catch (e) {\n    util.noop();\n  }\n  try {\n    result = checkLinuxDCHPInterfaces('/etc/network/interfaces');\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction parseLinuxDHCPNics(sections) {\n  const result = [];\n  if (sections && sections.length) {\n    sections.forEach(lines => {\n      if (lines && lines.length) {\n        const parts = lines[0].split(':');\n        if (parts.length > 2) {\n          for (let line of lines) {\n            if (line.indexOf(' inet ') >= 0 && line.indexOf(' dynamic ') >= 0) {\n              const parts2 = line.split(' ');\n              const nic = parts2[parts2.length - 1].trim();\n              result.push(nic);\n              break;\n            }\n          }\n        }\n      }\n    });\n  }\n  return result;\n}\n\nfunction getLinuxIfaceDHCPstatus(iface, connectionName, DHCPNics) {\n  let result = false;\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null \\| grep ipv4.method;`;\n    try {\n      const lines = execSync(cmd).toString();\n      const resultFormat = lines.replace(/\\s+/g, ' ').trim();\n\n      let dhcStatus = resultFormat.split(' ').slice(1).toString();\n      switch (dhcStatus) {\n        case 'auto':\n          result = true;\n          break;\n\n        default:\n          result = false;\n          break;\n      }\n      return result;\n    } catch (e) {\n      return (DHCPNics.indexOf(iface) >= 0);\n    }\n  } else {\n    return (DHCPNics.indexOf(iface) >= 0);\n  }\n}\n\nfunction getDarwinIfaceDHCPstatus(iface) {\n  let result = false;\n  const cmd = `ipconfig getpacket \"${iface}\" 2>/dev/null \\| grep lease_time;`;\n  try {\n    const lines = execSync(cmd).toString().split('\\n');\n    if (lines.length && lines[0].startsWith('lease_time')) {\n      result = true;\n    }\n  } catch (e) {\n    util.noop();\n  }\n  return result;\n}\n\nfunction getLinuxIfaceDNSsuffix(connectionName) {\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null \\| grep ipv4.dns-search;`;\n    try {\n      const result = execSync(cmd).toString();\n      const resultFormat = result.replace(/\\s+/g, ' ').trim();\n      const dnsSuffix = resultFormat.split(' ').slice(1).toString();\n      return dnsSuffix == '--' ? 'Not defined' : dnsSuffix;\n    } catch (e) {\n      return 'Unknown';\n    }\n  } else {\n    return 'Unknown';\n  }\n}\n\nfunction getLinuxIfaceIEEE8021xAuth(connectionName) {\n  if (connectionName) {\n    const cmd = `nmcli connection show \"${connectionName}\" 2>/dev/null \\| grep 802-1x.eap;`;\n    try {\n      const result = execSync(cmd).toString();\n      const resultFormat = result.replace(/\\s+/g, ' ').trim();\n      const authenticationProtocol = resultFormat.split(' ').slice(1).toString();\n\n\n      return authenticationProtocol == '--' ? '' : authenticationProtocol;\n    } catch (e) {\n      return 'Not defined';\n    }\n  } else {\n    return 'Not defined';\n  }\n}\n\nfunction getLinuxIfaceIEEE8021xState(authenticationProtocol) {\n  if (authenticationProtocol) {\n    if (authenticationProtocol == 'Not defined') {\n      return 'Disabled';\n    }\n    return 'Enabled';\n  } else {\n    return 'Unknown';\n  }\n}\n\nfunction testVirtualNic(iface, ifaceName, mac) {\n  const virtualMacs = ['00:00:00:00:00:00', '00:03:FF', '00:05:69', '00:0C:29', '00:0F:4B', '00:0F:4B', '00:13:07', '00:13:BE', '00:15:5d', '00:16:3E', '00:1C:42', '00:21:F6', '00:21:F6', '00:24:0B', '00:24:0B', '00:50:56', '00:A0:B1', '00:E0:C8', '08:00:27', '0A:00:27', '18:92:2C', '16:DF:49', '3C:F3:92', '54:52:00', 'FC:15:97'];\n  if (mac) {\n    return virtualMacs.filter(item => { return mac.toUpperCase().toUpperCase().startsWith(item.substr(0, mac.length)); }).length > 0 ||\n      iface.toLowerCase().indexOf(' virtual ') > -1 ||\n      ifaceName.toLowerCase().indexOf(' virtual ') > -1 ||\n      iface.toLowerCase().indexOf('vethernet ') > -1 ||\n      ifaceName.toLowerCase().indexOf('vethernet ') > -1 ||\n      iface.toLowerCase().startsWith('veth') ||\n      ifaceName.toLowerCase().startsWith('veth') ||\n      iface.toLowerCase().startsWith('vboxnet') ||\n      ifaceName.toLowerCase().startsWith('vboxnet');\n  } else return false;\n}\n\nfunction networkInterfaces(callback, rescan = true) {\n\n  if (typeof callback === 'boolean') {\n    rescan = callback;\n    callback = null;\n  }\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let ifaces = os.networkInterfaces();\n\n      let result = [];\n      let nics = [];\n      let dnsSuffixes = [];\n      let nics8021xInfo = [];\n      // seperate handling in OSX\n      if (_darwin || _freebsd || _openbsd || _netbsd) {\n        nics = getDarwinNics();\n\n\n        nics.forEach(nic => {\n\n          if ({}.hasOwnProperty.call(ifaces, nic.iface)) {\n            ifaces[nic.iface].forEach(function (details) {\n              if (details.family === 'IPv4') {\n                nic.ip4subnet = details.netmask;\n              }\n              if (details.family === 'IPv6') {\n                nic.ip6subnet = details.netmask;\n              }\n            });\n          }\n\n          result.push({\n            iface: nic.iface,\n            ifaceName: nic.iface,\n            ip4: nic.ip4,\n            ip4subnet: nic.ip4subnet || '',\n            ip6: nic.ip6,\n            ip6subnet: nic.ip6subnet || '',\n            mac: nic.mac,\n            internal: nic.internal,\n            virtual: nic.internal ? false : testVirtualNic(nic.iface, nic.iface, nic.mac),\n            operstate: nic.operstate,\n            type: nic.type,\n            duplex: nic.duplex,\n            mtu: nic.mtu,\n            speed: nic.speed,\n            dhcp: getDarwinIfaceDHCPstatus(nic.iface),\n            dnsSuffix: '',\n            ieee8021xAuth: '',\n            ieee8021xState: '',\n            carrierChanges: 0\n          });\n        });\n        _networkInterfaces = result;\n        if (callback) { callback(result); }\n        resolve(result);\n      } else {\n        if ((JSON.stringify(ifaces) === JSON.stringify(_ifaces)) && !rescan) {\n          // no changes - just return object\n          result = _networkInterfaces;\n\n          if (callback) { callback(result); }\n          resolve(result);\n        } else {\n          _ifaces = Object.assign({}, ifaces);\n\n          if (_windows) {\n            nics = getWindowsNics();\n            nics.forEach(nic => {\n              let found = false;\n              Object.keys(ifaces).forEach(key => {\n                if (!found) {\n                  ifaces[key].forEach(value => {\n                    if (Object.keys(value).indexOf('mac') >= 0) {\n                      found = value['mac'] === nic.mac;\n                    }\n                  });\n                }\n              });\n\n              if (!found) {\n                ifaces[nic.name] = [{ mac: nic.mac }];\n              }\n            });\n\n            nics8021xInfo = getWindowsWiredProfilesInformation();\n            dnsSuffixes = getWindowsDNSsuffixes();\n          }\n          if (_linux) {\n            _dhcpNics = getLinuxDHCPNics();\n          }\n          for (let dev in ifaces) {\n            let ip4 = '';\n            let ip4subnet = '';\n            let ip6 = '';\n            let ip6subnet = '';\n            let mac = '';\n            let duplex = '';\n            let mtu = '';\n            let speed = -1;\n            let carrierChanges = 0;\n            let operstate = 'down';\n            let dhcp = false;\n            let dnsSuffix = '';\n            let ieee8021xAuth = '';\n            let ieee8021xState = '';\n            let type = '';\n\n            if ({}.hasOwnProperty.call(ifaces, dev)) {\n              let ifaceName = dev;\n              ifaces[dev].forEach(function (details) {\n                if (details.family === 'IPv4') {\n                  ip4 = details.address;\n                  ip4subnet = details.netmask;\n                }\n                if (details.family === 'IPv6') {\n                  if (!ip6 || ip6.match(/^fe80::/i)) {\n                    ip6 = details.address;\n                    ip6subnet = details.netmask;\n                  }\n                }\n                mac = details.mac;\n                // fallback due to https://github.com/nodejs/node/issues/13581 (node 8.1 - node 8.2)\n                if (mac.indexOf('00:00:0') > -1 && (_linux || _darwin) && parseInt(process.versions.node.split('.'), 10) === 8) {\n                  if (Object.keys(_mac).length === 0) {\n                    _mac = getMacAddresses();\n                  }\n                  mac = _mac[dev] || '';\n                }\n              });\n              if (_linux) {\n                let iface = dev.split(':')[0].trim().toLowerCase();\n                const cmd = `echo -n \"addr_assign_type: \"; cat /sys/class/net/${iface}/addr_assign_type 2>/dev/null; echo;\n            echo -n \"address: \"; cat /sys/class/net/${iface}/address 2>/dev/null; echo;\n            echo -n \"addr_len: \"; cat /sys/class/net/${iface}/addr_len 2>/dev/null; echo;\n            echo -n \"broadcast: \"; cat /sys/class/net/${iface}/broadcast 2>/dev/null; echo;\n            echo -n \"carrier: \"; cat /sys/class/net/${iface}/carrier 2>/dev/null; echo;\n            echo -n \"carrier_changes: \"; cat /sys/class/net/${iface}/carrier_changes 2>/dev/null; echo;\n            echo -n \"dev_id: \"; cat /sys/class/net/${iface}/dev_id 2>/dev/null; echo;\n            echo -n \"dev_port: \"; cat /sys/class/net/${iface}/dev_port 2>/dev/null; echo;\n            echo -n \"dormant: \"; cat /sys/class/net/${iface}/dormant 2>/dev/null; echo;\n            echo -n \"duplex: \"; cat /sys/class/net/${iface}/duplex 2>/dev/null; echo;\n            echo -n \"flags: \"; cat /sys/class/net/${iface}/flags 2>/dev/null; echo;\n            echo -n \"gro_flush_timeout: \"; cat /sys/class/net/${iface}/gro_flush_timeout 2>/dev/null; echo;\n            echo -n \"ifalias: \"; cat /sys/class/net/${iface}/ifalias 2>/dev/null; echo;\n            echo -n \"ifindex: \"; cat /sys/class/net/${iface}/ifindex 2>/dev/null; echo;\n            echo -n \"iflink: \"; cat /sys/class/net/${iface}/iflink 2>/dev/null; echo;\n            echo -n \"link_mode: \"; cat /sys/class/net/${iface}/link_mode 2>/dev/null; echo;\n            echo -n \"mtu: \"; cat /sys/class/net/${iface}/mtu 2>/dev/null; echo;\n            echo -n \"netdev_group: \"; cat /sys/class/net/${iface}/netdev_group 2>/dev/null; echo;\n            echo -n \"operstate: \"; cat /sys/class/net/${iface}/operstate 2>/dev/null; echo;\n            echo -n \"proto_down: \"; cat /sys/class/net/${iface}/proto_down 2>/dev/null; echo;\n            echo -n \"speed: \"; cat /sys/class/net/${iface}/speed 2>/dev/null; echo;\n            echo -n \"tx_queue_len: \"; cat /sys/class/net/${iface}/tx_queue_len 2>/dev/null; echo;\n            echo -n \"type: \"; cat /sys/class/net/${iface}/type 2>/dev/null; echo;\n            echo -n \"wireless: \"; cat /proc/net/wireless 2>/dev/null \\| grep ${iface}; echo;\n            echo -n \"wirelessspeed: \"; iw dev ${iface} link 2>&1 \\| grep bitrate; echo;`;\n\n                let lines = [];\n                try {\n                  lines = execSync(cmd).toString().split('\\n');\n                  const connectionName = getLinuxIfaceConnectionName(iface);\n                  dhcp = getLinuxIfaceDHCPstatus(iface, connectionName, _dhcpNics);\n                  dnsSuffix = getLinuxIfaceDNSsuffix(connectionName);\n                  ieee8021xAuth = getLinuxIfaceIEEE8021xAuth(connectionName);\n                  ieee8021xState = getLinuxIfaceIEEE8021xState(ieee8021xAuth);\n                } catch (e) {\n                  util.noop();\n                }\n                duplex = util.getValue(lines, 'duplex');\n                duplex = duplex.startsWith('cat') ? '' : duplex;\n                mtu = parseInt(util.getValue(lines, 'mtu'), 10);\n                let myspeed = parseInt(util.getValue(lines, 'speed'), 10);\n                speed = isNaN(myspeed) ? -1 : myspeed;\n                let wirelessspeed = util.getValue(lines, 'wirelessspeed').split('tx bitrate: ');\n                if (speed === -1 && wirelessspeed.length === 2) {\n                  myspeed = parseFloat(wirelessspeed[1]);\n                  speed = isNaN(myspeed) ? -1 : myspeed;\n                }\n                carrierChanges = parseInt(util.getValue(lines, 'carrier_changes'), 10);\n                operstate = util.getValue(lines, 'operstate');\n                type = operstate === 'up' ? (util.getValue(lines, 'wireless').trim() ? 'wireless' : 'wired') : 'unknown';\n                if (iface === 'lo' || iface.startsWith('bond')) { type = 'virtual'; }\n              }\n              if (_windows) {\n\n\n                dnsSuffix = getWindowsIfaceDNSsuffix(dnsSuffixes.ifaces, dev);\n                nics.forEach(detail => {\n                  if (detail.mac === mac) {\n                    ifaceName = detail.name;\n                    dhcp = detail.dhcp;\n                    operstate = detail.operstate;\n                    speed = detail.speed;\n                    type = detail.type;\n                  }\n                });\n\n                if (dev.toLowerCase().indexOf('wlan') >= 0 || ifaceName.toLowerCase().indexOf('wlan') >= 0 || ifaceName.toLowerCase().indexOf('802.11n') >= 0 || ifaceName.toLowerCase().indexOf('wireless') >= 0 || ifaceName.toLowerCase().indexOf('wi-fi') >= 0 || ifaceName.toLowerCase().indexOf('wifi') >= 0) {\n                  type = 'wireless';\n                }\n\n                const IEEE8021x = getWindowsIEEE8021x(type, dev, nics8021xInfo);\n                ieee8021xAuth = IEEE8021x.protocol;\n                ieee8021xState = IEEE8021x.state;\n              }\n              let internal = (ifaces[dev] && ifaces[dev][0]) ? ifaces[dev][0].internal : false;\n              if (dev.toLowerCase().indexOf('loopback') > -1 || ifaceName.toLowerCase().indexOf('loopback') > -1) {\n                internal = true;\n              }\n              const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);\n              result.push({\n                iface: dev,\n                ifaceName,\n                ip4,\n                ip4subnet,\n                ip6,\n                ip6subnet,\n                mac,\n                internal,\n                virtual,\n                operstate,\n                type,\n                duplex,\n                mtu,\n                speed,\n                dhcp,\n                dnsSuffix,\n                ieee8021xAuth,\n                ieee8021xState,\n                carrierChanges,\n              });\n            }\n          }\n          _networkInterfaces = result;\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkInterfaces = networkInterfaces;\n\n// --------------------------\n// NET - Speed\n\nfunction calcNetworkSpeed(iface, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors) {\n  let result = {\n    iface,\n    operstate,\n    rx_bytes,\n    rx_dropped,\n    rx_errors,\n    tx_bytes,\n    tx_dropped,\n    tx_errors,\n    rx_sec: -1,\n    tx_sec: -1,\n    ms: 0\n  };\n\n  if (_network[iface] && _network[iface].ms) {\n    result.ms = Date.now() - _network[iface].ms;\n    result.rx_sec = (rx_bytes - _network[iface].rx_bytes) >= 0 ? (rx_bytes - _network[iface].rx_bytes) / (result.ms / 1000) : 0;\n    result.tx_sec = (tx_bytes - _network[iface].tx_bytes) >= 0 ? (tx_bytes - _network[iface].tx_bytes) / (result.ms / 1000) : 0;\n    _network[iface].rx_bytes = rx_bytes;\n    _network[iface].tx_bytes = tx_bytes;\n    _network[iface].rx_sec = result.rx_sec;\n    _network[iface].tx_sec = result.tx_sec;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = result.ms;\n    _network[iface].operstate = operstate;\n  } else {\n    if (!_network[iface]) _network[iface] = {};\n    _network[iface].rx_bytes = rx_bytes;\n    _network[iface].tx_bytes = tx_bytes;\n    _network[iface].rx_sec = -1;\n    _network[iface].tx_sec = -1;\n    _network[iface].ms = Date.now();\n    _network[iface].last_ms = 0;\n    _network[iface].operstate = operstate;\n  }\n  return result;\n}\n\nfunction networkStats(ifaces, callback) {\n\n  let ifacesArray = [];\n  // fallback - if only callback is given\n  if (util.isFunction(ifaces) && !callback) {\n    callback = ifaces;\n    ifacesArray = [getDefaultNetworkInterface()];\n  } else {\n    ifaces = ifaces || getDefaultNetworkInterface();\n    ifaces = ifaces.trim().toLowerCase().replace(/,+/g, '|');\n    ifacesArray = ifaces.split('|');\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      const result = [];\n\n      const workload = [];\n      if (ifacesArray.length && ifacesArray[0].trim() === '*') {\n        ifacesArray = [];\n        networkInterfaces(false).then(allIFaces => {\n          for (let iface of allIFaces) {\n            ifacesArray.push(iface.iface);\n          }\n          networkStats(ifacesArray.join(',')).then(result => {\n            if (callback) { callback(result); }\n            resolve(result);\n          });\n        });\n      } else {\n        for (let iface of ifacesArray) {\n          workload.push(networkStatsSingle(iface.trim()));\n        }\n        if (workload.length) {\n          Promise.all(\n            workload\n          ).then(data => {\n            if (callback) { callback(data); }\n            resolve(data);\n          });\n        } else {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nfunction networkStatsSingle(iface) {\n\n  function parseLinesWindowsPerfData(sections) {\n    let perfData = [];\n    for (let i in sections) {\n      if ({}.hasOwnProperty.call(sections, i)) {\n        if (sections[i].trim() !== '') {\n          let lines = sections[i].trim().split('\\r\\n');\n          perfData.push({\n            name: util.getValue(lines, 'Name', '=').replace(/[()\\[\\] ]+/g, '').replace('#', '_').toLowerCase(),\n            rx_bytes: parseInt(util.getValue(lines, 'BytesReceivedPersec', '='), 10),\n            rx_errors: parseInt(util.getValue(lines, 'PacketsReceivedErrors', '='), 10),\n            rx_dropped: parseInt(util.getValue(lines, 'PacketsReceivedDiscarded', '='), 10),\n            tx_bytes: parseInt(util.getValue(lines, 'BytesSentPersec', '='), 10),\n            tx_errors: parseInt(util.getValue(lines, 'PacketsOutboundErrors', '='), 10),\n            tx_dropped: parseInt(util.getValue(lines, 'PacketsOutboundDiscarded', '='), 10)\n          });\n        }\n      }\n    }\n    return perfData;\n  }\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n\n      const ifaceSanitized = util.isPrototypePolluted() ? '---' : util.sanitizeShellString(iface);\n\n      let result = {\n        iface: ifaceSanitized,\n        operstate: 'unknown',\n        rx_bytes: 0,\n        rx_dropped: 0,\n        rx_errors: 0,\n        tx_bytes: 0,\n        tx_dropped: 0,\n        tx_errors: 0,\n        rx_sec: -1,\n        tx_sec: -1,\n        ms: 0\n      };\n\n      let operstate = 'unknown';\n      let rx_bytes = 0;\n      let tx_bytes = 0;\n      let rx_dropped = 0;\n      let rx_errors = 0;\n      let tx_dropped = 0;\n      let tx_errors = 0;\n\n      let cmd, lines, stats;\n      if (!_network[ifaceSanitized] || (_network[ifaceSanitized] && !_network[ifaceSanitized].ms) || (_network[ifaceSanitized] && _network[ifaceSanitized].ms && Date.now() - _network[ifaceSanitized].ms >= 500)) {\n        if (_linux) {\n          if (fs.existsSync('/sys/class/net/' + ifaceSanitized)) {\n            cmd =\n              'cat /sys/class/net/' + ifaceSanitized + '/operstate; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_bytes; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_bytes; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_dropped; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/rx_errors; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_dropped; ' +\n              'cat /sys/class/net/' + ifaceSanitized + '/statistics/tx_errors; ';\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                operstate = lines[0].trim();\n                rx_bytes = parseInt(lines[1], 10);\n                tx_bytes = parseInt(lines[2], 10);\n                rx_dropped = parseInt(lines[3], 10);\n                rx_errors = parseInt(lines[4], 10);\n                tx_dropped = parseInt(lines[5], 10);\n                tx_errors = parseInt(lines[6], 10);\n\n                result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n\n              }\n              resolve(result);\n            });\n          } else {\n            resolve(result);\n          }\n        }\n        if (_freebsd || _openbsd || _netbsd) {\n          cmd = 'netstat -ibndI ' + ifaceSanitized;\n          exec(cmd, function (error, stdout) {\n            if (!error) {\n              lines = stdout.toString().split('\\n');\n              for (let i = 1; i < lines.length; i++) {\n                const line = lines[i].replace(/ +/g, ' ').split(' ');\n                if (line && line[0] && line[7] && line[10]) {\n                  rx_bytes = rx_bytes + parseInt(line[7]);\n                  if (line[6].trim() !== '-') { rx_dropped = rx_dropped + parseInt(line[6]); }\n                  if (line[5].trim() !== '-') { rx_errors = rx_errors + parseInt(line[5]); }\n                  tx_bytes = tx_bytes + parseInt(line[10]);\n                  if (line[12].trim() !== '-') { tx_dropped = tx_dropped + parseInt(line[12]); }\n                  if (line[9].trim() !== '-') { tx_errors = tx_errors + parseInt(line[9]); }\n                  operstate = 'up';\n                }\n              }\n              result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n            }\n            resolve(result);\n          });\n        }\n        if (_darwin) {\n          cmd = 'ifconfig ' + ifaceSanitized + ' | grep \"status\"';\n          exec(cmd, function (error, stdout) {\n            result.operstate = (stdout.toString().split(':')[1] || '').trim();\n            result.operstate = (result.operstate || '').toLowerCase();\n            result.operstate = (result.operstate === 'active' ? 'up' : (result.operstate === 'inactive' ? 'down' : 'unknown'));\n            cmd = 'netstat -bdI ' + ifaceSanitized;\n            exec(cmd, function (error, stdout) {\n              if (!error) {\n                lines = stdout.toString().split('\\n');\n                // if there is less than 2 lines, no information for this interface was found\n                if (lines.length > 1 && lines[1].trim() !== '') {\n                  // skip header line\n                  // use the second line because it is tied to the NIC instead of the ipv4 or ipv6 address\n                  stats = lines[1].replace(/ +/g, ' ').split(' ');\n                  const offset = stats.length > 11 ? 1 : 0;\n                  rx_bytes = parseInt(stats[offset + 5]);\n                  rx_dropped = parseInt(stats[offset + 10]);\n                  rx_errors = parseInt(stats[offset + 4]);\n                  tx_bytes = parseInt(stats[offset + 8]);\n                  tx_dropped = parseInt(stats[offset + 10]);\n                  tx_errors = parseInt(stats[offset + 7]);\n                  result = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, result.operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n                }\n              }\n              resolve(result);\n            });\n          });\n        }\n        if (_windows) {\n          let perfData = [];\n          let ifaceName = ifaceSanitized;\n\n          // Performance Data\n          util.wmic('path Win32_PerfRawData_Tcpip_NetworkInterface Get name,BytesReceivedPersec,BytesSentPersec,BytesTotalPersec,PacketsOutboundDiscarded,PacketsOutboundErrors,PacketsReceivedDiscarded,PacketsReceivedErrors /value').then((stdout, error) => {\n            if (!error) {\n              const psections = stdout.toString().split(/\\n\\s*\\n/);\n              perfData = parseLinesWindowsPerfData(psections);\n            }\n\n            // Network Interfaces\n            networkInterfaces(false).then(interfaces => {\n              // get bytes sent, received from perfData by name\n              rx_bytes = 0;\n              tx_bytes = 0;\n              perfData.forEach(detail => {\n                interfaces.forEach(det => {\n                  if ((det.iface.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.mac.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ip4.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ip6.toLowerCase() === ifaceSanitized.toLowerCase() ||\n                    det.ifaceName.replace(/[()\\[\\] ]+/g, '').replace('#', '_').toLowerCase() === ifaceSanitized.replace(/[()\\[\\] ]+/g, '').replace('#', '_').toLowerCase()) &&\n                    (det.ifaceName.replace(/[()\\[\\] ]+/g, '').replace('#', '_').toLowerCase() === detail.name)) {\n                    ifaceName = det.iface;\n                    rx_bytes = detail.rx_bytes;\n                    rx_dropped = detail.rx_dropped;\n                    rx_errors = detail.rx_errors;\n                    tx_bytes = detail.tx_bytes;\n                    tx_dropped = detail.tx_dropped;\n                    tx_errors = detail.tx_errors;\n                    operstate = det.operstate;\n                  }\n                });\n              });\n              if (rx_bytes && tx_bytes) {\n                result = calcNetworkSpeed(ifaceName, parseInt(rx_bytes), parseInt(tx_bytes), operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);\n              }\n              resolve(result);\n            });\n          });\n        }\n      } else {\n        result.rx_bytes = _network[ifaceSanitized].rx_bytes;\n        result.tx_bytes = _network[ifaceSanitized].tx_bytes;\n        result.rx_sec = _network[ifaceSanitized].rx_sec;\n        result.tx_sec = _network[ifaceSanitized].tx_sec;\n        result.ms = _network[ifaceSanitized].last_ms;\n        result.operstate = _network[ifaceSanitized].operstate;\n        resolve(result);\n      }\n    });\n  });\n}\n\nexports.networkStats = networkStats;\n\n// --------------------------\n// NET - connections (sockets)\n\nfunction networkConnections(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = [];\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'export LC_ALL=C; netstat -tunap | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"; unset LC_ALL';\n        if (_freebsd || _openbsd || _netbsd) cmd = 'export LC_ALL=C; netstat -na | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"; unset LC_ALL';\n        exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n          let lines = stdout.toString().split('\\n');\n          if (!error && (lines.length > 1 || lines[0] != '')) {\n            lines.forEach(function (line) {\n              line = line.replace(/ +/g, ' ').split(' ');\n              if (line.length >= 7) {\n                let localip = line[3];\n                let localport = '';\n                let localaddress = line[3].split(':');\n                if (localaddress.length > 1) {\n                  localport = localaddress[localaddress.length - 1];\n                  localaddress.pop();\n                  localip = localaddress.join(':');\n                }\n                let peerip = line[4];\n                let peerport = '';\n                let peeraddress = line[4].split(':');\n                if (peeraddress.length > 1) {\n                  peerport = peeraddress[peeraddress.length - 1];\n                  peeraddress.pop();\n                  peerip = peeraddress.join(':');\n                }\n                let connstate = line[5];\n                // if (connstate === 'VERBUNDEN') connstate = 'ESTABLISHED';\n                let proc = line[6].split('/');\n\n                if (connstate) {\n                  result.push({\n                    protocol: line[0],\n                    localaddress: localip,\n                    localport: localport,\n                    peeraddress: peerip,\n                    peerport: peerport,\n                    state: connstate,\n                    pid: proc[0] && proc[0] !== '-' ? parseInt(proc[0], 10) : -1,\n                    process: proc[1] ? proc[1].split(' ')[0] : ''\n                  });\n                }\n              }\n            });\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          } else {\n            cmd = 'ss -tunap | grep \"ESTAB\\\\|SYN-SENT\\\\|SYN-RECV\\\\|FIN-WAIT1\\\\|FIN-WAIT2\\\\|TIME-WAIT\\\\|CLOSE\\\\|CLOSE-WAIT\\\\|LAST-ACK\\\\|LISTEN\\\\|CLOSING\"';\n            exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n\n              if (!error) {\n                let lines = stdout.toString().split('\\n');\n                lines.forEach(function (line) {\n                  line = line.replace(/ +/g, ' ').split(' ');\n                  if (line.length >= 6) {\n                    let localip = line[4];\n                    let localport = '';\n                    let localaddress = line[4].split(':');\n                    if (localaddress.length > 1) {\n                      localport = localaddress[localaddress.length - 1];\n                      localaddress.pop();\n                      localip = localaddress.join(':');\n                    }\n                    let peerip = line[5];\n                    let peerport = '';\n                    let peeraddress = line[5].split(':');\n                    if (peeraddress.length > 1) {\n                      peerport = peeraddress[peeraddress.length - 1];\n                      peeraddress.pop();\n                      peerip = peeraddress.join(':');\n                    }\n                    let connstate = line[1];\n                    if (connstate === 'ESTAB') connstate = 'ESTABLISHED';\n                    if (connstate === 'TIME-WAIT') connstate = 'TIME_WAIT';\n                    let pid = -1;\n                    let process = '';\n                    if (line.length >= 7 && line[6].indexOf('users:') > -1) {\n                      let proc = line[6].replace('users:((\"', '').replace(/\"/g, '').split(',');\n                      if (proc.length > 2) {\n                        process = proc[0].split(' ')[0];\n                        pid = parseInt(proc[1], 10);\n                      }\n                    }\n                    if (connstate) {\n                      result.push({\n                        protocol: line[0],\n                        localaddress: localip,\n                        localport: localport,\n                        peeraddress: peerip,\n                        peerport: peerport,\n                        state: connstate,\n                        pid,\n                        process\n                      });\n                    }\n                  }\n                });\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            });\n          }\n        });\n      }\n      if (_darwin) {\n        let cmd = 'netstat -natv | grep \"ESTABLISHED\\\\|SYN_SENT\\\\|SYN_RECV\\\\|FIN_WAIT1\\\\|FIN_WAIT2\\\\|TIME_WAIT\\\\|CLOSE\\\\|CLOSE_WAIT\\\\|LAST_ACK\\\\|LISTEN\\\\|CLOSING\\\\|UNKNOWN\"';\n        exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n          if (!error) {\n\n            let lines = stdout.toString().split('\\n');\n\n            lines.forEach(function (line) {\n              line = line.replace(/ +/g, ' ').split(' ');\n              if (line.length >= 8) {\n                let localip = line[3];\n                let localport = '';\n                let localaddress = line[3].split('.');\n                if (localaddress.length > 1) {\n                  localport = localaddress[localaddress.length - 1];\n                  localaddress.pop();\n                  localip = localaddress.join('.');\n                }\n                let peerip = line[4];\n                let peerport = '';\n                let peeraddress = line[4].split('.');\n                if (peeraddress.length > 1) {\n                  peerport = peeraddress[peeraddress.length - 1];\n                  peeraddress.pop();\n                  peerip = peeraddress.join('.');\n                }\n                let connstate = line[5];\n                let pid = parseInt(line[8], 10);\n                if (connstate) {\n                  result.push({\n                    protocol: line[0],\n                    localaddress: localip,\n                    localport: localport,\n                    peeraddress: peerip,\n                    peerport: peerport,\n                    state: connstate,\n                    pid: pid,\n                    process: ''\n                  });\n                }\n              }\n            });\n            if (callback) {\n              callback(result);\n            }\n            resolve(result);\n          }\n        });\n      }\n      if (_windows) {\n        let cmd = 'netstat -nao';\n        try {\n          exec(cmd, util.execOptsWin, function (error, stdout) {\n            if (!error) {\n\n              let lines = stdout.toString().split('\\r\\n');\n\n              lines.forEach(function (line) {\n                line = line.trim().replace(/ +/g, ' ').split(' ');\n                if (line.length >= 4) {\n                  let localip = line[1];\n                  let localport = '';\n                  let localaddress = line[1].split(':');\n                  if (localaddress.length > 1) {\n                    localport = localaddress[localaddress.length - 1];\n                    localaddress.pop();\n                    localip = localaddress.join(':');\n                  }\n                  let peerip = line[2];\n                  let peerport = '';\n                  let peeraddress = line[2].split(':');\n                  if (peeraddress.length > 1) {\n                    peerport = peeraddress[peeraddress.length - 1];\n                    peeraddress.pop();\n                    peerip = peeraddress.join(':');\n                  }\n                  let pid = line[4];\n                  let connstate = line[3];\n                  if (connstate === 'HERGESTELLT') connstate = 'ESTABLISHED';\n                  if (connstate.startsWith('ABH')) connstate = 'LISTEN';\n                  if (connstate === 'SCHLIESSEN_WARTEN') connstate = 'CLOSE_WAIT';\n                  if (connstate === 'WARTEND') connstate = 'TIME_WAIT';\n                  if (connstate === 'SYN_GESENDET') connstate = 'SYN_SENT';\n\n                  if (connstate === 'LISTENING') connstate = 'LISTEN';\n                  if (connstate === 'SYN_RECEIVED') connstate = 'SYN_RECV';\n                  if (connstate === 'FIN_WAIT_1') connstate = 'FIN_WAIT1';\n                  if (connstate === 'FIN_WAIT_2') connstate = 'FIN_WAIT2';\n                  if (connstate) {\n                    result.push({\n                      protocol: line[0].toLowerCase(),\n                      localaddress: localip,\n                      localport: localport,\n                      peeraddress: peerip,\n                      peerport: peerport,\n                      state: connstate,\n                      pid,\n                      process: ''\n                    });\n                  }\n                }\n              });\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkConnections = networkConnections;\n\nfunction networkGatewayDefault(callback) {\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      let result = '';\n      if (_linux || _freebsd || _openbsd || _netbsd) {\n        let cmd = 'ip route get 1';\n        try {\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n');\n              const line = lines && lines[0] ? lines[0] : '';\n              let parts = line.split(' via ');\n              if (parts && parts[1]) {\n                parts = parts[1].split(' ');\n                result = parts[0];\n              }\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_darwin) {\n        let cmd = 'route -n get default';\n        try {\n          exec(cmd, { maxBuffer: 1024 * 20000 }, function (error, stdout) {\n            if (!error) {\n              let lines = stdout.toString().split('\\n').map(line => line.trim());\n              result = util.getValue(lines, 'gateway');\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n      if (_windows) {\n        try {\n          exec('netstat -r', util.execOptsWin, function (error, stdout) {\n            const lines = stdout.toString().split(os.EOL);\n            lines.forEach(line => {\n              line = line.replace(/\\s+/g, ' ').trim();\n              if (line.indexOf('0.0.0.0 0.0.0.0') > -1 && !(/[a-zA-Z]/.test(line))) {\n                const parts = line.split(' ');\n                if (parts.length >= 5 && (parts[parts.length - 3]).indexOf('.') > -1) {\n                  result = parts[parts.length - 3];\n                }\n              }\n            });\n            if (!result) {\n              util.powerShell('Get-CimInstance -ClassName Win32_IP4RouteTable | Where-Object { $_.Destination -eq \\'0.0.0.0\\' -and $_.Mask -eq \\'0.0.0.0\\' }')\n                .then(data => {\n                  let lines = data.toString().split('\\r\\n');\n                  if (lines.length > 1 && !result) {\n                    result = util.getValue(lines, 'NextHop');\n                    if (callback) {\n                      callback(result);\n                    }\n                    resolve(result);\n                    // } else {\n                    //   exec('ipconfig', util.execOptsWin, function (error, stdout) {\n                    //     let lines = stdout.toString().split('\\r\\n');\n                    //     lines.forEach(function (line) {\n                    //       line = line.trim().replace(/\\. /g, '');\n                    //       line = line.trim().replace(/ +/g, '');\n                    //       const parts = line.split(':');\n                    //       if ((parts[0].toLowerCase().startsWith('standardgate') || parts[0].toLowerCase().indexOf('gateway') > -1 || parts[0].toLowerCase().indexOf('enlace') > -1) && parts[1]) {\n                    //         result = parts[1];\n                    //       }\n                    //     });\n                    //     if (callback) { callback(result); }\n                    //     resolve(result);\n                    //   });\n                  }\n                });\n            } else {\n              if (callback) {\n                callback(result);\n              }\n              resolve(result);\n            }\n          });\n        } catch (e) {\n          if (callback) { callback(result); }\n          resolve(result);\n        }\n      }\n    });\n  });\n}\n\nexports.networkGatewayDefault = networkGatewayDefault;\n", "'use strict';\n// @ts-check\n// ==================================================================================\n// utils.js\n// ----------------------------------------------------------------------------------\n// Description:   System Information - library\n//                for Node.js\n// Copyright:     (c) 2014 - 2020\n// Author:        Sebastian Hildebrandt\n// ----------------------------------------------------------------------------------\n// License:       MIT\n// ==================================================================================\n// 0. helper functions\n// ----------------------------------------------------------------------------------\n\nconst os = require('os');\nconst fs = require('fs');\nconst spawn = require('child_process').spawn;\nconst exec = require('child_process').exec;\nconst execSync = require('child_process').execSync;\nconst util = require('util');\n\nlet _platform = process.platform;\nconst _linux = (_platform === 'linux');\nconst _darwin = (_platform === 'darwin');\nconst _windows = (_platform === 'win32');\nconst _freebsd = (_platform === 'freebsd');\nconst _openbsd = (_platform === 'openbsd');\nconst _netbsd = (_platform === 'netbsd');\n// const _sunos = (_platform === 'sunos');\n\nlet _cores = 0;\nlet wmicPath = '';\nlet codepage = '';\n\nconst execOptsWin = {\n  windowsHide: true,\n  maxBuffer: 1024 * 20000,\n  encoding: 'UTF-8',\n  env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n};\n\nfunction toInt(value) {\n  let result = parseInt(value, 10);\n  if (isNaN(result)) {\n    result = 0;\n  }\n  return result;\n}\n\nfunction isFunction(functionToCheck) {\n  let getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\nfunction unique(obj) {\n  let uniques = [];\n  let stringify = {};\n  for (let i = 0; i < obj.length; i++) {\n    let keys = Object.keys(obj[i]);\n    keys.sort(function (a, b) { return a - b; });\n    let str = '';\n    for (let j = 0; j < keys.length; j++) {\n      str += JSON.stringify(keys[j]);\n      str += JSON.stringify(obj[i][keys[j]]);\n    }\n    if (!{}.hasOwnProperty.call(stringify, str)) {\n      uniques.push(obj[i]);\n      stringify[str] = true;\n    }\n  }\n  return uniques;\n}\n\nfunction sortByKey(array, keys) {\n  return array.sort(function (a, b) {\n    let x = '';\n    let y = '';\n    keys.forEach(function (key) {\n      x = x + a[key]; y = y + b[key];\n    });\n    return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n  });\n}\n\nfunction cores() {\n  if (_cores === 0) {\n    _cores = os.cpus().length;\n  }\n  return _cores;\n}\n\nfunction getValue(lines, property, separator, trimmed) {\n  separator = separator || ':';\n  property = property.toLowerCase();\n  trimmed = trimmed || false;\n  for (let i = 0; i < lines.length; i++) {\n    let line = lines[i].toLowerCase().replace(/\\t/g, '');\n    if (trimmed) {\n      line = line.trim();\n    }\n    if (line.startsWith(property)) {\n      const parts = lines[i].split(separator);\n      if (parts.length >= 2) {\n        parts.shift();\n        return parts.join(separator).trim();\n      } else {\n        return '';\n      }\n    }\n  }\n  return '';\n}\n\nfunction decodeEscapeSequence(str, base) {\n  base = base || 16;\n  return str.replace(/\\\\x([0-9A-Fa-f]{2})/g, function () {\n    return String.fromCharCode(parseInt(arguments[1], base));\n  });\n}\n\nfunction detectSplit(str) {\n  let seperator = '';\n  let part = 0;\n  str.split('').forEach(element => {\n    if (element >= '0' && element <= '9') {\n      if (part === 1) { part++; }\n    } else {\n      if (part === 0) { part++; }\n      if (part === 1) {\n        seperator += element;\n      }\n    }\n  });\n  return seperator;\n}\n\nfunction parseTime(t, pmDesignator) {\n  pmDesignator = pmDesignator || '';\n  t = t.toUpperCase();\n  let hour = 0;\n  let min = 0;\n  let splitter = detectSplit(t);\n  let parts = t.split(splitter);\n  if (parts.length >= 2) {\n    if (parts[2]) {\n      parts[1] += parts[2];\n    }\n    let isPM = (parts[1] && (parts[1].toLowerCase().indexOf('pm') > -1) || (parts[1].toLowerCase().indexOf('p.m.') > -1) || (parts[1].toLowerCase().indexOf('p. m.') > -1) || (parts[1].toLowerCase().indexOf('n') > -1) || (parts[1].toLowerCase().indexOf('ch') > -1) || (parts[1].toLowerCase().indexOf('\u00f6s') > -1) || (pmDesignator && parts[1].toLowerCase().indexOf(pmDesignator) > -1));\n    hour = parseInt(parts[0], 10);\n    min = parseInt(parts[1], 10);\n    hour = isPM && hour < 12 ? hour + 12 : hour;\n    return ('0' + hour).substr(-2) + ':' + ('0' + min).substr(-2);\n  }\n}\n\nfunction parseDateTime(dt, culture) {\n  const result = {\n    date: '',\n    time: ''\n  };\n  culture = culture || {};\n  let dateFormat = (culture.dateFormat || '').toLowerCase();\n  let pmDesignator = (culture.pmDesignator || '');\n\n  const parts = dt.split(' ');\n  if (parts[0]) {\n    if (parts[0].indexOf('/') >= 0) {\n      // Dateformat: mm/dd/yyyy or dd/mm/yyyy or dd/mm/yy or yyyy/mm/dd\n      const dtparts = parts[0].split('/');\n      if (dtparts.length === 3) {\n        if (dtparts[0].length === 4) {\n          // Dateformat: yyyy/mm/dd\n          result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n        } else if (dtparts[2].length === 2) {\n          if ((dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1)) {\n            // Dateformat: mm/dd/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yy\n            result.date = '20' + dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        } else {\n          // Dateformat: mm/dd/yyyy or dd/mm/yyyy\n          const isEN = ((dt.toLowerCase().indexOf('pm') > -1) || (dt.toLowerCase().indexOf('p.m.') > -1) || (dt.toLowerCase().indexOf('p. m.') > -1) || (dt.toLowerCase().indexOf('am') > -1) || (dt.toLowerCase().indexOf('a.m.') > -1) || (dt.toLowerCase().indexOf('a. m.') > -1));\n          if ((isEN || dateFormat.indexOf('/d/') > -1 || dateFormat.indexOf('/dd/') > -1) && dateFormat.indexOf('dd/') !== 0) {\n            // Dateformat: mm/dd/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n          } else {\n            // Dateformat: dd/mm/yyyy\n            result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n          }\n        }\n      }\n    }\n    if (parts[0].indexOf('.') >= 0) {\n      const dtparts = parts[0].split('.');\n      if (dtparts.length === 3) {\n        if (dateFormat.indexOf('.d.') > -1 || dateFormat.indexOf('.dd.') > -1) {\n          // Dateformat: mm.dd.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[0]).substr(-2) + '-' + ('0' + dtparts[1]).substr(-2);\n        } else {\n          // Dateformat: dd.mm.yyyy\n          result.date = dtparts[2] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[0]).substr(-2);\n        }\n      }\n    }\n    if (parts[0].indexOf('-') >= 0) {\n      // Dateformat: yyyy-mm-dd\n      const dtparts = parts[0].split('-');\n      if (dtparts.length === 3) {\n        result.date = dtparts[0] + '-' + ('0' + dtparts[1]).substr(-2) + '-' + ('0' + dtparts[2]).substr(-2);\n      }\n    }\n  }\n  if (parts[1]) {\n    parts.shift();\n    let time = parts.join(' ');\n    result.time = parseTime(time, pmDesignator);\n  }\n  return result;\n}\n\nfunction parseHead(head, rights) {\n  let space = (rights > 0);\n  let count = 1;\n  let from = 0;\n  let to = 0;\n  let result = [];\n  for (let i = 0; i < head.length; i++) {\n    if (count <= rights) {\n      // if (head[i] === ' ' && !space) {\n      if (/\\s/.test(head[i]) && !space) {\n        to = i - 1;\n        result.push({\n          from: from,\n          to: to + 1,\n          cap: head.substring(from, to + 1)\n        });\n        from = to + 2;\n        count++;\n      }\n      space = head[i] === ' ';\n    } else {\n      if (!/\\s/.test(head[i]) && space) {\n        to = i - 1;\n        if (from < to) {\n          result.push({\n            from: from,\n            to: to,\n            cap: head.substring(from, to)\n          });\n        }\n        from = to + 1;\n        count++;\n      }\n      space = head[i] === ' ';\n    }\n  }\n  to = 1000;\n  result.push({\n    from: from,\n    to: to,\n    cap: head.substring(from, to)\n  });\n  let len = result.length;\n  for (var i = 0; i < len; i++) {\n    if (result[i].cap.replace(/\\s/g, '').length === 0) {\n      if (i + 1 < len) {\n        result[i].to = result[i + 1].to;\n        result[i].cap = result[i].cap + result[i + 1].cap;\n        result.splice(i + 1, 1);\n        len = len - 1;\n      }\n    }\n  }\n  return result;\n}\n\nfunction findObjectByKey(array, key, value) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i][key] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction getWmic() {\n  if (os.type() === 'Windows_NT' && !wmicPath) {\n    wmicPath = process.env.WINDIR + '\\\\system32\\\\wbem\\\\wmic.exe';\n    if (!fs.existsSync(wmicPath)) {\n      try {\n        const wmicPathArray = execSync('WHERE WMIC').toString().split('\\r\\n');\n        if (wmicPathArray && wmicPathArray.length) {\n          wmicPath = wmicPathArray[0];\n        } else {\n          wmicPath = 'wmic';\n        }\n      } catch (e) {\n        wmicPath = 'wmic';\n      }\n    }\n  }\n  return wmicPath;\n}\n\nfunction wmic(command, options) {\n  options = options || execOptsWin;\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        exec(process.env.WINDIR + '\\\\system32\\\\chcp.com 65001 | ' + getWmic() + ' ' + command, options, function (error, stdout) {\n          resolve(stdout, error);\n        }).stdin.end();\n      } catch (e) {\n        resolve('', e);\n      }\n    });\n  });\n}\n\nfunction getVboxmanage() {\n  return _windows ? process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH + '\\\\VBoxManage.exe' + '\" ' : 'vboxmanage';\n}\n\nfunction powerShell(cmd) {\n\n  let result = '';\n\n  return new Promise((resolve) => {\n    process.nextTick(() => {\n      try {\n        const child = spawn('powershell.exe', ['-NoLogo', '-InputFormat', 'Text', '-NoExit', '-ExecutionPolicy', 'Unrestricted', '-Command', '-'], {\n          stdio: 'pipe',\n          windowsHide: true,\n          maxBuffer: 1024 * 20000,\n          encoding: 'UTF-8',\n          env: util._extend({}, process.env, { LANG: 'en_US.UTF-8' })\n        });\n\n        if (child && !child.pid) {\n          child.on('error', function () {\n            resolve(result);\n          });\n        }\n        if (child && child.pid) {\n          child.stdout.on('data', function (data) {\n            result = result + data.toString('utf8');\n          });\n          child.stderr.on('data', function () {\n            child.kill();\n            resolve(result);\n          });\n          child.on('close', function () {\n            child.kill();\n            resolve(result);\n          });\n          child.on('error', function () {\n            child.kill();\n            resolve(result);\n          });\n          try {\n            child.stdin.write(cmd + os.EOL);\n            child.stdin.write('exit' + os.EOL);\n            child.stdin.end();\n          } catch (e) {\n            child.kill();\n            resolve(result);\n          }\n        } else {\n          resolve(result);\n        }\n      } catch (e) {\n        resolve(result);\n      }\n    });\n  });\n}\n\nfunction getCodepage() {\n  if (_windows) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('chcp');\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split(':');\n        codepage = parts.length > 1 ? parts[1].replace('.', '') : '';\n      } catch (err) {\n        codepage = '437';\n      }\n    }\n    return codepage;\n  }\n  if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {\n    if (!codepage) {\n      try {\n        const stdout = execSync('echo $LANG');\n        const lines = stdout.toString().split('\\r\\n');\n        const parts = lines[0].split('.');\n        codepage = parts.length > 1 ? parts[1].trim() : '';\n        if (!codepage) {\n          codepage = 'UTF-8';\n        }\n      } catch (err) {\n        codepage = 'UTF-8';\n      }\n    }\n    return codepage;\n  }\n}\n\nfunction isRaspberry() {\n  const PI_MODEL_NO = [\n    'BCM2708',\n    'BCM2709',\n    'BCM2710',\n    'BCM2835',\n    'BCM2837B0'\n  ];\n  let cpuinfo = [];\n  try {\n    cpuinfo = fs.readFileSync('/proc/cpuinfo', { encoding: 'utf8' }).split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const hardware = getValue(cpuinfo, 'hardware');\n  return (hardware && PI_MODEL_NO.indexOf(hardware) > -1);\n}\n\nfunction isRaspbian() {\n  let osrelease = [];\n  try {\n    osrelease = fs.readFileSync('/etc/os-release', { encoding: 'utf8' }).split('\\n');\n  } catch (e) {\n    return false;\n  }\n  const id = getValue(osrelease, 'id');\n  return (id && id.indexOf('raspbian') > -1);\n}\n\nfunction execWin(cmd, opts, callback) {\n  if (!callback) {\n    callback = opts;\n    opts = execOptsWin;\n  }\n  let newCmd = 'chcp 65001 > nul && cmd /C ' + cmd + ' && chcp ' + codepage + ' > nul';\n  exec(newCmd, opts, function (error, stdout) {\n    callback(error, stdout);\n  });\n}\n\nfunction darwinXcodeExists() {\n  const cmdLineToolsExists = fs.existsSync('/Library/Developer/CommandLineTools/usr/bin/');\n  const xcodeAppExists = fs.existsSync('/Applications/Xcode.app/Contents/Developer/Tools');\n  const xcodeExists = fs.existsSync('/Library/Developer/Xcode/');\n  return (cmdLineToolsExists || xcodeExists || xcodeAppExists);\n}\n\nfunction nanoSeconds() {\n  const time = process.hrtime();\n  if (!Array.isArray(time) || time.length !== 2) {\n    return 0;\n  }\n  return +time[0] * 1e9 + +time[1];\n}\n\nfunction countUniqueLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      if (uniqueLines.indexOf(line) === -1) {\n        uniqueLines.push(line);\n      }\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction countLines(lines, startingWith) {\n  startingWith = startingWith || '';\n  const uniqueLines = [];\n  lines.forEach(line => {\n    if (line.startsWith(startingWith)) {\n      uniqueLines.push(line);\n    }\n  });\n  return uniqueLines.length;\n}\n\nfunction sanitizeShellString(str) {\n  const s = str || '';\n  let result = '';\n  for (let i = 0; i <= 2000; i++) {\n    if (!(s[i] === undefined ||\n      s[i] === '>' ||\n      s[i] === '<' ||\n      s[i] === '*' ||\n      s[i] === '?' ||\n      s[i] === '[' ||\n      s[i] === ']' ||\n      s[i] === '|' ||\n      s[i] === '\u02da' ||\n      s[i] === '$' ||\n      s[i] === ';' ||\n      s[i] === '&' ||\n      s[i] === '(' ||\n      s[i] === ')' ||\n      s[i] === ']' ||\n      s[i] === '#' ||\n      s[i] === '\\\\' ||\n      s[i] === '\\t' ||\n      s[i] === '\\n' ||\n      s[i] === '\"')) {\n      result = result + s[i];\n    }\n  }\n  return result;\n}\n\nfunction isPrototypePolluted() {\n  const s = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  let notPolluted = true;\n  let st = '';\n  notPolluted = notPolluted || !(s.length === 62)\n  const ms = Date.now();\n  if (typeof ms === 'number' && ms > 1600000000000) {\n    const l = ms % 100 + 15;\n    let c = 0;\n    for (let i = 0; i < l; i++) {\n      const r = Math.random() * 61.99999999 + 1;\n      const rs = parseInt(Math.floor(r).toString(), 10)\n      const rs2 = parseInt(r.toString().split('.')[0], 10);\n      const q = Math.random() * 61.99999999 + 1;\n      const qs = parseInt(Math.floor(q).toString(), 10)\n      const qs2 = parseInt(q.toString().split('.')[0], 10);\n      notPolluted = notPolluted && !(r === q);\n      notPolluted = notPolluted && rs === rs2 && qs === qs2;\n      st += s[rs - 1];\n    }\n    notPolluted = notPolluted && st.length === l;\n    // string manipulation\n    let p = Math.random() * l * 0.9999999999;\n    let stm = st.substr(0, p) + ' ' + st.substr(p, 2000);\n    let sto = stm.replace(/ /g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '{' + st.substr(p, 2000);\n    sto = stm.replace(/{/g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '*' + st.substr(p, 2000);\n    sto = stm.replace(/\\*/g, '');\n    notPolluted = notPolluted && st === sto;\n    p = Math.random() * l * 0.9999999999;\n    stm = st.substr(0, p) + '$' + st.substr(p, 2000);\n    sto = stm.replace(/\\$/g, '');\n    notPolluted = notPolluted && st === sto;\n\n    // lower\n    const stl = st.toLowerCase();\n    notPolluted = notPolluted && (stl.length === l) && stl[l - 1] && !(stl[l])\n    for (let i = 0; i < l; i++) {\n      const s1 = st[i];\n      const s2 = stl[i];\n      const s1l = s1.toLowerCase();\n      notPolluted = notPolluted && s1l[0] === s2 && s1l[0] && !(s1l[1]);\n    }\n  }\n  return !notPolluted;\n}\n\nfunction hex2bin(hex) {\n  return (\"00000000\" + (parseInt(hex, 16)).toString(2)).substr(-8);\n}\n\nfunction decodePiCpuinfo(lines) {\n\n  // https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md\n\n  const oldRevisionCodes = {\n    '0002': {\n      type: 'B',\n      revision: '1.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0003': {\n      type: 'B',\n      revision: '1.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0004': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0005': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Qisda',\n      processor: 'BCM2835'\n    },\n    '0006': {\n      type: 'B',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0007': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0008': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0009': {\n      type: 'A',\n      revision: '2.0',\n      memory: 256,\n      manufacturer: 'Qisda',\n      processor: 'BCM2835'\n    },\n    '000d': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '000e': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '000f': {\n      type: 'B',\n      revision: '2.0',\n      memory: 512,\n      manufacturer: 'Egoman',\n      processor: 'BCM2835'\n    },\n    '0010': {\n      type: 'B+',\n      revision: '1.2',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0011': {\n      type: 'CM1',\n      revision: '1.0',\n      memory: 512,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0012': {\n      type: 'A+',\n      revision: '1.1',\n      memory: 256,\n      manufacturer: 'Sony UK',\n      processor: 'BCM2835'\n    },\n    '0013': {\n      type: 'B+',\n      revision: '1.2',\n      memory: 512,\n      manufacturer: 'Embest',\n      processor: 'BCM2835'\n    },\n    '0014': {\n      type: 'CM1',\n      revision: '1.0',\n      memory: 512,\n      manufacturer: 'Embest',\n      processor: 'BCM2835'\n    },\n    '0015': {\n      type: 'A+',\n      revision: '1.1',\n      memory: 256,\n      manufacturer: '512MB\tEmbest',\n      processor: 'BCM2835'\n    }\n  }\n\n  const processorList = [\n    'BMC2835',\n    'BMC2836',\n    'BMC2837',\n    'BMC2711',\n  ];\n  const manufacturerList = [\n    'Sony UK',\n    'Egoman',\n    'Embest',\n    'Sony Japan',\n    'Embest',\n    'Stadium'\n  ];\n  const typeList = {\n    '00': 'A',\n    '01': 'B',\n    '02': 'A+',\n    '03': 'B+',\n    '04': '2B',\n    '05': 'Alpha (early prototype)',\n    '06': 'CM1',\n    '08': '3B',\n    '09': 'Zero',\n    '0a': 'CM3',\n    '0c': 'Zero W',\n    '0d': '3B+',\n    '0e': '3A+',\n    '0f': 'Internal use only',\n    '10': 'CM3+',\n    '11': '4B',\n    '13': '400',\n    '14': 'CM4'\n  };\n\n  const revisionCode = getValue(lines, 'revision', ':', true);\n  const model = getValue(lines, 'model:', ':', true);\n  const serial = getValue(lines, 'serial', ':', true);\n\n  let result = {};\n  if (oldRevisionCodes.hasOwnProperty(revisionCode)) {\n    // old revision codes\n    result = {\n      model,\n      serial,\n      revisionCode,\n      memory: oldRevisionCodes[revisionCode].memory,\n      manufacturer: oldRevisionCodes[revisionCode].manufacturer,\n      processor: oldRevisionCodes[revisionCode].processor,\n      type: oldRevisionCodes[revisionCode].type,\n      revision: oldRevisionCodes[revisionCode].revision,\n    }\n\n  } else {\n    // new revision code\n    const revision = ('00000000' + getValue(lines, 'revision', ':', true).toLowerCase()).substr(-8);\n    // const revisionStyleNew = hex2bin(revision.substr(2, 1)).substr(4, 1) === '1';\n    const memSizeCode = parseInt(hex2bin(revision.substr(2, 1)).substr(5, 3), 2) || 0;\n    const manufacturer = manufacturerList[parseInt(revision.substr(3, 1), 10)];\n    const processor = processorList[parseInt(revision.substr(4, 1), 10)];\n    const typeCode = revision.substr(5, 2);\n\n\n    result = {\n      model,\n      serial,\n      revisionCode,\n      memory: 256 * Math.pow(2, memSizeCode),\n      manufacturer,\n      processor,\n      type: typeList.hasOwnProperty(typeCode) ? typeList[typeCode] : '',\n      revision: '1.' + revision.substr(7, 1),\n    }\n  }\n  return result;\n}\n\nfunction noop() { }\n\nexports.toInt = toInt;\nexports.execOptsWin = execOptsWin;\nexports.getCodepage = getCodepage;\nexports.execWin = execWin;\nexports.isFunction = isFunction;\nexports.unique = unique;\nexports.sortByKey = sortByKey;\nexports.cores = cores;\nexports.getValue = getValue;\nexports.decodeEscapeSequence = decodeEscapeSequence;\nexports.parseDateTime = parseDateTime;\nexports.parseHead = parseHead;\nexports.findObjectByKey = findObjectByKey;\nexports.getWmic = getWmic;\nexports.wmic = wmic;\nexports.darwinXcodeExists = darwinXcodeExists;\nexports.getVboxmanage = getVboxmanage;\nexports.powerShell = powerShell;\nexports.nanoSeconds = nanoSeconds;\nexports.countUniqueLines = countUniqueLines;\nexports.countLines = countLines;\nexports.noop = noop;\nexports.isRaspberry = isRaspberry;\nexports.isRaspbian = isRaspbian;\nexports.sanitizeShellString = sanitizeShellString;\nexports.isPrototypePolluted = isPrototypePolluted;\nexports.decodePiCpuinfo = decodePiCpuinfo;\n"], "filenames": ["lib/internet.js", "lib/network.js", "lib/util.js"], "buggy_code_start_loc": [38, 1137, 495], "buggy_code_end_loc": [46, 1144, 565], "fixing_code_start_loc": [38, 1137, 495], "fixing_code_end_loc": [46, 1144, 565], "type": "CWE-78", "message": "This affects the package systeminformation before 4.30.2. The attacker can overwrite the properties and functions of an object, which can lead to executing OS commands.", "other": {"cve": {"id": "CVE-2020-7778", "sourceIdentifier": "report@snyk.io", "published": "2020-11-26T11:15:10.787", "lastModified": "2020-12-01T14:28:03.860", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package systeminformation before 4.30.2. The attacker can overwrite the properties and functions of an object, which can lead to executing OS commands."}, {"lang": "es", "value": "Esto afecta al paquete systeminformation versiones anteriores a 4.30.2.&#xa0;El atacante puede sobrescribir las propiedades y funciones de un objeto, lo que puede conllevar a ejecutar comandos del Sistema Operativo"}], "metrics": {"cvssMetricV31": [{"source": "report@snyk.io", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:systeminformation:systeminformation:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.30.2", "matchCriteriaId": "8FFE7016-650C-428C-B16B-28CF0F1ED01D"}]}]}], "references": [{"url": "https://gist.github.com/EffectRenan/b434438938eed0b21b376cedf5c81e80", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/sebhildebrandt/systeminformation/blob/master/lib/internet.js", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/sebhildebrandt/systeminformation/commit/11103a447ab9550c25f1fbec7e6d903720b3fea8%23diff-970ae648187190f86bafc8f193b7538200eba164fad0674428b6487582c089cc", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sebhildebrandt/systeminformation/commit/73dce8d717ca9c3b7b0d0688254b8213b957f0fa%23diff-970ae648187190f86bafc8f193b7538200eba164fad0674428b6487582c089cc", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-SYSTEMINFORMATION-1043753", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sebhildebrandt/systeminformation/commit/11103a447ab9550c25f1fbec7e6d903720b3fea8%23diff-970ae648187190f86bafc8f193b7538200eba164fad0674428b6487582c089cc"}}