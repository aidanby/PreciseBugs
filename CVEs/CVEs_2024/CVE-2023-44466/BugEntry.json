{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Ceph msgr2 protocol implementation\n *\n * Copyright (C) 2020 Ilya Dryomov <idryomov@gmail.com>\n */\n\n#include <linux/ceph/ceph_debug.h>\n\n#include <crypto/aead.h>\n#include <crypto/algapi.h>  /* for crypto_memneq() */\n#include <crypto/hash.h>\n#include <crypto/sha2.h>\n#include <linux/bvec.h>\n#include <linux/crc32c.h>\n#include <linux/net.h>\n#include <linux/scatterlist.h>\n#include <linux/socket.h>\n#include <linux/sched/mm.h>\n#include <net/sock.h>\n#include <net/tcp.h>\n\n#include <linux/ceph/ceph_features.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/libceph.h>\n#include <linux/ceph/messenger.h>\n\n#include \"crypto.h\"  /* for CEPH_KEY_LEN and CEPH_MAX_CON_SECRET_LEN */\n\n#define FRAME_TAG_HELLO\t\t\t1\n#define FRAME_TAG_AUTH_REQUEST\t\t2\n#define FRAME_TAG_AUTH_BAD_METHOD\t3\n#define FRAME_TAG_AUTH_REPLY_MORE\t4\n#define FRAME_TAG_AUTH_REQUEST_MORE\t5\n#define FRAME_TAG_AUTH_DONE\t\t6\n#define FRAME_TAG_AUTH_SIGNATURE\t7\n#define FRAME_TAG_CLIENT_IDENT\t\t8\n#define FRAME_TAG_SERVER_IDENT\t\t9\n#define FRAME_TAG_IDENT_MISSING_FEATURES 10\n#define FRAME_TAG_SESSION_RECONNECT\t11\n#define FRAME_TAG_SESSION_RESET\t\t12\n#define FRAME_TAG_SESSION_RETRY\t\t13\n#define FRAME_TAG_SESSION_RETRY_GLOBAL\t14\n#define FRAME_TAG_SESSION_RECONNECT_OK\t15\n#define FRAME_TAG_WAIT\t\t\t16\n#define FRAME_TAG_MESSAGE\t\t17\n#define FRAME_TAG_KEEPALIVE2\t\t18\n#define FRAME_TAG_KEEPALIVE2_ACK\t19\n#define FRAME_TAG_ACK\t\t\t20\n\n#define FRAME_LATE_STATUS_ABORTED\t0x1\n#define FRAME_LATE_STATUS_COMPLETE\t0xe\n#define FRAME_LATE_STATUS_ABORTED_MASK\t0xf\n\n#define IN_S_HANDLE_PREAMBLE\t\t1\n#define IN_S_HANDLE_CONTROL\t\t2\n#define IN_S_HANDLE_CONTROL_REMAINDER\t3\n#define IN_S_PREPARE_READ_DATA\t\t4\n#define IN_S_PREPARE_READ_DATA_CONT\t5\n#define IN_S_PREPARE_READ_ENC_PAGE\t6\n#define IN_S_HANDLE_EPILOGUE\t\t7\n#define IN_S_FINISH_SKIP\t\t8\n\n#define OUT_S_QUEUE_DATA\t\t1\n#define OUT_S_QUEUE_DATA_CONT\t\t2\n#define OUT_S_QUEUE_ENC_PAGE\t\t3\n#define OUT_S_QUEUE_ZEROS\t\t4\n#define OUT_S_FINISH_MESSAGE\t\t5\n#define OUT_S_GET_NEXT\t\t\t6\n\n#define CTRL_BODY(p)\t((void *)(p) + CEPH_PREAMBLE_LEN)\n#define FRONT_PAD(p)\t((void *)(p) + CEPH_EPILOGUE_SECURE_LEN)\n#define MIDDLE_PAD(p)\t(FRONT_PAD(p) + CEPH_GCM_BLOCK_LEN)\n#define DATA_PAD(p)\t(MIDDLE_PAD(p) + CEPH_GCM_BLOCK_LEN)\n\n#define CEPH_MSG_FLAGS (MSG_DONTWAIT | MSG_NOSIGNAL)\n\nstatic int do_recvmsg(struct socket *sock, struct iov_iter *it)\n{\n\tstruct msghdr msg = { .msg_flags = CEPH_MSG_FLAGS };\n\tint ret;\n\n\tmsg.msg_iter = *it;\n\twhile (iov_iter_count(it)) {\n\t\tret = sock_recvmsg(sock, &msg, msg.msg_flags);\n\t\tif (ret <= 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tiov_iter_advance(it, ret);\n\t}\n\n\tWARN_ON(msg_data_left(&msg));\n\treturn 1;\n}\n\n/*\n * Read as much as possible.\n *\n * Return:\n *   1 - done, nothing (else) to read\n *   0 - socket is empty, need to wait\n *  <0 - error\n */\nstatic int ceph_tcp_recv(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s con %p %s %zu\\n\", __func__, con,\n\t     iov_iter_is_discard(&con->v2.in_iter) ? \"discard\" : \"need\",\n\t     iov_iter_count(&con->v2.in_iter));\n\tret = do_recvmsg(con->sock, &con->v2.in_iter);\n\tdout(\"%s con %p ret %d left %zu\\n\", __func__, con, ret,\n\t     iov_iter_count(&con->v2.in_iter));\n\treturn ret;\n}\n\nstatic int do_sendmsg(struct socket *sock, struct iov_iter *it)\n{\n\tstruct msghdr msg = { .msg_flags = CEPH_MSG_FLAGS };\n\tint ret;\n\n\tmsg.msg_iter = *it;\n\twhile (iov_iter_count(it)) {\n\t\tret = sock_sendmsg(sock, &msg);\n\t\tif (ret <= 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tiov_iter_advance(it, ret);\n\t}\n\n\tWARN_ON(msg_data_left(&msg));\n\treturn 1;\n}\n\nstatic int do_try_sendpage(struct socket *sock, struct iov_iter *it)\n{\n\tstruct msghdr msg = { .msg_flags = CEPH_MSG_FLAGS };\n\tstruct bio_vec bv;\n\tint ret;\n\n\tif (WARN_ON(!iov_iter_is_bvec(it)))\n\t\treturn -EINVAL;\n\n\twhile (iov_iter_count(it)) {\n\t\t/* iov_iter_iovec() for ITER_BVEC */\n\t\tbvec_set_page(&bv, it->bvec->bv_page,\n\t\t\t      min(iov_iter_count(it),\n\t\t\t\t  it->bvec->bv_len - it->iov_offset),\n\t\t\t      it->bvec->bv_offset + it->iov_offset);\n\n\t\t/*\n\t\t * MSG_SPLICE_PAGES cannot properly handle pages with\n\t\t * page_count == 0, we need to fall back to sendmsg if\n\t\t * that's the case.\n\t\t *\n\t\t * Same goes for slab pages: skb_can_coalesce() allows\n\t\t * coalescing neighboring slab objects into a single frag\n\t\t * which triggers one of hardened usercopy checks.\n\t\t */\n\t\tif (sendpage_ok(bv.bv_page))\n\t\t\tmsg.msg_flags |= MSG_SPLICE_PAGES;\n\t\telse\n\t\t\tmsg.msg_flags &= ~MSG_SPLICE_PAGES;\n\n\t\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, &bv, 1, bv.bv_len);\n\t\tret = sock_sendmsg(sock, &msg);\n\t\tif (ret <= 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tiov_iter_advance(it, ret);\n\t}\n\n\treturn 1;\n}\n\n/*\n * Write as much as possible.  The socket is expected to be corked,\n * so we don't bother with MSG_MORE here.\n *\n * Return:\n *   1 - done, nothing (else) to write\n *   0 - socket is full, need to wait\n *  <0 - error\n */\nstatic int ceph_tcp_send(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s con %p have %zu try_sendpage %d\\n\", __func__, con,\n\t     iov_iter_count(&con->v2.out_iter), con->v2.out_iter_sendpage);\n\tif (con->v2.out_iter_sendpage)\n\t\tret = do_try_sendpage(con->sock, &con->v2.out_iter);\n\telse\n\t\tret = do_sendmsg(con->sock, &con->v2.out_iter);\n\tdout(\"%s con %p ret %d left %zu\\n\", __func__, con, ret,\n\t     iov_iter_count(&con->v2.out_iter));\n\treturn ret;\n}\n\nstatic void add_in_kvec(struct ceph_connection *con, void *buf, int len)\n{\n\tBUG_ON(con->v2.in_kvec_cnt >= ARRAY_SIZE(con->v2.in_kvecs));\n\tWARN_ON(!iov_iter_is_kvec(&con->v2.in_iter));\n\n\tcon->v2.in_kvecs[con->v2.in_kvec_cnt].iov_base = buf;\n\tcon->v2.in_kvecs[con->v2.in_kvec_cnt].iov_len = len;\n\tcon->v2.in_kvec_cnt++;\n\n\tcon->v2.in_iter.nr_segs++;\n\tcon->v2.in_iter.count += len;\n}\n\nstatic void reset_in_kvecs(struct ceph_connection *con)\n{\n\tWARN_ON(iov_iter_count(&con->v2.in_iter));\n\n\tcon->v2.in_kvec_cnt = 0;\n\tiov_iter_kvec(&con->v2.in_iter, ITER_DEST, con->v2.in_kvecs, 0, 0);\n}\n\nstatic void set_in_bvec(struct ceph_connection *con, const struct bio_vec *bv)\n{\n\tWARN_ON(iov_iter_count(&con->v2.in_iter));\n\n\tcon->v2.in_bvec = *bv;\n\tiov_iter_bvec(&con->v2.in_iter, ITER_DEST, &con->v2.in_bvec, 1, bv->bv_len);\n}\n\nstatic void set_in_skip(struct ceph_connection *con, int len)\n{\n\tWARN_ON(iov_iter_count(&con->v2.in_iter));\n\n\tdout(\"%s con %p len %d\\n\", __func__, con, len);\n\tiov_iter_discard(&con->v2.in_iter, ITER_DEST, len);\n}\n\nstatic void add_out_kvec(struct ceph_connection *con, void *buf, int len)\n{\n\tBUG_ON(con->v2.out_kvec_cnt >= ARRAY_SIZE(con->v2.out_kvecs));\n\tWARN_ON(!iov_iter_is_kvec(&con->v2.out_iter));\n\tWARN_ON(con->v2.out_zero);\n\n\tcon->v2.out_kvecs[con->v2.out_kvec_cnt].iov_base = buf;\n\tcon->v2.out_kvecs[con->v2.out_kvec_cnt].iov_len = len;\n\tcon->v2.out_kvec_cnt++;\n\n\tcon->v2.out_iter.nr_segs++;\n\tcon->v2.out_iter.count += len;\n}\n\nstatic void reset_out_kvecs(struct ceph_connection *con)\n{\n\tWARN_ON(iov_iter_count(&con->v2.out_iter));\n\tWARN_ON(con->v2.out_zero);\n\n\tcon->v2.out_kvec_cnt = 0;\n\n\tiov_iter_kvec(&con->v2.out_iter, ITER_SOURCE, con->v2.out_kvecs, 0, 0);\n\tcon->v2.out_iter_sendpage = false;\n}\n\nstatic void set_out_bvec(struct ceph_connection *con, const struct bio_vec *bv,\n\t\t\t bool zerocopy)\n{\n\tWARN_ON(iov_iter_count(&con->v2.out_iter));\n\tWARN_ON(con->v2.out_zero);\n\n\tcon->v2.out_bvec = *bv;\n\tcon->v2.out_iter_sendpage = zerocopy;\n\tiov_iter_bvec(&con->v2.out_iter, ITER_SOURCE, &con->v2.out_bvec, 1,\n\t\t      con->v2.out_bvec.bv_len);\n}\n\nstatic void set_out_bvec_zero(struct ceph_connection *con)\n{\n\tWARN_ON(iov_iter_count(&con->v2.out_iter));\n\tWARN_ON(!con->v2.out_zero);\n\n\tbvec_set_page(&con->v2.out_bvec, ceph_zero_page,\n\t\t      min(con->v2.out_zero, (int)PAGE_SIZE), 0);\n\tcon->v2.out_iter_sendpage = true;\n\tiov_iter_bvec(&con->v2.out_iter, ITER_SOURCE, &con->v2.out_bvec, 1,\n\t\t      con->v2.out_bvec.bv_len);\n}\n\nstatic void out_zero_add(struct ceph_connection *con, int len)\n{\n\tdout(\"%s con %p len %d\\n\", __func__, con, len);\n\tcon->v2.out_zero += len;\n}\n\nstatic void *alloc_conn_buf(struct ceph_connection *con, int len)\n{\n\tvoid *buf;\n\n\tdout(\"%s con %p len %d\\n\", __func__, con, len);\n\n\tif (WARN_ON(con->v2.conn_buf_cnt >= ARRAY_SIZE(con->v2.conn_bufs)))\n\t\treturn NULL;\n\n\tbuf = kvmalloc(len, GFP_NOIO);\n\tif (!buf)\n\t\treturn NULL;\n\n\tcon->v2.conn_bufs[con->v2.conn_buf_cnt++] = buf;\n\treturn buf;\n}\n\nstatic void free_conn_bufs(struct ceph_connection *con)\n{\n\twhile (con->v2.conn_buf_cnt)\n\t\tkvfree(con->v2.conn_bufs[--con->v2.conn_buf_cnt]);\n}\n\nstatic void add_in_sign_kvec(struct ceph_connection *con, void *buf, int len)\n{\n\tBUG_ON(con->v2.in_sign_kvec_cnt >= ARRAY_SIZE(con->v2.in_sign_kvecs));\n\n\tcon->v2.in_sign_kvecs[con->v2.in_sign_kvec_cnt].iov_base = buf;\n\tcon->v2.in_sign_kvecs[con->v2.in_sign_kvec_cnt].iov_len = len;\n\tcon->v2.in_sign_kvec_cnt++;\n}\n\nstatic void clear_in_sign_kvecs(struct ceph_connection *con)\n{\n\tcon->v2.in_sign_kvec_cnt = 0;\n}\n\nstatic void add_out_sign_kvec(struct ceph_connection *con, void *buf, int len)\n{\n\tBUG_ON(con->v2.out_sign_kvec_cnt >= ARRAY_SIZE(con->v2.out_sign_kvecs));\n\n\tcon->v2.out_sign_kvecs[con->v2.out_sign_kvec_cnt].iov_base = buf;\n\tcon->v2.out_sign_kvecs[con->v2.out_sign_kvec_cnt].iov_len = len;\n\tcon->v2.out_sign_kvec_cnt++;\n}\n\nstatic void clear_out_sign_kvecs(struct ceph_connection *con)\n{\n\tcon->v2.out_sign_kvec_cnt = 0;\n}\n\nstatic bool con_secure(struct ceph_connection *con)\n{\n\treturn con->v2.con_mode == CEPH_CON_MODE_SECURE;\n}\n\nstatic int front_len(const struct ceph_msg *msg)\n{\n\treturn le32_to_cpu(msg->hdr.front_len);\n}\n\nstatic int middle_len(const struct ceph_msg *msg)\n{\n\treturn le32_to_cpu(msg->hdr.middle_len);\n}\n\nstatic int data_len(const struct ceph_msg *msg)\n{\n\treturn le32_to_cpu(msg->hdr.data_len);\n}\n\nstatic bool need_padding(int len)\n{\n\treturn !IS_ALIGNED(len, CEPH_GCM_BLOCK_LEN);\n}\n\nstatic int padded_len(int len)\n{\n\treturn ALIGN(len, CEPH_GCM_BLOCK_LEN);\n}\n\nstatic int padding_len(int len)\n{\n\treturn padded_len(len) - len;\n}\n\n/* preamble + control segment */\nstatic int head_onwire_len(int ctrl_len, bool secure)\n{\n\tint head_len;\n\tint rem_len;\n\n\tif (secure) {\n\t\thead_len = CEPH_PREAMBLE_SECURE_LEN;\n\t\tif (ctrl_len > CEPH_PREAMBLE_INLINE_LEN) {\n\t\t\trem_len = ctrl_len - CEPH_PREAMBLE_INLINE_LEN;\n\t\t\thead_len += padded_len(rem_len) + CEPH_GCM_TAG_LEN;\n\t\t}\n\t} else {\n\t\thead_len = CEPH_PREAMBLE_PLAIN_LEN;\n\t\tif (ctrl_len)\n\t\t\thead_len += ctrl_len + CEPH_CRC_LEN;\n\t}\n\treturn head_len;\n}\n\n/* front, middle and data segments + epilogue */\nstatic int __tail_onwire_len(int front_len, int middle_len, int data_len,\n\t\t\t     bool secure)\n{\n\tif (!front_len && !middle_len && !data_len)\n\t\treturn 0;\n\n\tif (!secure)\n\t\treturn front_len + middle_len + data_len +\n\t\t       CEPH_EPILOGUE_PLAIN_LEN;\n\n\treturn padded_len(front_len) + padded_len(middle_len) +\n\t       padded_len(data_len) + CEPH_EPILOGUE_SECURE_LEN;\n}\n\nstatic int tail_onwire_len(const struct ceph_msg *msg, bool secure)\n{\n\treturn __tail_onwire_len(front_len(msg), middle_len(msg),\n\t\t\t\t data_len(msg), secure);\n}\n\n/* head_onwire_len(sizeof(struct ceph_msg_header2), false) */\n#define MESSAGE_HEAD_PLAIN_LEN\t(CEPH_PREAMBLE_PLAIN_LEN +\t\t\\\n\t\t\t\t sizeof(struct ceph_msg_header2) +\t\\\n\t\t\t\t CEPH_CRC_LEN)\n\nstatic const int frame_aligns[] = {\n\tsizeof(void *),\n\tsizeof(void *),\n\tsizeof(void *),\n\tPAGE_SIZE\n};\n\n/*\n * Discards trailing empty segments, unless there is just one segment.\n * A frame always has at least one (possibly empty) segment.\n */\nstatic int calc_segment_count(const int *lens, int len_cnt)\n{\n\tint i;\n\n\tfor (i = len_cnt - 1; i >= 0; i--) {\n\t\tif (lens[i])\n\t\t\treturn i + 1;\n\t}\n\n\treturn 1;\n}\n\nstatic void init_frame_desc(struct ceph_frame_desc *desc, int tag,\n\t\t\t    const int *lens, int len_cnt)\n{\n\tint i;\n\n\tmemset(desc, 0, sizeof(*desc));\n\n\tdesc->fd_tag = tag;\n\tdesc->fd_seg_cnt = calc_segment_count(lens, len_cnt);\n\tBUG_ON(desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT);\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tdesc->fd_lens[i] = lens[i];\n\t\tdesc->fd_aligns[i] = frame_aligns[i];\n\t}\n}\n\n/*\n * Preamble crc covers everything up to itself (28 bytes) and\n * is calculated and verified irrespective of the connection mode\n * (i.e. even if the frame is encrypted).\n */\nstatic void encode_preamble(const struct ceph_frame_desc *desc, void *p)\n{\n\tvoid *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN;\n\tvoid *start = p;\n\tint i;\n\n\tmemset(p, 0, CEPH_PREAMBLE_LEN);\n\n\tceph_encode_8(&p, desc->fd_tag);\n\tceph_encode_8(&p, desc->fd_seg_cnt);\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tceph_encode_32(&p, desc->fd_lens[i]);\n\t\tceph_encode_16(&p, desc->fd_aligns[i]);\n\t}\n\n\tput_unaligned_le32(crc32c(0, start, crcp - start), crcp);\n}\n\nstatic int decode_preamble(void *p, struct ceph_frame_desc *desc)\n{\n\tvoid *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN;\n\tu32 crc, expected_crc;\n\tint i;\n\n\tcrc = crc32c(0, p, crcp - p);\n\texpected_crc = get_unaligned_le32(crcp);\n\tif (crc != expected_crc) {\n\t\tpr_err(\"bad preamble crc, calculated %u, expected %u\\n\",\n\t\t       crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\n\tmemset(desc, 0, sizeof(*desc));\n\n\tdesc->fd_tag = ceph_decode_8(&p);\n\tdesc->fd_seg_cnt = ceph_decode_8(&p);\n\tif (desc->fd_seg_cnt < 1 ||\n\t    desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT) {\n\t\tpr_err(\"bad segment count %d\\n\", desc->fd_seg_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tdesc->fd_lens[i] = ceph_decode_32(&p);\n\t\tdesc->fd_aligns[i] = ceph_decode_16(&p);\n\t}\n\n\t/*\n\t * This would fire for FRAME_TAG_WAIT (it has one empty\n\t * segment), but we should never get it as client.\n\t */\n\tif (!desc->fd_lens[desc->fd_seg_cnt - 1]) {\n\t\tpr_err(\"last segment empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (desc->fd_lens[0] > CEPH_MSG_MAX_CONTROL_LEN) {\n\t\tpr_err(\"control segment too big %d\\n\", desc->fd_lens[0]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[1] > CEPH_MSG_MAX_FRONT_LEN) {\n\t\tpr_err(\"front segment too big %d\\n\", desc->fd_lens[1]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[2] > CEPH_MSG_MAX_MIDDLE_LEN) {\n\t\tpr_err(\"middle segment too big %d\\n\", desc->fd_lens[2]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[3] > CEPH_MSG_MAX_DATA_LEN) {\n\t\tpr_err(\"data segment too big %d\\n\", desc->fd_lens[3]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void encode_epilogue_plain(struct ceph_connection *con, bool aborted)\n{\n\tcon->v2.out_epil.late_status = aborted ? FRAME_LATE_STATUS_ABORTED :\n\t\t\t\t\t\t FRAME_LATE_STATUS_COMPLETE;\n\tcpu_to_le32s(&con->v2.out_epil.front_crc);\n\tcpu_to_le32s(&con->v2.out_epil.middle_crc);\n\tcpu_to_le32s(&con->v2.out_epil.data_crc);\n}\n\nstatic void encode_epilogue_secure(struct ceph_connection *con, bool aborted)\n{\n\tmemset(&con->v2.out_epil, 0, sizeof(con->v2.out_epil));\n\tcon->v2.out_epil.late_status = aborted ? FRAME_LATE_STATUS_ABORTED :\n\t\t\t\t\t\t FRAME_LATE_STATUS_COMPLETE;\n}\n\nstatic int decode_epilogue(void *p, u32 *front_crc, u32 *middle_crc,\n\t\t\t   u32 *data_crc)\n{\n\tu8 late_status;\n\n\tlate_status = ceph_decode_8(&p);\n\tif ((late_status & FRAME_LATE_STATUS_ABORTED_MASK) !=\n\t\t\tFRAME_LATE_STATUS_COMPLETE) {\n\t\t/* we should never get an aborted message as client */\n\t\tpr_err(\"bad late_status 0x%x\\n\", late_status);\n\t\treturn -EINVAL;\n\t}\n\n\tif (front_crc && middle_crc && data_crc) {\n\t\t*front_crc = ceph_decode_32(&p);\n\t\t*middle_crc = ceph_decode_32(&p);\n\t\t*data_crc = ceph_decode_32(&p);\n\t}\n\n\treturn 0;\n}\n\nstatic void fill_header(struct ceph_msg_header *hdr,\n\t\t\tconst struct ceph_msg_header2 *hdr2,\n\t\t\tint front_len, int middle_len, int data_len,\n\t\t\tconst struct ceph_entity_name *peer_name)\n{\n\thdr->seq = hdr2->seq;\n\thdr->tid = hdr2->tid;\n\thdr->type = hdr2->type;\n\thdr->priority = hdr2->priority;\n\thdr->version = hdr2->version;\n\thdr->front_len = cpu_to_le32(front_len);\n\thdr->middle_len = cpu_to_le32(middle_len);\n\thdr->data_len = cpu_to_le32(data_len);\n\thdr->data_off = hdr2->data_off;\n\thdr->src = *peer_name;\n\thdr->compat_version = hdr2->compat_version;\n\thdr->reserved = 0;\n\thdr->crc = 0;\n}\n\nstatic void fill_header2(struct ceph_msg_header2 *hdr2,\n\t\t\t const struct ceph_msg_header *hdr, u64 ack_seq)\n{\n\thdr2->seq = hdr->seq;\n\thdr2->tid = hdr->tid;\n\thdr2->type = hdr->type;\n\thdr2->priority = hdr->priority;\n\thdr2->version = hdr->version;\n\thdr2->data_pre_padding_len = 0;\n\thdr2->data_off = hdr->data_off;\n\thdr2->ack_seq = cpu_to_le64(ack_seq);\n\thdr2->flags = 0;\n\thdr2->compat_version = hdr->compat_version;\n\thdr2->reserved = 0;\n}\n\nstatic int verify_control_crc(struct ceph_connection *con)\n{\n\tint ctrl_len = con->v2.in_desc.fd_lens[0];\n\tu32 crc, expected_crc;\n\n\tWARN_ON(con->v2.in_kvecs[0].iov_len != ctrl_len);\n\tWARN_ON(con->v2.in_kvecs[1].iov_len != CEPH_CRC_LEN);\n\n\tcrc = crc32c(-1, con->v2.in_kvecs[0].iov_base, ctrl_len);\n\texpected_crc = get_unaligned_le32(con->v2.in_kvecs[1].iov_base);\n\tif (crc != expected_crc) {\n\t\tpr_err(\"bad control crc, calculated %u, expected %u\\n\",\n\t\t       crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\n\treturn 0;\n}\n\nstatic int verify_epilogue_crcs(struct ceph_connection *con, u32 front_crc,\n\t\t\t\tu32 middle_crc, u32 data_crc)\n{\n\tif (front_len(con->in_msg)) {\n\t\tcon->in_front_crc = crc32c(-1, con->in_msg->front.iov_base,\n\t\t\t\t\t   front_len(con->in_msg));\n\t} else {\n\t\tWARN_ON(!middle_len(con->in_msg) && !data_len(con->in_msg));\n\t\tcon->in_front_crc = -1;\n\t}\n\n\tif (middle_len(con->in_msg))\n\t\tcon->in_middle_crc = crc32c(-1,\n\t\t\t\t\t    con->in_msg->middle->vec.iov_base,\n\t\t\t\t\t    middle_len(con->in_msg));\n\telse if (data_len(con->in_msg))\n\t\tcon->in_middle_crc = -1;\n\telse\n\t\tcon->in_middle_crc = 0;\n\n\tif (!data_len(con->in_msg))\n\t\tcon->in_data_crc = 0;\n\n\tdout(\"%s con %p msg %p crcs %u %u %u\\n\", __func__, con, con->in_msg,\n\t     con->in_front_crc, con->in_middle_crc, con->in_data_crc);\n\n\tif (con->in_front_crc != front_crc) {\n\t\tpr_err(\"bad front crc, calculated %u, expected %u\\n\",\n\t\t       con->in_front_crc, front_crc);\n\t\treturn -EBADMSG;\n\t}\n\tif (con->in_middle_crc != middle_crc) {\n\t\tpr_err(\"bad middle crc, calculated %u, expected %u\\n\",\n\t\t       con->in_middle_crc, middle_crc);\n\t\treturn -EBADMSG;\n\t}\n\tif (con->in_data_crc != data_crc) {\n\t\tpr_err(\"bad data crc, calculated %u, expected %u\\n\",\n\t\t       con->in_data_crc, data_crc);\n\t\treturn -EBADMSG;\n\t}\n\n\treturn 0;\n}\n\nstatic int setup_crypto(struct ceph_connection *con,\n\t\t\tconst u8 *session_key, int session_key_len,\n\t\t\tconst u8 *con_secret, int con_secret_len)\n{\n\tunsigned int noio_flag;\n\tint ret;\n\n\tdout(\"%s con %p con_mode %d session_key_len %d con_secret_len %d\\n\",\n\t     __func__, con, con->v2.con_mode, session_key_len, con_secret_len);\n\tWARN_ON(con->v2.hmac_tfm || con->v2.gcm_tfm || con->v2.gcm_req);\n\n\tif (con->v2.con_mode != CEPH_CON_MODE_CRC &&\n\t    con->v2.con_mode != CEPH_CON_MODE_SECURE) {\n\t\tpr_err(\"bad con_mode %d\\n\", con->v2.con_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!session_key_len) {\n\t\tWARN_ON(con->v2.con_mode != CEPH_CON_MODE_CRC);\n\t\tWARN_ON(con_secret_len);\n\t\treturn 0;  /* auth_none */\n\t}\n\n\tnoio_flag = memalloc_noio_save();\n\tcon->v2.hmac_tfm = crypto_alloc_shash(\"hmac(sha256)\", 0, 0);\n\tmemalloc_noio_restore(noio_flag);\n\tif (IS_ERR(con->v2.hmac_tfm)) {\n\t\tret = PTR_ERR(con->v2.hmac_tfm);\n\t\tcon->v2.hmac_tfm = NULL;\n\t\tpr_err(\"failed to allocate hmac tfm context: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tWARN_ON((unsigned long)session_key &\n\t\tcrypto_shash_alignmask(con->v2.hmac_tfm));\n\tret = crypto_shash_setkey(con->v2.hmac_tfm, session_key,\n\t\t\t\t  session_key_len);\n\tif (ret) {\n\t\tpr_err(\"failed to set hmac key: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (con->v2.con_mode == CEPH_CON_MODE_CRC) {\n\t\tWARN_ON(con_secret_len);\n\t\treturn 0;  /* auth_x, plain mode */\n\t}\n\n\tif (con_secret_len < CEPH_GCM_KEY_LEN + 2 * CEPH_GCM_IV_LEN) {\n\t\tpr_err(\"con_secret too small %d\\n\", con_secret_len);\n\t\treturn -EINVAL;\n\t}\n\n\tnoio_flag = memalloc_noio_save();\n\tcon->v2.gcm_tfm = crypto_alloc_aead(\"gcm(aes)\", 0, 0);\n\tmemalloc_noio_restore(noio_flag);\n\tif (IS_ERR(con->v2.gcm_tfm)) {\n\t\tret = PTR_ERR(con->v2.gcm_tfm);\n\t\tcon->v2.gcm_tfm = NULL;\n\t\tpr_err(\"failed to allocate gcm tfm context: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tWARN_ON((unsigned long)con_secret &\n\t\tcrypto_aead_alignmask(con->v2.gcm_tfm));\n\tret = crypto_aead_setkey(con->v2.gcm_tfm, con_secret, CEPH_GCM_KEY_LEN);\n\tif (ret) {\n\t\tpr_err(\"failed to set gcm key: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tWARN_ON(crypto_aead_ivsize(con->v2.gcm_tfm) != CEPH_GCM_IV_LEN);\n\tret = crypto_aead_setauthsize(con->v2.gcm_tfm, CEPH_GCM_TAG_LEN);\n\tif (ret) {\n\t\tpr_err(\"failed to set gcm tag size: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcon->v2.gcm_req = aead_request_alloc(con->v2.gcm_tfm, GFP_NOIO);\n\tif (!con->v2.gcm_req) {\n\t\tpr_err(\"failed to allocate gcm request\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcrypto_init_wait(&con->v2.gcm_wait);\n\taead_request_set_callback(con->v2.gcm_req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t  crypto_req_done, &con->v2.gcm_wait);\n\n\tmemcpy(&con->v2.in_gcm_nonce, con_secret + CEPH_GCM_KEY_LEN,\n\t       CEPH_GCM_IV_LEN);\n\tmemcpy(&con->v2.out_gcm_nonce,\n\t       con_secret + CEPH_GCM_KEY_LEN + CEPH_GCM_IV_LEN,\n\t       CEPH_GCM_IV_LEN);\n\treturn 0;  /* auth_x, secure mode */\n}\n\nstatic int hmac_sha256(struct ceph_connection *con, const struct kvec *kvecs,\n\t\t       int kvec_cnt, u8 *hmac)\n{\n\tSHASH_DESC_ON_STACK(desc, con->v2.hmac_tfm);  /* tfm arg is ignored */\n\tint ret;\n\tint i;\n\n\tdout(\"%s con %p hmac_tfm %p kvec_cnt %d\\n\", __func__, con,\n\t     con->v2.hmac_tfm, kvec_cnt);\n\n\tif (!con->v2.hmac_tfm) {\n\t\tmemset(hmac, 0, SHA256_DIGEST_SIZE);\n\t\treturn 0;  /* auth_none */\n\t}\n\n\tdesc->tfm = con->v2.hmac_tfm;\n\tret = crypto_shash_init(desc);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < kvec_cnt; i++) {\n\t\tWARN_ON((unsigned long)kvecs[i].iov_base &\n\t\t\tcrypto_shash_alignmask(con->v2.hmac_tfm));\n\t\tret = crypto_shash_update(desc, kvecs[i].iov_base,\n\t\t\t\t\t  kvecs[i].iov_len);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = crypto_shash_final(desc, hmac);\n\nout:\n\tshash_desc_zero(desc);\n\treturn ret;  /* auth_x, both plain and secure modes */\n}\n\nstatic void gcm_inc_nonce(struct ceph_gcm_nonce *nonce)\n{\n\tu64 counter;\n\n\tcounter = le64_to_cpu(nonce->counter);\n\tnonce->counter = cpu_to_le64(counter + 1);\n}\n\nstatic int gcm_crypt(struct ceph_connection *con, bool encrypt,\n\t\t     struct scatterlist *src, struct scatterlist *dst,\n\t\t     int src_len)\n{\n\tstruct ceph_gcm_nonce *nonce;\n\tint ret;\n\n\tnonce = encrypt ? &con->v2.out_gcm_nonce : &con->v2.in_gcm_nonce;\n\n\taead_request_set_ad(con->v2.gcm_req, 0);  /* no AAD */\n\taead_request_set_crypt(con->v2.gcm_req, src, dst, src_len, (u8 *)nonce);\n\tret = crypto_wait_req(encrypt ? crypto_aead_encrypt(con->v2.gcm_req) :\n\t\t\t\t\tcrypto_aead_decrypt(con->v2.gcm_req),\n\t\t\t      &con->v2.gcm_wait);\n\tif (ret)\n\t\treturn ret;\n\n\tgcm_inc_nonce(nonce);\n\treturn 0;\n}\n\nstatic void get_bvec_at(struct ceph_msg_data_cursor *cursor,\n\t\t\tstruct bio_vec *bv)\n{\n\tstruct page *page;\n\tsize_t off, len;\n\n\tWARN_ON(!cursor->total_resid);\n\n\t/* skip zero-length data items */\n\twhile (!cursor->resid)\n\t\tceph_msg_data_advance(cursor, 0);\n\n\t/* get a piece of data, cursor isn't advanced */\n\tpage = ceph_msg_data_next(cursor, &off, &len);\n\tbvec_set_page(bv, page, len, off);\n}\n\nstatic int calc_sg_cnt(void *buf, int buf_len)\n{\n\tint sg_cnt;\n\n\tif (!buf_len)\n\t\treturn 0;\n\n\tsg_cnt = need_padding(buf_len) ? 1 : 0;\n\tif (is_vmalloc_addr(buf)) {\n\t\tWARN_ON(offset_in_page(buf));\n\t\tsg_cnt += PAGE_ALIGN(buf_len) >> PAGE_SHIFT;\n\t} else {\n\t\tsg_cnt++;\n\t}\n\n\treturn sg_cnt;\n}\n\nstatic int calc_sg_cnt_cursor(struct ceph_msg_data_cursor *cursor)\n{\n\tint data_len = cursor->total_resid;\n\tstruct bio_vec bv;\n\tint sg_cnt;\n\n\tif (!data_len)\n\t\treturn 0;\n\n\tsg_cnt = need_padding(data_len) ? 1 : 0;\n\tdo {\n\t\tget_bvec_at(cursor, &bv);\n\t\tsg_cnt++;\n\n\t\tceph_msg_data_advance(cursor, bv.bv_len);\n\t} while (cursor->total_resid);\n\n\treturn sg_cnt;\n}\n\nstatic void init_sgs(struct scatterlist **sg, void *buf, int buf_len, u8 *pad)\n{\n\tvoid *end = buf + buf_len;\n\tstruct page *page;\n\tint len;\n\tvoid *p;\n\n\tif (!buf_len)\n\t\treturn;\n\n\tif (is_vmalloc_addr(buf)) {\n\t\tp = buf;\n\t\tdo {\n\t\t\tpage = vmalloc_to_page(p);\n\t\t\tlen = min_t(int, end - p, PAGE_SIZE);\n\t\t\tWARN_ON(!page || !len || offset_in_page(p));\n\t\t\tsg_set_page(*sg, page, len, 0);\n\t\t\t*sg = sg_next(*sg);\n\t\t\tp += len;\n\t\t} while (p != end);\n\t} else {\n\t\tsg_set_buf(*sg, buf, buf_len);\n\t\t*sg = sg_next(*sg);\n\t}\n\n\tif (need_padding(buf_len)) {\n\t\tsg_set_buf(*sg, pad, padding_len(buf_len));\n\t\t*sg = sg_next(*sg);\n\t}\n}\n\nstatic void init_sgs_cursor(struct scatterlist **sg,\n\t\t\t    struct ceph_msg_data_cursor *cursor, u8 *pad)\n{\n\tint data_len = cursor->total_resid;\n\tstruct bio_vec bv;\n\n\tif (!data_len)\n\t\treturn;\n\n\tdo {\n\t\tget_bvec_at(cursor, &bv);\n\t\tsg_set_page(*sg, bv.bv_page, bv.bv_len, bv.bv_offset);\n\t\t*sg = sg_next(*sg);\n\n\t\tceph_msg_data_advance(cursor, bv.bv_len);\n\t} while (cursor->total_resid);\n\n\tif (need_padding(data_len)) {\n\t\tsg_set_buf(*sg, pad, padding_len(data_len));\n\t\t*sg = sg_next(*sg);\n\t}\n}\n\nstatic int setup_message_sgs(struct sg_table *sgt, struct ceph_msg *msg,\n\t\t\t     u8 *front_pad, u8 *middle_pad, u8 *data_pad,\n\t\t\t     void *epilogue, bool add_tag)\n{\n\tstruct ceph_msg_data_cursor cursor;\n\tstruct scatterlist *cur_sg;\n\tint sg_cnt;\n\tint ret;\n\n\tif (!front_len(msg) && !middle_len(msg) && !data_len(msg))\n\t\treturn 0;\n\n\tsg_cnt = 1;  /* epilogue + [auth tag] */\n\tif (front_len(msg))\n\t\tsg_cnt += calc_sg_cnt(msg->front.iov_base,\n\t\t\t\t      front_len(msg));\n\tif (middle_len(msg))\n\t\tsg_cnt += calc_sg_cnt(msg->middle->vec.iov_base,\n\t\t\t\t      middle_len(msg));\n\tif (data_len(msg)) {\n\t\tceph_msg_data_cursor_init(&cursor, msg, data_len(msg));\n\t\tsg_cnt += calc_sg_cnt_cursor(&cursor);\n\t}\n\n\tret = sg_alloc_table(sgt, sg_cnt, GFP_NOIO);\n\tif (ret)\n\t\treturn ret;\n\n\tcur_sg = sgt->sgl;\n\tif (front_len(msg))\n\t\tinit_sgs(&cur_sg, msg->front.iov_base, front_len(msg),\n\t\t\t front_pad);\n\tif (middle_len(msg))\n\t\tinit_sgs(&cur_sg, msg->middle->vec.iov_base, middle_len(msg),\n\t\t\t middle_pad);\n\tif (data_len(msg)) {\n\t\tceph_msg_data_cursor_init(&cursor, msg, data_len(msg));\n\t\tinit_sgs_cursor(&cur_sg, &cursor, data_pad);\n\t}\n\n\tWARN_ON(!sg_is_last(cur_sg));\n\tsg_set_buf(cur_sg, epilogue,\n\t\t   CEPH_GCM_BLOCK_LEN + (add_tag ? CEPH_GCM_TAG_LEN : 0));\n\treturn 0;\n}\n\nstatic int decrypt_preamble(struct ceph_connection *con)\n{\n\tstruct scatterlist sg;\n\n\tsg_init_one(&sg, con->v2.in_buf, CEPH_PREAMBLE_SECURE_LEN);\n\treturn gcm_crypt(con, false, &sg, &sg, CEPH_PREAMBLE_SECURE_LEN);\n}\n\nstatic int decrypt_control_remainder(struct ceph_connection *con)\n{\n\tint ctrl_len = con->v2.in_desc.fd_lens[0];\n\tint rem_len = ctrl_len - CEPH_PREAMBLE_INLINE_LEN;\n\tint pt_len = padding_len(rem_len) + CEPH_GCM_TAG_LEN;\n\tstruct scatterlist sgs[2];\n\n\tWARN_ON(con->v2.in_kvecs[0].iov_len != rem_len);\n\tWARN_ON(con->v2.in_kvecs[1].iov_len != pt_len);\n\n\tsg_init_table(sgs, 2);\n\tsg_set_buf(&sgs[0], con->v2.in_kvecs[0].iov_base, rem_len);\n\tsg_set_buf(&sgs[1], con->v2.in_buf, pt_len);\n\n\treturn gcm_crypt(con, false, sgs, sgs,\n\t\t\t padded_len(rem_len) + CEPH_GCM_TAG_LEN);\n}\n\nstatic int decrypt_tail(struct ceph_connection *con)\n{\n\tstruct sg_table enc_sgt = {};\n\tstruct sg_table sgt = {};\n\tint tail_len;\n\tint ret;\n\n\ttail_len = tail_onwire_len(con->in_msg, true);\n\tret = sg_alloc_table_from_pages(&enc_sgt, con->v2.in_enc_pages,\n\t\t\t\t\tcon->v2.in_enc_page_cnt, 0, tail_len,\n\t\t\t\t\tGFP_NOIO);\n\tif (ret)\n\t\tgoto out;\n\n\tret = setup_message_sgs(&sgt, con->in_msg, FRONT_PAD(con->v2.in_buf),\n\t\t\tMIDDLE_PAD(con->v2.in_buf), DATA_PAD(con->v2.in_buf),\n\t\t\tcon->v2.in_buf, true);\n\tif (ret)\n\t\tgoto out;\n\n\tdout(\"%s con %p msg %p enc_page_cnt %d sg_cnt %d\\n\", __func__, con,\n\t     con->in_msg, con->v2.in_enc_page_cnt, sgt.orig_nents);\n\tret = gcm_crypt(con, false, enc_sgt.sgl, sgt.sgl, tail_len);\n\tif (ret)\n\t\tgoto out;\n\n\tWARN_ON(!con->v2.in_enc_page_cnt);\n\tceph_release_page_vector(con->v2.in_enc_pages,\n\t\t\t\t con->v2.in_enc_page_cnt);\n\tcon->v2.in_enc_pages = NULL;\n\tcon->v2.in_enc_page_cnt = 0;\n\nout:\n\tsg_free_table(&sgt);\n\tsg_free_table(&enc_sgt);\n\treturn ret;\n}\n\nstatic int prepare_banner(struct ceph_connection *con)\n{\n\tint buf_len = CEPH_BANNER_V2_LEN + 2 + 8 + 8;\n\tvoid *buf, *p;\n\n\tbuf = alloc_conn_buf(con, buf_len);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tp = buf;\n\tceph_encode_copy(&p, CEPH_BANNER_V2, CEPH_BANNER_V2_LEN);\n\tceph_encode_16(&p, sizeof(u64) + sizeof(u64));\n\tceph_encode_64(&p, CEPH_MSGR2_SUPPORTED_FEATURES);\n\tceph_encode_64(&p, CEPH_MSGR2_REQUIRED_FEATURES);\n\tWARN_ON(p != buf + buf_len);\n\n\tadd_out_kvec(con, buf, buf_len);\n\tadd_out_sign_kvec(con, buf, buf_len);\n\tceph_con_flag_set(con, CEPH_CON_F_WRITE_PENDING);\n\treturn 0;\n}\n\n/*\n * base:\n *   preamble\n *   control body (ctrl_len bytes)\n *   space for control crc\n *\n * extdata (optional):\n *   control body (extdata_len bytes)\n *\n * Compute control crc and gather base and extdata into:\n *\n *   preamble\n *   control body (ctrl_len + extdata_len bytes)\n *   control crc\n *\n * Preamble should already be encoded at the start of base.\n */\nstatic void prepare_head_plain(struct ceph_connection *con, void *base,\n\t\t\t       int ctrl_len, void *extdata, int extdata_len,\n\t\t\t       bool to_be_signed)\n{\n\tint base_len = CEPH_PREAMBLE_LEN + ctrl_len + CEPH_CRC_LEN;\n\tvoid *crcp = base + base_len - CEPH_CRC_LEN;\n\tu32 crc;\n\n\tcrc = crc32c(-1, CTRL_BODY(base), ctrl_len);\n\tif (extdata_len)\n\t\tcrc = crc32c(crc, extdata, extdata_len);\n\tput_unaligned_le32(crc, crcp);\n\n\tif (!extdata_len) {\n\t\tadd_out_kvec(con, base, base_len);\n\t\tif (to_be_signed)\n\t\t\tadd_out_sign_kvec(con, base, base_len);\n\t\treturn;\n\t}\n\n\tadd_out_kvec(con, base, crcp - base);\n\tadd_out_kvec(con, extdata, extdata_len);\n\tadd_out_kvec(con, crcp, CEPH_CRC_LEN);\n\tif (to_be_signed) {\n\t\tadd_out_sign_kvec(con, base, crcp - base);\n\t\tadd_out_sign_kvec(con, extdata, extdata_len);\n\t\tadd_out_sign_kvec(con, crcp, CEPH_CRC_LEN);\n\t}\n}\n\nstatic int prepare_head_secure_small(struct ceph_connection *con,\n\t\t\t\t     void *base, int ctrl_len)\n{\n\tstruct scatterlist sg;\n\tint ret;\n\n\t/* inline buffer padding? */\n\tif (ctrl_len < CEPH_PREAMBLE_INLINE_LEN)\n\t\tmemset(CTRL_BODY(base) + ctrl_len, 0,\n\t\t       CEPH_PREAMBLE_INLINE_LEN - ctrl_len);\n\n\tsg_init_one(&sg, base, CEPH_PREAMBLE_SECURE_LEN);\n\tret = gcm_crypt(con, true, &sg, &sg,\n\t\t\tCEPH_PREAMBLE_SECURE_LEN - CEPH_GCM_TAG_LEN);\n\tif (ret)\n\t\treturn ret;\n\n\tadd_out_kvec(con, base, CEPH_PREAMBLE_SECURE_LEN);\n\treturn 0;\n}\n\n/*\n * base:\n *   preamble\n *   control body (ctrl_len bytes)\n *   space for padding, if needed\n *   space for control remainder auth tag\n *   space for preamble auth tag\n *\n * Encrypt preamble and the inline portion, then encrypt the remainder\n * and gather into:\n *\n *   preamble\n *   control body (48 bytes)\n *   preamble auth tag\n *   control body (ctrl_len - 48 bytes)\n *   zero padding, if needed\n *   control remainder auth tag\n *\n * Preamble should already be encoded at the start of base.\n */\nstatic int prepare_head_secure_big(struct ceph_connection *con,\n\t\t\t\t   void *base, int ctrl_len)\n{\n\tint rem_len = ctrl_len - CEPH_PREAMBLE_INLINE_LEN;\n\tvoid *rem = CTRL_BODY(base) + CEPH_PREAMBLE_INLINE_LEN;\n\tvoid *rem_tag = rem + padded_len(rem_len);\n\tvoid *pmbl_tag = rem_tag + CEPH_GCM_TAG_LEN;\n\tstruct scatterlist sgs[2];\n\tint ret;\n\n\tsg_init_table(sgs, 2);\n\tsg_set_buf(&sgs[0], base, rem - base);\n\tsg_set_buf(&sgs[1], pmbl_tag, CEPH_GCM_TAG_LEN);\n\tret = gcm_crypt(con, true, sgs, sgs, rem - base);\n\tif (ret)\n\t\treturn ret;\n\n\t/* control remainder padding? */\n\tif (need_padding(rem_len))\n\t\tmemset(rem + rem_len, 0, padding_len(rem_len));\n\n\tsg_init_one(&sgs[0], rem, pmbl_tag - rem);\n\tret = gcm_crypt(con, true, sgs, sgs, rem_tag - rem);\n\tif (ret)\n\t\treturn ret;\n\n\tadd_out_kvec(con, base, rem - base);\n\tadd_out_kvec(con, pmbl_tag, CEPH_GCM_TAG_LEN);\n\tadd_out_kvec(con, rem, pmbl_tag - rem);\n\treturn 0;\n}\n\nstatic int __prepare_control(struct ceph_connection *con, int tag,\n\t\t\t     void *base, int ctrl_len, void *extdata,\n\t\t\t     int extdata_len, bool to_be_signed)\n{\n\tint total_len = ctrl_len + extdata_len;\n\tstruct ceph_frame_desc desc;\n\tint ret;\n\n\tdout(\"%s con %p tag %d len %d (%d+%d)\\n\", __func__, con, tag,\n\t     total_len, ctrl_len, extdata_len);\n\n\t/* extdata may be vmalloc'ed but not base */\n\tif (WARN_ON(is_vmalloc_addr(base) || !ctrl_len))\n\t\treturn -EINVAL;\n\n\tinit_frame_desc(&desc, tag, &total_len, 1);\n\tencode_preamble(&desc, base);\n\n\tif (con_secure(con)) {\n\t\tif (WARN_ON(extdata_len || to_be_signed))\n\t\t\treturn -EINVAL;\n\n\t\tif (ctrl_len <= CEPH_PREAMBLE_INLINE_LEN)\n\t\t\t/* fully inlined, inline buffer may need padding */\n\t\t\tret = prepare_head_secure_small(con, base, ctrl_len);\n\t\telse\n\t\t\t/* partially inlined, inline buffer is full */\n\t\t\tret = prepare_head_secure_big(con, base, ctrl_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tprepare_head_plain(con, base, ctrl_len, extdata, extdata_len,\n\t\t\t\t   to_be_signed);\n\t}\n\n\tceph_con_flag_set(con, CEPH_CON_F_WRITE_PENDING);\n\treturn 0;\n}\n\nstatic int prepare_control(struct ceph_connection *con, int tag,\n\t\t\t   void *base, int ctrl_len)\n{\n\treturn __prepare_control(con, tag, base, ctrl_len, NULL, 0, false);\n}\n\nstatic int prepare_hello(struct ceph_connection *con)\n{\n\tvoid *buf, *p;\n\tint ctrl_len;\n\n\tctrl_len = 1 + ceph_entity_addr_encoding_len(&con->peer_addr);\n\tbuf = alloc_conn_buf(con, head_onwire_len(ctrl_len, false));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tp = CTRL_BODY(buf);\n\tceph_encode_8(&p, CEPH_ENTITY_TYPE_CLIENT);\n\tceph_encode_entity_addr(&p, &con->peer_addr);\n\tWARN_ON(p != CTRL_BODY(buf) + ctrl_len);\n\n\treturn __prepare_control(con, FRAME_TAG_HELLO, buf, ctrl_len,\n\t\t\t\t NULL, 0, true);\n}\n\n/* so that head_onwire_len(AUTH_BUF_LEN, false) is 512 */\n#define AUTH_BUF_LEN\t(512 - CEPH_CRC_LEN - CEPH_PREAMBLE_PLAIN_LEN)\n\nstatic int prepare_auth_request(struct ceph_connection *con)\n{\n\tvoid *authorizer, *authorizer_copy;\n\tint ctrl_len, authorizer_len;\n\tvoid *buf;\n\tint ret;\n\n\tctrl_len = AUTH_BUF_LEN;\n\tbuf = alloc_conn_buf(con, head_onwire_len(ctrl_len, false));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_unlock(&con->mutex);\n\tret = con->ops->get_auth_request(con, CTRL_BODY(buf), &ctrl_len,\n\t\t\t\t\t &authorizer, &authorizer_len);\n\tmutex_lock(&con->mutex);\n\tif (con->state != CEPH_CON_S_V2_HELLO) {\n\t\tdout(\"%s con %p state changed to %d\\n\", __func__, con,\n\t\t     con->state);\n\t\treturn -EAGAIN;\n\t}\n\n\tdout(\"%s con %p get_auth_request ret %d\\n\", __func__, con, ret);\n\tif (ret)\n\t\treturn ret;\n\n\tauthorizer_copy = alloc_conn_buf(con, authorizer_len);\n\tif (!authorizer_copy)\n\t\treturn -ENOMEM;\n\n\tmemcpy(authorizer_copy, authorizer, authorizer_len);\n\n\treturn __prepare_control(con, FRAME_TAG_AUTH_REQUEST, buf, ctrl_len,\n\t\t\t\t authorizer_copy, authorizer_len, true);\n}\n\nstatic int prepare_auth_request_more(struct ceph_connection *con,\n\t\t\t\t     void *reply, int reply_len)\n{\n\tint ctrl_len, authorizer_len;\n\tvoid *authorizer;\n\tvoid *buf;\n\tint ret;\n\n\tctrl_len = AUTH_BUF_LEN;\n\tbuf = alloc_conn_buf(con, head_onwire_len(ctrl_len, false));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_unlock(&con->mutex);\n\tret = con->ops->handle_auth_reply_more(con, reply, reply_len,\n\t\t\t\t\t       CTRL_BODY(buf), &ctrl_len,\n\t\t\t\t\t       &authorizer, &authorizer_len);\n\tmutex_lock(&con->mutex);\n\tif (con->state != CEPH_CON_S_V2_AUTH) {\n\t\tdout(\"%s con %p state changed to %d\\n\", __func__, con,\n\t\t     con->state);\n\t\treturn -EAGAIN;\n\t}\n\n\tdout(\"%s con %p handle_auth_reply_more ret %d\\n\", __func__, con, ret);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __prepare_control(con, FRAME_TAG_AUTH_REQUEST_MORE, buf,\n\t\t\t\t ctrl_len, authorizer, authorizer_len, true);\n}\n\nstatic int prepare_auth_signature(struct ceph_connection *con)\n{\n\tvoid *buf;\n\tint ret;\n\n\tbuf = alloc_conn_buf(con, head_onwire_len(SHA256_DIGEST_SIZE,\n\t\t\t\t\t\t  con_secure(con)));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hmac_sha256(con, con->v2.in_sign_kvecs, con->v2.in_sign_kvec_cnt,\n\t\t\t  CTRL_BODY(buf));\n\tif (ret)\n\t\treturn ret;\n\n\treturn prepare_control(con, FRAME_TAG_AUTH_SIGNATURE, buf,\n\t\t\t       SHA256_DIGEST_SIZE);\n}\n\nstatic int prepare_client_ident(struct ceph_connection *con)\n{\n\tstruct ceph_entity_addr *my_addr = &con->msgr->inst.addr;\n\tstruct ceph_client *client = from_msgr(con->msgr);\n\tu64 global_id = ceph_client_gid(client);\n\tvoid *buf, *p;\n\tint ctrl_len;\n\n\tWARN_ON(con->v2.server_cookie);\n\tWARN_ON(con->v2.connect_seq);\n\tWARN_ON(con->v2.peer_global_seq);\n\n\tif (!con->v2.client_cookie) {\n\t\tdo {\n\t\t\tget_random_bytes(&con->v2.client_cookie,\n\t\t\t\t\t sizeof(con->v2.client_cookie));\n\t\t} while (!con->v2.client_cookie);\n\t\tdout(\"%s con %p generated cookie 0x%llx\\n\", __func__, con,\n\t\t     con->v2.client_cookie);\n\t} else {\n\t\tdout(\"%s con %p cookie already set 0x%llx\\n\", __func__, con,\n\t\t     con->v2.client_cookie);\n\t}\n\n\tdout(\"%s con %p my_addr %s/%u peer_addr %s/%u global_id %llu global_seq %llu features 0x%llx required_features 0x%llx cookie 0x%llx\\n\",\n\t     __func__, con, ceph_pr_addr(my_addr), le32_to_cpu(my_addr->nonce),\n\t     ceph_pr_addr(&con->peer_addr), le32_to_cpu(con->peer_addr.nonce),\n\t     global_id, con->v2.global_seq, client->supported_features,\n\t     client->required_features, con->v2.client_cookie);\n\n\tctrl_len = 1 + 4 + ceph_entity_addr_encoding_len(my_addr) +\n\t\t   ceph_entity_addr_encoding_len(&con->peer_addr) + 6 * 8;\n\tbuf = alloc_conn_buf(con, head_onwire_len(ctrl_len, con_secure(con)));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tp = CTRL_BODY(buf);\n\tceph_encode_8(&p, 2);  /* addrvec marker */\n\tceph_encode_32(&p, 1);  /* addr_cnt */\n\tceph_encode_entity_addr(&p, my_addr);\n\tceph_encode_entity_addr(&p, &con->peer_addr);\n\tceph_encode_64(&p, global_id);\n\tceph_encode_64(&p, con->v2.global_seq);\n\tceph_encode_64(&p, client->supported_features);\n\tceph_encode_64(&p, client->required_features);\n\tceph_encode_64(&p, 0);  /* flags */\n\tceph_encode_64(&p, con->v2.client_cookie);\n\tWARN_ON(p != CTRL_BODY(buf) + ctrl_len);\n\n\treturn prepare_control(con, FRAME_TAG_CLIENT_IDENT, buf, ctrl_len);\n}\n\nstatic int prepare_session_reconnect(struct ceph_connection *con)\n{\n\tstruct ceph_entity_addr *my_addr = &con->msgr->inst.addr;\n\tvoid *buf, *p;\n\tint ctrl_len;\n\n\tWARN_ON(!con->v2.client_cookie);\n\tWARN_ON(!con->v2.server_cookie);\n\tWARN_ON(!con->v2.connect_seq);\n\tWARN_ON(!con->v2.peer_global_seq);\n\n\tdout(\"%s con %p my_addr %s/%u client_cookie 0x%llx server_cookie 0x%llx global_seq %llu connect_seq %llu in_seq %llu\\n\",\n\t     __func__, con, ceph_pr_addr(my_addr), le32_to_cpu(my_addr->nonce),\n\t     con->v2.client_cookie, con->v2.server_cookie, con->v2.global_seq,\n\t     con->v2.connect_seq, con->in_seq);\n\n\tctrl_len = 1 + 4 + ceph_entity_addr_encoding_len(my_addr) + 5 * 8;\n\tbuf = alloc_conn_buf(con, head_onwire_len(ctrl_len, con_secure(con)));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tp = CTRL_BODY(buf);\n\tceph_encode_8(&p, 2);  /* entity_addrvec_t marker */\n\tceph_encode_32(&p, 1);  /* my_addrs len */\n\tceph_encode_entity_addr(&p, my_addr);\n\tceph_encode_64(&p, con->v2.client_cookie);\n\tceph_encode_64(&p, con->v2.server_cookie);\n\tceph_encode_64(&p, con->v2.global_seq);\n\tceph_encode_64(&p, con->v2.connect_seq);\n\tceph_encode_64(&p, con->in_seq);\n\tWARN_ON(p != CTRL_BODY(buf) + ctrl_len);\n\n\treturn prepare_control(con, FRAME_TAG_SESSION_RECONNECT, buf, ctrl_len);\n}\n\nstatic int prepare_keepalive2(struct ceph_connection *con)\n{\n\tstruct ceph_timespec *ts = CTRL_BODY(con->v2.out_buf);\n\tstruct timespec64 now;\n\n\tktime_get_real_ts64(&now);\n\tdout(\"%s con %p timestamp %lld.%09ld\\n\", __func__, con, now.tv_sec,\n\t     now.tv_nsec);\n\n\tceph_encode_timespec64(ts, &now);\n\n\treset_out_kvecs(con);\n\treturn prepare_control(con, FRAME_TAG_KEEPALIVE2, con->v2.out_buf,\n\t\t\t       sizeof(struct ceph_timespec));\n}\n\nstatic int prepare_ack(struct ceph_connection *con)\n{\n\tvoid *p;\n\n\tdout(\"%s con %p in_seq_acked %llu -> %llu\\n\", __func__, con,\n\t     con->in_seq_acked, con->in_seq);\n\tcon->in_seq_acked = con->in_seq;\n\n\tp = CTRL_BODY(con->v2.out_buf);\n\tceph_encode_64(&p, con->in_seq_acked);\n\n\treset_out_kvecs(con);\n\treturn prepare_control(con, FRAME_TAG_ACK, con->v2.out_buf, 8);\n}\n\nstatic void prepare_epilogue_plain(struct ceph_connection *con, bool aborted)\n{\n\tdout(\"%s con %p msg %p aborted %d crcs %u %u %u\\n\", __func__, con,\n\t     con->out_msg, aborted, con->v2.out_epil.front_crc,\n\t     con->v2.out_epil.middle_crc, con->v2.out_epil.data_crc);\n\n\tencode_epilogue_plain(con, aborted);\n\tadd_out_kvec(con, &con->v2.out_epil, CEPH_EPILOGUE_PLAIN_LEN);\n}\n\n/*\n * For \"used\" empty segments, crc is -1.  For unused (trailing)\n * segments, crc is 0.\n */\nstatic void prepare_message_plain(struct ceph_connection *con)\n{\n\tstruct ceph_msg *msg = con->out_msg;\n\n\tprepare_head_plain(con, con->v2.out_buf,\n\t\t\t   sizeof(struct ceph_msg_header2), NULL, 0, false);\n\n\tif (!front_len(msg) && !middle_len(msg)) {\n\t\tif (!data_len(msg)) {\n\t\t\t/*\n\t\t\t * Empty message: once the head is written,\n\t\t\t * we are done -- there is no epilogue.\n\t\t\t */\n\t\t\tcon->v2.out_state = OUT_S_FINISH_MESSAGE;\n\t\t\treturn;\n\t\t}\n\n\t\tcon->v2.out_epil.front_crc = -1;\n\t\tcon->v2.out_epil.middle_crc = -1;\n\t\tcon->v2.out_state = OUT_S_QUEUE_DATA;\n\t\treturn;\n\t}\n\n\tif (front_len(msg)) {\n\t\tcon->v2.out_epil.front_crc = crc32c(-1, msg->front.iov_base,\n\t\t\t\t\t\t    front_len(msg));\n\t\tadd_out_kvec(con, msg->front.iov_base, front_len(msg));\n\t} else {\n\t\t/* middle (at least) is there, checked above */\n\t\tcon->v2.out_epil.front_crc = -1;\n\t}\n\n\tif (middle_len(msg)) {\n\t\tcon->v2.out_epil.middle_crc =\n\t\t\tcrc32c(-1, msg->middle->vec.iov_base, middle_len(msg));\n\t\tadd_out_kvec(con, msg->middle->vec.iov_base, middle_len(msg));\n\t} else {\n\t\tcon->v2.out_epil.middle_crc = data_len(msg) ? -1 : 0;\n\t}\n\n\tif (data_len(msg)) {\n\t\tcon->v2.out_state = OUT_S_QUEUE_DATA;\n\t} else {\n\t\tcon->v2.out_epil.data_crc = 0;\n\t\tprepare_epilogue_plain(con, false);\n\t\tcon->v2.out_state = OUT_S_FINISH_MESSAGE;\n\t}\n}\n\n/*\n * Unfortunately the kernel crypto API doesn't support streaming\n * (piecewise) operation for AEAD algorithms, so we can't get away\n * with a fixed size buffer and a couple sgs.  Instead, we have to\n * allocate pages for the entire tail of the message (currently up\n * to ~32M) and two sgs arrays (up to ~256K each)...\n */\nstatic int prepare_message_secure(struct ceph_connection *con)\n{\n\tvoid *zerop = page_address(ceph_zero_page);\n\tstruct sg_table enc_sgt = {};\n\tstruct sg_table sgt = {};\n\tstruct page **enc_pages;\n\tint enc_page_cnt;\n\tint tail_len;\n\tint ret;\n\n\tret = prepare_head_secure_small(con, con->v2.out_buf,\n\t\t\t\t\tsizeof(struct ceph_msg_header2));\n\tif (ret)\n\t\treturn ret;\n\n\ttail_len = tail_onwire_len(con->out_msg, true);\n\tif (!tail_len) {\n\t\t/*\n\t\t * Empty message: once the head is written,\n\t\t * we are done -- there is no epilogue.\n\t\t */\n\t\tcon->v2.out_state = OUT_S_FINISH_MESSAGE;\n\t\treturn 0;\n\t}\n\n\tencode_epilogue_secure(con, false);\n\tret = setup_message_sgs(&sgt, con->out_msg, zerop, zerop, zerop,\n\t\t\t\t&con->v2.out_epil, false);\n\tif (ret)\n\t\tgoto out;\n\n\tenc_page_cnt = calc_pages_for(0, tail_len);\n\tenc_pages = ceph_alloc_page_vector(enc_page_cnt, GFP_NOIO);\n\tif (IS_ERR(enc_pages)) {\n\t\tret = PTR_ERR(enc_pages);\n\t\tgoto out;\n\t}\n\n\tWARN_ON(con->v2.out_enc_pages || con->v2.out_enc_page_cnt);\n\tcon->v2.out_enc_pages = enc_pages;\n\tcon->v2.out_enc_page_cnt = enc_page_cnt;\n\tcon->v2.out_enc_resid = tail_len;\n\tcon->v2.out_enc_i = 0;\n\n\tret = sg_alloc_table_from_pages(&enc_sgt, enc_pages, enc_page_cnt,\n\t\t\t\t\t0, tail_len, GFP_NOIO);\n\tif (ret)\n\t\tgoto out;\n\n\tret = gcm_crypt(con, true, sgt.sgl, enc_sgt.sgl,\n\t\t\ttail_len - CEPH_GCM_TAG_LEN);\n\tif (ret)\n\t\tgoto out;\n\n\tdout(\"%s con %p msg %p sg_cnt %d enc_page_cnt %d\\n\", __func__, con,\n\t     con->out_msg, sgt.orig_nents, enc_page_cnt);\n\tcon->v2.out_state = OUT_S_QUEUE_ENC_PAGE;\n\nout:\n\tsg_free_table(&sgt);\n\tsg_free_table(&enc_sgt);\n\treturn ret;\n}\n\nstatic int prepare_message(struct ceph_connection *con)\n{\n\tint lens[] = {\n\t\tsizeof(struct ceph_msg_header2),\n\t\tfront_len(con->out_msg),\n\t\tmiddle_len(con->out_msg),\n\t\tdata_len(con->out_msg)\n\t};\n\tstruct ceph_frame_desc desc;\n\tint ret;\n\n\tdout(\"%s con %p msg %p logical %d+%d+%d+%d\\n\", __func__, con,\n\t     con->out_msg, lens[0], lens[1], lens[2], lens[3]);\n\n\tif (con->in_seq > con->in_seq_acked) {\n\t\tdout(\"%s con %p in_seq_acked %llu -> %llu\\n\", __func__, con,\n\t\t     con->in_seq_acked, con->in_seq);\n\t\tcon->in_seq_acked = con->in_seq;\n\t}\n\n\treset_out_kvecs(con);\n\tinit_frame_desc(&desc, FRAME_TAG_MESSAGE, lens, 4);\n\tencode_preamble(&desc, con->v2.out_buf);\n\tfill_header2(CTRL_BODY(con->v2.out_buf), &con->out_msg->hdr,\n\t\t     con->in_seq_acked);\n\n\tif (con_secure(con)) {\n\t\tret = prepare_message_secure(con);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tprepare_message_plain(con);\n\t}\n\n\tceph_con_flag_set(con, CEPH_CON_F_WRITE_PENDING);\n\treturn 0;\n}\n\nstatic int prepare_read_banner_prefix(struct ceph_connection *con)\n{\n\tvoid *buf;\n\n\tbuf = alloc_conn_buf(con, CEPH_BANNER_V2_PREFIX_LEN);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\treset_in_kvecs(con);\n\tadd_in_kvec(con, buf, CEPH_BANNER_V2_PREFIX_LEN);\n\tadd_in_sign_kvec(con, buf, CEPH_BANNER_V2_PREFIX_LEN);\n\tcon->state = CEPH_CON_S_V2_BANNER_PREFIX;\n\treturn 0;\n}\n\nstatic int prepare_read_banner_payload(struct ceph_connection *con,\n\t\t\t\t       int payload_len)\n{\n\tvoid *buf;\n\n\tbuf = alloc_conn_buf(con, payload_len);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\treset_in_kvecs(con);\n\tadd_in_kvec(con, buf, payload_len);\n\tadd_in_sign_kvec(con, buf, payload_len);\n\tcon->state = CEPH_CON_S_V2_BANNER_PAYLOAD;\n\treturn 0;\n}\n\nstatic void prepare_read_preamble(struct ceph_connection *con)\n{\n\treset_in_kvecs(con);\n\tadd_in_kvec(con, con->v2.in_buf,\n\t\t    con_secure(con) ? CEPH_PREAMBLE_SECURE_LEN :\n\t\t\t\t      CEPH_PREAMBLE_PLAIN_LEN);\n\tcon->v2.in_state = IN_S_HANDLE_PREAMBLE;\n}\n\nstatic int prepare_read_control(struct ceph_connection *con)\n{\n\tint ctrl_len = con->v2.in_desc.fd_lens[0];\n\tint head_len;\n\tvoid *buf;\n\n\treset_in_kvecs(con);\n\tif (con->state == CEPH_CON_S_V2_HELLO ||\n\t    con->state == CEPH_CON_S_V2_AUTH) {\n\t\thead_len = head_onwire_len(ctrl_len, false);\n\t\tbuf = alloc_conn_buf(con, head_len);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\t/* preserve preamble */\n\t\tmemcpy(buf, con->v2.in_buf, CEPH_PREAMBLE_LEN);\n\n\t\tadd_in_kvec(con, CTRL_BODY(buf), ctrl_len);\n\t\tadd_in_kvec(con, CTRL_BODY(buf) + ctrl_len, CEPH_CRC_LEN);\n\t\tadd_in_sign_kvec(con, buf, head_len);\n\t} else {\n\t\tif (ctrl_len > CEPH_PREAMBLE_INLINE_LEN) {\n\t\t\tbuf = alloc_conn_buf(con, ctrl_len);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tadd_in_kvec(con, buf, ctrl_len);\n\t\t} else {\n\t\t\tadd_in_kvec(con, CTRL_BODY(con->v2.in_buf), ctrl_len);\n\t\t}\n\t\tadd_in_kvec(con, con->v2.in_buf, CEPH_CRC_LEN);\n\t}\n\tcon->v2.in_state = IN_S_HANDLE_CONTROL;\n\treturn 0;\n}\n\nstatic int prepare_read_control_remainder(struct ceph_connection *con)\n{\n\tint ctrl_len = con->v2.in_desc.fd_lens[0];\n\tint rem_len = ctrl_len - CEPH_PREAMBLE_INLINE_LEN;\n\tvoid *buf;\n\n\tbuf = alloc_conn_buf(con, ctrl_len);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, CTRL_BODY(con->v2.in_buf), CEPH_PREAMBLE_INLINE_LEN);\n\n\treset_in_kvecs(con);\n\tadd_in_kvec(con, buf + CEPH_PREAMBLE_INLINE_LEN, rem_len);\n\tadd_in_kvec(con, con->v2.in_buf,\n\t\t    padding_len(rem_len) + CEPH_GCM_TAG_LEN);\n\tcon->v2.in_state = IN_S_HANDLE_CONTROL_REMAINDER;\n\treturn 0;\n}\n\nstatic int prepare_read_data(struct ceph_connection *con)\n{\n\tstruct bio_vec bv;\n\n\tcon->in_data_crc = -1;\n\tceph_msg_data_cursor_init(&con->v2.in_cursor, con->in_msg,\n\t\t\t\t  data_len(con->in_msg));\n\n\tget_bvec_at(&con->v2.in_cursor, &bv);\n\tif (ceph_test_opt(from_msgr(con->msgr), RXBOUNCE)) {\n\t\tif (unlikely(!con->bounce_page)) {\n\t\t\tcon->bounce_page = alloc_page(GFP_NOIO);\n\t\t\tif (!con->bounce_page) {\n\t\t\t\tpr_err(\"failed to allocate bounce page\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tbv.bv_page = con->bounce_page;\n\t\tbv.bv_offset = 0;\n\t}\n\tset_in_bvec(con, &bv);\n\tcon->v2.in_state = IN_S_PREPARE_READ_DATA_CONT;\n\treturn 0;\n}\n\nstatic void prepare_read_data_cont(struct ceph_connection *con)\n{\n\tstruct bio_vec bv;\n\n\tif (ceph_test_opt(from_msgr(con->msgr), RXBOUNCE)) {\n\t\tcon->in_data_crc = crc32c(con->in_data_crc,\n\t\t\t\t\t  page_address(con->bounce_page),\n\t\t\t\t\t  con->v2.in_bvec.bv_len);\n\n\t\tget_bvec_at(&con->v2.in_cursor, &bv);\n\t\tmemcpy_to_page(bv.bv_page, bv.bv_offset,\n\t\t\t       page_address(con->bounce_page),\n\t\t\t       con->v2.in_bvec.bv_len);\n\t} else {\n\t\tcon->in_data_crc = ceph_crc32c_page(con->in_data_crc,\n\t\t\t\t\t\t    con->v2.in_bvec.bv_page,\n\t\t\t\t\t\t    con->v2.in_bvec.bv_offset,\n\t\t\t\t\t\t    con->v2.in_bvec.bv_len);\n\t}\n\n\tceph_msg_data_advance(&con->v2.in_cursor, con->v2.in_bvec.bv_len);\n\tif (con->v2.in_cursor.total_resid) {\n\t\tget_bvec_at(&con->v2.in_cursor, &bv);\n\t\tif (ceph_test_opt(from_msgr(con->msgr), RXBOUNCE)) {\n\t\t\tbv.bv_page = con->bounce_page;\n\t\t\tbv.bv_offset = 0;\n\t\t}\n\t\tset_in_bvec(con, &bv);\n\t\tWARN_ON(con->v2.in_state != IN_S_PREPARE_READ_DATA_CONT);\n\t\treturn;\n\t}\n\n\t/*\n\t * We've read all data.  Prepare to read epilogue.\n\t */\n\treset_in_kvecs(con);\n\tadd_in_kvec(con, con->v2.in_buf, CEPH_EPILOGUE_PLAIN_LEN);\n\tcon->v2.in_state = IN_S_HANDLE_EPILOGUE;\n}\n\nstatic int prepare_read_tail_plain(struct ceph_connection *con)\n{\n\tstruct ceph_msg *msg = con->in_msg;\n\n\tif (!front_len(msg) && !middle_len(msg)) {\n\t\tWARN_ON(!data_len(msg));\n\t\treturn prepare_read_data(con);\n\t}\n\n\treset_in_kvecs(con);\n\tif (front_len(msg)) {\n\t\tadd_in_kvec(con, msg->front.iov_base, front_len(msg));\n\t\tWARN_ON(msg->front.iov_len != front_len(msg));\n\t}\n\tif (middle_len(msg)) {\n\t\tadd_in_kvec(con, msg->middle->vec.iov_base, middle_len(msg));\n\t\tWARN_ON(msg->middle->vec.iov_len != middle_len(msg));\n\t}\n\n\tif (data_len(msg)) {\n\t\tcon->v2.in_state = IN_S_PREPARE_READ_DATA;\n\t} else {\n\t\tadd_in_kvec(con, con->v2.in_buf, CEPH_EPILOGUE_PLAIN_LEN);\n\t\tcon->v2.in_state = IN_S_HANDLE_EPILOGUE;\n\t}\n\treturn 0;\n}\n\nstatic void prepare_read_enc_page(struct ceph_connection *con)\n{\n\tstruct bio_vec bv;\n\n\tdout(\"%s con %p i %d resid %d\\n\", __func__, con, con->v2.in_enc_i,\n\t     con->v2.in_enc_resid);\n\tWARN_ON(!con->v2.in_enc_resid);\n\n\tbvec_set_page(&bv, con->v2.in_enc_pages[con->v2.in_enc_i],\n\t\t      min(con->v2.in_enc_resid, (int)PAGE_SIZE), 0);\n\n\tset_in_bvec(con, &bv);\n\tcon->v2.in_enc_i++;\n\tcon->v2.in_enc_resid -= bv.bv_len;\n\n\tif (con->v2.in_enc_resid) {\n\t\tcon->v2.in_state = IN_S_PREPARE_READ_ENC_PAGE;\n\t\treturn;\n\t}\n\n\t/*\n\t * We are set to read the last piece of ciphertext (ending\n\t * with epilogue) + auth tag.\n\t */\n\tWARN_ON(con->v2.in_enc_i != con->v2.in_enc_page_cnt);\n\tcon->v2.in_state = IN_S_HANDLE_EPILOGUE;\n}\n\nstatic int prepare_read_tail_secure(struct ceph_connection *con)\n{\n\tstruct page **enc_pages;\n\tint enc_page_cnt;\n\tint tail_len;\n\n\ttail_len = tail_onwire_len(con->in_msg, true);\n\tWARN_ON(!tail_len);\n\n\tenc_page_cnt = calc_pages_for(0, tail_len);\n\tenc_pages = ceph_alloc_page_vector(enc_page_cnt, GFP_NOIO);\n\tif (IS_ERR(enc_pages))\n\t\treturn PTR_ERR(enc_pages);\n\n\tWARN_ON(con->v2.in_enc_pages || con->v2.in_enc_page_cnt);\n\tcon->v2.in_enc_pages = enc_pages;\n\tcon->v2.in_enc_page_cnt = enc_page_cnt;\n\tcon->v2.in_enc_resid = tail_len;\n\tcon->v2.in_enc_i = 0;\n\n\tprepare_read_enc_page(con);\n\treturn 0;\n}\n\nstatic void __finish_skip(struct ceph_connection *con)\n{\n\tcon->in_seq++;\n\tprepare_read_preamble(con);\n}\n\nstatic void prepare_skip_message(struct ceph_connection *con)\n{\n\tstruct ceph_frame_desc *desc = &con->v2.in_desc;\n\tint tail_len;\n\n\tdout(\"%s con %p %d+%d+%d\\n\", __func__, con, desc->fd_lens[1],\n\t     desc->fd_lens[2], desc->fd_lens[3]);\n\n\ttail_len = __tail_onwire_len(desc->fd_lens[1], desc->fd_lens[2],\n\t\t\t\t     desc->fd_lens[3], con_secure(con));\n\tif (!tail_len) {\n\t\t__finish_skip(con);\n\t} else {\n\t\tset_in_skip(con, tail_len);\n\t\tcon->v2.in_state = IN_S_FINISH_SKIP;\n\t}\n}\n\nstatic int process_banner_prefix(struct ceph_connection *con)\n{\n\tint payload_len;\n\tvoid *p;\n\n\tWARN_ON(con->v2.in_kvecs[0].iov_len != CEPH_BANNER_V2_PREFIX_LEN);\n\n\tp = con->v2.in_kvecs[0].iov_base;\n\tif (memcmp(p, CEPH_BANNER_V2, CEPH_BANNER_V2_LEN)) {\n\t\tif (!memcmp(p, CEPH_BANNER, CEPH_BANNER_LEN))\n\t\t\tcon->error_msg = \"server is speaking msgr1 protocol\";\n\t\telse\n\t\t\tcon->error_msg = \"protocol error, bad banner\";\n\t\treturn -EINVAL;\n\t}\n\n\tp += CEPH_BANNER_V2_LEN;\n\tpayload_len = ceph_decode_16(&p);\n\tdout(\"%s con %p payload_len %d\\n\", __func__, con, payload_len);\n\n\treturn prepare_read_banner_payload(con, payload_len);\n}\n\nstatic int process_banner_payload(struct ceph_connection *con)\n{\n\tvoid *end = con->v2.in_kvecs[0].iov_base + con->v2.in_kvecs[0].iov_len;\n\tu64 feat = CEPH_MSGR2_SUPPORTED_FEATURES;\n\tu64 req_feat = CEPH_MSGR2_REQUIRED_FEATURES;\n\tu64 server_feat, server_req_feat;\n\tvoid *p;\n\tint ret;\n\n\tp = con->v2.in_kvecs[0].iov_base;\n\tceph_decode_64_safe(&p, end, server_feat, bad);\n\tceph_decode_64_safe(&p, end, server_req_feat, bad);\n\n\tdout(\"%s con %p server_feat 0x%llx server_req_feat 0x%llx\\n\",\n\t     __func__, con, server_feat, server_req_feat);\n\n\tif (req_feat & ~server_feat) {\n\t\tpr_err(\"msgr2 feature set mismatch: my required > server's supported 0x%llx, need 0x%llx\\n\",\n\t\t       server_feat, req_feat & ~server_feat);\n\t\tcon->error_msg = \"missing required protocol features\";\n\t\treturn -EINVAL;\n\t}\n\tif (server_req_feat & ~feat) {\n\t\tpr_err(\"msgr2 feature set mismatch: server's required > my supported 0x%llx, missing 0x%llx\\n\",\n\t\t       feat, server_req_feat & ~feat);\n\t\tcon->error_msg = \"missing required protocol features\";\n\t\treturn -EINVAL;\n\t}\n\n\t/* no reset_out_kvecs() as our banner may still be pending */\n\tret = prepare_hello(con);\n\tif (ret) {\n\t\tpr_err(\"prepare_hello failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcon->state = CEPH_CON_S_V2_HELLO;\n\tprepare_read_preamble(con);\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode banner payload\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_hello(struct ceph_connection *con, void *p, void *end)\n{\n\tstruct ceph_entity_addr *my_addr = &con->msgr->inst.addr;\n\tstruct ceph_entity_addr addr_for_me;\n\tu8 entity_type;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_HELLO) {\n\t\tcon->error_msg = \"protocol error, unexpected hello\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_8_safe(&p, end, entity_type, bad);\n\tret = ceph_decode_entity_addr(&p, end, &addr_for_me);\n\tif (ret) {\n\t\tpr_err(\"failed to decode addr_for_me: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdout(\"%s con %p entity_type %d addr_for_me %s\\n\", __func__, con,\n\t     entity_type, ceph_pr_addr(&addr_for_me));\n\n\tif (entity_type != con->peer_name.type) {\n\t\tpr_err(\"bad peer type, want %d, got %d\\n\",\n\t\t       con->peer_name.type, entity_type);\n\t\tcon->error_msg = \"wrong peer at address\";\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Set our address to the address our first peer (i.e. monitor)\n\t * sees that we are connecting from.  If we are behind some sort\n\t * of NAT and want to be identified by some private (not NATed)\n\t * address, ip option should be used.\n\t */\n\tif (ceph_addr_is_blank(my_addr)) {\n\t\tmemcpy(&my_addr->in_addr, &addr_for_me.in_addr,\n\t\t       sizeof(my_addr->in_addr));\n\t\tceph_addr_set_port(my_addr, 0);\n\t\tdout(\"%s con %p set my addr %s, as seen by peer %s\\n\",\n\t\t     __func__, con, ceph_pr_addr(my_addr),\n\t\t     ceph_pr_addr(&con->peer_addr));\n\t} else {\n\t\tdout(\"%s con %p my addr already set %s\\n\",\n\t\t     __func__, con, ceph_pr_addr(my_addr));\n\t}\n\n\tWARN_ON(ceph_addr_is_blank(my_addr) || ceph_addr_port(my_addr));\n\tWARN_ON(my_addr->type != CEPH_ENTITY_ADDR_TYPE_ANY);\n\tWARN_ON(!my_addr->nonce);\n\n\t/* no reset_out_kvecs() as our hello may still be pending */\n\tret = prepare_auth_request(con);\n\tif (ret) {\n\t\tif (ret != -EAGAIN)\n\t\t\tpr_err(\"prepare_auth_request failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcon->state = CEPH_CON_S_V2_AUTH;\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode hello\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_auth_bad_method(struct ceph_connection *con,\n\t\t\t\t   void *p, void *end)\n{\n\tint allowed_protos[8], allowed_modes[8];\n\tint allowed_proto_cnt, allowed_mode_cnt;\n\tint used_proto, result;\n\tint ret;\n\tint i;\n\n\tif (con->state != CEPH_CON_S_V2_AUTH) {\n\t\tcon->error_msg = \"protocol error, unexpected auth_bad_method\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_32_safe(&p, end, used_proto, bad);\n\tceph_decode_32_safe(&p, end, result, bad);\n\tdout(\"%s con %p used_proto %d result %d\\n\", __func__, con, used_proto,\n\t     result);\n\n\tceph_decode_32_safe(&p, end, allowed_proto_cnt, bad);\n\tif (allowed_proto_cnt > ARRAY_SIZE(allowed_protos)) {\n\t\tpr_err(\"allowed_protos too big %d\\n\", allowed_proto_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < allowed_proto_cnt; i++) {\n\t\tceph_decode_32_safe(&p, end, allowed_protos[i], bad);\n\t\tdout(\"%s con %p allowed_protos[%d] %d\\n\", __func__, con,\n\t\t     i, allowed_protos[i]);\n\t}\n\n\tceph_decode_32_safe(&p, end, allowed_mode_cnt, bad);\n\tif (allowed_mode_cnt > ARRAY_SIZE(allowed_modes)) {\n\t\tpr_err(\"allowed_modes too big %d\\n\", allowed_mode_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < allowed_mode_cnt; i++) {\n\t\tceph_decode_32_safe(&p, end, allowed_modes[i], bad);\n\t\tdout(\"%s con %p allowed_modes[%d] %d\\n\", __func__, con,\n\t\t     i, allowed_modes[i]);\n\t}\n\n\tmutex_unlock(&con->mutex);\n\tret = con->ops->handle_auth_bad_method(con, used_proto, result,\n\t\t\t\t\t       allowed_protos,\n\t\t\t\t\t       allowed_proto_cnt,\n\t\t\t\t\t       allowed_modes,\n\t\t\t\t\t       allowed_mode_cnt);\n\tmutex_lock(&con->mutex);\n\tif (con->state != CEPH_CON_S_V2_AUTH) {\n\t\tdout(\"%s con %p state changed to %d\\n\", __func__, con,\n\t\t     con->state);\n\t\treturn -EAGAIN;\n\t}\n\n\tdout(\"%s con %p handle_auth_bad_method ret %d\\n\", __func__, con, ret);\n\treturn ret;\n\nbad:\n\tpr_err(\"failed to decode auth_bad_method\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_auth_reply_more(struct ceph_connection *con,\n\t\t\t\t   void *p, void *end)\n{\n\tint payload_len;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_AUTH) {\n\t\tcon->error_msg = \"protocol error, unexpected auth_reply_more\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_32_safe(&p, end, payload_len, bad);\n\tceph_decode_need(&p, end, payload_len, bad);\n\n\tdout(\"%s con %p payload_len %d\\n\", __func__, con, payload_len);\n\n\treset_out_kvecs(con);\n\tret = prepare_auth_request_more(con, p, payload_len);\n\tif (ret) {\n\t\tif (ret != -EAGAIN)\n\t\t\tpr_err(\"prepare_auth_request_more failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode auth_reply_more\\n\");\n\treturn -EINVAL;\n}\n\n/*\n * Align session_key and con_secret to avoid GFP_ATOMIC allocation\n * inside crypto_shash_setkey() and crypto_aead_setkey() called from\n * setup_crypto().  __aligned(16) isn't guaranteed to work for stack\n * objects, so do it by hand.\n */\nstatic int process_auth_done(struct ceph_connection *con, void *p, void *end)\n{\n\tu8 session_key_buf[CEPH_KEY_LEN + 16];\n\tu8 con_secret_buf[CEPH_MAX_CON_SECRET_LEN + 16];\n\tu8 *session_key = PTR_ALIGN(&session_key_buf[0], 16);\n\tu8 *con_secret = PTR_ALIGN(&con_secret_buf[0], 16);\n\tint session_key_len, con_secret_len;\n\tint payload_len;\n\tu64 global_id;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_AUTH) {\n\t\tcon->error_msg = \"protocol error, unexpected auth_done\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_64_safe(&p, end, global_id, bad);\n\tceph_decode_32_safe(&p, end, con->v2.con_mode, bad);\n\tceph_decode_32_safe(&p, end, payload_len, bad);\n\n\tdout(\"%s con %p global_id %llu con_mode %d payload_len %d\\n\",\n\t     __func__, con, global_id, con->v2.con_mode, payload_len);\n\n\tmutex_unlock(&con->mutex);\n\tsession_key_len = 0;\n\tcon_secret_len = 0;\n\tret = con->ops->handle_auth_done(con, global_id, p, payload_len,\n\t\t\t\t\t session_key, &session_key_len,\n\t\t\t\t\t con_secret, &con_secret_len);\n\tmutex_lock(&con->mutex);\n\tif (con->state != CEPH_CON_S_V2_AUTH) {\n\t\tdout(\"%s con %p state changed to %d\\n\", __func__, con,\n\t\t     con->state);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tdout(\"%s con %p handle_auth_done ret %d\\n\", __func__, con, ret);\n\tif (ret)\n\t\tgoto out;\n\n\tret = setup_crypto(con, session_key, session_key_len, con_secret,\n\t\t\t   con_secret_len);\n\tif (ret)\n\t\tgoto out;\n\n\treset_out_kvecs(con);\n\tret = prepare_auth_signature(con);\n\tif (ret) {\n\t\tpr_err(\"prepare_auth_signature failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tcon->state = CEPH_CON_S_V2_AUTH_SIGNATURE;\n\nout:\n\tmemzero_explicit(session_key_buf, sizeof(session_key_buf));\n\tmemzero_explicit(con_secret_buf, sizeof(con_secret_buf));\n\treturn ret;\n\nbad:\n\tpr_err(\"failed to decode auth_done\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_auth_signature(struct ceph_connection *con,\n\t\t\t\t  void *p, void *end)\n{\n\tu8 hmac[SHA256_DIGEST_SIZE];\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_AUTH_SIGNATURE) {\n\t\tcon->error_msg = \"protocol error, unexpected auth_signature\";\n\t\treturn -EINVAL;\n\t}\n\n\tret = hmac_sha256(con, con->v2.out_sign_kvecs,\n\t\t\t  con->v2.out_sign_kvec_cnt, hmac);\n\tif (ret)\n\t\treturn ret;\n\n\tceph_decode_need(&p, end, SHA256_DIGEST_SIZE, bad);\n\tif (crypto_memneq(p, hmac, SHA256_DIGEST_SIZE)) {\n\t\tcon->error_msg = \"integrity error, bad auth signature\";\n\t\treturn -EBADMSG;\n\t}\n\n\tdout(\"%s con %p auth signature ok\\n\", __func__, con);\n\n\t/* no reset_out_kvecs() as our auth_signature may still be pending */\n\tif (!con->v2.server_cookie) {\n\t\tret = prepare_client_ident(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_client_ident failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tcon->state = CEPH_CON_S_V2_SESSION_CONNECT;\n\t} else {\n\t\tret = prepare_session_reconnect(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_session_reconnect failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tcon->state = CEPH_CON_S_V2_SESSION_RECONNECT;\n\t}\n\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode auth_signature\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_server_ident(struct ceph_connection *con,\n\t\t\t\tvoid *p, void *end)\n{\n\tstruct ceph_client *client = from_msgr(con->msgr);\n\tu64 features, required_features;\n\tstruct ceph_entity_addr addr;\n\tu64 global_seq;\n\tu64 global_id;\n\tu64 cookie;\n\tu64 flags;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_SESSION_CONNECT) {\n\t\tcon->error_msg = \"protocol error, unexpected server_ident\";\n\t\treturn -EINVAL;\n\t}\n\n\tret = ceph_decode_entity_addrvec(&p, end, true, &addr);\n\tif (ret) {\n\t\tpr_err(\"failed to decode server addrs: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tceph_decode_64_safe(&p, end, global_id, bad);\n\tceph_decode_64_safe(&p, end, global_seq, bad);\n\tceph_decode_64_safe(&p, end, features, bad);\n\tceph_decode_64_safe(&p, end, required_features, bad);\n\tceph_decode_64_safe(&p, end, flags, bad);\n\tceph_decode_64_safe(&p, end, cookie, bad);\n\n\tdout(\"%s con %p addr %s/%u global_id %llu global_seq %llu features 0x%llx required_features 0x%llx flags 0x%llx cookie 0x%llx\\n\",\n\t     __func__, con, ceph_pr_addr(&addr), le32_to_cpu(addr.nonce),\n\t     global_id, global_seq, features, required_features, flags, cookie);\n\n\t/* is this who we intended to talk to? */\n\tif (memcmp(&addr, &con->peer_addr, sizeof(con->peer_addr))) {\n\t\tpr_err(\"bad peer addr/nonce, want %s/%u, got %s/%u\\n\",\n\t\t       ceph_pr_addr(&con->peer_addr),\n\t\t       le32_to_cpu(con->peer_addr.nonce),\n\t\t       ceph_pr_addr(&addr), le32_to_cpu(addr.nonce));\n\t\tcon->error_msg = \"wrong peer at address\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (client->required_features & ~features) {\n\t\tpr_err(\"RADOS feature set mismatch: my required > server's supported 0x%llx, need 0x%llx\\n\",\n\t\t       features, client->required_features & ~features);\n\t\tcon->error_msg = \"missing required protocol features\";\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Both name->type and name->num are set in ceph_con_open() but\n\t * name->num may be bogus in the initial monmap.  name->type is\n\t * verified in handle_hello().\n\t */\n\tWARN_ON(!con->peer_name.type);\n\tcon->peer_name.num = cpu_to_le64(global_id);\n\tcon->v2.peer_global_seq = global_seq;\n\tcon->peer_features = features;\n\tWARN_ON(required_features & ~client->supported_features);\n\tcon->v2.server_cookie = cookie;\n\n\tif (flags & CEPH_MSG_CONNECT_LOSSY) {\n\t\tceph_con_flag_set(con, CEPH_CON_F_LOSSYTX);\n\t\tWARN_ON(con->v2.server_cookie);\n\t} else {\n\t\tWARN_ON(!con->v2.server_cookie);\n\t}\n\n\tclear_in_sign_kvecs(con);\n\tclear_out_sign_kvecs(con);\n\tfree_conn_bufs(con);\n\tcon->delay = 0;  /* reset backoff memory */\n\n\tcon->state = CEPH_CON_S_OPEN;\n\tcon->v2.out_state = OUT_S_GET_NEXT;\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode server_ident\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_ident_missing_features(struct ceph_connection *con,\n\t\t\t\t\t  void *p, void *end)\n{\n\tstruct ceph_client *client = from_msgr(con->msgr);\n\tu64 missing_features;\n\n\tif (con->state != CEPH_CON_S_V2_SESSION_CONNECT) {\n\t\tcon->error_msg = \"protocol error, unexpected ident_missing_features\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_64_safe(&p, end, missing_features, bad);\n\tpr_err(\"RADOS feature set mismatch: server's required > my supported 0x%llx, missing 0x%llx\\n\",\n\t       client->supported_features, missing_features);\n\tcon->error_msg = \"missing required protocol features\";\n\treturn -EINVAL;\n\nbad:\n\tpr_err(\"failed to decode ident_missing_features\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_session_reconnect_ok(struct ceph_connection *con,\n\t\t\t\t\tvoid *p, void *end)\n{\n\tu64 seq;\n\n\tif (con->state != CEPH_CON_S_V2_SESSION_RECONNECT) {\n\t\tcon->error_msg = \"protocol error, unexpected session_reconnect_ok\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_64_safe(&p, end, seq, bad);\n\n\tdout(\"%s con %p seq %llu\\n\", __func__, con, seq);\n\tceph_con_discard_requeued(con, seq);\n\n\tclear_in_sign_kvecs(con);\n\tclear_out_sign_kvecs(con);\n\tfree_conn_bufs(con);\n\tcon->delay = 0;  /* reset backoff memory */\n\n\tcon->state = CEPH_CON_S_OPEN;\n\tcon->v2.out_state = OUT_S_GET_NEXT;\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode session_reconnect_ok\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_session_retry(struct ceph_connection *con,\n\t\t\t\t void *p, void *end)\n{\n\tu64 connect_seq;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_SESSION_RECONNECT) {\n\t\tcon->error_msg = \"protocol error, unexpected session_retry\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_64_safe(&p, end, connect_seq, bad);\n\n\tdout(\"%s con %p connect_seq %llu\\n\", __func__, con, connect_seq);\n\tWARN_ON(connect_seq <= con->v2.connect_seq);\n\tcon->v2.connect_seq = connect_seq + 1;\n\n\tfree_conn_bufs(con);\n\n\treset_out_kvecs(con);\n\tret = prepare_session_reconnect(con);\n\tif (ret) {\n\t\tpr_err(\"prepare_session_reconnect (cseq) failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode session_retry\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_session_retry_global(struct ceph_connection *con,\n\t\t\t\t\tvoid *p, void *end)\n{\n\tu64 global_seq;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_SESSION_RECONNECT) {\n\t\tcon->error_msg = \"protocol error, unexpected session_retry_global\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_64_safe(&p, end, global_seq, bad);\n\n\tdout(\"%s con %p global_seq %llu\\n\", __func__, con, global_seq);\n\tWARN_ON(global_seq <= con->v2.global_seq);\n\tcon->v2.global_seq = ceph_get_global_seq(con->msgr, global_seq);\n\n\tfree_conn_bufs(con);\n\n\treset_out_kvecs(con);\n\tret = prepare_session_reconnect(con);\n\tif (ret) {\n\t\tpr_err(\"prepare_session_reconnect (gseq) failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode session_retry_global\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_session_reset(struct ceph_connection *con,\n\t\t\t\t void *p, void *end)\n{\n\tbool full;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_SESSION_RECONNECT) {\n\t\tcon->error_msg = \"protocol error, unexpected session_reset\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_8_safe(&p, end, full, bad);\n\tif (!full) {\n\t\tcon->error_msg = \"protocol error, bad session_reset\";\n\t\treturn -EINVAL;\n\t}\n\n\tpr_info(\"%s%lld %s session reset\\n\", ENTITY_NAME(con->peer_name),\n\t\tceph_pr_addr(&con->peer_addr));\n\tceph_con_reset_session(con);\n\n\tmutex_unlock(&con->mutex);\n\tif (con->ops->peer_reset)\n\t\tcon->ops->peer_reset(con);\n\tmutex_lock(&con->mutex);\n\tif (con->state != CEPH_CON_S_V2_SESSION_RECONNECT) {\n\t\tdout(\"%s con %p state changed to %d\\n\", __func__, con,\n\t\t     con->state);\n\t\treturn -EAGAIN;\n\t}\n\n\tfree_conn_bufs(con);\n\n\treset_out_kvecs(con);\n\tret = prepare_client_ident(con);\n\tif (ret) {\n\t\tpr_err(\"prepare_client_ident (rst) failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcon->state = CEPH_CON_S_V2_SESSION_CONNECT;\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode session_reset\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_keepalive2_ack(struct ceph_connection *con,\n\t\t\t\t  void *p, void *end)\n{\n\tif (con->state != CEPH_CON_S_OPEN) {\n\t\tcon->error_msg = \"protocol error, unexpected keepalive2_ack\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_need(&p, end, sizeof(struct ceph_timespec), bad);\n\tceph_decode_timespec64(&con->last_keepalive_ack, p);\n\n\tdout(\"%s con %p timestamp %lld.%09ld\\n\", __func__, con,\n\t     con->last_keepalive_ack.tv_sec, con->last_keepalive_ack.tv_nsec);\n\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode keepalive2_ack\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_ack(struct ceph_connection *con, void *p, void *end)\n{\n\tu64 seq;\n\n\tif (con->state != CEPH_CON_S_OPEN) {\n\t\tcon->error_msg = \"protocol error, unexpected ack\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_64_safe(&p, end, seq, bad);\n\n\tdout(\"%s con %p seq %llu\\n\", __func__, con, seq);\n\tceph_con_discard_sent(con, seq);\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode ack\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_control(struct ceph_connection *con, void *p, void *end)\n{\n\tint tag = con->v2.in_desc.fd_tag;\n\tint ret;\n\n\tdout(\"%s con %p tag %d len %d\\n\", __func__, con, tag, (int)(end - p));\n\n\tswitch (tag) {\n\tcase FRAME_TAG_HELLO:\n\t\tret = process_hello(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_AUTH_BAD_METHOD:\n\t\tret = process_auth_bad_method(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_AUTH_REPLY_MORE:\n\t\tret = process_auth_reply_more(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_AUTH_DONE:\n\t\tret = process_auth_done(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_AUTH_SIGNATURE:\n\t\tret = process_auth_signature(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_SERVER_IDENT:\n\t\tret = process_server_ident(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_IDENT_MISSING_FEATURES:\n\t\tret = process_ident_missing_features(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_SESSION_RECONNECT_OK:\n\t\tret = process_session_reconnect_ok(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_SESSION_RETRY:\n\t\tret = process_session_retry(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_SESSION_RETRY_GLOBAL:\n\t\tret = process_session_retry_global(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_SESSION_RESET:\n\t\tret = process_session_reset(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_KEEPALIVE2_ACK:\n\t\tret = process_keepalive2_ack(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_ACK:\n\t\tret = process_ack(con, p, end);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"bad tag %d\\n\", tag);\n\t\tcon->error_msg = \"protocol error, bad tag\";\n\t\treturn -EINVAL;\n\t}\n\tif (ret) {\n\t\tdout(\"%s con %p error %d\\n\", __func__, con, ret);\n\t\treturn ret;\n\t}\n\n\tprepare_read_preamble(con);\n\treturn 0;\n}\n\n/*\n * Return:\n *   1 - con->in_msg set, read message\n *   0 - skip message\n *  <0 - error\n */\nstatic int process_message_header(struct ceph_connection *con,\n\t\t\t\t  void *p, void *end)\n{\n\tstruct ceph_frame_desc *desc = &con->v2.in_desc;\n\tstruct ceph_msg_header2 *hdr2 = p;\n\tstruct ceph_msg_header hdr;\n\tint skip;\n\tint ret;\n\tu64 seq;\n\n\t/* verify seq# */\n\tseq = le64_to_cpu(hdr2->seq);\n\tif ((s64)seq - (s64)con->in_seq < 1) {\n\t\tpr_info(\"%s%lld %s skipping old message: seq %llu, expected %llu\\n\",\n\t\t\tENTITY_NAME(con->peer_name),\n\t\t\tceph_pr_addr(&con->peer_addr),\n\t\t\tseq, con->in_seq + 1);\n\t\treturn 0;\n\t}\n\tif ((s64)seq - (s64)con->in_seq > 1) {\n\t\tpr_err(\"bad seq %llu, expected %llu\\n\", seq, con->in_seq + 1);\n\t\tcon->error_msg = \"bad message sequence # for incoming message\";\n\t\treturn -EBADE;\n\t}\n\n\tceph_con_discard_sent(con, le64_to_cpu(hdr2->ack_seq));\n\n\tfill_header(&hdr, hdr2, desc->fd_lens[1], desc->fd_lens[2],\n\t\t    desc->fd_lens[3], &con->peer_name);\n\tret = ceph_con_in_msg_alloc(con, &hdr, &skip);\n\tif (ret)\n\t\treturn ret;\n\n\tWARN_ON(!con->in_msg ^ skip);\n\tif (skip)\n\t\treturn 0;\n\n\tWARN_ON(!con->in_msg);\n\tWARN_ON(con->in_msg->con != con);\n\treturn 1;\n}\n\nstatic int process_message(struct ceph_connection *con)\n{\n\tceph_con_process_message(con);\n\n\t/*\n\t * We could have been closed by ceph_con_close() because\n\t * ceph_con_process_message() temporarily drops con->mutex.\n\t */\n\tif (con->state != CEPH_CON_S_OPEN) {\n\t\tdout(\"%s con %p state changed to %d\\n\", __func__, con,\n\t\t     con->state);\n\t\treturn -EAGAIN;\n\t}\n\n\tprepare_read_preamble(con);\n\treturn 0;\n}\n\nstatic int __handle_control(struct ceph_connection *con, void *p)\n{\n\tvoid *end = p + con->v2.in_desc.fd_lens[0];\n\tstruct ceph_msg *msg;\n\tint ret;\n\n\tif (con->v2.in_desc.fd_tag != FRAME_TAG_MESSAGE)\n\t\treturn process_control(con, p, end);\n\n\tret = process_message_header(con, p, end);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0) {\n\t\tprepare_skip_message(con);\n\t\treturn 0;\n\t}\n\n\tmsg = con->in_msg;  /* set in process_message_header() */\n\tif (front_len(msg)) {\n\t\tWARN_ON(front_len(msg) > msg->front_alloc_len);\n\t\tmsg->front.iov_len = front_len(msg);\n\t} else {\n\t\tmsg->front.iov_len = 0;\n\t}\n\tif (middle_len(msg)) {\n\t\tWARN_ON(middle_len(msg) > msg->middle->alloc_len);\n\t\tmsg->middle->vec.iov_len = middle_len(msg);\n\t} else if (msg->middle) {\n\t\tmsg->middle->vec.iov_len = 0;\n\t}\n\n\tif (!front_len(msg) && !middle_len(msg) && !data_len(msg))\n\t\treturn process_message(con);\n\n\tif (con_secure(con))\n\t\treturn prepare_read_tail_secure(con);\n\n\treturn prepare_read_tail_plain(con);\n}\n\nstatic int handle_preamble(struct ceph_connection *con)\n{\n\tstruct ceph_frame_desc *desc = &con->v2.in_desc;\n\tint ret;\n\n\tif (con_secure(con)) {\n\t\tret = decrypt_preamble(con);\n\t\tif (ret) {\n\t\t\tif (ret == -EBADMSG)\n\t\t\t\tcon->error_msg = \"integrity error, bad preamble auth tag\";\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = decode_preamble(con->v2.in_buf, desc);\n\tif (ret) {\n\t\tif (ret == -EBADMSG)\n\t\t\tcon->error_msg = \"integrity error, bad crc\";\n\t\telse\n\t\t\tcon->error_msg = \"protocol error, bad preamble\";\n\t\treturn ret;\n\t}\n\n\tdout(\"%s con %p tag %d seg_cnt %d %d+%d+%d+%d\\n\", __func__,\n\t     con, desc->fd_tag, desc->fd_seg_cnt, desc->fd_lens[0],\n\t     desc->fd_lens[1], desc->fd_lens[2], desc->fd_lens[3]);\n\n\tif (!con_secure(con))\n\t\treturn prepare_read_control(con);\n\n\tif (desc->fd_lens[0] > CEPH_PREAMBLE_INLINE_LEN)\n\t\treturn prepare_read_control_remainder(con);\n\n\treturn __handle_control(con, CTRL_BODY(con->v2.in_buf));\n}\n\nstatic int handle_control(struct ceph_connection *con)\n{\n\tint ctrl_len = con->v2.in_desc.fd_lens[0];\n\tvoid *buf;\n\tint ret;\n\n\tWARN_ON(con_secure(con));\n\n\tret = verify_control_crc(con);\n\tif (ret) {\n\t\tcon->error_msg = \"integrity error, bad crc\";\n\t\treturn ret;\n\t}\n\n\tif (con->state == CEPH_CON_S_V2_AUTH) {\n\t\tbuf = alloc_conn_buf(con, ctrl_len);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(buf, con->v2.in_kvecs[0].iov_base, ctrl_len);\n\t\treturn __handle_control(con, buf);\n\t}\n\n\treturn __handle_control(con, con->v2.in_kvecs[0].iov_base);\n}\n\nstatic int handle_control_remainder(struct ceph_connection *con)\n{\n\tint ret;\n\n\tWARN_ON(!con_secure(con));\n\n\tret = decrypt_control_remainder(con);\n\tif (ret) {\n\t\tif (ret == -EBADMSG)\n\t\t\tcon->error_msg = \"integrity error, bad control remainder auth tag\";\n\t\treturn ret;\n\t}\n\n\treturn __handle_control(con, con->v2.in_kvecs[0].iov_base -\n\t\t\t\t     CEPH_PREAMBLE_INLINE_LEN);\n}\n\nstatic int handle_epilogue(struct ceph_connection *con)\n{\n\tu32 front_crc, middle_crc, data_crc;\n\tint ret;\n\n\tif (con_secure(con)) {\n\t\tret = decrypt_tail(con);\n\t\tif (ret) {\n\t\t\tif (ret == -EBADMSG)\n\t\t\t\tcon->error_msg = \"integrity error, bad epilogue auth tag\";\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* just late_status */\n\t\tret = decode_epilogue(con->v2.in_buf, NULL, NULL, NULL);\n\t\tif (ret) {\n\t\t\tcon->error_msg = \"protocol error, bad epilogue\";\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = decode_epilogue(con->v2.in_buf, &front_crc,\n\t\t\t\t      &middle_crc, &data_crc);\n\t\tif (ret) {\n\t\t\tcon->error_msg = \"protocol error, bad epilogue\";\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = verify_epilogue_crcs(con, front_crc, middle_crc,\n\t\t\t\t\t   data_crc);\n\t\tif (ret) {\n\t\t\tcon->error_msg = \"integrity error, bad crc\";\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn process_message(con);\n}\n\nstatic void finish_skip(struct ceph_connection *con)\n{\n\tdout(\"%s con %p\\n\", __func__, con);\n\n\tif (con_secure(con))\n\t\tgcm_inc_nonce(&con->v2.in_gcm_nonce);\n\n\t__finish_skip(con);\n}\n\nstatic int populate_in_iter(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s con %p state %d in_state %d\\n\", __func__, con, con->state,\n\t     con->v2.in_state);\n\tWARN_ON(iov_iter_count(&con->v2.in_iter));\n\n\tif (con->state == CEPH_CON_S_V2_BANNER_PREFIX) {\n\t\tret = process_banner_prefix(con);\n\t} else if (con->state == CEPH_CON_S_V2_BANNER_PAYLOAD) {\n\t\tret = process_banner_payload(con);\n\t} else if ((con->state >= CEPH_CON_S_V2_HELLO &&\n\t\t    con->state <= CEPH_CON_S_V2_SESSION_RECONNECT) ||\n\t\t   con->state == CEPH_CON_S_OPEN) {\n\t\tswitch (con->v2.in_state) {\n\t\tcase IN_S_HANDLE_PREAMBLE:\n\t\t\tret = handle_preamble(con);\n\t\t\tbreak;\n\t\tcase IN_S_HANDLE_CONTROL:\n\t\t\tret = handle_control(con);\n\t\t\tbreak;\n\t\tcase IN_S_HANDLE_CONTROL_REMAINDER:\n\t\t\tret = handle_control_remainder(con);\n\t\t\tbreak;\n\t\tcase IN_S_PREPARE_READ_DATA:\n\t\t\tret = prepare_read_data(con);\n\t\t\tbreak;\n\t\tcase IN_S_PREPARE_READ_DATA_CONT:\n\t\t\tprepare_read_data_cont(con);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase IN_S_PREPARE_READ_ENC_PAGE:\n\t\t\tprepare_read_enc_page(con);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase IN_S_HANDLE_EPILOGUE:\n\t\t\tret = handle_epilogue(con);\n\t\t\tbreak;\n\t\tcase IN_S_FINISH_SKIP:\n\t\t\tfinish_skip(con);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"bad in_state %d\", con->v2.in_state);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tWARN(1, \"bad state %d\", con->state);\n\t\treturn -EINVAL;\n\t}\n\tif (ret) {\n\t\tdout(\"%s con %p error %d\\n\", __func__, con, ret);\n\t\treturn ret;\n\t}\n\n\tif (WARN_ON(!iov_iter_count(&con->v2.in_iter)))\n\t\treturn -ENODATA;\n\tdout(\"%s con %p populated %zu\\n\", __func__, con,\n\t     iov_iter_count(&con->v2.in_iter));\n\treturn 1;\n}\n\nint ceph_con_v2_try_read(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s con %p state %d need %zu\\n\", __func__, con, con->state,\n\t     iov_iter_count(&con->v2.in_iter));\n\n\tif (con->state == CEPH_CON_S_PREOPEN)\n\t\treturn 0;\n\n\t/*\n\t * We should always have something pending here.  If not,\n\t * avoid calling populate_in_iter() as if we read something\n\t * (ceph_tcp_recv() would immediately return 1).\n\t */\n\tif (WARN_ON(!iov_iter_count(&con->v2.in_iter)))\n\t\treturn -ENODATA;\n\n\tfor (;;) {\n\t\tret = ceph_tcp_recv(con);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tret = populate_in_iter(con);\n\t\tif (ret <= 0) {\n\t\t\tif (ret && ret != -EAGAIN && !con->error_msg)\n\t\t\t\tcon->error_msg = \"read processing error\";\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n\nstatic void queue_data(struct ceph_connection *con)\n{\n\tstruct bio_vec bv;\n\n\tcon->v2.out_epil.data_crc = -1;\n\tceph_msg_data_cursor_init(&con->v2.out_cursor, con->out_msg,\n\t\t\t\t  data_len(con->out_msg));\n\n\tget_bvec_at(&con->v2.out_cursor, &bv);\n\tset_out_bvec(con, &bv, true);\n\tcon->v2.out_state = OUT_S_QUEUE_DATA_CONT;\n}\n\nstatic void queue_data_cont(struct ceph_connection *con)\n{\n\tstruct bio_vec bv;\n\n\tcon->v2.out_epil.data_crc = ceph_crc32c_page(\n\t\tcon->v2.out_epil.data_crc, con->v2.out_bvec.bv_page,\n\t\tcon->v2.out_bvec.bv_offset, con->v2.out_bvec.bv_len);\n\n\tceph_msg_data_advance(&con->v2.out_cursor, con->v2.out_bvec.bv_len);\n\tif (con->v2.out_cursor.total_resid) {\n\t\tget_bvec_at(&con->v2.out_cursor, &bv);\n\t\tset_out_bvec(con, &bv, true);\n\t\tWARN_ON(con->v2.out_state != OUT_S_QUEUE_DATA_CONT);\n\t\treturn;\n\t}\n\n\t/*\n\t * We've written all data.  Queue epilogue.  Once it's written,\n\t * we are done.\n\t */\n\treset_out_kvecs(con);\n\tprepare_epilogue_plain(con, false);\n\tcon->v2.out_state = OUT_S_FINISH_MESSAGE;\n}\n\nstatic void queue_enc_page(struct ceph_connection *con)\n{\n\tstruct bio_vec bv;\n\n\tdout(\"%s con %p i %d resid %d\\n\", __func__, con, con->v2.out_enc_i,\n\t     con->v2.out_enc_resid);\n\tWARN_ON(!con->v2.out_enc_resid);\n\n\tbvec_set_page(&bv, con->v2.out_enc_pages[con->v2.out_enc_i],\n\t\t      min(con->v2.out_enc_resid, (int)PAGE_SIZE), 0);\n\n\tset_out_bvec(con, &bv, false);\n\tcon->v2.out_enc_i++;\n\tcon->v2.out_enc_resid -= bv.bv_len;\n\n\tif (con->v2.out_enc_resid) {\n\t\tWARN_ON(con->v2.out_state != OUT_S_QUEUE_ENC_PAGE);\n\t\treturn;\n\t}\n\n\t/*\n\t * We've queued the last piece of ciphertext (ending with\n\t * epilogue) + auth tag.  Once it's written, we are done.\n\t */\n\tWARN_ON(con->v2.out_enc_i != con->v2.out_enc_page_cnt);\n\tcon->v2.out_state = OUT_S_FINISH_MESSAGE;\n}\n\nstatic void queue_zeros(struct ceph_connection *con)\n{\n\tdout(\"%s con %p out_zero %d\\n\", __func__, con, con->v2.out_zero);\n\n\tif (con->v2.out_zero) {\n\t\tset_out_bvec_zero(con);\n\t\tcon->v2.out_zero -= con->v2.out_bvec.bv_len;\n\t\tcon->v2.out_state = OUT_S_QUEUE_ZEROS;\n\t\treturn;\n\t}\n\n\t/*\n\t * We've zero-filled everything up to epilogue.  Queue epilogue\n\t * with late_status set to ABORTED and crcs adjusted for zeros.\n\t * Once it's written, we are done patching up for the revoke.\n\t */\n\treset_out_kvecs(con);\n\tprepare_epilogue_plain(con, true);\n\tcon->v2.out_state = OUT_S_FINISH_MESSAGE;\n}\n\nstatic void finish_message(struct ceph_connection *con)\n{\n\tdout(\"%s con %p msg %p\\n\", __func__, con, con->out_msg);\n\n\t/* we end up here both plain and secure modes */\n\tif (con->v2.out_enc_pages) {\n\t\tWARN_ON(!con->v2.out_enc_page_cnt);\n\t\tceph_release_page_vector(con->v2.out_enc_pages,\n\t\t\t\t\t con->v2.out_enc_page_cnt);\n\t\tcon->v2.out_enc_pages = NULL;\n\t\tcon->v2.out_enc_page_cnt = 0;\n\t}\n\t/* message may have been revoked */\n\tif (con->out_msg) {\n\t\tceph_msg_put(con->out_msg);\n\t\tcon->out_msg = NULL;\n\t}\n\n\tcon->v2.out_state = OUT_S_GET_NEXT;\n}\n\nstatic int populate_out_iter(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s con %p state %d out_state %d\\n\", __func__, con, con->state,\n\t     con->v2.out_state);\n\tWARN_ON(iov_iter_count(&con->v2.out_iter));\n\n\tif (con->state != CEPH_CON_S_OPEN) {\n\t\tWARN_ON(con->state < CEPH_CON_S_V2_BANNER_PREFIX ||\n\t\t\tcon->state > CEPH_CON_S_V2_SESSION_RECONNECT);\n\t\tgoto nothing_pending;\n\t}\n\n\tswitch (con->v2.out_state) {\n\tcase OUT_S_QUEUE_DATA:\n\t\tWARN_ON(!con->out_msg);\n\t\tqueue_data(con);\n\t\tgoto populated;\n\tcase OUT_S_QUEUE_DATA_CONT:\n\t\tWARN_ON(!con->out_msg);\n\t\tqueue_data_cont(con);\n\t\tgoto populated;\n\tcase OUT_S_QUEUE_ENC_PAGE:\n\t\tqueue_enc_page(con);\n\t\tgoto populated;\n\tcase OUT_S_QUEUE_ZEROS:\n\t\tWARN_ON(con->out_msg);  /* revoked */\n\t\tqueue_zeros(con);\n\t\tgoto populated;\n\tcase OUT_S_FINISH_MESSAGE:\n\t\tfinish_message(con);\n\t\tbreak;\n\tcase OUT_S_GET_NEXT:\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"bad out_state %d\", con->v2.out_state);\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(con->v2.out_state != OUT_S_GET_NEXT);\n\tif (ceph_con_flag_test_and_clear(con, CEPH_CON_F_KEEPALIVE_PENDING)) {\n\t\tret = prepare_keepalive2(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_keepalive2 failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else if (!list_empty(&con->out_queue)) {\n\t\tceph_con_get_out_msg(con);\n\t\tret = prepare_message(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_message failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else if (con->in_seq > con->in_seq_acked) {\n\t\tret = prepare_ack(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_ack failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tgoto nothing_pending;\n\t}\n\npopulated:\n\tif (WARN_ON(!iov_iter_count(&con->v2.out_iter)))\n\t\treturn -ENODATA;\n\tdout(\"%s con %p populated %zu\\n\", __func__, con,\n\t     iov_iter_count(&con->v2.out_iter));\n\treturn 1;\n\nnothing_pending:\n\tWARN_ON(iov_iter_count(&con->v2.out_iter));\n\tdout(\"%s con %p nothing pending\\n\", __func__, con);\n\tceph_con_flag_clear(con, CEPH_CON_F_WRITE_PENDING);\n\treturn 0;\n}\n\nint ceph_con_v2_try_write(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s con %p state %d have %zu\\n\", __func__, con, con->state,\n\t     iov_iter_count(&con->v2.out_iter));\n\n\t/* open the socket first? */\n\tif (con->state == CEPH_CON_S_PREOPEN) {\n\t\tWARN_ON(con->peer_addr.type != CEPH_ENTITY_ADDR_TYPE_MSGR2);\n\n\t\t/*\n\t\t * Always bump global_seq.  Bump connect_seq only if\n\t\t * there is a session (i.e. we are reconnecting and will\n\t\t * send session_reconnect instead of client_ident).\n\t\t */\n\t\tcon->v2.global_seq = ceph_get_global_seq(con->msgr, 0);\n\t\tif (con->v2.server_cookie)\n\t\t\tcon->v2.connect_seq++;\n\n\t\tret = prepare_read_banner_prefix(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_read_banner_prefix failed: %d\\n\", ret);\n\t\t\tcon->error_msg = \"connect error\";\n\t\t\treturn ret;\n\t\t}\n\n\t\treset_out_kvecs(con);\n\t\tret = prepare_banner(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_banner failed: %d\\n\", ret);\n\t\t\tcon->error_msg = \"connect error\";\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ceph_tcp_connect(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"ceph_tcp_connect failed: %d\\n\", ret);\n\t\t\tcon->error_msg = \"connect error\";\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!iov_iter_count(&con->v2.out_iter)) {\n\t\tret = populate_out_iter(con);\n\t\tif (ret <= 0) {\n\t\t\tif (ret && ret != -EAGAIN && !con->error_msg)\n\t\t\t\tcon->error_msg = \"write processing error\";\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttcp_sock_set_cork(con->sock->sk, true);\n\tfor (;;) {\n\t\tret = ceph_tcp_send(con);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tret = populate_out_iter(con);\n\t\tif (ret <= 0) {\n\t\t\tif (ret && ret != -EAGAIN && !con->error_msg)\n\t\t\t\tcon->error_msg = \"write processing error\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttcp_sock_set_cork(con->sock->sk, false);\n\treturn ret;\n}\n\nstatic u32 crc32c_zeros(u32 crc, int zero_len)\n{\n\tint len;\n\n\twhile (zero_len) {\n\t\tlen = min(zero_len, (int)PAGE_SIZE);\n\t\tcrc = crc32c(crc, page_address(ceph_zero_page), len);\n\t\tzero_len -= len;\n\t}\n\n\treturn crc;\n}\n\nstatic void prepare_zero_front(struct ceph_connection *con, int resid)\n{\n\tint sent;\n\n\tWARN_ON(!resid || resid > front_len(con->out_msg));\n\tsent = front_len(con->out_msg) - resid;\n\tdout(\"%s con %p sent %d resid %d\\n\", __func__, con, sent, resid);\n\n\tif (sent) {\n\t\tcon->v2.out_epil.front_crc =\n\t\t\tcrc32c(-1, con->out_msg->front.iov_base, sent);\n\t\tcon->v2.out_epil.front_crc =\n\t\t\tcrc32c_zeros(con->v2.out_epil.front_crc, resid);\n\t} else {\n\t\tcon->v2.out_epil.front_crc = crc32c_zeros(-1, resid);\n\t}\n\n\tcon->v2.out_iter.count -= resid;\n\tout_zero_add(con, resid);\n}\n\nstatic void prepare_zero_middle(struct ceph_connection *con, int resid)\n{\n\tint sent;\n\n\tWARN_ON(!resid || resid > middle_len(con->out_msg));\n\tsent = middle_len(con->out_msg) - resid;\n\tdout(\"%s con %p sent %d resid %d\\n\", __func__, con, sent, resid);\n\n\tif (sent) {\n\t\tcon->v2.out_epil.middle_crc =\n\t\t\tcrc32c(-1, con->out_msg->middle->vec.iov_base, sent);\n\t\tcon->v2.out_epil.middle_crc =\n\t\t\tcrc32c_zeros(con->v2.out_epil.middle_crc, resid);\n\t} else {\n\t\tcon->v2.out_epil.middle_crc = crc32c_zeros(-1, resid);\n\t}\n\n\tcon->v2.out_iter.count -= resid;\n\tout_zero_add(con, resid);\n}\n\nstatic void prepare_zero_data(struct ceph_connection *con)\n{\n\tdout(\"%s con %p\\n\", __func__, con);\n\tcon->v2.out_epil.data_crc = crc32c_zeros(-1, data_len(con->out_msg));\n\tout_zero_add(con, data_len(con->out_msg));\n}\n\nstatic void revoke_at_queue_data(struct ceph_connection *con)\n{\n\tint boundary;\n\tint resid;\n\n\tWARN_ON(!data_len(con->out_msg));\n\tWARN_ON(!iov_iter_is_kvec(&con->v2.out_iter));\n\tresid = iov_iter_count(&con->v2.out_iter);\n\n\tboundary = front_len(con->out_msg) + middle_len(con->out_msg);\n\tif (resid > boundary) {\n\t\tresid -= boundary;\n\t\tWARN_ON(resid > MESSAGE_HEAD_PLAIN_LEN);\n\t\tdout(\"%s con %p was sending head\\n\", __func__, con);\n\t\tif (front_len(con->out_msg))\n\t\t\tprepare_zero_front(con, front_len(con->out_msg));\n\t\tif (middle_len(con->out_msg))\n\t\t\tprepare_zero_middle(con, middle_len(con->out_msg));\n\t\tprepare_zero_data(con);\n\t\tWARN_ON(iov_iter_count(&con->v2.out_iter) != resid);\n\t\tcon->v2.out_state = OUT_S_QUEUE_ZEROS;\n\t\treturn;\n\t}\n\n\tboundary = middle_len(con->out_msg);\n\tif (resid > boundary) {\n\t\tresid -= boundary;\n\t\tdout(\"%s con %p was sending front\\n\", __func__, con);\n\t\tprepare_zero_front(con, resid);\n\t\tif (middle_len(con->out_msg))\n\t\t\tprepare_zero_middle(con, middle_len(con->out_msg));\n\t\tprepare_zero_data(con);\n\t\tqueue_zeros(con);\n\t\treturn;\n\t}\n\n\tWARN_ON(!resid);\n\tdout(\"%s con %p was sending middle\\n\", __func__, con);\n\tprepare_zero_middle(con, resid);\n\tprepare_zero_data(con);\n\tqueue_zeros(con);\n}\n\nstatic void revoke_at_queue_data_cont(struct ceph_connection *con)\n{\n\tint sent, resid;  /* current piece of data */\n\n\tWARN_ON(!data_len(con->out_msg));\n\tWARN_ON(!iov_iter_is_bvec(&con->v2.out_iter));\n\tresid = iov_iter_count(&con->v2.out_iter);\n\tWARN_ON(!resid || resid > con->v2.out_bvec.bv_len);\n\tsent = con->v2.out_bvec.bv_len - resid;\n\tdout(\"%s con %p sent %d resid %d\\n\", __func__, con, sent, resid);\n\n\tif (sent) {\n\t\tcon->v2.out_epil.data_crc = ceph_crc32c_page(\n\t\t\tcon->v2.out_epil.data_crc, con->v2.out_bvec.bv_page,\n\t\t\tcon->v2.out_bvec.bv_offset, sent);\n\t\tceph_msg_data_advance(&con->v2.out_cursor, sent);\n\t}\n\tWARN_ON(resid > con->v2.out_cursor.total_resid);\n\tcon->v2.out_epil.data_crc = crc32c_zeros(con->v2.out_epil.data_crc,\n\t\t\t\t\t\tcon->v2.out_cursor.total_resid);\n\n\tcon->v2.out_iter.count -= resid;\n\tout_zero_add(con, con->v2.out_cursor.total_resid);\n\tqueue_zeros(con);\n}\n\nstatic void revoke_at_finish_message(struct ceph_connection *con)\n{\n\tint boundary;\n\tint resid;\n\n\tWARN_ON(!iov_iter_is_kvec(&con->v2.out_iter));\n\tresid = iov_iter_count(&con->v2.out_iter);\n\n\tif (!front_len(con->out_msg) && !middle_len(con->out_msg) &&\n\t    !data_len(con->out_msg)) {\n\t\tWARN_ON(!resid || resid > MESSAGE_HEAD_PLAIN_LEN);\n\t\tdout(\"%s con %p was sending head (empty message) - noop\\n\",\n\t\t     __func__, con);\n\t\treturn;\n\t}\n\n\tboundary = front_len(con->out_msg) + middle_len(con->out_msg) +\n\t\t   CEPH_EPILOGUE_PLAIN_LEN;\n\tif (resid > boundary) {\n\t\tresid -= boundary;\n\t\tWARN_ON(resid > MESSAGE_HEAD_PLAIN_LEN);\n\t\tdout(\"%s con %p was sending head\\n\", __func__, con);\n\t\tif (front_len(con->out_msg))\n\t\t\tprepare_zero_front(con, front_len(con->out_msg));\n\t\tif (middle_len(con->out_msg))\n\t\t\tprepare_zero_middle(con, middle_len(con->out_msg));\n\t\tcon->v2.out_iter.count -= CEPH_EPILOGUE_PLAIN_LEN;\n\t\tWARN_ON(iov_iter_count(&con->v2.out_iter) != resid);\n\t\tcon->v2.out_state = OUT_S_QUEUE_ZEROS;\n\t\treturn;\n\t}\n\n\tboundary = middle_len(con->out_msg) + CEPH_EPILOGUE_PLAIN_LEN;\n\tif (resid > boundary) {\n\t\tresid -= boundary;\n\t\tdout(\"%s con %p was sending front\\n\", __func__, con);\n\t\tprepare_zero_front(con, resid);\n\t\tif (middle_len(con->out_msg))\n\t\t\tprepare_zero_middle(con, middle_len(con->out_msg));\n\t\tcon->v2.out_iter.count -= CEPH_EPILOGUE_PLAIN_LEN;\n\t\tqueue_zeros(con);\n\t\treturn;\n\t}\n\n\tboundary = CEPH_EPILOGUE_PLAIN_LEN;\n\tif (resid > boundary) {\n\t\tresid -= boundary;\n\t\tdout(\"%s con %p was sending middle\\n\", __func__, con);\n\t\tprepare_zero_middle(con, resid);\n\t\tcon->v2.out_iter.count -= CEPH_EPILOGUE_PLAIN_LEN;\n\t\tqueue_zeros(con);\n\t\treturn;\n\t}\n\n\tWARN_ON(!resid);\n\tdout(\"%s con %p was sending epilogue - noop\\n\", __func__, con);\n}\n\nvoid ceph_con_v2_revoke(struct ceph_connection *con)\n{\n\tWARN_ON(con->v2.out_zero);\n\n\tif (con_secure(con)) {\n\t\tWARN_ON(con->v2.out_state != OUT_S_QUEUE_ENC_PAGE &&\n\t\t\tcon->v2.out_state != OUT_S_FINISH_MESSAGE);\n\t\tdout(\"%s con %p secure - noop\\n\", __func__, con);\n\t\treturn;\n\t}\n\n\tswitch (con->v2.out_state) {\n\tcase OUT_S_QUEUE_DATA:\n\t\trevoke_at_queue_data(con);\n\t\tbreak;\n\tcase OUT_S_QUEUE_DATA_CONT:\n\t\trevoke_at_queue_data_cont(con);\n\t\tbreak;\n\tcase OUT_S_FINISH_MESSAGE:\n\t\trevoke_at_finish_message(con);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"bad out_state %d\", con->v2.out_state);\n\t\tbreak;\n\t}\n}\n\nstatic void revoke_at_prepare_read_data(struct ceph_connection *con)\n{\n\tint remaining;\n\tint resid;\n\n\tWARN_ON(con_secure(con));\n\tWARN_ON(!data_len(con->in_msg));\n\tWARN_ON(!iov_iter_is_kvec(&con->v2.in_iter));\n\tresid = iov_iter_count(&con->v2.in_iter);\n\tWARN_ON(!resid);\n\n\tremaining = data_len(con->in_msg) + CEPH_EPILOGUE_PLAIN_LEN;\n\tdout(\"%s con %p resid %d remaining %d\\n\", __func__, con, resid,\n\t     remaining);\n\tcon->v2.in_iter.count -= resid;\n\tset_in_skip(con, resid + remaining);\n\tcon->v2.in_state = IN_S_FINISH_SKIP;\n}\n\nstatic void revoke_at_prepare_read_data_cont(struct ceph_connection *con)\n{\n\tint recved, resid;  /* current piece of data */\n\tint remaining;\n\n\tWARN_ON(con_secure(con));\n\tWARN_ON(!data_len(con->in_msg));\n\tWARN_ON(!iov_iter_is_bvec(&con->v2.in_iter));\n\tresid = iov_iter_count(&con->v2.in_iter);\n\tWARN_ON(!resid || resid > con->v2.in_bvec.bv_len);\n\trecved = con->v2.in_bvec.bv_len - resid;\n\tdout(\"%s con %p recved %d resid %d\\n\", __func__, con, recved, resid);\n\n\tif (recved)\n\t\tceph_msg_data_advance(&con->v2.in_cursor, recved);\n\tWARN_ON(resid > con->v2.in_cursor.total_resid);\n\n\tremaining = CEPH_EPILOGUE_PLAIN_LEN;\n\tdout(\"%s con %p total_resid %zu remaining %d\\n\", __func__, con,\n\t     con->v2.in_cursor.total_resid, remaining);\n\tcon->v2.in_iter.count -= resid;\n\tset_in_skip(con, con->v2.in_cursor.total_resid + remaining);\n\tcon->v2.in_state = IN_S_FINISH_SKIP;\n}\n\nstatic void revoke_at_prepare_read_enc_page(struct ceph_connection *con)\n{\n\tint resid;  /* current enc page (not necessarily data) */\n\n\tWARN_ON(!con_secure(con));\n\tWARN_ON(!iov_iter_is_bvec(&con->v2.in_iter));\n\tresid = iov_iter_count(&con->v2.in_iter);\n\tWARN_ON(!resid || resid > con->v2.in_bvec.bv_len);\n\n\tdout(\"%s con %p resid %d enc_resid %d\\n\", __func__, con, resid,\n\t     con->v2.in_enc_resid);\n\tcon->v2.in_iter.count -= resid;\n\tset_in_skip(con, resid + con->v2.in_enc_resid);\n\tcon->v2.in_state = IN_S_FINISH_SKIP;\n}\n\nstatic void revoke_at_handle_epilogue(struct ceph_connection *con)\n{\n\tint resid;\n\n\tresid = iov_iter_count(&con->v2.in_iter);\n\tWARN_ON(!resid);\n\n\tdout(\"%s con %p resid %d\\n\", __func__, con, resid);\n\tcon->v2.in_iter.count -= resid;\n\tset_in_skip(con, resid);\n\tcon->v2.in_state = IN_S_FINISH_SKIP;\n}\n\nvoid ceph_con_v2_revoke_incoming(struct ceph_connection *con)\n{\n\tswitch (con->v2.in_state) {\n\tcase IN_S_PREPARE_READ_DATA:\n\t\trevoke_at_prepare_read_data(con);\n\t\tbreak;\n\tcase IN_S_PREPARE_READ_DATA_CONT:\n\t\trevoke_at_prepare_read_data_cont(con);\n\t\tbreak;\n\tcase IN_S_PREPARE_READ_ENC_PAGE:\n\t\trevoke_at_prepare_read_enc_page(con);\n\t\tbreak;\n\tcase IN_S_HANDLE_EPILOGUE:\n\t\trevoke_at_handle_epilogue(con);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"bad in_state %d\", con->v2.in_state);\n\t\tbreak;\n\t}\n}\n\nbool ceph_con_v2_opened(struct ceph_connection *con)\n{\n\treturn con->v2.peer_global_seq;\n}\n\nvoid ceph_con_v2_reset_session(struct ceph_connection *con)\n{\n\tcon->v2.client_cookie = 0;\n\tcon->v2.server_cookie = 0;\n\tcon->v2.global_seq = 0;\n\tcon->v2.connect_seq = 0;\n\tcon->v2.peer_global_seq = 0;\n}\n\nvoid ceph_con_v2_reset_protocol(struct ceph_connection *con)\n{\n\tiov_iter_truncate(&con->v2.in_iter, 0);\n\tiov_iter_truncate(&con->v2.out_iter, 0);\n\tcon->v2.out_zero = 0;\n\n\tclear_in_sign_kvecs(con);\n\tclear_out_sign_kvecs(con);\n\tfree_conn_bufs(con);\n\n\tif (con->v2.in_enc_pages) {\n\t\tWARN_ON(!con->v2.in_enc_page_cnt);\n\t\tceph_release_page_vector(con->v2.in_enc_pages,\n\t\t\t\t\t con->v2.in_enc_page_cnt);\n\t\tcon->v2.in_enc_pages = NULL;\n\t\tcon->v2.in_enc_page_cnt = 0;\n\t}\n\tif (con->v2.out_enc_pages) {\n\t\tWARN_ON(!con->v2.out_enc_page_cnt);\n\t\tceph_release_page_vector(con->v2.out_enc_pages,\n\t\t\t\t\t con->v2.out_enc_page_cnt);\n\t\tcon->v2.out_enc_pages = NULL;\n\t\tcon->v2.out_enc_page_cnt = 0;\n\t}\n\n\tcon->v2.con_mode = CEPH_CON_MODE_UNKNOWN;\n\tmemzero_explicit(&con->v2.in_gcm_nonce, CEPH_GCM_IV_LEN);\n\tmemzero_explicit(&con->v2.out_gcm_nonce, CEPH_GCM_IV_LEN);\n\n\tif (con->v2.hmac_tfm) {\n\t\tcrypto_free_shash(con->v2.hmac_tfm);\n\t\tcon->v2.hmac_tfm = NULL;\n\t}\n\tif (con->v2.gcm_req) {\n\t\taead_request_free(con->v2.gcm_req);\n\t\tcon->v2.gcm_req = NULL;\n\t}\n\tif (con->v2.gcm_tfm) {\n\t\tcrypto_free_aead(con->v2.gcm_tfm);\n\t\tcon->v2.gcm_tfm = NULL;\n\t}\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Ceph msgr2 protocol implementation\n *\n * Copyright (C) 2020 Ilya Dryomov <idryomov@gmail.com>\n */\n\n#include <linux/ceph/ceph_debug.h>\n\n#include <crypto/aead.h>\n#include <crypto/algapi.h>  /* for crypto_memneq() */\n#include <crypto/hash.h>\n#include <crypto/sha2.h>\n#include <linux/bvec.h>\n#include <linux/crc32c.h>\n#include <linux/net.h>\n#include <linux/scatterlist.h>\n#include <linux/socket.h>\n#include <linux/sched/mm.h>\n#include <net/sock.h>\n#include <net/tcp.h>\n\n#include <linux/ceph/ceph_features.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/libceph.h>\n#include <linux/ceph/messenger.h>\n\n#include \"crypto.h\"  /* for CEPH_KEY_LEN and CEPH_MAX_CON_SECRET_LEN */\n\n#define FRAME_TAG_HELLO\t\t\t1\n#define FRAME_TAG_AUTH_REQUEST\t\t2\n#define FRAME_TAG_AUTH_BAD_METHOD\t3\n#define FRAME_TAG_AUTH_REPLY_MORE\t4\n#define FRAME_TAG_AUTH_REQUEST_MORE\t5\n#define FRAME_TAG_AUTH_DONE\t\t6\n#define FRAME_TAG_AUTH_SIGNATURE\t7\n#define FRAME_TAG_CLIENT_IDENT\t\t8\n#define FRAME_TAG_SERVER_IDENT\t\t9\n#define FRAME_TAG_IDENT_MISSING_FEATURES 10\n#define FRAME_TAG_SESSION_RECONNECT\t11\n#define FRAME_TAG_SESSION_RESET\t\t12\n#define FRAME_TAG_SESSION_RETRY\t\t13\n#define FRAME_TAG_SESSION_RETRY_GLOBAL\t14\n#define FRAME_TAG_SESSION_RECONNECT_OK\t15\n#define FRAME_TAG_WAIT\t\t\t16\n#define FRAME_TAG_MESSAGE\t\t17\n#define FRAME_TAG_KEEPALIVE2\t\t18\n#define FRAME_TAG_KEEPALIVE2_ACK\t19\n#define FRAME_TAG_ACK\t\t\t20\n\n#define FRAME_LATE_STATUS_ABORTED\t0x1\n#define FRAME_LATE_STATUS_COMPLETE\t0xe\n#define FRAME_LATE_STATUS_ABORTED_MASK\t0xf\n\n#define IN_S_HANDLE_PREAMBLE\t\t1\n#define IN_S_HANDLE_CONTROL\t\t2\n#define IN_S_HANDLE_CONTROL_REMAINDER\t3\n#define IN_S_PREPARE_READ_DATA\t\t4\n#define IN_S_PREPARE_READ_DATA_CONT\t5\n#define IN_S_PREPARE_READ_ENC_PAGE\t6\n#define IN_S_HANDLE_EPILOGUE\t\t7\n#define IN_S_FINISH_SKIP\t\t8\n\n#define OUT_S_QUEUE_DATA\t\t1\n#define OUT_S_QUEUE_DATA_CONT\t\t2\n#define OUT_S_QUEUE_ENC_PAGE\t\t3\n#define OUT_S_QUEUE_ZEROS\t\t4\n#define OUT_S_FINISH_MESSAGE\t\t5\n#define OUT_S_GET_NEXT\t\t\t6\n\n#define CTRL_BODY(p)\t((void *)(p) + CEPH_PREAMBLE_LEN)\n#define FRONT_PAD(p)\t((void *)(p) + CEPH_EPILOGUE_SECURE_LEN)\n#define MIDDLE_PAD(p)\t(FRONT_PAD(p) + CEPH_GCM_BLOCK_LEN)\n#define DATA_PAD(p)\t(MIDDLE_PAD(p) + CEPH_GCM_BLOCK_LEN)\n\n#define CEPH_MSG_FLAGS (MSG_DONTWAIT | MSG_NOSIGNAL)\n\nstatic int do_recvmsg(struct socket *sock, struct iov_iter *it)\n{\n\tstruct msghdr msg = { .msg_flags = CEPH_MSG_FLAGS };\n\tint ret;\n\n\tmsg.msg_iter = *it;\n\twhile (iov_iter_count(it)) {\n\t\tret = sock_recvmsg(sock, &msg, msg.msg_flags);\n\t\tif (ret <= 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tiov_iter_advance(it, ret);\n\t}\n\n\tWARN_ON(msg_data_left(&msg));\n\treturn 1;\n}\n\n/*\n * Read as much as possible.\n *\n * Return:\n *   1 - done, nothing (else) to read\n *   0 - socket is empty, need to wait\n *  <0 - error\n */\nstatic int ceph_tcp_recv(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s con %p %s %zu\\n\", __func__, con,\n\t     iov_iter_is_discard(&con->v2.in_iter) ? \"discard\" : \"need\",\n\t     iov_iter_count(&con->v2.in_iter));\n\tret = do_recvmsg(con->sock, &con->v2.in_iter);\n\tdout(\"%s con %p ret %d left %zu\\n\", __func__, con, ret,\n\t     iov_iter_count(&con->v2.in_iter));\n\treturn ret;\n}\n\nstatic int do_sendmsg(struct socket *sock, struct iov_iter *it)\n{\n\tstruct msghdr msg = { .msg_flags = CEPH_MSG_FLAGS };\n\tint ret;\n\n\tmsg.msg_iter = *it;\n\twhile (iov_iter_count(it)) {\n\t\tret = sock_sendmsg(sock, &msg);\n\t\tif (ret <= 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tiov_iter_advance(it, ret);\n\t}\n\n\tWARN_ON(msg_data_left(&msg));\n\treturn 1;\n}\n\nstatic int do_try_sendpage(struct socket *sock, struct iov_iter *it)\n{\n\tstruct msghdr msg = { .msg_flags = CEPH_MSG_FLAGS };\n\tstruct bio_vec bv;\n\tint ret;\n\n\tif (WARN_ON(!iov_iter_is_bvec(it)))\n\t\treturn -EINVAL;\n\n\twhile (iov_iter_count(it)) {\n\t\t/* iov_iter_iovec() for ITER_BVEC */\n\t\tbvec_set_page(&bv, it->bvec->bv_page,\n\t\t\t      min(iov_iter_count(it),\n\t\t\t\t  it->bvec->bv_len - it->iov_offset),\n\t\t\t      it->bvec->bv_offset + it->iov_offset);\n\n\t\t/*\n\t\t * MSG_SPLICE_PAGES cannot properly handle pages with\n\t\t * page_count == 0, we need to fall back to sendmsg if\n\t\t * that's the case.\n\t\t *\n\t\t * Same goes for slab pages: skb_can_coalesce() allows\n\t\t * coalescing neighboring slab objects into a single frag\n\t\t * which triggers one of hardened usercopy checks.\n\t\t */\n\t\tif (sendpage_ok(bv.bv_page))\n\t\t\tmsg.msg_flags |= MSG_SPLICE_PAGES;\n\t\telse\n\t\t\tmsg.msg_flags &= ~MSG_SPLICE_PAGES;\n\n\t\tiov_iter_bvec(&msg.msg_iter, ITER_SOURCE, &bv, 1, bv.bv_len);\n\t\tret = sock_sendmsg(sock, &msg);\n\t\tif (ret <= 0) {\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tiov_iter_advance(it, ret);\n\t}\n\n\treturn 1;\n}\n\n/*\n * Write as much as possible.  The socket is expected to be corked,\n * so we don't bother with MSG_MORE here.\n *\n * Return:\n *   1 - done, nothing (else) to write\n *   0 - socket is full, need to wait\n *  <0 - error\n */\nstatic int ceph_tcp_send(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s con %p have %zu try_sendpage %d\\n\", __func__, con,\n\t     iov_iter_count(&con->v2.out_iter), con->v2.out_iter_sendpage);\n\tif (con->v2.out_iter_sendpage)\n\t\tret = do_try_sendpage(con->sock, &con->v2.out_iter);\n\telse\n\t\tret = do_sendmsg(con->sock, &con->v2.out_iter);\n\tdout(\"%s con %p ret %d left %zu\\n\", __func__, con, ret,\n\t     iov_iter_count(&con->v2.out_iter));\n\treturn ret;\n}\n\nstatic void add_in_kvec(struct ceph_connection *con, void *buf, int len)\n{\n\tBUG_ON(con->v2.in_kvec_cnt >= ARRAY_SIZE(con->v2.in_kvecs));\n\tWARN_ON(!iov_iter_is_kvec(&con->v2.in_iter));\n\n\tcon->v2.in_kvecs[con->v2.in_kvec_cnt].iov_base = buf;\n\tcon->v2.in_kvecs[con->v2.in_kvec_cnt].iov_len = len;\n\tcon->v2.in_kvec_cnt++;\n\n\tcon->v2.in_iter.nr_segs++;\n\tcon->v2.in_iter.count += len;\n}\n\nstatic void reset_in_kvecs(struct ceph_connection *con)\n{\n\tWARN_ON(iov_iter_count(&con->v2.in_iter));\n\n\tcon->v2.in_kvec_cnt = 0;\n\tiov_iter_kvec(&con->v2.in_iter, ITER_DEST, con->v2.in_kvecs, 0, 0);\n}\n\nstatic void set_in_bvec(struct ceph_connection *con, const struct bio_vec *bv)\n{\n\tWARN_ON(iov_iter_count(&con->v2.in_iter));\n\n\tcon->v2.in_bvec = *bv;\n\tiov_iter_bvec(&con->v2.in_iter, ITER_DEST, &con->v2.in_bvec, 1, bv->bv_len);\n}\n\nstatic void set_in_skip(struct ceph_connection *con, int len)\n{\n\tWARN_ON(iov_iter_count(&con->v2.in_iter));\n\n\tdout(\"%s con %p len %d\\n\", __func__, con, len);\n\tiov_iter_discard(&con->v2.in_iter, ITER_DEST, len);\n}\n\nstatic void add_out_kvec(struct ceph_connection *con, void *buf, int len)\n{\n\tBUG_ON(con->v2.out_kvec_cnt >= ARRAY_SIZE(con->v2.out_kvecs));\n\tWARN_ON(!iov_iter_is_kvec(&con->v2.out_iter));\n\tWARN_ON(con->v2.out_zero);\n\n\tcon->v2.out_kvecs[con->v2.out_kvec_cnt].iov_base = buf;\n\tcon->v2.out_kvecs[con->v2.out_kvec_cnt].iov_len = len;\n\tcon->v2.out_kvec_cnt++;\n\n\tcon->v2.out_iter.nr_segs++;\n\tcon->v2.out_iter.count += len;\n}\n\nstatic void reset_out_kvecs(struct ceph_connection *con)\n{\n\tWARN_ON(iov_iter_count(&con->v2.out_iter));\n\tWARN_ON(con->v2.out_zero);\n\n\tcon->v2.out_kvec_cnt = 0;\n\n\tiov_iter_kvec(&con->v2.out_iter, ITER_SOURCE, con->v2.out_kvecs, 0, 0);\n\tcon->v2.out_iter_sendpage = false;\n}\n\nstatic void set_out_bvec(struct ceph_connection *con, const struct bio_vec *bv,\n\t\t\t bool zerocopy)\n{\n\tWARN_ON(iov_iter_count(&con->v2.out_iter));\n\tWARN_ON(con->v2.out_zero);\n\n\tcon->v2.out_bvec = *bv;\n\tcon->v2.out_iter_sendpage = zerocopy;\n\tiov_iter_bvec(&con->v2.out_iter, ITER_SOURCE, &con->v2.out_bvec, 1,\n\t\t      con->v2.out_bvec.bv_len);\n}\n\nstatic void set_out_bvec_zero(struct ceph_connection *con)\n{\n\tWARN_ON(iov_iter_count(&con->v2.out_iter));\n\tWARN_ON(!con->v2.out_zero);\n\n\tbvec_set_page(&con->v2.out_bvec, ceph_zero_page,\n\t\t      min(con->v2.out_zero, (int)PAGE_SIZE), 0);\n\tcon->v2.out_iter_sendpage = true;\n\tiov_iter_bvec(&con->v2.out_iter, ITER_SOURCE, &con->v2.out_bvec, 1,\n\t\t      con->v2.out_bvec.bv_len);\n}\n\nstatic void out_zero_add(struct ceph_connection *con, int len)\n{\n\tdout(\"%s con %p len %d\\n\", __func__, con, len);\n\tcon->v2.out_zero += len;\n}\n\nstatic void *alloc_conn_buf(struct ceph_connection *con, int len)\n{\n\tvoid *buf;\n\n\tdout(\"%s con %p len %d\\n\", __func__, con, len);\n\n\tif (WARN_ON(con->v2.conn_buf_cnt >= ARRAY_SIZE(con->v2.conn_bufs)))\n\t\treturn NULL;\n\n\tbuf = kvmalloc(len, GFP_NOIO);\n\tif (!buf)\n\t\treturn NULL;\n\n\tcon->v2.conn_bufs[con->v2.conn_buf_cnt++] = buf;\n\treturn buf;\n}\n\nstatic void free_conn_bufs(struct ceph_connection *con)\n{\n\twhile (con->v2.conn_buf_cnt)\n\t\tkvfree(con->v2.conn_bufs[--con->v2.conn_buf_cnt]);\n}\n\nstatic void add_in_sign_kvec(struct ceph_connection *con, void *buf, int len)\n{\n\tBUG_ON(con->v2.in_sign_kvec_cnt >= ARRAY_SIZE(con->v2.in_sign_kvecs));\n\n\tcon->v2.in_sign_kvecs[con->v2.in_sign_kvec_cnt].iov_base = buf;\n\tcon->v2.in_sign_kvecs[con->v2.in_sign_kvec_cnt].iov_len = len;\n\tcon->v2.in_sign_kvec_cnt++;\n}\n\nstatic void clear_in_sign_kvecs(struct ceph_connection *con)\n{\n\tcon->v2.in_sign_kvec_cnt = 0;\n}\n\nstatic void add_out_sign_kvec(struct ceph_connection *con, void *buf, int len)\n{\n\tBUG_ON(con->v2.out_sign_kvec_cnt >= ARRAY_SIZE(con->v2.out_sign_kvecs));\n\n\tcon->v2.out_sign_kvecs[con->v2.out_sign_kvec_cnt].iov_base = buf;\n\tcon->v2.out_sign_kvecs[con->v2.out_sign_kvec_cnt].iov_len = len;\n\tcon->v2.out_sign_kvec_cnt++;\n}\n\nstatic void clear_out_sign_kvecs(struct ceph_connection *con)\n{\n\tcon->v2.out_sign_kvec_cnt = 0;\n}\n\nstatic bool con_secure(struct ceph_connection *con)\n{\n\treturn con->v2.con_mode == CEPH_CON_MODE_SECURE;\n}\n\nstatic int front_len(const struct ceph_msg *msg)\n{\n\treturn le32_to_cpu(msg->hdr.front_len);\n}\n\nstatic int middle_len(const struct ceph_msg *msg)\n{\n\treturn le32_to_cpu(msg->hdr.middle_len);\n}\n\nstatic int data_len(const struct ceph_msg *msg)\n{\n\treturn le32_to_cpu(msg->hdr.data_len);\n}\n\nstatic bool need_padding(int len)\n{\n\treturn !IS_ALIGNED(len, CEPH_GCM_BLOCK_LEN);\n}\n\nstatic int padded_len(int len)\n{\n\treturn ALIGN(len, CEPH_GCM_BLOCK_LEN);\n}\n\nstatic int padding_len(int len)\n{\n\treturn padded_len(len) - len;\n}\n\n/* preamble + control segment */\nstatic int head_onwire_len(int ctrl_len, bool secure)\n{\n\tint head_len;\n\tint rem_len;\n\n\tBUG_ON(ctrl_len < 0 || ctrl_len > CEPH_MSG_MAX_CONTROL_LEN);\n\n\tif (secure) {\n\t\thead_len = CEPH_PREAMBLE_SECURE_LEN;\n\t\tif (ctrl_len > CEPH_PREAMBLE_INLINE_LEN) {\n\t\t\trem_len = ctrl_len - CEPH_PREAMBLE_INLINE_LEN;\n\t\t\thead_len += padded_len(rem_len) + CEPH_GCM_TAG_LEN;\n\t\t}\n\t} else {\n\t\thead_len = CEPH_PREAMBLE_PLAIN_LEN;\n\t\tif (ctrl_len)\n\t\t\thead_len += ctrl_len + CEPH_CRC_LEN;\n\t}\n\treturn head_len;\n}\n\n/* front, middle and data segments + epilogue */\nstatic int __tail_onwire_len(int front_len, int middle_len, int data_len,\n\t\t\t     bool secure)\n{\n\tBUG_ON(front_len < 0 || front_len > CEPH_MSG_MAX_FRONT_LEN ||\n\t       middle_len < 0 || middle_len > CEPH_MSG_MAX_MIDDLE_LEN ||\n\t       data_len < 0 || data_len > CEPH_MSG_MAX_DATA_LEN);\n\n\tif (!front_len && !middle_len && !data_len)\n\t\treturn 0;\n\n\tif (!secure)\n\t\treturn front_len + middle_len + data_len +\n\t\t       CEPH_EPILOGUE_PLAIN_LEN;\n\n\treturn padded_len(front_len) + padded_len(middle_len) +\n\t       padded_len(data_len) + CEPH_EPILOGUE_SECURE_LEN;\n}\n\nstatic int tail_onwire_len(const struct ceph_msg *msg, bool secure)\n{\n\treturn __tail_onwire_len(front_len(msg), middle_len(msg),\n\t\t\t\t data_len(msg), secure);\n}\n\n/* head_onwire_len(sizeof(struct ceph_msg_header2), false) */\n#define MESSAGE_HEAD_PLAIN_LEN\t(CEPH_PREAMBLE_PLAIN_LEN +\t\t\\\n\t\t\t\t sizeof(struct ceph_msg_header2) +\t\\\n\t\t\t\t CEPH_CRC_LEN)\n\nstatic const int frame_aligns[] = {\n\tsizeof(void *),\n\tsizeof(void *),\n\tsizeof(void *),\n\tPAGE_SIZE\n};\n\n/*\n * Discards trailing empty segments, unless there is just one segment.\n * A frame always has at least one (possibly empty) segment.\n */\nstatic int calc_segment_count(const int *lens, int len_cnt)\n{\n\tint i;\n\n\tfor (i = len_cnt - 1; i >= 0; i--) {\n\t\tif (lens[i])\n\t\t\treturn i + 1;\n\t}\n\n\treturn 1;\n}\n\nstatic void init_frame_desc(struct ceph_frame_desc *desc, int tag,\n\t\t\t    const int *lens, int len_cnt)\n{\n\tint i;\n\n\tmemset(desc, 0, sizeof(*desc));\n\n\tdesc->fd_tag = tag;\n\tdesc->fd_seg_cnt = calc_segment_count(lens, len_cnt);\n\tBUG_ON(desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT);\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tdesc->fd_lens[i] = lens[i];\n\t\tdesc->fd_aligns[i] = frame_aligns[i];\n\t}\n}\n\n/*\n * Preamble crc covers everything up to itself (28 bytes) and\n * is calculated and verified irrespective of the connection mode\n * (i.e. even if the frame is encrypted).\n */\nstatic void encode_preamble(const struct ceph_frame_desc *desc, void *p)\n{\n\tvoid *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN;\n\tvoid *start = p;\n\tint i;\n\n\tmemset(p, 0, CEPH_PREAMBLE_LEN);\n\n\tceph_encode_8(&p, desc->fd_tag);\n\tceph_encode_8(&p, desc->fd_seg_cnt);\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tceph_encode_32(&p, desc->fd_lens[i]);\n\t\tceph_encode_16(&p, desc->fd_aligns[i]);\n\t}\n\n\tput_unaligned_le32(crc32c(0, start, crcp - start), crcp);\n}\n\nstatic int decode_preamble(void *p, struct ceph_frame_desc *desc)\n{\n\tvoid *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN;\n\tu32 crc, expected_crc;\n\tint i;\n\n\tcrc = crc32c(0, p, crcp - p);\n\texpected_crc = get_unaligned_le32(crcp);\n\tif (crc != expected_crc) {\n\t\tpr_err(\"bad preamble crc, calculated %u, expected %u\\n\",\n\t\t       crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\n\tmemset(desc, 0, sizeof(*desc));\n\n\tdesc->fd_tag = ceph_decode_8(&p);\n\tdesc->fd_seg_cnt = ceph_decode_8(&p);\n\tif (desc->fd_seg_cnt < 1 ||\n\t    desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT) {\n\t\tpr_err(\"bad segment count %d\\n\", desc->fd_seg_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tdesc->fd_lens[i] = ceph_decode_32(&p);\n\t\tdesc->fd_aligns[i] = ceph_decode_16(&p);\n\t}\n\n\tif (desc->fd_lens[0] < 0 ||\n\t    desc->fd_lens[0] > CEPH_MSG_MAX_CONTROL_LEN) {\n\t\tpr_err(\"bad control segment length %d\\n\", desc->fd_lens[0]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[1] < 0 ||\n\t    desc->fd_lens[1] > CEPH_MSG_MAX_FRONT_LEN) {\n\t\tpr_err(\"bad front segment length %d\\n\", desc->fd_lens[1]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[2] < 0 ||\n\t    desc->fd_lens[2] > CEPH_MSG_MAX_MIDDLE_LEN) {\n\t\tpr_err(\"bad middle segment length %d\\n\", desc->fd_lens[2]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[3] < 0 ||\n\t    desc->fd_lens[3] > CEPH_MSG_MAX_DATA_LEN) {\n\t\tpr_err(\"bad data segment length %d\\n\", desc->fd_lens[3]);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * This would fire for FRAME_TAG_WAIT (it has one empty\n\t * segment), but we should never get it as client.\n\t */\n\tif (!desc->fd_lens[desc->fd_seg_cnt - 1]) {\n\t\tpr_err(\"last segment empty, segment count %d\\n\",\n\t\t       desc->fd_seg_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void encode_epilogue_plain(struct ceph_connection *con, bool aborted)\n{\n\tcon->v2.out_epil.late_status = aborted ? FRAME_LATE_STATUS_ABORTED :\n\t\t\t\t\t\t FRAME_LATE_STATUS_COMPLETE;\n\tcpu_to_le32s(&con->v2.out_epil.front_crc);\n\tcpu_to_le32s(&con->v2.out_epil.middle_crc);\n\tcpu_to_le32s(&con->v2.out_epil.data_crc);\n}\n\nstatic void encode_epilogue_secure(struct ceph_connection *con, bool aborted)\n{\n\tmemset(&con->v2.out_epil, 0, sizeof(con->v2.out_epil));\n\tcon->v2.out_epil.late_status = aborted ? FRAME_LATE_STATUS_ABORTED :\n\t\t\t\t\t\t FRAME_LATE_STATUS_COMPLETE;\n}\n\nstatic int decode_epilogue(void *p, u32 *front_crc, u32 *middle_crc,\n\t\t\t   u32 *data_crc)\n{\n\tu8 late_status;\n\n\tlate_status = ceph_decode_8(&p);\n\tif ((late_status & FRAME_LATE_STATUS_ABORTED_MASK) !=\n\t\t\tFRAME_LATE_STATUS_COMPLETE) {\n\t\t/* we should never get an aborted message as client */\n\t\tpr_err(\"bad late_status 0x%x\\n\", late_status);\n\t\treturn -EINVAL;\n\t}\n\n\tif (front_crc && middle_crc && data_crc) {\n\t\t*front_crc = ceph_decode_32(&p);\n\t\t*middle_crc = ceph_decode_32(&p);\n\t\t*data_crc = ceph_decode_32(&p);\n\t}\n\n\treturn 0;\n}\n\nstatic void fill_header(struct ceph_msg_header *hdr,\n\t\t\tconst struct ceph_msg_header2 *hdr2,\n\t\t\tint front_len, int middle_len, int data_len,\n\t\t\tconst struct ceph_entity_name *peer_name)\n{\n\thdr->seq = hdr2->seq;\n\thdr->tid = hdr2->tid;\n\thdr->type = hdr2->type;\n\thdr->priority = hdr2->priority;\n\thdr->version = hdr2->version;\n\thdr->front_len = cpu_to_le32(front_len);\n\thdr->middle_len = cpu_to_le32(middle_len);\n\thdr->data_len = cpu_to_le32(data_len);\n\thdr->data_off = hdr2->data_off;\n\thdr->src = *peer_name;\n\thdr->compat_version = hdr2->compat_version;\n\thdr->reserved = 0;\n\thdr->crc = 0;\n}\n\nstatic void fill_header2(struct ceph_msg_header2 *hdr2,\n\t\t\t const struct ceph_msg_header *hdr, u64 ack_seq)\n{\n\thdr2->seq = hdr->seq;\n\thdr2->tid = hdr->tid;\n\thdr2->type = hdr->type;\n\thdr2->priority = hdr->priority;\n\thdr2->version = hdr->version;\n\thdr2->data_pre_padding_len = 0;\n\thdr2->data_off = hdr->data_off;\n\thdr2->ack_seq = cpu_to_le64(ack_seq);\n\thdr2->flags = 0;\n\thdr2->compat_version = hdr->compat_version;\n\thdr2->reserved = 0;\n}\n\nstatic int verify_control_crc(struct ceph_connection *con)\n{\n\tint ctrl_len = con->v2.in_desc.fd_lens[0];\n\tu32 crc, expected_crc;\n\n\tWARN_ON(con->v2.in_kvecs[0].iov_len != ctrl_len);\n\tWARN_ON(con->v2.in_kvecs[1].iov_len != CEPH_CRC_LEN);\n\n\tcrc = crc32c(-1, con->v2.in_kvecs[0].iov_base, ctrl_len);\n\texpected_crc = get_unaligned_le32(con->v2.in_kvecs[1].iov_base);\n\tif (crc != expected_crc) {\n\t\tpr_err(\"bad control crc, calculated %u, expected %u\\n\",\n\t\t       crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\n\treturn 0;\n}\n\nstatic int verify_epilogue_crcs(struct ceph_connection *con, u32 front_crc,\n\t\t\t\tu32 middle_crc, u32 data_crc)\n{\n\tif (front_len(con->in_msg)) {\n\t\tcon->in_front_crc = crc32c(-1, con->in_msg->front.iov_base,\n\t\t\t\t\t   front_len(con->in_msg));\n\t} else {\n\t\tWARN_ON(!middle_len(con->in_msg) && !data_len(con->in_msg));\n\t\tcon->in_front_crc = -1;\n\t}\n\n\tif (middle_len(con->in_msg))\n\t\tcon->in_middle_crc = crc32c(-1,\n\t\t\t\t\t    con->in_msg->middle->vec.iov_base,\n\t\t\t\t\t    middle_len(con->in_msg));\n\telse if (data_len(con->in_msg))\n\t\tcon->in_middle_crc = -1;\n\telse\n\t\tcon->in_middle_crc = 0;\n\n\tif (!data_len(con->in_msg))\n\t\tcon->in_data_crc = 0;\n\n\tdout(\"%s con %p msg %p crcs %u %u %u\\n\", __func__, con, con->in_msg,\n\t     con->in_front_crc, con->in_middle_crc, con->in_data_crc);\n\n\tif (con->in_front_crc != front_crc) {\n\t\tpr_err(\"bad front crc, calculated %u, expected %u\\n\",\n\t\t       con->in_front_crc, front_crc);\n\t\treturn -EBADMSG;\n\t}\n\tif (con->in_middle_crc != middle_crc) {\n\t\tpr_err(\"bad middle crc, calculated %u, expected %u\\n\",\n\t\t       con->in_middle_crc, middle_crc);\n\t\treturn -EBADMSG;\n\t}\n\tif (con->in_data_crc != data_crc) {\n\t\tpr_err(\"bad data crc, calculated %u, expected %u\\n\",\n\t\t       con->in_data_crc, data_crc);\n\t\treturn -EBADMSG;\n\t}\n\n\treturn 0;\n}\n\nstatic int setup_crypto(struct ceph_connection *con,\n\t\t\tconst u8 *session_key, int session_key_len,\n\t\t\tconst u8 *con_secret, int con_secret_len)\n{\n\tunsigned int noio_flag;\n\tint ret;\n\n\tdout(\"%s con %p con_mode %d session_key_len %d con_secret_len %d\\n\",\n\t     __func__, con, con->v2.con_mode, session_key_len, con_secret_len);\n\tWARN_ON(con->v2.hmac_tfm || con->v2.gcm_tfm || con->v2.gcm_req);\n\n\tif (con->v2.con_mode != CEPH_CON_MODE_CRC &&\n\t    con->v2.con_mode != CEPH_CON_MODE_SECURE) {\n\t\tpr_err(\"bad con_mode %d\\n\", con->v2.con_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!session_key_len) {\n\t\tWARN_ON(con->v2.con_mode != CEPH_CON_MODE_CRC);\n\t\tWARN_ON(con_secret_len);\n\t\treturn 0;  /* auth_none */\n\t}\n\n\tnoio_flag = memalloc_noio_save();\n\tcon->v2.hmac_tfm = crypto_alloc_shash(\"hmac(sha256)\", 0, 0);\n\tmemalloc_noio_restore(noio_flag);\n\tif (IS_ERR(con->v2.hmac_tfm)) {\n\t\tret = PTR_ERR(con->v2.hmac_tfm);\n\t\tcon->v2.hmac_tfm = NULL;\n\t\tpr_err(\"failed to allocate hmac tfm context: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tWARN_ON((unsigned long)session_key &\n\t\tcrypto_shash_alignmask(con->v2.hmac_tfm));\n\tret = crypto_shash_setkey(con->v2.hmac_tfm, session_key,\n\t\t\t\t  session_key_len);\n\tif (ret) {\n\t\tpr_err(\"failed to set hmac key: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (con->v2.con_mode == CEPH_CON_MODE_CRC) {\n\t\tWARN_ON(con_secret_len);\n\t\treturn 0;  /* auth_x, plain mode */\n\t}\n\n\tif (con_secret_len < CEPH_GCM_KEY_LEN + 2 * CEPH_GCM_IV_LEN) {\n\t\tpr_err(\"con_secret too small %d\\n\", con_secret_len);\n\t\treturn -EINVAL;\n\t}\n\n\tnoio_flag = memalloc_noio_save();\n\tcon->v2.gcm_tfm = crypto_alloc_aead(\"gcm(aes)\", 0, 0);\n\tmemalloc_noio_restore(noio_flag);\n\tif (IS_ERR(con->v2.gcm_tfm)) {\n\t\tret = PTR_ERR(con->v2.gcm_tfm);\n\t\tcon->v2.gcm_tfm = NULL;\n\t\tpr_err(\"failed to allocate gcm tfm context: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tWARN_ON((unsigned long)con_secret &\n\t\tcrypto_aead_alignmask(con->v2.gcm_tfm));\n\tret = crypto_aead_setkey(con->v2.gcm_tfm, con_secret, CEPH_GCM_KEY_LEN);\n\tif (ret) {\n\t\tpr_err(\"failed to set gcm key: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tWARN_ON(crypto_aead_ivsize(con->v2.gcm_tfm) != CEPH_GCM_IV_LEN);\n\tret = crypto_aead_setauthsize(con->v2.gcm_tfm, CEPH_GCM_TAG_LEN);\n\tif (ret) {\n\t\tpr_err(\"failed to set gcm tag size: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcon->v2.gcm_req = aead_request_alloc(con->v2.gcm_tfm, GFP_NOIO);\n\tif (!con->v2.gcm_req) {\n\t\tpr_err(\"failed to allocate gcm request\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcrypto_init_wait(&con->v2.gcm_wait);\n\taead_request_set_callback(con->v2.gcm_req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t  crypto_req_done, &con->v2.gcm_wait);\n\n\tmemcpy(&con->v2.in_gcm_nonce, con_secret + CEPH_GCM_KEY_LEN,\n\t       CEPH_GCM_IV_LEN);\n\tmemcpy(&con->v2.out_gcm_nonce,\n\t       con_secret + CEPH_GCM_KEY_LEN + CEPH_GCM_IV_LEN,\n\t       CEPH_GCM_IV_LEN);\n\treturn 0;  /* auth_x, secure mode */\n}\n\nstatic int hmac_sha256(struct ceph_connection *con, const struct kvec *kvecs,\n\t\t       int kvec_cnt, u8 *hmac)\n{\n\tSHASH_DESC_ON_STACK(desc, con->v2.hmac_tfm);  /* tfm arg is ignored */\n\tint ret;\n\tint i;\n\n\tdout(\"%s con %p hmac_tfm %p kvec_cnt %d\\n\", __func__, con,\n\t     con->v2.hmac_tfm, kvec_cnt);\n\n\tif (!con->v2.hmac_tfm) {\n\t\tmemset(hmac, 0, SHA256_DIGEST_SIZE);\n\t\treturn 0;  /* auth_none */\n\t}\n\n\tdesc->tfm = con->v2.hmac_tfm;\n\tret = crypto_shash_init(desc);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < kvec_cnt; i++) {\n\t\tWARN_ON((unsigned long)kvecs[i].iov_base &\n\t\t\tcrypto_shash_alignmask(con->v2.hmac_tfm));\n\t\tret = crypto_shash_update(desc, kvecs[i].iov_base,\n\t\t\t\t\t  kvecs[i].iov_len);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = crypto_shash_final(desc, hmac);\n\nout:\n\tshash_desc_zero(desc);\n\treturn ret;  /* auth_x, both plain and secure modes */\n}\n\nstatic void gcm_inc_nonce(struct ceph_gcm_nonce *nonce)\n{\n\tu64 counter;\n\n\tcounter = le64_to_cpu(nonce->counter);\n\tnonce->counter = cpu_to_le64(counter + 1);\n}\n\nstatic int gcm_crypt(struct ceph_connection *con, bool encrypt,\n\t\t     struct scatterlist *src, struct scatterlist *dst,\n\t\t     int src_len)\n{\n\tstruct ceph_gcm_nonce *nonce;\n\tint ret;\n\n\tnonce = encrypt ? &con->v2.out_gcm_nonce : &con->v2.in_gcm_nonce;\n\n\taead_request_set_ad(con->v2.gcm_req, 0);  /* no AAD */\n\taead_request_set_crypt(con->v2.gcm_req, src, dst, src_len, (u8 *)nonce);\n\tret = crypto_wait_req(encrypt ? crypto_aead_encrypt(con->v2.gcm_req) :\n\t\t\t\t\tcrypto_aead_decrypt(con->v2.gcm_req),\n\t\t\t      &con->v2.gcm_wait);\n\tif (ret)\n\t\treturn ret;\n\n\tgcm_inc_nonce(nonce);\n\treturn 0;\n}\n\nstatic void get_bvec_at(struct ceph_msg_data_cursor *cursor,\n\t\t\tstruct bio_vec *bv)\n{\n\tstruct page *page;\n\tsize_t off, len;\n\n\tWARN_ON(!cursor->total_resid);\n\n\t/* skip zero-length data items */\n\twhile (!cursor->resid)\n\t\tceph_msg_data_advance(cursor, 0);\n\n\t/* get a piece of data, cursor isn't advanced */\n\tpage = ceph_msg_data_next(cursor, &off, &len);\n\tbvec_set_page(bv, page, len, off);\n}\n\nstatic int calc_sg_cnt(void *buf, int buf_len)\n{\n\tint sg_cnt;\n\n\tif (!buf_len)\n\t\treturn 0;\n\n\tsg_cnt = need_padding(buf_len) ? 1 : 0;\n\tif (is_vmalloc_addr(buf)) {\n\t\tWARN_ON(offset_in_page(buf));\n\t\tsg_cnt += PAGE_ALIGN(buf_len) >> PAGE_SHIFT;\n\t} else {\n\t\tsg_cnt++;\n\t}\n\n\treturn sg_cnt;\n}\n\nstatic int calc_sg_cnt_cursor(struct ceph_msg_data_cursor *cursor)\n{\n\tint data_len = cursor->total_resid;\n\tstruct bio_vec bv;\n\tint sg_cnt;\n\n\tif (!data_len)\n\t\treturn 0;\n\n\tsg_cnt = need_padding(data_len) ? 1 : 0;\n\tdo {\n\t\tget_bvec_at(cursor, &bv);\n\t\tsg_cnt++;\n\n\t\tceph_msg_data_advance(cursor, bv.bv_len);\n\t} while (cursor->total_resid);\n\n\treturn sg_cnt;\n}\n\nstatic void init_sgs(struct scatterlist **sg, void *buf, int buf_len, u8 *pad)\n{\n\tvoid *end = buf + buf_len;\n\tstruct page *page;\n\tint len;\n\tvoid *p;\n\n\tif (!buf_len)\n\t\treturn;\n\n\tif (is_vmalloc_addr(buf)) {\n\t\tp = buf;\n\t\tdo {\n\t\t\tpage = vmalloc_to_page(p);\n\t\t\tlen = min_t(int, end - p, PAGE_SIZE);\n\t\t\tWARN_ON(!page || !len || offset_in_page(p));\n\t\t\tsg_set_page(*sg, page, len, 0);\n\t\t\t*sg = sg_next(*sg);\n\t\t\tp += len;\n\t\t} while (p != end);\n\t} else {\n\t\tsg_set_buf(*sg, buf, buf_len);\n\t\t*sg = sg_next(*sg);\n\t}\n\n\tif (need_padding(buf_len)) {\n\t\tsg_set_buf(*sg, pad, padding_len(buf_len));\n\t\t*sg = sg_next(*sg);\n\t}\n}\n\nstatic void init_sgs_cursor(struct scatterlist **sg,\n\t\t\t    struct ceph_msg_data_cursor *cursor, u8 *pad)\n{\n\tint data_len = cursor->total_resid;\n\tstruct bio_vec bv;\n\n\tif (!data_len)\n\t\treturn;\n\n\tdo {\n\t\tget_bvec_at(cursor, &bv);\n\t\tsg_set_page(*sg, bv.bv_page, bv.bv_len, bv.bv_offset);\n\t\t*sg = sg_next(*sg);\n\n\t\tceph_msg_data_advance(cursor, bv.bv_len);\n\t} while (cursor->total_resid);\n\n\tif (need_padding(data_len)) {\n\t\tsg_set_buf(*sg, pad, padding_len(data_len));\n\t\t*sg = sg_next(*sg);\n\t}\n}\n\nstatic int setup_message_sgs(struct sg_table *sgt, struct ceph_msg *msg,\n\t\t\t     u8 *front_pad, u8 *middle_pad, u8 *data_pad,\n\t\t\t     void *epilogue, bool add_tag)\n{\n\tstruct ceph_msg_data_cursor cursor;\n\tstruct scatterlist *cur_sg;\n\tint sg_cnt;\n\tint ret;\n\n\tif (!front_len(msg) && !middle_len(msg) && !data_len(msg))\n\t\treturn 0;\n\n\tsg_cnt = 1;  /* epilogue + [auth tag] */\n\tif (front_len(msg))\n\t\tsg_cnt += calc_sg_cnt(msg->front.iov_base,\n\t\t\t\t      front_len(msg));\n\tif (middle_len(msg))\n\t\tsg_cnt += calc_sg_cnt(msg->middle->vec.iov_base,\n\t\t\t\t      middle_len(msg));\n\tif (data_len(msg)) {\n\t\tceph_msg_data_cursor_init(&cursor, msg, data_len(msg));\n\t\tsg_cnt += calc_sg_cnt_cursor(&cursor);\n\t}\n\n\tret = sg_alloc_table(sgt, sg_cnt, GFP_NOIO);\n\tif (ret)\n\t\treturn ret;\n\n\tcur_sg = sgt->sgl;\n\tif (front_len(msg))\n\t\tinit_sgs(&cur_sg, msg->front.iov_base, front_len(msg),\n\t\t\t front_pad);\n\tif (middle_len(msg))\n\t\tinit_sgs(&cur_sg, msg->middle->vec.iov_base, middle_len(msg),\n\t\t\t middle_pad);\n\tif (data_len(msg)) {\n\t\tceph_msg_data_cursor_init(&cursor, msg, data_len(msg));\n\t\tinit_sgs_cursor(&cur_sg, &cursor, data_pad);\n\t}\n\n\tWARN_ON(!sg_is_last(cur_sg));\n\tsg_set_buf(cur_sg, epilogue,\n\t\t   CEPH_GCM_BLOCK_LEN + (add_tag ? CEPH_GCM_TAG_LEN : 0));\n\treturn 0;\n}\n\nstatic int decrypt_preamble(struct ceph_connection *con)\n{\n\tstruct scatterlist sg;\n\n\tsg_init_one(&sg, con->v2.in_buf, CEPH_PREAMBLE_SECURE_LEN);\n\treturn gcm_crypt(con, false, &sg, &sg, CEPH_PREAMBLE_SECURE_LEN);\n}\n\nstatic int decrypt_control_remainder(struct ceph_connection *con)\n{\n\tint ctrl_len = con->v2.in_desc.fd_lens[0];\n\tint rem_len = ctrl_len - CEPH_PREAMBLE_INLINE_LEN;\n\tint pt_len = padding_len(rem_len) + CEPH_GCM_TAG_LEN;\n\tstruct scatterlist sgs[2];\n\n\tWARN_ON(con->v2.in_kvecs[0].iov_len != rem_len);\n\tWARN_ON(con->v2.in_kvecs[1].iov_len != pt_len);\n\n\tsg_init_table(sgs, 2);\n\tsg_set_buf(&sgs[0], con->v2.in_kvecs[0].iov_base, rem_len);\n\tsg_set_buf(&sgs[1], con->v2.in_buf, pt_len);\n\n\treturn gcm_crypt(con, false, sgs, sgs,\n\t\t\t padded_len(rem_len) + CEPH_GCM_TAG_LEN);\n}\n\nstatic int decrypt_tail(struct ceph_connection *con)\n{\n\tstruct sg_table enc_sgt = {};\n\tstruct sg_table sgt = {};\n\tint tail_len;\n\tint ret;\n\n\ttail_len = tail_onwire_len(con->in_msg, true);\n\tret = sg_alloc_table_from_pages(&enc_sgt, con->v2.in_enc_pages,\n\t\t\t\t\tcon->v2.in_enc_page_cnt, 0, tail_len,\n\t\t\t\t\tGFP_NOIO);\n\tif (ret)\n\t\tgoto out;\n\n\tret = setup_message_sgs(&sgt, con->in_msg, FRONT_PAD(con->v2.in_buf),\n\t\t\tMIDDLE_PAD(con->v2.in_buf), DATA_PAD(con->v2.in_buf),\n\t\t\tcon->v2.in_buf, true);\n\tif (ret)\n\t\tgoto out;\n\n\tdout(\"%s con %p msg %p enc_page_cnt %d sg_cnt %d\\n\", __func__, con,\n\t     con->in_msg, con->v2.in_enc_page_cnt, sgt.orig_nents);\n\tret = gcm_crypt(con, false, enc_sgt.sgl, sgt.sgl, tail_len);\n\tif (ret)\n\t\tgoto out;\n\n\tWARN_ON(!con->v2.in_enc_page_cnt);\n\tceph_release_page_vector(con->v2.in_enc_pages,\n\t\t\t\t con->v2.in_enc_page_cnt);\n\tcon->v2.in_enc_pages = NULL;\n\tcon->v2.in_enc_page_cnt = 0;\n\nout:\n\tsg_free_table(&sgt);\n\tsg_free_table(&enc_sgt);\n\treturn ret;\n}\n\nstatic int prepare_banner(struct ceph_connection *con)\n{\n\tint buf_len = CEPH_BANNER_V2_LEN + 2 + 8 + 8;\n\tvoid *buf, *p;\n\n\tbuf = alloc_conn_buf(con, buf_len);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tp = buf;\n\tceph_encode_copy(&p, CEPH_BANNER_V2, CEPH_BANNER_V2_LEN);\n\tceph_encode_16(&p, sizeof(u64) + sizeof(u64));\n\tceph_encode_64(&p, CEPH_MSGR2_SUPPORTED_FEATURES);\n\tceph_encode_64(&p, CEPH_MSGR2_REQUIRED_FEATURES);\n\tWARN_ON(p != buf + buf_len);\n\n\tadd_out_kvec(con, buf, buf_len);\n\tadd_out_sign_kvec(con, buf, buf_len);\n\tceph_con_flag_set(con, CEPH_CON_F_WRITE_PENDING);\n\treturn 0;\n}\n\n/*\n * base:\n *   preamble\n *   control body (ctrl_len bytes)\n *   space for control crc\n *\n * extdata (optional):\n *   control body (extdata_len bytes)\n *\n * Compute control crc and gather base and extdata into:\n *\n *   preamble\n *   control body (ctrl_len + extdata_len bytes)\n *   control crc\n *\n * Preamble should already be encoded at the start of base.\n */\nstatic void prepare_head_plain(struct ceph_connection *con, void *base,\n\t\t\t       int ctrl_len, void *extdata, int extdata_len,\n\t\t\t       bool to_be_signed)\n{\n\tint base_len = CEPH_PREAMBLE_LEN + ctrl_len + CEPH_CRC_LEN;\n\tvoid *crcp = base + base_len - CEPH_CRC_LEN;\n\tu32 crc;\n\n\tcrc = crc32c(-1, CTRL_BODY(base), ctrl_len);\n\tif (extdata_len)\n\t\tcrc = crc32c(crc, extdata, extdata_len);\n\tput_unaligned_le32(crc, crcp);\n\n\tif (!extdata_len) {\n\t\tadd_out_kvec(con, base, base_len);\n\t\tif (to_be_signed)\n\t\t\tadd_out_sign_kvec(con, base, base_len);\n\t\treturn;\n\t}\n\n\tadd_out_kvec(con, base, crcp - base);\n\tadd_out_kvec(con, extdata, extdata_len);\n\tadd_out_kvec(con, crcp, CEPH_CRC_LEN);\n\tif (to_be_signed) {\n\t\tadd_out_sign_kvec(con, base, crcp - base);\n\t\tadd_out_sign_kvec(con, extdata, extdata_len);\n\t\tadd_out_sign_kvec(con, crcp, CEPH_CRC_LEN);\n\t}\n}\n\nstatic int prepare_head_secure_small(struct ceph_connection *con,\n\t\t\t\t     void *base, int ctrl_len)\n{\n\tstruct scatterlist sg;\n\tint ret;\n\n\t/* inline buffer padding? */\n\tif (ctrl_len < CEPH_PREAMBLE_INLINE_LEN)\n\t\tmemset(CTRL_BODY(base) + ctrl_len, 0,\n\t\t       CEPH_PREAMBLE_INLINE_LEN - ctrl_len);\n\n\tsg_init_one(&sg, base, CEPH_PREAMBLE_SECURE_LEN);\n\tret = gcm_crypt(con, true, &sg, &sg,\n\t\t\tCEPH_PREAMBLE_SECURE_LEN - CEPH_GCM_TAG_LEN);\n\tif (ret)\n\t\treturn ret;\n\n\tadd_out_kvec(con, base, CEPH_PREAMBLE_SECURE_LEN);\n\treturn 0;\n}\n\n/*\n * base:\n *   preamble\n *   control body (ctrl_len bytes)\n *   space for padding, if needed\n *   space for control remainder auth tag\n *   space for preamble auth tag\n *\n * Encrypt preamble and the inline portion, then encrypt the remainder\n * and gather into:\n *\n *   preamble\n *   control body (48 bytes)\n *   preamble auth tag\n *   control body (ctrl_len - 48 bytes)\n *   zero padding, if needed\n *   control remainder auth tag\n *\n * Preamble should already be encoded at the start of base.\n */\nstatic int prepare_head_secure_big(struct ceph_connection *con,\n\t\t\t\t   void *base, int ctrl_len)\n{\n\tint rem_len = ctrl_len - CEPH_PREAMBLE_INLINE_LEN;\n\tvoid *rem = CTRL_BODY(base) + CEPH_PREAMBLE_INLINE_LEN;\n\tvoid *rem_tag = rem + padded_len(rem_len);\n\tvoid *pmbl_tag = rem_tag + CEPH_GCM_TAG_LEN;\n\tstruct scatterlist sgs[2];\n\tint ret;\n\n\tsg_init_table(sgs, 2);\n\tsg_set_buf(&sgs[0], base, rem - base);\n\tsg_set_buf(&sgs[1], pmbl_tag, CEPH_GCM_TAG_LEN);\n\tret = gcm_crypt(con, true, sgs, sgs, rem - base);\n\tif (ret)\n\t\treturn ret;\n\n\t/* control remainder padding? */\n\tif (need_padding(rem_len))\n\t\tmemset(rem + rem_len, 0, padding_len(rem_len));\n\n\tsg_init_one(&sgs[0], rem, pmbl_tag - rem);\n\tret = gcm_crypt(con, true, sgs, sgs, rem_tag - rem);\n\tif (ret)\n\t\treturn ret;\n\n\tadd_out_kvec(con, base, rem - base);\n\tadd_out_kvec(con, pmbl_tag, CEPH_GCM_TAG_LEN);\n\tadd_out_kvec(con, rem, pmbl_tag - rem);\n\treturn 0;\n}\n\nstatic int __prepare_control(struct ceph_connection *con, int tag,\n\t\t\t     void *base, int ctrl_len, void *extdata,\n\t\t\t     int extdata_len, bool to_be_signed)\n{\n\tint total_len = ctrl_len + extdata_len;\n\tstruct ceph_frame_desc desc;\n\tint ret;\n\n\tdout(\"%s con %p tag %d len %d (%d+%d)\\n\", __func__, con, tag,\n\t     total_len, ctrl_len, extdata_len);\n\n\t/* extdata may be vmalloc'ed but not base */\n\tif (WARN_ON(is_vmalloc_addr(base) || !ctrl_len))\n\t\treturn -EINVAL;\n\n\tinit_frame_desc(&desc, tag, &total_len, 1);\n\tencode_preamble(&desc, base);\n\n\tif (con_secure(con)) {\n\t\tif (WARN_ON(extdata_len || to_be_signed))\n\t\t\treturn -EINVAL;\n\n\t\tif (ctrl_len <= CEPH_PREAMBLE_INLINE_LEN)\n\t\t\t/* fully inlined, inline buffer may need padding */\n\t\t\tret = prepare_head_secure_small(con, base, ctrl_len);\n\t\telse\n\t\t\t/* partially inlined, inline buffer is full */\n\t\t\tret = prepare_head_secure_big(con, base, ctrl_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tprepare_head_plain(con, base, ctrl_len, extdata, extdata_len,\n\t\t\t\t   to_be_signed);\n\t}\n\n\tceph_con_flag_set(con, CEPH_CON_F_WRITE_PENDING);\n\treturn 0;\n}\n\nstatic int prepare_control(struct ceph_connection *con, int tag,\n\t\t\t   void *base, int ctrl_len)\n{\n\treturn __prepare_control(con, tag, base, ctrl_len, NULL, 0, false);\n}\n\nstatic int prepare_hello(struct ceph_connection *con)\n{\n\tvoid *buf, *p;\n\tint ctrl_len;\n\n\tctrl_len = 1 + ceph_entity_addr_encoding_len(&con->peer_addr);\n\tbuf = alloc_conn_buf(con, head_onwire_len(ctrl_len, false));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tp = CTRL_BODY(buf);\n\tceph_encode_8(&p, CEPH_ENTITY_TYPE_CLIENT);\n\tceph_encode_entity_addr(&p, &con->peer_addr);\n\tWARN_ON(p != CTRL_BODY(buf) + ctrl_len);\n\n\treturn __prepare_control(con, FRAME_TAG_HELLO, buf, ctrl_len,\n\t\t\t\t NULL, 0, true);\n}\n\n/* so that head_onwire_len(AUTH_BUF_LEN, false) is 512 */\n#define AUTH_BUF_LEN\t(512 - CEPH_CRC_LEN - CEPH_PREAMBLE_PLAIN_LEN)\n\nstatic int prepare_auth_request(struct ceph_connection *con)\n{\n\tvoid *authorizer, *authorizer_copy;\n\tint ctrl_len, authorizer_len;\n\tvoid *buf;\n\tint ret;\n\n\tctrl_len = AUTH_BUF_LEN;\n\tbuf = alloc_conn_buf(con, head_onwire_len(ctrl_len, false));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_unlock(&con->mutex);\n\tret = con->ops->get_auth_request(con, CTRL_BODY(buf), &ctrl_len,\n\t\t\t\t\t &authorizer, &authorizer_len);\n\tmutex_lock(&con->mutex);\n\tif (con->state != CEPH_CON_S_V2_HELLO) {\n\t\tdout(\"%s con %p state changed to %d\\n\", __func__, con,\n\t\t     con->state);\n\t\treturn -EAGAIN;\n\t}\n\n\tdout(\"%s con %p get_auth_request ret %d\\n\", __func__, con, ret);\n\tif (ret)\n\t\treturn ret;\n\n\tauthorizer_copy = alloc_conn_buf(con, authorizer_len);\n\tif (!authorizer_copy)\n\t\treturn -ENOMEM;\n\n\tmemcpy(authorizer_copy, authorizer, authorizer_len);\n\n\treturn __prepare_control(con, FRAME_TAG_AUTH_REQUEST, buf, ctrl_len,\n\t\t\t\t authorizer_copy, authorizer_len, true);\n}\n\nstatic int prepare_auth_request_more(struct ceph_connection *con,\n\t\t\t\t     void *reply, int reply_len)\n{\n\tint ctrl_len, authorizer_len;\n\tvoid *authorizer;\n\tvoid *buf;\n\tint ret;\n\n\tctrl_len = AUTH_BUF_LEN;\n\tbuf = alloc_conn_buf(con, head_onwire_len(ctrl_len, false));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_unlock(&con->mutex);\n\tret = con->ops->handle_auth_reply_more(con, reply, reply_len,\n\t\t\t\t\t       CTRL_BODY(buf), &ctrl_len,\n\t\t\t\t\t       &authorizer, &authorizer_len);\n\tmutex_lock(&con->mutex);\n\tif (con->state != CEPH_CON_S_V2_AUTH) {\n\t\tdout(\"%s con %p state changed to %d\\n\", __func__, con,\n\t\t     con->state);\n\t\treturn -EAGAIN;\n\t}\n\n\tdout(\"%s con %p handle_auth_reply_more ret %d\\n\", __func__, con, ret);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __prepare_control(con, FRAME_TAG_AUTH_REQUEST_MORE, buf,\n\t\t\t\t ctrl_len, authorizer, authorizer_len, true);\n}\n\nstatic int prepare_auth_signature(struct ceph_connection *con)\n{\n\tvoid *buf;\n\tint ret;\n\n\tbuf = alloc_conn_buf(con, head_onwire_len(SHA256_DIGEST_SIZE,\n\t\t\t\t\t\t  con_secure(con)));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = hmac_sha256(con, con->v2.in_sign_kvecs, con->v2.in_sign_kvec_cnt,\n\t\t\t  CTRL_BODY(buf));\n\tif (ret)\n\t\treturn ret;\n\n\treturn prepare_control(con, FRAME_TAG_AUTH_SIGNATURE, buf,\n\t\t\t       SHA256_DIGEST_SIZE);\n}\n\nstatic int prepare_client_ident(struct ceph_connection *con)\n{\n\tstruct ceph_entity_addr *my_addr = &con->msgr->inst.addr;\n\tstruct ceph_client *client = from_msgr(con->msgr);\n\tu64 global_id = ceph_client_gid(client);\n\tvoid *buf, *p;\n\tint ctrl_len;\n\n\tWARN_ON(con->v2.server_cookie);\n\tWARN_ON(con->v2.connect_seq);\n\tWARN_ON(con->v2.peer_global_seq);\n\n\tif (!con->v2.client_cookie) {\n\t\tdo {\n\t\t\tget_random_bytes(&con->v2.client_cookie,\n\t\t\t\t\t sizeof(con->v2.client_cookie));\n\t\t} while (!con->v2.client_cookie);\n\t\tdout(\"%s con %p generated cookie 0x%llx\\n\", __func__, con,\n\t\t     con->v2.client_cookie);\n\t} else {\n\t\tdout(\"%s con %p cookie already set 0x%llx\\n\", __func__, con,\n\t\t     con->v2.client_cookie);\n\t}\n\n\tdout(\"%s con %p my_addr %s/%u peer_addr %s/%u global_id %llu global_seq %llu features 0x%llx required_features 0x%llx cookie 0x%llx\\n\",\n\t     __func__, con, ceph_pr_addr(my_addr), le32_to_cpu(my_addr->nonce),\n\t     ceph_pr_addr(&con->peer_addr), le32_to_cpu(con->peer_addr.nonce),\n\t     global_id, con->v2.global_seq, client->supported_features,\n\t     client->required_features, con->v2.client_cookie);\n\n\tctrl_len = 1 + 4 + ceph_entity_addr_encoding_len(my_addr) +\n\t\t   ceph_entity_addr_encoding_len(&con->peer_addr) + 6 * 8;\n\tbuf = alloc_conn_buf(con, head_onwire_len(ctrl_len, con_secure(con)));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tp = CTRL_BODY(buf);\n\tceph_encode_8(&p, 2);  /* addrvec marker */\n\tceph_encode_32(&p, 1);  /* addr_cnt */\n\tceph_encode_entity_addr(&p, my_addr);\n\tceph_encode_entity_addr(&p, &con->peer_addr);\n\tceph_encode_64(&p, global_id);\n\tceph_encode_64(&p, con->v2.global_seq);\n\tceph_encode_64(&p, client->supported_features);\n\tceph_encode_64(&p, client->required_features);\n\tceph_encode_64(&p, 0);  /* flags */\n\tceph_encode_64(&p, con->v2.client_cookie);\n\tWARN_ON(p != CTRL_BODY(buf) + ctrl_len);\n\n\treturn prepare_control(con, FRAME_TAG_CLIENT_IDENT, buf, ctrl_len);\n}\n\nstatic int prepare_session_reconnect(struct ceph_connection *con)\n{\n\tstruct ceph_entity_addr *my_addr = &con->msgr->inst.addr;\n\tvoid *buf, *p;\n\tint ctrl_len;\n\n\tWARN_ON(!con->v2.client_cookie);\n\tWARN_ON(!con->v2.server_cookie);\n\tWARN_ON(!con->v2.connect_seq);\n\tWARN_ON(!con->v2.peer_global_seq);\n\n\tdout(\"%s con %p my_addr %s/%u client_cookie 0x%llx server_cookie 0x%llx global_seq %llu connect_seq %llu in_seq %llu\\n\",\n\t     __func__, con, ceph_pr_addr(my_addr), le32_to_cpu(my_addr->nonce),\n\t     con->v2.client_cookie, con->v2.server_cookie, con->v2.global_seq,\n\t     con->v2.connect_seq, con->in_seq);\n\n\tctrl_len = 1 + 4 + ceph_entity_addr_encoding_len(my_addr) + 5 * 8;\n\tbuf = alloc_conn_buf(con, head_onwire_len(ctrl_len, con_secure(con)));\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tp = CTRL_BODY(buf);\n\tceph_encode_8(&p, 2);  /* entity_addrvec_t marker */\n\tceph_encode_32(&p, 1);  /* my_addrs len */\n\tceph_encode_entity_addr(&p, my_addr);\n\tceph_encode_64(&p, con->v2.client_cookie);\n\tceph_encode_64(&p, con->v2.server_cookie);\n\tceph_encode_64(&p, con->v2.global_seq);\n\tceph_encode_64(&p, con->v2.connect_seq);\n\tceph_encode_64(&p, con->in_seq);\n\tWARN_ON(p != CTRL_BODY(buf) + ctrl_len);\n\n\treturn prepare_control(con, FRAME_TAG_SESSION_RECONNECT, buf, ctrl_len);\n}\n\nstatic int prepare_keepalive2(struct ceph_connection *con)\n{\n\tstruct ceph_timespec *ts = CTRL_BODY(con->v2.out_buf);\n\tstruct timespec64 now;\n\n\tktime_get_real_ts64(&now);\n\tdout(\"%s con %p timestamp %lld.%09ld\\n\", __func__, con, now.tv_sec,\n\t     now.tv_nsec);\n\n\tceph_encode_timespec64(ts, &now);\n\n\treset_out_kvecs(con);\n\treturn prepare_control(con, FRAME_TAG_KEEPALIVE2, con->v2.out_buf,\n\t\t\t       sizeof(struct ceph_timespec));\n}\n\nstatic int prepare_ack(struct ceph_connection *con)\n{\n\tvoid *p;\n\n\tdout(\"%s con %p in_seq_acked %llu -> %llu\\n\", __func__, con,\n\t     con->in_seq_acked, con->in_seq);\n\tcon->in_seq_acked = con->in_seq;\n\n\tp = CTRL_BODY(con->v2.out_buf);\n\tceph_encode_64(&p, con->in_seq_acked);\n\n\treset_out_kvecs(con);\n\treturn prepare_control(con, FRAME_TAG_ACK, con->v2.out_buf, 8);\n}\n\nstatic void prepare_epilogue_plain(struct ceph_connection *con, bool aborted)\n{\n\tdout(\"%s con %p msg %p aborted %d crcs %u %u %u\\n\", __func__, con,\n\t     con->out_msg, aborted, con->v2.out_epil.front_crc,\n\t     con->v2.out_epil.middle_crc, con->v2.out_epil.data_crc);\n\n\tencode_epilogue_plain(con, aborted);\n\tadd_out_kvec(con, &con->v2.out_epil, CEPH_EPILOGUE_PLAIN_LEN);\n}\n\n/*\n * For \"used\" empty segments, crc is -1.  For unused (trailing)\n * segments, crc is 0.\n */\nstatic void prepare_message_plain(struct ceph_connection *con)\n{\n\tstruct ceph_msg *msg = con->out_msg;\n\n\tprepare_head_plain(con, con->v2.out_buf,\n\t\t\t   sizeof(struct ceph_msg_header2), NULL, 0, false);\n\n\tif (!front_len(msg) && !middle_len(msg)) {\n\t\tif (!data_len(msg)) {\n\t\t\t/*\n\t\t\t * Empty message: once the head is written,\n\t\t\t * we are done -- there is no epilogue.\n\t\t\t */\n\t\t\tcon->v2.out_state = OUT_S_FINISH_MESSAGE;\n\t\t\treturn;\n\t\t}\n\n\t\tcon->v2.out_epil.front_crc = -1;\n\t\tcon->v2.out_epil.middle_crc = -1;\n\t\tcon->v2.out_state = OUT_S_QUEUE_DATA;\n\t\treturn;\n\t}\n\n\tif (front_len(msg)) {\n\t\tcon->v2.out_epil.front_crc = crc32c(-1, msg->front.iov_base,\n\t\t\t\t\t\t    front_len(msg));\n\t\tadd_out_kvec(con, msg->front.iov_base, front_len(msg));\n\t} else {\n\t\t/* middle (at least) is there, checked above */\n\t\tcon->v2.out_epil.front_crc = -1;\n\t}\n\n\tif (middle_len(msg)) {\n\t\tcon->v2.out_epil.middle_crc =\n\t\t\tcrc32c(-1, msg->middle->vec.iov_base, middle_len(msg));\n\t\tadd_out_kvec(con, msg->middle->vec.iov_base, middle_len(msg));\n\t} else {\n\t\tcon->v2.out_epil.middle_crc = data_len(msg) ? -1 : 0;\n\t}\n\n\tif (data_len(msg)) {\n\t\tcon->v2.out_state = OUT_S_QUEUE_DATA;\n\t} else {\n\t\tcon->v2.out_epil.data_crc = 0;\n\t\tprepare_epilogue_plain(con, false);\n\t\tcon->v2.out_state = OUT_S_FINISH_MESSAGE;\n\t}\n}\n\n/*\n * Unfortunately the kernel crypto API doesn't support streaming\n * (piecewise) operation for AEAD algorithms, so we can't get away\n * with a fixed size buffer and a couple sgs.  Instead, we have to\n * allocate pages for the entire tail of the message (currently up\n * to ~32M) and two sgs arrays (up to ~256K each)...\n */\nstatic int prepare_message_secure(struct ceph_connection *con)\n{\n\tvoid *zerop = page_address(ceph_zero_page);\n\tstruct sg_table enc_sgt = {};\n\tstruct sg_table sgt = {};\n\tstruct page **enc_pages;\n\tint enc_page_cnt;\n\tint tail_len;\n\tint ret;\n\n\tret = prepare_head_secure_small(con, con->v2.out_buf,\n\t\t\t\t\tsizeof(struct ceph_msg_header2));\n\tif (ret)\n\t\treturn ret;\n\n\ttail_len = tail_onwire_len(con->out_msg, true);\n\tif (!tail_len) {\n\t\t/*\n\t\t * Empty message: once the head is written,\n\t\t * we are done -- there is no epilogue.\n\t\t */\n\t\tcon->v2.out_state = OUT_S_FINISH_MESSAGE;\n\t\treturn 0;\n\t}\n\n\tencode_epilogue_secure(con, false);\n\tret = setup_message_sgs(&sgt, con->out_msg, zerop, zerop, zerop,\n\t\t\t\t&con->v2.out_epil, false);\n\tif (ret)\n\t\tgoto out;\n\n\tenc_page_cnt = calc_pages_for(0, tail_len);\n\tenc_pages = ceph_alloc_page_vector(enc_page_cnt, GFP_NOIO);\n\tif (IS_ERR(enc_pages)) {\n\t\tret = PTR_ERR(enc_pages);\n\t\tgoto out;\n\t}\n\n\tWARN_ON(con->v2.out_enc_pages || con->v2.out_enc_page_cnt);\n\tcon->v2.out_enc_pages = enc_pages;\n\tcon->v2.out_enc_page_cnt = enc_page_cnt;\n\tcon->v2.out_enc_resid = tail_len;\n\tcon->v2.out_enc_i = 0;\n\n\tret = sg_alloc_table_from_pages(&enc_sgt, enc_pages, enc_page_cnt,\n\t\t\t\t\t0, tail_len, GFP_NOIO);\n\tif (ret)\n\t\tgoto out;\n\n\tret = gcm_crypt(con, true, sgt.sgl, enc_sgt.sgl,\n\t\t\ttail_len - CEPH_GCM_TAG_LEN);\n\tif (ret)\n\t\tgoto out;\n\n\tdout(\"%s con %p msg %p sg_cnt %d enc_page_cnt %d\\n\", __func__, con,\n\t     con->out_msg, sgt.orig_nents, enc_page_cnt);\n\tcon->v2.out_state = OUT_S_QUEUE_ENC_PAGE;\n\nout:\n\tsg_free_table(&sgt);\n\tsg_free_table(&enc_sgt);\n\treturn ret;\n}\n\nstatic int prepare_message(struct ceph_connection *con)\n{\n\tint lens[] = {\n\t\tsizeof(struct ceph_msg_header2),\n\t\tfront_len(con->out_msg),\n\t\tmiddle_len(con->out_msg),\n\t\tdata_len(con->out_msg)\n\t};\n\tstruct ceph_frame_desc desc;\n\tint ret;\n\n\tdout(\"%s con %p msg %p logical %d+%d+%d+%d\\n\", __func__, con,\n\t     con->out_msg, lens[0], lens[1], lens[2], lens[3]);\n\n\tif (con->in_seq > con->in_seq_acked) {\n\t\tdout(\"%s con %p in_seq_acked %llu -> %llu\\n\", __func__, con,\n\t\t     con->in_seq_acked, con->in_seq);\n\t\tcon->in_seq_acked = con->in_seq;\n\t}\n\n\treset_out_kvecs(con);\n\tinit_frame_desc(&desc, FRAME_TAG_MESSAGE, lens, 4);\n\tencode_preamble(&desc, con->v2.out_buf);\n\tfill_header2(CTRL_BODY(con->v2.out_buf), &con->out_msg->hdr,\n\t\t     con->in_seq_acked);\n\n\tif (con_secure(con)) {\n\t\tret = prepare_message_secure(con);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tprepare_message_plain(con);\n\t}\n\n\tceph_con_flag_set(con, CEPH_CON_F_WRITE_PENDING);\n\treturn 0;\n}\n\nstatic int prepare_read_banner_prefix(struct ceph_connection *con)\n{\n\tvoid *buf;\n\n\tbuf = alloc_conn_buf(con, CEPH_BANNER_V2_PREFIX_LEN);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\treset_in_kvecs(con);\n\tadd_in_kvec(con, buf, CEPH_BANNER_V2_PREFIX_LEN);\n\tadd_in_sign_kvec(con, buf, CEPH_BANNER_V2_PREFIX_LEN);\n\tcon->state = CEPH_CON_S_V2_BANNER_PREFIX;\n\treturn 0;\n}\n\nstatic int prepare_read_banner_payload(struct ceph_connection *con,\n\t\t\t\t       int payload_len)\n{\n\tvoid *buf;\n\n\tbuf = alloc_conn_buf(con, payload_len);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\treset_in_kvecs(con);\n\tadd_in_kvec(con, buf, payload_len);\n\tadd_in_sign_kvec(con, buf, payload_len);\n\tcon->state = CEPH_CON_S_V2_BANNER_PAYLOAD;\n\treturn 0;\n}\n\nstatic void prepare_read_preamble(struct ceph_connection *con)\n{\n\treset_in_kvecs(con);\n\tadd_in_kvec(con, con->v2.in_buf,\n\t\t    con_secure(con) ? CEPH_PREAMBLE_SECURE_LEN :\n\t\t\t\t      CEPH_PREAMBLE_PLAIN_LEN);\n\tcon->v2.in_state = IN_S_HANDLE_PREAMBLE;\n}\n\nstatic int prepare_read_control(struct ceph_connection *con)\n{\n\tint ctrl_len = con->v2.in_desc.fd_lens[0];\n\tint head_len;\n\tvoid *buf;\n\n\treset_in_kvecs(con);\n\tif (con->state == CEPH_CON_S_V2_HELLO ||\n\t    con->state == CEPH_CON_S_V2_AUTH) {\n\t\thead_len = head_onwire_len(ctrl_len, false);\n\t\tbuf = alloc_conn_buf(con, head_len);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\t/* preserve preamble */\n\t\tmemcpy(buf, con->v2.in_buf, CEPH_PREAMBLE_LEN);\n\n\t\tadd_in_kvec(con, CTRL_BODY(buf), ctrl_len);\n\t\tadd_in_kvec(con, CTRL_BODY(buf) + ctrl_len, CEPH_CRC_LEN);\n\t\tadd_in_sign_kvec(con, buf, head_len);\n\t} else {\n\t\tif (ctrl_len > CEPH_PREAMBLE_INLINE_LEN) {\n\t\t\tbuf = alloc_conn_buf(con, ctrl_len);\n\t\t\tif (!buf)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tadd_in_kvec(con, buf, ctrl_len);\n\t\t} else {\n\t\t\tadd_in_kvec(con, CTRL_BODY(con->v2.in_buf), ctrl_len);\n\t\t}\n\t\tadd_in_kvec(con, con->v2.in_buf, CEPH_CRC_LEN);\n\t}\n\tcon->v2.in_state = IN_S_HANDLE_CONTROL;\n\treturn 0;\n}\n\nstatic int prepare_read_control_remainder(struct ceph_connection *con)\n{\n\tint ctrl_len = con->v2.in_desc.fd_lens[0];\n\tint rem_len = ctrl_len - CEPH_PREAMBLE_INLINE_LEN;\n\tvoid *buf;\n\n\tbuf = alloc_conn_buf(con, ctrl_len);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, CTRL_BODY(con->v2.in_buf), CEPH_PREAMBLE_INLINE_LEN);\n\n\treset_in_kvecs(con);\n\tadd_in_kvec(con, buf + CEPH_PREAMBLE_INLINE_LEN, rem_len);\n\tadd_in_kvec(con, con->v2.in_buf,\n\t\t    padding_len(rem_len) + CEPH_GCM_TAG_LEN);\n\tcon->v2.in_state = IN_S_HANDLE_CONTROL_REMAINDER;\n\treturn 0;\n}\n\nstatic int prepare_read_data(struct ceph_connection *con)\n{\n\tstruct bio_vec bv;\n\n\tcon->in_data_crc = -1;\n\tceph_msg_data_cursor_init(&con->v2.in_cursor, con->in_msg,\n\t\t\t\t  data_len(con->in_msg));\n\n\tget_bvec_at(&con->v2.in_cursor, &bv);\n\tif (ceph_test_opt(from_msgr(con->msgr), RXBOUNCE)) {\n\t\tif (unlikely(!con->bounce_page)) {\n\t\t\tcon->bounce_page = alloc_page(GFP_NOIO);\n\t\t\tif (!con->bounce_page) {\n\t\t\t\tpr_err(\"failed to allocate bounce page\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tbv.bv_page = con->bounce_page;\n\t\tbv.bv_offset = 0;\n\t}\n\tset_in_bvec(con, &bv);\n\tcon->v2.in_state = IN_S_PREPARE_READ_DATA_CONT;\n\treturn 0;\n}\n\nstatic void prepare_read_data_cont(struct ceph_connection *con)\n{\n\tstruct bio_vec bv;\n\n\tif (ceph_test_opt(from_msgr(con->msgr), RXBOUNCE)) {\n\t\tcon->in_data_crc = crc32c(con->in_data_crc,\n\t\t\t\t\t  page_address(con->bounce_page),\n\t\t\t\t\t  con->v2.in_bvec.bv_len);\n\n\t\tget_bvec_at(&con->v2.in_cursor, &bv);\n\t\tmemcpy_to_page(bv.bv_page, bv.bv_offset,\n\t\t\t       page_address(con->bounce_page),\n\t\t\t       con->v2.in_bvec.bv_len);\n\t} else {\n\t\tcon->in_data_crc = ceph_crc32c_page(con->in_data_crc,\n\t\t\t\t\t\t    con->v2.in_bvec.bv_page,\n\t\t\t\t\t\t    con->v2.in_bvec.bv_offset,\n\t\t\t\t\t\t    con->v2.in_bvec.bv_len);\n\t}\n\n\tceph_msg_data_advance(&con->v2.in_cursor, con->v2.in_bvec.bv_len);\n\tif (con->v2.in_cursor.total_resid) {\n\t\tget_bvec_at(&con->v2.in_cursor, &bv);\n\t\tif (ceph_test_opt(from_msgr(con->msgr), RXBOUNCE)) {\n\t\t\tbv.bv_page = con->bounce_page;\n\t\t\tbv.bv_offset = 0;\n\t\t}\n\t\tset_in_bvec(con, &bv);\n\t\tWARN_ON(con->v2.in_state != IN_S_PREPARE_READ_DATA_CONT);\n\t\treturn;\n\t}\n\n\t/*\n\t * We've read all data.  Prepare to read epilogue.\n\t */\n\treset_in_kvecs(con);\n\tadd_in_kvec(con, con->v2.in_buf, CEPH_EPILOGUE_PLAIN_LEN);\n\tcon->v2.in_state = IN_S_HANDLE_EPILOGUE;\n}\n\nstatic int prepare_read_tail_plain(struct ceph_connection *con)\n{\n\tstruct ceph_msg *msg = con->in_msg;\n\n\tif (!front_len(msg) && !middle_len(msg)) {\n\t\tWARN_ON(!data_len(msg));\n\t\treturn prepare_read_data(con);\n\t}\n\n\treset_in_kvecs(con);\n\tif (front_len(msg)) {\n\t\tadd_in_kvec(con, msg->front.iov_base, front_len(msg));\n\t\tWARN_ON(msg->front.iov_len != front_len(msg));\n\t}\n\tif (middle_len(msg)) {\n\t\tadd_in_kvec(con, msg->middle->vec.iov_base, middle_len(msg));\n\t\tWARN_ON(msg->middle->vec.iov_len != middle_len(msg));\n\t}\n\n\tif (data_len(msg)) {\n\t\tcon->v2.in_state = IN_S_PREPARE_READ_DATA;\n\t} else {\n\t\tadd_in_kvec(con, con->v2.in_buf, CEPH_EPILOGUE_PLAIN_LEN);\n\t\tcon->v2.in_state = IN_S_HANDLE_EPILOGUE;\n\t}\n\treturn 0;\n}\n\nstatic void prepare_read_enc_page(struct ceph_connection *con)\n{\n\tstruct bio_vec bv;\n\n\tdout(\"%s con %p i %d resid %d\\n\", __func__, con, con->v2.in_enc_i,\n\t     con->v2.in_enc_resid);\n\tWARN_ON(!con->v2.in_enc_resid);\n\n\tbvec_set_page(&bv, con->v2.in_enc_pages[con->v2.in_enc_i],\n\t\t      min(con->v2.in_enc_resid, (int)PAGE_SIZE), 0);\n\n\tset_in_bvec(con, &bv);\n\tcon->v2.in_enc_i++;\n\tcon->v2.in_enc_resid -= bv.bv_len;\n\n\tif (con->v2.in_enc_resid) {\n\t\tcon->v2.in_state = IN_S_PREPARE_READ_ENC_PAGE;\n\t\treturn;\n\t}\n\n\t/*\n\t * We are set to read the last piece of ciphertext (ending\n\t * with epilogue) + auth tag.\n\t */\n\tWARN_ON(con->v2.in_enc_i != con->v2.in_enc_page_cnt);\n\tcon->v2.in_state = IN_S_HANDLE_EPILOGUE;\n}\n\nstatic int prepare_read_tail_secure(struct ceph_connection *con)\n{\n\tstruct page **enc_pages;\n\tint enc_page_cnt;\n\tint tail_len;\n\n\ttail_len = tail_onwire_len(con->in_msg, true);\n\tWARN_ON(!tail_len);\n\n\tenc_page_cnt = calc_pages_for(0, tail_len);\n\tenc_pages = ceph_alloc_page_vector(enc_page_cnt, GFP_NOIO);\n\tif (IS_ERR(enc_pages))\n\t\treturn PTR_ERR(enc_pages);\n\n\tWARN_ON(con->v2.in_enc_pages || con->v2.in_enc_page_cnt);\n\tcon->v2.in_enc_pages = enc_pages;\n\tcon->v2.in_enc_page_cnt = enc_page_cnt;\n\tcon->v2.in_enc_resid = tail_len;\n\tcon->v2.in_enc_i = 0;\n\n\tprepare_read_enc_page(con);\n\treturn 0;\n}\n\nstatic void __finish_skip(struct ceph_connection *con)\n{\n\tcon->in_seq++;\n\tprepare_read_preamble(con);\n}\n\nstatic void prepare_skip_message(struct ceph_connection *con)\n{\n\tstruct ceph_frame_desc *desc = &con->v2.in_desc;\n\tint tail_len;\n\n\tdout(\"%s con %p %d+%d+%d\\n\", __func__, con, desc->fd_lens[1],\n\t     desc->fd_lens[2], desc->fd_lens[3]);\n\n\ttail_len = __tail_onwire_len(desc->fd_lens[1], desc->fd_lens[2],\n\t\t\t\t     desc->fd_lens[3], con_secure(con));\n\tif (!tail_len) {\n\t\t__finish_skip(con);\n\t} else {\n\t\tset_in_skip(con, tail_len);\n\t\tcon->v2.in_state = IN_S_FINISH_SKIP;\n\t}\n}\n\nstatic int process_banner_prefix(struct ceph_connection *con)\n{\n\tint payload_len;\n\tvoid *p;\n\n\tWARN_ON(con->v2.in_kvecs[0].iov_len != CEPH_BANNER_V2_PREFIX_LEN);\n\n\tp = con->v2.in_kvecs[0].iov_base;\n\tif (memcmp(p, CEPH_BANNER_V2, CEPH_BANNER_V2_LEN)) {\n\t\tif (!memcmp(p, CEPH_BANNER, CEPH_BANNER_LEN))\n\t\t\tcon->error_msg = \"server is speaking msgr1 protocol\";\n\t\telse\n\t\t\tcon->error_msg = \"protocol error, bad banner\";\n\t\treturn -EINVAL;\n\t}\n\n\tp += CEPH_BANNER_V2_LEN;\n\tpayload_len = ceph_decode_16(&p);\n\tdout(\"%s con %p payload_len %d\\n\", __func__, con, payload_len);\n\n\treturn prepare_read_banner_payload(con, payload_len);\n}\n\nstatic int process_banner_payload(struct ceph_connection *con)\n{\n\tvoid *end = con->v2.in_kvecs[0].iov_base + con->v2.in_kvecs[0].iov_len;\n\tu64 feat = CEPH_MSGR2_SUPPORTED_FEATURES;\n\tu64 req_feat = CEPH_MSGR2_REQUIRED_FEATURES;\n\tu64 server_feat, server_req_feat;\n\tvoid *p;\n\tint ret;\n\n\tp = con->v2.in_kvecs[0].iov_base;\n\tceph_decode_64_safe(&p, end, server_feat, bad);\n\tceph_decode_64_safe(&p, end, server_req_feat, bad);\n\n\tdout(\"%s con %p server_feat 0x%llx server_req_feat 0x%llx\\n\",\n\t     __func__, con, server_feat, server_req_feat);\n\n\tif (req_feat & ~server_feat) {\n\t\tpr_err(\"msgr2 feature set mismatch: my required > server's supported 0x%llx, need 0x%llx\\n\",\n\t\t       server_feat, req_feat & ~server_feat);\n\t\tcon->error_msg = \"missing required protocol features\";\n\t\treturn -EINVAL;\n\t}\n\tif (server_req_feat & ~feat) {\n\t\tpr_err(\"msgr2 feature set mismatch: server's required > my supported 0x%llx, missing 0x%llx\\n\",\n\t\t       feat, server_req_feat & ~feat);\n\t\tcon->error_msg = \"missing required protocol features\";\n\t\treturn -EINVAL;\n\t}\n\n\t/* no reset_out_kvecs() as our banner may still be pending */\n\tret = prepare_hello(con);\n\tif (ret) {\n\t\tpr_err(\"prepare_hello failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcon->state = CEPH_CON_S_V2_HELLO;\n\tprepare_read_preamble(con);\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode banner payload\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_hello(struct ceph_connection *con, void *p, void *end)\n{\n\tstruct ceph_entity_addr *my_addr = &con->msgr->inst.addr;\n\tstruct ceph_entity_addr addr_for_me;\n\tu8 entity_type;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_HELLO) {\n\t\tcon->error_msg = \"protocol error, unexpected hello\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_8_safe(&p, end, entity_type, bad);\n\tret = ceph_decode_entity_addr(&p, end, &addr_for_me);\n\tif (ret) {\n\t\tpr_err(\"failed to decode addr_for_me: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdout(\"%s con %p entity_type %d addr_for_me %s\\n\", __func__, con,\n\t     entity_type, ceph_pr_addr(&addr_for_me));\n\n\tif (entity_type != con->peer_name.type) {\n\t\tpr_err(\"bad peer type, want %d, got %d\\n\",\n\t\t       con->peer_name.type, entity_type);\n\t\tcon->error_msg = \"wrong peer at address\";\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Set our address to the address our first peer (i.e. monitor)\n\t * sees that we are connecting from.  If we are behind some sort\n\t * of NAT and want to be identified by some private (not NATed)\n\t * address, ip option should be used.\n\t */\n\tif (ceph_addr_is_blank(my_addr)) {\n\t\tmemcpy(&my_addr->in_addr, &addr_for_me.in_addr,\n\t\t       sizeof(my_addr->in_addr));\n\t\tceph_addr_set_port(my_addr, 0);\n\t\tdout(\"%s con %p set my addr %s, as seen by peer %s\\n\",\n\t\t     __func__, con, ceph_pr_addr(my_addr),\n\t\t     ceph_pr_addr(&con->peer_addr));\n\t} else {\n\t\tdout(\"%s con %p my addr already set %s\\n\",\n\t\t     __func__, con, ceph_pr_addr(my_addr));\n\t}\n\n\tWARN_ON(ceph_addr_is_blank(my_addr) || ceph_addr_port(my_addr));\n\tWARN_ON(my_addr->type != CEPH_ENTITY_ADDR_TYPE_ANY);\n\tWARN_ON(!my_addr->nonce);\n\n\t/* no reset_out_kvecs() as our hello may still be pending */\n\tret = prepare_auth_request(con);\n\tif (ret) {\n\t\tif (ret != -EAGAIN)\n\t\t\tpr_err(\"prepare_auth_request failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcon->state = CEPH_CON_S_V2_AUTH;\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode hello\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_auth_bad_method(struct ceph_connection *con,\n\t\t\t\t   void *p, void *end)\n{\n\tint allowed_protos[8], allowed_modes[8];\n\tint allowed_proto_cnt, allowed_mode_cnt;\n\tint used_proto, result;\n\tint ret;\n\tint i;\n\n\tif (con->state != CEPH_CON_S_V2_AUTH) {\n\t\tcon->error_msg = \"protocol error, unexpected auth_bad_method\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_32_safe(&p, end, used_proto, bad);\n\tceph_decode_32_safe(&p, end, result, bad);\n\tdout(\"%s con %p used_proto %d result %d\\n\", __func__, con, used_proto,\n\t     result);\n\n\tceph_decode_32_safe(&p, end, allowed_proto_cnt, bad);\n\tif (allowed_proto_cnt > ARRAY_SIZE(allowed_protos)) {\n\t\tpr_err(\"allowed_protos too big %d\\n\", allowed_proto_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < allowed_proto_cnt; i++) {\n\t\tceph_decode_32_safe(&p, end, allowed_protos[i], bad);\n\t\tdout(\"%s con %p allowed_protos[%d] %d\\n\", __func__, con,\n\t\t     i, allowed_protos[i]);\n\t}\n\n\tceph_decode_32_safe(&p, end, allowed_mode_cnt, bad);\n\tif (allowed_mode_cnt > ARRAY_SIZE(allowed_modes)) {\n\t\tpr_err(\"allowed_modes too big %d\\n\", allowed_mode_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < allowed_mode_cnt; i++) {\n\t\tceph_decode_32_safe(&p, end, allowed_modes[i], bad);\n\t\tdout(\"%s con %p allowed_modes[%d] %d\\n\", __func__, con,\n\t\t     i, allowed_modes[i]);\n\t}\n\n\tmutex_unlock(&con->mutex);\n\tret = con->ops->handle_auth_bad_method(con, used_proto, result,\n\t\t\t\t\t       allowed_protos,\n\t\t\t\t\t       allowed_proto_cnt,\n\t\t\t\t\t       allowed_modes,\n\t\t\t\t\t       allowed_mode_cnt);\n\tmutex_lock(&con->mutex);\n\tif (con->state != CEPH_CON_S_V2_AUTH) {\n\t\tdout(\"%s con %p state changed to %d\\n\", __func__, con,\n\t\t     con->state);\n\t\treturn -EAGAIN;\n\t}\n\n\tdout(\"%s con %p handle_auth_bad_method ret %d\\n\", __func__, con, ret);\n\treturn ret;\n\nbad:\n\tpr_err(\"failed to decode auth_bad_method\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_auth_reply_more(struct ceph_connection *con,\n\t\t\t\t   void *p, void *end)\n{\n\tint payload_len;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_AUTH) {\n\t\tcon->error_msg = \"protocol error, unexpected auth_reply_more\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_32_safe(&p, end, payload_len, bad);\n\tceph_decode_need(&p, end, payload_len, bad);\n\n\tdout(\"%s con %p payload_len %d\\n\", __func__, con, payload_len);\n\n\treset_out_kvecs(con);\n\tret = prepare_auth_request_more(con, p, payload_len);\n\tif (ret) {\n\t\tif (ret != -EAGAIN)\n\t\t\tpr_err(\"prepare_auth_request_more failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode auth_reply_more\\n\");\n\treturn -EINVAL;\n}\n\n/*\n * Align session_key and con_secret to avoid GFP_ATOMIC allocation\n * inside crypto_shash_setkey() and crypto_aead_setkey() called from\n * setup_crypto().  __aligned(16) isn't guaranteed to work for stack\n * objects, so do it by hand.\n */\nstatic int process_auth_done(struct ceph_connection *con, void *p, void *end)\n{\n\tu8 session_key_buf[CEPH_KEY_LEN + 16];\n\tu8 con_secret_buf[CEPH_MAX_CON_SECRET_LEN + 16];\n\tu8 *session_key = PTR_ALIGN(&session_key_buf[0], 16);\n\tu8 *con_secret = PTR_ALIGN(&con_secret_buf[0], 16);\n\tint session_key_len, con_secret_len;\n\tint payload_len;\n\tu64 global_id;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_AUTH) {\n\t\tcon->error_msg = \"protocol error, unexpected auth_done\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_64_safe(&p, end, global_id, bad);\n\tceph_decode_32_safe(&p, end, con->v2.con_mode, bad);\n\tceph_decode_32_safe(&p, end, payload_len, bad);\n\n\tdout(\"%s con %p global_id %llu con_mode %d payload_len %d\\n\",\n\t     __func__, con, global_id, con->v2.con_mode, payload_len);\n\n\tmutex_unlock(&con->mutex);\n\tsession_key_len = 0;\n\tcon_secret_len = 0;\n\tret = con->ops->handle_auth_done(con, global_id, p, payload_len,\n\t\t\t\t\t session_key, &session_key_len,\n\t\t\t\t\t con_secret, &con_secret_len);\n\tmutex_lock(&con->mutex);\n\tif (con->state != CEPH_CON_S_V2_AUTH) {\n\t\tdout(\"%s con %p state changed to %d\\n\", __func__, con,\n\t\t     con->state);\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tdout(\"%s con %p handle_auth_done ret %d\\n\", __func__, con, ret);\n\tif (ret)\n\t\tgoto out;\n\n\tret = setup_crypto(con, session_key, session_key_len, con_secret,\n\t\t\t   con_secret_len);\n\tif (ret)\n\t\tgoto out;\n\n\treset_out_kvecs(con);\n\tret = prepare_auth_signature(con);\n\tif (ret) {\n\t\tpr_err(\"prepare_auth_signature failed: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tcon->state = CEPH_CON_S_V2_AUTH_SIGNATURE;\n\nout:\n\tmemzero_explicit(session_key_buf, sizeof(session_key_buf));\n\tmemzero_explicit(con_secret_buf, sizeof(con_secret_buf));\n\treturn ret;\n\nbad:\n\tpr_err(\"failed to decode auth_done\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_auth_signature(struct ceph_connection *con,\n\t\t\t\t  void *p, void *end)\n{\n\tu8 hmac[SHA256_DIGEST_SIZE];\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_AUTH_SIGNATURE) {\n\t\tcon->error_msg = \"protocol error, unexpected auth_signature\";\n\t\treturn -EINVAL;\n\t}\n\n\tret = hmac_sha256(con, con->v2.out_sign_kvecs,\n\t\t\t  con->v2.out_sign_kvec_cnt, hmac);\n\tif (ret)\n\t\treturn ret;\n\n\tceph_decode_need(&p, end, SHA256_DIGEST_SIZE, bad);\n\tif (crypto_memneq(p, hmac, SHA256_DIGEST_SIZE)) {\n\t\tcon->error_msg = \"integrity error, bad auth signature\";\n\t\treturn -EBADMSG;\n\t}\n\n\tdout(\"%s con %p auth signature ok\\n\", __func__, con);\n\n\t/* no reset_out_kvecs() as our auth_signature may still be pending */\n\tif (!con->v2.server_cookie) {\n\t\tret = prepare_client_ident(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_client_ident failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tcon->state = CEPH_CON_S_V2_SESSION_CONNECT;\n\t} else {\n\t\tret = prepare_session_reconnect(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_session_reconnect failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tcon->state = CEPH_CON_S_V2_SESSION_RECONNECT;\n\t}\n\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode auth_signature\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_server_ident(struct ceph_connection *con,\n\t\t\t\tvoid *p, void *end)\n{\n\tstruct ceph_client *client = from_msgr(con->msgr);\n\tu64 features, required_features;\n\tstruct ceph_entity_addr addr;\n\tu64 global_seq;\n\tu64 global_id;\n\tu64 cookie;\n\tu64 flags;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_SESSION_CONNECT) {\n\t\tcon->error_msg = \"protocol error, unexpected server_ident\";\n\t\treturn -EINVAL;\n\t}\n\n\tret = ceph_decode_entity_addrvec(&p, end, true, &addr);\n\tif (ret) {\n\t\tpr_err(\"failed to decode server addrs: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tceph_decode_64_safe(&p, end, global_id, bad);\n\tceph_decode_64_safe(&p, end, global_seq, bad);\n\tceph_decode_64_safe(&p, end, features, bad);\n\tceph_decode_64_safe(&p, end, required_features, bad);\n\tceph_decode_64_safe(&p, end, flags, bad);\n\tceph_decode_64_safe(&p, end, cookie, bad);\n\n\tdout(\"%s con %p addr %s/%u global_id %llu global_seq %llu features 0x%llx required_features 0x%llx flags 0x%llx cookie 0x%llx\\n\",\n\t     __func__, con, ceph_pr_addr(&addr), le32_to_cpu(addr.nonce),\n\t     global_id, global_seq, features, required_features, flags, cookie);\n\n\t/* is this who we intended to talk to? */\n\tif (memcmp(&addr, &con->peer_addr, sizeof(con->peer_addr))) {\n\t\tpr_err(\"bad peer addr/nonce, want %s/%u, got %s/%u\\n\",\n\t\t       ceph_pr_addr(&con->peer_addr),\n\t\t       le32_to_cpu(con->peer_addr.nonce),\n\t\t       ceph_pr_addr(&addr), le32_to_cpu(addr.nonce));\n\t\tcon->error_msg = \"wrong peer at address\";\n\t\treturn -EINVAL;\n\t}\n\n\tif (client->required_features & ~features) {\n\t\tpr_err(\"RADOS feature set mismatch: my required > server's supported 0x%llx, need 0x%llx\\n\",\n\t\t       features, client->required_features & ~features);\n\t\tcon->error_msg = \"missing required protocol features\";\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Both name->type and name->num are set in ceph_con_open() but\n\t * name->num may be bogus in the initial monmap.  name->type is\n\t * verified in handle_hello().\n\t */\n\tWARN_ON(!con->peer_name.type);\n\tcon->peer_name.num = cpu_to_le64(global_id);\n\tcon->v2.peer_global_seq = global_seq;\n\tcon->peer_features = features;\n\tWARN_ON(required_features & ~client->supported_features);\n\tcon->v2.server_cookie = cookie;\n\n\tif (flags & CEPH_MSG_CONNECT_LOSSY) {\n\t\tceph_con_flag_set(con, CEPH_CON_F_LOSSYTX);\n\t\tWARN_ON(con->v2.server_cookie);\n\t} else {\n\t\tWARN_ON(!con->v2.server_cookie);\n\t}\n\n\tclear_in_sign_kvecs(con);\n\tclear_out_sign_kvecs(con);\n\tfree_conn_bufs(con);\n\tcon->delay = 0;  /* reset backoff memory */\n\n\tcon->state = CEPH_CON_S_OPEN;\n\tcon->v2.out_state = OUT_S_GET_NEXT;\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode server_ident\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_ident_missing_features(struct ceph_connection *con,\n\t\t\t\t\t  void *p, void *end)\n{\n\tstruct ceph_client *client = from_msgr(con->msgr);\n\tu64 missing_features;\n\n\tif (con->state != CEPH_CON_S_V2_SESSION_CONNECT) {\n\t\tcon->error_msg = \"protocol error, unexpected ident_missing_features\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_64_safe(&p, end, missing_features, bad);\n\tpr_err(\"RADOS feature set mismatch: server's required > my supported 0x%llx, missing 0x%llx\\n\",\n\t       client->supported_features, missing_features);\n\tcon->error_msg = \"missing required protocol features\";\n\treturn -EINVAL;\n\nbad:\n\tpr_err(\"failed to decode ident_missing_features\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_session_reconnect_ok(struct ceph_connection *con,\n\t\t\t\t\tvoid *p, void *end)\n{\n\tu64 seq;\n\n\tif (con->state != CEPH_CON_S_V2_SESSION_RECONNECT) {\n\t\tcon->error_msg = \"protocol error, unexpected session_reconnect_ok\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_64_safe(&p, end, seq, bad);\n\n\tdout(\"%s con %p seq %llu\\n\", __func__, con, seq);\n\tceph_con_discard_requeued(con, seq);\n\n\tclear_in_sign_kvecs(con);\n\tclear_out_sign_kvecs(con);\n\tfree_conn_bufs(con);\n\tcon->delay = 0;  /* reset backoff memory */\n\n\tcon->state = CEPH_CON_S_OPEN;\n\tcon->v2.out_state = OUT_S_GET_NEXT;\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode session_reconnect_ok\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_session_retry(struct ceph_connection *con,\n\t\t\t\t void *p, void *end)\n{\n\tu64 connect_seq;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_SESSION_RECONNECT) {\n\t\tcon->error_msg = \"protocol error, unexpected session_retry\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_64_safe(&p, end, connect_seq, bad);\n\n\tdout(\"%s con %p connect_seq %llu\\n\", __func__, con, connect_seq);\n\tWARN_ON(connect_seq <= con->v2.connect_seq);\n\tcon->v2.connect_seq = connect_seq + 1;\n\n\tfree_conn_bufs(con);\n\n\treset_out_kvecs(con);\n\tret = prepare_session_reconnect(con);\n\tif (ret) {\n\t\tpr_err(\"prepare_session_reconnect (cseq) failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode session_retry\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_session_retry_global(struct ceph_connection *con,\n\t\t\t\t\tvoid *p, void *end)\n{\n\tu64 global_seq;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_SESSION_RECONNECT) {\n\t\tcon->error_msg = \"protocol error, unexpected session_retry_global\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_64_safe(&p, end, global_seq, bad);\n\n\tdout(\"%s con %p global_seq %llu\\n\", __func__, con, global_seq);\n\tWARN_ON(global_seq <= con->v2.global_seq);\n\tcon->v2.global_seq = ceph_get_global_seq(con->msgr, global_seq);\n\n\tfree_conn_bufs(con);\n\n\treset_out_kvecs(con);\n\tret = prepare_session_reconnect(con);\n\tif (ret) {\n\t\tpr_err(\"prepare_session_reconnect (gseq) failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode session_retry_global\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_session_reset(struct ceph_connection *con,\n\t\t\t\t void *p, void *end)\n{\n\tbool full;\n\tint ret;\n\n\tif (con->state != CEPH_CON_S_V2_SESSION_RECONNECT) {\n\t\tcon->error_msg = \"protocol error, unexpected session_reset\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_8_safe(&p, end, full, bad);\n\tif (!full) {\n\t\tcon->error_msg = \"protocol error, bad session_reset\";\n\t\treturn -EINVAL;\n\t}\n\n\tpr_info(\"%s%lld %s session reset\\n\", ENTITY_NAME(con->peer_name),\n\t\tceph_pr_addr(&con->peer_addr));\n\tceph_con_reset_session(con);\n\n\tmutex_unlock(&con->mutex);\n\tif (con->ops->peer_reset)\n\t\tcon->ops->peer_reset(con);\n\tmutex_lock(&con->mutex);\n\tif (con->state != CEPH_CON_S_V2_SESSION_RECONNECT) {\n\t\tdout(\"%s con %p state changed to %d\\n\", __func__, con,\n\t\t     con->state);\n\t\treturn -EAGAIN;\n\t}\n\n\tfree_conn_bufs(con);\n\n\treset_out_kvecs(con);\n\tret = prepare_client_ident(con);\n\tif (ret) {\n\t\tpr_err(\"prepare_client_ident (rst) failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcon->state = CEPH_CON_S_V2_SESSION_CONNECT;\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode session_reset\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_keepalive2_ack(struct ceph_connection *con,\n\t\t\t\t  void *p, void *end)\n{\n\tif (con->state != CEPH_CON_S_OPEN) {\n\t\tcon->error_msg = \"protocol error, unexpected keepalive2_ack\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_need(&p, end, sizeof(struct ceph_timespec), bad);\n\tceph_decode_timespec64(&con->last_keepalive_ack, p);\n\n\tdout(\"%s con %p timestamp %lld.%09ld\\n\", __func__, con,\n\t     con->last_keepalive_ack.tv_sec, con->last_keepalive_ack.tv_nsec);\n\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode keepalive2_ack\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_ack(struct ceph_connection *con, void *p, void *end)\n{\n\tu64 seq;\n\n\tif (con->state != CEPH_CON_S_OPEN) {\n\t\tcon->error_msg = \"protocol error, unexpected ack\";\n\t\treturn -EINVAL;\n\t}\n\n\tceph_decode_64_safe(&p, end, seq, bad);\n\n\tdout(\"%s con %p seq %llu\\n\", __func__, con, seq);\n\tceph_con_discard_sent(con, seq);\n\treturn 0;\n\nbad:\n\tpr_err(\"failed to decode ack\\n\");\n\treturn -EINVAL;\n}\n\nstatic int process_control(struct ceph_connection *con, void *p, void *end)\n{\n\tint tag = con->v2.in_desc.fd_tag;\n\tint ret;\n\n\tdout(\"%s con %p tag %d len %d\\n\", __func__, con, tag, (int)(end - p));\n\n\tswitch (tag) {\n\tcase FRAME_TAG_HELLO:\n\t\tret = process_hello(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_AUTH_BAD_METHOD:\n\t\tret = process_auth_bad_method(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_AUTH_REPLY_MORE:\n\t\tret = process_auth_reply_more(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_AUTH_DONE:\n\t\tret = process_auth_done(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_AUTH_SIGNATURE:\n\t\tret = process_auth_signature(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_SERVER_IDENT:\n\t\tret = process_server_ident(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_IDENT_MISSING_FEATURES:\n\t\tret = process_ident_missing_features(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_SESSION_RECONNECT_OK:\n\t\tret = process_session_reconnect_ok(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_SESSION_RETRY:\n\t\tret = process_session_retry(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_SESSION_RETRY_GLOBAL:\n\t\tret = process_session_retry_global(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_SESSION_RESET:\n\t\tret = process_session_reset(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_KEEPALIVE2_ACK:\n\t\tret = process_keepalive2_ack(con, p, end);\n\t\tbreak;\n\tcase FRAME_TAG_ACK:\n\t\tret = process_ack(con, p, end);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"bad tag %d\\n\", tag);\n\t\tcon->error_msg = \"protocol error, bad tag\";\n\t\treturn -EINVAL;\n\t}\n\tif (ret) {\n\t\tdout(\"%s con %p error %d\\n\", __func__, con, ret);\n\t\treturn ret;\n\t}\n\n\tprepare_read_preamble(con);\n\treturn 0;\n}\n\n/*\n * Return:\n *   1 - con->in_msg set, read message\n *   0 - skip message\n *  <0 - error\n */\nstatic int process_message_header(struct ceph_connection *con,\n\t\t\t\t  void *p, void *end)\n{\n\tstruct ceph_frame_desc *desc = &con->v2.in_desc;\n\tstruct ceph_msg_header2 *hdr2 = p;\n\tstruct ceph_msg_header hdr;\n\tint skip;\n\tint ret;\n\tu64 seq;\n\n\t/* verify seq# */\n\tseq = le64_to_cpu(hdr2->seq);\n\tif ((s64)seq - (s64)con->in_seq < 1) {\n\t\tpr_info(\"%s%lld %s skipping old message: seq %llu, expected %llu\\n\",\n\t\t\tENTITY_NAME(con->peer_name),\n\t\t\tceph_pr_addr(&con->peer_addr),\n\t\t\tseq, con->in_seq + 1);\n\t\treturn 0;\n\t}\n\tif ((s64)seq - (s64)con->in_seq > 1) {\n\t\tpr_err(\"bad seq %llu, expected %llu\\n\", seq, con->in_seq + 1);\n\t\tcon->error_msg = \"bad message sequence # for incoming message\";\n\t\treturn -EBADE;\n\t}\n\n\tceph_con_discard_sent(con, le64_to_cpu(hdr2->ack_seq));\n\n\tfill_header(&hdr, hdr2, desc->fd_lens[1], desc->fd_lens[2],\n\t\t    desc->fd_lens[3], &con->peer_name);\n\tret = ceph_con_in_msg_alloc(con, &hdr, &skip);\n\tif (ret)\n\t\treturn ret;\n\n\tWARN_ON(!con->in_msg ^ skip);\n\tif (skip)\n\t\treturn 0;\n\n\tWARN_ON(!con->in_msg);\n\tWARN_ON(con->in_msg->con != con);\n\treturn 1;\n}\n\nstatic int process_message(struct ceph_connection *con)\n{\n\tceph_con_process_message(con);\n\n\t/*\n\t * We could have been closed by ceph_con_close() because\n\t * ceph_con_process_message() temporarily drops con->mutex.\n\t */\n\tif (con->state != CEPH_CON_S_OPEN) {\n\t\tdout(\"%s con %p state changed to %d\\n\", __func__, con,\n\t\t     con->state);\n\t\treturn -EAGAIN;\n\t}\n\n\tprepare_read_preamble(con);\n\treturn 0;\n}\n\nstatic int __handle_control(struct ceph_connection *con, void *p)\n{\n\tvoid *end = p + con->v2.in_desc.fd_lens[0];\n\tstruct ceph_msg *msg;\n\tint ret;\n\n\tif (con->v2.in_desc.fd_tag != FRAME_TAG_MESSAGE)\n\t\treturn process_control(con, p, end);\n\n\tret = process_message_header(con, p, end);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0) {\n\t\tprepare_skip_message(con);\n\t\treturn 0;\n\t}\n\n\tmsg = con->in_msg;  /* set in process_message_header() */\n\tif (front_len(msg)) {\n\t\tWARN_ON(front_len(msg) > msg->front_alloc_len);\n\t\tmsg->front.iov_len = front_len(msg);\n\t} else {\n\t\tmsg->front.iov_len = 0;\n\t}\n\tif (middle_len(msg)) {\n\t\tWARN_ON(middle_len(msg) > msg->middle->alloc_len);\n\t\tmsg->middle->vec.iov_len = middle_len(msg);\n\t} else if (msg->middle) {\n\t\tmsg->middle->vec.iov_len = 0;\n\t}\n\n\tif (!front_len(msg) && !middle_len(msg) && !data_len(msg))\n\t\treturn process_message(con);\n\n\tif (con_secure(con))\n\t\treturn prepare_read_tail_secure(con);\n\n\treturn prepare_read_tail_plain(con);\n}\n\nstatic int handle_preamble(struct ceph_connection *con)\n{\n\tstruct ceph_frame_desc *desc = &con->v2.in_desc;\n\tint ret;\n\n\tif (con_secure(con)) {\n\t\tret = decrypt_preamble(con);\n\t\tif (ret) {\n\t\t\tif (ret == -EBADMSG)\n\t\t\t\tcon->error_msg = \"integrity error, bad preamble auth tag\";\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = decode_preamble(con->v2.in_buf, desc);\n\tif (ret) {\n\t\tif (ret == -EBADMSG)\n\t\t\tcon->error_msg = \"integrity error, bad crc\";\n\t\telse\n\t\t\tcon->error_msg = \"protocol error, bad preamble\";\n\t\treturn ret;\n\t}\n\n\tdout(\"%s con %p tag %d seg_cnt %d %d+%d+%d+%d\\n\", __func__,\n\t     con, desc->fd_tag, desc->fd_seg_cnt, desc->fd_lens[0],\n\t     desc->fd_lens[1], desc->fd_lens[2], desc->fd_lens[3]);\n\n\tif (!con_secure(con))\n\t\treturn prepare_read_control(con);\n\n\tif (desc->fd_lens[0] > CEPH_PREAMBLE_INLINE_LEN)\n\t\treturn prepare_read_control_remainder(con);\n\n\treturn __handle_control(con, CTRL_BODY(con->v2.in_buf));\n}\n\nstatic int handle_control(struct ceph_connection *con)\n{\n\tint ctrl_len = con->v2.in_desc.fd_lens[0];\n\tvoid *buf;\n\tint ret;\n\n\tWARN_ON(con_secure(con));\n\n\tret = verify_control_crc(con);\n\tif (ret) {\n\t\tcon->error_msg = \"integrity error, bad crc\";\n\t\treturn ret;\n\t}\n\n\tif (con->state == CEPH_CON_S_V2_AUTH) {\n\t\tbuf = alloc_conn_buf(con, ctrl_len);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(buf, con->v2.in_kvecs[0].iov_base, ctrl_len);\n\t\treturn __handle_control(con, buf);\n\t}\n\n\treturn __handle_control(con, con->v2.in_kvecs[0].iov_base);\n}\n\nstatic int handle_control_remainder(struct ceph_connection *con)\n{\n\tint ret;\n\n\tWARN_ON(!con_secure(con));\n\n\tret = decrypt_control_remainder(con);\n\tif (ret) {\n\t\tif (ret == -EBADMSG)\n\t\t\tcon->error_msg = \"integrity error, bad control remainder auth tag\";\n\t\treturn ret;\n\t}\n\n\treturn __handle_control(con, con->v2.in_kvecs[0].iov_base -\n\t\t\t\t     CEPH_PREAMBLE_INLINE_LEN);\n}\n\nstatic int handle_epilogue(struct ceph_connection *con)\n{\n\tu32 front_crc, middle_crc, data_crc;\n\tint ret;\n\n\tif (con_secure(con)) {\n\t\tret = decrypt_tail(con);\n\t\tif (ret) {\n\t\t\tif (ret == -EBADMSG)\n\t\t\t\tcon->error_msg = \"integrity error, bad epilogue auth tag\";\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* just late_status */\n\t\tret = decode_epilogue(con->v2.in_buf, NULL, NULL, NULL);\n\t\tif (ret) {\n\t\t\tcon->error_msg = \"protocol error, bad epilogue\";\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = decode_epilogue(con->v2.in_buf, &front_crc,\n\t\t\t\t      &middle_crc, &data_crc);\n\t\tif (ret) {\n\t\t\tcon->error_msg = \"protocol error, bad epilogue\";\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = verify_epilogue_crcs(con, front_crc, middle_crc,\n\t\t\t\t\t   data_crc);\n\t\tif (ret) {\n\t\t\tcon->error_msg = \"integrity error, bad crc\";\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn process_message(con);\n}\n\nstatic void finish_skip(struct ceph_connection *con)\n{\n\tdout(\"%s con %p\\n\", __func__, con);\n\n\tif (con_secure(con))\n\t\tgcm_inc_nonce(&con->v2.in_gcm_nonce);\n\n\t__finish_skip(con);\n}\n\nstatic int populate_in_iter(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s con %p state %d in_state %d\\n\", __func__, con, con->state,\n\t     con->v2.in_state);\n\tWARN_ON(iov_iter_count(&con->v2.in_iter));\n\n\tif (con->state == CEPH_CON_S_V2_BANNER_PREFIX) {\n\t\tret = process_banner_prefix(con);\n\t} else if (con->state == CEPH_CON_S_V2_BANNER_PAYLOAD) {\n\t\tret = process_banner_payload(con);\n\t} else if ((con->state >= CEPH_CON_S_V2_HELLO &&\n\t\t    con->state <= CEPH_CON_S_V2_SESSION_RECONNECT) ||\n\t\t   con->state == CEPH_CON_S_OPEN) {\n\t\tswitch (con->v2.in_state) {\n\t\tcase IN_S_HANDLE_PREAMBLE:\n\t\t\tret = handle_preamble(con);\n\t\t\tbreak;\n\t\tcase IN_S_HANDLE_CONTROL:\n\t\t\tret = handle_control(con);\n\t\t\tbreak;\n\t\tcase IN_S_HANDLE_CONTROL_REMAINDER:\n\t\t\tret = handle_control_remainder(con);\n\t\t\tbreak;\n\t\tcase IN_S_PREPARE_READ_DATA:\n\t\t\tret = prepare_read_data(con);\n\t\t\tbreak;\n\t\tcase IN_S_PREPARE_READ_DATA_CONT:\n\t\t\tprepare_read_data_cont(con);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase IN_S_PREPARE_READ_ENC_PAGE:\n\t\t\tprepare_read_enc_page(con);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase IN_S_HANDLE_EPILOGUE:\n\t\t\tret = handle_epilogue(con);\n\t\t\tbreak;\n\t\tcase IN_S_FINISH_SKIP:\n\t\t\tfinish_skip(con);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"bad in_state %d\", con->v2.in_state);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tWARN(1, \"bad state %d\", con->state);\n\t\treturn -EINVAL;\n\t}\n\tif (ret) {\n\t\tdout(\"%s con %p error %d\\n\", __func__, con, ret);\n\t\treturn ret;\n\t}\n\n\tif (WARN_ON(!iov_iter_count(&con->v2.in_iter)))\n\t\treturn -ENODATA;\n\tdout(\"%s con %p populated %zu\\n\", __func__, con,\n\t     iov_iter_count(&con->v2.in_iter));\n\treturn 1;\n}\n\nint ceph_con_v2_try_read(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s con %p state %d need %zu\\n\", __func__, con, con->state,\n\t     iov_iter_count(&con->v2.in_iter));\n\n\tif (con->state == CEPH_CON_S_PREOPEN)\n\t\treturn 0;\n\n\t/*\n\t * We should always have something pending here.  If not,\n\t * avoid calling populate_in_iter() as if we read something\n\t * (ceph_tcp_recv() would immediately return 1).\n\t */\n\tif (WARN_ON(!iov_iter_count(&con->v2.in_iter)))\n\t\treturn -ENODATA;\n\n\tfor (;;) {\n\t\tret = ceph_tcp_recv(con);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tret = populate_in_iter(con);\n\t\tif (ret <= 0) {\n\t\t\tif (ret && ret != -EAGAIN && !con->error_msg)\n\t\t\t\tcon->error_msg = \"read processing error\";\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n\nstatic void queue_data(struct ceph_connection *con)\n{\n\tstruct bio_vec bv;\n\n\tcon->v2.out_epil.data_crc = -1;\n\tceph_msg_data_cursor_init(&con->v2.out_cursor, con->out_msg,\n\t\t\t\t  data_len(con->out_msg));\n\n\tget_bvec_at(&con->v2.out_cursor, &bv);\n\tset_out_bvec(con, &bv, true);\n\tcon->v2.out_state = OUT_S_QUEUE_DATA_CONT;\n}\n\nstatic void queue_data_cont(struct ceph_connection *con)\n{\n\tstruct bio_vec bv;\n\n\tcon->v2.out_epil.data_crc = ceph_crc32c_page(\n\t\tcon->v2.out_epil.data_crc, con->v2.out_bvec.bv_page,\n\t\tcon->v2.out_bvec.bv_offset, con->v2.out_bvec.bv_len);\n\n\tceph_msg_data_advance(&con->v2.out_cursor, con->v2.out_bvec.bv_len);\n\tif (con->v2.out_cursor.total_resid) {\n\t\tget_bvec_at(&con->v2.out_cursor, &bv);\n\t\tset_out_bvec(con, &bv, true);\n\t\tWARN_ON(con->v2.out_state != OUT_S_QUEUE_DATA_CONT);\n\t\treturn;\n\t}\n\n\t/*\n\t * We've written all data.  Queue epilogue.  Once it's written,\n\t * we are done.\n\t */\n\treset_out_kvecs(con);\n\tprepare_epilogue_plain(con, false);\n\tcon->v2.out_state = OUT_S_FINISH_MESSAGE;\n}\n\nstatic void queue_enc_page(struct ceph_connection *con)\n{\n\tstruct bio_vec bv;\n\n\tdout(\"%s con %p i %d resid %d\\n\", __func__, con, con->v2.out_enc_i,\n\t     con->v2.out_enc_resid);\n\tWARN_ON(!con->v2.out_enc_resid);\n\n\tbvec_set_page(&bv, con->v2.out_enc_pages[con->v2.out_enc_i],\n\t\t      min(con->v2.out_enc_resid, (int)PAGE_SIZE), 0);\n\n\tset_out_bvec(con, &bv, false);\n\tcon->v2.out_enc_i++;\n\tcon->v2.out_enc_resid -= bv.bv_len;\n\n\tif (con->v2.out_enc_resid) {\n\t\tWARN_ON(con->v2.out_state != OUT_S_QUEUE_ENC_PAGE);\n\t\treturn;\n\t}\n\n\t/*\n\t * We've queued the last piece of ciphertext (ending with\n\t * epilogue) + auth tag.  Once it's written, we are done.\n\t */\n\tWARN_ON(con->v2.out_enc_i != con->v2.out_enc_page_cnt);\n\tcon->v2.out_state = OUT_S_FINISH_MESSAGE;\n}\n\nstatic void queue_zeros(struct ceph_connection *con)\n{\n\tdout(\"%s con %p out_zero %d\\n\", __func__, con, con->v2.out_zero);\n\n\tif (con->v2.out_zero) {\n\t\tset_out_bvec_zero(con);\n\t\tcon->v2.out_zero -= con->v2.out_bvec.bv_len;\n\t\tcon->v2.out_state = OUT_S_QUEUE_ZEROS;\n\t\treturn;\n\t}\n\n\t/*\n\t * We've zero-filled everything up to epilogue.  Queue epilogue\n\t * with late_status set to ABORTED and crcs adjusted for zeros.\n\t * Once it's written, we are done patching up for the revoke.\n\t */\n\treset_out_kvecs(con);\n\tprepare_epilogue_plain(con, true);\n\tcon->v2.out_state = OUT_S_FINISH_MESSAGE;\n}\n\nstatic void finish_message(struct ceph_connection *con)\n{\n\tdout(\"%s con %p msg %p\\n\", __func__, con, con->out_msg);\n\n\t/* we end up here both plain and secure modes */\n\tif (con->v2.out_enc_pages) {\n\t\tWARN_ON(!con->v2.out_enc_page_cnt);\n\t\tceph_release_page_vector(con->v2.out_enc_pages,\n\t\t\t\t\t con->v2.out_enc_page_cnt);\n\t\tcon->v2.out_enc_pages = NULL;\n\t\tcon->v2.out_enc_page_cnt = 0;\n\t}\n\t/* message may have been revoked */\n\tif (con->out_msg) {\n\t\tceph_msg_put(con->out_msg);\n\t\tcon->out_msg = NULL;\n\t}\n\n\tcon->v2.out_state = OUT_S_GET_NEXT;\n}\n\nstatic int populate_out_iter(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s con %p state %d out_state %d\\n\", __func__, con, con->state,\n\t     con->v2.out_state);\n\tWARN_ON(iov_iter_count(&con->v2.out_iter));\n\n\tif (con->state != CEPH_CON_S_OPEN) {\n\t\tWARN_ON(con->state < CEPH_CON_S_V2_BANNER_PREFIX ||\n\t\t\tcon->state > CEPH_CON_S_V2_SESSION_RECONNECT);\n\t\tgoto nothing_pending;\n\t}\n\n\tswitch (con->v2.out_state) {\n\tcase OUT_S_QUEUE_DATA:\n\t\tWARN_ON(!con->out_msg);\n\t\tqueue_data(con);\n\t\tgoto populated;\n\tcase OUT_S_QUEUE_DATA_CONT:\n\t\tWARN_ON(!con->out_msg);\n\t\tqueue_data_cont(con);\n\t\tgoto populated;\n\tcase OUT_S_QUEUE_ENC_PAGE:\n\t\tqueue_enc_page(con);\n\t\tgoto populated;\n\tcase OUT_S_QUEUE_ZEROS:\n\t\tWARN_ON(con->out_msg);  /* revoked */\n\t\tqueue_zeros(con);\n\t\tgoto populated;\n\tcase OUT_S_FINISH_MESSAGE:\n\t\tfinish_message(con);\n\t\tbreak;\n\tcase OUT_S_GET_NEXT:\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"bad out_state %d\", con->v2.out_state);\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(con->v2.out_state != OUT_S_GET_NEXT);\n\tif (ceph_con_flag_test_and_clear(con, CEPH_CON_F_KEEPALIVE_PENDING)) {\n\t\tret = prepare_keepalive2(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_keepalive2 failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else if (!list_empty(&con->out_queue)) {\n\t\tceph_con_get_out_msg(con);\n\t\tret = prepare_message(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_message failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else if (con->in_seq > con->in_seq_acked) {\n\t\tret = prepare_ack(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_ack failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tgoto nothing_pending;\n\t}\n\npopulated:\n\tif (WARN_ON(!iov_iter_count(&con->v2.out_iter)))\n\t\treturn -ENODATA;\n\tdout(\"%s con %p populated %zu\\n\", __func__, con,\n\t     iov_iter_count(&con->v2.out_iter));\n\treturn 1;\n\nnothing_pending:\n\tWARN_ON(iov_iter_count(&con->v2.out_iter));\n\tdout(\"%s con %p nothing pending\\n\", __func__, con);\n\tceph_con_flag_clear(con, CEPH_CON_F_WRITE_PENDING);\n\treturn 0;\n}\n\nint ceph_con_v2_try_write(struct ceph_connection *con)\n{\n\tint ret;\n\n\tdout(\"%s con %p state %d have %zu\\n\", __func__, con, con->state,\n\t     iov_iter_count(&con->v2.out_iter));\n\n\t/* open the socket first? */\n\tif (con->state == CEPH_CON_S_PREOPEN) {\n\t\tWARN_ON(con->peer_addr.type != CEPH_ENTITY_ADDR_TYPE_MSGR2);\n\n\t\t/*\n\t\t * Always bump global_seq.  Bump connect_seq only if\n\t\t * there is a session (i.e. we are reconnecting and will\n\t\t * send session_reconnect instead of client_ident).\n\t\t */\n\t\tcon->v2.global_seq = ceph_get_global_seq(con->msgr, 0);\n\t\tif (con->v2.server_cookie)\n\t\t\tcon->v2.connect_seq++;\n\n\t\tret = prepare_read_banner_prefix(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_read_banner_prefix failed: %d\\n\", ret);\n\t\t\tcon->error_msg = \"connect error\";\n\t\t\treturn ret;\n\t\t}\n\n\t\treset_out_kvecs(con);\n\t\tret = prepare_banner(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"prepare_banner failed: %d\\n\", ret);\n\t\t\tcon->error_msg = \"connect error\";\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ceph_tcp_connect(con);\n\t\tif (ret) {\n\t\t\tpr_err(\"ceph_tcp_connect failed: %d\\n\", ret);\n\t\t\tcon->error_msg = \"connect error\";\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!iov_iter_count(&con->v2.out_iter)) {\n\t\tret = populate_out_iter(con);\n\t\tif (ret <= 0) {\n\t\t\tif (ret && ret != -EAGAIN && !con->error_msg)\n\t\t\t\tcon->error_msg = \"write processing error\";\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttcp_sock_set_cork(con->sock->sk, true);\n\tfor (;;) {\n\t\tret = ceph_tcp_send(con);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tret = populate_out_iter(con);\n\t\tif (ret <= 0) {\n\t\t\tif (ret && ret != -EAGAIN && !con->error_msg)\n\t\t\t\tcon->error_msg = \"write processing error\";\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttcp_sock_set_cork(con->sock->sk, false);\n\treturn ret;\n}\n\nstatic u32 crc32c_zeros(u32 crc, int zero_len)\n{\n\tint len;\n\n\twhile (zero_len) {\n\t\tlen = min(zero_len, (int)PAGE_SIZE);\n\t\tcrc = crc32c(crc, page_address(ceph_zero_page), len);\n\t\tzero_len -= len;\n\t}\n\n\treturn crc;\n}\n\nstatic void prepare_zero_front(struct ceph_connection *con, int resid)\n{\n\tint sent;\n\n\tWARN_ON(!resid || resid > front_len(con->out_msg));\n\tsent = front_len(con->out_msg) - resid;\n\tdout(\"%s con %p sent %d resid %d\\n\", __func__, con, sent, resid);\n\n\tif (sent) {\n\t\tcon->v2.out_epil.front_crc =\n\t\t\tcrc32c(-1, con->out_msg->front.iov_base, sent);\n\t\tcon->v2.out_epil.front_crc =\n\t\t\tcrc32c_zeros(con->v2.out_epil.front_crc, resid);\n\t} else {\n\t\tcon->v2.out_epil.front_crc = crc32c_zeros(-1, resid);\n\t}\n\n\tcon->v2.out_iter.count -= resid;\n\tout_zero_add(con, resid);\n}\n\nstatic void prepare_zero_middle(struct ceph_connection *con, int resid)\n{\n\tint sent;\n\n\tWARN_ON(!resid || resid > middle_len(con->out_msg));\n\tsent = middle_len(con->out_msg) - resid;\n\tdout(\"%s con %p sent %d resid %d\\n\", __func__, con, sent, resid);\n\n\tif (sent) {\n\t\tcon->v2.out_epil.middle_crc =\n\t\t\tcrc32c(-1, con->out_msg->middle->vec.iov_base, sent);\n\t\tcon->v2.out_epil.middle_crc =\n\t\t\tcrc32c_zeros(con->v2.out_epil.middle_crc, resid);\n\t} else {\n\t\tcon->v2.out_epil.middle_crc = crc32c_zeros(-1, resid);\n\t}\n\n\tcon->v2.out_iter.count -= resid;\n\tout_zero_add(con, resid);\n}\n\nstatic void prepare_zero_data(struct ceph_connection *con)\n{\n\tdout(\"%s con %p\\n\", __func__, con);\n\tcon->v2.out_epil.data_crc = crc32c_zeros(-1, data_len(con->out_msg));\n\tout_zero_add(con, data_len(con->out_msg));\n}\n\nstatic void revoke_at_queue_data(struct ceph_connection *con)\n{\n\tint boundary;\n\tint resid;\n\n\tWARN_ON(!data_len(con->out_msg));\n\tWARN_ON(!iov_iter_is_kvec(&con->v2.out_iter));\n\tresid = iov_iter_count(&con->v2.out_iter);\n\n\tboundary = front_len(con->out_msg) + middle_len(con->out_msg);\n\tif (resid > boundary) {\n\t\tresid -= boundary;\n\t\tWARN_ON(resid > MESSAGE_HEAD_PLAIN_LEN);\n\t\tdout(\"%s con %p was sending head\\n\", __func__, con);\n\t\tif (front_len(con->out_msg))\n\t\t\tprepare_zero_front(con, front_len(con->out_msg));\n\t\tif (middle_len(con->out_msg))\n\t\t\tprepare_zero_middle(con, middle_len(con->out_msg));\n\t\tprepare_zero_data(con);\n\t\tWARN_ON(iov_iter_count(&con->v2.out_iter) != resid);\n\t\tcon->v2.out_state = OUT_S_QUEUE_ZEROS;\n\t\treturn;\n\t}\n\n\tboundary = middle_len(con->out_msg);\n\tif (resid > boundary) {\n\t\tresid -= boundary;\n\t\tdout(\"%s con %p was sending front\\n\", __func__, con);\n\t\tprepare_zero_front(con, resid);\n\t\tif (middle_len(con->out_msg))\n\t\t\tprepare_zero_middle(con, middle_len(con->out_msg));\n\t\tprepare_zero_data(con);\n\t\tqueue_zeros(con);\n\t\treturn;\n\t}\n\n\tWARN_ON(!resid);\n\tdout(\"%s con %p was sending middle\\n\", __func__, con);\n\tprepare_zero_middle(con, resid);\n\tprepare_zero_data(con);\n\tqueue_zeros(con);\n}\n\nstatic void revoke_at_queue_data_cont(struct ceph_connection *con)\n{\n\tint sent, resid;  /* current piece of data */\n\n\tWARN_ON(!data_len(con->out_msg));\n\tWARN_ON(!iov_iter_is_bvec(&con->v2.out_iter));\n\tresid = iov_iter_count(&con->v2.out_iter);\n\tWARN_ON(!resid || resid > con->v2.out_bvec.bv_len);\n\tsent = con->v2.out_bvec.bv_len - resid;\n\tdout(\"%s con %p sent %d resid %d\\n\", __func__, con, sent, resid);\n\n\tif (sent) {\n\t\tcon->v2.out_epil.data_crc = ceph_crc32c_page(\n\t\t\tcon->v2.out_epil.data_crc, con->v2.out_bvec.bv_page,\n\t\t\tcon->v2.out_bvec.bv_offset, sent);\n\t\tceph_msg_data_advance(&con->v2.out_cursor, sent);\n\t}\n\tWARN_ON(resid > con->v2.out_cursor.total_resid);\n\tcon->v2.out_epil.data_crc = crc32c_zeros(con->v2.out_epil.data_crc,\n\t\t\t\t\t\tcon->v2.out_cursor.total_resid);\n\n\tcon->v2.out_iter.count -= resid;\n\tout_zero_add(con, con->v2.out_cursor.total_resid);\n\tqueue_zeros(con);\n}\n\nstatic void revoke_at_finish_message(struct ceph_connection *con)\n{\n\tint boundary;\n\tint resid;\n\n\tWARN_ON(!iov_iter_is_kvec(&con->v2.out_iter));\n\tresid = iov_iter_count(&con->v2.out_iter);\n\n\tif (!front_len(con->out_msg) && !middle_len(con->out_msg) &&\n\t    !data_len(con->out_msg)) {\n\t\tWARN_ON(!resid || resid > MESSAGE_HEAD_PLAIN_LEN);\n\t\tdout(\"%s con %p was sending head (empty message) - noop\\n\",\n\t\t     __func__, con);\n\t\treturn;\n\t}\n\n\tboundary = front_len(con->out_msg) + middle_len(con->out_msg) +\n\t\t   CEPH_EPILOGUE_PLAIN_LEN;\n\tif (resid > boundary) {\n\t\tresid -= boundary;\n\t\tWARN_ON(resid > MESSAGE_HEAD_PLAIN_LEN);\n\t\tdout(\"%s con %p was sending head\\n\", __func__, con);\n\t\tif (front_len(con->out_msg))\n\t\t\tprepare_zero_front(con, front_len(con->out_msg));\n\t\tif (middle_len(con->out_msg))\n\t\t\tprepare_zero_middle(con, middle_len(con->out_msg));\n\t\tcon->v2.out_iter.count -= CEPH_EPILOGUE_PLAIN_LEN;\n\t\tWARN_ON(iov_iter_count(&con->v2.out_iter) != resid);\n\t\tcon->v2.out_state = OUT_S_QUEUE_ZEROS;\n\t\treturn;\n\t}\n\n\tboundary = middle_len(con->out_msg) + CEPH_EPILOGUE_PLAIN_LEN;\n\tif (resid > boundary) {\n\t\tresid -= boundary;\n\t\tdout(\"%s con %p was sending front\\n\", __func__, con);\n\t\tprepare_zero_front(con, resid);\n\t\tif (middle_len(con->out_msg))\n\t\t\tprepare_zero_middle(con, middle_len(con->out_msg));\n\t\tcon->v2.out_iter.count -= CEPH_EPILOGUE_PLAIN_LEN;\n\t\tqueue_zeros(con);\n\t\treturn;\n\t}\n\n\tboundary = CEPH_EPILOGUE_PLAIN_LEN;\n\tif (resid > boundary) {\n\t\tresid -= boundary;\n\t\tdout(\"%s con %p was sending middle\\n\", __func__, con);\n\t\tprepare_zero_middle(con, resid);\n\t\tcon->v2.out_iter.count -= CEPH_EPILOGUE_PLAIN_LEN;\n\t\tqueue_zeros(con);\n\t\treturn;\n\t}\n\n\tWARN_ON(!resid);\n\tdout(\"%s con %p was sending epilogue - noop\\n\", __func__, con);\n}\n\nvoid ceph_con_v2_revoke(struct ceph_connection *con)\n{\n\tWARN_ON(con->v2.out_zero);\n\n\tif (con_secure(con)) {\n\t\tWARN_ON(con->v2.out_state != OUT_S_QUEUE_ENC_PAGE &&\n\t\t\tcon->v2.out_state != OUT_S_FINISH_MESSAGE);\n\t\tdout(\"%s con %p secure - noop\\n\", __func__, con);\n\t\treturn;\n\t}\n\n\tswitch (con->v2.out_state) {\n\tcase OUT_S_QUEUE_DATA:\n\t\trevoke_at_queue_data(con);\n\t\tbreak;\n\tcase OUT_S_QUEUE_DATA_CONT:\n\t\trevoke_at_queue_data_cont(con);\n\t\tbreak;\n\tcase OUT_S_FINISH_MESSAGE:\n\t\trevoke_at_finish_message(con);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"bad out_state %d\", con->v2.out_state);\n\t\tbreak;\n\t}\n}\n\nstatic void revoke_at_prepare_read_data(struct ceph_connection *con)\n{\n\tint remaining;\n\tint resid;\n\n\tWARN_ON(con_secure(con));\n\tWARN_ON(!data_len(con->in_msg));\n\tWARN_ON(!iov_iter_is_kvec(&con->v2.in_iter));\n\tresid = iov_iter_count(&con->v2.in_iter);\n\tWARN_ON(!resid);\n\n\tremaining = data_len(con->in_msg) + CEPH_EPILOGUE_PLAIN_LEN;\n\tdout(\"%s con %p resid %d remaining %d\\n\", __func__, con, resid,\n\t     remaining);\n\tcon->v2.in_iter.count -= resid;\n\tset_in_skip(con, resid + remaining);\n\tcon->v2.in_state = IN_S_FINISH_SKIP;\n}\n\nstatic void revoke_at_prepare_read_data_cont(struct ceph_connection *con)\n{\n\tint recved, resid;  /* current piece of data */\n\tint remaining;\n\n\tWARN_ON(con_secure(con));\n\tWARN_ON(!data_len(con->in_msg));\n\tWARN_ON(!iov_iter_is_bvec(&con->v2.in_iter));\n\tresid = iov_iter_count(&con->v2.in_iter);\n\tWARN_ON(!resid || resid > con->v2.in_bvec.bv_len);\n\trecved = con->v2.in_bvec.bv_len - resid;\n\tdout(\"%s con %p recved %d resid %d\\n\", __func__, con, recved, resid);\n\n\tif (recved)\n\t\tceph_msg_data_advance(&con->v2.in_cursor, recved);\n\tWARN_ON(resid > con->v2.in_cursor.total_resid);\n\n\tremaining = CEPH_EPILOGUE_PLAIN_LEN;\n\tdout(\"%s con %p total_resid %zu remaining %d\\n\", __func__, con,\n\t     con->v2.in_cursor.total_resid, remaining);\n\tcon->v2.in_iter.count -= resid;\n\tset_in_skip(con, con->v2.in_cursor.total_resid + remaining);\n\tcon->v2.in_state = IN_S_FINISH_SKIP;\n}\n\nstatic void revoke_at_prepare_read_enc_page(struct ceph_connection *con)\n{\n\tint resid;  /* current enc page (not necessarily data) */\n\n\tWARN_ON(!con_secure(con));\n\tWARN_ON(!iov_iter_is_bvec(&con->v2.in_iter));\n\tresid = iov_iter_count(&con->v2.in_iter);\n\tWARN_ON(!resid || resid > con->v2.in_bvec.bv_len);\n\n\tdout(\"%s con %p resid %d enc_resid %d\\n\", __func__, con, resid,\n\t     con->v2.in_enc_resid);\n\tcon->v2.in_iter.count -= resid;\n\tset_in_skip(con, resid + con->v2.in_enc_resid);\n\tcon->v2.in_state = IN_S_FINISH_SKIP;\n}\n\nstatic void revoke_at_handle_epilogue(struct ceph_connection *con)\n{\n\tint resid;\n\n\tresid = iov_iter_count(&con->v2.in_iter);\n\tWARN_ON(!resid);\n\n\tdout(\"%s con %p resid %d\\n\", __func__, con, resid);\n\tcon->v2.in_iter.count -= resid;\n\tset_in_skip(con, resid);\n\tcon->v2.in_state = IN_S_FINISH_SKIP;\n}\n\nvoid ceph_con_v2_revoke_incoming(struct ceph_connection *con)\n{\n\tswitch (con->v2.in_state) {\n\tcase IN_S_PREPARE_READ_DATA:\n\t\trevoke_at_prepare_read_data(con);\n\t\tbreak;\n\tcase IN_S_PREPARE_READ_DATA_CONT:\n\t\trevoke_at_prepare_read_data_cont(con);\n\t\tbreak;\n\tcase IN_S_PREPARE_READ_ENC_PAGE:\n\t\trevoke_at_prepare_read_enc_page(con);\n\t\tbreak;\n\tcase IN_S_HANDLE_EPILOGUE:\n\t\trevoke_at_handle_epilogue(con);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"bad in_state %d\", con->v2.in_state);\n\t\tbreak;\n\t}\n}\n\nbool ceph_con_v2_opened(struct ceph_connection *con)\n{\n\treturn con->v2.peer_global_seq;\n}\n\nvoid ceph_con_v2_reset_session(struct ceph_connection *con)\n{\n\tcon->v2.client_cookie = 0;\n\tcon->v2.server_cookie = 0;\n\tcon->v2.global_seq = 0;\n\tcon->v2.connect_seq = 0;\n\tcon->v2.peer_global_seq = 0;\n}\n\nvoid ceph_con_v2_reset_protocol(struct ceph_connection *con)\n{\n\tiov_iter_truncate(&con->v2.in_iter, 0);\n\tiov_iter_truncate(&con->v2.out_iter, 0);\n\tcon->v2.out_zero = 0;\n\n\tclear_in_sign_kvecs(con);\n\tclear_out_sign_kvecs(con);\n\tfree_conn_bufs(con);\n\n\tif (con->v2.in_enc_pages) {\n\t\tWARN_ON(!con->v2.in_enc_page_cnt);\n\t\tceph_release_page_vector(con->v2.in_enc_pages,\n\t\t\t\t\t con->v2.in_enc_page_cnt);\n\t\tcon->v2.in_enc_pages = NULL;\n\t\tcon->v2.in_enc_page_cnt = 0;\n\t}\n\tif (con->v2.out_enc_pages) {\n\t\tWARN_ON(!con->v2.out_enc_page_cnt);\n\t\tceph_release_page_vector(con->v2.out_enc_pages,\n\t\t\t\t\t con->v2.out_enc_page_cnt);\n\t\tcon->v2.out_enc_pages = NULL;\n\t\tcon->v2.out_enc_page_cnt = 0;\n\t}\n\n\tcon->v2.con_mode = CEPH_CON_MODE_UNKNOWN;\n\tmemzero_explicit(&con->v2.in_gcm_nonce, CEPH_GCM_IV_LEN);\n\tmemzero_explicit(&con->v2.out_gcm_nonce, CEPH_GCM_IV_LEN);\n\n\tif (con->v2.hmac_tfm) {\n\t\tcrypto_free_shash(con->v2.hmac_tfm);\n\t\tcon->v2.hmac_tfm = NULL;\n\t}\n\tif (con->v2.gcm_req) {\n\t\taead_request_free(con->v2.gcm_req);\n\t\tcon->v2.gcm_req = NULL;\n\t}\n\tif (con->v2.gcm_tfm) {\n\t\tcrypto_free_aead(con->v2.gcm_tfm);\n\t\tcon->v2.gcm_tfm = NULL;\n\t}\n}\n"], "filenames": ["net/ceph/messenger_v2.c"], "buggy_code_start_loc": [392], "buggy_code_end_loc": [546], "fixing_code_start_loc": [393], "fixing_code_end_loc": [557], "type": "CWE-120", "message": "An issue was discovered in net/ceph/messenger_v2.c in the Linux kernel before 6.4.5. There is an integer signedness error, leading to a buffer overflow and remote code execution via HELLO or one of the AUTH frames. This occurs because of an untrusted length taken from a TCP packet in ceph_decode_32.", "other": {"cve": {"id": "CVE-2023-44466", "sourceIdentifier": "cve@mitre.org", "published": "2023-09-29T06:15:11.007", "lastModified": "2024-01-21T02:16:22.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in net/ceph/messenger_v2.c in the Linux kernel before 6.4.5. There is an integer signedness error, leading to a buffer overflow and remote code execution via HELLO or one of the AUTH frames. This occurs because of an untrusted length taken from a TCP packet in ceph_decode_32."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en net/ceph/messenger_v2.c en el kernel de Linux anterior a 6.4.5. Hay un error de firma de enteros, lo que provoca un desbordamiento del b\u00fafer y la ejecuci\u00f3n remota de c\u00f3digo a trav\u00e9s de HELLO o uno de los frames AUTH. Esto ocurre debido a una longitud no confiable tomada de un paquete TCP en ceph_decode_32."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.4.5", "matchCriteriaId": "5819C299-33F3-4B58-B0ED-46B0C73B4A51"}]}]}], "references": [{"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=a282a2f10539dce2aa619e71e1817570d557fc97", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}, {"url": "https://github.com/google/security-research/security/advisories/GHSA-jg27-jx6w-xwph", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/a282a2f10539dce2aa619e71e1817570d557fc97", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.netapp.com/advisory/ntap-20231116-0003/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.spinics.net/lists/ceph-devel/msg57909.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/a282a2f10539dce2aa619e71e1817570d557fc97"}}