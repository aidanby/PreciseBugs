{"buggy_code": ["# This code is part of Ansible, but is an independent component.\n# This particular file snippet, and this file snippet only, is BSD licensed.\n# Modules you write using this snippet, which is embedded dynamically by Ansible\n# still belong to the author of the module, and may assign their own license\n# to the complete work.\n# \n# Copyright (c), Michael DeHaan <michael.dehaan@gmail.com>, 2012-2013\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without modification, \n# are permitted provided that the following conditions are met:\n#\n#    * Redistributions of source code must retain the above copyright \n#      notice, this list of conditions and the following disclaimer.\n#    * Redistributions in binary form must reproduce the above copyright notice, \n#      this list of conditions and the following disclaimer in the documentation \n#      and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, \n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT \n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE \n# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n\n# == BEGIN DYNAMICALLY INSERTED CODE ==\n\nMODULE_ARGS = \"<<INCLUDE_ANSIBLE_MODULE_ARGS>>\"\nMODULE_COMPLEX_ARGS = \"<<INCLUDE_ANSIBLE_MODULE_COMPLEX_ARGS>>\"\n\nBOOLEANS_TRUE = ['yes', 'on', '1', 'true', 1]\nBOOLEANS_FALSE = ['no', 'off', '0', 'false', 0]\nBOOLEANS = BOOLEANS_TRUE + BOOLEANS_FALSE\n\n# ansible modules can be written in any language.  To simplify\n# development of Python modules, the functions available here\n# can be inserted in any module source automatically by including\n# #<<INCLUDE_ANSIBLE_MODULE_COMMON>> on a blank line by itself inside\n# of an ansible module. The source of this common code lives\n# in lib/ansible/module_common.py\n\nimport locale\nimport os\nimport re\nimport pipes\nimport shlex\nimport subprocess\nimport sys\nimport syslog\nimport types\nimport time\nimport shutil\nimport stat\nimport tempfile\nimport traceback\nimport grp\nimport pwd\nimport platform\nimport errno\nimport tempfile\n\ntry:\n    import json\nexcept ImportError:\n    try:\n        import simplejson as json\n    except ImportError:\n        sys.stderr.write('Error: ansible requires a json module, none found!')\n        sys.exit(1)\n    except SyntaxError:\n        sys.stderr.write('SyntaxError: probably due to json and python being for different versions')\n        sys.exit(1)\n\nHAVE_SELINUX=False\ntry:\n    import selinux\n    HAVE_SELINUX=True\nexcept ImportError:\n    pass\n\nHAVE_HASHLIB=False\ntry:\n    from hashlib import md5 as _md5\n    HAVE_HASHLIB=True\nexcept ImportError:\n    from md5 import md5 as _md5\n\ntry:\n    from hashlib import sha256 as _sha256\nexcept ImportError:\n    pass\n\ntry:\n    from systemd import journal\n    has_journal = True\nexcept ImportError:\n    import syslog\n    has_journal = False\n\nFILE_COMMON_ARGUMENTS=dict(\n    src = dict(),\n    mode = dict(),\n    owner = dict(),\n    group = dict(),\n    seuser = dict(),\n    serole = dict(),\n    selevel = dict(),\n    setype = dict(),\n    # not taken by the file module, but other modules call file so it must ignore them.\n    content = dict(),\n    backup = dict(),\n    force = dict(),\n    remote_src = dict(), # used by assemble\n    delimiter = dict(), # used by assemble\n    directory_mode = dict(), # used by copy\n)\n\n\ndef get_platform():\n    ''' what's the platform?  example: Linux is a platform. '''\n    return platform.system()\n\ndef get_distribution():\n    ''' return the distribution name '''\n    if platform.system() == 'Linux':\n        try:\n            distribution = platform.linux_distribution()[0].capitalize()\n            if not distribution and os.path.isfile('/etc/system-release'):\n                distribution = platform.linux_distribution(supported_dists=['system'])[0].capitalize()\n                if 'Amazon' in distribution:\n                    distribution = 'Amazon'\n                else:\n                    distribution = 'OtherLinux'\n        except:\n            # FIXME: MethodMissing, I assume?\n            distribution = platform.dist()[0].capitalize()\n    else:\n        distribution = None\n    return distribution\n\ndef load_platform_subclass(cls, *args, **kwargs):\n    '''\n    used by modules like User to have different implementations based on detected platform.  See User\n    module for an example.\n    '''\n\n    this_platform = get_platform()\n    distribution = get_distribution()\n    subclass = None\n\n    # get the most specific superclass for this platform\n    if distribution is not None:\n        for sc in cls.__subclasses__():\n            if sc.distribution is not None and sc.distribution == distribution and sc.platform == this_platform:\n                subclass = sc\n    if subclass is None:\n        for sc in cls.__subclasses__():\n            if sc.platform == this_platform and sc.distribution is None:\n                subclass = sc\n    if subclass is None:\n        subclass = cls\n\n    return super(cls, subclass).__new__(subclass)\n\n\nclass AnsibleModule(object):\n\n    def __init__(self, argument_spec, bypass_checks=False, no_log=False,\n        check_invalid_arguments=True, mutually_exclusive=None, required_together=None,\n        required_one_of=None, add_file_common_args=False, supports_check_mode=False):\n\n        '''\n        common code for quickly building an ansible module in Python\n        (although you can write modules in anything that can return JSON)\n        see library/* for examples\n        '''\n\n        self.argument_spec = argument_spec\n        self.supports_check_mode = supports_check_mode\n        self.check_mode = False\n        self.no_log = no_log\n        self.cleanup_files = []\n        \n        self.aliases = {}\n        \n        if add_file_common_args:\n            for k, v in FILE_COMMON_ARGUMENTS.iteritems():\n                if k not in self.argument_spec:\n                    self.argument_spec[k] = v\n\n        # check the locale as set by the current environment, and\n        # reset to LANG=C if it's an invalid/unavailable locale\n        self._check_locale()\n\n        (self.params, self.args) = self._load_params()\n\n        self._legal_inputs = ['CHECKMODE', 'NO_LOG']\n        \n        self.aliases = self._handle_aliases()\n\n        if check_invalid_arguments:\n            self._check_invalid_arguments()\n        self._check_for_check_mode()\n        self._check_for_no_log()\n\n        # check exclusive early \n        if not bypass_checks:\n            self._check_mutually_exclusive(mutually_exclusive)\n\n        self._set_defaults(pre=True)\n\n        if not bypass_checks:\n            self._check_required_arguments()\n            self._check_argument_values()\n            self._check_argument_types()\n            self._check_required_together(required_together)\n            self._check_required_one_of(required_one_of)\n\n        self._set_defaults(pre=False)\n        if not self.no_log:\n            self._log_invocation()\n\n        # finally, make sure we're in a sane working dir\n        self._set_cwd()\n\n    def load_file_common_arguments(self, params):\n        '''\n        many modules deal with files, this encapsulates common\n        options that the file module accepts such that it is directly\n        available to all modules and they can share code.\n        '''\n\n        path = params.get('path', params.get('dest', None))\n        if path is None:\n            return {}\n        else:\n            path = os.path.expanduser(path)\n\n        mode   = params.get('mode', None)\n        owner  = params.get('owner', None)\n        group  = params.get('group', None)\n\n        # selinux related options\n        seuser    = params.get('seuser', None)\n        serole    = params.get('serole', None)\n        setype    = params.get('setype', None)\n        selevel   = params.get('selevel', None)\n        secontext = [seuser, serole, setype]\n\n        if self.selinux_mls_enabled():\n            secontext.append(selevel)\n\n        default_secontext = self.selinux_default_context(path)\n        for i in range(len(default_secontext)):\n            if i is not None and secontext[i] == '_default':\n                secontext[i] = default_secontext[i]\n\n        return dict(\n            path=path, mode=mode, owner=owner, group=group,\n            seuser=seuser, serole=serole, setype=setype,\n            selevel=selevel, secontext=secontext,\n        )\n\n\n    # Detect whether using selinux that is MLS-aware.\n    # While this means you can set the level/range with\n    # selinux.lsetfilecon(), it may or may not mean that you\n    # will get the selevel as part of the context returned\n    # by selinux.lgetfilecon().\n\n    def selinux_mls_enabled(self):\n        if not HAVE_SELINUX:\n            return False\n        if selinux.is_selinux_mls_enabled() == 1:\n            return True\n        else:\n            return False\n\n    def selinux_enabled(self):\n        if not HAVE_SELINUX:\n            seenabled = self.get_bin_path('selinuxenabled')\n            if seenabled is not None:\n                (rc,out,err) = self.run_command(seenabled)\n                if rc == 0:\n                    self.fail_json(msg=\"Aborting, target uses selinux but python bindings (libselinux-python) aren't installed!\")\n            return False\n        if selinux.is_selinux_enabled() == 1:\n            return True\n        else:\n            return False\n\n    # Determine whether we need a placeholder for selevel/mls\n    def selinux_initial_context(self):\n        context = [None, None, None]\n        if self.selinux_mls_enabled():\n            context.append(None)\n        return context\n\n    def _to_filesystem_str(self, path):\n        '''Returns filesystem path as a str, if it wasn't already.\n\n        Used in selinux interactions because it cannot accept unicode\n        instances, and specifying complex args in a playbook leaves\n        you with unicode instances.  This method currently assumes\n        that your filesystem encoding is UTF-8.\n\n        '''\n        if isinstance(path, unicode):\n            path = path.encode(\"utf-8\")\n        return path\n\n    # If selinux fails to find a default, return an array of None\n    def selinux_default_context(self, path, mode=0):\n        context = self.selinux_initial_context()\n        if not HAVE_SELINUX or not self.selinux_enabled():\n            return context\n        try:\n            ret = selinux.matchpathcon(self._to_filesystem_str(path), mode)\n        except OSError:\n            return context\n        if ret[0] == -1:\n            return context\n        # Limit split to 4 because the selevel, the last in the list,\n        # may contain ':' characters\n        context = ret[1].split(':', 3)\n        return context\n\n    def selinux_context(self, path):\n        context = self.selinux_initial_context()\n        if not HAVE_SELINUX or not self.selinux_enabled():\n            return context\n        try:\n            ret = selinux.lgetfilecon_raw(self._to_filesystem_str(path))\n        except OSError, e:\n            if e.errno == errno.ENOENT:\n                self.fail_json(path=path, msg='path %s does not exist' % path)\n            else:\n                self.fail_json(path=path, msg='failed to retrieve selinux context')\n        if ret[0] == -1:\n            return context\n        # Limit split to 4 because the selevel, the last in the list,\n        # may contain ':' characters\n        context = ret[1].split(':', 3)\n        return context\n\n    def user_and_group(self, filename):\n        filename = os.path.expanduser(filename)\n        st = os.lstat(filename)\n        uid = st.st_uid\n        gid = st.st_gid\n        return (uid, gid)\n\n    def find_mount_point(self, path):\n        path = os.path.abspath(os.path.expanduser(os.path.expandvars(path)))\n        while not os.path.ismount(path):\n            path = os.path.dirname(path)\n        return path\n\n    def is_nfs_path(self, path):\n        \"\"\"\n        Returns a tuple containing (True, selinux_context) if the given path\n        is on a NFS mount point, otherwise the return will be (False, None).\n        \"\"\"\n        try:\n            f = open('/proc/mounts', 'r')\n            mount_data = f.readlines()\n            f.close()\n        except:\n            return (False, None)\n        path_mount_point = self.find_mount_point(path)\n        for line in mount_data:\n            (device, mount_point, fstype, options, rest) = line.split(' ', 4)\n            if path_mount_point == mount_point and 'nfs' in fstype:\n                nfs_context = self.selinux_context(path_mount_point)\n                return (True, nfs_context)\n        return (False, None)\n\n    def set_default_selinux_context(self, path, changed):\n        if not HAVE_SELINUX or not self.selinux_enabled():\n            return changed\n        context = self.selinux_default_context(path)\n        return self.set_context_if_different(path, context, False)\n\n    def set_context_if_different(self, path, context, changed):\n\n        if not HAVE_SELINUX or not self.selinux_enabled():\n            return changed\n        cur_context = self.selinux_context(path)\n        new_context = list(cur_context)\n        # Iterate over the current context instead of the\n        # argument context, which may have selevel.\n\n        (is_nfs, nfs_context) = self.is_nfs_path(path)\n        if is_nfs:\n            new_context = nfs_context\n        else:\n            for i in range(len(cur_context)):\n                if len(context) > i:\n                    if context[i] is not None and context[i] != cur_context[i]:\n                        new_context[i] = context[i]\n                    if context[i] is None:\n                        new_context[i] = cur_context[i]\n\n        if cur_context != new_context:\n            try:\n                if self.check_mode:\n                    return True\n                rc = selinux.lsetfilecon(self._to_filesystem_str(path),\n                                         str(':'.join(new_context)))\n            except OSError:\n                self.fail_json(path=path, msg='invalid selinux context', new_context=new_context, cur_context=cur_context, input_was=context)\n            if rc != 0:\n                self.fail_json(path=path, msg='set selinux context failed')\n            changed = True\n        return changed\n\n    def set_owner_if_different(self, path, owner, changed):\n        path = os.path.expanduser(path)\n        if owner is None:\n            return changed\n        orig_uid, orig_gid = self.user_and_group(path)\n        try:\n            uid = int(owner)\n        except ValueError:\n            try:\n                uid = pwd.getpwnam(owner).pw_uid\n            except KeyError:\n                self.fail_json(path=path, msg='chown failed: failed to look up user %s' % owner)\n        if orig_uid != uid:\n            if self.check_mode:\n                return True\n            try:\n                os.lchown(path, uid, -1)\n            except OSError:\n                self.fail_json(path=path, msg='chown failed')\n            changed = True\n        return changed\n\n    def set_group_if_different(self, path, group, changed):\n        path = os.path.expanduser(path)\n        if group is None:\n            return changed\n        orig_uid, orig_gid = self.user_and_group(path)\n        try:\n            gid = int(group)\n        except ValueError:\n            try:\n                gid = grp.getgrnam(group).gr_gid\n            except KeyError:\n                self.fail_json(path=path, msg='chgrp failed: failed to look up group %s' % group)\n        if orig_gid != gid:\n            if self.check_mode:\n                return True\n            try:\n                os.lchown(path, -1, gid)\n            except OSError:\n                self.fail_json(path=path, msg='chgrp failed')\n            changed = True\n        return changed\n\n    def set_mode_if_different(self, path, mode, changed):\n        path = os.path.expanduser(path)\n        if mode is None:\n            return changed\n        try:\n            # FIXME: support English modes\n            if not isinstance(mode, int):\n                mode = int(mode, 8)\n        except Exception, e:\n            self.fail_json(path=path, msg='mode needs to be something octalish', details=str(e))\n\n        st = os.lstat(path)\n        prev_mode = stat.S_IMODE(st[stat.ST_MODE])\n\n        if prev_mode != mode:\n            if self.check_mode:\n                return True\n            # FIXME: comparison against string above will cause this to be executed\n            # every time\n            try:\n                if 'lchmod' in dir(os):\n                    os.lchmod(path, mode)\n                else:\n                    os.chmod(path, mode)\n            except OSError, e:\n                if os.path.islink(path) and e.errno == errno.EPERM:  # Can't set mode on symbolic links\n                    pass\n                elif e.errno == errno.ENOENT: # Can't set mode on broken symbolic links\n                    pass\n                else:\n                    raise e\n            except Exception, e:\n                self.fail_json(path=path, msg='chmod failed', details=str(e))\n\n            st = os.lstat(path)\n            new_mode = stat.S_IMODE(st[stat.ST_MODE])\n\n            if new_mode != prev_mode:\n                changed = True\n        return changed\n\n    def set_fs_attributes_if_different(self, file_args, changed):\n        # set modes owners and context as needed\n        changed = self.set_context_if_different(\n            file_args['path'], file_args['secontext'], changed\n        )\n        changed = self.set_owner_if_different(\n            file_args['path'], file_args['owner'], changed\n        )\n        changed = self.set_group_if_different(\n            file_args['path'], file_args['group'], changed\n        )\n        changed = self.set_mode_if_different(\n            file_args['path'], file_args['mode'], changed\n        )\n        return changed\n\n    def set_directory_attributes_if_different(self, file_args, changed):\n        return self.set_fs_attributes_if_different(file_args, changed)\n\n    def set_file_attributes_if_different(self, file_args, changed):\n        return self.set_fs_attributes_if_different(file_args, changed)\n\n    def add_path_info(self, kwargs):\n        '''\n        for results that are files, supplement the info about the file\n        in the return path with stats about the file path.\n        '''\n\n        path = kwargs.get('path', kwargs.get('dest', None))\n        if path is None:\n            return kwargs\n        if os.path.exists(path):\n            (uid, gid) = self.user_and_group(path)\n            kwargs['uid'] = uid\n            kwargs['gid'] = gid\n            try:\n                user = pwd.getpwuid(uid)[0]\n            except KeyError:\n                user = str(uid)\n            try:\n                group = grp.getgrgid(gid)[0]\n            except KeyError:\n                group = str(gid)\n            kwargs['owner'] = user\n            kwargs['group'] = group\n            st = os.lstat(path)\n            kwargs['mode']  = oct(stat.S_IMODE(st[stat.ST_MODE]))\n            # secontext not yet supported\n            if os.path.islink(path):\n                kwargs['state'] = 'link'\n            elif os.path.isdir(path):\n                kwargs['state'] = 'directory'\n            elif os.stat(path).st_nlink > 1:\n                kwargs['state'] = 'hard'\n            else:\n                kwargs['state'] = 'file'\n            if HAVE_SELINUX and self.selinux_enabled():\n                kwargs['secontext'] = ':'.join(self.selinux_context(path))\n            kwargs['size'] = st[stat.ST_SIZE]\n        else:\n            kwargs['state'] = 'absent'\n        return kwargs\n\n    def _check_locale(self):\n        '''\n        Uses the locale module to test the currently set locale\n        (per the LANG and LC_CTYPE environment settings)\n        '''\n        try:\n            # setting the locale to '' uses the default locale\n            # as it would be returned by locale.getdefaultlocale()\n            locale.setlocale(locale.LC_ALL, '')\n        except locale.Error, e:\n            # fallback to the 'C' locale, which may cause unicode\n            # issues but is preferable to simply failing because\n            # of an unknown locale\n            locale.setlocale(locale.LC_ALL, 'C')\n            os.environ['LANG']     = 'C'\n            os.environ['LC_CTYPE'] = 'C'\n        except Exception, e:\n            self.fail_json(msg=\"An unknown error was encountered while attempting to validate the locale: %s\" % e)\n\n    def _handle_aliases(self):\n        aliases_results = {} #alias:canon\n        for (k,v) in self.argument_spec.iteritems():\n            self._legal_inputs.append(k)\n            aliases = v.get('aliases', None)\n            default = v.get('default', None)\n            required = v.get('required', False)\n            if default is not None and required:\n                # not alias specific but this is a good place to check this\n                self.fail_json(msg=\"internal error: required and default are mutally exclusive for %s\" % k)\n            if aliases is None:\n                continue\n            if type(aliases) != list:\n                self.fail_json(msg='internal error: aliases must be a list')\n            for alias in aliases:\n                self._legal_inputs.append(alias)\n                aliases_results[alias] = k\n                if alias in self.params:\n                    self.params[k] = self.params[alias]\n        \n        return aliases_results\n\n    def _check_for_check_mode(self):\n        for (k,v) in self.params.iteritems():\n            if k == 'CHECKMODE':\n                if not self.supports_check_mode:\n                    self.exit_json(skipped=True, msg=\"remote module does not support check mode\")\n                if self.supports_check_mode:\n                    self.check_mode = True\n\n    def _check_for_no_log(self):\n        for (k,v) in self.params.iteritems():\n            if k == 'NO_LOG':\n                self.no_log = self.boolean(v)\n\n    def _check_invalid_arguments(self):\n        for (k,v) in self.params.iteritems():\n            # these should be in legal inputs already\n            #if k in ('CHECKMODE', 'NO_LOG'):\n            #    continue\n            if k not in self._legal_inputs:\n                self.fail_json(msg=\"unsupported parameter for module: %s\" % k)\n\n    def _count_terms(self, check):\n        count = 0\n        for term in check:\n            if term in self.params:\n                count += 1\n        return count\n\n    def _check_mutually_exclusive(self, spec):\n        if spec is None:\n            return\n        for check in spec:\n            count = self._count_terms(check)\n            if count > 1:\n                self.fail_json(msg=\"parameters are mutually exclusive: %s\" % check)\n\n    def _check_required_one_of(self, spec):\n        if spec is None:\n            return\n        for check in spec:\n            count = self._count_terms(check)\n            if count == 0:\n                self.fail_json(msg=\"one of the following is required: %s\" % ','.join(check))\n\n    def _check_required_together(self, spec):\n        if spec is None:\n            return\n        for check in spec:\n            counts = [ self._count_terms([field]) for field in check ]\n            non_zero = [ c for c in counts if c > 0 ]\n            if len(non_zero) > 0:\n                if 0 in counts:\n                    self.fail_json(msg=\"parameters are required together: %s\" % check)\n\n    def _check_required_arguments(self):\n        ''' ensure all required arguments are present '''\n        missing = []\n        for (k,v) in self.argument_spec.iteritems():\n            required = v.get('required', False)\n            if required and k not in self.params:\n                missing.append(k)\n        if len(missing) > 0:\n            self.fail_json(msg=\"missing required arguments: %s\" % \",\".join(missing))\n\n    def _check_argument_values(self):\n        ''' ensure all arguments have the requested values, and there are no stray arguments '''\n        for (k,v) in self.argument_spec.iteritems():\n            choices = v.get('choices',None)\n            if choices is None:\n                continue\n            if type(choices) == list:\n                if k in self.params:\n                    if self.params[k] not in choices:\n                        choices_str=\",\".join([str(c) for c in choices])\n                        msg=\"value of %s must be one of: %s, got: %s\" % (k, choices_str, self.params[k])\n                        self.fail_json(msg=msg)\n            else:\n                self.fail_json(msg=\"internal error: do not know how to interpret argument_spec\")\n\n    def _check_argument_types(self):\n        ''' ensure all arguments have the requested type '''\n        for (k, v) in self.argument_spec.iteritems():\n            wanted = v.get('type', None)\n            if wanted is None:\n                continue\n            if k not in self.params:\n                continue\n\n            value = self.params[k]\n            is_invalid = False\n\n            if wanted == 'str':\n                if not isinstance(value, basestring):\n                    self.params[k] = str(value)\n            elif wanted == 'list':\n                if not isinstance(value, list):\n                    if isinstance(value, basestring):\n                        self.params[k] = value.split(\",\")\n                    elif isinstance(value, int) or isinstance(value, float):\n                        self.params[k] = [ str(value) ]\n                    else:\n                        is_invalid = True\n            elif wanted == 'dict':\n                if not isinstance(value, dict):\n                    if isinstance(value, basestring):\n                        if value.startswith(\"{\"):\n                            try:\n                                self.params[k] = json.loads(value)\n                            except:\n                                (result, exc) = self.safe_eval(value, dict(), include_exceptions=True)\n                                if exc is not None:\n                                    self.fail_json(msg=\"unable to evaluate dictionary for %s\" % k)\n                                self.params[k] = result\n                        elif '=' in value:\n                            self.params[k] = dict([x.split(\"=\", 1) for x in value.split(\",\")])\n                        else:\n                            self.fail_json(msg=\"dictionary requested, could not parse JSON or key=value\")\n                    else:\n                        is_invalid = True\n            elif wanted == 'bool':\n                if not isinstance(value, bool):\n                    if isinstance(value, basestring):\n                        self.params[k] = self.boolean(value)\n                    else:\n                        is_invalid = True\n            elif wanted == 'int':\n                if not isinstance(value, int):\n                    if isinstance(value, basestring):\n                        self.params[k] = int(value)\n                    else:\n                        is_invalid = True\n            elif wanted == 'float':\n                if not isinstance(value, float):\n                    if isinstance(value, basestring):\n                        self.params[k] = float(value)\n                    else:\n                        is_invalid = True\n            else:\n                self.fail_json(msg=\"implementation error: unknown type %s requested for %s\" % (wanted, k))\n\n            if is_invalid:\n                self.fail_json(msg=\"argument %s is of invalid type: %s, required: %s\" % (k, type(value), wanted))\n\n    def _set_defaults(self, pre=True):\n        for (k,v) in self.argument_spec.iteritems():\n            default = v.get('default', None)\n            if pre == True:\n                # this prevents setting defaults on required items\n                if default is not None and k not in self.params:\n                    self.params[k] = default\n            else:\n                # make sure things without a default still get set None\n                if k not in self.params:\n                    self.params[k] = default\n\n    def _load_params(self):\n        ''' read the input and return a dictionary and the arguments string '''\n        args = MODULE_ARGS\n        items   = shlex.split(args)\n        params = {}\n        for x in items:\n            try:\n                (k, v) = x.split(\"=\",1)\n            except Exception, e:\n                self.fail_json(msg=\"this module requires key=value arguments (%s)\" % (items))\n            params[k] = v\n        params2 = json.loads(MODULE_COMPLEX_ARGS)\n        params2.update(params)\n        return (params2, args)\n\n    def _log_invocation(self):\n        ''' log that ansible ran the module '''\n        # TODO: generalize a separate log function and make log_invocation use it\n        # Sanitize possible password argument when logging.\n        log_args = dict()\n        passwd_keys = ['password', 'login_password']\n\n        filter_re = [\n            # filter out things like user:pass@foo/whatever\n            # and http://username:pass@wherever/foo\n            re.compile('^(?P<before>.*:)(?P<password>.*)(?P<after>\\@.*)$'), \n        ]\n\n        for param in self.params:\n            canon  = self.aliases.get(param, param)\n            arg_opts = self.argument_spec.get(canon, {})\n            no_log = arg_opts.get('no_log', False)\n                \n            if no_log:\n                log_args[param] = 'NOT_LOGGING_PARAMETER'\n            elif param in passwd_keys:\n                log_args[param] = 'NOT_LOGGING_PASSWORD'\n            else:\n                found = False\n                for filter in filter_re:\n                    if isinstance(self.params[param], unicode):\n                        m = filter.match(self.params[param])\n                    else:\n                        m = filter.match(str(self.params[param]))\n                    if m:\n                        d = m.groupdict()\n                        log_args[param] = d['before'] + \"********\" + d['after']\n                        found = True\n                        break\n                if not found:\n                    log_args[param] = self.params[param]\n\n        module = 'ansible-%s' % os.path.basename(__file__)\n        msg = ''\n        for arg in log_args:\n            if isinstance(log_args[arg], basestring):\n                msg = msg + arg + '=' + log_args[arg].decode('utf-8') + ' '\n            else:\n                msg = msg + arg + '=' + str(log_args[arg]) + ' '\n        if msg:\n            msg = 'Invoked with %s' % msg\n        else:\n            msg = 'Invoked'\n\n        # 6655 - allow for accented characters\n        try:\n            msg = msg.encode('utf8')\n        except UnicodeDecodeError, e:\n            pass\n\n        if (has_journal):\n            journal_args = [\"MESSAGE=%s %s\" % (module, msg)]\n            journal_args.append(\"MODULE=%s\" % os.path.basename(__file__))\n            for arg in log_args:\n                journal_args.append(arg.upper() + \"=\" + str(log_args[arg]))\n            try:\n                journal.sendv(*journal_args)\n            except IOError, e:\n                # fall back to syslog since logging to journal failed\n                syslog.openlog(str(module), 0, syslog.LOG_USER)\n                syslog.syslog(syslog.LOG_NOTICE, msg) #1\n        else:\n            syslog.openlog(str(module), 0, syslog.LOG_USER)\n            syslog.syslog(syslog.LOG_NOTICE, msg) #2\n\n    def _set_cwd(self):\n        try:\n            cwd = os.getcwd()\n            if not os.access(cwd, os.F_OK|os.R_OK):\n                raise\n            return cwd\n        except:\n            # we don't have access to the cwd, probably because of sudo. \n            # Try and move to a neutral location to prevent errors\n            for cwd in [os.path.expandvars('$HOME'), tempfile.gettempdir()]:\n                try:\n                    if os.access(cwd, os.F_OK|os.R_OK):\n                        os.chdir(cwd)\n                        return cwd\n                except:\n                    pass\n        # we won't error here, as it may *not* be a problem, \n        # and we don't want to break modules unnecessarily\n        return None    \n\n    def get_bin_path(self, arg, required=False, opt_dirs=[]):\n        '''\n        find system executable in PATH.\n        Optional arguments:\n           - required:  if executable is not found and required is true, fail_json\n           - opt_dirs:  optional list of directories to search in addition to PATH\n        if found return full path; otherwise return None\n        '''\n        sbin_paths = ['/sbin', '/usr/sbin', '/usr/local/sbin']\n        paths = []\n        for d in opt_dirs:\n            if d is not None and os.path.exists(d):\n                paths.append(d)\n        paths += os.environ.get('PATH', '').split(os.pathsep)\n        bin_path = None\n        # mangle PATH to include /sbin dirs\n        for p in sbin_paths:\n            if p not in paths and os.path.exists(p):\n                paths.append(p)\n        for d in paths:\n            path = os.path.join(d, arg)\n            if os.path.exists(path) and self.is_executable(path):\n                bin_path = path\n                break\n        if required and bin_path is None:\n            self.fail_json(msg='Failed to find required executable %s' % arg)\n        return bin_path\n\n    def boolean(self, arg):\n        ''' return a bool for the arg '''\n        if arg is None or type(arg) == bool:\n            return arg\n        if type(arg) in types.StringTypes:\n            arg = arg.lower()\n        if arg in BOOLEANS_TRUE:\n            return True\n        elif arg in BOOLEANS_FALSE:\n            return False\n        else:\n            self.fail_json(msg='Boolean %s not in either boolean list' % arg)\n\n    def jsonify(self, data):\n        for encoding in (\"utf-8\", \"latin-1\", \"unicode_escape\"):\n            try:\n                return json.dumps(data, encoding=encoding)\n            # Old systems using simplejson module does not support encoding keyword.\n            except TypeError, e:\n                return json.dumps(data)\n            except UnicodeDecodeError, e:\n                continue\n        self.fail_json(msg='Invalid unicode encoding encountered')\n\n    def from_json(self, data):\n        return json.loads(data)\n\n    def add_cleanup_file(self, path):\n        if path not in self.cleanup_files:\n            self.cleanup_files.append(path)\n\n    def do_cleanup_files(self):\n        for path in self.cleanup_files:\n            self.cleanup(path)\n\n    def exit_json(self, **kwargs):\n        ''' return from the module, without error '''\n        self.add_path_info(kwargs)\n        if not 'changed' in kwargs:\n            kwargs['changed'] = False\n        self.do_cleanup_files()\n        print self.jsonify(kwargs)\n        sys.exit(0)\n\n    def fail_json(self, **kwargs):\n        ''' return from the module, with an error message '''\n        self.add_path_info(kwargs)\n        assert 'msg' in kwargs, \"implementation error -- msg to explain the error is required\"\n        kwargs['failed'] = True\n        self.do_cleanup_files()\n        print self.jsonify(kwargs)\n        sys.exit(1)\n\n    def is_executable(self, path):\n        '''is the given path executable?'''\n        return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE]\n                or stat.S_IXGRP & os.stat(path)[stat.ST_MODE]\n                or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])\n\n    def digest_from_file(self, filename, digest_method):\n        ''' Return hex digest of local file for a given digest_method, or None if file is not present. '''\n        if not os.path.exists(filename):\n            return None\n        if os.path.isdir(filename):\n            self.fail_json(msg=\"attempted to take checksum of directory: %s\" % filename)\n        digest = digest_method\n        blocksize = 64 * 1024\n        infile = open(filename, 'rb')\n        block = infile.read(blocksize)\n        while block:\n            digest.update(block)\n            block = infile.read(blocksize)\n        infile.close()\n        return digest.hexdigest()\n\n    def md5(self, filename):\n        ''' Return MD5 hex digest of local file using digest_from_file(). '''\n        return self.digest_from_file(filename, _md5())\n\n    def sha256(self, filename):\n        ''' Return SHA-256 hex digest of local file using digest_from_file(). '''\n        if not HAVE_HASHLIB:\n            self.fail_json(msg=\"SHA-256 checksums require hashlib, which is available in Python 2.5 and higher\")\n        return self.digest_from_file(filename, _sha256())\n\n    def backup_local(self, fn):\n        '''make a date-marked backup of the specified file, return True or False on success or failure'''\n        # backups named basename-YYYY-MM-DD@HH:MM~\n        ext = time.strftime(\"%Y-%m-%d@%H:%M~\", time.localtime(time.time()))\n        backupdest = '%s.%s' % (fn, ext)\n\n        try:\n            shutil.copy2(fn, backupdest)\n        except shutil.Error, e:\n            self.fail_json(msg='Could not make backup of %s to %s: %s' % (fn, backupdest, e))\n        return backupdest\n\n    def cleanup(self, tmpfile):\n        if os.path.exists(tmpfile):\n            try:\n                os.unlink(tmpfile)\n            except OSError, e:\n                sys.stderr.write(\"could not cleanup %s: %s\" % (tmpfile, e))\n\n    def atomic_move(self, src, dest):\n        '''atomically move src to dest, copying attributes from dest, returns true on success\n        it uses os.rename to ensure this as it is an atomic operation, rest of the function is\n        to work around limitations, corner cases and ensure selinux context is saved if possible'''\n        context = None\n        dest_stat = None\n        if os.path.exists(dest):\n            try:\n                dest_stat = os.stat(dest)\n                os.chmod(src, dest_stat.st_mode & 07777)\n                os.chown(src, dest_stat.st_uid, dest_stat.st_gid)\n            except OSError, e:\n                if e.errno != errno.EPERM:\n                    raise\n            if self.selinux_enabled():\n                context = self.selinux_context(dest)\n        else:\n            if self.selinux_enabled():\n                context = self.selinux_default_context(dest)\n\n        creating = not os.path.exists(dest)\n\n        try:\n            login_name = os.getlogin()\n        except OSError:\n            # not having a tty can cause the above to fail, so\n            # just get the LOGNAME environment variable instead\n            login_name = os.environ.get('LOGNAME', None)\n\n        # if the original login_name doesn't match the currently\n        # logged-in user, or if the SUDO_USER environment variable\n        # is set, then this user has switched their credentials\n        switched_user = login_name and login_name != pwd.getpwuid(os.getuid())[0] or os.environ.get('SUDO_USER')\n\n        try:\n            # Optimistically try a rename, solves some corner cases and can avoid useless work, throws exception if not atomic.\n            os.rename(src, dest)\n        except (IOError,OSError), e:\n            # only try workarounds for errno 18 (cross device), 1 (not permited) and 13 (permission denied)\n            if e.errno != errno.EPERM and e.errno != errno.EXDEV and e.errno != errno.EACCES:\n                self.fail_json(msg='Could not replace file: %s to %s: %s' % (src, dest, e))\n\n            dest_dir = os.path.dirname(dest)\n            dest_file = os.path.basename(dest)\n            tmp_dest = tempfile.NamedTemporaryFile(\n                prefix=\".ansible_tmp\", dir=dest_dir, suffix=dest_file)\n\n            try: # leaves tmp file behind when sudo and  not root\n                if switched_user and os.getuid() != 0:\n                    # cleanup will happen by 'rm' of tempdir\n                    # copy2 will preserve some metadata\n                    shutil.copy2(src, tmp_dest.name)\n                else:\n                    shutil.move(src, tmp_dest.name)\n                if self.selinux_enabled():\n                    self.set_context_if_different(\n                        tmp_dest.name, context, False)\n                tmp_stat = os.stat(tmp_dest.name)\n                if dest_stat and (tmp_stat.st_uid != dest_stat.st_uid or tmp_stat.st_gid != dest_stat.st_gid):\n                    os.chown(tmp_dest.name, dest_stat.st_uid, dest_stat.st_gid)\n                os.rename(tmp_dest.name, dest)\n            except (shutil.Error, OSError, IOError), e:\n                self.cleanup(tmp_dest.name)\n                self.fail_json(msg='Could not replace file: %s to %s: %s' % (src, dest, e))\n\n        if creating:\n            # make sure the file has the correct permissions\n            # based on the current value of umask\n            umask = os.umask(0)\n            os.umask(umask)\n            os.chmod(dest, 0666 ^ umask)\n            if switched_user:\n                os.chown(dest, os.getuid(), os.getgid())\n\n        if self.selinux_enabled():\n            # rename might not preserve context\n            self.set_context_if_different(dest, context, False)\n\n    def run_command(self, args, check_rc=False, close_fds=False, executable=None, data=None, binary_data=False, path_prefix=None, cwd=None, use_unsafe_shell=False):\n        '''\n        Execute a command, returns rc, stdout, and stderr.\n        args is the command to run\n        If args is a list, the command will be run with shell=False.\n        If args is a string and use_unsafe_shell=False it will split args to a list and run with shell=False\n        If args is a string and use_unsafe_shell=True it run with shell=True.\n        Other arguments:\n        - check_rc (boolean)  Whether to call fail_json in case of\n                              non zero RC.  Default is False.\n        - close_fds (boolean) See documentation for subprocess.Popen().\n                              Default is False.\n        - executable (string) See documentation for subprocess.Popen().\n                              Default is None.\n        '''\n\n        shell = False\n        if isinstance(args, list):\n            if use_unsafe_shell:\n                args = \" \".join([pipes.quote(x) for x in args])\n                shell = True\n        elif isinstance(args, basestring) and use_unsafe_shell:\n            shell = True\n        elif isinstance(args, basestring):\n            args = shlex.split(args.encode('utf-8'))\n        else:\n            msg = \"Argument 'args' to run_command must be list or string\"\n            self.fail_json(rc=257, cmd=args, msg=msg)\n\n        # expand things like $HOME and ~\n        if not shell:\n            args = [ os.path.expandvars(os.path.expanduser(x)) for x in args ]\n\n        rc = 0\n        msg = None\n        st_in = None\n\n        # Set a temporart env path if a prefix is passed\n        env=os.environ\n        if path_prefix:\n            env['PATH']=\"%s:%s\" % (path_prefix, env['PATH'])\n\n        # create a printable version of the command for use\n        # in reporting later, which strips out things like\n        # passwords from the args list\n        if isinstance(args, list):\n            clean_args = \" \".join(pipes.quote(arg) for arg in args)\n        else:\n            clean_args = args\n\n        # all clean strings should return two match groups, \n        # where the first is the CLI argument and the second \n        # is the password/key/phrase that will be hidden\n        clean_re_strings = [\n            # this removes things like --password, --pass, --pass-wd, etc.\n            # optionally followed by an '=' or a space. The password can \n            # be quoted or not too, though it does not care about quotes\n            # that are not balanced\n            # source: http://blog.stevenlevithan.com/archives/match-quoted-string\n            r'([-]{0,2}pass[-]?(?:word|wd)?[=\\s]?)((?:[\"\\'])?(?:[^\\s])*(?:\\1)?)',\n            # TODO: add more regex checks here\n        ]\n        for re_str in clean_re_strings:\n            r = re.compile(re_str)\n            clean_args = r.sub(r'\\1********', clean_args)\n\n        if data:\n            st_in = subprocess.PIPE\n\n        kwargs = dict(\n            executable=executable,\n            shell=shell,\n            close_fds=close_fds,\n            stdin= st_in,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE \n        )\n\n        if path_prefix:\n            kwargs['env'] = env\n        if cwd and os.path.isdir(cwd):\n            kwargs['cwd'] = cwd\n\n        # store the pwd\n        prev_dir = os.getcwd()\n\n        # make sure we're in the right working directory\n        if cwd and os.path.isdir(cwd):\n            try:\n                os.chdir(cwd)\n            except (OSError, IOError), e:\n                self.fail_json(rc=e.errno, msg=\"Could not open %s , %s\" % (cwd, str(e)))\n\n        try:\n            cmd = subprocess.Popen(args, **kwargs)\n\n            if data:\n                if not binary_data:\n                    data += '\\n'\n            out, err = cmd.communicate(input=data)\n            rc = cmd.returncode\n        except (OSError, IOError), e:\n            self.fail_json(rc=e.errno, msg=str(e), cmd=clean_args)\n        except:\n            self.fail_json(rc=257, msg=traceback.format_exc(), cmd=clean_args)\n\n        if rc != 0 and check_rc:\n            msg = err.rstrip()\n            self.fail_json(cmd=clean_args, rc=rc, stdout=out, stderr=err, msg=msg)\n\n        # reset the pwd\n        os.chdir(prev_dir)\n\n        return (rc, out, err)\n\n    def append_to_file(self, filename, str):\n        filename = os.path.expandvars(os.path.expanduser(filename))\n        fh = open(filename, 'a')\n        fh.write(str)\n        fh.close()\n\n    def pretty_bytes(self,size):\n        ranges = (\n                (1<<70L, 'ZB'),\n                (1<<60L, 'EB'),\n                (1<<50L, 'PB'),\n                (1<<40L, 'TB'),\n                (1<<30L, 'GB'),\n                (1<<20L, 'MB'),\n                (1<<10L, 'KB'),\n                (1, 'Bytes')\n            )\n        for limit, suffix in ranges:\n            if size >= limit:\n                break\n        return '%.2f %s' % (float(size)/ limit, suffix)\n\ndef get_module_path():\n    return os.path.dirname(os.path.realpath(__file__))\n", "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport multiprocessing\nimport signal\nimport os\nimport pwd\nimport Queue\nimport random\nimport traceback\nimport tempfile\nimport time\nimport collections\nimport socket\nimport base64\nimport sys\nimport pipes\nimport jinja2\nimport subprocess\nimport getpass\n\nimport ansible.constants as C\nimport ansible.inventory\nfrom ansible import utils\nfrom ansible.utils import template\nfrom ansible.utils import check_conditional\nfrom ansible.utils import string_functions\nfrom ansible import errors\nfrom ansible import module_common\nimport poller\nimport connection\nfrom return_data import ReturnData\nfrom ansible.callbacks import DefaultRunnerCallbacks, vv\nfrom ansible.module_common import ModuleReplacer\n\nmodule_replacer = ModuleReplacer(strip_comments=False)\n\nHAS_ATFORK=True\ntry:\n    from Crypto.Random import atfork\nexcept ImportError:\n    HAS_ATFORK=False\n\nmultiprocessing_runner = None\n        \nOUTPUT_LOCKFILE  = tempfile.TemporaryFile()\nPROCESS_LOCKFILE = tempfile.TemporaryFile()\n\n################################################\n\ndef _executor_hook(job_queue, result_queue, new_stdin):\n\n    # attempt workaround of https://github.com/newsapps/beeswithmachineguns/issues/17\n    # this function also not present in CentOS 6\n    if HAS_ATFORK:\n        atfork()\n\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n    while not job_queue.empty():\n        try:\n            host = job_queue.get(block=False)\n            return_data = multiprocessing_runner._executor(host, new_stdin)\n            result_queue.put(return_data)\n        except Queue.Empty:\n            pass\n        except:\n            traceback.print_exc()\n\nclass HostVars(dict):\n    ''' A special view of vars_cache that adds values from the inventory when needed. '''\n\n    def __init__(self, vars_cache, inventory, vault_password=None):\n        self.vars_cache = vars_cache\n        self.inventory = inventory\n        self.lookup = dict()\n        self.update(vars_cache)\n        self.vault_password = vault_password\n\n    def __getitem__(self, host):\n        if host not in self.lookup:\n            result = self.inventory.get_variables(host, vault_password=self.vault_password).copy()\n            result.update(self.vars_cache.get(host, {}))\n            self.lookup[host] = result\n        return self.lookup[host]\n\n\nclass Runner(object):\n    ''' core API interface to ansible '''\n\n    # see bin/ansible for how this is used...\n\n    def __init__(self,\n        host_list=C.DEFAULT_HOST_LIST,      # ex: /etc/ansible/hosts, legacy usage\n        module_path=None,                   # ex: /usr/share/ansible\n        module_name=C.DEFAULT_MODULE_NAME,  # ex: copy\n        module_args=C.DEFAULT_MODULE_ARGS,  # ex: \"src=/tmp/a dest=/tmp/b\"\n        forks=C.DEFAULT_FORKS,              # parallelism level\n        timeout=C.DEFAULT_TIMEOUT,          # SSH timeout\n        pattern=C.DEFAULT_PATTERN,          # which hosts?  ex: 'all', 'acme.example.org'\n        remote_user=C.DEFAULT_REMOTE_USER,  # ex: 'username'\n        remote_pass=C.DEFAULT_REMOTE_PASS,  # ex: 'password123' or None if using key\n        remote_port=None,                   # if SSH on different ports\n        private_key_file=C.DEFAULT_PRIVATE_KEY_FILE, # if not using keys/passwords\n        sudo_pass=C.DEFAULT_SUDO_PASS,      # ex: 'password123' or None\n        background=0,                       # async poll every X seconds, else 0 for non-async\n        basedir=None,                       # directory of playbook, if applicable\n        setup_cache=None,                   # used to share fact data w/ other tasks\n        vars_cache=None,                    # used to store variables about hosts\n        transport=C.DEFAULT_TRANSPORT,      # 'ssh', 'paramiko', 'local'\n        conditional='True',                 # run only if this fact expression evals to true\n        callbacks=None,                     # used for output\n        sudo=False,                         # whether to run sudo or not\n        sudo_user=C.DEFAULT_SUDO_USER,      # ex: 'root'\n        module_vars=None,                   # a playbooks internals thing\n        default_vars=None,                  # ditto\n        is_playbook=False,                  # running from playbook or not?\n        inventory=None,                     # reference to Inventory object\n        subset=None,                        # subset pattern\n        check=False,                        # don't make any changes, just try to probe for potential changes\n        diff=False,                         # whether to show diffs for template files that change\n        environment=None,                   # environment variables (as dict) to use inside the command\n        complex_args=None,                  # structured data in addition to module_args, must be a dict\n        error_on_undefined_vars=C.DEFAULT_UNDEFINED_VAR_BEHAVIOR, # ex. False\n        accelerate=False,                   # use accelerated connection\n        accelerate_ipv6=False,              # accelerated connection w/ IPv6\n        accelerate_port=None,               # port to use with accelerated connection\n        su=False,                           # Are we running our command via su?\n        su_user=None,                       # User to su to when running command, ex: 'root'\n        su_pass=C.DEFAULT_SU_PASS,\n        vault_pass=None,\n        run_hosts=None,                     # an optional list of pre-calculated hosts to run on\n        no_log=False,                       # option to enable/disable logging for a given task\n        ):\n\n        # used to lock multiprocess inputs and outputs at various levels\n        self.output_lockfile  = OUTPUT_LOCKFILE\n        self.process_lockfile = PROCESS_LOCKFILE\n\n        if not complex_args:\n            complex_args = {}\n\n        # storage & defaults\n        self.check            = check\n        self.diff             = diff\n        self.setup_cache      = utils.default(setup_cache, lambda: collections.defaultdict(dict))\n        self.vars_cache       = utils.default(vars_cache, lambda: collections.defaultdict(dict))\n        self.basedir          = utils.default(basedir, lambda: os.getcwd())\n        self.callbacks        = utils.default(callbacks, lambda: DefaultRunnerCallbacks())\n        self.generated_jid    = str(random.randint(0, 999999999999))\n        self.transport        = transport\n        self.inventory        = utils.default(inventory, lambda: ansible.inventory.Inventory(host_list))\n\n        self.module_vars      = utils.default(module_vars, lambda: {})\n        self.default_vars     = utils.default(default_vars, lambda: {})\n        self.always_run       = None\n        self.connector        = connection.Connection(self)\n        self.conditional      = conditional\n        self.module_name      = module_name\n        self.forks            = int(forks)\n        self.pattern          = pattern\n        self.module_args      = module_args\n        self.timeout          = timeout\n        self.remote_user      = remote_user\n        self.remote_pass      = remote_pass\n        self.remote_port      = remote_port\n        self.private_key_file = private_key_file\n        self.background       = background\n        self.sudo             = sudo\n        self.sudo_user_var    = sudo_user\n        self.sudo_user        = None\n        self.sudo_pass        = sudo_pass\n        self.is_playbook      = is_playbook\n        self.environment      = environment\n        self.complex_args     = complex_args\n        self.error_on_undefined_vars = error_on_undefined_vars\n        self.accelerate       = accelerate\n        self.accelerate_port  = accelerate_port\n        self.accelerate_ipv6  = accelerate_ipv6\n        self.callbacks.runner = self\n        self.su               = su\n        self.su_user_var      = su_user\n        self.su_user          = None\n        self.su_pass          = su_pass\n        self.vault_pass       = vault_pass\n        self.no_log           = no_log\n\n        if self.transport == 'smart':\n            # if the transport is 'smart' see if SSH can support ControlPersist if not use paramiko\n            # 'smart' is the default since 1.2.1/1.3\n            cmd = subprocess.Popen(['ssh','-o','ControlPersist'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            (out, err) = cmd.communicate() \n            if \"Bad configuration option\" in err:\n                self.transport = \"paramiko\"\n            else:\n                self.transport = \"ssh\" \n\n        # save the original transport, in case it gets\n        # changed later via options like accelerate\n        self.original_transport = self.transport\n\n        # misc housekeeping\n        if subset and self.inventory._subset is None:\n            # don't override subset when passed from playbook\n            self.inventory.subset(subset)\n\n        # If we get a pre-built list of hosts to run on, from say a playbook, use them.\n        # Also where we will store the hosts to run on once discovered\n        self.run_hosts = run_hosts\n\n        if self.transport == 'local':\n            self.remote_user = pwd.getpwuid(os.geteuid())[0]\n\n        if module_path is not None:\n            for i in module_path.split(os.pathsep):\n                utils.plugins.module_finder.add_directory(i)\n\n        utils.plugins.push_basedir(self.basedir)\n\n        # ensure we are using unique tmp paths\n        random.seed()\n    # *****************************************************\n\n    def _complex_args_hack(self, complex_args, module_args):\n        \"\"\"\n        ansible-playbook both allows specifying key=value string arguments and complex arguments\n        however not all modules use our python common module system and cannot\n        access these.  An example might be a Bash module.  This hack allows users to still pass \"args\"\n        as a hash of simple scalars to those arguments and is short term.  We could technically\n        just feed JSON to the module, but that makes it hard on Bash consumers.  The way this is implemented\n        it does mean values in 'args' have LOWER priority than those on the key=value line, allowing\n        args to provide yet another way to have pluggable defaults.\n        \"\"\"\n        if complex_args is None:\n            return module_args\n        if not isinstance(complex_args, dict):\n            raise errors.AnsibleError(\"complex arguments are not a dictionary: %s\" % complex_args)\n        for (k,v) in complex_args.iteritems():\n            if isinstance(v, basestring):\n                module_args = \"%s=%s %s\" % (k, pipes.quote(v), module_args)\n        return module_args\n\n    # *****************************************************\n\n    def _transfer_str(self, conn, tmp, name, data):\n        ''' transfer string to remote file '''\n\n        if type(data) == dict:\n            data = utils.jsonify(data)\n\n        afd, afile = tempfile.mkstemp()\n        afo = os.fdopen(afd, 'w')\n        try:\n            if not isinstance(data, unicode):\n                #ensure the data is valid UTF-8\n                data.decode('utf-8')\n            else:\n                data = data.encode('utf-8')\n            afo.write(data)\n        except:\n            raise errors.AnsibleError(\"failure encoding into utf-8\")\n        afo.flush()\n        afo.close()\n\n        remote = os.path.join(tmp, name)\n        try:\n            conn.put_file(afile, remote)\n        finally:\n            os.unlink(afile)\n        return remote\n\n    # *****************************************************\n\n    def _compute_environment_string(self, inject=None):\n        ''' what environment variables to use when running the command? '''\n\n        default_environment = dict(\n            LANG     = C.DEFAULT_MODULE_LANG,\n            LC_CTYPE = C.DEFAULT_MODULE_LANG,\n        )\n\n        if self.environment:\n            enviro = template.template(self.basedir, self.environment, inject, convert_bare=True)\n            enviro = utils.safe_eval(enviro)\n            if type(enviro) != dict:\n                raise errors.AnsibleError(\"environment must be a dictionary, received %s\" % enviro)\n            default_environment.update(enviro)\n\n        result = \"\"\n        for (k,v) in default_environment.iteritems():\n            result = \"%s=%s %s\" % (k, pipes.quote(unicode(v)), result)\n        return result\n\n    # *****************************************************\n\n    def _compute_delegate(self, host, password, remote_inject):\n\n        \"\"\" Build a dictionary of all attributes for the delegate host \"\"\"\n\n        delegate = {}\n\n        # allow delegated host to be templated\n        delegate['host'] = template.template(self.basedir, host, \n                                remote_inject, fail_on_undefined=True)\n\n        delegate['inject'] = remote_inject.copy()\n\n        # set any interpreters\n        interpreters = []\n        for i in delegate['inject']:\n            if i.startswith(\"ansible_\") and i.endswith(\"_interpreter\"):\n                interpreters.append(i)\n        for i in interpreters:\n            del delegate['inject'][i]\n        port = C.DEFAULT_REMOTE_PORT\n\n        this_host = delegate['host']\n\n        # get the vars for the delegate by it's name        \n        try:\n            this_info = delegate['inject']['hostvars'][this_host]\n        except:\n            # make sure the inject is empty for non-inventory hosts\n            this_info = {}\n\n        # get the real ssh_address for the delegate        \n        # and allow ansible_ssh_host to be templated\n        delegate['ssh_host'] = template.template(self.basedir,\n                            this_info.get('ansible_ssh_host', this_host),\n                            this_info, fail_on_undefined=True)\n\n        delegate['port'] = this_info.get('ansible_ssh_port', port)\n\n        delegate['user'] = self._compute_delegate_user(this_host, delegate['inject'])\n\n        delegate['pass'] = this_info.get('ansible_ssh_pass', password)\n        delegate['private_key_file'] = this_info.get('ansible_ssh_private_key_file', \n                                        self.private_key_file)\n        delegate['transport'] = this_info.get('ansible_connection', self.transport)\n        delegate['sudo_pass'] = this_info.get('ansible_sudo_pass', self.sudo_pass)\n\n        # Last chance to get private_key_file from global variables.\n        # this is usefull if delegated host is not defined in the inventory\n        if delegate['private_key_file'] is None:\n            delegate['private_key_file'] = remote_inject.get(\n                'ansible_ssh_private_key_file', None)\n\n        if delegate['private_key_file'] is not None:\n            delegate['private_key_file'] = os.path.expanduser(delegate['private_key_file'])\n\n        for i in this_info:\n            if i.startswith(\"ansible_\") and i.endswith(\"_interpreter\"):\n                delegate['inject'][i] = this_info[i]\n\n        return delegate\n\n    def _compute_delegate_user(self, host, inject):\n\n        \"\"\" Caculate the remote user based on an order of preference \"\"\"\n\n        # inventory > playbook > original_host\n\n        actual_user = inject.get('ansible_ssh_user', self.remote_user)\n        thisuser = None\n\n        if host in inject['hostvars']:\n            if inject['hostvars'][host].get('ansible_ssh_user'):\n                # user for delegate host in inventory\n                thisuser = inject['hostvars'][host].get('ansible_ssh_user')\n\n        if thisuser is None and self.remote_user:\n            # user defined by play/runner\n            thisuser = self.remote_user\n\n        if thisuser is not None:\n            actual_user = thisuser\n        else:\n            # fallback to the inventory user of the play host\n            #actual_user = inject.get('ansible_ssh_user', actual_user)\n            actual_user = inject.get('ansible_ssh_user', self.remote_user)\n\n        return actual_user\n\n\n    # *****************************************************\n\n    def _execute_module(self, conn, tmp, module_name, args,\n        async_jid=None, async_module=None, async_limit=None, inject=None, persist_files=False, complex_args=None, delete_remote_tmp=True):\n\n        ''' transfer and run a module along with its arguments on the remote side'''\n\n        # hack to support fireball mode\n        if module_name == 'fireball':\n            args = \"%s password=%s\" % (args, base64.b64encode(str(utils.key_for_hostname(conn.host))))\n            if 'port' not in args:\n                args += \" port=%s\" % C.ZEROMQ_PORT\n\n        (\n        module_style,\n        shebang,\n        module_data\n        ) = self._configure_module(conn, module_name, args, inject, complex_args)\n\n        # a remote tmp path may be necessary and not already created\n        if self._late_needs_tmp_path(conn, tmp, module_style):\n            tmp = self._make_tmp_path(conn)\n\n        remote_module_path = os.path.join(tmp, module_name)\n\n        if (module_style != 'new'\n           or async_jid is not None\n           or not conn.has_pipelining\n           or not C.ANSIBLE_SSH_PIPELINING\n           or C.DEFAULT_KEEP_REMOTE_FILES\n           or self.su):\n            self._transfer_str(conn, tmp, module_name, module_data)\n\n        environment_string = self._compute_environment_string(inject)\n\n        if \"tmp\" in tmp and ((self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root')):\n            # deal with possible umask issues once sudo'ed to other user\n            cmd_chmod = \"chmod a+r %s\" % remote_module_path\n            self._low_level_exec_command(conn, cmd_chmod, tmp, sudoable=False)\n\n        cmd = \"\"\n        in_data = None\n        if module_style != 'new':\n            if 'CHECKMODE=True' in args:\n                # if module isn't using AnsibleModuleCommon infrastructure we can't be certain it knows how to\n                # do --check mode, so to be safe we will not run it.\n                return ReturnData(conn=conn, result=dict(skipped=True, msg=\"cannot yet run check mode against old-style modules\"))\n            elif 'NO_LOG' in args:\n                return ReturnData(conn=conn, result=dict(skipped=True, msg=\"cannot use no_log: with old-style modules\"))\n\n            args = template.template(self.basedir, args, inject)\n\n            # decide whether we need to transfer JSON or key=value\n            argsfile = None\n            if module_style == 'non_native_want_json':\n                if complex_args:\n                    complex_args.update(utils.parse_kv(args))\n                    argsfile = self._transfer_str(conn, tmp, 'arguments', utils.jsonify(complex_args))\n                else:\n                    argsfile = self._transfer_str(conn, tmp, 'arguments', utils.jsonify(utils.parse_kv(args)))\n\n            else:\n                argsfile = self._transfer_str(conn, tmp, 'arguments', args)\n\n            if (self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root'):\n                # deal with possible umask issues once sudo'ed to other user\n                cmd_args_chmod = \"chmod a+r %s\" % argsfile\n                self._low_level_exec_command(conn, cmd_args_chmod, tmp, sudoable=False)\n\n            if async_jid is None:\n                cmd = \"%s %s\" % (remote_module_path, argsfile)\n            else:\n                cmd = \" \".join([str(x) for x in [remote_module_path, async_jid, async_limit, async_module, argsfile]])\n        else:\n            if async_jid is None:\n                if conn.has_pipelining and C.ANSIBLE_SSH_PIPELINING and not C.DEFAULT_KEEP_REMOTE_FILES and not self.su:\n                    in_data = module_data\n                else:\n                    cmd = \"%s\" % (remote_module_path)\n            else:\n                cmd = \" \".join([str(x) for x in [remote_module_path, async_jid, async_limit, async_module]])\n\n        if not shebang:\n            raise errors.AnsibleError(\"module is missing interpreter line\")\n\n\n        cmd = \" \".join([environment_string.strip(), shebang.replace(\"#!\",\"\").strip(), cmd])\n        cmd = cmd.strip()\n\n        if \"tmp\" in tmp and not C.DEFAULT_KEEP_REMOTE_FILES and not persist_files and delete_remote_tmp:\n            if not self.sudo or self.su or self.sudo_user == 'root' or self.su_user == 'root':\n                # not sudoing or sudoing to root, so can cleanup files in the same step\n                cmd = cmd + \"; rm -rf %s >/dev/null 2>&1\" % tmp\n\n        sudoable = True\n        if module_name == \"accelerate\":\n            # always run the accelerate module as the user\n            # specified in the play, not the sudo_user\n            sudoable = False\n\n        if self.su:\n            res = self._low_level_exec_command(conn, cmd, tmp, su=True, in_data=in_data)\n        else:\n            res = self._low_level_exec_command(conn, cmd, tmp, sudoable=sudoable, in_data=in_data)\n\n        if \"tmp\" in tmp and not C.DEFAULT_KEEP_REMOTE_FILES and not persist_files and delete_remote_tmp:\n            if (self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root'):\n            # not sudoing to root, so maybe can't delete files as that other user\n            # have to clean up temp files as original user in a second step\n                cmd2 = \"rm -rf %s >/dev/null 2>&1\" % tmp\n                self._low_level_exec_command(conn, cmd2, tmp, sudoable=False)\n\n        data = utils.parse_json(res['stdout'], from_remote=True)\n        if 'parsed' in data and data['parsed'] == False:\n            data['msg'] += res['stderr']\n        return ReturnData(conn=conn, result=data)\n\n    # *****************************************************\n\n    def _executor(self, host, new_stdin):\n        ''' handler for multiprocessing library '''\n\n        try:\n            fileno = sys.stdin.fileno()\n        except ValueError:\n            fileno = None\n\n        try:\n            self._new_stdin = new_stdin\n            if not new_stdin and fileno is not None:\n                try:\n                    self._new_stdin = os.fdopen(os.dup(fileno))\n                except OSError, e:\n                    # couldn't dupe stdin, most likely because it's\n                    # not a valid file descriptor, so we just rely on\n                    # using the one that was passed in\n                    pass\n\n            exec_rc = self._executor_internal(host, new_stdin)\n            if type(exec_rc) != ReturnData:\n                raise Exception(\"unexpected return type: %s\" % type(exec_rc))\n            # redundant, right?\n            if not exec_rc.comm_ok:\n                self.callbacks.on_unreachable(host, exec_rc.result)\n            return exec_rc\n        except errors.AnsibleError, ae:\n            msg = str(ae)\n            self.callbacks.on_unreachable(host, msg)\n            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg))\n        except Exception:\n            msg = traceback.format_exc()\n            self.callbacks.on_unreachable(host, msg)\n            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg))\n\n    # *****************************************************\n\n    def _executor_internal(self, host, new_stdin):\n        ''' executes any module one or more times '''\n\n        host_variables = self.inventory.get_variables(host, vault_password=self.vault_pass)\n        host_connection = host_variables.get('ansible_connection', self.transport)\n        if host_connection in [ 'paramiko', 'ssh', 'accelerate' ]:\n            port = host_variables.get('ansible_ssh_port', self.remote_port)\n            if port is None:\n                port = C.DEFAULT_REMOTE_PORT\n        else:\n            # fireball, local, etc\n            port = self.remote_port\n\n        # merge the VARS and SETUP caches for this host\n        combined_cache = self.setup_cache.copy()\n        combined_cache.setdefault(host, {}).update(self.vars_cache.get(host, {}))\n        hostvars = HostVars(combined_cache, self.inventory, vault_password=self.vault_pass)\n\n        # use combined_cache and host_variables to template the module_vars\n        # we update the inject variables with the data we're about to template\n        # since some of the variables we'll be replacing may be contained there too\n        module_vars_inject = utils.combine_vars(host_variables, combined_cache.get(host, {}))\n        module_vars_inject = utils.combine_vars(self.module_vars, module_vars_inject)\n        module_vars = template.template(self.basedir, self.module_vars, module_vars_inject)\n\n        inject = {}\n        inject = utils.combine_vars(inject, self.default_vars)\n        inject = utils.combine_vars(inject, host_variables)\n        inject = utils.combine_vars(inject, module_vars)\n        inject = utils.combine_vars(inject, combined_cache.get(host, {}))\n        inject.setdefault('ansible_ssh_user', self.remote_user)\n        inject['hostvars']    = hostvars\n        inject['group_names'] = host_variables.get('group_names', [])\n        inject['groups']      = self.inventory.groups_list()\n        inject['vars']        = self.module_vars\n        inject['defaults']    = self.default_vars\n        inject['environment'] = self.environment\n        inject['playbook_dir'] = self.basedir\n\n        if self.inventory.basedir() is not None:\n            inject['inventory_dir'] = self.inventory.basedir()\n\n        if self.inventory.src() is not None:\n            inject['inventory_file'] = self.inventory.src()\n\n        # allow with_foo to work in playbooks...\n        items = None\n        items_plugin = self.module_vars.get('items_lookup_plugin', None)\n\n        if items_plugin is not None and items_plugin in utils.plugins.lookup_loader:\n\n            basedir = self.basedir\n            if '_original_file' in inject:\n                basedir = os.path.dirname(inject['_original_file'])\n                filesdir = os.path.join(basedir, '..', 'files')\n                if os.path.exists(filesdir):\n                    basedir = filesdir\n\n            items_terms = self.module_vars.get('items_lookup_terms', '')\n            items_terms = template.template(basedir, items_terms, inject)\n            items = utils.plugins.lookup_loader.get(items_plugin, runner=self, basedir=basedir).run(items_terms, inject=inject)\n            if type(items) != list:\n                raise errors.AnsibleError(\"lookup plugins have to return a list: %r\" % items)\n\n            if len(items) and utils.is_list_of_strings(items) and self.module_name in [ 'apt', 'yum', 'pkgng' ]:\n                # hack for apt, yum, and pkgng so that with_items maps back into a single module call\n                use_these_items = []\n                for x in items:\n                    inject['item'] = x\n                    if not self.conditional or utils.check_conditional(self.conditional, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                        use_these_items.append(x)\n                inject['item'] = \",\".join(use_these_items)\n                items = None\n\n        # logic to replace complex args if possible\n        complex_args = self.complex_args\n\n        # logic to decide how to run things depends on whether with_items is used\n        if items is None:\n            if isinstance(complex_args, basestring):\n                complex_args = template.template(self.basedir, complex_args, inject, convert_bare=True)\n                complex_args = utils.safe_eval(complex_args)\n                if type(complex_args) != dict:\n                    raise errors.AnsibleError(\"args must be a dictionary, received %s\" % complex_args)\n            return self._executor_internal_inner(host, self.module_name, self.module_args, inject, port, complex_args=complex_args)\n        elif len(items) > 0:\n\n            # executing using with_items, so make multiple calls\n            # TODO: refactor\n\n            if self.background > 0:\n                raise errors.AnsibleError(\"lookup plugins (with_*) cannot be used with async tasks\")\n\n            all_comm_ok = True\n            all_changed = False\n            all_failed = False\n            results = []\n            for x in items:\n                # use a fresh inject for each item\n                this_inject = inject.copy()\n                this_inject['item'] = x\n\n                # TODO: this idiom should be replaced with an up-conversion to a Jinja2 template evaluation\n                if isinstance(self.complex_args, basestring):\n                    complex_args = template.template(self.basedir, self.complex_args, this_inject, convert_bare=True)\n                    complex_args = utils.safe_eval(complex_args)\n                    if type(complex_args) != dict:\n                        raise errors.AnsibleError(\"args must be a dictionary, received %s\" % complex_args)\n                result = self._executor_internal_inner(\n                     host,\n                     self.module_name,\n                     self.module_args,\n                     this_inject,\n                     port,\n                     complex_args=complex_args\n                )\n                results.append(result.result)\n                if result.comm_ok == False:\n                    all_comm_ok = False\n                    all_failed = True\n                    break\n                for x in results:\n                    if x.get('changed') == True:\n                        all_changed = True\n                    if (x.get('failed') == True) or ('failed_when_result' in x and [x['failed_when_result']] or [('rc' in x) and (x['rc'] != 0)])[0]:\n                        all_failed = True\n                        break\n            msg = 'All items completed'\n            if all_failed:\n                msg = \"One or more items failed.\"\n            rd_result = dict(failed=all_failed, changed=all_changed, results=results, msg=msg)\n            if not all_failed:\n                del rd_result['failed']\n            return ReturnData(host=host, comm_ok=all_comm_ok, result=rd_result)\n        else:\n            self.callbacks.on_skipped(host, None)\n            return ReturnData(host=host, comm_ok=True, result=dict(changed=False, skipped=True))\n\n    # *****************************************************\n\n    def _executor_internal_inner(self, host, module_name, module_args, inject, port, is_chained=False, complex_args=None):\n        ''' decides how to invoke a module '''\n\n        # late processing of parameterized sudo_user (with_items,..)\n        if self.sudo_user_var is not None:\n            self.sudo_user = template.template(self.basedir, self.sudo_user_var, inject)\n        if self.su_user_var is not None:\n            self.su_user = template.template(self.basedir, self.su_user_var, inject)\n\n        # allow module args to work as a dictionary\n        # though it is usually a string\n        new_args = \"\"\n        if type(module_args) == dict:\n            for (k,v) in module_args.iteritems():\n                new_args = new_args + \"%s='%s' \" % (k,v)\n            module_args = new_args\n\n        # module_name may be dynamic (but cannot contain {{ ansible_ssh_user }})\n        module_name  = template.template(self.basedir, module_name, inject)\n\n        if module_name in utils.plugins.action_loader:\n            if self.background != 0:\n                raise errors.AnsibleError(\"async mode is not supported with the %s module\" % module_name)\n            handler = utils.plugins.action_loader.get(module_name, self)\n        elif self.background == 0:\n            handler = utils.plugins.action_loader.get('normal', self)\n        else:\n            handler = utils.plugins.action_loader.get('async', self)\n\n        if type(self.conditional) != list:\n            self.conditional = [ self.conditional ]\n\n        for cond in self.conditional:\n\n            if not utils.check_conditional(cond, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                result = utils.jsonify(dict(changed=False, skipped=True))\n                self.callbacks.on_skipped(host, inject.get('item',None))\n                return ReturnData(host=host, result=result)\n\n        if getattr(handler, 'setup', None) is not None:\n            handler.setup(module_name, inject)\n        conn = None\n        actual_host = inject.get('ansible_ssh_host', host)\n        # allow ansible_ssh_host to be templated\n        actual_host = template.template(self.basedir, actual_host, inject, fail_on_undefined=True)\n        actual_port = port\n        actual_user = inject.get('ansible_ssh_user', self.remote_user)\n        actual_pass = inject.get('ansible_ssh_pass', self.remote_pass)\n        actual_transport = inject.get('ansible_connection', self.transport)\n        actual_private_key_file = inject.get('ansible_ssh_private_key_file', self.private_key_file)\n        actual_private_key_file = template.template(self.basedir, actual_private_key_file, inject, fail_on_undefined=True)\n        self.sudo = utils.boolean(inject.get('ansible_sudo', self.sudo))\n        self.sudo_user = inject.get('ansible_sudo_user', self.sudo_user)\n        self.sudo_pass = inject.get('ansible_sudo_pass', self.sudo_pass)\n        self.su = inject.get('ansible_su', self.su)\n        self.su_pass = inject.get('ansible_su_pass', self.su_pass)\n\n        # select default root user in case self.sudo requested\n        # but no user specified; happens e.g. in host vars when\n        # just ansible_sudo=True is specified\n        if self.sudo and self.sudo_user is None:\n            self.sudo_user = 'root'\n\n        if actual_private_key_file is not None:\n            actual_private_key_file = os.path.expanduser(actual_private_key_file)\n\n        if self.accelerate and actual_transport != 'local':\n            #Fix to get the inventory name of the host to accelerate plugin\n            if inject.get('ansible_ssh_host', None):\n                self.accelerate_inventory_host = host\n            else:\n                self.accelerate_inventory_host = None\n            # if we're using accelerated mode, force the\n            # transport to accelerate\n            actual_transport = \"accelerate\"\n            if not self.accelerate_port:\n                self.accelerate_port = C.ACCELERATE_PORT\n\n        if actual_transport in [ 'paramiko', 'ssh', 'accelerate' ]:\n            actual_port = inject.get('ansible_ssh_port', port)\n\n        # the delegated host may have different SSH port configured, etc\n        # and we need to transfer those, and only those, variables\n        delegate_to = inject.get('delegate_to', None)\n        if delegate_to is not None:\n            delegate = self._compute_delegate(delegate_to, actual_pass, inject)\n            actual_transport = delegate['transport']\n            actual_host = delegate['ssh_host']\n            actual_port = delegate['port']\n            actual_user = delegate['user']\n            actual_pass = delegate['pass']\n            actual_private_key_file = delegate['private_key_file']\n            self.sudo_pass = delegate['sudo_pass']\n            inject = delegate['inject']\n\n        # user/pass may still contain variables at this stage\n        actual_user = template.template(self.basedir, actual_user, inject)\n        actual_pass = template.template(self.basedir, actual_pass, inject)\n        self.sudo_pass = template.template(self.basedir, self.sudo_pass, inject)\n\n        # make actual_user available as __magic__ ansible_ssh_user variable\n        inject['ansible_ssh_user'] = actual_user\n\n        try:\n            if actual_transport == 'accelerate':\n                # for accelerate, we stuff both ports into a single\n                # variable so that we don't have to mangle other function\n                # calls just to accomodate this one case\n                actual_port = [actual_port, self.accelerate_port]\n            elif actual_port is not None:\n                actual_port = int(template.template(self.basedir, actual_port, inject))\n        except ValueError, e:\n            result = dict(failed=True, msg=\"FAILED: Configured port \\\"%s\\\" is not a valid port, expected integer\" % actual_port)\n            return ReturnData(host=host, comm_ok=False, result=result)\n\n        try:\n            conn = self.connector.connect(actual_host, actual_port, actual_user, actual_pass, actual_transport, actual_private_key_file)\n            if delegate_to or host != actual_host:\n                conn.delegate = host\n\n\n        except errors.AnsibleConnectionFailed, e:\n            result = dict(failed=True, msg=\"FAILED: %s\" % str(e))\n            return ReturnData(host=host, comm_ok=False, result=result)\n\n        tmp = ''\n        # action plugins may DECLARE via TRANSFERS_FILES = True that they need a remote tmp path working dir\n        if self._early_needs_tmp_path(module_name, handler):\n            tmp = self._make_tmp_path(conn)\n\n        # render module_args and complex_args templates\n        try:\n            module_args = template.template(self.basedir, module_args, inject, fail_on_undefined=self.error_on_undefined_vars)\n            complex_args = template.template(self.basedir, complex_args, inject, fail_on_undefined=self.error_on_undefined_vars)\n        except jinja2.exceptions.UndefinedError, e:\n            raise errors.AnsibleUndefinedVariable(\"One or more undefined variables: %s\" % str(e))\n\n\n        result = handler.run(conn, tmp, module_name, module_args, inject, complex_args)\n        # Code for do until feature\n        until = self.module_vars.get('until', None)\n        if until is not None and result.comm_ok:\n            inject[self.module_vars.get('register')] = result.result\n            cond = template.template(self.basedir, until, inject, expand_lists=False)\n            if not utils.check_conditional(cond,  self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                retries = self.module_vars.get('retries')\n                delay   = self.module_vars.get('delay')\n                for x in range(1, int(retries) + 1):\n                    # template the delay, cast to float and sleep\n                    delay = template.template(self.basedir, delay, inject, expand_lists=False)\n                    delay = float(delay)\n                    time.sleep(delay)\n                    tmp = ''\n                    if self._early_needs_tmp_path(module_name, handler):\n                        tmp = self._make_tmp_path(conn)\n                    result = handler.run(conn, tmp, module_name, module_args, inject, complex_args)\n                    result.result['attempts'] = x\n                    vv(\"Result from run %i is: %s\" % (x, result.result))\n                    inject[self.module_vars.get('register')] = result.result\n                    cond = template.template(self.basedir, until, inject, expand_lists=False)\n                    if utils.check_conditional(cond, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                        break\n                if result.result['attempts'] == retries and not utils.check_conditional(cond, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                    result.result['failed'] = True \n                    result.result['msg'] = \"Task failed as maximum retries was encountered\"\n            else:\n                result.result['attempts'] = 0\n        conn.close()\n\n        if not result.comm_ok:\n            # connection or parsing errors...\n            self.callbacks.on_unreachable(host, result.result)\n        else:\n            data = result.result\n\n            # https://github.com/ansible/ansible/issues/4958\n            if hasattr(sys.stdout, \"isatty\"):\n                if \"stdout\" in data and sys.stdout.isatty():\n                    if not string_functions.isprintable(data['stdout']):\n                        data['stdout'] = ''\n\n            if 'item' in inject:\n                result.result['item'] = inject['item']\n\n            result.result['invocation'] = dict(\n                module_args=module_args,\n                module_name=module_name\n            )\n\n            changed_when = self.module_vars.get('changed_when')\n            failed_when = self.module_vars.get('failed_when')\n            if (changed_when is not None or failed_when is not None) and self.background == 0:\n                register = self.module_vars.get('register')\n                if register is not None:\n                    if 'stdout' in data:\n                        data['stdout_lines'] = data['stdout'].splitlines()\n                    inject[register] = data\n                # only run the final checks if the async_status has finished,\n                # or if we're not running an async_status check at all\n                if (module_name == 'async_status' and \"finished\" in data) or module_name != 'async_status':\n                    if changed_when is not None and 'skipped' not in data:\n                        data['changed'] = utils.check_conditional(changed_when, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars)\n                    if failed_when is not None and 'skipped' not in data:\n                        data['failed_when_result'] = data['failed'] = utils.check_conditional(failed_when, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars)\n\n            if is_chained:\n                # no callbacks\n                return result\n            if 'skipped' in data:\n                self.callbacks.on_skipped(host, inject.get('item',None))\n            elif not result.is_successful():\n                ignore_errors = self.module_vars.get('ignore_errors', False)\n                self.callbacks.on_failed(host, data, ignore_errors)\n            else:\n                if self.diff:\n                    self.callbacks.on_file_diff(conn.host, result.diff)\n                self.callbacks.on_ok(host, data)\n        return result\n\n    def _early_needs_tmp_path(self, module_name, handler):\n        ''' detect if a tmp path should be created before the handler is called '''\n        if module_name in utils.plugins.action_loader:\n          return getattr(handler, 'TRANSFERS_FILES', False)\n        # other modules never need tmp path at early stage\n        return False\n\n    def _late_needs_tmp_path(self, conn, tmp, module_style):\n        if \"tmp\" in tmp:\n            # tmp has already been created\n            return False\n        if not conn.has_pipelining or not C.ANSIBLE_SSH_PIPELINING or C.DEFAULT_KEEP_REMOTE_FILES or self.su:\n            # tmp is necessary to store module source code\n            return True\n        if not conn.has_pipelining:\n            # tmp is necessary to store the module source code\n            # or we want to keep the files on the target system\n            return True\n        if module_style != \"new\":\n            # even when conn has pipelining, old style modules need tmp to store arguments\n            return True\n        return False\n    \n\n    # *****************************************************\n\n    def _low_level_exec_command(self, conn, cmd, tmp, sudoable=False,\n                                executable=None, su=False, in_data=None):\n        ''' execute a command string over SSH, return the output '''\n\n        if executable is None:\n            executable = C.DEFAULT_EXECUTABLE\n\n        sudo_user = self.sudo_user\n        su_user = self.su_user\n\n        # compare connection user to (su|sudo)_user and disable if the same\n        if hasattr(conn, 'user'):\n            if (not su and conn.user == sudo_user) or (su and conn.user == su_user):\n                sudoable = False\n                su = False\n        else:\n            # assume connection type is local if no user attribute\n            this_user = getpass.getuser()\n            if (not su and this_user == sudo_user) or (su and this_user == su_user):\n                sudoable = False\n                su = False\n\n        if su:\n            rc, stdin, stdout, stderr = conn.exec_command(cmd,\n                                                          tmp,\n                                                          su=su,\n                                                          su_user=su_user,\n                                                          executable=executable,\n                                                          in_data=in_data)\n        else:\n            rc, stdin, stdout, stderr = conn.exec_command(cmd,\n                                                          tmp,\n                                                          sudo_user,\n                                                          sudoable=sudoable,\n                                                          executable=executable,\n                                                          in_data=in_data)\n\n        if type(stdout) not in [ str, unicode ]:\n            out = ''.join(stdout.readlines())\n        else:\n            out = stdout\n\n        if type(stderr) not in [ str, unicode ]:\n            err = ''.join(stderr.readlines())\n        else:\n            err = stderr\n\n        if rc is not None:\n            return dict(rc=rc, stdout=out, stderr=err)\n        else:\n            return dict(stdout=out, stderr=err)\n\n    # *****************************************************\n\n    def _remote_md5(self, conn, tmp, path):\n        ''' takes a remote md5sum without requiring python, and returns 1 if no file '''\n\n        path = pipes.quote(path)\n        # The following test needs to be SH-compliant.  BASH-isms will\n        # not work if /bin/sh points to a non-BASH shell.\n        test = \"rc=0; [ -r \\\"%s\\\" ] || rc=2; [ -f \\\"%s\\\" ] || rc=1; [ -d \\\"%s\\\" ] && echo 3 && exit 0\" % ((path,) * 3)\n        md5s = [\n            \"(/usr/bin/md5sum %s 2>/dev/null)\" % path,          # Linux\n            \"(/sbin/md5sum -q %s 2>/dev/null)\" % path,          # ?\n            \"(/usr/bin/digest -a md5 %s 2>/dev/null)\" % path,   # Solaris 10+\n            \"(/sbin/md5 -q %s 2>/dev/null)\" % path,             # Freebsd\n            \"(/usr/bin/md5 -n %s 2>/dev/null)\" % path,          # Netbsd\n            \"(/bin/md5 -q %s 2>/dev/null)\" % path,              # Openbsd\n            \"(/usr/bin/csum -h MD5 %s 2>/dev/null)\" % path,     # AIX\n            \"(/bin/csum -h MD5 %s 2>/dev/null)\" % path          # AIX also\n        ]\n\n        cmd = \" || \".join(md5s)\n        cmd = \"%s; %s || (echo \\\"${rc}  %s\\\")\" % (test, cmd, path)\n        data = self._low_level_exec_command(conn, cmd, tmp, sudoable=True)\n        data2 = utils.last_non_blank_line(data['stdout'])\n        try:\n            if data2 == '':\n                # this may happen if the connection to the remote server\n                # failed, so just return \"INVALIDMD5SUM\" to avoid errors\n                return \"INVALIDMD5SUM\"\n            else:\n                return data2.split()[0]\n        except IndexError:\n            sys.stderr.write(\"warning: md5sum command failed unusually, please report this to the list so it can be fixed\\n\")\n            sys.stderr.write(\"command: %s\\n\" % md5s)\n            sys.stderr.write(\"----\\n\")\n            sys.stderr.write(\"output: %s\\n\" % data)\n            sys.stderr.write(\"----\\n\")\n            # this will signal that it changed and allow things to keep going\n            return \"INVALIDMD5SUM\"\n\n    # *****************************************************\n\n    def _make_tmp_path(self, conn):\n        ''' make and return a temporary path on a remote box '''\n\n        basefile = 'ansible-tmp-%s-%s' % (time.time(), random.randint(0, 2**48))\n        basetmp = os.path.join(C.DEFAULT_REMOTE_TMP, basefile)\n        if (self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root') and basetmp.startswith('$HOME'):\n            basetmp = os.path.join('/tmp', basefile)\n\n        cmd = 'mkdir -p %s' % basetmp\n        if self.remote_user != 'root' or ((self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root')):\n            cmd += ' && chmod a+rx %s' % basetmp\n        cmd += ' && echo %s' % basetmp\n\n        result = self._low_level_exec_command(conn, cmd, None, sudoable=False)\n\n        # error handling on this seems a little aggressive?\n        if result['rc'] != 0:\n            if result['rc'] == 5:\n                output = 'Authentication failure.'\n            elif result['rc'] == 255 and self.transport in ['ssh']:\n                if utils.VERBOSITY > 3:\n                    output = 'SSH encountered an unknown error. The output was:\\n%s' % (result['stdout']+result['stderr'])\n                else:\n                    output = 'SSH encountered an unknown error during the connection. We recommend you re-run the command using -vvvv, which will enable SSH debugging output to help diagnose the issue'\n            else:\n                output = 'Authentication or permission failure.  In some cases, you may have been able to authenticate and did not have permissions on the remote directory. Consider changing the remote temp path in ansible.cfg to a path rooted in \"/tmp\". Failed command was: %s, exited with result %d' % (cmd, result['rc'])\n            if 'stdout' in result and result['stdout'] != '':\n                output = output + \": %s\" % result['stdout']\n            raise errors.AnsibleError(output)\n\n        rc = utils.last_non_blank_line(result['stdout']).strip() + '/'\n        # Catch failure conditions, files should never be\n        # written to locations in /.\n        if rc == '/': \n            raise errors.AnsibleError('failed to resolve remote temporary directory from %s: `%s` returned empty string' % (basetmp, cmd))\n        return rc\n\n    # *****************************************************\n\n    def _remove_tmp_path(self, conn, tmp_path):\n        ''' Remove a tmp_path. '''\n\n        if \"-tmp-\" in tmp_path:\n            cmd = \"rm -rf %s >/dev/null 2>&1\" % tmp_path\n            self._low_level_exec_command(conn, cmd, None, sudoable=False)\n            # If we have gotten here we have a working ssh configuration.\n            # If ssh breaks we could leave tmp directories out on the remote system.\n\n    # *****************************************************\n\n    def _copy_module(self, conn, tmp, module_name, module_args, inject, complex_args=None):\n        ''' transfer a module over SFTP, does not run it '''\n        (\n        module_style,\n        module_shebang,\n        module_data\n        ) = self._configure_module(conn, module_name, module_args, inject, complex_args)\n        module_remote_path = os.path.join(tmp, module_name)\n        \n        self._transfer_str(conn, tmp, module_name, module_data)\n         \n        return (module_remote_path, module_style, module_shebang)\n\n    # *****************************************************\n\n    def _configure_module(self, conn, module_name, module_args, inject, complex_args=None):\n        ''' find module and configure it '''\n\n        # Search module path(s) for named module.\n        module_path = utils.plugins.module_finder.find_plugin(module_name)\n        if module_path is None:\n            raise errors.AnsibleFileNotFound(\"module %s not found in %s\" % (module_name, utils.plugins.module_finder.print_paths()))\n\n\n        # insert shared code and arguments into the module\n        (module_data, module_style, module_shebang) = module_replacer.modify_module(\n            module_path, complex_args, module_args, inject\n        )\n\n        return (module_style, module_shebang, module_data)\n\n\n    # *****************************************************\n\n\n    def _parallel_exec(self, hosts):\n        ''' handles mulitprocessing when more than 1 fork is required '''\n\n        manager = multiprocessing.Manager()\n        job_queue = manager.Queue()\n        for host in hosts:\n            job_queue.put(host)\n        result_queue = manager.Queue()\n\n        try:\n            fileno = sys.stdin.fileno()\n        except ValueError:\n            fileno = None\n\n        workers = []\n        for i in range(self.forks):\n            new_stdin = None\n            if fileno is not None:\n                try:\n                    new_stdin = os.fdopen(os.dup(fileno))\n                except OSError, e:\n                    # couldn't dupe stdin, most likely because it's\n                    # not a valid file descriptor, so we just rely on\n                    # using the one that was passed in\n                    pass\n            prc = multiprocessing.Process(target=_executor_hook,\n                args=(job_queue, result_queue, new_stdin))\n            prc.start()\n            workers.append(prc)\n\n        try:\n            for worker in workers:\n                worker.join()\n        except KeyboardInterrupt:\n            for worker in workers:\n                worker.terminate()\n                worker.join()\n        \n        results = []\n        try:\n            while not result_queue.empty():\n                results.append(result_queue.get(block=False))\n        except socket.error:\n            raise errors.AnsibleError(\"<interrupted>\")\n        return results\n\n    # *****************************************************\n\n    def _partition_results(self, results):\n        ''' separate results by ones we contacted & ones we didn't '''\n\n        if results is None:\n            return None\n        results2 = dict(contacted={}, dark={})\n\n        for result in results:\n            host = result.host\n            if host is None:\n                raise Exception(\"internal error, host not set\")\n            if result.communicated_ok():\n                results2[\"contacted\"][host] = result.result\n            else:\n                results2[\"dark\"][host] = result.result\n\n        # hosts which were contacted but never got a chance to return\n        for host in self.run_hosts:\n            if not (host in results2['dark'] or host in results2['contacted']):\n                results2[\"dark\"][host] = {}\n        return results2\n\n    # *****************************************************\n\n    def run(self):\n        ''' xfer & run module on all matched hosts '''\n\n        # find hosts that match the pattern\n        if not self.run_hosts:\n            self.run_hosts = self.inventory.list_hosts(self.pattern)\n        hosts = self.run_hosts\n        if len(hosts) == 0:\n            self.callbacks.on_no_hosts()\n            return dict(contacted={}, dark={})\n\n        global multiprocessing_runner\n        multiprocessing_runner = self\n        results = None\n\n        # Check if this is an action plugin. Some of them are designed\n        # to be ran once per group of hosts. Example module: pause,\n        # run once per hostgroup, rather than pausing once per each\n        # host.\n        p = utils.plugins.action_loader.get(self.module_name, self)\n\n        if self.forks == 0 or self.forks > len(hosts):\n            self.forks = len(hosts)\n\n        if p and getattr(p, 'BYPASS_HOST_LOOP', None):\n\n            # Expose the current hostgroup to the bypassing plugins\n            self.host_set = hosts\n            # We aren't iterating over all the hosts in this\n            # group. So, just pick the first host in our group to\n            # construct the conn object with.\n            result_data = self._executor(hosts[0], None).result\n            # Create a ResultData item for each host in this group\n            # using the returned result. If we didn't do this we would\n            # get false reports of dark hosts.\n            results = [ ReturnData(host=h, result=result_data, comm_ok=True) \\\n                           for h in hosts ]\n            del self.host_set\n\n        elif self.forks > 1:\n            try:\n                results = self._parallel_exec(hosts)\n            except IOError, ie:\n                print ie.errno\n                if ie.errno == 32:\n                    # broken pipe from Ctrl+C\n                    raise errors.AnsibleError(\"interrupted\")\n                raise\n        else:\n            results = [ self._executor(h, None) for h in hosts ]\n\n        return self._partition_results(results)\n\n    # *****************************************************\n\n    def run_async(self, time_limit):\n        ''' Run this module asynchronously and return a poller. '''\n\n        self.background = time_limit\n        results = self.run()\n        return results, poller.AsyncPoller(results, self)\n\n    # *****************************************************\n\n    def noop_on_check(self, inject):\n        ''' Should the runner run in check mode or not ? '''\n\n        # initialize self.always_run on first call\n        if self.always_run is None:\n            self.always_run = self.module_vars.get('always_run', False)\n            self.always_run = check_conditional(\n                self.always_run, self.basedir, inject, fail_on_undefined=True)\n\n        return (self.check and not self.always_run)\n", "# (c) 2013-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#           Stephen Fromm <sfromm@gmail.com>\n#           Brian Coca  <briancoca+dev@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n\nimport os\nimport os.path\nimport pipes\nimport shutil\nimport tempfile\nimport base64\nfrom ansible import utils\nfrom ansible.runner.return_data import ReturnData\n\nclass ActionModule(object):\n\n    TRANSFERS_FILES = True\n\n    def __init__(self, runner):\n        self.runner = runner\n\n    def _assemble_from_fragments(self, src_path, delimiter=None, compiled_regexp=None):\n        ''' assemble a file from a directory of fragments '''\n        tmpfd, temp_path = tempfile.mkstemp()\n        tmp = os.fdopen(tmpfd,'w')\n        delimit_me = False\n        add_newline = False\n\n        for f in sorted(os.listdir(src_path)):\n            if compiled_regexp and not compiled_regexp.search(f):\n                continue\n            fragment = \"%s/%s\" % (src_path, f)\n            if not os.path.isfile(fragment):\n                continue\n            fragment_content = file(fragment).read()\n\n            # always put a newline between fragments if the previous fragment didn't end with a newline.\n            if add_newline:\n                tmp.write('\\n')\n\n            # delimiters should only appear between fragments\n            if delimit_me:\n                if delimiter:\n                    # un-escape anything like newlines\n                    delimiter = delimiter.decode('unicode-escape')\n                    tmp.write(delimiter)\n                    # always make sure there's a newline after the\n                    # delimiter, so lines don't run together\n                    if delimiter[-1] != '\\n':\n                        tmp.write('\\n')\n\n            tmp.write(fragment_content)\n            delimit_me = True\n            if fragment_content.endswith('\\n'):\n                add_newline = False\n            else:\n                add_newline = True\n\n        tmp.close()\n        return temp_path\n\n    def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **kwargs):\n\n        # load up options\n        options  = {}\n        if complex_args:\n            options.update(complex_args)\n\n        options.update(utils.parse_kv(module_args))\n\n        src = options.get('src', None)\n        dest = options.get('dest', None)\n        delimiter = options.get('delimiter', None)\n        remote_src = utils.boolean(options.get('remote_src', 'yes'))\n\n\n        if src is None or dest is None:\n            result = dict(failed=True, msg=\"src and dest are required\")\n            return ReturnData(conn=conn, comm_ok=False, result=result)\n\n        if remote_src:\n            return self.runner._execute_module(conn, tmp, 'assemble', module_args, inject=inject, complex_args=complex_args)\n        elif '_original_file' in inject:\n            src = utils.path_dwim_relative(inject['_original_file'], 'files', src, self.runner.basedir)\n        else:\n            # the source is local, so expand it here\n            src = os.path.expanduser(src)\n\n        # Does all work assembling the file\n        path = self._assemble_from_fragments(src, delimiter)\n\n        pathmd5 = utils.md5s(path)\n        remote_md5 = self.runner._remote_md5(conn, tmp, dest)\n\n        if pathmd5 != remote_md5:\n            resultant = file(path).read()\n            if self.runner.diff:\n                dest_result = self.runner._execute_module(conn, tmp, 'slurp', \"path=%s\" % dest, inject=inject, persist_files=True)\n                if 'content' in dest_result.result:\n                    dest_contents = dest_result.result['content']\n                    if dest_result.result['encoding'] == 'base64':\n                        dest_contents = base64.b64decode(dest_contents)\n                    else:\n                        raise Exception(\"unknown encoding, failed: %s\" % dest_result.result)\n            xfered = self.runner._transfer_str(conn, tmp, 'src', resultant)\n\n            # fix file permissions when the copy is done as a different user\n            if self.runner.sudo and self.runner.sudo_user != 'root':\n                self.runner._low_level_exec_command(conn, \"chmod a+r %s\" % xfered, tmp)\n\n            # run the copy module\n            module_args = \"%s src=%s dest=%s original_basename=%s\" % (module_args, pipes.quote(xfered), pipes.quote(dest), pipes.quote(os.path.basename(src)))\n\n            if self.runner.noop_on_check(inject):\n                return ReturnData(conn=conn, comm_ok=True, result=dict(changed=True), diff=dict(before_header=dest, after_header=src, after=resultant))\n            else:\n                res = self.runner._execute_module(conn, tmp, 'copy', module_args, inject=inject)\n                res.diff = dict(after=resultant)\n                return res\n        else:\n            module_args = \"%s src=%s dest=%s original_basename=%s\" % (module_args, pipes.quote(xfered), pipes.quote(dest), pipes.quote(os.path.basename(src)))\n            return self.runner._execute_module(conn, tmp, 'file', module_args, inject=inject)\n", "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\n\nfrom ansible import utils\nimport ansible.constants as C\nimport ansible.utils.template as template\nfrom ansible import errors\nfrom ansible.runner.return_data import ReturnData\nimport base64\nimport json\nimport stat\nimport tempfile\nimport pipes\n\n## fixes https://github.com/ansible/ansible/issues/3518\n# http://mypy.pythonblogs.com/12_mypy/archive/1253_workaround_for_python_bug_ascii_codec_cant_encode_character_uxa0_in_position_111_ordinal_not_in_range128.html\nimport sys\nreload(sys)\nsys.setdefaultencoding(\"utf8\")\n\n\nclass ActionModule(object):\n\n    def __init__(self, runner):\n        self.runner = runner\n\n    def run(self, conn, tmp_path, module_name, module_args, inject, complex_args=None, **kwargs):\n        ''' handler for file transfer operations '''\n\n        # load up options\n        options = {}\n        if complex_args:\n            options.update(complex_args)\n        options.update(utils.parse_kv(module_args))\n        source  = options.get('src', None)\n        content = options.get('content', None)\n        dest    = options.get('dest', None)\n        raw     = utils.boolean(options.get('raw', 'no'))\n        force   = utils.boolean(options.get('force', 'yes'))\n\n        # content with newlines is going to be escaped to safely load in yaml\n        # now we need to unescape it so that the newlines are evaluated properly\n        # when writing the file to disk\n        if content:\n            if isinstance(content, unicode):\n                try:\n                    content = content.decode('unicode-escape')\n                except UnicodeDecodeError:\n                    pass\n\n        if (source is None and content is None and not 'first_available_file' in inject) or dest is None:\n            result=dict(failed=True, msg=\"src (or content) and dest are required\")\n            return ReturnData(conn=conn, result=result)\n        elif (source is not None or 'first_available_file' in inject) and content is not None:\n            result=dict(failed=True, msg=\"src and content are mutually exclusive\")\n            return ReturnData(conn=conn, result=result)\n\n        # Check if the source ends with a \"/\"\n        source_trailing_slash = False\n        if source:\n            source_trailing_slash = source.endswith(\"/\")\n\n        # Define content_tempfile in case we set it after finding content populated.\n        content_tempfile = None\n\n        # If content is defined make a temp file and write the content into it.\n        if content is not None:\n            try:\n                # If content comes to us as a dict it should be decoded json.\n                # We need to encode it back into a string to write it out.\n                if type(content) is dict:\n                    content_tempfile = self._create_content_tempfile(json.dumps(content))\n                else:\n                    content_tempfile = self._create_content_tempfile(content)\n                source = content_tempfile\n            except Exception, err:\n                result = dict(failed=True, msg=\"could not write content temp file: %s\" % err)\n                return ReturnData(conn=conn, result=result)\n        # if we have first_available_file in our vars\n        # look up the files and use the first one we find as src\n        elif 'first_available_file' in inject:\n            found = False\n            for fn in inject.get('first_available_file'):\n                fn_orig = fn\n                fnt = template.template(self.runner.basedir, fn, inject)\n                fnd = utils.path_dwim(self.runner.basedir, fnt)\n                if not os.path.exists(fnd) and '_original_file' in inject:\n                    fnd = utils.path_dwim_relative(inject['_original_file'], 'files', fnt, self.runner.basedir, check=False)\n                if os.path.exists(fnd):\n                    source = fnd\n                    found = True\n                    break\n            if not found:\n                results = dict(failed=True, msg=\"could not find src in first_available_file list\")\n                return ReturnData(conn=conn, result=results)\n        else:\n            source = template.template(self.runner.basedir, source, inject)\n            if '_original_file' in inject:\n                source = utils.path_dwim_relative(inject['_original_file'], 'files', source, self.runner.basedir)\n            else:\n                source = utils.path_dwim(self.runner.basedir, source)\n\n        # A list of source file tuples (full_path, relative_path) which will try to copy to the destination\n        source_files = []\n\n        # If source is a directory populate our list else source is a file and translate it to a tuple.\n        if os.path.isdir(source):\n            # Get the amount of spaces to remove to get the relative path.\n            if source_trailing_slash:\n                sz = len(source) + 1\n            else:\n                sz = len(source.rsplit('/', 1)[0]) + 1\n\n            # Walk the directory and append the file tuples to source_files.\n            for base_path, sub_folders, files in os.walk(source):\n                for file in files:\n                    full_path = os.path.join(base_path, file)\n                    rel_path = full_path[sz:]\n                    source_files.append((full_path, rel_path))\n\n            # If it's recursive copy, destination is always a dir,\n            # explicitly mark it so (note - copy module relies on this).\n            if not dest.endswith(\"/\"):\n                dest += \"/\"\n        else:\n            source_files.append((source, os.path.basename(source)))\n\n        changed = False\n        diffs = []\n        module_result = {\"changed\": False}\n\n        # A register for if we executed a module.\n        # Used to cut down on command calls when not recursive.\n        module_executed = False\n\n        # Tell _execute_module to delete the file if there is one file.\n        delete_remote_tmp = (len(source_files) == 1)\n\n        # If this is a recursive action create a tmp_path that we can share as the _exec_module create is too late.\n        if not delete_remote_tmp:\n            if \"-tmp-\" not in tmp_path:\n                tmp_path = self.runner._make_tmp_path(conn)\n\n        for source_full, source_rel in source_files:\n            # Generate the MD5 hash of the local file.\n            local_md5 = utils.md5(source_full)\n\n            # If local_md5 is not defined we can't find the file so we should fail out.\n            if local_md5 is None:\n                result = dict(failed=True, msg=\"could not find src=%s\" % source_full)\n                return ReturnData(conn=conn, result=result)\n\n            # This is kind of optimization - if user told us destination is\n            # dir, do path manipulation right away, otherwise we still check\n            # for dest being a dir via remote call below.\n            if dest.endswith(\"/\"):\n                dest_file = os.path.join(dest, source_rel)\n            else:\n                dest_file = dest\n\n            # Attempt to get the remote MD5 Hash.\n            remote_md5 = self.runner._remote_md5(conn, tmp_path, dest_file)\n\n            if remote_md5 == '3':\n                # The remote_md5 was executed on a directory.\n                if content is not None:\n                    # If source was defined as content remove the temporary file and fail out.\n                    self._remove_tempfile_if_content_defined(content, content_tempfile)\n                    result = dict(failed=True, msg=\"can not use content with a dir as dest\")\n                    return ReturnData(conn=conn, result=result)\n                else:\n                    # Append the relative source location to the destination and retry remote_md5.\n                    dest_file = os.path.join(dest, source_rel)\n                    remote_md5 = self.runner._remote_md5(conn, tmp_path, dest_file)\n\n            if remote_md5 != '1' and not force:\n                # remote_file does not exist so continue to next iteration.\n                continue\n\n            if local_md5 != remote_md5:\n                # The MD5 hashes don't match and we will change or error out.\n                changed = True\n\n                # Create a tmp_path if missing only if this is not recursive.\n                # If this is recursive we already have a tmp_path.\n                if delete_remote_tmp:\n                    if \"-tmp-\" not in tmp_path:\n                        tmp_path = self.runner._make_tmp_path(conn)\n\n                if self.runner.diff and not raw:\n                    diff = self._get_diff_data(conn, tmp_path, inject, dest_file, source_full)\n                else:\n                    diff = {}\n\n                if self.runner.noop_on_check(inject):\n                    self._remove_tempfile_if_content_defined(content, content_tempfile)\n                    diffs.append(diff)\n                    changed = True\n                    module_result = dict(changed=True)\n                    continue\n\n                # Define a remote directory that we will copy the file to.\n                tmp_src = tmp_path + 'source'\n\n                if not raw:\n                    conn.put_file(source_full, tmp_src)\n                else:\n                    conn.put_file(source_full, dest_file)\n\n                # We have copied the file remotely and no longer require our content_tempfile\n                self._remove_tempfile_if_content_defined(content, content_tempfile)\n\n                # fix file permissions when the copy is done as a different user\n                if self.runner.sudo and self.runner.sudo_user != 'root' and not raw:\n                    self.runner._low_level_exec_command(conn, \"chmod a+r %s\" % tmp_src, tmp_path)\n\n                if raw:\n                    # Continue to next iteration if raw is defined.\n                    continue\n\n                # Run the copy module\n\n                # src and dest here come after original and override them\n                # we pass dest only to make sure it includes trailing slash in case of recursive copy\n                module_args_tmp = \"%s src=%s dest=%s original_basename=%s\" % (module_args,\n                                  pipes.quote(tmp_src), pipes.quote(dest), pipes.quote(source_rel))\n\n                if self.runner.no_log:\n                    module_args_tmp = \"%s NO_LOG=True\" % module_args_tmp\n\n                module_return = self.runner._execute_module(conn, tmp_path, 'copy', module_args_tmp, inject=inject, complex_args=complex_args, delete_remote_tmp=delete_remote_tmp)\n                module_executed = True\n\n            else:\n                # no need to transfer the file, already correct md5, but still need to call\n                # the file module in case we want to change attributes\n                self._remove_tempfile_if_content_defined(content, content_tempfile)\n\n                if raw:\n                    # Continue to next iteration if raw is defined.\n                    # self.runner._remove_tmp_path(conn, tmp_path)\n                    continue\n\n                tmp_src = tmp_path + source_rel\n\n                # Build temporary module_args.\n                module_args_tmp = \"%s src=%s original_basename=%s\" % (module_args,\n                                  pipes.quote(tmp_src), pipes.quote(source_rel))\n                if self.runner.noop_on_check(inject):\n                    module_args_tmp = \"%s CHECKMODE=True\" % module_args_tmp\n                if self.runner.no_log:\n                    module_args_tmp = \"%s NO_LOG=True\" % module_args_tmp\n\n                # Execute the file module.\n                module_return = self.runner._execute_module(conn, tmp_path, 'file', module_args_tmp, inject=inject, complex_args=complex_args, delete_remote_tmp=delete_remote_tmp)\n                module_executed = True\n\n            module_result = module_return.result\n            if not module_result.get('md5sum'):\n                module_result['md5sum'] = local_md5\n            if module_result.get('failed') == True:\n                return module_return\n            if module_result.get('changed') == True:\n                changed = True\n\n        # Delete tmp_path if we were recursive or if we did not execute a module.\n        if (not C.DEFAULT_KEEP_REMOTE_FILES and not delete_remote_tmp) \\\n            or (not C.DEFAULT_KEEP_REMOTE_FILES and delete_remote_tmp and not module_executed):\n            self.runner._remove_tmp_path(conn, tmp_path)\n\n        # the file module returns the file path as 'path', but \n        # the copy module uses 'dest', so add it if it's not there\n        if 'path' in module_result and 'dest' not in module_result:\n            module_result['dest'] = module_result['path']\n\n        # TODO: Support detailed status/diff for multiple files\n        if len(source_files) == 1:\n            result = module_result\n        else:\n            result = dict(dest=dest, src=source, changed=changed)\n        if len(diffs) == 1:\n            return ReturnData(conn=conn, result=result, diff=diffs[0])\n        else:\n            return ReturnData(conn=conn, result=result)\n\n    def _create_content_tempfile(self, content):\n        ''' Create a tempfile containing defined content '''\n        fd, content_tempfile = tempfile.mkstemp()\n        f = os.fdopen(fd, 'w')\n        try:\n            f.write(content)\n        except Exception, err:\n            os.remove(content_tempfile)\n            raise Exception(err)\n        finally:\n            f.close()\n        return content_tempfile\n\n    def _get_diff_data(self, conn, tmp, inject, destination, source):\n        peek_result = self.runner._execute_module(conn, tmp, 'file', \"path=%s diff_peek=1\" % destination, inject=inject, persist_files=True)\n\n        if not peek_result.is_successful():\n            return {}\n\n        diff = {}\n        if peek_result.result['state'] == 'absent':\n            diff['before'] = ''\n        elif peek_result.result['appears_binary']:\n            diff['dst_binary'] = 1\n        elif peek_result.result['size'] > utils.MAX_FILE_SIZE_FOR_DIFF:\n            diff['dst_larger'] = utils.MAX_FILE_SIZE_FOR_DIFF\n        else:\n            dest_result = self.runner._execute_module(conn, tmp, 'slurp', \"path=%s\" % destination, inject=inject, persist_files=True)\n            if 'content' in dest_result.result:\n                dest_contents = dest_result.result['content']\n                if dest_result.result['encoding'] == 'base64':\n                    dest_contents = base64.b64decode(dest_contents)\n                else:\n                    raise Exception(\"unknown encoding, failed: %s\" % dest_result.result)\n                diff['before_header'] = destination\n                diff['before'] = dest_contents\n\n        src = open(source)\n        src_contents = src.read(8192)\n        st = os.stat(source)\n        if \"\\x00\" in src_contents:\n            diff['src_binary'] = 1\n        elif st[stat.ST_SIZE] > utils.MAX_FILE_SIZE_FOR_DIFF:\n            diff['src_larger'] = utils.MAX_FILE_SIZE_FOR_DIFF\n        else:\n            src.seek(0)\n            diff['after_header'] = source\n            diff['after'] = src.read()\n\n        return diff\n\n    def _remove_tempfile_if_content_defined(self, content, content_tempfile):\n        if content is not None:\n            os.remove(content_tempfile)\n\n    \n    def _result_key_merge(self, options, results):\n        # add keys to file module results to mimic copy\n        if 'path' in results.result and 'dest' not in results.result:\n            results.result['dest'] = results.result['path']\n            del results.result['path']\n        return results\n", "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport pipes\nfrom ansible.utils import template\nfrom ansible import utils\nfrom ansible import errors\nfrom ansible.runner.return_data import ReturnData\nimport base64\n\nclass ActionModule(object):\n\n    TRANSFERS_FILES = True\n\n    def __init__(self, runner):\n        self.runner = runner\n\n    def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **kwargs):\n        ''' handler for template operations '''\n\n        # note: since this module just calls the copy module, the --check mode support\n        # can be implemented entirely over there\n\n        if not self.runner.is_playbook:\n            raise errors.AnsibleError(\"in current versions of ansible, templates are only usable in playbooks\")\n\n        # load up options\n        options  = {}\n        if complex_args:\n            options.update(complex_args)\n        options.update(utils.parse_kv(module_args))\n\n        source   = options.get('src', None)\n        dest     = options.get('dest', None)\n\n        if (source is None and 'first_available_file' not in inject) or dest is None:\n            result = dict(failed=True, msg=\"src and dest are required\")\n            return ReturnData(conn=conn, comm_ok=False, result=result)\n\n        # if we have first_available_file in our vars\n        # look up the files and use the first one we find as src\n\n        if 'first_available_file' in inject:\n            found = False\n            for fn in self.runner.module_vars.get('first_available_file'):\n                fn_orig = fn\n                fnt = template.template(self.runner.basedir, fn, inject)\n                fnd = utils.path_dwim(self.runner.basedir, fnt)\n                if not os.path.exists(fnd) and '_original_file' in inject:\n                    fnd = utils.path_dwim_relative(inject['_original_file'], 'templates', fnt, self.runner.basedir, check=False)\n                if os.path.exists(fnd):\n                    source = fnd\n                    found = True\n                    break\n            if not found:\n                result = dict(failed=True, msg=\"could not find src in first_available_file list\")\n                return ReturnData(conn=conn, comm_ok=False, result=result)\n        else:\n            source = template.template(self.runner.basedir, source, inject)\n                \n            if '_original_file' in inject:\n                source = utils.path_dwim_relative(inject['_original_file'], 'templates', source, self.runner.basedir)\n            else:\n                source = utils.path_dwim(self.runner.basedir, source)\n\n\n        if dest.endswith(\"/\"):\n            base = os.path.basename(source)\n            dest = os.path.join(dest, base)\n\n        # template the source data locally & get ready to transfer\n        try:\n            resultant = template.template_from_file(self.runner.basedir, source, inject, vault_password=self.runner.vault_pass)\n        except Exception, e:\n            result = dict(failed=True, msg=str(e))\n            return ReturnData(conn=conn, comm_ok=False, result=result)\n\n        local_md5 = utils.md5s(resultant)\n        remote_md5 = self.runner._remote_md5(conn, tmp, dest)\n\n        if local_md5 != remote_md5:\n\n            # template is different from the remote value\n\n            # if showing diffs, we need to get the remote value\n            dest_contents = ''\n\n            if self.runner.diff:\n                # using persist_files to keep the temp directory around to avoid needing to grab another\n                dest_result = self.runner._execute_module(conn, tmp, 'slurp', \"path=%s\" % dest, inject=inject, persist_files=True)\n                if 'content' in dest_result.result:\n                    dest_contents = dest_result.result['content']\n                    if dest_result.result['encoding'] == 'base64':\n                        dest_contents = base64.b64decode(dest_contents)\n                    else:\n                        raise Exception(\"unknown encoding, failed: %s\" % dest_result.result)\n \n            xfered = self.runner._transfer_str(conn, tmp, 'source', resultant)\n\n            # fix file permissions when the copy is done as a different user\n            if self.runner.sudo and self.runner.sudo_user != 'root':\n                self.runner._low_level_exec_command(conn, \"chmod a+r %s\" % xfered, tmp)\n\n            # run the copy module\n            module_args = \"%s src=%s dest=%s original_basename=%s\" % (module_args, pipes.quote(xfered), pipes.quote(dest), pipes.quote(os.path.basename(source)))\n\n            if self.runner.noop_on_check(inject):\n                return ReturnData(conn=conn, comm_ok=True, result=dict(changed=True), diff=dict(before_header=dest, after_header=source, before=dest_contents, after=resultant))\n            else:\n                res = self.runner._execute_module(conn, tmp, 'copy', module_args, inject=inject, complex_args=complex_args)\n                if res.result.get('changed', False):\n                    res.diff = dict(before=dest_contents, after=resultant)\n                return res\n        else:\n            return self.runner._execute_module(conn, tmp, 'file', module_args, inject=inject, complex_args=complex_args)\n\n", "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport re\nimport os\nimport shlex\nimport yaml\nimport copy\nimport optparse\nimport operator\nfrom ansible import errors\nfrom ansible import __version__\nfrom ansible.utils import template\nfrom ansible.utils.display_functions import *\nfrom ansible.utils.plugins import *\nfrom ansible.callbacks import display\nimport ansible.constants as C\nimport ast\nimport time\nimport StringIO\nimport stat\nimport termios\nimport tty\nimport pipes\nimport random\nimport difflib\nimport warnings\nimport traceback\nimport getpass\nimport sys\nimport json\n\nfrom vault import VaultLib\n\nVERBOSITY=0\n\nMAX_FILE_SIZE_FOR_DIFF=1*1024*1024\n\ntry:\n    import json\nexcept ImportError:\n    import simplejson as json\n\ntry:\n    from hashlib import md5 as _md5\nexcept ImportError:\n    from md5 import md5 as _md5\n\nPASSLIB_AVAILABLE = False\ntry:\n    import passlib.hash\n    PASSLIB_AVAILABLE = True\nexcept:\n    pass\n\ntry:\n    import builtin\nexcept ImportError:\n    import __builtin__ as builtin\n\nKEYCZAR_AVAILABLE=False\ntry:\n    try:\n        # some versions of pycrypto may not have this?\n        from Crypto.pct_warnings import PowmInsecureWarning\n    except ImportError:\n        PowmInsecureWarning = RuntimeWarning\n\n    with warnings.catch_warnings(record=True) as warning_handler:\n        warnings.simplefilter(\"error\", PowmInsecureWarning)\n        try:\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        except PowmInsecureWarning:\n            system_warning(\n                \"The version of gmp you have installed has a known issue regarding \" + \\\n                \"timing vulnerabilities when used with pycrypto. \" + \\\n                \"If possible, you should update it (ie. yum update gmp).\"\n            )\n            warnings.resetwarnings()\n            warnings.simplefilter(\"ignore\")\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        KEYCZAR_AVAILABLE=True\nexcept ImportError:\n    pass\n\n###############################################################\n# Abstractions around keyczar\n###############################################################\n\ndef key_for_hostname(hostname):\n    # fireball mode is an implementation of ansible firing up zeromq via SSH\n    # to use no persistent daemons or key management\n\n    if not KEYCZAR_AVAILABLE:\n        raise errors.AnsibleError(\"python-keyczar must be installed on the control machine to use accelerated modes\")\n\n    key_path = os.path.expanduser(C.ACCELERATE_KEYS_DIR)\n    if not os.path.exists(key_path):\n        os.makedirs(key_path, mode=0700)\n        os.chmod(key_path, int(C.ACCELERATE_KEYS_DIR_PERMS, 8))\n    elif not os.path.isdir(key_path):\n        raise errors.AnsibleError('ACCELERATE_KEYS_DIR is not a directory.')\n\n    if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_DIR_PERMS, 8):\n        raise errors.AnsibleError('Incorrect permissions on the private key directory. Use `chmod 0%o %s` to correct this issue, and make sure any of the keys files contained within that directory are set to 0%o' % (int(C.ACCELERATE_KEYS_DIR_PERMS, 8), C.ACCELERATE_KEYS_DIR, int(C.ACCELERATE_KEYS_FILE_PERMS, 8)))\n\n    key_path = os.path.join(key_path, hostname)\n\n    # use new AES keys every 2 hours, which means fireball must not allow running for longer either\n    if not os.path.exists(key_path) or (time.time() - os.path.getmtime(key_path) > 60*60*2):\n        key = AesKey.Generate()\n        fd = os.open(key_path, os.O_WRONLY | os.O_CREAT, int(C.ACCELERATE_KEYS_FILE_PERMS, 8))\n        fh = os.fdopen(fd, 'w')\n        fh.write(str(key))\n        fh.close()\n        return key\n    else:\n        if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_FILE_PERMS, 8):\n            raise errors.AnsibleError('Incorrect permissions on the key file for this host. Use `chmod 0%o %s` to correct this issue.' % (int(C.ACCELERATE_KEYS_FILE_PERMS, 8), key_path))\n        fh = open(key_path)\n        key = AesKey.Read(fh.read())\n        fh.close()\n        return key\n\ndef encrypt(key, msg):\n    return key.Encrypt(msg)\n\ndef decrypt(key, msg):\n    try:\n        return key.Decrypt(msg)\n    except key_errors.InvalidSignatureError:\n        raise errors.AnsibleError(\"decryption failed\")\n\n###############################################################\n# UTILITY FUNCTIONS FOR COMMAND LINE TOOLS\n###############################################################\n\ndef err(msg):\n    ''' print an error message to stderr '''\n\n    print >> sys.stderr, msg\n\ndef exit(msg, rc=1):\n    ''' quit with an error to stdout and a failure code '''\n\n    err(msg)\n    sys.exit(rc)\n\ndef jsonify(result, format=False):\n    ''' format JSON output (uncompressed or uncompressed) '''\n\n    if result is None:\n        return \"{}\"\n    result2 = result.copy()\n    for key, value in result2.items():\n        if type(value) is str:\n            result2[key] = value.decode('utf-8', 'ignore')\n    if format:\n        return json.dumps(result2, sort_keys=True, indent=4)\n    else:\n        return json.dumps(result2, sort_keys=True)\n\ndef write_tree_file(tree, hostname, buf):\n    ''' write something into treedir/hostname '''\n\n    # TODO: might be nice to append playbook runs per host in a similar way\n    # in which case, we'd want append mode.\n    path = os.path.join(tree, hostname)\n    fd = open(path, \"w+\")\n    fd.write(buf)\n    fd.close()\n\ndef is_failed(result):\n    ''' is a given JSON result a failed result? '''\n\n    return ((result.get('rc', 0) != 0) or (result.get('failed', False) in [ True, 'True', 'true']))\n\ndef is_changed(result):\n    ''' is a given JSON result a changed result? '''\n\n    return (result.get('changed', False) in [ True, 'True', 'true'])\n\ndef check_conditional(conditional, basedir, inject, fail_on_undefined=False):\n\n    if conditional is None or conditional == '':\n        return True\n\n    if isinstance(conditional, list):\n        for x in conditional:\n            if not check_conditional(x, basedir, inject, fail_on_undefined=fail_on_undefined):\n                return False\n        return True\n\n    if not isinstance(conditional, basestring):\n        return conditional\n\n    conditional = conditional.replace(\"jinja2_compare \",\"\")\n    # allow variable names\n    if conditional in inject and '-' not in str(inject[conditional]):\n        conditional = inject[conditional]\n    conditional = template.template(basedir, conditional, inject, fail_on_undefined=fail_on_undefined)\n    original = str(conditional).replace(\"jinja2_compare \",\"\")\n    # a Jinja2 evaluation that results in something Python can eval!\n    presented = \"{%% if %s %%} True {%% else %%} False {%% endif %%}\" % conditional\n    conditional = template.template(basedir, presented, inject)\n    val = conditional.strip()\n    if val == presented:\n        # the templating failed, meaning most likely a \n        # variable was undefined. If we happened to be \n        # looking for an undefined variable, return True,\n        # otherwise fail\n        if \"is undefined\" in conditional:\n            return True\n        elif \"is defined\" in conditional:\n            return False\n        else:\n            raise errors.AnsibleError(\"error while evaluating conditional: %s\" % original)\n    elif val == \"True\":\n        return True\n    elif val == \"False\":\n        return False\n    else:\n        raise errors.AnsibleError(\"unable to evaluate conditional: %s\" % original)\n\ndef is_executable(path):\n    '''is the given path executable?'''\n    return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXGRP & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])\n\ndef unfrackpath(path):\n    ''' \n    returns a path that is free of symlinks, environment\n    variables, relative path traversals and symbols (~)\n    example:\n    '$HOME/../../var/mail' becomes '/var/spool/mail'\n    '''\n    return os.path.normpath(os.path.realpath(os.path.expandvars(os.path.expanduser(path))))\n\ndef prepare_writeable_dir(tree,mode=0777):\n    ''' make sure a directory exists and is writeable '''\n\n    # modify the mode to ensure the owner at least\n    # has read/write access to this directory\n    mode |= 0700\n\n    # make sure the tree path is always expanded\n    # and normalized and free of symlinks\n    tree = unfrackpath(tree)\n\n    if not os.path.exists(tree):\n        try:\n            os.makedirs(tree, mode)\n        except (IOError, OSError), e:\n            raise errors.AnsibleError(\"Could not make dir %s: %s\" % (tree, e))\n    if not os.access(tree, os.W_OK):\n        raise errors.AnsibleError(\"Cannot write to path %s\" % tree)\n    return tree\n\ndef path_dwim(basedir, given):\n    '''\n    make relative paths work like folks expect.\n    '''\n\n    if given.startswith(\"/\"):\n        return os.path.abspath(given)\n    elif given.startswith(\"~\"):\n        return os.path.abspath(os.path.expanduser(given))\n    else:\n        if basedir is None:\n            basedir = \".\"\n        return os.path.abspath(os.path.join(basedir, given))\n\ndef path_dwim_relative(original, dirname, source, playbook_base, check=True):\n    ''' find one file in a directory one level up in a dir named dirname relative to current '''\n    # (used by roles code)\n\n    basedir = os.path.dirname(original)\n    if os.path.islink(basedir):\n        basedir = unfrackpath(basedir)\n        template2 = os.path.join(basedir, dirname, source)\n    else:\n        template2 = os.path.join(basedir, '..', dirname, source)\n    source2 = path_dwim(basedir, template2)\n    if os.path.exists(source2):\n        return source2\n    obvious_local_path = path_dwim(playbook_base, source)\n    if os.path.exists(obvious_local_path):\n        return obvious_local_path\n    if check:\n        raise errors.AnsibleError(\"input file not found at %s or %s\" % (source2, obvious_local_path))\n    return source2 # which does not exist\n\ndef json_loads(data):\n    ''' parse a JSON string and return a data structure '''\n\n    return json.loads(data)\n\ndef _clean_data(orig_data):\n    ''' remove template tags from a string '''\n    data = orig_data\n    if isinstance(orig_data, basestring):\n        for pattern,replacement in (('{{','{#'), ('}}','#}'), ('{%','{#'), ('%}','#}')):\n            data = data.replace(pattern, replacement)\n    return data\n\ndef _clean_data_struct(orig_data):\n    '''\n    walk a complex data structure, and use _clean_data() to\n    remove any template tags that may exist\n    '''\n    if isinstance(orig_data, dict):\n        data = orig_data.copy()\n        for key in data:\n            new_key = _clean_data_struct(key)\n            new_val = _clean_data_struct(data[key])\n            if key != new_key:\n                del data[key]\n            data[new_key] = new_val\n    elif isinstance(orig_data, list):\n        data = orig_data[:]\n        for i in range(0, len(data)):\n            data[i] = _clean_data_struct(data[i])\n    elif isinstance(orig_data, basestring):\n        data = _clean_data(orig_data)\n    else:\n        data = orig_data\n    return data\n\ndef parse_json(raw_data, from_remote=False):\n    ''' this version for module return data only '''\n\n    orig_data = raw_data\n\n    # ignore stuff like tcgetattr spewage or other warnings\n    data = filter_leading_non_json_lines(raw_data)\n\n    try:\n        results = json.loads(data)\n    except:\n        # not JSON, but try \"Baby JSON\" which allows many of our modules to not\n        # require JSON and makes writing modules in bash much simpler\n        results = {}\n        try:\n            tokens = shlex.split(data)\n        except:\n            print \"failed to parse json: \"+ data\n            raise\n        for t in tokens:\n            if \"=\" not in t:\n                raise errors.AnsibleError(\"failed to parse: %s\" % orig_data)\n            (key,value) = t.split(\"=\", 1)\n            if key == 'changed' or 'failed':\n                if value.lower() in [ 'true', '1' ]:\n                    value = True\n                elif value.lower() in [ 'false', '0' ]:\n                    value = False\n            if key == 'rc':\n                value = int(value)\n            results[key] = value\n        if len(results.keys()) == 0:\n            return { \"failed\" : True, \"parsed\" : False, \"msg\" : orig_data }\n\n    if from_remote:\n        results = _clean_data_struct(results)\n\n    return results\n\ndef smush_braces(data):\n    ''' smush Jinaj2 braces so unresolved templates like {{ foo }} don't get parsed weird by key=value code '''\n    while '{{ ' in data:\n        data = data.replace('{{ ', '{{')\n    while ' }}' in data:\n        data = data.replace(' }}', '}}')\n    return data\n\ndef smush_ds(data):\n    # things like key={{ foo }} are not handled by shlex.split well, so preprocess any YAML we load\n    # so we do not have to call smush elsewhere\n    if type(data) == list:\n        return [ smush_ds(x) for x in data ]\n    elif type(data) == dict:\n        for (k,v) in data.items():\n            data[k] = smush_ds(v)\n        return data\n    elif isinstance(data, basestring):\n        return smush_braces(data)\n    else:\n        return data\n\ndef parse_yaml(data, path_hint=None):\n    ''' convert a yaml string to a data structure.  Also supports JSON, ssssssh!!!'''\n\n    stripped_data = data.lstrip()\n    loaded = None\n    if stripped_data.startswith(\"{\") or stripped_data.startswith(\"[\"):\n        # since the line starts with { or [ we can infer this is a JSON document.\n        try:\n            loaded = json.loads(data)\n        except ValueError, ve:\n            if path_hint:\n                raise errors.AnsibleError(path_hint + \": \" + str(ve))\n            else:\n                raise errors.AnsibleError(str(ve))\n    else:\n        # else this is pretty sure to be a YAML document\n        loaded = yaml.safe_load(data)\n\n    return smush_ds(loaded)\n\ndef process_common_errors(msg, probline, column):\n    replaced = probline.replace(\" \",\"\")\n\n    if \":{{\" in replaced and \"}}\" in replaced:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  YAML thought it was looking for the start of a \nhash/dictionary and was confused to see a second \"{\".  Most likely this was\nmeant to be an ansible template evaluation instead, so we have to give the \nparser a small hint that we wanted a string instead. The solution here is to \njust quote the entire value.\n\nFor instance, if the original line was:\n\n    app_path: {{ base_path }}/foo\n\nIt should be written as:\n\n    app_path: \"{{ base_path }}/foo\"\n\"\"\"\n        return msg\n\n    elif len(probline) and len(probline) > 1 and len(probline) > column and probline[column] == \":\" and probline.count(':') > 1:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  There seems to be an extra unquoted colon in the line \nand this is confusing the parser. It was only expecting to find one free \ncolon. The solution is just add some quotes around the colon, or quote the \nentire line after the first colon.\n\nFor instance, if the original line was:\n\n    copy: src=file.txt dest=/path/filename:with_colon.txt\n\nIt can be written as:\n\n    copy: src=file.txt dest='/path/filename:with_colon.txt'\n\nOr:\n    \n    copy: 'src=file.txt dest=/path/filename:with_colon.txt'\n\n\n\"\"\"\n        return msg\n    else:\n        parts = probline.split(\":\")\n        if len(parts) > 1:\n            middle = parts[1].strip()\n            match = False\n            unbalanced = False\n            if middle.startswith(\"'\") and not middle.endswith(\"'\"):\n                match = True\n            elif middle.startswith('\"') and not middle.endswith('\"'):\n                match = True\n            if len(middle) > 0 and middle[0] in [ '\"', \"'\" ] and middle[-1] in [ '\"', \"'\" ] and probline.count(\"'\") > 2 or probline.count('\"') > 2:\n                unbalanced = True\n            if match:\n                msg = msg + \"\"\"\nThis one looks easy to fix.  It seems that there is a value started \nwith a quote, and the YAML parser is expecting to see the line ended \nwith the same kind of quote.  For instance:\n\n    when: \"ok\" in result.stdout\n\nCould be written as:\n\n   when: '\"ok\" in result.stdout'\n\nor equivalently:\n\n   when: \"'ok' in result.stdout\"\n\n\"\"\"\n                return msg\n\n            if unbalanced:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with \nunbalanced quotes.  If starting a value with a quote, make sure the \nline ends with the same set of quotes.  For instance this arbitrary \nexample:\n\n    foo: \"bad\" \"wolf\"\n\nCould be written as:\n\n    foo: '\"bad\" \"wolf\"'\n\n\"\"\"\n                return msg\n\n    return msg\n\ndef process_yaml_error(exc, data, path=None, show_content=True):\n    if hasattr(exc, 'problem_mark'):\n        mark = exc.problem_mark\n        if show_content:\n            if mark.line -1 >= 0:\n                before_probline = data.split(\"\\n\")[mark.line-1]\n            else:\n                before_probline = ''\n            probline = data.split(\"\\n\")[mark.line]\n            arrow = \" \" * mark.column + \"^\"\n            msg = \"\"\"Syntax Error while loading YAML script, %s\nNote: The error may actually appear before this position: line %s, column %s\n\n%s\n%s\n%s\"\"\" % (path, mark.line + 1, mark.column + 1, before_probline, probline, arrow)\n\n            unquoted_var = None\n            if '{{' in probline and '}}' in probline:\n                if '\"{{' not in probline or \"'{{\" not in probline:\n                    unquoted_var = True\n\n            msg = process_common_errors(msg, probline, mark.column)\n            if not unquoted_var:\n                msg = process_common_errors(msg, probline, mark.column)\n            else:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with\nmissing quotes.  Always quote template expression brackets when they \nstart a value. For instance:            \n\n    with_items:\n      - {{ foo }}\n\nShould be written as:\n\n    with_items:\n      - \"{{ foo }}\"      \n\n\"\"\"\n                msg = process_common_errors(msg, probline, mark.column)\n        else:\n            # most likely displaying a file with sensitive content,\n            # so don't show any of the actual lines of yaml just the\n            # line number itself\n            msg = \"\"\"Syntax error while loading YAML script, %s\nThe error appears to have been on line %s, column %s, but may actually\nbe before there depending on the exact syntax problem.\n\"\"\" % (path, mark.line + 1, mark.column + 1)\n\n    else:\n        # No problem markers means we have to throw a generic\n        # \"stuff messed up\" type message. Sry bud.\n        if path:\n            msg = \"Could not parse YAML. Check over %s again.\" % path\n        else:\n            msg = \"Could not parse YAML.\"\n    raise errors.AnsibleYAMLValidationFailed(msg)\n\n\ndef parse_yaml_from_file(path, vault_password=None):\n    ''' convert a yaml file to a data structure '''\n\n    data = None\n    show_content = True\n\n    try:\n        data = open(path).read()\n    except IOError:\n        raise errors.AnsibleError(\"file could not read: %s\" % path)\n\n    vault = VaultLib(password=vault_password)\n    if vault.is_encrypted(data):\n        data = vault.decrypt(data)\n        show_content = False\n\n    try:\n        return parse_yaml(data, path_hint=path)\n    except yaml.YAMLError, exc:\n        process_yaml_error(exc, data, path, show_content)\n\ndef parse_kv(args):\n    ''' convert a string of key/value items to a dict '''\n    options = {}\n    if args is not None:\n        # attempting to split a unicode here does bad things\n        args = args.encode('utf-8')\n        try:\n            vargs = shlex.split(args, posix=True)\n        except ValueError, ve:\n            if 'no closing quotation' in str(ve).lower():\n                raise errors.AnsibleError(\"error parsing argument string, try quoting the entire line.\")\n            else:\n                raise\n        vargs = [x.decode('utf-8') for x in vargs]\n        for x in vargs:\n            if \"=\" in x:\n                k, v = x.split(\"=\",1)\n                options[k]=v\n    return options\n\ndef merge_hash(a, b):\n    ''' recursively merges hash b into a\n    keys from b take precedence over keys from a '''\n\n    result = copy.deepcopy(a)\n\n    # next, iterate over b keys and values\n    for k, v in b.iteritems():\n        # if there's already such key in a\n        # and that key contains dict\n        if k in result and isinstance(result[k], dict):\n            # merge those dicts recursively\n            result[k] = merge_hash(a[k], v)\n        else:\n            # otherwise, just copy a value from b to a\n            result[k] = v\n\n    return result\n\ndef md5s(data):\n    ''' Return MD5 hex digest of data. '''\n\n    digest = _md5()\n    try:\n        digest.update(data)\n    except UnicodeEncodeError:\n        digest.update(data.encode('utf-8'))\n    return digest.hexdigest()\n\ndef md5(filename):\n    ''' Return MD5 hex digest of local file, or None if file is not present. '''\n\n    if not os.path.exists(filename):\n        return None\n    digest = _md5()\n    blocksize = 64 * 1024\n    try:\n        infile = open(filename, 'rb')\n        block = infile.read(blocksize)\n        while block:\n            digest.update(block)\n            block = infile.read(blocksize)\n        infile.close()\n    except IOError, e:\n        raise errors.AnsibleError(\"error while accessing the file %s, error was: %s\" % (filename, e))\n    return digest.hexdigest()\n\ndef default(value, function):\n    ''' syntactic sugar around lazy evaluation of defaults '''\n    if value is None:\n        return function()\n    return value\n\ndef _gitinfo():\n    ''' returns a string containing git branch, commit id and commit date '''\n    result = None\n    repo_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', '.git')\n\n    if os.path.exists(repo_path):\n        # Check if the .git is a file. If it is a file, it means that we are in a submodule structure.\n        if os.path.isfile(repo_path):\n            try:\n                gitdir = yaml.safe_load(open(repo_path)).get('gitdir')\n                # There is a posibility the .git file to have an absolute path.\n                if os.path.isabs(gitdir):\n                    repo_path = gitdir\n                else:\n                    repo_path = os.path.join(repo_path.split('.git')[0], gitdir)\n            except (IOError, AttributeError):\n                return ''\n        f = open(os.path.join(repo_path, \"HEAD\"))\n        branch = f.readline().split('/')[-1].rstrip(\"\\n\")\n        f.close()\n        branch_path = os.path.join(repo_path, \"refs\", \"heads\", branch)\n        if os.path.exists(branch_path):\n            f = open(branch_path)\n            commit = f.readline()[:10]\n            f.close()\n            date = time.localtime(os.stat(branch_path).st_mtime)\n            if time.daylight == 0:\n                offset = time.timezone\n            else:\n                offset = time.altzone\n            result = \"({0} {1}) last updated {2} (GMT {3:+04d})\".format(branch, commit,\n                time.strftime(\"%Y/%m/%d %H:%M:%S\", date), offset / -36)\n    else:\n        result = ''\n    return result\n\ndef version(prog):\n    result = \"{0} {1}\".format(prog, __version__)\n    gitinfo = _gitinfo()\n    if gitinfo:\n        result = result + \" {0}\".format(gitinfo)\n    return result\n\ndef getch():\n    ''' read in a single character '''\n    fd = sys.stdin.fileno()\n    old_settings = termios.tcgetattr(fd)\n    try:\n        tty.setraw(sys.stdin.fileno())\n        ch = sys.stdin.read(1)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n    return ch\n\ndef sanitize_output(str):\n    ''' strips private info out of a string '''\n\n    private_keys = ['password', 'login_password']\n\n    filter_re = [\n        # filter out things like user:pass@foo/whatever\n        # and http://username:pass@wherever/foo\n        re.compile('^(?P<before>.*:)(?P<password>.*)(?P<after>\\@.*)$'),\n    ]\n\n    parts = str.split()\n    output = ''\n    for part in parts:\n        try:\n            (k,v) = part.split('=', 1)\n            if k in private_keys:\n                output += \" %s=VALUE_HIDDEN\" % k\n            else:\n                found = False\n                for filter in filter_re:\n                    m = filter.match(v)\n                    if m:\n                        d = m.groupdict()\n                        output += \" %s=%s\" % (k, d['before'] + \"********\" + d['after'])\n                        found = True\n                        break\n                if not found:\n                    output += \" %s\" % part\n        except:\n            output += \" %s\" % part\n\n    return output.strip()\n\n####################################################################\n# option handling code for /usr/bin/ansible and ansible-playbook\n# below this line\n\nclass SortedOptParser(optparse.OptionParser):\n    '''Optparser which sorts the options by opt before outputting --help'''\n\n    def format_help(self, formatter=None):\n        self.option_list.sort(key=operator.methodcaller('get_opt_string'))\n        return optparse.OptionParser.format_help(self, formatter=None)\n\ndef increment_debug(option, opt, value, parser):\n    global VERBOSITY\n    VERBOSITY += 1\n\ndef base_parser(constants=C, usage=\"\", output_opts=False, runas_opts=False,\n    async_opts=False, connect_opts=False, subset_opts=False, check_opts=False, diff_opts=False):\n    ''' create an options parser for any ansible script '''\n\n    parser = SortedOptParser(usage, version=version(\"%prog\"))\n    parser.add_option('-v','--verbose', default=False, action=\"callback\",\n        callback=increment_debug, help=\"verbose mode (-vvv for more, -vvvv to enable connection debugging)\")\n\n    parser.add_option('-f','--forks', dest='forks', default=constants.DEFAULT_FORKS, type='int',\n        help=\"specify number of parallel processes to use (default=%s)\" % constants.DEFAULT_FORKS)\n    parser.add_option('-i', '--inventory-file', dest='inventory',\n        help=\"specify inventory host file (default=%s)\" % constants.DEFAULT_HOST_LIST,\n        default=constants.DEFAULT_HOST_LIST)\n    parser.add_option('-k', '--ask-pass', default=False, dest='ask_pass', action='store_true',\n        help='ask for SSH password')\n    parser.add_option('--private-key', default=C.DEFAULT_PRIVATE_KEY_FILE, dest='private_key_file',\n        help='use this file to authenticate the connection')\n    parser.add_option('-K', '--ask-sudo-pass', default=False, dest='ask_sudo_pass', action='store_true',\n        help='ask for sudo password')\n    parser.add_option('--ask-su-pass', default=False, dest='ask_su_pass', action='store_true', \n        help='ask for su password')\n    parser.add_option('--ask-vault-pass', default=False, dest='ask_vault_pass', action='store_true', \n        help='ask for vault password')\n    parser.add_option('--vault-password-file', default=None, dest='vault_password_file',\n        help=\"vault password file\")\n    parser.add_option('--list-hosts', dest='listhosts', action='store_true',\n        help='outputs a list of matching hosts; does not execute anything else')\n    parser.add_option('-M', '--module-path', dest='module_path',\n        help=\"specify path(s) to module library (default=%s)\" % constants.DEFAULT_MODULE_PATH,\n        default=None)\n\n    if subset_opts:\n        parser.add_option('-l', '--limit', default=constants.DEFAULT_SUBSET, dest='subset',\n            help='further limit selected hosts to an additional pattern')\n\n    parser.add_option('-T', '--timeout', default=constants.DEFAULT_TIMEOUT, type='int',\n        dest='timeout',\n        help=\"override the SSH timeout in seconds (default=%s)\" % constants.DEFAULT_TIMEOUT)\n\n    if output_opts:\n        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',\n            help='condense output')\n        parser.add_option('-t', '--tree', dest='tree', default=None,\n            help='log output to this directory')\n\n    if runas_opts:\n        parser.add_option(\"-s\", \"--sudo\", default=constants.DEFAULT_SUDO, action=\"store_true\",\n            dest='sudo', help=\"run operations with sudo (nopasswd)\")\n        parser.add_option('-U', '--sudo-user', dest='sudo_user', default=None,\n                          help='desired sudo user (default=root)')  # Can't default to root because we need to detect when this option was given\n        parser.add_option('-u', '--user', default=constants.DEFAULT_REMOTE_USER,\n            dest='remote_user', help='connect as this user (default=%s)' % constants.DEFAULT_REMOTE_USER)\n\n        parser.add_option('-S', '--su', default=constants.DEFAULT_SU,\n                          action='store_true', help='run operations with su')\n        parser.add_option('-R', '--su-user', help='run operations with su as this '\n                                                  'user (default=%s)' % constants.DEFAULT_SU_USER)\n\n    if connect_opts:\n        parser.add_option('-c', '--connection', dest='connection',\n                          default=C.DEFAULT_TRANSPORT,\n                          help=\"connection type to use (default=%s)\" % C.DEFAULT_TRANSPORT)\n\n    if async_opts:\n        parser.add_option('-P', '--poll', default=constants.DEFAULT_POLL_INTERVAL, type='int',\n            dest='poll_interval',\n            help=\"set the poll interval if using -B (default=%s)\" % constants.DEFAULT_POLL_INTERVAL)\n        parser.add_option('-B', '--background', dest='seconds', type='int', default=0,\n            help='run asynchronously, failing after X seconds (default=N/A)')\n\n    if check_opts:\n        parser.add_option(\"-C\", \"--check\", default=False, dest='check', action='store_true',\n            help=\"don't make any changes; instead, try to predict some of the changes that may occur\"\n        )\n\n    if diff_opts:\n        parser.add_option(\"-D\", \"--diff\", default=False, dest='diff', action='store_true',\n            help=\"when changing (small) files and templates, show the differences in those files; works great with --check\"\n        )\n\n\n    return parser\n\ndef ask_vault_passwords(ask_vault_pass=False, ask_new_vault_pass=False, confirm_vault=False, confirm_new=False):\n\n    vault_pass = None\n    new_vault_pass = None\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    if ask_vault_pass and confirm_vault:\n        vault_pass2 = getpass.getpass(prompt=\"Confirm Vault password: \")\n        if vault_pass != vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    if ask_new_vault_pass:\n        new_vault_pass = getpass.getpass(prompt=\"New Vault password: \")\n\n    if ask_new_vault_pass and confirm_new:\n        new_vault_pass2 = getpass.getpass(prompt=\"Confirm New Vault password: \")\n        if new_vault_pass != new_vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    # enforce no newline chars at the end of passwords\n    if vault_pass:\n        vault_pass = vault_pass.strip()\n    if new_vault_pass:\n        new_vault_pass = new_vault_pass.strip()\n\n    return vault_pass, new_vault_pass\n\ndef ask_passwords(ask_pass=False, ask_sudo_pass=False, ask_su_pass=False, ask_vault_pass=False):\n    sshpass = None\n    sudopass = None\n    su_pass = None\n    vault_pass = None\n    sudo_prompt = \"sudo password: \"\n    su_prompt = \"su password: \"\n\n    if ask_pass:\n        sshpass = getpass.getpass(prompt=\"SSH password: \")\n        sudo_prompt = \"sudo password [defaults to SSH password]: \"\n\n    if ask_sudo_pass:\n        sudopass = getpass.getpass(prompt=sudo_prompt)\n        if ask_pass and sudopass == '':\n            sudopass = sshpass\n\n    if ask_su_pass:\n        su_pass = getpass.getpass(prompt=su_prompt)\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    return (sshpass, sudopass, su_pass, vault_pass)\n\ndef do_encrypt(result, encrypt, salt_size=None, salt=None):\n    if PASSLIB_AVAILABLE:\n        try:\n            crypt = getattr(passlib.hash, encrypt)\n        except:\n            raise errors.AnsibleError(\"passlib does not support '%s' algorithm\" % encrypt)\n\n        if salt_size:\n            result = crypt.encrypt(result, salt_size=salt_size)\n        elif salt:\n            result = crypt.encrypt(result, salt=salt)\n        else:\n            result = crypt.encrypt(result)\n    else:\n        raise errors.AnsibleError(\"passlib must be installed to encrypt vars_prompt values\")\n\n    return result\n\ndef last_non_blank_line(buf):\n\n    all_lines = buf.splitlines()\n    all_lines.reverse()\n    for line in all_lines:\n        if (len(line) > 0):\n            return line\n    # shouldn't occur unless there's no output\n    return \"\"\n\ndef filter_leading_non_json_lines(buf):\n    '''\n    used to avoid random output from SSH at the top of JSON output, like messages from\n    tcagetattr, or where dropbear spews MOTD on every single command (which is nuts).\n\n    need to filter anything which starts not with '{', '[', ', '=' or is an empty line.\n    filter only leading lines since multiline JSON is valid.\n    '''\n\n    kv_regex = re.compile(r'.*\\w+=\\w+.*')\n    filtered_lines = StringIO.StringIO()\n    stop_filtering = False\n    for line in buf.splitlines():\n        if stop_filtering or kv_regex.match(line) or line.startswith('{') or line.startswith('['):\n            stop_filtering = True\n            filtered_lines.write(line + '\\n')\n    return filtered_lines.getvalue()\n\ndef boolean(value):\n    val = str(value)\n    if val.lower() in [ \"true\", \"t\", \"y\", \"1\", \"yes\" ]:\n        return True\n    else:\n        return False\n\ndef make_sudo_cmd(sudo_user, executable, cmd):\n    \"\"\"\n    helper function for connection plugins to create sudo commands\n    \"\"\"\n    # Rather than detect if sudo wants a password this time, -k makes\n    # sudo always ask for a password if one is required.\n    # Passing a quoted compound command to sudo (or sudo -s)\n    # directly doesn't work, so we shellquote it with pipes.quote()\n    # and pass the quoted string to the user's shell.  We loop reading\n    # output until we see the randomly-generated sudo prompt set with\n    # the -p option.\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[sudo via ansible, key=%s] password: ' % randbits\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s -k && %s %s -S -p \"%s\" -u %s %s -c %s' % (\n        C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_FLAGS,\n        prompt, sudo_user, executable or '$SHELL', pipes.quote('echo %s; %s' % (success_key, cmd)))\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n\ndef make_su_cmd(su_user, executable, cmd):\n    \"\"\"\n    Helper function for connection plugins to create direct su commands\n    \"\"\"\n    # TODO: work on this function\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = 'assword: '\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s %s %s %s -c %s' % (\n        C.DEFAULT_SU_EXE, C.DEFAULT_SU_FLAGS, su_user, executable or '$SHELL',\n        pipes.quote('echo %s; %s' % (success_key, cmd))\n    )\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n_TO_UNICODE_TYPES = (unicode, type(None))\n\ndef to_unicode(value):\n    if isinstance(value, _TO_UNICODE_TYPES):\n        return value\n    return value.decode(\"utf-8\")\n\ndef get_diff(diff):\n    # called by --diff usage in playbook and runner via callbacks\n    # include names in diffs 'before' and 'after' and do diff -U 10\n\n    try:\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            ret = []\n            if 'dst_binary' in diff:\n                ret.append(\"diff skipped: destination file appears to be binary\\n\")\n            if 'src_binary' in diff:\n                ret.append(\"diff skipped: source file appears to be binary\\n\")\n            if 'dst_larger' in diff:\n                ret.append(\"diff skipped: destination file size is greater than %d\\n\" % diff['dst_larger'])\n            if 'src_larger' in diff:\n                ret.append(\"diff skipped: source file size is greater than %d\\n\" % diff['src_larger'])\n            if 'before' in diff and 'after' in diff:\n                if 'before_header' in diff:\n                    before_header = \"before: %s\" % diff['before_header']\n                else:\n                    before_header = 'before'\n                if 'after_header' in diff:\n                    after_header = \"after: %s\" % diff['after_header']\n                else:\n                    after_header = 'after'\n                differ = difflib.unified_diff(to_unicode(diff['before']).splitlines(True), to_unicode(diff['after']).splitlines(True), before_header, after_header, '', '', 10)\n                for line in list(differ):\n                    ret.append(line)\n            return u\"\".join(ret)\n    except UnicodeDecodeError:\n        return \">> the files are different, but the diff library cannot compare unicode strings\"\n\ndef is_list_of_strings(items):\n    for x in items:\n        if not isinstance(x, basestring):\n            return False\n    return True\n\ndef list_union(a, b):\n    result = []\n    for x in a:\n        if x not in result:\n            result.append(x)\n    for x in b:\n        if x not in result:\n            result.append(x)\n    return result\n\ndef list_intersection(a, b):\n    result = []\n    for x in a:\n        if x in b and x not in result:\n            result.append(x)\n    return result\n\ndef safe_eval(expr, locals={}, include_exceptions=False):\n    '''\n    this is intended for allowing things like:\n    with_items: a_list_variable\n    where Jinja2 would return a string\n    but we do not want to allow it to call functions (outside of Jinja2, where\n    the env is constrained)\n\n    Based on:\n    http://stackoverflow.com/questions/12523516/using-ast-and-whitelists-to-make-pythons-eval-safe\n    '''\n\n    # this is the whitelist of AST nodes we are going to \n    # allow in the evaluation. Any node type other than \n    # those listed here will raise an exception in our custom\n    # visitor class defined below.\n    SAFE_NODES = set(\n        (\n            ast.Add,\n            ast.BinOp,\n            ast.Call,\n            ast.Compare,\n            ast.Dict,\n            ast.Div,\n            ast.Expression,\n            ast.List,\n            ast.Load,\n            ast.Mult,\n            ast.Num,\n            ast.Name,\n            ast.Str,\n            ast.Sub,\n            ast.Tuple,\n            ast.UnaryOp,\n        )\n    )\n\n    # AST node types were expanded after 2.6\n    if not sys.version.startswith('2.6'):\n        SAFE_NODES.union(\n            set(\n                (ast.Set,)\n            )\n        )\n\n    filter_list = []\n    for filter in filter_loader.all():\n        filter_list.extend(filter.filters().keys())\n\n    CALL_WHITELIST = C.DEFAULT_CALLABLE_WHITELIST + filter_list\n\n    class CleansingNodeVisitor(ast.NodeVisitor):\n        def generic_visit(self, node, inside_call=False):\n            if type(node) not in SAFE_NODES:\n                raise Exception(\"invalid expression (%s)\" % expr)\n            elif isinstance(node, ast.Call):\n                inside_call = True\n            elif isinstance(node, ast.Name) and inside_call:\n                if hasattr(builtin, node.id) and node.id not in CALL_WHITELIST:\n                    raise Exception(\"invalid function: %s\" % node.id)\n            # iterate over all child nodes\n            for child_node in ast.iter_child_nodes(node):\n                self.generic_visit(child_node, inside_call)\n\n    if not isinstance(expr, basestring):\n        # already templated to a datastructure, perhaps?\n        if include_exceptions:\n            return (expr, None)\n        return expr\n\n    cnv = CleansingNodeVisitor()\n    try:\n        parsed_tree = ast.parse(expr, mode='eval')\n        cnv.visit(parsed_tree)\n        compiled = compile(parsed_tree, expr, 'eval')\n        result = eval(compiled, {}, locals)\n\n        if include_exceptions:\n            return (result, None)\n        else:\n            return result\n    except SyntaxError, e:\n        # special handling for syntax errors, we just return\n        # the expression string back as-is\n        if include_exceptions:\n            return (expr, None)\n        return expr\n    except Exception, e:\n        if include_exceptions:\n            return (expr, e)\n        return expr\n\n\ndef listify_lookup_plugin_terms(terms, basedir, inject):\n\n    if isinstance(terms, basestring):\n        # someone did:\n        #    with_items: alist\n        # OR\n        #    with_items: {{ alist }}\n\n        stripped = terms.strip()\n        if not (stripped.startswith('{') or stripped.startswith('[')) and not stripped.startswith(\"/\") and not stripped.startswith('set(['):\n            # if not already a list, get ready to evaluate with Jinja2\n            # not sure why the \"/\" is in above code :)\n            try:\n                new_terms = template.template(basedir, \"{{ %s }}\" % terms, inject)\n                if isinstance(new_terms, basestring) and \"{{\" in new_terms:\n                    pass\n                else:\n                    terms = new_terms\n            except:\n                pass\n\n        if '{' in terms or '[' in terms:\n            # Jinja2 already evaluated a variable to a list.\n            # Jinja2-ified list needs to be converted back to a real type\n            # TODO: something a bit less heavy than eval\n            return safe_eval(terms)\n\n        if isinstance(terms, basestring):\n            terms = [ terms ]\n\n    return terms\n\ndef combine_vars(a, b):\n\n    if C.DEFAULT_HASH_BEHAVIOUR == \"merge\":\n        return merge_hash(a, b)\n    else:\n        return dict(a.items() + b.items())\n\ndef random_password(length=20, chars=C.DEFAULT_PASSWORD_CHARS):\n    '''Return a random password string of length containing only chars.'''\n\n    password = []\n    while len(password) < length:\n        new_char = os.urandom(1)\n        if new_char in chars:\n            password.append(new_char)\n\n    return ''.join(password)\n\ndef before_comment(msg):\n    ''' what's the part of a string before a comment? '''\n    msg = msg.replace(\"\\#\",\"**NOT_A_COMMENT**\")\n    msg = msg.split(\"#\")[0]\n    msg = msg.replace(\"**NOT_A_COMMENT**\",\"#\")\n    return msg\n\n\n\n", "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport datetime\nimport traceback\nimport re\nimport shlex\nimport os\n\nDOCUMENTATION = '''\n---\nmodule: command\nversion_added: historical\nshort_description: Executes a command on a remote node\ndescription:\n     - The M(command) module takes the command name followed by a list of space-delimited arguments.\n     - The given command will be executed on all selected nodes. It will not be\n       processed through the shell, so variables like C($HOME) and operations\n       like C(\"<\"), C(\">\"), C(\"|\"), and C(\"&\") will not work (use the M(shell)\n       module if you need these features).\noptions:\n  free_form:\n    description:\n      - the command module takes a free form command to run.  There is no parameter actually named 'free form'.\n        See the examples!\n    required: true\n    default: null\n    aliases: []\n  creates:\n    description:\n      - a filename, when it already exists, this step will B(not) be run.\n    required: no\n    default: null\n  removes:\n    description:\n      - a filename, when it does not exist, this step will B(not) be run.\n    version_added: \"0.8\"\n    required: no\n    default: null\n  chdir:\n    description:\n      - cd into this directory before running the command\n    version_added: \"0.6\"\n    required: false\n    default: null\n  executable:\n    description:\n      - change the shell used to execute the command. Should be an absolute path to the executable.\n    required: false\n    default: null\n    version_added: \"0.9\"\nnotes:\n    -  If you want to run a command through the shell (say you are using C(<),\n       C(>), C(|), etc), you actually want the M(shell) module instead. The\n       M(command) module is much more secure as it's not affected by the user's\n       environment.\n    -  \" C(creates), C(removes), and C(chdir) can be specified after the command. For instance, if you only want to run a command if a certain file does not exist, use this.\"\nauthor: Michael DeHaan\n'''\n\nEXAMPLES = '''\n# Example from Ansible Playbooks\n- command: /sbin/shutdown -t now\n\n# Run the command if the specified file does not exist\n- command: /usr/bin/make_database.sh arg1 arg2 creates=/path/to/database\n'''\n\ndef main():\n\n    # the command module is the one ansible module that does not take key=value args\n    # hence don't copy this one if you are looking to build others!\n    module = CommandModule(argument_spec=dict())\n\n    shell = module.params['shell']\n    chdir = module.params['chdir']\n    executable = module.params['executable']\n    args  = module.params['args']\n    creates  = module.params['creates']\n    removes  = module.params['removes']\n\n    if args.strip() == '':\n        module.fail_json(rc=256, msg=\"no command given\")\n\n    if chdir:\n        os.chdir(chdir)\n\n    if creates:\n        # do not run the command if the line contains creates=filename\n        # and the filename already exists.  This allows idempotence\n        # of command executions.\n        v = os.path.expanduser(creates)\n        if os.path.exists(v):\n            module.exit_json(\n                cmd=args,\n                stdout=\"skipped, since %s exists\" % v,\n                skipped=True,\n                changed=False,\n                stderr=False,\n                rc=0\n            )\n\n    if removes:\n    # do not run the command if the line contains removes=filename\n    # and the filename does not exist.  This allows idempotence\n    # of command executions.\n        v = os.path.expanduser(removes)\n        if not os.path.exists(v):\n            module.exit_json(\n                cmd=args,\n                stdout=\"skipped, since %s does not exist\" % v,\n                skipped=True,\n                changed=False,\n                stderr=False,\n                rc=0\n            )\n\n    if not shell:\n        args = shlex.split(args)\n    startd = datetime.datetime.now()\n\n    rc, out, err = module.run_command(args, executable=executable, use_unsafe_shell=shell)\n\n    endd = datetime.datetime.now()\n    delta = endd - startd\n\n    if out is None:\n        out = ''\n    if err is None:\n        err = ''\n\n    module.exit_json(\n        cmd     = args,\n        stdout  = out.rstrip(\"\\r\\n\"),\n        stderr  = err.rstrip(\"\\r\\n\"),\n        rc      = rc,\n        start   = str(startd),\n        end     = str(endd),\n        delta   = str(delta),\n        changed = True\n    )\n\n# import module snippets\nfrom ansible.module_utils.basic import *\n\n# only the command module should ever need to do this\n# everything else should be simple key=value\n\nclass CommandModule(AnsibleModule):\n\n    def _handle_aliases(self):\n        return {}\n\n    def _check_invalid_arguments(self):\n        pass\n\n    def _load_params(self):\n        ''' read the input and return a dictionary and the arguments string '''\n        args = MODULE_ARGS\n        params = {}\n        params['chdir'] = None\n        params['creates'] = None\n        params['removes'] = None\n        params['shell'] = False\n        params['executable'] = None\n        if \"#USE_SHELL\" in args:\n            args = args.replace(\"#USE_SHELL\", \"\")\n            params['shell'] = True\n\n        r = re.compile(r'(^|\\s)(creates|removes|chdir|executable|NO_LOG)=(?P<quote>[\\'\"])?(.*?)(?(quote)(?<!\\\\)(?P=quote))((?<!\\\\)(?=\\s)|$)')\n        for m in r.finditer(args):\n            v = m.group(4).replace(\"\\\\\", \"\")\n            if m.group(2) == \"creates\":\n                params['creates'] = v\n            elif m.group(2) == \"removes\":\n                params['removes'] = v\n            elif m.group(2) == \"chdir\":\n                v = os.path.expanduser(v)\n                v = os.path.abspath(v)\n                if not (os.path.exists(v) and os.path.isdir(v)):\n                    self.fail_json(rc=258, msg=\"cannot change to directory '%s': path does not exist\" % v)\n                params['chdir'] = v\n            elif m.group(2) == \"executable\":\n                v = os.path.expanduser(v)\n                v = os.path.abspath(v)\n                if not (os.path.exists(v)):\n                    self.fail_json(rc=258, msg=\"cannot use executable '%s': file does not exist\" % v)\n                params['executable'] = v\n            elif m.group(2) == \"NO_LOG\":\n                params['NO_LOG'] = self.boolean(v)\n        args = r.sub(\"\", args)\n        params['args'] = args\n        return (params, params['args'])\n\nmain()\n", "# test code for iterating with lookup plugins\n# (c) 2014, James Tanner <tanner.jc@gmail.com>\n\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# WITH_ITEMS\n\n- name: test with_items\n  set_fact: \"{{ item + '=moo' }}\"\n  with_items:\n    - 'foo'\n    - 'bar'\n\n- debug: var=foo\n- debug: var=bar\n\n- name: verify with_items results\n  assert:\n    that:\n        - \"foo == 'moo'\"\n        - \"bar == 'moo'\"\n\n# WITH_NESTED\n\n- name: test with_nested\n  set_fact: \"{{ item.0 + item.1 + '=x' }}\"\n  with_nested:\n    - [ 'a', 'b' ]\n    - [ 'c', 'd' ]        \n\n- debug: var=ac\n- debug: var=ad\n- debug: var=bc\n- debug: var=bd\n\n- name: verify with_nested results\n  assert:\n    that:\n        - \"ac == 'x'\"\n        - \"ad == 'x'\"\n        - \"bc == 'x'\"\n        - \"bd == 'x'\"\n\n# WITH_SEQUENCE\n\n- name: test with_sequence\n  set_fact: \"{{ 'x' + item + '=' + item }}\"\n  with_sequence: start=0 end=3\n\n- name: verify with_sequence\n  assert:\n    that:\n        - \"x0 == '0'\"\n        - \"x1 == '1'\"\n        - \"x2 == '2'\"\n        - \"x3 == '3'\"\n\n# WITH_RANDOM_CHOICE\n\n- name: test with_random_choice\n  set_fact: \"{{ 'random=' + item }}\"\n  with_random_choice:\n    - \"foo\"\n    - \"bar\" \n\n- name: verify with_random_choice\n  assert:\n    that:\n        - \"random in ['foo', 'bar']\"\n\n# WITH_SUBELEMENTS\n\n- name: test with_subelements\n  set_fact: \"{{ '_'+ item.0.id + item.1 + '=' + item.1 }}\"\n  with_subelements:\n    - element_data\n    - the_list\n\n- name: verify with_subelements results\n  assert:\n    that:\n        - \"_xf == 'f'\"\n        - \"_xd == 'd'\"\n        - \"_ye == 'e'\"\n        - \"_yf == 'f'\"\n\n# WITH_TOGETHER        \n\n- name: test with_together\n  #shell: echo {{ item }}\n  set_fact: \"{{ item.0 + '=' + item.1 }}\"\n  with_together:\n    - [ 'a', 'b', 'c', 'd' ]\n    - [ '1', '2', '3', '4' ]\n\n- name: verify with_together results\n  assert:\n    that:\n        - \"a == '1'\"\n        - \"b == '2'\"\n        - \"c == '3'\"\n        - \"d == '4'\"\n\n# WITH_FIRST_FOUND\n\n- name: create file for test\n  shell: echo \"foo\" > {{ output_dir }}/foo1\n\n- name: create file for test\n  shell: echo \"bar\" > {{ output_dir }}/bar1\n\n- name: test with_first_found\n  #shell: echo {{ item }}\n  set_fact: \"{{ 'first_found=' + item }}\"\n  with_first_found:\n    - \"{{ output_dir + '/does_not_exist' }}\"\n    - \"{{ output_dir + '/foo1' }}\"\n    - \"{{ output_dir + '/bar1' }}\"\n\n- name: set expected\n  set_fact: first_expected=\"{{ output_dir | expanduser + '/foo1' }}\"\n\n- name: set unexpected\n  set_fact: first_unexpected=\"{{ output_dir | expanduser + '/bar1' }}\"\n\n- name: verify with_first_found results\n  assert:\n    that:\n        - \"first_found == first_expected\"  \n        - \"first_found != first_unexpected\"\n\n# WITH_LINES\n\n- name: test with_lines\n  #shell: echo \"{{ item }}\"\n  set_fact: \"{{ item + '=set' }}\" \n  with_lines: for i in $(seq 1 5); do echo \"l$i\" ; done;\n\n- name: verify with_lines results\n  assert:\n    that:\n        - \"l1 == 'set'\"\n        - \"l2 == 'set'\"\n        - \"l3 == 'set'\"\n        - \"l4 == 'set'\"\n        - \"l5 == 'set'\"\n\n# WITH_INDEX\n- name: create unindexed list\n  shell: for i in $(seq 1 5); do echo \"x\" ; done;\n  register: list_data\n\n- name: create indexed list\n  set_fact: \"{{ item[1] + item[0]|string + '=set' }}\"\n  with_indexed_items: list_data.stdout_lines  \n\n- name: verify with_indexed_items result\n  assert:\n    that:\n        - \"x0 == 'set'\"\n        - \"x1 == 'set'\"\n        - \"x2 == 'set'\"\n        - \"x3 == 'set'\"\n        - \"x4 == 'set'\"\n\n# WITH_FLATTENED\n\n- name: test with_flattened\n  #shell: echo {{ item + \"test\" }}\n  set_fact: \"{{ item + '=flattened' }}\"\n  with_flattened:\n    - [ 'a__' ]\n    - [ 'b__', ['c__', 'd__'] ]        \n\n- name: verify with_flattened results\n  assert:\n    that:\n        - \"a__ == 'flattened'\"\n        - \"b__ == 'flattened'\"\n        - \"c__ == 'flattened'\"\n        - \"d__ == 'flattened'\"\n\n\n"], "fixing_code": ["# This code is part of Ansible, but is an independent component.\n# This particular file snippet, and this file snippet only, is BSD licensed.\n# Modules you write using this snippet, which is embedded dynamically by Ansible\n# still belong to the author of the module, and may assign their own license\n# to the complete work.\n# \n# Copyright (c), Michael DeHaan <michael.dehaan@gmail.com>, 2012-2013\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without modification, \n# are permitted provided that the following conditions are met:\n#\n#    * Redistributions of source code must retain the above copyright \n#      notice, this list of conditions and the following disclaimer.\n#    * Redistributions in binary form must reproduce the above copyright notice, \n#      this list of conditions and the following disclaimer in the documentation \n#      and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND \n# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED \n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. \n# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, \n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \n# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT \n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE \n# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n\n# == BEGIN DYNAMICALLY INSERTED CODE ==\n\nMODULE_ARGS = \"<<INCLUDE_ANSIBLE_MODULE_ARGS>>\"\nMODULE_COMPLEX_ARGS = \"<<INCLUDE_ANSIBLE_MODULE_COMPLEX_ARGS>>\"\n\nBOOLEANS_TRUE = ['yes', 'on', '1', 'true', 1]\nBOOLEANS_FALSE = ['no', 'off', '0', 'false', 0]\nBOOLEANS = BOOLEANS_TRUE + BOOLEANS_FALSE\n\n# ansible modules can be written in any language.  To simplify\n# development of Python modules, the functions available here\n# can be inserted in any module source automatically by including\n# #<<INCLUDE_ANSIBLE_MODULE_COMMON>> on a blank line by itself inside\n# of an ansible module. The source of this common code lives\n# in lib/ansible/module_common.py\n\nimport locale\nimport os\nimport re\nimport pipes\nimport shlex\nimport subprocess\nimport sys\nimport syslog\nimport types\nimport time\nimport shutil\nimport stat\nimport tempfile\nimport traceback\nimport grp\nimport pwd\nimport platform\nimport errno\nimport tempfile\n\ntry:\n    import json\nexcept ImportError:\n    try:\n        import simplejson as json\n    except ImportError:\n        sys.stderr.write('Error: ansible requires a json module, none found!')\n        sys.exit(1)\n    except SyntaxError:\n        sys.stderr.write('SyntaxError: probably due to json and python being for different versions')\n        sys.exit(1)\n\nHAVE_SELINUX=False\ntry:\n    import selinux\n    HAVE_SELINUX=True\nexcept ImportError:\n    pass\n\nHAVE_HASHLIB=False\ntry:\n    from hashlib import md5 as _md5\n    HAVE_HASHLIB=True\nexcept ImportError:\n    from md5 import md5 as _md5\n\ntry:\n    from hashlib import sha256 as _sha256\nexcept ImportError:\n    pass\n\ntry:\n    from systemd import journal\n    has_journal = True\nexcept ImportError:\n    import syslog\n    has_journal = False\n\nFILE_COMMON_ARGUMENTS=dict(\n    src = dict(),\n    mode = dict(),\n    owner = dict(),\n    group = dict(),\n    seuser = dict(),\n    serole = dict(),\n    selevel = dict(),\n    setype = dict(),\n    # not taken by the file module, but other modules call file so it must ignore them.\n    content = dict(),\n    backup = dict(),\n    force = dict(),\n    remote_src = dict(), # used by assemble\n    delimiter = dict(), # used by assemble\n    directory_mode = dict(), # used by copy\n)\n\n\ndef get_platform():\n    ''' what's the platform?  example: Linux is a platform. '''\n    return platform.system()\n\ndef get_distribution():\n    ''' return the distribution name '''\n    if platform.system() == 'Linux':\n        try:\n            distribution = platform.linux_distribution()[0].capitalize()\n            if not distribution and os.path.isfile('/etc/system-release'):\n                distribution = platform.linux_distribution(supported_dists=['system'])[0].capitalize()\n                if 'Amazon' in distribution:\n                    distribution = 'Amazon'\n                else:\n                    distribution = 'OtherLinux'\n        except:\n            # FIXME: MethodMissing, I assume?\n            distribution = platform.dist()[0].capitalize()\n    else:\n        distribution = None\n    return distribution\n\ndef load_platform_subclass(cls, *args, **kwargs):\n    '''\n    used by modules like User to have different implementations based on detected platform.  See User\n    module for an example.\n    '''\n\n    this_platform = get_platform()\n    distribution = get_distribution()\n    subclass = None\n\n    # get the most specific superclass for this platform\n    if distribution is not None:\n        for sc in cls.__subclasses__():\n            if sc.distribution is not None and sc.distribution == distribution and sc.platform == this_platform:\n                subclass = sc\n    if subclass is None:\n        for sc in cls.__subclasses__():\n            if sc.platform == this_platform and sc.distribution is None:\n                subclass = sc\n    if subclass is None:\n        subclass = cls\n\n    return super(cls, subclass).__new__(subclass)\n\n\nclass AnsibleModule(object):\n\n    def __init__(self, argument_spec, bypass_checks=False, no_log=False,\n        check_invalid_arguments=True, mutually_exclusive=None, required_together=None,\n        required_one_of=None, add_file_common_args=False, supports_check_mode=False):\n\n        '''\n        common code for quickly building an ansible module in Python\n        (although you can write modules in anything that can return JSON)\n        see library/* for examples\n        '''\n\n        self.argument_spec = argument_spec\n        self.supports_check_mode = supports_check_mode\n        self.check_mode = False\n        self.no_log = no_log\n        self.cleanup_files = []\n        \n        self.aliases = {}\n        \n        if add_file_common_args:\n            for k, v in FILE_COMMON_ARGUMENTS.iteritems():\n                if k not in self.argument_spec:\n                    self.argument_spec[k] = v\n\n        # check the locale as set by the current environment, and\n        # reset to LANG=C if it's an invalid/unavailable locale\n        self._check_locale()\n\n        (self.params, self.args) = self._load_params()\n\n        self._legal_inputs = ['CHECKMODE', 'NO_LOG']\n        \n        self.aliases = self._handle_aliases()\n\n        if check_invalid_arguments:\n            self._check_invalid_arguments()\n        self._check_for_check_mode()\n        self._check_for_no_log()\n\n        # check exclusive early \n        if not bypass_checks:\n            self._check_mutually_exclusive(mutually_exclusive)\n\n        self._set_defaults(pre=True)\n\n        if not bypass_checks:\n            self._check_required_arguments()\n            self._check_argument_values()\n            self._check_argument_types()\n            self._check_required_together(required_together)\n            self._check_required_one_of(required_one_of)\n\n        self._set_defaults(pre=False)\n        if not self.no_log:\n            self._log_invocation()\n\n        # finally, make sure we're in a sane working dir\n        self._set_cwd()\n\n    def load_file_common_arguments(self, params):\n        '''\n        many modules deal with files, this encapsulates common\n        options that the file module accepts such that it is directly\n        available to all modules and they can share code.\n        '''\n\n        path = params.get('path', params.get('dest', None))\n        if path is None:\n            return {}\n        else:\n            path = os.path.expanduser(path)\n\n        mode   = params.get('mode', None)\n        owner  = params.get('owner', None)\n        group  = params.get('group', None)\n\n        # selinux related options\n        seuser    = params.get('seuser', None)\n        serole    = params.get('serole', None)\n        setype    = params.get('setype', None)\n        selevel   = params.get('selevel', None)\n        secontext = [seuser, serole, setype]\n\n        if self.selinux_mls_enabled():\n            secontext.append(selevel)\n\n        default_secontext = self.selinux_default_context(path)\n        for i in range(len(default_secontext)):\n            if i is not None and secontext[i] == '_default':\n                secontext[i] = default_secontext[i]\n\n        return dict(\n            path=path, mode=mode, owner=owner, group=group,\n            seuser=seuser, serole=serole, setype=setype,\n            selevel=selevel, secontext=secontext,\n        )\n\n\n    # Detect whether using selinux that is MLS-aware.\n    # While this means you can set the level/range with\n    # selinux.lsetfilecon(), it may or may not mean that you\n    # will get the selevel as part of the context returned\n    # by selinux.lgetfilecon().\n\n    def selinux_mls_enabled(self):\n        if not HAVE_SELINUX:\n            return False\n        if selinux.is_selinux_mls_enabled() == 1:\n            return True\n        else:\n            return False\n\n    def selinux_enabled(self):\n        if not HAVE_SELINUX:\n            seenabled = self.get_bin_path('selinuxenabled')\n            if seenabled is not None:\n                (rc,out,err) = self.run_command(seenabled)\n                if rc == 0:\n                    self.fail_json(msg=\"Aborting, target uses selinux but python bindings (libselinux-python) aren't installed!\")\n            return False\n        if selinux.is_selinux_enabled() == 1:\n            return True\n        else:\n            return False\n\n    # Determine whether we need a placeholder for selevel/mls\n    def selinux_initial_context(self):\n        context = [None, None, None]\n        if self.selinux_mls_enabled():\n            context.append(None)\n        return context\n\n    def _to_filesystem_str(self, path):\n        '''Returns filesystem path as a str, if it wasn't already.\n\n        Used in selinux interactions because it cannot accept unicode\n        instances, and specifying complex args in a playbook leaves\n        you with unicode instances.  This method currently assumes\n        that your filesystem encoding is UTF-8.\n\n        '''\n        if isinstance(path, unicode):\n            path = path.encode(\"utf-8\")\n        return path\n\n    # If selinux fails to find a default, return an array of None\n    def selinux_default_context(self, path, mode=0):\n        context = self.selinux_initial_context()\n        if not HAVE_SELINUX or not self.selinux_enabled():\n            return context\n        try:\n            ret = selinux.matchpathcon(self._to_filesystem_str(path), mode)\n        except OSError:\n            return context\n        if ret[0] == -1:\n            return context\n        # Limit split to 4 because the selevel, the last in the list,\n        # may contain ':' characters\n        context = ret[1].split(':', 3)\n        return context\n\n    def selinux_context(self, path):\n        context = self.selinux_initial_context()\n        if not HAVE_SELINUX or not self.selinux_enabled():\n            return context\n        try:\n            ret = selinux.lgetfilecon_raw(self._to_filesystem_str(path))\n        except OSError, e:\n            if e.errno == errno.ENOENT:\n                self.fail_json(path=path, msg='path %s does not exist' % path)\n            else:\n                self.fail_json(path=path, msg='failed to retrieve selinux context')\n        if ret[0] == -1:\n            return context\n        # Limit split to 4 because the selevel, the last in the list,\n        # may contain ':' characters\n        context = ret[1].split(':', 3)\n        return context\n\n    def user_and_group(self, filename):\n        filename = os.path.expanduser(filename)\n        st = os.lstat(filename)\n        uid = st.st_uid\n        gid = st.st_gid\n        return (uid, gid)\n\n    def find_mount_point(self, path):\n        path = os.path.abspath(os.path.expanduser(os.path.expandvars(path)))\n        while not os.path.ismount(path):\n            path = os.path.dirname(path)\n        return path\n\n    def is_nfs_path(self, path):\n        \"\"\"\n        Returns a tuple containing (True, selinux_context) if the given path\n        is on a NFS mount point, otherwise the return will be (False, None).\n        \"\"\"\n        try:\n            f = open('/proc/mounts', 'r')\n            mount_data = f.readlines()\n            f.close()\n        except:\n            return (False, None)\n        path_mount_point = self.find_mount_point(path)\n        for line in mount_data:\n            (device, mount_point, fstype, options, rest) = line.split(' ', 4)\n            if path_mount_point == mount_point and 'nfs' in fstype:\n                nfs_context = self.selinux_context(path_mount_point)\n                return (True, nfs_context)\n        return (False, None)\n\n    def set_default_selinux_context(self, path, changed):\n        if not HAVE_SELINUX or not self.selinux_enabled():\n            return changed\n        context = self.selinux_default_context(path)\n        return self.set_context_if_different(path, context, False)\n\n    def set_context_if_different(self, path, context, changed):\n\n        if not HAVE_SELINUX or not self.selinux_enabled():\n            return changed\n        cur_context = self.selinux_context(path)\n        new_context = list(cur_context)\n        # Iterate over the current context instead of the\n        # argument context, which may have selevel.\n\n        (is_nfs, nfs_context) = self.is_nfs_path(path)\n        if is_nfs:\n            new_context = nfs_context\n        else:\n            for i in range(len(cur_context)):\n                if len(context) > i:\n                    if context[i] is not None and context[i] != cur_context[i]:\n                        new_context[i] = context[i]\n                    if context[i] is None:\n                        new_context[i] = cur_context[i]\n\n        if cur_context != new_context:\n            try:\n                if self.check_mode:\n                    return True\n                rc = selinux.lsetfilecon(self._to_filesystem_str(path),\n                                         str(':'.join(new_context)))\n            except OSError:\n                self.fail_json(path=path, msg='invalid selinux context', new_context=new_context, cur_context=cur_context, input_was=context)\n            if rc != 0:\n                self.fail_json(path=path, msg='set selinux context failed')\n            changed = True\n        return changed\n\n    def set_owner_if_different(self, path, owner, changed):\n        path = os.path.expanduser(path)\n        if owner is None:\n            return changed\n        orig_uid, orig_gid = self.user_and_group(path)\n        try:\n            uid = int(owner)\n        except ValueError:\n            try:\n                uid = pwd.getpwnam(owner).pw_uid\n            except KeyError:\n                self.fail_json(path=path, msg='chown failed: failed to look up user %s' % owner)\n        if orig_uid != uid:\n            if self.check_mode:\n                return True\n            try:\n                os.lchown(path, uid, -1)\n            except OSError:\n                self.fail_json(path=path, msg='chown failed')\n            changed = True\n        return changed\n\n    def set_group_if_different(self, path, group, changed):\n        path = os.path.expanduser(path)\n        if group is None:\n            return changed\n        orig_uid, orig_gid = self.user_and_group(path)\n        try:\n            gid = int(group)\n        except ValueError:\n            try:\n                gid = grp.getgrnam(group).gr_gid\n            except KeyError:\n                self.fail_json(path=path, msg='chgrp failed: failed to look up group %s' % group)\n        if orig_gid != gid:\n            if self.check_mode:\n                return True\n            try:\n                os.lchown(path, -1, gid)\n            except OSError:\n                self.fail_json(path=path, msg='chgrp failed')\n            changed = True\n        return changed\n\n    def set_mode_if_different(self, path, mode, changed):\n        path = os.path.expanduser(path)\n        if mode is None:\n            return changed\n        try:\n            # FIXME: support English modes\n            if not isinstance(mode, int):\n                mode = int(mode, 8)\n        except Exception, e:\n            self.fail_json(path=path, msg='mode needs to be something octalish', details=str(e))\n\n        st = os.lstat(path)\n        prev_mode = stat.S_IMODE(st[stat.ST_MODE])\n\n        if prev_mode != mode:\n            if self.check_mode:\n                return True\n            # FIXME: comparison against string above will cause this to be executed\n            # every time\n            try:\n                if 'lchmod' in dir(os):\n                    os.lchmod(path, mode)\n                else:\n                    os.chmod(path, mode)\n            except OSError, e:\n                if os.path.islink(path) and e.errno == errno.EPERM:  # Can't set mode on symbolic links\n                    pass\n                elif e.errno == errno.ENOENT: # Can't set mode on broken symbolic links\n                    pass\n                else:\n                    raise e\n            except Exception, e:\n                self.fail_json(path=path, msg='chmod failed', details=str(e))\n\n            st = os.lstat(path)\n            new_mode = stat.S_IMODE(st[stat.ST_MODE])\n\n            if new_mode != prev_mode:\n                changed = True\n        return changed\n\n    def set_fs_attributes_if_different(self, file_args, changed):\n        # set modes owners and context as needed\n        changed = self.set_context_if_different(\n            file_args['path'], file_args['secontext'], changed\n        )\n        changed = self.set_owner_if_different(\n            file_args['path'], file_args['owner'], changed\n        )\n        changed = self.set_group_if_different(\n            file_args['path'], file_args['group'], changed\n        )\n        changed = self.set_mode_if_different(\n            file_args['path'], file_args['mode'], changed\n        )\n        return changed\n\n    def set_directory_attributes_if_different(self, file_args, changed):\n        return self.set_fs_attributes_if_different(file_args, changed)\n\n    def set_file_attributes_if_different(self, file_args, changed):\n        return self.set_fs_attributes_if_different(file_args, changed)\n\n    def add_path_info(self, kwargs):\n        '''\n        for results that are files, supplement the info about the file\n        in the return path with stats about the file path.\n        '''\n\n        path = kwargs.get('path', kwargs.get('dest', None))\n        if path is None:\n            return kwargs\n        if os.path.exists(path):\n            (uid, gid) = self.user_and_group(path)\n            kwargs['uid'] = uid\n            kwargs['gid'] = gid\n            try:\n                user = pwd.getpwuid(uid)[0]\n            except KeyError:\n                user = str(uid)\n            try:\n                group = grp.getgrgid(gid)[0]\n            except KeyError:\n                group = str(gid)\n            kwargs['owner'] = user\n            kwargs['group'] = group\n            st = os.lstat(path)\n            kwargs['mode']  = oct(stat.S_IMODE(st[stat.ST_MODE]))\n            # secontext not yet supported\n            if os.path.islink(path):\n                kwargs['state'] = 'link'\n            elif os.path.isdir(path):\n                kwargs['state'] = 'directory'\n            elif os.stat(path).st_nlink > 1:\n                kwargs['state'] = 'hard'\n            else:\n                kwargs['state'] = 'file'\n            if HAVE_SELINUX and self.selinux_enabled():\n                kwargs['secontext'] = ':'.join(self.selinux_context(path))\n            kwargs['size'] = st[stat.ST_SIZE]\n        else:\n            kwargs['state'] = 'absent'\n        return kwargs\n\n    def _check_locale(self):\n        '''\n        Uses the locale module to test the currently set locale\n        (per the LANG and LC_CTYPE environment settings)\n        '''\n        try:\n            # setting the locale to '' uses the default locale\n            # as it would be returned by locale.getdefaultlocale()\n            locale.setlocale(locale.LC_ALL, '')\n        except locale.Error, e:\n            # fallback to the 'C' locale, which may cause unicode\n            # issues but is preferable to simply failing because\n            # of an unknown locale\n            locale.setlocale(locale.LC_ALL, 'C')\n            os.environ['LANG']     = 'C'\n            os.environ['LC_CTYPE'] = 'C'\n        except Exception, e:\n            self.fail_json(msg=\"An unknown error was encountered while attempting to validate the locale: %s\" % e)\n\n    def _handle_aliases(self):\n        aliases_results = {} #alias:canon\n        for (k,v) in self.argument_spec.iteritems():\n            self._legal_inputs.append(k)\n            aliases = v.get('aliases', None)\n            default = v.get('default', None)\n            required = v.get('required', False)\n            if default is not None and required:\n                # not alias specific but this is a good place to check this\n                self.fail_json(msg=\"internal error: required and default are mutally exclusive for %s\" % k)\n            if aliases is None:\n                continue\n            if type(aliases) != list:\n                self.fail_json(msg='internal error: aliases must be a list')\n            for alias in aliases:\n                self._legal_inputs.append(alias)\n                aliases_results[alias] = k\n                if alias in self.params:\n                    self.params[k] = self.params[alias]\n        \n        return aliases_results\n\n    def _check_for_check_mode(self):\n        for (k,v) in self.params.iteritems():\n            if k == 'CHECKMODE':\n                if not self.supports_check_mode:\n                    self.exit_json(skipped=True, msg=\"remote module does not support check mode\")\n                if self.supports_check_mode:\n                    self.check_mode = True\n\n    def _check_for_no_log(self):\n        for (k,v) in self.params.iteritems():\n            if k == 'NO_LOG':\n                self.no_log = self.boolean(v)\n\n    def _check_invalid_arguments(self):\n        for (k,v) in self.params.iteritems():\n            # these should be in legal inputs already\n            #if k in ('CHECKMODE', 'NO_LOG'):\n            #    continue\n            if k not in self._legal_inputs:\n                self.fail_json(msg=\"unsupported parameter for module: %s\" % k)\n\n    def _count_terms(self, check):\n        count = 0\n        for term in check:\n            if term in self.params:\n                count += 1\n        return count\n\n    def _check_mutually_exclusive(self, spec):\n        if spec is None:\n            return\n        for check in spec:\n            count = self._count_terms(check)\n            if count > 1:\n                self.fail_json(msg=\"parameters are mutually exclusive: %s\" % check)\n\n    def _check_required_one_of(self, spec):\n        if spec is None:\n            return\n        for check in spec:\n            count = self._count_terms(check)\n            if count == 0:\n                self.fail_json(msg=\"one of the following is required: %s\" % ','.join(check))\n\n    def _check_required_together(self, spec):\n        if spec is None:\n            return\n        for check in spec:\n            counts = [ self._count_terms([field]) for field in check ]\n            non_zero = [ c for c in counts if c > 0 ]\n            if len(non_zero) > 0:\n                if 0 in counts:\n                    self.fail_json(msg=\"parameters are required together: %s\" % check)\n\n    def _check_required_arguments(self):\n        ''' ensure all required arguments are present '''\n        missing = []\n        for (k,v) in self.argument_spec.iteritems():\n            required = v.get('required', False)\n            if required and k not in self.params:\n                missing.append(k)\n        if len(missing) > 0:\n            self.fail_json(msg=\"missing required arguments: %s\" % \",\".join(missing))\n\n    def _check_argument_values(self):\n        ''' ensure all arguments have the requested values, and there are no stray arguments '''\n        for (k,v) in self.argument_spec.iteritems():\n            choices = v.get('choices',None)\n            if choices is None:\n                continue\n            if type(choices) == list:\n                if k in self.params:\n                    if self.params[k] not in choices:\n                        choices_str=\",\".join([str(c) for c in choices])\n                        msg=\"value of %s must be one of: %s, got: %s\" % (k, choices_str, self.params[k])\n                        self.fail_json(msg=msg)\n            else:\n                self.fail_json(msg=\"internal error: do not know how to interpret argument_spec\")\n\n    def _check_argument_types(self):\n        ''' ensure all arguments have the requested type '''\n        for (k, v) in self.argument_spec.iteritems():\n            wanted = v.get('type', None)\n            if wanted is None:\n                continue\n            if k not in self.params:\n                continue\n\n            value = self.params[k]\n            is_invalid = False\n\n            if wanted == 'str':\n                if not isinstance(value, basestring):\n                    self.params[k] = str(value)\n            elif wanted == 'list':\n                if not isinstance(value, list):\n                    if isinstance(value, basestring):\n                        self.params[k] = value.split(\",\")\n                    elif isinstance(value, int) or isinstance(value, float):\n                        self.params[k] = [ str(value) ]\n                    else:\n                        is_invalid = True\n            elif wanted == 'dict':\n                if not isinstance(value, dict):\n                    if isinstance(value, basestring):\n                        if value.startswith(\"{\"):\n                            try:\n                                self.params[k] = json.loads(value)\n                            except:\n                                (result, exc) = self.safe_eval(value, dict(), include_exceptions=True)\n                                if exc is not None:\n                                    self.fail_json(msg=\"unable to evaluate dictionary for %s\" % k)\n                                self.params[k] = result\n                        elif '=' in value:\n                            self.params[k] = dict([x.split(\"=\", 1) for x in value.split(\",\")])\n                        else:\n                            self.fail_json(msg=\"dictionary requested, could not parse JSON or key=value\")\n                    else:\n                        is_invalid = True\n            elif wanted == 'bool':\n                if not isinstance(value, bool):\n                    if isinstance(value, basestring):\n                        self.params[k] = self.boolean(value)\n                    else:\n                        is_invalid = True\n            elif wanted == 'int':\n                if not isinstance(value, int):\n                    if isinstance(value, basestring):\n                        self.params[k] = int(value)\n                    else:\n                        is_invalid = True\n            elif wanted == 'float':\n                if not isinstance(value, float):\n                    if isinstance(value, basestring):\n                        self.params[k] = float(value)\n                    else:\n                        is_invalid = True\n            else:\n                self.fail_json(msg=\"implementation error: unknown type %s requested for %s\" % (wanted, k))\n\n            if is_invalid:\n                self.fail_json(msg=\"argument %s is of invalid type: %s, required: %s\" % (k, type(value), wanted))\n\n    def _set_defaults(self, pre=True):\n        for (k,v) in self.argument_spec.iteritems():\n            default = v.get('default', None)\n            if pre == True:\n                # this prevents setting defaults on required items\n                if default is not None and k not in self.params:\n                    self.params[k] = default\n            else:\n                # make sure things without a default still get set None\n                if k not in self.params:\n                    self.params[k] = default\n\n    def _load_params(self):\n        ''' read the input and return a dictionary and the arguments string '''\n        args = MODULE_ARGS\n        items   = shlex.split(args)\n        params = {}\n        for x in items:\n            try:\n                (k, v) = x.split(\"=\",1)\n            except Exception, e:\n                self.fail_json(msg=\"this module requires key=value arguments (%s)\" % (items))\n            if k in params:\n                self.fail_json(msg=\"duplicate parameter: %s (value=%s)\" % (k, v))\n            params[k] = v\n        params2 = json.loads(MODULE_COMPLEX_ARGS)\n        params2.update(params)\n        return (params2, args)\n\n    def _log_invocation(self):\n        ''' log that ansible ran the module '''\n        # TODO: generalize a separate log function and make log_invocation use it\n        # Sanitize possible password argument when logging.\n        log_args = dict()\n        passwd_keys = ['password', 'login_password']\n\n        filter_re = [\n            # filter out things like user:pass@foo/whatever\n            # and http://username:pass@wherever/foo\n            re.compile('^(?P<before>.*:)(?P<password>.*)(?P<after>\\@.*)$'), \n        ]\n\n        for param in self.params:\n            canon  = self.aliases.get(param, param)\n            arg_opts = self.argument_spec.get(canon, {})\n            no_log = arg_opts.get('no_log', False)\n                \n            if no_log:\n                log_args[param] = 'NOT_LOGGING_PARAMETER'\n            elif param in passwd_keys:\n                log_args[param] = 'NOT_LOGGING_PASSWORD'\n            else:\n                found = False\n                for filter in filter_re:\n                    if isinstance(self.params[param], unicode):\n                        m = filter.match(self.params[param])\n                    else:\n                        m = filter.match(str(self.params[param]))\n                    if m:\n                        d = m.groupdict()\n                        log_args[param] = d['before'] + \"********\" + d['after']\n                        found = True\n                        break\n                if not found:\n                    log_args[param] = self.params[param]\n\n        module = 'ansible-%s' % os.path.basename(__file__)\n        msg = ''\n        for arg in log_args:\n            if isinstance(log_args[arg], basestring):\n                msg = msg + arg + '=' + log_args[arg].decode('utf-8') + ' '\n            else:\n                msg = msg + arg + '=' + str(log_args[arg]) + ' '\n        if msg:\n            msg = 'Invoked with %s' % msg\n        else:\n            msg = 'Invoked'\n\n        # 6655 - allow for accented characters\n        try:\n            msg = msg.encode('utf8')\n        except UnicodeDecodeError, e:\n            pass\n\n        if (has_journal):\n            journal_args = [\"MESSAGE=%s %s\" % (module, msg)]\n            journal_args.append(\"MODULE=%s\" % os.path.basename(__file__))\n            for arg in log_args:\n                journal_args.append(arg.upper() + \"=\" + str(log_args[arg]))\n            try:\n                journal.sendv(*journal_args)\n            except IOError, e:\n                # fall back to syslog since logging to journal failed\n                syslog.openlog(str(module), 0, syslog.LOG_USER)\n                syslog.syslog(syslog.LOG_NOTICE, msg) #1\n        else:\n            syslog.openlog(str(module), 0, syslog.LOG_USER)\n            syslog.syslog(syslog.LOG_NOTICE, msg) #2\n\n    def _set_cwd(self):\n        try:\n            cwd = os.getcwd()\n            if not os.access(cwd, os.F_OK|os.R_OK):\n                raise\n            return cwd\n        except:\n            # we don't have access to the cwd, probably because of sudo. \n            # Try and move to a neutral location to prevent errors\n            for cwd in [os.path.expandvars('$HOME'), tempfile.gettempdir()]:\n                try:\n                    if os.access(cwd, os.F_OK|os.R_OK):\n                        os.chdir(cwd)\n                        return cwd\n                except:\n                    pass\n        # we won't error here, as it may *not* be a problem, \n        # and we don't want to break modules unnecessarily\n        return None    \n\n    def get_bin_path(self, arg, required=False, opt_dirs=[]):\n        '''\n        find system executable in PATH.\n        Optional arguments:\n           - required:  if executable is not found and required is true, fail_json\n           - opt_dirs:  optional list of directories to search in addition to PATH\n        if found return full path; otherwise return None\n        '''\n        sbin_paths = ['/sbin', '/usr/sbin', '/usr/local/sbin']\n        paths = []\n        for d in opt_dirs:\n            if d is not None and os.path.exists(d):\n                paths.append(d)\n        paths += os.environ.get('PATH', '').split(os.pathsep)\n        bin_path = None\n        # mangle PATH to include /sbin dirs\n        for p in sbin_paths:\n            if p not in paths and os.path.exists(p):\n                paths.append(p)\n        for d in paths:\n            path = os.path.join(d, arg)\n            if os.path.exists(path) and self.is_executable(path):\n                bin_path = path\n                break\n        if required and bin_path is None:\n            self.fail_json(msg='Failed to find required executable %s' % arg)\n        return bin_path\n\n    def boolean(self, arg):\n        ''' return a bool for the arg '''\n        if arg is None or type(arg) == bool:\n            return arg\n        if type(arg) in types.StringTypes:\n            arg = arg.lower()\n        if arg in BOOLEANS_TRUE:\n            return True\n        elif arg in BOOLEANS_FALSE:\n            return False\n        else:\n            self.fail_json(msg='Boolean %s not in either boolean list' % arg)\n\n    def jsonify(self, data):\n        for encoding in (\"utf-8\", \"latin-1\", \"unicode_escape\"):\n            try:\n                return json.dumps(data, encoding=encoding)\n            # Old systems using simplejson module does not support encoding keyword.\n            except TypeError, e:\n                return json.dumps(data)\n            except UnicodeDecodeError, e:\n                continue\n        self.fail_json(msg='Invalid unicode encoding encountered')\n\n    def from_json(self, data):\n        return json.loads(data)\n\n    def add_cleanup_file(self, path):\n        if path not in self.cleanup_files:\n            self.cleanup_files.append(path)\n\n    def do_cleanup_files(self):\n        for path in self.cleanup_files:\n            self.cleanup(path)\n\n    def exit_json(self, **kwargs):\n        ''' return from the module, without error '''\n        self.add_path_info(kwargs)\n        if not 'changed' in kwargs:\n            kwargs['changed'] = False\n        self.do_cleanup_files()\n        print self.jsonify(kwargs)\n        sys.exit(0)\n\n    def fail_json(self, **kwargs):\n        ''' return from the module, with an error message '''\n        self.add_path_info(kwargs)\n        assert 'msg' in kwargs, \"implementation error -- msg to explain the error is required\"\n        kwargs['failed'] = True\n        self.do_cleanup_files()\n        print self.jsonify(kwargs)\n        sys.exit(1)\n\n    def is_executable(self, path):\n        '''is the given path executable?'''\n        return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE]\n                or stat.S_IXGRP & os.stat(path)[stat.ST_MODE]\n                or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])\n\n    def digest_from_file(self, filename, digest_method):\n        ''' Return hex digest of local file for a given digest_method, or None if file is not present. '''\n        if not os.path.exists(filename):\n            return None\n        if os.path.isdir(filename):\n            self.fail_json(msg=\"attempted to take checksum of directory: %s\" % filename)\n        digest = digest_method\n        blocksize = 64 * 1024\n        infile = open(filename, 'rb')\n        block = infile.read(blocksize)\n        while block:\n            digest.update(block)\n            block = infile.read(blocksize)\n        infile.close()\n        return digest.hexdigest()\n\n    def md5(self, filename):\n        ''' Return MD5 hex digest of local file using digest_from_file(). '''\n        return self.digest_from_file(filename, _md5())\n\n    def sha256(self, filename):\n        ''' Return SHA-256 hex digest of local file using digest_from_file(). '''\n        if not HAVE_HASHLIB:\n            self.fail_json(msg=\"SHA-256 checksums require hashlib, which is available in Python 2.5 and higher\")\n        return self.digest_from_file(filename, _sha256())\n\n    def backup_local(self, fn):\n        '''make a date-marked backup of the specified file, return True or False on success or failure'''\n        # backups named basename-YYYY-MM-DD@HH:MM~\n        ext = time.strftime(\"%Y-%m-%d@%H:%M~\", time.localtime(time.time()))\n        backupdest = '%s.%s' % (fn, ext)\n\n        try:\n            shutil.copy2(fn, backupdest)\n        except shutil.Error, e:\n            self.fail_json(msg='Could not make backup of %s to %s: %s' % (fn, backupdest, e))\n        return backupdest\n\n    def cleanup(self, tmpfile):\n        if os.path.exists(tmpfile):\n            try:\n                os.unlink(tmpfile)\n            except OSError, e:\n                sys.stderr.write(\"could not cleanup %s: %s\" % (tmpfile, e))\n\n    def atomic_move(self, src, dest):\n        '''atomically move src to dest, copying attributes from dest, returns true on success\n        it uses os.rename to ensure this as it is an atomic operation, rest of the function is\n        to work around limitations, corner cases and ensure selinux context is saved if possible'''\n        context = None\n        dest_stat = None\n        if os.path.exists(dest):\n            try:\n                dest_stat = os.stat(dest)\n                os.chmod(src, dest_stat.st_mode & 07777)\n                os.chown(src, dest_stat.st_uid, dest_stat.st_gid)\n            except OSError, e:\n                if e.errno != errno.EPERM:\n                    raise\n            if self.selinux_enabled():\n                context = self.selinux_context(dest)\n        else:\n            if self.selinux_enabled():\n                context = self.selinux_default_context(dest)\n\n        creating = not os.path.exists(dest)\n\n        try:\n            login_name = os.getlogin()\n        except OSError:\n            # not having a tty can cause the above to fail, so\n            # just get the LOGNAME environment variable instead\n            login_name = os.environ.get('LOGNAME', None)\n\n        # if the original login_name doesn't match the currently\n        # logged-in user, or if the SUDO_USER environment variable\n        # is set, then this user has switched their credentials\n        switched_user = login_name and login_name != pwd.getpwuid(os.getuid())[0] or os.environ.get('SUDO_USER')\n\n        try:\n            # Optimistically try a rename, solves some corner cases and can avoid useless work, throws exception if not atomic.\n            os.rename(src, dest)\n        except (IOError,OSError), e:\n            # only try workarounds for errno 18 (cross device), 1 (not permited) and 13 (permission denied)\n            if e.errno != errno.EPERM and e.errno != errno.EXDEV and e.errno != errno.EACCES:\n                self.fail_json(msg='Could not replace file: %s to %s: %s' % (src, dest, e))\n\n            dest_dir = os.path.dirname(dest)\n            dest_file = os.path.basename(dest)\n            tmp_dest = tempfile.NamedTemporaryFile(\n                prefix=\".ansible_tmp\", dir=dest_dir, suffix=dest_file)\n\n            try: # leaves tmp file behind when sudo and  not root\n                if switched_user and os.getuid() != 0:\n                    # cleanup will happen by 'rm' of tempdir\n                    # copy2 will preserve some metadata\n                    shutil.copy2(src, tmp_dest.name)\n                else:\n                    shutil.move(src, tmp_dest.name)\n                if self.selinux_enabled():\n                    self.set_context_if_different(\n                        tmp_dest.name, context, False)\n                tmp_stat = os.stat(tmp_dest.name)\n                if dest_stat and (tmp_stat.st_uid != dest_stat.st_uid or tmp_stat.st_gid != dest_stat.st_gid):\n                    os.chown(tmp_dest.name, dest_stat.st_uid, dest_stat.st_gid)\n                os.rename(tmp_dest.name, dest)\n            except (shutil.Error, OSError, IOError), e:\n                self.cleanup(tmp_dest.name)\n                self.fail_json(msg='Could not replace file: %s to %s: %s' % (src, dest, e))\n\n        if creating:\n            # make sure the file has the correct permissions\n            # based on the current value of umask\n            umask = os.umask(0)\n            os.umask(umask)\n            os.chmod(dest, 0666 ^ umask)\n            if switched_user:\n                os.chown(dest, os.getuid(), os.getgid())\n\n        if self.selinux_enabled():\n            # rename might not preserve context\n            self.set_context_if_different(dest, context, False)\n\n    def run_command(self, args, check_rc=False, close_fds=False, executable=None, data=None, binary_data=False, path_prefix=None, cwd=None, use_unsafe_shell=False):\n        '''\n        Execute a command, returns rc, stdout, and stderr.\n        args is the command to run\n        If args is a list, the command will be run with shell=False.\n        If args is a string and use_unsafe_shell=False it will split args to a list and run with shell=False\n        If args is a string and use_unsafe_shell=True it run with shell=True.\n        Other arguments:\n        - check_rc (boolean)  Whether to call fail_json in case of\n                              non zero RC.  Default is False.\n        - close_fds (boolean) See documentation for subprocess.Popen().\n                              Default is False.\n        - executable (string) See documentation for subprocess.Popen().\n                              Default is None.\n        '''\n\n        shell = False\n        if isinstance(args, list):\n            if use_unsafe_shell:\n                args = \" \".join([pipes.quote(x) for x in args])\n                shell = True\n        elif isinstance(args, basestring) and use_unsafe_shell:\n            shell = True\n        elif isinstance(args, basestring):\n            args = shlex.split(args.encode('utf-8'))\n        else:\n            msg = \"Argument 'args' to run_command must be list or string\"\n            self.fail_json(rc=257, cmd=args, msg=msg)\n\n        # expand things like $HOME and ~\n        if not shell:\n            args = [ os.path.expandvars(os.path.expanduser(x)) for x in args ]\n\n        rc = 0\n        msg = None\n        st_in = None\n\n        # Set a temporart env path if a prefix is passed\n        env=os.environ\n        if path_prefix:\n            env['PATH']=\"%s:%s\" % (path_prefix, env['PATH'])\n\n        # create a printable version of the command for use\n        # in reporting later, which strips out things like\n        # passwords from the args list\n        if isinstance(args, list):\n            clean_args = \" \".join(pipes.quote(arg) for arg in args)\n        else:\n            clean_args = args\n\n        # all clean strings should return two match groups, \n        # where the first is the CLI argument and the second \n        # is the password/key/phrase that will be hidden\n        clean_re_strings = [\n            # this removes things like --password, --pass, --pass-wd, etc.\n            # optionally followed by an '=' or a space. The password can \n            # be quoted or not too, though it does not care about quotes\n            # that are not balanced\n            # source: http://blog.stevenlevithan.com/archives/match-quoted-string\n            r'([-]{0,2}pass[-]?(?:word|wd)?[=\\s]?)((?:[\"\\'])?(?:[^\\s])*(?:\\1)?)',\n            # TODO: add more regex checks here\n        ]\n        for re_str in clean_re_strings:\n            r = re.compile(re_str)\n            clean_args = r.sub(r'\\1********', clean_args)\n\n        if data:\n            st_in = subprocess.PIPE\n\n        kwargs = dict(\n            executable=executable,\n            shell=shell,\n            close_fds=close_fds,\n            stdin= st_in,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE \n        )\n\n        if path_prefix:\n            kwargs['env'] = env\n        if cwd and os.path.isdir(cwd):\n            kwargs['cwd'] = cwd\n\n        # store the pwd\n        prev_dir = os.getcwd()\n\n        # make sure we're in the right working directory\n        if cwd and os.path.isdir(cwd):\n            try:\n                os.chdir(cwd)\n            except (OSError, IOError), e:\n                self.fail_json(rc=e.errno, msg=\"Could not open %s , %s\" % (cwd, str(e)))\n\n        try:\n            cmd = subprocess.Popen(args, **kwargs)\n\n            if data:\n                if not binary_data:\n                    data += '\\n'\n            out, err = cmd.communicate(input=data)\n            rc = cmd.returncode\n        except (OSError, IOError), e:\n            self.fail_json(rc=e.errno, msg=str(e), cmd=clean_args)\n        except:\n            self.fail_json(rc=257, msg=traceback.format_exc(), cmd=clean_args)\n\n        if rc != 0 and check_rc:\n            msg = err.rstrip()\n            self.fail_json(cmd=clean_args, rc=rc, stdout=out, stderr=err, msg=msg)\n\n        # reset the pwd\n        os.chdir(prev_dir)\n\n        return (rc, out, err)\n\n    def append_to_file(self, filename, str):\n        filename = os.path.expandvars(os.path.expanduser(filename))\n        fh = open(filename, 'a')\n        fh.write(str)\n        fh.close()\n\n    def pretty_bytes(self,size):\n        ranges = (\n                (1<<70L, 'ZB'),\n                (1<<60L, 'EB'),\n                (1<<50L, 'PB'),\n                (1<<40L, 'TB'),\n                (1<<30L, 'GB'),\n                (1<<20L, 'MB'),\n                (1<<10L, 'KB'),\n                (1, 'Bytes')\n            )\n        for limit, suffix in ranges:\n            if size >= limit:\n                break\n        return '%.2f %s' % (float(size)/ limit, suffix)\n\ndef get_module_path():\n    return os.path.dirname(os.path.realpath(__file__))\n", "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport multiprocessing\nimport signal\nimport os\nimport pwd\nimport Queue\nimport random\nimport traceback\nimport tempfile\nimport time\nimport collections\nimport socket\nimport base64\nimport sys\nimport pipes\nimport jinja2\nimport subprocess\nimport shlex\nimport getpass\n\nimport ansible.constants as C\nimport ansible.inventory\nfrom ansible import utils\nfrom ansible.utils import template\nfrom ansible.utils import check_conditional\nfrom ansible.utils import string_functions\nfrom ansible import errors\nfrom ansible import module_common\nimport poller\nimport connection\nfrom return_data import ReturnData\nfrom ansible.callbacks import DefaultRunnerCallbacks, vv\nfrom ansible.module_common import ModuleReplacer\n\nmodule_replacer = ModuleReplacer(strip_comments=False)\n\nHAS_ATFORK=True\ntry:\n    from Crypto.Random import atfork\nexcept ImportError:\n    HAS_ATFORK=False\n\nmultiprocessing_runner = None\n        \nOUTPUT_LOCKFILE  = tempfile.TemporaryFile()\nPROCESS_LOCKFILE = tempfile.TemporaryFile()\n\n################################################\n\ndef _executor_hook(job_queue, result_queue, new_stdin):\n\n    # attempt workaround of https://github.com/newsapps/beeswithmachineguns/issues/17\n    # this function also not present in CentOS 6\n    if HAS_ATFORK:\n        atfork()\n\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n    while not job_queue.empty():\n        try:\n            host = job_queue.get(block=False)\n            return_data = multiprocessing_runner._executor(host, new_stdin)\n            result_queue.put(return_data)\n        except Queue.Empty:\n            pass\n        except:\n            traceback.print_exc()\n\nclass HostVars(dict):\n    ''' A special view of vars_cache that adds values from the inventory when needed. '''\n\n    def __init__(self, vars_cache, inventory, vault_password=None):\n        self.vars_cache = vars_cache\n        self.inventory = inventory\n        self.lookup = dict()\n        self.update(vars_cache)\n        self.vault_password = vault_password\n\n    def __getitem__(self, host):\n        if host not in self.lookup:\n            result = self.inventory.get_variables(host, vault_password=self.vault_password).copy()\n            result.update(self.vars_cache.get(host, {}))\n            self.lookup[host] = result\n        return self.lookup[host]\n\n\nclass Runner(object):\n    ''' core API interface to ansible '''\n\n    # see bin/ansible for how this is used...\n\n    def __init__(self,\n        host_list=C.DEFAULT_HOST_LIST,      # ex: /etc/ansible/hosts, legacy usage\n        module_path=None,                   # ex: /usr/share/ansible\n        module_name=C.DEFAULT_MODULE_NAME,  # ex: copy\n        module_args=C.DEFAULT_MODULE_ARGS,  # ex: \"src=/tmp/a dest=/tmp/b\"\n        forks=C.DEFAULT_FORKS,              # parallelism level\n        timeout=C.DEFAULT_TIMEOUT,          # SSH timeout\n        pattern=C.DEFAULT_PATTERN,          # which hosts?  ex: 'all', 'acme.example.org'\n        remote_user=C.DEFAULT_REMOTE_USER,  # ex: 'username'\n        remote_pass=C.DEFAULT_REMOTE_PASS,  # ex: 'password123' or None if using key\n        remote_port=None,                   # if SSH on different ports\n        private_key_file=C.DEFAULT_PRIVATE_KEY_FILE, # if not using keys/passwords\n        sudo_pass=C.DEFAULT_SUDO_PASS,      # ex: 'password123' or None\n        background=0,                       # async poll every X seconds, else 0 for non-async\n        basedir=None,                       # directory of playbook, if applicable\n        setup_cache=None,                   # used to share fact data w/ other tasks\n        vars_cache=None,                    # used to store variables about hosts\n        transport=C.DEFAULT_TRANSPORT,      # 'ssh', 'paramiko', 'local'\n        conditional='True',                 # run only if this fact expression evals to true\n        callbacks=None,                     # used for output\n        sudo=False,                         # whether to run sudo or not\n        sudo_user=C.DEFAULT_SUDO_USER,      # ex: 'root'\n        module_vars=None,                   # a playbooks internals thing\n        default_vars=None,                  # ditto\n        is_playbook=False,                  # running from playbook or not?\n        inventory=None,                     # reference to Inventory object\n        subset=None,                        # subset pattern\n        check=False,                        # don't make any changes, just try to probe for potential changes\n        diff=False,                         # whether to show diffs for template files that change\n        environment=None,                   # environment variables (as dict) to use inside the command\n        complex_args=None,                  # structured data in addition to module_args, must be a dict\n        error_on_undefined_vars=C.DEFAULT_UNDEFINED_VAR_BEHAVIOR, # ex. False\n        accelerate=False,                   # use accelerated connection\n        accelerate_ipv6=False,              # accelerated connection w/ IPv6\n        accelerate_port=None,               # port to use with accelerated connection\n        su=False,                           # Are we running our command via su?\n        su_user=None,                       # User to su to when running command, ex: 'root'\n        su_pass=C.DEFAULT_SU_PASS,\n        vault_pass=None,\n        run_hosts=None,                     # an optional list of pre-calculated hosts to run on\n        no_log=False,                       # option to enable/disable logging for a given task\n        ):\n\n        # used to lock multiprocess inputs and outputs at various levels\n        self.output_lockfile  = OUTPUT_LOCKFILE\n        self.process_lockfile = PROCESS_LOCKFILE\n\n        if not complex_args:\n            complex_args = {}\n\n        # storage & defaults\n        self.check            = check\n        self.diff             = diff\n        self.setup_cache      = utils.default(setup_cache, lambda: collections.defaultdict(dict))\n        self.vars_cache       = utils.default(vars_cache, lambda: collections.defaultdict(dict))\n        self.basedir          = utils.default(basedir, lambda: os.getcwd())\n        self.callbacks        = utils.default(callbacks, lambda: DefaultRunnerCallbacks())\n        self.generated_jid    = str(random.randint(0, 999999999999))\n        self.transport        = transport\n        self.inventory        = utils.default(inventory, lambda: ansible.inventory.Inventory(host_list))\n\n        self.module_vars      = utils.default(module_vars, lambda: {})\n        self.default_vars     = utils.default(default_vars, lambda: {})\n        self.always_run       = None\n        self.connector        = connection.Connection(self)\n        self.conditional      = conditional\n        self.module_name      = module_name\n        self.forks            = int(forks)\n        self.pattern          = pattern\n        self.module_args      = module_args\n        self.timeout          = timeout\n        self.remote_user      = remote_user\n        self.remote_pass      = remote_pass\n        self.remote_port      = remote_port\n        self.private_key_file = private_key_file\n        self.background       = background\n        self.sudo             = sudo\n        self.sudo_user_var    = sudo_user\n        self.sudo_user        = None\n        self.sudo_pass        = sudo_pass\n        self.is_playbook      = is_playbook\n        self.environment      = environment\n        self.complex_args     = complex_args\n        self.error_on_undefined_vars = error_on_undefined_vars\n        self.accelerate       = accelerate\n        self.accelerate_port  = accelerate_port\n        self.accelerate_ipv6  = accelerate_ipv6\n        self.callbacks.runner = self\n        self.su               = su\n        self.su_user_var      = su_user\n        self.su_user          = None\n        self.su_pass          = su_pass\n        self.vault_pass       = vault_pass\n        self.no_log           = no_log\n\n        if self.transport == 'smart':\n            # if the transport is 'smart' see if SSH can support ControlPersist if not use paramiko\n            # 'smart' is the default since 1.2.1/1.3\n            cmd = subprocess.Popen(['ssh','-o','ControlPersist'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            (out, err) = cmd.communicate() \n            if \"Bad configuration option\" in err:\n                self.transport = \"paramiko\"\n            else:\n                self.transport = \"ssh\" \n\n        # save the original transport, in case it gets\n        # changed later via options like accelerate\n        self.original_transport = self.transport\n\n        # misc housekeeping\n        if subset and self.inventory._subset is None:\n            # don't override subset when passed from playbook\n            self.inventory.subset(subset)\n\n        # If we get a pre-built list of hosts to run on, from say a playbook, use them.\n        # Also where we will store the hosts to run on once discovered\n        self.run_hosts = run_hosts\n\n        if self.transport == 'local':\n            self.remote_user = pwd.getpwuid(os.geteuid())[0]\n\n        if module_path is not None:\n            for i in module_path.split(os.pathsep):\n                utils.plugins.module_finder.add_directory(i)\n\n        utils.plugins.push_basedir(self.basedir)\n\n        # ensure we are using unique tmp paths\n        random.seed()\n    # *****************************************************\n\n    def _complex_args_hack(self, complex_args, module_args):\n        \"\"\"\n        ansible-playbook both allows specifying key=value string arguments and complex arguments\n        however not all modules use our python common module system and cannot\n        access these.  An example might be a Bash module.  This hack allows users to still pass \"args\"\n        as a hash of simple scalars to those arguments and is short term.  We could technically\n        just feed JSON to the module, but that makes it hard on Bash consumers.  The way this is implemented\n        it does mean values in 'args' have LOWER priority than those on the key=value line, allowing\n        args to provide yet another way to have pluggable defaults.\n        \"\"\"\n        if complex_args is None:\n            return module_args\n        if not isinstance(complex_args, dict):\n            raise errors.AnsibleError(\"complex arguments are not a dictionary: %s\" % complex_args)\n        for (k,v) in complex_args.iteritems():\n            if isinstance(v, basestring):\n                module_args = \"%s=%s %s\" % (k, pipes.quote(v), module_args)\n        return module_args\n\n    # *****************************************************\n\n    def _transfer_str(self, conn, tmp, name, data):\n        ''' transfer string to remote file '''\n\n        if type(data) == dict:\n            data = utils.jsonify(data)\n\n        afd, afile = tempfile.mkstemp()\n        afo = os.fdopen(afd, 'w')\n        try:\n            if not isinstance(data, unicode):\n                #ensure the data is valid UTF-8\n                data.decode('utf-8')\n            else:\n                data = data.encode('utf-8')\n            afo.write(data)\n        except:\n            raise errors.AnsibleError(\"failure encoding into utf-8\")\n        afo.flush()\n        afo.close()\n\n        remote = os.path.join(tmp, name)\n        try:\n            conn.put_file(afile, remote)\n        finally:\n            os.unlink(afile)\n        return remote\n\n    # *****************************************************\n\n    def _compute_environment_string(self, inject=None):\n        ''' what environment variables to use when running the command? '''\n\n        default_environment = dict(\n            LANG     = C.DEFAULT_MODULE_LANG,\n            LC_CTYPE = C.DEFAULT_MODULE_LANG,\n        )\n\n        if self.environment:\n            enviro = template.template(self.basedir, self.environment, inject, convert_bare=True)\n            enviro = utils.safe_eval(enviro)\n            if type(enviro) != dict:\n                raise errors.AnsibleError(\"environment must be a dictionary, received %s\" % enviro)\n            default_environment.update(enviro)\n\n        result = \"\"\n        for (k,v) in default_environment.iteritems():\n            result = \"%s=%s %s\" % (k, pipes.quote(unicode(v)), result)\n        return result\n\n    # *****************************************************\n\n    def _compute_delegate(self, host, password, remote_inject):\n\n        \"\"\" Build a dictionary of all attributes for the delegate host \"\"\"\n\n        delegate = {}\n\n        # allow delegated host to be templated\n        delegate['host'] = template.template(self.basedir, host, \n                                remote_inject, fail_on_undefined=True)\n\n        delegate['inject'] = remote_inject.copy()\n\n        # set any interpreters\n        interpreters = []\n        for i in delegate['inject']:\n            if i.startswith(\"ansible_\") and i.endswith(\"_interpreter\"):\n                interpreters.append(i)\n        for i in interpreters:\n            del delegate['inject'][i]\n        port = C.DEFAULT_REMOTE_PORT\n\n        this_host = delegate['host']\n\n        # get the vars for the delegate by it's name        \n        try:\n            this_info = delegate['inject']['hostvars'][this_host]\n        except:\n            # make sure the inject is empty for non-inventory hosts\n            this_info = {}\n\n        # get the real ssh_address for the delegate        \n        # and allow ansible_ssh_host to be templated\n        delegate['ssh_host'] = template.template(self.basedir,\n                            this_info.get('ansible_ssh_host', this_host),\n                            this_info, fail_on_undefined=True)\n\n        delegate['port'] = this_info.get('ansible_ssh_port', port)\n\n        delegate['user'] = self._compute_delegate_user(this_host, delegate['inject'])\n\n        delegate['pass'] = this_info.get('ansible_ssh_pass', password)\n        delegate['private_key_file'] = this_info.get('ansible_ssh_private_key_file', \n                                        self.private_key_file)\n        delegate['transport'] = this_info.get('ansible_connection', self.transport)\n        delegate['sudo_pass'] = this_info.get('ansible_sudo_pass', self.sudo_pass)\n\n        # Last chance to get private_key_file from global variables.\n        # this is usefull if delegated host is not defined in the inventory\n        if delegate['private_key_file'] is None:\n            delegate['private_key_file'] = remote_inject.get(\n                'ansible_ssh_private_key_file', None)\n\n        if delegate['private_key_file'] is not None:\n            delegate['private_key_file'] = os.path.expanduser(delegate['private_key_file'])\n\n        for i in this_info:\n            if i.startswith(\"ansible_\") and i.endswith(\"_interpreter\"):\n                delegate['inject'][i] = this_info[i]\n\n        return delegate\n\n    def _compute_delegate_user(self, host, inject):\n\n        \"\"\" Caculate the remote user based on an order of preference \"\"\"\n\n        # inventory > playbook > original_host\n\n        actual_user = inject.get('ansible_ssh_user', self.remote_user)\n        thisuser = None\n\n        if host in inject['hostvars']:\n            if inject['hostvars'][host].get('ansible_ssh_user'):\n                # user for delegate host in inventory\n                thisuser = inject['hostvars'][host].get('ansible_ssh_user')\n\n        if thisuser is None and self.remote_user:\n            # user defined by play/runner\n            thisuser = self.remote_user\n\n        if thisuser is not None:\n            actual_user = thisuser\n        else:\n            # fallback to the inventory user of the play host\n            #actual_user = inject.get('ansible_ssh_user', actual_user)\n            actual_user = inject.get('ansible_ssh_user', self.remote_user)\n\n        return actual_user\n\n    def _count_module_args(self, args):\n        '''\n        Count the number of k=v pairs in the supplied module args. This is\n        basically a specialized version of parse_kv() from utils with a few\n        minor changes.\n        '''\n        options = {}\n        if args is not None:\n            args = args.encode('utf-8')\n            try:\n                lexer = shlex.shlex(args, posix=True)\n                lexer.whitespace_split = True\n                lexer.quotes = '\"'\n                lexer.ignore_quotes = \"'\"\n                vargs = list(lexer)\n            except ValueError, ve:\n                if 'no closing quotation' in str(ve).lower():\n                    raise errors.AnsibleError(\"error parsing argument string '%s', try quoting the entire line.\" % args)\n                else:\n                    raise\n            vargs = [x.decode('utf-8') for x in vargs]\n            for x in vargs:\n                if \"=\" in x:\n                    k, v = x.split(\"=\",1)\n                    if k in options:\n                        raise errors.AnsibleError(\"a duplicate parameter was found in the argument string (%s)\" % k)\n                    options[k] = v\n        return len(options)\n\n\n    # *****************************************************\n\n    def _execute_module(self, conn, tmp, module_name, args,\n        async_jid=None, async_module=None, async_limit=None, inject=None, persist_files=False, complex_args=None, delete_remote_tmp=True):\n\n        ''' transfer and run a module along with its arguments on the remote side'''\n\n        # hack to support fireball mode\n        if module_name == 'fireball':\n            args = \"%s password=%s\" % (args, base64.b64encode(str(utils.key_for_hostname(conn.host))))\n            if 'port' not in args:\n                args += \" port=%s\" % C.ZEROMQ_PORT\n\n        (\n        module_style,\n        shebang,\n        module_data\n        ) = self._configure_module(conn, module_name, args, inject, complex_args)\n\n        # a remote tmp path may be necessary and not already created\n        if self._late_needs_tmp_path(conn, tmp, module_style):\n            tmp = self._make_tmp_path(conn)\n\n        remote_module_path = os.path.join(tmp, module_name)\n\n        if (module_style != 'new'\n           or async_jid is not None\n           or not conn.has_pipelining\n           or not C.ANSIBLE_SSH_PIPELINING\n           or C.DEFAULT_KEEP_REMOTE_FILES\n           or self.su):\n            self._transfer_str(conn, tmp, module_name, module_data)\n\n        environment_string = self._compute_environment_string(inject)\n\n        if \"tmp\" in tmp and ((self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root')):\n            # deal with possible umask issues once sudo'ed to other user\n            cmd_chmod = \"chmod a+r %s\" % remote_module_path\n            self._low_level_exec_command(conn, cmd_chmod, tmp, sudoable=False)\n\n        cmd = \"\"\n        in_data = None\n        if module_style != 'new':\n            if 'CHECKMODE=True' in args:\n                # if module isn't using AnsibleModuleCommon infrastructure we can't be certain it knows how to\n                # do --check mode, so to be safe we will not run it.\n                return ReturnData(conn=conn, result=dict(skipped=True, msg=\"cannot yet run check mode against old-style modules\"))\n            elif 'NO_LOG' in args:\n                return ReturnData(conn=conn, result=dict(skipped=True, msg=\"cannot use no_log: with old-style modules\"))\n\n            args = template.template(self.basedir, args, inject)\n\n            # decide whether we need to transfer JSON or key=value\n            argsfile = None\n            if module_style == 'non_native_want_json':\n                if complex_args:\n                    complex_args.update(utils.parse_kv(args))\n                    argsfile = self._transfer_str(conn, tmp, 'arguments', utils.jsonify(complex_args))\n                else:\n                    argsfile = self._transfer_str(conn, tmp, 'arguments', utils.jsonify(utils.parse_kv(args)))\n\n            else:\n                argsfile = self._transfer_str(conn, tmp, 'arguments', args)\n\n            if (self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root'):\n                # deal with possible umask issues once sudo'ed to other user\n                cmd_args_chmod = \"chmod a+r %s\" % argsfile\n                self._low_level_exec_command(conn, cmd_args_chmod, tmp, sudoable=False)\n\n            if async_jid is None:\n                cmd = \"%s %s\" % (remote_module_path, argsfile)\n            else:\n                cmd = \" \".join([str(x) for x in [remote_module_path, async_jid, async_limit, async_module, argsfile]])\n        else:\n            if async_jid is None:\n                if conn.has_pipelining and C.ANSIBLE_SSH_PIPELINING and not C.DEFAULT_KEEP_REMOTE_FILES and not self.su:\n                    in_data = module_data\n                else:\n                    cmd = \"%s\" % (remote_module_path)\n            else:\n                cmd = \" \".join([str(x) for x in [remote_module_path, async_jid, async_limit, async_module]])\n\n        if not shebang:\n            raise errors.AnsibleError(\"module is missing interpreter line\")\n\n\n        cmd = \" \".join([environment_string.strip(), shebang.replace(\"#!\",\"\").strip(), cmd])\n        cmd = cmd.strip()\n\n        if \"tmp\" in tmp and not C.DEFAULT_KEEP_REMOTE_FILES and not persist_files and delete_remote_tmp:\n            if not self.sudo or self.su or self.sudo_user == 'root' or self.su_user == 'root':\n                # not sudoing or sudoing to root, so can cleanup files in the same step\n                cmd = cmd + \"; rm -rf %s >/dev/null 2>&1\" % tmp\n\n        sudoable = True\n        if module_name == \"accelerate\":\n            # always run the accelerate module as the user\n            # specified in the play, not the sudo_user\n            sudoable = False\n\n        if self.su:\n            res = self._low_level_exec_command(conn, cmd, tmp, su=True, in_data=in_data)\n        else:\n            res = self._low_level_exec_command(conn, cmd, tmp, sudoable=sudoable, in_data=in_data)\n\n        if \"tmp\" in tmp and not C.DEFAULT_KEEP_REMOTE_FILES and not persist_files and delete_remote_tmp:\n            if (self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root'):\n            # not sudoing to root, so maybe can't delete files as that other user\n            # have to clean up temp files as original user in a second step\n                cmd2 = \"rm -rf %s >/dev/null 2>&1\" % tmp\n                self._low_level_exec_command(conn, cmd2, tmp, sudoable=False)\n\n        data = utils.parse_json(res['stdout'], from_remote=True)\n        if 'parsed' in data and data['parsed'] == False:\n            data['msg'] += res['stderr']\n        return ReturnData(conn=conn, result=data)\n\n    # *****************************************************\n\n    def _executor(self, host, new_stdin):\n        ''' handler for multiprocessing library '''\n\n        try:\n            fileno = sys.stdin.fileno()\n        except ValueError:\n            fileno = None\n\n        try:\n            self._new_stdin = new_stdin\n            if not new_stdin and fileno is not None:\n                try:\n                    self._new_stdin = os.fdopen(os.dup(fileno))\n                except OSError, e:\n                    # couldn't dupe stdin, most likely because it's\n                    # not a valid file descriptor, so we just rely on\n                    # using the one that was passed in\n                    pass\n\n            exec_rc = self._executor_internal(host, new_stdin)\n            if type(exec_rc) != ReturnData:\n                raise Exception(\"unexpected return type: %s\" % type(exec_rc))\n            # redundant, right?\n            if not exec_rc.comm_ok:\n                self.callbacks.on_unreachable(host, exec_rc.result)\n            return exec_rc\n        except errors.AnsibleError, ae:\n            msg = str(ae)\n            self.callbacks.on_unreachable(host, msg)\n            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg))\n        except Exception:\n            msg = traceback.format_exc()\n            self.callbacks.on_unreachable(host, msg)\n            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg))\n\n    # *****************************************************\n\n    def _executor_internal(self, host, new_stdin):\n        ''' executes any module one or more times '''\n\n        host_variables = self.inventory.get_variables(host, vault_password=self.vault_pass)\n        host_connection = host_variables.get('ansible_connection', self.transport)\n        if host_connection in [ 'paramiko', 'ssh', 'accelerate' ]:\n            port = host_variables.get('ansible_ssh_port', self.remote_port)\n            if port is None:\n                port = C.DEFAULT_REMOTE_PORT\n        else:\n            # fireball, local, etc\n            port = self.remote_port\n\n        # merge the VARS and SETUP caches for this host\n        combined_cache = self.setup_cache.copy()\n        combined_cache.setdefault(host, {}).update(self.vars_cache.get(host, {}))\n        hostvars = HostVars(combined_cache, self.inventory, vault_password=self.vault_pass)\n\n        # use combined_cache and host_variables to template the module_vars\n        # we update the inject variables with the data we're about to template\n        # since some of the variables we'll be replacing may be contained there too\n        module_vars_inject = utils.combine_vars(host_variables, combined_cache.get(host, {}))\n        module_vars_inject = utils.combine_vars(self.module_vars, module_vars_inject)\n        module_vars = template.template(self.basedir, self.module_vars, module_vars_inject)\n\n        inject = {}\n        inject = utils.combine_vars(inject, self.default_vars)\n        inject = utils.combine_vars(inject, host_variables)\n        inject = utils.combine_vars(inject, module_vars)\n        inject = utils.combine_vars(inject, combined_cache.get(host, {}))\n        inject.setdefault('ansible_ssh_user', self.remote_user)\n        inject['hostvars']    = hostvars\n        inject['group_names'] = host_variables.get('group_names', [])\n        inject['groups']      = self.inventory.groups_list()\n        inject['vars']        = self.module_vars\n        inject['defaults']    = self.default_vars\n        inject['environment'] = self.environment\n        inject['playbook_dir'] = self.basedir\n\n        if self.inventory.basedir() is not None:\n            inject['inventory_dir'] = self.inventory.basedir()\n\n        if self.inventory.src() is not None:\n            inject['inventory_file'] = self.inventory.src()\n\n        # allow with_foo to work in playbooks...\n        items = None\n        items_plugin = self.module_vars.get('items_lookup_plugin', None)\n\n        if items_plugin is not None and items_plugin in utils.plugins.lookup_loader:\n\n            basedir = self.basedir\n            if '_original_file' in inject:\n                basedir = os.path.dirname(inject['_original_file'])\n                filesdir = os.path.join(basedir, '..', 'files')\n                if os.path.exists(filesdir):\n                    basedir = filesdir\n\n            items_terms = self.module_vars.get('items_lookup_terms', '')\n            items_terms = template.template(basedir, items_terms, inject)\n            items = utils.plugins.lookup_loader.get(items_plugin, runner=self, basedir=basedir).run(items_terms, inject=inject)\n            # strip out any jinja2 template syntax within\n            # the data returned by the lookup plugin\n            items = utils._clean_data_struct(items, from_remote=True)\n            if type(items) != list:\n                raise errors.AnsibleError(\"lookup plugins have to return a list: %r\" % items)\n\n            if len(items) and utils.is_list_of_strings(items) and self.module_name in [ 'apt', 'yum', 'pkgng' ]:\n                # hack for apt, yum, and pkgng so that with_items maps back into a single module call\n                use_these_items = []\n                for x in items:\n                    inject['item'] = x\n                    if not self.conditional or utils.check_conditional(self.conditional, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                        use_these_items.append(x)\n                inject['item'] = \",\".join(use_these_items)\n                items = None\n\n        # logic to replace complex args if possible\n        complex_args = self.complex_args\n\n        # logic to decide how to run things depends on whether with_items is used\n        if items is None:\n            if isinstance(complex_args, basestring):\n                complex_args = template.template(self.basedir, complex_args, inject, convert_bare=True)\n                complex_args = utils.safe_eval(complex_args)\n                if type(complex_args) != dict:\n                    raise errors.AnsibleError(\"args must be a dictionary, received %s\" % complex_args)\n            return self._executor_internal_inner(host, self.module_name, self.module_args, inject, port, complex_args=complex_args)\n        elif len(items) > 0:\n\n            # executing using with_items, so make multiple calls\n            # TODO: refactor\n\n            if self.background > 0:\n                raise errors.AnsibleError(\"lookup plugins (with_*) cannot be used with async tasks\")\n\n            all_comm_ok = True\n            all_changed = False\n            all_failed = False\n            results = []\n            for x in items:\n                # use a fresh inject for each item\n                this_inject = inject.copy()\n                this_inject['item'] = x\n\n                # TODO: this idiom should be replaced with an up-conversion to a Jinja2 template evaluation\n                if isinstance(self.complex_args, basestring):\n                    complex_args = template.template(self.basedir, self.complex_args, this_inject, convert_bare=True)\n                    complex_args = utils.safe_eval(complex_args)\n                    if type(complex_args) != dict:\n                        raise errors.AnsibleError(\"args must be a dictionary, received %s\" % complex_args)\n                result = self._executor_internal_inner(\n                     host,\n                     self.module_name,\n                     self.module_args,\n                     this_inject,\n                     port,\n                     complex_args=complex_args\n                )\n                results.append(result.result)\n                if result.comm_ok == False:\n                    all_comm_ok = False\n                    all_failed = True\n                    break\n                for x in results:\n                    if x.get('changed') == True:\n                        all_changed = True\n                    if (x.get('failed') == True) or ('failed_when_result' in x and [x['failed_when_result']] or [('rc' in x) and (x['rc'] != 0)])[0]:\n                        all_failed = True\n                        break\n            msg = 'All items completed'\n            if all_failed:\n                msg = \"One or more items failed.\"\n            rd_result = dict(failed=all_failed, changed=all_changed, results=results, msg=msg)\n            if not all_failed:\n                del rd_result['failed']\n            return ReturnData(host=host, comm_ok=all_comm_ok, result=rd_result)\n        else:\n            self.callbacks.on_skipped(host, None)\n            return ReturnData(host=host, comm_ok=True, result=dict(changed=False, skipped=True))\n\n    # *****************************************************\n\n    def _executor_internal_inner(self, host, module_name, module_args, inject, port, is_chained=False, complex_args=None):\n        ''' decides how to invoke a module '''\n\n        # late processing of parameterized sudo_user (with_items,..)\n        if self.sudo_user_var is not None:\n            self.sudo_user = template.template(self.basedir, self.sudo_user_var, inject)\n        if self.su_user_var is not None:\n            self.su_user = template.template(self.basedir, self.su_user_var, inject)\n\n        # allow module args to work as a dictionary\n        # though it is usually a string\n        new_args = \"\"\n        if type(module_args) == dict:\n            for (k,v) in module_args.iteritems():\n                new_args = new_args + \"%s='%s' \" % (k,v)\n            module_args = new_args\n\n        # module_name may be dynamic (but cannot contain {{ ansible_ssh_user }})\n        module_name  = template.template(self.basedir, module_name, inject)\n\n        if module_name in utils.plugins.action_loader:\n            if self.background != 0:\n                raise errors.AnsibleError(\"async mode is not supported with the %s module\" % module_name)\n            handler = utils.plugins.action_loader.get(module_name, self)\n        elif self.background == 0:\n            handler = utils.plugins.action_loader.get('normal', self)\n        else:\n            handler = utils.plugins.action_loader.get('async', self)\n\n        if type(self.conditional) != list:\n            self.conditional = [ self.conditional ]\n\n        for cond in self.conditional:\n\n            if not utils.check_conditional(cond, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                result = utils.jsonify(dict(changed=False, skipped=True))\n                self.callbacks.on_skipped(host, inject.get('item',None))\n                return ReturnData(host=host, result=result)\n\n        if getattr(handler, 'setup', None) is not None:\n            handler.setup(module_name, inject)\n        conn = None\n        actual_host = inject.get('ansible_ssh_host', host)\n        # allow ansible_ssh_host to be templated\n        actual_host = template.template(self.basedir, actual_host, inject, fail_on_undefined=True)\n        actual_port = port\n        actual_user = inject.get('ansible_ssh_user', self.remote_user)\n        actual_pass = inject.get('ansible_ssh_pass', self.remote_pass)\n        actual_transport = inject.get('ansible_connection', self.transport)\n        actual_private_key_file = inject.get('ansible_ssh_private_key_file', self.private_key_file)\n        actual_private_key_file = template.template(self.basedir, actual_private_key_file, inject, fail_on_undefined=True)\n        self.sudo = utils.boolean(inject.get('ansible_sudo', self.sudo))\n        self.sudo_user = inject.get('ansible_sudo_user', self.sudo_user)\n        self.sudo_pass = inject.get('ansible_sudo_pass', self.sudo_pass)\n        self.su = inject.get('ansible_su', self.su)\n        self.su_pass = inject.get('ansible_su_pass', self.su_pass)\n\n        # select default root user in case self.sudo requested\n        # but no user specified; happens e.g. in host vars when\n        # just ansible_sudo=True is specified\n        if self.sudo and self.sudo_user is None:\n            self.sudo_user = 'root'\n\n        if actual_private_key_file is not None:\n            actual_private_key_file = os.path.expanduser(actual_private_key_file)\n\n        if self.accelerate and actual_transport != 'local':\n            #Fix to get the inventory name of the host to accelerate plugin\n            if inject.get('ansible_ssh_host', None):\n                self.accelerate_inventory_host = host\n            else:\n                self.accelerate_inventory_host = None\n            # if we're using accelerated mode, force the\n            # transport to accelerate\n            actual_transport = \"accelerate\"\n            if not self.accelerate_port:\n                self.accelerate_port = C.ACCELERATE_PORT\n\n        if actual_transport in [ 'paramiko', 'ssh', 'accelerate' ]:\n            actual_port = inject.get('ansible_ssh_port', port)\n\n        # the delegated host may have different SSH port configured, etc\n        # and we need to transfer those, and only those, variables\n        delegate_to = inject.get('delegate_to', None)\n        if delegate_to is not None:\n            delegate = self._compute_delegate(delegate_to, actual_pass, inject)\n            actual_transport = delegate['transport']\n            actual_host = delegate['ssh_host']\n            actual_port = delegate['port']\n            actual_user = delegate['user']\n            actual_pass = delegate['pass']\n            actual_private_key_file = delegate['private_key_file']\n            self.sudo_pass = delegate['sudo_pass']\n            inject = delegate['inject']\n\n        # user/pass may still contain variables at this stage\n        actual_user = template.template(self.basedir, actual_user, inject)\n        actual_pass = template.template(self.basedir, actual_pass, inject)\n        self.sudo_pass = template.template(self.basedir, self.sudo_pass, inject)\n\n        # make actual_user available as __magic__ ansible_ssh_user variable\n        inject['ansible_ssh_user'] = actual_user\n\n        try:\n            if actual_transport == 'accelerate':\n                # for accelerate, we stuff both ports into a single\n                # variable so that we don't have to mangle other function\n                # calls just to accomodate this one case\n                actual_port = [actual_port, self.accelerate_port]\n            elif actual_port is not None:\n                actual_port = int(template.template(self.basedir, actual_port, inject))\n        except ValueError, e:\n            result = dict(failed=True, msg=\"FAILED: Configured port \\\"%s\\\" is not a valid port, expected integer\" % actual_port)\n            return ReturnData(host=host, comm_ok=False, result=result)\n\n        try:\n            conn = self.connector.connect(actual_host, actual_port, actual_user, actual_pass, actual_transport, actual_private_key_file)\n            if delegate_to or host != actual_host:\n                conn.delegate = host\n\n\n        except errors.AnsibleConnectionFailed, e:\n            result = dict(failed=True, msg=\"FAILED: %s\" % str(e))\n            return ReturnData(host=host, comm_ok=False, result=result)\n\n        tmp = ''\n        # action plugins may DECLARE via TRANSFERS_FILES = True that they need a remote tmp path working dir\n        if self._early_needs_tmp_path(module_name, handler):\n            tmp = self._make_tmp_path(conn)\n\n        # render module_args and complex_args templates\n        try:\n            # When templating module_args, we need to be careful to ensure\n            # that no variables inadvertantly (or maliciously) add params\n            # to the list of args. We do this by counting the number of k=v\n            # pairs before and after templating.\n            num_args_pre = self._count_module_args(module_args)\n            module_args = template.template(self.basedir, module_args, inject, fail_on_undefined=self.error_on_undefined_vars)\n            num_args_post = self._count_module_args(module_args)\n            if num_args_pre != num_args_post:\n                raise errors.AnsibleError(\"A variable inserted a new parameter into the module args. \" + \\\n                                          \"Be sure to quote variables if they contain equal signs (for example: \\\"{{var}}\\\").\")\n            # And we also make sure nothing added in special flags for things\n            # like the command/shell module (ie. #USE_SHELL)\n            if '#USE_SHELL' in module_args:\n                raise errors.AnsibleError(\"A variable tried to add #USE_SHELL to the module arguments.\")\n            complex_args = template.template(self.basedir, complex_args, inject, fail_on_undefined=self.error_on_undefined_vars)\n        except jinja2.exceptions.UndefinedError, e:\n            raise errors.AnsibleUndefinedVariable(\"One or more undefined variables: %s\" % str(e))\n\n\n        result = handler.run(conn, tmp, module_name, module_args, inject, complex_args)\n        # Code for do until feature\n        until = self.module_vars.get('until', None)\n        if until is not None and result.comm_ok:\n            inject[self.module_vars.get('register')] = result.result\n            cond = template.template(self.basedir, until, inject, expand_lists=False)\n            if not utils.check_conditional(cond,  self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                retries = self.module_vars.get('retries')\n                delay   = self.module_vars.get('delay')\n                for x in range(1, int(retries) + 1):\n                    # template the delay, cast to float and sleep\n                    delay = template.template(self.basedir, delay, inject, expand_lists=False)\n                    delay = float(delay)\n                    time.sleep(delay)\n                    tmp = ''\n                    if self._early_needs_tmp_path(module_name, handler):\n                        tmp = self._make_tmp_path(conn)\n                    result = handler.run(conn, tmp, module_name, module_args, inject, complex_args)\n                    result.result['attempts'] = x\n                    vv(\"Result from run %i is: %s\" % (x, result.result))\n                    inject[self.module_vars.get('register')] = result.result\n                    cond = template.template(self.basedir, until, inject, expand_lists=False)\n                    if utils.check_conditional(cond, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                        break\n                if result.result['attempts'] == retries and not utils.check_conditional(cond, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars):\n                    result.result['failed'] = True \n                    result.result['msg'] = \"Task failed as maximum retries was encountered\"\n            else:\n                result.result['attempts'] = 0\n        conn.close()\n\n        if not result.comm_ok:\n            # connection or parsing errors...\n            self.callbacks.on_unreachable(host, result.result)\n        else:\n            data = result.result\n\n            # https://github.com/ansible/ansible/issues/4958\n            if hasattr(sys.stdout, \"isatty\"):\n                if \"stdout\" in data and sys.stdout.isatty():\n                    if not string_functions.isprintable(data['stdout']):\n                        data['stdout'] = ''\n\n            if 'item' in inject:\n                result.result['item'] = inject['item']\n\n            result.result['invocation'] = dict(\n                module_args=module_args,\n                module_name=module_name\n            )\n\n            changed_when = self.module_vars.get('changed_when')\n            failed_when = self.module_vars.get('failed_when')\n            if (changed_when is not None or failed_when is not None) and self.background == 0:\n                register = self.module_vars.get('register')\n                if register is not None:\n                    if 'stdout' in data:\n                        data['stdout_lines'] = data['stdout'].splitlines()\n                    inject[register] = data\n                # only run the final checks if the async_status has finished,\n                # or if we're not running an async_status check at all\n                if (module_name == 'async_status' and \"finished\" in data) or module_name != 'async_status':\n                    if changed_when is not None and 'skipped' not in data:\n                        data['changed'] = utils.check_conditional(changed_when, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars)\n                    if failed_when is not None and 'skipped' not in data:\n                        data['failed_when_result'] = data['failed'] = utils.check_conditional(failed_when, self.basedir, inject, fail_on_undefined=self.error_on_undefined_vars)\n\n            if is_chained:\n                # no callbacks\n                return result\n            if 'skipped' in data:\n                self.callbacks.on_skipped(host, inject.get('item',None))\n            elif not result.is_successful():\n                ignore_errors = self.module_vars.get('ignore_errors', False)\n                self.callbacks.on_failed(host, data, ignore_errors)\n            else:\n                if self.diff:\n                    self.callbacks.on_file_diff(conn.host, result.diff)\n                self.callbacks.on_ok(host, data)\n        return result\n\n    def _early_needs_tmp_path(self, module_name, handler):\n        ''' detect if a tmp path should be created before the handler is called '''\n        if module_name in utils.plugins.action_loader:\n          return getattr(handler, 'TRANSFERS_FILES', False)\n        # other modules never need tmp path at early stage\n        return False\n\n    def _late_needs_tmp_path(self, conn, tmp, module_style):\n        if \"tmp\" in tmp:\n            # tmp has already been created\n            return False\n        if not conn.has_pipelining or not C.ANSIBLE_SSH_PIPELINING or C.DEFAULT_KEEP_REMOTE_FILES or self.su:\n            # tmp is necessary to store module source code\n            return True\n        if not conn.has_pipelining:\n            # tmp is necessary to store the module source code\n            # or we want to keep the files on the target system\n            return True\n        if module_style != \"new\":\n            # even when conn has pipelining, old style modules need tmp to store arguments\n            return True\n        return False\n    \n\n    # *****************************************************\n\n    def _low_level_exec_command(self, conn, cmd, tmp, sudoable=False,\n                                executable=None, su=False, in_data=None):\n        ''' execute a command string over SSH, return the output '''\n\n        if executable is None:\n            executable = C.DEFAULT_EXECUTABLE\n\n        sudo_user = self.sudo_user\n        su_user = self.su_user\n\n        # compare connection user to (su|sudo)_user and disable if the same\n        if hasattr(conn, 'user'):\n            if (not su and conn.user == sudo_user) or (su and conn.user == su_user):\n                sudoable = False\n                su = False\n        else:\n            # assume connection type is local if no user attribute\n            this_user = getpass.getuser()\n            if (not su and this_user == sudo_user) or (su and this_user == su_user):\n                sudoable = False\n                su = False\n\n        if su:\n            rc, stdin, stdout, stderr = conn.exec_command(cmd,\n                                                          tmp,\n                                                          su=su,\n                                                          su_user=su_user,\n                                                          executable=executable,\n                                                          in_data=in_data)\n        else:\n            rc, stdin, stdout, stderr = conn.exec_command(cmd,\n                                                          tmp,\n                                                          sudo_user,\n                                                          sudoable=sudoable,\n                                                          executable=executable,\n                                                          in_data=in_data)\n\n        if type(stdout) not in [ str, unicode ]:\n            out = ''.join(stdout.readlines())\n        else:\n            out = stdout\n\n        if type(stderr) not in [ str, unicode ]:\n            err = ''.join(stderr.readlines())\n        else:\n            err = stderr\n\n        if rc is not None:\n            return dict(rc=rc, stdout=out, stderr=err)\n        else:\n            return dict(stdout=out, stderr=err)\n\n    # *****************************************************\n\n    def _remote_md5(self, conn, tmp, path):\n        ''' takes a remote md5sum without requiring python, and returns 1 if no file '''\n\n        path = pipes.quote(path)\n        # The following test needs to be SH-compliant.  BASH-isms will\n        # not work if /bin/sh points to a non-BASH shell.\n        test = \"rc=0; [ -r \\\"%s\\\" ] || rc=2; [ -f \\\"%s\\\" ] || rc=1; [ -d \\\"%s\\\" ] && echo 3 && exit 0\" % ((path,) * 3)\n        md5s = [\n            \"(/usr/bin/md5sum %s 2>/dev/null)\" % path,          # Linux\n            \"(/sbin/md5sum -q %s 2>/dev/null)\" % path,          # ?\n            \"(/usr/bin/digest -a md5 %s 2>/dev/null)\" % path,   # Solaris 10+\n            \"(/sbin/md5 -q %s 2>/dev/null)\" % path,             # Freebsd\n            \"(/usr/bin/md5 -n %s 2>/dev/null)\" % path,          # Netbsd\n            \"(/bin/md5 -q %s 2>/dev/null)\" % path,              # Openbsd\n            \"(/usr/bin/csum -h MD5 %s 2>/dev/null)\" % path,     # AIX\n            \"(/bin/csum -h MD5 %s 2>/dev/null)\" % path          # AIX also\n        ]\n\n        cmd = \" || \".join(md5s)\n        cmd = \"%s; %s || (echo \\\"${rc}  %s\\\")\" % (test, cmd, path)\n        data = self._low_level_exec_command(conn, cmd, tmp, sudoable=True)\n        data2 = utils.last_non_blank_line(data['stdout'])\n        try:\n            if data2 == '':\n                # this may happen if the connection to the remote server\n                # failed, so just return \"INVALIDMD5SUM\" to avoid errors\n                return \"INVALIDMD5SUM\"\n            else:\n                return data2.split()[0]\n        except IndexError:\n            sys.stderr.write(\"warning: md5sum command failed unusually, please report this to the list so it can be fixed\\n\")\n            sys.stderr.write(\"command: %s\\n\" % md5s)\n            sys.stderr.write(\"----\\n\")\n            sys.stderr.write(\"output: %s\\n\" % data)\n            sys.stderr.write(\"----\\n\")\n            # this will signal that it changed and allow things to keep going\n            return \"INVALIDMD5SUM\"\n\n    # *****************************************************\n\n    def _make_tmp_path(self, conn):\n        ''' make and return a temporary path on a remote box '''\n\n        basefile = 'ansible-tmp-%s-%s' % (time.time(), random.randint(0, 2**48))\n        basetmp = os.path.join(C.DEFAULT_REMOTE_TMP, basefile)\n        if (self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root') and basetmp.startswith('$HOME'):\n            basetmp = os.path.join('/tmp', basefile)\n\n        cmd = 'mkdir -p %s' % basetmp\n        if self.remote_user != 'root' or ((self.sudo and self.sudo_user != 'root') or (self.su and self.su_user != 'root')):\n            cmd += ' && chmod a+rx %s' % basetmp\n        cmd += ' && echo %s' % basetmp\n\n        result = self._low_level_exec_command(conn, cmd, None, sudoable=False)\n\n        # error handling on this seems a little aggressive?\n        if result['rc'] != 0:\n            if result['rc'] == 5:\n                output = 'Authentication failure.'\n            elif result['rc'] == 255 and self.transport in ['ssh']:\n                if utils.VERBOSITY > 3:\n                    output = 'SSH encountered an unknown error. The output was:\\n%s' % (result['stdout']+result['stderr'])\n                else:\n                    output = 'SSH encountered an unknown error during the connection. We recommend you re-run the command using -vvvv, which will enable SSH debugging output to help diagnose the issue'\n            else:\n                output = 'Authentication or permission failure.  In some cases, you may have been able to authenticate and did not have permissions on the remote directory. Consider changing the remote temp path in ansible.cfg to a path rooted in \"/tmp\". Failed command was: %s, exited with result %d' % (cmd, result['rc'])\n            if 'stdout' in result and result['stdout'] != '':\n                output = output + \": %s\" % result['stdout']\n            raise errors.AnsibleError(output)\n\n        rc = utils.last_non_blank_line(result['stdout']).strip() + '/'\n        # Catch failure conditions, files should never be\n        # written to locations in /.\n        if rc == '/': \n            raise errors.AnsibleError('failed to resolve remote temporary directory from %s: `%s` returned empty string' % (basetmp, cmd))\n        return rc\n\n    # *****************************************************\n\n    def _remove_tmp_path(self, conn, tmp_path):\n        ''' Remove a tmp_path. '''\n\n        if \"-tmp-\" in tmp_path:\n            cmd = \"rm -rf %s >/dev/null 2>&1\" % tmp_path\n            self._low_level_exec_command(conn, cmd, None, sudoable=False)\n            # If we have gotten here we have a working ssh configuration.\n            # If ssh breaks we could leave tmp directories out on the remote system.\n\n    # *****************************************************\n\n    def _copy_module(self, conn, tmp, module_name, module_args, inject, complex_args=None):\n        ''' transfer a module over SFTP, does not run it '''\n        (\n        module_style,\n        module_shebang,\n        module_data\n        ) = self._configure_module(conn, module_name, module_args, inject, complex_args)\n        module_remote_path = os.path.join(tmp, module_name)\n        \n        self._transfer_str(conn, tmp, module_name, module_data)\n         \n        return (module_remote_path, module_style, module_shebang)\n\n    # *****************************************************\n\n    def _configure_module(self, conn, module_name, module_args, inject, complex_args=None):\n        ''' find module and configure it '''\n\n        # Search module path(s) for named module.\n        module_path = utils.plugins.module_finder.find_plugin(module_name)\n        if module_path is None:\n            raise errors.AnsibleFileNotFound(\"module %s not found in %s\" % (module_name, utils.plugins.module_finder.print_paths()))\n\n\n        # insert shared code and arguments into the module\n        (module_data, module_style, module_shebang) = module_replacer.modify_module(\n            module_path, complex_args, module_args, inject\n        )\n\n        return (module_style, module_shebang, module_data)\n\n\n    # *****************************************************\n\n\n    def _parallel_exec(self, hosts):\n        ''' handles mulitprocessing when more than 1 fork is required '''\n\n        manager = multiprocessing.Manager()\n        job_queue = manager.Queue()\n        for host in hosts:\n            job_queue.put(host)\n        result_queue = manager.Queue()\n\n        try:\n            fileno = sys.stdin.fileno()\n        except ValueError:\n            fileno = None\n\n        workers = []\n        for i in range(self.forks):\n            new_stdin = None\n            if fileno is not None:\n                try:\n                    new_stdin = os.fdopen(os.dup(fileno))\n                except OSError, e:\n                    # couldn't dupe stdin, most likely because it's\n                    # not a valid file descriptor, so we just rely on\n                    # using the one that was passed in\n                    pass\n            prc = multiprocessing.Process(target=_executor_hook,\n                args=(job_queue, result_queue, new_stdin))\n            prc.start()\n            workers.append(prc)\n\n        try:\n            for worker in workers:\n                worker.join()\n        except KeyboardInterrupt:\n            for worker in workers:\n                worker.terminate()\n                worker.join()\n        \n        results = []\n        try:\n            while not result_queue.empty():\n                results.append(result_queue.get(block=False))\n        except socket.error:\n            raise errors.AnsibleError(\"<interrupted>\")\n        return results\n\n    # *****************************************************\n\n    def _partition_results(self, results):\n        ''' separate results by ones we contacted & ones we didn't '''\n\n        if results is None:\n            return None\n        results2 = dict(contacted={}, dark={})\n\n        for result in results:\n            host = result.host\n            if host is None:\n                raise Exception(\"internal error, host not set\")\n            if result.communicated_ok():\n                results2[\"contacted\"][host] = result.result\n            else:\n                results2[\"dark\"][host] = result.result\n\n        # hosts which were contacted but never got a chance to return\n        for host in self.run_hosts:\n            if not (host in results2['dark'] or host in results2['contacted']):\n                results2[\"dark\"][host] = {}\n        return results2\n\n    # *****************************************************\n\n    def run(self):\n        ''' xfer & run module on all matched hosts '''\n\n        # find hosts that match the pattern\n        if not self.run_hosts:\n            self.run_hosts = self.inventory.list_hosts(self.pattern)\n        hosts = self.run_hosts\n        if len(hosts) == 0:\n            self.callbacks.on_no_hosts()\n            return dict(contacted={}, dark={})\n\n        global multiprocessing_runner\n        multiprocessing_runner = self\n        results = None\n\n        # Check if this is an action plugin. Some of them are designed\n        # to be ran once per group of hosts. Example module: pause,\n        # run once per hostgroup, rather than pausing once per each\n        # host.\n        p = utils.plugins.action_loader.get(self.module_name, self)\n\n        if self.forks == 0 or self.forks > len(hosts):\n            self.forks = len(hosts)\n\n        if p and getattr(p, 'BYPASS_HOST_LOOP', None):\n\n            # Expose the current hostgroup to the bypassing plugins\n            self.host_set = hosts\n            # We aren't iterating over all the hosts in this\n            # group. So, just pick the first host in our group to\n            # construct the conn object with.\n            result_data = self._executor(hosts[0], None).result\n            # Create a ResultData item for each host in this group\n            # using the returned result. If we didn't do this we would\n            # get false reports of dark hosts.\n            results = [ ReturnData(host=h, result=result_data, comm_ok=True) \\\n                           for h in hosts ]\n            del self.host_set\n\n        elif self.forks > 1:\n            try:\n                results = self._parallel_exec(hosts)\n            except IOError, ie:\n                print ie.errno\n                if ie.errno == 32:\n                    # broken pipe from Ctrl+C\n                    raise errors.AnsibleError(\"interrupted\")\n                raise\n        else:\n            results = [ self._executor(h, None) for h in hosts ]\n\n        return self._partition_results(results)\n\n    # *****************************************************\n\n    def run_async(self, time_limit):\n        ''' Run this module asynchronously and return a poller. '''\n\n        self.background = time_limit\n        results = self.run()\n        return results, poller.AsyncPoller(results, self)\n\n    # *****************************************************\n\n    def noop_on_check(self, inject):\n        ''' Should the runner run in check mode or not ? '''\n\n        # initialize self.always_run on first call\n        if self.always_run is None:\n            self.always_run = self.module_vars.get('always_run', False)\n            self.always_run = check_conditional(\n                self.always_run, self.basedir, inject, fail_on_undefined=True)\n\n        return (self.check and not self.always_run)\n", "# (c) 2013-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#           Stephen Fromm <sfromm@gmail.com>\n#           Brian Coca  <briancoca+dev@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n\nimport os\nimport os.path\nimport pipes\nimport shutil\nimport tempfile\nimport base64\nfrom ansible import utils\nfrom ansible.runner.return_data import ReturnData\n\nclass ActionModule(object):\n\n    TRANSFERS_FILES = True\n\n    def __init__(self, runner):\n        self.runner = runner\n\n    def _assemble_from_fragments(self, src_path, delimiter=None, compiled_regexp=None):\n        ''' assemble a file from a directory of fragments '''\n        tmpfd, temp_path = tempfile.mkstemp()\n        tmp = os.fdopen(tmpfd,'w')\n        delimit_me = False\n        add_newline = False\n\n        for f in sorted(os.listdir(src_path)):\n            if compiled_regexp and not compiled_regexp.search(f):\n                continue\n            fragment = \"%s/%s\" % (src_path, f)\n            if not os.path.isfile(fragment):\n                continue\n            fragment_content = file(fragment).read()\n\n            # always put a newline between fragments if the previous fragment didn't end with a newline.\n            if add_newline:\n                tmp.write('\\n')\n\n            # delimiters should only appear between fragments\n            if delimit_me:\n                if delimiter:\n                    # un-escape anything like newlines\n                    delimiter = delimiter.decode('unicode-escape')\n                    tmp.write(delimiter)\n                    # always make sure there's a newline after the\n                    # delimiter, so lines don't run together\n                    if delimiter[-1] != '\\n':\n                        tmp.write('\\n')\n\n            tmp.write(fragment_content)\n            delimit_me = True\n            if fragment_content.endswith('\\n'):\n                add_newline = False\n            else:\n                add_newline = True\n\n        tmp.close()\n        return temp_path\n\n    def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **kwargs):\n\n        # load up options\n        options  = {}\n        if complex_args:\n            options.update(complex_args)\n\n        options.update(utils.parse_kv(module_args))\n\n        src = options.get('src', None)\n        dest = options.get('dest', None)\n        delimiter = options.get('delimiter', None)\n        remote_src = utils.boolean(options.get('remote_src', 'yes'))\n\n\n        if src is None or dest is None:\n            result = dict(failed=True, msg=\"src and dest are required\")\n            return ReturnData(conn=conn, comm_ok=False, result=result)\n\n        if remote_src:\n            return self.runner._execute_module(conn, tmp, 'assemble', module_args, inject=inject, complex_args=complex_args)\n        elif '_original_file' in inject:\n            src = utils.path_dwim_relative(inject['_original_file'], 'files', src, self.runner.basedir)\n        else:\n            # the source is local, so expand it here\n            src = os.path.expanduser(src)\n\n        # Does all work assembling the file\n        path = self._assemble_from_fragments(src, delimiter)\n\n        pathmd5 = utils.md5s(path)\n        remote_md5 = self.runner._remote_md5(conn, tmp, dest)\n\n        if pathmd5 != remote_md5:\n            resultant = file(path).read()\n            if self.runner.diff:\n                dest_result = self.runner._execute_module(conn, tmp, 'slurp', \"path=%s\" % dest, inject=inject, persist_files=True)\n                if 'content' in dest_result.result:\n                    dest_contents = dest_result.result['content']\n                    if dest_result.result['encoding'] == 'base64':\n                        dest_contents = base64.b64decode(dest_contents)\n                    else:\n                        raise Exception(\"unknown encoding, failed: %s\" % dest_result.result)\n            xfered = self.runner._transfer_str(conn, tmp, 'src', resultant)\n\n            # fix file permissions when the copy is done as a different user\n            if self.runner.sudo and self.runner.sudo_user != 'root':\n                self.runner._low_level_exec_command(conn, \"chmod a+r %s\" % xfered, tmp)\n\n            # run the copy module\n            new_module_args = dict(\n                src=xfered,\n                dest=dest,\n                original_basename=os.path.basename(src),\n            )\n            module_args_tmp = utils.merge_module_args(module_args, new_module_args)\n\n            if self.runner.noop_on_check(inject):\n                return ReturnData(conn=conn, comm_ok=True, result=dict(changed=True), diff=dict(before_header=dest, after_header=src, after=resultant))\n            else:\n                res = self.runner._execute_module(conn, tmp, 'copy', module_args_tmp, inject=inject)\n                res.diff = dict(after=resultant)\n                return res\n        else:\n            new_module_args = dict(\n                src=xfered,\n                dest=dest,\n                original_basename=os.path.basename(src),\n            )\n            module_args_tmp = utils.merge_module_args(module_args, new_module_args)\n\n            return self.runner._execute_module(conn, tmp, 'file', module_args_tmp, inject=inject)\n", "# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\n\nfrom ansible import utils\nimport ansible.constants as C\nimport ansible.utils.template as template\nfrom ansible import errors\nfrom ansible.runner.return_data import ReturnData\nimport base64\nimport json\nimport stat\nimport tempfile\nimport pipes\n\n## fixes https://github.com/ansible/ansible/issues/3518\n# http://mypy.pythonblogs.com/12_mypy/archive/1253_workaround_for_python_bug_ascii_codec_cant_encode_character_uxa0_in_position_111_ordinal_not_in_range128.html\nimport sys\nreload(sys)\nsys.setdefaultencoding(\"utf8\")\n\n\nclass ActionModule(object):\n\n    def __init__(self, runner):\n        self.runner = runner\n\n    def run(self, conn, tmp_path, module_name, module_args, inject, complex_args=None, **kwargs):\n        ''' handler for file transfer operations '''\n\n        # load up options\n        options = {}\n        if complex_args:\n            options.update(complex_args)\n        options.update(utils.parse_kv(module_args))\n        source  = options.get('src', None)\n        content = options.get('content', None)\n        dest    = options.get('dest', None)\n        raw     = utils.boolean(options.get('raw', 'no'))\n        force   = utils.boolean(options.get('force', 'yes'))\n\n        # content with newlines is going to be escaped to safely load in yaml\n        # now we need to unescape it so that the newlines are evaluated properly\n        # when writing the file to disk\n        if content:\n            if isinstance(content, unicode):\n                try:\n                    content = content.decode('unicode-escape')\n                except UnicodeDecodeError:\n                    pass\n\n        if (source is None and content is None and not 'first_available_file' in inject) or dest is None:\n            result=dict(failed=True, msg=\"src (or content) and dest are required\")\n            return ReturnData(conn=conn, result=result)\n        elif (source is not None or 'first_available_file' in inject) and content is not None:\n            result=dict(failed=True, msg=\"src and content are mutually exclusive\")\n            return ReturnData(conn=conn, result=result)\n\n        # Check if the source ends with a \"/\"\n        source_trailing_slash = False\n        if source:\n            source_trailing_slash = source.endswith(\"/\")\n\n        # Define content_tempfile in case we set it after finding content populated.\n        content_tempfile = None\n\n        # If content is defined make a temp file and write the content into it.\n        if content is not None:\n            try:\n                # If content comes to us as a dict it should be decoded json.\n                # We need to encode it back into a string to write it out.\n                if type(content) is dict:\n                    content_tempfile = self._create_content_tempfile(json.dumps(content))\n                else:\n                    content_tempfile = self._create_content_tempfile(content)\n                source = content_tempfile\n            except Exception, err:\n                result = dict(failed=True, msg=\"could not write content temp file: %s\" % err)\n                return ReturnData(conn=conn, result=result)\n        # if we have first_available_file in our vars\n        # look up the files and use the first one we find as src\n        elif 'first_available_file' in inject:\n            found = False\n            for fn in inject.get('first_available_file'):\n                fn_orig = fn\n                fnt = template.template(self.runner.basedir, fn, inject)\n                fnd = utils.path_dwim(self.runner.basedir, fnt)\n                if not os.path.exists(fnd) and '_original_file' in inject:\n                    fnd = utils.path_dwim_relative(inject['_original_file'], 'files', fnt, self.runner.basedir, check=False)\n                if os.path.exists(fnd):\n                    source = fnd\n                    found = True\n                    break\n            if not found:\n                results = dict(failed=True, msg=\"could not find src in first_available_file list\")\n                return ReturnData(conn=conn, result=results)\n        else:\n            source = template.template(self.runner.basedir, source, inject)\n            if '_original_file' in inject:\n                source = utils.path_dwim_relative(inject['_original_file'], 'files', source, self.runner.basedir)\n            else:\n                source = utils.path_dwim(self.runner.basedir, source)\n\n        # A list of source file tuples (full_path, relative_path) which will try to copy to the destination\n        source_files = []\n\n        # If source is a directory populate our list else source is a file and translate it to a tuple.\n        if os.path.isdir(source):\n            # Get the amount of spaces to remove to get the relative path.\n            if source_trailing_slash:\n                sz = len(source) + 1\n            else:\n                sz = len(source.rsplit('/', 1)[0]) + 1\n\n            # Walk the directory and append the file tuples to source_files.\n            for base_path, sub_folders, files in os.walk(source):\n                for file in files:\n                    full_path = os.path.join(base_path, file)\n                    rel_path = full_path[sz:]\n                    source_files.append((full_path, rel_path))\n\n            # If it's recursive copy, destination is always a dir,\n            # explicitly mark it so (note - copy module relies on this).\n            if not dest.endswith(\"/\"):\n                dest += \"/\"\n        else:\n            source_files.append((source, os.path.basename(source)))\n\n        changed = False\n        diffs = []\n        module_result = {\"changed\": False}\n\n        # A register for if we executed a module.\n        # Used to cut down on command calls when not recursive.\n        module_executed = False\n\n        # Tell _execute_module to delete the file if there is one file.\n        delete_remote_tmp = (len(source_files) == 1)\n\n        # If this is a recursive action create a tmp_path that we can share as the _exec_module create is too late.\n        if not delete_remote_tmp:\n            if \"-tmp-\" not in tmp_path:\n                tmp_path = self.runner._make_tmp_path(conn)\n\n        for source_full, source_rel in source_files:\n            # Generate the MD5 hash of the local file.\n            local_md5 = utils.md5(source_full)\n\n            # If local_md5 is not defined we can't find the file so we should fail out.\n            if local_md5 is None:\n                result = dict(failed=True, msg=\"could not find src=%s\" % source_full)\n                return ReturnData(conn=conn, result=result)\n\n            # This is kind of optimization - if user told us destination is\n            # dir, do path manipulation right away, otherwise we still check\n            # for dest being a dir via remote call below.\n            if dest.endswith(\"/\"):\n                dest_file = os.path.join(dest, source_rel)\n            else:\n                dest_file = dest\n\n            # Attempt to get the remote MD5 Hash.\n            remote_md5 = self.runner._remote_md5(conn, tmp_path, dest_file)\n\n            if remote_md5 == '3':\n                # The remote_md5 was executed on a directory.\n                if content is not None:\n                    # If source was defined as content remove the temporary file and fail out.\n                    self._remove_tempfile_if_content_defined(content, content_tempfile)\n                    result = dict(failed=True, msg=\"can not use content with a dir as dest\")\n                    return ReturnData(conn=conn, result=result)\n                else:\n                    # Append the relative source location to the destination and retry remote_md5.\n                    dest_file = os.path.join(dest, source_rel)\n                    remote_md5 = self.runner._remote_md5(conn, tmp_path, dest_file)\n\n            if remote_md5 != '1' and not force:\n                # remote_file does not exist so continue to next iteration.\n                continue\n\n            if local_md5 != remote_md5:\n                # The MD5 hashes don't match and we will change or error out.\n                changed = True\n\n                # Create a tmp_path if missing only if this is not recursive.\n                # If this is recursive we already have a tmp_path.\n                if delete_remote_tmp:\n                    if \"-tmp-\" not in tmp_path:\n                        tmp_path = self.runner._make_tmp_path(conn)\n\n                if self.runner.diff and not raw:\n                    diff = self._get_diff_data(conn, tmp_path, inject, dest_file, source_full)\n                else:\n                    diff = {}\n\n                if self.runner.noop_on_check(inject):\n                    self._remove_tempfile_if_content_defined(content, content_tempfile)\n                    diffs.append(diff)\n                    changed = True\n                    module_result = dict(changed=True)\n                    continue\n\n                # Define a remote directory that we will copy the file to.\n                tmp_src = tmp_path + 'source'\n\n                if not raw:\n                    conn.put_file(source_full, tmp_src)\n                else:\n                    conn.put_file(source_full, dest_file)\n\n                # We have copied the file remotely and no longer require our content_tempfile\n                self._remove_tempfile_if_content_defined(content, content_tempfile)\n\n                # fix file permissions when the copy is done as a different user\n                if self.runner.sudo and self.runner.sudo_user != 'root' and not raw:\n                    self.runner._low_level_exec_command(conn, \"chmod a+r %s\" % tmp_src, tmp_path)\n\n                if raw:\n                    # Continue to next iteration if raw is defined.\n                    continue\n\n                # Run the copy module\n\n                # src and dest here come after original and override them\n                # we pass dest only to make sure it includes trailing slash in case of recursive copy\n                new_module_args = dict(\n                    src=tmp_src,\n                    dest=dest,\n                    original_basename=source_rel\n                )\n\n                if self.runner.no_log:\n                    new_module_args['NO_LOG'] = True\n\n                module_args_tmp = utils.merge_module_args(module_args, new_module_args)\n\n                module_return = self.runner._execute_module(conn, tmp_path, 'copy', module_args_tmp, inject=inject, complex_args=complex_args, delete_remote_tmp=delete_remote_tmp)\n                module_executed = True\n\n            else:\n                # no need to transfer the file, already correct md5, but still need to call\n                # the file module in case we want to change attributes\n                self._remove_tempfile_if_content_defined(content, content_tempfile)\n\n                if raw:\n                    # Continue to next iteration if raw is defined.\n                    # self.runner._remove_tmp_path(conn, tmp_path)\n                    continue\n\n                tmp_src = tmp_path + source_rel\n\n                # Build temporary module_args.\n                new_module_args = dict(\n                    src=tmp_src,\n                    dest=dest,\n                )\n                if self.runner.noop_on_check(inject):\n                    new_module_args['CHECKMODE'] = True\n                if self.runner.no_log:\n                    new_module_args['NO_LOG'] = True\n\n                module_args_tmp = utils.merge_module_args(module_args, new_module_args)\n\n                # Execute the file module.\n                module_return = self.runner._execute_module(conn, tmp_path, 'file', module_args_tmp, inject=inject, complex_args=complex_args, delete_remote_tmp=delete_remote_tmp)\n                module_executed = True\n\n            module_result = module_return.result\n            if not module_result.get('md5sum'):\n                module_result['md5sum'] = local_md5\n            if module_result.get('failed') == True:\n                return module_return\n            if module_result.get('changed') == True:\n                changed = True\n\n        # Delete tmp_path if we were recursive or if we did not execute a module.\n        if (not C.DEFAULT_KEEP_REMOTE_FILES and not delete_remote_tmp) \\\n            or (not C.DEFAULT_KEEP_REMOTE_FILES and delete_remote_tmp and not module_executed):\n            self.runner._remove_tmp_path(conn, tmp_path)\n\n        # the file module returns the file path as 'path', but \n        # the copy module uses 'dest', so add it if it's not there\n        if 'path' in module_result and 'dest' not in module_result:\n            module_result['dest'] = module_result['path']\n\n        # TODO: Support detailed status/diff for multiple files\n        if len(source_files) == 1:\n            result = module_result\n        else:\n            result = dict(dest=dest, src=source, changed=changed)\n        if len(diffs) == 1:\n            return ReturnData(conn=conn, result=result, diff=diffs[0])\n        else:\n            return ReturnData(conn=conn, result=result)\n\n    def _create_content_tempfile(self, content):\n        ''' Create a tempfile containing defined content '''\n        fd, content_tempfile = tempfile.mkstemp()\n        f = os.fdopen(fd, 'w')\n        try:\n            f.write(content)\n        except Exception, err:\n            os.remove(content_tempfile)\n            raise Exception(err)\n        finally:\n            f.close()\n        return content_tempfile\n\n    def _get_diff_data(self, conn, tmp, inject, destination, source):\n        peek_result = self.runner._execute_module(conn, tmp, 'file', \"path=%s diff_peek=1\" % destination, inject=inject, persist_files=True)\n\n        if not peek_result.is_successful():\n            return {}\n\n        diff = {}\n        if peek_result.result['state'] == 'absent':\n            diff['before'] = ''\n        elif peek_result.result['appears_binary']:\n            diff['dst_binary'] = 1\n        elif peek_result.result['size'] > utils.MAX_FILE_SIZE_FOR_DIFF:\n            diff['dst_larger'] = utils.MAX_FILE_SIZE_FOR_DIFF\n        else:\n            dest_result = self.runner._execute_module(conn, tmp, 'slurp', \"path=%s\" % destination, inject=inject, persist_files=True)\n            if 'content' in dest_result.result:\n                dest_contents = dest_result.result['content']\n                if dest_result.result['encoding'] == 'base64':\n                    dest_contents = base64.b64decode(dest_contents)\n                else:\n                    raise Exception(\"unknown encoding, failed: %s\" % dest_result.result)\n                diff['before_header'] = destination\n                diff['before'] = dest_contents\n\n        src = open(source)\n        src_contents = src.read(8192)\n        st = os.stat(source)\n        if \"\\x00\" in src_contents:\n            diff['src_binary'] = 1\n        elif st[stat.ST_SIZE] > utils.MAX_FILE_SIZE_FOR_DIFF:\n            diff['src_larger'] = utils.MAX_FILE_SIZE_FOR_DIFF\n        else:\n            src.seek(0)\n            diff['after_header'] = source\n            diff['after'] = src.read()\n\n        return diff\n\n    def _remove_tempfile_if_content_defined(self, content, content_tempfile):\n        if content is not None:\n            os.remove(content_tempfile)\n\n    \n    def _result_key_merge(self, options, results):\n        # add keys to file module results to mimic copy\n        if 'path' in results.result and 'dest' not in results.result:\n            results.result['dest'] = results.result['path']\n            del results.result['path']\n        return results\n", "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport pipes\nfrom ansible.utils import template\nfrom ansible import utils\nfrom ansible import errors\nfrom ansible.runner.return_data import ReturnData\nimport base64\n\nclass ActionModule(object):\n\n    TRANSFERS_FILES = True\n\n    def __init__(self, runner):\n        self.runner = runner\n\n    def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **kwargs):\n        ''' handler for template operations '''\n\n        # note: since this module just calls the copy module, the --check mode support\n        # can be implemented entirely over there\n\n        if not self.runner.is_playbook:\n            raise errors.AnsibleError(\"in current versions of ansible, templates are only usable in playbooks\")\n\n        # load up options\n        options  = {}\n        if complex_args:\n            options.update(complex_args)\n        options.update(utils.parse_kv(module_args))\n\n        source   = options.get('src', None)\n        dest     = options.get('dest', None)\n\n        if (source is None and 'first_available_file' not in inject) or dest is None:\n            result = dict(failed=True, msg=\"src and dest are required\")\n            return ReturnData(conn=conn, comm_ok=False, result=result)\n\n        # if we have first_available_file in our vars\n        # look up the files and use the first one we find as src\n\n        if 'first_available_file' in inject:\n            found = False\n            for fn in self.runner.module_vars.get('first_available_file'):\n                fn_orig = fn\n                fnt = template.template(self.runner.basedir, fn, inject)\n                fnd = utils.path_dwim(self.runner.basedir, fnt)\n                if not os.path.exists(fnd) and '_original_file' in inject:\n                    fnd = utils.path_dwim_relative(inject['_original_file'], 'templates', fnt, self.runner.basedir, check=False)\n                if os.path.exists(fnd):\n                    source = fnd\n                    found = True\n                    break\n            if not found:\n                result = dict(failed=True, msg=\"could not find src in first_available_file list\")\n                return ReturnData(conn=conn, comm_ok=False, result=result)\n        else:\n            source = template.template(self.runner.basedir, source, inject)\n                \n            if '_original_file' in inject:\n                source = utils.path_dwim_relative(inject['_original_file'], 'templates', source, self.runner.basedir)\n            else:\n                source = utils.path_dwim(self.runner.basedir, source)\n\n\n        if dest.endswith(\"/\"):\n            base = os.path.basename(source)\n            dest = os.path.join(dest, base)\n\n        # template the source data locally & get ready to transfer\n        try:\n            resultant = template.template_from_file(self.runner.basedir, source, inject, vault_password=self.runner.vault_pass)\n        except Exception, e:\n            result = dict(failed=True, msg=str(e))\n            return ReturnData(conn=conn, comm_ok=False, result=result)\n\n        local_md5 = utils.md5s(resultant)\n        remote_md5 = self.runner._remote_md5(conn, tmp, dest)\n\n        if local_md5 != remote_md5:\n\n            # template is different from the remote value\n\n            # if showing diffs, we need to get the remote value\n            dest_contents = ''\n\n            if self.runner.diff:\n                # using persist_files to keep the temp directory around to avoid needing to grab another\n                dest_result = self.runner._execute_module(conn, tmp, 'slurp', \"path=%s\" % dest, inject=inject, persist_files=True)\n                if 'content' in dest_result.result:\n                    dest_contents = dest_result.result['content']\n                    if dest_result.result['encoding'] == 'base64':\n                        dest_contents = base64.b64decode(dest_contents)\n                    else:\n                        raise Exception(\"unknown encoding, failed: %s\" % dest_result.result)\n \n            xfered = self.runner._transfer_str(conn, tmp, 'source', resultant)\n\n            # fix file permissions when the copy is done as a different user\n            if self.runner.sudo and self.runner.sudo_user != 'root':\n                self.runner._low_level_exec_command(conn, \"chmod a+r %s\" % xfered, tmp)\n\n            # run the copy module\n            new_module_args = dict(\n               src=xfered,\n               dest=dest,\n               original_basename=os.path.basename(source),\n            )\n            module_args_tmp = utils.merge_module_args(module_args, new_module_args)\n\n            if self.runner.noop_on_check(inject):\n                return ReturnData(conn=conn, comm_ok=True, result=dict(changed=True), diff=dict(before_header=dest, after_header=source, before=dest_contents, after=resultant))\n            else:\n                res = self.runner._execute_module(conn, tmp, 'copy', module_args_tmp, inject=inject, complex_args=complex_args)\n                if res.result.get('changed', False):\n                    res.diff = dict(before=dest_contents, after=resultant)\n                return res\n        else:\n            return self.runner._execute_module(conn, tmp, 'file', module_args, inject=inject, complex_args=complex_args)\n\n", "# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport re\nimport os\nimport shlex\nimport yaml\nimport copy\nimport optparse\nimport operator\nfrom ansible import errors\nfrom ansible import __version__\nfrom ansible.utils import template\nfrom ansible.utils.display_functions import *\nfrom ansible.utils.plugins import *\nfrom ansible.callbacks import display\nimport ansible.constants as C\nimport ast\nimport time\nimport StringIO\nimport stat\nimport termios\nimport tty\nimport pipes\nimport random\nimport difflib\nimport warnings\nimport traceback\nimport getpass\nimport sys\nimport json\n\nfrom vault import VaultLib\n\nVERBOSITY=0\n\nMAX_FILE_SIZE_FOR_DIFF=1*1024*1024\n\n# caching the compilation of the regex used\n# to check for lookup calls within data\nLOOKUP_REGEX=re.compile(r'lookup\\s*\\(')\n\ntry:\n    import json\nexcept ImportError:\n    import simplejson as json\n\ntry:\n    from hashlib import md5 as _md5\nexcept ImportError:\n    from md5 import md5 as _md5\n\nPASSLIB_AVAILABLE = False\ntry:\n    import passlib.hash\n    PASSLIB_AVAILABLE = True\nexcept:\n    pass\n\ntry:\n    import builtin\nexcept ImportError:\n    import __builtin__ as builtin\n\nKEYCZAR_AVAILABLE=False\ntry:\n    try:\n        # some versions of pycrypto may not have this?\n        from Crypto.pct_warnings import PowmInsecureWarning\n    except ImportError:\n        PowmInsecureWarning = RuntimeWarning\n\n    with warnings.catch_warnings(record=True) as warning_handler:\n        warnings.simplefilter(\"error\", PowmInsecureWarning)\n        try:\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        except PowmInsecureWarning:\n            system_warning(\n                \"The version of gmp you have installed has a known issue regarding \" + \\\n                \"timing vulnerabilities when used with pycrypto. \" + \\\n                \"If possible, you should update it (ie. yum update gmp).\"\n            )\n            warnings.resetwarnings()\n            warnings.simplefilter(\"ignore\")\n            import keyczar.errors as key_errors\n            from keyczar.keys import AesKey\n        KEYCZAR_AVAILABLE=True\nexcept ImportError:\n    pass\n\n###############################################################\n# Abstractions around keyczar\n###############################################################\n\ndef key_for_hostname(hostname):\n    # fireball mode is an implementation of ansible firing up zeromq via SSH\n    # to use no persistent daemons or key management\n\n    if not KEYCZAR_AVAILABLE:\n        raise errors.AnsibleError(\"python-keyczar must be installed on the control machine to use accelerated modes\")\n\n    key_path = os.path.expanduser(C.ACCELERATE_KEYS_DIR)\n    if not os.path.exists(key_path):\n        os.makedirs(key_path, mode=0700)\n        os.chmod(key_path, int(C.ACCELERATE_KEYS_DIR_PERMS, 8))\n    elif not os.path.isdir(key_path):\n        raise errors.AnsibleError('ACCELERATE_KEYS_DIR is not a directory.')\n\n    if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_DIR_PERMS, 8):\n        raise errors.AnsibleError('Incorrect permissions on the private key directory. Use `chmod 0%o %s` to correct this issue, and make sure any of the keys files contained within that directory are set to 0%o' % (int(C.ACCELERATE_KEYS_DIR_PERMS, 8), C.ACCELERATE_KEYS_DIR, int(C.ACCELERATE_KEYS_FILE_PERMS, 8)))\n\n    key_path = os.path.join(key_path, hostname)\n\n    # use new AES keys every 2 hours, which means fireball must not allow running for longer either\n    if not os.path.exists(key_path) or (time.time() - os.path.getmtime(key_path) > 60*60*2):\n        key = AesKey.Generate()\n        fd = os.open(key_path, os.O_WRONLY | os.O_CREAT, int(C.ACCELERATE_KEYS_FILE_PERMS, 8))\n        fh = os.fdopen(fd, 'w')\n        fh.write(str(key))\n        fh.close()\n        return key\n    else:\n        if stat.S_IMODE(os.stat(key_path).st_mode) != int(C.ACCELERATE_KEYS_FILE_PERMS, 8):\n            raise errors.AnsibleError('Incorrect permissions on the key file for this host. Use `chmod 0%o %s` to correct this issue.' % (int(C.ACCELERATE_KEYS_FILE_PERMS, 8), key_path))\n        fh = open(key_path)\n        key = AesKey.Read(fh.read())\n        fh.close()\n        return key\n\ndef encrypt(key, msg):\n    return key.Encrypt(msg)\n\ndef decrypt(key, msg):\n    try:\n        return key.Decrypt(msg)\n    except key_errors.InvalidSignatureError:\n        raise errors.AnsibleError(\"decryption failed\")\n\n###############################################################\n# UTILITY FUNCTIONS FOR COMMAND LINE TOOLS\n###############################################################\n\ndef err(msg):\n    ''' print an error message to stderr '''\n\n    print >> sys.stderr, msg\n\ndef exit(msg, rc=1):\n    ''' quit with an error to stdout and a failure code '''\n\n    err(msg)\n    sys.exit(rc)\n\ndef jsonify(result, format=False):\n    ''' format JSON output (uncompressed or uncompressed) '''\n\n    if result is None:\n        return \"{}\"\n    result2 = result.copy()\n    for key, value in result2.items():\n        if type(value) is str:\n            result2[key] = value.decode('utf-8', 'ignore')\n    if format:\n        return json.dumps(result2, sort_keys=True, indent=4)\n    else:\n        return json.dumps(result2, sort_keys=True)\n\ndef write_tree_file(tree, hostname, buf):\n    ''' write something into treedir/hostname '''\n\n    # TODO: might be nice to append playbook runs per host in a similar way\n    # in which case, we'd want append mode.\n    path = os.path.join(tree, hostname)\n    fd = open(path, \"w+\")\n    fd.write(buf)\n    fd.close()\n\ndef is_failed(result):\n    ''' is a given JSON result a failed result? '''\n\n    return ((result.get('rc', 0) != 0) or (result.get('failed', False) in [ True, 'True', 'true']))\n\ndef is_changed(result):\n    ''' is a given JSON result a changed result? '''\n\n    return (result.get('changed', False) in [ True, 'True', 'true'])\n\ndef check_conditional(conditional, basedir, inject, fail_on_undefined=False):\n\n    if conditional is None or conditional == '':\n        return True\n\n    if isinstance(conditional, list):\n        for x in conditional:\n            if not check_conditional(x, basedir, inject, fail_on_undefined=fail_on_undefined):\n                return False\n        return True\n\n    if not isinstance(conditional, basestring):\n        return conditional\n\n    conditional = conditional.replace(\"jinja2_compare \",\"\")\n    # allow variable names\n    if conditional in inject and '-' not in str(inject[conditional]):\n        conditional = inject[conditional]\n    conditional = template.template(basedir, conditional, inject, fail_on_undefined=fail_on_undefined)\n    original = str(conditional).replace(\"jinja2_compare \",\"\")\n    # a Jinja2 evaluation that results in something Python can eval!\n    presented = \"{%% if %s %%} True {%% else %%} False {%% endif %%}\" % conditional\n    conditional = template.template(basedir, presented, inject)\n    val = conditional.strip()\n    if val == presented:\n        # the templating failed, meaning most likely a \n        # variable was undefined. If we happened to be \n        # looking for an undefined variable, return True,\n        # otherwise fail\n        if \"is undefined\" in conditional:\n            return True\n        elif \"is defined\" in conditional:\n            return False\n        else:\n            raise errors.AnsibleError(\"error while evaluating conditional: %s\" % original)\n    elif val == \"True\":\n        return True\n    elif val == \"False\":\n        return False\n    else:\n        raise errors.AnsibleError(\"unable to evaluate conditional: %s\" % original)\n\ndef is_executable(path):\n    '''is the given path executable?'''\n    return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXGRP & os.stat(path)[stat.ST_MODE]\n            or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])\n\ndef unfrackpath(path):\n    ''' \n    returns a path that is free of symlinks, environment\n    variables, relative path traversals and symbols (~)\n    example:\n    '$HOME/../../var/mail' becomes '/var/spool/mail'\n    '''\n    return os.path.normpath(os.path.realpath(os.path.expandvars(os.path.expanduser(path))))\n\ndef prepare_writeable_dir(tree,mode=0777):\n    ''' make sure a directory exists and is writeable '''\n\n    # modify the mode to ensure the owner at least\n    # has read/write access to this directory\n    mode |= 0700\n\n    # make sure the tree path is always expanded\n    # and normalized and free of symlinks\n    tree = unfrackpath(tree)\n\n    if not os.path.exists(tree):\n        try:\n            os.makedirs(tree, mode)\n        except (IOError, OSError), e:\n            raise errors.AnsibleError(\"Could not make dir %s: %s\" % (tree, e))\n    if not os.access(tree, os.W_OK):\n        raise errors.AnsibleError(\"Cannot write to path %s\" % tree)\n    return tree\n\ndef path_dwim(basedir, given):\n    '''\n    make relative paths work like folks expect.\n    '''\n\n    if given.startswith(\"/\"):\n        return os.path.abspath(given)\n    elif given.startswith(\"~\"):\n        return os.path.abspath(os.path.expanduser(given))\n    else:\n        if basedir is None:\n            basedir = \".\"\n        return os.path.abspath(os.path.join(basedir, given))\n\ndef path_dwim_relative(original, dirname, source, playbook_base, check=True):\n    ''' find one file in a directory one level up in a dir named dirname relative to current '''\n    # (used by roles code)\n\n    basedir = os.path.dirname(original)\n    if os.path.islink(basedir):\n        basedir = unfrackpath(basedir)\n        template2 = os.path.join(basedir, dirname, source)\n    else:\n        template2 = os.path.join(basedir, '..', dirname, source)\n    source2 = path_dwim(basedir, template2)\n    if os.path.exists(source2):\n        return source2\n    obvious_local_path = path_dwim(playbook_base, source)\n    if os.path.exists(obvious_local_path):\n        return obvious_local_path\n    if check:\n        raise errors.AnsibleError(\"input file not found at %s or %s\" % (source2, obvious_local_path))\n    return source2 # which does not exist\n\ndef json_loads(data):\n    ''' parse a JSON string and return a data structure '''\n\n    return json.loads(data)\n\ndef _clean_data(orig_data, from_remote=False, from_inventory=False):\n    ''' remove template tags from a string '''\n    data = orig_data\n    if isinstance(orig_data, basestring):\n        sub_list = [('{%','{#'), ('%}','#}')]\n        if from_remote or (from_inventory and '{{' in data and LOOKUP_REGEX.search(data)):\n            # if from a remote, we completely disable any jinja2 blocks\n            sub_list.extend([('{{','{#'), ('}}','#}')])\n        for pattern,replacement in sub_list:\n            data = data.replace(pattern, replacement)\n    return data\n\ndef _clean_data_struct(orig_data, from_remote=False, from_inventory=False):\n    '''\n    walk a complex data structure, and use _clean_data() to\n    remove any template tags that may exist\n    '''\n    if not from_remote and not from_inventory:\n        raise errors.AnsibleErrors(\"when cleaning data, you must specify either from_remote or from_inventory\")\n    if isinstance(orig_data, dict):\n        data = orig_data.copy()\n        for key in data:\n            new_key = _clean_data_struct(key, from_remote, from_inventory)\n            new_val = _clean_data_struct(data[key], from_remote, from_inventory)\n            if key != new_key:\n                del data[key]\n            data[new_key] = new_val\n    elif isinstance(orig_data, list):\n        data = orig_data[:]\n        for i in range(0, len(data)):\n            data[i] = _clean_data_struct(data[i], from_remote, from_inventory)\n    elif isinstance(orig_data, basestring):\n        data = _clean_data(orig_data, from_remote, from_inventory)\n    else:\n        data = orig_data\n    return data\n\ndef parse_json(raw_data, from_remote=False, from_inventory=False):\n    ''' this version for module return data only '''\n\n    orig_data = raw_data\n\n    # ignore stuff like tcgetattr spewage or other warnings\n    data = filter_leading_non_json_lines(raw_data)\n\n    try:\n        results = json.loads(data)\n    except:\n        # not JSON, but try \"Baby JSON\" which allows many of our modules to not\n        # require JSON and makes writing modules in bash much simpler\n        results = {}\n        try:\n            tokens = shlex.split(data)\n        except:\n            print \"failed to parse json: \"+ data\n            raise\n        for t in tokens:\n            if \"=\" not in t:\n                raise errors.AnsibleError(\"failed to parse: %s\" % orig_data)\n            (key,value) = t.split(\"=\", 1)\n            if key == 'changed' or 'failed':\n                if value.lower() in [ 'true', '1' ]:\n                    value = True\n                elif value.lower() in [ 'false', '0' ]:\n                    value = False\n            if key == 'rc':\n                value = int(value)\n            results[key] = value\n        if len(results.keys()) == 0:\n            return { \"failed\" : True, \"parsed\" : False, \"msg\" : orig_data }\n\n    if from_remote:\n        results = _clean_data_struct(results, from_remote, from_inventory)\n\n    return results\n\ndef merge_module_args(current_args, new_args):\n    '''\n    merges either a dictionary or string of k=v pairs with another string of k=v pairs,\n    and returns a new k=v string without duplicates.\n    '''\n    if not isinstance(current_args, basestring):\n        raise errors.AnsibleError(\"expected current_args to be a basestring\")\n    # we use parse_kv to split up the current args into a dictionary\n    final_args = parse_kv(current_args)\n    if isinstance(new_args, dict):\n        final_args.update(new_args)\n    elif isinstance(new_args, basestring):\n        new_args_kv = parse_kv(new_args)\n        final_args.update(new_args_kv)\n    # then we re-assemble into a string\n    module_args = \"\"\n    for (k,v) in final_args.iteritems():\n        if isinstance(v, basestring):\n            module_args = \"%s=%s %s\" % (k, pipes.quote(v), module_args)\n    return module_args.strip()\n\ndef smush_braces(data):\n    ''' smush Jinaj2 braces so unresolved templates like {{ foo }} don't get parsed weird by key=value code '''\n    while '{{ ' in data:\n        data = data.replace('{{ ', '{{')\n    while ' }}' in data:\n        data = data.replace(' }}', '}}')\n    return data\n\ndef smush_ds(data):\n    # things like key={{ foo }} are not handled by shlex.split well, so preprocess any YAML we load\n    # so we do not have to call smush elsewhere\n    if type(data) == list:\n        return [ smush_ds(x) for x in data ]\n    elif type(data) == dict:\n        for (k,v) in data.items():\n            data[k] = smush_ds(v)\n        return data\n    elif isinstance(data, basestring):\n        return smush_braces(data)\n    else:\n        return data\n\ndef parse_yaml(data, path_hint=None):\n    ''' convert a yaml string to a data structure.  Also supports JSON, ssssssh!!!'''\n\n    stripped_data = data.lstrip()\n    loaded = None\n    if stripped_data.startswith(\"{\") or stripped_data.startswith(\"[\"):\n        # since the line starts with { or [ we can infer this is a JSON document.\n        try:\n            loaded = json.loads(data)\n        except ValueError, ve:\n            if path_hint:\n                raise errors.AnsibleError(path_hint + \": \" + str(ve))\n            else:\n                raise errors.AnsibleError(str(ve))\n    else:\n        # else this is pretty sure to be a YAML document\n        loaded = yaml.safe_load(data)\n\n    return smush_ds(loaded)\n\ndef process_common_errors(msg, probline, column):\n    replaced = probline.replace(\" \",\"\")\n\n    if \":{{\" in replaced and \"}}\" in replaced:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  YAML thought it was looking for the start of a \nhash/dictionary and was confused to see a second \"{\".  Most likely this was\nmeant to be an ansible template evaluation instead, so we have to give the \nparser a small hint that we wanted a string instead. The solution here is to \njust quote the entire value.\n\nFor instance, if the original line was:\n\n    app_path: {{ base_path }}/foo\n\nIt should be written as:\n\n    app_path: \"{{ base_path }}/foo\"\n\"\"\"\n        return msg\n\n    elif len(probline) and len(probline) > 1 and len(probline) > column and probline[column] == \":\" and probline.count(':') > 1:\n        msg = msg + \"\"\"\nThis one looks easy to fix.  There seems to be an extra unquoted colon in the line \nand this is confusing the parser. It was only expecting to find one free \ncolon. The solution is just add some quotes around the colon, or quote the \nentire line after the first colon.\n\nFor instance, if the original line was:\n\n    copy: src=file.txt dest=/path/filename:with_colon.txt\n\nIt can be written as:\n\n    copy: src=file.txt dest='/path/filename:with_colon.txt'\n\nOr:\n    \n    copy: 'src=file.txt dest=/path/filename:with_colon.txt'\n\n\n\"\"\"\n        return msg\n    else:\n        parts = probline.split(\":\")\n        if len(parts) > 1:\n            middle = parts[1].strip()\n            match = False\n            unbalanced = False\n            if middle.startswith(\"'\") and not middle.endswith(\"'\"):\n                match = True\n            elif middle.startswith('\"') and not middle.endswith('\"'):\n                match = True\n            if len(middle) > 0 and middle[0] in [ '\"', \"'\" ] and middle[-1] in [ '\"', \"'\" ] and probline.count(\"'\") > 2 or probline.count('\"') > 2:\n                unbalanced = True\n            if match:\n                msg = msg + \"\"\"\nThis one looks easy to fix.  It seems that there is a value started \nwith a quote, and the YAML parser is expecting to see the line ended \nwith the same kind of quote.  For instance:\n\n    when: \"ok\" in result.stdout\n\nCould be written as:\n\n   when: '\"ok\" in result.stdout'\n\nor equivalently:\n\n   when: \"'ok' in result.stdout\"\n\n\"\"\"\n                return msg\n\n            if unbalanced:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with \nunbalanced quotes.  If starting a value with a quote, make sure the \nline ends with the same set of quotes.  For instance this arbitrary \nexample:\n\n    foo: \"bad\" \"wolf\"\n\nCould be written as:\n\n    foo: '\"bad\" \"wolf\"'\n\n\"\"\"\n                return msg\n\n    return msg\n\ndef process_yaml_error(exc, data, path=None, show_content=True):\n    if hasattr(exc, 'problem_mark'):\n        mark = exc.problem_mark\n        if show_content:\n            if mark.line -1 >= 0:\n                before_probline = data.split(\"\\n\")[mark.line-1]\n            else:\n                before_probline = ''\n            probline = data.split(\"\\n\")[mark.line]\n            arrow = \" \" * mark.column + \"^\"\n            msg = \"\"\"Syntax Error while loading YAML script, %s\nNote: The error may actually appear before this position: line %s, column %s\n\n%s\n%s\n%s\"\"\" % (path, mark.line + 1, mark.column + 1, before_probline, probline, arrow)\n\n            unquoted_var = None\n            if '{{' in probline and '}}' in probline:\n                if '\"{{' not in probline or \"'{{\" not in probline:\n                    unquoted_var = True\n\n            msg = process_common_errors(msg, probline, mark.column)\n            if not unquoted_var:\n                msg = process_common_errors(msg, probline, mark.column)\n            else:\n                msg = msg + \"\"\"\nWe could be wrong, but this one looks like it might be an issue with\nmissing quotes.  Always quote template expression brackets when they \nstart a value. For instance:            \n\n    with_items:\n      - {{ foo }}\n\nShould be written as:\n\n    with_items:\n      - \"{{ foo }}\"      \n\n\"\"\"\n                msg = process_common_errors(msg, probline, mark.column)\n        else:\n            # most likely displaying a file with sensitive content,\n            # so don't show any of the actual lines of yaml just the\n            # line number itself\n            msg = \"\"\"Syntax error while loading YAML script, %s\nThe error appears to have been on line %s, column %s, but may actually\nbe before there depending on the exact syntax problem.\n\"\"\" % (path, mark.line + 1, mark.column + 1)\n\n    else:\n        # No problem markers means we have to throw a generic\n        # \"stuff messed up\" type message. Sry bud.\n        if path:\n            msg = \"Could not parse YAML. Check over %s again.\" % path\n        else:\n            msg = \"Could not parse YAML.\"\n    raise errors.AnsibleYAMLValidationFailed(msg)\n\n\ndef parse_yaml_from_file(path, vault_password=None):\n    ''' convert a yaml file to a data structure '''\n\n    data = None\n    show_content = True\n\n    try:\n        data = open(path).read()\n    except IOError:\n        raise errors.AnsibleError(\"file could not read: %s\" % path)\n\n    vault = VaultLib(password=vault_password)\n    if vault.is_encrypted(data):\n        data = vault.decrypt(data)\n        show_content = False\n\n    try:\n        return parse_yaml(data, path_hint=path)\n    except yaml.YAMLError, exc:\n        process_yaml_error(exc, data, path, show_content)\n\ndef parse_kv(args):\n    ''' convert a string of key/value items to a dict '''\n    options = {}\n    if args is not None:\n        # attempting to split a unicode here does bad things\n        args = args.encode('utf-8')\n        try:\n            vargs = shlex.split(args, posix=True)\n        except ValueError, ve:\n            if 'no closing quotation' in str(ve).lower():\n                raise errors.AnsibleError(\"error parsing argument string, try quoting the entire line.\")\n            else:\n                raise\n        vargs = [x.decode('utf-8') for x in vargs]\n        for x in vargs:\n            if \"=\" in x:\n                k, v = x.split(\"=\",1)\n                options[k] = v\n    return options\n\ndef merge_hash(a, b):\n    ''' recursively merges hash b into a\n    keys from b take precedence over keys from a '''\n\n    result = copy.deepcopy(a)\n\n    # next, iterate over b keys and values\n    for k, v in b.iteritems():\n        # if there's already such key in a\n        # and that key contains dict\n        if k in result and isinstance(result[k], dict):\n            # merge those dicts recursively\n            result[k] = merge_hash(a[k], v)\n        else:\n            # otherwise, just copy a value from b to a\n            result[k] = v\n\n    return result\n\ndef md5s(data):\n    ''' Return MD5 hex digest of data. '''\n\n    digest = _md5()\n    try:\n        digest.update(data)\n    except UnicodeEncodeError:\n        digest.update(data.encode('utf-8'))\n    return digest.hexdigest()\n\ndef md5(filename):\n    ''' Return MD5 hex digest of local file, or None if file is not present. '''\n\n    if not os.path.exists(filename):\n        return None\n    digest = _md5()\n    blocksize = 64 * 1024\n    try:\n        infile = open(filename, 'rb')\n        block = infile.read(blocksize)\n        while block:\n            digest.update(block)\n            block = infile.read(blocksize)\n        infile.close()\n    except IOError, e:\n        raise errors.AnsibleError(\"error while accessing the file %s, error was: %s\" % (filename, e))\n    return digest.hexdigest()\n\ndef default(value, function):\n    ''' syntactic sugar around lazy evaluation of defaults '''\n    if value is None:\n        return function()\n    return value\n\ndef _gitinfo():\n    ''' returns a string containing git branch, commit id and commit date '''\n    result = None\n    repo_path = os.path.join(os.path.dirname(__file__), '..', '..', '..', '.git')\n\n    if os.path.exists(repo_path):\n        # Check if the .git is a file. If it is a file, it means that we are in a submodule structure.\n        if os.path.isfile(repo_path):\n            try:\n                gitdir = yaml.safe_load(open(repo_path)).get('gitdir')\n                # There is a posibility the .git file to have an absolute path.\n                if os.path.isabs(gitdir):\n                    repo_path = gitdir\n                else:\n                    repo_path = os.path.join(repo_path.split('.git')[0], gitdir)\n            except (IOError, AttributeError):\n                return ''\n        f = open(os.path.join(repo_path, \"HEAD\"))\n        branch = f.readline().split('/')[-1].rstrip(\"\\n\")\n        f.close()\n        branch_path = os.path.join(repo_path, \"refs\", \"heads\", branch)\n        if os.path.exists(branch_path):\n            f = open(branch_path)\n            commit = f.readline()[:10]\n            f.close()\n            date = time.localtime(os.stat(branch_path).st_mtime)\n            if time.daylight == 0:\n                offset = time.timezone\n            else:\n                offset = time.altzone\n            result = \"({0} {1}) last updated {2} (GMT {3:+04d})\".format(branch, commit,\n                time.strftime(\"%Y/%m/%d %H:%M:%S\", date), offset / -36)\n    else:\n        result = ''\n    return result\n\ndef version(prog):\n    result = \"{0} {1}\".format(prog, __version__)\n    gitinfo = _gitinfo()\n    if gitinfo:\n        result = result + \" {0}\".format(gitinfo)\n    return result\n\ndef getch():\n    ''' read in a single character '''\n    fd = sys.stdin.fileno()\n    old_settings = termios.tcgetattr(fd)\n    try:\n        tty.setraw(sys.stdin.fileno())\n        ch = sys.stdin.read(1)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n    return ch\n\ndef sanitize_output(str):\n    ''' strips private info out of a string '''\n\n    private_keys = ['password', 'login_password']\n\n    filter_re = [\n        # filter out things like user:pass@foo/whatever\n        # and http://username:pass@wherever/foo\n        re.compile('^(?P<before>.*:)(?P<password>.*)(?P<after>\\@.*)$'),\n    ]\n\n    parts = str.split()\n    output = ''\n    for part in parts:\n        try:\n            (k,v) = part.split('=', 1)\n            if k in private_keys:\n                output += \" %s=VALUE_HIDDEN\" % k\n            else:\n                found = False\n                for filter in filter_re:\n                    m = filter.match(v)\n                    if m:\n                        d = m.groupdict()\n                        output += \" %s=%s\" % (k, d['before'] + \"********\" + d['after'])\n                        found = True\n                        break\n                if not found:\n                    output += \" %s\" % part\n        except:\n            output += \" %s\" % part\n\n    return output.strip()\n\n####################################################################\n# option handling code for /usr/bin/ansible and ansible-playbook\n# below this line\n\nclass SortedOptParser(optparse.OptionParser):\n    '''Optparser which sorts the options by opt before outputting --help'''\n\n    def format_help(self, formatter=None):\n        self.option_list.sort(key=operator.methodcaller('get_opt_string'))\n        return optparse.OptionParser.format_help(self, formatter=None)\n\ndef increment_debug(option, opt, value, parser):\n    global VERBOSITY\n    VERBOSITY += 1\n\ndef base_parser(constants=C, usage=\"\", output_opts=False, runas_opts=False,\n    async_opts=False, connect_opts=False, subset_opts=False, check_opts=False, diff_opts=False):\n    ''' create an options parser for any ansible script '''\n\n    parser = SortedOptParser(usage, version=version(\"%prog\"))\n    parser.add_option('-v','--verbose', default=False, action=\"callback\",\n        callback=increment_debug, help=\"verbose mode (-vvv for more, -vvvv to enable connection debugging)\")\n\n    parser.add_option('-f','--forks', dest='forks', default=constants.DEFAULT_FORKS, type='int',\n        help=\"specify number of parallel processes to use (default=%s)\" % constants.DEFAULT_FORKS)\n    parser.add_option('-i', '--inventory-file', dest='inventory',\n        help=\"specify inventory host file (default=%s)\" % constants.DEFAULT_HOST_LIST,\n        default=constants.DEFAULT_HOST_LIST)\n    parser.add_option('-k', '--ask-pass', default=False, dest='ask_pass', action='store_true',\n        help='ask for SSH password')\n    parser.add_option('--private-key', default=C.DEFAULT_PRIVATE_KEY_FILE, dest='private_key_file',\n        help='use this file to authenticate the connection')\n    parser.add_option('-K', '--ask-sudo-pass', default=False, dest='ask_sudo_pass', action='store_true',\n        help='ask for sudo password')\n    parser.add_option('--ask-su-pass', default=False, dest='ask_su_pass', action='store_true', \n        help='ask for su password')\n    parser.add_option('--ask-vault-pass', default=False, dest='ask_vault_pass', action='store_true', \n        help='ask for vault password')\n    parser.add_option('--vault-password-file', default=None, dest='vault_password_file',\n        help=\"vault password file\")\n    parser.add_option('--list-hosts', dest='listhosts', action='store_true',\n        help='outputs a list of matching hosts; does not execute anything else')\n    parser.add_option('-M', '--module-path', dest='module_path',\n        help=\"specify path(s) to module library (default=%s)\" % constants.DEFAULT_MODULE_PATH,\n        default=None)\n\n    if subset_opts:\n        parser.add_option('-l', '--limit', default=constants.DEFAULT_SUBSET, dest='subset',\n            help='further limit selected hosts to an additional pattern')\n\n    parser.add_option('-T', '--timeout', default=constants.DEFAULT_TIMEOUT, type='int',\n        dest='timeout',\n        help=\"override the SSH timeout in seconds (default=%s)\" % constants.DEFAULT_TIMEOUT)\n\n    if output_opts:\n        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',\n            help='condense output')\n        parser.add_option('-t', '--tree', dest='tree', default=None,\n            help='log output to this directory')\n\n    if runas_opts:\n        parser.add_option(\"-s\", \"--sudo\", default=constants.DEFAULT_SUDO, action=\"store_true\",\n            dest='sudo', help=\"run operations with sudo (nopasswd)\")\n        parser.add_option('-U', '--sudo-user', dest='sudo_user', default=None,\n                          help='desired sudo user (default=root)')  # Can't default to root because we need to detect when this option was given\n        parser.add_option('-u', '--user', default=constants.DEFAULT_REMOTE_USER,\n            dest='remote_user', help='connect as this user (default=%s)' % constants.DEFAULT_REMOTE_USER)\n\n        parser.add_option('-S', '--su', default=constants.DEFAULT_SU,\n                          action='store_true', help='run operations with su')\n        parser.add_option('-R', '--su-user', help='run operations with su as this '\n                                                  'user (default=%s)' % constants.DEFAULT_SU_USER)\n\n    if connect_opts:\n        parser.add_option('-c', '--connection', dest='connection',\n                          default=C.DEFAULT_TRANSPORT,\n                          help=\"connection type to use (default=%s)\" % C.DEFAULT_TRANSPORT)\n\n    if async_opts:\n        parser.add_option('-P', '--poll', default=constants.DEFAULT_POLL_INTERVAL, type='int',\n            dest='poll_interval',\n            help=\"set the poll interval if using -B (default=%s)\" % constants.DEFAULT_POLL_INTERVAL)\n        parser.add_option('-B', '--background', dest='seconds', type='int', default=0,\n            help='run asynchronously, failing after X seconds (default=N/A)')\n\n    if check_opts:\n        parser.add_option(\"-C\", \"--check\", default=False, dest='check', action='store_true',\n            help=\"don't make any changes; instead, try to predict some of the changes that may occur\"\n        )\n\n    if diff_opts:\n        parser.add_option(\"-D\", \"--diff\", default=False, dest='diff', action='store_true',\n            help=\"when changing (small) files and templates, show the differences in those files; works great with --check\"\n        )\n\n\n    return parser\n\ndef ask_vault_passwords(ask_vault_pass=False, ask_new_vault_pass=False, confirm_vault=False, confirm_new=False):\n\n    vault_pass = None\n    new_vault_pass = None\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    if ask_vault_pass and confirm_vault:\n        vault_pass2 = getpass.getpass(prompt=\"Confirm Vault password: \")\n        if vault_pass != vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    if ask_new_vault_pass:\n        new_vault_pass = getpass.getpass(prompt=\"New Vault password: \")\n\n    if ask_new_vault_pass and confirm_new:\n        new_vault_pass2 = getpass.getpass(prompt=\"Confirm New Vault password: \")\n        if new_vault_pass != new_vault_pass2:\n            raise errors.AnsibleError(\"Passwords do not match\")\n\n    # enforce no newline chars at the end of passwords\n    if vault_pass:\n        vault_pass = vault_pass.strip()\n    if new_vault_pass:\n        new_vault_pass = new_vault_pass.strip()\n\n    return vault_pass, new_vault_pass\n\ndef ask_passwords(ask_pass=False, ask_sudo_pass=False, ask_su_pass=False, ask_vault_pass=False):\n    sshpass = None\n    sudopass = None\n    su_pass = None\n    vault_pass = None\n    sudo_prompt = \"sudo password: \"\n    su_prompt = \"su password: \"\n\n    if ask_pass:\n        sshpass = getpass.getpass(prompt=\"SSH password: \")\n        sudo_prompt = \"sudo password [defaults to SSH password]: \"\n\n    if ask_sudo_pass:\n        sudopass = getpass.getpass(prompt=sudo_prompt)\n        if ask_pass and sudopass == '':\n            sudopass = sshpass\n\n    if ask_su_pass:\n        su_pass = getpass.getpass(prompt=su_prompt)\n\n    if ask_vault_pass:\n        vault_pass = getpass.getpass(prompt=\"Vault password: \")\n\n    return (sshpass, sudopass, su_pass, vault_pass)\n\ndef do_encrypt(result, encrypt, salt_size=None, salt=None):\n    if PASSLIB_AVAILABLE:\n        try:\n            crypt = getattr(passlib.hash, encrypt)\n        except:\n            raise errors.AnsibleError(\"passlib does not support '%s' algorithm\" % encrypt)\n\n        if salt_size:\n            result = crypt.encrypt(result, salt_size=salt_size)\n        elif salt:\n            result = crypt.encrypt(result, salt=salt)\n        else:\n            result = crypt.encrypt(result)\n    else:\n        raise errors.AnsibleError(\"passlib must be installed to encrypt vars_prompt values\")\n\n    return result\n\ndef last_non_blank_line(buf):\n\n    all_lines = buf.splitlines()\n    all_lines.reverse()\n    for line in all_lines:\n        if (len(line) > 0):\n            return line\n    # shouldn't occur unless there's no output\n    return \"\"\n\ndef filter_leading_non_json_lines(buf):\n    '''\n    used to avoid random output from SSH at the top of JSON output, like messages from\n    tcagetattr, or where dropbear spews MOTD on every single command (which is nuts).\n\n    need to filter anything which starts not with '{', '[', ', '=' or is an empty line.\n    filter only leading lines since multiline JSON is valid.\n    '''\n\n    kv_regex = re.compile(r'.*\\w+=\\w+.*')\n    filtered_lines = StringIO.StringIO()\n    stop_filtering = False\n    for line in buf.splitlines():\n        if stop_filtering or kv_regex.match(line) or line.startswith('{') or line.startswith('['):\n            stop_filtering = True\n            filtered_lines.write(line + '\\n')\n    return filtered_lines.getvalue()\n\ndef boolean(value):\n    val = str(value)\n    if val.lower() in [ \"true\", \"t\", \"y\", \"1\", \"yes\" ]:\n        return True\n    else:\n        return False\n\ndef make_sudo_cmd(sudo_user, executable, cmd):\n    \"\"\"\n    helper function for connection plugins to create sudo commands\n    \"\"\"\n    # Rather than detect if sudo wants a password this time, -k makes\n    # sudo always ask for a password if one is required.\n    # Passing a quoted compound command to sudo (or sudo -s)\n    # directly doesn't work, so we shellquote it with pipes.quote()\n    # and pass the quoted string to the user's shell.  We loop reading\n    # output until we see the randomly-generated sudo prompt set with\n    # the -p option.\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = '[sudo via ansible, key=%s] password: ' % randbits\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s -k && %s %s -S -p \"%s\" -u %s %s -c %s' % (\n        C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_EXE, C.DEFAULT_SUDO_FLAGS,\n        prompt, sudo_user, executable or '$SHELL', pipes.quote('echo %s; %s' % (success_key, cmd)))\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n\ndef make_su_cmd(su_user, executable, cmd):\n    \"\"\"\n    Helper function for connection plugins to create direct su commands\n    \"\"\"\n    # TODO: work on this function\n    randbits = ''.join(chr(random.randint(ord('a'), ord('z'))) for x in xrange(32))\n    prompt = 'assword: '\n    success_key = 'SUDO-SUCCESS-%s' % randbits\n    sudocmd = '%s %s %s %s -c %s' % (\n        C.DEFAULT_SU_EXE, C.DEFAULT_SU_FLAGS, su_user, executable or '$SHELL',\n        pipes.quote('echo %s; %s' % (success_key, cmd))\n    )\n    return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)\n\n_TO_UNICODE_TYPES = (unicode, type(None))\n\ndef to_unicode(value):\n    if isinstance(value, _TO_UNICODE_TYPES):\n        return value\n    return value.decode(\"utf-8\")\n\ndef get_diff(diff):\n    # called by --diff usage in playbook and runner via callbacks\n    # include names in diffs 'before' and 'after' and do diff -U 10\n\n    try:\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            ret = []\n            if 'dst_binary' in diff:\n                ret.append(\"diff skipped: destination file appears to be binary\\n\")\n            if 'src_binary' in diff:\n                ret.append(\"diff skipped: source file appears to be binary\\n\")\n            if 'dst_larger' in diff:\n                ret.append(\"diff skipped: destination file size is greater than %d\\n\" % diff['dst_larger'])\n            if 'src_larger' in diff:\n                ret.append(\"diff skipped: source file size is greater than %d\\n\" % diff['src_larger'])\n            if 'before' in diff and 'after' in diff:\n                if 'before_header' in diff:\n                    before_header = \"before: %s\" % diff['before_header']\n                else:\n                    before_header = 'before'\n                if 'after_header' in diff:\n                    after_header = \"after: %s\" % diff['after_header']\n                else:\n                    after_header = 'after'\n                differ = difflib.unified_diff(to_unicode(diff['before']).splitlines(True), to_unicode(diff['after']).splitlines(True), before_header, after_header, '', '', 10)\n                for line in list(differ):\n                    ret.append(line)\n            return u\"\".join(ret)\n    except UnicodeDecodeError:\n        return \">> the files are different, but the diff library cannot compare unicode strings\"\n\ndef is_list_of_strings(items):\n    for x in items:\n        if not isinstance(x, basestring):\n            return False\n    return True\n\ndef list_union(a, b):\n    result = []\n    for x in a:\n        if x not in result:\n            result.append(x)\n    for x in b:\n        if x not in result:\n            result.append(x)\n    return result\n\ndef list_intersection(a, b):\n    result = []\n    for x in a:\n        if x in b and x not in result:\n            result.append(x)\n    return result\n\ndef safe_eval(expr, locals={}, include_exceptions=False):\n    '''\n    This is intended for allowing things like:\n    with_items: a_list_variable\n\n    Where Jinja2 would return a string but we do not want to allow it to\n    call functions (outside of Jinja2, where the env is constrained). If\n    the input data to this function came from an untrusted (remote) source,\n    it should first be run through _clean_data_struct() to ensure the data\n    is further sanitized prior to evaluation.\n\n    Based on:\n    http://stackoverflow.com/questions/12523516/using-ast-and-whitelists-to-make-pythons-eval-safe\n    '''\n\n    # this is the whitelist of AST nodes we are going to \n    # allow in the evaluation. Any node type other than \n    # those listed here will raise an exception in our custom\n    # visitor class defined below.\n    SAFE_NODES = set(\n        (\n            ast.Add,\n            ast.BinOp,\n            ast.Call,\n            ast.Compare,\n            ast.Dict,\n            ast.Div,\n            ast.Expression,\n            ast.List,\n            ast.Load,\n            ast.Mult,\n            ast.Num,\n            ast.Name,\n            ast.Str,\n            ast.Sub,\n            ast.Tuple,\n            ast.UnaryOp,\n        )\n    )\n\n    # AST node types were expanded after 2.6\n    if not sys.version.startswith('2.6'):\n        SAFE_NODES.union(\n            set(\n                (ast.Set,)\n            )\n        )\n\n    filter_list = []\n    for filter in filter_loader.all():\n        filter_list.extend(filter.filters().keys())\n\n    CALL_WHITELIST = C.DEFAULT_CALLABLE_WHITELIST + filter_list\n\n    class CleansingNodeVisitor(ast.NodeVisitor):\n        def generic_visit(self, node, inside_call=False):\n            if type(node) not in SAFE_NODES:\n                raise Exception(\"invalid expression (%s)\" % expr)\n            elif isinstance(node, ast.Call):\n                inside_call = True\n            elif isinstance(node, ast.Name) and inside_call:\n                if hasattr(builtin, node.id) and node.id not in CALL_WHITELIST:\n                    raise Exception(\"invalid function: %s\" % node.id)\n            # iterate over all child nodes\n            for child_node in ast.iter_child_nodes(node):\n                self.generic_visit(child_node, inside_call)\n\n    if not isinstance(expr, basestring):\n        # already templated to a datastructure, perhaps?\n        if include_exceptions:\n            return (expr, None)\n        return expr\n\n    cnv = CleansingNodeVisitor()\n    try:\n        parsed_tree = ast.parse(expr, mode='eval')\n        cnv.visit(parsed_tree)\n        compiled = compile(parsed_tree, expr, 'eval')\n        result = eval(compiled, {}, locals)\n\n        if include_exceptions:\n            return (result, None)\n        else:\n            return result\n    except SyntaxError, e:\n        # special handling for syntax errors, we just return\n        # the expression string back as-is\n        if include_exceptions:\n            return (expr, None)\n        return expr\n    except Exception, e:\n        if include_exceptions:\n            return (expr, e)\n        return expr\n\n\ndef listify_lookup_plugin_terms(terms, basedir, inject):\n\n    if isinstance(terms, basestring):\n        # someone did:\n        #    with_items: alist\n        # OR\n        #    with_items: {{ alist }}\n\n        stripped = terms.strip()\n        if not (stripped.startswith('{') or stripped.startswith('[')) and not stripped.startswith(\"/\") and not stripped.startswith('set(['):\n            # if not already a list, get ready to evaluate with Jinja2\n            # not sure why the \"/\" is in above code :)\n            try:\n                new_terms = template.template(basedir, \"{{ %s }}\" % terms, inject)\n                if isinstance(new_terms, basestring) and \"{{\" in new_terms:\n                    pass\n                else:\n                    terms = new_terms\n            except:\n                pass\n\n        if '{' in terms or '[' in terms:\n            # Jinja2 already evaluated a variable to a list.\n            # Jinja2-ified list needs to be converted back to a real type\n            # TODO: something a bit less heavy than eval\n            return safe_eval(terms)\n\n        if isinstance(terms, basestring):\n            terms = [ terms ]\n\n    return terms\n\ndef combine_vars(a, b):\n\n    if C.DEFAULT_HASH_BEHAVIOUR == \"merge\":\n        return merge_hash(a, b)\n    else:\n        return dict(a.items() + b.items())\n\ndef random_password(length=20, chars=C.DEFAULT_PASSWORD_CHARS):\n    '''Return a random password string of length containing only chars.'''\n\n    password = []\n    while len(password) < length:\n        new_char = os.urandom(1)\n        if new_char in chars:\n            password.append(new_char)\n\n    return ''.join(password)\n\ndef before_comment(msg):\n    ''' what's the part of a string before a comment? '''\n    msg = msg.replace(\"\\#\",\"**NOT_A_COMMENT**\")\n    msg = msg.split(\"#\")[0]\n    msg = msg.replace(\"**NOT_A_COMMENT**\",\"#\")\n    return msg\n\n\n\n", "#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\n# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>, and others\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport datetime\nimport traceback\nimport re\nimport shlex\nimport os\n\nDOCUMENTATION = '''\n---\nmodule: command\nversion_added: historical\nshort_description: Executes a command on a remote node\ndescription:\n     - The M(command) module takes the command name followed by a list of space-delimited arguments.\n     - The given command will be executed on all selected nodes. It will not be\n       processed through the shell, so variables like C($HOME) and operations\n       like C(\"<\"), C(\">\"), C(\"|\"), and C(\"&\") will not work (use the M(shell)\n       module if you need these features).\noptions:\n  free_form:\n    description:\n      - the command module takes a free form command to run.  There is no parameter actually named 'free form'.\n        See the examples!\n    required: true\n    default: null\n    aliases: []\n  creates:\n    description:\n      - a filename, when it already exists, this step will B(not) be run.\n    required: no\n    default: null\n  removes:\n    description:\n      - a filename, when it does not exist, this step will B(not) be run.\n    version_added: \"0.8\"\n    required: no\n    default: null\n  chdir:\n    description:\n      - cd into this directory before running the command\n    version_added: \"0.6\"\n    required: false\n    default: null\n  executable:\n    description:\n      - change the shell used to execute the command. Should be an absolute path to the executable.\n    required: false\n    default: null\n    version_added: \"0.9\"\nnotes:\n    -  If you want to run a command through the shell (say you are using C(<),\n       C(>), C(|), etc), you actually want the M(shell) module instead. The\n       M(command) module is much more secure as it's not affected by the user's\n       environment.\n    -  \" C(creates), C(removes), and C(chdir) can be specified after the command. For instance, if you only want to run a command if a certain file does not exist, use this.\"\nauthor: Michael DeHaan\n'''\n\nEXAMPLES = '''\n# Example from Ansible Playbooks\n- command: /sbin/shutdown -t now\n\n# Run the command if the specified file does not exist\n- command: /usr/bin/make_database.sh arg1 arg2 creates=/path/to/database\n'''\n\ndef main():\n\n    # the command module is the one ansible module that does not take key=value args\n    # hence don't copy this one if you are looking to build others!\n    module = CommandModule(argument_spec=dict())\n\n    shell = module.params['shell']\n    chdir = module.params['chdir']\n    executable = module.params['executable']\n    args  = module.params['args']\n    creates  = module.params['creates']\n    removes  = module.params['removes']\n\n    if args.strip() == '':\n        module.fail_json(rc=256, msg=\"no command given\")\n\n    if chdir:\n        os.chdir(chdir)\n\n    if creates:\n        # do not run the command if the line contains creates=filename\n        # and the filename already exists.  This allows idempotence\n        # of command executions.\n        v = os.path.expanduser(creates)\n        if os.path.exists(v):\n            module.exit_json(\n                cmd=args,\n                stdout=\"skipped, since %s exists\" % v,\n                skipped=True,\n                changed=False,\n                stderr=False,\n                rc=0\n            )\n\n    if removes:\n    # do not run the command if the line contains removes=filename\n    # and the filename does not exist.  This allows idempotence\n    # of command executions.\n        v = os.path.expanduser(removes)\n        if not os.path.exists(v):\n            module.exit_json(\n                cmd=args,\n                stdout=\"skipped, since %s does not exist\" % v,\n                skipped=True,\n                changed=False,\n                stderr=False,\n                rc=0\n            )\n\n    if not shell:\n        args = shlex.split(args)\n    startd = datetime.datetime.now()\n\n    rc, out, err = module.run_command(args, executable=executable, use_unsafe_shell=shell)\n\n    endd = datetime.datetime.now()\n    delta = endd - startd\n\n    if out is None:\n        out = ''\n    if err is None:\n        err = ''\n\n    module.exit_json(\n        cmd     = args,\n        stdout  = out.rstrip(\"\\r\\n\"),\n        stderr  = err.rstrip(\"\\r\\n\"),\n        rc      = rc,\n        start   = str(startd),\n        end     = str(endd),\n        delta   = str(delta),\n        changed = True\n    )\n\n# import module snippets\nfrom ansible.module_utils.basic import *\n\n# only the command module should ever need to do this\n# everything else should be simple key=value\n\nclass CommandModule(AnsibleModule):\n\n    def _handle_aliases(self):\n        return {}\n\n    def _check_invalid_arguments(self):\n        pass\n\n    def _load_params(self):\n        ''' read the input and return a dictionary and the arguments string '''\n        args = MODULE_ARGS\n        params = {}\n        params['chdir']      = None\n        params['creates']    = None\n        params['removes']    = None\n        params['shell']      = False\n        params['executable'] = None\n        if \"#USE_SHELL\" in args:\n            args = args.replace(\"#USE_SHELL\", \"\")\n            params['shell'] = True\n\n        # use shlex to split up the args, while being careful to preserve\n        # single quotes so they're not removed accidentally\n        lexer = shlex.shlex(args, posix=True)\n        lexer.whitespace_split = True\n        lexer.quotes = '\"'\n        lexer.ignore_quotes = \"'\"\n        items = list(lexer)\n\n        command_args = ''\n        for x in items:\n            if '=' in x:\n                # check to see if this is a special parameter for the command\n                k, v = x.split('=', 1)\n                if k in ('creates', 'removes', 'chdir', 'executable', 'NO_LOG'):\n                    if k == \"chdir\":\n                        v = os.path.abspath(os.path.expanduser(v))\n                        if not (os.path.exists(v) and os.path.isdir(v)):\n                            self.fail_json(rc=258, msg=\"cannot change to directory '%s': path does not exist\" % v)\n                    elif k == \"executable\":\n                        v = os.path.abspath(os.path.expanduser(v))\n                        if not (os.path.exists(v)):\n                            self.fail_json(rc=258, msg=\"cannot use executable '%s': file does not exist\" % v)\n                    params[k] = v\n                else:\n                    # this isn't a valid parameter, so just append it back to the list of arguments\n                    command_args = \"%s %s\" % (command_args, x)\n            else:\n                # not a param, so just append it to the list of arguments\n                command_args = \"%s %s\" % (command_args, x)\n        params['args'] = command_args.strip()\n        return (params, params['args'])\n\nmain()\n", "# test code for iterating with lookup plugins\n# (c) 2014, James Tanner <tanner.jc@gmail.com>\n\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\n\n# WITH_ITEMS\n\n- name: test with_items\n  set_fact: \"{{ item }}=moo\"\n  with_items:\n    - 'foo'\n    - 'bar'\n\n- debug: var=foo\n- debug: var=bar\n\n- name: verify with_items results\n  assert:\n    that:\n        - \"foo == 'moo'\"\n        - \"bar == 'moo'\"\n\n# WITH_NESTED\n\n- name: test with_nested\n  set_fact: \"{{ item.0 + item.1 }}=x\"\n  with_nested:\n    - [ 'a', 'b' ]\n    - [ 'c', 'd' ]        \n\n- debug: var=ac\n- debug: var=ad\n- debug: var=bc\n- debug: var=bd\n\n- name: verify with_nested results\n  assert:\n    that:\n        - \"ac == 'x'\"\n        - \"ad == 'x'\"\n        - \"bc == 'x'\"\n        - \"bd == 'x'\"\n\n# WITH_SEQUENCE\n\n- name: test with_sequence\n  set_fact: \"{{ 'x' + item }}={{ item }}\"\n  with_sequence: start=0 end=3\n\n- name: verify with_sequence\n  assert:\n    that:\n        - \"x0 == '0'\"\n        - \"x1 == '1'\"\n        - \"x2 == '2'\"\n        - \"x3 == '3'\"\n\n# WITH_RANDOM_CHOICE\n\n- name: test with_random_choice\n  set_fact: \"random={{ item }}\"\n  with_random_choice:\n    - \"foo\"\n    - \"bar\" \n\n- name: verify with_random_choice\n  assert:\n    that:\n        - \"random in ['foo', 'bar']\"\n\n# WITH_SUBELEMENTS\n\n- name: test with_subelements\n  set_fact: \"{{ '_'+ item.0.id + item.1 }}={{ item.1 }}\"\n  with_subelements:\n    - element_data\n    - the_list\n\n- name: verify with_subelements results\n  assert:\n    that:\n        - \"_xf == 'f'\"\n        - \"_xd == 'd'\"\n        - \"_ye == 'e'\"\n        - \"_yf == 'f'\"\n\n# WITH_TOGETHER        \n\n- name: test with_together\n  #shell: echo {{ item }}\n  set_fact: \"{{ item.0 }}={{ item.1 }}\"\n  with_together:\n    - [ 'a', 'b', 'c', 'd' ]\n    - [ '1', '2', '3', '4' ]\n\n- name: verify with_together results\n  assert:\n    that:\n        - \"a == '1'\"\n        - \"b == '2'\"\n        - \"c == '3'\"\n        - \"d == '4'\"\n\n# WITH_FIRST_FOUND\n\n- name: create file for test\n  shell: echo \"foo\" > {{ output_dir }}/foo1\n\n- name: create file for test\n  shell: echo \"bar\" > {{ output_dir }}/bar1\n\n- name: test with_first_found\n  #shell: echo {{ item }}\n  set_fact: \"first_found={{ item }}\"\n  with_first_found:\n    - \"{{ output_dir + '/does_not_exist' }}\"\n    - \"{{ output_dir + '/foo1' }}\"\n    - \"{{ output_dir + '/bar1' }}\"\n\n- name: set expected\n  set_fact: first_expected=\"{{ output_dir | expanduser + '/foo1' }}\"\n\n- name: set unexpected\n  set_fact: first_unexpected=\"{{ output_dir | expanduser + '/bar1' }}\"\n\n- name: verify with_first_found results\n  assert:\n    that:\n        - \"first_found == first_expected\"  \n        - \"first_found != first_unexpected\"\n\n# WITH_LINES\n\n- name: test with_lines\n  #shell: echo \"{{ item }}\"\n  set_fact: \"{{ item }}=set\" \n  with_lines: for i in $(seq 1 5); do echo \"l$i\" ; done;\n\n- name: verify with_lines results\n  assert:\n    that:\n        - \"l1 == 'set'\"\n        - \"l2 == 'set'\"\n        - \"l3 == 'set'\"\n        - \"l4 == 'set'\"\n        - \"l5 == 'set'\"\n\n# WITH_INDEX\n- name: create unindexed list\n  shell: for i in $(seq 1 5); do echo \"x\" ; done;\n  register: list_data\n\n- name: create indexed list\n  set_fact: \"{{ item[1] + item[0]|string }}=set\"\n  with_indexed_items: list_data.stdout_lines  \n\n- name: verify with_indexed_items result\n  assert:\n    that:\n        - \"x0 == 'set'\"\n        - \"x1 == 'set'\"\n        - \"x2 == 'set'\"\n        - \"x3 == 'set'\"\n        - \"x4 == 'set'\"\n\n# WITH_FLATTENED\n\n- name: test with_flattened\n  set_fact: \"{{ item }}=flattened\"\n  with_flattened:\n    - [ 'a__' ]\n    - [ 'b__', ['c__', 'd__'] ]        \n\n- name: verify with_flattened results\n  assert:\n    that:\n        - \"a__ == 'flattened'\"\n        - \"b__ == 'flattened'\"\n        - \"c__ == 'flattened'\"\n        - \"d__ == 'flattened'\"\n\n\n"], "filenames": ["lib/ansible/module_utils/basic.py", "lib/ansible/runner/__init__.py", "lib/ansible/runner/action_plugins/assemble.py", "lib/ansible/runner/action_plugins/copy.py", "lib/ansible/runner/action_plugins/template.py", "lib/ansible/utils/__init__.py", "library/commands/command", "test/integration/roles/test_iterators/tasks/main.yml"], "buggy_code_start_loc": [774, 33, 125, 241, 120, 53, 179, 22], "buggy_code_end_loc": [774, 826, 136, 269, 126, 1070, 211, 184], "fixing_code_start_loc": [775, 34, 125, 241, 120, 54, 179, 22], "fixing_code_end_loc": [777, 873, 147, 278, 131, 1104, 218, 183], "type": "CWE-74", "message": "Multiple argument injection vulnerabilities in Ansible before 1.6.7 allow remote attackers to execute arbitrary code by leveraging access to an Ansible managed host and providing a crafted fact, as demonstrated by a fact with (1) a trailing \" src=\" clause, (2) a trailing \" temp=\" clause, or (3) a trailing \" validate=\" clause accompanied by a shell command.", "other": {"cve": {"id": "CVE-2014-4967", "sourceIdentifier": "cve@mitre.org", "published": "2020-02-18T15:15:11.957", "lastModified": "2020-02-26T15:35:08.750", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Multiple argument injection vulnerabilities in Ansible before 1.6.7 allow remote attackers to execute arbitrary code by leveraging access to an Ansible managed host and providing a crafted fact, as demonstrated by a fact with (1) a trailing \" src=\" clause, (2) a trailing \" temp=\" clause, or (3) a trailing \" validate=\" clause accompanied by a shell command."}, {"lang": "es", "value": "M\u00faltiples vulnerabilidades de inyecci\u00f3n de argumentos en Ansible versiones anteriores a 1.6.7, permiten a atacantes remotos ejecutar c\u00f3digo arbitrario al aprovechar el acceso a un host administrado de Ansible y proporcionar un dato dise\u00f1ado como es demostrado por un dato con (1) una cl\u00e1usula \"src=\" al final, (2) una cl\u00e1usula \"temp=\" al final, o (3) una cl\u00e1usula \"validate=\" al final, acompa\u00f1ada de un comando de shell."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ansible:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.7", "matchCriteriaId": "ADA7D67A-D8FE-44B1-96D5-3870DEE3A219"}]}]}], "references": [{"url": "http://www.ocert.org/advisories/ocert-2014-004.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/ansible/ansible/commit/62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ansible/ansible/commit/62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527"}}