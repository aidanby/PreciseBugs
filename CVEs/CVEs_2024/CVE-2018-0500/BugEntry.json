{"buggy_code": ["/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * RFC1870 SMTP Service Extension for Message Size\n * RFC2195 CRAM-MD5 authentication\n * RFC2831 DIGEST-MD5 authentication\n * RFC3207 SMTP over TLS\n * RFC4422 Simple Authentication and Security Layer (SASL)\n * RFC4616 PLAIN authentication\n * RFC4752 The Kerberos V5 (\"GSSAPI\") SASL Mechanism\n * RFC4954 SMTP Authentication\n * RFC5321 SMTP protocol\n * RFC6749 OAuth 2.0 Authorization Framework\n * Draft   SMTP URL Interface   <draft-earhart-url-smtp-00.txt>\n * Draft   LOGIN SASL Mechanism <draft-murchison-sasl-login-00.txt>\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifndef CURL_DISABLE_SMTP\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef HAVE_UTSNAME_H\n#include <sys/utsname.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef __VMS\n#include <in.h>\n#include <inet.h>\n#endif\n\n#if (defined(NETWARE) && defined(__NOVELL_LIBC__))\n#undef in_addr_t\n#define in_addr_t unsigned long\n#endif\n\n#include <curl/curl.h>\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"hostip.h\"\n#include \"progress.h\"\n#include \"transfer.h\"\n#include \"escape.h\"\n#include \"http.h\" /* for HTTP proxy tunnel stuff */\n#include \"mime.h\"\n#include \"socks.h\"\n#include \"smtp.h\"\n#include \"strtoofft.h\"\n#include \"strcase.h\"\n#include \"vtls/vtls.h\"\n#include \"connect.h\"\n#include \"strerror.h\"\n#include \"select.h\"\n#include \"multiif.h\"\n#include \"url.h\"\n#include \"curl_gethostname.h\"\n#include \"curl_sasl.h\"\n#include \"warnless.h\"\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* Local API functions */\nstatic CURLcode smtp_regular_transfer(struct connectdata *conn, bool *done);\nstatic CURLcode smtp_do(struct connectdata *conn, bool *done);\nstatic CURLcode smtp_done(struct connectdata *conn, CURLcode status,\n                          bool premature);\nstatic CURLcode smtp_connect(struct connectdata *conn, bool *done);\nstatic CURLcode smtp_disconnect(struct connectdata *conn, bool dead);\nstatic CURLcode smtp_multi_statemach(struct connectdata *conn, bool *done);\nstatic int smtp_getsock(struct connectdata *conn, curl_socket_t *socks,\n                        int numsocks);\nstatic CURLcode smtp_doing(struct connectdata *conn, bool *dophase_done);\nstatic CURLcode smtp_setup_connection(struct connectdata *conn);\nstatic CURLcode smtp_parse_url_options(struct connectdata *conn);\nstatic CURLcode smtp_parse_url_path(struct connectdata *conn);\nstatic CURLcode smtp_parse_custom_request(struct connectdata *conn);\nstatic CURLcode smtp_perform_auth(struct connectdata *conn, const char *mech,\n                                  const char *initresp);\nstatic CURLcode smtp_continue_auth(struct connectdata *conn, const char *resp);\nstatic void smtp_get_message(char *buffer, char **outptr);\n\n/*\n * SMTP protocol handler.\n */\n\nconst struct Curl_handler Curl_handler_smtp = {\n  \"SMTP\",                           /* scheme */\n  smtp_setup_connection,            /* setup_connection */\n  smtp_do,                          /* do_it */\n  smtp_done,                        /* done */\n  ZERO_NULL,                        /* do_more */\n  smtp_connect,                     /* connect_it */\n  smtp_multi_statemach,             /* connecting */\n  smtp_doing,                       /* doing */\n  smtp_getsock,                     /* proto_getsock */\n  smtp_getsock,                     /* doing_getsock */\n  ZERO_NULL,                        /* domore_getsock */\n  ZERO_NULL,                        /* perform_getsock */\n  smtp_disconnect,                  /* disconnect */\n  ZERO_NULL,                        /* readwrite */\n  ZERO_NULL,                        /* connection_check */\n  PORT_SMTP,                        /* defport */\n  CURLPROTO_SMTP,                   /* protocol */\n  PROTOPT_CLOSEACTION | PROTOPT_NOURLQUERY | /* flags */\n  PROTOPT_URLOPTIONS\n};\n\n#ifdef USE_SSL\n/*\n * SMTPS protocol handler.\n */\n\nconst struct Curl_handler Curl_handler_smtps = {\n  \"SMTPS\",                          /* scheme */\n  smtp_setup_connection,            /* setup_connection */\n  smtp_do,                          /* do_it */\n  smtp_done,                        /* done */\n  ZERO_NULL,                        /* do_more */\n  smtp_connect,                     /* connect_it */\n  smtp_multi_statemach,             /* connecting */\n  smtp_doing,                       /* doing */\n  smtp_getsock,                     /* proto_getsock */\n  smtp_getsock,                     /* doing_getsock */\n  ZERO_NULL,                        /* domore_getsock */\n  ZERO_NULL,                        /* perform_getsock */\n  smtp_disconnect,                  /* disconnect */\n  ZERO_NULL,                        /* readwrite */\n  ZERO_NULL,                        /* connection_check */\n  PORT_SMTPS,                       /* defport */\n  CURLPROTO_SMTPS,                  /* protocol */\n  PROTOPT_CLOSEACTION | PROTOPT_SSL\n  | PROTOPT_NOURLQUERY | PROTOPT_URLOPTIONS /* flags */\n};\n#endif\n\n/* SASL parameters for the smtp protocol */\nstatic const struct SASLproto saslsmtp = {\n  \"smtp\",                     /* The service name */\n  334,                        /* Code received when continuation is expected */\n  235,                        /* Code to receive upon authentication success */\n  512 - 8,                    /* Maximum initial response length (no max) */\n  smtp_perform_auth,          /* Send authentication command */\n  smtp_continue_auth,         /* Send authentication continuation */\n  smtp_get_message            /* Get SASL response message */\n};\n\n#ifdef USE_SSL\nstatic void smtp_to_smtps(struct connectdata *conn)\n{\n  /* Change the connection handler */\n  conn->handler = &Curl_handler_smtps;\n\n  /* Set the connection's upgraded to TLS flag */\n  conn->tls_upgraded = TRUE;\n}\n#else\n#define smtp_to_smtps(x) Curl_nop_stmt\n#endif\n\n/***********************************************************************\n *\n * smtp_endofresp()\n *\n * Checks for an ending SMTP status code at the start of the given string, but\n * also detects various capabilities from the EHLO response including the\n * supported authentication mechanisms.\n */\nstatic bool smtp_endofresp(struct connectdata *conn, char *line, size_t len,\n                           int *resp)\n{\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  bool result = FALSE;\n\n  /* Nothing for us */\n  if(len < 4 || !ISDIGIT(line[0]) || !ISDIGIT(line[1]) || !ISDIGIT(line[2]))\n    return FALSE;\n\n  /* Do we have a command response? This should be the response code followed\n     by a space and optionally some text as per RFC-5321 and as outlined in\n     Section 4. Examples of RFC-4954 but some e-mail servers ignore this and\n     only send the response code instead as per Section 4.2. */\n  if(line[3] == ' ' || len == 5) {\n    result = TRUE;\n    *resp = curlx_sltosi(strtol(line, NULL, 10));\n\n    /* Make sure real server never sends internal value */\n    if(*resp == 1)\n      *resp = 0;\n  }\n  /* Do we have a multiline (continuation) response? */\n  else if(line[3] == '-' &&\n          (smtpc->state == SMTP_EHLO || smtpc->state == SMTP_COMMAND)) {\n    result = TRUE;\n    *resp = 1;  /* Internal response code */\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_get_message()\n *\n * Gets the authentication message from the response buffer.\n */\nstatic void smtp_get_message(char *buffer, char **outptr)\n{\n  size_t len = strlen(buffer);\n  char *message = NULL;\n\n  if(len > 4) {\n    /* Find the start of the message */\n    len -= 4;\n    for(message = buffer + 4; *message == ' ' || *message == '\\t';\n        message++, len--)\n      ;\n\n    /* Find the end of the message */\n    for(; len--;)\n      if(message[len] != '\\r' && message[len] != '\\n' && message[len] != ' ' &&\n         message[len] != '\\t')\n        break;\n\n    /* Terminate the message */\n    if(++len) {\n      message[len] = '\\0';\n    }\n  }\n  else\n    /* junk input => zero length output */\n    message = &buffer[len];\n\n  *outptr = message;\n}\n\n/***********************************************************************\n *\n * state()\n *\n * This is the ONLY way to change SMTP state!\n */\nstatic void state(struct connectdata *conn, smtpstate newstate)\n{\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n  /* for debug purposes */\n  static const char * const names[] = {\n    \"STOP\",\n    \"SERVERGREET\",\n    \"EHLO\",\n    \"HELO\",\n    \"STARTTLS\",\n    \"UPGRADETLS\",\n    \"AUTH\",\n    \"COMMAND\",\n    \"MAIL\",\n    \"RCPT\",\n    \"DATA\",\n    \"POSTDATA\",\n    \"QUIT\",\n    /* LAST */\n  };\n\n  if(smtpc->state != newstate)\n    infof(conn->data, \"SMTP %p state change from %s to %s\\n\",\n          (void *)smtpc, names[smtpc->state], names[newstate]);\n#endif\n\n  smtpc->state = newstate;\n}\n\n/***********************************************************************\n *\n * smtp_perform_ehlo()\n *\n * Sends the EHLO command to not only initialise communication with the ESMTP\n * server but to also obtain a list of server side supported capabilities.\n */\nstatic CURLcode smtp_perform_ehlo(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  smtpc->sasl.authmechs = SASL_AUTH_NONE; /* No known auth. mechanism yet */\n  smtpc->sasl.authused = SASL_AUTH_NONE;  /* Clear the authentication mechanism\n                                             used for esmtp connections */\n  smtpc->tls_supported = FALSE;           /* Clear the TLS capability */\n  smtpc->auth_supported = FALSE;          /* Clear the AUTH capability */\n\n  /* Send the EHLO command */\n  result = Curl_pp_sendf(&smtpc->pp, \"EHLO %s\", smtpc->domain);\n\n  if(!result)\n    state(conn, SMTP_EHLO);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_helo()\n *\n * Sends the HELO command to initialise communication with the SMTP server.\n */\nstatic CURLcode smtp_perform_helo(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  smtpc->sasl.authused = SASL_AUTH_NONE; /* No authentication mechanism used\n                                            in smtp connections */\n\n  /* Send the HELO command */\n  result = Curl_pp_sendf(&smtpc->pp, \"HELO %s\", smtpc->domain);\n\n  if(!result)\n    state(conn, SMTP_HELO);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_starttls()\n *\n * Sends the STLS command to start the upgrade to TLS.\n */\nstatic CURLcode smtp_perform_starttls(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n\n  /* Send the STARTTLS command */\n  result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"%s\", \"STARTTLS\");\n\n  if(!result)\n    state(conn, SMTP_STARTTLS);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_upgrade_tls()\n *\n * Performs the upgrade to TLS.\n */\nstatic CURLcode smtp_perform_upgrade_tls(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  /* Start the SSL connection */\n  result = Curl_ssl_connect_nonblocking(conn, FIRSTSOCKET, &smtpc->ssldone);\n\n  if(!result) {\n    if(smtpc->state != SMTP_UPGRADETLS)\n      state(conn, SMTP_UPGRADETLS);\n\n    if(smtpc->ssldone) {\n      smtp_to_smtps(conn);\n      result = smtp_perform_ehlo(conn);\n    }\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_auth()\n *\n * Sends an AUTH command allowing the client to login with the given SASL\n * authentication mechanism.\n */\nstatic CURLcode smtp_perform_auth(struct connectdata *conn,\n                                  const char *mech,\n                                  const char *initresp)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  if(initresp) {                                  /* AUTH <mech> ...<crlf> */\n    /* Send the AUTH command with the initial response */\n    result = Curl_pp_sendf(&smtpc->pp, \"AUTH %s %s\", mech, initresp);\n  }\n  else {\n    /* Send the AUTH command */\n    result = Curl_pp_sendf(&smtpc->pp, \"AUTH %s\", mech);\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_continue_auth()\n *\n * Sends SASL continuation data or cancellation.\n */\nstatic CURLcode smtp_continue_auth(struct connectdata *conn, const char *resp)\n{\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  return Curl_pp_sendf(&smtpc->pp, \"%s\", resp);\n}\n\n/***********************************************************************\n *\n * smtp_perform_authentication()\n *\n * Initiates the authentication sequence, with the appropriate SASL\n * authentication mechanism.\n */\nstatic CURLcode smtp_perform_authentication(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  saslprogress progress;\n\n  /* Check we have enough data to authenticate with, and the\n     server supports authentiation, and end the connect phase if not */\n  if(!smtpc->auth_supported ||\n     !Curl_sasl_can_authenticate(&smtpc->sasl, conn)) {\n    state(conn, SMTP_STOP);\n    return result;\n  }\n\n  /* Calculate the SASL login details */\n  result = Curl_sasl_start(&smtpc->sasl, conn, FALSE, &progress);\n\n  if(!result) {\n    if(progress == SASL_INPROGRESS)\n      state(conn, SMTP_AUTH);\n    else {\n      /* Other mechanisms not supported */\n      infof(conn->data, \"No known authentication mechanisms supported!\\n\");\n      result = CURLE_LOGIN_DENIED;\n    }\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_command()\n *\n * Sends a SMTP based command.\n */\nstatic CURLcode smtp_perform_command(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n\n  /* Send the command */\n  if(smtp->rcpt)\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"%s %s\",\n                           smtp->custom && smtp->custom[0] != '\\0' ?\n                           smtp->custom : \"VRFY\",\n                           smtp->rcpt->data);\n  else\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"%s\",\n                           smtp->custom && smtp->custom[0] != '\\0' ?\n                           smtp->custom : \"HELP\");\n\n  if(!result)\n    state(conn, SMTP_COMMAND);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_mail()\n *\n * Sends an MAIL command to initiate the upload of a message.\n */\nstatic CURLcode smtp_perform_mail(struct connectdata *conn)\n{\n  char *from = NULL;\n  char *auth = NULL;\n  char *size = NULL;\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  /* Calculate the FROM parameter */\n  if(!data->set.str[STRING_MAIL_FROM])\n    /* Null reverse-path, RFC-5321, sect. 3.6.3 */\n    from = strdup(\"<>\");\n  else if(data->set.str[STRING_MAIL_FROM][0] == '<')\n    from = aprintf(\"%s\", data->set.str[STRING_MAIL_FROM]);\n  else\n    from = aprintf(\"<%s>\", data->set.str[STRING_MAIL_FROM]);\n\n  if(!from)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Calculate the optional AUTH parameter */\n  if(data->set.str[STRING_MAIL_AUTH] && conn->proto.smtpc.sasl.authused) {\n    if(data->set.str[STRING_MAIL_AUTH][0] != '\\0')\n      auth = aprintf(\"%s\", data->set.str[STRING_MAIL_AUTH]);\n    else\n      /* Empty AUTH, RFC-2554, sect. 5 */\n      auth = strdup(\"<>\");\n\n    if(!auth) {\n      free(from);\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* Prepare the mime data if some. */\n  if(data->set.mimepost.kind != MIMEKIND_NONE) {\n    /* Use the whole structure as data. */\n    data->set.mimepost.flags &= ~MIME_BODY_ONLY;\n\n    /* Add external headers and mime version. */\n    curl_mime_headers(&data->set.mimepost, data->set.headers, 0);\n    result = Curl_mime_prepare_headers(&data->set.mimepost, NULL,\n                                       NULL, MIMESTRATEGY_MAIL);\n\n    if(!result)\n      if(!Curl_checkheaders(conn, \"Mime-Version\"))\n        result = Curl_mime_add_header(&data->set.mimepost.curlheaders,\n                                      \"Mime-Version: 1.0\");\n\n    /* Make sure we will read the entire mime structure. */\n    if(!result)\n      result = Curl_mime_rewind(&data->set.mimepost);\n\n    if(result) {\n      free(from);\n      free(auth);\n      return result;\n    }\n\n    data->state.infilesize = Curl_mime_size(&data->set.mimepost);\n\n    /* Read from mime structure. */\n    data->state.fread_func = (curl_read_callback) Curl_mime_read;\n    data->state.in = (void *) &data->set.mimepost;\n  }\n\n  /* Calculate the optional SIZE parameter */\n  if(conn->proto.smtpc.size_supported && data->state.infilesize > 0) {\n    size = aprintf(\"%\" CURL_FORMAT_CURL_OFF_T, data->state.infilesize);\n\n    if(!size) {\n      free(from);\n      free(auth);\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* Send the MAIL command */\n  if(!auth && !size)\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp,\n                           \"MAIL FROM:%s\", from);\n  else if(auth && !size)\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp,\n                           \"MAIL FROM:%s AUTH=%s\", from, auth);\n  else if(auth && size)\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp,\n                           \"MAIL FROM:%s AUTH=%s SIZE=%s\", from, auth, size);\n  else\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp,\n                           \"MAIL FROM:%s SIZE=%s\", from, size);\n\n  free(from);\n  free(auth);\n  free(size);\n\n  if(!result)\n    state(conn, SMTP_MAIL);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_rcpt_to()\n *\n * Sends a RCPT TO command for a given recipient as part of the message upload\n * process.\n */\nstatic CURLcode smtp_perform_rcpt_to(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n\n  /* Send the RCPT TO command */\n  if(smtp->rcpt->data[0] == '<')\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"RCPT TO:%s\",\n                           smtp->rcpt->data);\n  else\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"RCPT TO:<%s>\",\n                           smtp->rcpt->data);\n  if(!result)\n    state(conn, SMTP_RCPT);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_quit()\n *\n * Performs the quit action prior to sclose() being called.\n */\nstatic CURLcode smtp_perform_quit(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n\n  /* Send the QUIT command */\n  result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"%s\", \"QUIT\");\n\n  if(!result)\n    state(conn, SMTP_QUIT);\n\n  return result;\n}\n\n/* For the initial server greeting */\nstatic CURLcode smtp_state_servergreet_resp(struct connectdata *conn,\n                                            int smtpcode,\n                                            smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode/100 != 2) {\n    failf(data, \"Got unexpected smtp-server response: %d\", smtpcode);\n    result = CURLE_WEIRD_SERVER_REPLY;\n  }\n  else\n    result = smtp_perform_ehlo(conn);\n\n  return result;\n}\n\n/* For STARTTLS responses */\nstatic CURLcode smtp_state_starttls_resp(struct connectdata *conn,\n                                         int smtpcode,\n                                         smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode != 220) {\n    if(data->set.use_ssl != CURLUSESSL_TRY) {\n      failf(data, \"STARTTLS denied, code %d\", smtpcode);\n      result = CURLE_USE_SSL_FAILED;\n    }\n    else\n      result = smtp_perform_authentication(conn);\n  }\n  else\n    result = smtp_perform_upgrade_tls(conn);\n\n  return result;\n}\n\n/* For EHLO responses */\nstatic CURLcode smtp_state_ehlo_resp(struct connectdata *conn, int smtpcode,\n                                     smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  const char *line = data->state.buffer;\n  size_t len = strlen(line);\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode/100 != 2 && smtpcode != 1) {\n    if(data->set.use_ssl <= CURLUSESSL_TRY || conn->ssl[FIRSTSOCKET].use)\n      result = smtp_perform_helo(conn);\n    else {\n      failf(data, \"Remote access denied: %d\", smtpcode);\n      result = CURLE_REMOTE_ACCESS_DENIED;\n    }\n  }\n  else {\n    line += 4;\n    len -= 4;\n\n    /* Does the server support the STARTTLS capability? */\n    if(len >= 8 && !memcmp(line, \"STARTTLS\", 8))\n      smtpc->tls_supported = TRUE;\n\n    /* Does the server support the SIZE capability? */\n    else if(len >= 4 && !memcmp(line, \"SIZE\", 4))\n      smtpc->size_supported = TRUE;\n\n    /* Does the server support authentication? */\n    else if(len >= 5 && !memcmp(line, \"AUTH \", 5)) {\n      smtpc->auth_supported = TRUE;\n\n      /* Advance past the AUTH keyword */\n      line += 5;\n      len -= 5;\n\n      /* Loop through the data line */\n      for(;;) {\n        size_t llen;\n        size_t wordlen;\n        unsigned int mechbit;\n\n        while(len &&\n              (*line == ' ' || *line == '\\t' ||\n               *line == '\\r' || *line == '\\n')) {\n\n          line++;\n          len--;\n        }\n\n        if(!len)\n          break;\n\n        /* Extract the word */\n        for(wordlen = 0; wordlen < len && line[wordlen] != ' ' &&\n              line[wordlen] != '\\t' && line[wordlen] != '\\r' &&\n              line[wordlen] != '\\n';)\n          wordlen++;\n\n        /* Test the word for a matching authentication mechanism */\n        mechbit = Curl_sasl_decode_mech(line, wordlen, &llen);\n        if(mechbit && llen == wordlen)\n          smtpc->sasl.authmechs |= mechbit;\n\n        line += wordlen;\n        len -= wordlen;\n      }\n    }\n\n    if(smtpcode != 1) {\n      if(data->set.use_ssl && !conn->ssl[FIRSTSOCKET].use) {\n        /* We don't have a SSL/TLS connection yet, but SSL is requested */\n        if(smtpc->tls_supported)\n          /* Switch to TLS connection now */\n          result = smtp_perform_starttls(conn);\n        else if(data->set.use_ssl == CURLUSESSL_TRY)\n          /* Fallback and carry on with authentication */\n          result = smtp_perform_authentication(conn);\n        else {\n          failf(data, \"STARTTLS not supported.\");\n          result = CURLE_USE_SSL_FAILED;\n        }\n      }\n      else\n        result = smtp_perform_authentication(conn);\n    }\n  }\n\n  return result;\n}\n\n/* For HELO responses */\nstatic CURLcode smtp_state_helo_resp(struct connectdata *conn, int smtpcode,\n                                     smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode/100 != 2) {\n    failf(data, \"Remote access denied: %d\", smtpcode);\n    result = CURLE_REMOTE_ACCESS_DENIED;\n  }\n  else\n    /* End of connect phase */\n    state(conn, SMTP_STOP);\n\n  return result;\n}\n\n/* For SASL authentication responses */\nstatic CURLcode smtp_state_auth_resp(struct connectdata *conn,\n                                     int smtpcode,\n                                     smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  saslprogress progress;\n\n  (void)instate; /* no use for this yet */\n\n  result = Curl_sasl_continue(&smtpc->sasl, conn, smtpcode, &progress);\n  if(!result)\n    switch(progress) {\n    case SASL_DONE:\n      state(conn, SMTP_STOP);  /* Authenticated */\n      break;\n    case SASL_IDLE:            /* No mechanism left after cancellation */\n      failf(data, \"Authentication cancelled\");\n      result = CURLE_LOGIN_DENIED;\n      break;\n    default:\n      break;\n    }\n\n  return result;\n}\n\n/* For command responses */\nstatic CURLcode smtp_state_command_resp(struct connectdata *conn, int smtpcode,\n                                        smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *line = data->state.buffer;\n  size_t len = strlen(line);\n\n  (void)instate; /* no use for this yet */\n\n  if((smtp->rcpt && smtpcode/100 != 2 && smtpcode != 553 && smtpcode != 1) ||\n     (!smtp->rcpt && smtpcode/100 != 2 && smtpcode != 1)) {\n    failf(data, \"Command failed: %d\", smtpcode);\n    result = CURLE_RECV_ERROR;\n  }\n  else {\n    /* Temporarily add the LF character back and send as body to the client */\n    if(!data->set.opt_no_body) {\n      line[len] = '\\n';\n      result = Curl_client_write(conn, CLIENTWRITE_BODY, line, len + 1);\n      line[len] = '\\0';\n    }\n\n    if(smtpcode != 1) {\n      if(smtp->rcpt) {\n        smtp->rcpt = smtp->rcpt->next;\n\n        if(smtp->rcpt) {\n          /* Send the next command */\n          result = smtp_perform_command(conn);\n        }\n        else\n          /* End of DO phase */\n          state(conn, SMTP_STOP);\n      }\n      else\n        /* End of DO phase */\n        state(conn, SMTP_STOP);\n    }\n  }\n\n  return result;\n}\n\n/* For MAIL responses */\nstatic CURLcode smtp_state_mail_resp(struct connectdata *conn, int smtpcode,\n                                     smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode/100 != 2) {\n    failf(data, \"MAIL failed: %d\", smtpcode);\n    result = CURLE_SEND_ERROR;\n  }\n  else\n    /* Start the RCPT TO command */\n    result = smtp_perform_rcpt_to(conn);\n\n  return result;\n}\n\n/* For RCPT responses */\nstatic CURLcode smtp_state_rcpt_resp(struct connectdata *conn, int smtpcode,\n                                     smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode/100 != 2) {\n    failf(data, \"RCPT failed: %d\", smtpcode);\n    result = CURLE_SEND_ERROR;\n  }\n  else {\n    smtp->rcpt = smtp->rcpt->next;\n\n    if(smtp->rcpt)\n      /* Send the next RCPT TO command */\n      result = smtp_perform_rcpt_to(conn);\n    else {\n      /* Send the DATA command */\n      result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"%s\", \"DATA\");\n\n      if(!result)\n        state(conn, SMTP_DATA);\n    }\n  }\n\n  return result;\n}\n\n/* For DATA response */\nstatic CURLcode smtp_state_data_resp(struct connectdata *conn, int smtpcode,\n                                     smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode != 354) {\n    failf(data, \"DATA failed: %d\", smtpcode);\n    result = CURLE_SEND_ERROR;\n  }\n  else {\n    /* Set the progress upload size */\n    Curl_pgrsSetUploadSize(data, data->state.infilesize);\n\n    /* SMTP upload */\n    Curl_setup_transfer(conn, -1, -1, FALSE, NULL, FIRSTSOCKET, NULL);\n\n    /* End of DO phase */\n    state(conn, SMTP_STOP);\n  }\n\n  return result;\n}\n\n/* For POSTDATA responses, which are received after the entire DATA\n   part has been sent to the server */\nstatic CURLcode smtp_state_postdata_resp(struct connectdata *conn,\n                                         int smtpcode,\n                                         smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode != 250)\n    result = CURLE_RECV_ERROR;\n\n  /* End of DONE phase */\n  state(conn, SMTP_STOP);\n\n  return result;\n}\n\nstatic CURLcode smtp_statemach_act(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  curl_socket_t sock = conn->sock[FIRSTSOCKET];\n  struct Curl_easy *data = conn->data;\n  int smtpcode;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct pingpong *pp = &smtpc->pp;\n  size_t nread = 0;\n\n  /* Busy upgrading the connection; right now all I/O is SSL/TLS, not SMTP */\n  if(smtpc->state == SMTP_UPGRADETLS)\n    return smtp_perform_upgrade_tls(conn);\n\n  /* Flush any data that needs to be sent */\n  if(pp->sendleft)\n    return Curl_pp_flushsend(pp);\n\n  do {\n    /* Read the response from the server */\n    result = Curl_pp_readresp(sock, pp, &smtpcode, &nread);\n    if(result)\n      return result;\n\n    /* Store the latest response for later retrieval if necessary */\n    if(smtpc->state != SMTP_QUIT && smtpcode != 1)\n      data->info.httpcode = smtpcode;\n\n    if(!smtpcode)\n      break;\n\n    /* We have now received a full SMTP server response */\n    switch(smtpc->state) {\n    case SMTP_SERVERGREET:\n      result = smtp_state_servergreet_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_EHLO:\n      result = smtp_state_ehlo_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_HELO:\n      result = smtp_state_helo_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_STARTTLS:\n      result = smtp_state_starttls_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_AUTH:\n      result = smtp_state_auth_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_COMMAND:\n      result = smtp_state_command_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_MAIL:\n      result = smtp_state_mail_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_RCPT:\n      result = smtp_state_rcpt_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_DATA:\n      result = smtp_state_data_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_POSTDATA:\n      result = smtp_state_postdata_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_QUIT:\n      /* fallthrough, just stop! */\n    default:\n      /* internal error */\n      state(conn, SMTP_STOP);\n      break;\n    }\n  } while(!result && smtpc->state != SMTP_STOP && Curl_pp_moredata(pp));\n\n  return result;\n}\n\n/* Called repeatedly until done from multi.c */\nstatic CURLcode smtp_multi_statemach(struct connectdata *conn, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  if((conn->handler->flags & PROTOPT_SSL) && !smtpc->ssldone) {\n    result = Curl_ssl_connect_nonblocking(conn, FIRSTSOCKET, &smtpc->ssldone);\n    if(result || !smtpc->ssldone)\n      return result;\n  }\n\n  result = Curl_pp_statemach(&smtpc->pp, FALSE);\n  *done = (smtpc->state == SMTP_STOP) ? TRUE : FALSE;\n\n  return result;\n}\n\nstatic CURLcode smtp_block_statemach(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  while(smtpc->state != SMTP_STOP && !result)\n    result = Curl_pp_statemach(&smtpc->pp, TRUE);\n\n  return result;\n}\n\n/* Allocate and initialize the SMTP struct for the current Curl_easy if\n   required */\nstatic CURLcode smtp_init(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp;\n\n  smtp = data->req.protop = calloc(sizeof(struct SMTP), 1);\n  if(!smtp)\n    result = CURLE_OUT_OF_MEMORY;\n\n  return result;\n}\n\n/* For the SMTP \"protocol connect\" and \"doing\" phases only */\nstatic int smtp_getsock(struct connectdata *conn, curl_socket_t *socks,\n                        int numsocks)\n{\n  return Curl_pp_getsock(&conn->proto.smtpc.pp, socks, numsocks);\n}\n\n/***********************************************************************\n *\n * smtp_connect()\n *\n * This function should do everything that is to be considered a part of\n * the connection phase.\n *\n * The variable pointed to by 'done' will be TRUE if the protocol-layer\n * connect phase is done when this function returns, or FALSE if not.\n */\nstatic CURLcode smtp_connect(struct connectdata *conn, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct pingpong *pp = &smtpc->pp;\n\n  *done = FALSE; /* default to not done yet */\n\n  /* We always support persistent connections in SMTP */\n  connkeep(conn, \"SMTP default\");\n\n  /* Set the default response time-out */\n  pp->response_time = RESP_TIMEOUT;\n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n\n  /* Initialize the SASL storage */\n  Curl_sasl_init(&smtpc->sasl, &saslsmtp);\n\n  /* Initialise the pingpong layer */\n  Curl_pp_init(pp);\n\n  /* Parse the URL options */\n  result = smtp_parse_url_options(conn);\n  if(result)\n    return result;\n\n  /* Parse the URL path */\n  result = smtp_parse_url_path(conn);\n  if(result)\n    return result;\n\n  /* Start off waiting for the server greeting response */\n  state(conn, SMTP_SERVERGREET);\n\n  result = smtp_multi_statemach(conn, done);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_done()\n *\n * The DONE function. This does what needs to be done after a single DO has\n * performed.\n *\n * Input argument is already checked for validity.\n */\nstatic CURLcode smtp_done(struct connectdata *conn, CURLcode status,\n                          bool premature)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  struct pingpong *pp = &conn->proto.smtpc.pp;\n  char *eob;\n  ssize_t len;\n  ssize_t bytes_written;\n\n  (void)premature;\n\n  if(!smtp || !pp->conn)\n    return CURLE_OK;\n\n  /* Cleanup our per-request based variables */\n  Curl_safefree(smtp->custom);\n\n  if(status) {\n    connclose(conn, \"SMTP done with bad status\"); /* marked for closure */\n    result = status;         /* use the already set error code */\n  }\n  else if(!data->set.connect_only && data->set.mail_rcpt &&\n          (data->set.upload || data->set.mimepost.kind)) {\n    /* Calculate the EOB taking into account any terminating CRLF from the\n       previous line of the email or the CRLF of the DATA command when there\n       is \"no mail data\". RFC-5321, sect. 4.1.1.4.\n\n       Note: As some SSL backends, such as OpenSSL, will cause Curl_write() to\n       fail when using a different pointer following a previous write, that\n       returned CURLE_AGAIN, we duplicate the EOB now rather than when the\n       bytes written doesn't equal len. */\n    if(smtp->trailing_crlf || !conn->data->state.infilesize) {\n      eob = strdup(SMTP_EOB + 2);\n      len = SMTP_EOB_LEN - 2;\n    }\n    else {\n      eob = strdup(SMTP_EOB);\n      len = SMTP_EOB_LEN;\n    }\n\n    if(!eob)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* Send the end of block data */\n    result = Curl_write(conn, conn->writesockfd, eob, len, &bytes_written);\n    if(result) {\n      free(eob);\n      return result;\n    }\n\n    if(bytes_written != len) {\n      /* The whole chunk was not sent so keep it around and adjust the\n         pingpong structure accordingly */\n      pp->sendthis = eob;\n      pp->sendsize = len;\n      pp->sendleft = len - bytes_written;\n    }\n    else {\n      /* Successfully sent so adjust the response timeout relative to now */\n      pp->response = Curl_now();\n\n      free(eob);\n    }\n\n    state(conn, SMTP_POSTDATA);\n\n    /* Run the state-machine\n\n       TODO: when the multi interface is used, this _really_ should be using\n       the smtp_multi_statemach function but we have no general support for\n       non-blocking DONE operations!\n    */\n    result = smtp_block_statemach(conn);\n  }\n\n  /* Clear the transfer mode for the next request */\n  smtp->transfer = FTPTRANSFER_BODY;\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform()\n *\n * This is the actual DO function for SMTP. Transfer a mail, send a command\n * or get some data according to the options previously setup.\n */\nstatic CURLcode smtp_perform(struct connectdata *conn, bool *connected,\n                             bool *dophase_done)\n{\n  /* This is SMTP and no proxy */\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n\n  DEBUGF(infof(conn->data, \"DO phase starts\\n\"));\n\n  if(data->set.opt_no_body) {\n    /* Requested no body means no transfer */\n    smtp->transfer = FTPTRANSFER_INFO;\n  }\n\n  *dophase_done = FALSE; /* not done yet */\n\n  /* Store the first recipient (or NULL if not specified) */\n  smtp->rcpt = data->set.mail_rcpt;\n\n  /* Initial data character is the first character in line: it is implicitly\n     preceded by a virtual CRLF. */\n  smtp->trailing_crlf = TRUE;\n  smtp->eob = 2;\n\n  /* Start the first command in the DO phase */\n  if((data->set.upload || data->set.mimepost.kind) && data->set.mail_rcpt)\n    /* MAIL transfer */\n    result = smtp_perform_mail(conn);\n  else\n    /* SMTP based command (VRFY, EXPN, NOOP, RSET or HELP) */\n    result = smtp_perform_command(conn);\n\n  if(result)\n    return result;\n\n  /* Run the state-machine */\n  result = smtp_multi_statemach(conn, dophase_done);\n\n  *connected = conn->bits.tcpconnect[FIRSTSOCKET];\n\n  if(*dophase_done)\n    DEBUGF(infof(conn->data, \"DO phase is complete\\n\"));\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_do()\n *\n * This function is registered as 'curl_do' function. It decodes the path\n * parts etc as a wrapper to the actual DO function (smtp_perform).\n *\n * The input argument is already checked for validity.\n */\nstatic CURLcode smtp_do(struct connectdata *conn, bool *done)\n{\n  CURLcode result = CURLE_OK;\n\n  *done = FALSE; /* default to false */\n\n  /* Parse the custom request */\n  result = smtp_parse_custom_request(conn);\n  if(result)\n    return result;\n\n  result = smtp_regular_transfer(conn, done);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_disconnect()\n *\n * Disconnect from an SMTP server. Cleanup protocol-specific per-connection\n * resources. BLOCKING.\n */\nstatic CURLcode smtp_disconnect(struct connectdata *conn, bool dead_connection)\n{\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  /* We cannot send quit unconditionally. If this connection is stale or\n     bad in any way, sending quit and waiting around here will make the\n     disconnect wait in vain and cause more problems than we need to. */\n\n  /* The SMTP session may or may not have been allocated/setup at this\n     point! */\n  if(!dead_connection && smtpc->pp.conn && smtpc->pp.conn->bits.protoconnstart)\n    if(!smtp_perform_quit(conn))\n      (void)smtp_block_statemach(conn); /* ignore errors on QUIT */\n\n  /* Disconnect from the server */\n  Curl_pp_disconnect(&smtpc->pp);\n\n  /* Cleanup the SASL module */\n  Curl_sasl_cleanup(conn, smtpc->sasl.authused);\n\n  /* Cleanup our connection based variables */\n  Curl_safefree(smtpc->domain);\n\n  return CURLE_OK;\n}\n\n/* Call this when the DO phase has completed */\nstatic CURLcode smtp_dophase_done(struct connectdata *conn, bool connected)\n{\n  struct SMTP *smtp = conn->data->req.protop;\n\n  (void)connected;\n\n  if(smtp->transfer != FTPTRANSFER_BODY)\n    /* no data to transfer */\n    Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);\n\n  return CURLE_OK;\n}\n\n/* Called from multi.c while DOing */\nstatic CURLcode smtp_doing(struct connectdata *conn, bool *dophase_done)\n{\n  CURLcode result = smtp_multi_statemach(conn, dophase_done);\n\n  if(result)\n    DEBUGF(infof(conn->data, \"DO phase failed\\n\"));\n  else if(*dophase_done) {\n    result = smtp_dophase_done(conn, FALSE /* not connected */);\n\n    DEBUGF(infof(conn->data, \"DO phase is complete\\n\"));\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_regular_transfer()\n *\n * The input argument is already checked for validity.\n *\n * Performs all commands done before a regular transfer between a local and a\n * remote host.\n */\nstatic CURLcode smtp_regular_transfer(struct connectdata *conn,\n                                      bool *dophase_done)\n{\n  CURLcode result = CURLE_OK;\n  bool connected = FALSE;\n  struct Curl_easy *data = conn->data;\n\n  /* Make sure size is unknown at this point */\n  data->req.size = -1;\n\n  /* Set the progress data */\n  Curl_pgrsSetUploadCounter(data, 0);\n  Curl_pgrsSetDownloadCounter(data, 0);\n  Curl_pgrsSetUploadSize(data, -1);\n  Curl_pgrsSetDownloadSize(data, -1);\n\n  /* Carry out the perform */\n  result = smtp_perform(conn, &connected, dophase_done);\n\n  /* Perform post DO phase operations if necessary */\n  if(!result && *dophase_done)\n    result = smtp_dophase_done(conn, connected);\n\n  return result;\n}\n\nstatic CURLcode smtp_setup_connection(struct connectdata *conn)\n{\n  struct Curl_easy *data = conn->data;\n  CURLcode result;\n\n  /* Clear the TLS upgraded flag */\n  conn->tls_upgraded = FALSE;\n\n  /* Initialise the SMTP layer */\n  result = smtp_init(conn);\n  if(result)\n    return result;\n\n  data->state.path++;   /* don't include the initial slash */\n\n  return CURLE_OK;\n}\n\n/***********************************************************************\n *\n * smtp_parse_url_options()\n *\n * Parse the URL login options.\n */\nstatic CURLcode smtp_parse_url_options(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  const char *ptr = conn->options;\n\n  smtpc->sasl.resetprefs = TRUE;\n\n  while(!result && ptr && *ptr) {\n    const char *key = ptr;\n    const char *value;\n\n    while(*ptr && *ptr != '=')\n      ptr++;\n\n    value = ptr + 1;\n\n    while(*ptr && *ptr != ';')\n      ptr++;\n\n    if(strncasecompare(key, \"AUTH=\", 5))\n      result = Curl_sasl_parse_url_auth_option(&smtpc->sasl,\n                                               value, ptr - value);\n    else\n      result = CURLE_URL_MALFORMAT;\n\n    if(*ptr == ';')\n      ptr++;\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_parse_url_path()\n *\n * Parse the URL path into separate path components.\n */\nstatic CURLcode smtp_parse_url_path(struct connectdata *conn)\n{\n  /* The SMTP struct is already initialised in smtp_connect() */\n  struct Curl_easy *data = conn->data;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  const char *path = data->state.path;\n  char localhost[HOSTNAME_MAX + 1];\n\n  /* Calculate the path if necessary */\n  if(!*path) {\n    if(!Curl_gethostname(localhost, sizeof(localhost)))\n      path = localhost;\n    else\n      path = \"localhost\";\n  }\n\n  /* URL decode the path and use it as the domain in our EHLO */\n  return Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n}\n\n/***********************************************************************\n *\n * smtp_parse_custom_request()\n *\n * Parse the custom request.\n */\nstatic CURLcode smtp_parse_custom_request(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  const char *custom = data->set.str[STRING_CUSTOMREQUEST];\n\n  /* URL decode the custom request */\n  if(custom)\n    result = Curl_urldecode(data, custom, 0, &smtp->custom, NULL, TRUE);\n\n  return result;\n}\n\nCURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)\n{\n  /* When sending a SMTP payload we must detect CRLF. sequences making sure\n     they are sent as CRLF.. instead, as a . on the beginning of a line will\n     be deleted by the server when not part of an EOB terminator and a\n     genuine CRLF.CRLF which isn't escaped will wrongly be detected as end of\n     data by the server\n  */\n  ssize_t i;\n  ssize_t si;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *scratch = data->state.scratch;\n  char *newscratch = NULL;\n  char *oldscratch = NULL;\n  size_t eob_sent;\n\n  /* Do we need to allocate a scratch buffer? */\n  if(!scratch || data->set.crlf) {\n    oldscratch = scratch;\n\n    scratch = newscratch = malloc(2 * data->set.buffer_size);\n    if(!newscratch) {\n      failf(data, \"Failed to alloc scratch buffer!\");\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* Have we already sent part of the EOB? */\n  eob_sent = smtp->eob;\n\n  /* This loop can be improved by some kind of Boyer-Moore style of\n     approach but that is saved for later... */\n  for(i = 0, si = 0; i < nread; i++) {\n    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {\n      smtp->eob++;\n\n      /* Is the EOB potentially the terminating CRLF? */\n      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)\n        smtp->trailing_crlf = TRUE;\n      else\n        smtp->trailing_crlf = FALSE;\n    }\n    else if(smtp->eob) {\n      /* A previous substring matched so output that first */\n      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n      si += smtp->eob - eob_sent;\n\n      /* Then compare the first byte */\n      if(SMTP_EOB[0] == data->req.upload_fromhere[i])\n        smtp->eob = 1;\n      else\n        smtp->eob = 0;\n\n      eob_sent = 0;\n\n      /* Reset the trailing CRLF flag as there was more data */\n      smtp->trailing_crlf = FALSE;\n    }\n\n    /* Do we have a match for CRLF. as per RFC-5321, sect. 4.5.2 */\n    if(SMTP_EOB_FIND_LEN == smtp->eob) {\n      /* Copy the replacement data to the target buffer */\n      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],\n             SMTP_EOB_REPL_LEN - eob_sent);\n      si += SMTP_EOB_REPL_LEN - eob_sent;\n      smtp->eob = 0;\n      eob_sent = 0;\n    }\n    else if(!smtp->eob)\n      scratch[si++] = data->req.upload_fromhere[i];\n  }\n\n  if(smtp->eob - eob_sent) {\n    /* A substring matched before processing ended so output that now */\n    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n    si += smtp->eob - eob_sent;\n  }\n\n  /* Only use the new buffer if we replaced something */\n  if(si != nread) {\n    /* Upload from the new (replaced) buffer instead */\n    data->req.upload_fromhere = scratch;\n\n    /* Save the buffer so it can be freed later */\n    data->state.scratch = scratch;\n\n    /* Free the old scratch buffer */\n    free(oldscratch);\n\n    /* Set the new amount too */\n    data->req.upload_present = si;\n  }\n  else\n    free(newscratch);\n\n  return CURLE_OK;\n}\n\n#endif /* CURL_DISABLE_SMTP */\n"], "fixing_code": ["/***************************************************************************\n *                                  _   _ ____  _\n *  Project                     ___| | | |  _ \\| |\n *                             / __| | | | |_) | |\n *                            | (__| |_| |  _ <| |___\n *                             \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2018, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at https://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * RFC1870 SMTP Service Extension for Message Size\n * RFC2195 CRAM-MD5 authentication\n * RFC2831 DIGEST-MD5 authentication\n * RFC3207 SMTP over TLS\n * RFC4422 Simple Authentication and Security Layer (SASL)\n * RFC4616 PLAIN authentication\n * RFC4752 The Kerberos V5 (\"GSSAPI\") SASL Mechanism\n * RFC4954 SMTP Authentication\n * RFC5321 SMTP protocol\n * RFC6749 OAuth 2.0 Authorization Framework\n * Draft   SMTP URL Interface   <draft-earhart-url-smtp-00.txt>\n * Draft   LOGIN SASL Mechanism <draft-murchison-sasl-login-00.txt>\n *\n ***************************************************************************/\n\n#include \"curl_setup.h\"\n\n#ifndef CURL_DISABLE_SMTP\n\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef HAVE_UTSNAME_H\n#include <sys/utsname.h>\n#endif\n#ifdef HAVE_NETDB_H\n#include <netdb.h>\n#endif\n#ifdef __VMS\n#include <in.h>\n#include <inet.h>\n#endif\n\n#if (defined(NETWARE) && defined(__NOVELL_LIBC__))\n#undef in_addr_t\n#define in_addr_t unsigned long\n#endif\n\n#include <curl/curl.h>\n#include \"urldata.h\"\n#include \"sendf.h\"\n#include \"hostip.h\"\n#include \"progress.h\"\n#include \"transfer.h\"\n#include \"escape.h\"\n#include \"http.h\" /* for HTTP proxy tunnel stuff */\n#include \"mime.h\"\n#include \"socks.h\"\n#include \"smtp.h\"\n#include \"strtoofft.h\"\n#include \"strcase.h\"\n#include \"vtls/vtls.h\"\n#include \"connect.h\"\n#include \"strerror.h\"\n#include \"select.h\"\n#include \"multiif.h\"\n#include \"url.h\"\n#include \"curl_gethostname.h\"\n#include \"curl_sasl.h\"\n#include \"warnless.h\"\n/* The last 3 #include files should be in this order */\n#include \"curl_printf.h\"\n#include \"curl_memory.h\"\n#include \"memdebug.h\"\n\n/* Local API functions */\nstatic CURLcode smtp_regular_transfer(struct connectdata *conn, bool *done);\nstatic CURLcode smtp_do(struct connectdata *conn, bool *done);\nstatic CURLcode smtp_done(struct connectdata *conn, CURLcode status,\n                          bool premature);\nstatic CURLcode smtp_connect(struct connectdata *conn, bool *done);\nstatic CURLcode smtp_disconnect(struct connectdata *conn, bool dead);\nstatic CURLcode smtp_multi_statemach(struct connectdata *conn, bool *done);\nstatic int smtp_getsock(struct connectdata *conn, curl_socket_t *socks,\n                        int numsocks);\nstatic CURLcode smtp_doing(struct connectdata *conn, bool *dophase_done);\nstatic CURLcode smtp_setup_connection(struct connectdata *conn);\nstatic CURLcode smtp_parse_url_options(struct connectdata *conn);\nstatic CURLcode smtp_parse_url_path(struct connectdata *conn);\nstatic CURLcode smtp_parse_custom_request(struct connectdata *conn);\nstatic CURLcode smtp_perform_auth(struct connectdata *conn, const char *mech,\n                                  const char *initresp);\nstatic CURLcode smtp_continue_auth(struct connectdata *conn, const char *resp);\nstatic void smtp_get_message(char *buffer, char **outptr);\n\n/*\n * SMTP protocol handler.\n */\n\nconst struct Curl_handler Curl_handler_smtp = {\n  \"SMTP\",                           /* scheme */\n  smtp_setup_connection,            /* setup_connection */\n  smtp_do,                          /* do_it */\n  smtp_done,                        /* done */\n  ZERO_NULL,                        /* do_more */\n  smtp_connect,                     /* connect_it */\n  smtp_multi_statemach,             /* connecting */\n  smtp_doing,                       /* doing */\n  smtp_getsock,                     /* proto_getsock */\n  smtp_getsock,                     /* doing_getsock */\n  ZERO_NULL,                        /* domore_getsock */\n  ZERO_NULL,                        /* perform_getsock */\n  smtp_disconnect,                  /* disconnect */\n  ZERO_NULL,                        /* readwrite */\n  ZERO_NULL,                        /* connection_check */\n  PORT_SMTP,                        /* defport */\n  CURLPROTO_SMTP,                   /* protocol */\n  PROTOPT_CLOSEACTION | PROTOPT_NOURLQUERY | /* flags */\n  PROTOPT_URLOPTIONS\n};\n\n#ifdef USE_SSL\n/*\n * SMTPS protocol handler.\n */\n\nconst struct Curl_handler Curl_handler_smtps = {\n  \"SMTPS\",                          /* scheme */\n  smtp_setup_connection,            /* setup_connection */\n  smtp_do,                          /* do_it */\n  smtp_done,                        /* done */\n  ZERO_NULL,                        /* do_more */\n  smtp_connect,                     /* connect_it */\n  smtp_multi_statemach,             /* connecting */\n  smtp_doing,                       /* doing */\n  smtp_getsock,                     /* proto_getsock */\n  smtp_getsock,                     /* doing_getsock */\n  ZERO_NULL,                        /* domore_getsock */\n  ZERO_NULL,                        /* perform_getsock */\n  smtp_disconnect,                  /* disconnect */\n  ZERO_NULL,                        /* readwrite */\n  ZERO_NULL,                        /* connection_check */\n  PORT_SMTPS,                       /* defport */\n  CURLPROTO_SMTPS,                  /* protocol */\n  PROTOPT_CLOSEACTION | PROTOPT_SSL\n  | PROTOPT_NOURLQUERY | PROTOPT_URLOPTIONS /* flags */\n};\n#endif\n\n/* SASL parameters for the smtp protocol */\nstatic const struct SASLproto saslsmtp = {\n  \"smtp\",                     /* The service name */\n  334,                        /* Code received when continuation is expected */\n  235,                        /* Code to receive upon authentication success */\n  512 - 8,                    /* Maximum initial response length (no max) */\n  smtp_perform_auth,          /* Send authentication command */\n  smtp_continue_auth,         /* Send authentication continuation */\n  smtp_get_message            /* Get SASL response message */\n};\n\n#ifdef USE_SSL\nstatic void smtp_to_smtps(struct connectdata *conn)\n{\n  /* Change the connection handler */\n  conn->handler = &Curl_handler_smtps;\n\n  /* Set the connection's upgraded to TLS flag */\n  conn->tls_upgraded = TRUE;\n}\n#else\n#define smtp_to_smtps(x) Curl_nop_stmt\n#endif\n\n/***********************************************************************\n *\n * smtp_endofresp()\n *\n * Checks for an ending SMTP status code at the start of the given string, but\n * also detects various capabilities from the EHLO response including the\n * supported authentication mechanisms.\n */\nstatic bool smtp_endofresp(struct connectdata *conn, char *line, size_t len,\n                           int *resp)\n{\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  bool result = FALSE;\n\n  /* Nothing for us */\n  if(len < 4 || !ISDIGIT(line[0]) || !ISDIGIT(line[1]) || !ISDIGIT(line[2]))\n    return FALSE;\n\n  /* Do we have a command response? This should be the response code followed\n     by a space and optionally some text as per RFC-5321 and as outlined in\n     Section 4. Examples of RFC-4954 but some e-mail servers ignore this and\n     only send the response code instead as per Section 4.2. */\n  if(line[3] == ' ' || len == 5) {\n    result = TRUE;\n    *resp = curlx_sltosi(strtol(line, NULL, 10));\n\n    /* Make sure real server never sends internal value */\n    if(*resp == 1)\n      *resp = 0;\n  }\n  /* Do we have a multiline (continuation) response? */\n  else if(line[3] == '-' &&\n          (smtpc->state == SMTP_EHLO || smtpc->state == SMTP_COMMAND)) {\n    result = TRUE;\n    *resp = 1;  /* Internal response code */\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_get_message()\n *\n * Gets the authentication message from the response buffer.\n */\nstatic void smtp_get_message(char *buffer, char **outptr)\n{\n  size_t len = strlen(buffer);\n  char *message = NULL;\n\n  if(len > 4) {\n    /* Find the start of the message */\n    len -= 4;\n    for(message = buffer + 4; *message == ' ' || *message == '\\t';\n        message++, len--)\n      ;\n\n    /* Find the end of the message */\n    for(; len--;)\n      if(message[len] != '\\r' && message[len] != '\\n' && message[len] != ' ' &&\n         message[len] != '\\t')\n        break;\n\n    /* Terminate the message */\n    if(++len) {\n      message[len] = '\\0';\n    }\n  }\n  else\n    /* junk input => zero length output */\n    message = &buffer[len];\n\n  *outptr = message;\n}\n\n/***********************************************************************\n *\n * state()\n *\n * This is the ONLY way to change SMTP state!\n */\nstatic void state(struct connectdata *conn, smtpstate newstate)\n{\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)\n  /* for debug purposes */\n  static const char * const names[] = {\n    \"STOP\",\n    \"SERVERGREET\",\n    \"EHLO\",\n    \"HELO\",\n    \"STARTTLS\",\n    \"UPGRADETLS\",\n    \"AUTH\",\n    \"COMMAND\",\n    \"MAIL\",\n    \"RCPT\",\n    \"DATA\",\n    \"POSTDATA\",\n    \"QUIT\",\n    /* LAST */\n  };\n\n  if(smtpc->state != newstate)\n    infof(conn->data, \"SMTP %p state change from %s to %s\\n\",\n          (void *)smtpc, names[smtpc->state], names[newstate]);\n#endif\n\n  smtpc->state = newstate;\n}\n\n/***********************************************************************\n *\n * smtp_perform_ehlo()\n *\n * Sends the EHLO command to not only initialise communication with the ESMTP\n * server but to also obtain a list of server side supported capabilities.\n */\nstatic CURLcode smtp_perform_ehlo(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  smtpc->sasl.authmechs = SASL_AUTH_NONE; /* No known auth. mechanism yet */\n  smtpc->sasl.authused = SASL_AUTH_NONE;  /* Clear the authentication mechanism\n                                             used for esmtp connections */\n  smtpc->tls_supported = FALSE;           /* Clear the TLS capability */\n  smtpc->auth_supported = FALSE;          /* Clear the AUTH capability */\n\n  /* Send the EHLO command */\n  result = Curl_pp_sendf(&smtpc->pp, \"EHLO %s\", smtpc->domain);\n\n  if(!result)\n    state(conn, SMTP_EHLO);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_helo()\n *\n * Sends the HELO command to initialise communication with the SMTP server.\n */\nstatic CURLcode smtp_perform_helo(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  smtpc->sasl.authused = SASL_AUTH_NONE; /* No authentication mechanism used\n                                            in smtp connections */\n\n  /* Send the HELO command */\n  result = Curl_pp_sendf(&smtpc->pp, \"HELO %s\", smtpc->domain);\n\n  if(!result)\n    state(conn, SMTP_HELO);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_starttls()\n *\n * Sends the STLS command to start the upgrade to TLS.\n */\nstatic CURLcode smtp_perform_starttls(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n\n  /* Send the STARTTLS command */\n  result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"%s\", \"STARTTLS\");\n\n  if(!result)\n    state(conn, SMTP_STARTTLS);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_upgrade_tls()\n *\n * Performs the upgrade to TLS.\n */\nstatic CURLcode smtp_perform_upgrade_tls(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  /* Start the SSL connection */\n  result = Curl_ssl_connect_nonblocking(conn, FIRSTSOCKET, &smtpc->ssldone);\n\n  if(!result) {\n    if(smtpc->state != SMTP_UPGRADETLS)\n      state(conn, SMTP_UPGRADETLS);\n\n    if(smtpc->ssldone) {\n      smtp_to_smtps(conn);\n      result = smtp_perform_ehlo(conn);\n    }\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_auth()\n *\n * Sends an AUTH command allowing the client to login with the given SASL\n * authentication mechanism.\n */\nstatic CURLcode smtp_perform_auth(struct connectdata *conn,\n                                  const char *mech,\n                                  const char *initresp)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  if(initresp) {                                  /* AUTH <mech> ...<crlf> */\n    /* Send the AUTH command with the initial response */\n    result = Curl_pp_sendf(&smtpc->pp, \"AUTH %s %s\", mech, initresp);\n  }\n  else {\n    /* Send the AUTH command */\n    result = Curl_pp_sendf(&smtpc->pp, \"AUTH %s\", mech);\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_continue_auth()\n *\n * Sends SASL continuation data or cancellation.\n */\nstatic CURLcode smtp_continue_auth(struct connectdata *conn, const char *resp)\n{\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  return Curl_pp_sendf(&smtpc->pp, \"%s\", resp);\n}\n\n/***********************************************************************\n *\n * smtp_perform_authentication()\n *\n * Initiates the authentication sequence, with the appropriate SASL\n * authentication mechanism.\n */\nstatic CURLcode smtp_perform_authentication(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  saslprogress progress;\n\n  /* Check we have enough data to authenticate with, and the\n     server supports authentiation, and end the connect phase if not */\n  if(!smtpc->auth_supported ||\n     !Curl_sasl_can_authenticate(&smtpc->sasl, conn)) {\n    state(conn, SMTP_STOP);\n    return result;\n  }\n\n  /* Calculate the SASL login details */\n  result = Curl_sasl_start(&smtpc->sasl, conn, FALSE, &progress);\n\n  if(!result) {\n    if(progress == SASL_INPROGRESS)\n      state(conn, SMTP_AUTH);\n    else {\n      /* Other mechanisms not supported */\n      infof(conn->data, \"No known authentication mechanisms supported!\\n\");\n      result = CURLE_LOGIN_DENIED;\n    }\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_command()\n *\n * Sends a SMTP based command.\n */\nstatic CURLcode smtp_perform_command(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n\n  /* Send the command */\n  if(smtp->rcpt)\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"%s %s\",\n                           smtp->custom && smtp->custom[0] != '\\0' ?\n                           smtp->custom : \"VRFY\",\n                           smtp->rcpt->data);\n  else\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"%s\",\n                           smtp->custom && smtp->custom[0] != '\\0' ?\n                           smtp->custom : \"HELP\");\n\n  if(!result)\n    state(conn, SMTP_COMMAND);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_mail()\n *\n * Sends an MAIL command to initiate the upload of a message.\n */\nstatic CURLcode smtp_perform_mail(struct connectdata *conn)\n{\n  char *from = NULL;\n  char *auth = NULL;\n  char *size = NULL;\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  /* Calculate the FROM parameter */\n  if(!data->set.str[STRING_MAIL_FROM])\n    /* Null reverse-path, RFC-5321, sect. 3.6.3 */\n    from = strdup(\"<>\");\n  else if(data->set.str[STRING_MAIL_FROM][0] == '<')\n    from = aprintf(\"%s\", data->set.str[STRING_MAIL_FROM]);\n  else\n    from = aprintf(\"<%s>\", data->set.str[STRING_MAIL_FROM]);\n\n  if(!from)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Calculate the optional AUTH parameter */\n  if(data->set.str[STRING_MAIL_AUTH] && conn->proto.smtpc.sasl.authused) {\n    if(data->set.str[STRING_MAIL_AUTH][0] != '\\0')\n      auth = aprintf(\"%s\", data->set.str[STRING_MAIL_AUTH]);\n    else\n      /* Empty AUTH, RFC-2554, sect. 5 */\n      auth = strdup(\"<>\");\n\n    if(!auth) {\n      free(from);\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* Prepare the mime data if some. */\n  if(data->set.mimepost.kind != MIMEKIND_NONE) {\n    /* Use the whole structure as data. */\n    data->set.mimepost.flags &= ~MIME_BODY_ONLY;\n\n    /* Add external headers and mime version. */\n    curl_mime_headers(&data->set.mimepost, data->set.headers, 0);\n    result = Curl_mime_prepare_headers(&data->set.mimepost, NULL,\n                                       NULL, MIMESTRATEGY_MAIL);\n\n    if(!result)\n      if(!Curl_checkheaders(conn, \"Mime-Version\"))\n        result = Curl_mime_add_header(&data->set.mimepost.curlheaders,\n                                      \"Mime-Version: 1.0\");\n\n    /* Make sure we will read the entire mime structure. */\n    if(!result)\n      result = Curl_mime_rewind(&data->set.mimepost);\n\n    if(result) {\n      free(from);\n      free(auth);\n      return result;\n    }\n\n    data->state.infilesize = Curl_mime_size(&data->set.mimepost);\n\n    /* Read from mime structure. */\n    data->state.fread_func = (curl_read_callback) Curl_mime_read;\n    data->state.in = (void *) &data->set.mimepost;\n  }\n\n  /* Calculate the optional SIZE parameter */\n  if(conn->proto.smtpc.size_supported && data->state.infilesize > 0) {\n    size = aprintf(\"%\" CURL_FORMAT_CURL_OFF_T, data->state.infilesize);\n\n    if(!size) {\n      free(from);\n      free(auth);\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n\n  /* Send the MAIL command */\n  if(!auth && !size)\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp,\n                           \"MAIL FROM:%s\", from);\n  else if(auth && !size)\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp,\n                           \"MAIL FROM:%s AUTH=%s\", from, auth);\n  else if(auth && size)\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp,\n                           \"MAIL FROM:%s AUTH=%s SIZE=%s\", from, auth, size);\n  else\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp,\n                           \"MAIL FROM:%s SIZE=%s\", from, size);\n\n  free(from);\n  free(auth);\n  free(size);\n\n  if(!result)\n    state(conn, SMTP_MAIL);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_rcpt_to()\n *\n * Sends a RCPT TO command for a given recipient as part of the message upload\n * process.\n */\nstatic CURLcode smtp_perform_rcpt_to(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n\n  /* Send the RCPT TO command */\n  if(smtp->rcpt->data[0] == '<')\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"RCPT TO:%s\",\n                           smtp->rcpt->data);\n  else\n    result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"RCPT TO:<%s>\",\n                           smtp->rcpt->data);\n  if(!result)\n    state(conn, SMTP_RCPT);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform_quit()\n *\n * Performs the quit action prior to sclose() being called.\n */\nstatic CURLcode smtp_perform_quit(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n\n  /* Send the QUIT command */\n  result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"%s\", \"QUIT\");\n\n  if(!result)\n    state(conn, SMTP_QUIT);\n\n  return result;\n}\n\n/* For the initial server greeting */\nstatic CURLcode smtp_state_servergreet_resp(struct connectdata *conn,\n                                            int smtpcode,\n                                            smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode/100 != 2) {\n    failf(data, \"Got unexpected smtp-server response: %d\", smtpcode);\n    result = CURLE_WEIRD_SERVER_REPLY;\n  }\n  else\n    result = smtp_perform_ehlo(conn);\n\n  return result;\n}\n\n/* For STARTTLS responses */\nstatic CURLcode smtp_state_starttls_resp(struct connectdata *conn,\n                                         int smtpcode,\n                                         smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode != 220) {\n    if(data->set.use_ssl != CURLUSESSL_TRY) {\n      failf(data, \"STARTTLS denied, code %d\", smtpcode);\n      result = CURLE_USE_SSL_FAILED;\n    }\n    else\n      result = smtp_perform_authentication(conn);\n  }\n  else\n    result = smtp_perform_upgrade_tls(conn);\n\n  return result;\n}\n\n/* For EHLO responses */\nstatic CURLcode smtp_state_ehlo_resp(struct connectdata *conn, int smtpcode,\n                                     smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  const char *line = data->state.buffer;\n  size_t len = strlen(line);\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode/100 != 2 && smtpcode != 1) {\n    if(data->set.use_ssl <= CURLUSESSL_TRY || conn->ssl[FIRSTSOCKET].use)\n      result = smtp_perform_helo(conn);\n    else {\n      failf(data, \"Remote access denied: %d\", smtpcode);\n      result = CURLE_REMOTE_ACCESS_DENIED;\n    }\n  }\n  else {\n    line += 4;\n    len -= 4;\n\n    /* Does the server support the STARTTLS capability? */\n    if(len >= 8 && !memcmp(line, \"STARTTLS\", 8))\n      smtpc->tls_supported = TRUE;\n\n    /* Does the server support the SIZE capability? */\n    else if(len >= 4 && !memcmp(line, \"SIZE\", 4))\n      smtpc->size_supported = TRUE;\n\n    /* Does the server support authentication? */\n    else if(len >= 5 && !memcmp(line, \"AUTH \", 5)) {\n      smtpc->auth_supported = TRUE;\n\n      /* Advance past the AUTH keyword */\n      line += 5;\n      len -= 5;\n\n      /* Loop through the data line */\n      for(;;) {\n        size_t llen;\n        size_t wordlen;\n        unsigned int mechbit;\n\n        while(len &&\n              (*line == ' ' || *line == '\\t' ||\n               *line == '\\r' || *line == '\\n')) {\n\n          line++;\n          len--;\n        }\n\n        if(!len)\n          break;\n\n        /* Extract the word */\n        for(wordlen = 0; wordlen < len && line[wordlen] != ' ' &&\n              line[wordlen] != '\\t' && line[wordlen] != '\\r' &&\n              line[wordlen] != '\\n';)\n          wordlen++;\n\n        /* Test the word for a matching authentication mechanism */\n        mechbit = Curl_sasl_decode_mech(line, wordlen, &llen);\n        if(mechbit && llen == wordlen)\n          smtpc->sasl.authmechs |= mechbit;\n\n        line += wordlen;\n        len -= wordlen;\n      }\n    }\n\n    if(smtpcode != 1) {\n      if(data->set.use_ssl && !conn->ssl[FIRSTSOCKET].use) {\n        /* We don't have a SSL/TLS connection yet, but SSL is requested */\n        if(smtpc->tls_supported)\n          /* Switch to TLS connection now */\n          result = smtp_perform_starttls(conn);\n        else if(data->set.use_ssl == CURLUSESSL_TRY)\n          /* Fallback and carry on with authentication */\n          result = smtp_perform_authentication(conn);\n        else {\n          failf(data, \"STARTTLS not supported.\");\n          result = CURLE_USE_SSL_FAILED;\n        }\n      }\n      else\n        result = smtp_perform_authentication(conn);\n    }\n  }\n\n  return result;\n}\n\n/* For HELO responses */\nstatic CURLcode smtp_state_helo_resp(struct connectdata *conn, int smtpcode,\n                                     smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode/100 != 2) {\n    failf(data, \"Remote access denied: %d\", smtpcode);\n    result = CURLE_REMOTE_ACCESS_DENIED;\n  }\n  else\n    /* End of connect phase */\n    state(conn, SMTP_STOP);\n\n  return result;\n}\n\n/* For SASL authentication responses */\nstatic CURLcode smtp_state_auth_resp(struct connectdata *conn,\n                                     int smtpcode,\n                                     smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  saslprogress progress;\n\n  (void)instate; /* no use for this yet */\n\n  result = Curl_sasl_continue(&smtpc->sasl, conn, smtpcode, &progress);\n  if(!result)\n    switch(progress) {\n    case SASL_DONE:\n      state(conn, SMTP_STOP);  /* Authenticated */\n      break;\n    case SASL_IDLE:            /* No mechanism left after cancellation */\n      failf(data, \"Authentication cancelled\");\n      result = CURLE_LOGIN_DENIED;\n      break;\n    default:\n      break;\n    }\n\n  return result;\n}\n\n/* For command responses */\nstatic CURLcode smtp_state_command_resp(struct connectdata *conn, int smtpcode,\n                                        smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *line = data->state.buffer;\n  size_t len = strlen(line);\n\n  (void)instate; /* no use for this yet */\n\n  if((smtp->rcpt && smtpcode/100 != 2 && smtpcode != 553 && smtpcode != 1) ||\n     (!smtp->rcpt && smtpcode/100 != 2 && smtpcode != 1)) {\n    failf(data, \"Command failed: %d\", smtpcode);\n    result = CURLE_RECV_ERROR;\n  }\n  else {\n    /* Temporarily add the LF character back and send as body to the client */\n    if(!data->set.opt_no_body) {\n      line[len] = '\\n';\n      result = Curl_client_write(conn, CLIENTWRITE_BODY, line, len + 1);\n      line[len] = '\\0';\n    }\n\n    if(smtpcode != 1) {\n      if(smtp->rcpt) {\n        smtp->rcpt = smtp->rcpt->next;\n\n        if(smtp->rcpt) {\n          /* Send the next command */\n          result = smtp_perform_command(conn);\n        }\n        else\n          /* End of DO phase */\n          state(conn, SMTP_STOP);\n      }\n      else\n        /* End of DO phase */\n        state(conn, SMTP_STOP);\n    }\n  }\n\n  return result;\n}\n\n/* For MAIL responses */\nstatic CURLcode smtp_state_mail_resp(struct connectdata *conn, int smtpcode,\n                                     smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode/100 != 2) {\n    failf(data, \"MAIL failed: %d\", smtpcode);\n    result = CURLE_SEND_ERROR;\n  }\n  else\n    /* Start the RCPT TO command */\n    result = smtp_perform_rcpt_to(conn);\n\n  return result;\n}\n\n/* For RCPT responses */\nstatic CURLcode smtp_state_rcpt_resp(struct connectdata *conn, int smtpcode,\n                                     smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode/100 != 2) {\n    failf(data, \"RCPT failed: %d\", smtpcode);\n    result = CURLE_SEND_ERROR;\n  }\n  else {\n    smtp->rcpt = smtp->rcpt->next;\n\n    if(smtp->rcpt)\n      /* Send the next RCPT TO command */\n      result = smtp_perform_rcpt_to(conn);\n    else {\n      /* Send the DATA command */\n      result = Curl_pp_sendf(&conn->proto.smtpc.pp, \"%s\", \"DATA\");\n\n      if(!result)\n        state(conn, SMTP_DATA);\n    }\n  }\n\n  return result;\n}\n\n/* For DATA response */\nstatic CURLcode smtp_state_data_resp(struct connectdata *conn, int smtpcode,\n                                     smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode != 354) {\n    failf(data, \"DATA failed: %d\", smtpcode);\n    result = CURLE_SEND_ERROR;\n  }\n  else {\n    /* Set the progress upload size */\n    Curl_pgrsSetUploadSize(data, data->state.infilesize);\n\n    /* SMTP upload */\n    Curl_setup_transfer(conn, -1, -1, FALSE, NULL, FIRSTSOCKET, NULL);\n\n    /* End of DO phase */\n    state(conn, SMTP_STOP);\n  }\n\n  return result;\n}\n\n/* For POSTDATA responses, which are received after the entire DATA\n   part has been sent to the server */\nstatic CURLcode smtp_state_postdata_resp(struct connectdata *conn,\n                                         int smtpcode,\n                                         smtpstate instate)\n{\n  CURLcode result = CURLE_OK;\n\n  (void)instate; /* no use for this yet */\n\n  if(smtpcode != 250)\n    result = CURLE_RECV_ERROR;\n\n  /* End of DONE phase */\n  state(conn, SMTP_STOP);\n\n  return result;\n}\n\nstatic CURLcode smtp_statemach_act(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  curl_socket_t sock = conn->sock[FIRSTSOCKET];\n  struct Curl_easy *data = conn->data;\n  int smtpcode;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct pingpong *pp = &smtpc->pp;\n  size_t nread = 0;\n\n  /* Busy upgrading the connection; right now all I/O is SSL/TLS, not SMTP */\n  if(smtpc->state == SMTP_UPGRADETLS)\n    return smtp_perform_upgrade_tls(conn);\n\n  /* Flush any data that needs to be sent */\n  if(pp->sendleft)\n    return Curl_pp_flushsend(pp);\n\n  do {\n    /* Read the response from the server */\n    result = Curl_pp_readresp(sock, pp, &smtpcode, &nread);\n    if(result)\n      return result;\n\n    /* Store the latest response for later retrieval if necessary */\n    if(smtpc->state != SMTP_QUIT && smtpcode != 1)\n      data->info.httpcode = smtpcode;\n\n    if(!smtpcode)\n      break;\n\n    /* We have now received a full SMTP server response */\n    switch(smtpc->state) {\n    case SMTP_SERVERGREET:\n      result = smtp_state_servergreet_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_EHLO:\n      result = smtp_state_ehlo_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_HELO:\n      result = smtp_state_helo_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_STARTTLS:\n      result = smtp_state_starttls_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_AUTH:\n      result = smtp_state_auth_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_COMMAND:\n      result = smtp_state_command_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_MAIL:\n      result = smtp_state_mail_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_RCPT:\n      result = smtp_state_rcpt_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_DATA:\n      result = smtp_state_data_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_POSTDATA:\n      result = smtp_state_postdata_resp(conn, smtpcode, smtpc->state);\n      break;\n\n    case SMTP_QUIT:\n      /* fallthrough, just stop! */\n    default:\n      /* internal error */\n      state(conn, SMTP_STOP);\n      break;\n    }\n  } while(!result && smtpc->state != SMTP_STOP && Curl_pp_moredata(pp));\n\n  return result;\n}\n\n/* Called repeatedly until done from multi.c */\nstatic CURLcode smtp_multi_statemach(struct connectdata *conn, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  if((conn->handler->flags & PROTOPT_SSL) && !smtpc->ssldone) {\n    result = Curl_ssl_connect_nonblocking(conn, FIRSTSOCKET, &smtpc->ssldone);\n    if(result || !smtpc->ssldone)\n      return result;\n  }\n\n  result = Curl_pp_statemach(&smtpc->pp, FALSE);\n  *done = (smtpc->state == SMTP_STOP) ? TRUE : FALSE;\n\n  return result;\n}\n\nstatic CURLcode smtp_block_statemach(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  while(smtpc->state != SMTP_STOP && !result)\n    result = Curl_pp_statemach(&smtpc->pp, TRUE);\n\n  return result;\n}\n\n/* Allocate and initialize the SMTP struct for the current Curl_easy if\n   required */\nstatic CURLcode smtp_init(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp;\n\n  smtp = data->req.protop = calloc(sizeof(struct SMTP), 1);\n  if(!smtp)\n    result = CURLE_OUT_OF_MEMORY;\n\n  return result;\n}\n\n/* For the SMTP \"protocol connect\" and \"doing\" phases only */\nstatic int smtp_getsock(struct connectdata *conn, curl_socket_t *socks,\n                        int numsocks)\n{\n  return Curl_pp_getsock(&conn->proto.smtpc.pp, socks, numsocks);\n}\n\n/***********************************************************************\n *\n * smtp_connect()\n *\n * This function should do everything that is to be considered a part of\n * the connection phase.\n *\n * The variable pointed to by 'done' will be TRUE if the protocol-layer\n * connect phase is done when this function returns, or FALSE if not.\n */\nstatic CURLcode smtp_connect(struct connectdata *conn, bool *done)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct pingpong *pp = &smtpc->pp;\n\n  *done = FALSE; /* default to not done yet */\n\n  /* We always support persistent connections in SMTP */\n  connkeep(conn, \"SMTP default\");\n\n  /* Set the default response time-out */\n  pp->response_time = RESP_TIMEOUT;\n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n\n  /* Initialize the SASL storage */\n  Curl_sasl_init(&smtpc->sasl, &saslsmtp);\n\n  /* Initialise the pingpong layer */\n  Curl_pp_init(pp);\n\n  /* Parse the URL options */\n  result = smtp_parse_url_options(conn);\n  if(result)\n    return result;\n\n  /* Parse the URL path */\n  result = smtp_parse_url_path(conn);\n  if(result)\n    return result;\n\n  /* Start off waiting for the server greeting response */\n  state(conn, SMTP_SERVERGREET);\n\n  result = smtp_multi_statemach(conn, done);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_done()\n *\n * The DONE function. This does what needs to be done after a single DO has\n * performed.\n *\n * Input argument is already checked for validity.\n */\nstatic CURLcode smtp_done(struct connectdata *conn, CURLcode status,\n                          bool premature)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  struct pingpong *pp = &conn->proto.smtpc.pp;\n  char *eob;\n  ssize_t len;\n  ssize_t bytes_written;\n\n  (void)premature;\n\n  if(!smtp || !pp->conn)\n    return CURLE_OK;\n\n  /* Cleanup our per-request based variables */\n  Curl_safefree(smtp->custom);\n\n  if(status) {\n    connclose(conn, \"SMTP done with bad status\"); /* marked for closure */\n    result = status;         /* use the already set error code */\n  }\n  else if(!data->set.connect_only && data->set.mail_rcpt &&\n          (data->set.upload || data->set.mimepost.kind)) {\n    /* Calculate the EOB taking into account any terminating CRLF from the\n       previous line of the email or the CRLF of the DATA command when there\n       is \"no mail data\". RFC-5321, sect. 4.1.1.4.\n\n       Note: As some SSL backends, such as OpenSSL, will cause Curl_write() to\n       fail when using a different pointer following a previous write, that\n       returned CURLE_AGAIN, we duplicate the EOB now rather than when the\n       bytes written doesn't equal len. */\n    if(smtp->trailing_crlf || !conn->data->state.infilesize) {\n      eob = strdup(SMTP_EOB + 2);\n      len = SMTP_EOB_LEN - 2;\n    }\n    else {\n      eob = strdup(SMTP_EOB);\n      len = SMTP_EOB_LEN;\n    }\n\n    if(!eob)\n      return CURLE_OUT_OF_MEMORY;\n\n    /* Send the end of block data */\n    result = Curl_write(conn, conn->writesockfd, eob, len, &bytes_written);\n    if(result) {\n      free(eob);\n      return result;\n    }\n\n    if(bytes_written != len) {\n      /* The whole chunk was not sent so keep it around and adjust the\n         pingpong structure accordingly */\n      pp->sendthis = eob;\n      pp->sendsize = len;\n      pp->sendleft = len - bytes_written;\n    }\n    else {\n      /* Successfully sent so adjust the response timeout relative to now */\n      pp->response = Curl_now();\n\n      free(eob);\n    }\n\n    state(conn, SMTP_POSTDATA);\n\n    /* Run the state-machine\n\n       TODO: when the multi interface is used, this _really_ should be using\n       the smtp_multi_statemach function but we have no general support for\n       non-blocking DONE operations!\n    */\n    result = smtp_block_statemach(conn);\n  }\n\n  /* Clear the transfer mode for the next request */\n  smtp->transfer = FTPTRANSFER_BODY;\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_perform()\n *\n * This is the actual DO function for SMTP. Transfer a mail, send a command\n * or get some data according to the options previously setup.\n */\nstatic CURLcode smtp_perform(struct connectdata *conn, bool *connected,\n                             bool *dophase_done)\n{\n  /* This is SMTP and no proxy */\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n\n  DEBUGF(infof(conn->data, \"DO phase starts\\n\"));\n\n  if(data->set.opt_no_body) {\n    /* Requested no body means no transfer */\n    smtp->transfer = FTPTRANSFER_INFO;\n  }\n\n  *dophase_done = FALSE; /* not done yet */\n\n  /* Store the first recipient (or NULL if not specified) */\n  smtp->rcpt = data->set.mail_rcpt;\n\n  /* Initial data character is the first character in line: it is implicitly\n     preceded by a virtual CRLF. */\n  smtp->trailing_crlf = TRUE;\n  smtp->eob = 2;\n\n  /* Start the first command in the DO phase */\n  if((data->set.upload || data->set.mimepost.kind) && data->set.mail_rcpt)\n    /* MAIL transfer */\n    result = smtp_perform_mail(conn);\n  else\n    /* SMTP based command (VRFY, EXPN, NOOP, RSET or HELP) */\n    result = smtp_perform_command(conn);\n\n  if(result)\n    return result;\n\n  /* Run the state-machine */\n  result = smtp_multi_statemach(conn, dophase_done);\n\n  *connected = conn->bits.tcpconnect[FIRSTSOCKET];\n\n  if(*dophase_done)\n    DEBUGF(infof(conn->data, \"DO phase is complete\\n\"));\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_do()\n *\n * This function is registered as 'curl_do' function. It decodes the path\n * parts etc as a wrapper to the actual DO function (smtp_perform).\n *\n * The input argument is already checked for validity.\n */\nstatic CURLcode smtp_do(struct connectdata *conn, bool *done)\n{\n  CURLcode result = CURLE_OK;\n\n  *done = FALSE; /* default to false */\n\n  /* Parse the custom request */\n  result = smtp_parse_custom_request(conn);\n  if(result)\n    return result;\n\n  result = smtp_regular_transfer(conn, done);\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_disconnect()\n *\n * Disconnect from an SMTP server. Cleanup protocol-specific per-connection\n * resources. BLOCKING.\n */\nstatic CURLcode smtp_disconnect(struct connectdata *conn, bool dead_connection)\n{\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n\n  /* We cannot send quit unconditionally. If this connection is stale or\n     bad in any way, sending quit and waiting around here will make the\n     disconnect wait in vain and cause more problems than we need to. */\n\n  /* The SMTP session may or may not have been allocated/setup at this\n     point! */\n  if(!dead_connection && smtpc->pp.conn && smtpc->pp.conn->bits.protoconnstart)\n    if(!smtp_perform_quit(conn))\n      (void)smtp_block_statemach(conn); /* ignore errors on QUIT */\n\n  /* Disconnect from the server */\n  Curl_pp_disconnect(&smtpc->pp);\n\n  /* Cleanup the SASL module */\n  Curl_sasl_cleanup(conn, smtpc->sasl.authused);\n\n  /* Cleanup our connection based variables */\n  Curl_safefree(smtpc->domain);\n\n  return CURLE_OK;\n}\n\n/* Call this when the DO phase has completed */\nstatic CURLcode smtp_dophase_done(struct connectdata *conn, bool connected)\n{\n  struct SMTP *smtp = conn->data->req.protop;\n\n  (void)connected;\n\n  if(smtp->transfer != FTPTRANSFER_BODY)\n    /* no data to transfer */\n    Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);\n\n  return CURLE_OK;\n}\n\n/* Called from multi.c while DOing */\nstatic CURLcode smtp_doing(struct connectdata *conn, bool *dophase_done)\n{\n  CURLcode result = smtp_multi_statemach(conn, dophase_done);\n\n  if(result)\n    DEBUGF(infof(conn->data, \"DO phase failed\\n\"));\n  else if(*dophase_done) {\n    result = smtp_dophase_done(conn, FALSE /* not connected */);\n\n    DEBUGF(infof(conn->data, \"DO phase is complete\\n\"));\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_regular_transfer()\n *\n * The input argument is already checked for validity.\n *\n * Performs all commands done before a regular transfer between a local and a\n * remote host.\n */\nstatic CURLcode smtp_regular_transfer(struct connectdata *conn,\n                                      bool *dophase_done)\n{\n  CURLcode result = CURLE_OK;\n  bool connected = FALSE;\n  struct Curl_easy *data = conn->data;\n\n  /* Make sure size is unknown at this point */\n  data->req.size = -1;\n\n  /* Set the progress data */\n  Curl_pgrsSetUploadCounter(data, 0);\n  Curl_pgrsSetDownloadCounter(data, 0);\n  Curl_pgrsSetUploadSize(data, -1);\n  Curl_pgrsSetDownloadSize(data, -1);\n\n  /* Carry out the perform */\n  result = smtp_perform(conn, &connected, dophase_done);\n\n  /* Perform post DO phase operations if necessary */\n  if(!result && *dophase_done)\n    result = smtp_dophase_done(conn, connected);\n\n  return result;\n}\n\nstatic CURLcode smtp_setup_connection(struct connectdata *conn)\n{\n  struct Curl_easy *data = conn->data;\n  CURLcode result;\n\n  /* Clear the TLS upgraded flag */\n  conn->tls_upgraded = FALSE;\n\n  /* Initialise the SMTP layer */\n  result = smtp_init(conn);\n  if(result)\n    return result;\n\n  data->state.path++;   /* don't include the initial slash */\n\n  return CURLE_OK;\n}\n\n/***********************************************************************\n *\n * smtp_parse_url_options()\n *\n * Parse the URL login options.\n */\nstatic CURLcode smtp_parse_url_options(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  const char *ptr = conn->options;\n\n  smtpc->sasl.resetprefs = TRUE;\n\n  while(!result && ptr && *ptr) {\n    const char *key = ptr;\n    const char *value;\n\n    while(*ptr && *ptr != '=')\n      ptr++;\n\n    value = ptr + 1;\n\n    while(*ptr && *ptr != ';')\n      ptr++;\n\n    if(strncasecompare(key, \"AUTH=\", 5))\n      result = Curl_sasl_parse_url_auth_option(&smtpc->sasl,\n                                               value, ptr - value);\n    else\n      result = CURLE_URL_MALFORMAT;\n\n    if(*ptr == ';')\n      ptr++;\n  }\n\n  return result;\n}\n\n/***********************************************************************\n *\n * smtp_parse_url_path()\n *\n * Parse the URL path into separate path components.\n */\nstatic CURLcode smtp_parse_url_path(struct connectdata *conn)\n{\n  /* The SMTP struct is already initialised in smtp_connect() */\n  struct Curl_easy *data = conn->data;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  const char *path = data->state.path;\n  char localhost[HOSTNAME_MAX + 1];\n\n  /* Calculate the path if necessary */\n  if(!*path) {\n    if(!Curl_gethostname(localhost, sizeof(localhost)))\n      path = localhost;\n    else\n      path = \"localhost\";\n  }\n\n  /* URL decode the path and use it as the domain in our EHLO */\n  return Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n}\n\n/***********************************************************************\n *\n * smtp_parse_custom_request()\n *\n * Parse the custom request.\n */\nstatic CURLcode smtp_parse_custom_request(struct connectdata *conn)\n{\n  CURLcode result = CURLE_OK;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  const char *custom = data->set.str[STRING_CUSTOMREQUEST];\n\n  /* URL decode the custom request */\n  if(custom)\n    result = Curl_urldecode(data, custom, 0, &smtp->custom, NULL, TRUE);\n\n  return result;\n}\n\nCURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)\n{\n  /* When sending a SMTP payload we must detect CRLF. sequences making sure\n     they are sent as CRLF.. instead, as a . on the beginning of a line will\n     be deleted by the server when not part of an EOB terminator and a\n     genuine CRLF.CRLF which isn't escaped will wrongly be detected as end of\n     data by the server\n  */\n  ssize_t i;\n  ssize_t si;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *scratch = data->state.scratch;\n  char *newscratch = NULL;\n  char *oldscratch = NULL;\n  size_t eob_sent;\n\n  /* Do we need to allocate a scratch buffer? */\n  if(!scratch || data->set.crlf) {\n    oldscratch = scratch;\n\n    scratch = newscratch = malloc(2 * UPLOAD_BUFSIZE);\n    if(!newscratch) {\n      failf(data, \"Failed to alloc scratch buffer!\");\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  DEBUGASSERT(UPLOAD_BUFSIZE >= nread);\n\n  /* Have we already sent part of the EOB? */\n  eob_sent = smtp->eob;\n\n  /* This loop can be improved by some kind of Boyer-Moore style of\n     approach but that is saved for later... */\n  for(i = 0, si = 0; i < nread; i++) {\n    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {\n      smtp->eob++;\n\n      /* Is the EOB potentially the terminating CRLF? */\n      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)\n        smtp->trailing_crlf = TRUE;\n      else\n        smtp->trailing_crlf = FALSE;\n    }\n    else if(smtp->eob) {\n      /* A previous substring matched so output that first */\n      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n      si += smtp->eob - eob_sent;\n\n      /* Then compare the first byte */\n      if(SMTP_EOB[0] == data->req.upload_fromhere[i])\n        smtp->eob = 1;\n      else\n        smtp->eob = 0;\n\n      eob_sent = 0;\n\n      /* Reset the trailing CRLF flag as there was more data */\n      smtp->trailing_crlf = FALSE;\n    }\n\n    /* Do we have a match for CRLF. as per RFC-5321, sect. 4.5.2 */\n    if(SMTP_EOB_FIND_LEN == smtp->eob) {\n      /* Copy the replacement data to the target buffer */\n      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],\n             SMTP_EOB_REPL_LEN - eob_sent);\n      si += SMTP_EOB_REPL_LEN - eob_sent;\n      smtp->eob = 0;\n      eob_sent = 0;\n    }\n    else if(!smtp->eob)\n      scratch[si++] = data->req.upload_fromhere[i];\n  }\n\n  if(smtp->eob - eob_sent) {\n    /* A substring matched before processing ended so output that now */\n    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n    si += smtp->eob - eob_sent;\n  }\n\n  /* Only use the new buffer if we replaced something */\n  if(si != nread) {\n    /* Upload from the new (replaced) buffer instead */\n    data->req.upload_fromhere = scratch;\n\n    /* Save the buffer so it can be freed later */\n    data->state.scratch = scratch;\n\n    /* Free the old scratch buffer */\n    free(oldscratch);\n\n    /* Set the new amount too */\n    data->req.upload_present = si;\n  }\n  else\n    free(newscratch);\n\n  return CURLE_OK;\n}\n\n#endif /* CURL_DISABLE_SMTP */\n"], "filenames": ["lib/smtp.c"], "buggy_code_start_loc": [1566], "buggy_code_end_loc": [1572], "fixing_code_start_loc": [1566], "fixing_code_end_loc": [1574], "type": "CWE-787", "message": "Curl_smtp_escape_eob in lib/smtp.c in curl 7.54.1 to and including curl 7.60.0 has a heap-based buffer overflow that might be exploitable by an attacker who can control the data that curl transmits over SMTP with certain settings (i.e., use of a nonstandard --limit-rate argument or CURLOPT_BUFFERSIZE value).", "other": {"cve": {"id": "CVE-2018-0500", "sourceIdentifier": "security@debian.org", "published": "2018-07-11T13:29:00.317", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Curl_smtp_escape_eob in lib/smtp.c in curl 7.54.1 to and including curl 7.60.0 has a heap-based buffer overflow that might be exploitable by an attacker who can control the data that curl transmits over SMTP with certain settings (i.e., use of a nonstandard --limit-rate argument or CURLOPT_BUFFERSIZE value)."}, {"lang": "es", "value": "Curl_smtp_escape_eob en lib/smtp.c en curl desde la versi\u00f3n 7.54.1 hasta la 7.60.0 tiene un desbordamiento de b\u00fafer basado en memoria din\u00e1mica (heap) que podr\u00eda ser explotado por un atacante que pueda controlar los datos que curl transmite por SMTP con ciertas opciones (p.ej., el uso de un argumento no est\u00e1ndar --limit-rate o un valor CURLOPT_BUFFERSIZE)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:haxx:curl:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.54.1", "versionEndIncluding": "7.60.0", "matchCriteriaId": "14529B18-3A03-40FB-8B60-9CF0802DA443"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:17.10:*:*:*:*:*:*:*", "matchCriteriaId": "9070C9D8-A14A-467F-8253-33B966C16886"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}]}]}], "references": [{"url": "http://www.securitytracker.com/id/1041280", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2486", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "https://curl.haxx.se/docs/adv_2018-70a2.html", "source": "security@debian.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/curl/curl/commit/ba1dbd78e5f1ed67c1b8d37ac89d90e5e330b628", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201807-04", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3710-1/", "source": "security@debian.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/curl/curl/commit/ba1dbd78e5f1ed67c1b8d37ac89d90e5e330b628"}}