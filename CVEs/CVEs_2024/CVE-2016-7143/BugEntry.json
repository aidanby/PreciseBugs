{"buggy_code": ["/* modules/m_sasl.c\n *   Copyright (C) 2006 Michael Tharp <gxti@partiallystapled.com>\n *   Copyright (C) 2006 charybdis development team\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * 1.Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * 2.Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n * 3.The name of the author may not be used to endorse or promote products\n *   derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * $Id: m_sasl.c 1409 2006-05-21 14:46:17Z jilles $\n */\n\n#include \"stdinc.h\"\n\n#include \"client.h\"\n#include \"hash.h\"\n#include \"send.h\"\n#include \"msg.h\"\n#include \"modules.h\"\n#include \"numeric.h\"\n#include \"s_serv.h\"\n#include \"s_stats.h\"\n#include \"string.h\"\n#include \"s_newconf.h\"\n#include \"s_conf.h\"\n\nstatic int m_authenticate(struct Client *, struct Client *, int, const char **);\nstatic int me_sasl(struct Client *, struct Client *, int, const char **);\n\nstatic void abort_sasl(struct Client *);\nstatic void abort_sasl_exit(hook_data_client_exit *);\n\nstatic void advertise_sasl(struct Client *);\nstatic void advertise_sasl_exit(hook_data_client_exit *);\n\nstruct Message authenticate_msgtab = {\n\t\"AUTHENTICATE\", 0, 0, 0, MFLG_SLOW,\n\t{{m_authenticate, 2}, {m_authenticate, 2}, mg_ignore, mg_ignore, mg_ignore, {m_authenticate, 2}}\n};\nstruct Message sasl_msgtab = {\n\t\"SASL\", 0, 0, 0, MFLG_SLOW,\n\t{mg_ignore, mg_ignore, mg_ignore, mg_ignore, {me_sasl, 5}, mg_ignore}\n};\n\nmapi_clist_av1 sasl_clist[] = {\n\t&authenticate_msgtab, &sasl_msgtab, NULL\n};\nmapi_hfn_list_av1 sasl_hfnlist[] = {\n\t{ \"new_local_user\",\t(hookfn) abort_sasl },\n\t{ \"client_exit\",\t(hookfn) abort_sasl_exit },\n\t{ \"new_remote_user\",\t(hookfn) advertise_sasl },\n\t{ \"client_exit\",\t(hookfn) advertise_sasl_exit },\n\t{ NULL, NULL }\n};\n\nDECLARE_MODULE_AV1(sasl, NULL, NULL, sasl_clist, NULL, sasl_hfnlist, \"$Revision: 1409 $\");\n\nstatic int\nm_authenticate(struct Client *client_p, struct Client *source_p,\n\tint parc, const char *parv[])\n{\n\tstruct Client *agent_p = NULL;\n\tstruct Client *saslserv_p = NULL;\n\n\t/* They really should use CAP for their own sake. */\n\tif(!IsCapable(source_p, CLICAP_SASL))\n\t\treturn 0;\n\n\tif (strlen(client_p->id) == 3)\n\t{\n\t\texit_client(client_p, client_p, client_p, \"Mixing client and server protocol\");\n\t\treturn 0;\n\t}\n\n\tsaslserv_p = find_named_client(ConfigFileEntry.sasl_service);\n\tif (saslserv_p == NULL || !IsService(saslserv_p))\n\t{\n\t\tsendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\n\t\treturn 0;\n\t}\n\n\tif(source_p->localClient->sasl_complete)\n\t{\n\t\t*source_p->localClient->sasl_agent = '\\0';\n\t\tsource_p->localClient->sasl_complete = 0;\n\t}\n\n\tif(strlen(parv[1]) > 400)\n\t{\n\t\tsendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\n\t\treturn 0;\n\t}\n\n\tif(!*source_p->id)\n\t{\n\t\t/* Allocate a UID. */\n\t\tstrcpy(source_p->id, generate_uid());\n\t\tadd_to_id_hash(source_p->id, source_p);\n\t}\n\n\tif(*source_p->localClient->sasl_agent)\n\t\tagent_p = find_id(source_p->localClient->sasl_agent);\n\n\tif(agent_p == NULL)\n\t{\n\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s H %s %s\",\n\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\tsource_p->host, source_p->sockhost);\n\n\t\tif (!strcmp(parv[1], \"EXTERNAL\") && source_p->certfp != NULL)\n\t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s %s\",\n\t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\t\tparv[1], source_p->certfp);\n\t\telse\n\t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s\",\n\t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\t\tparv[1]);\n\n\t\trb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);\n\t}\n\telse\n\t\tsendto_one(agent_p, \":%s ENCAP %s SASL %s %s C %s\",\n\t\t\t\tme.id, agent_p->servptr->name, source_p->id, agent_p->id,\n\t\t\t\tparv[1]);\n\tsource_p->localClient->sasl_out++;\n\n\treturn 0;\n}\n\nstatic int\nme_sasl(struct Client *client_p, struct Client *source_p,\n\tint parc, const char *parv[])\n{\n\tstruct Client *target_p, *agent_p;\n\n\t/* Let propagate if not addressed to us, or if broadcast.\n\t * Only SASL agents can answer global requests.\n\t */\n\tif(strncmp(parv[2], me.id, 3))\n\t\treturn 0;\n\n\tif((target_p = find_id(parv[2])) == NULL)\n\t\treturn 0;\n\n\tif((agent_p = find_id(parv[1])) == NULL)\n\t\treturn 0;\n\n\tif(source_p != agent_p->servptr) /* WTF?! */\n\t\treturn 0;\n\n\t/* We only accept messages from SASL agents; these must have umode +S\n\t * (so the server must be listed in a service{} block).\n\t */\n\tif(!IsService(agent_p))\n\t\treturn 0;\n\n\t/* Reject if someone has already answered. */\n\tif(*target_p->localClient->sasl_agent && strncmp(parv[1], target_p->localClient->sasl_agent, IDLEN))\n\t\treturn 0;\n\telse if(!*target_p->localClient->sasl_agent)\n\t\trb_strlcpy(target_p->localClient->sasl_agent, parv[1], IDLEN);\n\n\tif(*parv[3] == 'C')\n\t\tsendto_one(target_p, \"AUTHENTICATE %s\", parv[4]);\n\telse if(*parv[3] == 'D')\n\t{\n\t\tif(*parv[4] == 'F')\n\t\t\tsendto_one(target_p, form_str(ERR_SASLFAIL), me.name, EmptyString(target_p->name) ? \"*\" : target_p->name);\n\t\telse if(*parv[4] == 'S') {\n\t\t\tsendto_one(target_p, form_str(RPL_SASLSUCCESS), me.name, EmptyString(target_p->name) ? \"*\" : target_p->name);\n\t\t\ttarget_p->localClient->sasl_complete = 1;\n\t\t\tServerStats.is_ssuc++;\n\t\t}\n\t\t*target_p->localClient->sasl_agent = '\\0'; /* Blank the stored agent so someone else can answer */\n\t}\n\telse if(*parv[3] == 'M')\n\t\tsendto_one(target_p, form_str(RPL_SASLMECHS), me.name, EmptyString(target_p->name) ? \"*\" : target_p->name, parv[4]);\n\n\treturn 0;\n}\n\n/* If the client never finished authenticating but is\n * registering anyway, abort the exchange.\n */\nstatic void\nabort_sasl(struct Client *data)\n{\n\tif(data->localClient->sasl_out == 0 || data->localClient->sasl_complete)\n\t\treturn;\n\n\tdata->localClient->sasl_out = data->localClient->sasl_complete = 0;\n\tServerStats.is_sbad++;\n\n\tif(!IsClosing(data))\n\t\tsendto_one(data, form_str(ERR_SASLABORTED), me.name, EmptyString(data->name) ? \"*\" : data->name);\n\n\tif(*data->localClient->sasl_agent)\n\t{\n\t\tstruct Client *agent_p = find_id(data->localClient->sasl_agent);\n\t\tif(agent_p)\n\t\t{\n\t\t\tsendto_one(agent_p, \":%s ENCAP %s SASL %s %s D A\", me.id, agent_p->servptr->name,\n\t\t\t\t\tdata->id, agent_p->id);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsendto_server(NULL, NULL, CAP_TS6|CAP_ENCAP, NOCAPS, \":%s ENCAP * SASL %s * D A\", me.id,\n\t\t\tdata->id);\n}\n\nstatic void\nabort_sasl_exit(hook_data_client_exit *data)\n{\n\tif (data->target->localClient)\n\t\tabort_sasl(data->target);\n}\n\nstatic void\nadvertise_sasl(struct Client *client_p)\n{\n\tif (!ConfigFileEntry.sasl_service)\n\t\treturn;\n\n\tif (irccmp(client_p->name, ConfigFileEntry.sasl_service))\n\t\treturn;\n\n\tsendto_local_clients_with_capability(CLICAP_CAP_NOTIFY, \":%s CAP * NEW :sasl\", me.name);\n}\n\nstatic void\nadvertise_sasl_exit(hook_data_client_exit *data)\n{\n\tif (!ConfigFileEntry.sasl_service)\n\t\treturn;\n\n\tif (irccmp(data->target->name, ConfigFileEntry.sasl_service))\n\t\treturn;\n\n\tsendto_local_clients_with_capability(CLICAP_CAP_NOTIFY, \":%s CAP * DEL :sasl\", me.name);\n}\n"], "fixing_code": ["/* modules/m_sasl.c\n *   Copyright (C) 2006 Michael Tharp <gxti@partiallystapled.com>\n *   Copyright (C) 2006 charybdis development team\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * 1.Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n * 2.Redistributions in binary form must reproduce the above copyright\n *   notice, this list of conditions and the following disclaimer in the\n *   documentation and/or other materials provided with the distribution.\n * 3.The name of the author may not be used to endorse or promote products\n *   derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * $Id: m_sasl.c 1409 2006-05-21 14:46:17Z jilles $\n */\n\n#include \"stdinc.h\"\n\n#include \"client.h\"\n#include \"hash.h\"\n#include \"send.h\"\n#include \"msg.h\"\n#include \"modules.h\"\n#include \"numeric.h\"\n#include \"s_serv.h\"\n#include \"s_stats.h\"\n#include \"string.h\"\n#include \"s_newconf.h\"\n#include \"s_conf.h\"\n\nstatic int m_authenticate(struct Client *, struct Client *, int, const char **);\nstatic int me_sasl(struct Client *, struct Client *, int, const char **);\n\nstatic void abort_sasl(struct Client *);\nstatic void abort_sasl_exit(hook_data_client_exit *);\n\nstatic void advertise_sasl(struct Client *);\nstatic void advertise_sasl_exit(hook_data_client_exit *);\n\nstruct Message authenticate_msgtab = {\n\t\"AUTHENTICATE\", 0, 0, 0, MFLG_SLOW,\n\t{{m_authenticate, 2}, {m_authenticate, 2}, mg_ignore, mg_ignore, mg_ignore, {m_authenticate, 2}}\n};\nstruct Message sasl_msgtab = {\n\t\"SASL\", 0, 0, 0, MFLG_SLOW,\n\t{mg_ignore, mg_ignore, mg_ignore, mg_ignore, {me_sasl, 5}, mg_ignore}\n};\n\nmapi_clist_av1 sasl_clist[] = {\n\t&authenticate_msgtab, &sasl_msgtab, NULL\n};\nmapi_hfn_list_av1 sasl_hfnlist[] = {\n\t{ \"new_local_user\",\t(hookfn) abort_sasl },\n\t{ \"client_exit\",\t(hookfn) abort_sasl_exit },\n\t{ \"new_remote_user\",\t(hookfn) advertise_sasl },\n\t{ \"client_exit\",\t(hookfn) advertise_sasl_exit },\n\t{ NULL, NULL }\n};\n\nDECLARE_MODULE_AV1(sasl, NULL, NULL, sasl_clist, NULL, sasl_hfnlist, \"$Revision: 1409 $\");\n\nstatic int\nm_authenticate(struct Client *client_p, struct Client *source_p,\n\tint parc, const char *parv[])\n{\n\tstruct Client *agent_p = NULL;\n\tstruct Client *saslserv_p = NULL;\n\n\t/* They really should use CAP for their own sake. */\n\tif(!IsCapable(source_p, CLICAP_SASL))\n\t\treturn 0;\n\n\tif (strlen(client_p->id) == 3)\n\t{\n\t\texit_client(client_p, client_p, client_p, \"Mixing client and server protocol\");\n\t\treturn 0;\n\t}\n\n\tif (*parv[1] == ':' || strchr(parv[1], ' '))\n\t{\n\t\texit_client(client_p, client_p, client_p, \"Malformed AUTHENTICATE\");\n\t\treturn 0;\n\t}\n\n\tsaslserv_p = find_named_client(ConfigFileEntry.sasl_service);\n\tif (saslserv_p == NULL || !IsService(saslserv_p))\n\t{\n\t\tsendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\n\t\treturn 0;\n\t}\n\n\tif(source_p->localClient->sasl_complete)\n\t{\n\t\t*source_p->localClient->sasl_agent = '\\0';\n\t\tsource_p->localClient->sasl_complete = 0;\n\t}\n\n\tif(strlen(parv[1]) > 400)\n\t{\n\t\tsendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\n\t\treturn 0;\n\t}\n\n\tif(!*source_p->id)\n\t{\n\t\t/* Allocate a UID. */\n\t\tstrcpy(source_p->id, generate_uid());\n\t\tadd_to_id_hash(source_p->id, source_p);\n\t}\n\n\tif(*source_p->localClient->sasl_agent)\n\t\tagent_p = find_id(source_p->localClient->sasl_agent);\n\n\tif(agent_p == NULL)\n\t{\n\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s H %s %s\",\n\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\tsource_p->host, source_p->sockhost);\n\n\t\tif (!strcmp(parv[1], \"EXTERNAL\") && source_p->certfp != NULL)\n\t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s %s\",\n\t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\t\tparv[1], source_p->certfp);\n\t\telse\n\t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s\",\n\t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\t\tparv[1]);\n\n\t\trb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);\n\t}\n\telse\n\t\tsendto_one(agent_p, \":%s ENCAP %s SASL %s %s C %s\",\n\t\t\t\tme.id, agent_p->servptr->name, source_p->id, agent_p->id,\n\t\t\t\tparv[1]);\n\tsource_p->localClient->sasl_out++;\n\n\treturn 0;\n}\n\nstatic int\nme_sasl(struct Client *client_p, struct Client *source_p,\n\tint parc, const char *parv[])\n{\n\tstruct Client *target_p, *agent_p;\n\n\t/* Let propagate if not addressed to us, or if broadcast.\n\t * Only SASL agents can answer global requests.\n\t */\n\tif(strncmp(parv[2], me.id, 3))\n\t\treturn 0;\n\n\tif((target_p = find_id(parv[2])) == NULL)\n\t\treturn 0;\n\n\tif((agent_p = find_id(parv[1])) == NULL)\n\t\treturn 0;\n\n\tif(source_p != agent_p->servptr) /* WTF?! */\n\t\treturn 0;\n\n\t/* We only accept messages from SASL agents; these must have umode +S\n\t * (so the server must be listed in a service{} block).\n\t */\n\tif(!IsService(agent_p))\n\t\treturn 0;\n\n\t/* Reject if someone has already answered. */\n\tif(*target_p->localClient->sasl_agent && strncmp(parv[1], target_p->localClient->sasl_agent, IDLEN))\n\t\treturn 0;\n\telse if(!*target_p->localClient->sasl_agent)\n\t\trb_strlcpy(target_p->localClient->sasl_agent, parv[1], IDLEN);\n\n\tif(*parv[3] == 'C')\n\t\tsendto_one(target_p, \"AUTHENTICATE %s\", parv[4]);\n\telse if(*parv[3] == 'D')\n\t{\n\t\tif(*parv[4] == 'F')\n\t\t\tsendto_one(target_p, form_str(ERR_SASLFAIL), me.name, EmptyString(target_p->name) ? \"*\" : target_p->name);\n\t\telse if(*parv[4] == 'S') {\n\t\t\tsendto_one(target_p, form_str(RPL_SASLSUCCESS), me.name, EmptyString(target_p->name) ? \"*\" : target_p->name);\n\t\t\ttarget_p->localClient->sasl_complete = 1;\n\t\t\tServerStats.is_ssuc++;\n\t\t}\n\t\t*target_p->localClient->sasl_agent = '\\0'; /* Blank the stored agent so someone else can answer */\n\t}\n\telse if(*parv[3] == 'M')\n\t\tsendto_one(target_p, form_str(RPL_SASLMECHS), me.name, EmptyString(target_p->name) ? \"*\" : target_p->name, parv[4]);\n\n\treturn 0;\n}\n\n/* If the client never finished authenticating but is\n * registering anyway, abort the exchange.\n */\nstatic void\nabort_sasl(struct Client *data)\n{\n\tif(data->localClient->sasl_out == 0 || data->localClient->sasl_complete)\n\t\treturn;\n\n\tdata->localClient->sasl_out = data->localClient->sasl_complete = 0;\n\tServerStats.is_sbad++;\n\n\tif(!IsClosing(data))\n\t\tsendto_one(data, form_str(ERR_SASLABORTED), me.name, EmptyString(data->name) ? \"*\" : data->name);\n\n\tif(*data->localClient->sasl_agent)\n\t{\n\t\tstruct Client *agent_p = find_id(data->localClient->sasl_agent);\n\t\tif(agent_p)\n\t\t{\n\t\t\tsendto_one(agent_p, \":%s ENCAP %s SASL %s %s D A\", me.id, agent_p->servptr->name,\n\t\t\t\t\tdata->id, agent_p->id);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsendto_server(NULL, NULL, CAP_TS6|CAP_ENCAP, NOCAPS, \":%s ENCAP * SASL %s * D A\", me.id,\n\t\t\tdata->id);\n}\n\nstatic void\nabort_sasl_exit(hook_data_client_exit *data)\n{\n\tif (data->target->localClient)\n\t\tabort_sasl(data->target);\n}\n\nstatic void\nadvertise_sasl(struct Client *client_p)\n{\n\tif (!ConfigFileEntry.sasl_service)\n\t\treturn;\n\n\tif (irccmp(client_p->name, ConfigFileEntry.sasl_service))\n\t\treturn;\n\n\tsendto_local_clients_with_capability(CLICAP_CAP_NOTIFY, \":%s CAP * NEW :sasl\", me.name);\n}\n\nstatic void\nadvertise_sasl_exit(hook_data_client_exit *data)\n{\n\tif (!ConfigFileEntry.sasl_service)\n\t\treturn;\n\n\tif (irccmp(data->target->name, ConfigFileEntry.sasl_service))\n\t\treturn;\n\n\tsendto_local_clients_with_capability(CLICAP_CAP_NOTIFY, \":%s CAP * DEL :sasl\", me.name);\n}\n"], "filenames": ["modules/m_sasl.c"], "buggy_code_start_loc": [93], "buggy_code_end_loc": [93], "fixing_code_start_loc": [94], "fixing_code_end_loc": [100], "type": "CWE-285", "message": "The m_authenticate function in modules/m_sasl.c in Charybdis before 3.5.3 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.", "other": {"cve": {"id": "CVE-2016-7143", "sourceIdentifier": "cve@mitre.org", "published": "2016-09-21T14:25:26.177", "lastModified": "2016-11-28T20:37:30.080", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The m_authenticate function in modules/m_sasl.c in Charybdis before 3.5.3 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter."}, {"lang": "es", "value": "La funci\u00f3n m_authenticate en modules/m_sasl.c en Charybdis en versiones anteriores a 3.5.3 permite a atacantes remotos suplantar huellas dactilares de certificados y consecuentemente iniciar sesi\u00f3n como otro usuario a trav\u00e9s de un par\u00e1metro AUTHENTICATE manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:charybdis_project:charybdis:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.5.2", "matchCriteriaId": "FED40C6F-0F70-40CE-A7E6-D9A015186805"}]}]}], "references": [{"url": "http://www.debian.org/security/2016/dsa-3661", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/04/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/05/8", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/92761", "source": "cve@mitre.org"}, {"url": "https://github.com/charybdis-ircd/charybdis/blob/charybdis-3.5.3/NEWS.md", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/charybdis-ircd/charybdis/commit/818a3fda944b26d4814132cee14cfda4ea4aa824", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/charybdis-ircd/charybdis/commit/818a3fda944b26d4814132cee14cfda4ea4aa824"}}