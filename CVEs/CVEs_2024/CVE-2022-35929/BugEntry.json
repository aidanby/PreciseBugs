{"buggy_code": ["//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage verify\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pkcs11key\"\n\t\"github.com/sigstore/cosign/pkg/cosign/rego\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/fulcio\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/rekor\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/cue\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pivkey\"\n\t\"github.com/sigstore/cosign/pkg/policy\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n)\n\n// VerifyAttestationCommand verifies a signature on a supplied container image\n// nolint\ntype VerifyAttestationCommand struct {\n\toptions.RegistryOptions\n\tCheckClaims                  bool\n\tKeyRef                       string\n\tCertRef                      string\n\tCertEmail                    string\n\tCertOidcIssuer               string\n\tCertGithubWorkflowTrigger    string\n\tCertGithubWorkflowSha        string\n\tCertGithubWorkflowName       string\n\tCertGithubWorkflowRepository string\n\tCertGithubWorkflowRef        string\n\tCertChain                    string\n\tEnforceSCT                   bool\n\tSk                           bool\n\tSlot                         string\n\tOutput                       string\n\tRekorURL                     string\n\tPredicateType                string\n\tPolicies                     []string\n\tLocalImage                   bool\n}\n\n// Exec runs the verification command\nfunc (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (err error) {\n\tif len(images) == 0 {\n\t\treturn flag.ErrHelp\n\t}\n\n\tif !options.OneOf(c.KeyRef, c.Sk, c.CertRef) && !options.EnableExperimental() {\n\t\treturn &options.PubKeyParseError{}\n\t}\n\n\tociremoteOpts, err := c.ClientOpts(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"constructing client options: %w\", err)\n\t}\n\tco := &cosign.CheckOpts{\n\t\tRegistryClientOpts:           ociremoteOpts,\n\t\tCertEmail:                    c.CertEmail,\n\t\tCertOidcIssuer:               c.CertOidcIssuer,\n\t\tCertGithubWorkflowTrigger:    c.CertGithubWorkflowTrigger,\n\t\tCertGithubWorkflowSha:        c.CertGithubWorkflowSha,\n\t\tCertGithubWorkflowName:       c.CertGithubWorkflowName,\n\t\tCertGithubWorkflowRepository: c.CertGithubWorkflowRepository,\n\t\tCertGithubWorkflowRef:        c.CertGithubWorkflowRef,\n\t\tEnforceSCT:                   c.EnforceSCT,\n\t}\n\tif c.CheckClaims {\n\t\tco.ClaimVerifier = cosign.IntotoSubjectClaimVerifier\n\t}\n\tif options.EnableExperimental() {\n\t\tif c.RekorURL != \"\" {\n\t\t\trekorClient, err := rekor.NewClient(c.RekorURL)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"creating Rekor client: %w\", err)\n\t\t\t}\n\t\t\tco.RekorClient = rekorClient\n\t\t}\n\t\tco.RootCerts, err = fulcio.GetRoots()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getting Fulcio roots: %w\", err)\n\t\t}\n\t\tco.IntermediateCerts, err = fulcio.GetIntermediates()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getting Fulcio intermediates: %w\", err)\n\t\t}\n\t}\n\tkeyRef := c.KeyRef\n\n\t// Keys are optional!\n\tswitch {\n\tcase keyRef != \"\":\n\t\tco.SigVerifier, err = sigs.PublicKeyFromKeyRef(ctx, keyRef)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading public key: %w\", err)\n\t\t}\n\t\tpkcs11Key, ok := co.SigVerifier.(*pkcs11key.Key)\n\t\tif ok {\n\t\t\tdefer pkcs11Key.Close()\n\t\t}\n\tcase c.Sk:\n\t\tsk, err := pivkey.GetKeyWithSlot(c.Slot)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"opening piv token: %w\", err)\n\t\t}\n\t\tdefer sk.Close()\n\t\tco.SigVerifier, err = sk.Verifier()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"initializing piv token verifier: %w\", err)\n\t\t}\n\tcase c.CertRef != \"\":\n\t\tcert, err := loadCertFromFileOrURL(c.CertRef)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading certificate from reference: %w\", err)\n\t\t}\n\t\tif c.CertChain == \"\" {\n\t\t\terr = cosign.CheckCertificatePolicy(cert, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tco.SigVerifier, err = signature.LoadVerifier(cert.PublicKey, crypto.SHA256)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"creating certificate verifier: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t// Verify certificate with chain\n\t\t\tchain, err := loadCertChainFromFileOrURL(c.CertChain)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tco.SigVerifier, err = cosign.ValidateAndUnpackCertWithChain(cert, chain, co)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"creating certificate verifier: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\t// NB: There are only 2 kinds of verification right now:\n\t// 1. You gave us the public key explicitly to verify against so co.SigVerifier is non-nil or,\n\t// 2. We're going to find an x509 certificate on the signature and verify against Fulcio root trust\n\t// TODO(nsmith5): Refactor this verification logic to pass back _how_ verification\n\t// was performed so we don't need to use this fragile logic here.\n\tfulcioVerified := (co.SigVerifier == nil)\n\n\tfor _, imageRef := range images {\n\t\tvar verified []oci.Signature\n\t\tvar bundleVerified bool\n\n\t\tif c.LocalImage {\n\t\t\tverified, bundleVerified, err = cosign.VerifyLocalImageAttestations(ctx, imageRef, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tref, err := name.ParseReference(imageRef)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tverified, bundleVerified, err = cosign.VerifyImageAttestations(ctx, ref, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tvar cuePolicies, regoPolicies []string\n\n\t\tfor _, policy := range c.Policies {\n\t\t\tswitch filepath.Ext(policy) {\n\t\t\tcase \".rego\":\n\t\t\t\tregoPolicies = append(regoPolicies, policy)\n\t\t\tcase \".cue\":\n\t\t\t\tcuePolicies = append(cuePolicies, policy)\n\t\t\tdefault:\n\t\t\t\treturn errors.New(\"invalid policy format, expected .cue or .rego\")\n\t\t\t}\n\t\t}\n\n\t\tvar validationErrors []error\n\t\tfor _, vp := range verified {\n\t\t\tpayload, err := policy.AttestationToPayloadJSON(ctx, c.PredicateType, vp)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"converting to consumable policy validation: %w\", err)\n\t\t\t}\n\t\t\tif len(payload) == 0 {\n\t\t\t\t// This is not the predicate type we're looking for.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif len(cuePolicies) > 0 {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"will be validating against CUE policies: %v\\n\", cuePolicies)\n\t\t\t\tcueValidationErr := cue.ValidateJSON(payload, cuePolicies)\n\t\t\t\tif cueValidationErr != nil {\n\t\t\t\t\tvalidationErrors = append(validationErrors, cueValidationErr)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(regoPolicies) > 0 {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"will be validating against Rego policies: %v\\n\", regoPolicies)\n\t\t\t\tregoValidationErrs := rego.ValidateJSON(payload, regoPolicies)\n\t\t\t\tif len(regoValidationErrs) > 0 {\n\t\t\t\t\tvalidationErrors = append(validationErrors, regoValidationErrs...)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif len(validationErrors) > 0 {\n\t\t\tfmt.Fprintf(os.Stderr, \"There are %d number of errors occurred during the validation:\\n\", len(validationErrors))\n\t\t\tfor _, v := range validationErrors {\n\t\t\t\t_, _ = fmt.Fprintf(os.Stderr, \"- %v\\n\", v)\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"%d validation errors occurred\", len(validationErrors))\n\t\t}\n\n\t\t// TODO: add CUE validation report to `PrintVerificationHeader`.\n\t\tPrintVerificationHeader(imageRef, co, bundleVerified, fulcioVerified)\n\t\t// The attestations are always JSON, so use the raw \"text\" mode for outputting them instead of conversion\n\t\tPrintVerification(imageRef, verified, \"text\")\n\t}\n\n\treturn nil\n}\n"], "fixing_code": ["//\n// Copyright 2021 The Sigstore Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage verify\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/google/go-containerregistry/pkg/name\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pkcs11key\"\n\t\"github.com/sigstore/cosign/pkg/cosign/rego\"\n\t\"github.com/sigstore/cosign/pkg/oci\"\n\t\"github.com/sigstore/sigstore/pkg/signature\"\n\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/fulcio\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/options\"\n\t\"github.com/sigstore/cosign/cmd/cosign/cli/rekor\"\n\t\"github.com/sigstore/cosign/pkg/cosign\"\n\t\"github.com/sigstore/cosign/pkg/cosign/cue\"\n\t\"github.com/sigstore/cosign/pkg/cosign/pivkey\"\n\t\"github.com/sigstore/cosign/pkg/policy\"\n\tsigs \"github.com/sigstore/cosign/pkg/signature\"\n)\n\n// VerifyAttestationCommand verifies a signature on a supplied container image\n// nolint\ntype VerifyAttestationCommand struct {\n\toptions.RegistryOptions\n\tCheckClaims                  bool\n\tKeyRef                       string\n\tCertRef                      string\n\tCertEmail                    string\n\tCertOidcIssuer               string\n\tCertGithubWorkflowTrigger    string\n\tCertGithubWorkflowSha        string\n\tCertGithubWorkflowName       string\n\tCertGithubWorkflowRepository string\n\tCertGithubWorkflowRef        string\n\tCertChain                    string\n\tEnforceSCT                   bool\n\tSk                           bool\n\tSlot                         string\n\tOutput                       string\n\tRekorURL                     string\n\tPredicateType                string\n\tPolicies                     []string\n\tLocalImage                   bool\n}\n\n// Exec runs the verification command\nfunc (c *VerifyAttestationCommand) Exec(ctx context.Context, images []string) (err error) {\n\tif len(images) == 0 {\n\t\treturn flag.ErrHelp\n\t}\n\n\tif !options.OneOf(c.KeyRef, c.Sk, c.CertRef) && !options.EnableExperimental() {\n\t\treturn &options.PubKeyParseError{}\n\t}\n\n\tociremoteOpts, err := c.ClientOpts(ctx)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"constructing client options: %w\", err)\n\t}\n\tco := &cosign.CheckOpts{\n\t\tRegistryClientOpts:           ociremoteOpts,\n\t\tCertEmail:                    c.CertEmail,\n\t\tCertOidcIssuer:               c.CertOidcIssuer,\n\t\tCertGithubWorkflowTrigger:    c.CertGithubWorkflowTrigger,\n\t\tCertGithubWorkflowSha:        c.CertGithubWorkflowSha,\n\t\tCertGithubWorkflowName:       c.CertGithubWorkflowName,\n\t\tCertGithubWorkflowRepository: c.CertGithubWorkflowRepository,\n\t\tCertGithubWorkflowRef:        c.CertGithubWorkflowRef,\n\t\tEnforceSCT:                   c.EnforceSCT,\n\t}\n\tif c.CheckClaims {\n\t\tco.ClaimVerifier = cosign.IntotoSubjectClaimVerifier\n\t}\n\tif options.EnableExperimental() {\n\t\tif c.RekorURL != \"\" {\n\t\t\trekorClient, err := rekor.NewClient(c.RekorURL)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"creating Rekor client: %w\", err)\n\t\t\t}\n\t\t\tco.RekorClient = rekorClient\n\t\t}\n\t\tco.RootCerts, err = fulcio.GetRoots()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getting Fulcio roots: %w\", err)\n\t\t}\n\t\tco.IntermediateCerts, err = fulcio.GetIntermediates()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"getting Fulcio intermediates: %w\", err)\n\t\t}\n\t}\n\tkeyRef := c.KeyRef\n\n\t// Keys are optional!\n\tswitch {\n\tcase keyRef != \"\":\n\t\tco.SigVerifier, err = sigs.PublicKeyFromKeyRef(ctx, keyRef)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading public key: %w\", err)\n\t\t}\n\t\tpkcs11Key, ok := co.SigVerifier.(*pkcs11key.Key)\n\t\tif ok {\n\t\t\tdefer pkcs11Key.Close()\n\t\t}\n\tcase c.Sk:\n\t\tsk, err := pivkey.GetKeyWithSlot(c.Slot)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"opening piv token: %w\", err)\n\t\t}\n\t\tdefer sk.Close()\n\t\tco.SigVerifier, err = sk.Verifier()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"initializing piv token verifier: %w\", err)\n\t\t}\n\tcase c.CertRef != \"\":\n\t\tcert, err := loadCertFromFileOrURL(c.CertRef)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"loading certificate from reference: %w\", err)\n\t\t}\n\t\tif c.CertChain == \"\" {\n\t\t\terr = cosign.CheckCertificatePolicy(cert, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tco.SigVerifier, err = signature.LoadVerifier(cert.PublicKey, crypto.SHA256)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"creating certificate verifier: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t// Verify certificate with chain\n\t\t\tchain, err := loadCertChainFromFileOrURL(c.CertChain)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tco.SigVerifier, err = cosign.ValidateAndUnpackCertWithChain(cert, chain, co)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"creating certificate verifier: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\t// NB: There are only 2 kinds of verification right now:\n\t// 1. You gave us the public key explicitly to verify against so co.SigVerifier is non-nil or,\n\t// 2. We're going to find an x509 certificate on the signature and verify against Fulcio root trust\n\t// TODO(nsmith5): Refactor this verification logic to pass back _how_ verification\n\t// was performed so we don't need to use this fragile logic here.\n\tfulcioVerified := (co.SigVerifier == nil)\n\n\tfor _, imageRef := range images {\n\t\tvar verified []oci.Signature\n\t\tvar bundleVerified bool\n\n\t\tif c.LocalImage {\n\t\t\tverified, bundleVerified, err = cosign.VerifyLocalImageAttestations(ctx, imageRef, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tref, err := name.ParseReference(imageRef)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tverified, bundleVerified, err = cosign.VerifyImageAttestations(ctx, ref, co)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tvar cuePolicies, regoPolicies []string\n\n\t\tfor _, policy := range c.Policies {\n\t\t\tswitch filepath.Ext(policy) {\n\t\t\tcase \".rego\":\n\t\t\t\tregoPolicies = append(regoPolicies, policy)\n\t\t\tcase \".cue\":\n\t\t\t\tcuePolicies = append(cuePolicies, policy)\n\t\t\tdefault:\n\t\t\t\treturn errors.New(\"invalid policy format, expected .cue or .rego\")\n\t\t\t}\n\t\t}\n\n\t\tvar checked []oci.Signature\n\t\tvar validationErrors []error\n\t\tfor _, vp := range verified {\n\t\t\tpayload, err := policy.AttestationToPayloadJSON(ctx, c.PredicateType, vp)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"converting to consumable policy validation: %w\", err)\n\t\t\t}\n\t\t\tif len(payload) == 0 {\n\t\t\t\t// This is not the predicate type we're looking for.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif len(cuePolicies) > 0 {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"will be validating against CUE policies: %v\\n\", cuePolicies)\n\t\t\t\tcueValidationErr := cue.ValidateJSON(payload, cuePolicies)\n\t\t\t\tif cueValidationErr != nil {\n\t\t\t\t\tvalidationErrors = append(validationErrors, cueValidationErr)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(regoPolicies) > 0 {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"will be validating against Rego policies: %v\\n\", regoPolicies)\n\t\t\t\tregoValidationErrs := rego.ValidateJSON(payload, regoPolicies)\n\t\t\t\tif len(regoValidationErrs) > 0 {\n\t\t\t\t\tvalidationErrors = append(validationErrors, regoValidationErrs...)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchecked = append(checked, vp)\n\t\t}\n\n\t\tif len(validationErrors) > 0 {\n\t\t\tfmt.Fprintf(os.Stderr, \"There are %d number of errors occurred during the validation:\\n\", len(validationErrors))\n\t\t\tfor _, v := range validationErrors {\n\t\t\t\t_, _ = fmt.Fprintf(os.Stderr, \"- %v\\n\", v)\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"%d validation errors occurred\", len(validationErrors))\n\t\t}\n\n\t\tif len(checked) == 0 {\n\t\t\treturn fmt.Errorf(\"none of the attestations matched the predicate type: %s\", c.PredicateType)\n\t\t}\n\n\t\t// TODO: add CUE validation report to `PrintVerificationHeader`.\n\t\tPrintVerificationHeader(imageRef, co, bundleVerified, fulcioVerified)\n\t\t// The attestations are always JSON, so use the raw \"text\" mode for outputting them instead of conversion\n\t\tPrintVerification(imageRef, checked, \"text\")\n\t}\n\n\treturn nil\n}\n"], "filenames": ["cmd/cosign/cli/verify/verify_attestation.go"], "buggy_code_start_loc": [203], "buggy_code_end_loc": [244], "fixing_code_start_loc": [204], "fixing_code_end_loc": [253], "type": "CWE-347", "message": "cosign is a container signing and verification utility. In versions prior to 1.10.1 cosign can report a false positive if any attestation exists. `cosign verify-attestation` used with the `--type` flag will report a false positive verification when there is at least one attestation with a valid signature and there are NO attestations of the type being verified (--type defaults to \"custom\"). This can happen when signing with a standard keypair and with \"keyless\" signing with Fulcio. This vulnerability can be reproduced with the `distroless.dev/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2` image. This image has a `vuln` attestation but not an `spdx` attestation. However, if you run `cosign verify-attestation --type=spdx` on this image, it incorrectly succeeds. This issue has been addressed in version 1.10.1 of cosign. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-35929", "sourceIdentifier": "security-advisories@github.com", "published": "2022-08-04T19:15:09.937", "lastModified": "2022-08-10T18:38:44.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "cosign is a container signing and verification utility. In versions prior to 1.10.1 cosign can report a false positive if any attestation exists. `cosign verify-attestation` used with the `--type` flag will report a false positive verification when there is at least one attestation with a valid signature and there are NO attestations of the type being verified (--type defaults to \"custom\"). This can happen when signing with a standard keypair and with \"keyless\" signing with Fulcio. This vulnerability can be reproduced with the `distroless.dev/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2` image. This image has a `vuln` attestation but not an `spdx` attestation. However, if you run `cosign verify-attestation --type=spdx` on this image, it incorrectly succeeds. This issue has been addressed in version 1.10.1 of cosign. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "cosign es una utilidad de firma y verificaci\u00f3n de contenedores. En versiones anteriores a 1.10.1 cosign puede reportar un falso positivo si se presenta alguna atestaci\u00f3n. Si es usado \"cosign verify-attestation\" con el indicador \"--type\", ser\u00e1 informado de un falso positivo en la verificaci\u00f3n cuando haya al menos un certificado con una firma v\u00e1lida y NO haya certificados del tipo que est\u00e1 siendo verificado (--type es, por defecto, \"custom\"). Esto puede ocurrir cuando es firmado con un par de claves est\u00e1ndar y con la firma \"keyless\" con Fulcio. Esta vulnerabilidad puede reproducirse con la imagen \"distroless.dev/static@sha256:dd7614b5a12bc4d617b223c588b4e0c833402b8f4991fb5702ea83afad1986e2\". Esta imagen presenta una certificaci\u00f3n \"vuln\" pero no una certificaci\u00f3n \"spdx\". Sin embargo, si es ejecutado \"cosign verify-attestation --type=spdx\" en esta imagen, el resultado es incorrecto. Este problema ha sido abordado en versi\u00f3n 1.10.1 de cosign. Es recomendado a usuarios actualizar. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sigstore:cosign:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "6FAFBB9B-E4B0-4C98-8A24-52F23931A39E"}]}]}], "references": [{"url": "https://github.com/sigstore/cosign/commit/c5fda01a8ff33ca981f45a9f13e7fb6bd2080b94", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/sigstore/cosign/security/advisories/GHSA-vjxv-45g9-9296", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sigstore/cosign/commit/c5fda01a8ff33ca981f45a9f13e7fb6bd2080b94"}}