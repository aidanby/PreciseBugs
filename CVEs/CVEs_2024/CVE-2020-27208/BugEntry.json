{"buggy_code": ["// Copyright 2019 SoloKeys Developers\n//\n// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or\n// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or\n// http://opensource.org/licenses/MIT>, at your option. This file may not be\n// copied, modified, or distributed except according to those terms.\n#include \"device.h\"\n#include \"usbd_def.h\"\n#include \"stm32l4xx.h\"\n#include \"stm32l4xx_ll_gpio.h\"\n#include \"stm32l4xx_ll_tim.h\"\n#include \"stm32l4xx_ll_usart.h\"\n#include \"stm32l4xx_ll_pwr.h\"\n#include \"usbd_hid.h\"\n\n#include APP_CONFIG\n#include \"flash.h\"\n#include \"rng.h\"\n#include \"led.h\"\n#include \"device.h\"\n#include \"util.h\"\n#include \"fifo.h\"\n#include \"log.h\"\n#include \"ctaphid.h\"\n#include \"ctap.h\"\n#include \"crypto.h\"\n#include \"memory_layout.h\"\n#include \"stm32l4xx_ll_iwdg.h\"\n#include \"usbd_cdc_if.h\"\n#include \"nfc.h\"\n#include \"init.h\"\n#include \"sense.h\"\n\n#define LOW_FREQUENCY        1\n#define HIGH_FREQUENCY       0\n\n#define SOLO_FLAG_LOCKED                    0x2\n\nvoid wait_for_usb_tether(void);\n\n\nuint32_t __90_ms = 0;\nuint32_t __last_button_press_time = 0;\nuint32_t __last_button_bounce_time = 0;\nuint32_t __device_status = 0;\nuint32_t __last_update = 0;\nextern PCD_HandleTypeDef hpcd;\nstatic int _NFC_status = 0;\nstatic bool isLowFreq = 0;\nstatic bool _up_disabled = false;\n\n// #define IS_BUTTON_PRESSED()         (0  == (LL_GPIO_ReadInputPort(SOLO_BUTTON_PORT) & SOLO_BUTTON_PIN))\nstatic int is_physical_button_pressed(void)\n{\n    return (0  == (LL_GPIO_ReadInputPort(SOLO_BUTTON_PORT) & SOLO_BUTTON_PIN));\n}\n\nstatic int is_touch_button_pressed(void)\n{\n    int is_pressed = (tsc_read_button(0) || tsc_read_button(1));\n#ifndef IS_BOOTLOADER\n    if (is_pressed)\n    {\n        // delay for debounce, and longer than polling timer period.\n        delay(95);\n        return (tsc_read_button(0) || tsc_read_button(1));\n    }\n#endif\n    return is_pressed;\n}\n\nint (*IS_BUTTON_PRESSED)() = is_physical_button_pressed;\n\nstatic void edge_detect_touch_button(void)\n{\n    static uint8_t last_touch = 0;\n    uint8_t current_touch = 0;\n    if (is_touch_button_pressed == IS_BUTTON_PRESSED)\n    {\n        current_touch = (tsc_read_button(0) || tsc_read_button(1));\n\n        // 1 sample per 25 ms\n        if ((millis() - __last_button_bounce_time) > 25)\n        {\n            // Detect \"touch / rising edge\"\n            if (!last_touch && current_touch)\n            {\n                __last_button_press_time = millis();\n            }\n            __last_button_bounce_time = millis();\n            last_touch = current_touch;\n        }\n    }\n\n}\n\nvoid device_disable_up(bool disable)\n{\n    _up_disabled = disable;\n}\n\n// Timer6 overflow handler.  happens every ~90ms.\nvoid TIM6_DAC_IRQHandler(void)\n{\n    // timer is only 16 bits, so roll it over here\n    TIM6->SR = 0;\n    __90_ms += 1;\n    if ((millis() - __last_update) > 90)\n    {\n        if (__device_status != CTAPHID_STATUS_IDLE)\n        {\n            ctaphid_update_status(__device_status);\n        }\n    }\n\n    edge_detect_touch_button();\n\n#ifndef IS_BOOTLOADER\n\t// NFC sending WTX if needs\n\tif (device_is_nfc() == NFC_IS_ACTIVE)\n\t{\n\t\tWTX_timer_exec();\n\t}\n#endif\n}\n\n// Interrupt on rising edge of button (button released)\nvoid EXTI0_IRQHandler(void)\n{\n    EXTI->PR1 = EXTI->PR1;\n    if (is_physical_button_pressed == IS_BUTTON_PRESSED)\n    {\n        // Only allow 1 press per 25 ms.\n        if ((millis() - __last_button_bounce_time) > 25)\n        {\n            __last_button_press_time = millis();\n        }\n        __last_button_bounce_time = millis();\n    }\n}\n\n// Global USB interrupt handler\nvoid USB_IRQHandler(void)\n{\n  HAL_PCD_IRQHandler(&hpcd);\n}\n\nuint32_t millis(void)\n{\n    return (((uint32_t)TIM6->CNT) + (__90_ms * 90));\n}\n\nvoid device_set_status(uint32_t status)\n{\n    __disable_irq();\n    __last_update = millis();\n    __enable_irq();\n\n    if (status != CTAPHID_STATUS_IDLE && __device_status != status)\n    {\n        ctaphid_update_status(status);\n    }\n    __device_status = status;\n}\n\nint device_is_button_pressed(void)\n{\n    return IS_BUTTON_PRESSED();\n}\n\nvoid delay(uint32_t ms)\n{\n    uint32_t time = millis();\n    while ((millis() - time) < ms)\n        ;\n}\n\nvoid device_reboot(void)\n{\n    NVIC_SystemReset();\n}\n\nvoid device_init_button(void)\n{\n    if (tsc_sensor_exists())\n    {\n        tsc_init();\n        IS_BUTTON_PRESSED = is_touch_button_pressed;\n    }\n    else\n    {\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n}\n\nint solo_is_locked(){\n    uint64_t device_settings = ((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->device_settings;\n    uint32_t tag = (uint32_t)(device_settings >> 32ull);\n    return tag == ATTESTATION_CONFIGURED_TAG && (device_settings & SOLO_FLAG_LOCKED) != 0;\n}\n\n// Locks solo flash from debugging.  Locks on next reboot.\n// This should be removed in next Solo release.\nvoid solo_lock_if_not_already() {\n    uint8_t buf[2048];\n\n    memmove(buf, (uint8_t*)ATTESTATION_PAGE_ADDR, 2048);\n\n    ((flash_attestation_page *)buf)->device_settings |= SOLO_FLAG_LOCKED;\n\n    flash_erase_page(ATTESTATION_PAGE);\n\n    flash_write(ATTESTATION_PAGE_ADDR, buf, 2048);\n}\n\n/** device_migrate\n * Depending on version of device, migrates:\n * * Moves attestation certificate to data segment. \n * * Creates locked variable and stores in data segment.\n * \n * Once in place, this allows all devices to accept same firmware,\n * rather than using \"hacker\" and \"secure\" builds.\n*/\nstatic void device_migrate(){\n    extern const uint16_t attestation_solo_cert_der_size;\n    extern const uint16_t attestation_hacker_cert_der_size;\n\n    extern uint8_t attestation_solo_cert_der[];\n    extern uint8_t attestation_hacker_cert_der[];\n\n    uint64_t device_settings = ((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->device_settings;\n    uint32_t configure_tag = (uint32_t)(device_settings >> 32);\n\n    if (configure_tag != ATTESTATION_CONFIGURED_TAG)\n    {\n        printf1(TAG_RED,\"Migrating certificate and lock information to data segment.\\r\\n\");\n\n        device_settings = ATTESTATION_CONFIGURED_TAG;\n        device_settings <<= 32;\n\n        // Read current device lock level.\n        uint32_t optr = FLASH->OPTR;\n        if ((optr & 0xff) != 0xAA){\n            device_settings |= SOLO_FLAG_LOCKED;\n        }\n\n        uint8_t tmp_attestation_key[32];\n\n        memmove(tmp_attestation_key,\n            ((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->attestation_key,\n            32);\n\n        flash_erase_page(ATTESTATION_PAGE);\n        flash_write(\n            (uint32_t)((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->attestation_key,\n            tmp_attestation_key,\n            32\n        );\n\n        // Check if this is Solo Hacker attestation (not confidential)\n        // then write solo or hacker attestation cert to flash page.\n        uint8_t solo_hacker_attestation_key[32] = \"\\x1b\\x26\\x26\\xec\\xc8\\xf6\\x9b\\x0f\\x69\\xe3\\x4f\"\n                                                  \"\\xb2\\x36\\xd7\\x64\\x66\\xba\\x12\\xac\\x16\\xc3\\xab\"\n                                                  \"\\x57\\x50\\xba\\x06\\x4e\\x8b\\x90\\xe0\\x24\\x48\";\n\n        if (memcmp(solo_hacker_attestation_key,\n                   tmp_attestation_key,\n                   32) == 0)\n        {\n            printf1(TAG_GREEN,\"Updating solo hacker cert\\r\\n\");\n            flash_write_dword(\n             (uint32_t)&((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->attestation_cert_size,\n             (uint64_t)attestation_hacker_cert_der_size\n             );\n            flash_write(\n                (uint32_t)((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->attestation_cert,\n                attestation_hacker_cert_der,\n                attestation_hacker_cert_der_size\n            );\n        }\n        else\n        {\n            printf1(TAG_GREEN,\"Updating solo secure cert\\r\\n\");\n            flash_write_dword(\n             (uint32_t)&((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->attestation_cert_size,\n             (uint64_t)attestation_solo_cert_der_size\n             );\n            flash_write(\n                (uint32_t)((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->attestation_cert,\n                attestation_solo_cert_der,\n                attestation_solo_cert_der_size\n            );\n        }\n\n        // Save / done.\n        flash_write_dword(\n            (uint32_t) & ((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->device_settings,\n            (uint64_t)device_settings);\n    }\n}\n\nvoid device_init()\n{\n\n    hw_init(LOW_FREQUENCY);\n\n    if (! tsc_sensor_exists())\n    {\n        _NFC_status = nfc_init();\n    }\n\n    if (_NFC_status == NFC_IS_ACTIVE)\n    {\n        printf1(TAG_NFC, \"Have NFC\\r\\n\");\n        isLowFreq = 1;\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n    else\n    {\n        printf1(TAG_NFC, \"Have NO NFC\\r\\n\");\n        hw_init(HIGH_FREQUENCY);\n        isLowFreq = 0;\n        device_init_button();\n    }\n\n    usbhid_init();\n    ctaphid_init();\n    ctap_init();\n\n    device_migrate();\n\n#if BOOT_TO_DFU\n    flash_option_bytes_init(1);\n#else\n    flash_option_bytes_init(0);\n#endif\n\n\n}\n\nint device_is_nfc(void)\n{\n    return _NFC_status;\n}\n\nvoid wait_for_usb_tether(void)\n{\n    while (USBD_OK != CDC_Transmit_FS((uint8_t*)\"tethered\\r\\n\", 10) )\n        ;\n    while (USBD_OK != CDC_Transmit_FS((uint8_t*)\"tethered\\r\\n\", 10) )\n        ;\n    delay(10);\n    while (USBD_OK != CDC_Transmit_FS((uint8_t*)\"tethered\\r\\n\", 10) )\n        ;\n}\n\nvoid usbhid_init(void)\n{\n    if (!isLowFreq)\n    {\n        init_usb();\n\n#if DEBUG_LEVEL>1\n        wait_for_usb_tether();\n#endif\n    }\n    else\n    {\n\n\n\n    }\n}\n\n\n\nint usbhid_recv(uint8_t * msg)\n{\n    if (fifo_hidmsg_size())\n    {\n        fifo_hidmsg_take(msg);\n        printf1(TAG_DUMP2,\">> \");\n        dump_hex1(TAG_DUMP2,msg, HID_PACKET_SIZE);\n        return HID_PACKET_SIZE;\n    }\n    return 0;\n}\n\nvoid usbhid_send(uint8_t * msg)\n{\n\n    printf1(TAG_DUMP2,\"<< \");\n    dump_hex1(TAG_DUMP2, msg, HID_PACKET_SIZE);\n    while (PCD_GET_EP_TX_STATUS(USB, HID_EPIN_ADDR & 0x0f) == USB_EP_TX_VALID)\n        ;\n    USBD_LL_Transmit(&Solo_USBD_Device, HID_EPIN_ADDR, msg, HID_PACKET_SIZE);\n\n\n}\n\nvoid ctaphid_write_block(uint8_t * data)\n{\n    usbhid_send(data);\n}\n\n\nvoid usbhid_close(void)\n{\n\n}\n\nvoid main_loop_delay(void)\n{\n\n}\n\nstatic int wink_time = 0;\nstatic uint32_t winkt1 = 0;\n#ifdef LED_WINK_VALUE\nstatic uint32_t winkt2 = 0;\n#endif\n\nvoid device_wink(void)\n{\n    wink_time = 10;\n    winkt1 = 0;\n}\n\nvoid heartbeat(void)\n{\n    static int state = 0;\n    static uint32_t val = (LED_MAX_SCALER - LED_MIN_SCALER)/2;\n    uint8_t r = (LED_INIT_VALUE >> 16) & 0xff;\n    uint8_t g = (LED_INIT_VALUE >> 8) & 0xff;\n    uint8_t b = (LED_INIT_VALUE >> 0) & 0xff;\n    int but = IS_BUTTON_PRESSED();\n\n    if (state)\n    {\n        val--;\n    }\n    else\n    {\n        val++;\n    }\n\n    if (val >= LED_MAX_SCALER || val <= LED_MIN_SCALER)\n    {\n        state = !state;\n\n\t\tif (val > LED_MAX_SCALER)\n\t\t\tval = LED_MAX_SCALER;\n\t\tif (val < LED_MIN_SCALER)\n\t\t\tval = LED_MIN_SCALER;\n    }\n\n#ifdef LED_WINK_VALUE\n    if (wink_time)\n    {\n        if (millis() - winkt1 > 120)\n        {\n            winkt1 = millis();\n            if (winkt2++ & 1)\n            {\n                led_rgb(LED_WINK_VALUE * (LED_MAX_SCALER - LED_MIN_SCALER)/2);\n            }\n            else\n            {\n                led_rgb(0);\n            }\n            wink_time--;\n        }\n    }\n    else\n#endif\n    {\n        if (but)\n            led_rgb(((val * r)<<8) | ((val*b) << 16) | (val*g));\n        else\n            led_rgb(((val * g)<<8) | ((val*r) << 16) | (val*b));\n    }\n\n}\n\n\nstatic int authenticator_is_backup_initialized(void)\n{\n    uint8_t header[16];\n    uint32_t * ptr = (uint32_t *)flash_addr(STATE2_PAGE);\n    memmove(header,ptr,16);\n    AuthenticatorState * state = (AuthenticatorState*)header;\n    return state->is_initialized == INITIALIZED_MARKER;\n}\n\nint authenticator_read_state(AuthenticatorState * a)\n{\n    uint32_t * ptr = (uint32_t *) flash_addr(STATE1_PAGE);\n    memmove(a, ptr, sizeof(AuthenticatorState));\n\n    if (a->is_initialized != INITIALIZED_MARKER){\n\n        if (authenticator_is_backup_initialized()){\n            printf1(TAG_ERR,\"Warning: memory corruption detected.  restoring from backup..\\n\");\n            ptr = (uint32_t *) flash_addr(STATE2_PAGE);\n            memmove(a, ptr, sizeof(AuthenticatorState));\n            authenticator_write_state(a);\n            return 1;\n        }\n\n        return 0;\n    }\n\n    return 1;\n}\n\n\nvoid authenticator_write_state(AuthenticatorState * a)\n{\n    flash_erase_page(STATE1_PAGE);\n    flash_write(flash_addr(STATE1_PAGE), (uint8_t*)a, sizeof(AuthenticatorState));\n\n    flash_erase_page(STATE2_PAGE);\n    flash_write(flash_addr(STATE2_PAGE), (uint8_t*)a, sizeof(AuthenticatorState));\n}\n\n#if !defined(IS_BOOTLOADER)\nuint32_t ctap_atomic_count(uint32_t amount)\n{\n    int offset = 0;\n    uint32_t * ptr = (uint32_t *)flash_addr(COUNTER1_PAGE);\n    uint32_t erases = *(uint32_t *)flash_addr(COUNTER2_PAGE);\n    static uint32_t sc = 0;\n    if (erases == 0xffffffff)\n    {\n        erases = 1;\n        flash_erase_page(COUNTER2_PAGE);\n        flash_write(flash_addr(COUNTER2_PAGE), (uint8_t*)&erases, 4);\n    }\n\n    uint32_t lastc = 0;\n\n    if (amount == 0)\n    {\n        // Use a random count [1-16].\n        uint8_t rng[1];\n        ctap_generate_rng(rng, 1);\n        amount = (rng[0] & 0x0f) + 1;\n    }\n\n    for (offset = 0; offset < PAGE_SIZE/4; offset += 2) // wear-level the flash\n    {\n        if (ptr[offset] != 0xffffffff)\n        {\n            if (ptr[offset] < lastc)\n            {\n                printf2(TAG_ERR,\"Error, count went down!\\r\\n\");\n            }\n            lastc = ptr[offset];\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    if (!lastc) // Happens on initialization as well.\n    {\n        printf2(TAG_ERR,\"warning, power interrupted during previous count.  Restoring. lastc==%lu, erases=%lu, offset=%d\\r\\n\", lastc,erases,offset);\n        // there are 32 counts per page\n        lastc =  erases * 256 + 1;\n        flash_erase_page(COUNTER1_PAGE);\n        flash_write(flash_addr(COUNTER1_PAGE), (uint8_t*)&lastc, 4);\n\n        erases++;\n        flash_erase_page(COUNTER2_PAGE);\n        flash_write(flash_addr(COUNTER2_PAGE), (uint8_t*)&erases, 4);\n        return lastc;\n    }\n\n    if (amount > 256){\n        lastc = amount;\n    } else {\n        lastc += amount;\n    }\n\n    if (lastc/256 > erases)\n    {\n        printf2(TAG_ERR,\"warning, power interrupted, erases mark, restoring. lastc==%lu, erases=%lu\\r\\n\", lastc,erases);\n        erases = lastc/256;\n        flash_erase_page(COUNTER2_PAGE);\n        flash_write(flash_addr(COUNTER2_PAGE), (uint8_t*)&erases, 4);\n    }\n\n    if (offset == PAGE_SIZE/4)\n    {\n        if (lastc/256 > erases)\n        {\n            printf2(TAG_ERR,\"warning, power interrupted, erases mark, restoring lastc==%lu, erases=%lu\\r\\n\", lastc,erases);\n        }\n        erases = lastc/256 + 1;\n        flash_erase_page(COUNTER2_PAGE);\n        flash_write(flash_addr(COUNTER2_PAGE), (uint8_t*)&erases, 4);\n\n        flash_erase_page(COUNTER1_PAGE);\n        offset = 0;\n    }\n\n\n    flash_write(flash_addr(COUNTER1_PAGE) + offset * 4, (uint8_t*)&lastc, 4);\n\n    if (lastc == sc)\n    {\n        printf1(TAG_RED,\"no count detected:  lastc==%lu, erases=%lu, offset=%d\\r\\n\", lastc,erases,offset);\n        while(1)\n            ;\n    }\n\n    sc = lastc;\n\n    return lastc;\n}\n#endif\n\n\nvoid device_manage(void)\n{\n#if NON_BLOCK_PRINTING\n    int i = 10;\n    uint8_t c;\n    while (i--)\n    {\n        if (fifo_debug_size())\n        {\n            fifo_debug_take(&c);\n            while (! LL_USART_IsActiveFlag_TXE(DEBUG_UART))\n                ;\n            LL_USART_TransmitData8(DEBUG_UART,c);\n        }\n        else\n        {\n            break;\n        }\n    }\n#endif\n#ifndef IS_BOOTLOADER\n\tif(device_is_nfc())\n\t\tnfc_loop();\n#endif\n}\n\nstatic int handle_packets(void)\n{\n    static uint8_t hidmsg[HID_PACKET_SIZE];\n    memset(hidmsg,0, sizeof(hidmsg));\n    if (usbhid_recv(hidmsg) > 0)\n    {\n        if ( ctaphid_handle_packet(hidmsg) ==  CTAPHID_CANCEL)\n        {\n            printf1(TAG_GREEN, \"CANCEL!\\r\\n\");\n            return -1;\n        }\n        else\n        {\n            return 0;\n        }\n    }\n    return 0;\n}\n\nstatic int wait_for_button_activate(uint32_t wait)\n{\n    int ret;\n    uint32_t start = millis();\n    do\n    {\n        if ((start + wait) < millis())\n        {\n            return 0;\n        }\n        delay(1);\n        ret = handle_packets();\n        if (ret)\n            return ret;\n    } while (!IS_BUTTON_PRESSED());\n    return 0;\n}\n\nstatic int wait_for_button_release(uint32_t wait)\n{\n    int ret;\n    uint32_t start = millis();\n    do\n    {\n        if ((start + wait) < millis())\n        {\n            return 0;\n        }\n        delay(1);\n        ret = handle_packets();\n        if (ret)\n            return ret;\n    } while (IS_BUTTON_PRESSED());\n    return 0;\n}\n\nint ctap_user_presence_test(uint32_t up_delay)\n{\n    int ret;\n\n    if (device_is_nfc() == NFC_IS_ACTIVE)\n    {\n        return 1;\n    }\n\n    if (_up_disabled)\n    {\n        return 2;\n    }\n\n#if SKIP_BUTTON_CHECK_WITH_DELAY\n    int i=500;\n    while(i--)\n    {\n        delay(1);\n        ret = handle_packets();\n        if (ret) return ret;\n    }\n    goto done;\n#elif SKIP_BUTTON_CHECK_FAST\n    delay(2);\n    ret = handle_packets();\n    if (ret)\n        return ret;\n    goto done;\n#endif\n\n    // If button was pressed within last [2] seconds, succeed.\n    if (__last_button_press_time && (millis() - __last_button_press_time < 2000))\n    {\n        goto done;\n    }\n\n    // Set LED status and wait.\n    led_rgb(0xff3520);\n\n    // Block and wait for some time.\n    ret = wait_for_button_activate(up_delay);\n    if (ret) return ret;\n    ret = wait_for_button_release(up_delay);\n    if (ret) return ret;\n\n    // If button was pressed within last [2] seconds, succeed.\n    if (__last_button_press_time && (millis() - __last_button_press_time < 2000))\n    {\n        goto done;\n    }\n\n\n    return 0;\n\n\ndone:\n    ret = wait_for_button_release(up_delay);\n    __last_button_press_time = 0;\n    return 1;\n\n}\n\nint ctap_generate_rng(uint8_t * dst, size_t num)\n{\n    rng_get_bytes(dst, num);\n    return 1;\n}\n\n\nvoid ctap_reset_rk(void)\n{\n    int i;\n    printf1(TAG_GREEN, \"resetting RK \\r\\n\");\n    for(i = 0; i < RK_NUM_PAGES; i++)\n    {\n        flash_erase_page(RK_START_PAGE + i);\n    }\n}\n\nuint32_t ctap_rk_size(void)\n{\n    return RK_NUM_PAGES * (PAGE_SIZE / sizeof(CTAP_residentKey));\n}\n\nvoid ctap_store_rk(int index,CTAP_residentKey * rk)\n{\n    ctap_overwrite_rk(index, rk);\n}\n\nvoid ctap_delete_rk(int index)\n{\n    CTAP_residentKey rk;\n    memset(&rk, 0xff, sizeof(CTAP_residentKey));\n    ctap_overwrite_rk(index, &rk);\n}\n\nvoid ctap_load_rk(int index,CTAP_residentKey * rk)\n{\n    int byte_offset_into_page = (sizeof(CTAP_residentKey) * (index % (PAGE_SIZE/sizeof(CTAP_residentKey))));\n    int page_offset = (index)/(PAGE_SIZE/sizeof(CTAP_residentKey));\n\n    uint32_t addr = flash_addr(page_offset + RK_START_PAGE) + byte_offset_into_page;\n\n    printf1(TAG_GREEN, \"reading RK %d @ %04x\\r\\n\", index, addr);\n    if (page_offset < RK_NUM_PAGES)\n    {\n        uint32_t * ptr = (uint32_t *)addr;\n        memmove((uint8_t*)rk,ptr,sizeof(CTAP_residentKey));\n    }\n    else\n    {\n        printf2(TAG_ERR,\"Out of bounds reading index %d for rk\\n\", index);\n    }\n}\n\nvoid ctap_overwrite_rk(int index,CTAP_residentKey * rk)\n{\n    uint8_t tmppage[PAGE_SIZE];\n\n    int byte_offset_into_page = (sizeof(CTAP_residentKey) * (index % (PAGE_SIZE/sizeof(CTAP_residentKey))));\n    int page_offset = (index)/(PAGE_SIZE/sizeof(CTAP_residentKey));\n\n    printf1(TAG_GREEN, \"overwriting RK %d @ page %d @ addr 0x%08x-0x%08x\\r\\n\", \n        index, RK_START_PAGE + page_offset, \n        flash_addr(RK_START_PAGE + page_offset) + byte_offset_into_page, \n        flash_addr(RK_START_PAGE + page_offset) + byte_offset_into_page + sizeof(CTAP_residentKey) \n        );\n    if (page_offset < RK_NUM_PAGES)\n    {\n        memmove(tmppage, (uint8_t*)flash_addr(RK_START_PAGE + page_offset), PAGE_SIZE);\n\n        memmove(tmppage + byte_offset_into_page, rk, sizeof(CTAP_residentKey));\n        flash_erase_page(RK_START_PAGE + page_offset);\n        flash_write(flash_addr(RK_START_PAGE + page_offset), tmppage, PAGE_SIZE);\n    }\n    else\n    {\n        printf2(TAG_ERR,\"Out of bounds reading index %d for rk\\n\", index);\n    }\n    printf1(TAG_GREEN, \"4\\r\\n\");\n}\n\nvoid boot_st_bootloader(void)\n{\n    __disable_irq();\n\n    __set_MSP(*((uint32_t *)0x1fff0000));\n\n    ((void (*)(void)) (*((uint32_t *)0x1fff0004)))();\n\n    while(1)\n    ;\n}\n\nvoid boot_solo_bootloader(void)\n{\n    LL_IWDG_Enable(IWDG);\n\n    LL_IWDG_EnableWriteAccess(IWDG);\n\n    LL_IWDG_SetPrescaler(IWDG, LL_IWDG_PRESCALER_4);\n\n    LL_IWDG_SetWindow(IWDG, 4095);\n\n    LL_IWDG_SetReloadCounter(IWDG, 2000); // ~0.25s\n\n    while (LL_IWDG_IsReady(IWDG) != 1)\n    {\n    }\n\n    LL_IWDG_ReloadCounter(IWDG);\n\n}\n\nvoid device_read_aaguid(uint8_t * dst){\n    uint8_t * aaguid = (uint8_t *)\"\\x88\\x76\\x63\\x1b\\xd4\\xa0\\x42\\x7f\\x57\\x73\\x0e\\xc7\\x1c\\x9e\\x02\\x79\";\n    memmove(dst, aaguid, 16);\n    if (device_is_nfc()){\n        dst[0] = 0x89;\n    }\n    else if (tsc_sensor_exists()){\n        dst[0] = 0x98;\n    }\n    dump_hex1(TAG_GREEN,dst, 16);\n}\n\n\nvoid _Error_Handler(char *file, int line)\n{\n    printf2(TAG_ERR,\"Error: %s: %d\\r\\n\", file, line);\n    while(1)\n    {\n    }\n}\n", "// Copyright 2019 SoloKeys Developers\n//\n// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or\n// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or\n// http://opensource.org/licenses/MIT>, at your option. This file may not be\n// copied, modified, or distributed except according to those terms.\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include \"stm32l4xx.h\"\n\n#include APP_CONFIG\n#include \"flash.h\"\n#include \"log.h\"\n#include \"device.h\"\n\nstatic void flash_lock(void)\n{\n    FLASH->CR |= (1U<<31);\n}\n\nstatic void flash_unlock(void)\n{\n    if (FLASH->CR & FLASH_CR_LOCK)\n    {\n        FLASH->KEYR = 0x45670123;\n        FLASH->KEYR = 0xCDEF89AB;\n    }\n}\n\n// Locks flash and turns off DFU\nvoid flash_option_bytes_init(int boot_from_dfu)\n{\n    uint32_t val = 0xfffff8aa;\n\n    if (boot_from_dfu){\n        val &= ~(1<<27); // nBOOT0 = 0  (boot from system rom)\n    }\n    else {\n        if (solo_is_locked())\n        {\n            val = 0xfffff8cc;\n        }\n    }\n\n    val &= ~(1<<26); // nSWBOOT0 = 0  (boot from nBoot0)\n    val &= ~(1<<25); // SRAM2_RST = 1 (erase sram on reset)\n    val &= ~(1<<24); // SRAM2_PE = 1 (parity check en)\n\n    if (FLASH->OPTR == val)\n    {\n        return;\n    }\n\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n    if (FLASH->CR & (1<<30))\n    {\n        FLASH->OPTKEYR = 0x08192A3B;\n        FLASH->OPTKEYR = 0x4C5D6E7F;\n    }\n\n    FLASH->OPTR =val;\n    FLASH->CR |= (1<<17);\n\n    while (FLASH->SR & (1<<16))\n        ;\n\n    flash_lock();\n\n    __enable_irq();\n}\n\nvoid flash_erase_page(uint8_t page)\n{\n    __disable_irq();\n\n    // Wait if flash is busy\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n\n    FLASH->SR = FLASH->SR;\n\n    // enable flash erase and select page\n    FLASH->CR &= ~((0xff<<3) | 7);\n    FLASH->CR |= (page<<3) | (1<<1);\n\n    // Go!\n    FLASH->CR |= (1<<16);\n    while (FLASH->SR & (1<<16))\n        ;\n\n    if(FLASH->SR & (1<<1))\n    {\n        printf2(TAG_ERR,\"erase NOT successful %lx\\r\\n\", FLASH->SR);\n    }\n\n    FLASH->CR &= ~(0x7);\n    __enable_irq();\n}\n\nvoid flash_write_dword(uint32_t addr, uint64_t data)\n{\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    FLASH->SR = FLASH->SR;\n\n    // Select program action\n    FLASH->CR |= (1<<0);\n\n    *(volatile uint32_t*)addr = data;\n    *(volatile uint32_t*)(addr+4) = data>>32;\n\n    while (FLASH->SR & (1<<16))\n        ;\n\n    if(FLASH->SR & (1<<1))\n    {\n        printf2(TAG_ERR,\"program NOT successful %lx\\r\\n\", FLASH->SR);\n    }\n\n    FLASH->SR = (1<<0);\n    FLASH->CR &= ~(1<<0);\n    __enable_irq();\n}\n\nvoid flash_write(uint32_t addr, uint8_t * data, size_t sz)\n{\n    unsigned int i;\n    uint8_t buf[8];\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n\n    // dword align\n    addr &= ~(0x07);\n\n    for(i = 0; i < sz; i+=8)\n    {\n        memmove(buf, data + i, (sz - i) > 8 ? 8 : sz - i);\n        if (sz - i < 8)\n        {\n            memset(buf + sz - i, 0xff, 8 - (sz - i));\n        }\n        flash_write_dword(addr, *(uint64_t*)buf);\n        addr += 8;\n    }\n\n}\n\n// NOT YET working\nvoid flash_write_fast(uint32_t addr, uint32_t * data)\n{\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    FLASH->SR = FLASH->SR;\n\n    // Select fast program action\n    FLASH->CR |= (1<<18);\n\n    int i;\n    for(i = 0; i < 64; i++)\n    {\n        *(volatile uint32_t*)addr = (*data);\n        addr+=4;\n        data++;\n    }\n\n    while (FLASH->SR & (1<<16))\n        ;\n\n    if(FLASH->SR & (1<<1))\n    {\n        printf2(TAG_ERR,\"program NOT successful %lx\\r\\n\", FLASH->SR);\n    }\n\n    FLASH->SR = (1<<0);\n    FLASH->CR &= ~(1<<18);\n    __enable_irq();\n\n}\n"], "fixing_code": ["// Copyright 2019 SoloKeys Developers\n//\n// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or\n// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or\n// http://opensource.org/licenses/MIT>, at your option. This file may not be\n// copied, modified, or distributed except according to those terms.\n#include \"device.h\"\n#include \"usbd_def.h\"\n#include \"stm32l4xx.h\"\n#include \"stm32l4xx_ll_gpio.h\"\n#include \"stm32l4xx_ll_tim.h\"\n#include \"stm32l4xx_ll_usart.h\"\n#include \"stm32l4xx_ll_pwr.h\"\n#include \"usbd_hid.h\"\n\n#include APP_CONFIG\n#include \"flash.h\"\n#include \"rng.h\"\n#include \"led.h\"\n#include \"device.h\"\n#include \"util.h\"\n#include \"fifo.h\"\n#include \"log.h\"\n#include \"ctaphid.h\"\n#include \"ctap.h\"\n#include \"crypto.h\"\n#include \"memory_layout.h\"\n#include \"stm32l4xx_ll_iwdg.h\"\n#include \"usbd_cdc_if.h\"\n#include \"nfc.h\"\n#include \"init.h\"\n#include \"sense.h\"\n\n#define LOW_FREQUENCY        1\n#define HIGH_FREQUENCY       0\n\n#define SOLO_FLAG_LOCKED                    0x2\n\nvoid wait_for_usb_tether(void);\n\n\nuint32_t __90_ms = 0;\nuint32_t __last_button_press_time = 0;\nuint32_t __last_button_bounce_time = 0;\nuint32_t __device_status = 0;\nuint32_t __last_update = 0;\nextern PCD_HandleTypeDef hpcd;\nstatic int _NFC_status = 0;\nstatic bool isLowFreq = 0;\nstatic bool _up_disabled = false;\n\n// #define IS_BUTTON_PRESSED()         (0  == (LL_GPIO_ReadInputPort(SOLO_BUTTON_PORT) & SOLO_BUTTON_PIN))\nstatic int is_physical_button_pressed(void)\n{\n    return (0  == (LL_GPIO_ReadInputPort(SOLO_BUTTON_PORT) & SOLO_BUTTON_PIN));\n}\n\nstatic int is_touch_button_pressed(void)\n{\n    int is_pressed = (tsc_read_button(0) || tsc_read_button(1));\n#ifndef IS_BOOTLOADER\n    if (is_pressed)\n    {\n        // delay for debounce, and longer than polling timer period.\n        delay(95);\n        return (tsc_read_button(0) || tsc_read_button(1));\n    }\n#endif\n    return is_pressed;\n}\n\nint (*IS_BUTTON_PRESSED)() = is_physical_button_pressed;\n\nstatic void edge_detect_touch_button(void)\n{\n    static uint8_t last_touch = 0;\n    uint8_t current_touch = 0;\n    if (is_touch_button_pressed == IS_BUTTON_PRESSED)\n    {\n        current_touch = (tsc_read_button(0) || tsc_read_button(1));\n\n        // 1 sample per 25 ms\n        if ((millis() - __last_button_bounce_time) > 25)\n        {\n            // Detect \"touch / rising edge\"\n            if (!last_touch && current_touch)\n            {\n                __last_button_press_time = millis();\n            }\n            __last_button_bounce_time = millis();\n            last_touch = current_touch;\n        }\n    }\n\n}\n\nvoid device_disable_up(bool disable)\n{\n    _up_disabled = disable;\n}\n\n// Timer6 overflow handler.  happens every ~90ms.\nvoid TIM6_DAC_IRQHandler(void)\n{\n    // timer is only 16 bits, so roll it over here\n    TIM6->SR = 0;\n    __90_ms += 1;\n    if ((millis() - __last_update) > 90)\n    {\n        if (__device_status != CTAPHID_STATUS_IDLE)\n        {\n            ctaphid_update_status(__device_status);\n        }\n    }\n\n    edge_detect_touch_button();\n\n#ifndef IS_BOOTLOADER\n\t// NFC sending WTX if needs\n\tif (device_is_nfc() == NFC_IS_ACTIVE)\n\t{\n\t\tWTX_timer_exec();\n\t}\n#endif\n}\n\n// Interrupt on rising edge of button (button released)\nvoid EXTI0_IRQHandler(void)\n{\n    EXTI->PR1 = EXTI->PR1;\n    if (is_physical_button_pressed == IS_BUTTON_PRESSED)\n    {\n        // Only allow 1 press per 25 ms.\n        if ((millis() - __last_button_bounce_time) > 25)\n        {\n            __last_button_press_time = millis();\n        }\n        __last_button_bounce_time = millis();\n    }\n}\n\n// Global USB interrupt handler\nvoid USB_IRQHandler(void)\n{\n  HAL_PCD_IRQHandler(&hpcd);\n}\n\nuint32_t millis(void)\n{\n    return (((uint32_t)TIM6->CNT) + (__90_ms * 90));\n}\n\nvoid device_set_status(uint32_t status)\n{\n    __disable_irq();\n    __last_update = millis();\n    __enable_irq();\n\n    if (status != CTAPHID_STATUS_IDLE && __device_status != status)\n    {\n        ctaphid_update_status(status);\n    }\n    __device_status = status;\n}\n\nint device_is_button_pressed(void)\n{\n    return IS_BUTTON_PRESSED();\n}\n\nvoid delay(uint32_t ms)\n{\n    uint32_t time = millis();\n    while ((millis() - time) < ms)\n        ;\n}\n\nvoid device_reboot(void)\n{\n    NVIC_SystemReset();\n}\n\nvoid device_init_button(void)\n{\n    if (tsc_sensor_exists())\n    {\n        tsc_init();\n        IS_BUTTON_PRESSED = is_touch_button_pressed;\n    }\n    else\n    {\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n}\n\nint solo_is_locked(){\n    uint64_t device_settings = ((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->device_settings;\n    uint32_t tag = (uint32_t)(device_settings >> 32ull);\n    return tag == ATTESTATION_CONFIGURED_TAG && (device_settings & SOLO_FLAG_LOCKED) != 0;\n}\n\n// Locks solo flash from debugging.  Locks on next reboot.\n// This should be removed in next Solo release.\nvoid solo_lock_if_not_already() {\n    uint8_t buf[2048];\n\n    memmove(buf, (uint8_t*)ATTESTATION_PAGE_ADDR, 2048);\n\n    ((flash_attestation_page *)buf)->device_settings |= SOLO_FLAG_LOCKED;\n\n    flash_erase_page(ATTESTATION_PAGE);\n\n    flash_write(ATTESTATION_PAGE_ADDR, buf, 2048);\n}\n\n/** device_migrate\n * Depending on version of device, migrates:\n * * Moves attestation certificate to data segment. \n * * Creates locked variable and stores in data segment.\n * \n * Once in place, this allows all devices to accept same firmware,\n * rather than using \"hacker\" and \"secure\" builds.\n*/\nstatic void device_migrate(){\n    extern const uint16_t attestation_solo_cert_der_size;\n    extern const uint16_t attestation_hacker_cert_der_size;\n\n    extern uint8_t attestation_solo_cert_der[];\n    extern uint8_t attestation_hacker_cert_der[];\n\n    uint64_t device_settings = ((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->device_settings;\n    uint32_t configure_tag = (uint32_t)(device_settings >> 32);\n\n    if (configure_tag != ATTESTATION_CONFIGURED_TAG)\n    {\n        printf1(TAG_RED,\"Migrating certificate and lock information to data segment.\\r\\n\");\n\n        device_settings = ATTESTATION_CONFIGURED_TAG;\n        device_settings <<= 32;\n\n        // Read current device lock level.\n        uint32_t optr = FLASH->OPTR;\n        if ((optr & 0xff) != 0xAA){\n            device_settings |= SOLO_FLAG_LOCKED;\n        }\n\n        uint8_t tmp_attestation_key[32];\n\n        memmove(tmp_attestation_key,\n            ((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->attestation_key,\n            32);\n\n        flash_erase_page(ATTESTATION_PAGE);\n        flash_write(\n            (uint32_t)((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->attestation_key,\n            tmp_attestation_key,\n            32\n        );\n\n        // Check if this is Solo Hacker attestation (not confidential)\n        // then write solo or hacker attestation cert to flash page.\n        uint8_t solo_hacker_attestation_key[32] = \"\\x1b\\x26\\x26\\xec\\xc8\\xf6\\x9b\\x0f\\x69\\xe3\\x4f\"\n                                                  \"\\xb2\\x36\\xd7\\x64\\x66\\xba\\x12\\xac\\x16\\xc3\\xab\"\n                                                  \"\\x57\\x50\\xba\\x06\\x4e\\x8b\\x90\\xe0\\x24\\x48\";\n\n        if (memcmp(solo_hacker_attestation_key,\n                   tmp_attestation_key,\n                   32) == 0)\n        {\n            printf1(TAG_GREEN,\"Updating solo hacker cert\\r\\n\");\n            flash_write_dword(\n             (uint32_t)&((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->attestation_cert_size,\n             (uint64_t)attestation_hacker_cert_der_size\n             );\n            flash_write(\n                (uint32_t)((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->attestation_cert,\n                attestation_hacker_cert_der,\n                attestation_hacker_cert_der_size\n            );\n        }\n        else\n        {\n            printf1(TAG_GREEN,\"Updating solo secure cert\\r\\n\");\n            flash_write_dword(\n             (uint32_t)&((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->attestation_cert_size,\n             (uint64_t)attestation_solo_cert_der_size\n             );\n            flash_write(\n                (uint32_t)((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->attestation_cert,\n                attestation_solo_cert_der,\n                attestation_solo_cert_der_size\n            );\n        }\n\n        // Save / done.\n        flash_write_dword(\n            (uint32_t) & ((flash_attestation_page *)ATTESTATION_PAGE_ADDR)->device_settings,\n            (uint64_t)device_settings);\n    }\n}\n\nvoid device_init()\n{\n\n    hw_init(LOW_FREQUENCY);\n\n#if BOOT_TO_DFU\n    flash_option_bytes_init(1);\n#else\n    flash_option_bytes_init(0);\n#endif\n\n    if (! tsc_sensor_exists())\n    {\n        _NFC_status = nfc_init();\n    }\n\n    if (_NFC_status == NFC_IS_ACTIVE)\n    {\n        printf1(TAG_NFC, \"Have NFC\\r\\n\");\n        isLowFreq = 1;\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n    else\n    {\n        printf1(TAG_NFC, \"Have NO NFC\\r\\n\");\n        hw_init(HIGH_FREQUENCY);\n        isLowFreq = 0;\n        device_init_button();\n    }\n\n    usbhid_init();\n    ctaphid_init();\n    ctap_init();\n\n    device_migrate();\n\n\n}\n\nint device_is_nfc(void)\n{\n    return _NFC_status;\n}\n\nvoid wait_for_usb_tether(void)\n{\n    while (USBD_OK != CDC_Transmit_FS((uint8_t*)\"tethered\\r\\n\", 10) )\n        ;\n    while (USBD_OK != CDC_Transmit_FS((uint8_t*)\"tethered\\r\\n\", 10) )\n        ;\n    delay(10);\n    while (USBD_OK != CDC_Transmit_FS((uint8_t*)\"tethered\\r\\n\", 10) )\n        ;\n}\n\nvoid usbhid_init(void)\n{\n    if (!isLowFreq)\n    {\n        init_usb();\n\n#if DEBUG_LEVEL>1\n        wait_for_usb_tether();\n#endif\n    }\n    else\n    {\n\n\n\n    }\n}\n\n\n\nint usbhid_recv(uint8_t * msg)\n{\n    if (fifo_hidmsg_size())\n    {\n        fifo_hidmsg_take(msg);\n        printf1(TAG_DUMP2,\">> \");\n        dump_hex1(TAG_DUMP2,msg, HID_PACKET_SIZE);\n        return HID_PACKET_SIZE;\n    }\n    return 0;\n}\n\nvoid usbhid_send(uint8_t * msg)\n{\n\n    printf1(TAG_DUMP2,\"<< \");\n    dump_hex1(TAG_DUMP2, msg, HID_PACKET_SIZE);\n    while (PCD_GET_EP_TX_STATUS(USB, HID_EPIN_ADDR & 0x0f) == USB_EP_TX_VALID)\n        ;\n    USBD_LL_Transmit(&Solo_USBD_Device, HID_EPIN_ADDR, msg, HID_PACKET_SIZE);\n\n\n}\n\nvoid ctaphid_write_block(uint8_t * data)\n{\n    usbhid_send(data);\n}\n\n\nvoid usbhid_close(void)\n{\n\n}\n\nvoid main_loop_delay(void)\n{\n\n}\n\nstatic int wink_time = 0;\nstatic uint32_t winkt1 = 0;\n#ifdef LED_WINK_VALUE\nstatic uint32_t winkt2 = 0;\n#endif\n\nvoid device_wink(void)\n{\n    wink_time = 10;\n    winkt1 = 0;\n}\n\nvoid heartbeat(void)\n{\n    static int state = 0;\n    static uint32_t val = (LED_MAX_SCALER - LED_MIN_SCALER)/2;\n    uint8_t r = (LED_INIT_VALUE >> 16) & 0xff;\n    uint8_t g = (LED_INIT_VALUE >> 8) & 0xff;\n    uint8_t b = (LED_INIT_VALUE >> 0) & 0xff;\n    int but = IS_BUTTON_PRESSED();\n\n    if (state)\n    {\n        val--;\n    }\n    else\n    {\n        val++;\n    }\n\n    if (val >= LED_MAX_SCALER || val <= LED_MIN_SCALER)\n    {\n        state = !state;\n\n\t\tif (val > LED_MAX_SCALER)\n\t\t\tval = LED_MAX_SCALER;\n\t\tif (val < LED_MIN_SCALER)\n\t\t\tval = LED_MIN_SCALER;\n    }\n\n#ifdef LED_WINK_VALUE\n    if (wink_time)\n    {\n        if (millis() - winkt1 > 120)\n        {\n            winkt1 = millis();\n            if (winkt2++ & 1)\n            {\n                led_rgb(LED_WINK_VALUE * (LED_MAX_SCALER - LED_MIN_SCALER)/2);\n            }\n            else\n            {\n                led_rgb(0);\n            }\n            wink_time--;\n        }\n    }\n    else\n#endif\n    {\n        if (but)\n            led_rgb(((val * r)<<8) | ((val*b) << 16) | (val*g));\n        else\n            led_rgb(((val * g)<<8) | ((val*r) << 16) | (val*b));\n    }\n\n}\n\n\nstatic int authenticator_is_backup_initialized(void)\n{\n    uint8_t header[16];\n    uint32_t * ptr = (uint32_t *)flash_addr(STATE2_PAGE);\n    memmove(header,ptr,16);\n    AuthenticatorState * state = (AuthenticatorState*)header;\n    return state->is_initialized == INITIALIZED_MARKER;\n}\n\nint authenticator_read_state(AuthenticatorState * a)\n{\n    uint32_t * ptr = (uint32_t *) flash_addr(STATE1_PAGE);\n    memmove(a, ptr, sizeof(AuthenticatorState));\n\n    if (a->is_initialized != INITIALIZED_MARKER){\n\n        if (authenticator_is_backup_initialized()){\n            printf1(TAG_ERR,\"Warning: memory corruption detected.  restoring from backup..\\n\");\n            ptr = (uint32_t *) flash_addr(STATE2_PAGE);\n            memmove(a, ptr, sizeof(AuthenticatorState));\n            authenticator_write_state(a);\n            return 1;\n        }\n\n        return 0;\n    }\n\n    return 1;\n}\n\n\nvoid authenticator_write_state(AuthenticatorState * a)\n{\n    flash_erase_page(STATE1_PAGE);\n    flash_write(flash_addr(STATE1_PAGE), (uint8_t*)a, sizeof(AuthenticatorState));\n\n    flash_erase_page(STATE2_PAGE);\n    flash_write(flash_addr(STATE2_PAGE), (uint8_t*)a, sizeof(AuthenticatorState));\n}\n\n#if !defined(IS_BOOTLOADER)\nuint32_t ctap_atomic_count(uint32_t amount)\n{\n    int offset = 0;\n    uint32_t * ptr = (uint32_t *)flash_addr(COUNTER1_PAGE);\n    uint32_t erases = *(uint32_t *)flash_addr(COUNTER2_PAGE);\n    static uint32_t sc = 0;\n    if (erases == 0xffffffff)\n    {\n        erases = 1;\n        flash_erase_page(COUNTER2_PAGE);\n        flash_write(flash_addr(COUNTER2_PAGE), (uint8_t*)&erases, 4);\n    }\n\n    uint32_t lastc = 0;\n\n    if (amount == 0)\n    {\n        // Use a random count [1-16].\n        uint8_t rng[1];\n        ctap_generate_rng(rng, 1);\n        amount = (rng[0] & 0x0f) + 1;\n    }\n\n    for (offset = 0; offset < PAGE_SIZE/4; offset += 2) // wear-level the flash\n    {\n        if (ptr[offset] != 0xffffffff)\n        {\n            if (ptr[offset] < lastc)\n            {\n                printf2(TAG_ERR,\"Error, count went down!\\r\\n\");\n            }\n            lastc = ptr[offset];\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    if (!lastc) // Happens on initialization as well.\n    {\n        printf2(TAG_ERR,\"warning, power interrupted during previous count.  Restoring. lastc==%lu, erases=%lu, offset=%d\\r\\n\", lastc,erases,offset);\n        // there are 32 counts per page\n        lastc =  erases * 256 + 1;\n        flash_erase_page(COUNTER1_PAGE);\n        flash_write(flash_addr(COUNTER1_PAGE), (uint8_t*)&lastc, 4);\n\n        erases++;\n        flash_erase_page(COUNTER2_PAGE);\n        flash_write(flash_addr(COUNTER2_PAGE), (uint8_t*)&erases, 4);\n        return lastc;\n    }\n\n    if (amount > 256){\n        lastc = amount;\n    } else {\n        lastc += amount;\n    }\n\n    if (lastc/256 > erases)\n    {\n        printf2(TAG_ERR,\"warning, power interrupted, erases mark, restoring. lastc==%lu, erases=%lu\\r\\n\", lastc,erases);\n        erases = lastc/256;\n        flash_erase_page(COUNTER2_PAGE);\n        flash_write(flash_addr(COUNTER2_PAGE), (uint8_t*)&erases, 4);\n    }\n\n    if (offset == PAGE_SIZE/4)\n    {\n        if (lastc/256 > erases)\n        {\n            printf2(TAG_ERR,\"warning, power interrupted, erases mark, restoring lastc==%lu, erases=%lu\\r\\n\", lastc,erases);\n        }\n        erases = lastc/256 + 1;\n        flash_erase_page(COUNTER2_PAGE);\n        flash_write(flash_addr(COUNTER2_PAGE), (uint8_t*)&erases, 4);\n\n        flash_erase_page(COUNTER1_PAGE);\n        offset = 0;\n    }\n\n\n    flash_write(flash_addr(COUNTER1_PAGE) + offset * 4, (uint8_t*)&lastc, 4);\n\n    if (lastc == sc)\n    {\n        printf1(TAG_RED,\"no count detected:  lastc==%lu, erases=%lu, offset=%d\\r\\n\", lastc,erases,offset);\n        while(1)\n            ;\n    }\n\n    sc = lastc;\n\n    return lastc;\n}\n#endif\n\n\nvoid device_manage(void)\n{\n#if NON_BLOCK_PRINTING\n    int i = 10;\n    uint8_t c;\n    while (i--)\n    {\n        if (fifo_debug_size())\n        {\n            fifo_debug_take(&c);\n            while (! LL_USART_IsActiveFlag_TXE(DEBUG_UART))\n                ;\n            LL_USART_TransmitData8(DEBUG_UART,c);\n        }\n        else\n        {\n            break;\n        }\n    }\n#endif\n#ifndef IS_BOOTLOADER\n\tif(device_is_nfc())\n\t\tnfc_loop();\n#endif\n}\n\nstatic int handle_packets(void)\n{\n    static uint8_t hidmsg[HID_PACKET_SIZE];\n    memset(hidmsg,0, sizeof(hidmsg));\n    if (usbhid_recv(hidmsg) > 0)\n    {\n        if ( ctaphid_handle_packet(hidmsg) ==  CTAPHID_CANCEL)\n        {\n            printf1(TAG_GREEN, \"CANCEL!\\r\\n\");\n            return -1;\n        }\n        else\n        {\n            return 0;\n        }\n    }\n    return 0;\n}\n\nstatic int wait_for_button_activate(uint32_t wait)\n{\n    int ret;\n    uint32_t start = millis();\n    do\n    {\n        if ((start + wait) < millis())\n        {\n            return 0;\n        }\n        delay(1);\n        ret = handle_packets();\n        if (ret)\n            return ret;\n    } while (!IS_BUTTON_PRESSED());\n    return 0;\n}\n\nstatic int wait_for_button_release(uint32_t wait)\n{\n    int ret;\n    uint32_t start = millis();\n    do\n    {\n        if ((start + wait) < millis())\n        {\n            return 0;\n        }\n        delay(1);\n        ret = handle_packets();\n        if (ret)\n            return ret;\n    } while (IS_BUTTON_PRESSED());\n    return 0;\n}\n\nint ctap_user_presence_test(uint32_t up_delay)\n{\n    int ret;\n\n    if (device_is_nfc() == NFC_IS_ACTIVE)\n    {\n        return 1;\n    }\n\n    if (_up_disabled)\n    {\n        return 2;\n    }\n\n#if SKIP_BUTTON_CHECK_WITH_DELAY\n    int i=500;\n    while(i--)\n    {\n        delay(1);\n        ret = handle_packets();\n        if (ret) return ret;\n    }\n    goto done;\n#elif SKIP_BUTTON_CHECK_FAST\n    delay(2);\n    ret = handle_packets();\n    if (ret)\n        return ret;\n    goto done;\n#endif\n\n    // If button was pressed within last [2] seconds, succeed.\n    if (__last_button_press_time && (millis() - __last_button_press_time < 2000))\n    {\n        goto done;\n    }\n\n    // Set LED status and wait.\n    led_rgb(0xff3520);\n\n    // Block and wait for some time.\n    ret = wait_for_button_activate(up_delay);\n    if (ret) return ret;\n    ret = wait_for_button_release(up_delay);\n    if (ret) return ret;\n\n    // If button was pressed within last [2] seconds, succeed.\n    if (__last_button_press_time && (millis() - __last_button_press_time < 2000))\n    {\n        goto done;\n    }\n\n\n    return 0;\n\n\ndone:\n    ret = wait_for_button_release(up_delay);\n    __last_button_press_time = 0;\n    return 1;\n\n}\n\nint ctap_generate_rng(uint8_t * dst, size_t num)\n{\n    rng_get_bytes(dst, num);\n    return 1;\n}\n\n\nvoid ctap_reset_rk(void)\n{\n    int i;\n    printf1(TAG_GREEN, \"resetting RK \\r\\n\");\n    for(i = 0; i < RK_NUM_PAGES; i++)\n    {\n        flash_erase_page(RK_START_PAGE + i);\n    }\n}\n\nuint32_t ctap_rk_size(void)\n{\n    return RK_NUM_PAGES * (PAGE_SIZE / sizeof(CTAP_residentKey));\n}\n\nvoid ctap_store_rk(int index,CTAP_residentKey * rk)\n{\n    ctap_overwrite_rk(index, rk);\n}\n\nvoid ctap_delete_rk(int index)\n{\n    CTAP_residentKey rk;\n    memset(&rk, 0xff, sizeof(CTAP_residentKey));\n    ctap_overwrite_rk(index, &rk);\n}\n\nvoid ctap_load_rk(int index,CTAP_residentKey * rk)\n{\n    int byte_offset_into_page = (sizeof(CTAP_residentKey) * (index % (PAGE_SIZE/sizeof(CTAP_residentKey))));\n    int page_offset = (index)/(PAGE_SIZE/sizeof(CTAP_residentKey));\n\n    uint32_t addr = flash_addr(page_offset + RK_START_PAGE) + byte_offset_into_page;\n\n    printf1(TAG_GREEN, \"reading RK %d @ %04x\\r\\n\", index, addr);\n    if (page_offset < RK_NUM_PAGES)\n    {\n        uint32_t * ptr = (uint32_t *)addr;\n        memmove((uint8_t*)rk,ptr,sizeof(CTAP_residentKey));\n    }\n    else\n    {\n        printf2(TAG_ERR,\"Out of bounds reading index %d for rk\\n\", index);\n    }\n}\n\nvoid ctap_overwrite_rk(int index,CTAP_residentKey * rk)\n{\n    uint8_t tmppage[PAGE_SIZE];\n\n    int byte_offset_into_page = (sizeof(CTAP_residentKey) * (index % (PAGE_SIZE/sizeof(CTAP_residentKey))));\n    int page_offset = (index)/(PAGE_SIZE/sizeof(CTAP_residentKey));\n\n    printf1(TAG_GREEN, \"overwriting RK %d @ page %d @ addr 0x%08x-0x%08x\\r\\n\", \n        index, RK_START_PAGE + page_offset, \n        flash_addr(RK_START_PAGE + page_offset) + byte_offset_into_page, \n        flash_addr(RK_START_PAGE + page_offset) + byte_offset_into_page + sizeof(CTAP_residentKey) \n        );\n    if (page_offset < RK_NUM_PAGES)\n    {\n        memmove(tmppage, (uint8_t*)flash_addr(RK_START_PAGE + page_offset), PAGE_SIZE);\n\n        memmove(tmppage + byte_offset_into_page, rk, sizeof(CTAP_residentKey));\n        flash_erase_page(RK_START_PAGE + page_offset);\n        flash_write(flash_addr(RK_START_PAGE + page_offset), tmppage, PAGE_SIZE);\n    }\n    else\n    {\n        printf2(TAG_ERR,\"Out of bounds reading index %d for rk\\n\", index);\n    }\n    printf1(TAG_GREEN, \"4\\r\\n\");\n}\n\nvoid boot_st_bootloader(void)\n{\n    __disable_irq();\n\n    __set_MSP(*((uint32_t *)0x1fff0000));\n\n    ((void (*)(void)) (*((uint32_t *)0x1fff0004)))();\n\n    while(1)\n    ;\n}\n\nvoid boot_solo_bootloader(void)\n{\n    LL_IWDG_Enable(IWDG);\n\n    LL_IWDG_EnableWriteAccess(IWDG);\n\n    LL_IWDG_SetPrescaler(IWDG, LL_IWDG_PRESCALER_4);\n\n    LL_IWDG_SetWindow(IWDG, 4095);\n\n    LL_IWDG_SetReloadCounter(IWDG, 2000); // ~0.25s\n\n    while (LL_IWDG_IsReady(IWDG) != 1)\n    {\n    }\n\n    LL_IWDG_ReloadCounter(IWDG);\n\n}\n\nvoid device_read_aaguid(uint8_t * dst){\n    uint8_t * aaguid = (uint8_t *)\"\\x88\\x76\\x63\\x1b\\xd4\\xa0\\x42\\x7f\\x57\\x73\\x0e\\xc7\\x1c\\x9e\\x02\\x79\";\n    memmove(dst, aaguid, 16);\n    if (device_is_nfc()){\n        dst[0] = 0x89;\n    }\n    else if (tsc_sensor_exists()){\n        dst[0] = 0x98;\n    }\n    dump_hex1(TAG_GREEN,dst, 16);\n}\n\n\nvoid _Error_Handler(char *file, int line)\n{\n    printf2(TAG_ERR,\"Error: %s: %d\\r\\n\", file, line);\n    while(1)\n    {\n    }\n}\n", "// Copyright 2019 SoloKeys Developers\n//\n// Licensed under the Apache License, Version 2.0, <LICENSE-APACHE or\n// http://apache.org/licenses/LICENSE-2.0> or the MIT license <LICENSE-MIT or\n// http://opensource.org/licenses/MIT>, at your option. This file may not be\n// copied, modified, or distributed except according to those terms.\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include \"stm32l4xx.h\"\n\n#include APP_CONFIG\n#include \"flash.h\"\n#include \"log.h\"\n#include \"device.h\"\n\nstatic void flash_lock(void)\n{\n    FLASH->CR |= (1U<<31);\n}\n\nstatic void flash_unlock(void)\n{\n    if (FLASH->CR & FLASH_CR_LOCK)\n    {\n        FLASH->KEYR = 0x45670123;\n        FLASH->KEYR = 0xCDEF89AB;\n    }\n}\n\n// Locks flash and turns off DFU\nvoid flash_option_bytes_init(int boot_from_dfu)\n{\n    uint32_t val = 0xfffff8aa;\n\n    if (boot_from_dfu){\n        val &= ~(1<<27); // nBOOT0 = 0  (boot from system rom)\n    }\n    else {\n        if (solo_is_locked())\n        {\n            val = 0xfffff8cc;\n        }\n    }\n\n    val &= ~(1<<26); // nSWBOOT0 = 0  (boot from nBoot0)\n    val &= ~(1<<25); // SRAM2_RST = 1 (erase sram on reset)\n    val &= ~(1<<24); // SRAM2_PE = 1 (parity check en)\n\n    if (FLASH->OPTR == val)\n    {\n        return;\n    }\n\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n    if (FLASH->CR & (1<<30))\n    {\n        FLASH->OPTKEYR = 0x08192A3B;\n        FLASH->OPTKEYR = 0x4C5D6E7F;\n    }\n\n    FLASH->OPTR =val;\n    FLASH->CR |= (1<<17);\n\n    while (FLASH->SR & (1<<16))\n        ;\n\n    flash_lock();\n\n\n    /* Perform option byte loading which triggers a device reset. */\n    FLASH->CR |= FLASH_CR_OBL_LAUNCH;\n\n    while (true);\n}\n\nvoid flash_erase_page(uint8_t page)\n{\n    __disable_irq();\n\n    // Wait if flash is busy\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n\n    FLASH->SR = FLASH->SR;\n\n    // enable flash erase and select page\n    FLASH->CR &= ~((0xff<<3) | 7);\n    FLASH->CR |= (page<<3) | (1<<1);\n\n    // Go!\n    FLASH->CR |= (1<<16);\n    while (FLASH->SR & (1<<16))\n        ;\n\n    if(FLASH->SR & (1<<1))\n    {\n        printf2(TAG_ERR,\"erase NOT successful %lx\\r\\n\", FLASH->SR);\n    }\n\n    FLASH->CR &= ~(0x7);\n    __enable_irq();\n}\n\nvoid flash_write_dword(uint32_t addr, uint64_t data)\n{\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    FLASH->SR = FLASH->SR;\n\n    // Select program action\n    FLASH->CR |= (1<<0);\n\n    *(volatile uint32_t*)addr = data;\n    *(volatile uint32_t*)(addr+4) = data>>32;\n\n    while (FLASH->SR & (1<<16))\n        ;\n\n    if(FLASH->SR & (1<<1))\n    {\n        printf2(TAG_ERR,\"program NOT successful %lx\\r\\n\", FLASH->SR);\n    }\n\n    FLASH->SR = (1<<0);\n    FLASH->CR &= ~(1<<0);\n    __enable_irq();\n}\n\nvoid flash_write(uint32_t addr, uint8_t * data, size_t sz)\n{\n    unsigned int i;\n    uint8_t buf[8];\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n\n    // dword align\n    addr &= ~(0x07);\n\n    for(i = 0; i < sz; i+=8)\n    {\n        memmove(buf, data + i, (sz - i) > 8 ? 8 : sz - i);\n        if (sz - i < 8)\n        {\n            memset(buf + sz - i, 0xff, 8 - (sz - i));\n        }\n        flash_write_dword(addr, *(uint64_t*)buf);\n        addr += 8;\n    }\n\n}\n\n// NOT YET working\nvoid flash_write_fast(uint32_t addr, uint32_t * data)\n{\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    FLASH->SR = FLASH->SR;\n\n    // Select fast program action\n    FLASH->CR |= (1<<18);\n\n    int i;\n    for(i = 0; i < 64; i++)\n    {\n        *(volatile uint32_t*)addr = (*data);\n        addr+=4;\n        data++;\n    }\n\n    while (FLASH->SR & (1<<16))\n        ;\n\n    if(FLASH->SR & (1<<1))\n    {\n        printf2(TAG_ERR,\"program NOT successful %lx\\r\\n\", FLASH->SR);\n    }\n\n    FLASH->SR = (1<<0);\n    FLASH->CR &= ~(1<<18);\n    __enable_irq();\n\n}\n"], "filenames": ["targets/stm32l432/src/device.c", "targets/stm32l432/src/flash.c"], "buggy_code_start_loc": [307, 73], "buggy_code_end_loc": [336, 74], "fixing_code_start_loc": [306, 73], "fixing_code_end_loc": [337, 78], "type": "CWE-326", "message": "The flash read-out protection (RDP) level is not enforced during the device initialization phase of the SoloKeys Solo 4.0.0 & Somu and the Nitrokey FIDO2 token. This allows an adversary to downgrade the RDP level and access secrets such as private ECC keys from SRAM via the debug interface.", "other": {"cve": {"id": "CVE-2020-27208", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-21T12:15:07.663", "lastModified": "2021-05-28T15:41:32.837", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The flash read-out protection (RDP) level is not enforced during the device initialization phase of the SoloKeys Solo 4.0.0 & Somu and the Nitrokey FIDO2 token. This allows an adversary to downgrade the RDP level and access secrets such as private ECC keys from SRAM via the debug interface."}, {"lang": "es", "value": "El nivel de protecci\u00f3n de lectura flash (RDP) no se aplica durante la fase de inicializaci\u00f3n del dispositivo del SoloKeys Solo 4.0.0 &amp; Somu y el token de Nitrokey FIDO2.&#xa0;Esto permite a un adversario degradar el nivel de RDP y acceder a secretos como claves ECC privadas de SRAM por medio de la interfaz de depuraci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-326"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:solokeys:solo_firmware:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "9F4A1941-6161-4C38-945C-298984D12855"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:solokeys:solo:-:*:*:*:*:*:*:*", "matchCriteriaId": "34CA8B4C-315B-44DC-9167-D124735508E6"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:solokeys:somu_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "AE13529D-B23F-43C3-A82A-BD82C671DB56"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:solokeys:somu:-:*:*:*:*:*:*:*", "matchCriteriaId": "842068EB-B958-45E3-A1FF-332D4617ABD5"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:nitrokey:fido2_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "AA9A941B-1849-47BB-ABC0-743FD1A4E330"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:nitrokey:fido2:-:*:*:*:*:*:*:*", "matchCriteriaId": "C6CA2A4B-E52A-4F7A-82B7-7CFBC69354D0"}]}]}], "references": [{"url": "https://eprint.iacr.org/2021/640", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/solokeys/solo/commit/a9c02cd354f34b48195a342c7f524abdef5cbcec", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://solokeys.com", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://twitter.com/SoloKeysSec", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://www.aisec.fraunhofer.de/de/das-institut/wissenschaftliche-exzellenz/security-and-trust-in-open-source-security-tokens.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.aisec.fraunhofer.de/en/FirmwareProtection.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/solokeys/solo/commit/a9c02cd354f34b48195a342c7f524abdef5cbcec"}}