{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * diff.c: code for diff'ing two, three or four buffers.\n *\n * There are three ways to diff:\n * - Shell out to an external diff program, using files.\n * - Use the compiled-in xdiff library.\n * - Let 'diffexpr' do the work, using files.\n */\n\n#include \"vim.h\"\n#include \"xdiff/xdiff.h\"\n\n#if defined(FEAT_DIFF) || defined(PROTO)\n\nstatic int diff_busy = FALSE;\t    // using diff structs, don't change them\nstatic int diff_need_update = FALSE; // ex_diffupdate needs to be called\n\n// flags obtained from the 'diffopt' option\n#define DIFF_FILLER\t0x001\t// display filler lines\n#define DIFF_IBLANK\t0x002\t// ignore empty lines\n#define DIFF_ICASE\t0x004\t// ignore case\n#define DIFF_IWHITE\t0x008\t// ignore change in white space\n#define DIFF_IWHITEALL\t0x010\t// ignore all white space changes\n#define DIFF_IWHITEEOL\t0x020\t// ignore change in white space at EOL\n#define DIFF_HORIZONTAL\t0x040\t// horizontal splits\n#define DIFF_VERTICAL\t0x080\t// vertical splits\n#define DIFF_HIDDEN_OFF\t0x100\t// diffoff when hidden\n#define DIFF_INTERNAL\t0x200\t// use internal xdiff algorithm\n#define DIFF_CLOSE_OFF\t0x400\t// diffoff when closing window\n#define DIFF_FOLLOWWRAP\t0x800\t// follow the wrap option\n#define ALL_WHITE_DIFF (DIFF_IWHITE | DIFF_IWHITEALL | DIFF_IWHITEEOL)\nstatic int\tdiff_flags = DIFF_INTERNAL | DIFF_FILLER | DIFF_CLOSE_OFF;\n\nstatic long diff_algorithm = 0;\n\n#define LBUFLEN 50\t\t// length of line in diff file\n\nstatic int diff_a_works = MAYBE; // TRUE when \"diff -a\" works, FALSE when it\n\t\t\t\t // doesn't work, MAYBE when not checked yet\n#if defined(MSWIN)\nstatic int diff_bin_works = MAYBE; // TRUE when \"diff --binary\" works, FALSE\n\t\t\t\t   // when it doesn't work, MAYBE when not\n\t\t\t\t   // checked yet\n#endif\n\n// used for diff input\ntypedef struct {\n    char_u\t*din_fname;  // used for external diff\n    mmfile_t\tdin_mmfile;  // used for internal diff\n} diffin_T;\n\n// used for diff result\ntypedef struct {\n    char_u\t*dout_fname;  // used for external diff\n    garray_T\tdout_ga;      // used for internal diff\n} diffout_T;\n\n// used for recording hunks from xdiff\ntypedef struct {\n    linenr_T lnum_orig;\n    long     count_orig;\n    linenr_T lnum_new;\n    long     count_new;\n} diffhunk_T;\n\n// two diff inputs and one result\ntypedef struct {\n    diffin_T\tdio_orig;     // original file input\n    diffin_T\tdio_new;      // new file input\n    diffout_T\tdio_diff;     // diff result\n    int\t\tdio_internal; // using internal diff\n} diffio_T;\n\nstatic int diff_buf_idx(buf_T *buf);\nstatic int diff_buf_idx_tp(buf_T *buf, tabpage_T *tp);\nstatic void diff_mark_adjust_tp(tabpage_T *tp, int idx, linenr_T line1, linenr_T line2, long amount, long amount_after);\nstatic void diff_check_unchanged(tabpage_T *tp, diff_T *dp);\nstatic int diff_check_sanity(tabpage_T *tp, diff_T *dp);\nstatic int check_external_diff(diffio_T *diffio);\nstatic int diff_file(diffio_T *diffio);\nstatic int diff_equal_entry(diff_T *dp, int idx1, int idx2);\nstatic int diff_cmp(char_u *s1, char_u *s2);\n#ifdef FEAT_FOLDING\nstatic void diff_fold_update(diff_T *dp, int skip_idx);\n#endif\nstatic void diff_read(int idx_orig, int idx_new, diffio_T *dio);\nstatic void diff_copy_entry(diff_T *dprev, diff_T *dp, int idx_orig, int idx_new);\nstatic diff_T *diff_alloc_new(tabpage_T *tp, diff_T *dprev, diff_T *dp);\nstatic int parse_diff_ed(char_u *line, diffhunk_T *hunk);\nstatic int parse_diff_unified(char_u *line, diffhunk_T *hunk);\nstatic int xdiff_out(long start_a, long count_a, long start_b, long count_b, void *priv);\n\n#define FOR_ALL_DIFFBLOCKS_IN_TAB(tp, dp) \\\n    for ((dp) = (tp)->tp_first_diff; (dp) != NULL; (dp) = (dp)->df_next)\n\n/*\n * Called when deleting or unloading a buffer: No longer make a diff with it.\n */\n    void\ndiff_buf_delete(buf_T *buf)\n{\n    int\t\ti;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\ti = diff_buf_idx_tp(buf, tp);\n\tif (i != DB_COUNT)\n\t{\n\t    tp->tp_diffbuf[i] = NULL;\n\t    tp->tp_diff_invalid = TRUE;\n\t    if (tp == curtab)\n\t    {\n\t\t// don't redraw right away, more might change or buffer state\n\t\t// is invalid right now\n\t\tneed_diff_redraw = TRUE;\n\t\tredraw_later(VALID);\n\t    }\n\t}\n    }\n}\n\n/*\n * Check if the current buffer should be added to or removed from the list of\n * diff buffers.\n */\n    void\ndiff_buf_adjust(win_T *win)\n{\n    win_T\t*wp;\n    int\t\ti;\n\n    if (!win->w_p_diff)\n    {\n\t// When there is no window showing a diff for this buffer, remove\n\t// it from the diffs.\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == win->w_buffer && wp->w_p_diff)\n\t\tbreak;\n\tif (wp == NULL)\n\t{\n\t    i = diff_buf_idx(win->w_buffer);\n\t    if (i != DB_COUNT)\n\t    {\n\t\tcurtab->tp_diffbuf[i] = NULL;\n\t\tcurtab->tp_diff_invalid = TRUE;\n\t\tdiff_redraw(TRUE);\n\t    }\n\t}\n    }\n    else\n\tdiff_buf_add(win->w_buffer);\n}\n\n/*\n * Add a buffer to make diffs for.\n * Call this when a new buffer is being edited in the current window where\n * 'diff' is set.\n * Marks the current buffer as being part of the diff and requiring updating.\n * This must be done before any autocmd, because a command may use info\n * about the screen contents.\n */\n    void\ndiff_buf_add(buf_T *buf)\n{\n    int\t\ti;\n\n    if (diff_buf_idx(buf) != DB_COUNT)\n\treturn;\t\t// It's already there.\n\n    for (i = 0; i < DB_COUNT; ++i)\n\tif (curtab->tp_diffbuf[i] == NULL)\n\t{\n\t    curtab->tp_diffbuf[i] = buf;\n\t    curtab->tp_diff_invalid = TRUE;\n\t    diff_redraw(TRUE);\n\t    return;\n\t}\n\n    semsg(_(e_cannot_diff_more_than_nr_buffers), DB_COUNT);\n}\n\n/*\n * Remove all buffers to make diffs for.\n */\n    static void\ndiff_buf_clear(void)\n{\n    int\t\ti;\n\n    for (i = 0; i < DB_COUNT; ++i)\n\tif (curtab->tp_diffbuf[i] != NULL)\n\t{\n\t    curtab->tp_diffbuf[i] = NULL;\n\t    curtab->tp_diff_invalid = TRUE;\n\t    diff_redraw(TRUE);\n\t}\n}\n\n/*\n * Find buffer \"buf\" in the list of diff buffers for the current tab page.\n * Return its index or DB_COUNT if not found.\n */\n    static int\ndiff_buf_idx(buf_T *buf)\n{\n    int\t\tidx;\n\n    for (idx = 0; idx < DB_COUNT; ++idx)\n\tif (curtab->tp_diffbuf[idx] == buf)\n\t    break;\n    return idx;\n}\n\n/*\n * Find buffer \"buf\" in the list of diff buffers for tab page \"tp\".\n * Return its index or DB_COUNT if not found.\n */\n    static int\ndiff_buf_idx_tp(buf_T *buf, tabpage_T *tp)\n{\n    int\t\tidx;\n\n    for (idx = 0; idx < DB_COUNT; ++idx)\n\tif (tp->tp_diffbuf[idx] == buf)\n\t    break;\n    return idx;\n}\n\n/*\n * Mark the diff info involving buffer \"buf\" as invalid, it will be updated\n * when info is requested.\n */\n    void\ndiff_invalidate(buf_T *buf)\n{\n    tabpage_T\t*tp;\n    int\t\ti;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\ti = diff_buf_idx_tp(buf, tp);\n\tif (i != DB_COUNT)\n\t{\n\t    tp->tp_diff_invalid = TRUE;\n\t    if (tp == curtab)\n\t\tdiff_redraw(TRUE);\n\t}\n    }\n}\n\n/*\n * Called by mark_adjust(): update line numbers in \"curbuf\".\n */\n    void\ndiff_mark_adjust(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after)\n{\n    int\t\tidx;\n    tabpage_T\t*tp;\n\n    // Handle all tab pages that use the current buffer in a diff.\n    FOR_ALL_TABPAGES(tp)\n    {\n\tidx = diff_buf_idx_tp(curbuf, tp);\n\tif (idx != DB_COUNT)\n\t    diff_mark_adjust_tp(tp, idx, line1, line2, amount, amount_after);\n    }\n}\n\n/*\n * Update line numbers in tab page \"tp\" for \"curbuf\" with index \"idx\".\n * This attempts to update the changes as much as possible:\n * When inserting/deleting lines outside of existing change blocks, create a\n * new change block and update the line numbers in following blocks.\n * When inserting/deleting lines in existing change blocks, update them.\n */\n    static void\ndiff_mark_adjust_tp(\n    tabpage_T\t*tp,\n    int\t\tidx,\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after)\n{\n    diff_T\t*dp;\n    diff_T\t*dprev;\n    diff_T\t*dnext;\n    int\t\ti;\n    int\t\tinserted, deleted;\n    int\t\tn, off;\n    linenr_T\tlast;\n    linenr_T\tlnum_deleted = line1;\t// lnum of remaining deletion\n    int\t\tcheck_unchanged;\n\n    if (diff_internal())\n    {\n\t// Will update diffs before redrawing.  Set _invalid to update the\n\t// diffs themselves, set _update to also update folds properly just\n\t// before redrawing.\n\t// Do update marks here, it is needed for :%diffput.\n\ttp->tp_diff_invalid = TRUE;\n\ttp->tp_diff_update = TRUE;\n    }\n\n    if (line2 == MAXLNUM)\n    {\n\t// mark_adjust(99, MAXLNUM, 9, 0): insert lines\n\tinserted = amount;\n\tdeleted = 0;\n    }\n    else if (amount_after > 0)\n    {\n\t// mark_adjust(99, 98, MAXLNUM, 9): a change that inserts lines\n\tinserted = amount_after;\n\tdeleted = 0;\n    }\n    else\n    {\n\t// mark_adjust(98, 99, MAXLNUM, -2): delete lines\n\tinserted = 0;\n\tdeleted = -amount_after;\n    }\n\n    dprev = NULL;\n    dp = tp->tp_first_diff;\n    for (;;)\n    {\n\t// If the change is after the previous diff block and before the next\n\t// diff block, thus not touching an existing change, create a new diff\n\t// block.  Don't do this when ex_diffgetput() is busy.\n\tif ((dp == NULL || dp->df_lnum[idx] - 1 > line2\n\t\t    || (line2 == MAXLNUM && dp->df_lnum[idx] > line1))\n\t\t&& (dprev == NULL\n\t\t    || dprev->df_lnum[idx] + dprev->df_count[idx] < line1)\n\t\t&& !diff_busy)\n\t{\n\t    dnext = diff_alloc_new(tp, dprev, dp);\n\t    if (dnext == NULL)\n\t\treturn;\n\n\t    dnext->df_lnum[idx] = line1;\n\t    dnext->df_count[idx] = inserted;\n\t    for (i = 0; i < DB_COUNT; ++i)\n\t\tif (tp->tp_diffbuf[i] != NULL && i != idx)\n\t\t{\n\t\t    if (dprev == NULL)\n\t\t\tdnext->df_lnum[i] = line1;\n\t\t    else\n\t\t\tdnext->df_lnum[i] = line1\n\t\t\t    + (dprev->df_lnum[i] + dprev->df_count[i])\n\t\t\t    - (dprev->df_lnum[idx] + dprev->df_count[idx]);\n\t\t    dnext->df_count[i] = deleted;\n\t\t}\n\t}\n\n\t// if at end of the list, quit\n\tif (dp == NULL)\n\t    break;\n\n\t/*\n\t * Check for these situations:\n\t *\t  1  2\t3\n\t *\t  1  2\t3\n\t * line1     2\t3  4  5\n\t *\t     2\t3  4  5\n\t *\t     2\t3  4  5\n\t * line2     2\t3  4  5\n\t *\t\t3     5  6\n\t *\t\t3     5  6\n\t */\n\t// compute last line of this change\n\tlast = dp->df_lnum[idx] + dp->df_count[idx] - 1;\n\n\t// 1. change completely above line1: nothing to do\n\tif (last >= line1 - 1)\n\t{\n\t    // 6. change below line2: only adjust for amount_after; also when\n\t    // \"deleted\" became zero when deleted all lines between two diffs\n\t    if (dp->df_lnum[idx] - (deleted + inserted != 0) > line2)\n\t    {\n\t\tif (amount_after == 0)\n\t\t    break;\t// nothing left to change\n\t\tdp->df_lnum[idx] += amount_after;\n\t    }\n\t    else\n\t    {\n\t\tcheck_unchanged = FALSE;\n\n\t\t// 2. 3. 4. 5.: inserted/deleted lines touching this diff.\n\t\tif (deleted > 0)\n\t\t{\n\t\t    if (dp->df_lnum[idx] >= line1)\n\t\t    {\n\t\t\toff = dp->df_lnum[idx] - lnum_deleted;\n\t\t\tif (last <= line2)\n\t\t\t{\n\t\t\t    // 4. delete all lines of diff\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp->df_next->df_lnum[idx] - lnum_deleted;\n\t\t\t\tdeleted -= n;\n\t\t\t\tn -= dp->df_count[idx];\n\t\t\t\tlnum_deleted = dp->df_next->df_lnum[idx];\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tn = deleted - dp->df_count[idx];\n\t\t\t    dp->df_count[idx] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // 5. delete lines at or just before top of diff\n\t\t\t    n = off;\n\t\t\t    dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\tdp->df_lnum[idx] = line1;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\toff = 0;\n\t\t\tif (last < line2)\n\t\t\t{\n\t\t\t    // 2. delete at end of diff\n\t\t\t    dp->df_count[idx] -= last - lnum_deleted + 1;\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp->df_next->df_lnum[idx] - 1 - last;\n\t\t\t\tdeleted -= dp->df_next->df_lnum[idx]\n\t\t\t\t\t\t\t       - lnum_deleted;\n\t\t\t\tlnum_deleted = dp->df_next->df_lnum[idx];\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tn = line2 - last;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // 3. delete lines inside the diff\n\t\t\t    n = 0;\n\t\t\t    dp->df_count[idx] -= deleted;\n\t\t\t}\n\t\t    }\n\n\t\t    for (i = 0; i < DB_COUNT; ++i)\n\t\t\tif (tp->tp_diffbuf[i] != NULL && i != idx)\n\t\t\t{\n\t\t\t    dp->df_lnum[i] -= off;\n\t\t\t    dp->df_count[i] += n;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (dp->df_lnum[idx] <= line1)\n\t\t    {\n\t\t\t// inserted lines somewhere in this diff\n\t\t\tdp->df_count[idx] += inserted;\n\t\t\tcheck_unchanged = TRUE;\n\t\t    }\n\t\t    else\n\t\t\t// inserted lines somewhere above this diff\n\t\t\tdp->df_lnum[idx] += inserted;\n\t\t}\n\n\t\tif (check_unchanged)\n\t\t    // Check if inserted lines are equal, may reduce the\n\t\t    // size of the diff.  TODO: also check for equal lines\n\t\t    // in the middle and perhaps split the block.\n\t\t    diff_check_unchanged(tp, dp);\n\t    }\n\t}\n\n\t// check if this block touches the previous one, may merge them.\n\tif (dprev != NULL && dprev->df_lnum[idx] + dprev->df_count[idx]\n\t\t\t\t\t\t\t  == dp->df_lnum[idx])\n\t{\n\t    for (i = 0; i < DB_COUNT; ++i)\n\t\tif (tp->tp_diffbuf[i] != NULL)\n\t\t    dprev->df_count[i] += dp->df_count[i];\n\t    dprev->df_next = dp->df_next;\n\t    vim_free(dp);\n\t    dp = dprev->df_next;\n\t}\n\telse\n\t{\n\t    // Advance to next entry.\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t}\n    }\n\n    dprev = NULL;\n    dp = tp->tp_first_diff;\n    while (dp != NULL)\n    {\n\t// All counts are zero, remove this entry.\n\tfor (i = 0; i < DB_COUNT; ++i)\n\t    if (tp->tp_diffbuf[i] != NULL && dp->df_count[i] != 0)\n\t\tbreak;\n\tif (i == DB_COUNT)\n\t{\n\t    dnext = dp->df_next;\n\t    vim_free(dp);\n\t    dp = dnext;\n\t    if (dprev == NULL)\n\t\ttp->tp_first_diff = dnext;\n\t    else\n\t\tdprev->df_next = dnext;\n\t}\n\telse\n\t{\n\t    // Advance to next entry.\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t}\n\n    }\n\n    if (tp == curtab)\n    {\n\t// Don't redraw right away, this updates the diffs, which can be slow.\n\tneed_diff_redraw = TRUE;\n\n\t// Need to recompute the scroll binding, may remove or add filler\n\t// lines (e.g., when adding lines above w_topline). But it's slow when\n\t// making many changes, postpone until redrawing.\n\tdiff_need_scrollbind = TRUE;\n    }\n}\n\n/*\n * Allocate a new diff block and link it between \"dprev\" and \"dp\".\n */\n    static diff_T *\ndiff_alloc_new(tabpage_T *tp, diff_T *dprev, diff_T *dp)\n{\n    diff_T\t*dnew;\n\n    dnew = ALLOC_ONE(diff_T);\n    if (dnew != NULL)\n    {\n\tdnew->df_next = dp;\n\tif (dprev == NULL)\n\t    tp->tp_first_diff = dnew;\n\telse\n\t    dprev->df_next = dnew;\n    }\n    return dnew;\n}\n\n/*\n * Check if the diff block \"dp\" can be made smaller for lines at the start and\n * end that are equal.  Called after inserting lines.\n * This may result in a change where all buffers have zero lines, the caller\n * must take care of removing it.\n */\n    static void\ndiff_check_unchanged(tabpage_T *tp, diff_T *dp)\n{\n    int\t\ti_org;\n    int\t\ti_new;\n    int\t\toff_org, off_new;\n    char_u\t*line_org;\n    int\t\tdir = FORWARD;\n\n    // Find the first buffers, use it as the original, compare the other\n    // buffer lines against this one.\n    for (i_org = 0; i_org < DB_COUNT; ++i_org)\n\tif (tp->tp_diffbuf[i_org] != NULL)\n\t    break;\n    if (i_org == DB_COUNT)\t// safety check\n\treturn;\n\n    if (diff_check_sanity(tp, dp) == FAIL)\n\treturn;\n\n    // First check lines at the top, then at the bottom.\n    off_org = 0;\n    off_new = 0;\n    for (;;)\n    {\n\t// Repeat until a line is found which is different or the number of\n\t// lines has become zero.\n\twhile (dp->df_count[i_org] > 0)\n\t{\n\t    // Copy the line, the next ml_get() will invalidate it.\n\t    if (dir == BACKWARD)\n\t\toff_org = dp->df_count[i_org] - 1;\n\t    line_org = vim_strsave(ml_get_buf(tp->tp_diffbuf[i_org],\n\t\t\t\t\tdp->df_lnum[i_org] + off_org, FALSE));\n\t    if (line_org == NULL)\n\t\treturn;\n\t    for (i_new = i_org + 1; i_new < DB_COUNT; ++i_new)\n\t    {\n\t\tif (tp->tp_diffbuf[i_new] == NULL)\n\t\t    continue;\n\t\tif (dir == BACKWARD)\n\t\t    off_new = dp->df_count[i_new] - 1;\n\t\t// if other buffer doesn't have this line, it was inserted\n\t\tif (off_new < 0 || off_new >= dp->df_count[i_new])\n\t\t    break;\n\t\tif (diff_cmp(line_org, ml_get_buf(tp->tp_diffbuf[i_new],\n\t\t\t\t   dp->df_lnum[i_new] + off_new, FALSE)) != 0)\n\t\t    break;\n\t    }\n\t    vim_free(line_org);\n\n\t    // Stop when a line isn't equal in all diff buffers.\n\t    if (i_new != DB_COUNT)\n\t\tbreak;\n\n\t    // Line matched in all buffers, remove it from the diff.\n\t    for (i_new = i_org; i_new < DB_COUNT; ++i_new)\n\t\tif (tp->tp_diffbuf[i_new] != NULL)\n\t\t{\n\t\t    if (dir == FORWARD)\n\t\t\t++dp->df_lnum[i_new];\n\t\t    --dp->df_count[i_new];\n\t\t}\n\t}\n\tif (dir == BACKWARD)\n\t    break;\n\tdir = BACKWARD;\n    }\n}\n\n/*\n * Check if a diff block doesn't contain invalid line numbers.\n * This can happen when the diff program returns invalid results.\n */\n    static int\ndiff_check_sanity(tabpage_T *tp, diff_T *dp)\n{\n    int\t\ti;\n\n    for (i = 0; i < DB_COUNT; ++i)\n\tif (tp->tp_diffbuf[i] != NULL)\n\t    if (dp->df_lnum[i] + dp->df_count[i] - 1\n\t\t\t\t      > tp->tp_diffbuf[i]->b_ml.ml_line_count)\n\t\treturn FAIL;\n    return OK;\n}\n\n/*\n * Mark all diff buffers in the current tab page for redraw.\n */\n    void\ndiff_redraw(\n    int\t\tdofold)\t    // also recompute the folds\n{\n    win_T\t*wp;\n    win_T\t*wp_other = NULL;\n    int\t\tused_max_fill_other = FALSE;\n    int\t\tused_max_fill_curwin = FALSE;\n    int\t\tn;\n\n    need_diff_redraw = FALSE;\n    FOR_ALL_WINDOWS(wp)\n\t// when closing windows or wiping buffers skip invalid window\n\tif (wp->w_p_diff && buf_valid(wp->w_buffer))\n\t{\n\t    redraw_win_later(wp, SOME_VALID);\n\t    if (wp != curwin)\n\t\twp_other = wp;\n#ifdef FEAT_FOLDING\n\t    if (dofold && foldmethodIsDiff(wp))\n\t\tfoldUpdateAll(wp);\n#endif\n\t    // A change may have made filler lines invalid, need to take care\n\t    // of that for other windows.\n\t    n = diff_check(wp, wp->w_topline);\n\t    if ((wp != curwin && wp->w_topfill > 0) || n > 0)\n\t    {\n\t\tif (wp->w_topfill > n)\n\t\t    wp->w_topfill = (n < 0 ? 0 : n);\n\t\telse if (n > 0 && n > wp->w_topfill)\n\t\t{\n\t\t    wp->w_topfill = n;\n\t\t    if (wp == curwin)\n\t\t\tused_max_fill_curwin = TRUE;\n\t\t    else if (wp_other != NULL)\n\t\t\tused_max_fill_other = TRUE;\n\t\t}\n\t\tcheck_topfill(wp, FALSE);\n\t    }\n\t}\n\n    if (wp_other != NULL && curwin->w_p_scb)\n    {\n\tif (used_max_fill_curwin)\n\t    // The current window was set to use the maximum number of filler\n\t    // lines, may need to reduce them.\n\t    diff_set_topline(wp_other, curwin);\n\telse if (used_max_fill_other)\n\t    // The other window was set to use the maximum number of filler\n\t    // lines, may need to reduce them.\n\t    diff_set_topline(curwin, wp_other);\n    }\n}\n\n    static void\nclear_diffin(diffin_T *din)\n{\n    if (din->din_fname == NULL)\n    {\n\tvim_free(din->din_mmfile.ptr);\n\tdin->din_mmfile.ptr = NULL;\n    }\n    else\n\tmch_remove(din->din_fname);\n}\n\n    static void\nclear_diffout(diffout_T *dout)\n{\n    if (dout->dout_fname == NULL)\n\tga_clear_strings(&dout->dout_ga);\n    else\n\tmch_remove(dout->dout_fname);\n}\n\n/*\n * Write buffer \"buf\" to a memory buffer.\n * Return FAIL for failure.\n */\n    static int\ndiff_write_buffer(buf_T *buf, diffin_T *din)\n{\n    linenr_T\tlnum;\n    char_u\t*s;\n    long\tlen = 0;\n    char_u\t*ptr;\n\n    // xdiff requires one big block of memory with all the text.\n    for (lnum = 1; lnum <= buf->b_ml.ml_line_count; ++lnum)\n\tlen += (long)STRLEN(ml_get_buf(buf, lnum, FALSE)) + 1;\n    ptr = alloc(len);\n    if (ptr == NULL)\n    {\n\t// Allocating memory failed.  This can happen, because we try to read\n\t// the whole buffer text into memory.  Set the failed flag, the diff\n\t// will be retried with external diff.  The flag is never reset.\n\tbuf->b_diff_failed = TRUE;\n\tif (p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    smsg(_(\"Not enough memory to use internal diff for buffer \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\t buf->b_fname);\n\t    verbose_leave();\n\t}\n\treturn FAIL;\n    }\n    din->din_mmfile.ptr = (char *)ptr;\n    din->din_mmfile.size = len;\n\n    len = 0;\n    for (lnum = 1; lnum <= buf->b_ml.ml_line_count; ++lnum)\n    {\n\tfor (s = ml_get_buf(buf, lnum, FALSE); *s != NUL; )\n\t{\n\t    if (diff_flags & DIFF_ICASE)\n\t    {\n\t\tint c;\n\t\tint\torig_len;\n\t\tchar_u\tcbuf[MB_MAXBYTES + 1];\n\n\t\tif (*s == NL)\n\t\t    c = NUL;\n\t\telse\n\t\t{\n\t\t    // xdiff doesn't support ignoring case, fold-case the text.\n\t\t    c = PTR2CHAR(s);\n\t\t    c = MB_CASEFOLD(c);\n\t\t}\n\t\torig_len = mb_ptr2len(s);\n\t\tif (mb_char2bytes(c, cbuf) != orig_len)\n\t\t    // TODO: handle byte length difference\n\t\t    mch_memmove(ptr + len, s, orig_len);\n\t\telse\n\t\t    mch_memmove(ptr + len, cbuf, orig_len);\n\n\t\ts += orig_len;\n\t\tlen += orig_len;\n\t    }\n\t    else\n\t    {\n\t\tptr[len++] = *s == NL ? NUL : *s;\n\t\ts++;\n\t    }\n\t}\n\tptr[len++] = NL;\n    }\n    return OK;\n}\n\n/*\n * Write buffer \"buf\" to file or memory buffer.\n * Return FAIL for failure.\n */\n    static int\ndiff_write(buf_T *buf, diffin_T *din)\n{\n    int\t\tr;\n    char_u\t*save_ff;\n    int\t\tsave_cmod_flags;\n\n    if (din->din_fname == NULL)\n\treturn diff_write_buffer(buf, din);\n\n    // Always use 'fileformat' set to \"unix\".\n    save_ff = buf->b_p_ff;\n    buf->b_p_ff = vim_strsave((char_u *)FF_UNIX);\n    save_cmod_flags = cmdmod.cmod_flags;\n    // Writing the buffer is an implementation detail of performing the diff,\n    // so it shouldn't update the '[ and '] marks.\n    cmdmod.cmod_flags |= CMOD_LOCKMARKS;\n    r = buf_write(buf, din->din_fname, NULL,\n\t\t\t(linenr_T)1, buf->b_ml.ml_line_count,\n\t\t\tNULL, FALSE, FALSE, FALSE, TRUE);\n    cmdmod.cmod_flags = save_cmod_flags;\n    free_string_option(buf->b_p_ff);\n    buf->b_p_ff = save_ff;\n    return r;\n}\n\n/*\n * Update the diffs for all buffers involved.\n */\n    static void\ndiff_try_update(\n\tdiffio_T    *dio,\n\tint\t    idx_orig,\n\texarg_T\t    *eap)\t// \"eap\" can be NULL\n{\n    buf_T\t*buf;\n    int\t\tidx_new;\n\n    if (dio->dio_internal)\n    {\n\tga_init2(&dio->dio_diff.dout_ga, sizeof(char *), 1000);\n    }\n    else\n    {\n\t// We need three temp file names.\n\tdio->dio_orig.din_fname = vim_tempname('o', TRUE);\n\tdio->dio_new.din_fname = vim_tempname('n', TRUE);\n\tdio->dio_diff.dout_fname = vim_tempname('d', TRUE);\n\tif (dio->dio_orig.din_fname == NULL\n\t\t|| dio->dio_new.din_fname == NULL\n\t\t|| dio->dio_diff.dout_fname == NULL)\n\t    goto theend;\n    }\n\n    // Check external diff is actually working.\n    if (!dio->dio_internal && check_external_diff(dio) == FAIL)\n\tgoto theend;\n\n    // :diffupdate!\n    if (eap != NULL && eap->forceit)\n\tfor (idx_new = idx_orig; idx_new < DB_COUNT; ++idx_new)\n\t{\n\t    buf = curtab->tp_diffbuf[idx_new];\n\t    if (buf_valid(buf))\n\t\tbuf_check_timestamp(buf, FALSE);\n\t}\n\n    // Write the first buffer to a tempfile or mmfile_t.\n    buf = curtab->tp_diffbuf[idx_orig];\n    if (diff_write(buf, &dio->dio_orig) == FAIL)\n\tgoto theend;\n\n    // Make a difference between the first buffer and every other.\n    for (idx_new = idx_orig + 1; idx_new < DB_COUNT; ++idx_new)\n    {\n\tbuf = curtab->tp_diffbuf[idx_new];\n\tif (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\t    continue; // skip buffer that isn't loaded\n\n\t// Write the other buffer and diff with the first one.\n\tif (diff_write(buf, &dio->dio_new) == FAIL)\n\t    continue;\n\tif (diff_file(dio) == FAIL)\n\t    continue;\n\n\t// Read the diff output and add each entry to the diff list.\n\tdiff_read(idx_orig, idx_new, dio);\n\n\tclear_diffin(&dio->dio_new);\n\tclear_diffout(&dio->dio_diff);\n    }\n    clear_diffin(&dio->dio_orig);\n\ntheend:\n    vim_free(dio->dio_orig.din_fname);\n    vim_free(dio->dio_new.din_fname);\n    vim_free(dio->dio_diff.dout_fname);\n}\n\n/*\n * Return TRUE if the options are set to use the internal diff library.\n * Note that if the internal diff failed for one of the buffers, the external\n * diff will be used anyway.\n */\n    int\ndiff_internal(void)\n{\n    return (diff_flags & DIFF_INTERNAL) != 0\n#ifdef FEAT_EVAL\n\t&& *p_dex == NUL\n#endif\n\t;\n}\n\n/*\n * Return TRUE if the internal diff failed for one of the diff buffers.\n */\n    static int\ndiff_internal_failed(void)\n{\n    int idx;\n\n    // Only need to do something when there is another buffer.\n    for (idx = 0; idx < DB_COUNT; ++idx)\n\tif (curtab->tp_diffbuf[idx] != NULL\n\t\t&& curtab->tp_diffbuf[idx]->b_diff_failed)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Completely update the diffs for the buffers involved.\n * When using the external \"diff\" command the buffers are written to a file,\n * also for unmodified buffers (the file could have been produced by\n * autocommands, e.g. the netrw plugin).\n */\n    void\nex_diffupdate(exarg_T *eap)\t// \"eap\" can be NULL\n{\n    int\t\tidx_orig;\n    int\t\tidx_new;\n    diffio_T\tdiffio;\n    int\t\thad_diffs = curtab->tp_first_diff != NULL;\n\n    if (diff_busy)\n    {\n\tdiff_need_update = TRUE;\n\treturn;\n    }\n\n    // Delete all diffblocks.\n    diff_clear(curtab);\n    curtab->tp_diff_invalid = FALSE;\n\n    // Use the first buffer as the original text.\n    for (idx_orig = 0; idx_orig < DB_COUNT; ++idx_orig)\n\tif (curtab->tp_diffbuf[idx_orig] != NULL)\n\t    break;\n    if (idx_orig == DB_COUNT)\n\tgoto theend;\n\n    // Only need to do something when there is another buffer.\n    for (idx_new = idx_orig + 1; idx_new < DB_COUNT; ++idx_new)\n\tif (curtab->tp_diffbuf[idx_new] != NULL)\n\t    break;\n    if (idx_new == DB_COUNT)\n\tgoto theend;\n\n    // Only use the internal method if it did not fail for one of the buffers.\n    CLEAR_FIELD(diffio);\n    diffio.dio_internal = diff_internal() && !diff_internal_failed();\n\n    diff_try_update(&diffio, idx_orig, eap);\n    if (diffio.dio_internal && diff_internal_failed())\n    {\n\t// Internal diff failed, use external diff instead.\n\tCLEAR_FIELD(diffio);\n\tdiff_try_update(&diffio, idx_orig, eap);\n    }\n\n    // force updating cursor position on screen\n    curwin->w_valid_cursor.lnum = 0;\n\ntheend:\n    // A redraw is needed if there were diffs and they were cleared, or there\n    // are diffs now, which means they got updated.\n    if (had_diffs || curtab->tp_first_diff != NULL)\n    {\n\tdiff_redraw(TRUE);\n\tapply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf);\n    }\n}\n\n/*\n * Do a quick test if \"diff\" really works.  Otherwise it looks like there\n * are no differences.  Can't use the return value, it's non-zero when\n * there are differences.\n */\n    static int\ncheck_external_diff(diffio_T *diffio)\n{\n    FILE\t*fd;\n    int\t\tok;\n    int\t\tio_error = FALSE;\n\n    // May try twice, first with \"-a\" and then without.\n    for (;;)\n    {\n\tok = FALSE;\n\tfd = mch_fopen((char *)diffio->dio_orig.din_fname, \"w\");\n\tif (fd == NULL)\n\t    io_error = TRUE;\n\telse\n\t{\n\t    if (fwrite(\"line1\\n\", (size_t)6, (size_t)1, fd) != 1)\n\t\tio_error = TRUE;\n\t    fclose(fd);\n\t    fd = mch_fopen((char *)diffio->dio_new.din_fname, \"w\");\n\t    if (fd == NULL)\n\t\tio_error = TRUE;\n\t    else\n\t    {\n\t\tif (fwrite(\"line2\\n\", (size_t)6, (size_t)1, fd) != 1)\n\t\t    io_error = TRUE;\n\t\tfclose(fd);\n\t\tfd = NULL;\n\t\tif (diff_file(diffio) == OK)\n\t\t    fd = mch_fopen((char *)diffio->dio_diff.dout_fname, \"r\");\n\t\tif (fd == NULL)\n\t\t    io_error = TRUE;\n\t\telse\n\t\t{\n\t\t    char_u\tlinebuf[LBUFLEN];\n\n\t\t    for (;;)\n\t\t    {\n\t\t\t// For normal diff there must be a line that contains\n\t\t\t// \"1c1\".  For unified diff \"@@ -1 +1 @@\".\n\t\t\tif (vim_fgets(linebuf, LBUFLEN, fd))\n\t\t\t    break;\n\t\t\tif (STRNCMP(linebuf, \"1c1\", 3) == 0\n\t\t\t\t|| STRNCMP(linebuf, \"@@ -1 +1 @@\", 11) == 0)\n\t\t\t    ok = TRUE;\n\t\t    }\n\t\t    fclose(fd);\n\t\t}\n\t\tmch_remove(diffio->dio_diff.dout_fname);\n\t\tmch_remove(diffio->dio_new.din_fname);\n\t    }\n\t    mch_remove(diffio->dio_orig.din_fname);\n\t}\n\n#ifdef FEAT_EVAL\n\t// When using 'diffexpr' break here.\n\tif (*p_dex != NUL)\n\t    break;\n#endif\n\n#if defined(MSWIN)\n\t// If the \"-a\" argument works, also check if \"--binary\" works.\n\tif (ok && diff_a_works == MAYBE && diff_bin_works == MAYBE)\n\t{\n\t    diff_a_works = TRUE;\n\t    diff_bin_works = TRUE;\n\t    continue;\n\t}\n\tif (!ok && diff_a_works == TRUE && diff_bin_works == TRUE)\n\t{\n\t    // Tried --binary, but it failed. \"-a\" works though.\n\t    diff_bin_works = FALSE;\n\t    ok = TRUE;\n\t}\n#endif\n\n\t// If we checked if \"-a\" works already, break here.\n\tif (diff_a_works != MAYBE)\n\t    break;\n\tdiff_a_works = ok;\n\n\t// If \"-a\" works break here, otherwise retry without \"-a\".\n\tif (ok)\n\t    break;\n    }\n    if (!ok)\n    {\n\tif (io_error)\n\t    emsg(_(e_cannot_read_or_write_temp_files));\n\temsg(_(e_cannot_create_diffs));\n\tdiff_a_works = MAYBE;\n#if defined(MSWIN)\n\tdiff_bin_works = MAYBE;\n#endif\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Invoke the xdiff function.\n */\n    static int\ndiff_file_internal(diffio_T *diffio)\n{\n    xpparam_t\t    param;\n    xdemitconf_t    emit_cfg;\n    xdemitcb_t\t    emit_cb;\n\n    CLEAR_FIELD(param);\n    CLEAR_FIELD(emit_cfg);\n    CLEAR_FIELD(emit_cb);\n\n    param.flags = diff_algorithm;\n\n    if (diff_flags & DIFF_IWHITE)\n\tparam.flags |= XDF_IGNORE_WHITESPACE_CHANGE;\n    if (diff_flags & DIFF_IWHITEALL)\n\tparam.flags |= XDF_IGNORE_WHITESPACE;\n    if (diff_flags & DIFF_IWHITEEOL)\n\tparam.flags |= XDF_IGNORE_WHITESPACE_AT_EOL;\n    if (diff_flags & DIFF_IBLANK)\n\tparam.flags |= XDF_IGNORE_BLANK_LINES;\n\n    emit_cfg.ctxlen = 0; // don't need any diff_context here\n    emit_cb.priv = &diffio->dio_diff;\n    emit_cfg.hunk_func = xdiff_out;\n    if (xdl_diff(&diffio->dio_orig.din_mmfile,\n\t\t&diffio->dio_new.din_mmfile,\n\t\t&param, &emit_cfg, &emit_cb) < 0)\n    {\n\temsg(_(e_problem_creating_internal_diff));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Make a diff between files \"tmp_orig\" and \"tmp_new\", results in \"tmp_diff\".\n * return OK or FAIL;\n */\n    static int\ndiff_file(diffio_T *dio)\n{\n    char_u\t*cmd;\n    size_t\tlen;\n    char_u\t*tmp_orig = dio->dio_orig.din_fname;\n    char_u\t*tmp_new = dio->dio_new.din_fname;\n    char_u\t*tmp_diff = dio->dio_diff.dout_fname;\n\n#ifdef FEAT_EVAL\n    if (*p_dex != NUL)\n    {\n\t// Use 'diffexpr' to generate the diff file.\n\teval_diff(tmp_orig, tmp_new, tmp_diff);\n\treturn OK;\n    }\n    else\n#endif\n    // Use xdiff for generating the diff.\n    if (dio->dio_internal)\n    {\n\treturn diff_file_internal(dio);\n    }\n    else\n    {\n\tlen = STRLEN(tmp_orig) + STRLEN(tmp_new)\n\t\t\t\t      + STRLEN(tmp_diff) + STRLEN(p_srr) + 27;\n\tcmd = alloc(len);\n\tif (cmd == NULL)\n\t    return FAIL;\n\n\t// We don't want $DIFF_OPTIONS to get in the way.\n\tif (getenv(\"DIFF_OPTIONS\"))\n\t    vim_setenv((char_u *)\"DIFF_OPTIONS\", (char_u *)\"\");\n\n\t// Build the diff command and execute it.  Always use -a, binary\n\t// differences are of no use.  Ignore errors, diff returns\n\t// non-zero when differences have been found.\n\tvim_snprintf((char *)cmd, len, \"diff %s%s%s%s%s%s%s%s %s\",\n\t\tdiff_a_works == FALSE ? \"\" : \"-a \",\n#if defined(MSWIN)\n\t\tdiff_bin_works == TRUE ? \"--binary \" : \"\",\n#else\n\t\t\"\",\n#endif\n\t\t(diff_flags & DIFF_IWHITE) ? \"-b \" : \"\",\n\t\t(diff_flags & DIFF_IWHITEALL) ? \"-w \" : \"\",\n\t\t(diff_flags & DIFF_IWHITEEOL) ? \"-Z \" : \"\",\n\t\t(diff_flags & DIFF_IBLANK) ? \"-B \" : \"\",\n\t\t(diff_flags & DIFF_ICASE) ? \"-i \" : \"\",\n\t\ttmp_orig, tmp_new);\n\tappend_redir(cmd, (int)len, p_srr, tmp_diff);\n\tblock_autocmds();\t// avoid ShellCmdPost stuff\n\t(void)call_shell(cmd, SHELL_FILTER|SHELL_SILENT|SHELL_DOOUT);\n\tunblock_autocmds();\n\tvim_free(cmd);\n\treturn OK;\n    }\n}\n\n/*\n * Create a new version of a file from the current buffer and a diff file.\n * The buffer is written to a file, also for unmodified buffers (the file\n * could have been produced by autocommands, e.g. the netrw plugin).\n */\n    void\nex_diffpatch(exarg_T *eap)\n{\n    char_u\t*tmp_orig;\t// name of original temp file\n    char_u\t*tmp_new;\t// name of patched temp file\n    char_u\t*buf = NULL;\n    size_t\tbuflen;\n    win_T\t*old_curwin = curwin;\n    char_u\t*newname = NULL;\t// name of patched file buffer\n#ifdef UNIX\n    char_u\tdirbuf[MAXPATHL];\n    char_u\t*fullname = NULL;\n#endif\n#ifdef FEAT_BROWSE\n    char_u\t*browseFile = NULL;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#endif\n    stat_T\tst;\n    char_u\t*esc_name = NULL;\n\n#ifdef FEAT_BROWSE\n    if (cmdmod.cmod_flags & CMOD_BROWSE)\n    {\n\tbrowseFile = do_browse(0, (char_u *)_(\"Patch file\"),\n\t\t\t eap->arg, NULL, NULL,\n\t\t\t (char_u *)_(BROWSE_FILTER_ALL_FILES), NULL);\n\tif (browseFile == NULL)\n\t    return;\t\t// operation cancelled\n\teap->arg = browseFile;\n\tcmdmod.cmod_flags &= ~CMOD_BROWSE; // don't let do_ecmd() browse again\n    }\n#endif\n\n    // We need two temp file names.\n    tmp_orig = vim_tempname('o', FALSE);\n    tmp_new = vim_tempname('n', FALSE);\n    if (tmp_orig == NULL || tmp_new == NULL)\n\tgoto theend;\n\n    // Write the current buffer to \"tmp_orig\".\n    if (buf_write(curbuf, tmp_orig, NULL,\n\t\t(linenr_T)1, curbuf->b_ml.ml_line_count,\n\t\t\t\t     NULL, FALSE, FALSE, FALSE, TRUE) == FAIL)\n\tgoto theend;\n\n#ifdef UNIX\n    // Get the absolute path of the patchfile, changing directory below.\n    fullname = FullName_save(eap->arg, FALSE);\n#endif\n    esc_name = vim_strsave_shellescape(\n# ifdef UNIX\n\t\t    fullname != NULL ? fullname :\n# endif\n\t\t    eap->arg, TRUE, TRUE);\n    if (esc_name == NULL)\n\tgoto theend;\n    buflen = STRLEN(tmp_orig) + STRLEN(esc_name) + STRLEN(tmp_new) + 16;\n    buf = alloc(buflen);\n    if (buf == NULL)\n\tgoto theend;\n\n#ifdef UNIX\n    // Temporarily chdir to /tmp, to avoid patching files in the current\n    // directory when the patch file contains more than one patch.  When we\n    // have our own temp dir use that instead, it will be cleaned up when we\n    // exit (any .rej files created).  Don't change directory if we can't\n    // return to the current.\n    if (mch_dirname(dirbuf, MAXPATHL) != OK || mch_chdir((char *)dirbuf) != 0)\n\tdirbuf[0] = NUL;\n    else\n    {\n# ifdef TEMPDIRNAMES\n\tif (vim_tempdir != NULL)\n\t    vim_ignored = mch_chdir((char *)vim_tempdir);\n\telse\n# endif\n\t    vim_ignored = mch_chdir(\"/tmp\");\n\tshorten_fnames(TRUE);\n    }\n#endif\n\n#ifdef FEAT_EVAL\n    if (*p_pex != NUL)\n\t// Use 'patchexpr' to generate the new file.\n\teval_patch(tmp_orig,\n# ifdef UNIX\n\t\tfullname != NULL ? fullname :\n# endif\n\t\teap->arg, tmp_new);\n    else\n#endif\n    {\n\t// Build the patch command and execute it.  Ignore errors.  Switch to\n\t// cooked mode to allow the user to respond to prompts.\n\tvim_snprintf((char *)buf, buflen, \"patch -o %s %s < %s\",\n\t\t\t\t\t\t  tmp_new, tmp_orig, esc_name);\n\tblock_autocmds();\t// Avoid ShellCmdPost stuff\n\t(void)call_shell(buf, SHELL_FILTER | SHELL_COOKED);\n\tunblock_autocmds();\n    }\n\n#ifdef UNIX\n    if (dirbuf[0] != NUL)\n    {\n\tif (mch_chdir((char *)dirbuf) != 0)\n\t    emsg(_(e_cannot_go_back_to_previous_directory));\n\tshorten_fnames(TRUE);\n    }\n#endif\n\n    // patch probably has written over the screen\n    redraw_later(CLEAR);\n\n    // Delete any .orig or .rej file created.\n    STRCPY(buf, tmp_new);\n    STRCAT(buf, \".orig\");\n    mch_remove(buf);\n    STRCPY(buf, tmp_new);\n    STRCAT(buf, \".rej\");\n    mch_remove(buf);\n\n    // Only continue if the output file was created.\n    if (mch_stat((char *)tmp_new, &st) < 0 || st.st_size == 0)\n\temsg(_(e_cannot_read_patch_output));\n    else\n    {\n\tif (curbuf->b_fname != NULL)\n\t{\n\t    newname = vim_strnsave(curbuf->b_fname,\n\t\t\t\t\t\t  STRLEN(curbuf->b_fname) + 4);\n\t    if (newname != NULL)\n\t\tSTRCAT(newname, \".new\");\n\t}\n\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\t// don't use a new tab page, each tab page has its own diffs\n\tcmdmod.cmod_tab = 0;\n\n\tif (win_split(0, (diff_flags & DIFF_VERTICAL) ? WSP_VERT : 0) != FAIL)\n\t{\n\t    // Pretend it was a \":split fname\" command\n\t    eap->cmdidx = CMD_split;\n\t    eap->arg = tmp_new;\n\t    do_exedit(eap, old_curwin);\n\n\t    // check that split worked and editing tmp_new\n\t    if (curwin != old_curwin && win_valid(old_curwin))\n\t    {\n\t\t// Set 'diff', 'scrollbind' on and 'wrap' off.\n\t\tdiff_win_options(curwin, TRUE);\n\t\tdiff_win_options(old_curwin, TRUE);\n\n\t\tif (newname != NULL)\n\t\t{\n\t\t    // do a \":file filename.new\" on the patched buffer\n\t\t    eap->arg = newname;\n\t\t    ex_file(eap);\n\n\t\t    // Do filetype detection with the new name.\n\t\t    if (au_has_group((char_u *)\"filetypedetect\"))\n\t\t\tdo_cmdline_cmd((char_u *)\":doau filetypedetect BufRead\");\n\t\t}\n\t    }\n\t}\n    }\n\ntheend:\n    if (tmp_orig != NULL)\n\tmch_remove(tmp_orig);\n    vim_free(tmp_orig);\n    if (tmp_new != NULL)\n\tmch_remove(tmp_new);\n    vim_free(tmp_new);\n    vim_free(newname);\n    vim_free(buf);\n#ifdef UNIX\n    vim_free(fullname);\n#endif\n    vim_free(esc_name);\n#ifdef FEAT_BROWSE\n    vim_free(browseFile);\n    cmdmod.cmod_flags = save_cmod_flags;\n#endif\n}\n\n/*\n * Split the window and edit another file, setting options to show the diffs.\n */\n    void\nex_diffsplit(exarg_T *eap)\n{\n    win_T\t*old_curwin = curwin;\n    bufref_T\told_curbuf;\n\n    set_bufref(&old_curbuf, curbuf);\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    // Need to compute w_fraction when no redraw happened yet.\n    validate_cursor();\n    set_fraction(curwin);\n\n    // don't use a new tab page, each tab page has its own diffs\n    cmdmod.cmod_tab = 0;\n\n    if (win_split(0, (diff_flags & DIFF_VERTICAL) ? WSP_VERT : 0) != FAIL)\n    {\n\t// Pretend it was a \":split fname\" command\n\teap->cmdidx = CMD_split;\n\tcurwin->w_p_diff = TRUE;\n\tdo_exedit(eap, old_curwin);\n\n\tif (curwin != old_curwin)\t\t// split must have worked\n\t{\n\t    // Set 'diff', 'scrollbind' on and 'wrap' off.\n\t    diff_win_options(curwin, TRUE);\n\t    if (win_valid(old_curwin))\n\t    {\n\t\tdiff_win_options(old_curwin, TRUE);\n\n\t\tif (bufref_valid(&old_curbuf))\n\t\t    // Move the cursor position to that of the old window.\n\t\t    curwin->w_cursor.lnum = diff_get_corresponding_line(\n\t\t\t    old_curbuf.br_buf, old_curwin->w_cursor.lnum);\n\t    }\n\t    // Now that lines are folded scroll to show the cursor at the same\n\t    // relative position.\n\t    scroll_to_fraction(curwin, curwin->w_height);\n\t}\n    }\n}\n\n/*\n * Set options to show diffs for the current window.\n */\n    void\nex_diffthis(exarg_T *eap UNUSED)\n{\n    // Set 'diff', 'scrollbind' on and 'wrap' off.\n    diff_win_options(curwin, TRUE);\n}\n\n    static void\nset_diff_option(win_T *wp, int value)\n{\n    win_T *old_curwin = curwin;\n\n    curwin = wp;\n    curbuf = curwin->w_buffer;\n    ++curbuf_lock;\n    set_option_value_give_err((char_u *)\"diff\", (long)value, NULL, OPT_LOCAL);\n    --curbuf_lock;\n    curwin = old_curwin;\n    curbuf = curwin->w_buffer;\n}\n\n/*\n * Set options in window \"wp\" for diff mode.\n */\n    void\ndiff_win_options(\n    win_T\t*wp,\n    int\t\taddbuf)\t\t// Add buffer to diff.\n{\n# ifdef FEAT_FOLDING\n    win_T *old_curwin = curwin;\n\n    // close the manually opened folds\n    curwin = wp;\n    newFoldLevel();\n    curwin = old_curwin;\n# endif\n\n    // Use 'scrollbind' and 'cursorbind' when available\n    if (!wp->w_p_diff)\n\twp->w_p_scb_save = wp->w_p_scb;\n    wp->w_p_scb = TRUE;\n    if (!wp->w_p_diff)\n\twp->w_p_crb_save = wp->w_p_crb;\n    wp->w_p_crb = TRUE;\n    if (!(diff_flags & DIFF_FOLLOWWRAP))\n    {\n\tif (!wp->w_p_diff)\n\t    wp->w_p_wrap_save = wp->w_p_wrap;\n\twp->w_p_wrap = FALSE;\n    }\n# ifdef FEAT_FOLDING\n    if (!wp->w_p_diff)\n    {\n\tif (wp->w_p_diff_saved)\n\t    free_string_option(wp->w_p_fdm_save);\n\twp->w_p_fdm_save = vim_strsave(wp->w_p_fdm);\n    }\n    set_string_option_direct_in_win(wp, (char_u *)\"fdm\", -1, (char_u *)\"diff\",\n\t\t\t\t\t\t       OPT_LOCAL|OPT_FREE, 0);\n    if (!wp->w_p_diff)\n    {\n\twp->w_p_fdc_save = wp->w_p_fdc;\n\twp->w_p_fen_save = wp->w_p_fen;\n\twp->w_p_fdl_save = wp->w_p_fdl;\n    }\n    wp->w_p_fdc = diff_foldcolumn;\n    wp->w_p_fen = TRUE;\n    wp->w_p_fdl = 0;\n    foldUpdateAll(wp);\n    // make sure topline is not halfway a fold\n    changed_window_setting_win(wp);\n# endif\n    if (vim_strchr(p_sbo, 'h') == NULL)\n\tdo_cmdline_cmd((char_u *)\"set sbo+=hor\");\n    // Save the current values, to be restored in ex_diffoff().\n    wp->w_p_diff_saved = TRUE;\n\n    set_diff_option(wp, TRUE);\n\n    if (addbuf)\n\tdiff_buf_add(wp->w_buffer);\n    redraw_win_later(wp, NOT_VALID);\n}\n\n/*\n * Set options not to show diffs.  For the current window or all windows.\n * Only in the current tab page.\n */\n    void\nex_diffoff(exarg_T *eap)\n{\n    win_T\t*wp;\n    int\t\tdiffwin = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (eap->forceit ? wp->w_p_diff : wp == curwin)\n\t{\n\t    // Set 'diff' off. If option values were saved in\n\t    // diff_win_options(), restore the ones whose settings seem to have\n\t    // been left over from diff mode.\n\t    set_diff_option(wp, FALSE);\n\n\t    if (wp->w_p_diff_saved)\n\t    {\n\n\t\tif (wp->w_p_scb)\n\t\t    wp->w_p_scb = wp->w_p_scb_save;\n\t\tif (wp->w_p_crb)\n\t\t    wp->w_p_crb = wp->w_p_crb_save;\n\t\tif (!(diff_flags & DIFF_FOLLOWWRAP))\n\t\t{\n\t\t    if (!wp->w_p_wrap)\n\t\t\twp->w_p_wrap = wp->w_p_wrap_save;\n\t\t}\n#ifdef FEAT_FOLDING\n\t\tfree_string_option(wp->w_p_fdm);\n\t\twp->w_p_fdm = vim_strsave(\n\t\t    *wp->w_p_fdm_save ? wp->w_p_fdm_save : (char_u*)\"manual\");\n\n\t\tif (wp->w_p_fdc == diff_foldcolumn)\n\t\t    wp->w_p_fdc = wp->w_p_fdc_save;\n\t\tif (wp->w_p_fdl == 0)\n\t\t    wp->w_p_fdl = wp->w_p_fdl_save;\n\n\t\t// Only restore 'foldenable' when 'foldmethod' is not\n\t\t// \"manual\", otherwise we continue to show the diff folds.\n\t\tif (wp->w_p_fen)\n\t\t    wp->w_p_fen = foldmethodIsManual(wp) ? FALSE\n\t\t\t\t\t\t\t : wp->w_p_fen_save;\n\n\t\tfoldUpdateAll(wp);\n#endif\n\t    }\n\t    // remove filler lines\n\t    wp->w_topfill = 0;\n\n\t    // make sure topline is not halfway a fold and cursor is\n\t    // invalidated\n\t    changed_window_setting_win(wp);\n\n\t    // Note: 'sbo' is not restored, it's a global option.\n\t    diff_buf_adjust(wp);\n\t}\n\tdiffwin |= wp->w_p_diff;\n    }\n\n    // Also remove hidden buffers from the list.\n    if (eap->forceit)\n\tdiff_buf_clear();\n\n    if (!diffwin)\n    {\n\tdiff_need_update = FALSE;\n\tcurtab->tp_diff_invalid = FALSE;\n\tcurtab->tp_diff_update = FALSE;\n\tdiff_clear(curtab);\n    }\n\n    // Remove \"hor\" from 'scrollopt' if there are no diff windows left.\n    if (!diffwin && vim_strchr(p_sbo, 'h') != NULL)\n\tdo_cmdline_cmd((char_u *)\"set sbo-=hor\");\n}\n\n/*\n * Read the diff output and add each entry to the diff list.\n */\n    static void\ndiff_read(\n    int\t\tidx_orig,\t// idx of original file\n    int\t\tidx_new,\t// idx of new file\n    diffio_T   *dio)\t\t// diff output\n{\n    FILE\t*fd = NULL;\n    int\t\tline_idx = 0;\n    diff_T\t*dprev = NULL;\n    diff_T\t*dp = curtab->tp_first_diff;\n    diff_T\t*dn, *dpl;\n    diffout_T   *dout = &dio->dio_diff;\n    char_u\tlinebuf[LBUFLEN];   // only need to hold the diff line\n    char_u\t*line;\n    long\toff;\n    int\t\ti;\n    int\t\tnotset = TRUE;\t    // block \"*dp\" not set yet\n    diffhunk_T\t*hunk = NULL;\t    // init to avoid gcc warning\n\n    enum {\n\tDIFF_ED,\n\tDIFF_UNIFIED,\n\tDIFF_NONE\n    } diffstyle = DIFF_NONE;\n\n    if (dout->dout_fname == NULL)\n    {\n\tdiffstyle = DIFF_UNIFIED;\n    }\n    else\n    {\n\tfd = mch_fopen((char *)dout->dout_fname, \"r\");\n\tif (fd == NULL)\n\t{\n\t    emsg(_(e_cannot_read_diff_output));\n\t    return;\n\t}\n    }\n\n    if (!dio->dio_internal)\n    {\n\thunk = ALLOC_ONE(diffhunk_T);\n\tif (hunk == NULL)\n\t{\n\t    if (fd != NULL)\n\t\tfclose(fd);\n\t    return;\n\t}\n    }\n\n    for (;;)\n    {\n\tif (dio->dio_internal)\n\t{\n\t    if (line_idx >= dout->dout_ga.ga_len) {\n\t\tbreak;      // did last line\n\t    }\n\t    hunk = ((diffhunk_T **)dout->dout_ga.ga_data)[line_idx++];\n\t}\n\telse\n\t{\n\t    if (fd == NULL)\n\t    {\n\t\tif (line_idx >= dout->dout_ga.ga_len)\n\t\t    break;\t    // did last line\n\t\tline = ((char_u **)dout->dout_ga.ga_data)[line_idx++];\n\t    }\n\t    else\n\t    {\n\t\tif (vim_fgets(linebuf, LBUFLEN, fd))\n\t\t    break;\t\t// end of file\n\t\tline = linebuf;\n\t    }\n\n\t    if (diffstyle == DIFF_NONE)\n\t    {\n\t\t// Determine diff style.\n\t\t// ed like diff looks like this:\n\t\t// {first}[,{last}]c{first}[,{last}]\n\t\t// {first}a{first}[,{last}]\n\t\t// {first}[,{last}]d{first}\n\t\t//\n\t\t// unified diff looks like this:\n\t\t// --- file1       2018-03-20 13:23:35.783153140 +0100\n\t\t// +++ file2       2018-03-20 13:23:41.183156066 +0100\n\t\t// @@ -1,3 +1,5 @@\n\t\tif (isdigit(*line))\n\t\t    diffstyle = DIFF_ED;\n\t\telse if ((STRNCMP(line, \"@@ \", 3) == 0))\n\t\t    diffstyle = DIFF_UNIFIED;\n\t\telse if ((STRNCMP(line, \"--- \", 4) == 0)\n\t\t\t&& (vim_fgets(linebuf, LBUFLEN, fd) == 0)\n\t\t\t&& (STRNCMP(line, \"+++ \", 4) == 0)\n\t\t\t&& (vim_fgets(linebuf, LBUFLEN, fd) == 0)\n\t\t\t&& (STRNCMP(line, \"@@ \", 3) == 0))\n\t\t    diffstyle = DIFF_UNIFIED;\n\t\telse\n\t\t    // Format not recognized yet, skip over this line.  Cygwin\n\t\t    // diff may put a warning at the start of the file.\n\t\t    continue;\n\t    }\n\n\t    if (diffstyle == DIFF_ED)\n\t    {\n\t\tif (!isdigit(*line))\n\t\t    continue;\t// not the start of a diff block\n\t\tif (parse_diff_ed(line, hunk) == FAIL)\n\t\t    continue;\n\t    }\n\t    else if (diffstyle == DIFF_UNIFIED)\n\t    {\n\t\tif (STRNCMP(line, \"@@ \", 3)  != 0)\n\t\t    continue;\t// not the start of a diff block\n\t\tif (parse_diff_unified(line, hunk) == FAIL)\n\t\t    continue;\n\t    }\n\t    else\n\t    {\n\t\temsg(_(e_invalid_diff_format));\n\t\tbreak;\n\t    }\n\t}\n\n\t// Go over blocks before the change, for which orig and new are equal.\n\t// Copy blocks from orig to new.\n\twhile (dp != NULL\n\t\t&& hunk->lnum_orig > dp->df_lnum[idx_orig]\n\t\t\t\t\t\t      + dp->df_count[idx_orig])\n\t{\n\t    if (notset)\n\t\tdiff_copy_entry(dprev, dp, idx_orig, idx_new);\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t    notset = TRUE;\n\t}\n\n\tif (dp != NULL\n\t\t&& hunk->lnum_orig <= dp->df_lnum[idx_orig]\n\t\t\t\t\t\t       + dp->df_count[idx_orig]\n\t\t&& hunk->lnum_orig + hunk->count_orig >= dp->df_lnum[idx_orig])\n\t{\n\t    // New block overlaps with existing block(s).\n\t    // First find last block that overlaps.\n\t    for (dpl = dp; dpl->df_next != NULL; dpl = dpl->df_next)\n\t\tif (hunk->lnum_orig + hunk->count_orig\n\t\t\t\t\t     < dpl->df_next->df_lnum[idx_orig])\n\t\t    break;\n\n\t    // If the newly found block starts before the old one, set the\n\t    // start back a number of lines.\n\t    off = dp->df_lnum[idx_orig] - hunk->lnum_orig;\n\t    if (off > 0)\n\t    {\n\t\tfor (i = idx_orig; i < idx_new; ++i)\n\t\t    if (curtab->tp_diffbuf[i] != NULL)\n\t\t\tdp->df_lnum[i] -= off;\n\t\tdp->df_lnum[idx_new] = hunk->lnum_new;\n\t\tdp->df_count[idx_new] = hunk->count_new;\n\t    }\n\t    else if (notset)\n\t    {\n\t\t// new block inside existing one, adjust new block\n\t\tdp->df_lnum[idx_new] = hunk->lnum_new + off;\n\t\tdp->df_count[idx_new] = hunk->count_new - off;\n\t    }\n\t    else\n\t\t// second overlap of new block with existing block\n\t\tdp->df_count[idx_new] += hunk->count_new - hunk->count_orig\n\t\t    + dpl->df_lnum[idx_orig] + dpl->df_count[idx_orig]\n\t\t    - (dp->df_lnum[idx_orig] + dp->df_count[idx_orig]);\n\n\t    // Adjust the size of the block to include all the lines to the\n\t    // end of the existing block or the new diff, whatever ends last.\n\t    off = (hunk->lnum_orig + hunk->count_orig)\n\t\t\t - (dpl->df_lnum[idx_orig] + dpl->df_count[idx_orig]);\n\t    if (off < 0)\n\t    {\n\t\t// new change ends in existing block, adjust the end if not\n\t\t// done already\n\t\tif (notset)\n\t\t    dp->df_count[idx_new] += -off;\n\t\toff = 0;\n\t    }\n\t    for (i = idx_orig; i < idx_new; ++i)\n\t\tif (curtab->tp_diffbuf[i] != NULL)\n\t\t    dp->df_count[i] = dpl->df_lnum[i] + dpl->df_count[i]\n\t\t\t\t\t\t       - dp->df_lnum[i] + off;\n\n\t    // Delete the diff blocks that have been merged into one.\n\t    dn = dp->df_next;\n\t    dp->df_next = dpl->df_next;\n\t    while (dn != dp->df_next)\n\t    {\n\t\tdpl = dn->df_next;\n\t\tvim_free(dn);\n\t\tdn = dpl;\n\t    }\n\t}\n\telse\n\t{\n\t    // Allocate a new diffblock.\n\t    dp = diff_alloc_new(curtab, dprev, dp);\n\t    if (dp == NULL)\n\t\tgoto done;\n\n\t    dp->df_lnum[idx_orig] = hunk->lnum_orig;\n\t    dp->df_count[idx_orig] = hunk->count_orig;\n\t    dp->df_lnum[idx_new] = hunk->lnum_new;\n\t    dp->df_count[idx_new] = hunk->count_new;\n\n\t    // Set values for other buffers, these must be equal to the\n\t    // original buffer, otherwise there would have been a change\n\t    // already.\n\t    for (i = idx_orig + 1; i < idx_new; ++i)\n\t\tif (curtab->tp_diffbuf[i] != NULL)\n\t\t    diff_copy_entry(dprev, dp, idx_orig, i);\n\t}\n\tnotset = FALSE;\t\t// \"*dp\" has been set\n    }\n\n    // for remaining diff blocks orig and new are equal\n    while (dp != NULL)\n    {\n\tif (notset)\n\t    diff_copy_entry(dprev, dp, idx_orig, idx_new);\n\tdprev = dp;\n\tdp = dp->df_next;\n\tnotset = TRUE;\n    }\n\ndone:\n    if (!dio->dio_internal)\n\tvim_free(hunk);\n\n    if (fd != NULL)\n\tfclose(fd);\n}\n\n/*\n * Copy an entry at \"dp\" from \"idx_orig\" to \"idx_new\".\n */\n    static void\ndiff_copy_entry(\n    diff_T\t*dprev,\n    diff_T\t*dp,\n    int\t\tidx_orig,\n    int\t\tidx_new)\n{\n    long\toff;\n\n    if (dprev == NULL)\n\toff = 0;\n    else\n\toff = (dprev->df_lnum[idx_orig] + dprev->df_count[idx_orig])\n\t    - (dprev->df_lnum[idx_new] + dprev->df_count[idx_new]);\n    dp->df_lnum[idx_new] = dp->df_lnum[idx_orig] - off;\n    dp->df_count[idx_new] = dp->df_count[idx_orig];\n}\n\n/*\n * Clear the list of diffblocks for tab page \"tp\".\n */\n    void\ndiff_clear(tabpage_T *tp)\n{\n    diff_T\t*p, *next_p;\n\n    for (p = tp->tp_first_diff; p != NULL; p = next_p)\n    {\n\tnext_p = p->df_next;\n\tvim_free(p);\n    }\n    tp->tp_first_diff = NULL;\n}\n\n/*\n * Check diff status for line \"lnum\" in buffer \"buf\":\n * Returns 0 for nothing special\n * Returns -1 for a line that should be highlighted as changed.\n * Returns -2 for a line that should be highlighted as added/deleted.\n * Returns > 0 for inserting that many filler lines above it (never happens\n * when 'diffopt' doesn't contain \"filler\").\n * This should only be used for windows where 'diff' is set.\n */\n    int\ndiff_check(win_T *wp, linenr_T lnum)\n{\n    int\t\tidx;\t\t// index in tp_diffbuf[] for this buffer\n    diff_T\t*dp;\n    int\t\tmaxcount;\n    int\t\ti;\n    buf_T\t*buf = wp->w_buffer;\n    int\t\tcmp;\n\n    if (curtab->tp_diff_invalid)\n\tex_diffupdate(NULL);\t\t// update after a big change\n\n    if (curtab->tp_first_diff == NULL || !wp->w_p_diff)\t// no diffs at all\n\treturn 0;\n\n    // safety check: \"lnum\" must be a buffer line\n    if (lnum < 1 || lnum > buf->b_ml.ml_line_count + 1)\n\treturn 0;\n\n    idx = diff_buf_idx(buf);\n    if (idx == DB_COUNT)\n\treturn 0;\t\t// no diffs for buffer \"buf\"\n\n#ifdef FEAT_FOLDING\n    // A closed fold never has filler lines.\n    if (hasFoldingWin(wp, lnum, NULL, NULL, TRUE, NULL))\n\treturn 0;\n#endif\n\n    // search for a change that includes \"lnum\" in the list of diffblocks.\n    FOR_ALL_DIFFBLOCKS_IN_TAB(curtab, dp)\n\tif (lnum <= dp->df_lnum[idx] + dp->df_count[idx])\n\t    break;\n    if (dp == NULL || lnum < dp->df_lnum[idx])\n\treturn 0;\n\n    if (lnum < dp->df_lnum[idx] + dp->df_count[idx])\n    {\n\tint\tzero = FALSE;\n\n\t// Changed or inserted line.  If the other buffers have a count of\n\t// zero, the lines were inserted.  If the other buffers have the same\n\t// count, check if the lines are identical.\n\tcmp = FALSE;\n\tfor (i = 0; i < DB_COUNT; ++i)\n\t    if (i != idx && curtab->tp_diffbuf[i] != NULL)\n\t    {\n\t\tif (dp->df_count[i] == 0)\n\t\t    zero = TRUE;\n\t\telse\n\t\t{\n\t\t    if (dp->df_count[i] != dp->df_count[idx])\n\t\t\treturn -1;\t    // nr of lines changed.\n\t\t    cmp = TRUE;\n\t\t}\n\t    }\n\tif (cmp)\n\t{\n\t    // Compare all lines.  If they are equal the lines were inserted\n\t    // in some buffers, deleted in others, but not changed.\n\t    for (i = 0; i < DB_COUNT; ++i)\n\t\tif (i != idx && curtab->tp_diffbuf[i] != NULL\n\t\t\t\t\t\t      && dp->df_count[i] != 0)\n\t\t    if (!diff_equal_entry(dp, idx, i))\n\t\t\treturn -1;\n\t}\n\t// If there is no buffer with zero lines then there is no difference\n\t// any longer.  Happens when making a change (or undo) that removes\n\t// the difference.  Can't remove the entry here, we might be halfway\n\t// updating the window.  Just report the text as unchanged.  Other\n\t// windows might still show the change though.\n\tif (zero == FALSE)\n\t    return 0;\n\treturn -2;\n    }\n\n    // If 'diffopt' doesn't contain \"filler\", return 0.\n    if (!(diff_flags & DIFF_FILLER))\n\treturn 0;\n\n    // Insert filler lines above the line just below the change.  Will return\n    // 0 when this buf had the max count.\n    maxcount = 0;\n    for (i = 0; i < DB_COUNT; ++i)\n\tif (curtab->tp_diffbuf[i] != NULL && dp->df_count[i] > maxcount)\n\t    maxcount = dp->df_count[i];\n    return maxcount - dp->df_count[idx];\n}\n\n/*\n * Compare two entries in diff \"*dp\" and return TRUE if they are equal.\n */\n    static int\ndiff_equal_entry(diff_T *dp, int idx1, int idx2)\n{\n    int\t\ti;\n    char_u\t*line;\n    int\t\tcmp;\n\n    if (dp->df_count[idx1] != dp->df_count[idx2])\n\treturn FALSE;\n    if (diff_check_sanity(curtab, dp) == FAIL)\n\treturn FALSE;\n    for (i = 0; i < dp->df_count[idx1]; ++i)\n    {\n\tline = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx1],\n\t\t\t\t\t       dp->df_lnum[idx1] + i, FALSE));\n\tif (line == NULL)\n\t    return FALSE;\n\tcmp = diff_cmp(line, ml_get_buf(curtab->tp_diffbuf[idx2],\n\t\t\t\t\t       dp->df_lnum[idx2] + i, FALSE));\n\tvim_free(line);\n\tif (cmp != 0)\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Compare the characters at \"p1\" and \"p2\".  If they are equal (possibly\n * ignoring case) return TRUE and set \"len\" to the number of bytes.\n */\n    static int\ndiff_equal_char(char_u *p1, char_u *p2, int *len)\n{\n    int l  = (*mb_ptr2len)(p1);\n\n    if (l != (*mb_ptr2len)(p2))\n\treturn FALSE;\n    if (l > 1)\n    {\n\tif (STRNCMP(p1, p2, l) != 0\n\t\t&& (!enc_utf8\n\t\t    || !(diff_flags & DIFF_ICASE)\n\t\t    || utf_fold(utf_ptr2char(p1))\n\t\t\t\t\t\t!= utf_fold(utf_ptr2char(p2))))\n\t    return FALSE;\n\t*len = l;\n    }\n    else\n    {\n\tif ((*p1 != *p2)\n\t\t&& (!(diff_flags & DIFF_ICASE)\n\t\t    || TOLOWER_LOC(*p1) != TOLOWER_LOC(*p2)))\n\t    return FALSE;\n\t*len = 1;\n    }\n    return TRUE;\n}\n\n/*\n * Compare strings \"s1\" and \"s2\" according to 'diffopt'.\n * Return non-zero when they are different.\n */\n    static int\ndiff_cmp(char_u *s1, char_u *s2)\n{\n    char_u\t*p1, *p2;\n    int\t\tl;\n\n    if ((diff_flags & DIFF_IBLANK)\n\t    && (*skipwhite(s1) == NUL || *skipwhite(s2) == NUL))\n\treturn 0;\n\n    if ((diff_flags & (DIFF_ICASE | ALL_WHITE_DIFF)) == 0)\n\treturn STRCMP(s1, s2);\n    if ((diff_flags & DIFF_ICASE) && !(diff_flags & ALL_WHITE_DIFF))\n\treturn MB_STRICMP(s1, s2);\n\n    p1 = s1;\n    p2 = s2;\n\n    // Ignore white space changes and possibly ignore case.\n    while (*p1 != NUL && *p2 != NUL)\n    {\n\tif (((diff_flags & DIFF_IWHITE)\n\t\t    && VIM_ISWHITE(*p1) && VIM_ISWHITE(*p2))\n\t\t|| ((diff_flags & DIFF_IWHITEALL)\n\t\t    && (VIM_ISWHITE(*p1) || VIM_ISWHITE(*p2))))\n\t{\n\t    p1 = skipwhite(p1);\n\t    p2 = skipwhite(p2);\n\t}\n\telse\n\t{\n\t    if (!diff_equal_char(p1, p2, &l))\n\t\tbreak;\n\t    p1 += l;\n\t    p2 += l;\n\t}\n    }\n\n    // Ignore trailing white space.\n    p1 = skipwhite(p1);\n    p2 = skipwhite(p2);\n    if (*p1 != NUL || *p2 != NUL)\n\treturn 1;\n    return 0;\n}\n\n/*\n * Return the number of filler lines above \"lnum\".\n */\n    int\ndiff_check_fill(win_T *wp, linenr_T lnum)\n{\n    int\t\tn;\n\n    // be quick when there are no filler lines\n    if (!(diff_flags & DIFF_FILLER))\n\treturn 0;\n    n = diff_check(wp, lnum);\n    if (n <= 0)\n\treturn 0;\n    return n;\n}\n\n/*\n * Set the topline of \"towin\" to match the position in \"fromwin\", so that they\n * show the same diff'ed lines.\n */\n    void\ndiff_set_topline(win_T *fromwin, win_T *towin)\n{\n    buf_T\t*frombuf = fromwin->w_buffer;\n    linenr_T\tlnum = fromwin->w_topline;\n    int\t\tfromidx;\n    int\t\ttoidx;\n    diff_T\t*dp;\n    int\t\tmax_count;\n    int\t\ti;\n\n    fromidx = diff_buf_idx(frombuf);\n    if (fromidx == DB_COUNT)\n\treturn;\t\t// safety check\n\n    if (curtab->tp_diff_invalid)\n\tex_diffupdate(NULL);\t\t// update after a big change\n\n    towin->w_topfill = 0;\n\n    // search for a change that includes \"lnum\" in the list of diffblocks.\n    FOR_ALL_DIFFBLOCKS_IN_TAB(curtab, dp)\n\tif (lnum <= dp->df_lnum[fromidx] + dp->df_count[fromidx])\n\t    break;\n    if (dp == NULL)\n    {\n\t// After last change, compute topline relative to end of file; no\n\t// filler lines.\n\ttowin->w_topline = towin->w_buffer->b_ml.ml_line_count\n\t\t\t\t       - (frombuf->b_ml.ml_line_count - lnum);\n    }\n    else\n    {\n\t// Find index for \"towin\".\n\ttoidx = diff_buf_idx(towin->w_buffer);\n\tif (toidx == DB_COUNT)\n\t    return;\t\t// safety check\n\n\ttowin->w_topline = lnum + (dp->df_lnum[toidx] - dp->df_lnum[fromidx]);\n\tif (lnum >= dp->df_lnum[fromidx])\n\t{\n\t    // Inside a change: compute filler lines. With three or more\n\t    // buffers we need to know the largest count.\n\t    max_count = 0;\n\t    for (i = 0; i < DB_COUNT; ++i)\n\t\tif (curtab->tp_diffbuf[i] != NULL\n\t\t\t\t\t       && max_count < dp->df_count[i])\n\t\t    max_count = dp->df_count[i];\n\n\t    if (dp->df_count[toidx] == dp->df_count[fromidx])\n\t    {\n\t\t// same number of lines: use same filler count\n\t\ttowin->w_topfill = fromwin->w_topfill;\n\t    }\n\t    else if (dp->df_count[toidx] > dp->df_count[fromidx])\n\t    {\n\t\tif (lnum == dp->df_lnum[fromidx] + dp->df_count[fromidx])\n\t\t{\n\t\t    // more lines in towin and fromwin doesn't show diff\n\t\t    // lines, only filler lines\n\t\t    if (max_count - fromwin->w_topfill >= dp->df_count[toidx])\n\t\t    {\n\t\t\t// towin also only shows filler lines\n\t\t\ttowin->w_topline = dp->df_lnum[toidx]\n\t\t\t\t\t\t       + dp->df_count[toidx];\n\t\t\ttowin->w_topfill = fromwin->w_topfill;\n\t\t    }\n\t\t    else\n\t\t\t// towin still has some diff lines to show\n\t\t\ttowin->w_topline = dp->df_lnum[toidx]\n\t\t\t\t\t     + max_count - fromwin->w_topfill;\n\t\t}\n\t    }\n\t    else if (towin->w_topline >= dp->df_lnum[toidx]\n\t\t\t\t\t\t\t+ dp->df_count[toidx])\n\t    {\n\t\t// less lines in towin and no diff lines to show: compute\n\t\t// filler lines\n\t\ttowin->w_topline = dp->df_lnum[toidx] + dp->df_count[toidx];\n\t\tif (diff_flags & DIFF_FILLER)\n\t\t{\n\t\t    if (lnum == dp->df_lnum[fromidx] + dp->df_count[fromidx])\n\t\t\t// fromwin is also out of diff lines\n\t\t\ttowin->w_topfill = fromwin->w_topfill;\n\t\t    else\n\t\t\t// fromwin has some diff lines\n\t\t\ttowin->w_topfill = dp->df_lnum[fromidx]\n\t\t\t\t\t\t\t   + max_count - lnum;\n\t\t}\n\t    }\n\t}\n    }\n\n    // safety check (if diff info gets outdated strange things may happen)\n    towin->w_botfill = FALSE;\n    if (towin->w_topline > towin->w_buffer->b_ml.ml_line_count)\n    {\n\ttowin->w_topline = towin->w_buffer->b_ml.ml_line_count;\n\ttowin->w_botfill = TRUE;\n    }\n    if (towin->w_topline < 1)\n    {\n\ttowin->w_topline = 1;\n\ttowin->w_topfill = 0;\n    }\n\n    // When w_topline changes need to recompute w_botline and cursor position\n    invalidate_botline_win(towin);\n    changed_line_abv_curs_win(towin);\n\n    check_topfill(towin, FALSE);\n#ifdef FEAT_FOLDING\n    (void)hasFoldingWin(towin, towin->w_topline, &towin->w_topline,\n\t\t\t\t\t\t\t    NULL, TRUE, NULL);\n#endif\n}\n\n/*\n * This is called when 'diffopt' is changed.\n */\n    int\ndiffopt_changed(void)\n{\n    char_u\t*p;\n    int\t\tdiff_context_new = 6;\n    int\t\tdiff_flags_new = 0;\n    int\t\tdiff_foldcolumn_new = 2;\n    long\tdiff_algorithm_new = 0;\n    long\tdiff_indent_heuristic = 0;\n    tabpage_T\t*tp;\n\n    p = p_dip;\n    while (*p != NUL)\n    {\n\tif (STRNCMP(p, \"filler\", 6) == 0)\n\t{\n\t    p += 6;\n\t    diff_flags_new |= DIFF_FILLER;\n\t}\n\telse if (STRNCMP(p, \"context:\", 8) == 0 && VIM_ISDIGIT(p[8]))\n\t{\n\t    p += 8;\n\t    diff_context_new = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"iblank\", 6) == 0)\n\t{\n\t    p += 6;\n\t    diff_flags_new |= DIFF_IBLANK;\n\t}\n\telse if (STRNCMP(p, \"icase\", 5) == 0)\n\t{\n\t    p += 5;\n\t    diff_flags_new |= DIFF_ICASE;\n\t}\n\telse if (STRNCMP(p, \"iwhiteall\", 9) == 0)\n\t{\n\t    p += 9;\n\t    diff_flags_new |= DIFF_IWHITEALL;\n\t}\n\telse if (STRNCMP(p, \"iwhiteeol\", 9) == 0)\n\t{\n\t    p += 9;\n\t    diff_flags_new |= DIFF_IWHITEEOL;\n\t}\n\telse if (STRNCMP(p, \"iwhite\", 6) == 0)\n\t{\n\t    p += 6;\n\t    diff_flags_new |= DIFF_IWHITE;\n\t}\n\telse if (STRNCMP(p, \"horizontal\", 10) == 0)\n\t{\n\t    p += 10;\n\t    diff_flags_new |= DIFF_HORIZONTAL;\n\t}\n\telse if (STRNCMP(p, \"vertical\", 8) == 0)\n\t{\n\t    p += 8;\n\t    diff_flags_new |= DIFF_VERTICAL;\n\t}\n\telse if (STRNCMP(p, \"foldcolumn:\", 11) == 0 && VIM_ISDIGIT(p[11]))\n\t{\n\t    p += 11;\n\t    diff_foldcolumn_new = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"hiddenoff\", 9) == 0)\n\t{\n\t    p += 9;\n\t    diff_flags_new |= DIFF_HIDDEN_OFF;\n\t}\n\telse if (STRNCMP(p, \"closeoff\", 8) == 0)\n\t{\n\t    p += 8;\n\t    diff_flags_new |= DIFF_CLOSE_OFF;\n\t}\n\telse if (STRNCMP(p, \"followwrap\", 10) == 0)\n\t{\n\t    p += 10;\n\t    diff_flags_new |= DIFF_FOLLOWWRAP;\n\t}\n\telse if (STRNCMP(p, \"indent-heuristic\", 16) == 0)\n\t{\n\t    p += 16;\n\t    diff_indent_heuristic = XDF_INDENT_HEURISTIC;\n\t}\n\telse if (STRNCMP(p, \"internal\", 8) == 0)\n\t{\n\t    p += 8;\n\t    diff_flags_new |= DIFF_INTERNAL;\n\t}\n\telse if (STRNCMP(p, \"algorithm:\", 10) == 0)\n\t{\n\t    p += 10;\n\t    if (STRNCMP(p, \"myers\", 5) == 0)\n\t    {\n\t\tp += 5;\n\t\tdiff_algorithm_new = 0;\n\t    }\n\t    else if (STRNCMP(p, \"minimal\", 7) == 0)\n\t    {\n\t\tp += 7;\n\t\tdiff_algorithm_new = XDF_NEED_MINIMAL;\n\t    }\n\t    else if (STRNCMP(p, \"patience\", 8) == 0)\n\t    {\n\t\tp += 8;\n\t\tdiff_algorithm_new = XDF_PATIENCE_DIFF;\n\t    }\n\t    else if (STRNCMP(p, \"histogram\", 9) == 0)\n\t    {\n\t\tp += 9;\n\t\tdiff_algorithm_new = XDF_HISTOGRAM_DIFF;\n\t    }\n\t    else\n\t\treturn FAIL;\n\t}\n\n\tif (*p != ',' && *p != NUL)\n\t    return FAIL;\n\tif (*p == ',')\n\t    ++p;\n    }\n\n    diff_algorithm_new |= diff_indent_heuristic;\n\n    // Can't have both \"horizontal\" and \"vertical\".\n    if ((diff_flags_new & DIFF_HORIZONTAL) && (diff_flags_new & DIFF_VERTICAL))\n\treturn FAIL;\n\n    // If flags were added or removed, or the algorithm was changed, need to\n    // update the diff.\n    if (diff_flags != diff_flags_new || diff_algorithm != diff_algorithm_new)\n\tFOR_ALL_TABPAGES(tp)\n\t    tp->tp_diff_invalid = TRUE;\n\n    diff_flags = diff_flags_new;\n    diff_context = diff_context_new == 0 ? 1 : diff_context_new;\n    diff_foldcolumn = diff_foldcolumn_new;\n    diff_algorithm = diff_algorithm_new;\n\n    diff_redraw(TRUE);\n\n    // recompute the scroll binding with the new option value, may\n    // remove or add filler lines\n    check_scrollbind((linenr_T)0, 0L);\n\n    return OK;\n}\n\n/*\n * Return TRUE if 'diffopt' contains \"horizontal\".\n */\n    int\ndiffopt_horizontal(void)\n{\n    return (diff_flags & DIFF_HORIZONTAL) != 0;\n}\n\n/*\n * Return TRUE if 'diffopt' contains \"hiddenoff\".\n */\n    int\ndiffopt_hiddenoff(void)\n{\n    return (diff_flags & DIFF_HIDDEN_OFF) != 0;\n}\n\n/*\n * Return TRUE if 'diffopt' contains \"closeoff\".\n */\n    int\ndiffopt_closeoff(void)\n{\n    return (diff_flags & DIFF_CLOSE_OFF) != 0;\n}\n\n/*\n * Find the difference within a changed line.\n * Returns TRUE if the line was added, no other buffer has it.\n */\n    int\ndiff_find_change(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    int\t\t*startp,\t// first char of the change\n    int\t\t*endp)\t\t// last char of the change\n{\n    char_u\t*line_org;\n    char_u\t*line_new;\n    int\t\ti;\n    int\t\tsi_org, si_new;\n    int\t\tei_org, ei_new;\n    diff_T\t*dp;\n    int\t\tidx;\n    int\t\toff;\n    int\t\tadded = TRUE;\n    char_u\t*p1, *p2;\n    int\t\tl;\n\n    // Make a copy of the line, the next ml_get() will invalidate it.\n    line_org = vim_strsave(ml_get_buf(wp->w_buffer, lnum, FALSE));\n    if (line_org == NULL)\n\treturn FALSE;\n\n    idx = diff_buf_idx(wp->w_buffer);\n    if (idx == DB_COUNT)\t// cannot happen\n    {\n\tvim_free(line_org);\n\treturn FALSE;\n    }\n\n    // search for a change that includes \"lnum\" in the list of diffblocks.\n    FOR_ALL_DIFFBLOCKS_IN_TAB(curtab, dp)\n\tif (lnum <= dp->df_lnum[idx] + dp->df_count[idx])\n\t    break;\n    if (dp == NULL || diff_check_sanity(curtab, dp) == FAIL)\n    {\n\tvim_free(line_org);\n\treturn FALSE;\n    }\n\n    off = lnum - dp->df_lnum[idx];\n\n    for (i = 0; i < DB_COUNT; ++i)\n\tif (curtab->tp_diffbuf[i] != NULL && i != idx)\n\t{\n\t    // Skip lines that are not in the other change (filler lines).\n\t    if (off >= dp->df_count[i])\n\t\tcontinue;\n\t    added = FALSE;\n\t    line_new = ml_get_buf(curtab->tp_diffbuf[i],\n\t\t\t\t\t\t dp->df_lnum[i] + off, FALSE);\n\n\t    // Search for start of difference\n\t    si_org = si_new = 0;\n\t    while (line_org[si_org] != NUL)\n\t    {\n\t\tif (((diff_flags & DIFF_IWHITE)\n\t\t\t    && VIM_ISWHITE(line_org[si_org])\n\t\t\t\t\t      && VIM_ISWHITE(line_new[si_new]))\n\t\t\t|| ((diff_flags & DIFF_IWHITEALL)\n\t\t\t    && (VIM_ISWHITE(line_org[si_org])\n\t\t\t\t\t    || VIM_ISWHITE(line_new[si_new]))))\n\t\t{\n\t\t    si_org = (int)(skipwhite(line_org + si_org) - line_org);\n\t\t    si_new = (int)(skipwhite(line_new + si_new) - line_new);\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (!diff_equal_char(line_org + si_org, line_new + si_new,\n\t\t\t\t\t\t\t\t\t   &l))\n\t\t\tbreak;\n\t\t    si_org += l;\n\t\t    si_new += l;\n\t\t}\n\t    }\n\t    if (has_mbyte)\n\t    {\n\t\t// Move back to first byte of character in both lines (may\n\t\t// have \"nn^\" in line_org and \"n^ in line_new).\n\t\tsi_org -= (*mb_head_off)(line_org, line_org + si_org);\n\t\tsi_new -= (*mb_head_off)(line_new, line_new + si_new);\n\t    }\n\t    if (*startp > si_org)\n\t\t*startp = si_org;\n\n\t    // Search for end of difference, if any.\n\t    if (line_org[si_org] != NUL || line_new[si_new] != NUL)\n\t    {\n\t\tei_org = (int)STRLEN(line_org);\n\t\tei_new = (int)STRLEN(line_new);\n\t\twhile (ei_org >= *startp && ei_new >= si_new\n\t\t\t\t\t\t&& ei_org >= 0 && ei_new >= 0)\n\t\t{\n\t\t    if (((diff_flags & DIFF_IWHITE)\n\t\t\t\t&& VIM_ISWHITE(line_org[ei_org])\n\t\t\t\t\t      && VIM_ISWHITE(line_new[ei_new]))\n\t\t\t    || ((diff_flags & DIFF_IWHITEALL)\n\t\t\t\t&& (VIM_ISWHITE(line_org[ei_org])\n\t\t\t\t\t    || VIM_ISWHITE(line_new[ei_new]))))\n\t\t    {\n\t\t\twhile (ei_org >= *startp\n\t\t\t\t\t     && VIM_ISWHITE(line_org[ei_org]))\n\t\t\t    --ei_org;\n\t\t\twhile (ei_new >= si_new\n\t\t\t\t\t     && VIM_ISWHITE(line_new[ei_new]))\n\t\t\t    --ei_new;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tp1 = line_org + ei_org;\n\t\t\tp2 = line_new + ei_new;\n\t\t\tp1 -= (*mb_head_off)(line_org, p1);\n\t\t\tp2 -= (*mb_head_off)(line_new, p2);\n\t\t\tif (!diff_equal_char(p1, p2, &l))\n\t\t\t    break;\n\t\t\tei_org -= l;\n\t\t\tei_new -= l;\n\t\t    }\n\t\t}\n\t\tif (*endp < ei_org)\n\t\t    *endp = ei_org;\n\t    }\n\t}\n\n    vim_free(line_org);\n    return added;\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Return TRUE if line \"lnum\" is not close to a diff block, this line should\n * be in a fold.\n * Return FALSE if there are no diff blocks at all in this window.\n */\n    int\ndiff_infold(win_T *wp, linenr_T lnum)\n{\n    int\t\ti;\n    int\t\tidx = -1;\n    int\t\tother = FALSE;\n    diff_T\t*dp;\n\n    // Return if 'diff' isn't set.\n    if (!wp->w_p_diff)\n\treturn FALSE;\n\n    for (i = 0; i < DB_COUNT; ++i)\n    {\n\tif (curtab->tp_diffbuf[i] == wp->w_buffer)\n\t    idx = i;\n\telse if (curtab->tp_diffbuf[i] != NULL)\n\t    other = TRUE;\n    }\n\n    // return here if there are no diffs in the window\n    if (idx == -1 || !other)\n\treturn FALSE;\n\n    if (curtab->tp_diff_invalid)\n\tex_diffupdate(NULL);\t\t// update after a big change\n\n    // Return if there are no diff blocks.  All lines will be folded.\n    if (curtab->tp_first_diff == NULL)\n\treturn TRUE;\n\n    FOR_ALL_DIFFBLOCKS_IN_TAB(curtab, dp)\n    {\n\t// If this change is below the line there can't be any further match.\n\tif (dp->df_lnum[idx] - diff_context > lnum)\n\t    break;\n\t// If this change ends before the line we have a match.\n\tif (dp->df_lnum[idx] + dp->df_count[idx] + diff_context > lnum)\n\t    return FALSE;\n    }\n    return TRUE;\n}\n#endif\n\n/*\n * \"dp\" and \"do\" commands.\n */\n    void\nnv_diffgetput(int put, long count)\n{\n    exarg_T\tea;\n    char_u\tbuf[30];\n\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf))\n    {\n\tvim_beep(BO_OPER);\n\treturn;\n    }\n#endif\n    if (count == 0)\n\tea.arg = (char_u *)\"\";\n    else\n    {\n\tvim_snprintf((char *)buf, 30, \"%ld\", count);\n\tea.arg = buf;\n    }\n    if (put)\n\tea.cmdidx = CMD_diffput;\n    else\n\tea.cmdidx = CMD_diffget;\n    ea.addr_count = 0;\n    ea.line1 = curwin->w_cursor.lnum;\n    ea.line2 = curwin->w_cursor.lnum;\n    ex_diffgetput(&ea);\n}\n\n/*\n * \":diffget\"\n * \":diffput\"\n */\n    void\nex_diffgetput(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tcount;\n    linenr_T\toff = 0;\n    diff_T\t*dp;\n    diff_T\t*dprev;\n    diff_T\t*dfree;\n    int\t\tidx_cur;\n    int\t\tidx_other;\n    int\t\tidx_from;\n    int\t\tidx_to;\n    int\t\ti;\n    int\t\tadded;\n    char_u\t*p;\n    aco_save_T\taco;\n    buf_T\t*buf;\n    int\t\tstart_skip, end_skip;\n    int\t\tnew_count;\n    int\t\tbuf_empty;\n    int\t\tfound_not_ma = FALSE;\n\n    // Find the current buffer in the list of diff buffers.\n    idx_cur = diff_buf_idx(curbuf);\n    if (idx_cur == DB_COUNT)\n    {\n\temsg(_(e_current_buffer_is_not_in_diff_mode));\n\treturn;\n    }\n\n    if (*eap->arg == NUL)\n    {\n\t// No argument: Find the other buffer in the list of diff buffers.\n\tfor (idx_other = 0; idx_other < DB_COUNT; ++idx_other)\n\t    if (curtab->tp_diffbuf[idx_other] != curbuf\n\t\t    && curtab->tp_diffbuf[idx_other] != NULL)\n\t    {\n\t\tif (eap->cmdidx != CMD_diffput\n\t\t\t\t     || curtab->tp_diffbuf[idx_other]->b_p_ma)\n\t\t    break;\n\t\tfound_not_ma = TRUE;\n\t    }\n\tif (idx_other == DB_COUNT)\n\t{\n\t    if (found_not_ma)\n\t\temsg(_(e_no_other_buffer_in_diff_mode_is_modifiable));\n\t    else\n\t\temsg(_(e_no_other_buffer_in_diff_mode));\n\t    return;\n\t}\n\n\t// Check that there isn't a third buffer in the list\n\tfor (i = idx_other + 1; i < DB_COUNT; ++i)\n\t    if (curtab->tp_diffbuf[i] != curbuf\n\t\t    && curtab->tp_diffbuf[i] != NULL\n\t\t    && (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma))\n\t    {\n\t\temsg(_(e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use));\n\t\treturn;\n\t    }\n    }\n    else\n    {\n\t// Buffer number or pattern given.  Ignore trailing white space.\n\tp = eap->arg + STRLEN(eap->arg);\n\twhile (p > eap->arg && VIM_ISWHITE(p[-1]))\n\t    --p;\n\tfor (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i)\n\t    ;\n\tif (eap->arg + i == p)\t    // digits only\n\t    i = atol((char *)eap->arg);\n\telse\n\t{\n\t    i = buflist_findpat(eap->arg, p, FALSE, TRUE, FALSE);\n\t    if (i < 0)\n\t\treturn;\t\t// error message already given\n\t}\n\tbuf = buflist_findnr(i);\n\tif (buf == NULL)\n\t{\n\t    semsg(_(e_cant_find_buffer_str), eap->arg);\n\t    return;\n\t}\n\tif (buf == curbuf)\n\t    return;\t\t// nothing to do\n\tidx_other = diff_buf_idx(buf);\n\tif (idx_other == DB_COUNT)\n\t{\n\t    semsg(_(e_buffer_str_is_not_in_diff_mode), eap->arg);\n\t    return;\n\t}\n    }\n\n    diff_busy = TRUE;\n\n    // When no range given include the line above or below the cursor.\n    if (eap->addr_count == 0)\n    {\n\t// Make it possible that \":diffget\" on the last line gets line below\n\t// the cursor line when there is no difference above the cursor.\n\tif (eap->cmdidx == CMD_diffget\n\t\t&& eap->line1 == curbuf->b_ml.ml_line_count\n\t\t&& diff_check(curwin, eap->line1) == 0\n\t\t&& (eap->line1 == 1 || diff_check(curwin, eap->line1 - 1) == 0))\n\t    ++eap->line2;\n\telse if (eap->line1 > 0)\n\t    --eap->line1;\n    }\n\n    if (eap->cmdidx == CMD_diffget)\n    {\n\tidx_from = idx_other;\n\tidx_to = idx_cur;\n    }\n    else\n    {\n\tidx_from = idx_cur;\n\tidx_to = idx_other;\n\t// Need to make the other buffer the current buffer to be able to make\n\t// changes in it.\n\t// set curwin/curbuf to buf and save a few things\n\taucmd_prepbuf(&aco, curtab->tp_diffbuf[idx_other]);\n    }\n\n    // May give the warning for a changed buffer here, which can trigger the\n    // FileChangedRO autocommand, which may do nasty things and mess\n    // everything up.\n    if (!curbuf->b_changed)\n    {\n\tchange_warning(0);\n\tif (diff_buf_idx(curbuf) != idx_to)\n\t{\n\t    emsg(_(e_buffer_changed_unexpectedly));\n\t    goto theend;\n\t}\n    }\n\n    dprev = NULL;\n    for (dp = curtab->tp_first_diff; dp != NULL; )\n    {\n\tif (dp->df_lnum[idx_cur] > eap->line2 + off)\n\t    break;\t// past the range that was specified\n\n\tdfree = NULL;\n\tlnum = dp->df_lnum[idx_to];\n\tcount = dp->df_count[idx_to];\n\tif (dp->df_lnum[idx_cur] + dp->df_count[idx_cur] > eap->line1 + off\n\t\t&& u_save(lnum - 1, lnum + count) != FAIL)\n\t{\n\t    // Inside the specified range and saving for undo worked.\n\t    start_skip = 0;\n\t    end_skip = 0;\n\t    if (eap->addr_count > 0)\n\t    {\n\t\t// A range was specified: check if lines need to be skipped.\n\t\tstart_skip = eap->line1 + off - dp->df_lnum[idx_cur];\n\t\tif (start_skip > 0)\n\t\t{\n\t\t    // range starts below start of current diff block\n\t\t    if (start_skip > count)\n\t\t    {\n\t\t\tlnum += count;\n\t\t\tcount = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tcount -= start_skip;\n\t\t\tlnum += start_skip;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    start_skip = 0;\n\n\t\tend_skip = dp->df_lnum[idx_cur] + dp->df_count[idx_cur] - 1\n\t\t\t\t\t\t\t - (eap->line2 + off);\n\t\tif (end_skip > 0)\n\t\t{\n\t\t    // range ends above end of current/from diff block\n\t\t    if (idx_cur == idx_from)\t// :diffput\n\t\t    {\n\t\t\ti = dp->df_count[idx_cur] - start_skip - end_skip;\n\t\t\tif (count > i)\n\t\t\t    count = i;\n\t\t    }\n\t\t    else\t\t\t// :diffget\n\t\t    {\n\t\t\tcount -= end_skip;\n\t\t\tend_skip = dp->df_count[idx_from] - start_skip - count;\n\t\t\tif (end_skip < 0)\n\t\t\t    end_skip = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    end_skip = 0;\n\t    }\n\n\t    buf_empty = BUFEMPTY();\n\t    added = 0;\n\t    for (i = 0; i < count; ++i)\n\t    {\n\t\t// remember deleting the last line of the buffer\n\t\tbuf_empty = curbuf->b_ml.ml_line_count == 1;\n\t\tml_delete(lnum);\n\t\t--added;\n\t    }\n\t    for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i)\n\t    {\n\t\tlinenr_T nr;\n\n\t\tnr = dp->df_lnum[idx_from] + start_skip + i;\n\t\tif (nr > curtab->tp_diffbuf[idx_from]->b_ml.ml_line_count)\n\t\t    break;\n\t\tp = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from],\n\t\t\t\t\t\t\t\t  nr, FALSE));\n\t\tif (p != NULL)\n\t\t{\n\t\t    ml_append(lnum + i - 1, p, 0, FALSE);\n\t\t    vim_free(p);\n\t\t    ++added;\n\t\t    if (buf_empty && curbuf->b_ml.ml_line_count == 2)\n\t\t    {\n\t\t\t// Added the first line into an empty buffer, need to\n\t\t\t// delete the dummy empty line.\n\t\t\tbuf_empty = FALSE;\n\t\t\tml_delete((linenr_T)2);\n\t\t    }\n\t\t}\n\t    }\n\t    new_count = dp->df_count[idx_to] + added;\n\t    dp->df_count[idx_to] = new_count;\n\n\t    if (start_skip == 0 && end_skip == 0)\n\t    {\n\t\t// Check if there are any other buffers and if the diff is\n\t\t// equal in them.\n\t\tfor (i = 0; i < DB_COUNT; ++i)\n\t\t    if (curtab->tp_diffbuf[i] != NULL && i != idx_from\n\t\t\t\t\t\t\t\t&& i != idx_to\n\t\t\t    && !diff_equal_entry(dp, idx_from, i))\n\t\t\tbreak;\n\t\tif (i == DB_COUNT)\n\t\t{\n\t\t    // delete the diff entry, the buffers are now equal here\n\t\t    dfree = dp;\n\t\t    dp = dp->df_next;\n\t\t    if (dprev == NULL)\n\t\t\tcurtab->tp_first_diff = dp;\n\t\t    else\n\t\t\tdprev->df_next = dp;\n\t\t}\n\t    }\n\n\t    // Adjust marks.  This will change the following entries!\n\t    if (added != 0)\n\t    {\n\t\tmark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added);\n\t\tif (curwin->w_cursor.lnum >= lnum)\n\t\t{\n\t\t    // Adjust the cursor position if it's in/after the changed\n\t\t    // lines.\n\t\t    if (curwin->w_cursor.lnum >= lnum + count)\n\t\t\tcurwin->w_cursor.lnum += added;\n\t\t    else if (added < 0)\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t}\n\t    }\n\t    changed_lines(lnum, 0, lnum + count, (long)added);\n\n\t    if (dfree != NULL)\n\t    {\n\t\t// Diff is deleted, update folds in other windows.\n#ifdef FEAT_FOLDING\n\t\tdiff_fold_update(dfree, idx_to);\n#endif\n\t\tvim_free(dfree);\n\t    }\n\t    else\n\t\t// mark_adjust() may have changed the count in a wrong way\n\t\tdp->df_count[idx_to] = new_count;\n\n\t    // When changing the current buffer, keep track of line numbers\n\t    if (idx_cur == idx_to)\n\t\toff += added;\n\t}\n\n\t// If before the range or not deleted, go to next diff.\n\tif (dfree == NULL)\n\t{\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t}\n    }\n\n    // restore curwin/curbuf and a few other things\n    if (eap->cmdidx != CMD_diffget)\n    {\n\t// Syncing undo only works for the current buffer, but we change\n\t// another buffer.  Sync undo if the command was typed.  This isn't\n\t// 100% right when \":diffput\" is used in a function or mapping.\n\tif (KeyTyped)\n\t    u_sync(FALSE);\n\taucmd_restbuf(&aco);\n    }\n\ntheend:\n    diff_busy = FALSE;\n    if (diff_need_update)\n\tex_diffupdate(NULL);\n\n    // Check that the cursor is on a valid character and update its\n    // position.  When there were filler lines the topline has become\n    // invalid.\n    check_cursor();\n    changed_line_abv_curs();\n\n    if (diff_need_update)\n\t// redraw already done by ex_diffupdate()\n\tdiff_need_update = FALSE;\n    else\n    {\n\t// Also need to redraw the other buffers.\n\tdiff_redraw(FALSE);\n\tapply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf);\n    }\n}\n\n#ifdef FEAT_FOLDING\n/*\n * Update folds for all diff buffers for entry \"dp\".\n * Skip buffer with index \"skip_idx\".\n * When there are no diffs, all folds are removed.\n */\n    static void\ndiff_fold_update(diff_T *dp, int skip_idx)\n{\n    int\t\ti;\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tfor (i = 0; i < DB_COUNT; ++i)\n\t    if (curtab->tp_diffbuf[i] == wp->w_buffer && i != skip_idx)\n\t\tfoldUpdate(wp, dp->df_lnum[i],\n\t\t\t\t\t    dp->df_lnum[i] + dp->df_count[i]);\n}\n#endif\n\n/*\n * Return TRUE if buffer \"buf\" is in diff-mode.\n */\n    int\ndiff_mode_buf(buf_T *buf)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (diff_buf_idx_tp(buf, tp) != DB_COUNT)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Move \"count\" times in direction \"dir\" to the next diff block.\n * Return FAIL if there isn't such a diff block.\n */\n    int\ndiff_move_to(int dir, long count)\n{\n    int\t\tidx;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    diff_T\t*dp;\n\n    idx = diff_buf_idx(curbuf);\n    if (idx == DB_COUNT || curtab->tp_first_diff == NULL)\n\treturn FAIL;\n\n    if (curtab->tp_diff_invalid)\n\tex_diffupdate(NULL);\t\t// update after a big change\n\n    if (curtab->tp_first_diff == NULL)\t\t// no diffs today\n\treturn FAIL;\n\n    while (--count >= 0)\n    {\n\t// Check if already before first diff.\n\tif (dir == BACKWARD && lnum <= curtab->tp_first_diff->df_lnum[idx])\n\t    break;\n\n\tfor (dp = curtab->tp_first_diff; ; dp = dp->df_next)\n\t{\n\t    if (dp == NULL)\n\t\tbreak;\n\t    if ((dir == FORWARD && lnum < dp->df_lnum[idx])\n\t\t    || (dir == BACKWARD\n\t\t\t&& (dp->df_next == NULL\n\t\t\t    || lnum <= dp->df_next->df_lnum[idx])))\n\t    {\n\t\tlnum = dp->df_lnum[idx];\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // don't end up past the end of the file\n    if (lnum > curbuf->b_ml.ml_line_count)\n\tlnum = curbuf->b_ml.ml_line_count;\n\n    // When the cursor didn't move at all we fail.\n    if (lnum == curwin->w_cursor.lnum)\n\treturn FAIL;\n\n    setpcmark();\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n\n    return OK;\n}\n\n/*\n * Return the line number in the current window that is closest to \"lnum1\" in\n * \"buf1\" in diff mode.\n */\n    static linenr_T\ndiff_get_corresponding_line_int(\n    buf_T\t*buf1,\n    linenr_T\tlnum1)\n{\n    int\t\tidx1;\n    int\t\tidx2;\n    diff_T\t*dp;\n    int\t\tbaseline = 0;\n\n    idx1 = diff_buf_idx(buf1);\n    idx2 = diff_buf_idx(curbuf);\n    if (idx1 == DB_COUNT || idx2 == DB_COUNT || curtab->tp_first_diff == NULL)\n\treturn lnum1;\n\n    if (curtab->tp_diff_invalid)\n\tex_diffupdate(NULL);\t\t// update after a big change\n\n    if (curtab->tp_first_diff == NULL)\t\t// no diffs today\n\treturn lnum1;\n\n    FOR_ALL_DIFFBLOCKS_IN_TAB(curtab, dp)\n    {\n\tif (dp->df_lnum[idx1] > lnum1)\n\t    return lnum1 - baseline;\n\tif ((dp->df_lnum[idx1] + dp->df_count[idx1]) > lnum1)\n\t{\n\t    // Inside the diffblock\n\t    baseline = lnum1 - dp->df_lnum[idx1];\n\t    if (baseline > dp->df_count[idx2])\n\t\tbaseline = dp->df_count[idx2];\n\n\t    return dp->df_lnum[idx2] + baseline;\n\t}\n\tif (    (dp->df_lnum[idx1] == lnum1)\n\t     && (dp->df_count[idx1] == 0)\n\t     && (dp->df_lnum[idx2] <= curwin->w_cursor.lnum)\n\t     && ((dp->df_lnum[idx2] + dp->df_count[idx2])\n\t\t\t\t\t\t      > curwin->w_cursor.lnum))\n\t    /*\n\t     * Special case: if the cursor is just after a zero-count\n\t     * block (i.e. all filler) and the target cursor is already\n\t     * inside the corresponding block, leave the target cursor\n\t     * unmoved. This makes repeated CTRL-W W operations work\n\t     * as expected.\n\t     */\n\t    return curwin->w_cursor.lnum;\n\tbaseline = (dp->df_lnum[idx1] + dp->df_count[idx1])\n\t\t\t\t   - (dp->df_lnum[idx2] + dp->df_count[idx2]);\n    }\n\n    // If we get here then the cursor is after the last diff\n    return lnum1 - baseline;\n}\n\n/*\n * Return the line number in the current window that is closest to \"lnum1\" in\n * \"buf1\" in diff mode.  Checks the line number to be valid.\n */\n    linenr_T\ndiff_get_corresponding_line(buf_T *buf1, linenr_T lnum1)\n{\n    linenr_T lnum = diff_get_corresponding_line_int(buf1, lnum1);\n\n    // don't end up past the end of the file\n    if (lnum > curbuf->b_ml.ml_line_count)\n\treturn curbuf->b_ml.ml_line_count;\n    return lnum;\n}\n\n/*\n * For line \"lnum\" in the current window find the equivalent lnum in window\n * \"wp\", compensating for inserted/deleted lines.\n */\n    linenr_T\ndiff_lnum_win(linenr_T lnum, win_T *wp)\n{\n    diff_T\t*dp;\n    int\t\tidx;\n    int\t\ti;\n    linenr_T\tn;\n\n    idx = diff_buf_idx(curbuf);\n    if (idx == DB_COUNT)\t\t// safety check\n\treturn (linenr_T)0;\n\n    if (curtab->tp_diff_invalid)\n\tex_diffupdate(NULL);\t\t// update after a big change\n\n    // search for a change that includes \"lnum\" in the list of diffblocks.\n    FOR_ALL_DIFFBLOCKS_IN_TAB(curtab, dp)\n\tif (lnum <= dp->df_lnum[idx] + dp->df_count[idx])\n\t    break;\n\n    // When after the last change, compute relative to the last line number.\n    if (dp == NULL)\n\treturn wp->w_buffer->b_ml.ml_line_count\n\t\t\t\t\t- (curbuf->b_ml.ml_line_count - lnum);\n\n    // Find index for \"wp\".\n    i = diff_buf_idx(wp->w_buffer);\n    if (i == DB_COUNT)\t\t\t// safety check\n\treturn (linenr_T)0;\n\n    n = lnum + (dp->df_lnum[i] - dp->df_lnum[idx]);\n    if (n > dp->df_lnum[i] + dp->df_count[i])\n\tn = dp->df_lnum[i] + dp->df_count[i];\n    return n;\n}\n\n/*\n * Handle an ED style diff line.\n * Return FAIL if the line does not contain diff info.\n */\n    static int\nparse_diff_ed(\n\tchar_u\t    *line,\n\tdiffhunk_T  *hunk)\n{\n    char_u *p;\n    long    f1, l1, f2, l2;\n    int\t    difftype;\n\n    // The line must be one of three formats:\n    // change: {first}[,{last}]c{first}[,{last}]\n    // append: {first}a{first}[,{last}]\n    // delete: {first}[,{last}]d{first}\n    p = line;\n    f1 = getdigits(&p);\n    if (*p == ',')\n    {\n\t++p;\n\tl1 = getdigits(&p);\n    }\n    else\n\tl1 = f1;\n    if (*p != 'a' && *p != 'c' && *p != 'd')\n\treturn FAIL;\t\t// invalid diff format\n    difftype = *p++;\n    f2 = getdigits(&p);\n    if (*p == ',')\n    {\n\t++p;\n\tl2 = getdigits(&p);\n    }\n    else\n\tl2 = f2;\n    if (l1 < f1 || l2 < f2)\n\treturn FAIL;\n\n    if (difftype == 'a')\n    {\n\thunk->lnum_orig = f1 + 1;\n\thunk->count_orig = 0;\n    }\n    else\n    {\n\thunk->lnum_orig = f1;\n\thunk->count_orig = l1 - f1 + 1;\n    }\n    if (difftype == 'd')\n    {\n\thunk->lnum_new = f2 + 1;\n\thunk->count_new = 0;\n    }\n    else\n    {\n\thunk->lnum_new = f2;\n\thunk->count_new = l2 - f2 + 1;\n    }\n    return OK;\n}\n\n/*\n * Parses unified diff with zero(!) context lines.\n * Return FAIL if there is no diff information in \"line\".\n */\n    static int\nparse_diff_unified(\n\tchar_u\t    *line,\n\tdiffhunk_T  *hunk)\n{\n    char_u *p;\n    long    oldline, oldcount, newline, newcount;\n\n    // Parse unified diff hunk header:\n    // @@ -oldline,oldcount +newline,newcount @@\n    p = line;\n    if (*p++ == '@' && *p++ == '@' && *p++ == ' ' && *p++ == '-')\n    {\n\toldline = getdigits(&p);\n\tif (*p == ',')\n\t{\n\t    ++p;\n\t    oldcount = getdigits(&p);\n\t}\n\telse\n\t    oldcount = 1;\n\tif (*p++ == ' ' && *p++ == '+')\n\t{\n\t    newline = getdigits(&p);\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\tnewcount = getdigits(&p);\n\t    }\n\t    else\n\t\tnewcount = 1;\n\t}\n\telse\n\t    return FAIL;\t// invalid diff format\n\n\tif (oldcount == 0)\n\t    oldline += 1;\n\tif (newcount == 0)\n\t    newline += 1;\n\tif (newline == 0)\n\t    newline = 1;\n\n\thunk->lnum_orig = oldline;\n\thunk->count_orig = oldcount;\n\thunk->lnum_new = newline;\n\thunk->count_new = newcount;\n\n\treturn OK;\n    }\n\n    return FAIL;\n}\n\n/*\n * Callback function for the xdl_diff() function.\n * Stores the diff output in a grow array.\n */\n    static int\nxdiff_out(\n\tlong start_a,\n\tlong count_a,\n\tlong start_b,\n\tlong count_b,\n\tvoid *priv)\n{\n    diffout_T\t*dout = (diffout_T *)priv;\n    diffhunk_T *p = ALLOC_ONE(diffhunk_T);\n\n    if (p == NULL)\n\treturn -1;\n\n    if (ga_grow(&dout->dout_ga, 1) == FAIL)\n    {\n\tvim_free(p);\n\treturn -1;\n    }\n\n    p->lnum_orig  = start_a + 1;\n    p->count_orig = count_a;\n    p->lnum_new   = start_b + 1;\n    p->count_new  = count_b;\n    ((diffhunk_T **)dout->dout_ga.ga_data)[dout->dout_ga.ga_len++] = p;\n    return 0;\n}\n\n#endif\t// FEAT_DIFF\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * \"diff_filler()\" function\n */\n    void\nf_diff_filler(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n#ifdef FEAT_DIFF\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = diff_check_fill(curwin, tv_get_lnum(argvars));\n#endif\n}\n\n/*\n * \"diff_hlID()\" function\n */\n    void\nf_diff_hlID(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n#ifdef FEAT_DIFF\n    linenr_T\t\tlnum;\n    static linenr_T\tprev_lnum = 0;\n    static varnumber_T\tchangedtick = 0;\n    static int\t\tfnum = 0;\n    static int\t\tchange_start = 0;\n    static int\t\tchange_end = 0;\n    static hlf_T\thlID = (hlf_T)0;\n    int\t\t\tfiller_lines;\n    int\t\t\tcol;\n\n    if (in_vim9script()\n\t    && (check_for_lnum_arg(argvars,0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    lnum = tv_get_lnum(argvars);\n    if (lnum < 0)\t// ignore type error in {lnum} arg\n\tlnum = 0;\n    if (lnum != prev_lnum\n\t    || changedtick != CHANGEDTICK(curbuf)\n\t    || fnum != curbuf->b_fnum)\n    {\n\t// New line, buffer, change: need to get the values.\n\tfiller_lines = diff_check(curwin, lnum);\n\tif (filler_lines < 0)\n\t{\n\t    if (filler_lines == -1)\n\t    {\n\t\tchange_start = MAXCOL;\n\t\tchange_end = -1;\n\t\tif (diff_find_change(curwin, lnum, &change_start, &change_end))\n\t\t    hlID = HLF_ADD;\t// added line\n\t\telse\n\t\t    hlID = HLF_CHD;\t// changed line\n\t    }\n\t    else\n\t\thlID = HLF_ADD;\t// added line\n\t}\n\telse\n\t    hlID = (hlf_T)0;\n\tprev_lnum = lnum;\n\tchangedtick = CHANGEDTICK(curbuf);\n\tfnum = curbuf->b_fnum;\n    }\n\n    if (hlID == HLF_CHD || hlID == HLF_TXD)\n    {\n\tcol = tv_get_number(&argvars[1]) - 1; // ignore type error in {col}\n\tif (col >= change_start && col <= change_end)\n\t    hlID = HLF_TXD;\t\t\t// changed text\n\telse\n\t    hlID = HLF_CHD;\t\t\t// changed line\n    }\n    rettv->vval.v_number = hlID == (hlf_T)0 ? 0 : (int)hlID;\n#endif\n}\n\n#endif\n", "\" Tests for diff mode\n\nsource shared.vim\nsource screendump.vim\nsource check.vim\n\nfunc Test_diff_fold_sync()\n  enew!\n  let g:update_count = 0\n  au DiffUpdated * let g:update_count += 1\n\n  let l = range(50)\n  call setline(1, l)\n  diffthis\n  let winone = win_getid()\n  new\n  let l[25] = 'diff'\n  call setline(1, l)\n  diffthis\n  let wintwo = win_getid()\n  \" line 15 is inside the closed fold\n  call assert_equal(19, foldclosedend(10))\n  call win_gotoid(winone)\n  call assert_equal(19, foldclosedend(10))\n  \" open the fold\n  normal zv\n  call assert_equal(-1, foldclosedend(10))\n  \" fold in other window must have opened too\n  call win_gotoid(wintwo)\n  call assert_equal(-1, foldclosedend(10))\n\n  \" cursor position is in sync\n  normal 23G\n  call win_gotoid(winone)\n  call assert_equal(23, getcurpos()[1])\n\n  call assert_equal(1, g:update_count)\n  au! DiffUpdated\n\n  windo diffoff\n  close!\n  set nomodified\nendfunc\n\nfunc Test_vert_split()\n  set diffopt=filler\n  call Common_vert_split()\n  set diffopt&\nendfunc\n\nfunc Test_vert_split_internal()\n  set diffopt=internal,filler\n  call Common_vert_split()\n  set diffopt&\nendfunc\n\nfunc Common_vert_split()\n  \" Disable the title to avoid xterm keeping the wrong one.\n  set notitle noicon\n  new\n  let l = ['1 aa', '2 bb', '3 cc', '4 dd', '5 ee']\n  call setline(1, l)\n  w! Xtest\n  normal dd\n  $\n  put\n  normal kkrXoxxx\u001b\n  w! Xtest2\n  file Nop\n  normal ggoyyy\u001bjjjozzzz\u001b\n  set foldmethod=marker foldcolumn=4\n  call assert_equal(0, &diff)\n  call assert_equal('marker', &foldmethod)\n  call assert_equal(4, &foldcolumn)\n  call assert_equal(0, &scrollbind)\n  call assert_equal(0, &cursorbind)\n  call assert_equal(1, &wrap)\n\n  vert diffsplit Xtest\n  vert diffsplit Xtest2\n  call assert_equal(1, &diff)\n  call assert_equal('diff', &foldmethod)\n  call assert_equal(2, &foldcolumn)\n  call assert_equal(1, &scrollbind)\n  call assert_equal(1, &cursorbind)\n  call assert_equal(0, &wrap)\n\n  let diff_fdm = &fdm\n  let diff_fdc = &fdc\n  \" repeat entering diff mode here to see if this saves the wrong settings\n  diffthis\n  \" jump to second window for a moment to have filler line appear at start of\n  \" first window\n  wincmd w\n  normal gg\n  wincmd p\n  normal gg\n  call assert_equal(2, winline())\n  normal j\n  call assert_equal(4, winline())\n  normal j\n  call assert_equal(5, winline())\n  normal j\n  call assert_equal(6, winline())\n  normal j\n  call assert_equal(8, winline())\n  normal j\n  call assert_equal(9, winline())\n\n  wincmd w\n  normal gg\n  call assert_equal(1, winline())\n  normal j\n  call assert_equal(2, winline())\n  normal j\n  call assert_equal(4, winline())\n  normal j\n  call assert_equal(5, winline())\n  normal j\n  call assert_equal(8, winline())\n\n  wincmd w\n  normal gg\n  call assert_equal(2, winline())\n  normal j\n  call assert_equal(3, winline())\n  normal j\n  call assert_equal(4, winline())\n  normal j\n  call assert_equal(5, winline())\n  normal j\n  call assert_equal(6, winline())\n  normal j\n  call assert_equal(7, winline())\n  normal j\n  call assert_equal(8, winline())\n\n  \" Test diffoff\n  diffoff!\n  1wincmd 2\n  let &diff = 1\n  let &fdm = diff_fdm\n  let &fdc = diff_fdc\n  4wincmd w\n  diffoff!\n  1wincmd w\n  call assert_equal(0, &diff)\n  call assert_equal('marker', &foldmethod)\n  call assert_equal(4, &foldcolumn)\n  call assert_equal(0, &scrollbind)\n  call assert_equal(0, &cursorbind)\n  call assert_equal(1, &wrap)\n\n  wincmd w\n  call assert_equal(0, &diff)\n  call assert_equal('marker', &foldmethod)\n  call assert_equal(4, &foldcolumn)\n  call assert_equal(0, &scrollbind)\n  call assert_equal(0, &cursorbind)\n  call assert_equal(1, &wrap)\n\n  wincmd w\n  call assert_equal(0, &diff)\n  call assert_equal('marker', &foldmethod)\n  call assert_equal(4, &foldcolumn)\n  call assert_equal(0, &scrollbind)\n  call assert_equal(0, &cursorbind)\n  call assert_equal(1, &wrap)\n\n  call delete('Xtest')\n  call delete('Xtest2')\n  windo bw!\nendfunc\n\nfunc Test_filler_lines()\n  \" Test that diffing shows correct filler lines\n  enew!\n  put =range(4,10)\n  1d _\n  vnew\n  put =range(1,10)\n  1d _\n  windo diffthis\n  wincmd h\n  call assert_equal(1, line('w0'))\n  unlet! diff_fdm diff_fdc\n  windo diffoff\n  bwipe!\n  enew!\nendfunc\n\nfunc Test_diffget_diffput()\n  enew!\n  let l = range(50)\n  call setline(1, l)\n  call assert_fails('diffget', 'E99:')\n  diffthis\n  call assert_fails('diffget', 'E100:')\n  new\n  let l[10] = 'one'\n  let l[20] = 'two'\n  let l[30] = 'three'\n  let l[40] = 'four'\n  call setline(1, l)\n  diffthis\n  call assert_equal('one', getline(11))\n  11diffget\n  call assert_equal('10', getline(11))\n  21diffput\n  wincmd w\n  call assert_equal('two', getline(21))\n  normal 31Gdo\n  call assert_equal('three', getline(31))\n  call assert_equal('40', getline(41))\n  normal 41Gdp\n  wincmd w\n  call assert_equal('40', getline(41))\n  new\n  diffthis\n  call assert_fails('diffget', 'E101:')\n\n  windo diffoff\n  %bwipe!\nendfunc\n\n\" Test putting two changes from one buffer to another\nfunc Test_diffput_two()\n  new a\n  let win_a = win_getid()\n  call setline(1, range(1, 10))\n  diffthis\n  new b\n  let win_b = win_getid()\n  call setline(1, range(1, 10))\n  8del\n  5del\n  diffthis\n  call win_gotoid(win_a)\n  %diffput\n  call win_gotoid(win_b)\n  call assert_equal(map(range(1, 10), 'string(v:val)'), getline(1, '$'))\n  bwipe! a\n  bwipe! b\nendfunc\n\n\" Test for :diffget/:diffput with a range that is inside a diff chunk\nfunc Test_diffget_diffput_range()\n  call setline(1, range(1, 10))\n  new\n  call setline(1, range(11, 20))\n  windo diffthis\n  3,5diffget\n  call assert_equal(['13', '14', '15'], getline(3, 5))\n  call setline(1, range(1, 10))\n  4,8diffput\n  wincmd p\n  call assert_equal(['13', '4', '5', '6', '7', '8', '19'], getline(3, 9))\n  %bw!\nendfunc\n\n\" Test for :diffget/:diffput with an empty buffer and a non-empty buffer\nfunc Test_diffget_diffput_empty_buffer()\n  %d _\n  new\n  call setline(1, 'one')\n  windo diffthis\n  diffget\n  call assert_equal(['one'], getline(1, '$'))\n  %d _\n  diffput\n  wincmd p\n  call assert_equal([''], getline(1, '$'))\n  %bw!\nendfunc\n\n\" :diffput and :diffget completes names of buffers which\n\" are in diff mode and which are different than current buffer.\n\" No completion when the current window is not in diff mode.\nfunc Test_diffget_diffput_completion()\n  e            Xdiff1 | diffthis\n  botright new Xdiff2\n  botright new Xdiff3 | split | diffthis\n  botright new Xdiff4 | diffthis\n\n  wincmd t\n  call assert_equal('Xdiff1', bufname('%'))\n  call feedkeys(\":diffput \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput Xdiff3 Xdiff4', @:)\n  call feedkeys(\":diffget \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget Xdiff3 Xdiff4', @:)\n  call assert_equal(['Xdiff3', 'Xdiff4'], getcompletion('', 'diff_buffer'))\n\n  \" Xdiff2 is not in diff mode, so no completion for :diffput, :diffget\n  wincmd j\n  call assert_equal('Xdiff2', bufname('%'))\n  call feedkeys(\":diffput \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput ', @:)\n  call feedkeys(\":diffget \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget ', @:)\n  call assert_equal([], getcompletion('', 'diff_buffer'))\n\n  \" Xdiff3 is split in 2 windows, only the top one is in diff mode.\n  \" So completion of :diffput :diffget only happens in the top window.\n  wincmd j\n  call assert_equal('Xdiff3', bufname('%'))\n  call assert_equal(1, &diff)\n  call feedkeys(\":diffput \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput Xdiff1 Xdiff4', @:)\n  call feedkeys(\":diffget \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget Xdiff1 Xdiff4', @:)\n  call assert_equal(['Xdiff1', 'Xdiff4'], getcompletion('', 'diff_buffer'))\n\n  wincmd j\n  call assert_equal('Xdiff3', bufname('%'))\n  call assert_equal(0, &diff)\n  call feedkeys(\":diffput \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput ', @:)\n  call feedkeys(\":diffget \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget ', @:)\n  call assert_equal([], getcompletion('', 'diff_buffer'))\n\n  wincmd j\n  call assert_equal('Xdiff4', bufname('%'))\n  call feedkeys(\":diffput \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput Xdiff1 Xdiff3', @:)\n  call feedkeys(\":diffget \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget Xdiff1 Xdiff3', @:)\n  call assert_equal(['Xdiff1', 'Xdiff3'], getcompletion('', 'diff_buffer'))\n\n  %bwipe\nendfunc\n\nfunc Test_dp_do_buffer()\n  e! one\n  let bn1=bufnr('%')\n  let l = range(60)\n  call setline(1, l)\n  diffthis\n\n  new two\n  let l[10] = 'one'\n  let l[20] = 'two'\n  let l[30] = 'three'\n  let l[40] = 'four'\n  let l[50] = 'five'\n  call setline(1, l)\n  diffthis\n\n  \" dp and do with invalid buffer number.\n  11\n  call assert_fails('norm 99999dp', 'E102:')\n  call assert_fails('norm 99999do', 'E102:')\n  call assert_fails('diffput non_existing_buffer', 'E94:')\n  call assert_fails('diffget non_existing_buffer', 'E94:')\n\n  \" dp and do with valid buffer number.\n  call assert_equal('one', getline('.'))\n  exe 'norm ' . bn1 . 'do'\n  call assert_equal('10', getline('.'))\n  21\n  call assert_equal('two', getline('.'))\n  diffget one \n  call assert_equal('20', getline('.'))\n\n  31\n  exe 'norm ' . bn1 . 'dp'\n  41\n  diffput one\n  wincmd w\n  31\n  call assert_equal('three', getline('.'))\n  41\n  call assert_equal('four', getline('.'))\n\n  \" dp and do with buffer number which is not in diff mode.\n  new not_in_diff_mode\n  let bn3=bufnr('%')\n  wincmd w\n  51\n  call assert_fails('exe \"norm\" . bn3 . \"dp\"', 'E103:')\n  call assert_fails('exe \"norm\" . bn3 . \"do\"', 'E103:')\n  call assert_fails('diffput not_in_diff_mode', 'E94:')\n  call assert_fails('diffget not_in_diff_mode', 'E94:')\n\n  windo diffoff\n  %bwipe!\nendfunc\n\nfunc Test_do_lastline()\n  e! one\n  call setline(1, ['1','2','3','4','5','6'])\n  diffthis\n\n  new two\n  call setline(1, ['2','4','5'])\n  diffthis\n\n  1\n  norm dp]c\n  norm dp]c\n  wincmd w\n  call assert_equal(4, line('$'))\n  norm G\n  norm do\n  call assert_equal(3, line('$'))\n\n  windo diffoff\n  %bwipe!\nendfunc\n\nfunc Test_diffoff()\n  enew!\n  call setline(1, ['Two', 'Three'])\n  redraw\n  let normattr = screenattr(1, 1)\n  diffthis\n  botright vert new\n  call setline(1, ['One', '', 'Two', 'Three'])\n  diffthis\n  redraw\n  call assert_notequal(normattr, 1->screenattr(1))\n  diffoff!\n  redraw\n  call assert_equal(normattr, screenattr(1, 1))\n  bwipe!\n  bwipe!\nendfunc\n\nfunc Common_icase_test()\n  edit one\n  call setline(1, ['One', 'Two', 'Three', 'Four', 'Fi#ve'])\n  redraw\n  let normattr = screenattr(1, 1)\n  diffthis\n\n  botright vert new two\n  call setline(1, ['one', 'TWO', 'Three ', 'Four', 'fI=VE'])\n  diffthis\n\n  redraw\n  call assert_equal(normattr, screenattr(1, 1))\n  call assert_equal(normattr, screenattr(2, 1))\n  call assert_notequal(normattr, screenattr(3, 1))\n  call assert_equal(normattr, screenattr(4, 1))\n\n  let dtextattr = screenattr(5, 3)\n  call assert_notequal(dtextattr, screenattr(5, 1))\n  call assert_notequal(dtextattr, screenattr(5, 5))\n\n  diffoff!\n  %bwipe!\nendfunc\n\nfunc Test_diffopt_icase()\n  set diffopt=icase,foldcolumn:0\n  call Common_icase_test()\n  set diffopt&\nendfunc\n\nfunc Test_diffopt_icase_internal()\n  set diffopt=icase,foldcolumn:0,internal\n  call Common_icase_test()\n  set diffopt&\nendfunc\n\nfunc Common_iwhite_test()\n  edit one\n  \" Difference in trailing spaces and amount of spaces should be ignored,\n  \" but not other space differences.\n  call setline(1, [\"One \\t\", 'Two', 'Three', 'one two', 'one two', 'Four'])\n  redraw\n  let normattr = screenattr(1, 1)\n  diffthis\n\n  botright vert new two\n  call setline(1, [\"One\\t \", \"Two\\t \", 'Three', 'one   two', 'onetwo', ' Four'])\n  diffthis\n\n  redraw\n  call assert_equal(normattr, screenattr(1, 1))\n  call assert_equal(normattr, screenattr(2, 1))\n  call assert_equal(normattr, screenattr(3, 1))\n  call assert_equal(normattr, screenattr(4, 1))\n  call assert_notequal(normattr, screenattr(5, 1))\n  call assert_notequal(normattr, screenattr(6, 1))\n\n  diffoff!\n  %bwipe!\nendfunc\n\nfunc Test_diffopt_iwhite()\n  set diffopt=iwhite,foldcolumn:0\n  call Common_iwhite_test()\n  set diffopt&\nendfunc\n\nfunc Test_diffopt_iwhite_internal()\n  set diffopt=internal,iwhite,foldcolumn:0\n  call Common_iwhite_test()\n  set diffopt&\nendfunc\n\nfunc Test_diffopt_context()\n  enew!\n  call setline(1, ['1', '2', '3', '4', '5', '6', '7'])\n  diffthis\n  new\n  call setline(1, ['1', '2', '3', '4', '5x', '6', '7'])\n  diffthis\n\n  set diffopt=context:2\n  call assert_equal('+--  2 lines: 1', foldtextresult(1))\n  set diffopt=internal,context:2\n  call assert_equal('+--  2 lines: 1', foldtextresult(1))\n\n  set diffopt=context:1\n  call assert_equal('+--  3 lines: 1', foldtextresult(1))\n  set diffopt=internal,context:1\n  call assert_equal('+--  3 lines: 1', foldtextresult(1))\n\n  diffoff!\n  %bwipe!\n  set diffopt&\nendfunc\n\nfunc Test_diffopt_horizontal()\n  set diffopt=internal,horizontal\n  diffsplit\n\n  call assert_equal(&columns, winwidth(1))\n  call assert_equal(&columns, winwidth(2))\n  call assert_equal(&lines, winheight(1) + winheight(2) + 3)\n  call assert_inrange(0, 1, winheight(1) - winheight(2))\n\n  set diffopt&\n  diffoff!\n  %bwipe\nendfunc\n\nfunc Test_diffopt_vertical()\n  set diffopt=internal,vertical\n  diffsplit\n\n  call assert_equal(&lines - 2, winheight(1))\n  call assert_equal(&lines - 2, winheight(2))\n  call assert_equal(&columns, winwidth(1) + winwidth(2) + 1)\n  call assert_inrange(0, 1, winwidth(1) - winwidth(2))\n\n  set diffopt&\n  diffoff!\n  %bwipe\nendfunc\n\nfunc Test_diffopt_hiddenoff()\n  set diffopt=internal,filler,foldcolumn:0,hiddenoff\n  e! one\n  call setline(1, ['Two', 'Three'])\n  redraw\n  let normattr = screenattr(1, 1)\n  diffthis\n  botright vert new two\n  call setline(1, ['One', 'Four'])\n  diffthis\n  redraw\n  call assert_notequal(normattr, screenattr(1, 1))\n  set hidden\n  close\n  redraw\n  \" should not diffing with hidden buffer two while 'hiddenoff' is enabled\n  call assert_equal(normattr, screenattr(1, 1))\n\n  bwipe!\n  bwipe!\n  set hidden& diffopt&\nendfunc\n\nfunc Test_diffoff_hidden()\n  set diffopt=internal,filler,foldcolumn:0\n  e! one\n  call setline(1, ['Two', 'Three'])\n  redraw\n  let normattr = screenattr(1, 1)\n  diffthis\n  botright vert new two\n  call setline(1, ['One', 'Four'])\n  diffthis\n  redraw\n  call assert_notequal(normattr, screenattr(1, 1))\n  set hidden\n  close\n  redraw\n  \" diffing with hidden buffer two\n  call assert_notequal(normattr, screenattr(1, 1))\n  diffoff\n  redraw\n  call assert_equal(normattr, screenattr(1, 1))\n  diffthis\n  redraw\n  \" still diffing with hidden buffer two\n  call assert_notequal(normattr, screenattr(1, 1))\n  diffoff!\n  redraw\n  call assert_equal(normattr, screenattr(1, 1))\n  diffthis\n  redraw\n  \" no longer diffing with hidden buffer two\n  call assert_equal(normattr, screenattr(1, 1))\n\n  bwipe!\n  bwipe!\n  set hidden& diffopt&\nendfunc\n\nfunc Test_setting_cursor()\n  new Xtest1\n  put =range(1,90)\n  wq\n  new Xtest2\n  put =range(1,100)\n  wq\n\n  tabe Xtest2\n  $\n  diffsp Xtest1\n  tabclose\n\n  call delete('Xtest1')\n  call delete('Xtest2')\nendfunc\n\nfunc Test_diff_move_to()\n  new\n  call setline(1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  diffthis\n  vnew\n  call setline(1, [1, '2x', 3, 4, 4, 5, '6x', 7, '8x', 9, '10x'])\n  diffthis\n  norm ]c\n  call assert_equal(2, line('.'))\n  norm 3]c\n  call assert_equal(9, line('.'))\n  norm 10]c\n  call assert_equal(11, line('.'))\n  norm [c\n  call assert_equal(9, line('.'))\n  norm 2[c\n  call assert_equal(5, line('.'))\n  norm 10[c\n  call assert_equal(2, line('.'))\n  %bwipe!\nendfunc\n\nfunc Test_diffexpr()\n  CheckExecutable diff\n\n  func DiffExpr()\n    \" Prepend some text to check diff type detection\n    call writefile(['warning', '  message'], v:fname_out)\n    silent exe '!diff ' . v:fname_in . ' ' . v:fname_new . '>>' . v:fname_out\n  endfunc\n  set diffexpr=DiffExpr()\n  set diffopt=foldcolumn:0\n\n  enew!\n  call setline(1, ['one', 'two', 'three'])\n  redraw\n  let normattr = screenattr(1, 1)\n  diffthis\n\n  botright vert new\n  call setline(1, ['one', 'two', 'three.'])\n  diffthis\n\n  redraw\n  call assert_equal(normattr, screenattr(1, 1))\n  call assert_equal(normattr, screenattr(2, 1))\n  call assert_notequal(normattr, screenattr(3, 1))\n  diffoff!\n\n  \" Try using a non-existing function for 'diffexpr'.\n  set diffexpr=NewDiffFunc()\n  call assert_fails('windo diffthis', ['E117:', 'E97:'])\n  diffoff!\n\n  \" Using a script-local function\n  func s:NewDiffExpr()\n  endfunc\n  set diffexpr=s:NewDiffExpr()\n  call assert_equal(expand('<SID>') .. 'NewDiffExpr()', &diffexpr)\n  set diffexpr=<SID>NewDiffExpr()\n  call assert_equal(expand('<SID>') .. 'NewDiffExpr()', &diffexpr)\n\n  %bwipe!\n  set diffexpr& diffopt&\n  delfunc DiffExpr\n  delfunc s:NewDiffExpr\nendfunc\n\nfunc Test_diffpatch()\n  \" The patch program on MS-Windows may fail or hang.\n  CheckExecutable patch\n  CheckUnix\n  new\n  insert\n***************\n*** 1,3 ****\n  1\n! 2\n  3\n--- 1,4 ----\n  1\n! 2x\n  3\n+ 4\n.\n  saveas! Xpatch\n  bwipe!\n  new\n  call assert_fails('diffpatch Xpatch', 'E816:')\n\n  for name in ['Xpatch', 'Xpatch$HOME', 'Xpa''tch']\n    call setline(1, ['1', '2', '3'])\n    if name != 'Xpatch'\n      call rename('Xpatch', name)\n    endif\n    exe 'diffpatch ' . escape(name, '$')\n    call assert_equal(['1', '2x', '3', '4'], getline(1, '$'))\n    if name != 'Xpatch'\n      call rename(name, 'Xpatch')\n    endif\n    bwipe!\n  endfor\n\n  call delete('Xpatch')\n  bwipe!\nendfunc\n\nfunc Test_diff_too_many_buffers()\n  for i in range(1, 8)\n    exe \"new Xtest\" . i\n    diffthis\n  endfor\n  new Xtest9\n  call assert_fails('diffthis', 'E96:')\n  %bwipe!\nendfunc\n\nfunc Test_diff_nomodifiable()\n  new\n  call setline(1, [1, 2, 3, 4])\n  setl nomodifiable\n  diffthis\n  vnew\n  call setline(1, ['1x', 2, 3, 3, 4])\n  diffthis\n  call assert_fails('norm dp', 'E793:')\n  setl nomodifiable\n  call assert_fails('norm do', 'E21:')\n  %bwipe!\nendfunc\n\nfunc Test_diff_hlID()\n  new\n  call setline(1, [1, 2, 3])\n  diffthis\n  vnew\n  call setline(1, ['1x', 2, 'x', 3])\n  diffthis\n  redraw\n\n  call diff_hlID(-1, 1)->synIDattr(\"name\")->assert_equal(\"\")\n\n  call diff_hlID(1, 1)->synIDattr(\"name\")->assert_equal(\"DiffChange\")\n  call diff_hlID(1, 2)->synIDattr(\"name\")->assert_equal(\"DiffText\")\n  call diff_hlID(2, 1)->synIDattr(\"name\")->assert_equal(\"\")\n  call diff_hlID(3, 1)->synIDattr(\"name\")->assert_equal(\"DiffAdd\")\n  eval 4->diff_hlID(1)->synIDattr(\"name\")->assert_equal(\"\")\n\n  wincmd w\n  call assert_equal(synIDattr(diff_hlID(1, 1), \"name\"), \"DiffChange\")\n  call assert_equal(synIDattr(diff_hlID(2, 1), \"name\"), \"\")\n  call assert_equal(synIDattr(diff_hlID(3, 1), \"name\"), \"\")\n\n  %bwipe!\nendfunc\n\nfunc Test_diff_filler()\n  new\n  call setline(1, [1, 2, 3, 'x', 4])\n  diffthis\n  vnew\n  call setline(1, [1, 2, 'y', 'y', 3, 4])\n  diffthis\n  redraw\n\n  call assert_equal([0, 0, 0, 0, 0, 0, 0, 1, 0], map(range(-1, 7), 'v:val->diff_filler()'))\n  wincmd w\n  call assert_equal([0, 0, 0, 0, 2, 0, 0, 0], map(range(-1, 6), 'diff_filler(v:val)'))\n\n  %bwipe!\nendfunc\n\nfunc Test_diff_lastline()\n  enew!\n  only!\n  call setline(1, ['This is a ', 'line with five ', 'rows'])\n  diffthis\n  botright vert new\n  call setline(1, ['This is', 'a line with ', 'four rows'])\n  diffthis\n  1\n  call feedkeys(\"Je a\\<CR>\", 'tx')\n  call feedkeys(\"Je a\\<CR>\", 'tx')\n  let w1lines = winline()\n  wincmd w\n  $\n  let w2lines = winline()\n  call assert_equal(w2lines, w1lines)\n  bwipe!\n  bwipe!\nendfunc\n\nfunc WriteDiffFiles(buf, list1, list2)\n  call writefile(a:list1, 'Xfile1')\n  call writefile(a:list2, 'Xfile2')\n  if a:buf\n    call term_sendkeys(a:buf, \":checktime\\<CR>\")\n  endif\nendfunc\n\n\" Verify a screendump with both the internal and external diff.\nfunc VerifyBoth(buf, dumpfile, extra)\n  \" trailing : for leaving the cursor on the command line\n  for cmd in [\":set diffopt=filler\" . a:extra . \"\\<CR>:\", \":set diffopt+=internal\\<CR>:\"]\n    call term_sendkeys(a:buf, cmd)\n    if VerifyScreenDump(a:buf, a:dumpfile, {}, cmd =~ 'internal' ? 'internal' : 'external')\n      \" don't let the next iteration overwrite the \"failed\" file.\n      return\n    endif\n  endfor\n\n  \" also test unified diff\n  call term_sendkeys(a:buf, \":call SetupUnified()\\<CR>:\")\n  call term_sendkeys(a:buf, \":redraw!\\<CR>:\")\n  call VerifyScreenDump(a:buf, a:dumpfile, {}, 'unified')\n  call term_sendkeys(a:buf, \":call StopUnified()\\<CR>:\")\nendfunc\n\n\" Verify a screendump with the internal diff only.\nfunc VerifyInternal(buf, dumpfile, extra)\n  call term_sendkeys(a:buf, \":diffupdate!\\<CR>\")\n  \" trailing : for leaving the cursor on the command line\n  call term_sendkeys(a:buf, \":set diffopt=internal,filler\" . a:extra . \"\\<CR>:\")\n  call VerifyScreenDump(a:buf, a:dumpfile, {})\nendfunc\n\nfunc Test_diff_screen()\n  let g:test_is_flaky = 1\n  CheckScreendump\n  CheckFeature menu\n\n  let lines =<< trim END\n      func UnifiedDiffExpr()\n        \" Prepend some text to check diff type detection\n        call writefile(['warning', '  message'], v:fname_out)\n        silent exe '!diff -U0 ' .. v:fname_in .. ' ' .. v:fname_new .. '>>' .. v:fname_out\n      endfunc\n      func SetupUnified()\n        set diffexpr=UnifiedDiffExpr()\n        diffupdate\n      endfunc\n      func StopUnified()\n        set diffexpr=\n      endfunc\n  END\n  call writefile(lines, 'XdiffSetup')\n\n  \" clean up already existing swap files, just in case\n  call delete('.Xfile1.swp')\n  call delete('.Xfile2.swp')\n\n  \" Test 1: Add a line in beginning of file 2\n  call WriteDiffFiles(0, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  let buf = RunVimInTerminal('-d -S XdiffSetup Xfile1 Xfile2', {})\n  \" Set autoread mode, so that Vim won't complain once we re-write the test\n  \" files\n  call term_sendkeys(buf, \":set autoread\\<CR>\\<c-w>w:set autoread\\<CR>\\<c-w>w\")\n\n  call VerifyBoth(buf, 'Test_diff_01', '')\n\n  \" Test 2: Add a line in beginning of file 1\n  call WriteDiffFiles(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  call VerifyBoth(buf, 'Test_diff_02', '')\n\n  \" Test 3: Add a line at the end of file 2\n  call WriteDiffFiles(buf, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  call VerifyBoth(buf, 'Test_diff_03', '')\n\n  \" Test 4: Add a line at the end of file 1\n  call WriteDiffFiles(buf, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  call VerifyBoth(buf, 'Test_diff_04', '')\n\n  \" Test 5: Add a line in the middle of file 2, remove on at the end of file 1\n  call WriteDiffFiles(buf, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10])\n  call VerifyBoth(buf, 'Test_diff_05', '')\n\n  \" Test 6: Add a line in the middle of file 1, remove on at the end of file 2\n  call WriteDiffFiles(buf, [1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  call VerifyBoth(buf, 'Test_diff_06', '')\n\n  \" Variants on test 6 with different context settings\n  call term_sendkeys(buf, \":set diffopt+=context:2\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_06.2', {})\n  call term_sendkeys(buf, \":set diffopt-=context:2\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt+=context:1\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_06.1', {})\n  call term_sendkeys(buf, \":set diffopt-=context:1\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt+=context:0\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_06.0', {})\n  call term_sendkeys(buf, \":set diffopt-=context:0\\<cr>\")\n\n  \" Test 7 - 9: Test normal/patience/histogram diff algorithm\n  call WriteDiffFiles(buf, ['#include <stdio.h>', '', '// Frobs foo heartily', 'int frobnitz(int foo)', '{',\n      \\ '    int i;', '    for(i = 0; i < 10; i++)', '    {', '        printf(\"Your answer is: \");',\n      \\ '        printf(\"%d\\n\", foo);', '    }', '}', '', 'int fact(int n)', '{', '    if(n > 1)', '    {',\n      \\ '        return fact(n-1) * n;', '    }', '    return 1;', '}', '', 'int main(int argc, char **argv)',\n      \\ '{', '    frobnitz(fact(10));', '}'],\n      \\ ['#include <stdio.h>', '', 'int fib(int n)', '{', '    if(n > 2)', '    {',\n      \\ '        return fib(n-1) + fib(n-2);', '    }', '    return 1;', '}', '', '// Frobs foo heartily',\n      \\ 'int frobnitz(int foo)', '{', '    int i;', '    for(i = 0; i < 10; i++)', '    {',\n      \\ '        printf(\"%d\\n\", foo);', '    }', '}', '',\n      \\ 'int main(int argc, char **argv)', '{', '    frobnitz(fib(10));', '}'])\n  call term_sendkeys(buf, \":diffupdate!\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt+=internal\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_07', {})\n\n  call term_sendkeys(buf, \":set diffopt+=algorithm:patience\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_08', {})\n\n  call term_sendkeys(buf, \":set diffopt+=algorithm:histogram\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_09', {})\n\n  \" Test 10-11: normal/indent-heuristic\n  call term_sendkeys(buf, \":set diffopt&vim\\<cr>\")\n  call WriteDiffFiles(buf, ['', '  def finalize(values)', '', '    values.each do |v|', '      v.finalize', '    end'],\n      \\ ['', '  def finalize(values)', '', '    values.each do |v|', '      v.prepare', '    end', '',\n      \\ '    values.each do |v|', '      v.finalize', '    end'])\n  call term_sendkeys(buf, \":diffupdate!\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt+=internal\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_10', {})\n\n  \" Leave trailing : at commandline!\n  call term_sendkeys(buf, \":set diffopt+=indent-heuristic\\<cr>:\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_11', {}, 'one')\n  \" shouldn't matter, if indent-algorithm comes before or after the algorithm\n  call term_sendkeys(buf, \":set diffopt&\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt+=indent-heuristic,algorithm:patience\\<cr>:\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_11', {}, 'two')\n  call term_sendkeys(buf, \":set diffopt&\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt+=algorithm:patience,indent-heuristic\\<cr>:\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_11', {}, 'three')\n\n  \" Test 12: diff the same file\n  call WriteDiffFiles(buf, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  call VerifyBoth(buf, 'Test_diff_12', '')\n\n  \" Test 13: diff an empty file\n  call WriteDiffFiles(buf, [], [])\n  call VerifyBoth(buf, 'Test_diff_13', '')\n\n  \" Test 14: test diffopt+=icase\n  call WriteDiffFiles(buf, ['a', 'b', 'cd'], ['A', 'b', 'cDe'])\n  call VerifyBoth(buf, 'Test_diff_14', \" diffopt+=filler diffopt+=icase\")\n\n  \" Test 15-16: test diffopt+=iwhite\n  call WriteDiffFiles(buf, ['int main()', '{', '   printf(\"Hello, World!\");', '   return 0;', '}'],\n      \\ ['int main()', '{', '   if (0)', '   {', '      printf(\"Hello, World!\");', '      return 0;', '   }', '}'])\n  call term_sendkeys(buf, \":diffupdate!\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt&vim diffopt+=filler diffopt+=iwhite\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_15', {})\n  call term_sendkeys(buf, \":set diffopt+=internal\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_16', {})\n\n  \" Test 17: test diffopt+=iblank\n  call WriteDiffFiles(buf, ['a', ' ', 'cd', 'ef', 'xxx'], ['a', 'cd', '', 'ef', 'yyy'])\n  call VerifyInternal(buf, 'Test_diff_17', \" diffopt+=iblank\")\n\n  \" Test 18: test diffopt+=iblank,iwhite / iwhiteall / iwhiteeol\n  call VerifyInternal(buf, 'Test_diff_18', \" diffopt+=iblank,iwhite\")\n  call VerifyInternal(buf, 'Test_diff_18', \" diffopt+=iblank,iwhiteall\")\n  call VerifyInternal(buf, 'Test_diff_18', \" diffopt+=iblank,iwhiteeol\")\n\n  \" Test 19: test diffopt+=iwhiteeol\n  call WriteDiffFiles(buf, ['a ', 'x', 'cd', 'ef', 'xx  xx', 'foo', 'bar'], ['a', 'x', 'c d', ' ef', 'xx xx', 'foo', '', 'bar'])\n  call VerifyInternal(buf, 'Test_diff_19', \" diffopt+=iwhiteeol\")\n\n  \" Test 19: test diffopt+=iwhiteall\n  call VerifyInternal(buf, 'Test_diff_20', \" diffopt+=iwhiteall\")\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xfile1')\n  call delete('Xfile2')\n  call delete('XdiffSetup')\nendfunc\n\nfunc Test_diff_with_scroll_and_change()\n  CheckScreendump\n\n  let lines =<< trim END\n\tcall setline(1, range(1, 15))\n\tvnew\n\tcall setline(1, range(9, 15))\n\twindo diffthis\n\twincmd h\n\texe \"normal Gl5\\<C-E>\"\n  END\n  call writefile(lines, 'Xtest_scroll_change')\n  let buf = RunVimInTerminal('-S Xtest_scroll_change', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_scroll_change_01', {})\n\n  call term_sendkeys(buf, \"ax\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_diff_scroll_change_02', {})\n\n  call term_sendkeys(buf, \"\\<C-W>lay\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_diff_scroll_change_03', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_scroll_change')\nendfunc\n\nfunc Test_diff_with_cursorline()\n  CheckScreendump\n\n  call writefile([\n\t\\ 'hi CursorLine ctermbg=red ctermfg=white',\n\t\\ 'set cursorline',\n\t\\ 'call setline(1, [\"foo\",\"foo\",\"foo\",\"bar\"])',\n\t\\ 'vnew',\n\t\\ 'call setline(1, [\"bee\",\"foo\",\"foo\",\"baz\"])',\n\t\\ 'windo diffthis',\n\t\\ '2wincmd w',\n\t\\ ], 'Xtest_diff_cursorline')\n  let buf = RunVimInTerminal('-S Xtest_diff_cursorline', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_with_cursorline_01', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cursorline_02', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cursorline_03', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_cursorline')\nendfunc\n\nfunc Test_diff_with_cursorline_number()\n  CheckScreendump\n\n  let lines =<< trim END\n      hi CursorLine ctermbg=red ctermfg=white\n      hi CursorLineNr ctermbg=white ctermfg=black cterm=underline\n      set cursorline number\n      call setline(1, [\"baz\", \"foo\", \"foo\", \"bar\"])\n      2\n      vnew\n      call setline(1, [\"foo\", \"foo\", \"bar\"])\n      windo diffthis\n      1wincmd w\n  END\n  call writefile(lines, 'Xtest_diff_cursorline_number')\n  let buf = RunVimInTerminal('-S Xtest_diff_cursorline_number', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_with_cursorline_number_01', {})\n  call term_sendkeys(buf, \":set cursorlineopt=number\\r\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cursorline_number_02', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_cursorline_number')\nendfunc\n\nfunc Test_diff_with_cursorline_breakindent()\n  CheckScreendump\n\n  call writefile([\n\t\\ 'hi CursorLine ctermbg=red ctermfg=white',\n\t\\ 'set noequalalways wrap diffopt=followwrap cursorline breakindent',\n\t\\ '50vnew',\n\t\\ 'call setline(1, [\"  \",\"  \",\"  \",\"  \"])',\n\t\\ 'exe \"norm 20Afoo\\<Esc>j20Afoo\\<Esc>j20Afoo\\<Esc>j20Abar\\<Esc>\"',\n\t\\ 'vnew',\n\t\\ 'call setline(1, [\"  \",\"  \",\"  \",\"  \"])',\n\t\\ 'exe \"norm 20Abee\\<Esc>j20Afoo\\<Esc>j20Afoo\\<Esc>j20Abaz\\<Esc>\"',\n\t\\ 'windo diffthis',\n\t\\ '2wincmd w',\n\t\\ ], 'Xtest_diff_cursorline_breakindent')\n  let buf = RunVimInTerminal('-S Xtest_diff_cursorline_breakindent', {})\n\n  call term_sendkeys(buf, \"gg0\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cul_bri_01', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cul_bri_02', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cul_bri_03', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cul_bri_04', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_cursorline_breakindent')\nendfunc\n\nfunc Test_diff_with_syntax()\n  CheckScreendump\n\n  let lines =<< trim END\n  \tvoid doNothing() {\n\t   int x = 0;\n\t   char *s = \"hello\";\n\t   return 5;\n\t}\n  END\n  call writefile(lines, 'Xprogram1.c')\n  let lines =<< trim END\n  \tvoid doSomething() {\n\t   int x = 0;\n\t   char *s = \"there\";\n\t   return 5;\n\t}\n  END\n  call writefile(lines, 'Xprogram2.c')\n\n  let lines =<< trim END\n  \tedit Xprogram1.c\n\tdiffsplit Xprogram2.c\n  END\n  call writefile(lines, 'Xtest_diff_syntax')\n  let buf = RunVimInTerminal('-S Xtest_diff_syntax', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_syntax_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_syntax')\n  call delete('Xprogram1.c')\n  call delete('Xprogram2.c')\nendfunc\n\nfunc Test_diff_of_diff()\n  CheckScreendump\n  CheckFeature rightleft\n\n  call writefile([\n\t\\ 'call setline(1, [\"aa\",\"bb\",\"cc\",\"@@ -3,2 +5,7 @@\",\"dd\",\"ee\",\"ff\"])',\n\t\\ 'vnew',\n\t\\ 'call setline(1, [\"aa\",\"bb\",\"cc\"])',\n\t\\ 'windo diffthis',\n\t\\ '1wincmd w',\n\t\\ 'setlocal number',\n\t\\ ], 'Xtest_diff_diff')\n  let buf = RunVimInTerminal('-S Xtest_diff_diff', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_of_diff_01', {})\n\n  call term_sendkeys(buf, \":set rightleft\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_of_diff_02', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_diff')\nendfunc\n\nfunc CloseoffSetup()\n  enew\n  call setline(1, ['one', 'two', 'three'])\n  diffthis\n  new\n  call setline(1, ['one', 'tow', 'three'])\n  diffthis\n  call assert_equal(1, &diff)\n  only!\nendfunc\n\nfunc Test_diff_closeoff()\n  \" \"closeoff\" included by default: last diff win gets 'diff' reset'\n  call CloseoffSetup()\n  call assert_equal(0, &diff)\n  enew!\n\n  \" \"closeoff\" excluded: last diff win keeps 'diff' set'\n  set diffopt-=closeoff\n  call CloseoffSetup()\n  call assert_equal(1, &diff)\n  diffoff!\n  enew!\nendfunc\n\nfunc Test_diff_followwrap()\n  new\n  set diffopt+=followwrap\n  set wrap\n  diffthis\n  call assert_equal(1, &wrap)\n  diffoff\n  set nowrap\n  diffthis\n  call assert_equal(0, &wrap)\n  diffoff\n  set diffopt&\n  bwipe!\nendfunc\n\nfunc Test_diff_maintains_change_mark()\n  func DiffMaintainsChangeMark()\n    enew!\n    call setline(1, ['a', 'b', 'c', 'd'])\n    diffthis\n    new\n    call setline(1, ['a', 'b', 'c', 'e'])\n    \" Set '[ and '] marks\n    2,3yank\n    call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n    \" Verify they aren't affected by the implicit diff\n    diffthis\n    call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n    \" Verify they aren't affected by an explicit diff\n    diffupdate\n    call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n    bwipe!\n    bwipe!\n  endfunc\n\n  set diffopt-=internal\n  call DiffMaintainsChangeMark()\n  set diffopt+=internal\n  call DiffMaintainsChangeMark()\n\n  set diffopt&\n  delfunc DiffMaintainsChangeMark\nendfunc\n\n\" Test for 'patchexpr'\nfunc Test_patchexpr()\n  let g:patch_args = []\n  func TPatch()\n    call add(g:patch_args, readfile(v:fname_in))\n    call add(g:patch_args, readfile(v:fname_diff))\n    call writefile(['output file'], v:fname_out)\n  endfunc\n  set patchexpr=TPatch()\n\n  call writefile(['input file'], 'Xinput')\n  call writefile(['diff file'], 'Xdiff')\n  %bwipe!\n  edit Xinput\n  diffpatch Xdiff\n  call assert_equal('output file', getline(1))\n  call assert_equal('Xinput.new', bufname())\n  call assert_equal(2, winnr('$'))\n  call assert_true(&diff)\n\n  \" Using a script-local function\n  func s:NewPatchExpr()\n  endfunc\n  set patchexpr=s:NewPatchExpr()\n  call assert_equal(expand('<SID>') .. 'NewPatchExpr()', &patchexpr)\n  set patchexpr=<SID>NewPatchExpr()\n  call assert_equal(expand('<SID>') .. 'NewPatchExpr()', &patchexpr)\n\n  call delete('Xinput')\n  call delete('Xdiff')\n  set patchexpr&\n  delfunc TPatch\n  delfunc s:NewPatchExpr\n  %bwipe!\nendfunc\n\nfunc Test_diff_rnu()\n  CheckScreendump\n\n  let content =<< trim END\n    call setline(1, ['a', 'a', 'a', 'y', 'b', 'b', 'b', 'b', 'b'])\n    vnew\n    call setline(1, ['a', 'a', 'a', 'x', 'x', 'x', 'b', 'b', 'b', 'b', 'b'])\n    windo diffthis\n    setlocal number rnu foldcolumn=0\n  END\n  call writefile(content, 'Xtest_diff_rnu')\n  let buf = RunVimInTerminal('-S Xtest_diff_rnu', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_rnu_01', {})\n\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_rnu_02', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_rnu_03', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_rnu')\nendfunc\n\nfunc Test_diff_multilineconceal()\n  new\n  diffthis\n\n  new\n  call matchadd('Conceal', 'a\\nb', 9, -1, {'conceal': 'Y'})\n  set cole=2 cocu=n\n  call setline(1, [\"a\", \"b\"])\n  diffthis\n  redraw\nendfunc\n\nfunc Test_diff_and_scroll()\n  \" this was causing an ml_get error\n  set ls=2\n  for i in range(winheight(0) * 2) \n    call setline(i, i < winheight(0) - 10 ? i : i + 10) \n  endfor\n  vnew\n  for i in range(winheight(0)*2 + 10) \n    call setline(i, i < winheight(0) - 10 ? 0 : i) \n  endfor\n  diffthis\n  wincmd p\n  diffthis\n  execute 'normal ' . winheight(0) . \"\\<C-d>\"\n\n  bwipe!\n  bwipe!\n  set ls&\nendfunc\n\nfunc Test_diff_filler_cursorcolumn()\n  CheckScreendump\n\n  let content =<< trim END\n    call setline(1, ['aa', 'bb', 'cc'])\n    vnew\n    call setline(1, ['aa', 'cc'])\n    windo diffthis\n    wincmd p\n    setlocal cursorcolumn foldcolumn=0\n    norm! gg0\n    redraw!\n  END\n  call writefile(content, 'Xtest_diff_cuc')\n  let buf = RunVimInTerminal('-S Xtest_diff_cuc', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_cuc_01', {})\n\n  call term_sendkeys(buf, \"l\")\n  call term_sendkeys(buf, \"\\<C-l>\")\n  call VerifyScreenDump(buf, 'Test_diff_cuc_02', {})\n  call term_sendkeys(buf, \"0j\")\n  call term_sendkeys(buf, \"\\<C-l>\")\n  call VerifyScreenDump(buf, 'Test_diff_cuc_03', {})\n  call term_sendkeys(buf, \"l\")\n  call term_sendkeys(buf, \"\\<C-l>\")\n  call VerifyScreenDump(buf, 'Test_diff_cuc_04', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_cuc')\nendfunc\n\n\" Test for adding/removing lines inside diff chunks, between diff chunks\n\" and before diff chunks\nfunc Test_diff_modify_chunks()\n  enew!\n  let w2_id = win_getid()\n  call setline(1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  new\n  let w1_id = win_getid()\n  call setline(1, ['a', '2', '3', 'd', 'e', 'f', '7', '8', 'i'])\n  windo diffthis\n\n  \" remove a line between two diff chunks and create a new diff chunk\n  call win_gotoid(w2_id)\n  5d\n  call win_gotoid(w1_id)\n  call diff_hlID(5, 1)->synIDattr('name')->assert_equal('DiffAdd')\n\n  \" add a line between two diff chunks\n  call win_gotoid(w2_id)\n  normal! 4Goe\n  call win_gotoid(w1_id)\n  call diff_hlID(4, 1)->synIDattr('name')->assert_equal('')\n  call diff_hlID(5, 1)->synIDattr('name')->assert_equal('')\n\n  \" remove all the lines in a diff chunk.\n  call win_gotoid(w2_id)\n  7,8d\n  call win_gotoid(w1_id)\n  let hl = range(1, 9)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', 'DiffText', 'DiffText', '', '', '', 'DiffAdd',\n        \\ 'DiffAdd', ''], hl)\n\n  \" remove lines from one diff chunk to just before the next diff chunk\n  call win_gotoid(w2_id)\n  call setline(1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  2,6d\n  call win_gotoid(w1_id)\n  let hl = range(1, 9)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', 'DiffText', 'DiffText', 'DiffAdd', 'DiffAdd',\n        \\ 'DiffAdd', 'DiffAdd', 'DiffAdd', ''], hl)\n\n  \" remove lines just before the top of a diff chunk\n  call win_gotoid(w2_id)\n  call setline(1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  5,6d\n  call win_gotoid(w1_id)\n  let hl = range(1, 9)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', 'DiffText', 'DiffText', '', 'DiffText', 'DiffText',\n        \\ 'DiffAdd', 'DiffAdd', ''], hl)\n\n  \" remove line after the end of a diff chunk\n  call win_gotoid(w2_id)\n  call setline(1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  4d\n  call win_gotoid(w1_id)\n  let hl = range(1, 9)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', 'DiffText', 'DiffText', 'DiffAdd', '', '', 'DiffText',\n        \\ 'DiffText', ''], hl)\n\n  \" remove lines starting from the end of one diff chunk and ending inside\n  \" another diff chunk\n  call win_gotoid(w2_id)\n  call setline(1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  4,7d\n  call win_gotoid(w1_id)\n  let hl = range(1, 9)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', 'DiffText', 'DiffText', 'DiffText', 'DiffAdd',\n        \\ 'DiffAdd', 'DiffAdd', 'DiffAdd', ''], hl)\n\n  \" removing the only remaining diff chunk should make the files equal\n  call win_gotoid(w2_id)\n  call setline(1, ['a', '2', '3', 'x', 'd', 'e', 'f', 'x', '7', '8', 'i'])\n  8d\n  let hl = range(1, 10)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', '', '', 'DiffAdd', '', '', '', '', '', ''], hl)\n  call win_gotoid(w2_id)\n  4d\n  call win_gotoid(w1_id)\n  let hl = range(1, 9)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', '', '', '', '', '', '', '', ''], hl)\n\n  %bw!\nendfunc\n\nfunc Test_diff_binary()\n  CheckScreendump\n\n  let content =<< trim END\n    call setline(1, ['a', 'b', \"c\\n\", 'd', 'e', 'f', 'g'])\n    vnew\n    call setline(1, ['A', 'b', 'c', 'd', 'E', 'f', 'g'])\n    windo diffthis\n    wincmd p\n    norm! gg0\n    redraw!\n  END\n  call writefile(content, 'Xtest_diff_bin')\n  let buf = RunVimInTerminal('-S Xtest_diff_bin', {})\n\n  \" Test using internal diff\n  call VerifyScreenDump(buf, 'Test_diff_bin_01', {})\n\n  \" Test using internal diff and case folding\n  call term_sendkeys(buf, \":set diffopt+=icase\\<cr>\")\n  call term_sendkeys(buf, \"\\<C-l>\")\n  call VerifyScreenDump(buf, 'Test_diff_bin_02', {})\n  \" Test using external diff\n  call term_sendkeys(buf, \":set diffopt=filler\\<cr>\")\n  call term_sendkeys(buf, \"\\<C-l>\")\n  call VerifyScreenDump(buf, 'Test_diff_bin_03', {})\n  \" Test using external diff and case folding\n  call term_sendkeys(buf, \":set diffopt=filler,icase\\<cr>\")\n  call term_sendkeys(buf, \"\\<C-l>\")\n  call VerifyScreenDump(buf, 'Test_diff_bin_04', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_bin')\n  set diffopt&vim\nendfunc\n\n\" Test for using the 'zi' command to invert 'foldenable' in diff windows (test\n\" for the issue fixed by patch 6.2.317)\nfunc Test_diff_foldinvert()\n  %bw!\n  edit Xfile1\n  new Xfile2\n  new Xfile3\n  windo diffthis\n  \" open a non-diff window\n  botright new\n  1wincmd w\n  call assert_true(getwinvar(1, '&foldenable'))\n  call assert_true(getwinvar(2, '&foldenable'))\n  call assert_true(getwinvar(3, '&foldenable'))\n  normal zi\n  call assert_false(getwinvar(1, '&foldenable'))\n  call assert_false(getwinvar(2, '&foldenable'))\n  call assert_false(getwinvar(3, '&foldenable'))\n  normal zi\n  call assert_true(getwinvar(1, '&foldenable'))\n  call assert_true(getwinvar(2, '&foldenable'))\n  call assert_true(getwinvar(3, '&foldenable'))\n\n  \" If the current window has 'noscrollbind', then 'zi' should not change\n  \" 'foldenable' in other windows.\n  1wincmd w\n  set noscrollbind\n  normal zi\n  call assert_false(getwinvar(1, '&foldenable'))\n  call assert_true(getwinvar(2, '&foldenable'))\n  call assert_true(getwinvar(3, '&foldenable'))\n\n  \" 'zi' should not change the 'foldenable' for windows with 'noscrollbind'\n  1wincmd w\n  set scrollbind\n  normal zi\n  call setwinvar(2, '&scrollbind', v:false)\n  normal zi\n  call assert_false(getwinvar(1, '&foldenable'))\n  call assert_true(getwinvar(2, '&foldenable'))\n  call assert_false(getwinvar(3, '&foldenable'))\n\n  %bw!\n  set scrollbind&\nendfunc\n\n\" This was scrolling for 'cursorbind' but 'scrollbind' is more important\nfunc Test_diff_scroll()\n  CheckScreendump\n\n  let left =<< trim END\n      line 1\n      line 2\n      line 3\n      line 4\n\n      // Common block\n      // one\n      // containing\n      // four lines\n\n      // Common block\n      // two\n      // containing\n      // four lines\n  END\n  call writefile(left, 'Xleft')\n  let right =<< trim END\n      line 1\n      line 2\n      line 3\n      line 4\n\n      Lorem\n      ipsum\n      dolor\n      sit\n      amet,\n      consectetur\n      adipiscing\n      elit.\n      Etiam\n      luctus\n      lectus\n      sodales,\n      dictum\n\n      // Common block\n      // one\n      // containing\n      // four lines\n\n      Vestibulum\n      tincidunt\n      aliquet\n      nulla.\n\n      // Common block\n      // two\n      // containing\n      // four lines\n  END\n  call writefile(right, 'Xright')\n  let buf = RunVimInTerminal('-d Xleft Xright', {'rows': 12})\n  call term_sendkeys(buf, \"\\<C-W>\\<C-W>jjjj\")\n  call VerifyScreenDump(buf, 'Test_diff_scroll_1', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_scroll_2', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xleft')\n  call delete('Xright')\nendfunc\n\n\" This was trying to update diffs for a buffer being closed\nfunc Test_diff_only()\n  silent! lfile\n  set diff\n  lopen\n  norm \u0017\u0018\u0017\u000eo\n  silent! norm \u0017\u000e\u0017o\n\n  set nodiff\n  %bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5163,\n/**/\n    5162,\n/**/\n    5161,\n/**/\n    5160,\n/**/\n    5159,\n/**/\n    5158,\n/**/\n    5157,\n/**/\n    5156,\n/**/\n    5155,\n/**/\n    5154,\n/**/\n    5153,\n/**/\n    5152,\n/**/\n    5151,\n/**/\n    5150,\n/**/\n    5149,\n/**/\n    5148,\n/**/\n    5147,\n/**/\n    5146,\n/**/\n    5145,\n/**/\n    5144,\n/**/\n    5143,\n/**/\n    5142,\n/**/\n    5141,\n/**/\n    5140,\n/**/\n    5139,\n/**/\n    5138,\n/**/\n    5137,\n/**/\n    5136,\n/**/\n    5135,\n/**/\n    5134,\n/**/\n    5133,\n/**/\n    5132,\n/**/\n    5131,\n/**/\n    5130,\n/**/\n    5129,\n/**/\n    5128,\n/**/\n    5127,\n/**/\n    5126,\n/**/\n    5125,\n/**/\n    5124,\n/**/\n    5123,\n/**/\n    5122,\n/**/\n    5121,\n/**/\n    5120,\n/**/\n    5119,\n/**/\n    5118,\n/**/\n    5117,\n/**/\n    5116,\n/**/\n    5115,\n/**/\n    5114,\n/**/\n    5113,\n/**/\n    5112,\n/**/\n    5111,\n/**/\n    5110,\n/**/\n    5109,\n/**/\n    5108,\n/**/\n    5107,\n/**/\n    5106,\n/**/\n    5105,\n/**/\n    5104,\n/**/\n    5103,\n/**/\n    5102,\n/**/\n    5101,\n/**/\n    5100,\n/**/\n    5099,\n/**/\n    5098,\n/**/\n    5097,\n/**/\n    5096,\n/**/\n    5095,\n/**/\n    5094,\n/**/\n    5093,\n/**/\n    5092,\n/**/\n    5091,\n/**/\n    5090,\n/**/\n    5089,\n/**/\n    5088,\n/**/\n    5087,\n/**/\n    5086,\n/**/\n    5085,\n/**/\n    5084,\n/**/\n    5083,\n/**/\n    5082,\n/**/\n    5081,\n/**/\n    5080,\n/**/\n    5079,\n/**/\n    5078,\n/**/\n    5077,\n/**/\n    5076,\n/**/\n    5075,\n/**/\n    5074,\n/**/\n    5073,\n/**/\n    5072,\n/**/\n    5071,\n/**/\n    5070,\n/**/\n    5069,\n/**/\n    5068,\n/**/\n    5067,\n/**/\n    5066,\n/**/\n    5065,\n/**/\n    5064,\n/**/\n    5063,\n/**/\n    5062,\n/**/\n    5061,\n/**/\n    5060,\n/**/\n    5059,\n/**/\n    5058,\n/**/\n    5057,\n/**/\n    5056,\n/**/\n    5055,\n/**/\n    5054,\n/**/\n    5053,\n/**/\n    5052,\n/**/\n    5051,\n/**/\n    5050,\n/**/\n    5049,\n/**/\n    5048,\n/**/\n    5047,\n/**/\n    5046,\n/**/\n    5045,\n/**/\n    5044,\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * diff.c: code for diff'ing two, three or four buffers.\n *\n * There are three ways to diff:\n * - Shell out to an external diff program, using files.\n * - Use the compiled-in xdiff library.\n * - Let 'diffexpr' do the work, using files.\n */\n\n#include \"vim.h\"\n#include \"xdiff/xdiff.h\"\n\n#if defined(FEAT_DIFF) || defined(PROTO)\n\nstatic int diff_busy = FALSE;\t    // using diff structs, don't change them\nstatic int diff_need_update = FALSE; // ex_diffupdate needs to be called\n\n// flags obtained from the 'diffopt' option\n#define DIFF_FILLER\t0x001\t// display filler lines\n#define DIFF_IBLANK\t0x002\t// ignore empty lines\n#define DIFF_ICASE\t0x004\t// ignore case\n#define DIFF_IWHITE\t0x008\t// ignore change in white space\n#define DIFF_IWHITEALL\t0x010\t// ignore all white space changes\n#define DIFF_IWHITEEOL\t0x020\t// ignore change in white space at EOL\n#define DIFF_HORIZONTAL\t0x040\t// horizontal splits\n#define DIFF_VERTICAL\t0x080\t// vertical splits\n#define DIFF_HIDDEN_OFF\t0x100\t// diffoff when hidden\n#define DIFF_INTERNAL\t0x200\t// use internal xdiff algorithm\n#define DIFF_CLOSE_OFF\t0x400\t// diffoff when closing window\n#define DIFF_FOLLOWWRAP\t0x800\t// follow the wrap option\n#define ALL_WHITE_DIFF (DIFF_IWHITE | DIFF_IWHITEALL | DIFF_IWHITEEOL)\nstatic int\tdiff_flags = DIFF_INTERNAL | DIFF_FILLER | DIFF_CLOSE_OFF;\n\nstatic long diff_algorithm = 0;\n\n#define LBUFLEN 50\t\t// length of line in diff file\n\nstatic int diff_a_works = MAYBE; // TRUE when \"diff -a\" works, FALSE when it\n\t\t\t\t // doesn't work, MAYBE when not checked yet\n#if defined(MSWIN)\nstatic int diff_bin_works = MAYBE; // TRUE when \"diff --binary\" works, FALSE\n\t\t\t\t   // when it doesn't work, MAYBE when not\n\t\t\t\t   // checked yet\n#endif\n\n// used for diff input\ntypedef struct {\n    char_u\t*din_fname;  // used for external diff\n    mmfile_t\tdin_mmfile;  // used for internal diff\n} diffin_T;\n\n// used for diff result\ntypedef struct {\n    char_u\t*dout_fname;  // used for external diff\n    garray_T\tdout_ga;      // used for internal diff\n} diffout_T;\n\n// used for recording hunks from xdiff\ntypedef struct {\n    linenr_T lnum_orig;\n    long     count_orig;\n    linenr_T lnum_new;\n    long     count_new;\n} diffhunk_T;\n\n// two diff inputs and one result\ntypedef struct {\n    diffin_T\tdio_orig;     // original file input\n    diffin_T\tdio_new;      // new file input\n    diffout_T\tdio_diff;     // diff result\n    int\t\tdio_internal; // using internal diff\n} diffio_T;\n\nstatic int diff_buf_idx(buf_T *buf);\nstatic int diff_buf_idx_tp(buf_T *buf, tabpage_T *tp);\nstatic void diff_mark_adjust_tp(tabpage_T *tp, int idx, linenr_T line1, linenr_T line2, long amount, long amount_after);\nstatic void diff_check_unchanged(tabpage_T *tp, diff_T *dp);\nstatic int diff_check_sanity(tabpage_T *tp, diff_T *dp);\nstatic int check_external_diff(diffio_T *diffio);\nstatic int diff_file(diffio_T *diffio);\nstatic int diff_equal_entry(diff_T *dp, int idx1, int idx2);\nstatic int diff_cmp(char_u *s1, char_u *s2);\n#ifdef FEAT_FOLDING\nstatic void diff_fold_update(diff_T *dp, int skip_idx);\n#endif\nstatic void diff_read(int idx_orig, int idx_new, diffio_T *dio);\nstatic void diff_copy_entry(diff_T *dprev, diff_T *dp, int idx_orig, int idx_new);\nstatic diff_T *diff_alloc_new(tabpage_T *tp, diff_T *dprev, diff_T *dp);\nstatic int parse_diff_ed(char_u *line, diffhunk_T *hunk);\nstatic int parse_diff_unified(char_u *line, diffhunk_T *hunk);\nstatic int xdiff_out(long start_a, long count_a, long start_b, long count_b, void *priv);\n\n#define FOR_ALL_DIFFBLOCKS_IN_TAB(tp, dp) \\\n    for ((dp) = (tp)->tp_first_diff; (dp) != NULL; (dp) = (dp)->df_next)\n\n/*\n * Called when deleting or unloading a buffer: No longer make a diff with it.\n */\n    void\ndiff_buf_delete(buf_T *buf)\n{\n    int\t\ti;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\ti = diff_buf_idx_tp(buf, tp);\n\tif (i != DB_COUNT)\n\t{\n\t    tp->tp_diffbuf[i] = NULL;\n\t    tp->tp_diff_invalid = TRUE;\n\t    if (tp == curtab)\n\t    {\n\t\t// don't redraw right away, more might change or buffer state\n\t\t// is invalid right now\n\t\tneed_diff_redraw = TRUE;\n\t\tredraw_later(VALID);\n\t    }\n\t}\n    }\n}\n\n/*\n * Check if the current buffer should be added to or removed from the list of\n * diff buffers.\n */\n    void\ndiff_buf_adjust(win_T *win)\n{\n    win_T\t*wp;\n    int\t\ti;\n\n    if (!win->w_p_diff)\n    {\n\t// When there is no window showing a diff for this buffer, remove\n\t// it from the diffs.\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == win->w_buffer && wp->w_p_diff)\n\t\tbreak;\n\tif (wp == NULL)\n\t{\n\t    i = diff_buf_idx(win->w_buffer);\n\t    if (i != DB_COUNT)\n\t    {\n\t\tcurtab->tp_diffbuf[i] = NULL;\n\t\tcurtab->tp_diff_invalid = TRUE;\n\t\tdiff_redraw(TRUE);\n\t    }\n\t}\n    }\n    else\n\tdiff_buf_add(win->w_buffer);\n}\n\n/*\n * Add a buffer to make diffs for.\n * Call this when a new buffer is being edited in the current window where\n * 'diff' is set.\n * Marks the current buffer as being part of the diff and requiring updating.\n * This must be done before any autocmd, because a command may use info\n * about the screen contents.\n */\n    void\ndiff_buf_add(buf_T *buf)\n{\n    int\t\ti;\n\n    if (diff_buf_idx(buf) != DB_COUNT)\n\treturn;\t\t// It's already there.\n\n    for (i = 0; i < DB_COUNT; ++i)\n\tif (curtab->tp_diffbuf[i] == NULL)\n\t{\n\t    curtab->tp_diffbuf[i] = buf;\n\t    curtab->tp_diff_invalid = TRUE;\n\t    diff_redraw(TRUE);\n\t    return;\n\t}\n\n    semsg(_(e_cannot_diff_more_than_nr_buffers), DB_COUNT);\n}\n\n/*\n * Remove all buffers to make diffs for.\n */\n    static void\ndiff_buf_clear(void)\n{\n    int\t\ti;\n\n    for (i = 0; i < DB_COUNT; ++i)\n\tif (curtab->tp_diffbuf[i] != NULL)\n\t{\n\t    curtab->tp_diffbuf[i] = NULL;\n\t    curtab->tp_diff_invalid = TRUE;\n\t    diff_redraw(TRUE);\n\t}\n}\n\n/*\n * Find buffer \"buf\" in the list of diff buffers for the current tab page.\n * Return its index or DB_COUNT if not found.\n */\n    static int\ndiff_buf_idx(buf_T *buf)\n{\n    int\t\tidx;\n\n    for (idx = 0; idx < DB_COUNT; ++idx)\n\tif (curtab->tp_diffbuf[idx] == buf)\n\t    break;\n    return idx;\n}\n\n/*\n * Find buffer \"buf\" in the list of diff buffers for tab page \"tp\".\n * Return its index or DB_COUNT if not found.\n */\n    static int\ndiff_buf_idx_tp(buf_T *buf, tabpage_T *tp)\n{\n    int\t\tidx;\n\n    for (idx = 0; idx < DB_COUNT; ++idx)\n\tif (tp->tp_diffbuf[idx] == buf)\n\t    break;\n    return idx;\n}\n\n/*\n * Mark the diff info involving buffer \"buf\" as invalid, it will be updated\n * when info is requested.\n */\n    void\ndiff_invalidate(buf_T *buf)\n{\n    tabpage_T\t*tp;\n    int\t\ti;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\ti = diff_buf_idx_tp(buf, tp);\n\tif (i != DB_COUNT)\n\t{\n\t    tp->tp_diff_invalid = TRUE;\n\t    if (tp == curtab)\n\t\tdiff_redraw(TRUE);\n\t}\n    }\n}\n\n/*\n * Called by mark_adjust(): update line numbers in \"curbuf\".\n */\n    void\ndiff_mark_adjust(\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after)\n{\n    int\t\tidx;\n    tabpage_T\t*tp;\n\n    // Handle all tab pages that use the current buffer in a diff.\n    FOR_ALL_TABPAGES(tp)\n    {\n\tidx = diff_buf_idx_tp(curbuf, tp);\n\tif (idx != DB_COUNT)\n\t    diff_mark_adjust_tp(tp, idx, line1, line2, amount, amount_after);\n    }\n}\n\n/*\n * Update line numbers in tab page \"tp\" for \"curbuf\" with index \"idx\".\n * This attempts to update the changes as much as possible:\n * When inserting/deleting lines outside of existing change blocks, create a\n * new change block and update the line numbers in following blocks.\n * When inserting/deleting lines in existing change blocks, update them.\n */\n    static void\ndiff_mark_adjust_tp(\n    tabpage_T\t*tp,\n    int\t\tidx,\n    linenr_T\tline1,\n    linenr_T\tline2,\n    long\tamount,\n    long\tamount_after)\n{\n    diff_T\t*dp;\n    diff_T\t*dprev;\n    diff_T\t*dnext;\n    int\t\ti;\n    int\t\tinserted, deleted;\n    int\t\tn, off;\n    linenr_T\tlast;\n    linenr_T\tlnum_deleted = line1;\t// lnum of remaining deletion\n    int\t\tcheck_unchanged;\n\n    if (diff_internal())\n    {\n\t// Will update diffs before redrawing.  Set _invalid to update the\n\t// diffs themselves, set _update to also update folds properly just\n\t// before redrawing.\n\t// Do update marks here, it is needed for :%diffput.\n\ttp->tp_diff_invalid = TRUE;\n\ttp->tp_diff_update = TRUE;\n    }\n\n    if (line2 == MAXLNUM)\n    {\n\t// mark_adjust(99, MAXLNUM, 9, 0): insert lines\n\tinserted = amount;\n\tdeleted = 0;\n    }\n    else if (amount_after > 0)\n    {\n\t// mark_adjust(99, 98, MAXLNUM, 9): a change that inserts lines\n\tinserted = amount_after;\n\tdeleted = 0;\n    }\n    else\n    {\n\t// mark_adjust(98, 99, MAXLNUM, -2): delete lines\n\tinserted = 0;\n\tdeleted = -amount_after;\n    }\n\n    dprev = NULL;\n    dp = tp->tp_first_diff;\n    for (;;)\n    {\n\t// If the change is after the previous diff block and before the next\n\t// diff block, thus not touching an existing change, create a new diff\n\t// block.  Don't do this when ex_diffgetput() is busy.\n\tif ((dp == NULL || dp->df_lnum[idx] - 1 > line2\n\t\t    || (line2 == MAXLNUM && dp->df_lnum[idx] > line1))\n\t\t&& (dprev == NULL\n\t\t    || dprev->df_lnum[idx] + dprev->df_count[idx] < line1)\n\t\t&& !diff_busy)\n\t{\n\t    dnext = diff_alloc_new(tp, dprev, dp);\n\t    if (dnext == NULL)\n\t\treturn;\n\n\t    dnext->df_lnum[idx] = line1;\n\t    dnext->df_count[idx] = inserted;\n\t    for (i = 0; i < DB_COUNT; ++i)\n\t\tif (tp->tp_diffbuf[i] != NULL && i != idx)\n\t\t{\n\t\t    if (dprev == NULL)\n\t\t\tdnext->df_lnum[i] = line1;\n\t\t    else\n\t\t\tdnext->df_lnum[i] = line1\n\t\t\t    + (dprev->df_lnum[i] + dprev->df_count[i])\n\t\t\t    - (dprev->df_lnum[idx] + dprev->df_count[idx]);\n\t\t    dnext->df_count[i] = deleted;\n\t\t}\n\t}\n\n\t// if at end of the list, quit\n\tif (dp == NULL)\n\t    break;\n\n\t/*\n\t * Check for these situations:\n\t *\t  1  2\t3\n\t *\t  1  2\t3\n\t * line1     2\t3  4  5\n\t *\t     2\t3  4  5\n\t *\t     2\t3  4  5\n\t * line2     2\t3  4  5\n\t *\t\t3     5  6\n\t *\t\t3     5  6\n\t */\n\t// compute last line of this change\n\tlast = dp->df_lnum[idx] + dp->df_count[idx] - 1;\n\n\t// 1. change completely above line1: nothing to do\n\tif (last >= line1 - 1)\n\t{\n\t    // 6. change below line2: only adjust for amount_after; also when\n\t    // \"deleted\" became zero when deleted all lines between two diffs\n\t    if (dp->df_lnum[idx] - (deleted + inserted != 0) > line2)\n\t    {\n\t\tif (amount_after == 0)\n\t\t    break;\t// nothing left to change\n\t\tdp->df_lnum[idx] += amount_after;\n\t    }\n\t    else\n\t    {\n\t\tcheck_unchanged = FALSE;\n\n\t\t// 2. 3. 4. 5.: inserted/deleted lines touching this diff.\n\t\tif (deleted > 0)\n\t\t{\n\t\t    off = 0;\n\t\t    if (dp->df_lnum[idx] >= line1)\n\t\t    {\n\t\t\tif (last <= line2)\n\t\t\t{\n\t\t\t    // 4. delete all lines of diff\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp->df_next->df_lnum[idx] - lnum_deleted;\n\t\t\t\tdeleted -= n;\n\t\t\t\tn -= dp->df_count[idx];\n\t\t\t\tlnum_deleted = dp->df_next->df_lnum[idx];\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tn = deleted - dp->df_count[idx];\n\t\t\t    dp->df_count[idx] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // 5. delete lines at or just before top of diff\n\t\t\t    off = dp->df_lnum[idx] - lnum_deleted;\n\t\t\t    n = off;\n\t\t\t    dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\tdp->df_lnum[idx] = line1;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (last < line2)\n\t\t\t{\n\t\t\t    // 2. delete at end of diff\n\t\t\t    dp->df_count[idx] -= last - lnum_deleted + 1;\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp->df_next->df_lnum[idx] - 1 - last;\n\t\t\t\tdeleted -= dp->df_next->df_lnum[idx]\n\t\t\t\t\t\t\t       - lnum_deleted;\n\t\t\t\tlnum_deleted = dp->df_next->df_lnum[idx];\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tn = line2 - last;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // 3. delete lines inside the diff\n\t\t\t    n = 0;\n\t\t\t    dp->df_count[idx] -= deleted;\n\t\t\t}\n\t\t    }\n\n\t\t    for (i = 0; i < DB_COUNT; ++i)\n\t\t\tif (tp->tp_diffbuf[i] != NULL && i != idx)\n\t\t\t{\n\t\t\t    dp->df_lnum[i] -= off;\n\t\t\t    dp->df_count[i] += n;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (dp->df_lnum[idx] <= line1)\n\t\t    {\n\t\t\t// inserted lines somewhere in this diff\n\t\t\tdp->df_count[idx] += inserted;\n\t\t\tcheck_unchanged = TRUE;\n\t\t    }\n\t\t    else\n\t\t\t// inserted lines somewhere above this diff\n\t\t\tdp->df_lnum[idx] += inserted;\n\t\t}\n\n\t\tif (check_unchanged)\n\t\t    // Check if inserted lines are equal, may reduce the\n\t\t    // size of the diff.  TODO: also check for equal lines\n\t\t    // in the middle and perhaps split the block.\n\t\t    diff_check_unchanged(tp, dp);\n\t    }\n\t}\n\n\t// check if this block touches the previous one, may merge them.\n\tif (dprev != NULL && dprev->df_lnum[idx] + dprev->df_count[idx]\n\t\t\t\t\t\t\t  == dp->df_lnum[idx])\n\t{\n\t    for (i = 0; i < DB_COUNT; ++i)\n\t\tif (tp->tp_diffbuf[i] != NULL)\n\t\t    dprev->df_count[i] += dp->df_count[i];\n\t    dprev->df_next = dp->df_next;\n\t    vim_free(dp);\n\t    dp = dprev->df_next;\n\t}\n\telse\n\t{\n\t    // Advance to next entry.\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t}\n    }\n\n    dprev = NULL;\n    dp = tp->tp_first_diff;\n    while (dp != NULL)\n    {\n\t// All counts are zero, remove this entry.\n\tfor (i = 0; i < DB_COUNT; ++i)\n\t    if (tp->tp_diffbuf[i] != NULL && dp->df_count[i] != 0)\n\t\tbreak;\n\tif (i == DB_COUNT)\n\t{\n\t    dnext = dp->df_next;\n\t    vim_free(dp);\n\t    dp = dnext;\n\t    if (dprev == NULL)\n\t\ttp->tp_first_diff = dnext;\n\t    else\n\t\tdprev->df_next = dnext;\n\t}\n\telse\n\t{\n\t    // Advance to next entry.\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t}\n\n    }\n\n    if (tp == curtab)\n    {\n\t// Don't redraw right away, this updates the diffs, which can be slow.\n\tneed_diff_redraw = TRUE;\n\n\t// Need to recompute the scroll binding, may remove or add filler\n\t// lines (e.g., when adding lines above w_topline). But it's slow when\n\t// making many changes, postpone until redrawing.\n\tdiff_need_scrollbind = TRUE;\n    }\n}\n\n/*\n * Allocate a new diff block and link it between \"dprev\" and \"dp\".\n */\n    static diff_T *\ndiff_alloc_new(tabpage_T *tp, diff_T *dprev, diff_T *dp)\n{\n    diff_T\t*dnew;\n\n    dnew = ALLOC_ONE(diff_T);\n    if (dnew != NULL)\n    {\n\tdnew->df_next = dp;\n\tif (dprev == NULL)\n\t    tp->tp_first_diff = dnew;\n\telse\n\t    dprev->df_next = dnew;\n    }\n    return dnew;\n}\n\n/*\n * Check if the diff block \"dp\" can be made smaller for lines at the start and\n * end that are equal.  Called after inserting lines.\n * This may result in a change where all buffers have zero lines, the caller\n * must take care of removing it.\n */\n    static void\ndiff_check_unchanged(tabpage_T *tp, diff_T *dp)\n{\n    int\t\ti_org;\n    int\t\ti_new;\n    int\t\toff_org, off_new;\n    char_u\t*line_org;\n    int\t\tdir = FORWARD;\n\n    // Find the first buffers, use it as the original, compare the other\n    // buffer lines against this one.\n    for (i_org = 0; i_org < DB_COUNT; ++i_org)\n\tif (tp->tp_diffbuf[i_org] != NULL)\n\t    break;\n    if (i_org == DB_COUNT)\t// safety check\n\treturn;\n\n    if (diff_check_sanity(tp, dp) == FAIL)\n\treturn;\n\n    // First check lines at the top, then at the bottom.\n    off_org = 0;\n    off_new = 0;\n    for (;;)\n    {\n\t// Repeat until a line is found which is different or the number of\n\t// lines has become zero.\n\twhile (dp->df_count[i_org] > 0)\n\t{\n\t    // Copy the line, the next ml_get() will invalidate it.\n\t    if (dir == BACKWARD)\n\t\toff_org = dp->df_count[i_org] - 1;\n\t    line_org = vim_strsave(ml_get_buf(tp->tp_diffbuf[i_org],\n\t\t\t\t\tdp->df_lnum[i_org] + off_org, FALSE));\n\t    if (line_org == NULL)\n\t\treturn;\n\t    for (i_new = i_org + 1; i_new < DB_COUNT; ++i_new)\n\t    {\n\t\tif (tp->tp_diffbuf[i_new] == NULL)\n\t\t    continue;\n\t\tif (dir == BACKWARD)\n\t\t    off_new = dp->df_count[i_new] - 1;\n\t\t// if other buffer doesn't have this line, it was inserted\n\t\tif (off_new < 0 || off_new >= dp->df_count[i_new])\n\t\t    break;\n\t\tif (diff_cmp(line_org, ml_get_buf(tp->tp_diffbuf[i_new],\n\t\t\t\t   dp->df_lnum[i_new] + off_new, FALSE)) != 0)\n\t\t    break;\n\t    }\n\t    vim_free(line_org);\n\n\t    // Stop when a line isn't equal in all diff buffers.\n\t    if (i_new != DB_COUNT)\n\t\tbreak;\n\n\t    // Line matched in all buffers, remove it from the diff.\n\t    for (i_new = i_org; i_new < DB_COUNT; ++i_new)\n\t\tif (tp->tp_diffbuf[i_new] != NULL)\n\t\t{\n\t\t    if (dir == FORWARD)\n\t\t\t++dp->df_lnum[i_new];\n\t\t    --dp->df_count[i_new];\n\t\t}\n\t}\n\tif (dir == BACKWARD)\n\t    break;\n\tdir = BACKWARD;\n    }\n}\n\n/*\n * Check if a diff block doesn't contain invalid line numbers.\n * This can happen when the diff program returns invalid results.\n */\n    static int\ndiff_check_sanity(tabpage_T *tp, diff_T *dp)\n{\n    int\t\ti;\n\n    for (i = 0; i < DB_COUNT; ++i)\n\tif (tp->tp_diffbuf[i] != NULL)\n\t    if (dp->df_lnum[i] + dp->df_count[i] - 1\n\t\t\t\t      > tp->tp_diffbuf[i]->b_ml.ml_line_count)\n\t\treturn FAIL;\n    return OK;\n}\n\n/*\n * Mark all diff buffers in the current tab page for redraw.\n */\n    void\ndiff_redraw(\n    int\t\tdofold)\t    // also recompute the folds\n{\n    win_T\t*wp;\n    win_T\t*wp_other = NULL;\n    int\t\tused_max_fill_other = FALSE;\n    int\t\tused_max_fill_curwin = FALSE;\n    int\t\tn;\n\n    need_diff_redraw = FALSE;\n    FOR_ALL_WINDOWS(wp)\n\t// when closing windows or wiping buffers skip invalid window\n\tif (wp->w_p_diff && buf_valid(wp->w_buffer))\n\t{\n\t    redraw_win_later(wp, SOME_VALID);\n\t    if (wp != curwin)\n\t\twp_other = wp;\n#ifdef FEAT_FOLDING\n\t    if (dofold && foldmethodIsDiff(wp))\n\t\tfoldUpdateAll(wp);\n#endif\n\t    // A change may have made filler lines invalid, need to take care\n\t    // of that for other windows.\n\t    n = diff_check(wp, wp->w_topline);\n\t    if ((wp != curwin && wp->w_topfill > 0) || n > 0)\n\t    {\n\t\tif (wp->w_topfill > n)\n\t\t    wp->w_topfill = (n < 0 ? 0 : n);\n\t\telse if (n > 0 && n > wp->w_topfill)\n\t\t{\n\t\t    wp->w_topfill = n;\n\t\t    if (wp == curwin)\n\t\t\tused_max_fill_curwin = TRUE;\n\t\t    else if (wp_other != NULL)\n\t\t\tused_max_fill_other = TRUE;\n\t\t}\n\t\tcheck_topfill(wp, FALSE);\n\t    }\n\t}\n\n    if (wp_other != NULL && curwin->w_p_scb)\n    {\n\tif (used_max_fill_curwin)\n\t    // The current window was set to use the maximum number of filler\n\t    // lines, may need to reduce them.\n\t    diff_set_topline(wp_other, curwin);\n\telse if (used_max_fill_other)\n\t    // The other window was set to use the maximum number of filler\n\t    // lines, may need to reduce them.\n\t    diff_set_topline(curwin, wp_other);\n    }\n}\n\n    static void\nclear_diffin(diffin_T *din)\n{\n    if (din->din_fname == NULL)\n    {\n\tvim_free(din->din_mmfile.ptr);\n\tdin->din_mmfile.ptr = NULL;\n    }\n    else\n\tmch_remove(din->din_fname);\n}\n\n    static void\nclear_diffout(diffout_T *dout)\n{\n    if (dout->dout_fname == NULL)\n\tga_clear_strings(&dout->dout_ga);\n    else\n\tmch_remove(dout->dout_fname);\n}\n\n/*\n * Write buffer \"buf\" to a memory buffer.\n * Return FAIL for failure.\n */\n    static int\ndiff_write_buffer(buf_T *buf, diffin_T *din)\n{\n    linenr_T\tlnum;\n    char_u\t*s;\n    long\tlen = 0;\n    char_u\t*ptr;\n\n    // xdiff requires one big block of memory with all the text.\n    for (lnum = 1; lnum <= buf->b_ml.ml_line_count; ++lnum)\n\tlen += (long)STRLEN(ml_get_buf(buf, lnum, FALSE)) + 1;\n    ptr = alloc(len);\n    if (ptr == NULL)\n    {\n\t// Allocating memory failed.  This can happen, because we try to read\n\t// the whole buffer text into memory.  Set the failed flag, the diff\n\t// will be retried with external diff.  The flag is never reset.\n\tbuf->b_diff_failed = TRUE;\n\tif (p_verbose > 0)\n\t{\n\t    verbose_enter();\n\t    smsg(_(\"Not enough memory to use internal diff for buffer \\\"%s\\\"\"),\n\t\t\t\t\t\t\t\t buf->b_fname);\n\t    verbose_leave();\n\t}\n\treturn FAIL;\n    }\n    din->din_mmfile.ptr = (char *)ptr;\n    din->din_mmfile.size = len;\n\n    len = 0;\n    for (lnum = 1; lnum <= buf->b_ml.ml_line_count; ++lnum)\n    {\n\tfor (s = ml_get_buf(buf, lnum, FALSE); *s != NUL; )\n\t{\n\t    if (diff_flags & DIFF_ICASE)\n\t    {\n\t\tint c;\n\t\tint\torig_len;\n\t\tchar_u\tcbuf[MB_MAXBYTES + 1];\n\n\t\tif (*s == NL)\n\t\t    c = NUL;\n\t\telse\n\t\t{\n\t\t    // xdiff doesn't support ignoring case, fold-case the text.\n\t\t    c = PTR2CHAR(s);\n\t\t    c = MB_CASEFOLD(c);\n\t\t}\n\t\torig_len = mb_ptr2len(s);\n\t\tif (mb_char2bytes(c, cbuf) != orig_len)\n\t\t    // TODO: handle byte length difference\n\t\t    mch_memmove(ptr + len, s, orig_len);\n\t\telse\n\t\t    mch_memmove(ptr + len, cbuf, orig_len);\n\n\t\ts += orig_len;\n\t\tlen += orig_len;\n\t    }\n\t    else\n\t    {\n\t\tptr[len++] = *s == NL ? NUL : *s;\n\t\ts++;\n\t    }\n\t}\n\tptr[len++] = NL;\n    }\n    return OK;\n}\n\n/*\n * Write buffer \"buf\" to file or memory buffer.\n * Return FAIL for failure.\n */\n    static int\ndiff_write(buf_T *buf, diffin_T *din)\n{\n    int\t\tr;\n    char_u\t*save_ff;\n    int\t\tsave_cmod_flags;\n\n    if (din->din_fname == NULL)\n\treturn diff_write_buffer(buf, din);\n\n    // Always use 'fileformat' set to \"unix\".\n    save_ff = buf->b_p_ff;\n    buf->b_p_ff = vim_strsave((char_u *)FF_UNIX);\n    save_cmod_flags = cmdmod.cmod_flags;\n    // Writing the buffer is an implementation detail of performing the diff,\n    // so it shouldn't update the '[ and '] marks.\n    cmdmod.cmod_flags |= CMOD_LOCKMARKS;\n    r = buf_write(buf, din->din_fname, NULL,\n\t\t\t(linenr_T)1, buf->b_ml.ml_line_count,\n\t\t\tNULL, FALSE, FALSE, FALSE, TRUE);\n    cmdmod.cmod_flags = save_cmod_flags;\n    free_string_option(buf->b_p_ff);\n    buf->b_p_ff = save_ff;\n    return r;\n}\n\n/*\n * Update the diffs for all buffers involved.\n */\n    static void\ndiff_try_update(\n\tdiffio_T    *dio,\n\tint\t    idx_orig,\n\texarg_T\t    *eap)\t// \"eap\" can be NULL\n{\n    buf_T\t*buf;\n    int\t\tidx_new;\n\n    if (dio->dio_internal)\n    {\n\tga_init2(&dio->dio_diff.dout_ga, sizeof(char *), 1000);\n    }\n    else\n    {\n\t// We need three temp file names.\n\tdio->dio_orig.din_fname = vim_tempname('o', TRUE);\n\tdio->dio_new.din_fname = vim_tempname('n', TRUE);\n\tdio->dio_diff.dout_fname = vim_tempname('d', TRUE);\n\tif (dio->dio_orig.din_fname == NULL\n\t\t|| dio->dio_new.din_fname == NULL\n\t\t|| dio->dio_diff.dout_fname == NULL)\n\t    goto theend;\n    }\n\n    // Check external diff is actually working.\n    if (!dio->dio_internal && check_external_diff(dio) == FAIL)\n\tgoto theend;\n\n    // :diffupdate!\n    if (eap != NULL && eap->forceit)\n\tfor (idx_new = idx_orig; idx_new < DB_COUNT; ++idx_new)\n\t{\n\t    buf = curtab->tp_diffbuf[idx_new];\n\t    if (buf_valid(buf))\n\t\tbuf_check_timestamp(buf, FALSE);\n\t}\n\n    // Write the first buffer to a tempfile or mmfile_t.\n    buf = curtab->tp_diffbuf[idx_orig];\n    if (diff_write(buf, &dio->dio_orig) == FAIL)\n\tgoto theend;\n\n    // Make a difference between the first buffer and every other.\n    for (idx_new = idx_orig + 1; idx_new < DB_COUNT; ++idx_new)\n    {\n\tbuf = curtab->tp_diffbuf[idx_new];\n\tif (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\t    continue; // skip buffer that isn't loaded\n\n\t// Write the other buffer and diff with the first one.\n\tif (diff_write(buf, &dio->dio_new) == FAIL)\n\t    continue;\n\tif (diff_file(dio) == FAIL)\n\t    continue;\n\n\t// Read the diff output and add each entry to the diff list.\n\tdiff_read(idx_orig, idx_new, dio);\n\n\tclear_diffin(&dio->dio_new);\n\tclear_diffout(&dio->dio_diff);\n    }\n    clear_diffin(&dio->dio_orig);\n\ntheend:\n    vim_free(dio->dio_orig.din_fname);\n    vim_free(dio->dio_new.din_fname);\n    vim_free(dio->dio_diff.dout_fname);\n}\n\n/*\n * Return TRUE if the options are set to use the internal diff library.\n * Note that if the internal diff failed for one of the buffers, the external\n * diff will be used anyway.\n */\n    int\ndiff_internal(void)\n{\n    return (diff_flags & DIFF_INTERNAL) != 0\n#ifdef FEAT_EVAL\n\t&& *p_dex == NUL\n#endif\n\t;\n}\n\n/*\n * Return TRUE if the internal diff failed for one of the diff buffers.\n */\n    static int\ndiff_internal_failed(void)\n{\n    int idx;\n\n    // Only need to do something when there is another buffer.\n    for (idx = 0; idx < DB_COUNT; ++idx)\n\tif (curtab->tp_diffbuf[idx] != NULL\n\t\t&& curtab->tp_diffbuf[idx]->b_diff_failed)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Completely update the diffs for the buffers involved.\n * When using the external \"diff\" command the buffers are written to a file,\n * also for unmodified buffers (the file could have been produced by\n * autocommands, e.g. the netrw plugin).\n */\n    void\nex_diffupdate(exarg_T *eap)\t// \"eap\" can be NULL\n{\n    int\t\tidx_orig;\n    int\t\tidx_new;\n    diffio_T\tdiffio;\n    int\t\thad_diffs = curtab->tp_first_diff != NULL;\n\n    if (diff_busy)\n    {\n\tdiff_need_update = TRUE;\n\treturn;\n    }\n\n    // Delete all diffblocks.\n    diff_clear(curtab);\n    curtab->tp_diff_invalid = FALSE;\n\n    // Use the first buffer as the original text.\n    for (idx_orig = 0; idx_orig < DB_COUNT; ++idx_orig)\n\tif (curtab->tp_diffbuf[idx_orig] != NULL)\n\t    break;\n    if (idx_orig == DB_COUNT)\n\tgoto theend;\n\n    // Only need to do something when there is another buffer.\n    for (idx_new = idx_orig + 1; idx_new < DB_COUNT; ++idx_new)\n\tif (curtab->tp_diffbuf[idx_new] != NULL)\n\t    break;\n    if (idx_new == DB_COUNT)\n\tgoto theend;\n\n    // Only use the internal method if it did not fail for one of the buffers.\n    CLEAR_FIELD(diffio);\n    diffio.dio_internal = diff_internal() && !diff_internal_failed();\n\n    diff_try_update(&diffio, idx_orig, eap);\n    if (diffio.dio_internal && diff_internal_failed())\n    {\n\t// Internal diff failed, use external diff instead.\n\tCLEAR_FIELD(diffio);\n\tdiff_try_update(&diffio, idx_orig, eap);\n    }\n\n    // force updating cursor position on screen\n    curwin->w_valid_cursor.lnum = 0;\n\ntheend:\n    // A redraw is needed if there were diffs and they were cleared, or there\n    // are diffs now, which means they got updated.\n    if (had_diffs || curtab->tp_first_diff != NULL)\n    {\n\tdiff_redraw(TRUE);\n\tapply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf);\n    }\n}\n\n/*\n * Do a quick test if \"diff\" really works.  Otherwise it looks like there\n * are no differences.  Can't use the return value, it's non-zero when\n * there are differences.\n */\n    static int\ncheck_external_diff(diffio_T *diffio)\n{\n    FILE\t*fd;\n    int\t\tok;\n    int\t\tio_error = FALSE;\n\n    // May try twice, first with \"-a\" and then without.\n    for (;;)\n    {\n\tok = FALSE;\n\tfd = mch_fopen((char *)diffio->dio_orig.din_fname, \"w\");\n\tif (fd == NULL)\n\t    io_error = TRUE;\n\telse\n\t{\n\t    if (fwrite(\"line1\\n\", (size_t)6, (size_t)1, fd) != 1)\n\t\tio_error = TRUE;\n\t    fclose(fd);\n\t    fd = mch_fopen((char *)diffio->dio_new.din_fname, \"w\");\n\t    if (fd == NULL)\n\t\tio_error = TRUE;\n\t    else\n\t    {\n\t\tif (fwrite(\"line2\\n\", (size_t)6, (size_t)1, fd) != 1)\n\t\t    io_error = TRUE;\n\t\tfclose(fd);\n\t\tfd = NULL;\n\t\tif (diff_file(diffio) == OK)\n\t\t    fd = mch_fopen((char *)diffio->dio_diff.dout_fname, \"r\");\n\t\tif (fd == NULL)\n\t\t    io_error = TRUE;\n\t\telse\n\t\t{\n\t\t    char_u\tlinebuf[LBUFLEN];\n\n\t\t    for (;;)\n\t\t    {\n\t\t\t// For normal diff there must be a line that contains\n\t\t\t// \"1c1\".  For unified diff \"@@ -1 +1 @@\".\n\t\t\tif (vim_fgets(linebuf, LBUFLEN, fd))\n\t\t\t    break;\n\t\t\tif (STRNCMP(linebuf, \"1c1\", 3) == 0\n\t\t\t\t|| STRNCMP(linebuf, \"@@ -1 +1 @@\", 11) == 0)\n\t\t\t    ok = TRUE;\n\t\t    }\n\t\t    fclose(fd);\n\t\t}\n\t\tmch_remove(diffio->dio_diff.dout_fname);\n\t\tmch_remove(diffio->dio_new.din_fname);\n\t    }\n\t    mch_remove(diffio->dio_orig.din_fname);\n\t}\n\n#ifdef FEAT_EVAL\n\t// When using 'diffexpr' break here.\n\tif (*p_dex != NUL)\n\t    break;\n#endif\n\n#if defined(MSWIN)\n\t// If the \"-a\" argument works, also check if \"--binary\" works.\n\tif (ok && diff_a_works == MAYBE && diff_bin_works == MAYBE)\n\t{\n\t    diff_a_works = TRUE;\n\t    diff_bin_works = TRUE;\n\t    continue;\n\t}\n\tif (!ok && diff_a_works == TRUE && diff_bin_works == TRUE)\n\t{\n\t    // Tried --binary, but it failed. \"-a\" works though.\n\t    diff_bin_works = FALSE;\n\t    ok = TRUE;\n\t}\n#endif\n\n\t// If we checked if \"-a\" works already, break here.\n\tif (diff_a_works != MAYBE)\n\t    break;\n\tdiff_a_works = ok;\n\n\t// If \"-a\" works break here, otherwise retry without \"-a\".\n\tif (ok)\n\t    break;\n    }\n    if (!ok)\n    {\n\tif (io_error)\n\t    emsg(_(e_cannot_read_or_write_temp_files));\n\temsg(_(e_cannot_create_diffs));\n\tdiff_a_works = MAYBE;\n#if defined(MSWIN)\n\tdiff_bin_works = MAYBE;\n#endif\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Invoke the xdiff function.\n */\n    static int\ndiff_file_internal(diffio_T *diffio)\n{\n    xpparam_t\t    param;\n    xdemitconf_t    emit_cfg;\n    xdemitcb_t\t    emit_cb;\n\n    CLEAR_FIELD(param);\n    CLEAR_FIELD(emit_cfg);\n    CLEAR_FIELD(emit_cb);\n\n    param.flags = diff_algorithm;\n\n    if (diff_flags & DIFF_IWHITE)\n\tparam.flags |= XDF_IGNORE_WHITESPACE_CHANGE;\n    if (diff_flags & DIFF_IWHITEALL)\n\tparam.flags |= XDF_IGNORE_WHITESPACE;\n    if (diff_flags & DIFF_IWHITEEOL)\n\tparam.flags |= XDF_IGNORE_WHITESPACE_AT_EOL;\n    if (diff_flags & DIFF_IBLANK)\n\tparam.flags |= XDF_IGNORE_BLANK_LINES;\n\n    emit_cfg.ctxlen = 0; // don't need any diff_context here\n    emit_cb.priv = &diffio->dio_diff;\n    emit_cfg.hunk_func = xdiff_out;\n    if (xdl_diff(&diffio->dio_orig.din_mmfile,\n\t\t&diffio->dio_new.din_mmfile,\n\t\t&param, &emit_cfg, &emit_cb) < 0)\n    {\n\temsg(_(e_problem_creating_internal_diff));\n\treturn FAIL;\n    }\n    return OK;\n}\n\n/*\n * Make a diff between files \"tmp_orig\" and \"tmp_new\", results in \"tmp_diff\".\n * return OK or FAIL;\n */\n    static int\ndiff_file(diffio_T *dio)\n{\n    char_u\t*cmd;\n    size_t\tlen;\n    char_u\t*tmp_orig = dio->dio_orig.din_fname;\n    char_u\t*tmp_new = dio->dio_new.din_fname;\n    char_u\t*tmp_diff = dio->dio_diff.dout_fname;\n\n#ifdef FEAT_EVAL\n    if (*p_dex != NUL)\n    {\n\t// Use 'diffexpr' to generate the diff file.\n\teval_diff(tmp_orig, tmp_new, tmp_diff);\n\treturn OK;\n    }\n    else\n#endif\n    // Use xdiff for generating the diff.\n    if (dio->dio_internal)\n    {\n\treturn diff_file_internal(dio);\n    }\n    else\n    {\n\tlen = STRLEN(tmp_orig) + STRLEN(tmp_new)\n\t\t\t\t      + STRLEN(tmp_diff) + STRLEN(p_srr) + 27;\n\tcmd = alloc(len);\n\tif (cmd == NULL)\n\t    return FAIL;\n\n\t// We don't want $DIFF_OPTIONS to get in the way.\n\tif (getenv(\"DIFF_OPTIONS\"))\n\t    vim_setenv((char_u *)\"DIFF_OPTIONS\", (char_u *)\"\");\n\n\t// Build the diff command and execute it.  Always use -a, binary\n\t// differences are of no use.  Ignore errors, diff returns\n\t// non-zero when differences have been found.\n\tvim_snprintf((char *)cmd, len, \"diff %s%s%s%s%s%s%s%s %s\",\n\t\tdiff_a_works == FALSE ? \"\" : \"-a \",\n#if defined(MSWIN)\n\t\tdiff_bin_works == TRUE ? \"--binary \" : \"\",\n#else\n\t\t\"\",\n#endif\n\t\t(diff_flags & DIFF_IWHITE) ? \"-b \" : \"\",\n\t\t(diff_flags & DIFF_IWHITEALL) ? \"-w \" : \"\",\n\t\t(diff_flags & DIFF_IWHITEEOL) ? \"-Z \" : \"\",\n\t\t(diff_flags & DIFF_IBLANK) ? \"-B \" : \"\",\n\t\t(diff_flags & DIFF_ICASE) ? \"-i \" : \"\",\n\t\ttmp_orig, tmp_new);\n\tappend_redir(cmd, (int)len, p_srr, tmp_diff);\n\tblock_autocmds();\t// avoid ShellCmdPost stuff\n\t(void)call_shell(cmd, SHELL_FILTER|SHELL_SILENT|SHELL_DOOUT);\n\tunblock_autocmds();\n\tvim_free(cmd);\n\treturn OK;\n    }\n}\n\n/*\n * Create a new version of a file from the current buffer and a diff file.\n * The buffer is written to a file, also for unmodified buffers (the file\n * could have been produced by autocommands, e.g. the netrw plugin).\n */\n    void\nex_diffpatch(exarg_T *eap)\n{\n    char_u\t*tmp_orig;\t// name of original temp file\n    char_u\t*tmp_new;\t// name of patched temp file\n    char_u\t*buf = NULL;\n    size_t\tbuflen;\n    win_T\t*old_curwin = curwin;\n    char_u\t*newname = NULL;\t// name of patched file buffer\n#ifdef UNIX\n    char_u\tdirbuf[MAXPATHL];\n    char_u\t*fullname = NULL;\n#endif\n#ifdef FEAT_BROWSE\n    char_u\t*browseFile = NULL;\n    int\t\tsave_cmod_flags = cmdmod.cmod_flags;\n#endif\n    stat_T\tst;\n    char_u\t*esc_name = NULL;\n\n#ifdef FEAT_BROWSE\n    if (cmdmod.cmod_flags & CMOD_BROWSE)\n    {\n\tbrowseFile = do_browse(0, (char_u *)_(\"Patch file\"),\n\t\t\t eap->arg, NULL, NULL,\n\t\t\t (char_u *)_(BROWSE_FILTER_ALL_FILES), NULL);\n\tif (browseFile == NULL)\n\t    return;\t\t// operation cancelled\n\teap->arg = browseFile;\n\tcmdmod.cmod_flags &= ~CMOD_BROWSE; // don't let do_ecmd() browse again\n    }\n#endif\n\n    // We need two temp file names.\n    tmp_orig = vim_tempname('o', FALSE);\n    tmp_new = vim_tempname('n', FALSE);\n    if (tmp_orig == NULL || tmp_new == NULL)\n\tgoto theend;\n\n    // Write the current buffer to \"tmp_orig\".\n    if (buf_write(curbuf, tmp_orig, NULL,\n\t\t(linenr_T)1, curbuf->b_ml.ml_line_count,\n\t\t\t\t     NULL, FALSE, FALSE, FALSE, TRUE) == FAIL)\n\tgoto theend;\n\n#ifdef UNIX\n    // Get the absolute path of the patchfile, changing directory below.\n    fullname = FullName_save(eap->arg, FALSE);\n#endif\n    esc_name = vim_strsave_shellescape(\n# ifdef UNIX\n\t\t    fullname != NULL ? fullname :\n# endif\n\t\t    eap->arg, TRUE, TRUE);\n    if (esc_name == NULL)\n\tgoto theend;\n    buflen = STRLEN(tmp_orig) + STRLEN(esc_name) + STRLEN(tmp_new) + 16;\n    buf = alloc(buflen);\n    if (buf == NULL)\n\tgoto theend;\n\n#ifdef UNIX\n    // Temporarily chdir to /tmp, to avoid patching files in the current\n    // directory when the patch file contains more than one patch.  When we\n    // have our own temp dir use that instead, it will be cleaned up when we\n    // exit (any .rej files created).  Don't change directory if we can't\n    // return to the current.\n    if (mch_dirname(dirbuf, MAXPATHL) != OK || mch_chdir((char *)dirbuf) != 0)\n\tdirbuf[0] = NUL;\n    else\n    {\n# ifdef TEMPDIRNAMES\n\tif (vim_tempdir != NULL)\n\t    vim_ignored = mch_chdir((char *)vim_tempdir);\n\telse\n# endif\n\t    vim_ignored = mch_chdir(\"/tmp\");\n\tshorten_fnames(TRUE);\n    }\n#endif\n\n#ifdef FEAT_EVAL\n    if (*p_pex != NUL)\n\t// Use 'patchexpr' to generate the new file.\n\teval_patch(tmp_orig,\n# ifdef UNIX\n\t\tfullname != NULL ? fullname :\n# endif\n\t\teap->arg, tmp_new);\n    else\n#endif\n    {\n\t// Build the patch command and execute it.  Ignore errors.  Switch to\n\t// cooked mode to allow the user to respond to prompts.\n\tvim_snprintf((char *)buf, buflen, \"patch -o %s %s < %s\",\n\t\t\t\t\t\t  tmp_new, tmp_orig, esc_name);\n\tblock_autocmds();\t// Avoid ShellCmdPost stuff\n\t(void)call_shell(buf, SHELL_FILTER | SHELL_COOKED);\n\tunblock_autocmds();\n    }\n\n#ifdef UNIX\n    if (dirbuf[0] != NUL)\n    {\n\tif (mch_chdir((char *)dirbuf) != 0)\n\t    emsg(_(e_cannot_go_back_to_previous_directory));\n\tshorten_fnames(TRUE);\n    }\n#endif\n\n    // patch probably has written over the screen\n    redraw_later(CLEAR);\n\n    // Delete any .orig or .rej file created.\n    STRCPY(buf, tmp_new);\n    STRCAT(buf, \".orig\");\n    mch_remove(buf);\n    STRCPY(buf, tmp_new);\n    STRCAT(buf, \".rej\");\n    mch_remove(buf);\n\n    // Only continue if the output file was created.\n    if (mch_stat((char *)tmp_new, &st) < 0 || st.st_size == 0)\n\temsg(_(e_cannot_read_patch_output));\n    else\n    {\n\tif (curbuf->b_fname != NULL)\n\t{\n\t    newname = vim_strnsave(curbuf->b_fname,\n\t\t\t\t\t\t  STRLEN(curbuf->b_fname) + 4);\n\t    if (newname != NULL)\n\t\tSTRCAT(newname, \".new\");\n\t}\n\n#ifdef FEAT_GUI\n\tneed_mouse_correct = TRUE;\n#endif\n\t// don't use a new tab page, each tab page has its own diffs\n\tcmdmod.cmod_tab = 0;\n\n\tif (win_split(0, (diff_flags & DIFF_VERTICAL) ? WSP_VERT : 0) != FAIL)\n\t{\n\t    // Pretend it was a \":split fname\" command\n\t    eap->cmdidx = CMD_split;\n\t    eap->arg = tmp_new;\n\t    do_exedit(eap, old_curwin);\n\n\t    // check that split worked and editing tmp_new\n\t    if (curwin != old_curwin && win_valid(old_curwin))\n\t    {\n\t\t// Set 'diff', 'scrollbind' on and 'wrap' off.\n\t\tdiff_win_options(curwin, TRUE);\n\t\tdiff_win_options(old_curwin, TRUE);\n\n\t\tif (newname != NULL)\n\t\t{\n\t\t    // do a \":file filename.new\" on the patched buffer\n\t\t    eap->arg = newname;\n\t\t    ex_file(eap);\n\n\t\t    // Do filetype detection with the new name.\n\t\t    if (au_has_group((char_u *)\"filetypedetect\"))\n\t\t\tdo_cmdline_cmd((char_u *)\":doau filetypedetect BufRead\");\n\t\t}\n\t    }\n\t}\n    }\n\ntheend:\n    if (tmp_orig != NULL)\n\tmch_remove(tmp_orig);\n    vim_free(tmp_orig);\n    if (tmp_new != NULL)\n\tmch_remove(tmp_new);\n    vim_free(tmp_new);\n    vim_free(newname);\n    vim_free(buf);\n#ifdef UNIX\n    vim_free(fullname);\n#endif\n    vim_free(esc_name);\n#ifdef FEAT_BROWSE\n    vim_free(browseFile);\n    cmdmod.cmod_flags = save_cmod_flags;\n#endif\n}\n\n/*\n * Split the window and edit another file, setting options to show the diffs.\n */\n    void\nex_diffsplit(exarg_T *eap)\n{\n    win_T\t*old_curwin = curwin;\n    bufref_T\told_curbuf;\n\n    set_bufref(&old_curbuf, curbuf);\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    // Need to compute w_fraction when no redraw happened yet.\n    validate_cursor();\n    set_fraction(curwin);\n\n    // don't use a new tab page, each tab page has its own diffs\n    cmdmod.cmod_tab = 0;\n\n    if (win_split(0, (diff_flags & DIFF_VERTICAL) ? WSP_VERT : 0) != FAIL)\n    {\n\t// Pretend it was a \":split fname\" command\n\teap->cmdidx = CMD_split;\n\tcurwin->w_p_diff = TRUE;\n\tdo_exedit(eap, old_curwin);\n\n\tif (curwin != old_curwin)\t\t// split must have worked\n\t{\n\t    // Set 'diff', 'scrollbind' on and 'wrap' off.\n\t    diff_win_options(curwin, TRUE);\n\t    if (win_valid(old_curwin))\n\t    {\n\t\tdiff_win_options(old_curwin, TRUE);\n\n\t\tif (bufref_valid(&old_curbuf))\n\t\t    // Move the cursor position to that of the old window.\n\t\t    curwin->w_cursor.lnum = diff_get_corresponding_line(\n\t\t\t    old_curbuf.br_buf, old_curwin->w_cursor.lnum);\n\t    }\n\t    // Now that lines are folded scroll to show the cursor at the same\n\t    // relative position.\n\t    scroll_to_fraction(curwin, curwin->w_height);\n\t}\n    }\n}\n\n/*\n * Set options to show diffs for the current window.\n */\n    void\nex_diffthis(exarg_T *eap UNUSED)\n{\n    // Set 'diff', 'scrollbind' on and 'wrap' off.\n    diff_win_options(curwin, TRUE);\n}\n\n    static void\nset_diff_option(win_T *wp, int value)\n{\n    win_T *old_curwin = curwin;\n\n    curwin = wp;\n    curbuf = curwin->w_buffer;\n    ++curbuf_lock;\n    set_option_value_give_err((char_u *)\"diff\", (long)value, NULL, OPT_LOCAL);\n    --curbuf_lock;\n    curwin = old_curwin;\n    curbuf = curwin->w_buffer;\n}\n\n/*\n * Set options in window \"wp\" for diff mode.\n */\n    void\ndiff_win_options(\n    win_T\t*wp,\n    int\t\taddbuf)\t\t// Add buffer to diff.\n{\n# ifdef FEAT_FOLDING\n    win_T *old_curwin = curwin;\n\n    // close the manually opened folds\n    curwin = wp;\n    newFoldLevel();\n    curwin = old_curwin;\n# endif\n\n    // Use 'scrollbind' and 'cursorbind' when available\n    if (!wp->w_p_diff)\n\twp->w_p_scb_save = wp->w_p_scb;\n    wp->w_p_scb = TRUE;\n    if (!wp->w_p_diff)\n\twp->w_p_crb_save = wp->w_p_crb;\n    wp->w_p_crb = TRUE;\n    if (!(diff_flags & DIFF_FOLLOWWRAP))\n    {\n\tif (!wp->w_p_diff)\n\t    wp->w_p_wrap_save = wp->w_p_wrap;\n\twp->w_p_wrap = FALSE;\n    }\n# ifdef FEAT_FOLDING\n    if (!wp->w_p_diff)\n    {\n\tif (wp->w_p_diff_saved)\n\t    free_string_option(wp->w_p_fdm_save);\n\twp->w_p_fdm_save = vim_strsave(wp->w_p_fdm);\n    }\n    set_string_option_direct_in_win(wp, (char_u *)\"fdm\", -1, (char_u *)\"diff\",\n\t\t\t\t\t\t       OPT_LOCAL|OPT_FREE, 0);\n    if (!wp->w_p_diff)\n    {\n\twp->w_p_fdc_save = wp->w_p_fdc;\n\twp->w_p_fen_save = wp->w_p_fen;\n\twp->w_p_fdl_save = wp->w_p_fdl;\n    }\n    wp->w_p_fdc = diff_foldcolumn;\n    wp->w_p_fen = TRUE;\n    wp->w_p_fdl = 0;\n    foldUpdateAll(wp);\n    // make sure topline is not halfway a fold\n    changed_window_setting_win(wp);\n# endif\n    if (vim_strchr(p_sbo, 'h') == NULL)\n\tdo_cmdline_cmd((char_u *)\"set sbo+=hor\");\n    // Save the current values, to be restored in ex_diffoff().\n    wp->w_p_diff_saved = TRUE;\n\n    set_diff_option(wp, TRUE);\n\n    if (addbuf)\n\tdiff_buf_add(wp->w_buffer);\n    redraw_win_later(wp, NOT_VALID);\n}\n\n/*\n * Set options not to show diffs.  For the current window or all windows.\n * Only in the current tab page.\n */\n    void\nex_diffoff(exarg_T *eap)\n{\n    win_T\t*wp;\n    int\t\tdiffwin = FALSE;\n\n    FOR_ALL_WINDOWS(wp)\n    {\n\tif (eap->forceit ? wp->w_p_diff : wp == curwin)\n\t{\n\t    // Set 'diff' off. If option values were saved in\n\t    // diff_win_options(), restore the ones whose settings seem to have\n\t    // been left over from diff mode.\n\t    set_diff_option(wp, FALSE);\n\n\t    if (wp->w_p_diff_saved)\n\t    {\n\n\t\tif (wp->w_p_scb)\n\t\t    wp->w_p_scb = wp->w_p_scb_save;\n\t\tif (wp->w_p_crb)\n\t\t    wp->w_p_crb = wp->w_p_crb_save;\n\t\tif (!(diff_flags & DIFF_FOLLOWWRAP))\n\t\t{\n\t\t    if (!wp->w_p_wrap)\n\t\t\twp->w_p_wrap = wp->w_p_wrap_save;\n\t\t}\n#ifdef FEAT_FOLDING\n\t\tfree_string_option(wp->w_p_fdm);\n\t\twp->w_p_fdm = vim_strsave(\n\t\t    *wp->w_p_fdm_save ? wp->w_p_fdm_save : (char_u*)\"manual\");\n\n\t\tif (wp->w_p_fdc == diff_foldcolumn)\n\t\t    wp->w_p_fdc = wp->w_p_fdc_save;\n\t\tif (wp->w_p_fdl == 0)\n\t\t    wp->w_p_fdl = wp->w_p_fdl_save;\n\n\t\t// Only restore 'foldenable' when 'foldmethod' is not\n\t\t// \"manual\", otherwise we continue to show the diff folds.\n\t\tif (wp->w_p_fen)\n\t\t    wp->w_p_fen = foldmethodIsManual(wp) ? FALSE\n\t\t\t\t\t\t\t : wp->w_p_fen_save;\n\n\t\tfoldUpdateAll(wp);\n#endif\n\t    }\n\t    // remove filler lines\n\t    wp->w_topfill = 0;\n\n\t    // make sure topline is not halfway a fold and cursor is\n\t    // invalidated\n\t    changed_window_setting_win(wp);\n\n\t    // Note: 'sbo' is not restored, it's a global option.\n\t    diff_buf_adjust(wp);\n\t}\n\tdiffwin |= wp->w_p_diff;\n    }\n\n    // Also remove hidden buffers from the list.\n    if (eap->forceit)\n\tdiff_buf_clear();\n\n    if (!diffwin)\n    {\n\tdiff_need_update = FALSE;\n\tcurtab->tp_diff_invalid = FALSE;\n\tcurtab->tp_diff_update = FALSE;\n\tdiff_clear(curtab);\n    }\n\n    // Remove \"hor\" from 'scrollopt' if there are no diff windows left.\n    if (!diffwin && vim_strchr(p_sbo, 'h') != NULL)\n\tdo_cmdline_cmd((char_u *)\"set sbo-=hor\");\n}\n\n/*\n * Read the diff output and add each entry to the diff list.\n */\n    static void\ndiff_read(\n    int\t\tidx_orig,\t// idx of original file\n    int\t\tidx_new,\t// idx of new file\n    diffio_T   *dio)\t\t// diff output\n{\n    FILE\t*fd = NULL;\n    int\t\tline_idx = 0;\n    diff_T\t*dprev = NULL;\n    diff_T\t*dp = curtab->tp_first_diff;\n    diff_T\t*dn, *dpl;\n    diffout_T   *dout = &dio->dio_diff;\n    char_u\tlinebuf[LBUFLEN];   // only need to hold the diff line\n    char_u\t*line;\n    long\toff;\n    int\t\ti;\n    int\t\tnotset = TRUE;\t    // block \"*dp\" not set yet\n    diffhunk_T\t*hunk = NULL;\t    // init to avoid gcc warning\n\n    enum {\n\tDIFF_ED,\n\tDIFF_UNIFIED,\n\tDIFF_NONE\n    } diffstyle = DIFF_NONE;\n\n    if (dout->dout_fname == NULL)\n    {\n\tdiffstyle = DIFF_UNIFIED;\n    }\n    else\n    {\n\tfd = mch_fopen((char *)dout->dout_fname, \"r\");\n\tif (fd == NULL)\n\t{\n\t    emsg(_(e_cannot_read_diff_output));\n\t    return;\n\t}\n    }\n\n    if (!dio->dio_internal)\n    {\n\thunk = ALLOC_ONE(diffhunk_T);\n\tif (hunk == NULL)\n\t{\n\t    if (fd != NULL)\n\t\tfclose(fd);\n\t    return;\n\t}\n    }\n\n    for (;;)\n    {\n\tif (dio->dio_internal)\n\t{\n\t    if (line_idx >= dout->dout_ga.ga_len) {\n\t\tbreak;      // did last line\n\t    }\n\t    hunk = ((diffhunk_T **)dout->dout_ga.ga_data)[line_idx++];\n\t}\n\telse\n\t{\n\t    if (fd == NULL)\n\t    {\n\t\tif (line_idx >= dout->dout_ga.ga_len)\n\t\t    break;\t    // did last line\n\t\tline = ((char_u **)dout->dout_ga.ga_data)[line_idx++];\n\t    }\n\t    else\n\t    {\n\t\tif (vim_fgets(linebuf, LBUFLEN, fd))\n\t\t    break;\t\t// end of file\n\t\tline = linebuf;\n\t    }\n\n\t    if (diffstyle == DIFF_NONE)\n\t    {\n\t\t// Determine diff style.\n\t\t// ed like diff looks like this:\n\t\t// {first}[,{last}]c{first}[,{last}]\n\t\t// {first}a{first}[,{last}]\n\t\t// {first}[,{last}]d{first}\n\t\t//\n\t\t// unified diff looks like this:\n\t\t// --- file1       2018-03-20 13:23:35.783153140 +0100\n\t\t// +++ file2       2018-03-20 13:23:41.183156066 +0100\n\t\t// @@ -1,3 +1,5 @@\n\t\tif (isdigit(*line))\n\t\t    diffstyle = DIFF_ED;\n\t\telse if ((STRNCMP(line, \"@@ \", 3) == 0))\n\t\t    diffstyle = DIFF_UNIFIED;\n\t\telse if ((STRNCMP(line, \"--- \", 4) == 0)\n\t\t\t&& (vim_fgets(linebuf, LBUFLEN, fd) == 0)\n\t\t\t&& (STRNCMP(line, \"+++ \", 4) == 0)\n\t\t\t&& (vim_fgets(linebuf, LBUFLEN, fd) == 0)\n\t\t\t&& (STRNCMP(line, \"@@ \", 3) == 0))\n\t\t    diffstyle = DIFF_UNIFIED;\n\t\telse\n\t\t    // Format not recognized yet, skip over this line.  Cygwin\n\t\t    // diff may put a warning at the start of the file.\n\t\t    continue;\n\t    }\n\n\t    if (diffstyle == DIFF_ED)\n\t    {\n\t\tif (!isdigit(*line))\n\t\t    continue;\t// not the start of a diff block\n\t\tif (parse_diff_ed(line, hunk) == FAIL)\n\t\t    continue;\n\t    }\n\t    else if (diffstyle == DIFF_UNIFIED)\n\t    {\n\t\tif (STRNCMP(line, \"@@ \", 3)  != 0)\n\t\t    continue;\t// not the start of a diff block\n\t\tif (parse_diff_unified(line, hunk) == FAIL)\n\t\t    continue;\n\t    }\n\t    else\n\t    {\n\t\temsg(_(e_invalid_diff_format));\n\t\tbreak;\n\t    }\n\t}\n\n\t// Go over blocks before the change, for which orig and new are equal.\n\t// Copy blocks from orig to new.\n\twhile (dp != NULL\n\t\t&& hunk->lnum_orig > dp->df_lnum[idx_orig]\n\t\t\t\t\t\t      + dp->df_count[idx_orig])\n\t{\n\t    if (notset)\n\t\tdiff_copy_entry(dprev, dp, idx_orig, idx_new);\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t    notset = TRUE;\n\t}\n\n\tif (dp != NULL\n\t\t&& hunk->lnum_orig <= dp->df_lnum[idx_orig]\n\t\t\t\t\t\t       + dp->df_count[idx_orig]\n\t\t&& hunk->lnum_orig + hunk->count_orig >= dp->df_lnum[idx_orig])\n\t{\n\t    // New block overlaps with existing block(s).\n\t    // First find last block that overlaps.\n\t    for (dpl = dp; dpl->df_next != NULL; dpl = dpl->df_next)\n\t\tif (hunk->lnum_orig + hunk->count_orig\n\t\t\t\t\t     < dpl->df_next->df_lnum[idx_orig])\n\t\t    break;\n\n\t    // If the newly found block starts before the old one, set the\n\t    // start back a number of lines.\n\t    off = dp->df_lnum[idx_orig] - hunk->lnum_orig;\n\t    if (off > 0)\n\t    {\n\t\tfor (i = idx_orig; i < idx_new; ++i)\n\t\t    if (curtab->tp_diffbuf[i] != NULL)\n\t\t\tdp->df_lnum[i] -= off;\n\t\tdp->df_lnum[idx_new] = hunk->lnum_new;\n\t\tdp->df_count[idx_new] = hunk->count_new;\n\t    }\n\t    else if (notset)\n\t    {\n\t\t// new block inside existing one, adjust new block\n\t\tdp->df_lnum[idx_new] = hunk->lnum_new + off;\n\t\tdp->df_count[idx_new] = hunk->count_new - off;\n\t    }\n\t    else\n\t\t// second overlap of new block with existing block\n\t\tdp->df_count[idx_new] += hunk->count_new - hunk->count_orig\n\t\t    + dpl->df_lnum[idx_orig] + dpl->df_count[idx_orig]\n\t\t    - (dp->df_lnum[idx_orig] + dp->df_count[idx_orig]);\n\n\t    // Adjust the size of the block to include all the lines to the\n\t    // end of the existing block or the new diff, whatever ends last.\n\t    off = (hunk->lnum_orig + hunk->count_orig)\n\t\t\t - (dpl->df_lnum[idx_orig] + dpl->df_count[idx_orig]);\n\t    if (off < 0)\n\t    {\n\t\t// new change ends in existing block, adjust the end if not\n\t\t// done already\n\t\tif (notset)\n\t\t    dp->df_count[idx_new] += -off;\n\t\toff = 0;\n\t    }\n\t    for (i = idx_orig; i < idx_new; ++i)\n\t\tif (curtab->tp_diffbuf[i] != NULL)\n\t\t    dp->df_count[i] = dpl->df_lnum[i] + dpl->df_count[i]\n\t\t\t\t\t\t       - dp->df_lnum[i] + off;\n\n\t    // Delete the diff blocks that have been merged into one.\n\t    dn = dp->df_next;\n\t    dp->df_next = dpl->df_next;\n\t    while (dn != dp->df_next)\n\t    {\n\t\tdpl = dn->df_next;\n\t\tvim_free(dn);\n\t\tdn = dpl;\n\t    }\n\t}\n\telse\n\t{\n\t    // Allocate a new diffblock.\n\t    dp = diff_alloc_new(curtab, dprev, dp);\n\t    if (dp == NULL)\n\t\tgoto done;\n\n\t    dp->df_lnum[idx_orig] = hunk->lnum_orig;\n\t    dp->df_count[idx_orig] = hunk->count_orig;\n\t    dp->df_lnum[idx_new] = hunk->lnum_new;\n\t    dp->df_count[idx_new] = hunk->count_new;\n\n\t    // Set values for other buffers, these must be equal to the\n\t    // original buffer, otherwise there would have been a change\n\t    // already.\n\t    for (i = idx_orig + 1; i < idx_new; ++i)\n\t\tif (curtab->tp_diffbuf[i] != NULL)\n\t\t    diff_copy_entry(dprev, dp, idx_orig, i);\n\t}\n\tnotset = FALSE;\t\t// \"*dp\" has been set\n    }\n\n    // for remaining diff blocks orig and new are equal\n    while (dp != NULL)\n    {\n\tif (notset)\n\t    diff_copy_entry(dprev, dp, idx_orig, idx_new);\n\tdprev = dp;\n\tdp = dp->df_next;\n\tnotset = TRUE;\n    }\n\ndone:\n    if (!dio->dio_internal)\n\tvim_free(hunk);\n\n    if (fd != NULL)\n\tfclose(fd);\n}\n\n/*\n * Copy an entry at \"dp\" from \"idx_orig\" to \"idx_new\".\n */\n    static void\ndiff_copy_entry(\n    diff_T\t*dprev,\n    diff_T\t*dp,\n    int\t\tidx_orig,\n    int\t\tidx_new)\n{\n    long\toff;\n\n    if (dprev == NULL)\n\toff = 0;\n    else\n\toff = (dprev->df_lnum[idx_orig] + dprev->df_count[idx_orig])\n\t    - (dprev->df_lnum[idx_new] + dprev->df_count[idx_new]);\n    dp->df_lnum[idx_new] = dp->df_lnum[idx_orig] - off;\n    dp->df_count[idx_new] = dp->df_count[idx_orig];\n}\n\n/*\n * Clear the list of diffblocks for tab page \"tp\".\n */\n    void\ndiff_clear(tabpage_T *tp)\n{\n    diff_T\t*p, *next_p;\n\n    for (p = tp->tp_first_diff; p != NULL; p = next_p)\n    {\n\tnext_p = p->df_next;\n\tvim_free(p);\n    }\n    tp->tp_first_diff = NULL;\n}\n\n/*\n * Check diff status for line \"lnum\" in buffer \"buf\":\n * Returns 0 for nothing special\n * Returns -1 for a line that should be highlighted as changed.\n * Returns -2 for a line that should be highlighted as added/deleted.\n * Returns > 0 for inserting that many filler lines above it (never happens\n * when 'diffopt' doesn't contain \"filler\").\n * This should only be used for windows where 'diff' is set.\n */\n    int\ndiff_check(win_T *wp, linenr_T lnum)\n{\n    int\t\tidx;\t\t// index in tp_diffbuf[] for this buffer\n    diff_T\t*dp;\n    int\t\tmaxcount;\n    int\t\ti;\n    buf_T\t*buf = wp->w_buffer;\n    int\t\tcmp;\n\n    if (curtab->tp_diff_invalid)\n\tex_diffupdate(NULL);\t\t// update after a big change\n\n    if (curtab->tp_first_diff == NULL || !wp->w_p_diff)\t// no diffs at all\n\treturn 0;\n\n    // safety check: \"lnum\" must be a buffer line\n    if (lnum < 1 || lnum > buf->b_ml.ml_line_count + 1)\n\treturn 0;\n\n    idx = diff_buf_idx(buf);\n    if (idx == DB_COUNT)\n\treturn 0;\t\t// no diffs for buffer \"buf\"\n\n#ifdef FEAT_FOLDING\n    // A closed fold never has filler lines.\n    if (hasFoldingWin(wp, lnum, NULL, NULL, TRUE, NULL))\n\treturn 0;\n#endif\n\n    // search for a change that includes \"lnum\" in the list of diffblocks.\n    FOR_ALL_DIFFBLOCKS_IN_TAB(curtab, dp)\n\tif (lnum <= dp->df_lnum[idx] + dp->df_count[idx])\n\t    break;\n    if (dp == NULL || lnum < dp->df_lnum[idx])\n\treturn 0;\n\n    if (lnum < dp->df_lnum[idx] + dp->df_count[idx])\n    {\n\tint\tzero = FALSE;\n\n\t// Changed or inserted line.  If the other buffers have a count of\n\t// zero, the lines were inserted.  If the other buffers have the same\n\t// count, check if the lines are identical.\n\tcmp = FALSE;\n\tfor (i = 0; i < DB_COUNT; ++i)\n\t    if (i != idx && curtab->tp_diffbuf[i] != NULL)\n\t    {\n\t\tif (dp->df_count[i] == 0)\n\t\t    zero = TRUE;\n\t\telse\n\t\t{\n\t\t    if (dp->df_count[i] != dp->df_count[idx])\n\t\t\treturn -1;\t    // nr of lines changed.\n\t\t    cmp = TRUE;\n\t\t}\n\t    }\n\tif (cmp)\n\t{\n\t    // Compare all lines.  If they are equal the lines were inserted\n\t    // in some buffers, deleted in others, but not changed.\n\t    for (i = 0; i < DB_COUNT; ++i)\n\t\tif (i != idx && curtab->tp_diffbuf[i] != NULL\n\t\t\t\t\t\t      && dp->df_count[i] != 0)\n\t\t    if (!diff_equal_entry(dp, idx, i))\n\t\t\treturn -1;\n\t}\n\t// If there is no buffer with zero lines then there is no difference\n\t// any longer.  Happens when making a change (or undo) that removes\n\t// the difference.  Can't remove the entry here, we might be halfway\n\t// updating the window.  Just report the text as unchanged.  Other\n\t// windows might still show the change though.\n\tif (zero == FALSE)\n\t    return 0;\n\treturn -2;\n    }\n\n    // If 'diffopt' doesn't contain \"filler\", return 0.\n    if (!(diff_flags & DIFF_FILLER))\n\treturn 0;\n\n    // Insert filler lines above the line just below the change.  Will return\n    // 0 when this buf had the max count.\n    maxcount = 0;\n    for (i = 0; i < DB_COUNT; ++i)\n\tif (curtab->tp_diffbuf[i] != NULL && dp->df_count[i] > maxcount)\n\t    maxcount = dp->df_count[i];\n    return maxcount - dp->df_count[idx];\n}\n\n/*\n * Compare two entries in diff \"*dp\" and return TRUE if they are equal.\n */\n    static int\ndiff_equal_entry(diff_T *dp, int idx1, int idx2)\n{\n    int\t\ti;\n    char_u\t*line;\n    int\t\tcmp;\n\n    if (dp->df_count[idx1] != dp->df_count[idx2])\n\treturn FALSE;\n    if (diff_check_sanity(curtab, dp) == FAIL)\n\treturn FALSE;\n    for (i = 0; i < dp->df_count[idx1]; ++i)\n    {\n\tline = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx1],\n\t\t\t\t\t       dp->df_lnum[idx1] + i, FALSE));\n\tif (line == NULL)\n\t    return FALSE;\n\tcmp = diff_cmp(line, ml_get_buf(curtab->tp_diffbuf[idx2],\n\t\t\t\t\t       dp->df_lnum[idx2] + i, FALSE));\n\tvim_free(line);\n\tif (cmp != 0)\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Compare the characters at \"p1\" and \"p2\".  If they are equal (possibly\n * ignoring case) return TRUE and set \"len\" to the number of bytes.\n */\n    static int\ndiff_equal_char(char_u *p1, char_u *p2, int *len)\n{\n    int l  = (*mb_ptr2len)(p1);\n\n    if (l != (*mb_ptr2len)(p2))\n\treturn FALSE;\n    if (l > 1)\n    {\n\tif (STRNCMP(p1, p2, l) != 0\n\t\t&& (!enc_utf8\n\t\t    || !(diff_flags & DIFF_ICASE)\n\t\t    || utf_fold(utf_ptr2char(p1))\n\t\t\t\t\t\t!= utf_fold(utf_ptr2char(p2))))\n\t    return FALSE;\n\t*len = l;\n    }\n    else\n    {\n\tif ((*p1 != *p2)\n\t\t&& (!(diff_flags & DIFF_ICASE)\n\t\t    || TOLOWER_LOC(*p1) != TOLOWER_LOC(*p2)))\n\t    return FALSE;\n\t*len = 1;\n    }\n    return TRUE;\n}\n\n/*\n * Compare strings \"s1\" and \"s2\" according to 'diffopt'.\n * Return non-zero when they are different.\n */\n    static int\ndiff_cmp(char_u *s1, char_u *s2)\n{\n    char_u\t*p1, *p2;\n    int\t\tl;\n\n    if ((diff_flags & DIFF_IBLANK)\n\t    && (*skipwhite(s1) == NUL || *skipwhite(s2) == NUL))\n\treturn 0;\n\n    if ((diff_flags & (DIFF_ICASE | ALL_WHITE_DIFF)) == 0)\n\treturn STRCMP(s1, s2);\n    if ((diff_flags & DIFF_ICASE) && !(diff_flags & ALL_WHITE_DIFF))\n\treturn MB_STRICMP(s1, s2);\n\n    p1 = s1;\n    p2 = s2;\n\n    // Ignore white space changes and possibly ignore case.\n    while (*p1 != NUL && *p2 != NUL)\n    {\n\tif (((diff_flags & DIFF_IWHITE)\n\t\t    && VIM_ISWHITE(*p1) && VIM_ISWHITE(*p2))\n\t\t|| ((diff_flags & DIFF_IWHITEALL)\n\t\t    && (VIM_ISWHITE(*p1) || VIM_ISWHITE(*p2))))\n\t{\n\t    p1 = skipwhite(p1);\n\t    p2 = skipwhite(p2);\n\t}\n\telse\n\t{\n\t    if (!diff_equal_char(p1, p2, &l))\n\t\tbreak;\n\t    p1 += l;\n\t    p2 += l;\n\t}\n    }\n\n    // Ignore trailing white space.\n    p1 = skipwhite(p1);\n    p2 = skipwhite(p2);\n    if (*p1 != NUL || *p2 != NUL)\n\treturn 1;\n    return 0;\n}\n\n/*\n * Return the number of filler lines above \"lnum\".\n */\n    int\ndiff_check_fill(win_T *wp, linenr_T lnum)\n{\n    int\t\tn;\n\n    // be quick when there are no filler lines\n    if (!(diff_flags & DIFF_FILLER))\n\treturn 0;\n    n = diff_check(wp, lnum);\n    if (n <= 0)\n\treturn 0;\n    return n;\n}\n\n/*\n * Set the topline of \"towin\" to match the position in \"fromwin\", so that they\n * show the same diff'ed lines.\n */\n    void\ndiff_set_topline(win_T *fromwin, win_T *towin)\n{\n    buf_T\t*frombuf = fromwin->w_buffer;\n    linenr_T\tlnum = fromwin->w_topline;\n    int\t\tfromidx;\n    int\t\ttoidx;\n    diff_T\t*dp;\n    int\t\tmax_count;\n    int\t\ti;\n\n    fromidx = diff_buf_idx(frombuf);\n    if (fromidx == DB_COUNT)\n\treturn;\t\t// safety check\n\n    if (curtab->tp_diff_invalid)\n\tex_diffupdate(NULL);\t\t// update after a big change\n\n    towin->w_topfill = 0;\n\n    // search for a change that includes \"lnum\" in the list of diffblocks.\n    FOR_ALL_DIFFBLOCKS_IN_TAB(curtab, dp)\n\tif (lnum <= dp->df_lnum[fromidx] + dp->df_count[fromidx])\n\t    break;\n    if (dp == NULL)\n    {\n\t// After last change, compute topline relative to end of file; no\n\t// filler lines.\n\ttowin->w_topline = towin->w_buffer->b_ml.ml_line_count\n\t\t\t\t       - (frombuf->b_ml.ml_line_count - lnum);\n    }\n    else\n    {\n\t// Find index for \"towin\".\n\ttoidx = diff_buf_idx(towin->w_buffer);\n\tif (toidx == DB_COUNT)\n\t    return;\t\t// safety check\n\n\ttowin->w_topline = lnum + (dp->df_lnum[toidx] - dp->df_lnum[fromidx]);\n\tif (lnum >= dp->df_lnum[fromidx])\n\t{\n\t    // Inside a change: compute filler lines. With three or more\n\t    // buffers we need to know the largest count.\n\t    max_count = 0;\n\t    for (i = 0; i < DB_COUNT; ++i)\n\t\tif (curtab->tp_diffbuf[i] != NULL\n\t\t\t\t\t       && max_count < dp->df_count[i])\n\t\t    max_count = dp->df_count[i];\n\n\t    if (dp->df_count[toidx] == dp->df_count[fromidx])\n\t    {\n\t\t// same number of lines: use same filler count\n\t\ttowin->w_topfill = fromwin->w_topfill;\n\t    }\n\t    else if (dp->df_count[toidx] > dp->df_count[fromidx])\n\t    {\n\t\tif (lnum == dp->df_lnum[fromidx] + dp->df_count[fromidx])\n\t\t{\n\t\t    // more lines in towin and fromwin doesn't show diff\n\t\t    // lines, only filler lines\n\t\t    if (max_count - fromwin->w_topfill >= dp->df_count[toidx])\n\t\t    {\n\t\t\t// towin also only shows filler lines\n\t\t\ttowin->w_topline = dp->df_lnum[toidx]\n\t\t\t\t\t\t       + dp->df_count[toidx];\n\t\t\ttowin->w_topfill = fromwin->w_topfill;\n\t\t    }\n\t\t    else\n\t\t\t// towin still has some diff lines to show\n\t\t\ttowin->w_topline = dp->df_lnum[toidx]\n\t\t\t\t\t     + max_count - fromwin->w_topfill;\n\t\t}\n\t    }\n\t    else if (towin->w_topline >= dp->df_lnum[toidx]\n\t\t\t\t\t\t\t+ dp->df_count[toidx])\n\t    {\n\t\t// less lines in towin and no diff lines to show: compute\n\t\t// filler lines\n\t\ttowin->w_topline = dp->df_lnum[toidx] + dp->df_count[toidx];\n\t\tif (diff_flags & DIFF_FILLER)\n\t\t{\n\t\t    if (lnum == dp->df_lnum[fromidx] + dp->df_count[fromidx])\n\t\t\t// fromwin is also out of diff lines\n\t\t\ttowin->w_topfill = fromwin->w_topfill;\n\t\t    else\n\t\t\t// fromwin has some diff lines\n\t\t\ttowin->w_topfill = dp->df_lnum[fromidx]\n\t\t\t\t\t\t\t   + max_count - lnum;\n\t\t}\n\t    }\n\t}\n    }\n\n    // safety check (if diff info gets outdated strange things may happen)\n    towin->w_botfill = FALSE;\n    if (towin->w_topline > towin->w_buffer->b_ml.ml_line_count)\n    {\n\ttowin->w_topline = towin->w_buffer->b_ml.ml_line_count;\n\ttowin->w_botfill = TRUE;\n    }\n    if (towin->w_topline < 1)\n    {\n\ttowin->w_topline = 1;\n\ttowin->w_topfill = 0;\n    }\n\n    // When w_topline changes need to recompute w_botline and cursor position\n    invalidate_botline_win(towin);\n    changed_line_abv_curs_win(towin);\n\n    check_topfill(towin, FALSE);\n#ifdef FEAT_FOLDING\n    (void)hasFoldingWin(towin, towin->w_topline, &towin->w_topline,\n\t\t\t\t\t\t\t    NULL, TRUE, NULL);\n#endif\n}\n\n/*\n * This is called when 'diffopt' is changed.\n */\n    int\ndiffopt_changed(void)\n{\n    char_u\t*p;\n    int\t\tdiff_context_new = 6;\n    int\t\tdiff_flags_new = 0;\n    int\t\tdiff_foldcolumn_new = 2;\n    long\tdiff_algorithm_new = 0;\n    long\tdiff_indent_heuristic = 0;\n    tabpage_T\t*tp;\n\n    p = p_dip;\n    while (*p != NUL)\n    {\n\tif (STRNCMP(p, \"filler\", 6) == 0)\n\t{\n\t    p += 6;\n\t    diff_flags_new |= DIFF_FILLER;\n\t}\n\telse if (STRNCMP(p, \"context:\", 8) == 0 && VIM_ISDIGIT(p[8]))\n\t{\n\t    p += 8;\n\t    diff_context_new = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"iblank\", 6) == 0)\n\t{\n\t    p += 6;\n\t    diff_flags_new |= DIFF_IBLANK;\n\t}\n\telse if (STRNCMP(p, \"icase\", 5) == 0)\n\t{\n\t    p += 5;\n\t    diff_flags_new |= DIFF_ICASE;\n\t}\n\telse if (STRNCMP(p, \"iwhiteall\", 9) == 0)\n\t{\n\t    p += 9;\n\t    diff_flags_new |= DIFF_IWHITEALL;\n\t}\n\telse if (STRNCMP(p, \"iwhiteeol\", 9) == 0)\n\t{\n\t    p += 9;\n\t    diff_flags_new |= DIFF_IWHITEEOL;\n\t}\n\telse if (STRNCMP(p, \"iwhite\", 6) == 0)\n\t{\n\t    p += 6;\n\t    diff_flags_new |= DIFF_IWHITE;\n\t}\n\telse if (STRNCMP(p, \"horizontal\", 10) == 0)\n\t{\n\t    p += 10;\n\t    diff_flags_new |= DIFF_HORIZONTAL;\n\t}\n\telse if (STRNCMP(p, \"vertical\", 8) == 0)\n\t{\n\t    p += 8;\n\t    diff_flags_new |= DIFF_VERTICAL;\n\t}\n\telse if (STRNCMP(p, \"foldcolumn:\", 11) == 0 && VIM_ISDIGIT(p[11]))\n\t{\n\t    p += 11;\n\t    diff_foldcolumn_new = getdigits(&p);\n\t}\n\telse if (STRNCMP(p, \"hiddenoff\", 9) == 0)\n\t{\n\t    p += 9;\n\t    diff_flags_new |= DIFF_HIDDEN_OFF;\n\t}\n\telse if (STRNCMP(p, \"closeoff\", 8) == 0)\n\t{\n\t    p += 8;\n\t    diff_flags_new |= DIFF_CLOSE_OFF;\n\t}\n\telse if (STRNCMP(p, \"followwrap\", 10) == 0)\n\t{\n\t    p += 10;\n\t    diff_flags_new |= DIFF_FOLLOWWRAP;\n\t}\n\telse if (STRNCMP(p, \"indent-heuristic\", 16) == 0)\n\t{\n\t    p += 16;\n\t    diff_indent_heuristic = XDF_INDENT_HEURISTIC;\n\t}\n\telse if (STRNCMP(p, \"internal\", 8) == 0)\n\t{\n\t    p += 8;\n\t    diff_flags_new |= DIFF_INTERNAL;\n\t}\n\telse if (STRNCMP(p, \"algorithm:\", 10) == 0)\n\t{\n\t    p += 10;\n\t    if (STRNCMP(p, \"myers\", 5) == 0)\n\t    {\n\t\tp += 5;\n\t\tdiff_algorithm_new = 0;\n\t    }\n\t    else if (STRNCMP(p, \"minimal\", 7) == 0)\n\t    {\n\t\tp += 7;\n\t\tdiff_algorithm_new = XDF_NEED_MINIMAL;\n\t    }\n\t    else if (STRNCMP(p, \"patience\", 8) == 0)\n\t    {\n\t\tp += 8;\n\t\tdiff_algorithm_new = XDF_PATIENCE_DIFF;\n\t    }\n\t    else if (STRNCMP(p, \"histogram\", 9) == 0)\n\t    {\n\t\tp += 9;\n\t\tdiff_algorithm_new = XDF_HISTOGRAM_DIFF;\n\t    }\n\t    else\n\t\treturn FAIL;\n\t}\n\n\tif (*p != ',' && *p != NUL)\n\t    return FAIL;\n\tif (*p == ',')\n\t    ++p;\n    }\n\n    diff_algorithm_new |= diff_indent_heuristic;\n\n    // Can't have both \"horizontal\" and \"vertical\".\n    if ((diff_flags_new & DIFF_HORIZONTAL) && (diff_flags_new & DIFF_VERTICAL))\n\treturn FAIL;\n\n    // If flags were added or removed, or the algorithm was changed, need to\n    // update the diff.\n    if (diff_flags != diff_flags_new || diff_algorithm != diff_algorithm_new)\n\tFOR_ALL_TABPAGES(tp)\n\t    tp->tp_diff_invalid = TRUE;\n\n    diff_flags = diff_flags_new;\n    diff_context = diff_context_new == 0 ? 1 : diff_context_new;\n    diff_foldcolumn = diff_foldcolumn_new;\n    diff_algorithm = diff_algorithm_new;\n\n    diff_redraw(TRUE);\n\n    // recompute the scroll binding with the new option value, may\n    // remove or add filler lines\n    check_scrollbind((linenr_T)0, 0L);\n\n    return OK;\n}\n\n/*\n * Return TRUE if 'diffopt' contains \"horizontal\".\n */\n    int\ndiffopt_horizontal(void)\n{\n    return (diff_flags & DIFF_HORIZONTAL) != 0;\n}\n\n/*\n * Return TRUE if 'diffopt' contains \"hiddenoff\".\n */\n    int\ndiffopt_hiddenoff(void)\n{\n    return (diff_flags & DIFF_HIDDEN_OFF) != 0;\n}\n\n/*\n * Return TRUE if 'diffopt' contains \"closeoff\".\n */\n    int\ndiffopt_closeoff(void)\n{\n    return (diff_flags & DIFF_CLOSE_OFF) != 0;\n}\n\n/*\n * Find the difference within a changed line.\n * Returns TRUE if the line was added, no other buffer has it.\n */\n    int\ndiff_find_change(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    int\t\t*startp,\t// first char of the change\n    int\t\t*endp)\t\t// last char of the change\n{\n    char_u\t*line_org;\n    char_u\t*line_new;\n    int\t\ti;\n    int\t\tsi_org, si_new;\n    int\t\tei_org, ei_new;\n    diff_T\t*dp;\n    int\t\tidx;\n    int\t\toff;\n    int\t\tadded = TRUE;\n    char_u\t*p1, *p2;\n    int\t\tl;\n\n    // Make a copy of the line, the next ml_get() will invalidate it.\n    line_org = vim_strsave(ml_get_buf(wp->w_buffer, lnum, FALSE));\n    if (line_org == NULL)\n\treturn FALSE;\n\n    idx = diff_buf_idx(wp->w_buffer);\n    if (idx == DB_COUNT)\t// cannot happen\n    {\n\tvim_free(line_org);\n\treturn FALSE;\n    }\n\n    // search for a change that includes \"lnum\" in the list of diffblocks.\n    FOR_ALL_DIFFBLOCKS_IN_TAB(curtab, dp)\n\tif (lnum <= dp->df_lnum[idx] + dp->df_count[idx])\n\t    break;\n    if (dp == NULL || diff_check_sanity(curtab, dp) == FAIL)\n    {\n\tvim_free(line_org);\n\treturn FALSE;\n    }\n\n    off = lnum - dp->df_lnum[idx];\n\n    for (i = 0; i < DB_COUNT; ++i)\n\tif (curtab->tp_diffbuf[i] != NULL && i != idx)\n\t{\n\t    // Skip lines that are not in the other change (filler lines).\n\t    if (off >= dp->df_count[i])\n\t\tcontinue;\n\t    added = FALSE;\n\t    line_new = ml_get_buf(curtab->tp_diffbuf[i],\n\t\t\t\t\t\t dp->df_lnum[i] + off, FALSE);\n\n\t    // Search for start of difference\n\t    si_org = si_new = 0;\n\t    while (line_org[si_org] != NUL)\n\t    {\n\t\tif (((diff_flags & DIFF_IWHITE)\n\t\t\t    && VIM_ISWHITE(line_org[si_org])\n\t\t\t\t\t      && VIM_ISWHITE(line_new[si_new]))\n\t\t\t|| ((diff_flags & DIFF_IWHITEALL)\n\t\t\t    && (VIM_ISWHITE(line_org[si_org])\n\t\t\t\t\t    || VIM_ISWHITE(line_new[si_new]))))\n\t\t{\n\t\t    si_org = (int)(skipwhite(line_org + si_org) - line_org);\n\t\t    si_new = (int)(skipwhite(line_new + si_new) - line_new);\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (!diff_equal_char(line_org + si_org, line_new + si_new,\n\t\t\t\t\t\t\t\t\t   &l))\n\t\t\tbreak;\n\t\t    si_org += l;\n\t\t    si_new += l;\n\t\t}\n\t    }\n\t    if (has_mbyte)\n\t    {\n\t\t// Move back to first byte of character in both lines (may\n\t\t// have \"nn^\" in line_org and \"n^ in line_new).\n\t\tsi_org -= (*mb_head_off)(line_org, line_org + si_org);\n\t\tsi_new -= (*mb_head_off)(line_new, line_new + si_new);\n\t    }\n\t    if (*startp > si_org)\n\t\t*startp = si_org;\n\n\t    // Search for end of difference, if any.\n\t    if (line_org[si_org] != NUL || line_new[si_new] != NUL)\n\t    {\n\t\tei_org = (int)STRLEN(line_org);\n\t\tei_new = (int)STRLEN(line_new);\n\t\twhile (ei_org >= *startp && ei_new >= si_new\n\t\t\t\t\t\t&& ei_org >= 0 && ei_new >= 0)\n\t\t{\n\t\t    if (((diff_flags & DIFF_IWHITE)\n\t\t\t\t&& VIM_ISWHITE(line_org[ei_org])\n\t\t\t\t\t      && VIM_ISWHITE(line_new[ei_new]))\n\t\t\t    || ((diff_flags & DIFF_IWHITEALL)\n\t\t\t\t&& (VIM_ISWHITE(line_org[ei_org])\n\t\t\t\t\t    || VIM_ISWHITE(line_new[ei_new]))))\n\t\t    {\n\t\t\twhile (ei_org >= *startp\n\t\t\t\t\t     && VIM_ISWHITE(line_org[ei_org]))\n\t\t\t    --ei_org;\n\t\t\twhile (ei_new >= si_new\n\t\t\t\t\t     && VIM_ISWHITE(line_new[ei_new]))\n\t\t\t    --ei_new;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tp1 = line_org + ei_org;\n\t\t\tp2 = line_new + ei_new;\n\t\t\tp1 -= (*mb_head_off)(line_org, p1);\n\t\t\tp2 -= (*mb_head_off)(line_new, p2);\n\t\t\tif (!diff_equal_char(p1, p2, &l))\n\t\t\t    break;\n\t\t\tei_org -= l;\n\t\t\tei_new -= l;\n\t\t    }\n\t\t}\n\t\tif (*endp < ei_org)\n\t\t    *endp = ei_org;\n\t    }\n\t}\n\n    vim_free(line_org);\n    return added;\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Return TRUE if line \"lnum\" is not close to a diff block, this line should\n * be in a fold.\n * Return FALSE if there are no diff blocks at all in this window.\n */\n    int\ndiff_infold(win_T *wp, linenr_T lnum)\n{\n    int\t\ti;\n    int\t\tidx = -1;\n    int\t\tother = FALSE;\n    diff_T\t*dp;\n\n    // Return if 'diff' isn't set.\n    if (!wp->w_p_diff)\n\treturn FALSE;\n\n    for (i = 0; i < DB_COUNT; ++i)\n    {\n\tif (curtab->tp_diffbuf[i] == wp->w_buffer)\n\t    idx = i;\n\telse if (curtab->tp_diffbuf[i] != NULL)\n\t    other = TRUE;\n    }\n\n    // return here if there are no diffs in the window\n    if (idx == -1 || !other)\n\treturn FALSE;\n\n    if (curtab->tp_diff_invalid)\n\tex_diffupdate(NULL);\t\t// update after a big change\n\n    // Return if there are no diff blocks.  All lines will be folded.\n    if (curtab->tp_first_diff == NULL)\n\treturn TRUE;\n\n    FOR_ALL_DIFFBLOCKS_IN_TAB(curtab, dp)\n    {\n\t// If this change is below the line there can't be any further match.\n\tif (dp->df_lnum[idx] - diff_context > lnum)\n\t    break;\n\t// If this change ends before the line we have a match.\n\tif (dp->df_lnum[idx] + dp->df_count[idx] + diff_context > lnum)\n\t    return FALSE;\n    }\n    return TRUE;\n}\n#endif\n\n/*\n * \"dp\" and \"do\" commands.\n */\n    void\nnv_diffgetput(int put, long count)\n{\n    exarg_T\tea;\n    char_u\tbuf[30];\n\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf))\n    {\n\tvim_beep(BO_OPER);\n\treturn;\n    }\n#endif\n    if (count == 0)\n\tea.arg = (char_u *)\"\";\n    else\n    {\n\tvim_snprintf((char *)buf, 30, \"%ld\", count);\n\tea.arg = buf;\n    }\n    if (put)\n\tea.cmdidx = CMD_diffput;\n    else\n\tea.cmdidx = CMD_diffget;\n    ea.addr_count = 0;\n    ea.line1 = curwin->w_cursor.lnum;\n    ea.line2 = curwin->w_cursor.lnum;\n    ex_diffgetput(&ea);\n}\n\n/*\n * \":diffget\"\n * \":diffput\"\n */\n    void\nex_diffgetput(exarg_T *eap)\n{\n    linenr_T\tlnum;\n    int\t\tcount;\n    linenr_T\toff = 0;\n    diff_T\t*dp;\n    diff_T\t*dprev;\n    diff_T\t*dfree;\n    int\t\tidx_cur;\n    int\t\tidx_other;\n    int\t\tidx_from;\n    int\t\tidx_to;\n    int\t\ti;\n    int\t\tadded;\n    char_u\t*p;\n    aco_save_T\taco;\n    buf_T\t*buf;\n    int\t\tstart_skip, end_skip;\n    int\t\tnew_count;\n    int\t\tbuf_empty;\n    int\t\tfound_not_ma = FALSE;\n\n    // Find the current buffer in the list of diff buffers.\n    idx_cur = diff_buf_idx(curbuf);\n    if (idx_cur == DB_COUNT)\n    {\n\temsg(_(e_current_buffer_is_not_in_diff_mode));\n\treturn;\n    }\n\n    if (*eap->arg == NUL)\n    {\n\t// No argument: Find the other buffer in the list of diff buffers.\n\tfor (idx_other = 0; idx_other < DB_COUNT; ++idx_other)\n\t    if (curtab->tp_diffbuf[idx_other] != curbuf\n\t\t    && curtab->tp_diffbuf[idx_other] != NULL)\n\t    {\n\t\tif (eap->cmdidx != CMD_diffput\n\t\t\t\t     || curtab->tp_diffbuf[idx_other]->b_p_ma)\n\t\t    break;\n\t\tfound_not_ma = TRUE;\n\t    }\n\tif (idx_other == DB_COUNT)\n\t{\n\t    if (found_not_ma)\n\t\temsg(_(e_no_other_buffer_in_diff_mode_is_modifiable));\n\t    else\n\t\temsg(_(e_no_other_buffer_in_diff_mode));\n\t    return;\n\t}\n\n\t// Check that there isn't a third buffer in the list\n\tfor (i = idx_other + 1; i < DB_COUNT; ++i)\n\t    if (curtab->tp_diffbuf[i] != curbuf\n\t\t    && curtab->tp_diffbuf[i] != NULL\n\t\t    && (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma))\n\t    {\n\t\temsg(_(e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use));\n\t\treturn;\n\t    }\n    }\n    else\n    {\n\t// Buffer number or pattern given.  Ignore trailing white space.\n\tp = eap->arg + STRLEN(eap->arg);\n\twhile (p > eap->arg && VIM_ISWHITE(p[-1]))\n\t    --p;\n\tfor (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i)\n\t    ;\n\tif (eap->arg + i == p)\t    // digits only\n\t    i = atol((char *)eap->arg);\n\telse\n\t{\n\t    i = buflist_findpat(eap->arg, p, FALSE, TRUE, FALSE);\n\t    if (i < 0)\n\t\treturn;\t\t// error message already given\n\t}\n\tbuf = buflist_findnr(i);\n\tif (buf == NULL)\n\t{\n\t    semsg(_(e_cant_find_buffer_str), eap->arg);\n\t    return;\n\t}\n\tif (buf == curbuf)\n\t    return;\t\t// nothing to do\n\tidx_other = diff_buf_idx(buf);\n\tif (idx_other == DB_COUNT)\n\t{\n\t    semsg(_(e_buffer_str_is_not_in_diff_mode), eap->arg);\n\t    return;\n\t}\n    }\n\n    diff_busy = TRUE;\n\n    // When no range given include the line above or below the cursor.\n    if (eap->addr_count == 0)\n    {\n\t// Make it possible that \":diffget\" on the last line gets line below\n\t// the cursor line when there is no difference above the cursor.\n\tif (eap->cmdidx == CMD_diffget\n\t\t&& eap->line1 == curbuf->b_ml.ml_line_count\n\t\t&& diff_check(curwin, eap->line1) == 0\n\t\t&& (eap->line1 == 1 || diff_check(curwin, eap->line1 - 1) == 0))\n\t    ++eap->line2;\n\telse if (eap->line1 > 0)\n\t    --eap->line1;\n    }\n\n    if (eap->cmdidx == CMD_diffget)\n    {\n\tidx_from = idx_other;\n\tidx_to = idx_cur;\n    }\n    else\n    {\n\tidx_from = idx_cur;\n\tidx_to = idx_other;\n\t// Need to make the other buffer the current buffer to be able to make\n\t// changes in it.\n\t// set curwin/curbuf to buf and save a few things\n\taucmd_prepbuf(&aco, curtab->tp_diffbuf[idx_other]);\n    }\n\n    // May give the warning for a changed buffer here, which can trigger the\n    // FileChangedRO autocommand, which may do nasty things and mess\n    // everything up.\n    if (!curbuf->b_changed)\n    {\n\tchange_warning(0);\n\tif (diff_buf_idx(curbuf) != idx_to)\n\t{\n\t    emsg(_(e_buffer_changed_unexpectedly));\n\t    goto theend;\n\t}\n    }\n\n    dprev = NULL;\n    for (dp = curtab->tp_first_diff; dp != NULL; )\n    {\n\tif (dp->df_lnum[idx_cur] > eap->line2 + off)\n\t    break;\t// past the range that was specified\n\n\tdfree = NULL;\n\tlnum = dp->df_lnum[idx_to];\n\tcount = dp->df_count[idx_to];\n\tif (dp->df_lnum[idx_cur] + dp->df_count[idx_cur] > eap->line1 + off\n\t\t&& u_save(lnum - 1, lnum + count) != FAIL)\n\t{\n\t    // Inside the specified range and saving for undo worked.\n\t    start_skip = 0;\n\t    end_skip = 0;\n\t    if (eap->addr_count > 0)\n\t    {\n\t\t// A range was specified: check if lines need to be skipped.\n\t\tstart_skip = eap->line1 + off - dp->df_lnum[idx_cur];\n\t\tif (start_skip > 0)\n\t\t{\n\t\t    // range starts below start of current diff block\n\t\t    if (start_skip > count)\n\t\t    {\n\t\t\tlnum += count;\n\t\t\tcount = 0;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tcount -= start_skip;\n\t\t\tlnum += start_skip;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    start_skip = 0;\n\n\t\tend_skip = dp->df_lnum[idx_cur] + dp->df_count[idx_cur] - 1\n\t\t\t\t\t\t\t - (eap->line2 + off);\n\t\tif (end_skip > 0)\n\t\t{\n\t\t    // range ends above end of current/from diff block\n\t\t    if (idx_cur == idx_from)\t// :diffput\n\t\t    {\n\t\t\ti = dp->df_count[idx_cur] - start_skip - end_skip;\n\t\t\tif (count > i)\n\t\t\t    count = i;\n\t\t    }\n\t\t    else\t\t\t// :diffget\n\t\t    {\n\t\t\tcount -= end_skip;\n\t\t\tend_skip = dp->df_count[idx_from] - start_skip - count;\n\t\t\tif (end_skip < 0)\n\t\t\t    end_skip = 0;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    end_skip = 0;\n\t    }\n\n\t    buf_empty = BUFEMPTY();\n\t    added = 0;\n\t    for (i = 0; i < count; ++i)\n\t    {\n\t\t// remember deleting the last line of the buffer\n\t\tbuf_empty = curbuf->b_ml.ml_line_count == 1;\n\t\tml_delete(lnum);\n\t\t--added;\n\t    }\n\t    for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i)\n\t    {\n\t\tlinenr_T nr;\n\n\t\tnr = dp->df_lnum[idx_from] + start_skip + i;\n\t\tif (nr > curtab->tp_diffbuf[idx_from]->b_ml.ml_line_count)\n\t\t    break;\n\t\tp = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from],\n\t\t\t\t\t\t\t\t  nr, FALSE));\n\t\tif (p != NULL)\n\t\t{\n\t\t    ml_append(lnum + i - 1, p, 0, FALSE);\n\t\t    vim_free(p);\n\t\t    ++added;\n\t\t    if (buf_empty && curbuf->b_ml.ml_line_count == 2)\n\t\t    {\n\t\t\t// Added the first line into an empty buffer, need to\n\t\t\t// delete the dummy empty line.\n\t\t\tbuf_empty = FALSE;\n\t\t\tml_delete((linenr_T)2);\n\t\t    }\n\t\t}\n\t    }\n\t    new_count = dp->df_count[idx_to] + added;\n\t    dp->df_count[idx_to] = new_count;\n\n\t    if (start_skip == 0 && end_skip == 0)\n\t    {\n\t\t// Check if there are any other buffers and if the diff is\n\t\t// equal in them.\n\t\tfor (i = 0; i < DB_COUNT; ++i)\n\t\t    if (curtab->tp_diffbuf[i] != NULL && i != idx_from\n\t\t\t\t\t\t\t\t&& i != idx_to\n\t\t\t    && !diff_equal_entry(dp, idx_from, i))\n\t\t\tbreak;\n\t\tif (i == DB_COUNT)\n\t\t{\n\t\t    // delete the diff entry, the buffers are now equal here\n\t\t    dfree = dp;\n\t\t    dp = dp->df_next;\n\t\t    if (dprev == NULL)\n\t\t\tcurtab->tp_first_diff = dp;\n\t\t    else\n\t\t\tdprev->df_next = dp;\n\t\t}\n\t    }\n\n\t    // Adjust marks.  This will change the following entries!\n\t    if (added != 0)\n\t    {\n\t\tmark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added);\n\t\tif (curwin->w_cursor.lnum >= lnum)\n\t\t{\n\t\t    // Adjust the cursor position if it's in/after the changed\n\t\t    // lines.\n\t\t    if (curwin->w_cursor.lnum >= lnum + count)\n\t\t\tcurwin->w_cursor.lnum += added;\n\t\t    else if (added < 0)\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t}\n\t    }\n\t    changed_lines(lnum, 0, lnum + count, (long)added);\n\n\t    if (dfree != NULL)\n\t    {\n\t\t// Diff is deleted, update folds in other windows.\n#ifdef FEAT_FOLDING\n\t\tdiff_fold_update(dfree, idx_to);\n#endif\n\t\tvim_free(dfree);\n\t    }\n\t    else\n\t\t// mark_adjust() may have changed the count in a wrong way\n\t\tdp->df_count[idx_to] = new_count;\n\n\t    // When changing the current buffer, keep track of line numbers\n\t    if (idx_cur == idx_to)\n\t\toff += added;\n\t}\n\n\t// If before the range or not deleted, go to next diff.\n\tif (dfree == NULL)\n\t{\n\t    dprev = dp;\n\t    dp = dp->df_next;\n\t}\n    }\n\n    // restore curwin/curbuf and a few other things\n    if (eap->cmdidx != CMD_diffget)\n    {\n\t// Syncing undo only works for the current buffer, but we change\n\t// another buffer.  Sync undo if the command was typed.  This isn't\n\t// 100% right when \":diffput\" is used in a function or mapping.\n\tif (KeyTyped)\n\t    u_sync(FALSE);\n\taucmd_restbuf(&aco);\n    }\n\ntheend:\n    diff_busy = FALSE;\n    if (diff_need_update)\n\tex_diffupdate(NULL);\n\n    // Check that the cursor is on a valid character and update its\n    // position.  When there were filler lines the topline has become\n    // invalid.\n    check_cursor();\n    changed_line_abv_curs();\n\n    if (diff_need_update)\n\t// redraw already done by ex_diffupdate()\n\tdiff_need_update = FALSE;\n    else\n    {\n\t// Also need to redraw the other buffers.\n\tdiff_redraw(FALSE);\n\tapply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf);\n    }\n}\n\n#ifdef FEAT_FOLDING\n/*\n * Update folds for all diff buffers for entry \"dp\".\n * Skip buffer with index \"skip_idx\".\n * When there are no diffs, all folds are removed.\n */\n    static void\ndiff_fold_update(diff_T *dp, int skip_idx)\n{\n    int\t\ti;\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tfor (i = 0; i < DB_COUNT; ++i)\n\t    if (curtab->tp_diffbuf[i] == wp->w_buffer && i != skip_idx)\n\t\tfoldUpdate(wp, dp->df_lnum[i],\n\t\t\t\t\t    dp->df_lnum[i] + dp->df_count[i]);\n}\n#endif\n\n/*\n * Return TRUE if buffer \"buf\" is in diff-mode.\n */\n    int\ndiff_mode_buf(buf_T *buf)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (diff_buf_idx_tp(buf, tp) != DB_COUNT)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Move \"count\" times in direction \"dir\" to the next diff block.\n * Return FAIL if there isn't such a diff block.\n */\n    int\ndiff_move_to(int dir, long count)\n{\n    int\t\tidx;\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    diff_T\t*dp;\n\n    idx = diff_buf_idx(curbuf);\n    if (idx == DB_COUNT || curtab->tp_first_diff == NULL)\n\treturn FAIL;\n\n    if (curtab->tp_diff_invalid)\n\tex_diffupdate(NULL);\t\t// update after a big change\n\n    if (curtab->tp_first_diff == NULL)\t\t// no diffs today\n\treturn FAIL;\n\n    while (--count >= 0)\n    {\n\t// Check if already before first diff.\n\tif (dir == BACKWARD && lnum <= curtab->tp_first_diff->df_lnum[idx])\n\t    break;\n\n\tfor (dp = curtab->tp_first_diff; ; dp = dp->df_next)\n\t{\n\t    if (dp == NULL)\n\t\tbreak;\n\t    if ((dir == FORWARD && lnum < dp->df_lnum[idx])\n\t\t    || (dir == BACKWARD\n\t\t\t&& (dp->df_next == NULL\n\t\t\t    || lnum <= dp->df_next->df_lnum[idx])))\n\t    {\n\t\tlnum = dp->df_lnum[idx];\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // don't end up past the end of the file\n    if (lnum > curbuf->b_ml.ml_line_count)\n\tlnum = curbuf->b_ml.ml_line_count;\n\n    // When the cursor didn't move at all we fail.\n    if (lnum == curwin->w_cursor.lnum)\n\treturn FAIL;\n\n    setpcmark();\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n\n    return OK;\n}\n\n/*\n * Return the line number in the current window that is closest to \"lnum1\" in\n * \"buf1\" in diff mode.\n */\n    static linenr_T\ndiff_get_corresponding_line_int(\n    buf_T\t*buf1,\n    linenr_T\tlnum1)\n{\n    int\t\tidx1;\n    int\t\tidx2;\n    diff_T\t*dp;\n    int\t\tbaseline = 0;\n\n    idx1 = diff_buf_idx(buf1);\n    idx2 = diff_buf_idx(curbuf);\n    if (idx1 == DB_COUNT || idx2 == DB_COUNT || curtab->tp_first_diff == NULL)\n\treturn lnum1;\n\n    if (curtab->tp_diff_invalid)\n\tex_diffupdate(NULL);\t\t// update after a big change\n\n    if (curtab->tp_first_diff == NULL)\t\t// no diffs today\n\treturn lnum1;\n\n    FOR_ALL_DIFFBLOCKS_IN_TAB(curtab, dp)\n    {\n\tif (dp->df_lnum[idx1] > lnum1)\n\t    return lnum1 - baseline;\n\tif ((dp->df_lnum[idx1] + dp->df_count[idx1]) > lnum1)\n\t{\n\t    // Inside the diffblock\n\t    baseline = lnum1 - dp->df_lnum[idx1];\n\t    if (baseline > dp->df_count[idx2])\n\t\tbaseline = dp->df_count[idx2];\n\n\t    return dp->df_lnum[idx2] + baseline;\n\t}\n\tif (    (dp->df_lnum[idx1] == lnum1)\n\t     && (dp->df_count[idx1] == 0)\n\t     && (dp->df_lnum[idx2] <= curwin->w_cursor.lnum)\n\t     && ((dp->df_lnum[idx2] + dp->df_count[idx2])\n\t\t\t\t\t\t      > curwin->w_cursor.lnum))\n\t    /*\n\t     * Special case: if the cursor is just after a zero-count\n\t     * block (i.e. all filler) and the target cursor is already\n\t     * inside the corresponding block, leave the target cursor\n\t     * unmoved. This makes repeated CTRL-W W operations work\n\t     * as expected.\n\t     */\n\t    return curwin->w_cursor.lnum;\n\tbaseline = (dp->df_lnum[idx1] + dp->df_count[idx1])\n\t\t\t\t   - (dp->df_lnum[idx2] + dp->df_count[idx2]);\n    }\n\n    // If we get here then the cursor is after the last diff\n    return lnum1 - baseline;\n}\n\n/*\n * Return the line number in the current window that is closest to \"lnum1\" in\n * \"buf1\" in diff mode.  Checks the line number to be valid.\n */\n    linenr_T\ndiff_get_corresponding_line(buf_T *buf1, linenr_T lnum1)\n{\n    linenr_T lnum = diff_get_corresponding_line_int(buf1, lnum1);\n\n    // don't end up past the end of the file\n    if (lnum > curbuf->b_ml.ml_line_count)\n\treturn curbuf->b_ml.ml_line_count;\n    return lnum;\n}\n\n/*\n * For line \"lnum\" in the current window find the equivalent lnum in window\n * \"wp\", compensating for inserted/deleted lines.\n */\n    linenr_T\ndiff_lnum_win(linenr_T lnum, win_T *wp)\n{\n    diff_T\t*dp;\n    int\t\tidx;\n    int\t\ti;\n    linenr_T\tn;\n\n    idx = diff_buf_idx(curbuf);\n    if (idx == DB_COUNT)\t\t// safety check\n\treturn (linenr_T)0;\n\n    if (curtab->tp_diff_invalid)\n\tex_diffupdate(NULL);\t\t// update after a big change\n\n    // search for a change that includes \"lnum\" in the list of diffblocks.\n    FOR_ALL_DIFFBLOCKS_IN_TAB(curtab, dp)\n\tif (lnum <= dp->df_lnum[idx] + dp->df_count[idx])\n\t    break;\n\n    // When after the last change, compute relative to the last line number.\n    if (dp == NULL)\n\treturn wp->w_buffer->b_ml.ml_line_count\n\t\t\t\t\t- (curbuf->b_ml.ml_line_count - lnum);\n\n    // Find index for \"wp\".\n    i = diff_buf_idx(wp->w_buffer);\n    if (i == DB_COUNT)\t\t\t// safety check\n\treturn (linenr_T)0;\n\n    n = lnum + (dp->df_lnum[i] - dp->df_lnum[idx]);\n    if (n > dp->df_lnum[i] + dp->df_count[i])\n\tn = dp->df_lnum[i] + dp->df_count[i];\n    return n;\n}\n\n/*\n * Handle an ED style diff line.\n * Return FAIL if the line does not contain diff info.\n */\n    static int\nparse_diff_ed(\n\tchar_u\t    *line,\n\tdiffhunk_T  *hunk)\n{\n    char_u *p;\n    long    f1, l1, f2, l2;\n    int\t    difftype;\n\n    // The line must be one of three formats:\n    // change: {first}[,{last}]c{first}[,{last}]\n    // append: {first}a{first}[,{last}]\n    // delete: {first}[,{last}]d{first}\n    p = line;\n    f1 = getdigits(&p);\n    if (*p == ',')\n    {\n\t++p;\n\tl1 = getdigits(&p);\n    }\n    else\n\tl1 = f1;\n    if (*p != 'a' && *p != 'c' && *p != 'd')\n\treturn FAIL;\t\t// invalid diff format\n    difftype = *p++;\n    f2 = getdigits(&p);\n    if (*p == ',')\n    {\n\t++p;\n\tl2 = getdigits(&p);\n    }\n    else\n\tl2 = f2;\n    if (l1 < f1 || l2 < f2)\n\treturn FAIL;\n\n    if (difftype == 'a')\n    {\n\thunk->lnum_orig = f1 + 1;\n\thunk->count_orig = 0;\n    }\n    else\n    {\n\thunk->lnum_orig = f1;\n\thunk->count_orig = l1 - f1 + 1;\n    }\n    if (difftype == 'd')\n    {\n\thunk->lnum_new = f2 + 1;\n\thunk->count_new = 0;\n    }\n    else\n    {\n\thunk->lnum_new = f2;\n\thunk->count_new = l2 - f2 + 1;\n    }\n    return OK;\n}\n\n/*\n * Parses unified diff with zero(!) context lines.\n * Return FAIL if there is no diff information in \"line\".\n */\n    static int\nparse_diff_unified(\n\tchar_u\t    *line,\n\tdiffhunk_T  *hunk)\n{\n    char_u *p;\n    long    oldline, oldcount, newline, newcount;\n\n    // Parse unified diff hunk header:\n    // @@ -oldline,oldcount +newline,newcount @@\n    p = line;\n    if (*p++ == '@' && *p++ == '@' && *p++ == ' ' && *p++ == '-')\n    {\n\toldline = getdigits(&p);\n\tif (*p == ',')\n\t{\n\t    ++p;\n\t    oldcount = getdigits(&p);\n\t}\n\telse\n\t    oldcount = 1;\n\tif (*p++ == ' ' && *p++ == '+')\n\t{\n\t    newline = getdigits(&p);\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\tnewcount = getdigits(&p);\n\t    }\n\t    else\n\t\tnewcount = 1;\n\t}\n\telse\n\t    return FAIL;\t// invalid diff format\n\n\tif (oldcount == 0)\n\t    oldline += 1;\n\tif (newcount == 0)\n\t    newline += 1;\n\tif (newline == 0)\n\t    newline = 1;\n\n\thunk->lnum_orig = oldline;\n\thunk->count_orig = oldcount;\n\thunk->lnum_new = newline;\n\thunk->count_new = newcount;\n\n\treturn OK;\n    }\n\n    return FAIL;\n}\n\n/*\n * Callback function for the xdl_diff() function.\n * Stores the diff output in a grow array.\n */\n    static int\nxdiff_out(\n\tlong start_a,\n\tlong count_a,\n\tlong start_b,\n\tlong count_b,\n\tvoid *priv)\n{\n    diffout_T\t*dout = (diffout_T *)priv;\n    diffhunk_T *p = ALLOC_ONE(diffhunk_T);\n\n    if (p == NULL)\n\treturn -1;\n\n    if (ga_grow(&dout->dout_ga, 1) == FAIL)\n    {\n\tvim_free(p);\n\treturn -1;\n    }\n\n    p->lnum_orig  = start_a + 1;\n    p->count_orig = count_a;\n    p->lnum_new   = start_b + 1;\n    p->count_new  = count_b;\n    ((diffhunk_T **)dout->dout_ga.ga_data)[dout->dout_ga.ga_len++] = p;\n    return 0;\n}\n\n#endif\t// FEAT_DIFF\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * \"diff_filler()\" function\n */\n    void\nf_diff_filler(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n#ifdef FEAT_DIFF\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n\n    rettv->vval.v_number = diff_check_fill(curwin, tv_get_lnum(argvars));\n#endif\n}\n\n/*\n * \"diff_hlID()\" function\n */\n    void\nf_diff_hlID(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n#ifdef FEAT_DIFF\n    linenr_T\t\tlnum;\n    static linenr_T\tprev_lnum = 0;\n    static varnumber_T\tchangedtick = 0;\n    static int\t\tfnum = 0;\n    static int\t\tchange_start = 0;\n    static int\t\tchange_end = 0;\n    static hlf_T\thlID = (hlf_T)0;\n    int\t\t\tfiller_lines;\n    int\t\t\tcol;\n\n    if (in_vim9script()\n\t    && (check_for_lnum_arg(argvars,0) == FAIL\n\t\t|| check_for_number_arg(argvars, 1) == FAIL))\n\treturn;\n\n    lnum = tv_get_lnum(argvars);\n    if (lnum < 0)\t// ignore type error in {lnum} arg\n\tlnum = 0;\n    if (lnum != prev_lnum\n\t    || changedtick != CHANGEDTICK(curbuf)\n\t    || fnum != curbuf->b_fnum)\n    {\n\t// New line, buffer, change: need to get the values.\n\tfiller_lines = diff_check(curwin, lnum);\n\tif (filler_lines < 0)\n\t{\n\t    if (filler_lines == -1)\n\t    {\n\t\tchange_start = MAXCOL;\n\t\tchange_end = -1;\n\t\tif (diff_find_change(curwin, lnum, &change_start, &change_end))\n\t\t    hlID = HLF_ADD;\t// added line\n\t\telse\n\t\t    hlID = HLF_CHD;\t// changed line\n\t    }\n\t    else\n\t\thlID = HLF_ADD;\t// added line\n\t}\n\telse\n\t    hlID = (hlf_T)0;\n\tprev_lnum = lnum;\n\tchangedtick = CHANGEDTICK(curbuf);\n\tfnum = curbuf->b_fnum;\n    }\n\n    if (hlID == HLF_CHD || hlID == HLF_TXD)\n    {\n\tcol = tv_get_number(&argvars[1]) - 1; // ignore type error in {col}\n\tif (col >= change_start && col <= change_end)\n\t    hlID = HLF_TXD;\t\t\t// changed text\n\telse\n\t    hlID = HLF_CHD;\t\t\t// changed line\n    }\n    rettv->vval.v_number = hlID == (hlf_T)0 ? 0 : (int)hlID;\n#endif\n}\n\n#endif\n", "\" Tests for diff mode\n\nsource shared.vim\nsource screendump.vim\nsource check.vim\n\nfunc Test_diff_fold_sync()\n  enew!\n  let g:update_count = 0\n  au DiffUpdated * let g:update_count += 1\n\n  let l = range(50)\n  call setline(1, l)\n  diffthis\n  let winone = win_getid()\n  new\n  let l[25] = 'diff'\n  call setline(1, l)\n  diffthis\n  let wintwo = win_getid()\n  \" line 15 is inside the closed fold\n  call assert_equal(19, foldclosedend(10))\n  call win_gotoid(winone)\n  call assert_equal(19, foldclosedend(10))\n  \" open the fold\n  normal zv\n  call assert_equal(-1, foldclosedend(10))\n  \" fold in other window must have opened too\n  call win_gotoid(wintwo)\n  call assert_equal(-1, foldclosedend(10))\n\n  \" cursor position is in sync\n  normal 23G\n  call win_gotoid(winone)\n  call assert_equal(23, getcurpos()[1])\n\n  call assert_equal(1, g:update_count)\n  au! DiffUpdated\n\n  windo diffoff\n  close!\n  set nomodified\nendfunc\n\nfunc Test_vert_split()\n  set diffopt=filler\n  call Common_vert_split()\n  set diffopt&\nendfunc\n\nfunc Test_vert_split_internal()\n  set diffopt=internal,filler\n  call Common_vert_split()\n  set diffopt&\nendfunc\n\nfunc Common_vert_split()\n  \" Disable the title to avoid xterm keeping the wrong one.\n  set notitle noicon\n  new\n  let l = ['1 aa', '2 bb', '3 cc', '4 dd', '5 ee']\n  call setline(1, l)\n  w! Xtest\n  normal dd\n  $\n  put\n  normal kkrXoxxx\u001b\n  w! Xtest2\n  file Nop\n  normal ggoyyy\u001bjjjozzzz\u001b\n  set foldmethod=marker foldcolumn=4\n  call assert_equal(0, &diff)\n  call assert_equal('marker', &foldmethod)\n  call assert_equal(4, &foldcolumn)\n  call assert_equal(0, &scrollbind)\n  call assert_equal(0, &cursorbind)\n  call assert_equal(1, &wrap)\n\n  vert diffsplit Xtest\n  vert diffsplit Xtest2\n  call assert_equal(1, &diff)\n  call assert_equal('diff', &foldmethod)\n  call assert_equal(2, &foldcolumn)\n  call assert_equal(1, &scrollbind)\n  call assert_equal(1, &cursorbind)\n  call assert_equal(0, &wrap)\n\n  let diff_fdm = &fdm\n  let diff_fdc = &fdc\n  \" repeat entering diff mode here to see if this saves the wrong settings\n  diffthis\n  \" jump to second window for a moment to have filler line appear at start of\n  \" first window\n  wincmd w\n  normal gg\n  wincmd p\n  normal gg\n  call assert_equal(2, winline())\n  normal j\n  call assert_equal(4, winline())\n  normal j\n  call assert_equal(5, winline())\n  normal j\n  call assert_equal(6, winline())\n  normal j\n  call assert_equal(8, winline())\n  normal j\n  call assert_equal(9, winline())\n\n  wincmd w\n  normal gg\n  call assert_equal(1, winline())\n  normal j\n  call assert_equal(2, winline())\n  normal j\n  call assert_equal(4, winline())\n  normal j\n  call assert_equal(5, winline())\n  normal j\n  call assert_equal(8, winline())\n\n  wincmd w\n  normal gg\n  call assert_equal(2, winline())\n  normal j\n  call assert_equal(3, winline())\n  normal j\n  call assert_equal(4, winline())\n  normal j\n  call assert_equal(5, winline())\n  normal j\n  call assert_equal(6, winline())\n  normal j\n  call assert_equal(7, winline())\n  normal j\n  call assert_equal(8, winline())\n\n  \" Test diffoff\n  diffoff!\n  1wincmd 2\n  let &diff = 1\n  let &fdm = diff_fdm\n  let &fdc = diff_fdc\n  4wincmd w\n  diffoff!\n  1wincmd w\n  call assert_equal(0, &diff)\n  call assert_equal('marker', &foldmethod)\n  call assert_equal(4, &foldcolumn)\n  call assert_equal(0, &scrollbind)\n  call assert_equal(0, &cursorbind)\n  call assert_equal(1, &wrap)\n\n  wincmd w\n  call assert_equal(0, &diff)\n  call assert_equal('marker', &foldmethod)\n  call assert_equal(4, &foldcolumn)\n  call assert_equal(0, &scrollbind)\n  call assert_equal(0, &cursorbind)\n  call assert_equal(1, &wrap)\n\n  wincmd w\n  call assert_equal(0, &diff)\n  call assert_equal('marker', &foldmethod)\n  call assert_equal(4, &foldcolumn)\n  call assert_equal(0, &scrollbind)\n  call assert_equal(0, &cursorbind)\n  call assert_equal(1, &wrap)\n\n  call delete('Xtest')\n  call delete('Xtest2')\n  windo bw!\nendfunc\n\nfunc Test_filler_lines()\n  \" Test that diffing shows correct filler lines\n  enew!\n  put =range(4,10)\n  1d _\n  vnew\n  put =range(1,10)\n  1d _\n  windo diffthis\n  wincmd h\n  call assert_equal(1, line('w0'))\n  unlet! diff_fdm diff_fdc\n  windo diffoff\n  bwipe!\n  enew!\nendfunc\n\nfunc Test_diffget_diffput()\n  enew!\n  let l = range(50)\n  call setline(1, l)\n  call assert_fails('diffget', 'E99:')\n  diffthis\n  call assert_fails('diffget', 'E100:')\n  new\n  let l[10] = 'one'\n  let l[20] = 'two'\n  let l[30] = 'three'\n  let l[40] = 'four'\n  call setline(1, l)\n  diffthis\n  call assert_equal('one', getline(11))\n  11diffget\n  call assert_equal('10', getline(11))\n  21diffput\n  wincmd w\n  call assert_equal('two', getline(21))\n  normal 31Gdo\n  call assert_equal('three', getline(31))\n  call assert_equal('40', getline(41))\n  normal 41Gdp\n  wincmd w\n  call assert_equal('40', getline(41))\n  new\n  diffthis\n  call assert_fails('diffget', 'E101:')\n\n  windo diffoff\n  %bwipe!\nendfunc\n\n\" Test putting two changes from one buffer to another\nfunc Test_diffput_two()\n  new a\n  let win_a = win_getid()\n  call setline(1, range(1, 10))\n  diffthis\n  new b\n  let win_b = win_getid()\n  call setline(1, range(1, 10))\n  8del\n  5del\n  diffthis\n  call win_gotoid(win_a)\n  %diffput\n  call win_gotoid(win_b)\n  call assert_equal(map(range(1, 10), 'string(v:val)'), getline(1, '$'))\n  bwipe! a\n  bwipe! b\nendfunc\n\n\" Test for :diffget/:diffput with a range that is inside a diff chunk\nfunc Test_diffget_diffput_range()\n  call setline(1, range(1, 10))\n  new\n  call setline(1, range(11, 20))\n  windo diffthis\n  3,5diffget\n  call assert_equal(['13', '14', '15'], getline(3, 5))\n  call setline(1, range(1, 10))\n  4,8diffput\n  wincmd p\n  call assert_equal(['13', '4', '5', '6', '7', '8', '19'], getline(3, 9))\n  %bw!\nendfunc\n\n\" Test for :diffget/:diffput with an empty buffer and a non-empty buffer\nfunc Test_diffget_diffput_empty_buffer()\n  %d _\n  new\n  call setline(1, 'one')\n  windo diffthis\n  diffget\n  call assert_equal(['one'], getline(1, '$'))\n  %d _\n  diffput\n  wincmd p\n  call assert_equal([''], getline(1, '$'))\n  %bw!\nendfunc\n\n\" :diffput and :diffget completes names of buffers which\n\" are in diff mode and which are different than current buffer.\n\" No completion when the current window is not in diff mode.\nfunc Test_diffget_diffput_completion()\n  e            Xdiff1 | diffthis\n  botright new Xdiff2\n  botright new Xdiff3 | split | diffthis\n  botright new Xdiff4 | diffthis\n\n  wincmd t\n  call assert_equal('Xdiff1', bufname('%'))\n  call feedkeys(\":diffput \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput Xdiff3 Xdiff4', @:)\n  call feedkeys(\":diffget \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget Xdiff3 Xdiff4', @:)\n  call assert_equal(['Xdiff3', 'Xdiff4'], getcompletion('', 'diff_buffer'))\n\n  \" Xdiff2 is not in diff mode, so no completion for :diffput, :diffget\n  wincmd j\n  call assert_equal('Xdiff2', bufname('%'))\n  call feedkeys(\":diffput \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput ', @:)\n  call feedkeys(\":diffget \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget ', @:)\n  call assert_equal([], getcompletion('', 'diff_buffer'))\n\n  \" Xdiff3 is split in 2 windows, only the top one is in diff mode.\n  \" So completion of :diffput :diffget only happens in the top window.\n  wincmd j\n  call assert_equal('Xdiff3', bufname('%'))\n  call assert_equal(1, &diff)\n  call feedkeys(\":diffput \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput Xdiff1 Xdiff4', @:)\n  call feedkeys(\":diffget \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget Xdiff1 Xdiff4', @:)\n  call assert_equal(['Xdiff1', 'Xdiff4'], getcompletion('', 'diff_buffer'))\n\n  wincmd j\n  call assert_equal('Xdiff3', bufname('%'))\n  call assert_equal(0, &diff)\n  call feedkeys(\":diffput \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput ', @:)\n  call feedkeys(\":diffget \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget ', @:)\n  call assert_equal([], getcompletion('', 'diff_buffer'))\n\n  wincmd j\n  call assert_equal('Xdiff4', bufname('%'))\n  call feedkeys(\":diffput \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffput Xdiff1 Xdiff3', @:)\n  call feedkeys(\":diffget \\<C-A>\\<C-B>\\\"\\<CR>\", 'tx')\n  call assert_equal('\"diffget Xdiff1 Xdiff3', @:)\n  call assert_equal(['Xdiff1', 'Xdiff3'], getcompletion('', 'diff_buffer'))\n\n  %bwipe\nendfunc\n\nfunc Test_dp_do_buffer()\n  e! one\n  let bn1=bufnr('%')\n  let l = range(60)\n  call setline(1, l)\n  diffthis\n\n  new two\n  let l[10] = 'one'\n  let l[20] = 'two'\n  let l[30] = 'three'\n  let l[40] = 'four'\n  let l[50] = 'five'\n  call setline(1, l)\n  diffthis\n\n  \" dp and do with invalid buffer number.\n  11\n  call assert_fails('norm 99999dp', 'E102:')\n  call assert_fails('norm 99999do', 'E102:')\n  call assert_fails('diffput non_existing_buffer', 'E94:')\n  call assert_fails('diffget non_existing_buffer', 'E94:')\n\n  \" dp and do with valid buffer number.\n  call assert_equal('one', getline('.'))\n  exe 'norm ' . bn1 . 'do'\n  call assert_equal('10', getline('.'))\n  21\n  call assert_equal('two', getline('.'))\n  diffget one \n  call assert_equal('20', getline('.'))\n\n  31\n  exe 'norm ' . bn1 . 'dp'\n  41\n  diffput one\n  wincmd w\n  31\n  call assert_equal('three', getline('.'))\n  41\n  call assert_equal('four', getline('.'))\n\n  \" dp and do with buffer number which is not in diff mode.\n  new not_in_diff_mode\n  let bn3=bufnr('%')\n  wincmd w\n  51\n  call assert_fails('exe \"norm\" . bn3 . \"dp\"', 'E103:')\n  call assert_fails('exe \"norm\" . bn3 . \"do\"', 'E103:')\n  call assert_fails('diffput not_in_diff_mode', 'E94:')\n  call assert_fails('diffget not_in_diff_mode', 'E94:')\n\n  windo diffoff\n  %bwipe!\nendfunc\n\nfunc Test_do_lastline()\n  e! one\n  call setline(1, ['1','2','3','4','5','6'])\n  diffthis\n\n  new two\n  call setline(1, ['2','4','5'])\n  diffthis\n\n  1\n  norm dp]c\n  norm dp]c\n  wincmd w\n  call assert_equal(4, line('$'))\n  norm G\n  norm do\n  call assert_equal(3, line('$'))\n\n  windo diffoff\n  %bwipe!\nendfunc\n\nfunc Test_diffoff()\n  enew!\n  call setline(1, ['Two', 'Three'])\n  redraw\n  let normattr = screenattr(1, 1)\n  diffthis\n  botright vert new\n  call setline(1, ['One', '', 'Two', 'Three'])\n  diffthis\n  redraw\n  call assert_notequal(normattr, 1->screenattr(1))\n  diffoff!\n  redraw\n  call assert_equal(normattr, screenattr(1, 1))\n  bwipe!\n  bwipe!\nendfunc\n\nfunc Common_icase_test()\n  edit one\n  call setline(1, ['One', 'Two', 'Three', 'Four', 'Fi#ve'])\n  redraw\n  let normattr = screenattr(1, 1)\n  diffthis\n\n  botright vert new two\n  call setline(1, ['one', 'TWO', 'Three ', 'Four', 'fI=VE'])\n  diffthis\n\n  redraw\n  call assert_equal(normattr, screenattr(1, 1))\n  call assert_equal(normattr, screenattr(2, 1))\n  call assert_notequal(normattr, screenattr(3, 1))\n  call assert_equal(normattr, screenattr(4, 1))\n\n  let dtextattr = screenattr(5, 3)\n  call assert_notequal(dtextattr, screenattr(5, 1))\n  call assert_notequal(dtextattr, screenattr(5, 5))\n\n  diffoff!\n  %bwipe!\nendfunc\n\nfunc Test_diffopt_icase()\n  set diffopt=icase,foldcolumn:0\n  call Common_icase_test()\n  set diffopt&\nendfunc\n\nfunc Test_diffopt_icase_internal()\n  set diffopt=icase,foldcolumn:0,internal\n  call Common_icase_test()\n  set diffopt&\nendfunc\n\nfunc Common_iwhite_test()\n  edit one\n  \" Difference in trailing spaces and amount of spaces should be ignored,\n  \" but not other space differences.\n  call setline(1, [\"One \\t\", 'Two', 'Three', 'one two', 'one two', 'Four'])\n  redraw\n  let normattr = screenattr(1, 1)\n  diffthis\n\n  botright vert new two\n  call setline(1, [\"One\\t \", \"Two\\t \", 'Three', 'one   two', 'onetwo', ' Four'])\n  diffthis\n\n  redraw\n  call assert_equal(normattr, screenattr(1, 1))\n  call assert_equal(normattr, screenattr(2, 1))\n  call assert_equal(normattr, screenattr(3, 1))\n  call assert_equal(normattr, screenattr(4, 1))\n  call assert_notequal(normattr, screenattr(5, 1))\n  call assert_notequal(normattr, screenattr(6, 1))\n\n  diffoff!\n  %bwipe!\nendfunc\n\nfunc Test_diffopt_iwhite()\n  set diffopt=iwhite,foldcolumn:0\n  call Common_iwhite_test()\n  set diffopt&\nendfunc\n\nfunc Test_diffopt_iwhite_internal()\n  set diffopt=internal,iwhite,foldcolumn:0\n  call Common_iwhite_test()\n  set diffopt&\nendfunc\n\nfunc Test_diffopt_context()\n  enew!\n  call setline(1, ['1', '2', '3', '4', '5', '6', '7'])\n  diffthis\n  new\n  call setline(1, ['1', '2', '3', '4', '5x', '6', '7'])\n  diffthis\n\n  set diffopt=context:2\n  call assert_equal('+--  2 lines: 1', foldtextresult(1))\n  set diffopt=internal,context:2\n  call assert_equal('+--  2 lines: 1', foldtextresult(1))\n\n  set diffopt=context:1\n  call assert_equal('+--  3 lines: 1', foldtextresult(1))\n  set diffopt=internal,context:1\n  call assert_equal('+--  3 lines: 1', foldtextresult(1))\n\n  diffoff!\n  %bwipe!\n  set diffopt&\nendfunc\n\nfunc Test_diffopt_horizontal()\n  set diffopt=internal,horizontal\n  diffsplit\n\n  call assert_equal(&columns, winwidth(1))\n  call assert_equal(&columns, winwidth(2))\n  call assert_equal(&lines, winheight(1) + winheight(2) + 3)\n  call assert_inrange(0, 1, winheight(1) - winheight(2))\n\n  set diffopt&\n  diffoff!\n  %bwipe\nendfunc\n\nfunc Test_diffopt_vertical()\n  set diffopt=internal,vertical\n  diffsplit\n\n  call assert_equal(&lines - 2, winheight(1))\n  call assert_equal(&lines - 2, winheight(2))\n  call assert_equal(&columns, winwidth(1) + winwidth(2) + 1)\n  call assert_inrange(0, 1, winwidth(1) - winwidth(2))\n\n  set diffopt&\n  diffoff!\n  %bwipe\nendfunc\n\nfunc Test_diffopt_hiddenoff()\n  set diffopt=internal,filler,foldcolumn:0,hiddenoff\n  e! one\n  call setline(1, ['Two', 'Three'])\n  redraw\n  let normattr = screenattr(1, 1)\n  diffthis\n  botright vert new two\n  call setline(1, ['One', 'Four'])\n  diffthis\n  redraw\n  call assert_notequal(normattr, screenattr(1, 1))\n  set hidden\n  close\n  redraw\n  \" should not diffing with hidden buffer two while 'hiddenoff' is enabled\n  call assert_equal(normattr, screenattr(1, 1))\n\n  bwipe!\n  bwipe!\n  set hidden& diffopt&\nendfunc\n\nfunc Test_diffoff_hidden()\n  set diffopt=internal,filler,foldcolumn:0\n  e! one\n  call setline(1, ['Two', 'Three'])\n  redraw\n  let normattr = screenattr(1, 1)\n  diffthis\n  botright vert new two\n  call setline(1, ['One', 'Four'])\n  diffthis\n  redraw\n  call assert_notequal(normattr, screenattr(1, 1))\n  set hidden\n  close\n  redraw\n  \" diffing with hidden buffer two\n  call assert_notequal(normattr, screenattr(1, 1))\n  diffoff\n  redraw\n  call assert_equal(normattr, screenattr(1, 1))\n  diffthis\n  redraw\n  \" still diffing with hidden buffer two\n  call assert_notequal(normattr, screenattr(1, 1))\n  diffoff!\n  redraw\n  call assert_equal(normattr, screenattr(1, 1))\n  diffthis\n  redraw\n  \" no longer diffing with hidden buffer two\n  call assert_equal(normattr, screenattr(1, 1))\n\n  bwipe!\n  bwipe!\n  set hidden& diffopt&\nendfunc\n\nfunc Test_setting_cursor()\n  new Xtest1\n  put =range(1,90)\n  wq\n  new Xtest2\n  put =range(1,100)\n  wq\n\n  tabe Xtest2\n  $\n  diffsp Xtest1\n  tabclose\n\n  call delete('Xtest1')\n  call delete('Xtest2')\nendfunc\n\nfunc Test_diff_move_to()\n  new\n  call setline(1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  diffthis\n  vnew\n  call setline(1, [1, '2x', 3, 4, 4, 5, '6x', 7, '8x', 9, '10x'])\n  diffthis\n  norm ]c\n  call assert_equal(2, line('.'))\n  norm 3]c\n  call assert_equal(9, line('.'))\n  norm 10]c\n  call assert_equal(11, line('.'))\n  norm [c\n  call assert_equal(9, line('.'))\n  norm 2[c\n  call assert_equal(5, line('.'))\n  norm 10[c\n  call assert_equal(2, line('.'))\n  %bwipe!\nendfunc\n\nfunc Test_diffexpr()\n  CheckExecutable diff\n\n  func DiffExpr()\n    \" Prepend some text to check diff type detection\n    call writefile(['warning', '  message'], v:fname_out)\n    silent exe '!diff ' . v:fname_in . ' ' . v:fname_new . '>>' . v:fname_out\n  endfunc\n  set diffexpr=DiffExpr()\n  set diffopt=foldcolumn:0\n\n  enew!\n  call setline(1, ['one', 'two', 'three'])\n  redraw\n  let normattr = screenattr(1, 1)\n  diffthis\n\n  botright vert new\n  call setline(1, ['one', 'two', 'three.'])\n  diffthis\n\n  redraw\n  call assert_equal(normattr, screenattr(1, 1))\n  call assert_equal(normattr, screenattr(2, 1))\n  call assert_notequal(normattr, screenattr(3, 1))\n  diffoff!\n\n  \" Try using a non-existing function for 'diffexpr'.\n  set diffexpr=NewDiffFunc()\n  call assert_fails('windo diffthis', ['E117:', 'E97:'])\n  diffoff!\n\n  \" Using a script-local function\n  func s:NewDiffExpr()\n  endfunc\n  set diffexpr=s:NewDiffExpr()\n  call assert_equal(expand('<SID>') .. 'NewDiffExpr()', &diffexpr)\n  set diffexpr=<SID>NewDiffExpr()\n  call assert_equal(expand('<SID>') .. 'NewDiffExpr()', &diffexpr)\n\n  %bwipe!\n  set diffexpr& diffopt&\n  delfunc DiffExpr\n  delfunc s:NewDiffExpr\nendfunc\n\nfunc Test_diffpatch()\n  \" The patch program on MS-Windows may fail or hang.\n  CheckExecutable patch\n  CheckUnix\n  new\n  insert\n***************\n*** 1,3 ****\n  1\n! 2\n  3\n--- 1,4 ----\n  1\n! 2x\n  3\n+ 4\n.\n  saveas! Xpatch\n  bwipe!\n  new\n  call assert_fails('diffpatch Xpatch', 'E816:')\n\n  for name in ['Xpatch', 'Xpatch$HOME', 'Xpa''tch']\n    call setline(1, ['1', '2', '3'])\n    if name != 'Xpatch'\n      call rename('Xpatch', name)\n    endif\n    exe 'diffpatch ' . escape(name, '$')\n    call assert_equal(['1', '2x', '3', '4'], getline(1, '$'))\n    if name != 'Xpatch'\n      call rename(name, 'Xpatch')\n    endif\n    bwipe!\n  endfor\n\n  call delete('Xpatch')\n  bwipe!\nendfunc\n\nfunc Test_diff_too_many_buffers()\n  for i in range(1, 8)\n    exe \"new Xtest\" . i\n    diffthis\n  endfor\n  new Xtest9\n  call assert_fails('diffthis', 'E96:')\n  %bwipe!\nendfunc\n\nfunc Test_diff_nomodifiable()\n  new\n  call setline(1, [1, 2, 3, 4])\n  setl nomodifiable\n  diffthis\n  vnew\n  call setline(1, ['1x', 2, 3, 3, 4])\n  diffthis\n  call assert_fails('norm dp', 'E793:')\n  setl nomodifiable\n  call assert_fails('norm do', 'E21:')\n  %bwipe!\nendfunc\n\nfunc Test_diff_hlID()\n  new\n  call setline(1, [1, 2, 3])\n  diffthis\n  vnew\n  call setline(1, ['1x', 2, 'x', 3])\n  diffthis\n  redraw\n\n  call diff_hlID(-1, 1)->synIDattr(\"name\")->assert_equal(\"\")\n\n  call diff_hlID(1, 1)->synIDattr(\"name\")->assert_equal(\"DiffChange\")\n  call diff_hlID(1, 2)->synIDattr(\"name\")->assert_equal(\"DiffText\")\n  call diff_hlID(2, 1)->synIDattr(\"name\")->assert_equal(\"\")\n  call diff_hlID(3, 1)->synIDattr(\"name\")->assert_equal(\"DiffAdd\")\n  eval 4->diff_hlID(1)->synIDattr(\"name\")->assert_equal(\"\")\n\n  wincmd w\n  call assert_equal(synIDattr(diff_hlID(1, 1), \"name\"), \"DiffChange\")\n  call assert_equal(synIDattr(diff_hlID(2, 1), \"name\"), \"\")\n  call assert_equal(synIDattr(diff_hlID(3, 1), \"name\"), \"\")\n\n  %bwipe!\nendfunc\n\nfunc Test_diff_filler()\n  new\n  call setline(1, [1, 2, 3, 'x', 4])\n  diffthis\n  vnew\n  call setline(1, [1, 2, 'y', 'y', 3, 4])\n  diffthis\n  redraw\n\n  call assert_equal([0, 0, 0, 0, 0, 0, 0, 1, 0], map(range(-1, 7), 'v:val->diff_filler()'))\n  wincmd w\n  call assert_equal([0, 0, 0, 0, 2, 0, 0, 0], map(range(-1, 6), 'diff_filler(v:val)'))\n\n  %bwipe!\nendfunc\n\nfunc Test_diff_lastline()\n  enew!\n  only!\n  call setline(1, ['This is a ', 'line with five ', 'rows'])\n  diffthis\n  botright vert new\n  call setline(1, ['This is', 'a line with ', 'four rows'])\n  diffthis\n  1\n  call feedkeys(\"Je a\\<CR>\", 'tx')\n  call feedkeys(\"Je a\\<CR>\", 'tx')\n  let w1lines = winline()\n  wincmd w\n  $\n  let w2lines = winline()\n  call assert_equal(w2lines, w1lines)\n  bwipe!\n  bwipe!\nendfunc\n\nfunc WriteDiffFiles(buf, list1, list2)\n  call writefile(a:list1, 'Xfile1')\n  call writefile(a:list2, 'Xfile2')\n  if a:buf\n    call term_sendkeys(a:buf, \":checktime\\<CR>\")\n  endif\nendfunc\n\n\" Verify a screendump with both the internal and external diff.\nfunc VerifyBoth(buf, dumpfile, extra)\n  \" trailing : for leaving the cursor on the command line\n  for cmd in [\":set diffopt=filler\" . a:extra . \"\\<CR>:\", \":set diffopt+=internal\\<CR>:\"]\n    call term_sendkeys(a:buf, cmd)\n    if VerifyScreenDump(a:buf, a:dumpfile, {}, cmd =~ 'internal' ? 'internal' : 'external')\n      \" don't let the next iteration overwrite the \"failed\" file.\n      return\n    endif\n  endfor\n\n  \" also test unified diff\n  call term_sendkeys(a:buf, \":call SetupUnified()\\<CR>:\")\n  call term_sendkeys(a:buf, \":redraw!\\<CR>:\")\n  call VerifyScreenDump(a:buf, a:dumpfile, {}, 'unified')\n  call term_sendkeys(a:buf, \":call StopUnified()\\<CR>:\")\nendfunc\n\n\" Verify a screendump with the internal diff only.\nfunc VerifyInternal(buf, dumpfile, extra)\n  call term_sendkeys(a:buf, \":diffupdate!\\<CR>\")\n  \" trailing : for leaving the cursor on the command line\n  call term_sendkeys(a:buf, \":set diffopt=internal,filler\" . a:extra . \"\\<CR>:\")\n  call VerifyScreenDump(a:buf, a:dumpfile, {})\nendfunc\n\nfunc Test_diff_screen()\n  let g:test_is_flaky = 1\n  CheckScreendump\n  CheckFeature menu\n\n  let lines =<< trim END\n      func UnifiedDiffExpr()\n        \" Prepend some text to check diff type detection\n        call writefile(['warning', '  message'], v:fname_out)\n        silent exe '!diff -U0 ' .. v:fname_in .. ' ' .. v:fname_new .. '>>' .. v:fname_out\n      endfunc\n      func SetupUnified()\n        set diffexpr=UnifiedDiffExpr()\n        diffupdate\n      endfunc\n      func StopUnified()\n        set diffexpr=\n      endfunc\n  END\n  call writefile(lines, 'XdiffSetup')\n\n  \" clean up already existing swap files, just in case\n  call delete('.Xfile1.swp')\n  call delete('.Xfile2.swp')\n\n  \" Test 1: Add a line in beginning of file 2\n  call WriteDiffFiles(0, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  let buf = RunVimInTerminal('-d -S XdiffSetup Xfile1 Xfile2', {})\n  \" Set autoread mode, so that Vim won't complain once we re-write the test\n  \" files\n  call term_sendkeys(buf, \":set autoread\\<CR>\\<c-w>w:set autoread\\<CR>\\<c-w>w\")\n\n  call VerifyBoth(buf, 'Test_diff_01', '')\n\n  \" Test 2: Add a line in beginning of file 1\n  call WriteDiffFiles(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  call VerifyBoth(buf, 'Test_diff_02', '')\n\n  \" Test 3: Add a line at the end of file 2\n  call WriteDiffFiles(buf, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  call VerifyBoth(buf, 'Test_diff_03', '')\n\n  \" Test 4: Add a line at the end of file 1\n  call WriteDiffFiles(buf, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  call VerifyBoth(buf, 'Test_diff_04', '')\n\n  \" Test 5: Add a line in the middle of file 2, remove on at the end of file 1\n  call WriteDiffFiles(buf, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10])\n  call VerifyBoth(buf, 'Test_diff_05', '')\n\n  \" Test 6: Add a line in the middle of file 1, remove on at the end of file 2\n  call WriteDiffFiles(buf, [1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n  call VerifyBoth(buf, 'Test_diff_06', '')\n\n  \" Variants on test 6 with different context settings\n  call term_sendkeys(buf, \":set diffopt+=context:2\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_06.2', {})\n  call term_sendkeys(buf, \":set diffopt-=context:2\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt+=context:1\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_06.1', {})\n  call term_sendkeys(buf, \":set diffopt-=context:1\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt+=context:0\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_06.0', {})\n  call term_sendkeys(buf, \":set diffopt-=context:0\\<cr>\")\n\n  \" Test 7 - 9: Test normal/patience/histogram diff algorithm\n  call WriteDiffFiles(buf, ['#include <stdio.h>', '', '// Frobs foo heartily', 'int frobnitz(int foo)', '{',\n      \\ '    int i;', '    for(i = 0; i < 10; i++)', '    {', '        printf(\"Your answer is: \");',\n      \\ '        printf(\"%d\\n\", foo);', '    }', '}', '', 'int fact(int n)', '{', '    if(n > 1)', '    {',\n      \\ '        return fact(n-1) * n;', '    }', '    return 1;', '}', '', 'int main(int argc, char **argv)',\n      \\ '{', '    frobnitz(fact(10));', '}'],\n      \\ ['#include <stdio.h>', '', 'int fib(int n)', '{', '    if(n > 2)', '    {',\n      \\ '        return fib(n-1) + fib(n-2);', '    }', '    return 1;', '}', '', '// Frobs foo heartily',\n      \\ 'int frobnitz(int foo)', '{', '    int i;', '    for(i = 0; i < 10; i++)', '    {',\n      \\ '        printf(\"%d\\n\", foo);', '    }', '}', '',\n      \\ 'int main(int argc, char **argv)', '{', '    frobnitz(fib(10));', '}'])\n  call term_sendkeys(buf, \":diffupdate!\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt+=internal\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_07', {})\n\n  call term_sendkeys(buf, \":set diffopt+=algorithm:patience\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_08', {})\n\n  call term_sendkeys(buf, \":set diffopt+=algorithm:histogram\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_09', {})\n\n  \" Test 10-11: normal/indent-heuristic\n  call term_sendkeys(buf, \":set diffopt&vim\\<cr>\")\n  call WriteDiffFiles(buf, ['', '  def finalize(values)', '', '    values.each do |v|', '      v.finalize', '    end'],\n      \\ ['', '  def finalize(values)', '', '    values.each do |v|', '      v.prepare', '    end', '',\n      \\ '    values.each do |v|', '      v.finalize', '    end'])\n  call term_sendkeys(buf, \":diffupdate!\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt+=internal\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_10', {})\n\n  \" Leave trailing : at commandline!\n  call term_sendkeys(buf, \":set diffopt+=indent-heuristic\\<cr>:\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_11', {}, 'one')\n  \" shouldn't matter, if indent-algorithm comes before or after the algorithm\n  call term_sendkeys(buf, \":set diffopt&\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt+=indent-heuristic,algorithm:patience\\<cr>:\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_11', {}, 'two')\n  call term_sendkeys(buf, \":set diffopt&\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt+=algorithm:patience,indent-heuristic\\<cr>:\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_11', {}, 'three')\n\n  \" Test 12: diff the same file\n  call WriteDiffFiles(buf, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n  call VerifyBoth(buf, 'Test_diff_12', '')\n\n  \" Test 13: diff an empty file\n  call WriteDiffFiles(buf, [], [])\n  call VerifyBoth(buf, 'Test_diff_13', '')\n\n  \" Test 14: test diffopt+=icase\n  call WriteDiffFiles(buf, ['a', 'b', 'cd'], ['A', 'b', 'cDe'])\n  call VerifyBoth(buf, 'Test_diff_14', \" diffopt+=filler diffopt+=icase\")\n\n  \" Test 15-16: test diffopt+=iwhite\n  call WriteDiffFiles(buf, ['int main()', '{', '   printf(\"Hello, World!\");', '   return 0;', '}'],\n      \\ ['int main()', '{', '   if (0)', '   {', '      printf(\"Hello, World!\");', '      return 0;', '   }', '}'])\n  call term_sendkeys(buf, \":diffupdate!\\<cr>\")\n  call term_sendkeys(buf, \":set diffopt&vim diffopt+=filler diffopt+=iwhite\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_15', {})\n  call term_sendkeys(buf, \":set diffopt+=internal\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_16', {})\n\n  \" Test 17: test diffopt+=iblank\n  call WriteDiffFiles(buf, ['a', ' ', 'cd', 'ef', 'xxx'], ['a', 'cd', '', 'ef', 'yyy'])\n  call VerifyInternal(buf, 'Test_diff_17', \" diffopt+=iblank\")\n\n  \" Test 18: test diffopt+=iblank,iwhite / iwhiteall / iwhiteeol\n  call VerifyInternal(buf, 'Test_diff_18', \" diffopt+=iblank,iwhite\")\n  call VerifyInternal(buf, 'Test_diff_18', \" diffopt+=iblank,iwhiteall\")\n  call VerifyInternal(buf, 'Test_diff_18', \" diffopt+=iblank,iwhiteeol\")\n\n  \" Test 19: test diffopt+=iwhiteeol\n  call WriteDiffFiles(buf, ['a ', 'x', 'cd', 'ef', 'xx  xx', 'foo', 'bar'], ['a', 'x', 'c d', ' ef', 'xx xx', 'foo', '', 'bar'])\n  call VerifyInternal(buf, 'Test_diff_19', \" diffopt+=iwhiteeol\")\n\n  \" Test 19: test diffopt+=iwhiteall\n  call VerifyInternal(buf, 'Test_diff_20', \" diffopt+=iwhiteall\")\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xfile1')\n  call delete('Xfile2')\n  call delete('XdiffSetup')\nendfunc\n\nfunc Test_diff_with_scroll_and_change()\n  CheckScreendump\n\n  let lines =<< trim END\n\tcall setline(1, range(1, 15))\n\tvnew\n\tcall setline(1, range(9, 15))\n\twindo diffthis\n\twincmd h\n\texe \"normal Gl5\\<C-E>\"\n  END\n  call writefile(lines, 'Xtest_scroll_change')\n  let buf = RunVimInTerminal('-S Xtest_scroll_change', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_scroll_change_01', {})\n\n  call term_sendkeys(buf, \"ax\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_diff_scroll_change_02', {})\n\n  call term_sendkeys(buf, \"\\<C-W>lay\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_diff_scroll_change_03', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_scroll_change')\nendfunc\n\nfunc Test_diff_with_cursorline()\n  CheckScreendump\n\n  call writefile([\n\t\\ 'hi CursorLine ctermbg=red ctermfg=white',\n\t\\ 'set cursorline',\n\t\\ 'call setline(1, [\"foo\",\"foo\",\"foo\",\"bar\"])',\n\t\\ 'vnew',\n\t\\ 'call setline(1, [\"bee\",\"foo\",\"foo\",\"baz\"])',\n\t\\ 'windo diffthis',\n\t\\ '2wincmd w',\n\t\\ ], 'Xtest_diff_cursorline')\n  let buf = RunVimInTerminal('-S Xtest_diff_cursorline', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_with_cursorline_01', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cursorline_02', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cursorline_03', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_cursorline')\nendfunc\n\nfunc Test_diff_with_cursorline_number()\n  CheckScreendump\n\n  let lines =<< trim END\n      hi CursorLine ctermbg=red ctermfg=white\n      hi CursorLineNr ctermbg=white ctermfg=black cterm=underline\n      set cursorline number\n      call setline(1, [\"baz\", \"foo\", \"foo\", \"bar\"])\n      2\n      vnew\n      call setline(1, [\"foo\", \"foo\", \"bar\"])\n      windo diffthis\n      1wincmd w\n  END\n  call writefile(lines, 'Xtest_diff_cursorline_number')\n  let buf = RunVimInTerminal('-S Xtest_diff_cursorline_number', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_with_cursorline_number_01', {})\n  call term_sendkeys(buf, \":set cursorlineopt=number\\r\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cursorline_number_02', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_cursorline_number')\nendfunc\n\nfunc Test_diff_with_cursorline_breakindent()\n  CheckScreendump\n\n  call writefile([\n\t\\ 'hi CursorLine ctermbg=red ctermfg=white',\n\t\\ 'set noequalalways wrap diffopt=followwrap cursorline breakindent',\n\t\\ '50vnew',\n\t\\ 'call setline(1, [\"  \",\"  \",\"  \",\"  \"])',\n\t\\ 'exe \"norm 20Afoo\\<Esc>j20Afoo\\<Esc>j20Afoo\\<Esc>j20Abar\\<Esc>\"',\n\t\\ 'vnew',\n\t\\ 'call setline(1, [\"  \",\"  \",\"  \",\"  \"])',\n\t\\ 'exe \"norm 20Abee\\<Esc>j20Afoo\\<Esc>j20Afoo\\<Esc>j20Abaz\\<Esc>\"',\n\t\\ 'windo diffthis',\n\t\\ '2wincmd w',\n\t\\ ], 'Xtest_diff_cursorline_breakindent')\n  let buf = RunVimInTerminal('-S Xtest_diff_cursorline_breakindent', {})\n\n  call term_sendkeys(buf, \"gg0\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cul_bri_01', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cul_bri_02', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cul_bri_03', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_with_cul_bri_04', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_cursorline_breakindent')\nendfunc\n\nfunc Test_diff_with_syntax()\n  CheckScreendump\n\n  let lines =<< trim END\n  \tvoid doNothing() {\n\t   int x = 0;\n\t   char *s = \"hello\";\n\t   return 5;\n\t}\n  END\n  call writefile(lines, 'Xprogram1.c')\n  let lines =<< trim END\n  \tvoid doSomething() {\n\t   int x = 0;\n\t   char *s = \"there\";\n\t   return 5;\n\t}\n  END\n  call writefile(lines, 'Xprogram2.c')\n\n  let lines =<< trim END\n  \tedit Xprogram1.c\n\tdiffsplit Xprogram2.c\n  END\n  call writefile(lines, 'Xtest_diff_syntax')\n  let buf = RunVimInTerminal('-S Xtest_diff_syntax', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_syntax_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_syntax')\n  call delete('Xprogram1.c')\n  call delete('Xprogram2.c')\nendfunc\n\nfunc Test_diff_of_diff()\n  CheckScreendump\n  CheckFeature rightleft\n\n  call writefile([\n\t\\ 'call setline(1, [\"aa\",\"bb\",\"cc\",\"@@ -3,2 +5,7 @@\",\"dd\",\"ee\",\"ff\"])',\n\t\\ 'vnew',\n\t\\ 'call setline(1, [\"aa\",\"bb\",\"cc\"])',\n\t\\ 'windo diffthis',\n\t\\ '1wincmd w',\n\t\\ 'setlocal number',\n\t\\ ], 'Xtest_diff_diff')\n  let buf = RunVimInTerminal('-S Xtest_diff_diff', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_of_diff_01', {})\n\n  call term_sendkeys(buf, \":set rightleft\\<cr>\")\n  call VerifyScreenDump(buf, 'Test_diff_of_diff_02', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_diff')\nendfunc\n\nfunc CloseoffSetup()\n  enew\n  call setline(1, ['one', 'two', 'three'])\n  diffthis\n  new\n  call setline(1, ['one', 'tow', 'three'])\n  diffthis\n  call assert_equal(1, &diff)\n  only!\nendfunc\n\nfunc Test_diff_closeoff()\n  \" \"closeoff\" included by default: last diff win gets 'diff' reset'\n  call CloseoffSetup()\n  call assert_equal(0, &diff)\n  enew!\n\n  \" \"closeoff\" excluded: last diff win keeps 'diff' set'\n  set diffopt-=closeoff\n  call CloseoffSetup()\n  call assert_equal(1, &diff)\n  diffoff!\n  enew!\nendfunc\n\nfunc Test_diff_followwrap()\n  new\n  set diffopt+=followwrap\n  set wrap\n  diffthis\n  call assert_equal(1, &wrap)\n  diffoff\n  set nowrap\n  diffthis\n  call assert_equal(0, &wrap)\n  diffoff\n  set diffopt&\n  bwipe!\nendfunc\n\nfunc Test_diff_maintains_change_mark()\n  func DiffMaintainsChangeMark()\n    enew!\n    call setline(1, ['a', 'b', 'c', 'd'])\n    diffthis\n    new\n    call setline(1, ['a', 'b', 'c', 'e'])\n    \" Set '[ and '] marks\n    2,3yank\n    call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n    \" Verify they aren't affected by the implicit diff\n    diffthis\n    call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n    \" Verify they aren't affected by an explicit diff\n    diffupdate\n    call assert_equal([2, 3], [line(\"'[\"), line(\"']\")])\n    bwipe!\n    bwipe!\n  endfunc\n\n  set diffopt-=internal\n  call DiffMaintainsChangeMark()\n  set diffopt+=internal\n  call DiffMaintainsChangeMark()\n\n  set diffopt&\n  delfunc DiffMaintainsChangeMark\nendfunc\n\n\" Test for 'patchexpr'\nfunc Test_patchexpr()\n  let g:patch_args = []\n  func TPatch()\n    call add(g:patch_args, readfile(v:fname_in))\n    call add(g:patch_args, readfile(v:fname_diff))\n    call writefile(['output file'], v:fname_out)\n  endfunc\n  set patchexpr=TPatch()\n\n  call writefile(['input file'], 'Xinput')\n  call writefile(['diff file'], 'Xdiff')\n  %bwipe!\n  edit Xinput\n  diffpatch Xdiff\n  call assert_equal('output file', getline(1))\n  call assert_equal('Xinput.new', bufname())\n  call assert_equal(2, winnr('$'))\n  call assert_true(&diff)\n\n  \" Using a script-local function\n  func s:NewPatchExpr()\n  endfunc\n  set patchexpr=s:NewPatchExpr()\n  call assert_equal(expand('<SID>') .. 'NewPatchExpr()', &patchexpr)\n  set patchexpr=<SID>NewPatchExpr()\n  call assert_equal(expand('<SID>') .. 'NewPatchExpr()', &patchexpr)\n\n  call delete('Xinput')\n  call delete('Xdiff')\n  set patchexpr&\n  delfunc TPatch\n  delfunc s:NewPatchExpr\n  %bwipe!\nendfunc\n\nfunc Test_diff_rnu()\n  CheckScreendump\n\n  let content =<< trim END\n    call setline(1, ['a', 'a', 'a', 'y', 'b', 'b', 'b', 'b', 'b'])\n    vnew\n    call setline(1, ['a', 'a', 'a', 'x', 'x', 'x', 'b', 'b', 'b', 'b', 'b'])\n    windo diffthis\n    setlocal number rnu foldcolumn=0\n  END\n  call writefile(content, 'Xtest_diff_rnu')\n  let buf = RunVimInTerminal('-S Xtest_diff_rnu', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_rnu_01', {})\n\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_rnu_02', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_rnu_03', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_rnu')\nendfunc\n\nfunc Test_diff_multilineconceal()\n  new\n  diffthis\n\n  new\n  call matchadd('Conceal', 'a\\nb', 9, -1, {'conceal': 'Y'})\n  set cole=2 cocu=n\n  call setline(1, [\"a\", \"b\"])\n  diffthis\n  redraw\nendfunc\n\nfunc Test_diff_and_scroll()\n  \" this was causing an ml_get error\n  set ls=2\n  for i in range(winheight(0) * 2) \n    call setline(i, i < winheight(0) - 10 ? i : i + 10) \n  endfor\n  vnew\n  for i in range(winheight(0)*2 + 10) \n    call setline(i, i < winheight(0) - 10 ? 0 : i) \n  endfor\n  diffthis\n  wincmd p\n  diffthis\n  execute 'normal ' . winheight(0) . \"\\<C-d>\"\n\n  bwipe!\n  bwipe!\n  set ls&\nendfunc\n\nfunc Test_diff_filler_cursorcolumn()\n  CheckScreendump\n\n  let content =<< trim END\n    call setline(1, ['aa', 'bb', 'cc'])\n    vnew\n    call setline(1, ['aa', 'cc'])\n    windo diffthis\n    wincmd p\n    setlocal cursorcolumn foldcolumn=0\n    norm! gg0\n    redraw!\n  END\n  call writefile(content, 'Xtest_diff_cuc')\n  let buf = RunVimInTerminal('-S Xtest_diff_cuc', {})\n\n  call VerifyScreenDump(buf, 'Test_diff_cuc_01', {})\n\n  call term_sendkeys(buf, \"l\")\n  call term_sendkeys(buf, \"\\<C-l>\")\n  call VerifyScreenDump(buf, 'Test_diff_cuc_02', {})\n  call term_sendkeys(buf, \"0j\")\n  call term_sendkeys(buf, \"\\<C-l>\")\n  call VerifyScreenDump(buf, 'Test_diff_cuc_03', {})\n  call term_sendkeys(buf, \"l\")\n  call term_sendkeys(buf, \"\\<C-l>\")\n  call VerifyScreenDump(buf, 'Test_diff_cuc_04', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_cuc')\nendfunc\n\n\" Test for adding/removing lines inside diff chunks, between diff chunks\n\" and before diff chunks\nfunc Test_diff_modify_chunks()\n  enew!\n  let w2_id = win_getid()\n  call setline(1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  new\n  let w1_id = win_getid()\n  call setline(1, ['a', '2', '3', 'd', 'e', 'f', '7', '8', 'i'])\n  windo diffthis\n\n  \" remove a line between two diff chunks and create a new diff chunk\n  call win_gotoid(w2_id)\n  5d\n  call win_gotoid(w1_id)\n  call diff_hlID(5, 1)->synIDattr('name')->assert_equal('DiffAdd')\n\n  \" add a line between two diff chunks\n  call win_gotoid(w2_id)\n  normal! 4Goe\n  call win_gotoid(w1_id)\n  call diff_hlID(4, 1)->synIDattr('name')->assert_equal('')\n  call diff_hlID(5, 1)->synIDattr('name')->assert_equal('')\n\n  \" remove all the lines in a diff chunk.\n  call win_gotoid(w2_id)\n  7,8d\n  call win_gotoid(w1_id)\n  let hl = range(1, 9)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', 'DiffText', 'DiffText', '', '', '', 'DiffAdd',\n        \\ 'DiffAdd', ''], hl)\n\n  \" remove lines from one diff chunk to just before the next diff chunk\n  call win_gotoid(w2_id)\n  call setline(1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  2,6d\n  call win_gotoid(w1_id)\n  let hl = range(1, 9)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', 'DiffText', 'DiffText', 'DiffAdd', 'DiffAdd',\n        \\ 'DiffAdd', 'DiffAdd', 'DiffAdd', ''], hl)\n\n  \" remove lines just before the top of a diff chunk\n  call win_gotoid(w2_id)\n  call setline(1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  5,6d\n  call win_gotoid(w1_id)\n  let hl = range(1, 9)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', 'DiffText', 'DiffText', '', 'DiffText', 'DiffText',\n        \\ 'DiffAdd', 'DiffAdd', ''], hl)\n\n  \" remove line after the end of a diff chunk\n  call win_gotoid(w2_id)\n  call setline(1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  4d\n  call win_gotoid(w1_id)\n  let hl = range(1, 9)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', 'DiffText', 'DiffText', 'DiffAdd', '', '', 'DiffText',\n        \\ 'DiffText', ''], hl)\n\n  \" remove lines starting from the end of one diff chunk and ending inside\n  \" another diff chunk\n  call win_gotoid(w2_id)\n  call setline(1, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'])\n  4,7d\n  call win_gotoid(w1_id)\n  let hl = range(1, 9)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', 'DiffText', 'DiffText', 'DiffText', 'DiffAdd',\n        \\ 'DiffAdd', 'DiffAdd', 'DiffAdd', ''], hl)\n\n  \" removing the only remaining diff chunk should make the files equal\n  call win_gotoid(w2_id)\n  call setline(1, ['a', '2', '3', 'x', 'd', 'e', 'f', 'x', '7', '8', 'i'])\n  8d\n  let hl = range(1, 10)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', '', '', 'DiffAdd', '', '', '', '', '', ''], hl)\n  call win_gotoid(w2_id)\n  4d\n  call win_gotoid(w1_id)\n  let hl = range(1, 9)->map({_, lnum -> diff_hlID(lnum, 1)->synIDattr('name')})\n  call assert_equal(['', '', '', '', '', '', '', '', ''], hl)\n\n  %bw!\nendfunc\n\nfunc Test_diff_binary()\n  CheckScreendump\n\n  let content =<< trim END\n    call setline(1, ['a', 'b', \"c\\n\", 'd', 'e', 'f', 'g'])\n    vnew\n    call setline(1, ['A', 'b', 'c', 'd', 'E', 'f', 'g'])\n    windo diffthis\n    wincmd p\n    norm! gg0\n    redraw!\n  END\n  call writefile(content, 'Xtest_diff_bin')\n  let buf = RunVimInTerminal('-S Xtest_diff_bin', {})\n\n  \" Test using internal diff\n  call VerifyScreenDump(buf, 'Test_diff_bin_01', {})\n\n  \" Test using internal diff and case folding\n  call term_sendkeys(buf, \":set diffopt+=icase\\<cr>\")\n  call term_sendkeys(buf, \"\\<C-l>\")\n  call VerifyScreenDump(buf, 'Test_diff_bin_02', {})\n  \" Test using external diff\n  call term_sendkeys(buf, \":set diffopt=filler\\<cr>\")\n  call term_sendkeys(buf, \"\\<C-l>\")\n  call VerifyScreenDump(buf, 'Test_diff_bin_03', {})\n  \" Test using external diff and case folding\n  call term_sendkeys(buf, \":set diffopt=filler,icase\\<cr>\")\n  call term_sendkeys(buf, \"\\<C-l>\")\n  call VerifyScreenDump(buf, 'Test_diff_bin_04', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\n  call delete('Xtest_diff_bin')\n  set diffopt&vim\nendfunc\n\n\" Test for using the 'zi' command to invert 'foldenable' in diff windows (test\n\" for the issue fixed by patch 6.2.317)\nfunc Test_diff_foldinvert()\n  %bw!\n  edit Xfile1\n  new Xfile2\n  new Xfile3\n  windo diffthis\n  \" open a non-diff window\n  botright new\n  1wincmd w\n  call assert_true(getwinvar(1, '&foldenable'))\n  call assert_true(getwinvar(2, '&foldenable'))\n  call assert_true(getwinvar(3, '&foldenable'))\n  normal zi\n  call assert_false(getwinvar(1, '&foldenable'))\n  call assert_false(getwinvar(2, '&foldenable'))\n  call assert_false(getwinvar(3, '&foldenable'))\n  normal zi\n  call assert_true(getwinvar(1, '&foldenable'))\n  call assert_true(getwinvar(2, '&foldenable'))\n  call assert_true(getwinvar(3, '&foldenable'))\n\n  \" If the current window has 'noscrollbind', then 'zi' should not change\n  \" 'foldenable' in other windows.\n  1wincmd w\n  set noscrollbind\n  normal zi\n  call assert_false(getwinvar(1, '&foldenable'))\n  call assert_true(getwinvar(2, '&foldenable'))\n  call assert_true(getwinvar(3, '&foldenable'))\n\n  \" 'zi' should not change the 'foldenable' for windows with 'noscrollbind'\n  1wincmd w\n  set scrollbind\n  normal zi\n  call setwinvar(2, '&scrollbind', v:false)\n  normal zi\n  call assert_false(getwinvar(1, '&foldenable'))\n  call assert_true(getwinvar(2, '&foldenable'))\n  call assert_false(getwinvar(3, '&foldenable'))\n\n  %bw!\n  set scrollbind&\nendfunc\n\n\" This was scrolling for 'cursorbind' but 'scrollbind' is more important\nfunc Test_diff_scroll()\n  CheckScreendump\n\n  let left =<< trim END\n      line 1\n      line 2\n      line 3\n      line 4\n\n      // Common block\n      // one\n      // containing\n      // four lines\n\n      // Common block\n      // two\n      // containing\n      // four lines\n  END\n  call writefile(left, 'Xleft')\n  let right =<< trim END\n      line 1\n      line 2\n      line 3\n      line 4\n\n      Lorem\n      ipsum\n      dolor\n      sit\n      amet,\n      consectetur\n      adipiscing\n      elit.\n      Etiam\n      luctus\n      lectus\n      sodales,\n      dictum\n\n      // Common block\n      // one\n      // containing\n      // four lines\n\n      Vestibulum\n      tincidunt\n      aliquet\n      nulla.\n\n      // Common block\n      // two\n      // containing\n      // four lines\n  END\n  call writefile(right, 'Xright')\n  let buf = RunVimInTerminal('-d Xleft Xright', {'rows': 12})\n  call term_sendkeys(buf, \"\\<C-W>\\<C-W>jjjj\")\n  call VerifyScreenDump(buf, 'Test_diff_scroll_1', {})\n  call term_sendkeys(buf, \"j\")\n  call VerifyScreenDump(buf, 'Test_diff_scroll_2', {})\n\n  call StopVimInTerminal(buf)\n  call delete('Xleft')\n  call delete('Xright')\nendfunc\n\n\" This was trying to update diffs for a buffer being closed\nfunc Test_diff_only()\n  silent! lfile\n  set diff\n  lopen\n  norm \u0017\u0018\u0017\u000eo\n  silent! norm \u0017\u000e\u0017o\n\n  set nodiff\n  %bwipe!\nendfunc\n\n\" This was causing invalid diff block values\n\" FIXME: somehow this causes a valgrind error when run directly but not when\n\" run as a test.\nfunc Test_diff_manipulations()\n  set diff\n  split 0\n  sil! norm R\r\u001bdoo\u001bbdeu\u0017\u0018R\r\u001bdoo\u001bbdeu\u0017\u0018R\r\u001bdoo\u001bbdeu\n\n  set nodiff\n  %bwipe!\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    5164,\n/**/\n    5163,\n/**/\n    5162,\n/**/\n    5161,\n/**/\n    5160,\n/**/\n    5159,\n/**/\n    5158,\n/**/\n    5157,\n/**/\n    5156,\n/**/\n    5155,\n/**/\n    5154,\n/**/\n    5153,\n/**/\n    5152,\n/**/\n    5151,\n/**/\n    5150,\n/**/\n    5149,\n/**/\n    5148,\n/**/\n    5147,\n/**/\n    5146,\n/**/\n    5145,\n/**/\n    5144,\n/**/\n    5143,\n/**/\n    5142,\n/**/\n    5141,\n/**/\n    5140,\n/**/\n    5139,\n/**/\n    5138,\n/**/\n    5137,\n/**/\n    5136,\n/**/\n    5135,\n/**/\n    5134,\n/**/\n    5133,\n/**/\n    5132,\n/**/\n    5131,\n/**/\n    5130,\n/**/\n    5129,\n/**/\n    5128,\n/**/\n    5127,\n/**/\n    5126,\n/**/\n    5125,\n/**/\n    5124,\n/**/\n    5123,\n/**/\n    5122,\n/**/\n    5121,\n/**/\n    5120,\n/**/\n    5119,\n/**/\n    5118,\n/**/\n    5117,\n/**/\n    5116,\n/**/\n    5115,\n/**/\n    5114,\n/**/\n    5113,\n/**/\n    5112,\n/**/\n    5111,\n/**/\n    5110,\n/**/\n    5109,\n/**/\n    5108,\n/**/\n    5107,\n/**/\n    5106,\n/**/\n    5105,\n/**/\n    5104,\n/**/\n    5103,\n/**/\n    5102,\n/**/\n    5101,\n/**/\n    5100,\n/**/\n    5099,\n/**/\n    5098,\n/**/\n    5097,\n/**/\n    5096,\n/**/\n    5095,\n/**/\n    5094,\n/**/\n    5093,\n/**/\n    5092,\n/**/\n    5091,\n/**/\n    5090,\n/**/\n    5089,\n/**/\n    5088,\n/**/\n    5087,\n/**/\n    5086,\n/**/\n    5085,\n/**/\n    5084,\n/**/\n    5083,\n/**/\n    5082,\n/**/\n    5081,\n/**/\n    5080,\n/**/\n    5079,\n/**/\n    5078,\n/**/\n    5077,\n/**/\n    5076,\n/**/\n    5075,\n/**/\n    5074,\n/**/\n    5073,\n/**/\n    5072,\n/**/\n    5071,\n/**/\n    5070,\n/**/\n    5069,\n/**/\n    5068,\n/**/\n    5067,\n/**/\n    5066,\n/**/\n    5065,\n/**/\n    5064,\n/**/\n    5063,\n/**/\n    5062,\n/**/\n    5061,\n/**/\n    5060,\n/**/\n    5059,\n/**/\n    5058,\n/**/\n    5057,\n/**/\n    5056,\n/**/\n    5055,\n/**/\n    5054,\n/**/\n    5053,\n/**/\n    5052,\n/**/\n    5051,\n/**/\n    5050,\n/**/\n    5049,\n/**/\n    5048,\n/**/\n    5047,\n/**/\n    5046,\n/**/\n    5045,\n/**/\n    5044,\n/**/\n    5043,\n/**/\n    5042,\n/**/\n    5041,\n/**/\n    5040,\n/**/\n    5039,\n/**/\n    5038,\n/**/\n    5037,\n/**/\n    5036,\n/**/\n    5035,\n/**/\n    5034,\n/**/\n    5033,\n/**/\n    5032,\n/**/\n    5031,\n/**/\n    5030,\n/**/\n    5029,\n/**/\n    5028,\n/**/\n    5027,\n/**/\n    5026,\n/**/\n    5025,\n/**/\n    5024,\n/**/\n    5023,\n/**/\n    5022,\n/**/\n    5021,\n/**/\n    5020,\n/**/\n    5019,\n/**/\n    5018,\n/**/\n    5017,\n/**/\n    5016,\n/**/\n    5015,\n/**/\n    5014,\n/**/\n    5013,\n/**/\n    5012,\n/**/\n    5011,\n/**/\n    5010,\n/**/\n    5009,\n/**/\n    5008,\n/**/\n    5007,\n/**/\n    5006,\n/**/\n    5005,\n/**/\n    5004,\n/**/\n    5003,\n/**/\n    5002,\n/**/\n    5001,\n/**/\n    5000,\n/**/\n    4999,\n/**/\n    4998,\n/**/\n    4997,\n/**/\n    4996,\n/**/\n    4995,\n/**/\n    4994,\n/**/\n    4993,\n/**/\n    4992,\n/**/\n    4991,\n/**/\n    4990,\n/**/\n    4989,\n/**/\n    4988,\n/**/\n    4987,\n/**/\n    4986,\n/**/\n    4985,\n/**/\n    4984,\n/**/\n    4983,\n/**/\n    4982,\n/**/\n    4981,\n/**/\n    4980,\n/**/\n    4979,\n/**/\n    4978,\n/**/\n    4977,\n/**/\n    4976,\n/**/\n    4975,\n/**/\n    4974,\n/**/\n    4973,\n/**/\n    4972,\n/**/\n    4971,\n/**/\n    4970,\n/**/\n    4969,\n/**/\n    4968,\n/**/\n    4967,\n/**/\n    4966,\n/**/\n    4965,\n/**/\n    4964,\n/**/\n    4963,\n/**/\n    4962,\n/**/\n    4961,\n/**/\n    4960,\n/**/\n    4959,\n/**/\n    4958,\n/**/\n    4957,\n/**/\n    4956,\n/**/\n    4955,\n/**/\n    4954,\n/**/\n    4953,\n/**/\n    4952,\n/**/\n    4951,\n/**/\n    4950,\n/**/\n    4949,\n/**/\n    4948,\n/**/\n    4947,\n/**/\n    4946,\n/**/\n    4945,\n/**/\n    4944,\n/**/\n    4943,\n/**/\n    4942,\n/**/\n    4941,\n/**/\n    4940,\n/**/\n    4939,\n/**/\n    4938,\n/**/\n    4937,\n/**/\n    4936,\n/**/\n    4935,\n/**/\n    4934,\n/**/\n    4933,\n/**/\n    4932,\n/**/\n    4931,\n/**/\n    4930,\n/**/\n    4929,\n/**/\n    4928,\n/**/\n    4927,\n/**/\n    4926,\n/**/\n    4925,\n/**/\n    4924,\n/**/\n    4923,\n/**/\n    4922,\n/**/\n    4921,\n/**/\n    4920,\n/**/\n    4919,\n/**/\n    4918,\n/**/\n    4917,\n/**/\n    4916,\n/**/\n    4915,\n/**/\n    4914,\n/**/\n    4913,\n/**/\n    4912,\n/**/\n    4911,\n/**/\n    4910,\n/**/\n    4909,\n/**/\n    4908,\n/**/\n    4907,\n/**/\n    4906,\n/**/\n    4905,\n/**/\n    4904,\n/**/\n    4903,\n/**/\n    4902,\n/**/\n    4901,\n/**/\n    4900,\n/**/\n    4899,\n/**/\n    4898,\n/**/\n    4897,\n/**/\n    4896,\n/**/\n    4895,\n/**/\n    4894,\n/**/\n    4893,\n/**/\n    4892,\n/**/\n    4891,\n/**/\n    4890,\n/**/\n    4889,\n/**/\n    4888,\n/**/\n    4887,\n/**/\n    4886,\n/**/\n    4885,\n/**/\n    4884,\n/**/\n    4883,\n/**/\n    4882,\n/**/\n    4881,\n/**/\n    4880,\n/**/\n    4879,\n/**/\n    4878,\n/**/\n    4877,\n/**/\n    4876,\n/**/\n    4875,\n/**/\n    4874,\n/**/\n    4873,\n/**/\n    4872,\n/**/\n    4871,\n/**/\n    4870,\n/**/\n    4869,\n/**/\n    4868,\n/**/\n    4867,\n/**/\n    4866,\n/**/\n    4865,\n/**/\n    4864,\n/**/\n    4863,\n/**/\n    4862,\n/**/\n    4861,\n/**/\n    4860,\n/**/\n    4859,\n/**/\n    4858,\n/**/\n    4857,\n/**/\n    4856,\n/**/\n    4855,\n/**/\n    4854,\n/**/\n    4853,\n/**/\n    4852,\n/**/\n    4851,\n/**/\n    4850,\n/**/\n    4849,\n/**/\n    4848,\n/**/\n    4847,\n/**/\n    4846,\n/**/\n    4845,\n/**/\n    4844,\n/**/\n    4843,\n/**/\n    4842,\n/**/\n    4841,\n/**/\n    4840,\n/**/\n    4839,\n/**/\n    4838,\n/**/\n    4837,\n/**/\n    4836,\n/**/\n    4835,\n/**/\n    4834,\n/**/\n    4833,\n/**/\n    4832,\n/**/\n    4831,\n/**/\n    4830,\n/**/\n    4829,\n/**/\n    4828,\n/**/\n    4827,\n/**/\n    4826,\n/**/\n    4825,\n/**/\n    4824,\n/**/\n    4823,\n/**/\n    4822,\n/**/\n    4821,\n/**/\n    4820,\n/**/\n    4819,\n/**/\n    4818,\n/**/\n    4817,\n/**/\n    4816,\n/**/\n    4815,\n/**/\n    4814,\n/**/\n    4813,\n/**/\n    4812,\n/**/\n    4811,\n/**/\n    4810,\n/**/\n    4809,\n/**/\n    4808,\n/**/\n    4807,\n/**/\n    4806,\n/**/\n    4805,\n/**/\n    4804,\n/**/\n    4803,\n/**/\n    4802,\n/**/\n    4801,\n/**/\n    4800,\n/**/\n    4799,\n/**/\n    4798,\n/**/\n    4797,\n/**/\n    4796,\n/**/\n    4795,\n/**/\n    4794,\n/**/\n    4793,\n/**/\n    4792,\n/**/\n    4791,\n/**/\n    4790,\n/**/\n    4789,\n/**/\n    4788,\n/**/\n    4787,\n/**/\n    4786,\n/**/\n    4785,\n/**/\n    4784,\n/**/\n    4783,\n/**/\n    4782,\n/**/\n    4781,\n/**/\n    4780,\n/**/\n    4779,\n/**/\n    4778,\n/**/\n    4777,\n/**/\n    4776,\n/**/\n    4775,\n/**/\n    4774,\n/**/\n    4773,\n/**/\n    4772,\n/**/\n    4771,\n/**/\n    4770,\n/**/\n    4769,\n/**/\n    4768,\n/**/\n    4767,\n/**/\n    4766,\n/**/\n    4765,\n/**/\n    4764,\n/**/\n    4763,\n/**/\n    4762,\n/**/\n    4761,\n/**/\n    4760,\n/**/\n    4759,\n/**/\n    4758,\n/**/\n    4757,\n/**/\n    4756,\n/**/\n    4755,\n/**/\n    4754,\n/**/\n    4753,\n/**/\n    4752,\n/**/\n    4751,\n/**/\n    4750,\n/**/\n    4749,\n/**/\n    4748,\n/**/\n    4747,\n/**/\n    4746,\n/**/\n    4745,\n/**/\n    4744,\n/**/\n    4743,\n/**/\n    4742,\n/**/\n    4741,\n/**/\n    4740,\n/**/\n    4739,\n/**/\n    4738,\n/**/\n    4737,\n/**/\n    4736,\n/**/\n    4735,\n/**/\n    4734,\n/**/\n    4733,\n/**/\n    4732,\n/**/\n    4731,\n/**/\n    4730,\n/**/\n    4729,\n/**/\n    4728,\n/**/\n    4727,\n/**/\n    4726,\n/**/\n    4725,\n/**/\n    4724,\n/**/\n    4723,\n/**/\n    4722,\n/**/\n    4721,\n/**/\n    4720,\n/**/\n    4719,\n/**/\n    4718,\n/**/\n    4717,\n/**/\n    4716,\n/**/\n    4715,\n/**/\n    4714,\n/**/\n    4713,\n/**/\n    4712,\n/**/\n    4711,\n/**/\n    4710,\n/**/\n    4709,\n/**/\n    4708,\n/**/\n    4707,\n/**/\n    4706,\n/**/\n    4705,\n/**/\n    4704,\n/**/\n    4703,\n/**/\n    4702,\n/**/\n    4701,\n/**/\n    4700,\n/**/\n    4699,\n/**/\n    4698,\n/**/\n    4697,\n/**/\n    4696,\n/**/\n    4695,\n/**/\n    4694,\n/**/\n    4693,\n/**/\n    4692,\n/**/\n    4691,\n/**/\n    4690,\n/**/\n    4689,\n/**/\n    4688,\n/**/\n    4687,\n/**/\n    4686,\n/**/\n    4685,\n/**/\n    4684,\n/**/\n    4683,\n/**/\n    4682,\n/**/\n    4681,\n/**/\n    4680,\n/**/\n    4679,\n/**/\n    4678,\n/**/\n    4677,\n/**/\n    4676,\n/**/\n    4675,\n/**/\n    4674,\n/**/\n    4673,\n/**/\n    4672,\n/**/\n    4671,\n/**/\n    4670,\n/**/\n    4669,\n/**/\n    4668,\n/**/\n    4667,\n/**/\n    4666,\n/**/\n    4665,\n/**/\n    4664,\n/**/\n    4663,\n/**/\n    4662,\n/**/\n    4661,\n/**/\n    4660,\n/**/\n    4659,\n/**/\n    4658,\n/**/\n    4657,\n/**/\n    4656,\n/**/\n    4655,\n/**/\n    4654,\n/**/\n    4653,\n/**/\n    4652,\n/**/\n    4651,\n/**/\n    4650,\n/**/\n    4649,\n/**/\n    4648,\n/**/\n    4647,\n/**/\n    4646,\n/**/\n    4645,\n/**/\n    4644,\n/**/\n    4643,\n/**/\n    4642,\n/**/\n    4641,\n/**/\n    4640,\n/**/\n    4639,\n/**/\n    4638,\n/**/\n    4637,\n/**/\n    4636,\n/**/\n    4635,\n/**/\n    4634,\n/**/\n    4633,\n/**/\n    4632,\n/**/\n    4631,\n/**/\n    4630,\n/**/\n    4629,\n/**/\n    4628,\n/**/\n    4627,\n/**/\n    4626,\n/**/\n    4625,\n/**/\n    4624,\n/**/\n    4623,\n/**/\n    4622,\n/**/\n    4621,\n/**/\n    4620,\n/**/\n    4619,\n/**/\n    4618,\n/**/\n    4617,\n/**/\n    4616,\n/**/\n    4615,\n/**/\n    4614,\n/**/\n    4613,\n/**/\n    4612,\n/**/\n    4611,\n/**/\n    4610,\n/**/\n    4609,\n/**/\n    4608,\n/**/\n    4607,\n/**/\n    4606,\n/**/\n    4605,\n/**/\n    4604,\n/**/\n    4603,\n/**/\n    4602,\n/**/\n    4601,\n/**/\n    4600,\n/**/\n    4599,\n/**/\n    4598,\n/**/\n    4597,\n/**/\n    4596,\n/**/\n    4595,\n/**/\n    4594,\n/**/\n    4593,\n/**/\n    4592,\n/**/\n    4591,\n/**/\n    4590,\n/**/\n    4589,\n/**/\n    4588,\n/**/\n    4587,\n/**/\n    4586,\n/**/\n    4585,\n/**/\n    4584,\n/**/\n    4583,\n/**/\n    4582,\n/**/\n    4581,\n/**/\n    4580,\n/**/\n    4579,\n/**/\n    4578,\n/**/\n    4577,\n/**/\n    4576,\n/**/\n    4575,\n/**/\n    4574,\n/**/\n    4573,\n/**/\n    4572,\n/**/\n    4571,\n/**/\n    4570,\n/**/\n    4569,\n/**/\n    4568,\n/**/\n    4567,\n/**/\n    4566,\n/**/\n    4565,\n/**/\n    4564,\n/**/\n    4563,\n/**/\n    4562,\n/**/\n    4561,\n/**/\n    4560,\n/**/\n    4559,\n/**/\n    4558,\n/**/\n    4557,\n/**/\n    4556,\n/**/\n    4555,\n/**/\n    4554,\n/**/\n    4553,\n/**/\n    4552,\n/**/\n    4551,\n/**/\n    4550,\n/**/\n    4549,\n/**/\n    4548,\n/**/\n    4547,\n/**/\n    4546,\n/**/\n    4545,\n/**/\n    4544,\n/**/\n    4543,\n/**/\n    4542,\n/**/\n    4541,\n/**/\n    4540,\n/**/\n    4539,\n/**/\n    4538,\n/**/\n    4537,\n/**/\n    4536,\n/**/\n    4535,\n/**/\n    4534,\n/**/\n    4533,\n/**/\n    4532,\n/**/\n    4531,\n/**/\n    4530,\n/**/\n    4529,\n/**/\n    4528,\n/**/\n    4527,\n/**/\n    4526,\n/**/\n    4525,\n/**/\n    4524,\n/**/\n    4523,\n/**/\n    4522,\n/**/\n    4521,\n/**/\n    4520,\n/**/\n    4519,\n/**/\n    4518,\n/**/\n    4517,\n/**/\n    4516,\n/**/\n    4515,\n/**/\n    4514,\n/**/\n    4513,\n/**/\n    4512,\n/**/\n    4511,\n/**/\n    4510,\n/**/\n    4509,\n/**/\n    4508,\n/**/\n    4507,\n/**/\n    4506,\n/**/\n    4505,\n/**/\n    4504,\n/**/\n    4503,\n/**/\n    4502,\n/**/\n    4501,\n/**/\n    4500,\n/**/\n    4499,\n/**/\n    4498,\n/**/\n    4497,\n/**/\n    4496,\n/**/\n    4495,\n/**/\n    4494,\n/**/\n    4493,\n/**/\n    4492,\n/**/\n    4491,\n/**/\n    4490,\n/**/\n    4489,\n/**/\n    4488,\n/**/\n    4487,\n/**/\n    4486,\n/**/\n    4485,\n/**/\n    4484,\n/**/\n    4483,\n/**/\n    4482,\n/**/\n    4481,\n/**/\n    4480,\n/**/\n    4479,\n/**/\n    4478,\n/**/\n    4477,\n/**/\n    4476,\n/**/\n    4475,\n/**/\n    4474,\n/**/\n    4473,\n/**/\n    4472,\n/**/\n    4471,\n/**/\n    4470,\n/**/\n    4469,\n/**/\n    4468,\n/**/\n    4467,\n/**/\n    4466,\n/**/\n    4465,\n/**/\n    4464,\n/**/\n    4463,\n/**/\n    4462,\n/**/\n    4461,\n/**/\n    4460,\n/**/\n    4459,\n/**/\n    4458,\n/**/\n    4457,\n/**/\n    4456,\n/**/\n    4455,\n/**/\n    4454,\n/**/\n    4453,\n/**/\n    4452,\n/**/\n    4451,\n/**/\n    4450,\n/**/\n    4449,\n/**/\n    4448,\n/**/\n    4447,\n/**/\n    4446,\n/**/\n    4445,\n/**/\n    4444,\n/**/\n    4443,\n/**/\n    4442,\n/**/\n    4441,\n/**/\n    4440,\n/**/\n    4439,\n/**/\n    4438,\n/**/\n    4437,\n/**/\n    4436,\n/**/\n    4435,\n/**/\n    4434,\n/**/\n    4433,\n/**/\n    4432,\n/**/\n    4431,\n/**/\n    4430,\n/**/\n    4429,\n/**/\n    4428,\n/**/\n    4427,\n/**/\n    4426,\n/**/\n    4425,\n/**/\n    4424,\n/**/\n    4423,\n/**/\n    4422,\n/**/\n    4421,\n/**/\n    4420,\n/**/\n    4419,\n/**/\n    4418,\n/**/\n    4417,\n/**/\n    4416,\n/**/\n    4415,\n/**/\n    4414,\n/**/\n    4413,\n/**/\n    4412,\n/**/\n    4411,\n/**/\n    4410,\n/**/\n    4409,\n/**/\n    4408,\n/**/\n    4407,\n/**/\n    4406,\n/**/\n    4405,\n/**/\n    4404,\n/**/\n    4403,\n/**/\n    4402,\n/**/\n    4401,\n/**/\n    4400,\n/**/\n    4399,\n/**/\n    4398,\n/**/\n    4397,\n/**/\n    4396,\n/**/\n    4395,\n/**/\n    4394,\n/**/\n    4393,\n/**/\n    4392,\n/**/\n    4391,\n/**/\n    4390,\n/**/\n    4389,\n/**/\n    4388,\n/**/\n    4387,\n/**/\n    4386,\n/**/\n    4385,\n/**/\n    4384,\n/**/\n    4383,\n/**/\n    4382,\n/**/\n    4381,\n/**/\n    4380,\n/**/\n    4379,\n/**/\n    4378,\n/**/\n    4377,\n/**/\n    4376,\n/**/\n    4375,\n/**/\n    4374,\n/**/\n    4373,\n/**/\n    4372,\n/**/\n    4371,\n/**/\n    4370,\n/**/\n    4369,\n/**/\n    4368,\n/**/\n    4367,\n/**/\n    4366,\n/**/\n    4365,\n/**/\n    4364,\n/**/\n    4363,\n/**/\n    4362,\n/**/\n    4361,\n/**/\n    4360,\n/**/\n    4359,\n/**/\n    4358,\n/**/\n    4357,\n/**/\n    4356,\n/**/\n    4355,\n/**/\n    4354,\n/**/\n    4353,\n/**/\n    4352,\n/**/\n    4351,\n/**/\n    4350,\n/**/\n    4349,\n/**/\n    4348,\n/**/\n    4347,\n/**/\n    4346,\n/**/\n    4345,\n/**/\n    4344,\n/**/\n    4343,\n/**/\n    4342,\n/**/\n    4341,\n/**/\n    4340,\n/**/\n    4339,\n/**/\n    4338,\n/**/\n    4337,\n/**/\n    4336,\n/**/\n    4335,\n/**/\n    4334,\n/**/\n    4333,\n/**/\n    4332,\n/**/\n    4331,\n/**/\n    4330,\n/**/\n    4329,\n/**/\n    4328,\n/**/\n    4327,\n/**/\n    4326,\n/**/\n    4325,\n/**/\n    4324,\n/**/\n    4323,\n/**/\n    4322,\n/**/\n    4321,\n/**/\n    4320,\n/**/\n    4319,\n/**/\n    4318,\n/**/\n    4317,\n/**/\n    4316,\n/**/\n    4315,\n/**/\n    4314,\n/**/\n    4313,\n/**/\n    4312,\n/**/\n    4311,\n/**/\n    4310,\n/**/\n    4309,\n/**/\n    4308,\n/**/\n    4307,\n/**/\n    4306,\n/**/\n    4305,\n/**/\n    4304,\n/**/\n    4303,\n/**/\n    4302,\n/**/\n    4301,\n/**/\n    4300,\n/**/\n    4299,\n/**/\n    4298,\n/**/\n    4297,\n/**/\n    4296,\n/**/\n    4295,\n/**/\n    4294,\n/**/\n    4293,\n/**/\n    4292,\n/**/\n    4291,\n/**/\n    4290,\n/**/\n    4289,\n/**/\n    4288,\n/**/\n    4287,\n/**/\n    4286,\n/**/\n    4285,\n/**/\n    4284,\n/**/\n    4283,\n/**/\n    4282,\n/**/\n    4281,\n/**/\n    4280,\n/**/\n    4279,\n/**/\n    4278,\n/**/\n    4277,\n/**/\n    4276,\n/**/\n    4275,\n/**/\n    4274,\n/**/\n    4273,\n/**/\n    4272,\n/**/\n    4271,\n/**/\n    4270,\n/**/\n    4269,\n/**/\n    4268,\n/**/\n    4267,\n/**/\n    4266,\n/**/\n    4265,\n/**/\n    4264,\n/**/\n    4263,\n/**/\n    4262,\n/**/\n    4261,\n/**/\n    4260,\n/**/\n    4259,\n/**/\n    4258,\n/**/\n    4257,\n/**/\n    4256,\n/**/\n    4255,\n/**/\n    4254,\n/**/\n    4253,\n/**/\n    4252,\n/**/\n    4251,\n/**/\n    4250,\n/**/\n    4249,\n/**/\n    4248,\n/**/\n    4247,\n/**/\n    4246,\n/**/\n    4245,\n/**/\n    4244,\n/**/\n    4243,\n/**/\n    4242,\n/**/\n    4241,\n/**/\n    4240,\n/**/\n    4239,\n/**/\n    4238,\n/**/\n    4237,\n/**/\n    4236,\n/**/\n    4235,\n/**/\n    4234,\n/**/\n    4233,\n/**/\n    4232,\n/**/\n    4231,\n/**/\n    4230,\n/**/\n    4229,\n/**/\n    4228,\n/**/\n    4227,\n/**/\n    4226,\n/**/\n    4225,\n/**/\n    4224,\n/**/\n    4223,\n/**/\n    4222,\n/**/\n    4221,\n/**/\n    4220,\n/**/\n    4219,\n/**/\n    4218,\n/**/\n    4217,\n/**/\n    4216,\n/**/\n    4215,\n/**/\n    4214,\n/**/\n    4213,\n/**/\n    4212,\n/**/\n    4211,\n/**/\n    4210,\n/**/\n    4209,\n/**/\n    4208,\n/**/\n    4207,\n/**/\n    4206,\n/**/\n    4205,\n/**/\n    4204,\n/**/\n    4203,\n/**/\n    4202,\n/**/\n    4201,\n/**/\n    4200,\n/**/\n    4199,\n/**/\n    4198,\n/**/\n    4197,\n/**/\n    4196,\n/**/\n    4195,\n/**/\n    4194,\n/**/\n    4193,\n/**/\n    4192,\n/**/\n    4191,\n/**/\n    4190,\n/**/\n    4189,\n/**/\n    4188,\n/**/\n    4187,\n/**/\n    4186,\n/**/\n    4185,\n/**/\n    4184,\n/**/\n    4183,\n/**/\n    4182,\n/**/\n    4181,\n/**/\n    4180,\n/**/\n    4179,\n/**/\n    4178,\n/**/\n    4177,\n/**/\n    4176,\n/**/\n    4175,\n/**/\n    4174,\n/**/\n    4173,\n/**/\n    4172,\n/**/\n    4171,\n/**/\n    4170,\n/**/\n    4169,\n/**/\n    4168,\n/**/\n    4167,\n/**/\n    4166,\n/**/\n    4165,\n/**/\n    4164,\n/**/\n    4163,\n/**/\n    4162,\n/**/\n    4161,\n/**/\n    4160,\n/**/\n    4159,\n/**/\n    4158,\n/**/\n    4157,\n/**/\n    4156,\n/**/\n    4155,\n/**/\n    4154,\n/**/\n    4153,\n/**/\n    4152,\n/**/\n    4151,\n/**/\n    4150,\n/**/\n    4149,\n/**/\n    4148,\n/**/\n    4147,\n/**/\n    4146,\n/**/\n    4145,\n/**/\n    4144,\n/**/\n    4143,\n/**/\n    4142,\n/**/\n    4141,\n/**/\n    4140,\n/**/\n    4139,\n/**/\n    4138,\n/**/\n    4137,\n/**/\n    4136,\n/**/\n    4135,\n/**/\n    4134,\n/**/\n    4133,\n/**/\n    4132,\n/**/\n    4131,\n/**/\n    4130,\n/**/\n    4129,\n/**/\n    4128,\n/**/\n    4127,\n/**/\n    4126,\n/**/\n    4125,\n/**/\n    4124,\n/**/\n    4123,\n/**/\n    4122,\n/**/\n    4121,\n/**/\n    4120,\n/**/\n    4119,\n/**/\n    4118,\n/**/\n    4117,\n/**/\n    4116,\n/**/\n    4115,\n/**/\n    4114,\n/**/\n    4113,\n/**/\n    4112,\n/**/\n    4111,\n/**/\n    4110,\n/**/\n    4109,\n/**/\n    4108,\n/**/\n    4107,\n/**/\n    4106,\n/**/\n    4105,\n/**/\n    4104,\n/**/\n    4103,\n/**/\n    4102,\n/**/\n    4101,\n/**/\n    4100,\n/**/\n    4099,\n/**/\n    4098,\n/**/\n    4097,\n/**/\n    4096,\n/**/\n    4095,\n/**/\n    4094,\n/**/\n    4093,\n/**/\n    4092,\n/**/\n    4091,\n/**/\n    4090,\n/**/\n    4089,\n/**/\n    4088,\n/**/\n    4087,\n/**/\n    4086,\n/**/\n    4085,\n/**/\n    4084,\n/**/\n    4083,\n/**/\n    4082,\n/**/\n    4081,\n/**/\n    4080,\n/**/\n    4079,\n/**/\n    4078,\n/**/\n    4077,\n/**/\n    4076,\n/**/\n    4075,\n/**/\n    4074,\n/**/\n    4073,\n/**/\n    4072,\n/**/\n    4071,\n/**/\n    4070,\n/**/\n    4069,\n/**/\n    4068,\n/**/\n    4067,\n/**/\n    4066,\n/**/\n    4065,\n/**/\n    4064,\n/**/\n    4063,\n/**/\n    4062,\n/**/\n    4061,\n/**/\n    4060,\n/**/\n    4059,\n/**/\n    4058,\n/**/\n    4057,\n/**/\n    4056,\n/**/\n    4055,\n/**/\n    4054,\n/**/\n    4053,\n/**/\n    4052,\n/**/\n    4051,\n/**/\n    4050,\n/**/\n    4049,\n/**/\n    4048,\n/**/\n    4047,\n/**/\n    4046,\n/**/\n    4045,\n/**/\n    4044,\n/**/\n    4043,\n/**/\n    4042,\n/**/\n    4041,\n/**/\n    4040,\n/**/\n    4039,\n/**/\n    4038,\n/**/\n    4037,\n/**/\n    4036,\n/**/\n    4035,\n/**/\n    4034,\n/**/\n    4033,\n/**/\n    4032,\n/**/\n    4031,\n/**/\n    4030,\n/**/\n    4029,\n/**/\n    4028,\n/**/\n    4027,\n/**/\n    4026,\n/**/\n    4025,\n/**/\n    4024,\n/**/\n    4023,\n/**/\n    4022,\n/**/\n    4021,\n/**/\n    4020,\n/**/\n    4019,\n/**/\n    4018,\n/**/\n    4017,\n/**/\n    4016,\n/**/\n    4015,\n/**/\n    4014,\n/**/\n    4013,\n/**/\n    4012,\n/**/\n    4011,\n/**/\n    4010,\n/**/\n    4009,\n/**/\n    4008,\n/**/\n    4007,\n/**/\n    4006,\n/**/\n    4005,\n/**/\n    4004,\n/**/\n    4003,\n/**/\n    4002,\n/**/\n    4001,\n/**/\n    4000,\n/**/\n    3999,\n/**/\n    3998,\n/**/\n    3997,\n/**/\n    3996,\n/**/\n    3995,\n/**/\n    3994,\n/**/\n    3993,\n/**/\n    3992,\n/**/\n    3991,\n/**/\n    3990,\n/**/\n    3989,\n/**/\n    3988,\n/**/\n    3987,\n/**/\n    3986,\n/**/\n    3985,\n/**/\n    3984,\n/**/\n    3983,\n/**/\n    3982,\n/**/\n    3981,\n/**/\n    3980,\n/**/\n    3979,\n/**/\n    3978,\n/**/\n    3977,\n/**/\n    3976,\n/**/\n    3975,\n/**/\n    3974,\n/**/\n    3973,\n/**/\n    3972,\n/**/\n    3971,\n/**/\n    3970,\n/**/\n    3969,\n/**/\n    3968,\n/**/\n    3967,\n/**/\n    3966,\n/**/\n    3965,\n/**/\n    3964,\n/**/\n    3963,\n/**/\n    3962,\n/**/\n    3961,\n/**/\n    3960,\n/**/\n    3959,\n/**/\n    3958,\n/**/\n    3957,\n/**/\n    3956,\n/**/\n    3955,\n/**/\n    3954,\n/**/\n    3953,\n/**/\n    3952,\n/**/\n    3951,\n/**/\n    3950,\n/**/\n    3949,\n/**/\n    3948,\n/**/\n    3947,\n/**/\n    3946,\n/**/\n    3945,\n/**/\n    3944,\n/**/\n    3943,\n/**/\n    3942,\n/**/\n    3941,\n/**/\n    3940,\n/**/\n    3939,\n/**/\n    3938,\n/**/\n    3937,\n/**/\n    3936,\n/**/\n    3935,\n/**/\n    3934,\n/**/\n    3933,\n/**/\n    3932,\n/**/\n    3931,\n/**/\n    3930,\n/**/\n    3929,\n/**/\n    3928,\n/**/\n    3927,\n/**/\n    3926,\n/**/\n    3925,\n/**/\n    3924,\n/**/\n    3923,\n/**/\n    3922,\n/**/\n    3921,\n/**/\n    3920,\n/**/\n    3919,\n/**/\n    3918,\n/**/\n    3917,\n/**/\n    3916,\n/**/\n    3915,\n/**/\n    3914,\n/**/\n    3913,\n/**/\n    3912,\n/**/\n    3911,\n/**/\n    3910,\n/**/\n    3909,\n/**/\n    3908,\n/**/\n    3907,\n/**/\n    3906,\n/**/\n    3905,\n/**/\n    3904,\n/**/\n    3903,\n/**/\n    3902,\n/**/\n    3901,\n/**/\n    3900,\n/**/\n    3899,\n/**/\n    3898,\n/**/\n    3897,\n/**/\n    3896,\n/**/\n    3895,\n/**/\n    3894,\n/**/\n    3893,\n/**/\n    3892,\n/**/\n    3891,\n/**/\n    3890,\n/**/\n    3889,\n/**/\n    3888,\n/**/\n    3887,\n/**/\n    3886,\n/**/\n    3885,\n/**/\n    3884,\n/**/\n    3883,\n/**/\n    3882,\n/**/\n    3881,\n/**/\n    3880,\n/**/\n    3879,\n/**/\n    3878,\n/**/\n    3877,\n/**/\n    3876,\n/**/\n    3875,\n/**/\n    3874,\n/**/\n    3873,\n/**/\n    3872,\n/**/\n    3871,\n/**/\n    3870,\n/**/\n    3869,\n/**/\n    3868,\n/**/\n    3867,\n/**/\n    3866,\n/**/\n    3865,\n/**/\n    3864,\n/**/\n    3863,\n/**/\n    3862,\n/**/\n    3861,\n/**/\n    3860,\n/**/\n    3859,\n/**/\n    3858,\n/**/\n    3857,\n/**/\n    3856,\n/**/\n    3855,\n/**/\n    3854,\n/**/\n    3853,\n/**/\n    3852,\n/**/\n    3851,\n/**/\n    3850,\n/**/\n    3849,\n/**/\n    3848,\n/**/\n    3847,\n/**/\n    3846,\n/**/\n    3845,\n/**/\n    3844,\n/**/\n    3843,\n/**/\n    3842,\n/**/\n    3841,\n/**/\n    3840,\n/**/\n    3839,\n/**/\n    3838,\n/**/\n    3837,\n/**/\n    3836,\n/**/\n    3835,\n/**/\n    3834,\n/**/\n    3833,\n/**/\n    3832,\n/**/\n    3831,\n/**/\n    3830,\n/**/\n    3829,\n/**/\n    3828,\n/**/\n    3827,\n/**/\n    3826,\n/**/\n    3825,\n/**/\n    3824,\n/**/\n    3823,\n/**/\n    3822,\n/**/\n    3821,\n/**/\n    3820,\n/**/\n    3819,\n/**/\n    3818,\n/**/\n    3817,\n/**/\n    3816,\n/**/\n    3815,\n/**/\n    3814,\n/**/\n    3813,\n/**/\n    3812,\n/**/\n    3811,\n/**/\n    3810,\n/**/\n    3809,\n/**/\n    3808,\n/**/\n    3807,\n/**/\n    3806,\n/**/\n    3805,\n/**/\n    3804,\n/**/\n    3803,\n/**/\n    3802,\n/**/\n    3801,\n/**/\n    3800,\n/**/\n    3799,\n/**/\n    3798,\n/**/\n    3797,\n/**/\n    3796,\n/**/\n    3795,\n/**/\n    3794,\n/**/\n    3793,\n/**/\n    3792,\n/**/\n    3791,\n/**/\n    3790,\n/**/\n    3789,\n/**/\n    3788,\n/**/\n    3787,\n/**/\n    3786,\n/**/\n    3785,\n/**/\n    3784,\n/**/\n    3783,\n/**/\n    3782,\n/**/\n    3781,\n/**/\n    3780,\n/**/\n    3779,\n/**/\n    3778,\n/**/\n    3777,\n/**/\n    3776,\n/**/\n    3775,\n/**/\n    3774,\n/**/\n    3773,\n/**/\n    3772,\n/**/\n    3771,\n/**/\n    3770,\n/**/\n    3769,\n/**/\n    3768,\n/**/\n    3767,\n/**/\n    3766,\n/**/\n    3765,\n/**/\n    3764,\n/**/\n    3763,\n/**/\n    3762,\n/**/\n    3761,\n/**/\n    3760,\n/**/\n    3759,\n/**/\n    3758,\n/**/\n    3757,\n/**/\n    3756,\n/**/\n    3755,\n/**/\n    3754,\n/**/\n    3753,\n/**/\n    3752,\n/**/\n    3751,\n/**/\n    3750,\n/**/\n    3749,\n/**/\n    3748,\n/**/\n    3747,\n/**/\n    3746,\n/**/\n    3745,\n/**/\n    3744,\n/**/\n    3743,\n/**/\n    3742,\n/**/\n    3741,\n/**/\n    3740,\n/**/\n    3739,\n/**/\n    3738,\n/**/\n    3737,\n/**/\n    3736,\n/**/\n    3735,\n/**/\n    3734,\n/**/\n    3733,\n/**/\n    3732,\n/**/\n    3731,\n/**/\n    3730,\n/**/\n    3729,\n/**/\n    3728,\n/**/\n    3727,\n/**/\n    3726,\n/**/\n    3725,\n/**/\n    3724,\n/**/\n    3723,\n/**/\n    3722,\n/**/\n    3721,\n/**/\n    3720,\n/**/\n    3719,\n/**/\n    3718,\n/**/\n    3717,\n/**/\n    3716,\n/**/\n    3715,\n/**/\n    3714,\n/**/\n    3713,\n/**/\n    3712,\n/**/\n    3711,\n/**/\n    3710,\n/**/\n    3709,\n/**/\n    3708,\n/**/\n    3707,\n/**/\n    3706,\n/**/\n    3705,\n/**/\n    3704,\n/**/\n    3703,\n/**/\n    3702,\n/**/\n    3701,\n/**/\n    3700,\n/**/\n    3699,\n/**/\n    3698,\n/**/\n    3697,\n/**/\n    3696,\n/**/\n    3695,\n/**/\n    3694,\n/**/\n    3693,\n/**/\n    3692,\n/**/\n    3691,\n/**/\n    3690,\n/**/\n    3689,\n/**/\n    3688,\n/**/\n    3687,\n/**/\n    3686,\n/**/\n    3685,\n/**/\n    3684,\n/**/\n    3683,\n/**/\n    3682,\n/**/\n    3681,\n/**/\n    3680,\n/**/\n    3679,\n/**/\n    3678,\n/**/\n    3677,\n/**/\n    3676,\n/**/\n    3675,\n/**/\n    3674,\n/**/\n    3673,\n/**/\n    3672,\n/**/\n    3671,\n/**/\n    3670,\n/**/\n    3669,\n/**/\n    3668,\n/**/\n    3667,\n/**/\n    3666,\n/**/\n    3665,\n/**/\n    3664,\n/**/\n    3663,\n/**/\n    3662,\n/**/\n    3661,\n/**/\n    3660,\n/**/\n    3659,\n/**/\n    3658,\n/**/\n    3657,\n/**/\n    3656,\n/**/\n    3655,\n/**/\n    3654,\n/**/\n    3653,\n/**/\n    3652,\n/**/\n    3651,\n/**/\n    3650,\n/**/\n    3649,\n/**/\n    3648,\n/**/\n    3647,\n/**/\n    3646,\n/**/\n    3645,\n/**/\n    3644,\n/**/\n    3643,\n/**/\n    3642,\n/**/\n    3641,\n/**/\n    3640,\n/**/\n    3639,\n/**/\n    3638,\n/**/\n    3637,\n/**/\n    3636,\n/**/\n    3635,\n/**/\n    3634,\n/**/\n    3633,\n/**/\n    3632,\n/**/\n    3631,\n/**/\n    3630,\n/**/\n    3629,\n/**/\n    3628,\n/**/\n    3627,\n/**/\n    3626,\n/**/\n    3625,\n/**/\n    3624,\n/**/\n    3623,\n/**/\n    3622,\n/**/\n    3621,\n/**/\n    3620,\n/**/\n    3619,\n/**/\n    3618,\n/**/\n    3617,\n/**/\n    3616,\n/**/\n    3615,\n/**/\n    3614,\n/**/\n    3613,\n/**/\n    3612,\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/diff.c", "src/testdir/test_diffmode.vim", "src/version.c"], "buggy_code_start_loc": [405, 1617, 737], "buggy_code_end_loc": [438, 1617, 737], "fixing_code_start_loc": [406, 1618, 738], "fixing_code_end_loc": [437, 1633, 740], "type": "CWE-787", "message": "Out-of-bounds Write in GitHub repository vim/vim prior to 8.2.", "other": {"cve": {"id": "CVE-2022-2210", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-27T16:15:08.467", "lastModified": "2023-05-03T12:15:49.510", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Out-of-bounds Write in GitHub repository vim/vim prior to 8.2."}, {"lang": "es", "value": "Una Escritura Fuera de L\u00edmites en el repositorio de GitHub vim/vim anterior a 8.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.5164", "matchCriteriaId": "A7524DFF-EBEB-46FA-A2CD-7D92324D5DC3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/c101abff4c6756db4f5e740fde289decb9452efa", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/020845f8-f047-4072-af0f-3726fe1aea25", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GFD2A4YLBR7OIRHTL7CK6YNMEIQ264CN/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U743FMJGFQ35GBPCQ6OWMVZEJPDFVEWM/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/c101abff4c6756db4f5e740fde289decb9452efa"}}