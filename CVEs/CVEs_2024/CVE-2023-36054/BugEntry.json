{"buggy_code": ["/* -*- mode: c; c-file-style: \"bsd\"; indent-tabs-mode: t -*- */\n/*\n * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved\n */\n\n#include <gssrpc/rpc.h>\n#include <krb5.h>\n#include <errno.h>\n#include <kadm5/admin.h>\n#include <kadm5/kadm_rpc.h>\n#include <kadm5/admin_xdr.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic bool_t\n_xdr_kadm5_principal_ent_rec(XDR *xdrs, kadm5_principal_ent_rec *objp,\n\t\t\t     int v);\nstatic bool_t\n_xdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp, int vers);\n\n/*\n * Function: xdr_ui_4\n *\n * Purpose: XDR function which serves as a wrapper for xdr_u_int32,\n * to prevent compiler warnings about type clashes between u_int32\n * and krb5_ui_4.\n */\nbool_t xdr_ui_4(XDR *xdrs, krb5_ui_4 *objp)\n{\n  /* Assumes that krb5_ui_4 and u_int32 are both four bytes long.\n     This should not be a harmful assumption. */\n  return xdr_u_int32(xdrs, (uint32_t *) objp);\n}\n\n\n/*\n * Function: xdr_nullstring\n *\n * Purpose: XDR function for \"strings\" that are either NULL-terminated\n * or NULL.\n */\nbool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  if (!xdr_opaque(xdrs, *objp, size))\n\t\t  return FALSE;\n\t  /* Check that the unmarshalled bytes are a C string. */\n\t  if ((*objp)[size - 1] != '\\0')\n\t\t  return FALSE;\n\t  if (memchr(*objp, '\\0', size - 1) != NULL)\n\t\t  return FALSE;\n\t  return TRUE;\n\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n\n     return FALSE;\n}\n\n/*\n * Function: xdr_nulltype\n *\n * Purpose: XDR function for arbitrary pointer types that are either\n * NULL or contain data.\n */\nbool_t xdr_nulltype(XDR *xdrs, void **objp, xdrproc_t proc)\n{\n     bool_t null;\n\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (!xdr_bool(xdrs, &null))\n\t      return FALSE;\n\t  if (null) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  }\n\t  return (*proc)(xdrs, objp);\n\n     case XDR_ENCODE:\n\t  if (*objp == NULL)\n\t       null = TRUE;\n\t  else\n\t       null = FALSE;\n\t  if (!xdr_bool(xdrs, &null))\n\t       return FALSE;\n\t  if (null == FALSE)\n\t       return (*proc)(xdrs, objp);\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp)\n\t       return (*proc)(xdrs, objp);\n\t  return TRUE;\n     }\n\n     return FALSE;\n}\n\nbool_t\nxdr_krb5_timestamp(XDR *xdrs, krb5_timestamp *objp)\n{\n  /* This assumes that int32 and krb5_timestamp are the same size.\n     This shouldn't be a problem, since we've got a unit test which\n     checks for this. */\n\tif (!xdr_int32(xdrs, (int32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_kvno(XDR *xdrs, krb5_kvno *objp)\n{\n\treturn xdr_u_int(xdrs, objp);\n}\n\nbool_t\nxdr_krb5_deltat(XDR *xdrs, krb5_deltat *objp)\n{\n  /* This assumes that int32 and krb5_deltat are the same size.\n     This shouldn't be a problem, since we've got a unit test which\n     checks for this. */\n\tif (!xdr_int32(xdrs, (int32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_flags(XDR *xdrs, krb5_flags *objp)\n{\n  /* This assumes that int32 and krb5_flags are the same size.\n     This shouldn't be a problem, since we've got a unit test which\n     checks for this. */\n\tif (!xdr_int32(xdrs, (int32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_ui_4(XDR *xdrs, krb5_ui_4 *objp)\n{\n\tif (!xdr_u_int32(xdrs, (uint32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_int16(XDR *xdrs, krb5_int16 *objp)\n{\n    int tmp;\n\n    tmp = (int) *objp;\n\n    if (!xdr_int(xdrs, &tmp))\n\treturn(FALSE);\n\n    *objp = (krb5_int16) tmp;\n\n    return(TRUE);\n}\n\n/*\n * Function: xdr_krb5_ui_2\n *\n * Purpose: XDR function which serves as a wrapper for xdr_u_int,\n * to prevent compiler warnings about type clashes between u_int\n * and krb5_ui_2.\n */\nbool_t\nxdr_krb5_ui_2(XDR *xdrs, krb5_ui_2 *objp)\n{\n    unsigned int tmp;\n\n    tmp = (unsigned int) *objp;\n\n    if (!xdr_u_int(xdrs, &tmp))\n\treturn(FALSE);\n\n    *objp = (krb5_ui_2) tmp;\n\n    return(TRUE);\n}\n\n\n\nstatic bool_t xdr_krb5_boolean(XDR *xdrs, krb5_boolean *kbool)\n{\n\tbool_t val;\n\n\tswitch (xdrs->x_op) {\n\tcase XDR_DECODE:\n\t     if (!xdr_bool(xdrs, &val))\n\t\t     return FALSE;\n\n\t     *kbool = (val == FALSE) ? FALSE : TRUE;\n\t     return TRUE;\n\n\tcase XDR_ENCODE:\n\t     val = *kbool ? TRUE : FALSE;\n\t     return xdr_bool(xdrs, &val);\n\n\tcase XDR_FREE:\n\t     return TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nbool_t xdr_krb5_key_data_nocontents(XDR *xdrs, krb5_key_data *objp)\n{\n     /*\n      * Note that this function intentionally DOES NOT transfer key\n      * length or contents!  xdr_krb5_key_data in adb_xdr.c does, but\n      * that is only for use within the server-side library.\n      */\n     unsigned int tmp;\n\n     if (xdrs->x_op == XDR_DECODE)\n\t  memset(objp, 0, sizeof(krb5_key_data));\n\n     if (!xdr_krb5_int16(xdrs, &objp->key_data_ver)) {\n\t  return (FALSE);\n     }\n     if (!xdr_krb5_ui_2(xdrs, &objp->key_data_kvno)) {\n\t  return (FALSE);\n     }\n     if (!xdr_krb5_int16(xdrs, &objp->key_data_type[0])) {\n\t  return (FALSE);\n     }\n     if (objp->key_data_ver > 1) {\n\t  if (!xdr_krb5_int16(xdrs, &objp->key_data_type[1])) {\n\t       return (FALSE);\n\t  }\n     }\n     /*\n      * kadm5_get_principal on the server side allocates and returns\n      * key contents when asked.  Even though this function refuses to\n      * transmit that data, it still has to *free* the data at the\n      * appropriate time to avoid a memory leak.\n      */\n     if (xdrs->x_op == XDR_FREE) {\n\t  tmp = (unsigned int) objp->key_data_length[0];\n\t  if (!xdr_bytes(xdrs, (char **) &objp->key_data_contents[0],\n\t\t\t &tmp, ~0))\n\t       return FALSE;\n\n\t  tmp = (unsigned int) objp->key_data_length[1];\n\t  if (!xdr_bytes(xdrs, (char **) &objp->key_data_contents[1],\n\t\t\t &tmp, ~0))\n\t       return FALSE;\n     }\n\n     return (TRUE);\n}\n\n\nbool_t\nxdr_krb5_key_salt_tuple(XDR *xdrs, krb5_key_salt_tuple *objp)\n{\n    if (!xdr_krb5_enctype(xdrs, &objp->ks_enctype))\n\treturn FALSE;\n    if (!xdr_krb5_salttype(xdrs, &objp->ks_salttype))\n\treturn FALSE;\n    return TRUE;\n}\n\nbool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n\t       free(tl);\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = NULL;\n\t  break;\n\n     case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\n\t  *tl_data_head = tl;\n\t  break;\n     }\n\n     return TRUE;\n}\n\nbool_t\nxdr_kadm5_ret_t(XDR *xdrs, kadm5_ret_t *objp)\n{\n\tuint32_t tmp;\n\n\tif (xdrs->x_op == XDR_ENCODE)\n\t\ttmp = (uint32_t) *objp;\n\n\tif (!xdr_u_int32(xdrs, &tmp))\n\t\treturn (FALSE);\n\n\tif (xdrs->x_op == XDR_DECODE)\n\t\t*objp = (kadm5_ret_t) tmp;\n\n\treturn (TRUE);\n}\n\nbool_t xdr_kadm5_principal_ent_rec(XDR *xdrs,\n\t\t\t\t   kadm5_principal_ent_rec *objp)\n{\n     return _xdr_kadm5_principal_ent_rec(xdrs, objp, KADM5_API_VERSION_3);\n}\n\nstatic bool_t\n_xdr_kadm5_principal_ent_rec(XDR *xdrs, kadm5_principal_ent_rec *objp,\n\t\t\t     int v)\n{\n\tunsigned int n;\n\n\tif (!xdr_krb5_principal(xdrs, &objp->principal)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->princ_expire_time)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->last_pwd_change)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->pw_expiration)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_deltat(xdrs, &objp->max_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nulltype(xdrs, (void **) &objp->mod_name,\n\t\t\t  xdr_krb5_principal)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->mod_date)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_flags(xdrs, &objp->attributes)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->kvno)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->mkvno)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->policy)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->aux_attributes)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_deltat(xdrs, &objp->max_renewable_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->last_success)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->last_failed)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->fail_auth_count)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_int16(xdrs, &objp->n_key_data)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_int16(xdrs, &objp->n_tl_data)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nulltype(xdrs, (void **) &objp->tl_data,\n\t\t\t  xdr_krb5_tl_data)) {\n\t\treturn FALSE;\n\t}\n\tn = objp->n_key_data;\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->key_data,\n\t\t       &n, ~0, sizeof(krb5_key_data),\n\t\t       xdr_krb5_key_data_nocontents)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nstatic bool_t\n_xdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp, int vers)\n{\n\tif (!xdr_nullstring(xdrs, &objp->policy)) {\n\t\treturn (FALSE);\n\t}\n\t/* these all used to be u_int32, but it's stupid for sized types\n\t   to be exposed at the api, and they're the same as longs on the\n\t   wire. */\n\tif (!xdr_long(xdrs, &objp->pw_min_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_max_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_min_length)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_min_classes)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_history_num)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->policy_refcnt)) {\n\t\treturn (FALSE);\n\t}\n\tif (xdrs->x_op == XDR_DECODE) {\n\t\tobjp->pw_max_fail = 0;\n\t\tobjp->pw_failcnt_interval = 0;\n\t\tobjp->pw_lockout_duration = 0;\n\t\tobjp->attributes = 0;\n\t\tobjp->max_life = 0;\n\t\tobjp->max_renewable_life = 0;\n\t\tobjp->allowed_keysalts = NULL;\n\t\tobjp->n_tl_data = 0;\n\t\tobjp->tl_data = NULL;\n\t}\n\tif (vers >= KADM5_API_VERSION_3) {\n\t\tif (!xdr_krb5_kvno(xdrs, &objp->pw_max_fail))\n\t\t\treturn (FALSE);\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->pw_failcnt_interval))\n\t\t\treturn (FALSE);\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->pw_lockout_duration))\n\t\t\treturn (FALSE);\n\t}\n\tif (vers >= KADM5_API_VERSION_4) {\n\t\tif (!xdr_krb5_flags(xdrs, &objp->attributes)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->max_life)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->max_renewable_life)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_nullstring(xdrs, &objp->allowed_keysalts)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_krb5_int16(xdrs, &objp->n_tl_data)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_nulltype(xdrs, (void **) &objp->tl_data,\n\t\t\t\t  xdr_krb5_tl_data)) {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp)\n{\n\treturn _xdr_kadm5_policy_ent_rec(xdrs, objp, KADM5_API_VERSION_4);\n}\n\nbool_t\nxdr_cprinc_arg(XDR *xdrs, cprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t  objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->passwd)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_cprinc3_arg(XDR *xdrs, cprinc3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t  objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *)&objp->ks_tuple,\n\t\t       (unsigned int *)&objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple),\n\t\t       xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->passwd)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_generic_ret(XDR *xdrs, generic_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn(TRUE);\n}\n\nbool_t\nxdr_dprinc_arg(XDR *xdrs, dprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_mprinc_arg(XDR *xdrs, mprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t  objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_rprinc_arg(XDR *xdrs, rprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->src)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->dest)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gprincs_arg(XDR *xdrs, gprincs_arg *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_nullstring(xdrs, &objp->exp)) {\n\t  return (FALSE);\n     }\n     return (TRUE);\n}\n\nbool_t\nxdr_gprincs_ret(XDR *xdrs, gprincs_ret *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t  return (FALSE);\n     }\n     if (objp->code == KADM5_OK) {\n\t  if (!xdr_int(xdrs, &objp->count)) {\n\t       return (FALSE);\n\t  }\n\t  if (!xdr_array(xdrs, (caddr_t *) &objp->princs,\n\t\t\t (unsigned int *) &objp->count, ~0,\n\t\t\t sizeof(char *), xdr_nullstring)) {\n\t       return (FALSE);\n\t  }\n     }\n\n     return (TRUE);\n}\n\nbool_t\nxdr_chpass_arg(XDR *xdrs, chpass_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->pass)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chpass3_arg(XDR *xdrs, chpass3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *)&objp->ks_tuple,\n\t\t       (unsigned int*)&objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple),\n\t\t       xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->pass)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_setkey_arg(XDR *xdrs, setkey_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->keyblocks,\n\t\t       (unsigned int *) &objp->n_keys, ~0,\n\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_setkey3_arg(XDR *xdrs, setkey3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->ks_tuple,\n\t\t       (unsigned int *) &objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple), xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->keyblocks,\n\t\t       (unsigned int *) &objp->n_keys, ~0,\n\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_setkey4_arg(XDR *xdrs, setkey4_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn FALSE;\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn FALSE;\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn FALSE;\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->key_data,\n\t\t       (unsigned int *) &objp->n_key_data, ~0,\n\t\t       sizeof(kadm5_key_data), xdr_kadm5_key_data)) {\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nbool_t\nxdr_chrand_arg(XDR *xdrs, chrand_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chrand3_arg(XDR *xdrs, chrand3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *)&objp->ks_tuple,\n\t\t       (unsigned int*)&objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple),\n\t\t       xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chrand_ret(XDR *xdrs, chrand_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif (objp->code == KADM5_OK) {\n\t\tif (!xdr_array(xdrs, (char **)&objp->keys,\n\t\t\t       (unsigned int *)&objp->n_keys, ~0,\n\t\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock))\n\t\t\treturn FALSE;\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gprinc_arg(XDR *xdrs, gprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t     return FALSE;\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gprinc_ret(XDR *xdrs, gprinc_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif(objp->code == KADM5_OK)  {\n\t\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t\t  objp->api_version)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_cpol_arg(XDR *xdrs, cpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_policy_ent_rec(xdrs, &objp->rec,\n\t\t\t\t       objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_dpol_arg(XDR *xdrs, dpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->name)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_mpol_arg(XDR *xdrs, mpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_policy_ent_rec(xdrs, &objp->rec,\n\t\t\t\t       objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gpol_arg(XDR *xdrs, gpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->name)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gpol_ret(XDR *xdrs, gpol_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif(objp->code == KADM5_OK) {\n\t    if (!_xdr_kadm5_policy_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t   objp->api_version))\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gpols_arg(XDR *xdrs, gpols_arg *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_nullstring(xdrs, &objp->exp)) {\n\t  return (FALSE);\n     }\n     return (TRUE);\n}\n\nbool_t\nxdr_gpols_ret(XDR *xdrs, gpols_ret *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t  return (FALSE);\n     }\n     if (objp->code == KADM5_OK) {\n\t  if (!xdr_int(xdrs, &objp->count)) {\n\t       return (FALSE);\n\t  }\n\t  if (!xdr_array(xdrs, (caddr_t *) &objp->pols,\n\t\t\t (unsigned int *) &objp->count, ~0,\n\t\t\t sizeof(char *), xdr_nullstring)) {\n\t       return (FALSE);\n\t  }\n     }\n\n     return (TRUE);\n}\n\nbool_t xdr_getprivs_ret(XDR *xdrs, getprivs_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n     if (! xdr_kadm5_ret_t(xdrs, &objp->code) ||\n\t ! xdr_long(xdrs, &objp->privs))\n\t  return FALSE;\n\n     return TRUE;\n}\n\nbool_t\nxdr_purgekeys_arg(XDR *xdrs, purgekeys_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_int(xdrs, &objp->keepkvno)) {\n\t     return FALSE;\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gstrings_arg(XDR *xdrs, gstrings_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gstrings_ret(XDR *xdrs, gstrings_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif (objp->code == KADM5_OK) {\n\t\tif (!xdr_int(xdrs, &objp->count)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_array(xdrs, (caddr_t *) &objp->strings,\n\t\t\t       (unsigned int *) &objp->count, ~0,\n\t\t\t       sizeof(krb5_string_attr),\n\t\t\t       xdr_krb5_string_attr)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_sstring_arg(XDR *xdrs, sstring_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->key)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->value)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_principal(XDR *xdrs, krb5_principal *objp)\n{\n    int\t    ret;\n    char\t    *p = NULL;\n    krb5_principal  pr = NULL;\n    static krb5_context context = NULL;\n\n    /* using a static context here is ugly, but should work\n       ok, and the other solutions are even uglier */\n\n    if (!context &&\n\tkadm5_init_krb5_context(&context))\n       return(FALSE);\n\n    switch(xdrs->x_op) {\n    case XDR_ENCODE:\n\tif (*objp) {\n\t     if((ret = krb5_unparse_name(context, *objp, &p)) != 0)\n\t\t  return FALSE;\n\t}\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) free(p);\n\tbreak;\n    case XDR_DECODE:\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) {\n\t     ret = krb5_parse_name(context, p, &pr);\n\t     if(ret != 0)\n\t\t  return FALSE;\n\t     *objp = pr;\n\t     free(p);\n\t} else\n\t     *objp = NULL;\n\tbreak;\n    case XDR_FREE:\n\tif(*objp != NULL)\n\t    krb5_free_principal(context, *objp);\n\t*objp = NULL;\n\tbreak;\n    }\n    return TRUE;\n}\n\nbool_t\nxdr_krb5_octet(XDR *xdrs, krb5_octet *objp)\n{\n   if (!xdr_u_char(xdrs, objp))\n\treturn (FALSE);\n   return (TRUE);\n}\n\nbool_t\nxdr_krb5_enctype(XDR *xdrs, krb5_enctype *objp)\n{\n   if (!xdr_int32(xdrs, (int32_t *) objp))\n\treturn (FALSE);\n   return (TRUE);\n}\n\nbool_t\nxdr_krb5_salttype(XDR *xdrs, krb5_int32 *objp)\n{\n    if (!xdr_int32(xdrs, (int32_t *) objp))\n\treturn FALSE;\n    return TRUE;\n}\n\nbool_t\nxdr_krb5_keyblock(XDR *xdrs, krb5_keyblock *objp)\n{\n   char *cp;\n\n   /* XXX This only works because free_keyblock assumes ->contents\n      is allocated by malloc() */\n   if(!xdr_krb5_enctype(xdrs, &objp->enctype))\n      return FALSE;\n   cp = (char *)objp->contents;\n   if(!xdr_bytes(xdrs, &cp, &objp->length, ~0))\n      return FALSE;\n   objp->contents = (uint8_t *)cp;\n   return TRUE;\n}\n\nbool_t\nxdr_krb5_string_attr(XDR *xdrs, krb5_string_attr *objp)\n{\n\tif (!xdr_nullstring(xdrs, &objp->key))\n\t\treturn FALSE;\n\tif (!xdr_nullstring(xdrs, &objp->value))\n\t\treturn FALSE;\n\tif (xdrs->x_op == XDR_DECODE &&\n\t    (objp->key == NULL || objp->value == NULL))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\nbool_t\nxdr_kadm5_key_data(XDR *xdrs, kadm5_key_data *objp)\n{\n\tif (!xdr_krb5_kvno(xdrs, &objp->kvno))\n\t\treturn FALSE;\n\tif (!xdr_krb5_keyblock(xdrs, &objp->key))\n\t\treturn FALSE;\n\tif (!xdr_krb5_int16(xdrs, &objp->salt.type))\n\t\treturn FALSE;\n\tif (!xdr_bytes(xdrs, &objp->salt.data.data,\n\t\t       &objp->salt.data.length, ~0))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\nbool_t\nxdr_getpkeys_arg(XDR *xdrs, getpkeys_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn FALSE;\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn FALSE;\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->kvno)) {\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nbool_t\nxdr_getpkeys_ret(XDR *xdrs, getpkeys_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn FALSE;\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn FALSE;\n\t}\n\tif (objp->code == KADM5_OK) {\n\t\tif (!xdr_array(xdrs, (caddr_t *) &objp->key_data,\n\t\t\t       (unsigned int *) &objp->n_key_data, ~0,\n\t\t\t       sizeof(kadm5_key_data), xdr_kadm5_key_data)) {\n\t\t    return FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n"], "fixing_code": ["/* -*- mode: c; c-file-style: \"bsd\"; indent-tabs-mode: t -*- */\n/*\n * Copyright 1993 OpenVision Technologies, Inc., All Rights Reserved\n */\n\n#include <gssrpc/rpc.h>\n#include <krb5.h>\n#include <errno.h>\n#include <kadm5/admin.h>\n#include <kadm5/kadm_rpc.h>\n#include <kadm5/admin_xdr.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic bool_t\n_xdr_kadm5_principal_ent_rec(XDR *xdrs, kadm5_principal_ent_rec *objp,\n\t\t\t     int v);\nstatic bool_t\n_xdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp, int vers);\n\n/*\n * Function: xdr_ui_4\n *\n * Purpose: XDR function which serves as a wrapper for xdr_u_int32,\n * to prevent compiler warnings about type clashes between u_int32\n * and krb5_ui_4.\n */\nbool_t xdr_ui_4(XDR *xdrs, krb5_ui_4 *objp)\n{\n  /* Assumes that krb5_ui_4 and u_int32 are both four bytes long.\n     This should not be a harmful assumption. */\n  return xdr_u_int32(xdrs, (uint32_t *) objp);\n}\n\n\n/*\n * Function: xdr_nullstring\n *\n * Purpose: XDR function for \"strings\" that are either NULL-terminated\n * or NULL.\n */\nbool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  if (!xdr_opaque(xdrs, *objp, size))\n\t\t  return FALSE;\n\t  /* Check that the unmarshalled bytes are a C string. */\n\t  if ((*objp)[size - 1] != '\\0')\n\t\t  return FALSE;\n\t  if (memchr(*objp, '\\0', size - 1) != NULL)\n\t\t  return FALSE;\n\t  return TRUE;\n\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n\n     return FALSE;\n}\n\n/*\n * Function: xdr_nulltype\n *\n * Purpose: XDR function for arbitrary pointer types that are either\n * NULL or contain data.\n */\nbool_t xdr_nulltype(XDR *xdrs, void **objp, xdrproc_t proc)\n{\n     bool_t null;\n\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (!xdr_bool(xdrs, &null))\n\t      return FALSE;\n\t  if (null) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  }\n\t  return (*proc)(xdrs, objp);\n\n     case XDR_ENCODE:\n\t  if (*objp == NULL)\n\t       null = TRUE;\n\t  else\n\t       null = FALSE;\n\t  if (!xdr_bool(xdrs, &null))\n\t       return FALSE;\n\t  if (null == FALSE)\n\t       return (*proc)(xdrs, objp);\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp)\n\t       return (*proc)(xdrs, objp);\n\t  return TRUE;\n     }\n\n     return FALSE;\n}\n\nbool_t\nxdr_krb5_timestamp(XDR *xdrs, krb5_timestamp *objp)\n{\n  /* This assumes that int32 and krb5_timestamp are the same size.\n     This shouldn't be a problem, since we've got a unit test which\n     checks for this. */\n\tif (!xdr_int32(xdrs, (int32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_kvno(XDR *xdrs, krb5_kvno *objp)\n{\n\treturn xdr_u_int(xdrs, objp);\n}\n\nbool_t\nxdr_krb5_deltat(XDR *xdrs, krb5_deltat *objp)\n{\n  /* This assumes that int32 and krb5_deltat are the same size.\n     This shouldn't be a problem, since we've got a unit test which\n     checks for this. */\n\tif (!xdr_int32(xdrs, (int32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_flags(XDR *xdrs, krb5_flags *objp)\n{\n  /* This assumes that int32 and krb5_flags are the same size.\n     This shouldn't be a problem, since we've got a unit test which\n     checks for this. */\n\tif (!xdr_int32(xdrs, (int32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_ui_4(XDR *xdrs, krb5_ui_4 *objp)\n{\n\tif (!xdr_u_int32(xdrs, (uint32_t *) objp)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_int16(XDR *xdrs, krb5_int16 *objp)\n{\n    int tmp;\n\n    tmp = (int) *objp;\n\n    if (!xdr_int(xdrs, &tmp))\n\treturn(FALSE);\n\n    *objp = (krb5_int16) tmp;\n\n    return(TRUE);\n}\n\n/*\n * Function: xdr_krb5_ui_2\n *\n * Purpose: XDR function which serves as a wrapper for xdr_u_int,\n * to prevent compiler warnings about type clashes between u_int\n * and krb5_ui_2.\n */\nbool_t\nxdr_krb5_ui_2(XDR *xdrs, krb5_ui_2 *objp)\n{\n    unsigned int tmp;\n\n    tmp = (unsigned int) *objp;\n\n    if (!xdr_u_int(xdrs, &tmp))\n\treturn(FALSE);\n\n    *objp = (krb5_ui_2) tmp;\n\n    return(TRUE);\n}\n\n\n\nstatic bool_t xdr_krb5_boolean(XDR *xdrs, krb5_boolean *kbool)\n{\n\tbool_t val;\n\n\tswitch (xdrs->x_op) {\n\tcase XDR_DECODE:\n\t     if (!xdr_bool(xdrs, &val))\n\t\t     return FALSE;\n\n\t     *kbool = (val == FALSE) ? FALSE : TRUE;\n\t     return TRUE;\n\n\tcase XDR_ENCODE:\n\t     val = *kbool ? TRUE : FALSE;\n\t     return xdr_bool(xdrs, &val);\n\n\tcase XDR_FREE:\n\t     return TRUE;\n\t}\n\n\treturn FALSE;\n}\n\nbool_t xdr_krb5_key_data_nocontents(XDR *xdrs, krb5_key_data *objp)\n{\n     /*\n      * Note that this function intentionally DOES NOT transfer key\n      * length or contents!  xdr_krb5_key_data in adb_xdr.c does, but\n      * that is only for use within the server-side library.\n      */\n     unsigned int tmp;\n\n     if (xdrs->x_op == XDR_DECODE)\n\t  memset(objp, 0, sizeof(krb5_key_data));\n\n     if (!xdr_krb5_int16(xdrs, &objp->key_data_ver)) {\n\t  return (FALSE);\n     }\n     if (!xdr_krb5_ui_2(xdrs, &objp->key_data_kvno)) {\n\t  return (FALSE);\n     }\n     if (!xdr_krb5_int16(xdrs, &objp->key_data_type[0])) {\n\t  return (FALSE);\n     }\n     if (objp->key_data_ver > 1) {\n\t  if (!xdr_krb5_int16(xdrs, &objp->key_data_type[1])) {\n\t       return (FALSE);\n\t  }\n     }\n     /*\n      * kadm5_get_principal on the server side allocates and returns\n      * key contents when asked.  Even though this function refuses to\n      * transmit that data, it still has to *free* the data at the\n      * appropriate time to avoid a memory leak.\n      */\n     if (xdrs->x_op == XDR_FREE) {\n\t  tmp = (unsigned int) objp->key_data_length[0];\n\t  if (!xdr_bytes(xdrs, (char **) &objp->key_data_contents[0],\n\t\t\t &tmp, ~0))\n\t       return FALSE;\n\n\t  tmp = (unsigned int) objp->key_data_length[1];\n\t  if (!xdr_bytes(xdrs, (char **) &objp->key_data_contents[1],\n\t\t\t &tmp, ~0))\n\t       return FALSE;\n     }\n\n     return (TRUE);\n}\n\n\nbool_t\nxdr_krb5_key_salt_tuple(XDR *xdrs, krb5_key_salt_tuple *objp)\n{\n    if (!xdr_krb5_enctype(xdrs, &objp->ks_enctype))\n\treturn FALSE;\n    if (!xdr_krb5_salttype(xdrs, &objp->ks_salttype))\n\treturn FALSE;\n    return TRUE;\n}\n\nbool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n\t       free(tl);\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = NULL;\n\t  break;\n\n     case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\n\t  *tl_data_head = tl;\n\t  break;\n     }\n\n     return TRUE;\n}\n\nbool_t\nxdr_kadm5_ret_t(XDR *xdrs, kadm5_ret_t *objp)\n{\n\tuint32_t tmp;\n\n\tif (xdrs->x_op == XDR_ENCODE)\n\t\ttmp = (uint32_t) *objp;\n\n\tif (!xdr_u_int32(xdrs, &tmp))\n\t\treturn (FALSE);\n\n\tif (xdrs->x_op == XDR_DECODE)\n\t\t*objp = (kadm5_ret_t) tmp;\n\n\treturn (TRUE);\n}\n\nbool_t xdr_kadm5_principal_ent_rec(XDR *xdrs,\n\t\t\t\t   kadm5_principal_ent_rec *objp)\n{\n     return _xdr_kadm5_principal_ent_rec(xdrs, objp, KADM5_API_VERSION_3);\n}\n\nstatic bool_t\n_xdr_kadm5_principal_ent_rec(XDR *xdrs, kadm5_principal_ent_rec *objp,\n\t\t\t     int v)\n{\n\tunsigned int n;\n\tbool_t r;\n\n\tif (!xdr_krb5_principal(xdrs, &objp->principal)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->princ_expire_time)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->last_pwd_change)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->pw_expiration)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_deltat(xdrs, &objp->max_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nulltype(xdrs, (void **) &objp->mod_name,\n\t\t\t  xdr_krb5_principal)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->mod_date)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_flags(xdrs, &objp->attributes)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->kvno)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->mkvno)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->policy)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->aux_attributes)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_deltat(xdrs, &objp->max_renewable_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->last_success)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_timestamp(xdrs, &objp->last_failed)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->fail_auth_count)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_int16(xdrs, &objp->n_key_data)) {\n\t\treturn (FALSE);\n\t}\n\tif (xdrs->x_op == XDR_DECODE && objp->n_key_data < 0) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_int16(xdrs, &objp->n_tl_data)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nulltype(xdrs, (void **) &objp->tl_data,\n\t\t\t  xdr_krb5_tl_data)) {\n\t\treturn FALSE;\n\t}\n\tn = objp->n_key_data;\n\tr = xdr_array(xdrs, (caddr_t *) &objp->key_data, &n, objp->n_key_data,\n\t\t      sizeof(krb5_key_data), xdr_krb5_key_data_nocontents);\n\tobjp->n_key_data = n;\n\tif (!r) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nstatic bool_t\n_xdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp, int vers)\n{\n\tif (!xdr_nullstring(xdrs, &objp->policy)) {\n\t\treturn (FALSE);\n\t}\n\t/* these all used to be u_int32, but it's stupid for sized types\n\t   to be exposed at the api, and they're the same as longs on the\n\t   wire. */\n\tif (!xdr_long(xdrs, &objp->pw_min_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_max_life)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_min_length)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_min_classes)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->pw_history_num)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->policy_refcnt)) {\n\t\treturn (FALSE);\n\t}\n\tif (xdrs->x_op == XDR_DECODE) {\n\t\tobjp->pw_max_fail = 0;\n\t\tobjp->pw_failcnt_interval = 0;\n\t\tobjp->pw_lockout_duration = 0;\n\t\tobjp->attributes = 0;\n\t\tobjp->max_life = 0;\n\t\tobjp->max_renewable_life = 0;\n\t\tobjp->allowed_keysalts = NULL;\n\t\tobjp->n_tl_data = 0;\n\t\tobjp->tl_data = NULL;\n\t}\n\tif (vers >= KADM5_API_VERSION_3) {\n\t\tif (!xdr_krb5_kvno(xdrs, &objp->pw_max_fail))\n\t\t\treturn (FALSE);\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->pw_failcnt_interval))\n\t\t\treturn (FALSE);\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->pw_lockout_duration))\n\t\t\treturn (FALSE);\n\t}\n\tif (vers >= KADM5_API_VERSION_4) {\n\t\tif (!xdr_krb5_flags(xdrs, &objp->attributes)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->max_life)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_krb5_deltat(xdrs, &objp->max_renewable_life)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_nullstring(xdrs, &objp->allowed_keysalts)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_krb5_int16(xdrs, &objp->n_tl_data)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_nulltype(xdrs, (void **) &objp->tl_data,\n\t\t\t\t  xdr_krb5_tl_data)) {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_kadm5_policy_ent_rec(XDR *xdrs, kadm5_policy_ent_rec *objp)\n{\n\treturn _xdr_kadm5_policy_ent_rec(xdrs, objp, KADM5_API_VERSION_4);\n}\n\nbool_t\nxdr_cprinc_arg(XDR *xdrs, cprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t  objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->passwd)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_cprinc3_arg(XDR *xdrs, cprinc3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t  objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *)&objp->ks_tuple,\n\t\t       (unsigned int *)&objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple),\n\t\t       xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->passwd)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_generic_ret(XDR *xdrs, generic_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn(TRUE);\n}\n\nbool_t\nxdr_dprinc_arg(XDR *xdrs, dprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_mprinc_arg(XDR *xdrs, mprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t  objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_rprinc_arg(XDR *xdrs, rprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->src)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->dest)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gprincs_arg(XDR *xdrs, gprincs_arg *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_nullstring(xdrs, &objp->exp)) {\n\t  return (FALSE);\n     }\n     return (TRUE);\n}\n\nbool_t\nxdr_gprincs_ret(XDR *xdrs, gprincs_ret *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t  return (FALSE);\n     }\n     if (objp->code == KADM5_OK) {\n\t  if (!xdr_int(xdrs, &objp->count)) {\n\t       return (FALSE);\n\t  }\n\t  if (!xdr_array(xdrs, (caddr_t *) &objp->princs,\n\t\t\t (unsigned int *) &objp->count, ~0,\n\t\t\t sizeof(char *), xdr_nullstring)) {\n\t       return (FALSE);\n\t  }\n     }\n\n     return (TRUE);\n}\n\nbool_t\nxdr_chpass_arg(XDR *xdrs, chpass_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->pass)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chpass3_arg(XDR *xdrs, chpass3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *)&objp->ks_tuple,\n\t\t       (unsigned int*)&objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple),\n\t\t       xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->pass)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_setkey_arg(XDR *xdrs, setkey_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->keyblocks,\n\t\t       (unsigned int *) &objp->n_keys, ~0,\n\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_setkey3_arg(XDR *xdrs, setkey3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->ks_tuple,\n\t\t       (unsigned int *) &objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple), xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->keyblocks,\n\t\t       (unsigned int *) &objp->n_keys, ~0,\n\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_setkey4_arg(XDR *xdrs, setkey4_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn FALSE;\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn FALSE;\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn FALSE;\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *) &objp->key_data,\n\t\t       (unsigned int *) &objp->n_key_data, ~0,\n\t\t       sizeof(kadm5_key_data), xdr_kadm5_key_data)) {\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nbool_t\nxdr_chrand_arg(XDR *xdrs, chrand_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chrand3_arg(XDR *xdrs, chrand3_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_boolean(xdrs, &objp->keepold)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_array(xdrs, (caddr_t *)&objp->ks_tuple,\n\t\t       (unsigned int*)&objp->n_ks_tuple, ~0,\n\t\t       sizeof(krb5_key_salt_tuple),\n\t\t       xdr_krb5_key_salt_tuple)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_chrand_ret(XDR *xdrs, chrand_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif (objp->code == KADM5_OK) {\n\t\tif (!xdr_array(xdrs, (char **)&objp->keys,\n\t\t\t       (unsigned int *)&objp->n_keys, ~0,\n\t\t\t       sizeof(krb5_keyblock), xdr_krb5_keyblock))\n\t\t\treturn FALSE;\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gprinc_arg(XDR *xdrs, gprinc_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t     return FALSE;\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gprinc_ret(XDR *xdrs, gprinc_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif(objp->code == KADM5_OK)  {\n\t\tif (!_xdr_kadm5_principal_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t\t  objp->api_version)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_cpol_arg(XDR *xdrs, cpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_policy_ent_rec(xdrs, &objp->rec,\n\t\t\t\t       objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_dpol_arg(XDR *xdrs, dpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->name)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_mpol_arg(XDR *xdrs, mpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!_xdr_kadm5_policy_ent_rec(xdrs, &objp->rec,\n\t\t\t\t       objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_long(xdrs, &objp->mask)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gpol_arg(XDR *xdrs, gpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->name)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gpol_ret(XDR *xdrs, gpol_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif(objp->code == KADM5_OK) {\n\t    if (!_xdr_kadm5_policy_ent_rec(xdrs, &objp->rec,\n\t\t\t\t\t   objp->api_version))\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gpols_arg(XDR *xdrs, gpols_arg *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_nullstring(xdrs, &objp->exp)) {\n\t  return (FALSE);\n     }\n     return (TRUE);\n}\n\nbool_t\nxdr_gpols_ret(XDR *xdrs, gpols_ret *objp)\n{\n     if (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t  return (FALSE);\n     }\n     if (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t  return (FALSE);\n     }\n     if (objp->code == KADM5_OK) {\n\t  if (!xdr_int(xdrs, &objp->count)) {\n\t       return (FALSE);\n\t  }\n\t  if (!xdr_array(xdrs, (caddr_t *) &objp->pols,\n\t\t\t (unsigned int *) &objp->count, ~0,\n\t\t\t sizeof(char *), xdr_nullstring)) {\n\t       return (FALSE);\n\t  }\n     }\n\n     return (TRUE);\n}\n\nbool_t xdr_getprivs_ret(XDR *xdrs, getprivs_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n     if (! xdr_kadm5_ret_t(xdrs, &objp->code) ||\n\t ! xdr_long(xdrs, &objp->privs))\n\t  return FALSE;\n\n     return TRUE;\n}\n\nbool_t\nxdr_purgekeys_arg(XDR *xdrs, purgekeys_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_int(xdrs, &objp->keepkvno)) {\n\t     return FALSE;\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gstrings_arg(XDR *xdrs, gstrings_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_gstrings_ret(XDR *xdrs, gstrings_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn (FALSE);\n\t}\n\tif (objp->code == KADM5_OK) {\n\t\tif (!xdr_int(xdrs, &objp->count)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t\tif (!xdr_array(xdrs, (caddr_t *) &objp->strings,\n\t\t\t       (unsigned int *) &objp->count, ~0,\n\t\t\t       sizeof(krb5_string_attr),\n\t\t\t       xdr_krb5_string_attr)) {\n\t\t\treturn (FALSE);\n\t\t}\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_sstring_arg(XDR *xdrs, sstring_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->key)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->value)) {\n\t\treturn (FALSE);\n\t}\n\n\treturn (TRUE);\n}\n\nbool_t\nxdr_krb5_principal(XDR *xdrs, krb5_principal *objp)\n{\n    int\t    ret;\n    char\t    *p = NULL;\n    krb5_principal  pr = NULL;\n    static krb5_context context = NULL;\n\n    /* using a static context here is ugly, but should work\n       ok, and the other solutions are even uglier */\n\n    if (!context &&\n\tkadm5_init_krb5_context(&context))\n       return(FALSE);\n\n    switch(xdrs->x_op) {\n    case XDR_ENCODE:\n\tif (*objp) {\n\t     if((ret = krb5_unparse_name(context, *objp, &p)) != 0)\n\t\t  return FALSE;\n\t}\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) free(p);\n\tbreak;\n    case XDR_DECODE:\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) {\n\t     ret = krb5_parse_name(context, p, &pr);\n\t     if(ret != 0)\n\t\t  return FALSE;\n\t     *objp = pr;\n\t     free(p);\n\t} else\n\t     *objp = NULL;\n\tbreak;\n    case XDR_FREE:\n\tif(*objp != NULL)\n\t    krb5_free_principal(context, *objp);\n\t*objp = NULL;\n\tbreak;\n    }\n    return TRUE;\n}\n\nbool_t\nxdr_krb5_octet(XDR *xdrs, krb5_octet *objp)\n{\n   if (!xdr_u_char(xdrs, objp))\n\treturn (FALSE);\n   return (TRUE);\n}\n\nbool_t\nxdr_krb5_enctype(XDR *xdrs, krb5_enctype *objp)\n{\n   if (!xdr_int32(xdrs, (int32_t *) objp))\n\treturn (FALSE);\n   return (TRUE);\n}\n\nbool_t\nxdr_krb5_salttype(XDR *xdrs, krb5_int32 *objp)\n{\n    if (!xdr_int32(xdrs, (int32_t *) objp))\n\treturn FALSE;\n    return TRUE;\n}\n\nbool_t\nxdr_krb5_keyblock(XDR *xdrs, krb5_keyblock *objp)\n{\n   char *cp;\n\n   /* XXX This only works because free_keyblock assumes ->contents\n      is allocated by malloc() */\n   if(!xdr_krb5_enctype(xdrs, &objp->enctype))\n      return FALSE;\n   cp = (char *)objp->contents;\n   if(!xdr_bytes(xdrs, &cp, &objp->length, ~0))\n      return FALSE;\n   objp->contents = (uint8_t *)cp;\n   return TRUE;\n}\n\nbool_t\nxdr_krb5_string_attr(XDR *xdrs, krb5_string_attr *objp)\n{\n\tif (!xdr_nullstring(xdrs, &objp->key))\n\t\treturn FALSE;\n\tif (!xdr_nullstring(xdrs, &objp->value))\n\t\treturn FALSE;\n\tif (xdrs->x_op == XDR_DECODE &&\n\t    (objp->key == NULL || objp->value == NULL))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\nbool_t\nxdr_kadm5_key_data(XDR *xdrs, kadm5_key_data *objp)\n{\n\tif (!xdr_krb5_kvno(xdrs, &objp->kvno))\n\t\treturn FALSE;\n\tif (!xdr_krb5_keyblock(xdrs, &objp->key))\n\t\treturn FALSE;\n\tif (!xdr_krb5_int16(xdrs, &objp->salt.type))\n\t\treturn FALSE;\n\tif (!xdr_bytes(xdrs, &objp->salt.data.data,\n\t\t       &objp->salt.data.length, ~0))\n\t\treturn FALSE;\n\treturn TRUE;\n}\n\nbool_t\nxdr_getpkeys_arg(XDR *xdrs, getpkeys_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn FALSE;\n\t}\n\tif (!xdr_krb5_principal(xdrs, &objp->princ)) {\n\t\treturn FALSE;\n\t}\n\tif (!xdr_krb5_kvno(xdrs, &objp->kvno)) {\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}\n\nbool_t\nxdr_getpkeys_ret(XDR *xdrs, getpkeys_ret *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn FALSE;\n\t}\n\tif (!xdr_kadm5_ret_t(xdrs, &objp->code)) {\n\t\treturn FALSE;\n\t}\n\tif (objp->code == KADM5_OK) {\n\t\tif (!xdr_array(xdrs, (caddr_t *) &objp->key_data,\n\t\t\t       (unsigned int *) &objp->n_key_data, ~0,\n\t\t\t       sizeof(kadm5_key_data), xdr_kadm5_key_data)) {\n\t\t    return FALSE;\n\t\t}\n\t}\n\treturn TRUE;\n}\n"], "filenames": ["src/lib/kadm5/kadm_rpc_xdr.c"], "buggy_code_start_loc": [392], "buggy_code_end_loc": [457], "fixing_code_start_loc": [393], "fixing_code_end_loc": [462], "type": "CWE-824", "message": "lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count.", "other": {"cve": {"id": "CVE-2023-36054", "sourceIdentifier": "cve@mitre.org", "published": "2023-08-07T19:15:09.840", "lastModified": "2023-11-15T03:23:27.470", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lib/kadm5/kadm_rpc_xdr.c in MIT Kerberos 5 (aka krb5) before 1.20.2 and 1.21.x before 1.21.1 frees an uninitialized pointer. A remote authenticated user can trigger a kadmind crash. This occurs because _xdr_kadm5_principal_ent_rec does not validate the relationship between n_key_data and the key_data array count."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-824"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.20.2", "matchCriteriaId": "8F862235-F5E3-46F0-8907-5521B79DD14D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.21:-:*:*:*:*:*:*", "matchCriteriaId": "77FA11D6-3074-412F-9008-A4F690C79133"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.21:beta1:*:*:*:*:*:*", "matchCriteriaId": "5096413B-6BEE-424A-A198-C01934E45000"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:clustered_data_ontap:9.0:-:*:*:*:*:*:*", "matchCriteriaId": "52DE3DFE-350F-4E83-B425-1D7D47BEF6DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci:-:*:*:*:*:*:*:*", "matchCriteriaId": "8A6E548F-62E9-40CB-85DA-FDAA0F0096C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:management_services_for_element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "86B51137-28D9-41F2-AFA2-3CC22B4954D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_tools:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "CBCC384C-5DF0-41AB-B17B-6E9B6CAE8065"}]}]}], "references": [{"url": "https://github.com/krb5/krb5/commit/ef08b09c9459551aabbe7924fb176f1583053cdd", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/krb5/krb5/compare/krb5-1.20.1-final...krb5-1.20.2-final", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/krb5/krb5/compare/krb5-1.21-final...krb5-1.21.1-final", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/10/msg00031.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230908-0004/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://web.mit.edu/kerberos/www/advisories/", "source": "cve@mitre.org", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/ef08b09c9459551aabbe7924fb176f1583053cdd"}}