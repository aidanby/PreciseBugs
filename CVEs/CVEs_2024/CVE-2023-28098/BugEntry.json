{"buggy_code": ["/*\n * 32-bit Digest parameter name parser\n *\n * Copyright (C) 2001-2003 FhG Fokus\n *\n * This file is part of opensips, a free SIP server.\n *\n * opensips is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * opensips is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n#include \"param_parser.h\"\n#include \"digest_keys.h\"\n#include \"../../trim.h\"\n#include \"../../ut.h\"\n\n#define LOWER_BYTE(b) ((b) | 0x20)\n#define LOWER_DWORD(d) ((d) | 0x20202020)\n\n/*\n * Parse short (less than 4 bytes) parameter names\n */\n#define PARSE_SHORT                                                   \\\n\tswitch(LOWER_BYTE(*p)) {                                      \\\n\tcase 'u':                                                     \\\n\t\tif (LOWER_BYTE(*(p + 1)) == 'r') {                    \\\n\t\t\tif (LOWER_BYTE(*(p + 2)) == 'i') {            \\\n\t\t\t\t*_type = PAR_URI;                     \\\n                                p += 3;                               \\\n\t\t\t\tgoto end;                             \\\n\t\t\t}                                             \\\n\t\t}                                                     \\\n\t\tbreak;                                                \\\n                                                                      \\\n\tcase 'q':                                                     \\\n\t\tif (LOWER_BYTE(*(p + 1)) == 'o') {                    \\\n\t\t\tif (LOWER_BYTE(*(p + 2)) == 'p') {            \\\n\t\t\t\t*_type = PAR_QOP;                     \\\n                                p += 3;                               \\\n\t\t\t\tgoto end;                             \\\n\t\t\t}                                             \\\n\t\t}                                                     \\\n\t\tbreak;                                                \\\n                                                                      \\\n\tcase 'n':                                                     \\\n\t\tif (LOWER_BYTE(*(p + 1)) == 'c') {                    \\\n\t\t\t*_type = PAR_NC;                              \\\n                        p += 2;                                       \\\n\t\t\tgoto end;                                     \\\n\t\t}                                                     \\\n\t\tbreak;                                                \\\n\t}\n\n\n/*\n * Read 4-bytes from memory and store them in an integer variable\n * Reading byte by byte ensures, that the code works also on HW which\n * does not allow reading 4-bytes at once from unaligned memory position\n * (Sparc for example)\n */\n#define READ(val) \\\n(*(val + 0) + (*(val + 1) << 8) + (*(val + 2) << 16) + (*(val + 3) << 24))\n\n\n#define name_CASE                      \\\n        switch(LOWER_DWORD(val)) {     \\\n        case _name_:                   \\\n\t\t*_type = PAR_USERNAME; \\\n                p += 4;                \\\n\t\tgoto end;              \\\n        }\n\n\n#define user_CASE         \\\n        p += 4;           \\\n        val = READ(p);    \\\n        name_CASE;        \\\n        goto other;\n\n\n#define real_CASE                         \\\n        p += 4;                           \\\n        if (LOWER_BYTE(*p) == 'm') {      \\\n\t\t*_type = PAR_REALM;       \\\n                p++;                      \\\n\t\tgoto end;                 \\\n\t}\n\n\n#define nonc_CASE                         \\\n        p += 4;                           \\\n        if (LOWER_BYTE(*p) == 'e') {      \\\n\t        *_type = PAR_NONCE;       \\\n                p++;                      \\\n\t\tgoto end;                 \\\n\t}\n\n\n#define onse_CASE                      \\\n        switch(LOWER_DWORD(val)) {     \\\n        case _onse_:                   \\\n\t\t*_type = PAR_RESPONSE; \\\n                p += 4;                \\\n\t\tgoto end;              \\\n        }\n\n\n#define resp_CASE         \\\n        p += 4;           \\\n        val = READ(p);    \\\n        onse_CASE;        \\\n        goto other;\n\n\n#define cnon_CASE                                 \\\n        p += 4;                                   \\\n        if (LOWER_BYTE(*p) == 'c') {              \\\n\t\tp++;                              \\\n\t\tif (LOWER_BYTE(*p) == 'e') {      \\\n\t\t\t*_type = PAR_CNONCE;      \\\n                        p++;                      \\\n\t\t\tgoto end;                 \\\n\t\t}                                 \\\n\t}                                         \\\n        goto other;\n\n\n#define opaq_CASE                                 \\\n        p += 4;                                   \\\n        if (LOWER_BYTE(*p) == 'u') {              \\\n\t\tp++;                              \\\n\t\tif (LOWER_BYTE(*p) == 'e') {      \\\n\t\t\t*_type = PAR_OPAQUE;      \\\n                        p++;                      \\\n\t\t\tgoto end;                 \\\n\t\t}                                 \\\n\t}                                         \\\n        goto other;\n\n\n#define rith_CASE                                 \\\n        switch(LOWER_DWORD(val)) {                \\\n\tcase _rith_:                              \\\n\t\tp += 4;                           \\\n\t\tif (LOWER_BYTE(*p) == 'm') {      \\\n\t\t\t*_type = PAR_ALGORITHM;   \\\n                        p++;                      \\\n\t\t\tgoto end;                 \\\n\t\t}                                 \\\n\t\tgoto other;                       \\\n\t}\n\n\n#define algo_CASE         \\\n        p += 4;           \\\n        val = READ(p);    \\\n        rith_CASE;        \\\n        goto other\n\n\n#define FIRST_QUATERNIONS       \\\n        case _user_: user_CASE; \\\n        case _real_: real_CASE; \\\n        case _nonc_: nonc_CASE; \\\n        case _resp_: resp_CASE; \\\n        case _cnon_: cnon_CASE; \\\n        case _opaq_: opaq_CASE; \\\n        case _algo_: algo_CASE;\n\n\n\n\nint parse_param_name(str* _s, dig_par_t* _type)\n{\n        register char* p;\n        register int val;\n\tchar* end;\n\n\tend = _s->s + _s->len;\n\n\tp = _s->s;\n\tval = READ(p);\n\n\tif (_s->len < 4) {\n\t\tgoto other;\n\t}\n\n        switch(LOWER_DWORD(val)) {\n\tFIRST_QUATERNIONS;\n\tdefault:\n\t\tPARSE_SHORT;\n\t\tgoto other;\n        }\n\n end:\n\t_s->len -= p - _s->s;\n\t_s->s = p;\n\n\ttrim_leading(_s);\n\tif (_s->s[0] == '=') {\n\t\treturn 0;\n\t}\n\n other:\n\tp = q_memchr(p, '=', end - p);\n\tif (!p) {\n\t\treturn -1; /* Parse error */\n\t} else {\n\t\t*_type = PAR_OTHER;\n\t\t_s->len -= p - _s->s;\n\t\t_s->s = p;\n\t\treturn 0;\n\t}\n}\n"], "fixing_code": ["/*\n * 32-bit Digest parameter name parser\n *\n * Copyright (C) 2001-2003 FhG Fokus\n *\n * This file is part of opensips, a free SIP server.\n *\n * opensips is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * opensips is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n */\n\n#include \"param_parser.h\"\n#include \"digest_keys.h\"\n#include \"../../trim.h\"\n#include \"../../ut.h\"\n\n#define LOWER_BYTE(b) ((b) | 0x20)\n#define LOWER_DWORD(d) ((d) | 0x20202020)\n\n/*\n * Parse short (less than 4 bytes) parameter names\n */\n#define PARSE_SHORT                                                   \\\n\tswitch(LOWER_BYTE(*p)) {                                      \\\n\tcase 'u':                                                     \\\n\t\tif (LOWER_BYTE(*(p + 1)) == 'r') {                    \\\n\t\t\tif (LOWER_BYTE(*(p + 2)) == 'i') {            \\\n\t\t\t\t*_type = PAR_URI;                     \\\n                                p += 3;                               \\\n\t\t\t\tgoto end;                             \\\n\t\t\t}                                             \\\n\t\t}                                                     \\\n\t\tbreak;                                                \\\n                                                                      \\\n\tcase 'q':                                                     \\\n\t\tif (LOWER_BYTE(*(p + 1)) == 'o') {                    \\\n\t\t\tif (LOWER_BYTE(*(p + 2)) == 'p') {            \\\n\t\t\t\t*_type = PAR_QOP;                     \\\n                                p += 3;                               \\\n\t\t\t\tgoto end;                             \\\n\t\t\t}                                             \\\n\t\t}                                                     \\\n\t\tbreak;                                                \\\n                                                                      \\\n\tcase 'n':                                                     \\\n\t\tif (LOWER_BYTE(*(p + 1)) == 'c') {                    \\\n\t\t\t*_type = PAR_NC;                              \\\n                        p += 2;                                       \\\n\t\t\tgoto end;                                     \\\n\t\t}                                                     \\\n\t\tbreak;                                                \\\n\t}\n\n\n/*\n * Read 4-bytes from memory and store them in an integer variable\n * Reading byte by byte ensures, that the code works also on HW which\n * does not allow reading 4-bytes at once from unaligned memory position\n * (Sparc for example)\n */\n#define READ(val) \\\n(*(val + 0) + (*(val + 1) << 8) + (*(val + 2) << 16) + (*(val + 3) << 24))\n\n#define NEED(bytes) do { if (end - p < (bytes)) goto other; } while (0)\n\n#define name_CASE                      \\\n        switch(LOWER_DWORD(val)) {     \\\n        case _name_:                   \\\n\t\t*_type = PAR_USERNAME; \\\n                p += 4;                \\\n\t\tgoto end;              \\\n        }\n\n\n#define user_CASE         \\\n        p += 4; NEED(4);  \\\n        val = READ(p);    \\\n        name_CASE;        \\\n        goto other;\n\n\n#define real_CASE                         \\\n        p += 4; NEED(1);                  \\\n        if (LOWER_BYTE(*p) == 'm') {      \\\n\t\t*_type = PAR_REALM;       \\\n                p++;                      \\\n\t\tgoto end;                 \\\n\t}                                 \\\n        goto other;\n\n\n#define nonc_CASE                         \\\n        p += 4; NEED(1);                  \\\n        if (LOWER_BYTE(*p) == 'e') {      \\\n\t        *_type = PAR_NONCE;       \\\n                p++;                      \\\n\t\tgoto end;                 \\\n\t}                                 \\\n        goto other;\n\n\n#define onse_CASE                      \\\n        switch(LOWER_DWORD(val)) {     \\\n        case _onse_:                   \\\n\t\t*_type = PAR_RESPONSE; \\\n                p += 4;                \\\n\t\tgoto end;              \\\n        }\n\n\n#define resp_CASE         \\\n        p += 4; NEED(4);  \\\n        val = READ(p);    \\\n        onse_CASE;        \\\n        goto other;\n\n\n#define cnon_CASE                                 \\\n        p += 4; NEED(2);                          \\\n        if (LOWER_BYTE(*p) == 'c') {              \\\n\t\tp++;                              \\\n\t\tif (LOWER_BYTE(*p) == 'e') {      \\\n\t\t\t*_type = PAR_CNONCE;      \\\n                        p++;                      \\\n\t\t\tgoto end;                 \\\n\t\t}                                 \\\n\t}                                         \\\n        goto other;\n\n\n#define opaq_CASE                                 \\\n        p += 4; NEED(2);                          \\\n        if (LOWER_BYTE(*p) == 'u') {              \\\n\t\tp++;                              \\\n\t\tif (LOWER_BYTE(*p) == 'e') {      \\\n\t\t\t*_type = PAR_OPAQUE;      \\\n                        p++;                      \\\n\t\t\tgoto end;                 \\\n\t\t}                                 \\\n\t}                                         \\\n        goto other;\n\n\n#define rith_CASE                                 \\\n        switch(LOWER_DWORD(val)) {                \\\n\tcase _rith_:                              \\\n\t\tp += 4;                           \\\n\t\tif (LOWER_BYTE(*p) == 'm') {      \\\n\t\t\t*_type = PAR_ALGORITHM;   \\\n                        p++;                      \\\n\t\t\tgoto end;                 \\\n\t\t}                                 \\\n\t\tgoto other;                       \\\n\t}\n\n\n#define algo_CASE         \\\n        p += 4; NEED(5);  \\\n        val = READ(p);    \\\n        rith_CASE;        \\\n        goto other\n\n\n#define FIRST_QUATERNIONS       \\\n        case _user_: user_CASE; \\\n        case _real_: real_CASE; \\\n        case _nonc_: nonc_CASE; \\\n        case _resp_: resp_CASE; \\\n        case _cnon_: cnon_CASE; \\\n        case _opaq_: opaq_CASE; \\\n        case _algo_: algo_CASE;\n\n\n\n\nint parse_param_name(str* _s, dig_par_t* _type)\n{\n        register char* p;\n        register int val;\n\tchar* end;\n\n\tend = _s->s + _s->len;\n\n\tp = _s->s;\n\tval = READ(p);\n\n\tif (_s->len < 4) {\n\t\tgoto other;\n\t}\n\n        switch(LOWER_DWORD(val)) {\n\tFIRST_QUATERNIONS;\n\tdefault:\n\t\tPARSE_SHORT;\n\t\tgoto other;\n        }\n\n end:\n\t_s->len -= p - _s->s;\n\t_s->s = p;\n\n\ttrim_leading(_s);\n\tif (_s->s[0] == '=') {\n\t\treturn 0;\n\t}\n\n other:\n\tp = q_memchr(p, '=', end - p);\n\tif (!p) {\n\t\treturn -1; /* Parse error */\n\t} else {\n\t\t*_type = PAR_OTHER;\n\t\t_s->len -= p - _s->s;\n\t\t_s->s = p;\n\t\treturn 0;\n\t}\n}\n"], "filenames": ["parser/digest/param_parser.c"], "buggy_code_start_loc": [74], "buggy_code_end_loc": [167], "fixing_code_start_loc": [75], "fixing_code_end_loc": [170], "type": "NVD-CWE-noinfo", "message": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.7 and 3.2.4, a specially crafted Authorization header causes OpenSIPS to crash or behave in an unexpected way due to a bug in the function `parse_param_name()` . This issue was discovered while performing coverage guided fuzzing of the function parse_msg. The AddressSanitizer identified that the issue occurred in the function `q_memchr()` which is being called by the function `parse_param_name()`. This issue may cause erratic program behaviour or a server crash. It affects configurations containing functions that make use of the affected code, such as the function `www_authorize()` . Versions 3.1.7 and 3.2.4 contain a fix.", "other": {"cve": {"id": "CVE-2023-28098", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-15T23:15:09.717", "lastModified": "2023-03-21T22:39:28.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.7 and 3.2.4, a specially crafted Authorization header causes OpenSIPS to crash or behave in an unexpected way due to a bug in the function `parse_param_name()` . This issue was discovered while performing coverage guided fuzzing of the function parse_msg. The AddressSanitizer identified that the issue occurred in the function `q_memchr()` which is being called by the function `parse_param_name()`. This issue may cause erratic program behaviour or a server crash. It affects configurations containing functions that make use of the affected code, such as the function `www_authorize()` . Versions 3.1.7 and 3.2.4 contain a fix."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensips:opensips:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.7", "matchCriteriaId": "8EF642AA-D786-40DF-801D-515888AF89BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensips:opensips:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2.0", "versionEndExcluding": "3.2.4", "matchCriteriaId": "34713A76-CAED-43CF-A77C-73F1C36208AA"}]}]}], "references": [{"url": "https://github.com/OpenSIPS/opensips/commit/dd9141b6f67d7df4072f3430f628d4b73df5e102", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenSIPS/opensips/security/advisories/GHSA-jrqg-vppj-hr2h", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenSIPS/opensips/commit/dd9141b6f67d7df4072f3430f628d4b73df5e102"}}