{"buggy_code": ["// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2015-2016, Linaro Limited\n * Copyright (c) 2014, STMicroelectronics International N.V.\n */\n\n#include <assert.h>\n#include <bench.h>\n#include <compiler.h>\n#include <initcall.h>\n#include <io.h>\n#include <kernel/linker.h>\n#include <kernel/msg_param.h>\n#include <kernel/panic.h>\n#include <kernel/tee_misc.h>\n#include <mm/core_memprot.h>\n#include <mm/core_mmu.h>\n#include <mm/mobj.h>\n#include <optee_msg.h>\n#include <sm/optee_smc.h>\n#include <string.h>\n#include <tee/entry_std.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee/uuid.h>\n#include <util.h>\n\n#define SHM_CACHE_ATTRS\t\\\n\t(uint32_t)(core_mmu_is_shm_cached() ?  OPTEE_SMC_SHM_CACHED : 0)\n\n/* Sessions opened from normal world */\nstatic struct tee_ta_session_head tee_open_sessions =\nTAILQ_HEAD_INITIALIZER(tee_open_sessions);\n\nstatic struct mobj *shm_mobj;\n#ifdef CFG_SECURE_DATA_PATH\nstatic struct mobj **sdp_mem_mobjs;\n#endif\n\nstatic unsigned int session_pnum;\n\nstatic bool param_mem_from_mobj(struct param_mem *mem, struct mobj *mobj,\n\t\t\t\tconst paddr_t pa, const size_t sz)\n{\n\tpaddr_t b;\n\n\tif (mobj_get_pa(mobj, 0, 0, &b) != TEE_SUCCESS)\n\t\tpanic(\"mobj_get_pa failed\");\n\n\tif (!core_is_buffer_inside(pa, MAX(sz, 1UL), b, mobj->size))\n\t\treturn false;\n\n\tmem->mobj = mobj;\n\tmem->offs = pa - b;\n\tmem->size = sz;\n\treturn true;\n}\n\n/* fill 'struct param_mem' structure if buffer matches a valid memory object */\nstatic TEE_Result set_tmem_param(const struct optee_msg_param_tmem *tmem,\n\t\t\t\t uint32_t attr, struct param_mem *mem)\n{\n\tstruct mobj __maybe_unused **mobj;\n\tpaddr_t pa = READ_ONCE(tmem->buf_ptr);\n\tsize_t sz = READ_ONCE(tmem->size);\n\n\t/* NULL Memory Rerefence? */\n\tif (!pa && !sz) {\n\t\tmem->mobj = NULL;\n\t\tmem->offs = 0;\n\t\tmem->size = 0;\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* Non-contigous buffer from non sec DDR? */\n\tif (attr & OPTEE_MSG_ATTR_NONCONTIG) {\n\t\tuint64_t shm_ref = READ_ONCE(tmem->shm_ref);\n\n\t\tmem->mobj = msg_param_mobj_from_noncontig(pa, sz, shm_ref,\n\t\t\t\t\t\t\t  false);\n\t\tif (!mem->mobj)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tmem->offs = 0;\n\t\tmem->size = sz;\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* Belongs to nonsecure shared memory? */\n\tif (param_mem_from_mobj(mem, shm_mobj, pa, sz))\n\t\treturn TEE_SUCCESS;\n\n#ifdef CFG_SECURE_DATA_PATH\n\t/* Belongs to SDP memories? */\n\tfor (mobj = sdp_mem_mobjs; *mobj; mobj++)\n\t\tif (param_mem_from_mobj(mem, *mobj, pa, sz))\n\t\t\treturn TEE_SUCCESS;\n#endif\n\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n\nstatic TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = READ_ONCE(rmem->size);\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result copy_in_params(const struct optee_msg_param *params,\n\t\t\t\t uint32_t num_params,\n\t\t\t\t struct tee_ta_param *ta_param,\n\t\t\t\t uint64_t *saved_attr)\n{\n\tTEE_Result res;\n\tsize_t n;\n\tuint8_t pt[TEE_NUM_PARAMS] = { 0 };\n\n\tif (num_params > TEE_NUM_PARAMS)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmemset(ta_param, 0, sizeof(*ta_param));\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tuint32_t attr;\n\n\t\tsaved_attr[n] = READ_ONCE(params[n].attr);\n\n\t\tif (saved_attr[n] & OPTEE_MSG_ATTR_META)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tattr = saved_attr[n] & OPTEE_MSG_ATTR_TYPE_MASK;\n\t\tswitch (attr) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_NONE:\n\t\t\tpt[n] = TEE_PARAM_TYPE_NONE;\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_INOUT:\n\t\t\tpt[n] = TEE_PARAM_TYPE_VALUE_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_VALUE_INPUT;\n\t\t\tta_param->u[n].val.a = READ_ONCE(params[n].u.value.a);\n\t\t\tta_param->u[n].val.b = READ_ONCE(params[n].u.value.b);\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n\t\t\tres = set_tmem_param(&params[n].u.tmem, saved_attr[n],\n\t\t\t\t\t     &ta_param->u[n].mem);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tpt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_TMEM_INPUT;\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n\t\t\tres = set_rmem_param(&params[n].u.rmem,\n\t\t\t\t\t     &ta_param->u[n].mem);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tpt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_RMEM_INPUT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\tta_param->types = TEE_PARAM_TYPES(pt[0], pt[1], pt[2], pt[3]);\n\n\treturn TEE_SUCCESS;\n}\n\nstatic void cleanup_shm_refs(const uint64_t *saved_attr,\n\t\t\t     struct tee_ta_param *param, uint32_t num_params)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (saved_attr[n]) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n\t\t\tif (saved_attr[n] & OPTEE_MSG_ATTR_NONCONTIG)\n\t\t\t\tmobj_free(param->u[n].mem.mobj);\n\t\t\tbreak;\n\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n\t\t\tmobj_reg_shm_put(param->u[n].mem.mobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void copy_out_param(struct tee_ta_param *ta_param, uint32_t num_params,\n\t\t\t   struct optee_msg_param *params, uint64_t *saved_attr)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (TEE_PARAM_TYPE_GET(ta_param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tswitch (saved_attr[n] & OPTEE_MSG_ATTR_TYPE_MASK) {\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n\t\t\t\tparams[n].u.tmem.size = ta_param->u[n].mem.size;\n\t\t\t\tbreak;\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n\t\t\t\tparams[n].u.rmem.size = ta_param->u[n].mem.size;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tparams[n].u.value.a = ta_param->u[n].val.a;\n\t\t\tparams[n].u.value.b = ta_param->u[n].val.b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * Extracts mandatory parameter for open session.\n *\n * Returns\n * false : mandatory parameter wasn't found or malformatted\n * true  : paramater found and OK\n */\nstatic TEE_Result get_open_session_meta(size_t num_params,\n\t\t\t\t\tstruct optee_msg_param *params,\n\t\t\t\t\tsize_t *num_meta, TEE_UUID *uuid,\n\t\t\t\t\tTEE_Identity *clnt_id)\n{\n\tconst uint32_t req_attr = OPTEE_MSG_ATTR_META |\n\t\t\t\t  OPTEE_MSG_ATTR_TYPE_VALUE_INPUT;\n\n\tif (num_params < 2)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (params[0].attr != req_attr || params[1].attr != req_attr)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttee_uuid_from_octets(uuid, (void *)&params[0].u.value);\n\tclnt_id->login = params[1].u.value.c;\n\tswitch (clnt_id->login) {\n\tcase TEE_LOGIN_PUBLIC:\n\t\tmemset(&clnt_id->uuid, 0, sizeof(clnt_id->uuid));\n\t\tbreak;\n\tcase TEE_LOGIN_USER:\n\tcase TEE_LOGIN_GROUP:\n\tcase TEE_LOGIN_APPLICATION:\n\tcase TEE_LOGIN_APPLICATION_USER:\n\tcase TEE_LOGIN_APPLICATION_GROUP:\n\t\ttee_uuid_from_octets(&clnt_id->uuid,\n\t\t\t\t     (void *)&params[1].u.value);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t*num_meta = 2;\n\treturn TEE_SUCCESS;\n}\n\nstatic void entry_open_session(struct thread_smc_args *smc_args,\n\t\t\t       struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tTEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s = NULL;\n\tTEE_Identity clnt_id;\n\tTEE_UUID uuid;\n\tstruct tee_ta_param param;\n\tsize_t num_meta;\n\tuint64_t saved_attr[TEE_NUM_PARAMS] = { 0 };\n\n\tres = get_open_session_meta(num_params, arg->params, &num_meta, &uuid,\n\t\t\t\t    &clnt_id);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = copy_in_params(arg->params + num_meta, num_params - num_meta,\n\t\t\t     &param, saved_attr);\n\tif (res != TEE_SUCCESS)\n\t\tgoto cleanup_shm_refs;\n\n\tres = tee_ta_open_session(&err_orig, &s, &tee_open_sessions, &uuid,\n\t\t\t\t  &clnt_id, TEE_TIMEOUT_INFINITE, &param);\n\tif (res != TEE_SUCCESS)\n\t\ts = NULL;\n\tcopy_out_param(&param, num_params - num_meta, arg->params + num_meta,\n\t\t       saved_attr);\n\n\t/*\n\t * The occurrence of open/close session command is usually\n\t * un-predictable, using this property to increase randomness\n\t * of prng\n\t */\n\tplat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_SESSION,\n\t\t\t\t     &session_pnum);\n\ncleanup_shm_refs:\n\tcleanup_shm_refs(saved_attr, &param, num_params - num_meta);\n\nout:\n\tif (s)\n\t\targ->session = (vaddr_t)s;\n\telse\n\t\targ->session = 0;\n\targ->ret = res;\n\targ->ret_origin = err_orig;\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n}\n\nstatic void entry_close_session(struct thread_smc_args *smc_args,\n\t\t\tstruct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tif (num_params) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tplat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_SESSION,\n\t\t\t\t     &session_pnum);\n\n\ts = (struct tee_ta_session *)(vaddr_t)arg->session;\n\tres = tee_ta_close_session(s, &tee_open_sessions, NSAPP_IDENTITY);\nout:\n\targ->ret = res;\n\targ->ret_origin = TEE_ORIGIN_TEE;\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n}\n\nstatic void entry_invoke_command(struct thread_smc_args *smc_args,\n\t\t\t\t struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tTEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s;\n\tstruct tee_ta_param param = { 0 };\n\tuint64_t saved_attr[TEE_NUM_PARAMS] = { 0 };\n\n\tbm_timestamp();\n\n\tres = copy_in_params(arg->params, num_params, &param, saved_attr);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\ts = tee_ta_get_session(arg->session, true, &tee_open_sessions);\n\tif (!s) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tres = tee_ta_invoke_command(&err_orig, s, NSAPP_IDENTITY,\n\t\t\t\t    TEE_TIMEOUT_INFINITE, arg->func, &param);\n\n\tbm_timestamp();\n\n\ttee_ta_put_session(s);\n\n\tcopy_out_param(&param, num_params, arg->params, saved_attr);\n\nout:\n\tcleanup_shm_refs(saved_attr, &param, num_params);\n\n\targ->ret = res;\n\targ->ret_origin = err_orig;\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n}\n\nstatic void entry_cancel(struct thread_smc_args *smc_args,\n\t\t\tstruct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tTEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s;\n\n\tif (num_params) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\ts = tee_ta_get_session(arg->session, false, &tee_open_sessions);\n\tif (!s) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tres = tee_ta_cancel_command(&err_orig, s, NSAPP_IDENTITY);\n\ttee_ta_put_session(s);\n\nout:\n\targ->ret = res;\n\targ->ret_origin = err_orig;\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n}\n\nstatic void register_shm(struct thread_smc_args *smc_args,\n\t\t\t struct optee_msg_arg *arg, uint32_t num_params)\n{\n\targ->ret = TEE_ERROR_BAD_PARAMETERS;\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n\n\tif (num_params != 1 ||\n\t    (arg->params[0].attr !=\n\t     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))\n\t\treturn;\n\n\tstruct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;\n\tstruct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,\n\t\t\t\t\t\t\t  tmem->size,\n\t\t\t\t\t\t\t  tmem->shm_ref, false);\n\n\tif (!mobj)\n\t\treturn;\n\n\tmobj_reg_shm_unguard(mobj);\n\targ->ret = TEE_SUCCESS;\n}\n\nstatic void unregister_shm(struct thread_smc_args *smc_args,\n\t\t\t   struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tif (num_params == 1) {\n\t\tuint64_t cookie = arg->params[0].u.rmem.shm_ref;\n\t\tTEE_Result res = mobj_reg_shm_release_by_cookie(cookie);\n\n\t\tif (res)\n\t\t\tEMSG(\"Can't find mapping with given cookie\");\n\t\targ->ret = res;\n\t} else {\n\t\targ->ret = TEE_ERROR_BAD_PARAMETERS;\n\t\targ->ret_origin = TEE_ORIGIN_TEE;\n\t}\n\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n}\n\nstatic struct mobj *map_cmd_buffer(paddr_t parg, uint32_t *num_params)\n{\n\tstruct mobj *mobj;\n\tstruct optee_msg_arg *arg;\n\tsize_t args_size;\n\n\tassert(!(parg & SMALL_PAGE_MASK));\n\t/* mobj_mapped_shm_alloc checks if parg resides in nonsec ddr */\n\tmobj = mobj_mapped_shm_alloc(&parg, 1, 0, 0);\n\tif (!mobj)\n\t\treturn NULL;\n\n\targ = mobj_get_va(mobj, 0);\n\tif (!arg) {\n\t\tmobj_free(mobj);\n\t\treturn NULL;\n\t}\n\n\t*num_params = READ_ONCE(arg->num_params);\n\targs_size = OPTEE_MSG_GET_ARG_SIZE(*num_params);\n\tif (args_size > SMALL_PAGE_SIZE) {\n\t\tEMSG(\"Command buffer spans across page boundary\");\n\t\tmobj_free(mobj);\n\t\treturn NULL;\n\t}\n\n\treturn mobj;\n}\n\nstatic struct mobj *get_cmd_buffer(paddr_t parg, uint32_t *num_params)\n{\n\tstruct optee_msg_arg *arg;\n\tsize_t args_size;\n\n\targ = phys_to_virt(parg, MEM_AREA_NSEC_SHM);\n\tif (!arg)\n\t\treturn NULL;\n\n\t*num_params = READ_ONCE(arg->num_params);\n\targs_size = OPTEE_MSG_GET_ARG_SIZE(*num_params);\n\n\treturn mobj_shm_alloc(parg, args_size, 0);\n}\n\n/*\n * Note: this function is weak just to make it possible to exclude it from\n * the unpaged area.\n */\nvoid __weak tee_entry_std(struct thread_smc_args *smc_args)\n{\n\tpaddr_t parg;\n\tstruct optee_msg_arg *arg = NULL;\t/* fix gcc warning */\n\tuint32_t num_params = 0;\t\t/* fix gcc warning */\n\tstruct mobj *mobj;\n\n\tif (smc_args->a0 != OPTEE_SMC_CALL_WITH_ARG) {\n\t\tEMSG(\"Unknown SMC 0x%\" PRIx64, (uint64_t)smc_args->a0);\n\t\tDMSG(\"Expected 0x%x\\n\", OPTEE_SMC_CALL_WITH_ARG);\n\t\tsmc_args->a0 = OPTEE_SMC_RETURN_EBADCMD;\n\t\treturn;\n\t}\n\tparg = (uint64_t)smc_args->a1 << 32 | smc_args->a2;\n\n\t/* Check if this region is in static shared space */\n\tif (core_pbuf_is(CORE_MEM_NSEC_SHM, parg,\n\t\t\t  sizeof(struct optee_msg_arg))) {\n\t\tmobj = get_cmd_buffer(parg, &num_params);\n\t} else {\n\t\tif (parg & SMALL_PAGE_MASK) {\n\t\t\tsmc_args->a0 = OPTEE_SMC_RETURN_EBADADDR;\n\t\t\treturn;\n\t\t}\n\t\tmobj = map_cmd_buffer(parg, &num_params);\n\t}\n\n\tif (!mobj || !ALIGNMENT_IS_OK(parg, struct optee_msg_arg)) {\n\t\tEMSG(\"Bad arg address 0x%\" PRIxPA, parg);\n\t\tsmc_args->a0 = OPTEE_SMC_RETURN_EBADADDR;\n\t\tmobj_free(mobj);\n\t\treturn;\n\t}\n\n\targ = mobj_get_va(mobj, 0);\n\tassert(arg && mobj_is_nonsec(mobj));\n\n\t/* Enable foreign interrupts for STD calls */\n\tthread_set_foreign_intr(true);\n\tswitch (arg->cmd) {\n\tcase OPTEE_MSG_CMD_OPEN_SESSION:\n\t\tentry_open_session(smc_args, arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_CLOSE_SESSION:\n\t\tentry_close_session(smc_args, arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_INVOKE_COMMAND:\n\t\tentry_invoke_command(smc_args, arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_CANCEL:\n\t\tentry_cancel(smc_args, arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_REGISTER_SHM:\n\t\tregister_shm(smc_args, arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_UNREGISTER_SHM:\n\t\tunregister_shm(smc_args, arg, num_params);\n\t\tbreak;\n\n\tdefault:\n\t\tEMSG(\"Unknown cmd 0x%x\\n\", arg->cmd);\n\t\tsmc_args->a0 = OPTEE_SMC_RETURN_EBADCMD;\n\t}\n\tmobj_free(mobj);\n}\n\nstatic TEE_Result default_mobj_init(void)\n{\n\tshm_mobj = mobj_phys_alloc(default_nsec_shm_paddr,\n\t\t\t\t   default_nsec_shm_size, SHM_CACHE_ATTRS,\n\t\t\t\t   CORE_MEM_NSEC_SHM);\n\tif (!shm_mobj)\n\t\tpanic(\"Failed to register shared memory\");\n\n#ifdef CFG_SECURE_DATA_PATH\n\tsdp_mem_mobjs = core_sdp_mem_create_mobjs();\n\tif (!sdp_mem_mobjs)\n\t\tpanic(\"Failed to register SDP memory\");\n#endif\n\n\treturn TEE_SUCCESS;\n}\n\ndriver_init_late(default_mobj_init);\n"], "fixing_code": ["// SPDX-License-Identifier: BSD-2-Clause\n/*\n * Copyright (c) 2015-2016, Linaro Limited\n * Copyright (c) 2014, STMicroelectronics International N.V.\n */\n\n#include <assert.h>\n#include <bench.h>\n#include <compiler.h>\n#include <initcall.h>\n#include <io.h>\n#include <kernel/linker.h>\n#include <kernel/msg_param.h>\n#include <kernel/panic.h>\n#include <kernel/tee_misc.h>\n#include <mm/core_memprot.h>\n#include <mm/core_mmu.h>\n#include <mm/mobj.h>\n#include <optee_msg.h>\n#include <sm/optee_smc.h>\n#include <string.h>\n#include <tee/entry_std.h>\n#include <tee/tee_cryp_utl.h>\n#include <tee/uuid.h>\n#include <util.h>\n\n#define SHM_CACHE_ATTRS\t\\\n\t(uint32_t)(core_mmu_is_shm_cached() ?  OPTEE_SMC_SHM_CACHED : 0)\n\n/* Sessions opened from normal world */\nstatic struct tee_ta_session_head tee_open_sessions =\nTAILQ_HEAD_INITIALIZER(tee_open_sessions);\n\nstatic struct mobj *shm_mobj;\n#ifdef CFG_SECURE_DATA_PATH\nstatic struct mobj **sdp_mem_mobjs;\n#endif\n\nstatic unsigned int session_pnum;\n\nstatic bool param_mem_from_mobj(struct param_mem *mem, struct mobj *mobj,\n\t\t\t\tconst paddr_t pa, const size_t sz)\n{\n\tpaddr_t b;\n\n\tif (mobj_get_pa(mobj, 0, 0, &b) != TEE_SUCCESS)\n\t\tpanic(\"mobj_get_pa failed\");\n\n\tif (!core_is_buffer_inside(pa, MAX(sz, 1UL), b, mobj->size))\n\t\treturn false;\n\n\tmem->mobj = mobj;\n\tmem->offs = pa - b;\n\tmem->size = sz;\n\treturn true;\n}\n\n/* fill 'struct param_mem' structure if buffer matches a valid memory object */\nstatic TEE_Result set_tmem_param(const struct optee_msg_param_tmem *tmem,\n\t\t\t\t uint32_t attr, struct param_mem *mem)\n{\n\tstruct mobj __maybe_unused **mobj;\n\tpaddr_t pa = READ_ONCE(tmem->buf_ptr);\n\tsize_t sz = READ_ONCE(tmem->size);\n\n\t/* NULL Memory Rerefence? */\n\tif (!pa && !sz) {\n\t\tmem->mobj = NULL;\n\t\tmem->offs = 0;\n\t\tmem->size = 0;\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* Non-contigous buffer from non sec DDR? */\n\tif (attr & OPTEE_MSG_ATTR_NONCONTIG) {\n\t\tuint64_t shm_ref = READ_ONCE(tmem->shm_ref);\n\n\t\tmem->mobj = msg_param_mobj_from_noncontig(pa, sz, shm_ref,\n\t\t\t\t\t\t\t  false);\n\t\tif (!mem->mobj)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tmem->offs = 0;\n\t\tmem->size = sz;\n\t\treturn TEE_SUCCESS;\n\t}\n\n\t/* Belongs to nonsecure shared memory? */\n\tif (param_mem_from_mobj(mem, shm_mobj, pa, sz))\n\t\treturn TEE_SUCCESS;\n\n#ifdef CFG_SECURE_DATA_PATH\n\t/* Belongs to SDP memories? */\n\tfor (mobj = sdp_mem_mobjs; *mobj; mobj++)\n\t\tif (param_mem_from_mobj(mem, *mobj, pa, sz))\n\t\t\treturn TEE_SUCCESS;\n#endif\n\n\treturn TEE_ERROR_BAD_PARAMETERS;\n}\n\nstatic TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tsize_t req_size = 0;\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = READ_ONCE(rmem->size);\n\n\t/*\n\t * Check that the supplied offset and size is covered by the\n\t * previously verified MOBJ.\n\t */\n\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||\n\t    mem->mobj->size < req_size)\n\t\treturn TEE_ERROR_SECURITY;\n\n\treturn TEE_SUCCESS;\n}\n\nstatic TEE_Result copy_in_params(const struct optee_msg_param *params,\n\t\t\t\t uint32_t num_params,\n\t\t\t\t struct tee_ta_param *ta_param,\n\t\t\t\t uint64_t *saved_attr)\n{\n\tTEE_Result res;\n\tsize_t n;\n\tuint8_t pt[TEE_NUM_PARAMS] = { 0 };\n\n\tif (num_params > TEE_NUM_PARAMS)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tmemset(ta_param, 0, sizeof(*ta_param));\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tuint32_t attr;\n\n\t\tsaved_attr[n] = READ_ONCE(params[n].attr);\n\n\t\tif (saved_attr[n] & OPTEE_MSG_ATTR_META)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tattr = saved_attr[n] & OPTEE_MSG_ATTR_TYPE_MASK;\n\t\tswitch (attr) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_NONE:\n\t\t\tpt[n] = TEE_PARAM_TYPE_NONE;\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_VALUE_INOUT:\n\t\t\tpt[n] = TEE_PARAM_TYPE_VALUE_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_VALUE_INPUT;\n\t\t\tta_param->u[n].val.a = READ_ONCE(params[n].u.value.a);\n\t\t\tta_param->u[n].val.b = READ_ONCE(params[n].u.value.b);\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n\t\t\tres = set_tmem_param(&params[n].u.tmem, saved_attr[n],\n\t\t\t\t\t     &ta_param->u[n].mem);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tpt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_TMEM_INPUT;\n\t\t\tbreak;\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n\t\t\tres = set_rmem_param(&params[n].u.rmem,\n\t\t\t\t\t     &ta_param->u[n].mem);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t\tpt[n] = TEE_PARAM_TYPE_MEMREF_INPUT + attr -\n\t\t\t\tOPTEE_MSG_ATTR_TYPE_RMEM_INPUT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t}\n\t}\n\n\tta_param->types = TEE_PARAM_TYPES(pt[0], pt[1], pt[2], pt[3]);\n\n\treturn TEE_SUCCESS;\n}\n\nstatic void cleanup_shm_refs(const uint64_t *saved_attr,\n\t\t\t     struct tee_ta_param *param, uint32_t num_params)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (saved_attr[n]) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n\t\t\tif (saved_attr[n] & OPTEE_MSG_ATTR_NONCONTIG)\n\t\t\t\tmobj_free(param->u[n].mem.mobj);\n\t\t\tbreak;\n\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n\t\t\tmobj_reg_shm_put(param->u[n].mem.mobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void copy_out_param(struct tee_ta_param *ta_param, uint32_t num_params,\n\t\t\t   struct optee_msg_param *params, uint64_t *saved_attr)\n{\n\tsize_t n;\n\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (TEE_PARAM_TYPE_GET(ta_param->types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tswitch (saved_attr[n] & OPTEE_MSG_ATTR_TYPE_MASK) {\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n\t\t\t\tparams[n].u.tmem.size = ta_param->u[n].mem.size;\n\t\t\t\tbreak;\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n\t\t\t\tparams[n].u.rmem.size = ta_param->u[n].mem.size;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tparams[n].u.value.a = ta_param->u[n].val.a;\n\t\t\tparams[n].u.value.b = ta_param->u[n].val.b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/*\n * Extracts mandatory parameter for open session.\n *\n * Returns\n * false : mandatory parameter wasn't found or malformatted\n * true  : paramater found and OK\n */\nstatic TEE_Result get_open_session_meta(size_t num_params,\n\t\t\t\t\tstruct optee_msg_param *params,\n\t\t\t\t\tsize_t *num_meta, TEE_UUID *uuid,\n\t\t\t\t\tTEE_Identity *clnt_id)\n{\n\tconst uint32_t req_attr = OPTEE_MSG_ATTR_META |\n\t\t\t\t  OPTEE_MSG_ATTR_TYPE_VALUE_INPUT;\n\n\tif (num_params < 2)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (params[0].attr != req_attr || params[1].attr != req_attr)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\ttee_uuid_from_octets(uuid, (void *)&params[0].u.value);\n\tclnt_id->login = params[1].u.value.c;\n\tswitch (clnt_id->login) {\n\tcase TEE_LOGIN_PUBLIC:\n\t\tmemset(&clnt_id->uuid, 0, sizeof(clnt_id->uuid));\n\t\tbreak;\n\tcase TEE_LOGIN_USER:\n\tcase TEE_LOGIN_GROUP:\n\tcase TEE_LOGIN_APPLICATION:\n\tcase TEE_LOGIN_APPLICATION_USER:\n\tcase TEE_LOGIN_APPLICATION_GROUP:\n\t\ttee_uuid_from_octets(&clnt_id->uuid,\n\t\t\t\t     (void *)&params[1].u.value);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\t*num_meta = 2;\n\treturn TEE_SUCCESS;\n}\n\nstatic void entry_open_session(struct thread_smc_args *smc_args,\n\t\t\t       struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tTEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s = NULL;\n\tTEE_Identity clnt_id;\n\tTEE_UUID uuid;\n\tstruct tee_ta_param param;\n\tsize_t num_meta;\n\tuint64_t saved_attr[TEE_NUM_PARAMS] = { 0 };\n\n\tres = get_open_session_meta(num_params, arg->params, &num_meta, &uuid,\n\t\t\t\t    &clnt_id);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = copy_in_params(arg->params + num_meta, num_params - num_meta,\n\t\t\t     &param, saved_attr);\n\tif (res != TEE_SUCCESS)\n\t\tgoto cleanup_shm_refs;\n\n\tres = tee_ta_open_session(&err_orig, &s, &tee_open_sessions, &uuid,\n\t\t\t\t  &clnt_id, TEE_TIMEOUT_INFINITE, &param);\n\tif (res != TEE_SUCCESS)\n\t\ts = NULL;\n\tcopy_out_param(&param, num_params - num_meta, arg->params + num_meta,\n\t\t       saved_attr);\n\n\t/*\n\t * The occurrence of open/close session command is usually\n\t * un-predictable, using this property to increase randomness\n\t * of prng\n\t */\n\tplat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_SESSION,\n\t\t\t\t     &session_pnum);\n\ncleanup_shm_refs:\n\tcleanup_shm_refs(saved_attr, &param, num_params - num_meta);\n\nout:\n\tif (s)\n\t\targ->session = (vaddr_t)s;\n\telse\n\t\targ->session = 0;\n\targ->ret = res;\n\targ->ret_origin = err_orig;\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n}\n\nstatic void entry_close_session(struct thread_smc_args *smc_args,\n\t\t\tstruct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *s;\n\n\tif (num_params) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tplat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_SESSION,\n\t\t\t\t     &session_pnum);\n\n\ts = (struct tee_ta_session *)(vaddr_t)arg->session;\n\tres = tee_ta_close_session(s, &tee_open_sessions, NSAPP_IDENTITY);\nout:\n\targ->ret = res;\n\targ->ret_origin = TEE_ORIGIN_TEE;\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n}\n\nstatic void entry_invoke_command(struct thread_smc_args *smc_args,\n\t\t\t\t struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tTEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s;\n\tstruct tee_ta_param param = { 0 };\n\tuint64_t saved_attr[TEE_NUM_PARAMS] = { 0 };\n\n\tbm_timestamp();\n\n\tres = copy_in_params(arg->params, num_params, &param, saved_attr);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\ts = tee_ta_get_session(arg->session, true, &tee_open_sessions);\n\tif (!s) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tres = tee_ta_invoke_command(&err_orig, s, NSAPP_IDENTITY,\n\t\t\t\t    TEE_TIMEOUT_INFINITE, arg->func, &param);\n\n\tbm_timestamp();\n\n\ttee_ta_put_session(s);\n\n\tcopy_out_param(&param, num_params, arg->params, saved_attr);\n\nout:\n\tcleanup_shm_refs(saved_attr, &param, num_params);\n\n\targ->ret = res;\n\targ->ret_origin = err_orig;\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n}\n\nstatic void entry_cancel(struct thread_smc_args *smc_args,\n\t\t\tstruct optee_msg_arg *arg, uint32_t num_params)\n{\n\tTEE_Result res;\n\tTEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE;\n\tstruct tee_ta_session *s;\n\n\tif (num_params) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\ts = tee_ta_get_session(arg->session, false, &tee_open_sessions);\n\tif (!s) {\n\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tgoto out;\n\t}\n\n\tres = tee_ta_cancel_command(&err_orig, s, NSAPP_IDENTITY);\n\ttee_ta_put_session(s);\n\nout:\n\targ->ret = res;\n\targ->ret_origin = err_orig;\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n}\n\nstatic void register_shm(struct thread_smc_args *smc_args,\n\t\t\t struct optee_msg_arg *arg, uint32_t num_params)\n{\n\targ->ret = TEE_ERROR_BAD_PARAMETERS;\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n\n\tif (num_params != 1 ||\n\t    (arg->params[0].attr !=\n\t     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))\n\t\treturn;\n\n\tstruct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;\n\tstruct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,\n\t\t\t\t\t\t\t  tmem->size,\n\t\t\t\t\t\t\t  tmem->shm_ref, false);\n\n\tif (!mobj)\n\t\treturn;\n\n\tmobj_reg_shm_unguard(mobj);\n\targ->ret = TEE_SUCCESS;\n}\n\nstatic void unregister_shm(struct thread_smc_args *smc_args,\n\t\t\t   struct optee_msg_arg *arg, uint32_t num_params)\n{\n\tif (num_params == 1) {\n\t\tuint64_t cookie = arg->params[0].u.rmem.shm_ref;\n\t\tTEE_Result res = mobj_reg_shm_release_by_cookie(cookie);\n\n\t\tif (res)\n\t\t\tEMSG(\"Can't find mapping with given cookie\");\n\t\targ->ret = res;\n\t} else {\n\t\targ->ret = TEE_ERROR_BAD_PARAMETERS;\n\t\targ->ret_origin = TEE_ORIGIN_TEE;\n\t}\n\n\tsmc_args->a0 = OPTEE_SMC_RETURN_OK;\n}\n\nstatic struct mobj *map_cmd_buffer(paddr_t parg, uint32_t *num_params)\n{\n\tstruct mobj *mobj;\n\tstruct optee_msg_arg *arg;\n\tsize_t args_size;\n\n\tassert(!(parg & SMALL_PAGE_MASK));\n\t/* mobj_mapped_shm_alloc checks if parg resides in nonsec ddr */\n\tmobj = mobj_mapped_shm_alloc(&parg, 1, 0, 0);\n\tif (!mobj)\n\t\treturn NULL;\n\n\targ = mobj_get_va(mobj, 0);\n\tif (!arg) {\n\t\tmobj_free(mobj);\n\t\treturn NULL;\n\t}\n\n\t*num_params = READ_ONCE(arg->num_params);\n\targs_size = OPTEE_MSG_GET_ARG_SIZE(*num_params);\n\tif (args_size > SMALL_PAGE_SIZE) {\n\t\tEMSG(\"Command buffer spans across page boundary\");\n\t\tmobj_free(mobj);\n\t\treturn NULL;\n\t}\n\n\treturn mobj;\n}\n\nstatic struct mobj *get_cmd_buffer(paddr_t parg, uint32_t *num_params)\n{\n\tstruct optee_msg_arg *arg;\n\tsize_t args_size;\n\n\targ = phys_to_virt(parg, MEM_AREA_NSEC_SHM);\n\tif (!arg)\n\t\treturn NULL;\n\n\t*num_params = READ_ONCE(arg->num_params);\n\targs_size = OPTEE_MSG_GET_ARG_SIZE(*num_params);\n\n\treturn mobj_shm_alloc(parg, args_size, 0);\n}\n\n/*\n * Note: this function is weak just to make it possible to exclude it from\n * the unpaged area.\n */\nvoid __weak tee_entry_std(struct thread_smc_args *smc_args)\n{\n\tpaddr_t parg;\n\tstruct optee_msg_arg *arg = NULL;\t/* fix gcc warning */\n\tuint32_t num_params = 0;\t\t/* fix gcc warning */\n\tstruct mobj *mobj;\n\n\tif (smc_args->a0 != OPTEE_SMC_CALL_WITH_ARG) {\n\t\tEMSG(\"Unknown SMC 0x%\" PRIx64, (uint64_t)smc_args->a0);\n\t\tDMSG(\"Expected 0x%x\\n\", OPTEE_SMC_CALL_WITH_ARG);\n\t\tsmc_args->a0 = OPTEE_SMC_RETURN_EBADCMD;\n\t\treturn;\n\t}\n\tparg = (uint64_t)smc_args->a1 << 32 | smc_args->a2;\n\n\t/* Check if this region is in static shared space */\n\tif (core_pbuf_is(CORE_MEM_NSEC_SHM, parg,\n\t\t\t  sizeof(struct optee_msg_arg))) {\n\t\tmobj = get_cmd_buffer(parg, &num_params);\n\t} else {\n\t\tif (parg & SMALL_PAGE_MASK) {\n\t\t\tsmc_args->a0 = OPTEE_SMC_RETURN_EBADADDR;\n\t\t\treturn;\n\t\t}\n\t\tmobj = map_cmd_buffer(parg, &num_params);\n\t}\n\n\tif (!mobj || !ALIGNMENT_IS_OK(parg, struct optee_msg_arg)) {\n\t\tEMSG(\"Bad arg address 0x%\" PRIxPA, parg);\n\t\tsmc_args->a0 = OPTEE_SMC_RETURN_EBADADDR;\n\t\tmobj_free(mobj);\n\t\treturn;\n\t}\n\n\targ = mobj_get_va(mobj, 0);\n\tassert(arg && mobj_is_nonsec(mobj));\n\n\t/* Enable foreign interrupts for STD calls */\n\tthread_set_foreign_intr(true);\n\tswitch (arg->cmd) {\n\tcase OPTEE_MSG_CMD_OPEN_SESSION:\n\t\tentry_open_session(smc_args, arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_CLOSE_SESSION:\n\t\tentry_close_session(smc_args, arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_INVOKE_COMMAND:\n\t\tentry_invoke_command(smc_args, arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_CANCEL:\n\t\tentry_cancel(smc_args, arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_REGISTER_SHM:\n\t\tregister_shm(smc_args, arg, num_params);\n\t\tbreak;\n\tcase OPTEE_MSG_CMD_UNREGISTER_SHM:\n\t\tunregister_shm(smc_args, arg, num_params);\n\t\tbreak;\n\n\tdefault:\n\t\tEMSG(\"Unknown cmd 0x%x\\n\", arg->cmd);\n\t\tsmc_args->a0 = OPTEE_SMC_RETURN_EBADCMD;\n\t}\n\tmobj_free(mobj);\n}\n\nstatic TEE_Result default_mobj_init(void)\n{\n\tshm_mobj = mobj_phys_alloc(default_nsec_shm_paddr,\n\t\t\t\t   default_nsec_shm_size, SHM_CACHE_ATTRS,\n\t\t\t\t   CORE_MEM_NSEC_SHM);\n\tif (!shm_mobj)\n\t\tpanic(\"Failed to register shared memory\");\n\n#ifdef CFG_SECURE_DATA_PATH\n\tsdp_mem_mobjs = core_sdp_mem_create_mobjs();\n\tif (!sdp_mem_mobjs)\n\t\tpanic(\"Failed to register SDP memory\");\n#endif\n\n\treturn TEE_SUCCESS;\n}\n\ndriver_init_late(default_mobj_init);\n"], "filenames": ["core/arch/arm/tee/entry_std.c"], "buggy_code_start_loc": [103], "buggy_code_end_loc": [111], "fixing_code_start_loc": [104], "fixing_code_end_loc": [121], "type": "CWE-787", "message": "Linaro/OP-TEE OP-TEE Prior to version v3.4.0 is affected by: Boundary checks. The impact is: This could lead to corruption of any memory which the TA can access. The component is: optee_os. The fixed version is: v3.4.0.", "other": {"cve": {"id": "CVE-2019-1010292", "sourceIdentifier": "josh@bress.net", "published": "2019-07-16T14:15:11.997", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Linaro/OP-TEE OP-TEE Prior to version v3.4.0 is affected by: Boundary checks. The impact is: This could lead to corruption of any memory which the TA can access. The component is: optee_os. The fixed version is: v3.4.0."}, {"lang": "es", "value": "OP-TEE versiones anteriores a  v3.4.0 de Linaro/OP-TEE, est\u00e1 afectada por: Comprobaciones de l\u00edmites. El impacto es: Esto podr\u00eda conllevar a la corrupci\u00f3n de cualquier memoria a la que pueda acceder el TA. El componente es: optee_os. La versi\u00f3n corregida es: v3.4.0."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linaro:op-tee:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.4.0", "matchCriteriaId": "E5151242-B2AA-44C7-8271-52C991A0FF8D"}]}]}], "references": [{"url": "https://github.com/OP-TEE/optee_os/commit/e3adcf566cb278444830e7badfdcc3983e334fd1", "source": "josh@bress.net", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OP-TEE/optee_os/commit/e3adcf566cb278444830e7badfdcc3983e334fd1"}}