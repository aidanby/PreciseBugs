{"buggy_code": ["/*\n * USB HandSpring Visor, Palm m50x, and Sony Clie driver\n * (supports all of the Palm OS USB devices)\n *\n *\tCopyright (C) 1999 - 2004\n *\t    Greg Kroah-Hartman (greg@kroah.com)\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License version\n *\t2 as published by the Free Software Foundation.\n *\n * See Documentation/usb/usb-serial.txt for more information on using this\n * driver\n *\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/usb/cdc.h>\n#include \"visor.h\"\n\n/*\n * Version Information\n */\n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <greg@kroah.com>\"\n#define DRIVER_DESC \"USB HandSpring Visor / Palm OS driver\"\n\n/* function prototypes for a handspring visor */\nstatic int  visor_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void visor_close(struct usb_serial_port *port);\nstatic int  visor_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\nstatic int  visor_calc_num_ports(struct usb_serial *serial);\nstatic void visor_read_int_callback(struct urb *urb);\nstatic int  clie_3_5_startup(struct usb_serial *serial);\nstatic int  treo_attach(struct usb_serial *serial);\nstatic int clie_5_attach(struct usb_serial *serial);\nstatic int palm_os_3_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\nstatic int palm_os_4_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_VISOR_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_3_probe },\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_TREO_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_TREO600_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(GSPDA_VENDOR_ID, GSPDA_XPLORE_M68_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M500_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M505_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M515_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_I705_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M100_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M125_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M130_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_T_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TREO_650),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_Z_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_ZIRE_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_0_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_S360_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_1_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NX60_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NZ90V_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_TJ25_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(ACER_VENDOR_ID, ACER_S10_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE_INTERFACE_CLASS(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID, 0xff),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SPH_I500_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(TAPWAVE_VENDOR_ID, TAPWAVE_ZODIAC_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(GARMIN_VENDOR_ID, GARMIN_IQUE_3600_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(ACEECA_VENDOR_ID, ACEECA_MEZ1000_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_7135_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(FOSSIL_VENDOR_ID, FOSSIL_ABACUS_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\n\nstatic const struct usb_device_id clie_id_5_table[] = {\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_UX50_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\n\nstatic const struct usb_device_id clie_id_3_5_table[] = {\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_3_5_ID) },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\n\nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_VISOR_ID) },\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_TREO_ID) },\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_TREO600_ID) },\n\t{ USB_DEVICE(GSPDA_VENDOR_ID, GSPDA_XPLORE_M68_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M500_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M505_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M515_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_I705_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M100_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M125_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M130_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_T_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TREO_650) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_Z_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_ZIRE_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_3_5_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_0_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_S360_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_1_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NX60_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NZ90V_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_UX50_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_TJ25_ID) },\n\t{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID) },\n\t{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SPH_I500_ID) },\n\t{ USB_DEVICE(TAPWAVE_VENDOR_ID, TAPWAVE_ZODIAC_ID) },\n\t{ USB_DEVICE(GARMIN_VENDOR_ID, GARMIN_IQUE_3600_ID) },\n\t{ USB_DEVICE(ACEECA_VENDOR_ID, ACEECA_MEZ1000_ID) },\n\t{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_7135_ID) },\n\t{ USB_DEVICE(FOSSIL_VENDOR_ID, FOSSIL_ABACUS_ID) },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\n/* All of the device info needed for the Handspring Visor,\n   and Palm 4.0 devices */\nstatic struct usb_serial_driver handspring_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"visor\",\n\t},\n\t.description =\t\t\"Handspring Visor / Palm OS\",\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t2,\n\t.bulk_out_size =\t256,\n\t.open =\t\t\tvisor_open,\n\t.close =\t\tvisor_close,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.attach =\t\ttreo_attach,\n\t.probe =\t\tvisor_probe,\n\t.calc_num_ports =\tvisor_calc_num_ports,\n\t.read_int_callback =\tvisor_read_int_callback,\n};\n\n/* All of the device info needed for the Clie UX50, TH55 Palm 5.0 devices */\nstatic struct usb_serial_driver clie_5_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"clie_5\",\n\t},\n\t.description =\t\t\"Sony Clie 5.0\",\n\t.id_table =\t\tclie_id_5_table,\n\t.num_ports =\t\t2,\n\t.bulk_out_size =\t256,\n\t.open =\t\t\tvisor_open,\n\t.close =\t\tvisor_close,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.attach =\t\tclie_5_attach,\n\t.probe =\t\tvisor_probe,\n\t.calc_num_ports =\tvisor_calc_num_ports,\n\t.read_int_callback =\tvisor_read_int_callback,\n};\n\n/* device info for the Sony Clie OS version 3.5 */\nstatic struct usb_serial_driver clie_3_5_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"clie_3.5\",\n\t},\n\t.description =\t\t\"Sony Clie 3.5\",\n\t.id_table =\t\tclie_id_3_5_table,\n\t.num_ports =\t\t1,\n\t.bulk_out_size =\t256,\n\t.open =\t\t\tvisor_open,\n\t.close =\t\tvisor_close,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.attach =\t\tclie_3_5_startup,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&handspring_device, &clie_5_device, &clie_3_5_device, NULL\n};\n\n/******************************************************************************\n * Handspring Visor specific driver functions\n ******************************************************************************/\nstatic int visor_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint result = 0;\n\n\tif (!port->read_urb) {\n\t\t/* this is needed for some brain dead Sony devices */\n\t\tdev_err(&port->dev, \"Device lied about number of ports, please use a lower one.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t/* Start reading from the device */\n\tresult = usb_serial_generic_open(tty, port);\n\tif (result)\n\t\tgoto exit;\n\n\tif (port->interrupt_in_urb) {\n\t\tdev_dbg(&port->dev, \"adding interrupt input for treo\\n\");\n\t\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\t\tif (result)\n\t\t\tdev_err(&port->dev,\n\t\t\t    \"%s - failed submitting interrupt urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t}\nexit:\n\treturn result;\n}\n\n\nstatic void visor_close(struct usb_serial_port *port)\n{\n\tunsigned char *transfer_buffer;\n\n\tusb_serial_generic_close(port);\n\tusb_kill_urb(port->interrupt_in_urb);\n\n\ttransfer_buffer = kmalloc(0x12, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn;\n\tusb_control_msg(port->serial->dev,\n\t\t\t\t\t usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t\t\t VISOR_CLOSE_NOTIFICATION, 0xc2,\n\t\t\t\t\t 0x0000, 0x0000,\n\t\t\t\t\t transfer_buffer, 0x12, 300);\n\tkfree(transfer_buffer);\n}\n\nstatic void visor_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tint status = urb->status;\n\tint result;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&port->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * This information is still unknown what it can be used for.\n\t * If anyone has an idea, please let the author know...\n\t *\n\t * Rumor has it this endpoint is used to notify when data\n\t * is ready to be read from the bulk ones.\n\t */\n\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length,\n\t\t\t      urb->transfer_buffer);\n\nexit:\n\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\t\"%s - Error %d submitting interrupt urb\\n\",\n\t\t\t\t\t\t\t__func__, result);\n}\n\nstatic int palm_os_3_probe(struct usb_serial *serial,\n\t\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct device *dev = &serial->dev->dev;\n\tstruct visor_connection_info *connection_info;\n\tunsigned char *transfer_buffer;\n\tchar *string;\n\tint retval = 0;\n\tint i;\n\tint num_ports = 0;\n\n\ttransfer_buffer = kmalloc(sizeof(*connection_info), GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\n\t/* send a get connection info request */\n\tretval = usb_control_msg(serial->dev,\n\t\t\t\t  usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  VISOR_GET_CONNECTION_INFORMATION,\n\t\t\t\t  0xc2, 0x0000, 0x0000, transfer_buffer,\n\t\t\t\t  sizeof(*connection_info), 300);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"%s - error %d getting connection information\\n\",\n\t\t\t__func__, retval);\n\t\tgoto exit;\n\t}\n\n\tif (retval == sizeof(*connection_info)) {\n\t\t\tconnection_info = (struct visor_connection_info *)\n\t\t\t\t\t\t\ttransfer_buffer;\n\n\t\tnum_ports = le16_to_cpu(connection_info->num_ports);\n\t\tfor (i = 0; i < num_ports; ++i) {\n\t\t\tswitch (\n\t\t\t   connection_info->connections[i].port_function_id) {\n\t\t\tcase VISOR_FUNCTION_GENERIC:\n\t\t\t\tstring = \"Generic\";\n\t\t\t\tbreak;\n\t\t\tcase VISOR_FUNCTION_DEBUGGER:\n\t\t\t\tstring = \"Debugger\";\n\t\t\t\tbreak;\n\t\t\tcase VISOR_FUNCTION_HOTSYNC:\n\t\t\t\tstring = \"HotSync\";\n\t\t\t\tbreak;\n\t\t\tcase VISOR_FUNCTION_CONSOLE:\n\t\t\t\tstring = \"Console\";\n\t\t\t\tbreak;\n\t\t\tcase VISOR_FUNCTION_REMOTE_FILE_SYS:\n\t\t\t\tstring = \"Remote File System\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstring = \"unknown\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_info(dev, \"%s: port %d, is for %s use\\n\",\n\t\t\t\tserial->type->description,\n\t\t\t\tconnection_info->connections[i].port, string);\n\t\t}\n\t}\n\t/*\n\t* Handle devices that report invalid stuff here.\n\t*/\n\tif (num_ports == 0 || num_ports > 2) {\n\t\tdev_warn(dev, \"%s: No valid connect info available\\n\",\n\t\t\tserial->type->description);\n\t\tnum_ports = 2;\n\t}\n\n\tdev_info(dev, \"%s: Number of ports: %d\\n\", serial->type->description,\n\t\tnum_ports);\n\n\t/*\n\t * save off our num_ports info so that we can use it in the\n\t * calc_num_ports callback\n\t */\n\tusb_set_serial_data(serial, (void *)(long)num_ports);\n\n\t/* ask for the number of bytes available, but ignore the\n\t   response as it is broken */\n\tretval = usb_control_msg(serial->dev,\n\t\t\t\t  usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  VISOR_REQUEST_BYTES_AVAILABLE,\n\t\t\t\t  0xc2, 0x0000, 0x0005, transfer_buffer,\n\t\t\t\t  0x02, 300);\n\tif (retval < 0)\n\t\tdev_err(dev, \"%s - error %d getting bytes available request\\n\",\n\t\t\t__func__, retval);\n\tretval = 0;\n\nexit:\n\tkfree(transfer_buffer);\n\n\treturn retval;\n}\n\nstatic int palm_os_4_probe(struct usb_serial *serial,\n\t\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct device *dev = &serial->dev->dev;\n\tstruct palm_ext_connection_info *connection_info;\n\tunsigned char *transfer_buffer;\n\tint retval;\n\n\ttransfer_buffer =  kmalloc(sizeof(*connection_info), GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\n\tretval = usb_control_msg(serial->dev,\n\t\t\t\t  usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  PALM_GET_EXT_CONNECTION_INFORMATION,\n\t\t\t\t  0xc2, 0x0000, 0x0000, transfer_buffer,\n\t\t\t\t  sizeof(*connection_info), 300);\n\tif (retval < 0)\n\t\tdev_err(dev, \"%s - error %d getting connection info\\n\",\n\t\t\t__func__, retval);\n\telse\n\t\tusb_serial_debug_data(dev, __func__, retval, transfer_buffer);\n\n\tkfree(transfer_buffer);\n\treturn 0;\n}\n\n\nstatic int visor_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tint retval = 0;\n\tint (*startup)(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\n\n\t/*\n\t * some Samsung Android phones in modem mode have the same ID\n\t * as SPH-I500, but they are ACM devices, so dont bind to them\n\t */\n\tif (id->idVendor == SAMSUNG_VENDOR_ID &&\n\t\tid->idProduct == SAMSUNG_SPH_I500_ID &&\n\t\tserial->dev->descriptor.bDeviceClass == USB_CLASS_COMM &&\n\t\tserial->dev->descriptor.bDeviceSubClass ==\n\t\t\tUSB_CDC_SUBCLASS_ACM)\n\t\treturn -ENODEV;\n\n\tif (serial->dev->actconfig->desc.bConfigurationValue != 1) {\n\t\tdev_err(&serial->dev->dev, \"active config #%d != 1 ??\\n\",\n\t\t\tserial->dev->actconfig->desc.bConfigurationValue);\n\t\treturn -ENODEV;\n\t}\n\n\tif (id->driver_info) {\n\t\tstartup = (void *)id->driver_info;\n\t\tretval = startup(serial, id);\n\t}\n\n\treturn retval;\n}\n\nstatic int visor_calc_num_ports(struct usb_serial *serial)\n{\n\tint num_ports = (int)(long)(usb_get_serial_data(serial));\n\n\tif (num_ports)\n\t\tusb_set_serial_data(serial, NULL);\n\n\treturn num_ports;\n}\n\nstatic int clie_3_5_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->dev->dev;\n\tint result;\n\tu8 *data;\n\n\tdata = kmalloc(1, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Note that PEG-300 series devices expect the following two calls.\n\t */\n\n\t/* get the config number */\n\tresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  USB_REQ_GET_CONFIGURATION, USB_DIR_IN,\n\t\t\t\t  0, 0, data, 1, 3000);\n\tif (result < 0) {\n\t\tdev_err(dev, \"%s: get config number failed: %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\tif (result != 1) {\n\t\tdev_err(dev, \"%s: get config number bad return length: %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tresult = -EIO;\n\t\tgoto out;\n\t}\n\n\t/* get the interface number */\n\tresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  USB_REQ_GET_INTERFACE,\n\t\t\t\t  USB_DIR_IN | USB_RECIP_INTERFACE,\n\t\t\t\t  0, 0, data, 1, 3000);\n\tif (result < 0) {\n\t\tdev_err(dev, \"%s: get interface number failed: %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\tif (result != 1) {\n\t\tdev_err(dev,\n\t\t\t\"%s: get interface number bad return length: %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tresult = -EIO;\n\t\tgoto out;\n\t}\n\n\tresult = 0;\nout:\n\tkfree(data);\n\n\treturn result;\n}\n\nstatic int treo_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *swap_port;\n\n\t/* Only do this endpoint hack for the Handspring devices with\n\t * interrupt in endpoints, which for now are the Treo devices. */\n\tif (!((le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== HANDSPRING_VENDOR_ID) ||\n\t\t(le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== KYOCERA_VENDOR_ID)) ||\n\t\t(serial->num_interrupt_in == 0))\n\t\treturn 0;\n\n\t/*\n\t* It appears that Treos and Kyoceras want to use the\n\t* 1st bulk in endpoint to communicate with the 2nd bulk out endpoint,\n\t* so let's swap the 1st and 2nd bulk in and interrupt endpoints.\n\t* Note that swapping the bulk out endpoints would break lots of\n\t* apps that want to communicate on the second port.\n\t*/\n#define COPY_PORT(dest, src)\t\t\t\t\t\t\\\n\tdo { \\\n\t\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < ARRAY_SIZE(src->read_urbs); ++i) {\t\\\n\t\t\tdest->read_urbs[i] = src->read_urbs[i];\t\t\\\n\t\t\tdest->read_urbs[i]->context = dest;\t\t\\\n\t\t\tdest->bulk_in_buffers[i] = src->bulk_in_buffers[i]; \\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tdest->read_urb = src->read_urb;\t\t\t\t\\\n\t\tdest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\\\n\t\tdest->bulk_in_buffer = src->bulk_in_buffer;\t\t\\\n\t\tdest->bulk_in_size = src->bulk_in_size;\t\t\t\\\n\t\tdest->interrupt_in_urb = src->interrupt_in_urb;\t\t\\\n\t\tdest->interrupt_in_urb->context = dest;\t\t\t\\\n\t\tdest->interrupt_in_endpointAddress = \\\n\t\t\t\t\tsrc->interrupt_in_endpointAddress;\\\n\t\tdest->interrupt_in_buffer = src->interrupt_in_buffer;\t\\\n\t} while (0);\n\n\tswap_port = kmalloc(sizeof(*swap_port), GFP_KERNEL);\n\tif (!swap_port)\n\t\treturn -ENOMEM;\n\tCOPY_PORT(swap_port, serial->port[0]);\n\tCOPY_PORT(serial->port[0], serial->port[1]);\n\tCOPY_PORT(serial->port[1], swap_port);\n\tkfree(swap_port);\n\n\treturn 0;\n}\n\nstatic int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\n\t/* TH55 registers 2 ports.\n\t   Communication in from the UX50/TH55 uses bulk_in_endpointAddress\n\t   from port 0. Communication out to the UX50/TH55 uses\n\t   bulk_out_endpointAddress from port 1\n\n\t   Lets do a quick and dirty mapping\n\t */\n\n\t/* some sanity check */\n\tif (serial->num_ports < 2)\n\t\treturn -1;\n\n\t/* port 0 now uses the modified endpoint Address */\n\tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\n\treturn 0;\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * USB HandSpring Visor, Palm m50x, and Sony Clie driver\n * (supports all of the Palm OS USB devices)\n *\n *\tCopyright (C) 1999 - 2004\n *\t    Greg Kroah-Hartman (greg@kroah.com)\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License version\n *\t2 as published by the Free Software Foundation.\n *\n * See Documentation/usb/usb-serial.txt for more information on using this\n * driver\n *\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/usb/cdc.h>\n#include \"visor.h\"\n\n/*\n * Version Information\n */\n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <greg@kroah.com>\"\n#define DRIVER_DESC \"USB HandSpring Visor / Palm OS driver\"\n\n/* function prototypes for a handspring visor */\nstatic int  visor_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void visor_close(struct usb_serial_port *port);\nstatic int  visor_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\nstatic int  visor_calc_num_ports(struct usb_serial *serial);\nstatic void visor_read_int_callback(struct urb *urb);\nstatic int  clie_3_5_startup(struct usb_serial *serial);\nstatic int  treo_attach(struct usb_serial *serial);\nstatic int clie_5_attach(struct usb_serial *serial);\nstatic int palm_os_3_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\nstatic int palm_os_4_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_VISOR_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_3_probe },\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_TREO_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_TREO600_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(GSPDA_VENDOR_ID, GSPDA_XPLORE_M68_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M500_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M505_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M515_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_I705_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M100_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M125_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M130_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_T_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TREO_650),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_Z_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_ZIRE_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_0_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_S360_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_1_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NX60_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NZ90V_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_TJ25_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(ACER_VENDOR_ID, ACER_S10_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE_INTERFACE_CLASS(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID, 0xff),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SPH_I500_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(TAPWAVE_VENDOR_ID, TAPWAVE_ZODIAC_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(GARMIN_VENDOR_ID, GARMIN_IQUE_3600_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(ACEECA_VENDOR_ID, ACEECA_MEZ1000_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_7135_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(FOSSIL_VENDOR_ID, FOSSIL_ABACUS_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\n\nstatic const struct usb_device_id clie_id_5_table[] = {\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_UX50_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\n\nstatic const struct usb_device_id clie_id_3_5_table[] = {\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_3_5_ID) },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\n\nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_VISOR_ID) },\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_TREO_ID) },\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_TREO600_ID) },\n\t{ USB_DEVICE(GSPDA_VENDOR_ID, GSPDA_XPLORE_M68_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M500_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M505_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M515_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_I705_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M100_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M125_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M130_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_T_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TREO_650) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_Z_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_ZIRE_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_3_5_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_0_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_S360_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_1_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NX60_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NZ90V_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_UX50_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_TJ25_ID) },\n\t{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID) },\n\t{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SPH_I500_ID) },\n\t{ USB_DEVICE(TAPWAVE_VENDOR_ID, TAPWAVE_ZODIAC_ID) },\n\t{ USB_DEVICE(GARMIN_VENDOR_ID, GARMIN_IQUE_3600_ID) },\n\t{ USB_DEVICE(ACEECA_VENDOR_ID, ACEECA_MEZ1000_ID) },\n\t{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_7135_ID) },\n\t{ USB_DEVICE(FOSSIL_VENDOR_ID, FOSSIL_ABACUS_ID) },\n\t{ }\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\n/* All of the device info needed for the Handspring Visor,\n   and Palm 4.0 devices */\nstatic struct usb_serial_driver handspring_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"visor\",\n\t},\n\t.description =\t\t\"Handspring Visor / Palm OS\",\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t2,\n\t.bulk_out_size =\t256,\n\t.open =\t\t\tvisor_open,\n\t.close =\t\tvisor_close,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.attach =\t\ttreo_attach,\n\t.probe =\t\tvisor_probe,\n\t.calc_num_ports =\tvisor_calc_num_ports,\n\t.read_int_callback =\tvisor_read_int_callback,\n};\n\n/* All of the device info needed for the Clie UX50, TH55 Palm 5.0 devices */\nstatic struct usb_serial_driver clie_5_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"clie_5\",\n\t},\n\t.description =\t\t\"Sony Clie 5.0\",\n\t.id_table =\t\tclie_id_5_table,\n\t.num_ports =\t\t2,\n\t.bulk_out_size =\t256,\n\t.open =\t\t\tvisor_open,\n\t.close =\t\tvisor_close,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.attach =\t\tclie_5_attach,\n\t.probe =\t\tvisor_probe,\n\t.calc_num_ports =\tvisor_calc_num_ports,\n\t.read_int_callback =\tvisor_read_int_callback,\n};\n\n/* device info for the Sony Clie OS version 3.5 */\nstatic struct usb_serial_driver clie_3_5_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"clie_3.5\",\n\t},\n\t.description =\t\t\"Sony Clie 3.5\",\n\t.id_table =\t\tclie_id_3_5_table,\n\t.num_ports =\t\t1,\n\t.bulk_out_size =\t256,\n\t.open =\t\t\tvisor_open,\n\t.close =\t\tvisor_close,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.attach =\t\tclie_3_5_startup,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&handspring_device, &clie_5_device, &clie_3_5_device, NULL\n};\n\n/******************************************************************************\n * Handspring Visor specific driver functions\n ******************************************************************************/\nstatic int visor_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint result = 0;\n\n\tif (!port->read_urb) {\n\t\t/* this is needed for some brain dead Sony devices */\n\t\tdev_err(&port->dev, \"Device lied about number of ports, please use a lower one.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t/* Start reading from the device */\n\tresult = usb_serial_generic_open(tty, port);\n\tif (result)\n\t\tgoto exit;\n\n\tif (port->interrupt_in_urb) {\n\t\tdev_dbg(&port->dev, \"adding interrupt input for treo\\n\");\n\t\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\t\tif (result)\n\t\t\tdev_err(&port->dev,\n\t\t\t    \"%s - failed submitting interrupt urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t}\nexit:\n\treturn result;\n}\n\n\nstatic void visor_close(struct usb_serial_port *port)\n{\n\tunsigned char *transfer_buffer;\n\n\tusb_serial_generic_close(port);\n\tusb_kill_urb(port->interrupt_in_urb);\n\n\ttransfer_buffer = kmalloc(0x12, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn;\n\tusb_control_msg(port->serial->dev,\n\t\t\t\t\t usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t\t\t VISOR_CLOSE_NOTIFICATION, 0xc2,\n\t\t\t\t\t 0x0000, 0x0000,\n\t\t\t\t\t transfer_buffer, 0x12, 300);\n\tkfree(transfer_buffer);\n}\n\nstatic void visor_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tint status = urb->status;\n\tint result;\n\n\tswitch (status) {\n\tcase 0:\n\t\t/* success */\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t/* this urb is terminated, clean up */\n\t\tdev_dbg(&port->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * This information is still unknown what it can be used for.\n\t * If anyone has an idea, please let the author know...\n\t *\n\t * Rumor has it this endpoint is used to notify when data\n\t * is ready to be read from the bulk ones.\n\t */\n\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length,\n\t\t\t      urb->transfer_buffer);\n\nexit:\n\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\t\"%s - Error %d submitting interrupt urb\\n\",\n\t\t\t\t\t\t\t__func__, result);\n}\n\nstatic int palm_os_3_probe(struct usb_serial *serial,\n\t\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct device *dev = &serial->dev->dev;\n\tstruct visor_connection_info *connection_info;\n\tunsigned char *transfer_buffer;\n\tchar *string;\n\tint retval = 0;\n\tint i;\n\tint num_ports = 0;\n\n\ttransfer_buffer = kmalloc(sizeof(*connection_info), GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\n\t/* send a get connection info request */\n\tretval = usb_control_msg(serial->dev,\n\t\t\t\t  usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  VISOR_GET_CONNECTION_INFORMATION,\n\t\t\t\t  0xc2, 0x0000, 0x0000, transfer_buffer,\n\t\t\t\t  sizeof(*connection_info), 300);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"%s - error %d getting connection information\\n\",\n\t\t\t__func__, retval);\n\t\tgoto exit;\n\t}\n\n\tif (retval == sizeof(*connection_info)) {\n\t\t\tconnection_info = (struct visor_connection_info *)\n\t\t\t\t\t\t\ttransfer_buffer;\n\n\t\tnum_ports = le16_to_cpu(connection_info->num_ports);\n\t\tfor (i = 0; i < num_ports; ++i) {\n\t\t\tswitch (\n\t\t\t   connection_info->connections[i].port_function_id) {\n\t\t\tcase VISOR_FUNCTION_GENERIC:\n\t\t\t\tstring = \"Generic\";\n\t\t\t\tbreak;\n\t\t\tcase VISOR_FUNCTION_DEBUGGER:\n\t\t\t\tstring = \"Debugger\";\n\t\t\t\tbreak;\n\t\t\tcase VISOR_FUNCTION_HOTSYNC:\n\t\t\t\tstring = \"HotSync\";\n\t\t\t\tbreak;\n\t\t\tcase VISOR_FUNCTION_CONSOLE:\n\t\t\t\tstring = \"Console\";\n\t\t\t\tbreak;\n\t\t\tcase VISOR_FUNCTION_REMOTE_FILE_SYS:\n\t\t\t\tstring = \"Remote File System\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstring = \"unknown\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_info(dev, \"%s: port %d, is for %s use\\n\",\n\t\t\t\tserial->type->description,\n\t\t\t\tconnection_info->connections[i].port, string);\n\t\t}\n\t}\n\t/*\n\t* Handle devices that report invalid stuff here.\n\t*/\n\tif (num_ports == 0 || num_ports > 2) {\n\t\tdev_warn(dev, \"%s: No valid connect info available\\n\",\n\t\t\tserial->type->description);\n\t\tnum_ports = 2;\n\t}\n\n\tdev_info(dev, \"%s: Number of ports: %d\\n\", serial->type->description,\n\t\tnum_ports);\n\n\t/*\n\t * save off our num_ports info so that we can use it in the\n\t * calc_num_ports callback\n\t */\n\tusb_set_serial_data(serial, (void *)(long)num_ports);\n\n\t/* ask for the number of bytes available, but ignore the\n\t   response as it is broken */\n\tretval = usb_control_msg(serial->dev,\n\t\t\t\t  usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  VISOR_REQUEST_BYTES_AVAILABLE,\n\t\t\t\t  0xc2, 0x0000, 0x0005, transfer_buffer,\n\t\t\t\t  0x02, 300);\n\tif (retval < 0)\n\t\tdev_err(dev, \"%s - error %d getting bytes available request\\n\",\n\t\t\t__func__, retval);\n\tretval = 0;\n\nexit:\n\tkfree(transfer_buffer);\n\n\treturn retval;\n}\n\nstatic int palm_os_4_probe(struct usb_serial *serial,\n\t\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct device *dev = &serial->dev->dev;\n\tstruct palm_ext_connection_info *connection_info;\n\tunsigned char *transfer_buffer;\n\tint retval;\n\n\ttransfer_buffer =  kmalloc(sizeof(*connection_info), GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\n\tretval = usb_control_msg(serial->dev,\n\t\t\t\t  usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  PALM_GET_EXT_CONNECTION_INFORMATION,\n\t\t\t\t  0xc2, 0x0000, 0x0000, transfer_buffer,\n\t\t\t\t  sizeof(*connection_info), 300);\n\tif (retval < 0)\n\t\tdev_err(dev, \"%s - error %d getting connection info\\n\",\n\t\t\t__func__, retval);\n\telse\n\t\tusb_serial_debug_data(dev, __func__, retval, transfer_buffer);\n\n\tkfree(transfer_buffer);\n\treturn 0;\n}\n\n\nstatic int visor_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tint retval = 0;\n\tint (*startup)(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\n\n\t/*\n\t * some Samsung Android phones in modem mode have the same ID\n\t * as SPH-I500, but they are ACM devices, so dont bind to them\n\t */\n\tif (id->idVendor == SAMSUNG_VENDOR_ID &&\n\t\tid->idProduct == SAMSUNG_SPH_I500_ID &&\n\t\tserial->dev->descriptor.bDeviceClass == USB_CLASS_COMM &&\n\t\tserial->dev->descriptor.bDeviceSubClass ==\n\t\t\tUSB_CDC_SUBCLASS_ACM)\n\t\treturn -ENODEV;\n\n\tif (serial->dev->actconfig->desc.bConfigurationValue != 1) {\n\t\tdev_err(&serial->dev->dev, \"active config #%d != 1 ??\\n\",\n\t\t\tserial->dev->actconfig->desc.bConfigurationValue);\n\t\treturn -ENODEV;\n\t}\n\n\tif (id->driver_info) {\n\t\tstartup = (void *)id->driver_info;\n\t\tretval = startup(serial, id);\n\t}\n\n\treturn retval;\n}\n\nstatic int visor_calc_num_ports(struct usb_serial *serial)\n{\n\tint num_ports = (int)(long)(usb_get_serial_data(serial));\n\n\tif (num_ports)\n\t\tusb_set_serial_data(serial, NULL);\n\n\treturn num_ports;\n}\n\nstatic int clie_3_5_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->dev->dev;\n\tint result;\n\tu8 *data;\n\n\tdata = kmalloc(1, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Note that PEG-300 series devices expect the following two calls.\n\t */\n\n\t/* get the config number */\n\tresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  USB_REQ_GET_CONFIGURATION, USB_DIR_IN,\n\t\t\t\t  0, 0, data, 1, 3000);\n\tif (result < 0) {\n\t\tdev_err(dev, \"%s: get config number failed: %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\tif (result != 1) {\n\t\tdev_err(dev, \"%s: get config number bad return length: %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tresult = -EIO;\n\t\tgoto out;\n\t}\n\n\t/* get the interface number */\n\tresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  USB_REQ_GET_INTERFACE,\n\t\t\t\t  USB_DIR_IN | USB_RECIP_INTERFACE,\n\t\t\t\t  0, 0, data, 1, 3000);\n\tif (result < 0) {\n\t\tdev_err(dev, \"%s: get interface number failed: %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\tif (result != 1) {\n\t\tdev_err(dev,\n\t\t\t\"%s: get interface number bad return length: %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tresult = -EIO;\n\t\tgoto out;\n\t}\n\n\tresult = 0;\nout:\n\tkfree(data);\n\n\treturn result;\n}\n\nstatic int treo_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *swap_port;\n\n\t/* Only do this endpoint hack for the Handspring devices with\n\t * interrupt in endpoints, which for now are the Treo devices. */\n\tif (!((le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== HANDSPRING_VENDOR_ID) ||\n\t\t(le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== KYOCERA_VENDOR_ID)) ||\n\t\t(serial->num_interrupt_in == 0))\n\t\treturn 0;\n\n\tif (serial->num_bulk_in < 2 || serial->num_interrupt_in < 2) {\n\t\tdev_err(&serial->interface->dev, \"missing endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t/*\n\t* It appears that Treos and Kyoceras want to use the\n\t* 1st bulk in endpoint to communicate with the 2nd bulk out endpoint,\n\t* so let's swap the 1st and 2nd bulk in and interrupt endpoints.\n\t* Note that swapping the bulk out endpoints would break lots of\n\t* apps that want to communicate on the second port.\n\t*/\n#define COPY_PORT(dest, src)\t\t\t\t\t\t\\\n\tdo { \\\n\t\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < ARRAY_SIZE(src->read_urbs); ++i) {\t\\\n\t\t\tdest->read_urbs[i] = src->read_urbs[i];\t\t\\\n\t\t\tdest->read_urbs[i]->context = dest;\t\t\\\n\t\t\tdest->bulk_in_buffers[i] = src->bulk_in_buffers[i]; \\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tdest->read_urb = src->read_urb;\t\t\t\t\\\n\t\tdest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\\\n\t\tdest->bulk_in_buffer = src->bulk_in_buffer;\t\t\\\n\t\tdest->bulk_in_size = src->bulk_in_size;\t\t\t\\\n\t\tdest->interrupt_in_urb = src->interrupt_in_urb;\t\t\\\n\t\tdest->interrupt_in_urb->context = dest;\t\t\t\\\n\t\tdest->interrupt_in_endpointAddress = \\\n\t\t\t\t\tsrc->interrupt_in_endpointAddress;\\\n\t\tdest->interrupt_in_buffer = src->interrupt_in_buffer;\t\\\n\t} while (0);\n\n\tswap_port = kmalloc(sizeof(*swap_port), GFP_KERNEL);\n\tif (!swap_port)\n\t\treturn -ENOMEM;\n\tCOPY_PORT(swap_port, serial->port[0]);\n\tCOPY_PORT(serial->port[0], serial->port[1]);\n\tCOPY_PORT(serial->port[1], swap_port);\n\tkfree(swap_port);\n\n\treturn 0;\n}\n\nstatic int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\n\t/* TH55 registers 2 ports.\n\t   Communication in from the UX50/TH55 uses bulk_in_endpointAddress\n\t   from port 0. Communication out to the UX50/TH55 uses\n\t   bulk_out_endpointAddress from port 1\n\n\t   Lets do a quick and dirty mapping\n\t */\n\n\t/* some sanity check */\n\tif (serial->num_ports < 2)\n\t\treturn -1;\n\n\t/* port 0 now uses the modified endpoint Address */\n\tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\n\treturn 0;\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/usb/serial/visor.c"], "buggy_code_start_loc": [546], "buggy_code_end_loc": [546], "fixing_code_start_loc": [547], "fixing_code_end_loc": [552], "type": "CWE-476", "message": "The treo_attach function in drivers/usb/serial/visor.c in the Linux kernel before 4.5 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by inserting a USB device that lacks a (1) bulk-in or (2) interrupt-in endpoint.", "other": {"cve": {"id": "CVE-2016-2782", "sourceIdentifier": "secalert@redhat.com", "published": "2016-04-27T17:59:20.960", "lastModified": "2022-01-31T18:02:24.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The treo_attach function in drivers/usb/serial/visor.c in the Linux kernel before 4.5 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) or possibly have unspecified other impact by inserting a USB device that lacks a (1) bulk-in or (2) interrupt-in endpoint."}, {"lang": "es", "value": "La funci\u00f3n treo_attach en drivers/usb/serial/visor.c en el kernel de Linux en versiones anteriores a 4.5 permite a atacantes f\u00edsicamente pr\u00f3ximos causar una denegaci\u00f3n de servicio (referencia a puntero NULL y ca\u00edda del sistema) o posiblemente tener otro impacto no especificado mediante la inserci\u00f3n de un dispositivo USB que carece de punto final en (1) bulk-in o (2) interrupt-in."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.5.0", "matchCriteriaId": "8B6177A4-8E9B-448D-A6C1-1F88863DE391"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.5.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "2BEB8150-FFE5-47FA-A056-9029F00744AA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:suse:linux_enterprise_debuginfo:11:sp2:*:*:*:*:*:*", "matchCriteriaId": "D5900A25-FDD7-4900-BF7C-F3ECCB714D2B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:suse:linux_enterprise_debuginfo:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "F892F1B0-514C-42F7-90AE-12ACDFDC1033"}, {"vulnerable": true, "criteria": "cpe:2.3:a:suse:linux_enterprise_module_for_public_cloud:12:*:*:*:*:*:*:*", "matchCriteriaId": "1B8F4626-6942-4A79-BF25-C8AD33A82034"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:12:-:*:*:*:*:*:*", "matchCriteriaId": "D2DF4815-B8CB-4AD3-B91D-2E09A8E318E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:12:sp1:*:*:*:*:*:*", "matchCriteriaId": "3A0BA503-3F96-48DA-AF47-FBA37A9D0C48"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_real_time_extension:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "99A38379-DBD3-4BF6-9A8F-95A3F553AD02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_real_time_extension:12:sp1:*:*:*:*:*:*", "matchCriteriaId": "18D823E3-E1F3-4A15-A9C7-1AB61C1B6703"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp2:*:*:ltss:*:*:*", "matchCriteriaId": "CB6476C7-03F2-4939-AB85-69AA524516D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "55C5561F-BE86-4EEA-99D4-8697F8BD9DFE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:12:-:*:*:*:*:*:*", "matchCriteriaId": "15FC9014-BD85-4382-9D04-C0703E901D7A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:12:sp1:*:*:*:*:*:*", "matchCriteriaId": "2076747F-A98E-4DD9-9B52-BF1732BCAD3D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_software_development_kit:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "D41A798E-0D69-43C7-9A63-1E5921138EAC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_software_development_kit:12:-:*:*:*:*:*:*", "matchCriteriaId": "1831D45A-EE6E-4220-8F8C-248B69520948"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_software_development_kit:12:sp1:*:*:*:*:*:*", "matchCriteriaId": "5A633996-2FD7-467C-BAA6-529E16BD06D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_workstation_extension:12:*:*:*:*:*:*:*", "matchCriteriaId": "9DFA18B6-2642-470A-A350-68947529EE5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_workstation_extension:12:sp1:*:*:*:*:*:*", "matchCriteriaId": "ED540469-C4DD-485D-9B89-6877B2A74217"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=cac9b50b0d75a1d50d6c056ff65c005f3224c8e0", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00019.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-06/msg00052.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-06/msg00054.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-06/msg00059.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-07/msg00005.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00038.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/02/28/9", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2929-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2929-2", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2930-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2930-2", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2930-3", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2932-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2948-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2948-2", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2967-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2967-2", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1312670", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/cac9b50b0d75a1d50d6c056ff65c005f3224c8e0", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/39539/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/cac9b50b0d75a1d50d6c056ff65c005f3224c8e0"}}