{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * eval.c: Expression evaluation.\n */\n#define USING_FLOAT_STUFF\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n#ifdef VMS\n# include <float.h>\n#endif\n\n#define NAMESPACE_CHAR\t(char_u *)\"abglstvw\"\n\n/*\n * When recursively copying lists and dicts we need to remember which ones we\n * have done to avoid endless recursiveness.  This unique ID is used for that.\n * The last bit is used for previous_funccal, ignored when comparing.\n */\nstatic int current_copyID = 0;\n\n/*\n * Info used by a \":for\" loop.\n */\ntypedef struct\n{\n    int\t\tfi_semicolon;\t// TRUE if ending in '; var]'\n    int\t\tfi_varcount;\t// nr of variables in the list\n    int\t\tfi_break_count;\t// nr of line breaks encountered\n    listwatch_T\tfi_lw;\t\t// keep an eye on the item used.\n    list_T\t*fi_list;\t// list being used\n    int\t\tfi_bi;\t\t// index of blob\n    blob_T\t*fi_blob;\t// blob being used\n    char_u\t*fi_string;\t// copy of string being used\n    int\t\tfi_byte_idx;\t// byte index in fi_string\n} forinfo_T;\n\nstatic int eval2(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval3(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval5(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval6(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval7(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval8(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval9(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval9_leader(typval_T *rettv, int numeric_only, char_u *start_leader, char_u **end_leaderp);\n\nstatic int free_unref_items(int copyID);\nstatic char_u *make_expanded_name(char_u *in_start, char_u *expr_start, char_u *expr_end, char_u *in_end);\n\n/*\n * Return \"n1\" divided by \"n2\", taking care of dividing by zero.\n * If \"failed\" is not NULL set it to TRUE when dividing by zero fails.\n */\n\tvarnumber_T\nnum_divide(varnumber_T n1, varnumber_T n2, int *failed)\n{\n    varnumber_T\tresult;\n\n    if (n2 == 0)\n    {\n\tif (in_vim9script())\n\t{\n\t    emsg(_(e_divide_by_zero));\n\t    if (failed != NULL)\n\t\t*failed = TRUE;\n\t}\n\tif (n1 == 0)\n\t    result = VARNUM_MIN; // similar to NaN\n\telse if (n1 < 0)\n\t    result = -VARNUM_MAX;\n\telse\n\t    result = VARNUM_MAX;\n    }\n    else\n\tresult = n1 / n2;\n\n    return result;\n}\n\n/*\n * Return \"n1\" modulus \"n2\", taking care of dividing by zero.\n * If \"failed\" is not NULL set it to TRUE when dividing by zero fails.\n */\n\tvarnumber_T\nnum_modulus(varnumber_T n1, varnumber_T n2, int *failed)\n{\n    if (n2 == 0 && in_vim9script())\n    {\n\temsg(_(e_divide_by_zero));\n\tif (failed != NULL)\n\t    *failed = TRUE;\n    }\n    return (n2 == 0) ? 0 : (n1 % n2);\n}\n\n/*\n * Initialize the global and v: variables.\n */\n    void\neval_init(void)\n{\n    evalvars_init();\n    func_init();\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\neval_clear(void)\n{\n    evalvars_clear();\n    free_scriptnames();  // must come after evalvars_clear().\n    free_locales();\n\n    // autoloaded script names\n    free_autoload_scriptnames();\n\n    // unreferenced lists and dicts\n    (void)garbage_collect(FALSE);\n\n    // functions not garbage collected\n    free_all_functions();\n}\n#endif\n\n    void\nfill_evalarg_from_eap(evalarg_T *evalarg, exarg_T *eap, int skip)\n{\n    init_evalarg(evalarg);\n    evalarg->eval_flags = skip ? 0 : EVAL_EVALUATE;\n    if (eap != NULL)\n    {\n\tevalarg->eval_cstack = eap->cstack;\n\tif (sourcing_a_script(eap) || eap->getline == get_list_line)\n\t{\n\t    evalarg->eval_getline = eap->getline;\n\t    evalarg->eval_cookie = eap->cookie;\n\t}\n    }\n}\n\n/*\n * Top level evaluation function, returning a boolean.\n * Sets \"error\" to TRUE if there was an error.\n * Return TRUE or FALSE.\n */\n    int\neval_to_bool(\n    char_u\t*arg,\n    int\t\t*error,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    varnumber_T\tretval = FALSE;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL)\n\t*error = TRUE;\n    else\n    {\n\t*error = FALSE;\n\tif (!skip)\n\t{\n\t    if (in_vim9script())\n\t\tretval = tv_get_bool_chk(&tv, error);\n\t    else\n\t\tretval = (tv_get_number_chk(&tv, error) != 0);\n\t    clear_tv(&tv);\n\t}\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return (int)retval;\n}\n\n/*\n * Call eval1() and give an error message if not done at a lower level.\n */\n    static int\neval1_emsg(char_u **arg, typval_T *rettv, exarg_T *eap)\n{\n    char_u\t*start = *arg;\n    int\t\tret;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n\n    ret = eval1(arg, rettv, &evalarg);\n    if (ret == FAIL)\n    {\n\t// Report the invalid expression unless the expression evaluation has\n\t// been cancelled due to an aborting error, an interrupt, or an\n\t// exception, or we already gave a more specific error.\n\t// Also check called_emsg for when using assert_fails().\n\tif (!aborting() && did_emsg == did_emsg_before\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t    semsg(_(e_invalid_expression_str), start);\n    }\n    clear_evalarg(&evalarg, eap);\n    return ret;\n}\n\n/*\n * Return whether a typval is a valid expression to pass to eval_expr_typval()\n * or eval_expr_to_bool().  An empty string returns FALSE;\n */\n    int\neval_expr_valid_arg(typval_T *tv)\n{\n    return tv->v_type != VAR_UNKNOWN\n\t    && (tv->v_type != VAR_STRING\n\t\t  || (tv->vval.v_string != NULL && *tv->vval.v_string != NUL));\n}\n\n/*\n * Evaluate an expression, which can be a function, partial or string.\n * Pass arguments \"argv[argc]\".\n * Return the result in \"rettv\" and OK or FAIL.\n */\n    int\neval_expr_typval(typval_T *expr, typval_T *argv, int argc, typval_T *rettv)\n{\n    char_u\t*s;\n    char_u\tbuf[NUMBUFLEN];\n    funcexe_T\tfuncexe;\n\n    if (expr->v_type == VAR_FUNC)\n    {\n\ts = expr->vval.v_string;\n\tif (s == NULL || *s == NUL)\n\t    return FAIL;\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_evaluate = TRUE;\n\tif (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t    return FAIL;\n    }\n    else if (expr->v_type == VAR_PARTIAL)\n    {\n\tpartial_T   *partial = expr->vval.v_partial;\n\n\tif (partial == NULL)\n\t    return FAIL;\n\n\tif (partial->pt_func != NULL\n\t\t\t  && partial->pt_func->uf_def_status != UF_NOT_COMPILED)\n\t{\n\t    if (call_def_function(partial->pt_func, argc, argv,\n\t\t\t\t\t\t       partial, rettv) == FAIL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    s = partial_name(partial);\n\t    if (s == NULL || *s == NUL)\n\t\treturn FAIL;\n\t    CLEAR_FIELD(funcexe);\n\t    funcexe.fe_evaluate = TRUE;\n\t    funcexe.fe_partial = partial;\n\t    if (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    else if (expr->v_type == VAR_INSTR)\n    {\n\treturn exe_typval_instr(expr, rettv);\n    }\n    else\n    {\n\ts = tv_get_string_buf_chk_strict(expr, buf, in_vim9script());\n\tif (s == NULL)\n\t    return FAIL;\n\ts = skipwhite(s);\n\tif (eval1_emsg(&s, rettv, NULL) == FAIL)\n\t    return FAIL;\n\tif (*skipwhite(s) != NUL)  // check for trailing chars after expr\n\t{\n\t    clear_tv(rettv);\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Like eval_to_bool() but using a typval_T instead of a string.\n * Works for string, funcref and partial.\n */\n    int\neval_expr_to_bool(typval_T *expr, int *error)\n{\n    typval_T\trettv;\n    int\t\tres;\n\n    if (eval_expr_typval(expr, NULL, 0, &rettv) == FAIL)\n    {\n\t*error = TRUE;\n\treturn FALSE;\n    }\n    res = (tv_get_bool_chk(&rettv, error) != 0);\n    clear_tv(&rettv);\n    return res;\n}\n\n/*\n * Top level evaluation function, returning a string.  If \"skip\" is TRUE,\n * only parsing to \"nextcmd\" is done, without reporting errors.  Return\n * pointer to allocated memory, or NULL for failure or when \"skip\" is TRUE.\n */\n    char_u *\neval_to_string_skip(\n    char_u\t*arg,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL || skip)\n\tretval = NULL;\n    else\n    {\n\tretval = vim_strsave(tv_get_string(&tv));\n\tclear_tv(&tv);\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return retval;\n}\n\n/*\n * Skip over an expression at \"*pp\".\n * Return FAIL for an error, OK otherwise.\n */\n    int\nskip_expr(char_u **pp, evalarg_T *evalarg)\n{\n    typval_T\trettv;\n\n    *pp = skipwhite(*pp);\n    return eval1(pp, &rettv, evalarg);\n}\n\n/*\n * Skip over an expression at \"*arg\".\n * If in Vim9 script and line breaks are encountered, the lines are\n * concatenated.  \"evalarg->eval_tofree\" will be set accordingly.\n * \"arg\" is advanced to just after the expression.\n * \"start\" is set to the start of the expression, \"end\" to just after the end.\n * Also when the expression is copied to allocated memory.\n * Return FAIL for an error, OK otherwise.\n */\n    int\nskip_expr_concatenate(\n\tchar_u\t    **arg,\n\tchar_u\t    **start,\n\tchar_u\t    **end,\n\tevalarg_T   *evalarg)\n{\n    typval_T\trettv;\n    int\t\tres;\n    int\t\tvim9script = in_vim9script();\n    garray_T    *gap = evalarg == NULL ? NULL : &evalarg->eval_ga;\n    garray_T    *freegap = evalarg == NULL ? NULL : &evalarg->eval_freega;\n    int\t\tsave_flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tevaluate = evalarg == NULL\n\t\t\t       ? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    if (vim9script && evaluate\n\t       && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tga_init2(gap, sizeof(char_u *), 10);\n\t// leave room for \"start\"\n\tif (ga_grow(gap, 1) == OK)\n\t    ++gap->ga_len;\n\tga_init2(freegap, sizeof(char_u *), 10);\n    }\n    *start = *arg;\n\n    // Don't evaluate the expression.\n    if (evalarg != NULL)\n\tevalarg->eval_flags &= ~EVAL_EVALUATE;\n    *arg = skipwhite(*arg);\n    res = eval1(arg, &rettv, evalarg);\n    *end = *arg;\n    if (evalarg != NULL)\n\tevalarg->eval_flags = save_flags;\n\n    if (vim9script && evaluate\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tif (evalarg->eval_ga.ga_len == 1)\n\t{\n\t    // just the one line, no need to concatenate\n\t    ga_clear(gap);\n\t    gap->ga_itemsize = 0;\n\t}\n\telse\n\t{\n\t    char_u\t    *p;\n\t    size_t\t    endoff = STRLEN(*arg);\n\n\t    // Line breaks encountered, concatenate all the lines.\n\t    *((char_u **)gap->ga_data) = *start;\n\t    p = ga_concat_strings(gap, \" \");\n\n\t    // free the lines only when using getsourceline()\n\t    if (evalarg->eval_cookie != NULL)\n\t    {\n\t\t// Do not free the first line, the caller can still use it.\n\t\t*((char_u **)gap->ga_data) = NULL;\n\t\t// Do not free the last line, \"arg\" points into it, free it\n\t\t// later.\n\t\tvim_free(evalarg->eval_tofree);\n\t\tevalarg->eval_tofree =\n\t\t\t\t    ((char_u **)gap->ga_data)[gap->ga_len - 1];\n\t\t((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;\n\t\tga_clear_strings(gap);\n\t    }\n\t    else\n\t    {\n\t\tga_clear(gap);\n\n\t\t// free lines that were explicitly marked for freeing\n\t\tga_clear_strings(freegap);\n\t    }\n\n\t    gap->ga_itemsize = 0;\n\t    if (p == NULL)\n\t\treturn FAIL;\n\t    *start = p;\n\t    vim_free(evalarg->eval_tofree_lambda);\n\t    evalarg->eval_tofree_lambda = p;\n\t    // Compute \"end\" relative to the end.\n\t    *end = *start + STRLEN(*start) - endoff;\n\t}\n    }\n\n    return res;\n}\n\n/*\n * Convert \"tv\" to a string.\n * When \"convert\" is TRUE convert a List into a sequence of lines and convert\n * a Float to a String.\n * Returns an allocated string (NULL when out of memory).\n */\n    char_u *\ntypval2string(typval_T *tv, int convert)\n{\n    garray_T\tga;\n    char_u\t*retval;\n#ifdef FEAT_FLOAT\n    char_u\tnumbuf[NUMBUFLEN];\n#endif\n\n    if (convert && tv->v_type == VAR_LIST)\n    {\n\tga_init2(&ga, sizeof(char), 80);\n\tif (tv->vval.v_list != NULL)\n\t{\n\t    list_join(&ga, tv->vval.v_list, (char_u *)\"\\n\", TRUE, FALSE, 0);\n\t    if (tv->vval.v_list->lv_len > 0)\n\t\tga_append(&ga, NL);\n\t}\n\tga_append(&ga, NUL);\n\tretval = (char_u *)ga.ga_data;\n    }\n#ifdef FEAT_FLOAT\n    else if (convert && tv->v_type == VAR_FLOAT)\n    {\n\tvim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);\n\tretval = vim_strsave(numbuf);\n    }\n#endif\n    else\n\tretval = vim_strsave(tv_get_string(tv));\n    return retval;\n}\n\n/*\n * Top level evaluation function, returning a string.  Does not handle line\n * breaks.\n * When \"convert\" is TRUE convert a List into a sequence of lines and convert\n * a Float to a String.\n * Return pointer to allocated memory, or NULL for failure.\n */\n    char_u *\neval_to_string_eap(\n    char_u\t*arg,\n    int\t\tconvert,\n    exarg_T\t*eap)\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n    if (eval0(arg, &tv, NULL, &evalarg) == FAIL)\n\tretval = NULL;\n    else\n    {\n\tretval = typval2string(&tv, convert);\n\tclear_tv(&tv);\n    }\n    clear_evalarg(&evalarg, NULL);\n\n    return retval;\n}\n\n    char_u *\neval_to_string(\n    char_u\t*arg,\n    int\t\tconvert)\n{\n    return eval_to_string_eap(arg, convert, NULL);\n}\n\n/*\n * Call eval_to_string() without using current local variables and using\n * textlock.  When \"use_sandbox\" is TRUE use the sandbox.\n * Use legacy Vim script syntax.\n */\n    char_u *\neval_to_string_safe(\n    char_u\t*arg,\n    int\t\tuse_sandbox,\n    int\t\tkeep_script_version)\n{\n    char_u\t*retval;\n    funccal_entry_T funccal_entry;\n    int\t\tsave_sc_version = current_sctx.sc_version;\n    int\t\tsave_garbage = may_garbage_collect;\n\n    if (!keep_script_version)\n\tcurrent_sctx.sc_version = 1;\n    save_funccal(&funccal_entry);\n    if (use_sandbox)\n\t++sandbox;\n    ++textlock;\n    may_garbage_collect = FALSE;\n    retval = eval_to_string(arg, FALSE);\n    if (use_sandbox)\n\t--sandbox;\n    --textlock;\n    may_garbage_collect = save_garbage;\n    restore_funccal();\n    current_sctx.sc_version = save_sc_version;\n    return retval;\n}\n\n/*\n * Top level evaluation function, returning a number.\n * Evaluates \"expr\" silently.\n * Returns -1 for an error.\n */\n    varnumber_T\neval_to_number(char_u *expr)\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n    char_u\t*p = skipwhite(expr);\n\n    ++emsg_off;\n\n    if (eval1(&p, &rettv, &EVALARG_EVALUATE) == FAIL)\n\tretval = -1;\n    else\n    {\n\tretval = tv_get_number_chk(&rettv, NULL);\n\tclear_tv(&rettv);\n    }\n    --emsg_off;\n\n    return retval;\n}\n\n/*\n * Top level evaluation function.\n * Returns an allocated typval_T with the result.\n * Returns NULL when there is an error.\n */\n    typval_T *\neval_expr(char_u *arg, exarg_T *eap)\n{\n    typval_T\t*tv;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n\n    tv = ALLOC_ONE(typval_T);\n    if (tv != NULL && eval0(arg, tv, eap, &evalarg) == FAIL)\n\tVIM_CLEAR(tv);\n\n    clear_evalarg(&evalarg, eap);\n    return tv;\n}\n\n/*\n * \"*arg\" points to what can be a function name in the form of \"import.Name\" or\n * \"Funcref\".  Return the name of the function.  Set \"tofree\" to something that\n * was allocated.\n * If \"verbose\" is FALSE no errors are given.\n * Return NULL for any failure.\n */\n    static char_u *\nderef_function_name(\n\t    char_u\t**arg,\n\t    char_u\t**tofree,\n\t    evalarg_T\t*evalarg,\n\t    int\t\tverbose)\n{\n    typval_T\tref;\n    char_u\t*name = *arg;\n\n    ref.v_type = VAR_UNKNOWN;\n    if (eval9(arg, &ref, evalarg, FALSE) == FAIL)\n    {\n\tdictitem_T\t*v;\n\n\t// If <SID>VarName was used it would not be found, try another way.\n\tv = find_var_also_in_script(name, NULL, FALSE);\n\tif (v == NULL)\n\t    return NULL;\n\tcopy_tv(&v->di_tv, &ref);\n    }\n    if (*skipwhite(*arg) != NUL)\n    {\n\tif (verbose)\n\t    semsg(_(e_trailing_characters_str), *arg);\n\tname = NULL;\n    }\n    else if (ref.v_type == VAR_FUNC && ref.vval.v_string != NULL)\n    {\n\tname = ref.vval.v_string;\n\tref.vval.v_string = NULL;\n\t*tofree = name;\n    }\n    else if (ref.v_type == VAR_PARTIAL && ref.vval.v_partial != NULL)\n    {\n\tif (ref.vval.v_partial->pt_argc > 0\n\t\t|| ref.vval.v_partial->pt_dict != NULL)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_use_partial_here));\n\t    name = NULL;\n\t}\n\telse\n\t{\n\t    name = vim_strsave(partial_name(ref.vval.v_partial));\n\t    *tofree = name;\n\t}\n    }\n    else\n    {\n\tif (verbose)\n\t    semsg(_(e_not_callable_type_str), name);\n\tname = NULL;\n    }\n    clear_tv(&ref);\n    return name;\n}\n\n/*\n * Call some Vim script function and return the result in \"*rettv\".\n * Uses argv[0] to argv[argc - 1] for the function arguments.  argv[argc]\n * should have type VAR_UNKNOWN.\n * Returns OK or FAIL.\n */\n    int\ncall_vim_function(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv,\n    typval_T\t*rettv)\n{\n    int\t\tret;\n    funcexe_T\tfuncexe;\n    char_u\t*arg;\n    char_u\t*name;\n    char_u\t*tofree = NULL;\n    int\t\tignore_errors;\n\n    rettv->v_type = VAR_UNKNOWN;\t\t// clear_tv() uses this\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_firstline = curwin->w_cursor.lnum;\n    funcexe.fe_lastline = curwin->w_cursor.lnum;\n    funcexe.fe_evaluate = TRUE;\n\n    // The name might be \"import.Func\" or \"Funcref\".  We don't know, we need to\n    // ignore errors for an undefined name.  But we do want errors when an\n    // autoload script has errors.  Guess that when there is a dot in the name\n    // showing errors is the right choice.\n    ignore_errors = vim_strchr(func, '.') == NULL;\n    arg = func;\n    if (ignore_errors)\n\t++emsg_off;\n    name = deref_function_name(&arg, &tofree, &EVALARG_EVALUATE, FALSE);\n    if (ignore_errors)\n\t--emsg_off;\n    if (name == NULL)\n\tname = func;\n\n    ret = call_func(name, -1, rettv, argc, argv, &funcexe);\n\n    if (ret == FAIL)\n\tclear_tv(rettv);\n    vim_free(tofree);\n\n    return ret;\n}\n\n/*\n * Call Vim script function \"func\" and return the result as a string.\n * Uses \"argv[0]\" to \"argv[argc - 1]\" for the function arguments. \"argv[argc]\"\n * should have type VAR_UNKNOWN.\n * Returns NULL when calling the function fails.\n */\n    void *\ncall_func_retstr(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv)\n{\n    typval_T\trettv;\n    char_u\t*retval;\n\n    if (call_vim_function(func, argc, argv, &rettv) == FAIL)\n\treturn NULL;\n\n    retval = vim_strsave(tv_get_string(&rettv));\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Call Vim script function \"func\" and return the result as a List.\n * Uses \"argv\" and \"argc\" as call_func_retstr().\n * Returns NULL when there is something wrong.\n */\n    void *\ncall_func_retlist(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv)\n{\n    typval_T\trettv;\n\n    if (call_vim_function(func, argc, argv, &rettv) == FAIL)\n\treturn NULL;\n\n    if (rettv.v_type != VAR_LIST)\n    {\n\tclear_tv(&rettv);\n\treturn NULL;\n    }\n\n    return rettv.vval.v_list;\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Evaluate \"arg\", which is 'foldexpr'.\n * Note: caller must set \"curwin\" to match \"arg\".\n * Returns the foldlevel, and any character preceding it in \"*cp\".  Doesn't\n * give error messages.\n */\n    int\neval_foldexpr(win_T *wp, int *cp)\n{\n    char_u\t*arg;\n    typval_T\ttv;\n    varnumber_T\tretval;\n    char_u\t*s;\n    sctx_T\tsaved_sctx = current_sctx;\n    int\t\tuse_sandbox = was_set_insecurely((char_u *)\"foldexpr\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n\n    arg = wp->w_p_fde;\n    current_sctx = wp->w_p_script_ctx[WV_FDE];\n\n    ++emsg_off;\n    if (use_sandbox)\n\t++sandbox;\n    ++textlock;\n    *cp = NUL;\n    if (eval0(arg, &tv, NULL, &EVALARG_EVALUATE) == FAIL)\n\tretval = 0;\n    else\n    {\n\t// If the result is a number, just return the number.\n\tif (tv.v_type == VAR_NUMBER)\n\t    retval = tv.vval.v_number;\n\telse if (tv.v_type != VAR_STRING || tv.vval.v_string == NULL)\n\t    retval = 0;\n\telse\n\t{\n\t    // If the result is a string, check if there is a non-digit before\n\t    // the number.\n\t    s = tv.vval.v_string;\n\t    if (!VIM_ISDIGIT(*s) && *s != '-')\n\t\t*cp = *s++;\n\t    retval = atol((char *)s);\n\t}\n\tclear_tv(&tv);\n    }\n    --emsg_off;\n    if (use_sandbox)\n\t--sandbox;\n    --textlock;\n    clear_evalarg(&EVALARG_EVALUATE, NULL);\n    current_sctx = saved_sctx;\n\n    return (int)retval;\n}\n#endif\n\n/*\n * Get an lval: variable, Dict item or List item that can be assigned a value\n * to: \"name\", \"na{me}\", \"name[expr]\", \"name[expr:expr]\", \"name[expr][expr]\",\n * \"name.key\", \"name.key[expr]\" etc.\n * Indexing only works if \"name\" is an existing List or Dictionary.\n * \"name\" points to the start of the name.\n * If \"rettv\" is not NULL it points to the value to be assigned.\n * \"unlet\" is TRUE for \":unlet\": slightly different behavior when something is\n * wrong; must end in space or cmd separator.\n *\n * flags:\n *  GLV_QUIET:       do not give error messages\n *  GLV_READ_ONLY:   will not change the variable\n *  GLV_NO_AUTOLOAD: do not use script autoloading\n *\n * Returns a pointer to just after the name, including indexes.\n * When an evaluation error occurs \"lp->ll_name\" is NULL;\n * Returns NULL for a parsing error.  Still need to free items in \"lp\"!\n */\n    char_u *\nget_lval(\n    char_u\t*name,\n    typval_T\t*rettv,\n    lval_T\t*lp,\n    int\t\tunlet,\n    int\t\tskip,\n    int\t\tflags,\t    // GLV_ values\n    int\t\tfne_flags)  // flags for find_name_end()\n{\n    char_u\t*p;\n    char_u\t*expr_start, *expr_end;\n    int\t\tcc;\n    dictitem_T\t*v;\n    typval_T\tvar1;\n    typval_T\tvar2;\n    int\t\tempty1 = FALSE;\n    char_u\t*key = NULL;\n    int\t\tlen;\n    hashtab_T\t*ht = NULL;\n    int\t\tquiet = flags & GLV_QUIET;\n    int\t\twriting;\n    int\t\tvim9script = in_vim9script();\n\n    // Clear everything in \"lp\".\n    CLEAR_POINTER(lp);\n\n    if (skip || (flags & GLV_COMPILING))\n    {\n\t// When skipping or compiling just find the end of the name.\n\tlp->ll_name = name;\n\tlp->ll_name_end = find_name_end(name, NULL, NULL,\n\t\t\t\t\t\t      FNE_INCL_BR | fne_flags);\n\treturn lp->ll_name_end;\n    }\n\n    // Cannot use \"s:var\" at the Vim9 script level.  \"s: type\" is OK.\n    if (vim9script && at_script_level()\n\t\t  && name[0] == 's' && name[1] == ':' && !VIM_ISWHITE(name[2]))\n    {\n\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str), name);\n\treturn NULL;\n    }\n\n    // Find the end of the name.\n    p = find_name_end(name, &expr_start, &expr_end, fne_flags);\n    lp->ll_name_end = p;\n    if (expr_start != NULL)\n    {\n\t// Don't expand the name when we already know there is an error.\n\tif (unlet && !VIM_ISWHITE(*p) && !ends_excmd(*p)\n\t\t\t\t\t\t    && *p != '[' && *p != '.')\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    return NULL;\n\t}\n\n\tlp->ll_exp_name = make_expanded_name(name, expr_start, expr_end, p);\n\tif (lp->ll_exp_name == NULL)\n\t{\n\t    // Report an invalid expression in braces, unless the\n\t    // expression evaluation has been cancelled due to an\n\t    // aborting error, an interrupt, or an exception.\n\t    if (!aborting() && !quiet)\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_invalid_argument_str), name);\n\t\treturn NULL;\n\t    }\n\t}\n\tlp->ll_name = lp->ll_exp_name;\n    }\n    else\n    {\n\tlp->ll_name = name;\n\n\tif (vim9script)\n\t{\n\t    // \"a: type\" is declaring variable \"a\" with a type, not \"a:\".\n\t    // However, \"g:[key]\" is indexing a dictionary.\n\t    if (p == name + 2 && p[-1] == ':' && *p != '[')\n\t    {\n\t\t--p;\n\t\tlp->ll_name_end = p;\n\t    }\n\t    if (*p == ':')\n\t    {\n\t\tchar_u\t    *tp = skipwhite(p + 1);\n\n\t\tif (tp == p + 1 && !quiet)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \":\", p);\n\t\t    return NULL;\n\t\t}\n\n\t\tif (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\t\t{\n\t\t    semsg(_(e_using_type_not_in_script_context_str), p);\n\t\t    return NULL;\n\t\t}\n\n\t\t// parse the type after the name\n\t\tlp->ll_type = parse_type(&tp,\n\t\t\t       &SCRIPT_ITEM(current_sctx.sc_sid)->sn_type_list,\n\t\t\t       !quiet);\n\t\tif (lp->ll_type == NULL && !quiet)\n\t\t    return NULL;\n\t\tlp->ll_name_end = tp;\n\t    }\n\t}\n    }\n    if (lp->ll_name == NULL)\n\treturn p;\n\n    if (*p == '.')\n    {\n\timported_T *import = find_imported(lp->ll_name, p - lp->ll_name, TRUE);\n\n\tif (import != NULL)\n\t{\n\t    ufunc_T *ufunc;\n\t    type_T *type;\n\n\t    lp->ll_sid = import->imp_sid;\n\t    lp->ll_name = skipwhite(p + 1);\n\t    p = find_name_end(lp->ll_name, NULL, NULL, fne_flags);\n\t    lp->ll_name_end = p;\n\n\t    // check the item is exported\n\t    cc = *p;\n\t    *p = NUL;\n\t    if (find_exported(import->imp_sid, lp->ll_name, &ufunc, &type,\n\t\t\t\t\t\t       NULL, NULL, TRUE) == -1)\n\t    {\n\t\t*p = cc;\n\t\treturn NULL;\n\t    }\n\t    *p = cc;\n\t}\n    }\n\n    // Without [idx] or .key we are done.\n    if ((*p != '[' && *p != '.'))\n\treturn p;\n\n    if (vim9script && lval_root != NULL)\n    {\n\t// using local variable\n\tlp->ll_tv = lval_root;\n\tv = NULL;\n    }\n    else\n    {\n\tcc = *p;\n\t*p = NUL;\n\t// When we would write to the variable pass &ht and prevent autoload.\n\twriting = !(flags & GLV_READ_ONLY);\n\tv = find_var(lp->ll_name, writing ? &ht : NULL,\n\t\t\t\t\t (flags & GLV_NO_AUTOLOAD) || writing);\n\tif (v == NULL && !quiet)\n\t    semsg(_(e_undefined_variable_str), lp->ll_name);\n\t*p = cc;\n\tif (v == NULL)\n\t    return NULL;\n\tlp->ll_tv = &v->di_tv;\n    }\n\n    if (vim9script && (flags & GLV_NO_DECL) == 0)\n    {\n\tif (!quiet)\n\t    semsg(_(e_variable_already_declared), lp->ll_name);\n\treturn NULL;\n    }\n\n    /*\n     * Loop until no more [idx] or .key is following.\n     */\n    var1.v_type = VAR_UNKNOWN;\n    var2.v_type = VAR_UNKNOWN;\n    while (*p == '[' || (*p == '.' && p[1] != '=' && p[1] != '.'))\n    {\n\tif (*p == '.' && lp->ll_tv->v_type != VAR_DICT)\n\t{\n\t    if (!quiet)\n\t\tsemsg(_(e_dot_can_only_be_used_on_dictionary_str), name);\n\t    return NULL;\n\t}\n\tif (lp->ll_tv->v_type != VAR_LIST\n\t\t&& lp->ll_tv->v_type != VAR_DICT\n\t\t&& lp->ll_tv->v_type != VAR_BLOB)\n\t{\n\t    if (!quiet)\n\t\temsg(_(e_can_only_index_list_dictionary_or_blob));\n\t    return NULL;\n\t}\n\n\t// a NULL list/blob works like an empty list/blob, allocate one now.\n\tif (lp->ll_tv->v_type == VAR_LIST && lp->ll_tv->vval.v_list == NULL)\n\t    rettv_list_alloc(lp->ll_tv);\n\telse if (lp->ll_tv->v_type == VAR_BLOB\n\t\t\t\t\t     && lp->ll_tv->vval.v_blob == NULL)\n\t    rettv_blob_alloc(lp->ll_tv);\n\n\tif (lp->ll_range)\n\t{\n\t    if (!quiet)\n\t\temsg(_(e_slice_must_come_last));\n\t    return NULL;\n\t}\n\n\tif (vim9script && lp->ll_valtype == NULL\n\t\t&& v != NULL\n\t\t&& lp->ll_tv == &v->di_tv\n\t\t&& ht != NULL && ht == get_script_local_ht())\n\t{\n\t    svar_T  *sv = find_typval_in_script(lp->ll_tv, 0, TRUE);\n\n\t    // Vim9 script local variable: get the type\n\t    if (sv != NULL)\n\t\tlp->ll_valtype = sv->sv_type;\n\t}\n\n\tlen = -1;\n\tif (*p == '.')\n\t{\n\t    key = p + 1;\n\t    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)\n\t\t;\n\t    if (len == 0)\n\t    {\n\t\tif (!quiet)\n\t\t    emsg(_(e_cannot_use_empty_key_for_dictionary));\n\t\treturn NULL;\n\t    }\n\t    p = key + len;\n\t}\n\telse\n\t{\n\t    // Get the index [expr] or the first index [expr: ].\n\t    p = skipwhite(p + 1);\n\t    if (*p == ':')\n\t\tempty1 = TRUE;\n\t    else\n\t    {\n\t\tempty1 = FALSE;\n\t\tif (eval1(&p, &var1, &EVALARG_EVALUATE) == FAIL)  // recursive!\n\t\t    return NULL;\n\t\tif (tv_get_string_chk(&var1) == NULL)\n\t\t{\n\t\t    // not a number or string\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\n\t    // Optionally get the second index [ :expr].\n\t    if (*p == ':')\n\t    {\n\t\tif (lp->ll_tv->v_type == VAR_DICT)\n\t\t{\n\t\t    if (!quiet)\n\t\t\temsg(_(e_cannot_slice_dictionary));\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tif (rettv != NULL\n\t\t\t&& !(rettv->v_type == VAR_LIST\n\t\t\t\t\t\t && rettv->vval.v_list != NULL)\n\t\t\t&& !(rettv->v_type == VAR_BLOB\n\t\t\t\t\t\t&& rettv->vval.v_blob != NULL))\n\t\t{\n\t\t    if (!quiet)\n\t\t\temsg(_(e_slice_requires_list_or_blob_value));\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tp = skipwhite(p + 1);\n\t\tif (*p == ']')\n\t\t    lp->ll_empty2 = TRUE;\n\t\telse\n\t\t{\n\t\t    lp->ll_empty2 = FALSE;\n\t\t    // recursive!\n\t\t    if (eval1(&p, &var2, &EVALARG_EVALUATE) == FAIL)\n\t\t    {\n\t\t\tclear_tv(&var1);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (tv_get_string_chk(&var2) == NULL)\n\t\t    {\n\t\t\t// not a number or string\n\t\t\tclear_tv(&var1);\n\t\t\tclear_tv(&var2);\n\t\t\treturn NULL;\n\t\t    }\n\t\t}\n\t\tlp->ll_range = TRUE;\n\t    }\n\t    else\n\t\tlp->ll_range = FALSE;\n\n\t    if (*p != ']')\n\t    {\n\t\tif (!quiet)\n\t\t    emsg(_(e_missing_closing_square_brace));\n\t\tclear_tv(&var1);\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\n\t    // Skip to past ']'.\n\t    ++p;\n\t}\n\n\tif (lp->ll_tv->v_type == VAR_DICT)\n\t{\n\t    if (len == -1)\n\t    {\n\t\t// \"[key]\": get key from \"var1\"\n\t\tkey = tv_get_string_chk(&var1);\t// is number or string\n\t\tif (key == NULL)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t    }\n\t    lp->ll_list = NULL;\n\n\t    // a NULL dict is equivalent with an empty dict\n\t    if (lp->ll_tv->vval.v_dict == NULL)\n\t    {\n\t\tlp->ll_tv->vval.v_dict = dict_alloc();\n\t\tif (lp->ll_tv->vval.v_dict == NULL)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\t++lp->ll_tv->vval.v_dict->dv_refcount;\n\t    }\n\t    lp->ll_dict = lp->ll_tv->vval.v_dict;\n\n\t    lp->ll_di = dict_find(lp->ll_dict, key, len);\n\n\t    // When assigning to a scope dictionary check that a function and\n\t    // variable name is valid (only variable name unless it is l: or\n\t    // g: dictionary). Disallow overwriting a builtin function.\n\t    if (rettv != NULL && lp->ll_dict->dv_scope != 0)\n\t    {\n\t\tint prevval;\n\t\tint wrong;\n\n\t\tif (len != -1)\n\t\t{\n\t\t    prevval = key[len];\n\t\t    key[len] = NUL;\n\t\t}\n\t\telse\n\t\t    prevval = 0; // avoid compiler warning\n\t\twrong = (lp->ll_dict->dv_scope == VAR_DEF_SCOPE\n\t\t\t       && rettv->v_type == VAR_FUNC\n\t\t\t       && var_wrong_func_name(key, lp->ll_di == NULL))\n\t\t\t|| !valid_varname(key, -1, TRUE);\n\t\tif (len != -1)\n\t\t    key[len] = prevval;\n\t\tif (wrong)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t    }\n\n\t    if (lp->ll_valtype != NULL)\n\t\t// use the type of the member\n\t\tlp->ll_valtype = lp->ll_valtype->tt_member;\n\n\t    if (lp->ll_di == NULL)\n\t    {\n\t\t// Can't add \"v:\" or \"a:\" variable.\n\t\tif (lp->ll_dict == get_vimvar_dict()\n\t\t\t || &lp->ll_dict->dv_hashtab == get_funccal_args_ht())\n\t\t{\n\t\t    semsg(_(e_illegal_variable_name_str), name);\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\n\t\t// Key does not exist in dict: may need to add it.\n\t\tif (*p == '[' || *p == '.' || unlet)\n\t\t{\n\t\t    if (!quiet)\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tif (len == -1)\n\t\t    lp->ll_newkey = vim_strsave(key);\n\t\telse\n\t\t    lp->ll_newkey = vim_strnsave(key, len);\n\t\tclear_tv(&var1);\n\t\tif (lp->ll_newkey == NULL)\n\t\t    p = NULL;\n\t\tbreak;\n\t    }\n\t    // existing variable, need to check if it can be changed\n\t    else if ((flags & GLV_READ_ONLY) == 0\n\t\t\t&& (var_check_ro(lp->ll_di->di_flags, name, FALSE)\n\t\t\t  || var_check_lock(lp->ll_di->di_flags, name, FALSE)))\n\t    {\n\t\tclear_tv(&var1);\n\t\treturn NULL;\n\t    }\n\n\t    clear_tv(&var1);\n\t    lp->ll_tv = &lp->ll_di->di_tv;\n\t}\n\telse if (lp->ll_tv->v_type == VAR_BLOB)\n\t{\n\t    long bloblen = blob_len(lp->ll_tv->vval.v_blob);\n\n\t    /*\n\t     * Get the number and item for the only or first index of the List.\n\t     */\n\t    if (empty1)\n\t\tlp->ll_n1 = 0;\n\t    else\n\t\t// is number or string\n\t\tlp->ll_n1 = (long)tv_get_number(&var1);\n\t    clear_tv(&var1);\n\n\t    if (check_blob_index(bloblen, lp->ll_n1, quiet) == FAIL)\n\t    {\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\t    if (lp->ll_range && !lp->ll_empty2)\n\t    {\n\t\tlp->ll_n2 = (long)tv_get_number(&var2);\n\t\tclear_tv(&var2);\n\t\tif (check_blob_range(bloblen, lp->ll_n1, lp->ll_n2, quiet)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    return NULL;\n\t    }\n\t    lp->ll_blob = lp->ll_tv->vval.v_blob;\n\t    lp->ll_tv = NULL;\n\t    break;\n\t}\n\telse\n\t{\n\t    /*\n\t     * Get the number and item for the only or first index of the List.\n\t     */\n\t    if (empty1)\n\t\tlp->ll_n1 = 0;\n\t    else\n\t\t// is number or string\n\t\tlp->ll_n1 = (long)tv_get_number(&var1);\n\t    clear_tv(&var1);\n\n\t    lp->ll_dict = NULL;\n\t    lp->ll_list = lp->ll_tv->vval.v_list;\n\t    lp->ll_li = check_range_index_one(lp->ll_list, &lp->ll_n1,\n\t\t\t\t     (flags & GLV_ASSIGN_WITH_OP) == 0, quiet);\n\t    if (lp->ll_li == NULL)\n\t    {\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\n\t    if (lp->ll_valtype != NULL)\n\t\t// use the type of the member\n\t\tlp->ll_valtype = lp->ll_valtype->tt_member;\n\n\t    /*\n\t     * May need to find the item or absolute index for the second\n\t     * index of a range.\n\t     * When no index given: \"lp->ll_empty2\" is TRUE.\n\t     * Otherwise \"lp->ll_n2\" is set to the second index.\n\t     */\n\t    if (lp->ll_range && !lp->ll_empty2)\n\t    {\n\t\tlp->ll_n2 = (long)tv_get_number(&var2);\n\t\t\t\t\t\t    // is number or string\n\t\tclear_tv(&var2);\n\t\tif (check_range_index_two(lp->ll_list,\n\t\t\t\t\t    &lp->ll_n1, lp->ll_li,\n\t\t\t\t\t    &lp->ll_n2, quiet) == FAIL)\n\t\t    return NULL;\n\t    }\n\n\t    lp->ll_tv = &lp->ll_li->li_tv;\n\t}\n    }\n\n    clear_tv(&var1);\n    lp->ll_name_end = p;\n    return p;\n}\n\n/*\n * Clear lval \"lp\" that was filled by get_lval().\n */\n    void\nclear_lval(lval_T *lp)\n{\n    vim_free(lp->ll_exp_name);\n    vim_free(lp->ll_newkey);\n}\n\n/*\n * Set a variable that was parsed by get_lval() to \"rettv\".\n * \"endp\" points to just after the parsed name.\n * \"op\" is NULL, \"+\" for \"+=\", \"-\" for \"-=\", \"*\" for \"*=\", \"/\" for \"/=\",\n * \"%\" for \"%=\", \".\" for \".=\" or \"=\" for \"=\".\n */\n    void\nset_var_lval(\n    lval_T\t*lp,\n    char_u\t*endp,\n    typval_T\t*rettv,\n    int\t\tcopy,\n    int\t\tflags,\t    // ASSIGN_CONST, ASSIGN_NO_DECL\n    char_u\t*op,\n    int\t\tvar_idx)    // index for \"let [a, b] = list\"\n{\n    int\t\tcc;\n    dictitem_T\t*di;\n\n    if (lp->ll_tv == NULL)\n    {\n\tcc = *endp;\n\t*endp = NUL;\n\tif (in_vim9script() && check_reserved_name(lp->ll_name) == FAIL)\n\t    return;\n\n\tif (lp->ll_blob != NULL)\n\t{\n\t    int\t    error = FALSE, val;\n\n\t    if (op != NULL && *op != '=')\n\t    {\n\t\tsemsg(_(e_wrong_variable_type_for_str_equal), op);\n\t\treturn;\n\t    }\n\t    if (value_check_lock(lp->ll_blob->bv_lock, lp->ll_name, FALSE))\n\t\treturn;\n\n\t    if (lp->ll_range && rettv->v_type == VAR_BLOB)\n\t    {\n\t\tif (lp->ll_empty2)\n\t\t    lp->ll_n2 = blob_len(lp->ll_blob) - 1;\n\n\t\tif (blob_set_range(lp->ll_blob, lp->ll_n1, lp->ll_n2,\n\t\t\t\t\t\t\t\trettv) == FAIL)\n\t\t    return;\n\t    }\n\t    else\n\t    {\n\t\tval = (int)tv_get_number_chk(rettv, &error);\n\t\tif (!error)\n\t\t    blob_set_append(lp->ll_blob, lp->ll_n1, val);\n\t    }\n\t}\n\telse if (op != NULL && *op != '=')\n\t{\n\t    typval_T tv;\n\n\t    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t    {\n\t\temsg(_(e_cannot_modify_existing_variable));\n\t\t*endp = cc;\n\t\treturn;\n\t    }\n\n\t    // handle +=, -=, *=, /=, %= and .=\n\t    di = NULL;\n\t    if (eval_variable(lp->ll_name, (int)STRLEN(lp->ll_name),\n\t\t\t\t lp->ll_sid, &tv, &di, EVAL_VAR_VERBOSE) == OK)\n\t    {\n\t\tif ((di == NULL\n\t\t\t || (!var_check_ro(di->di_flags, lp->ll_name, FALSE)\n\t\t\t   && !tv_check_lock(&di->di_tv, lp->ll_name, FALSE)))\n\t\t\t&& tv_op(&tv, rettv, op) == OK)\n\t\t    set_var_const(lp->ll_name, lp->ll_sid, NULL, &tv, FALSE,\n\t\t\t\t\t\t\t    ASSIGN_NO_DECL, 0);\n\t\tclear_tv(&tv);\n\t    }\n\t}\n\telse\n\t{\n\t    if (lp->ll_type != NULL && check_typval_arg_type(lp->ll_type, rettv,\n\t\t\t\t\t\t\t      NULL, 0) == FAIL)\n\t\treturn;\n\t    set_var_const(lp->ll_name, lp->ll_sid, lp->ll_type, rettv, copy,\n\t\t\t\t\t\t\t       flags, var_idx);\n\t}\n\t*endp = cc;\n    }\n    else if (value_check_lock(lp->ll_newkey == NULL\n\t\t? lp->ll_tv->v_lock\n\t\t: lp->ll_tv->vval.v_dict->dv_lock, lp->ll_name, FALSE))\n\t;\n    else if (lp->ll_range)\n    {\n\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t{\n\t    emsg(_(e_cannot_lock_range));\n\t    return;\n\t}\n\n\t(void)list_assign_range(lp->ll_list, rettv->vval.v_list,\n\t\t\t lp->ll_n1, lp->ll_n2, lp->ll_empty2, op, lp->ll_name);\n    }\n    else\n    {\n\t/*\n\t * Assign to a List or Dictionary item.\n\t */\n\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t{\n\t    emsg(_(e_cannot_lock_list_or_dict));\n\t    return;\n\t}\n\n\tif (lp->ll_valtype != NULL\n\t\t    && check_typval_arg_type(lp->ll_valtype, rettv,\n\t\t\t\t\t\t\t      NULL, 0) == FAIL)\n\t    return;\n\n\tif (lp->ll_newkey != NULL)\n\t{\n\t    if (op != NULL && *op != '=')\n\t    {\n\t\tsemsg(_(e_key_not_present_in_dictionary), lp->ll_newkey);\n\t\treturn;\n\t    }\n\t    if (dict_wrong_func_name(lp->ll_tv->vval.v_dict, rettv,\n\t\t\t\t\t\t\t\tlp->ll_newkey))\n\t\treturn;\n\n\t    // Need to add an item to the Dictionary.\n\t    di = dictitem_alloc(lp->ll_newkey);\n\t    if (di == NULL)\n\t\treturn;\n\t    if (dict_add(lp->ll_tv->vval.v_dict, di) == FAIL)\n\t    {\n\t\tvim_free(di);\n\t\treturn;\n\t    }\n\t    lp->ll_tv = &di->di_tv;\n\t}\n\telse if (op != NULL && *op != '=')\n\t{\n\t    tv_op(lp->ll_tv, rettv, op);\n\t    return;\n\t}\n\telse\n\t    clear_tv(lp->ll_tv);\n\n\t/*\n\t * Assign the value to the variable or list item.\n\t */\n\tif (copy)\n\t    copy_tv(rettv, lp->ll_tv);\n\telse\n\t{\n\t    *lp->ll_tv = *rettv;\n\t    lp->ll_tv->v_lock = 0;\n\t    init_tv(rettv);\n\t}\n    }\n}\n\n/*\n * Handle \"tv1 += tv2\", \"tv1 -= tv2\", \"tv1 *= tv2\", \"tv1 /= tv2\", \"tv1 %= tv2\"\n * and \"tv1 .= tv2\"\n * Returns OK or FAIL.\n */\n    int\ntv_op(typval_T *tv1, typval_T *tv2, char_u *op)\n{\n    varnumber_T\tn;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*s;\n    int\t\tfailed = FALSE;\n\n    // Can't do anything with a Funcref or Dict on the right.\n    // v:true and friends only work with \"..=\".\n    if (tv2->v_type != VAR_FUNC && tv2->v_type != VAR_DICT\n\t\t    && ((tv2->v_type != VAR_BOOL && tv2->v_type != VAR_SPECIAL)\n\t\t\t\t\t\t\t\t|| *op == '.'))\n    {\n\tswitch (tv1->v_type)\n\t{\n\t    case VAR_UNKNOWN:\n\t    case VAR_ANY:\n\t    case VAR_VOID:\n\t    case VAR_DICT:\n\t    case VAR_FUNC:\n\t    case VAR_PARTIAL:\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t    case VAR_JOB:\n\t    case VAR_CHANNEL:\n\t    case VAR_INSTR:\n\t\tbreak;\n\n\t    case VAR_BLOB:\n\t\tif (*op != '+' || tv2->v_type != VAR_BLOB)\n\t\t    break;\n\t\t// BLOB += BLOB\n\t\tif (tv1->vval.v_blob != NULL && tv2->vval.v_blob != NULL)\n\t\t{\n\t\t    blob_T  *b1 = tv1->vval.v_blob;\n\t\t    blob_T  *b2 = tv2->vval.v_blob;\n\t\t    int\ti, len = blob_len(b2);\n\t\t    for (i = 0; i < len; i++)\n\t\t\tga_append(&b1->bv_ga, blob_get(b2, i));\n\t\t}\n\t\treturn OK;\n\n\t    case VAR_LIST:\n\t\tif (*op != '+' || tv2->v_type != VAR_LIST)\n\t\t    break;\n\t\t// List += List\n\t\tif (tv2->vval.v_list != NULL)\n\t\t{\n\t\t    if (tv1->vval.v_list == NULL)\n\t\t    {\n\t\t\ttv1->vval.v_list = tv2->vval.v_list;\n\t\t\t++tv1->vval.v_list->lv_refcount;\n\t\t    }\n\t\t    else\n\t\t\tlist_extend(tv1->vval.v_list, tv2->vval.v_list, NULL);\n\t\t}\n\t\treturn OK;\n\n\t    case VAR_NUMBER:\n\t    case VAR_STRING:\n\t\tif (tv2->v_type == VAR_LIST)\n\t\t    break;\n\t\tif (vim_strchr((char_u *)\"+-*/%\", *op) != NULL)\n\t\t{\n\t\t    // nr += nr , nr -= nr , nr *=nr , nr /= nr , nr %= nr\n\t\t    n = tv_get_number(tv1);\n#ifdef FEAT_FLOAT\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tfloat_T f = n;\n\n\t\t\tif (*op == '%')\n\t\t\t    break;\n\t\t\tswitch (*op)\n\t\t\t{\n\t\t\t    case '+': f += tv2->vval.v_float; break;\n\t\t\t    case '-': f -= tv2->vval.v_float; break;\n\t\t\t    case '*': f *= tv2->vval.v_float; break;\n\t\t\t    case '/': f /= tv2->vval.v_float; break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\ttv1->v_type = VAR_FLOAT;\n\t\t\ttv1->vval.v_float = f;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tswitch (*op)\n\t\t\t{\n\t\t\t    case '+': n += tv_get_number(tv2); break;\n\t\t\t    case '-': n -= tv_get_number(tv2); break;\n\t\t\t    case '*': n *= tv_get_number(tv2); break;\n\t\t\t    case '/': n = num_divide(n, tv_get_number(tv2),\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\t    case '%': n = num_modulus(n, tv_get_number(tv2),\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\ttv1->v_type = VAR_NUMBER;\n\t\t\ttv1->vval.v_number = n;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t\tbreak;\n\n\t\t    // str .= str\n\t\t    s = tv_get_string(tv1);\n\t\t    s = concat_str(s, tv_get_string_buf(tv2, numbuf));\n\t\t    clear_tv(tv1);\n\t\t    tv1->v_type = VAR_STRING;\n\t\t    tv1->vval.v_string = s;\n\t\t}\n\t\treturn failed ? FAIL : OK;\n\n\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t{\n\t\t    float_T f;\n\n\t\t    if (*op == '%' || *op == '.'\n\t\t\t\t   || (tv2->v_type != VAR_FLOAT\n\t\t\t\t    && tv2->v_type != VAR_NUMBER\n\t\t\t\t    && tv2->v_type != VAR_STRING))\n\t\t\tbreak;\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t\tf = tv2->vval.v_float;\n\t\t    else\n\t\t\tf = tv_get_number(tv2);\n\t\t    switch (*op)\n\t\t    {\n\t\t\tcase '+': tv1->vval.v_float += f; break;\n\t\t\tcase '-': tv1->vval.v_float -= f; break;\n\t\t\tcase '*': tv1->vval.v_float *= f; break;\n\t\t\tcase '/': tv1->vval.v_float /= f; break;\n\t\t    }\n\t\t}\n#endif\n\t\treturn OK;\n\t}\n    }\n\n    semsg(_(e_wrong_variable_type_for_str_equal), op);\n    return FAIL;\n}\n\n/*\n * Evaluate the expression used in a \":for var in expr\" command.\n * \"arg\" points to \"var\".\n * Set \"*errp\" to TRUE for an error, FALSE otherwise;\n * Return a pointer that holds the info.  Null when there is an error.\n */\n    void *\neval_for_line(\n    char_u\t*arg,\n    int\t\t*errp,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg)\n{\n    forinfo_T\t*fi;\n    char_u\t*var_list_end;\n    char_u\t*expr;\n    typval_T\ttv;\n    list_T\t*l;\n    int\t\tskip = !(evalarg->eval_flags & EVAL_EVALUATE);\n\n    *errp = TRUE;\t// default: there is an error\n\n    fi = ALLOC_CLEAR_ONE(forinfo_T);\n    if (fi == NULL)\n\treturn NULL;\n\n    var_list_end = skip_var_list(arg, TRUE, &fi->fi_varcount,\n\t\t\t\t\t\t     &fi->fi_semicolon, FALSE);\n    if (var_list_end == NULL)\n\treturn fi;\n\n    expr = skipwhite_and_linebreak(var_list_end, evalarg);\n    if (expr[0] != 'i' || expr[1] != 'n'\n\t\t\t\t  || !(expr[2] == NUL || VIM_ISWHITE(expr[2])))\n    {\n\tif (in_vim9script() && *expr == ':' && expr != var_list_end)\n\t    semsg(_(e_no_white_space_allowed_before_colon_str), expr);\n\telse\n\t    emsg(_(e_missing_in_after_for));\n\treturn fi;\n    }\n\n    if (skip)\n\t++emsg_skip;\n    expr = skipwhite_and_linebreak(expr + 2, evalarg);\n    if (eval0(expr, &tv, eap, evalarg) == OK)\n    {\n\t*errp = FALSE;\n\tif (!skip)\n\t{\n\t    if (tv.v_type == VAR_LIST)\n\t    {\n\t\tl = tv.vval.v_list;\n\t\tif (l == NULL)\n\t\t{\n\t\t    // a null list is like an empty list: do nothing\n\t\t    clear_tv(&tv);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Need a real list here.\n\t\t    CHECK_LIST_MATERIALIZE(l);\n\n\t\t    // No need to increment the refcount, it's already set for\n\t\t    // the list being used in \"tv\".\n\t\t    fi->fi_list = l;\n\t\t    list_add_watch(l, &fi->fi_lw);\n\t\t    fi->fi_lw.lw_item = l->lv_first;\n\t\t}\n\t    }\n\t    else if (tv.v_type == VAR_BLOB)\n\t    {\n\t\tfi->fi_bi = 0;\n\t\tif (tv.vval.v_blob != NULL)\n\t\t{\n\t\t    typval_T btv;\n\n\t\t    // Make a copy, so that the iteration still works when the\n\t\t    // blob is changed.\n\t\t    blob_copy(tv.vval.v_blob, &btv);\n\t\t    fi->fi_blob = btv.vval.v_blob;\n\t\t}\n\t\tclear_tv(&tv);\n\t    }\n\t    else if (tv.v_type == VAR_STRING)\n\t    {\n\t\tfi->fi_byte_idx = 0;\n\t\tfi->fi_string = tv.vval.v_string;\n\t\ttv.vval.v_string = NULL;\n\t\tif (fi->fi_string == NULL)\n\t\t    fi->fi_string = vim_strsave((char_u *)\"\");\n\t    }\n\t    else\n\t    {\n\t\temsg(_(e_string_list_or_blob_required));\n\t\tclear_tv(&tv);\n\t    }\n\t}\n    }\n    if (skip)\n\t--emsg_skip;\n    fi->fi_break_count = evalarg->eval_break_count;\n\n    return fi;\n}\n\n/*\n * Used when looping over a :for line, skip the \"in expr\" part.\n */\n    void\nskip_for_lines(void *fi_void, evalarg_T *evalarg)\n{\n    forinfo_T\t*fi = (forinfo_T *)fi_void;\n    int\t\ti;\n\n    for (i = 0; i < fi->fi_break_count; ++i)\n\teval_next_line(NULL, evalarg);\n}\n\n/*\n * Use the first item in a \":for\" list.  Advance to the next.\n * Assign the values to the variable (list).  \"arg\" points to the first one.\n * Return TRUE when a valid item was found, FALSE when at end of list or\n * something wrong.\n */\n    int\nnext_for_item(void *fi_void, char_u *arg)\n{\n    forinfo_T\t*fi = (forinfo_T *)fi_void;\n    int\t\tresult;\n    int\t\tflag = ASSIGN_FOR_LOOP | (in_vim9script()\n\t\t\t ? (ASSIGN_FINAL\n\t\t\t     // first round: error if variable exists\n\t\t\t     | (fi->fi_bi == 0 ? 0 : ASSIGN_DECL)\n\t\t\t     | ASSIGN_NO_MEMBER_TYPE)\n\t\t\t : 0);\n    listitem_T\t*item;\n    int\t\tskip_assign = in_vim9script() && arg[0] == '_'\n\t\t\t\t\t\t      && !eval_isnamec(arg[1]);\n\n    if (fi->fi_blob != NULL)\n    {\n\ttypval_T\ttv;\n\n\tif (fi->fi_bi >= blob_len(fi->fi_blob))\n\t    return FALSE;\n\ttv.v_type = VAR_NUMBER;\n\ttv.v_lock = VAR_FIXED;\n\ttv.vval.v_number = blob_get(fi->fi_blob, fi->fi_bi);\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    return TRUE;\n\treturn ex_let_vars(arg, &tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t    fi->fi_varcount, flag, NULL) == OK;\n    }\n\n    if (fi->fi_string != NULL)\n    {\n\ttypval_T\ttv;\n\tint\t\tlen;\n\n\tlen = mb_ptr2len(fi->fi_string + fi->fi_byte_idx);\n\tif (len == 0)\n\t    return FALSE;\n\ttv.v_type = VAR_STRING;\n\ttv.v_lock = VAR_FIXED;\n\ttv.vval.v_string = vim_strnsave(fi->fi_string + fi->fi_byte_idx, len);\n\tfi->fi_byte_idx += len;\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    result = TRUE;\n\telse\n\t    result = ex_let_vars(arg, &tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t    fi->fi_varcount, flag, NULL) == OK;\n\tvim_free(tv.vval.v_string);\n\treturn result;\n    }\n\n    item = fi->fi_lw.lw_item;\n    if (item == NULL)\n\tresult = FALSE;\n    else\n    {\n\tfi->fi_lw.lw_item = item->li_next;\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    result = TRUE;\n\telse\n\t    result = (ex_let_vars(arg, &item->li_tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t   fi->fi_varcount, flag, NULL) == OK);\n    }\n    return result;\n}\n\n/*\n * Free the structure used to store info used by \":for\".\n */\n    void\nfree_for_info(void *fi_void)\n{\n    forinfo_T    *fi = (forinfo_T *)fi_void;\n\n    if (fi == NULL)\n\treturn;\n    if (fi->fi_list != NULL)\n    {\n\tlist_rem_watch(fi->fi_list, &fi->fi_lw);\n\tlist_unref(fi->fi_list);\n    }\n    else if (fi->fi_blob != NULL)\n\tblob_unref(fi->fi_blob);\n    else\n\tvim_free(fi->fi_string);\n    vim_free(fi);\n}\n\n    void\nset_context_for_expression(\n    expand_T\t*xp,\n    char_u\t*arg,\n    cmdidx_T\tcmdidx)\n{\n    int\t\thas_expr = cmdidx != CMD_let && cmdidx != CMD_var;\n    int\t\tc;\n    char_u\t*p;\n\n    if (cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_const || cmdidx == CMD_final)\n    {\n\txp->xp_context = EXPAND_USER_VARS;\n\tif (vim_strpbrk(arg, (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\") == NULL)\n\t{\n\t    // \":let var1 var2 ...\": find last space.\n\t    for (p = arg + STRLEN(arg); p >= arg; )\n\t    {\n\t\txp->xp_pattern = p;\n\t\tMB_PTR_BACK(arg, p);\n\t\tif (VIM_ISWHITE(*p))\n\t\t    break;\n\t    }\n\t    return;\n\t}\n    }\n    else\n\txp->xp_context = cmdidx == CMD_call ? EXPAND_FUNCTIONS\n\t\t\t\t\t\t\t  : EXPAND_EXPRESSION;\n    while ((xp->xp_pattern = vim_strpbrk(arg,\n\t\t\t\t  (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\")) != NULL)\n    {\n\tc = *xp->xp_pattern;\n\tif (c == '&')\n\t{\n\t    c = xp->xp_pattern[1];\n\t    if (c == '&')\n\t    {\n\t\t++xp->xp_pattern;\n\t\txp->xp_context = has_expr ? EXPAND_EXPRESSION : EXPAND_NOTHING;\n\t    }\n\t    else if (c != ' ')\n\t    {\n\t\txp->xp_context = EXPAND_SETTINGS;\n\t\tif ((c == 'l' || c == 'g') && xp->xp_pattern[2] == ':')\n\t\t    xp->xp_pattern += 2;\n\n\t    }\n\t}\n\telse if (c == '$')\n\t{\n\t    // environment variable\n\t    xp->xp_context = EXPAND_ENV_VARS;\n\t}\n\telse if (c == '=')\n\t{\n\t    has_expr = TRUE;\n\t    xp->xp_context = EXPAND_EXPRESSION;\n\t}\n\telse if (c == '#'\n\t\t&& xp->xp_context == EXPAND_EXPRESSION)\n\t{\n\t    // Autoload function/variable contains '#'.\n\t    break;\n\t}\n\telse if ((c == '<' || c == '#')\n\t\t&& xp->xp_context == EXPAND_FUNCTIONS\n\t\t&& vim_strchr(xp->xp_pattern, '(') == NULL)\n\t{\n\t    // Function name can start with \"<SNR>\" and contain '#'.\n\t    break;\n\t}\n\telse if (has_expr)\n\t{\n\t    if (c == '\"')\t    // string\n\t    {\n\t\twhile ((c = *++xp->xp_pattern) != NUL && c != '\"')\n\t\t    if (c == '\\\\' && xp->xp_pattern[1] != NUL)\n\t\t\t++xp->xp_pattern;\n\t\txp->xp_context = EXPAND_NOTHING;\n\t    }\n\t    else if (c == '\\'')\t    // literal string\n\t    {\n\t\t// Trick: '' is like stopping and starting a literal string.\n\t\twhile ((c = *++xp->xp_pattern) != NUL && c != '\\'')\n\t\t    /* skip */ ;\n\t\txp->xp_context = EXPAND_NOTHING;\n\t    }\n\t    else if (c == '|')\n\t    {\n\t\tif (xp->xp_pattern[1] == '|')\n\t\t{\n\t\t    ++xp->xp_pattern;\n\t\t    xp->xp_context = EXPAND_EXPRESSION;\n\t\t}\n\t\telse\n\t\t    xp->xp_context = EXPAND_COMMANDS;\n\t    }\n\t    else\n\t\txp->xp_context = EXPAND_EXPRESSION;\n\t}\n\telse\n\t    // Doesn't look like something valid, expand as an expression\n\t    // anyway.\n\t    xp->xp_context = EXPAND_EXPRESSION;\n\targ = xp->xp_pattern;\n\tif (*arg != NUL)\n\t    while ((c = *++arg) != NUL && (c == ' ' || c == '\\t'))\n\t\t/* skip */ ;\n    }\n\n    // \":exe one two\" completes \"two\"\n    if ((cmdidx == CMD_execute\n\t\t|| cmdidx == CMD_echo\n\t\t|| cmdidx == CMD_echon\n\t\t|| cmdidx == CMD_echomsg)\n\t    && xp->xp_context == EXPAND_EXPRESSION)\n    {\n\tfor (;;)\n\t{\n\t    char_u *n = skiptowhite(arg);\n\n\t    if (n == arg || IS_WHITE_OR_NUL(*skipwhite(n)))\n\t\tbreak;\n\t    arg = skipwhite(n);\n\t}\n    }\n\n    xp->xp_pattern = arg;\n}\n\n/*\n * Return TRUE if \"pat\" matches \"text\".\n * Does not use 'cpo' and always uses 'magic'.\n */\n    int\npattern_match(char_u *pat, char_u *text, int ic)\n{\n    int\t\tmatches = FALSE;\n    char_u\t*save_cpo;\n    regmatch_T\tregmatch;\n\n    // avoid 'l' flag in 'cpoptions'\n    save_cpo = p_cpo;\n    p_cpo = empty_option;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog != NULL)\n    {\n\tregmatch.rm_ic = ic;\n\tmatches = vim_regexec_nl(&regmatch, text, (colnr_T)0);\n\tvim_regfree(regmatch.regprog);\n    }\n    p_cpo = save_cpo;\n    return matches;\n}\n\n/*\n * Handle a name followed by \"(\".  Both for just \"name(arg)\" and for\n * \"expr->name(arg)\".\n * Returns OK or FAIL.\n */\n    static int\neval_func(\n\tchar_u\t    **arg,\t// points to \"(\", will be advanced\n\tevalarg_T   *evalarg,\n\tchar_u\t    *name,\n\tint\t    name_len,\n\ttypval_T    *rettv,\n\tint\t    flags,\n\ttypval_T    *basetv)\t// \"expr\" for \"expr->name(arg)\"\n{\n    int\t\tevaluate = flags & EVAL_EVALUATE;\n    char_u\t*s = name;\n    int\t\tlen = name_len;\n    partial_T\t*partial;\n    int\t\tret = OK;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n\n    if (!evaluate)\n\tcheck_vars(s, len);\n\n    // If \"s\" is the name of a variable of type VAR_FUNC\n    // use its contents.\n    s = deref_func_name(s, &len, &partial,\n\t\t in_vim9script() ? &type : NULL, !evaluate, FALSE, &found_var);\n\n    // Need to make a copy, in case evaluating the arguments makes\n    // the name invalid.\n    s = vim_strsave(s);\n    if (s == NULL || (evaluate && (*s == NUL || (flags & EVAL_CONSTANT))))\n\tret = FAIL;\n    else\n    {\n\tfuncexe_T funcexe;\n\n\t// Invoke the function.\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = evaluate;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_basetv = basetv;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\tret = get_func_tv(s, len, rettv, arg, evalarg, &funcexe);\n    }\n    vim_free(s);\n\n    // If evaluate is FALSE rettv->v_type was not set in\n    // get_func_tv, but it's needed in handle_subscript() to parse\n    // what follows. So set it here.\n    if (rettv->v_type == VAR_UNKNOWN && !evaluate && **arg == '(')\n    {\n\trettv->vval.v_string = NULL;\n\trettv->v_type = VAR_FUNC;\n    }\n\n    // Stop the expression evaluation when immediately\n    // aborting on error, or when an interrupt occurred or\n    // an exception was thrown but not caught.\n    if (evaluate && aborting())\n    {\n\tif (ret == OK)\n\t    clear_tv(rettv);\n\tret = FAIL;\n    }\n    return ret;\n}\n\n/*\n * After a NL, skip over empty lines and comment-only lines.\n */\n    static char_u *\nnewline_skip_comments(char_u *arg)\n{\n    char_u *p = arg + 1;\n\n    for (;;)\n    {\n\tp = skipwhite(p);\n\n\tif (*p == NUL)\n\t    break;\n\tif (vim9_comment_start(p))\n\t{\n\t    char_u *nl = vim_strchr(p, NL);\n\n\t    if (nl == NULL)\n\t\t    break;\n\t    p = nl;\n\t}\n\tif (*p != NL)\n\t    break;\n\t++p;  // skip another NL\n    }\n    return p;\n}\n\n/*\n * Get the next line source line without advancing.  But do skip over comment\n * lines.\n * Only called for Vim9 script.\n */\n    static char_u *\ngetline_peek_skip_comments(evalarg_T *evalarg)\n{\n    for (;;)\n    {\n\tchar_u *next = getline_peek(evalarg->eval_getline,\n\t\t\t\t\t\t\t evalarg->eval_cookie);\n\tchar_u *p;\n\n\tif (next == NULL)\n\t    break;\n\tp = skipwhite(next);\n\tif (*p != NUL && !vim9_comment_start(p))\n\t    return next;\n\tif (eval_next_line(NULL, evalarg) == NULL)\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * If inside Vim9 script, \"arg\" points to the end of a line (ignoring a #\n * comment) and there is a next line, return the next line (skipping blanks)\n * and set \"getnext\".\n * Otherwise return the next non-white at or after \"arg\" and set \"getnext\" to\n * FALSE.\n * \"arg\" must point somewhere inside a line, not at the start.\n */\n    char_u *\neval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext)\n{\n    char_u *p = skipwhite(arg);\n\n    *getnext = FALSE;\n    if (in_vim9script()\n\t    && evalarg != NULL\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL\n\t\t\t\t\t\t\t\t   || *p == NL)\n\t    && (*p == NUL || *p == NL\n\t\t\t     || (vim9_comment_start(p) && VIM_ISWHITE(p[-1]))))\n    {\n\tchar_u *next;\n\n\tif (*p == NL)\n\t    next = newline_skip_comments(p);\n\telse if (evalarg->eval_cookie != NULL)\n\t    next = getline_peek_skip_comments(evalarg);\n\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = TRUE;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}\n\n/*\n * To be called after eval_next_non_blank() sets \"getnext\" to TRUE.\n * Only called for Vim9 script.\n */\n    char_u *\neval_next_line(char_u *arg, evalarg_T *evalarg)\n{\n    garray_T\t*gap = &evalarg->eval_ga;\n    char_u\t*line;\n\n    if (arg != NULL)\n    {\n\tif (*arg == NL)\n\t    return newline_skip_comments(arg);\n\t// Truncate before a trailing comment, so that concatenating the lines\n\t// won't turn the rest into a comment.\n\tif (*skipwhite(arg) == '#')\n\t    *arg = NUL;\n    }\n\n    if (evalarg->eval_cookie != NULL)\n\tline = evalarg->eval_getline(0, evalarg->eval_cookie, 0,\n\t\t\t\t\t\t\t   GETLINE_CONCAT_ALL);\n    else\n\tline = next_line_from_context(evalarg->eval_cctx, TRUE);\n    if (line == NULL)\n\treturn NULL;\n\n    ++evalarg->eval_break_count;\n    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)\n    {\n\tchar_u *p = skipwhite(line);\n\n\t// Going to concatenate the lines after parsing.  For an empty or\n\t// comment line use an empty string.\n\tif (*p == NUL || vim9_comment_start(p))\n\t{\n\t    vim_free(line);\n\t    line = vim_strsave((char_u *)\"\");\n\t}\n\n\t((char_u **)gap->ga_data)[gap->ga_len] = line;\n\t++gap->ga_len;\n    }\n    else if (evalarg->eval_cookie != NULL)\n    {\n\tvim_free(evalarg->eval_tofree);\n\tevalarg->eval_tofree = line;\n    }\n\n    // Advanced to the next line, \"arg\" no longer points into the previous\n    // line.\n    evalarg->eval_using_cmdline = FALSE;\n    return skipwhite(line);\n}\n\n/*\n * Call eval_next_non_blank() and get the next line if needed.\n */\n    char_u *\nskipwhite_and_linebreak(char_u *arg, evalarg_T *evalarg)\n{\n    int\t    getnext;\n    char_u  *p = skipwhite_and_nl(arg);\n\n    if (evalarg == NULL)\n\treturn skipwhite(arg);\n    eval_next_non_blank(p, evalarg, &getnext);\n    if (getnext)\n\treturn eval_next_line(arg, evalarg);\n    return p;\n}\n\n/*\n * Initialize \"evalarg\" for use.\n */\n    void\ninit_evalarg(evalarg_T *evalarg)\n{\n    CLEAR_POINTER(evalarg);\n    ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);\n}\n\n/*\n * After using \"evalarg\" filled from \"eap\": free the memory.\n */\n    void\nclear_evalarg(evalarg_T *evalarg, exarg_T *eap)\n{\n    if (evalarg != NULL)\n    {\n\tif (evalarg->eval_tofree != NULL)\n\t{\n\t    if (eap != NULL)\n\t    {\n\t\t// We may need to keep the original command line, e.g. for\n\t\t// \":let\" it has the variable names.  But we may also need the\n\t\t// new one, \"nextcmd\" points into it.  Keep both.\n\t\tvim_free(eap->cmdline_tofree);\n\t\teap->cmdline_tofree = *eap->cmdlinep;\n\t\t*eap->cmdlinep = evalarg->eval_tofree;\n\t    }\n\t    else\n\t\tvim_free(evalarg->eval_tofree);\n\t    evalarg->eval_tofree = NULL;\n\t}\n\n\tga_clear_strings(&evalarg->eval_tofree_ga);\n\tVIM_CLEAR(evalarg->eval_tofree_lambda);\n    }\n}\n\n/*\n * The \"evaluate\" argument: When FALSE, the argument is only parsed but not\n * executed.  The function may return OK, but the rettv will be of type\n * VAR_UNKNOWN.  The function still returns FAIL for a syntax error.\n */\n\n/*\n * Handle zero level expression.\n * This calls eval1() and handles error message and nextcmd.\n * Put the result in \"rettv\" when returning OK and \"evaluate\" is TRUE.\n * Note: \"rettv.v_lock\" is not set.\n * \"evalarg\" can be NULL, EVALARG_EVALUATE or a pointer.\n * Return OK or FAIL.\n */\n    int\neval0(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg)\n{\n    return eval0_retarg(arg, rettv, eap, evalarg, NULL);\n}\n\n/*\n * Like eval0() but when \"retarg\" is not NULL store the pointer to after the\n * expression and don't check what comes after the expression.\n */\n    int\neval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n\n    if (ret != FAIL)\n    {\n\texpr_end = p;\n\tp = skipwhite(p);\n\n\t// In Vim9 script a command block is not split at NL characters for\n\t// commands using an expression argument.  Skip over a '#' comment to\n\t// check for a following NL.  Require white space before the '#'.\n\tif (in_vim9script() && p > expr_end && retarg == NULL)\n\t    while (*p == '#')\n\t    {\n\t\tchar_u *nl = vim_strchr(p, NL);\n\n\t\tif (nl == NULL)\n\t\t    break;\n\t\tp = skipwhite(nl + 1);\n\t\tif (eap != NULL && *p != NUL)\n\t\t    eap->nextcmd = p;\n\t\tcheck_for_end = FALSE;\n\t    }\n\n\tif (check_for_end)\n\t    end_error = !ends_excmd2(arg, p);\n    }\n\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\t/*\n\t * Report the invalid expression unless the expression evaluation has\n\t * been cancelled due to an aborting error, an interrupt, or an\n\t * exception, or we already gave a more specific error.\n\t * Also check called_emsg for when using assert_fails().\n\t */\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\n\t// Some of the expression may not have been consumed.  Do not check for\n\t// a next command to avoid more errors, unless \"|\" is following, which\n\t// could only be a command separator.\n\tif (eap != NULL && p != NULL\n\t\t\t  &&  skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n\n    return ret;\n}\n\n/*\n * Handle top level expression:\n *\texpr2 ? expr1 : expr1\n *\texpr2 ?? expr1\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Note: \"rettv.v_lock\" is not set.\n *\n * Return OK or FAIL.\n */\n    int\neval1(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u  *p;\n    int\t    getnext;\n\n    CLEAR_POINTER(rettv);\n\n    /*\n     * Get the first variable.\n     */\n    if (eval2(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (*p == '?')\n    {\n\tint\t\top_falsy = p[1] == '?';\n\tint\t\tresult;\n\ttypval_T\tvar2;\n\tevalarg_T\t*evalarg_used = evalarg;\n\tevalarg_T\tlocal_evalarg;\n\tint\t\torig_flags;\n\tint\t\tevaluate;\n\tint\t\tvim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = evalarg_used->eval_flags & EVAL_EVALUATE;\n\n\tif (getnext)\n\t    *arg = eval_next_line(*arg, evalarg_used);\n\telse\n\t{\n\t    if (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t    {\n\t\terror_white_both(p, op_falsy ? 2 : 1);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\n\tresult = FALSE;\n\tif (evaluate)\n\t{\n\t    int\t\terror = FALSE;\n\n\t    if (op_falsy)\n\t\tresult = tv2bool(rettv);\n\t    else if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) != 0)\n\t\tresult = TRUE;\n\t    if (error || !op_falsy || !result)\n\t\tclear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Get the second variable.  Recursive!\n\t */\n\tif (op_falsy)\n\t    ++*arg;\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[1]))\n\t{\n\t    error_white_both(*arg - (op_falsy ? 1 : 0), op_falsy ? 2 : 1);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg_used);\n\tevalarg_used->eval_flags = (op_falsy ? !result : result)\n\t\t\t\t    ? orig_flags : orig_flags & ~EVAL_EVALUATE;\n\tif (eval1(arg, &var2, evalarg_used) == FAIL)\n\t{\n\t    evalarg_used->eval_flags = orig_flags;\n\t    return FAIL;\n\t}\n\tif (!op_falsy || !result)\n\t    *rettv = var2;\n\n\tif (!op_falsy)\n\t{\n\t    /*\n\t     * Check for the \":\".\n\t     */\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t    if (*p != ':')\n\t    {\n\t\temsg(_(e_missing_colon_after_questionmark));\n\t\tif (evaluate && result)\n\t\t    clear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    if (getnext)\n\t\t*arg = eval_next_line(*arg, evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 1);\n\t\t    clear_tv(rettv);\n\t\t    evalarg_used->eval_flags = orig_flags;\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the third variable.  Recursive!\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[1]))\n\t    {\n\t\terror_white_both(*arg, 1);\n\t\tclear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg_used);\n\t    evalarg_used->eval_flags = !result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    if (eval1(arg, &var2, evalarg_used) == FAIL)\n\t    {\n\t\tif (evaluate && result)\n\t\t    clear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    if (evaluate && !result)\n\t\t*rettv = var2;\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle first level expression:\n *\texpr2 || expr2 || expr2\t    logical OR\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval2(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n\n    /*\n     * Get the first expression.\n     */\n    if (eval3(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Handle the  \"||\" operator.\n     */\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (p[0] == '|' && p[1] == '|')\n    {\n\tevalarg_T   *evalarg_used = evalarg;\n\tevalarg_T   local_evalarg;\n\tint\t    evaluate;\n\tint\t    orig_flags;\n\tlong\t    result = FALSE;\n\ttypval_T    var2;\n\tint\t    error = FALSE;\n\tint\t    vim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = orig_flags & EVAL_EVALUATE;\n\tif (evaluate)\n\t{\n\t    if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) != 0)\n\t\tresult = TRUE;\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Repeat until there is no following \"||\".\n\t */\n\twhile (p[0] == '|' && p[1] == '|')\n\t{\n\t    if (getnext)\n\t\t*arg = eval_next_line(*arg, evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 2);\n\t\t    clear_tv(rettv);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the second variable.\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[2]))\n\t    {\n\t\terror_white_both(*arg, 2);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 2, evalarg_used);\n\t    evalarg_used->eval_flags = !result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    if (eval3(arg, &var2, evalarg_used) == FAIL)\n\t\treturn FAIL;\n\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (evaluate && !result)\n\t    {\n\t\tif (vim9script)\n\t\t    result = tv_get_bool_chk(&var2, &error);\n\t\telse if (tv_get_number_chk(&var2, &error) != 0)\n\t\t    result = TRUE;\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    if (evaluate)\n\t    {\n\t\tif (vim9script)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = result ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = result;\n\t\t}\n\t    }\n\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle second level expression:\n *\texpr3 && expr3 && expr3\t    logical AND\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval3(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n\n    /*\n     * Get the first expression.\n     */\n    if (eval4(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Handle the \"&&\" operator.\n     */\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (p[0] == '&' && p[1] == '&')\n    {\n\tevalarg_T   *evalarg_used = evalarg;\n\tevalarg_T   local_evalarg;\n\tint\t    orig_flags;\n\tint\t    evaluate;\n\tlong\t    result = TRUE;\n\ttypval_T    var2;\n\tint\t    error = FALSE;\n\tint\t    vim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = orig_flags & EVAL_EVALUATE;\n\tif (evaluate)\n\t{\n\t    if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) == 0)\n\t\tresult = FALSE;\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Repeat until there is no following \"&&\".\n\t */\n\twhile (p[0] == '&' && p[1] == '&')\n\t{\n\t    if (getnext)\n\t\t*arg = eval_next_line(*arg, evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 2);\n\t\t    clear_tv(rettv);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the second variable.\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[2]))\n\t    {\n\t\terror_white_both(*arg, 2);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 2, evalarg_used);\n\t    evalarg_used->eval_flags = result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    CLEAR_FIELD(var2);\n\t    if (eval4(arg, &var2, evalarg_used) == FAIL)\n\t\treturn FAIL;\n\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (evaluate && result)\n\t    {\n\t\tif (vim9script)\n\t\t    result = tv_get_bool_chk(&var2, &error);\n\t\telse if (tv_get_number_chk(&var2, &error) == 0)\n\t\t    result = FALSE;\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    if (evaluate)\n\t    {\n\t\tif (vim9script)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = result ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = result;\n\t\t}\n\t    }\n\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle third level expression:\n *\tvar1 == var2\n *\tvar1 =~ var2\n *\tvar1 != var2\n *\tvar1 !~ var2\n *\tvar1 > var2\n *\tvar1 >= var2\n *\tvar1 < var2\n *\tvar1 <= var2\n *\tvar1 is var2\n *\tvar1 isnot var2\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n    exprtype_T\ttype = EXPR_UNKNOWN;\n    int\t\tlen = 2;\n    int\t\ttype_is = FALSE;\n\n    /*\n     * Get the first expression.\n     */\n    if (eval5(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n\n    type = get_compare_type(p, &len, &type_is);\n\n    /*\n     * If there is a comparative operator, use it.\n     */\n    if (type != EXPR_UNKNOWN)\n    {\n\ttypval_T    var2;\n\tint\t    ic;\n\tint\t    vim9script = in_vim9script();\n\tint\t    evaluate = evalarg == NULL\n\t\t\t\t   ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tlong\t    comp_lnum = SOURCING_LNUM;\n\n\tif (getnext)\n\t{\n\t    *arg = eval_next_line(*arg, evalarg);\n\t    p = *arg;\n\t}\n\telse if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t{\n\t    error_white_both(*arg, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (vim9script && type_is && (p[len] == '?' || p[len] == '#'))\n\t{\n\t    semsg(_(e_invalid_expression_str), p);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\t// extra question mark appended: ignore case\n\tif (p[len] == '?')\n\t{\n\t    ic = TRUE;\n\t    ++len;\n\t}\n\t// extra '#' appended: match case\n\telse if (p[len] == '#')\n\t{\n\t    ic = FALSE;\n\t    ++len;\n\t}\n\t// nothing appended: use 'ignorecase' if not in Vim script\n\telse\n\t    ic = vim9script ? FALSE : p_ic;\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL(p[len]))\n\t{\n\t    error_white_both(p, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(p + len, evalarg);\n\tif (eval5(arg, &var2, evalarg) == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\tif (evaluate)\n\t{\n\t    int ret;\n\n\t    // use the line of the comparison for messages\n\t    SOURCING_LNUM = comp_lnum;\n\t    if (vim9script && check_compare_types(type, rettv, &var2) == FAIL)\n\t    {\n\t\tret = FAIL;\n\t\tclear_tv(rettv);\n\t    }\n\t    else\n\t\tret = typval_compare(rettv, &var2, type, ic);\n\t    clear_tv(&var2);\n\t    return ret;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Make a copy of blob \"tv1\" and append blob \"tv2\".\n */\n    void\neval_addblob(typval_T *tv1, typval_T *tv2)\n{\n    blob_T  *b1 = tv1->vval.v_blob;\n    blob_T  *b2 = tv2->vval.v_blob;\n    blob_T  *b = blob_alloc();\n    int\t    i;\n\n    if (b != NULL)\n    {\n\tfor (i = 0; i < blob_len(b1); i++)\n\t    ga_append(&b->bv_ga, blob_get(b1, i));\n\tfor (i = 0; i < blob_len(b2); i++)\n\t    ga_append(&b->bv_ga, blob_get(b2, i));\n\n\tclear_tv(tv1);\n\trettv_blob_set(tv1, b);\n    }\n}\n\n/*\n * Make a copy of list \"tv1\" and append list \"tv2\".\n */\n    int\neval_addlist(typval_T *tv1, typval_T *tv2)\n{\n    typval_T var3;\n\n    // concatenate Lists\n    if (list_concat(tv1->vval.v_list, tv2->vval.v_list, &var3) == FAIL)\n    {\n\tclear_tv(tv1);\n\tclear_tv(tv2);\n\treturn FAIL;\n    }\n    clear_tv(tv1);\n    *tv1 = var3;\n    return OK;\n}\n\n/*\n * Handle the bitwise left/right shift operator expression:\n *\tvar1 << var2\n *\tvar1 >> var2\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval5(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    /*\n     * Get the first expression.\n     */\n    if (eval6(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '<<' or '>>' is following.\n     */\n    for (;;)\n    {\n\tchar_u\t\t*p;\n\tint\t\tgetnext;\n\texprtype_T\ttype;\n\tint\t\tevaluate;\n\ttypval_T\tvar2;\n\tint\t\tvim9script;\n\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\tif (p[0] == '<' && p[1] == '<')\n\t    type = EXPR_LSHIFT;\n\telse if (p[0] == '>' && p[1] == '>')\n\t    type = EXPR_RSHIFT;\n\telse\n\t    return OK;\n\n\t// Handle a bitwise left or right shift operator\n\tif (rettv->v_type != VAR_NUMBER)\n\t{\n\t    // left operand should be a number\n\t    emsg(_(e_bitshift_ops_must_be_number));\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tvim9script = in_vim9script();\n\tif (getnext)\n\t{\n\t    *arg = eval_next_line(*arg, evalarg);\n\t    p = *arg;\n\t}\n\telse if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t{\n\t    error_white_both(*arg, 2);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL(p[2]))\n\t{\n\t    error_white_both(p, 2);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(p + 2, evalarg);\n\tif (eval6(arg, &var2, evalarg) == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (var2.v_type != VAR_NUMBER || var2.vval.v_number < 0)\n\t{\n\t    // right operand should be a positive number\n\t    if (var2.v_type != VAR_NUMBER)\n\t\temsg(_(e_bitshift_ops_must_be_number));\n\t    else\n\t\temsg(_(e_bitshift_ops_must_be_postive));\n\t    clear_tv(rettv);\n\t    clear_tv(&var2);\n\t    return FAIL;\n\t}\n\n\tif (evaluate)\n\t{\n\t    if (var2.vval.v_number > MAX_LSHIFT_BITS)\n\t\t// shifting more bits than we have always results in zero\n\t\trettv->vval.v_number = 0;\n\t    else if (type == EXPR_LSHIFT)\n\t\trettv->vval.v_number =\n\t\t      (uvarnumber_T)rettv->vval.v_number << var2.vval.v_number;\n\t    else\n\t\trettv->vval.v_number =\n\t\t      (uvarnumber_T)rettv->vval.v_number >> var2.vval.v_number;\n\t}\n\n\tclear_tv(&var2);\n    }\n\n    return OK;\n}\n\n/*\n * Handle fifth level expression:\n *\t+\tnumber addition, concatenation of list or blob\n *\t-\tnumber subtraction\n *\t.\tstring concatenation (if script version is 1)\n *\t..\tstring concatenation\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval6(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    /*\n     * Get the first expression.\n     */\n    if (eval7(arg, rettv, evalarg, FALSE) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '+', '-' or '.' is following.\n     */\n    for (;;)\n    {\n\tint\t    evaluate;\n\tint\t    getnext;\n\tchar_u\t    *p;\n\tint\t    op;\n\tint\t    oplen;\n\tint\t    concat;\n\ttypval_T    var2;\n\tint\t    vim9script = in_vim9script();\n\n\t// \".\" is only string concatenation when scriptversion is 1\n\t// \"+=\", \"-=\" and \"..=\" are assignments\n\t// \"++\" and \"--\" on the next line are a separate command.\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\top = *p;\n\tconcat = op == '.' && (*(p + 1) == '.' || in_old_script(2));\n\tif ((op != '+' && op != '-' && !concat) || p[1] == '='\n\t\t\t\t\t       || (p[1] == '.' && p[2] == '='))\n\t    break;\n\tif (getnext && (op == '+' || op == '-') && p[0] == p[1])\n\t    break;\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\toplen = (concat && p[1] == '.') ? 2 : 1;\n\tif (getnext)\n\t    *arg = eval_next_line(*arg, evalarg);\n\telse\n\t{\n\t    if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t    {\n\t\terror_white_both(*arg, oplen);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\tif ((op != '+' || (rettv->v_type != VAR_LIST\n\t\t\t\t\t\t && rettv->v_type != VAR_BLOB))\n#ifdef FEAT_FLOAT\n\t\t&& (op == '.' || rettv->v_type != VAR_FLOAT)\n#endif\n\t\t&& evaluate)\n\t{\n\t    int\t\terror = FALSE;\n\n\t    // For \"list + ...\", an illegal use of the first operand as\n\t    // a number cannot be determined before evaluating the 2nd\n\t    // operand: if this is also a list, all is ok.\n\t    // For \"something . ...\", \"something - ...\" or \"non-list + ...\",\n\t    // we know that the first operand needs to be a string or number\n\t    // without evaluating the 2nd operand.  So check before to avoid\n\t    // side effects after an error.\n\t    if (op != '.')\n\t\ttv_get_number_chk(rettv, &error);\n\t    if ((op == '.' && tv_get_string_chk(rettv) == NULL) || error)\n\t    {\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[oplen]))\n\t{\n\t    error_white_both(*arg, oplen);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + oplen, evalarg);\n\tif (eval7(arg, &var2, evalarg, !vim9script && op == '.') == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (evaluate)\n\t{\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (op == '.')\n\t    {\n\t\tchar_u\tbuf1[NUMBUFLEN], buf2[NUMBUFLEN];\n\t\tchar_u\t*s1 = tv_get_string_buf(rettv, buf1);\n\t\tchar_u\t*s2 = NULL;\n\n\t\tif (vim9script && (var2.v_type == VAR_VOID\n\t\t\t|| var2.v_type == VAR_CHANNEL\n\t\t\t|| var2.v_type == VAR_JOB))\n\t\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t   vartype_name(var2.v_type));\n#ifdef FEAT_FLOAT\n\t\telse if (vim9script && var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%g\",\n\t\t\t\t\t\t\t    var2.vval.v_float);\n\t\t    s2 = buf2;\n\t\t}\n#endif\n\t\telse\n\t\t    s2 = tv_get_string_buf_chk(&var2, buf2);\n\t\tif (s2 == NULL)\t\t// type error ?\n\t\t{\n\t\t    clear_tv(rettv);\n\t\t    clear_tv(&var2);\n\t\t    return FAIL;\n\t\t}\n\t\tp = concat_str(s1, s2);\n\t\tclear_tv(rettv);\n\t\trettv->v_type = VAR_STRING;\n\t\trettv->vval.v_string = p;\n\t    }\n\t    else if (op == '+' && rettv->v_type == VAR_BLOB\n\t\t\t\t\t\t   && var2.v_type == VAR_BLOB)\n\t\teval_addblob(rettv, &var2);\n\t    else if (op == '+' && rettv->v_type == VAR_LIST\n\t\t\t\t\t\t   && var2.v_type == VAR_LIST)\n\t    {\n\t\tif (eval_addlist(rettv, &var2) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tint\t\terror = FALSE;\n\t\tvarnumber_T\tn1, n2;\n#ifdef FEAT_FLOAT\n\t\tfloat_T\t    f1 = 0, f2 = 0;\n\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t{\n\t\t    f1 = rettv->vval.v_float;\n\t\t    n1 = 0;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    n1 = tv_get_number_chk(rettv, &error);\n\t\t    if (error)\n\t\t    {\n\t\t\t// This can only happen for \"list + non-list\" or\n\t\t\t// \"blob + non-blob\".  For \"non-list + ...\" or\n\t\t\t// \"something - ...\", we returned before evaluating the\n\t\t\t// 2nd operand.\n\t\t\tclear_tv(rettv);\n\t\t\tclear_tv(&var2);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (var2.v_type == VAR_FLOAT)\n\t\t\tf1 = n1;\n#endif\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    f2 = var2.vval.v_float;\n\t\t    n2 = 0;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    n2 = tv_get_number_chk(&var2, &error);\n\t\t    if (error)\n\t\t    {\n\t\t\tclear_tv(rettv);\n\t\t\tclear_tv(&var2);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (rettv->v_type == VAR_FLOAT)\n\t\t\tf2 = n2;\n#endif\n\t\t}\n\t\tclear_tv(rettv);\n\n#ifdef FEAT_FLOAT\n\t\t// If there is a float on either side the result is a float.\n\t\tif (rettv->v_type == VAR_FLOAT || var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    if (op == '+')\n\t\t\tf1 = f1 + f2;\n\t\t    else\n\t\t\tf1 = f1 - f2;\n\t\t    rettv->v_type = VAR_FLOAT;\n\t\t    rettv->vval.v_float = f1;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (op == '+')\n\t\t\tn1 = n1 + n2;\n\t\t    else\n\t\t\tn1 = n1 - n2;\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = n1;\n\t\t}\n\t    }\n\t    clear_tv(&var2);\n\t}\n    }\n    return OK;\n}\n\n/*\n * Handle sixth level expression:\n *\t*\tnumber multiplication\n *\t/\tnumber division\n *\t%\tnumber modulo\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval7(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)  // after \".\" operator\n{\n#ifdef FEAT_FLOAT\n    int\t    use_float = FALSE;\n#endif\n\n    /*\n     * Get the first expression.\n     */\n    if (eval8(arg, rettv, evalarg, want_string) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '*', '/' or '%' is following.\n     */\n    for (;;)\n    {\n\tint\t    evaluate;\n\tint\t    getnext;\n\ttypval_T    var2;\n\tchar_u\t    *p;\n\tint\t    op;\n\tvarnumber_T n1, n2;\n#ifdef FEAT_FLOAT\n\tfloat_T\t    f1, f2;\n#endif\n\tint\t    error;\n\n\t// \"*=\", \"/=\" and \"%=\" are assignments\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\top = *p;\n\tif ((op != '*' && op != '/' && op != '%') || p[1] == '=')\n\t    break;\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tif (getnext)\n\t    *arg = eval_next_line(*arg, evalarg);\n\telse\n\t{\n\t    if (evaluate && in_vim9script() && !VIM_ISWHITE(**arg))\n\t    {\n\t\terror_white_both(*arg, 1);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\n#ifdef FEAT_FLOAT\n\tf1 = 0;\n\tf2 = 0;\n#endif\n\terror = FALSE;\n\tif (evaluate)\n\t{\n#ifdef FEAT_FLOAT\n\t    if (rettv->v_type == VAR_FLOAT)\n\t    {\n\t\tf1 = rettv->vval.v_float;\n\t\tuse_float = TRUE;\n\t\tn1 = 0;\n\t    }\n\t    else\n#endif\n\t\tn1 = tv_get_number_chk(rettv, &error);\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\telse\n\t    n1 = 0;\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && in_vim9script() && !IS_WHITE_OR_NUL((*arg)[1]))\n\t{\n\t    error_white_both(*arg, 1);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\tif (eval8(arg, &var2, evalarg, FALSE) == FAIL)\n\t    return FAIL;\n\n\tif (evaluate)\n\t{\n#ifdef FEAT_FLOAT\n\t    if (var2.v_type == VAR_FLOAT)\n\t    {\n\t\tif (!use_float)\n\t\t{\n\t\t    f1 = n1;\n\t\t    use_float = TRUE;\n\t\t}\n\t\tf2 = var2.vval.v_float;\n\t\tn2 = 0;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tn2 = tv_get_number_chk(&var2, &error);\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n#ifdef FEAT_FLOAT\n\t\tif (use_float)\n\t\t    f2 = n2;\n#endif\n\t    }\n\n\t    /*\n\t     * Compute the result.\n\t     * When either side is a float the result is a float.\n\t     */\n#ifdef FEAT_FLOAT\n\t    if (use_float)\n\t    {\n\t\tif (op == '*')\n\t\t    f1 = f1 * f2;\n\t\telse if (op == '/')\n\t\t{\n# ifdef VMS\n\t\t    // VMS crashes on divide by zero, work around it\n\t\t    if (f2 == 0.0)\n\t\t    {\n\t\t\tif (f1 == 0)\n\t\t\t    f1 = -1 * __F_FLT_MAX - 1L;   // similar to NaN\n\t\t\telse if (f1 < 0)\n\t\t\t    f1 = -1 * __F_FLT_MAX;\n\t\t\telse\n\t\t\t    f1 = __F_FLT_MAX;\n\t\t    }\n\t\t    else\n\t\t\tf1 = f1 / f2;\n# else\n\t\t    // We rely on the floating point library to handle divide\n\t\t    // by zero to result in \"inf\" and not a crash.\n\t\t    f1 = f1 / f2;\n# endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    emsg(_(e_cannot_use_percent_with_float));\n\t\t    return FAIL;\n\t\t}\n\t\trettv->v_type = VAR_FLOAT;\n\t\trettv->vval.v_float = f1;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tint\t    failed = FALSE;\n\n\t\tif (op == '*')\n\t\t    n1 = n1 * n2;\n\t\telse if (op == '/')\n\t\t    n1 = num_divide(n1, n2, &failed);\n\t\telse\n\t\t    n1 = num_modulus(n1, n2, &failed);\n\t\tif (failed)\n\t\t    return FAIL;\n\n\t\trettv->v_type = VAR_NUMBER;\n\t\trettv->vval.v_number = n1;\n\t    }\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Handle a type cast before a base level expression.\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n * Return OK or FAIL.\n */\n    static int\neval8(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    type_T\t*want_type = NULL;\n    garray_T\ttype_list;\t    // list of pointers to allocated types\n    int\t\tres;\n    int\t\tevaluate = evalarg == NULL ? 0\n\t\t\t\t       : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    // Recognize <type> in Vim9 script only.\n    if (in_vim9script() && **arg == '<' && eval_isnamec1((*arg)[1])\n\t\t\t\t\t     && STRNCMP(*arg, \"<SNR>\", 5) != 0)\n    {\n\t++*arg;\n\tga_init2(&type_list, sizeof(type_T *), 10);\n\twant_type = parse_type(arg, &type_list, TRUE);\n\tif (want_type == NULL && (evaluate || **arg != '>'))\n\t{\n\t    clear_type_list(&type_list);\n\t    return FAIL;\n\t}\n\n\tif (**arg != '>')\n\t{\n\t    if (*skipwhite(*arg) == '>')\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \">\", *arg);\n\t    else\n\t\temsg(_(e_missing_gt));\n\t    clear_type_list(&type_list);\n\t    return FAIL;\n\t}\n\t++*arg;\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n    }\n\n    res = eval9(arg, rettv, evalarg, want_string);\n\n    if (want_type != NULL && evaluate)\n    {\n\tif (res == OK)\n\t{\n\t    type_T *actual = typval2type(rettv, get_copyID(), &type_list,\n\t\t\t\t\t\t\t       TVTT_DO_MEMBER);\n\n\t    if (!equal_type(want_type, actual, 0))\n\t    {\n\t\tif (want_type == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n\t\t{\n\t\t    int n = tv2bool(rettv);\n\n\t\t    // can use \"0\" and \"1\" for boolean in some places\n\t\t    clear_tv(rettv);\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = n ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    where_T where = WHERE_INIT;\n\n\t\t    where.wt_variable = TRUE;\n\t\t    res = check_type(want_type, actual, TRUE, where);\n\t\t}\n\t    }\n\t}\n\tclear_type_list(&type_list);\n    }\n\n    return res;\n}\n\n    int\neval_leader(char_u **arg, int vim9)\n{\n    char_u\t*s = *arg;\n    char_u\t*p = *arg;\n\n    while (*p == '!' || *p == '-' || *p == '+')\n    {\n\tchar_u *n = skipwhite(p + 1);\n\n\t// ++, --, -+ and +- are not accepted in Vim9 script\n\tif (vim9 && (*p == '-' || *p == '+') && (*n == '-' || *n == '+'))\n\t{\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n\tp = n;\n    }\n    *arg = p;\n    return OK;\n}\n\n/*\n * Check for a predefined value \"true\", \"false\" and \"null.*\".\n * Return OK when recognized.\n */\n    int\nhandle_predefined(char_u *s, int len, typval_T *rettv)\n{\n    switch (len)\n    {\n\tcase 4: if (STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 5: if (STRNCMP(s, \"false\", 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_FALSE;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 8: if (STRNCMP(s, \"null_job\", 8) == 0)\n\t\t{\n#ifdef FEAT_JOB_CHANNEL\n\t\t    rettv->v_type = VAR_JOB;\n\t\t    rettv->vval.v_job = NULL;\n#else\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n#endif\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 9:\n\t\tif (STRNCMP(s, \"null_\", 5) != 0)\n\t\t    break;\n\t\tif (STRNCMP(s + 5, \"list\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_LIST;\n\t\t    rettv->vval.v_list = NULL;\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s + 5, \"dict\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_DICT;\n\t\t    rettv->vval.v_dict = NULL;\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s + 5, \"blob\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BLOB;\n\t\t    rettv->vval.v_blob = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 11: if (STRNCMP(s, \"null_string\", 11) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_STRING;\n\t\t    rettv->vval.v_string = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 12:\n\t\tif (STRNCMP(s, \"null_channel\", 12) == 0)\n\t\t{\n#ifdef FEAT_JOB_CHANNEL\n\t\t    rettv->v_type = VAR_CHANNEL;\n\t\t    rettv->vval.v_channel = NULL;\n#else\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n#endif\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s, \"null_partial\", 12) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_PARTIAL;\n\t\t    rettv->vval.v_partial = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 13: if (STRNCMP(s, \"null_function\", 13) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_FUNC;\n\t\t    rettv->vval.v_string = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n    }\n    return FAIL;\n}\n\n/*\n * Handle sixth level expression:\n *  number\t\tnumber constant\n *  0zFFFFFFFF\t\tBlob constant\n *  \"string\"\t\tstring constant\n *  'string'\t\tliteral string constant\n *  &option-name\toption value\n *  @r\t\t\tregister contents\n *  identifier\t\tvariable value\n *  function()\t\tfunction call\n *  $VAR\t\tenvironment variable\n *  (expression)\tnested expression\n *  [expr, expr]\tList\n *  {arg, arg -> expr}\tLambda\n *  {key: val, key: val}   Dictionary\n *  #{key: val, key: val}  Dictionary with literal keys\n *\n *  Also handle:\n *  ! in front\t\tlogical NOT\n *  - in front\t\tunary minus\n *  + in front\t\tunary plus (ignored)\n *  trailing []\t\tsubscript in String or List\n *  trailing .name\tentry in Dictionary\n *  trailing ->name()\tmethod call\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval9(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    char_u\t*alias;\n    static int\trecurse = 0;\n    int\t\tvim9script = in_vim9script();\n\n    /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n     * string and free a string that isn't there.\n     */\n    rettv->v_type = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, vim9script) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n#endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\treturn FAIL;\n    }\n\n    // Limit recursion to 1000 levels.  At least at 10000 we run out of stack\n    // and crash.  With MSVC the stack is smaller.\n    if (recurse ==\n#ifdef _MSC_VER\n\t\t    300\n#else\n\t\t    1000\n#endif\n\t\t    )\n    {\n\tsemsg(_(e_expression_too_recursive_str), *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"-\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n\t\t    ret = eval9_leader(rettv, TRUE, start_leader, &end_leader);\n\t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"':\tret = eval_string(arg, rettv, evaluate, FALSE);\n\t\tbreak;\n\n    /*\n     * Literal string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg, rettv, evaluate, FALSE);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n    /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (vim9script)\n\t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key': val}\n     */\n    case '{':\tif (vim9script)\n\t\t    ret = NOTDONE;\n\t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, vim9script, evalarg);\n\t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment variable: $VAR.\n     * Interpolated string: $\"string\" or $'string'.\n     */\n    case '$':\tif ((*arg)[1] == '\"' || (*arg)[1] == '\\'')\n\t\t    ret = eval_interp_string(arg, rettv, evaluate);\n\t\telse\n\t\t    ret = eval_env_var(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (vim9script && IS_WHITE_OR_NUL(**arg))\n\t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (vim9script && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\tif (vim9script)\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc, FALSE,\n\t\t\t\t\tget_compile_type(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t{\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg, rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret == OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t{\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t    if (evaluate && vim9script && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\t\tret = FAIL;\n\t    }\n\t    else if (evaluate && vim9script && len > 2\n\t\t\t\t\t\t && s[0] == 's' && s[1] == ':')\n\t    {\n\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str), s);\n\t\tret = FAIL;\n\t    }\n\t    else if ((vim9script ? **arg : *skipwhite(*arg)) == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t    else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\t    {\n\t\t// get the value of \"true\", \"false\", etc. or a variable\n\t\tret = FAIL;\n\t\tif (vim9script)\n\t\t    ret = handle_predefined(s, len, rettv);\n\t\tif (ret == FAIL)\n\t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv, NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret = eval9_leader(rettv, FALSE, start_leader, &end_leader);\n\n    --recurse;\n    return ret;\n}\n\n/*\n * Apply the leading \"!\" and \"-\" before an eval9 expression to \"rettv\".\n * When \"numeric_only\" is TRUE only handle \"+\" and \"-\".\n * Adjusts \"end_leaderp\" until it is at \"start_leader\".\n */\n    static int\neval9_leader(\n\ttypval_T    *rettv,\n\tint\t    numeric_only,\n\tchar_u\t    *start_leader,\n\tchar_u\t    **end_leaderp)\n{\n    char_u\t*end_leader = *end_leaderp;\n    int\t\tret = OK;\n    int\t\terror = FALSE;\n    varnumber_T val = 0;\n    vartype_T\ttype = rettv->v_type;\n    int\t\tvim9script = in_vim9script();\n#ifdef FEAT_FLOAT\n    float_T\t    f = 0.0;\n\n    if (rettv->v_type == VAR_FLOAT)\n\tf = rettv->vval.v_float;\n    else\n#endif\n    {\n\twhile (VIM_ISWHITE(end_leader[-1]))\n\t    --end_leader;\n\tif (vim9script && end_leader[-1] == '!')\n\t    val = tv2bool(rettv);\n\telse\n\t    val = tv_get_number_chk(rettv, &error);\n    }\n    if (error)\n    {\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n    {\n\twhile (end_leader > start_leader)\n\t{\n\t    --end_leader;\n\t    if (*end_leader == '!')\n\t    {\n\t\tif (numeric_only)\n\t\t{\n\t\t    ++end_leader;\n\t\t    break;\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t{\n\t\t    if (vim9script)\n\t\t    {\n\t\t\trettv->v_type = VAR_BOOL;\n\t\t\tval = f == 0.0 ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\tf = !f;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    val = !val;\n\t\t    type = VAR_BOOL;\n\t\t}\n\t    }\n\t    else if (*end_leader == '-')\n\t    {\n#ifdef FEAT_FLOAT\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t    f = -f;\n\t\telse\n#endif\n\t\t{\n\t\t    val = -val;\n\t\t    type = VAR_NUMBER;\n\t\t}\n\t    }\n\t}\n#ifdef FEAT_FLOAT\n\tif (rettv->v_type == VAR_FLOAT)\n\t{\n\t    clear_tv(rettv);\n\t    rettv->vval.v_float = f;\n\t}\n\telse\n#endif\n\t{\n\t    clear_tv(rettv);\n\t    if (vim9script)\n\t\trettv->v_type = type;\n\t    else\n\t\trettv->v_type = VAR_NUMBER;\n\t    rettv->vval.v_number = val;\n\t}\n    }\n    *end_leaderp = end_leader;\n    return ret;\n}\n\n/*\n * Call the function referred to in \"rettv\".\n */\n    static int\ncall_func_rettv(\n\tchar_u\t    **arg,\n\tevalarg_T   *evalarg,\n\ttypval_T    *rettv,\n\tint\t    evaluate,\n\tdict_T\t    *selfdict,\n\ttypval_T    *basetv)\n{\n    partial_T\t*pt = NULL;\n    funcexe_T\tfuncexe;\n    typval_T\tfunctv;\n    char_u\t*s;\n    int\t\tret;\n\n    // need to copy the funcref so that we can clear rettv\n    if (evaluate)\n    {\n\tfunctv = *rettv;\n\trettv->v_type = VAR_UNKNOWN;\n\n\t// Invoke the function.  Recursive!\n\tif (functv.v_type == VAR_PARTIAL)\n\t{\n\t    pt = functv.vval.v_partial;\n\t    s = partial_name(pt);\n\t}\n\telse\n\t{\n\t    s = functv.vval.v_string;\n\t    if (s == NULL || *s == NUL)\n\t    {\n\t\temsg(_(e_empty_function_name));\n\t\tret = FAIL;\n\t\tgoto theend;\n\t    }\n\t}\n    }\n    else\n\ts = (char_u *)\"\";\n\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_firstline = curwin->w_cursor.lnum;\n    funcexe.fe_lastline = curwin->w_cursor.lnum;\n    funcexe.fe_evaluate = evaluate;\n    funcexe.fe_partial = pt;\n    funcexe.fe_selfdict = selfdict;\n    funcexe.fe_basetv = basetv;\n    ret = get_func_tv(s, -1, rettv, arg, evalarg, &funcexe);\n\ntheend:\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&functv);\n\n    return ret;\n}\n\n/*\n * Evaluate \"->method()\".\n * \"*arg\" points to \"method\".\n * Returns FAIL or OK. \"*arg\" is advanced to after the ')'.\n */\n    static int\neval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (**arg == '{')\n    {\n\t// ->{lambda}()\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t// ->(lambda)()\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ')')\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    return FAIL;\n\t}\n\tif (rettv->v_type != VAR_STRING && rettv->v_type != VAR_FUNC\n\t\t\t\t\t       && rettv->v_type != VAR_PARTIAL)\n\t{\n\t    emsg(_(e_string_or_function_required_for_arrow_parens_expr));\n\t    return FAIL;\n\t}\n\t++*arg;\n    }\n    if (ret != OK)\n\treturn FAIL;\n\n    if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n\n    return ret;\n}\n\n/*\n * Evaluate \"->method()\".\n * \"*arg\" points to \"method\".\n * Returns FAIL or OK. \"*arg\" is advanced to after the ')'.\n */\n    static int\neval_method(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    char_u\t*name;\n    long\tlen;\n    char_u\t*alias;\n    char_u\t*tofree = NULL;\n    typval_T\tbase = *rettv;\n    int\t\tret = OK;\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    name = *arg;\n    len = get_name_len(arg, &alias, evaluate, TRUE);\n    if (alias != NULL)\n\tname = alias;\n\n    if (len <= 0)\n    {\n\tif (verbose)\n\t    emsg(_(e_missing_name_after_method));\n\tret = FAIL;\n    }\n    else\n    {\n\tchar_u *paren;\n\n\t// If there is no \"(\" immediately following, but there is further on,\n\t// it can be \"import.Func()\", \"dict.Func()\", \"list[nr]\", etc.\n\t// Does not handle anything where \"(\" is part of the expression.\n\t*arg = skipwhite(*arg);\n\n\tif (**arg != '(' && alias == NULL\n\t\t\t\t    && (paren = vim_strchr(*arg, '(')) != NULL)\n\t{\n\t    char_u *deref;\n\n\t    *arg = name;\n\t    *paren = NUL;\n\t    deref = deref_function_name(arg, &tofree, evalarg, verbose);\n\t    if (deref == NULL)\n\t    {\n\t\t*arg = name + len;\n\t\tret = FAIL;\n\t    }\n\t    else\n\t    {\n\t\tname = deref;\n\t\tlen = (long)STRLEN(name);\n\t    }\n\t    *paren = '(';\n\t}\n\n\tif (ret == OK)\n\t{\n\t    *arg = skipwhite(*arg);\n\n\t    if (**arg != '(')\n\t    {\n\t\tif (verbose)\n\t\t    semsg(_(e_missing_parenthesis_str), name);\n\t\tret = FAIL;\n\t    }\n\t    else if (VIM_ISWHITE((*arg)[-1]))\n\t    {\n\t\tif (verbose)\n\t\t    emsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\tret = FAIL;\n\t    }\n\t    else\n\t\tret = eval_func(arg, evalarg, name, len, rettv,\n\t\t\t\t\t  evaluate ? EVAL_EVALUATE : 0, &base);\n\t}\n    }\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n    vim_free(tofree);\n\n    return ret;\n}\n\n/*\n * Evaluate an \"[expr]\" or \"[expr:expr]\" index.  Also \"dict.key\".\n * \"*arg\" points to the '[' or '.'.\n * Returns FAIL or OK. \"*arg\" is advanced to after the ']'.\n */\n    static int\neval_index(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tempty1 = FALSE, empty2 = FALSE;\n    typval_T\tvar1, var2;\n    int\t\trange = FALSE;\n    char_u\t*key = NULL;\n    int\t\tkeylen = -1;\n    int\t\tvim9script = in_vim9script();\n\n    if (check_can_index(rettv, evaluate, verbose) == FAIL)\n\treturn FAIL;\n\n    init_tv(&var1);\n    init_tv(&var2);\n    if (**arg == '.')\n    {\n\t/*\n\t * dict.name\n\t */\n\tkey = *arg + 1;\n\tfor (keylen = 0; eval_isdictc(key[keylen]); ++keylen)\n\t    ;\n\tif (keylen == 0)\n\t    return FAIL;\n\t*arg = key + keylen;\n    }\n    else\n    {\n\t/*\n\t * something[idx]\n\t *\n\t * Get the (first) variable from inside the [].\n\t */\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\tif (**arg == ':')\n\t    empty1 = TRUE;\n\telse if (eval1(arg, &var1, evalarg) == FAIL)\t// recursive!\n\t    return FAIL;\n\telse if (vim9script && **arg == ':')\n\t{\n\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t    \":\", *arg);\n\t    clear_tv(&var1);\n\t    return FAIL;\n\t}\n\telse if (evaluate)\n\t{\n\t    int error = FALSE;\n\n#ifdef FEAT_FLOAT\n\t    // allow for indexing with float\n\t    if (vim9script && rettv->v_type == VAR_DICT\n\t\t\t\t\t\t   && var1.v_type == VAR_FLOAT)\n\t    {\n\t\tvar1.vval.v_string = typval_tostring(&var1, TRUE);\n\t\tvar1.v_type = VAR_STRING;\n\t    }\n#endif\n\t    if (vim9script && rettv->v_type == VAR_LIST)\n\t\ttv_get_number_chk(&var1, &error);\n\t    else\n\t\terror = tv_get_string_chk(&var1) == NULL;\n\t    if (error)\n\t    {\n\t\t// not a number or string\n\t\tclear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t/*\n\t * Get the second variable from inside the [:].\n\t */\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ':')\n\t{\n\t    range = TRUE;\n\t    ++*arg;\n\t    if (vim9script && !IS_WHITE_OR_NUL(**arg) && **arg != ']')\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t\":\", *arg - 1);\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t    if (**arg == ']')\n\t\tempty2 = TRUE;\n\t    else if (eval1(arg, &var2, evalarg) == FAIL)\t// recursive!\n\t    {\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t    else if (evaluate && tv_get_string_chk(&var2) == NULL)\n\t    {\n\t\t// not a number or string\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\tclear_tv(&var2);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// Check for the ']'.\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ']')\n\t{\n\t    if (verbose)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    clear_tv(&var1);\n\t    if (range)\n\t\tclear_tv(&var2);\n\t    return FAIL;\n\t}\n\t*arg = *arg + 1;\t// skip over the ']'\n    }\n\n    if (evaluate)\n    {\n\tint res = eval_index_inner(rettv, range,\n\t\tempty1 ? NULL : &var1, empty2 ? NULL : &var2, FALSE,\n\t\tkey, keylen, verbose);\n\n\tif (!empty1)\n\t    clear_tv(&var1);\n\tif (range)\n\t    clear_tv(&var2);\n\treturn res;\n    }\n    return OK;\n}\n\n/*\n * Check if \"rettv\" can have an [index] or [sli:ce]\n */\n    int\ncheck_can_index(typval_T *rettv, int evaluate, int verbose)\n{\n    switch (rettv->v_type)\n    {\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\t    if (verbose)\n\t\temsg(_(e_cannot_index_a_funcref));\n\t    return FAIL;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    if (verbose)\n\t\temsg(_(e_using_float_as_string));\n\t    return FAIL;\n#endif\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    if (verbose)\n\t\temsg(_(e_cannot_index_special_variable));\n\t    return FAIL;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    if (evaluate)\n\t    {\n\t\temsg(_(e_cannot_index_special_variable));\n\t\treturn FAIL;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase VAR_STRING:\n\tcase VAR_LIST:\n\tcase VAR_DICT:\n\tcase VAR_BLOB:\n\t    break;\n\tcase VAR_NUMBER:\n\t    if (in_vim9script())\n\t\temsg(_(e_cannot_index_number));\n\t    break;\n    }\n    return OK;\n}\n\n/*\n * slice() function\n */\n    void\nf_slice(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && ((argvars[0].v_type != VAR_STRING\n\t\t    && argvars[0].v_type != VAR_LIST\n\t\t    && argvars[0].v_type != VAR_BLOB\n\t\t    && check_for_list_arg(argvars, 0) == FAIL)\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    if (check_can_index(argvars, TRUE, FALSE) == OK)\n    {\n\tcopy_tv(argvars, rettv);\n\teval_index_inner(rettv, TRUE, argvars + 1,\n\t\targvars[2].v_type == VAR_UNKNOWN ? NULL : argvars + 2,\n\t\tTRUE, NULL, 0, FALSE);\n    }\n}\n\n/*\n * Apply index or range to \"rettv\".\n * \"var1\" is the first index, NULL for [:expr].\n * \"var2\" is the second index, NULL for [expr] and [expr: ]\n * \"exclusive\" is TRUE for slice(): second index is exclusive, use character\n * index for string.\n * Alternatively, \"key\" is not NULL, then key[keylen] is the dict index.\n */\n    int\neval_index_inner(\n\ttypval_T    *rettv,\n\tint\t    is_range,\n\ttypval_T    *var1,\n\ttypval_T    *var2,\n\tint\t    exclusive,\n\tchar_u\t    *key,\n\tint\t    keylen,\n\tint\t    verbose)\n{\n    varnumber_T\t    n1, n2 = 0;\n    long\t    len;\n\n    n1 = 0;\n    if (var1 != NULL && rettv->v_type != VAR_DICT)\n\tn1 = tv_get_number(var1);\n\n    if (is_range)\n    {\n\tif (rettv->v_type == VAR_DICT)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_slice_dictionary));\n\t    return FAIL;\n\t}\n\tif (var2 != NULL)\n\t    n2 = tv_get_number(var2);\n\telse\n\t    n2 = VARNUM_MAX;\n    }\n\n    switch (rettv->v_type)\n    {\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_FLOAT:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    break; // not evaluating, skipping over subscript\n\n\tcase VAR_NUMBER:\n\tcase VAR_STRING:\n\t    {\n\t\tchar_u\t*s = tv_get_string(rettv);\n\n\t\tlen = (long)STRLEN(s);\n\t\tif (in_vim9script() || exclusive)\n\t\t{\n\t\t    if (is_range)\n\t\t\ts = string_slice(s, n1, n2, exclusive);\n\t\t    else\n\t\t\ts = char_from_string(s, n1);\n\t\t}\n\t\telse if (is_range)\n\t\t{\n\t\t    // The resulting variable is a substring.  If the indexes\n\t\t    // are out of range the result is empty.\n\t\t    if (n1 < 0)\n\t\t    {\n\t\t\tn1 = len + n1;\n\t\t\tif (n1 < 0)\n\t\t\t    n1 = 0;\n\t\t    }\n\t\t    if (n2 < 0)\n\t\t\tn2 = len + n2;\n\t\t    else if (n2 >= len)\n\t\t\tn2 = len;\n\t\t    if (n1 >= len || n2 < 0 || n1 > n2)\n\t\t\ts = NULL;\n\t\t    else\n\t\t\ts = vim_strnsave(s + n1, n2 - n1 + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // The resulting variable is a string of a single\n\t\t    // character.  If the index is too big or negative the\n\t\t    // result is empty.\n\t\t    if (n1 >= len || n1 < 0)\n\t\t\ts = NULL;\n\t\t    else\n\t\t\ts = vim_strnsave(s + n1, 1);\n\t\t}\n\t\tclear_tv(rettv);\n\t\trettv->v_type = VAR_STRING;\n\t\trettv->vval.v_string = s;\n\t    }\n\t    break;\n\n\tcase VAR_BLOB:\n\t    blob_slice_or_index(rettv->vval.v_blob, is_range, n1, n2,\n\t\t\t\t\t\t\t     exclusive, rettv);\n\t    break;\n\n\tcase VAR_LIST:\n\t    if (var1 == NULL)\n\t\tn1 = 0;\n\t    if (var2 == NULL)\n\t\tn2 = VARNUM_MAX;\n\t    if (list_slice_or_index(rettv->vval.v_list,\n\t\t\t  is_range, n1, n2, exclusive, rettv, verbose) == FAIL)\n\t\treturn FAIL;\n\t    break;\n\n\tcase VAR_DICT:\n\t    {\n\t\tdictitem_T\t*item;\n\t\ttypval_T\ttmp;\n\n\t\tif (key == NULL)\n\t\t{\n\t\t    key = tv_get_string_chk(var1);\n\t\t    if (key == NULL)\n\t\t\treturn FAIL;\n\t\t}\n\n\t\titem = dict_find(rettv->vval.v_dict, key, keylen);\n\n\t\tif (item == NULL)\n\t\t{\n\t\t    if (verbose)\n\t\t    {\n\t\t\tif (keylen > 0)\n\t\t\t    key[keylen] = NUL;\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\t\t    }\n\t\t    return FAIL;\n\t\t}\n\n\t\tcopy_tv(&item->di_tv, &tmp);\n\t\tclear_tv(rettv);\n\t\t*rettv = tmp;\n\t    }\n\t    break;\n    }\n    return OK;\n}\n\n/*\n * Return the function name of partial \"pt\".\n */\n    char_u *\npartial_name(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (pt->pt_name != NULL)\n\t    return pt->pt_name;\n\tif (pt->pt_func != NULL)\n\t    return pt->pt_func->uf_name;\n    }\n    return (char_u *)\"\";\n}\n\n    static void\npartial_free(partial_T *pt)\n{\n    int i;\n\n    for (i = 0; i < pt->pt_argc; ++i)\n\tclear_tv(&pt->pt_argv[i]);\n    vim_free(pt->pt_argv);\n    dict_unref(pt->pt_dict);\n    if (pt->pt_name != NULL)\n    {\n\tfunc_unref(pt->pt_name);\n\tvim_free(pt->pt_name);\n    }\n    else\n\tfunc_ptr_unref(pt->pt_func);\n\n    // \"out_up\" is no longer used, decrement refcount on partial that owns it.\n    partial_unref(pt->pt_outer.out_up_partial);\n\n    // Using pt_outer from another partial.\n    partial_unref(pt->pt_outer_partial);\n\n    // Decrease the reference count for the context of a closure.  If down\n    // to the minimum it may be time to free it.\n    if (pt->pt_funcstack != NULL)\n    {\n\t--pt->pt_funcstack->fs_refcount;\n\tfuncstack_check_refcount(pt->pt_funcstack);\n    }\n\n    vim_free(pt);\n}\n\n/*\n * Unreference a closure: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\npartial_unref(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (--pt->pt_refcount <= 0)\n\t    partial_free(pt);\n\n\t// If the reference count goes down to one, the funcstack may be the\n\t// only reference and can be freed if no other partials reference it.\n\telse if (pt->pt_refcount == 1 && pt->pt_funcstack != NULL)\n\t    funcstack_check_refcount(pt->pt_funcstack);\n    }\n}\n\n/*\n * Return the next (unique) copy ID.\n * Used for serializing nested structures.\n */\n    int\nget_copyID(void)\n{\n    current_copyID += COPYID_INC;\n    return current_copyID;\n}\n\n/*\n * Garbage collection for lists and dictionaries.\n *\n * We use reference counts to be able to free most items right away when they\n * are no longer used.  But for composite items it's possible that it becomes\n * unused while the reference count is > 0: When there is a recursive\n * reference.  Example:\n *\t:let l = [1, 2, 3]\n *\t:let d = {9: l}\n *\t:let l[1] = d\n *\n * Since this is quite unusual we handle this with garbage collection: every\n * once in a while find out which lists and dicts are not referenced from any\n * variable.\n *\n * Here is a good reference text about garbage collection (refers to Python\n * but it applies to all reference-counting mechanisms):\n *\thttp://python.ca/nas/python/gc/\n */\n\n/*\n * Do garbage collection for lists and dicts.\n * When \"testing\" is TRUE this is called from test_garbagecollect_now().\n * Return TRUE if some memory was freed.\n */\n    int\ngarbage_collect(int testing)\n{\n    int\t\tcopyID;\n    int\t\tabort = FALSE;\n    buf_T\t*buf;\n    win_T\t*wp;\n    int\t\tdid_free = FALSE;\n    tabpage_T\t*tp;\n\n    if (!testing)\n    {\n\t// Only do this once.\n\twant_garbage_collect = FALSE;\n\tmay_garbage_collect = FALSE;\n\tgarbage_collect_at_exit = FALSE;\n    }\n\n    // The execution stack can grow big, limit the size.\n    if (exestack.ga_maxlen - exestack.ga_len > 500)\n    {\n\tsize_t\tnew_len;\n\tchar_u\t*pp;\n\tint\tn;\n\n\t// Keep 150% of the current size, with a minimum of the growth size.\n\tn = exestack.ga_len / 2;\n\tif (n < exestack.ga_growsize)\n\t    n = exestack.ga_growsize;\n\n\t// Don't make it bigger though.\n\tif (exestack.ga_len + n < exestack.ga_maxlen)\n\t{\n\t    new_len = (size_t)exestack.ga_itemsize * (exestack.ga_len + n);\n\t    pp = vim_realloc(exestack.ga_data, new_len);\n\t    if (pp == NULL)\n\t\treturn FAIL;\n\t    exestack.ga_maxlen = exestack.ga_len + n;\n\t    exestack.ga_data = pp;\n\t}\n    }\n\n    // We advance by two because we add one for items referenced through\n    // previous_funccal.\n    copyID = get_copyID();\n\n    /*\n     * 1. Go through all accessible variables and mark all lists and dicts\n     *    with copyID.\n     */\n\n    // Don't free variables in the previous_funccal list unless they are only\n    // referenced through previous_funccal.  This must be first, because if\n    // the item is referenced elsewhere the funccal must not be freed.\n    abort = abort || set_ref_in_previous_funccal(copyID);\n\n    // script-local variables\n    abort = abort || garbage_collect_scriptvars(copyID);\n\n    // buffer-local variables\n    FOR_ALL_BUFFERS(buf)\n\tabort = abort || set_ref_in_item(&buf->b_bufvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n\n    // window-local variables\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    if (aucmd_win != NULL)\n\tabort = abort || set_ref_in_item(&aucmd_win->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    FOR_ALL_TABPAGES(tp)\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n#endif\n\n    // tabpage-local variables\n    FOR_ALL_TABPAGES(tp)\n\tabort = abort || set_ref_in_item(&tp->tp_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    // global variables\n    abort = abort || garbage_collect_globvars(copyID);\n\n    // function-local variables\n    abort = abort || set_ref_in_call_stack(copyID);\n\n    // named functions (matters for closures)\n    abort = abort || set_ref_in_functions(copyID);\n\n    // function call arguments, if v:testing is set.\n    abort = abort || set_ref_in_func_args(copyID);\n\n    // funcstacks keep variables for closures\n    abort = abort || set_ref_in_funcstacks(copyID);\n\n    // v: vars\n    abort = abort || garbage_collect_vimvars(copyID);\n\n    // callbacks in buffers\n    abort = abort || set_ref_in_buffers(copyID);\n\n    // 'completefunc', 'omnifunc' and 'thesaurusfunc' callbacks\n    abort = abort || set_ref_in_insexpand_funcs(copyID);\n\n    // 'operatorfunc' callback\n    abort = abort || set_ref_in_opfunc(copyID);\n\n    // 'tagfunc' callback\n    abort = abort || set_ref_in_tagfunc(copyID);\n\n    // 'imactivatefunc' and 'imstatusfunc' callbacks\n    abort = abort || set_ref_in_im_funcs(copyID);\n\n#ifdef FEAT_LUA\n    abort = abort || set_ref_in_lua(copyID);\n#endif\n\n#ifdef FEAT_PYTHON\n    abort = abort || set_ref_in_python(copyID);\n#endif\n\n#ifdef FEAT_PYTHON3\n    abort = abort || set_ref_in_python3(copyID);\n#endif\n\n#ifdef FEAT_JOB_CHANNEL\n    abort = abort || set_ref_in_channel(copyID);\n    abort = abort || set_ref_in_job(copyID);\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    abort = abort || set_ref_in_nb_channel(copyID);\n#endif\n\n#ifdef FEAT_TIMERS\n    abort = abort || set_ref_in_timer(copyID);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    abort = abort || set_ref_in_quickfix(copyID);\n#endif\n\n#ifdef FEAT_TERMINAL\n    abort = abort || set_ref_in_term(copyID);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    abort = abort || set_ref_in_popups(copyID);\n#endif\n\n    if (!abort)\n    {\n\t/*\n\t * 2. Free lists and dictionaries that are not referenced.\n\t */\n\tdid_free = free_unref_items(copyID);\n\n\t/*\n\t * 3. Check if any funccal can be freed now.\n\t *    This may call us back recursively.\n\t */\n\tfree_unref_funccal(copyID, testing);\n    }\n    else if (p_verbose > 0)\n    {\n\tverb_msg(_(\"Not enough memory to set references, garbage collection aborted!\"));\n    }\n\n    return did_free;\n}\n\n/*\n * Free lists, dictionaries, channels and jobs that are no longer referenced.\n */\n    static int\nfree_unref_items(int copyID)\n{\n    int\t\tdid_free = FALSE;\n\n    // Let all \"free\" functions know that we are here.  This means no\n    // dictionaries, lists, channels or jobs are to be freed, because we will\n    // do that here.\n    in_free_unref_items = TRUE;\n\n    /*\n     * PASS 1: free the contents of the items.  We don't free the items\n     * themselves yet, so that it is possible to decrement refcount counters\n     */\n\n    // Go through the list of dicts and free items without the copyID.\n    did_free |= dict_free_nonref(copyID);\n\n    // Go through the list of lists and free items without the copyID.\n    did_free |= list_free_nonref(copyID);\n\n#ifdef FEAT_JOB_CHANNEL\n    // Go through the list of jobs and free items without the copyID. This\n    // must happen before doing channels, because jobs refer to channels, but\n    // the reference from the channel to the job isn't tracked.\n    did_free |= free_unused_jobs_contents(copyID, COPYID_MASK);\n\n    // Go through the list of channels and free items without the copyID.\n    did_free |= free_unused_channels_contents(copyID, COPYID_MASK);\n#endif\n\n    /*\n     * PASS 2: free the items themselves.\n     */\n    dict_free_items(copyID);\n    list_free_items(copyID);\n\n#ifdef FEAT_JOB_CHANNEL\n    // Go through the list of jobs and free items without the copyID. This\n    // must happen before doing channels, because jobs refer to channels, but\n    // the reference from the channel to the job isn't tracked.\n    free_unused_jobs(copyID, COPYID_MASK);\n\n    // Go through the list of channels and free items without the copyID.\n    free_unused_channels(copyID, COPYID_MASK);\n#endif\n\n    in_free_unref_items = FALSE;\n\n    return did_free;\n}\n\n/*\n * Mark all lists and dicts referenced through hashtab \"ht\" with \"copyID\".\n * \"list_stack\" is used to add lists to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack)\n{\n    int\t\ttodo;\n    int\t\tabort = FALSE;\n    hashitem_T\t*hi;\n    hashtab_T\t*cur_ht;\n    ht_stack_T\t*ht_stack = NULL;\n    ht_stack_T\t*tempitem;\n\n    cur_ht = ht;\n    for (;;)\n    {\n\tif (!abort)\n\t{\n\t    // Mark each item in the hashtab.  If the item contains a hashtab\n\t    // it is added to ht_stack, if it contains a list it is added to\n\t    // list_stack.\n\t    todo = (int)cur_ht->ht_used;\n\t    for (hi = cur_ht->ht_array; todo > 0; ++hi)\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    --todo;\n\t\t    abort = abort || set_ref_in_item(&HI2DI(hi)->di_tv, copyID,\n\t\t\t\t\t\t       &ht_stack, list_stack);\n\t\t}\n\t}\n\n\tif (ht_stack == NULL)\n\t    break;\n\n\t// take an item from the stack\n\tcur_ht = ht_stack->ht;\n\ttempitem = ht_stack;\n\tht_stack = ht_stack->prev;\n\tfree(tempitem);\n    }\n\n    return abort;\n}\n\n#if defined(FEAT_LUA) || defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) \\\n\t\t\t\t\t\t\t|| defined(PROTO)\n/*\n * Mark a dict and its items with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_dict(dict_T *d, int copyID)\n{\n    if (d != NULL && d->dv_copyID != copyID)\n    {\n\td->dv_copyID = copyID;\n\treturn set_ref_in_ht(&d->dv_hashtab, copyID, NULL);\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Mark a list and its items with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_list(list_T *ll, int copyID)\n{\n    if (ll != NULL && ll->lv_copyID != copyID)\n    {\n\tll->lv_copyID = copyID;\n\treturn set_ref_in_list_items(ll, copyID, NULL);\n    }\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through list \"l\" with \"copyID\".\n * \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_list_items(list_T *l, int copyID, ht_stack_T **ht_stack)\n{\n    listitem_T\t *li;\n    int\t\t abort = FALSE;\n    list_T\t *cur_l;\n    list_stack_T *list_stack = NULL;\n    list_stack_T *tempitem;\n\n    cur_l = l;\n    for (;;)\n    {\n\tif (!abort && cur_l->lv_first != &range_list_item)\n\t    // Mark each item in the list.  If the item contains a hashtab\n\t    // it is added to ht_stack, if it contains a list it is added to\n\t    // list_stack.\n\t    for (li = cur_l->lv_first; !abort && li != NULL; li = li->li_next)\n\t\tabort = abort || set_ref_in_item(&li->li_tv, copyID,\n\t\t\t\t\t\t       ht_stack, &list_stack);\n\tif (list_stack == NULL)\n\t    break;\n\n\t// take an item from the stack\n\tcur_l = list_stack->list;\n\ttempitem = list_stack;\n\tlist_stack = list_stack->prev;\n\tfree(tempitem);\n    }\n\n    return abort;\n}\n\n/*\n * Mark the partial in callback 'cb' with \"copyID\".\n */\n    int\nset_ref_in_callback(callback_T *cb, int copyID)\n{\n    typval_T tv;\n\n    if (cb->cb_name == NULL || *cb->cb_name == NUL || cb->cb_partial == NULL)\n\treturn FALSE;\n\n    tv.v_type = VAR_PARTIAL;\n    tv.vval.v_partial = cb->cb_partial;\n    return set_ref_in_item(&tv, copyID, NULL, NULL);\n}\n\n/*\n * Mark all lists and dicts referenced through typval \"tv\" with \"copyID\".\n * \"list_stack\" is used to add lists to be marked.  Can be NULL.\n * \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_item(\n    typval_T\t    *tv,\n    int\t\t    copyID,\n    ht_stack_T\t    **ht_stack,\n    list_stack_T    **list_stack)\n{\n    int\t\tabort = FALSE;\n\n    if (tv->v_type == VAR_DICT)\n    {\n\tdict_T\t*dd = tv->vval.v_dict;\n\n\tif (dd != NULL && dd->dv_copyID != copyID)\n\t{\n\t    // Didn't see this dict yet.\n\t    dd->dv_copyID = copyID;\n\t    if (ht_stack == NULL)\n\t    {\n\t\tabort = set_ref_in_ht(&dd->dv_hashtab, copyID, list_stack);\n\t    }\n\t    else\n\t    {\n\t\tht_stack_T *newitem = ALLOC_ONE(ht_stack_T);\n\n\t\tif (newitem == NULL)\n\t\t    abort = TRUE;\n\t\telse\n\t\t{\n\t\t    newitem->ht = &dd->dv_hashtab;\n\t\t    newitem->prev = *ht_stack;\n\t\t    *ht_stack = newitem;\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_LIST)\n    {\n\tlist_T\t*ll = tv->vval.v_list;\n\n\tif (ll != NULL && ll->lv_copyID != copyID)\n\t{\n\t    // Didn't see this list yet.\n\t    ll->lv_copyID = copyID;\n\t    if (list_stack == NULL)\n\t    {\n\t\tabort = set_ref_in_list_items(ll, copyID, ht_stack);\n\t    }\n\t    else\n\t    {\n\t\tlist_stack_T *newitem = ALLOC_ONE(list_stack_T);\n\n\t\tif (newitem == NULL)\n\t\t    abort = TRUE;\n\t\telse\n\t\t{\n\t\t    newitem->list = ll;\n\t\t    newitem->prev = *list_stack;\n\t\t    *list_stack = newitem;\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_FUNC)\n    {\n\tabort = set_ref_in_func(tv->vval.v_string, NULL, copyID);\n    }\n    else if (tv->v_type == VAR_PARTIAL)\n    {\n\tpartial_T\t*pt = tv->vval.v_partial;\n\tint\t\ti;\n\n\tif (pt != NULL && pt->pt_copyID != copyID)\n\t{\n\t    // Didn't see this partial yet.\n\t    pt->pt_copyID = copyID;\n\n\t    abort = set_ref_in_func(pt->pt_name, pt->pt_func, copyID);\n\n\t    if (pt->pt_dict != NULL)\n\t    {\n\t\ttypval_T dtv;\n\n\t\tdtv.v_type = VAR_DICT;\n\t\tdtv.vval.v_dict = pt->pt_dict;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\n\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\tabort = abort || set_ref_in_item(&pt->pt_argv[i], copyID,\n\t\t\t\t\t\t\tht_stack, list_stack);\n\t    // pt_funcstack is handled in set_ref_in_funcstacks()\n\t}\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (tv->v_type == VAR_JOB)\n    {\n\tjob_T\t    *job = tv->vval.v_job;\n\ttypval_T    dtv;\n\n\tif (job != NULL && job->jv_copyID != copyID)\n\t{\n\t    job->jv_copyID = copyID;\n\t    if (job->jv_channel != NULL)\n\t    {\n\t\tdtv.v_type = VAR_CHANNEL;\n\t\tdtv.vval.v_channel = job->jv_channel;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t    if (job->jv_exit_cb.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = job->jv_exit_cb.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_CHANNEL)\n    {\n\tchannel_T   *ch =tv->vval.v_channel;\n\tch_part_T   part;\n\ttypval_T    dtv;\n\tjsonq_T\t    *jq;\n\tcbq_T\t    *cq;\n\n\tif (ch != NULL && ch->ch_copyID != copyID)\n\t{\n\t    ch->ch_copyID = copyID;\n\t    for (part = PART_SOCK; part < PART_COUNT; ++part)\n\t    {\n\t\tfor (jq = ch->ch_part[part].ch_json_head.jq_next; jq != NULL;\n\t\t\t\t\t\t\t     jq = jq->jq_next)\n\t\t    set_ref_in_item(jq->jq_value, copyID, ht_stack, list_stack);\n\t\tfor (cq = ch->ch_part[part].ch_cb_head.cq_next; cq != NULL;\n\t\t\t\t\t\t\t     cq = cq->cq_next)\n\t\t    if (cq->cq_callback.cb_partial != NULL)\n\t\t    {\n\t\t\tdtv.v_type = VAR_PARTIAL;\n\t\t\tdtv.vval.v_partial = cq->cq_callback.cb_partial;\n\t\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t\t    }\n\t\tif (ch->ch_part[part].ch_callback.cb_partial != NULL)\n\t\t{\n\t\t    dtv.v_type = VAR_PARTIAL;\n\t\t    dtv.vval.v_partial =\n\t\t\t\t      ch->ch_part[part].ch_callback.cb_partial;\n\t\t    set_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t\t}\n\t    }\n\t    if (ch->ch_callback.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = ch->ch_callback.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t    if (ch->ch_close_cb.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = ch->ch_close_cb.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t}\n    }\n#endif\n    return abort;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * When \"copyID\" is not NULL replace recursive lists and dicts with \"...\".\n * When both \"echo_style\" and \"composite_val\" are FALSE, put quotes around\n * strings as \"string()\", otherwise does not put quotes around strings, as\n * \":echo\" displays values.\n * When \"restore_copyID\" is FALSE, repeated items in dictionaries and lists\n * are replaced with \"...\".\n * May return NULL.\n */\n    char_u *\necho_string_core(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID,\n    int\t\techo_style,\n    int\t\trestore_copyID,\n    int\t\tcomposite_val)\n{\n    static int\trecurse = 0;\n    char_u\t*r = NULL;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\tif (!did_echo_string_emsg)\n\t{\n\t    // Only give this message once for a recursive call to avoid\n\t    // flooding the user with errors.  And stop iterating over lists\n\t    // and dicts.\n\t    did_echo_string_emsg = TRUE;\n\t    emsg(_(e_variable_nested_too_deep_for_displaying));\n\t}\n\t*tofree = NULL;\n\treturn (char_u *)\"{E724}\";\n    }\n    ++recurse;\n\n    switch (tv->v_type)\n    {\n\tcase VAR_STRING:\n\t    if (echo_style && !composite_val)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = tv->vval.v_string;\n\t\tif (r == NULL)\n\t\t    r = (char_u *)\"\";\n\t    }\n\t    else\n\t    {\n\t\t*tofree = string_quote(tv->vval.v_string, FALSE);\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_FUNC:\n\t    {\n\t\tchar_u buf[MAX_FUNC_NAME_LEN];\n\n\t\tif (echo_style)\n\t\t{\n\t\t    r = tv->vval.v_string == NULL ? (char_u *)\"function()\"\n\t\t\t\t  : make_ufunc_name_readable(tv->vval.v_string,\n\t\t\t\t\t\t       buf, MAX_FUNC_NAME_LEN);\n\t\t    if (r == buf)\n\t\t    {\n\t\t\tr = vim_strsave(buf);\n\t\t\t*tofree = r;\n\t\t    }\n\t\t    else\n\t\t\t*tofree = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *tofree = string_quote(tv->vval.v_string == NULL ? NULL\n\t\t\t    : make_ufunc_name_readable(\n\t\t\t\ttv->vval.v_string, buf, MAX_FUNC_NAME_LEN),\n\t\t\t\t\t\t\t\t\t TRUE);\n\t\t    r = *tofree;\n\t\t}\n\t    }\n\t    break;\n\n\tcase VAR_PARTIAL:\n\t    {\n\t\tpartial_T   *pt = tv->vval.v_partial;\n\t\tchar_u\t    *fname = string_quote(pt == NULL ? NULL\n\t\t\t\t\t\t    : partial_name(pt), FALSE);\n\t\tgarray_T    ga;\n\t\tint\t    i;\n\t\tchar_u\t    *tf;\n\n\t\tga_init2(&ga, 1, 100);\n\t\tga_concat(&ga, (char_u *)\"function(\");\n\t\tif (fname != NULL)\n\t\t{\n\t\t    // When using uf_name prepend \"g:\" for a global function.\n\t\t    if (pt != NULL && pt->pt_name == NULL && fname[0] == '\\''\n\t\t\t\t\t\t      && vim_isupper(fname[1]))\n\t\t    {\n\t\t\tga_concat(&ga, (char_u *)\"'g:\");\n\t\t\tga_concat(&ga, fname + 1);\n\t\t    }\n\t\t    else\n\t\t\tga_concat(&ga, fname);\n\t\t    vim_free(fname);\n\t\t}\n\t\tif (pt != NULL && pt->pt_argc > 0)\n\t\t{\n\t\t    ga_concat(&ga, (char_u *)\", [\");\n\t\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ga_concat(&ga, (char_u *)\", \");\n\t\t\tga_concat(&ga,\n\t\t\t     tv2string(&pt->pt_argv[i], &tf, numbuf, copyID));\n\t\t\tvim_free(tf);\n\t\t    }\n\t\t    ga_concat(&ga, (char_u *)\"]\");\n\t\t}\n\t\tif (pt != NULL && pt->pt_dict != NULL)\n\t\t{\n\t\t    typval_T dtv;\n\n\t\t    ga_concat(&ga, (char_u *)\", \");\n\t\t    dtv.v_type = VAR_DICT;\n\t\t    dtv.vval.v_dict = pt->pt_dict;\n\t\t    ga_concat(&ga, tv2string(&dtv, &tf, numbuf, copyID));\n\t\t    vim_free(tf);\n\t\t}\n\t\t// terminate with ')' and a NUL\n\t\tga_concat_len(&ga, (char_u *)\")\", 2);\n\n\t\t*tofree = ga.ga_data;\n\t\tr = *tofree;\n\t\tbreak;\n\t    }\n\n\tcase VAR_BLOB:\n\t    r = blob2string(tv->vval.v_blob, tofree, numbuf);\n\t    break;\n\n\tcase VAR_LIST:\n\t    if (tv->vval.v_list == NULL)\n\t    {\n\t\t// NULL list is equivalent to empty list.\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"[]\";\n\t    }\n\t    else if (copyID != 0 && tv->vval.v_list->lv_copyID == copyID\n\t\t    && tv->vval.v_list->lv_len > 0)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"[...]\";\n\t    }\n\t    else\n\t    {\n\t\tint old_copyID = tv->vval.v_list->lv_copyID;\n\n\t\ttv->vval.v_list->lv_copyID = copyID;\n\t\t*tofree = list2string(tv, copyID, restore_copyID);\n\t\tif (restore_copyID)\n\t\t    tv->vval.v_list->lv_copyID = old_copyID;\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_DICT:\n\t    if (tv->vval.v_dict == NULL)\n\t    {\n\t\t// NULL dict is equivalent to empty dict.\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"{}\";\n\t    }\n\t    else if (copyID != 0 && tv->vval.v_dict->dv_copyID == copyID\n\t\t    && tv->vval.v_dict->dv_hashtab.ht_used != 0)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"{...}\";\n\t    }\n\t    else\n\t    {\n\t\tint old_copyID = tv->vval.v_dict->dv_copyID;\n\n\t\ttv->vval.v_dict->dv_copyID = copyID;\n\t\t*tofree = dict2string(tv, copyID, restore_copyID);\n\t\tif (restore_copyID)\n\t\t    tv->vval.v_dict->dv_copyID = old_copyID;\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_NUMBER:\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    *tofree = NULL;\n\t    r = tv_get_string_buf(tv, numbuf);\n\t    break;\n\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    *tofree = NULL;\n\t    r = tv->v_type == VAR_JOB ? job_to_string_buf(tv, numbuf)\n\t\t\t\t\t   : channel_to_string_buf(tv, numbuf);\n\t    if (composite_val)\n\t    {\n\t\t*tofree = string_quote(r, FALSE);\n\t\tr = *tofree;\n\t    }\n#endif\n\t    break;\n\n\tcase VAR_INSTR:\n\t    *tofree = NULL;\n\t    r = (char_u *)\"instructions\";\n\t    break;\n\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    *tofree = NULL;\n\t    vim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);\n\t    r = numbuf;\n\t    break;\n#endif\n\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    *tofree = NULL;\n\t    r = (char_u *)get_var_special_name(tv->vval.v_number);\n\t    break;\n    }\n\n    if (--recurse == 0)\n\tdid_echo_string_emsg = FALSE;\n    return r;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * Does not put quotes around strings, as \":echo\" displays values.\n * When \"copyID\" is not NULL replace recursive lists and dicts with \"...\".\n * May return NULL.\n */\n    char_u *\necho_string(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID)\n{\n    return echo_string_core(tv, tofree, numbuf, copyID, TRUE, FALSE, FALSE);\n}\n\n/*\n * Convert the specified byte index of line 'lnum' in buffer 'buf' to a\n * character index.  Works only for loaded buffers. Returns -1 on failure.\n * The index of the first byte and the first character is zero.\n */\n    int\nbuf_byteidx_to_charidx(buf_T *buf, int lnum, int byteidx)\n{\n    char_u\t*str;\n    char_u\t*t;\n    int\t\tcount;\n\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\treturn -1;\n\n    if (lnum > buf->b_ml.ml_line_count)\n\tlnum = buf->b_ml.ml_line_count;\n\n    str = ml_get_buf(buf, lnum, FALSE);\n    if (str == NULL)\n\treturn -1;\n\n    if (*str == NUL)\n\treturn 0;\n\n    // count the number of characters\n    t = str;\n    for (count = 0; *t != NUL && t <= str + byteidx; count++)\n\tt += mb_ptr2len(t);\n\n    // In insert mode, when the cursor is at the end of a non-empty line,\n    // byteidx points to the NUL character immediately past the end of the\n    // string. In this case, add one to the character count.\n    if (*t == NUL && byteidx != 0 && t == str + byteidx)\n\tcount++;\n\n    return count - 1;\n}\n\n/*\n * Convert the specified character index of line 'lnum' in buffer 'buf' to a\n * byte index.  Works only for loaded buffers. Returns -1 on failure.\n * The index of the first byte and the first character is zero.\n */\n    int\nbuf_charidx_to_byteidx(buf_T *buf, int lnum, int charidx)\n{\n    char_u\t*str;\n    char_u\t*t;\n\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\treturn -1;\n\n    if (lnum > buf->b_ml.ml_line_count)\n\tlnum = buf->b_ml.ml_line_count;\n\n    str = ml_get_buf(buf, lnum, FALSE);\n    if (str == NULL)\n\treturn -1;\n\n    // Convert the character offset to a byte offset\n    t = str;\n    while (*t != NUL && --charidx > 0)\n\tt += mb_ptr2len(t);\n\n    return t - str;\n}\n\n/*\n * Translate a String variable into a position.\n * Returns NULL when there is an error.\n */\n    pos_T *\nvar2fpos(\n    typval_T\t*varp,\n    int\t\tdollar_lnum,\t// TRUE when $ is last line\n    int\t\t*fnum,\t\t// set to fnum for '0, 'A, etc.\n    int\t\tcharcol)\t// return character column\n{\n    char_u\t\t*name;\n    static pos_T\tpos;\n    pos_T\t\t*pp;\n\n    // Argument can be [lnum, col, coladd].\n    if (varp->v_type == VAR_LIST)\n    {\n\tlist_T\t\t*l;\n\tint\t\tlen;\n\tint\t\terror = FALSE;\n\tlistitem_T\t*li;\n\n\tl = varp->vval.v_list;\n\tif (l == NULL)\n\t    return NULL;\n\n\t// Get the line number\n\tpos.lnum = list_find_nr(l, 0L, &error);\n\tif (error || pos.lnum <= 0 || pos.lnum > curbuf->b_ml.ml_line_count)\n\t    return NULL;\t// invalid line number\n\tif (charcol)\n\t    len = (long)mb_charlen(ml_get(pos.lnum));\n\telse\n\t    len = (long)STRLEN(ml_get(pos.lnum));\n\n\t// Get the column number\n\t// We accept \"$\" for the column number: last column.\n\tli = list_find(l, 1L);\n\tif (li != NULL && li->li_tv.v_type == VAR_STRING\n\t\t&& li->li_tv.vval.v_string != NULL\n\t\t&& STRCMP(li->li_tv.vval.v_string, \"$\") == 0)\n\t{\n\t    pos.col = len + 1;\n\t}\n\telse\n\t{\n\t    pos.col = list_find_nr(l, 1L, &error);\n\t    if (error)\n\t\treturn NULL;\n\t}\n\n\t// Accept a position up to the NUL after the line.\n\tif (pos.col == 0 || (int)pos.col > len + 1)\n\t    return NULL;\t// invalid column number\n\t--pos.col;\n\n\t// Get the virtual offset.  Defaults to zero.\n\tpos.coladd = list_find_nr(l, 2L, &error);\n\tif (error)\n\t    pos.coladd = 0;\n\n\treturn &pos;\n    }\n\n    if (in_vim9script() && check_for_string_arg(varp, 0) == FAIL)\n\treturn NULL;\n\n    name = tv_get_string_chk(varp);\n    if (name == NULL)\n\treturn NULL;\n\n    pos.lnum = 0;\n    if (name[0] == '.' && (!in_vim9script() || name[1] == NUL))\n    {\n\t// cursor\n\tpos = curwin->w_cursor;\n    }\n    else if (name[0] == 'v' && name[1] == NUL)\n    {\n\t// Visual start\n\tif (VIsual_active)\n\t    pos = VIsual;\n\telse\n\t    pos = curwin->w_cursor;\n    }\n    else if (name[0] == '\\'' && (!in_vim9script()\n\t\t\t\t\t|| (name[1] != NUL && name[2] == NUL)))\n    {\n\t// mark\n\tpp = getmark_buf_fnum(curbuf, name[1], FALSE, fnum);\n\tif (pp == NULL || pp == (pos_T *)-1 || pp->lnum <= 0)\n\t    return NULL;\n\tpos = *pp;\n    }\n    if (pos.lnum != 0)\n    {\n\tif (charcol)\n\t    pos.col = buf_byteidx_to_charidx(curbuf, pos.lnum, pos.col);\n\treturn &pos;\n    }\n\n    pos.coladd = 0;\n\n    if (name[0] == 'w' && dollar_lnum)\n    {\n\tpos.col = 0;\n\tif (name[1] == '0')\t\t// \"w0\": first visible line\n\t{\n\t    update_topline();\n\t    // In silent Ex mode topline is zero, but that's not a valid line\n\t    // number; use one instead.\n\t    pos.lnum = curwin->w_topline > 0 ? curwin->w_topline : 1;\n\t    return &pos;\n\t}\n\telse if (name[1] == '$')\t// \"w$\": last visible line\n\t{\n\t    validate_botline();\n\t    // In silent Ex mode botline is zero, return zero then.\n\t    pos.lnum = curwin->w_botline > 0 ? curwin->w_botline - 1 : 0;\n\t    return &pos;\n\t}\n    }\n    else if (name[0] == '$')\t\t// last column or line\n    {\n\tif (dollar_lnum)\n\t{\n\t    pos.lnum = curbuf->b_ml.ml_line_count;\n\t    pos.col = 0;\n\t}\n\telse\n\t{\n\t    pos.lnum = curwin->w_cursor.lnum;\n\t    if (charcol)\n\t\tpos.col = (colnr_T)mb_charlen(ml_get_curline());\n\t    else\n\t\tpos.col = (colnr_T)STRLEN(ml_get_curline());\n\t}\n\treturn &pos;\n    }\n    if (in_vim9script())\n\tsemsg(_(e_invalid_value_for_line_number_str), name);\n    return NULL;\n}\n\n/*\n * Convert list in \"arg\" into a position and optional file number.\n * When \"fnump\" is NULL there is no file number, only 3 items.\n * Note that the column is passed on as-is, the caller may want to decrement\n * it to use 1 for the first column.\n * Return FAIL when conversion is not possible, doesn't check the position for\n * validity.\n */\n    int\nlist2fpos(\n    typval_T\t*arg,\n    pos_T\t*posp,\n    int\t\t*fnump,\n    colnr_T\t*curswantp,\n    int\t\tcharcol)\n{\n    list_T\t*l = arg->vval.v_list;\n    long\ti = 0;\n    long\tn;\n\n    // List must be: [fnum, lnum, col, coladd, curswant], where \"fnum\" is only\n    // there when \"fnump\" isn't NULL; \"coladd\" and \"curswant\" are optional.\n    if (arg->v_type != VAR_LIST\n\t    || l == NULL\n\t    || l->lv_len < (fnump == NULL ? 2 : 3)\n\t    || l->lv_len > (fnump == NULL ? 4 : 5))\n\treturn FAIL;\n\n    if (fnump != NULL)\n    {\n\tn = list_find_nr(l, i++, NULL);\t// fnum\n\tif (n < 0)\n\t    return FAIL;\n\tif (n == 0)\n\t    n = curbuf->b_fnum;\t\t// current buffer\n\t*fnump = n;\n    }\n\n    n = list_find_nr(l, i++, NULL);\t// lnum\n    if (n < 0)\n\treturn FAIL;\n    posp->lnum = n;\n\n    n = list_find_nr(l, i++, NULL);\t// col\n    if (n < 0)\n\treturn FAIL;\n    // If character position is specified, then convert to byte position\n    if (charcol)\n    {\n\tbuf_T\t*buf;\n\n\t// Get the text for the specified line in a loaded buffer\n\tbuf = buflist_findnr(fnump == NULL ? curbuf->b_fnum : *fnump);\n\tif (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\t    return FAIL;\n\n\tn = buf_charidx_to_byteidx(buf, posp->lnum, n) + 1;\n    }\n    posp->col = n;\n\n    n = list_find_nr(l, i, NULL);\t// off\n    if (n < 0)\n\tposp->coladd = 0;\n    else\n\tposp->coladd = n;\n\n    if (curswantp != NULL)\n\t*curswantp = list_find_nr(l, i + 1, NULL);  // curswant\n\n    return OK;\n}\n\n/*\n * Get the length of an environment variable name.\n * Advance \"arg\" to the first character after the name.\n * Return 0 for error.\n */\n    int\nget_env_len(char_u **arg)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    for (p = *arg; vim_isIDc(*p); ++p)\n\t;\n    if (p == *arg)\t    // no name found\n\treturn 0;\n\n    len = (int)(p - *arg);\n    *arg = p;\n    return len;\n}\n\n/*\n * Get the length of the name of a function or internal variable.\n * \"arg\" is advanced to after the name.\n * Return 0 if something is wrong.\n */\n    int\nget_id_len(char_u **arg)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    // Find the end of the name.\n    for (p = *arg; eval_isnamec(*p); ++p)\n    {\n\tif (*p == ':')\n\t{\n\t    // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n\t    // slice \"[n:]\".  Also \"xx:\" is not a namespace.\n\t    len = (int)(p - *arg);\n\t    if ((len == 1 && vim_strchr(NAMESPACE_CHAR, **arg) == NULL)\n\t\t    || len > 1)\n\t\tbreak;\n\t}\n    }\n    if (p == *arg)\t    // no name found\n\treturn 0;\n\n    len = (int)(p - *arg);\n    *arg = p;\n\n    return len;\n}\n\n/*\n * Get the length of the name of a variable or function.\n * Only the name is recognized, does not handle \".key\" or \"[idx]\".\n * \"arg\" is advanced to the first non-white character after the name.\n * Return -1 if curly braces expansion failed.\n * Return 0 if something else is wrong.\n * If the name contains 'magic' {}'s, expand them and return the\n * expanded name in an allocated string via 'alias' - caller must free.\n */\n    int\nget_name_len(\n    char_u\t**arg,\n    char_u\t**alias,\n    int\t\tevaluate,\n    int\t\tverbose)\n{\n    int\t\tlen;\n    char_u\t*p;\n    char_u\t*expr_start;\n    char_u\t*expr_end;\n\n    *alias = NULL;  // default to no alias\n\n    if ((*arg)[0] == K_SPECIAL && (*arg)[1] == KS_EXTRA\n\t\t\t\t\t\t  && (*arg)[2] == (int)KE_SNR)\n    {\n\t// hard coded <SNR>, already translated\n\t*arg += 3;\n\treturn get_id_len(arg) + 3;\n    }\n    len = eval_fname_script(*arg);\n    if (len > 0)\n    {\n\t// literal \"<SID>\", \"s:\" or \"<SNR>\"\n\t*arg += len;\n    }\n\n    /*\n     * Find the end of the name; check for {} construction.\n     */\n    p = find_name_end(*arg, &expr_start, &expr_end,\n\t\t\t\t\t       len > 0 ? 0 : FNE_CHECK_START);\n    if (expr_start != NULL)\n    {\n\tchar_u\t*temp_string;\n\n\tif (!evaluate)\n\t{\n\t    len += (int)(p - *arg);\n\t    *arg = skipwhite(p);\n\t    return len;\n\t}\n\n\t/*\n\t * Include any <SID> etc in the expanded string:\n\t * Thus the -len here.\n\t */\n\ttemp_string = make_expanded_name(*arg - len, expr_start, expr_end, p);\n\tif (temp_string == NULL)\n\t    return -1;\n\t*alias = temp_string;\n\t*arg = skipwhite(p);\n\treturn (int)STRLEN(temp_string);\n    }\n\n    len += get_id_len(arg);\n    // Only give an error when there is something, otherwise it will be\n    // reported at a higher level.\n    if (len == 0 && verbose && **arg != NUL)\n\tsemsg(_(e_invalid_expression_str), *arg);\n\n    return len;\n}\n\n/*\n * Find the end of a variable or function name, taking care of magic braces.\n * If \"expr_start\" is not NULL then \"expr_start\" and \"expr_end\" are set to the\n * start and end of the first magic braces item.\n * \"flags\" can have FNE_INCL_BR and FNE_CHECK_START.\n * Return a pointer to just after the name.  Equal to \"arg\" if there is no\n * valid name.\n */\n    char_u *\nfind_name_end(\n    char_u\t*arg,\n    char_u\t**expr_start,\n    char_u\t**expr_end,\n    int\t\tflags)\n{\n    int\t\tmb_nest = 0;\n    int\t\tbr_nest = 0;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tvim9script = in_vim9script();\n\n    if (expr_start != NULL)\n    {\n\t*expr_start = NULL;\n\t*expr_end = NULL;\n    }\n\n    // Quick check for valid starting character.\n    if ((flags & FNE_CHECK_START) && !eval_isnamec1(*arg)\n\t\t\t\t\t\t&& (*arg != '{' || vim9script))\n\treturn arg;\n\n    for (p = arg; *p != NUL\n\t\t    && (eval_isnamec(*p)\n\t\t\t|| (*p == '{' && !vim9script)\n\t\t\t|| ((flags & FNE_INCL_BR) && (*p == '['\n\t\t\t\t\t || (*p == '.' && eval_isdictc(p[1]))))\n\t\t\t|| mb_nest != 0\n\t\t\t|| br_nest != 0); MB_PTR_ADV(p))\n    {\n\tif (*p == '\\'')\n\t{\n\t    // skip over 'string' to avoid counting [ and ] inside it.\n\t    for (p = p + 1; *p != NUL && *p != '\\''; MB_PTR_ADV(p))\n\t\t;\n\t    if (*p == NUL)\n\t\tbreak;\n\t}\n\telse if (*p == '\"')\n\t{\n\t    // skip over \"str\\\"ing\" to avoid counting [ and ] inside it.\n\t    for (p = p + 1; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n\t\tif (*p == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t}\n\telse if (br_nest == 0 && mb_nest == 0 && *p == ':')\n\t{\n\t    // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n\t    // slice \"[n:]\".  Also \"xx:\" is not a namespace. But {ns}: is.\n\t    len = (int)(p - arg);\n\t    if ((len == 1 && vim_strchr(NAMESPACE_CHAR, *arg) == NULL)\n\t\t    || (len > 1 && p[-1] != '}'))\n\t\tbreak;\n\t}\n\n\tif (mb_nest == 0)\n\t{\n\t    if (*p == '[')\n\t\t++br_nest;\n\t    else if (*p == ']')\n\t\t--br_nest;\n\t}\n\n\tif (br_nest == 0 && !vim9script)\n\t{\n\t    if (*p == '{')\n\t    {\n\t\tmb_nest++;\n\t\tif (expr_start != NULL && *expr_start == NULL)\n\t\t    *expr_start = p;\n\t    }\n\t    else if (*p == '}')\n\t    {\n\t\tmb_nest--;\n\t\tif (expr_start != NULL && mb_nest == 0 && *expr_end == NULL)\n\t\t    *expr_end = p;\n\t    }\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Expands out the 'magic' {}'s in a variable/function name.\n * Note that this can call itself recursively, to deal with\n * constructs like foo{bar}{baz}{bam}\n * The four pointer arguments point to \"foo{expre}ss{ion}bar\"\n *\t\t\t\"in_start\"      ^\n *\t\t\t\"expr_start\"\t   ^\n *\t\t\t\"expr_end\"\t\t ^\n *\t\t\t\"in_end\"\t\t\t    ^\n *\n * Returns a new allocated string, which the caller must free.\n * Returns NULL for failure.\n */\n    static char_u *\nmake_expanded_name(\n    char_u\t*in_start,\n    char_u\t*expr_start,\n    char_u\t*expr_end,\n    char_u\t*in_end)\n{\n    char_u\tc1;\n    char_u\t*retval = NULL;\n    char_u\t*temp_result;\n\n    if (expr_end == NULL || in_end == NULL)\n\treturn NULL;\n    *expr_start\t= NUL;\n    *expr_end = NUL;\n    c1 = *in_end;\n    *in_end = NUL;\n\n    temp_result = eval_to_string(expr_start + 1, FALSE);\n    if (temp_result != NULL)\n    {\n\tretval = alloc(STRLEN(temp_result) + (expr_start - in_start)\n\t\t\t\t\t\t   + (in_end - expr_end) + 1);\n\tif (retval != NULL)\n\t{\n\t    STRCPY(retval, in_start);\n\t    STRCAT(retval, temp_result);\n\t    STRCAT(retval, expr_end + 1);\n\t}\n    }\n    vim_free(temp_result);\n\n    *in_end = c1;\t\t// put char back for error messages\n    *expr_start = '{';\n    *expr_end = '}';\n\n    if (retval != NULL)\n    {\n\ttemp_result = find_name_end(retval, &expr_start, &expr_end, 0);\n\tif (expr_start != NULL)\n\t{\n\t    // Further expansion!\n\t    temp_result = make_expanded_name(retval, expr_start,\n\t\t\t\t\t\t       expr_end, temp_result);\n\t    vim_free(retval);\n\t    retval = temp_result;\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if character \"c\" can be used in a variable or function name.\n * Does not include '{' or '}' for magic braces.\n */\n    int\neval_isnamec(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_' || c == ':' || c == AUTOLOAD_CHAR;\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character in a\n * variable or function name (excluding '{' and '}').\n */\n    int\neval_isnamec1(int c)\n{\n    return ASCII_ISALPHA(c) || c == '_';\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character of a\n * dictionary key.\n */\n    int\neval_isdictc(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_';\n}\n\n/*\n * Handle:\n * - expr[expr], expr[expr:expr] subscript\n * - \".name\" lookup\n * - function call with Funcref variable: func(expr)\n * - method call: var->method()\n *\n * Can all be combined in any order: dict.func(expr)[idx]['func'](expr)->len()\n * \"name_start\" points to a variable before the subscript or is NULL.\n */\n    int\nhandle_subscript(\n    char_u\t**arg,\n    char_u\t*name_start,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tret = OK;\n    dict_T\t*selfdict = NULL;\n    int\t\tcheck_white = TRUE;\n    int\t\tgetnext;\n    char_u\t*p;\n\n    while (ret == OK)\n    {\n\t// When at the end of the line and \".name\" or \"->{\" or \"->X\" follows in\n\t// the next line then consume the line break.\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\tif (getnext\n\t    && ((rettv->v_type == VAR_DICT && *p == '.' && eval_isdictc(p[1]))\n\t\t|| (p[0] == '-' && p[1] == '>' && (p[2] == '{'\n\t\t\t|| ASCII_ISALPHA(in_vim9script() ? *skipwhite(p + 2)\n\t\t\t\t\t\t\t\t    : p[2])))))\n\t{\n\t    *arg = eval_next_line(*arg, evalarg);\n\t    p = *arg;\n\t    check_white = FALSE;\n\t}\n\n\tif (rettv->v_type == VAR_ANY)\n\t{\n\t    char_u\t*exp_name;\n\t    int\t\tcc;\n\t    int\t\tidx;\n\t    ufunc_T\t*ufunc;\n\t    type_T\t*type;\n\n\t    // Found script from \"import {name} as name\", script item name must\n\t    // follow.  \"rettv->vval.v_number\" has the script ID.\n\t    if (**arg != '.')\n\t    {\n\t\tif (verbose)\n\t\t    semsg(_(e_expected_dot_after_name_str),\n\t\t\t\t\tname_start != NULL ? name_start: *arg);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    ++*arg;\n\t    if (IS_WHITE_OR_NUL(**arg))\n\t    {\n\t\tif (verbose)\n\t\t    emsg(_(e_no_white_space_allowed_after_dot));\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // isolate the name\n\t    exp_name = *arg;\n\t    while (eval_isnamec(**arg))\n\t\t++*arg;\n\t    cc = **arg;\n\t    **arg = NUL;\n\n\t    idx = find_exported(rettv->vval.v_number, exp_name, &ufunc, &type,\n\t\t\t    evalarg->eval_cctx, evalarg->eval_cstack, verbose);\n\t    **arg = cc;\n\n\t    if (idx < 0 && ufunc == NULL)\n\t    {\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    if (idx >= 0)\n\t    {\n\t\tscriptitem_T    *si = SCRIPT_ITEM(rettv->vval.v_number);\n\t\tsvar_T\t\t*sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\n\t\tcopy_tv(sv->sv_tv, rettv);\n\t    }\n\t    else\n\t    {\n\t\trettv->v_type = VAR_FUNC;\n\t\trettv->vval.v_string = vim_strsave(ufunc->uf_name);\n\t    }\n\t    continue;\n\t}\n\n\tif ((**arg == '(' && (!evaluate || rettv->v_type == VAR_FUNC\n\t\t\t    || rettv->v_type == VAR_PARTIAL))\n\t\t    && (!check_white || !VIM_ISWHITE(*(*arg - 1))))\n\t{\n\t    ret = call_func_rettv(arg, evalarg, rettv, evaluate,\n\t\t\t\t\t\t\t       selfdict, NULL);\n\n\t    // Stop the expression evaluation when immediately aborting on\n\t    // error, or when an interrupt occurred or an exception was thrown\n\t    // but not caught.\n\t    if (aborting())\n\t    {\n\t\tif (ret == OK)\n\t\t    clear_tv(rettv);\n\t\tret = FAIL;\n\t    }\n\t    dict_unref(selfdict);\n\t    selfdict = NULL;\n\t}\n\telse if (p[0] == '-' && p[1] == '>')\n\t{\n\t    if (in_vim9script())\n\t\t*arg = skipwhite(p + 2);\n\t    else\n\t\t*arg = p + 2;\n\t    if (ret == OK)\n\t    {\n\t\tif (VIM_ISWHITE(**arg))\n\t\t{\n\t\t    emsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\t    ret = FAIL;\n\t\t}\n\t\telse if ((**arg == '{' && !in_vim9script()) || **arg == '(')\n\t\t    // expr->{lambda}() or expr->(lambda)()\n\t\t    ret = eval_lambda(arg, rettv, evalarg, verbose);\n\t\telse\n\t\t    // expr->name()\n\t\t    ret = eval_method(arg, rettv, evalarg, verbose);\n\t    }\n\t}\n\t// \".\" is \".name\" lookup when we found a dict or when evaluating and\n\t// scriptversion is at least 2, where string concatenation is \"..\".\n\telse if (**arg == '['\n\t\t|| (**arg == '.' && (rettv->v_type == VAR_DICT\n\t\t\t|| (!evaluate\n\t\t\t    && (*arg)[1] != '.'\n\t\t\t    && !in_old_script(2)))))\n\t{\n\t    dict_unref(selfdict);\n\t    if (rettv->v_type == VAR_DICT)\n\t    {\n\t\tselfdict = rettv->vval.v_dict;\n\t\tif (selfdict != NULL)\n\t\t    ++selfdict->dv_refcount;\n\t    }\n\t    else\n\t\tselfdict = NULL;\n\t    if (eval_index(arg, rettv, evalarg, verbose) == FAIL)\n\t    {\n\t\tclear_tv(rettv);\n\t\tret = FAIL;\n\t    }\n\t}\n\telse\n\t    break;\n    }\n\n    // Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n    // Don't do this when \"Func\" is already a partial that was bound\n    // explicitly (pt_auto is FALSE).\n    if (selfdict != NULL\n\t    && (rettv->v_type == VAR_FUNC\n\t\t|| (rettv->v_type == VAR_PARTIAL\n\t\t    && (rettv->vval.v_partial->pt_auto\n\t\t\t|| rettv->vval.v_partial->pt_dict == NULL))))\n\tselfdict = make_partial(selfdict, rettv);\n\n    dict_unref(selfdict);\n    return ret;\n}\n\n/*\n * Make a copy of an item.\n * Lists and Dictionaries are also copied.  A deep copy if \"deep\" is set.\n * \"top\" is TRUE for the toplevel of copy().\n * For deepcopy() \"copyID\" is zero for a full copy or the ID for when a\n * reference to an already copied list/dict can be used.\n * Returns FAIL or OK.\n */\n    int\nitem_copy(\n    typval_T\t*from,\n    typval_T\t*to,\n    int\t\tdeep,\n    int\t\ttop,\n    int\t\tcopyID)\n{\n    static int\trecurse = 0;\n    int\t\tret = OK;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\temsg(_(e_variable_nested_too_deep_for_making_copy));\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (from->v_type)\n    {\n\tcase VAR_NUMBER:\n\tcase VAR_FLOAT:\n\tcase VAR_STRING:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    copy_tv(from, to);\n\t    break;\n\tcase VAR_LIST:\n\t    to->v_type = VAR_LIST;\n\t    to->v_lock = 0;\n\t    if (from->vval.v_list == NULL)\n\t\tto->vval.v_list = NULL;\n\t    else if (copyID != 0 && from->vval.v_list->lv_copyID == copyID)\n\t    {\n\t\t// use the copy made earlier\n\t\tto->vval.v_list = from->vval.v_list->lv_copylist;\n\t\t++to->vval.v_list->lv_refcount;\n\t    }\n\t    else\n\t\tto->vval.v_list = list_copy(from->vval.v_list,\n\t\t\t\t\t\t\t    deep, top, copyID);\n\t    if (to->vval.v_list == NULL)\n\t\tret = FAIL;\n\t    break;\n\tcase VAR_BLOB:\n\t    ret = blob_copy(from->vval.v_blob, to);\n\t    break;\n\tcase VAR_DICT:\n\t    to->v_type = VAR_DICT;\n\t    to->v_lock = 0;\n\t    if (from->vval.v_dict == NULL)\n\t\tto->vval.v_dict = NULL;\n\t    else if (copyID != 0 && from->vval.v_dict->dv_copyID == copyID)\n\t    {\n\t\t// use the copy made earlier\n\t\tto->vval.v_dict = from->vval.v_dict->dv_copydict;\n\t\t++to->vval.v_dict->dv_refcount;\n\t    }\n\t    else\n\t\tto->vval.v_dict = dict_copy(from->vval.v_dict,\n\t\t\t\t\t\t\t    deep, top, copyID);\n\t    if (to->vval.v_dict == NULL)\n\t\tret = FAIL;\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    internal_error_no_abort(\"item_copy(UNKNOWN)\");\n\t    ret = FAIL;\n    }\n    --recurse;\n    return ret;\n}\n\n    void\necho_one(typval_T *rettv, int with_space, int *atstart, int *needclr)\n{\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*p = echo_string(rettv, &tofree, numbuf, get_copyID());\n\n    if (*atstart)\n    {\n\t*atstart = FALSE;\n\t// Call msg_start() after eval1(), evaluating the expression\n\t// may cause a message to appear.\n\tif (with_space)\n\t{\n\t    // Mark the saved text as finishing the line, so that what\n\t    // follows is displayed on a new line when scrolling back\n\t    // at the more prompt.\n\t    msg_sb_eol();\n\t    msg_start();\n\t}\n    }\n    else if (with_space)\n\tmsg_puts_attr(\" \", echo_attr);\n\n    if (p != NULL)\n\tfor ( ; *p != NUL && !got_int; ++p)\n\t{\n\t    if (*p == '\\n' || *p == '\\r' || *p == TAB)\n\t    {\n\t\tif (*p != TAB && *needclr)\n\t\t{\n\t\t    // remove any text still there from the command\n\t\t    msg_clr_eos();\n\t\t    *needclr = FALSE;\n\t\t}\n\t\tmsg_putchar_attr(*p, echo_attr);\n\t    }\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int i = (*mb_ptr2len)(p);\n\n\t\t    (void)msg_outtrans_len_attr(p, i, echo_attr);\n\t\t    p += i - 1;\n\t\t}\n\t\telse\n\t\t    (void)msg_outtrans_len_attr(p, 1, echo_attr);\n\t    }\n\t}\n    vim_free(tofree);\n}\n\n/*\n * \":echo expr1 ...\"\tprint each argument separated with a space, add a\n *\t\t\tnewline at the end.\n * \":echon expr1 ...\"\tprint each argument plain.\n */\n    void\nex_echo(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    char_u\t*arg_start;\n    int\t\tneedclr = TRUE;\n    int\t\tatstart = TRUE;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n\n    if (eap->skip)\n\t++emsg_skip;\n    while ((!ends_excmd2(eap->cmd, arg) || *arg == '\"') && !got_int)\n    {\n\t// If eval1() causes an error message the text from the command may\n\t// still need to be cleared. E.g., \"echo 22,44\".\n\tneed_clr_eos = needclr;\n\n\targ_start = arg;\n\tif (eval1(&arg, &rettv, &evalarg) == FAIL)\n\t{\n\t    /*\n\t     * Report the invalid expression unless the expression evaluation\n\t     * has been cancelled due to an aborting error, an interrupt, or an\n\t     * exception.\n\t     */\n\t    if (!aborting() && did_emsg == did_emsg_before\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t\tsemsg(_(e_invalid_expression_str), arg_start);\n\t    need_clr_eos = FALSE;\n\t    break;\n\t}\n\tneed_clr_eos = FALSE;\n\n\tif (!eap->skip)\n\t{\n\t    if (rettv.v_type == VAR_VOID)\n\t    {\n\t\tsemsg(_(e_expression_does_not_result_in_value_str), arg_start);\n\t\tbreak;\n\t    }\n\t    echo_one(&rettv, eap->cmdidx == CMD_echo, &atstart, &needclr);\n\t}\n\n\tclear_tv(&rettv);\n\targ = skipwhite(arg);\n    }\n    set_nextcmd(eap, arg);\n    clear_evalarg(&evalarg, eap);\n\n    if (eap->skip)\n\t--emsg_skip;\n    else\n    {\n\t// remove text that may still be there from the command\n\tif (needclr)\n\t    msg_clr_eos();\n\tif (eap->cmdidx == CMD_echo)\n\t    msg_end();\n    }\n}\n\n/*\n * \":echohl {name}\".\n */\n    void\nex_echohl(exarg_T *eap)\n{\n    echo_attr = syn_name2attr(eap->arg);\n}\n\n/*\n * Returns the :echo attribute\n */\n    int\nget_echo_attr(void)\n{\n    return echo_attr;\n}\n\n/*\n * \":execute expr1 ...\"\texecute the result of an expression.\n * \":echomsg expr1 ...\"\tPrint a message\n * \":echoerr expr1 ...\"\tPrint an error\n * \":echoconsole expr1 ...\" Print a message on stdout\n * Each gets spaces around each argument and a newline at the end for\n * echo commands\n */\n    void\nex_execute(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\tret = OK;\n    char_u\t*p;\n    garray_T\tga;\n    int\t\tlen;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    ga_init2(&ga, 1, 80);\n\n    if (eap->skip)\n\t++emsg_skip;\n    while (!ends_excmd2(eap->cmd, arg) || *arg == '\"')\n    {\n\tret = eval1_emsg(&arg, &rettv, eap);\n\tif (ret == FAIL)\n\t    break;\n\n\tif (!eap->skip)\n\t{\n\t    char_u   buf[NUMBUFLEN];\n\n\t    if (eap->cmdidx == CMD_execute)\n\t    {\n\t\tif (rettv.v_type == VAR_CHANNEL || rettv.v_type == VAR_JOB)\n\t\t{\n\t\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t  vartype_name(rettv.v_type));\n\t\t    p = NULL;\n\t\t}\n\t\telse\n\t\t    p = tv_get_string_buf(&rettv, buf);\n\t    }\n\t    else\n\t\tp = tv_stringify(&rettv, buf);\n\t    if (p == NULL)\n\t    {\n\t\tclear_tv(&rettv);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    len = (int)STRLEN(p);\n\t    if (ga_grow(&ga, len + 2) == FAIL)\n\t    {\n\t\tclear_tv(&rettv);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    if (ga.ga_len)\n\t\t((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';\n\t    STRCPY((char_u *)(ga.ga_data) + ga.ga_len, p);\n\t    ga.ga_len += len;\n\t}\n\n\tclear_tv(&rettv);\n\targ = skipwhite(arg);\n    }\n\n    if (ret != FAIL && ga.ga_data != NULL)\n    {\n\t// use the first line of continuation lines for messages\n\tSOURCING_LNUM = start_lnum;\n\n\tif (eap->cmdidx == CMD_echomsg || eap->cmdidx == CMD_echoerr)\n\t{\n\t    // Mark the already saved text as finishing the line, so that what\n\t    // follows is displayed on a new line when scrolling back at the\n\t    // more prompt.\n\t    msg_sb_eol();\n\t}\n\n\tif (eap->cmdidx == CMD_echomsg)\n\t{\n\t    msg_attr(ga.ga_data, echo_attr);\n\t    out_flush();\n\t}\n\telse if (eap->cmdidx == CMD_echoconsole)\n\t{\n\t    ui_write(ga.ga_data, (int)STRLEN(ga.ga_data), TRUE);\n\t    ui_write((char_u *)\"\\r\\n\", 2, TRUE);\n\t}\n\telse if (eap->cmdidx == CMD_echoerr)\n\t{\n\t    int\t\tsave_did_emsg = did_emsg;\n\n\t    // We don't want to abort following commands, restore did_emsg.\n\t    emsg(ga.ga_data);\n\t    if (!force_abort)\n\t\tdid_emsg = save_did_emsg;\n\t}\n\telse if (eap->cmdidx == CMD_execute)\n\t{\n\t    int save_sticky_cmdmod_flags = sticky_cmdmod_flags;\n\n\t    // \"legacy exe cmd\" and \"vim9cmd exe cmd\" applies to \"cmd\".\n\t    sticky_cmdmod_flags = cmdmod.cmod_flags\n\t\t\t\t\t\t& (CMOD_LEGACY | CMOD_VIM9CMD);\n\t    do_cmdline((char_u *)ga.ga_data,\n\t\t       eap->getline, eap->cookie, DOCMD_NOWAIT|DOCMD_VERBOSE);\n\t    sticky_cmdmod_flags = save_sticky_cmdmod_flags;\n\t}\n    }\n\n    ga_clear(&ga);\n\n    if (eap->skip)\n\t--emsg_skip;\n\n    set_nextcmd(eap, arg);\n}\n\n/*\n * Skip over the name of an option: \"&option\", \"&g:option\" or \"&l:option\".\n * \"arg\" points to the \"&\" or '+' when called, to \"option\" when returning.\n * Returns NULL when no option name found.  Otherwise pointer to the char\n * after the option name.\n */\n    char_u *\nfind_option_end(char_u **arg, int *scope)\n{\n    char_u\t*p = *arg;\n\n    ++p;\n    if (*p == 'g' && p[1] == ':')\n    {\n\t*scope = OPT_GLOBAL;\n\tp += 2;\n    }\n    else if (*p == 'l' && p[1] == ':')\n    {\n\t*scope = OPT_LOCAL;\n\tp += 2;\n    }\n    else\n\t*scope = 0;\n\n    if (!ASCII_ISALPHA(*p))\n\treturn NULL;\n    *arg = p;\n\n    if (p[0] == 't' && p[1] == '_' && p[2] != NUL && p[3] != NUL)\n\tp += 4;\t    // termcap option\n    else\n\twhile (ASCII_ISALPHA(*p))\n\t    ++p;\n    return p;\n}\n\n/*\n * Display script name where an item was last set.\n * Should only be invoked when 'verbose' is non-zero.\n */\n    void\nlast_set_msg(sctx_T script_ctx)\n{\n    char_u *p;\n\n    if (script_ctx.sc_sid != 0)\n    {\n\tp = home_replace_save(NULL, get_scriptname(script_ctx.sc_sid));\n\tif (p != NULL)\n\t{\n\t    verbose_enter();\n\t    msg_puts(_(\"\\n\\tLast set from \"));\n\t    msg_puts((char *)p);\n\t    if (script_ctx.sc_lnum > 0)\n\t    {\n\t\tmsg_puts(_(line_msg));\n\t\tmsg_outnum((long)script_ctx.sc_lnum);\n\t    }\n\t    verbose_leave();\n\t    vim_free(p);\n\t}\n    }\n}\n\n#endif // FEAT_EVAL\n\n/*\n * Perform a substitution on \"str\" with pattern \"pat\" and substitute \"sub\".\n * When \"sub\" is NULL \"expr\" is used, must be a VAR_FUNC or VAR_PARTIAL.\n * \"flags\" can be \"g\" to do a global substitute.\n * Returns an allocated string, NULL for error.\n */\n    char_u *\ndo_string_sub(\n    char_u\t*str,\n    char_u\t*pat,\n    char_u\t*sub,\n    typval_T\t*expr,\n    char_u\t*flags)\n{\n    int\t\tsublen;\n    regmatch_T\tregmatch;\n    int\t\ti;\n    int\t\tdo_all;\n    char_u\t*tail;\n    char_u\t*end;\n    garray_T\tga;\n    char_u\t*ret;\n    char_u\t*save_cpo;\n    char_u\t*zero_width = NULL;\n\n    // Make 'cpoptions' empty, so that the 'l' flag doesn't work here\n    save_cpo = p_cpo;\n    p_cpo = empty_option;\n\n    ga_init2(&ga, 1, 200);\n\n    do_all = (flags[0] == 'g');\n\n    regmatch.rm_ic = p_ic;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog != NULL)\n    {\n\ttail = str;\n\tend = str + STRLEN(str);\n\twhile (vim_regexec_nl(&regmatch, str, (colnr_T)(tail - str)))\n\t{\n\t    // Skip empty match except for first match.\n\t    if (regmatch.startp[0] == regmatch.endp[0])\n\t    {\n\t\tif (zero_width == regmatch.startp[0])\n\t\t{\n\t\t    // avoid getting stuck on a match with an empty string\n\t\t    i = mb_ptr2len(tail);\n\t\t    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail,\n\t\t\t\t\t\t\t\t   (size_t)i);\n\t\t    ga.ga_len += i;\n\t\t    tail += i;\n\t\t    continue;\n\t\t}\n\t\tzero_width = regmatch.startp[0];\n\t    }\n\n\t    /*\n\t     * Get some space for a temporary buffer to do the substitution\n\t     * into.  It will contain:\n\t     * - The text up to where the match is.\n\t     * - The substituted text.\n\t     * - The text after the match.\n\t     */\n\t    sublen = vim_regsub(&regmatch, sub, expr, tail, 0, REGSUB_MAGIC);\n\t    if (ga_grow(&ga, (int)((end - tail) + sublen -\n\t\t\t    (regmatch.endp[0] - regmatch.startp[0]))) == FAIL)\n\t    {\n\t\tga_clear(&ga);\n\t\tbreak;\n\t    }\n\n\t    // copy the text up to where the match is\n\t    i = (int)(regmatch.startp[0] - tail);\n\t    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail, (size_t)i);\n\t    // add the substituted text\n\t    (void)vim_regsub(&regmatch, sub, expr,\n\t\t\t\t  (char_u *)ga.ga_data + ga.ga_len + i, sublen,\n\t\t\t\t  REGSUB_COPY | REGSUB_MAGIC);\n\t    ga.ga_len += i + sublen - 1;\n\t    tail = regmatch.endp[0];\n\t    if (*tail == NUL)\n\t\tbreak;\n\t    if (!do_all)\n\t\tbreak;\n\t}\n\n\tif (ga.ga_data != NULL)\n\t    STRCPY((char *)ga.ga_data + ga.ga_len, tail);\n\n\tvim_regfree(regmatch.regprog);\n    }\n\n    ret = vim_strsave(ga.ga_data == NULL ? str : (char_u *)ga.ga_data);\n    ga_clear(&ga);\n    if (p_cpo == empty_option)\n\tp_cpo = save_cpo;\n    else\n    {\n\t// Darn, evaluating {sub} expression or {expr} changed the value.\n\t// If it's still empty it was changed and restored, need to restore in\n\t// the complicated way.\n\tif (*p_cpo == NUL)\n\t    set_option_value_give_err((char_u *)\"cpo\", 0L, save_cpo, 0);\n\tfree_string_option(save_cpo);\n    }\n\n    return ret;\n}\n", "/* eval.c */\nvarnumber_T num_divide(varnumber_T n1, varnumber_T n2, int *failed);\nvarnumber_T num_modulus(varnumber_T n1, varnumber_T n2, int *failed);\nvoid eval_init(void);\nvoid eval_clear(void);\nvoid fill_evalarg_from_eap(evalarg_T *evalarg, exarg_T *eap, int skip);\nint eval_to_bool(char_u *arg, int *error, exarg_T *eap, int skip);\nint eval_expr_valid_arg(typval_T *tv);\nint eval_expr_typval(typval_T *expr, typval_T *argv, int argc, typval_T *rettv);\nint eval_expr_to_bool(typval_T *expr, int *error);\nchar_u *eval_to_string_skip(char_u *arg, exarg_T *eap, int skip);\nint skip_expr(char_u **pp, evalarg_T *evalarg);\nint skip_expr_concatenate(char_u **arg, char_u **start, char_u **end, evalarg_T *evalarg);\nchar_u *typval2string(typval_T *tv, int convert);\nchar_u *eval_to_string_eap(char_u *arg, int convert, exarg_T *eap);\nchar_u *eval_to_string(char_u *arg, int convert);\nchar_u *eval_to_string_safe(char_u *arg, int use_sandbox, int keep_script_version);\nvarnumber_T eval_to_number(char_u *expr);\ntypval_T *eval_expr(char_u *arg, exarg_T *eap);\nint call_vim_function(char_u *func, int argc, typval_T *argv, typval_T *rettv);\nvoid *call_func_retstr(char_u *func, int argc, typval_T *argv);\nvoid *call_func_retlist(char_u *func, int argc, typval_T *argv);\nint eval_foldexpr(win_T *wp, int *cp);\nchar_u *get_lval(char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int flags, int fne_flags);\nvoid clear_lval(lval_T *lp);\nvoid set_var_lval(lval_T *lp, char_u *endp, typval_T *rettv, int copy, int flags, char_u *op, int var_idx);\nint tv_op(typval_T *tv1, typval_T *tv2, char_u *op);\nvoid *eval_for_line(char_u *arg, int *errp, exarg_T *eap, evalarg_T *evalarg);\nvoid skip_for_lines(void *fi_void, evalarg_T *evalarg);\nint next_for_item(void *fi_void, char_u *arg);\nvoid free_for_info(void *fi_void);\nvoid set_context_for_expression(expand_T *xp, char_u *arg, cmdidx_T cmdidx);\nint pattern_match(char_u *pat, char_u *text, int ic);\nchar_u *eval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext);\nchar_u *eval_next_line(char_u *arg, evalarg_T *evalarg);\nchar_u *skipwhite_and_linebreak(char_u *arg, evalarg_T *evalarg);\nvoid init_evalarg(evalarg_T *evalarg);\nvoid clear_evalarg(evalarg_T *evalarg, exarg_T *eap);\nint eval0(char_u *arg, typval_T *rettv, exarg_T *eap, evalarg_T *evalarg);\nint eval0_retarg(char_u *arg, typval_T *rettv, exarg_T *eap, evalarg_T *evalarg, char_u **retarg);\nint eval1(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nvoid eval_addblob(typval_T *tv1, typval_T *tv2);\nint eval_addlist(typval_T *tv1, typval_T *tv2);\nint eval_leader(char_u **arg, int vim9);\nint handle_predefined(char_u *s, int len, typval_T *rettv);\nint check_can_index(typval_T *rettv, int evaluate, int verbose);\nvoid f_slice(typval_T *argvars, typval_T *rettv);\nint eval_index_inner(typval_T *rettv, int is_range, typval_T *var1, typval_T *var2, int exclusive, char_u *key, int keylen, int verbose);\nchar_u *partial_name(partial_T *pt);\nvoid partial_unref(partial_T *pt);\nint get_copyID(void);\nint garbage_collect(int testing);\nint set_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack);\nint set_ref_in_dict(dict_T *d, int copyID);\nint set_ref_in_list(list_T *ll, int copyID);\nint set_ref_in_list_items(list_T *l, int copyID, ht_stack_T **ht_stack);\nint set_ref_in_callback(callback_T *cb, int copyID);\nint set_ref_in_item(typval_T *tv, int copyID, ht_stack_T **ht_stack, list_stack_T **list_stack);\nchar_u *echo_string_core(typval_T *tv, char_u **tofree, char_u *numbuf, int copyID, int echo_style, int restore_copyID, int composite_val);\nchar_u *echo_string(typval_T *tv, char_u **tofree, char_u *numbuf, int copyID);\nint buf_byteidx_to_charidx(buf_T *buf, int lnum, int byteidx);\nint buf_charidx_to_byteidx(buf_T *buf, int lnum, int charidx);\npos_T *var2fpos(typval_T *varp, int dollar_lnum, int *fnum, int charcol);\nint list2fpos(typval_T *arg, pos_T *posp, int *fnump, colnr_T *curswantp, int charcol);\nint get_env_len(char_u **arg);\nint get_id_len(char_u **arg);\nint get_name_len(char_u **arg, char_u **alias, int evaluate, int verbose);\nchar_u *find_name_end(char_u *arg, char_u **expr_start, char_u **expr_end, int flags);\nint eval_isnamec(int c);\nint eval_isnamec1(int c);\nint eval_isdictc(int c);\nint handle_subscript(char_u **arg, char_u *name_start, typval_T *rettv, evalarg_T *evalarg, int verbose);\nint item_copy(typval_T *from, typval_T *to, int deep, int top, int copyID);\nvoid echo_one(typval_T *rettv, int with_space, int *atstart, int *needclr);\nvoid ex_echo(exarg_T *eap);\nvoid ex_echohl(exarg_T *eap);\nint get_echo_attr(void);\nvoid ex_execute(exarg_T *eap);\nchar_u *find_option_end(char_u **arg, int *scope);\nvoid last_set_msg(sctx_T script_ctx);\nchar_u *do_string_sub(char_u *str, char_u *pat, char_u *sub, typval_T *expr, char_u *flags);\n/* vim: set ft=c : */\n", "\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nimport './vim9.vim' as v9\nsource screendump.vim\nsource shared.vim\n\ndef Test_vim9script_feature()\n  # example from the help, here the feature is always present\n  var lines =<< trim END\n      \" old style comment\n      if !has('vim9script')\n        \" legacy commands would go here\n        finish\n      endif\n      vim9script\n      # Vim9 script commands go here\n      g:didit = true\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(true, g:didit)\n  unlet g:didit\nenddef\n\ndef Test_range_only()\n  new\n  setline(1, ['blah', 'Blah'])\n  :/Blah/\n  assert_equal(2, getcurpos()[1])\n  bwipe!\n\n  # without range commands use current line\n  new\n  setline(1, ['one', 'two', 'three'])\n  :2\n  print\n  assert_equal('two', g:Screenline(&lines))\n  :3\n  list\n  assert_equal('three$', g:Screenline(&lines))\n\n  # missing command does not print the line\n  var lines =<< trim END\n    vim9script\n    :1|\n    assert_equal('three$', g:Screenline(&lines))\n    :|\n    assert_equal('three$', g:Screenline(&lines))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  bwipe!\n\n  lines =<< trim END\n      set cpo+=-\n      :1,999\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E16:', 2)\n  set cpo&vim\n\n  v9.CheckDefExecAndScriptFailure([\":'x\"], 'E20:', 1)\n\n  # won't generate anything\n  if false\n    :123\n  endif\nenddef\n\ndef Test_invalid_range()\n  var lines =<< trim END\n      :123 eval 1 + 2\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 if true\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 echo 'yes'\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 cd there\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\nenddef\n\nlet g:alist = [7]\nlet g:astring = 'text'\nlet g:anumber = 123\n\ndef Test_delfunction()\n  # Check function is defined in script namespace\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func CheckMe()',\n      '  return 123',\n      'endfunc',\n      'func DoTest()',\n      '  call assert_equal(123, s:CheckMe())',\n      'endfunc',\n      'DoTest()',\n      ])\n\n  # Check function in script namespace cannot be deleted\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func DeleteMe1()',\n      'endfunc',\n      'delfunction DeleteMe1',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func DeleteMe2()',\n      'endfunc',\n      'def DoThat()',\n      '  delfunction DeleteMe2',\n      'enddef',\n      'DoThat()',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def DeleteMe3()',\n      'enddef',\n      'delfunction DeleteMe3',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def DeleteMe4()',\n      'enddef',\n      'def DoThat()',\n      '  delfunction DeleteMe4',\n      'enddef',\n      'DoThat()',\n      ], 'E1084:')\n\n  # Check that global :def function can be replaced and deleted\n  var lines =<< trim END\n      vim9script\n      def g:Global(): string\n        return \"yes\"\n      enddef\n      assert_equal(\"yes\", g:Global())\n      def! g:Global(): string\n        return \"no\"\n      enddef\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Check that global function can be replaced by a :def function and deleted\n  lines =<< trim END\n      vim9script\n      func g:Global()\n        return \"yes\"\n      endfunc\n      assert_equal(\"yes\", g:Global())\n      def! g:Global(): string\n        return \"no\"\n      enddef\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Check that global :def function can be replaced by a function and deleted\n  lines =<< trim END\n      vim9script\n      def g:Global(): string\n        return \"yes\"\n      enddef\n      assert_equal(\"yes\", g:Global())\n      func! g:Global()\n        return \"no\"\n      endfunc\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_wrong_type()\n  v9.CheckDefFailure(['var name: list<nothing>'], 'E1010:')\n  v9.CheckDefFailure(['var name: list<list<nothing>>'], 'E1010:')\n  v9.CheckDefFailure(['var name: dict<nothing>'], 'E1010:')\n  v9.CheckDefFailure(['var name: dict<dict<nothing>>'], 'E1010:')\n\n  v9.CheckDefFailure(['var name: dict<number'], 'E1009:')\n  v9.CheckDefFailure(['var name: dict<list<number>'], 'E1009:')\n\n  v9.CheckDefFailure(['var name: ally'], 'E1010:')\n  v9.CheckDefFailure(['var name: bram'], 'E1010:')\n  v9.CheckDefFailure(['var name: cathy'], 'E1010:')\n  v9.CheckDefFailure(['var name: dom'], 'E1010:')\n  v9.CheckDefFailure(['var name: freddy'], 'E1010:')\n  v9.CheckDefFailure(['var name: john'], 'E1010:')\n  v9.CheckDefFailure(['var name: larry'], 'E1010:')\n  v9.CheckDefFailure(['var name: ned'], 'E1010:')\n  v9.CheckDefFailure(['var name: pam'], 'E1010:')\n  v9.CheckDefFailure(['var name: sam'], 'E1010:')\n  v9.CheckDefFailure(['var name: vim'], 'E1010:')\n\n  v9.CheckDefFailure(['var Ref: number', 'Ref()'], 'E1085:')\n  v9.CheckDefFailure(['var Ref: string', 'var res = Ref()'], 'E1085:')\nenddef\n\ndef Test_script_namespace()\n  # defining a function or variable with s: is not allowed\n  var lines =<< trim END\n      vim9script\n      def s:Function()\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n\n  for decl in ['var', 'const', 'final']\n    lines =<< trim END\n        vim9script\n        var s:var = 'var'\n    END\n    v9.CheckScriptFailure([\n        'vim9script',\n        decl .. ' s:var = \"var\"',\n        ], 'E1268:')\n  endfor\n\n  # Calling a function or using a variable with s: is not allowed at script\n  # level\n  lines =<< trim END\n      vim9script\n      def Function()\n      enddef\n      s:Function()\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n  lines =<< trim END\n      vim9script\n      def Function()\n      enddef\n      call s:Function()\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n  lines =<< trim END\n      vim9script\n      var var = 'var'\n      echo s:var\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\nenddef\n\ndef Test_script_wrong_type()\n  var lines =<< trim END\n      vim9script\n      var dict: dict<string>\n      dict['a'] = ['x']\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected string but got list<string>', 3)\nenddef\n\ndef Test_const()\n  v9.CheckDefFailure(['final name = 234', 'name = 99'], 'E1018:')\n  v9.CheckDefFailure(['final one = 234', 'var one = 99'], 'E1017:')\n  v9.CheckDefFailure(['final list = [1, 2]', 'var list = [3, 4]'], 'E1017:')\n  v9.CheckDefFailure(['final two'], 'E1125:')\n  v9.CheckDefFailure(['final &option'], 'E996:')\n\n  var lines =<< trim END\n    final list = [1, 2, 3]\n    list[0] = 4\n    list->assert_equal([4, 2, 3])\n    const other = [5, 6, 7]\n    other->assert_equal([5, 6, 7])\n\n    var varlist = [7, 8]\n    const constlist = [1, varlist, 3]\n    varlist[0] = 77\n    constlist[1][1] = 88\n    var cl = constlist[1]\n    cl[1] = 88\n    constlist->assert_equal([1, [77, 88], 3])\n\n    var vardict = {five: 5, six: 6}\n    const constdict = {one: 1, two: vardict, three: 3}\n    vardict['five'] = 55\n    constdict['two']['six'] = 66\n    var cd = constdict['two']\n    cd['six'] = 66\n    constdict->assert_equal({one: 1, two: {five: 55, six: 66}, three: 3})\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_const_bang()\n  var lines =<< trim END\n      const var = 234\n      var = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1018:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E46:', 3)\n\n  lines =<< trim END\n      const ll = [2, 3, 4]\n      ll[0] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1119:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\n\n  lines =<< trim END\n      const ll = [2, 3, 4]\n      ll[3] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1118:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E684:', 3)\n\n  lines =<< trim END\n      const dd = {one: 1, two: 2}\n      dd[\"one\"] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1121:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\n\n  lines =<< trim END\n      const dd = {one: 1, two: 2}\n      dd[\"three\"] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1120:')\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\nenddef\n\ndef Test_range_no_colon()\n  v9.CheckDefFailure(['%s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['+ s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['- s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['. s/a/b/'], 'E1050:')\nenddef\n\n\ndef Test_block()\n  var outer = 1\n  {\n    var inner = 2\n    assert_equal(1, outer)\n    assert_equal(2, inner)\n  }\n  assert_equal(1, outer)\n\n  {|echo 'yes'|}\nenddef\n\ndef Test_block_failure()\n  v9.CheckDefFailure(['{', 'var inner = 1', '}', 'echo inner'], 'E1001:')\n  v9.CheckDefFailure(['}'], 'E1025:')\n  v9.CheckDefFailure(['{', 'echo 1'], 'E1026:')\nenddef\n\ndef Test_block_local_vars()\n  var lines =<< trim END\n      vim9script\n      v:testing = 1\n      if true\n        var text = ['hello']\n        def SayHello(): list<string>\n          return text\n        enddef\n        def SetText(v: string)\n          text = [v]\n        enddef\n      endif\n\n      if true\n        var text = ['again']\n        def SayAgain(): list<string>\n          return text\n        enddef\n      endif\n\n      # test that the \"text\" variables are not cleaned up\n      test_garbagecollect_now()\n\n      defcompile\n\n      assert_equal(['hello'], SayHello())\n      assert_equal(['again'], SayAgain())\n\n      SetText('foobar')\n      assert_equal(['foobar'], SayHello())\n\n      call writefile(['ok'], 'Xdidit')\n      qall!\n  END\n\n  # need to execute this with a separate Vim instance to avoid the current\n  # context gets garbage collected.\n  writefile(lines, 'Xscript')\n  g:RunVim([], [], '-S Xscript')\n  assert_equal(['ok'], readfile('Xdidit'))\n\n  delete('Xscript')\n  delete('Xdidit')\nenddef\n\ndef Test_block_local_vars_with_func()\n  var lines =<< trim END\n      vim9script\n      if true\n        var foo = 'foo'\n        if true\n          var bar = 'bar'\n          def Func(): list<string>\n            return [foo, bar]\n          enddef\n        endif\n      endif\n      # function is compiled here, after blocks have finished, can still access\n      # \"foo\" and \"bar\"\n      assert_equal(['foo', 'bar'], Func())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\n\" legacy func for command that's defined later\nfunc s:InvokeSomeCommand()\n  SomeCommand\nendfunc\n\ndef Test_autocommand_block()\n  com SomeCommand {\n      g:someVar = 'some'\n    }\n  InvokeSomeCommand()\n  assert_equal('some', g:someVar)\n\n  delcommand SomeCommand\n  unlet g:someVar\nenddef\n\ndef Test_command_block()\n  au BufNew *.xml {\n      g:otherVar = 'other'\n    }\n  split other.xml\n  assert_equal('other', g:otherVar)\n\n  bwipe!\n  au! BufNew *.xml\n  unlet g:otherVar\nenddef\n\nfunc g:NoSuchFunc()\n  echo 'none'\nendfunc\n\ndef Test_try_catch_throw()\n  var l = []\n  try # comment\n    add(l, '1')\n    throw 'wrong'\n    add(l, '2')\n  catch # comment\n    add(l, v:exception)\n  finally # comment\n    add(l, '3')\n  endtry # comment\n  assert_equal(['1', 'wrong', '3'], l)\n\n  l = []\n  try\n    try\n      add(l, '1')\n      throw 'wrong'\n      add(l, '2')\n    catch /right/\n      add(l, v:exception)\n    endtry\n  catch /wrong/\n    add(l, 'caught')\n  finally\n    add(l, 'finally')\n  endtry\n  assert_equal(['1', 'caught', 'finally'], l)\n\n  var n: number\n  try\n    n = l[3]\n  catch /E684:/\n    n = 99\n  endtry\n  assert_equal(99, n)\n\n  var done = 'no'\n  if 0\n    try | catch | endtry\n  else\n    done = 'yes'\n  endif\n  assert_equal('yes', done)\n\n  done = 'no'\n  if 1\n    done = 'yes'\n  else\n    try | catch | endtry\n    done = 'never'\n  endif\n  assert_equal('yes', done)\n\n  if 1\n  else\n    try | catch /pat/ | endtry\n    try | catch /pat/ \n    endtry\n    try \n    catch /pat/ | endtry\n    try \n    catch /pat/ \n    endtry\n  endif\n\n  try\n    # string slice returns a string, not a number\n    n = g:astring[3]\n  catch /E1012:/\n    n = 77\n  endtry\n  assert_equal(77, n)\n\n  try\n    n = l[g:astring]\n  catch /E1012:/\n    n = 88\n  endtry\n  assert_equal(88, n)\n\n  try\n    n = s:does_not_exist\n  catch /E121:/\n    n = 111\n  endtry\n  assert_equal(111, n)\n\n  try\n    n = g:does_not_exist\n  catch /E121:/\n    n = 121\n  endtry\n  assert_equal(121, n)\n\n  var d = {one: 1}\n  try\n    n = d[g:astring]\n  catch /E716:/\n    n = 222\n  endtry\n  assert_equal(222, n)\n\n  try\n    n = -g:astring\n  catch /E1012:/\n    n = 233\n  endtry\n  assert_equal(233, n)\n\n  try\n    n = +g:astring\n  catch /E1012:/\n    n = 244\n  endtry\n  assert_equal(244, n)\n\n  try\n    n = +g:alist\n  catch /E1012:/\n    n = 255\n  endtry\n  assert_equal(255, n)\n\n  var nd: dict<any>\n  try\n    nd = {[g:alist]: 1}\n  catch /E1105:/\n    n = 266\n  endtry\n  assert_equal(266, n)\n\n  l = [1, 2, 3] \n  try\n    [n] = l\n  catch /E1093:/\n    n = 277\n  endtry\n  assert_equal(277, n)\n\n  try\n    &ts = g:astring\n  catch /E1012:/\n    n = 288\n  endtry\n  assert_equal(288, n)\n\n  try\n    &backspace = 'asdf'\n  catch /E474:/\n    n = 299\n  endtry\n  assert_equal(299, n)\n\n  l = [1]\n  try\n    l[3] = 3\n  catch /E684:/\n    n = 300\n  endtry\n  assert_equal(300, n)\n\n  try\n    unlet g:does_not_exist\n  catch /E108:/\n    n = 322\n  endtry\n  assert_equal(322, n)\n\n  try\n    d = {text: 1, [g:astring]: 2}\n  catch /E721:/\n    n = 333\n  endtry\n  assert_equal(333, n)\n\n  try\n    l = g:DeletedFunc()\n  catch /E933:/\n    n = 344\n  endtry\n  assert_equal(344, n)\n\n  try\n    echo range(1, 2, 0)\n  catch /E726:/\n    n = 355\n  endtry\n  assert_equal(355, n)\n\n  var P = function('g:NoSuchFunc')\n  delfunc g:NoSuchFunc\n  try\n    echo P()\n  catch /E117:/\n    n = 366\n  endtry\n  assert_equal(366, n)\n\n  try\n    echo g:NoSuchFunc()\n  catch /E117:/\n    n = 377\n  endtry\n  assert_equal(377, n)\n\n  try\n    echo g:alist + 4\n  catch /E745:/\n    n = 388\n  endtry\n  assert_equal(388, n)\n\n  try\n    echo 4 + g:alist\n  catch /E745:/\n    n = 399\n  endtry\n  assert_equal(399, n)\n\n  try\n    echo g:alist.member\n  catch /E715:/\n    n = 400\n  endtry\n  assert_equal(400, n)\n\n  try\n    echo d.member\n  catch /E716:/\n    n = 411\n  endtry\n  assert_equal(411, n)\n\n  var counter = 0\n  for i in range(4)\n    try\n      eval [][0]\n    catch\n    endtry\n    counter += 1\n  endfor\n  assert_equal(4, counter)\n\n  # no requirement for spaces before |\n  try|echo 0|catch|endtry\n\n  # return in try with finally\n  def ReturnInTry(): number\n    var ret = 4\n    try\n      return ret\n    catch /this/\n      return -1\n    catch /that/\n      return -1\n    finally\n      # changing ret has no effect\n      ret = 7\n    endtry\n    return -2\n  enddef\n  assert_equal(4, ReturnInTry())\n\n  # return in catch with finally\n  def ReturnInCatch(): number\n    var ret = 5\n    try\n      throw 'getout'\n      return -1\n    catch /getout/\n      # ret is evaluated here\n      return ret\n    finally\n      # changing ret later has no effect\n      ret = -3\n    endtry\n    return -2\n  enddef\n  assert_equal(5, ReturnInCatch())\n\n  # return in finally after empty catch\n  def ReturnInFinally(): number\n    try\n    finally\n      return 6\n    endtry\n  enddef\n  assert_equal(6, ReturnInFinally())\n\n  var lines =<< trim END\n      vim9script\n      try\n        acos('0.5')\n          ->setline(1)\n      catch\n        g:caught = v:exception\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_match('E1219: Float or Number required for argument 1', g:caught)\n  unlet g:caught\n\n  # missing catch and/or finally\n  lines =<< trim END\n      vim9script\n      try\n        echo 'something'\n      endtry\n  END\n  v9.CheckScriptFailure(lines, 'E1032:')\n\n  # skipping try-finally-endtry when try-finally-endtry is used in another block\n  lines =<< trim END\n      if v:true\n        try\n        finally\n        endtry\n      else\n        try\n        finally\n        endtry\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_try_var_decl()\n  var lines =<< trim END\n      vim9script\n      try\n        var in_try = 1\n        assert_equal(1, get(s:, 'in_try', -1))\n        throw \"getout\"\n      catch\n        var in_catch = 2\n        assert_equal(-1, get(s:, 'in_try', -1))\n        assert_equal(2, get(s:, 'in_catch', -1))\n      finally\n        var in_finally = 3\n        assert_equal(-1, get(s:, 'in_try', -1))\n        assert_equal(-1, get(s:, 'in_catch', -1))\n        assert_equal(3, get(s:, 'in_finally', -1))\n      endtry\n      assert_equal(-1, get(s:, 'in_try', -1))\n      assert_equal(-1, get(s:, 'in_catch', -1))\n      assert_equal(-1, get(s:, 'in_finally', -1))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_try_ends_in_return()\n  var lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch\n          return 'caught'\n        endtry\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch\n          return 'caught'\n        endtry\n        echo 'notreached'\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptFailure(lines, 'E1095:')\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch /x/\n          return 'caught'\n        endtry\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptFailure(lines, 'E1027:')\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          echo 'foo'\n        catch\n          echo 'caught'\n        finally\n          return 'done'\n        endtry\n      enddef\n      assert_equal('done', Foo())\n  END\n  v9.CheckScriptSuccess(lines)\n\nenddef\n\ndef Test_try_in_catch()\n  var lines =<< trim END\n      vim9script\n      var seq = []\n      def DoIt()\n        try\n          seq->add('throw 1')\n          eval [][0]\n          seq->add('notreached')\n        catch\n          seq->add('catch')\n          try\n            seq->add('throw 2')\n            eval [][0]\n            seq->add('notreached')\n          catch /nothing/\n            seq->add('notreached')\n          endtry\n          seq->add('done')\n        endtry\n      enddef\n      DoIt()\n      assert_equal(['throw 1', 'catch', 'throw 2', 'done'], seq)\n  END\nenddef\n\ndef Test_error_in_catch()\n  var lines =<< trim END\n      try\n        eval [][0]\n      catch /E684:/\n        eval [][0]\n      endtry\n  END\n  v9.CheckDefExecFailure(lines, 'E684:', 4)\nenddef\n\n\" :while at the very start of a function that :continue jumps to\ndef s:TryContinueFunc()\n while g:Count < 2\n   g:sequence ..= 't'\n    try\n      echoerr 'Test'\n    catch\n      g:Count += 1\n      g:sequence ..= 'c'\n      continue\n    endtry\n    g:sequence ..= 'e'\n    g:Count += 1\n  endwhile\nenddef\n\ndef Test_continue_in_try_in_while()\n  g:Count = 0\n  g:sequence = ''\n  TryContinueFunc()\n  assert_equal('tctc', g:sequence)\n  unlet g:Count\n  unlet g:sequence\nenddef\n\ndef Test_break_in_try_in_for()\n  var lines =<< trim END\n      vim9script\n      def Ls(): list<string>\n        var ls: list<string>\n        for s in ['abc', 'def']\n          for _ in [123, 456]\n            try\n              eval [][0]\n            catch\n              break\n            endtry\n          endfor\n          ls += [s]\n        endfor\n        return ls\n      enddef\n      assert_equal(['abc', 'def'], Ls())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nocatch_return_in_try()\n  # return in try block returns normally\n  def ReturnInTry(): string\n    try\n      return '\"some message\"'\n    catch\n    endtry\n    return 'not reached'\n  enddef\n  exe 'echoerr ' .. ReturnInTry()\nenddef\n\ndef Test_cnext_works_in_catch()\n  var lines =<< trim END\n      vim9script\n      au BufEnter * eval 1 + 2\n      writefile(['text'], 'Xfile1')\n      writefile(['text'], 'Xfile2')\n      var items = [\n          {lnum: 1, filename: 'Xfile1', valid: true},\n          {lnum: 1, filename: 'Xfile2', valid: true}\n        ]\n      setqflist([], ' ', {items: items})\n      cwindow\n\n      def CnextOrCfirst()\n        # if cnext fails, cfirst is used\n        try\n          cnext\n        catch\n          cfirst\n        endtry\n      enddef\n\n      CnextOrCfirst()\n      CnextOrCfirst()\n      writefile([getqflist({idx: 0}).idx], 'Xresult')\n      qall\n  END\n  writefile(lines, 'XCatchCnext')\n  g:RunVim([], [], '--clean -S XCatchCnext')\n  assert_equal(['1'], readfile('Xresult'))\n\n  delete('Xfile1')\n  delete('Xfile2')\n  delete('XCatchCnext')\n  delete('Xresult')\nenddef\n\ndef Test_throw_skipped()\n  if 0\n    throw dontgethere\n  endif\nenddef\n\ndef Test_nocatch_throw_silenced()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      throw 'error'\n    enddef\n    silent! Func()\n  END\n  writefile(lines, 'XthrowSilenced')\n  source XthrowSilenced\n  delete('XthrowSilenced')\nenddef\n\ndef DeletedFunc(): list<any>\n  return ['delete me']\nenddef\ndefcompile\ndelfunc DeletedFunc\n\ndef s:ThrowFromDef()\n  throw \"getout\" # comment\nenddef\n\nfunc s:CatchInFunc()\n  try\n    call s:ThrowFromDef()\n  catch\n    let g:thrown_func = v:exception\n  endtry\nendfunc\n\ndef s:CatchInDef()\n  try\n    ThrowFromDef()\n  catch\n    g:thrown_def = v:exception\n  endtry\nenddef\n\ndef s:ReturnFinally(): string\n  try\n    return 'intry'\n  finally\n    g:in_finally = 'finally'\n  endtry\n  return 'end'\nenddef\n\ndef Test_try_catch_nested()\n  CatchInFunc()\n  assert_equal('getout', g:thrown_func)\n\n  CatchInDef()\n  assert_equal('getout', g:thrown_def)\n\n  assert_equal('intry', ReturnFinally())\n  assert_equal('finally', g:in_finally)\n\n  var l = []\n  try\n    l->add('1')\n    throw 'bad'\n    l->add('x')\n  catch /bad/\n    l->add('2')\n    try\n      l->add('3')\n      throw 'one'\n      l->add('x')\n    catch /one/\n      l->add('4')\n      try\n        l->add('5')\n        throw 'more'\n        l->add('x')\n      catch /more/\n        l->add('6')\n      endtry\n    endtry\n  endtry\n  assert_equal(['1', '2', '3', '4', '5', '6'], l)\n\n  l = []\n  try\n    try\n      l->add('1')\n      throw 'foo'\n      l->add('x')\n    catch\n      l->add('2')\n      throw 'bar'\n      l->add('x')\n    finally\n      l->add('3')\n    endtry\n    l->add('x')\n  catch /bar/\n    l->add('4')\n  endtry\n  assert_equal(['1', '2', '3', '4'], l)\nenddef\n\ndef s:TryOne(): number\n  try\n    return 0\n  catch\n  endtry\n  return 0\nenddef\n\ndef s:TryTwo(n: number): string\n  try\n    var x = {}\n  catch\n  endtry\n  return 'text'\nenddef\n\ndef Test_try_catch_twice()\n  assert_equal('text', TryOne()->TryTwo())\nenddef\n\ndef Test_try_catch_match()\n  var seq = 'a'\n  try\n    throw 'something'\n  catch /nothing/\n    seq ..= 'x'\n  catch /some/\n    seq ..= 'b'\n  catch /asdf/\n    seq ..= 'x'\n  catch ?a\\?sdf?\n    seq ..= 'y'\n  finally\n    seq ..= 'c'\n  endtry\n  assert_equal('abc', seq)\nenddef\n\ndef Test_try_catch_fails()\n  v9.CheckDefFailure(['catch'], 'E603:')\n  v9.CheckDefFailure(['try', 'echo 0', 'catch', 'catch'], 'E1033:')\n  v9.CheckDefFailure(['try', 'echo 0', 'catch /pat'], 'E1067:')\n  v9.CheckDefFailure(['finally'], 'E606:')\n  v9.CheckDefFailure(['try', 'echo 0', 'finally', 'echo 1', 'finally'], 'E607:')\n  v9.CheckDefFailure(['endtry'], 'E602:')\n  v9.CheckDefFailure(['while 1', 'endtry'], 'E170:')\n  v9.CheckDefFailure(['for i in range(5)', 'endtry'], 'E170:')\n  v9.CheckDefFailure(['if 1', 'endtry'], 'E171:')\n  v9.CheckDefFailure(['try', 'echo 1', 'endtry'], 'E1032:')\n\n  v9.CheckDefFailure(['throw'], 'E1143:')\n  v9.CheckDefFailure(['throw xxx'], 'E1001:')\nenddef\n\ndef Try_catch_skipped()\n  var l = []\n  try\n  finally\n  endtry\n\n  if 1\n  else\n    try\n    endtry\n  endif\nenddef\n\n\" The skipped try/endtry was updating the wrong instruction.\ndef Test_try_catch_skipped()\n  var instr = execute('disassemble Try_catch_skipped')\n  assert_match(\"NEWLIST size 0\\n\", instr)\nenddef\n\ndef Test_throw_line_number()\n  def Func()\n    eval 1 + 1\n    eval 2 + 2\n    throw 'exception'\n  enddef\n  try\n    Func()\n  catch /exception/\n    assert_match('line 3', v:throwpoint)\n  endtry\nenddef\n\n\ndef Test_throw_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      try\n        throw 'one'\n              .. 'two'\n      catch\n        assert_equal('onetwo', v:exception)\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    @r = ''\n    def Func()\n      throw @r\n    enddef\n    var result = ''\n    try\n      Func()\n    catch /E1129:/\n      result = 'caught'\n    endtry\n    assert_equal('caught', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_error_in_nested_function()\n  # an error in a nested :function aborts executing in the calling :def function\n  var lines =<< trim END\n      vim9script\n      def Func()\n        Error()\n        g:test_var = 1\n      enddef\n      func Error() abort\n        eval [][0]\n      endfunc\n      Func()\n  END\n  g:test_var = 0\n  v9.CheckScriptFailure(lines, 'E684:')\n  assert_equal(0, g:test_var)\nenddef\n\ndef Test_abort_after_error()\n  var lines =<< trim END\n      vim9script\n      while true\n        echo notfound\n      endwhile\n      g:gotthere = true\n  END\n  g:gotthere = false\n  v9.CheckScriptFailure(lines, 'E121:')\n  assert_false(g:gotthere)\n  unlet g:gotthere\nenddef\n\ndef Test_cexpr_vimscript()\n  # only checks line continuation\n  set errorformat=File\\ %f\\ line\\ %l\n  var lines =<< trim END\n      vim9script\n      cexpr 'File'\n                .. ' someFile' ..\n                   ' line 19'\n      assert_equal(19, getqflist()[0].lnum)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def CexprFail()\n        au QuickfixCmdPre * echo g:doesnotexist\n        cexpr 'File otherFile line 99'\n        g:didContinue = 'yes'\n      enddef\n      CexprFail()\n      g:didContinue = 'also'\n  END\n  g:didContinue = 'no'\n  v9.CheckScriptFailure(lines, 'E121: Undefined variable: g:doesnotexist')\n  assert_equal('no', g:didContinue)\n  au! QuickfixCmdPre\n\n  lines =<< trim END\n      vim9script\n      def CexprFail()\n        cexpr g:aNumber\n        g:didContinue = 'yes'\n      enddef\n      CexprFail()\n      g:didContinue = 'also'\n  END\n  g:aNumber = 123\n  g:didContinue = 'no'\n  v9.CheckScriptFailure(lines, 'E777: String or List expected')\n  assert_equal('no', g:didContinue)\n  unlet g:didContinue\n\n  set errorformat&\nenddef\n\ndef Test_statusline_syntax()\n  # legacy syntax is used for 'statusline'\n  var lines =<< trim END\n      vim9script\n      func g:Status()\n        return '%{\"x\" is# \"x\"}'\n      endfunc\n      set laststatus=2 statusline=%!Status()\n      redrawstatus\n      set laststatus statusline= \n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_vimscript()\n  # checks line continuation and comments\n  var lines =<< trim END\n      vim9script\n      var mylist = [\n            'one',\n            # comment\n            'two', # empty line follows\n\n            'three',\n            ]\n      assert_equal(['one', 'two', 'three'], mylist)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # check all lines from heredoc are kept\n  lines =<< trim END\n      # comment 1\n      two\n      # comment 3\n\n      five\n      # comment 6\n  END\n  assert_equal(['# comment 1', 'two', '# comment 3', '', 'five', '# comment 6'], lines)\n\n  lines =<< trim END\n    [{\n      a: 0}]->string()->assert_equal(\"[{'a': 0}]\")\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nif has('channel')\n  let someJob = test_null_job()\n\n  def FuncWithError()\n    echomsg g:someJob\n  enddef\n\n  func Test_convert_emsg_to_exception()\n    try\n      call FuncWithError()\n    catch\n      call assert_match('Vim:E908:', v:exception)\n    endtry\n  endfunc\nendif\n\ndef Test_vim9script_mix()\n  var lines =<< trim END\n    if has(g:feature)\n      \" legacy script\n      let g:legacy = 1\n      finish\n    endif\n    vim9script\n    g:legacy = 0\n  END\n  g:feature = 'eval'\n  g:legacy = -1\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:legacy)\n\n  g:feature = 'noteval'\n  g:legacy = -1\n  v9.CheckScriptSuccess(lines)\n  assert_equal(0, g:legacy)\nenddef\n\ndef Test_vim9script_fails()\n  v9.CheckScriptFailure(['scriptversion 2', 'vim9script'], 'E1039:')\n  v9.CheckScriptFailure(['vim9script', 'scriptversion 2'], 'E1040:')\n\n  v9.CheckScriptFailure(['vim9script', 'var str: string', 'str = 1234'], 'E1012:')\n  v9.CheckScriptFailure(['vim9script', 'const str = \"asdf\"', 'str = \"xxx\"'], 'E46:')\n\n  assert_fails('vim9script', 'E1038:')\n  v9.CheckDefFailure(['vim9script'], 'E1038:')\n\n  # no error when skipping\n  if has('nothing')\n    vim9script\n  endif\nenddef\n\ndef Test_script_var_shadows_function()\n  var lines =<< trim END\n      vim9script\n      def Func(): number\n        return 123\n      enddef\n      var Func = 1\n  END\n  v9.CheckScriptFailure(lines, 'E1041:', 5)\nenddef\n\ndef Test_function_shadows_script_var()\n  var lines =<< trim END\n      vim9script\n      var Func = 1\n      def Func(): number\n        return 123\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1041:', 3)\nenddef\n\ndef Test_script_var_shadows_command()\n  var lines =<< trim END\n      var undo = 1\n      undo = 2\n      assert_equal(2, undo)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var undo = 1\n      undo\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\nenddef\n\ndef Test_vim9script_call_wrong_type()\n  var lines =<< trim END\n      vim9script\n      var Time = 'localtime'\n      Time()\n  END\n  v9.CheckScriptFailure(lines, 'E1085:')\nenddef\n\ndef Test_vim9script_reload_delfunc()\n  var first_lines =<< trim END\n    vim9script\n    def FuncYes(): string\n      return 'yes'\n    enddef\n  END\n  var withno_lines =<< trim END\n    def FuncNo(): string\n      return 'no'\n    enddef\n    def g:DoCheck(no_exists: bool)\n      assert_equal('yes', FuncYes())\n      assert_equal('no', FuncNo())\n    enddef\n  END\n  var nono_lines =<< trim END\n    def g:DoCheck(no_exists: bool)\n      assert_equal('yes', FuncYes())\n      assert_fails('FuncNo()', 'E117:', '', 2, 'DoCheck')\n    enddef\n  END\n\n  # FuncNo() is defined\n  writefile(first_lines + withno_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(true)\n\n  # FuncNo() is not redefined\n  writefile(first_lines + nono_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(false)\n\n  # FuncNo() is back\n  writefile(first_lines + withno_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(false)\n\n  delete('Xreloaded.vim')\nenddef\n\ndef Test_vim9script_reload_delvar()\n  # write the script with a script-local variable\n  var lines =<< trim END\n    vim9script\n    var name = 'string'\n  END\n  writefile(lines, 'XreloadVar.vim')\n  source XreloadVar.vim\n\n  # now write the script using the same variable locally - works\n  lines =<< trim END\n    vim9script\n    def Func()\n      var name = 'string'\n    enddef\n  END\n  writefile(lines, 'XreloadVar.vim')\n  source XreloadVar.vim\n\n  delete('XreloadVar.vim')\nenddef\n\ndef Test_func_redefine_error()\n  var lines = [\n        'vim9script',\n        'def Func()',\n        '  eval [][0]',\n        'enddef',\n        'Func()',\n        ]\n  writefile(lines, 'Xtestscript.vim')\n\n  for count in range(3)\n    try\n      source Xtestscript.vim\n    catch /E684/\n      # function name should contain <SNR> every time\n      assert_match('E684: List index out of range', v:exception)\n      assert_match('function <SNR>\\d\\+_Func, line 1', v:throwpoint)\n    endtry\n  endfor\n\n  delete('Xtestscript.vim')\nenddef\n\ndef Test_func_redefine_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      echo 'one'\n    enddef\n    def Func()\n      echo 'two'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1073:')\n\n  lines =<< trim END\n    vim9script\n    def Foo(): string\n      return 'foo'\n    enddef\n    def Func()\n      var  Foo = {-> 'lambda'}\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1073:')\nenddef\n\ndef Test_fixed_size_list()\n  # will be allocated as one piece of memory, check that changes work\n  var l = [1, 2, 3, 4]\n  l->remove(0)\n  l->add(5)\n  l->insert(99, 1)\n  assert_equal([2, 99, 3, 4, 5], l)\nenddef\n\ndef Test_no_insert_xit()\n  v9.CheckDefExecFailure(['a = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['c = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['i = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['t = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['x = 1'], 'E1100:')\n\n  v9.CheckScriptFailure(['vim9script', 'a = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'a'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'c = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'c'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'i = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'i'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'o = 1'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'o'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 't'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 't = 1'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'x = 1'], 'E1100:')\nenddef\n\ndef s:IfElse(what: number): string\n  var res = ''\n  if what == 1\n    res = \"one\"\n  elseif what == 2\n    res = \"two\"\n  else\n    res = \"three\"\n  endif\n  return res\nenddef\n\ndef Test_if_elseif_else()\n  assert_equal('one', IfElse(1))\n  assert_equal('two', IfElse(2))\n  assert_equal('three', IfElse(3))\nenddef\n\ndef Test_if_elseif_else_fails()\n  v9.CheckDefFailure(['elseif true'], 'E582:')\n  v9.CheckDefFailure(['else'], 'E581:')\n  v9.CheckDefFailure(['endif'], 'E580:')\n  v9.CheckDefFailure(['if g:abool', 'elseif xxx'], 'E1001:')\n  v9.CheckDefFailure(['if true', 'echo 1'], 'E171:')\n\n  var lines =<< trim END\n      var s = ''\n      if s = ''\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E488:')\n\n  lines =<< trim END\n      var s = ''\n      if s == ''\n      elseif s = ''\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E488:')\n\n  lines =<< trim END\n      var cond = true\n      if cond\n        echo 'true'\n      elseif\n        echo 'false'\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1143:', 'E15:'], 4)\nenddef\n\ndef Test_if_else_func_using_var()\n  var lines =<< trim END\n      vim9script\n\n      const debug = true\n      if debug\n        var mode_chars = 'something'\n        def Bits2Ascii()\n          var x = mode_chars\n          g:where = 'in true'\n        enddef\n      else\n        def Bits2Ascii()\n          g:where = 'in false'\n        enddef\n      endif\n\n      Bits2Ascii()\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal('in true', g:where)\n  unlet g:where\n\n  lines =<< trim END\n      vim9script\n\n      const debug = false\n      if debug\n        var mode_chars = 'something'\n        def Bits2Ascii()\n          g:where = 'in true'\n        enddef\n      else\n        def Bits2Ascii()\n          var x = mode_chars\n          g:where = 'in false'\n        enddef\n      endif\n\n      Bits2Ascii()\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: mode_chars')\nenddef\n\nlet g:bool_true = v:true\nlet g:bool_false = v:false\n\ndef Test_if_const_expr()\n  var res = false\n  if true ? true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  g:glob = 2\n  if false\n    execute('g:glob = 3')\n  endif\n  assert_equal(2, g:glob)\n  if true\n    execute('g:glob = 3')\n  endif\n  assert_equal(3, g:glob)\n\n  res = false\n  if g:bool_true ? true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? g:bool_true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? true : g:bool_false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? false : true\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if false ? false : true\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if false ? true : false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if has('xyz') ? true : false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true && true\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if g:bool_true && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true && g:bool_false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if false && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true || false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if g:bool_true || false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true || g:bool_false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if false || false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  # with constant \"false\" expression may be invalid so long as the syntax is OK\n  if false | eval 1 + 2 | endif\n  if false | eval burp + 234 | endif\n  if false | echo burp 234 'asd' | endif\n  if false\n    burp\n  endif\n\n  if 0\n    if 1\n      echo nothing\n    elseif 1\n      echo still nothing\n    endif\n  endif\n\n  # expression with line breaks skipped\n  if false\n      ('aaa'\n      .. 'bbb'\n      .. 'ccc'\n      )->setline(1)\n  endif\nenddef\n\ndef Test_if_const_expr_fails()\n  v9.CheckDefFailure(['if \"aaa\" == \"bbb'], 'E114:')\n  v9.CheckDefFailure([\"if 'aaa' == 'bbb\"], 'E115:')\n  v9.CheckDefFailure([\"if has('aaa'\"], 'E110:')\n  v9.CheckDefFailure([\"if has('aaa') ? true false\"], 'E109:')\nenddef\n\ndef s:RunNested(i: number): number\n  var x: number = 0\n  if i % 2\n    if 1\n      # comment\n    else\n      # comment\n    endif\n    x += 1\n  else\n    x += 1000\n  endif\n  return x\nenddef\n\ndef Test_nested_if()\n  assert_equal(1, RunNested(1))\n  assert_equal(1000, RunNested(2))\nenddef\n\ndef Test_execute_cmd()\n  # missing argument is ignored\n  execute\n  execute # comment\n\n  new\n  setline(1, 'default')\n  execute 'setline(1, \"execute-string\")'\n  assert_equal('execute-string', getline(1))\n\n  execute \"setline(1, 'execute-string')\"\n  assert_equal('execute-string', getline(1))\n\n  var cmd1 = 'setline(1,'\n  var cmd2 = '\"execute-var\")'\n  execute cmd1 cmd2 # comment\n  assert_equal('execute-var', getline(1))\n\n  execute cmd1 cmd2 '|setline(1, \"execute-var-string\")'\n  assert_equal('execute-var-string', getline(1))\n\n  var cmd_first = 'call '\n  var cmd_last = 'setline(1, \"execute-var-var\")'\n  execute cmd_first .. cmd_last\n  assert_equal('execute-var-var', getline(1))\n  bwipe!\n\n  var n = true\n  execute 'echomsg' (n ? '\"true\"' : '\"no\"')\n  assert_match('^true$', g:Screenline(&lines))\n\n  echomsg [1, 2, 3] {a: 1, b: 2}\n  assert_match('^\\[1, 2, 3\\] {''a'': 1, ''b'': 2}$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['execute xxx'], 'E1001:', 1)\n  v9.CheckDefExecFailure(['execute \"tabnext \" .. 8'], 'E475:', 1)\n  v9.CheckDefFailure(['execute \"cmd\"# comment'], 'E488:', 1)\n  if has('channel')\n    v9.CheckDefExecFailure(['execute test_null_channel()'], 'E908:', 1)\n  endif\nenddef\n\ndef Test_execute_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      execute 'g:someVar'\n                .. ' = ' ..\n                   '28'\n      assert_equal(28, g:someVar)\n      unlet g:someVar\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_execute_finish()\n  # the empty lines are relevant here\n  var lines =<< trim END\n      vim9script\n\n      var vname = \"g:hello\"\n\n      if exists(vname) | finish | endif | execute vname '= \"world\"'\n\n      assert_equal('world', g:hello)\n\n      if exists(vname) | finish | endif | execute vname '= \"world\"'\n\n      assert_report('should not be reached')\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echo_cmd()\n  echo 'some' # comment\n  echon 'thing'\n  assert_match('^something$', g:Screenline(&lines))\n\n  echo \"some\" # comment\n  echon \"thing\"\n  assert_match('^something$', g:Screenline(&lines))\n\n  var str1 = 'some'\n  var str2 = 'more'\n  echo str1 str2\n  assert_match('^some more$', g:Screenline(&lines))\n\n  echo \"one\\ntwo\"\n  assert_match('^one$', g:Screenline(&lines - 1))\n  assert_match('^two$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['echo \"xxx\"# comment'], 'E488:')\nenddef\n\ndef Test_echomsg_cmd()\n  echomsg 'some' 'more' # comment\n  assert_match('^some more$', g:Screenline(&lines))\n  echo 'clear'\n  :1messages\n  assert_match('^some more$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['echomsg \"xxx\"# comment'], 'E488:')\nenddef\n\ndef Test_echomsg_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      echomsg 'here'\n                .. ' is ' ..\n                   'a message'\n      assert_match('^here is a message$', g:Screenline(&lines))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echoerr_cmd()\n  var local = 'local'\n  try\n    echoerr 'something' local 'wrong' # comment\n  catch\n    assert_match('something local wrong', v:exception)\n  endtry\nenddef\n\ndef Test_echoerr_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      try\n        echoerr 'this'\n                .. ' is ' ..\n                   'wrong'\n      catch\n        assert_match('this is wrong', v:exception)\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echoconsole_cmd()\n  var local = 'local'\n  echoconsole 'something' local # comment\n  # output goes anywhere\nenddef\n\ndef Test_for_outside_of_function()\n  var lines =<< trim END\n    vim9script\n    new\n    for var in range(0, 3)\n      append(line('$'), var)\n    endfor\n    assert_equal(['', '0', '1', '2', '3'], getline(1, '$'))\n    bwipe!\n\n    var result = ''\n    for i in [1, 2, 3]\n      var loop = ' loop ' .. i\n      result ..= loop\n    endfor\n    assert_equal(' loop 1 loop 2 loop 3', result)\n  END\n  writefile(lines, 'Xvim9for.vim')\n  source Xvim9for.vim\n  delete('Xvim9for.vim')\nenddef\n\ndef Test_for_skipped_block()\n  # test skipped blocks at outside of function\n  var lines =<< trim END\n    var result = []\n    if true\n      for n in [1, 2]\n        result += [n]\n      endfor\n    else\n      for n in [3, 4]\n        result += [n]\n      endfor\n    endif\n    assert_equal([1, 2], result)\n\n    result = []\n    if false\n      for n in [1, 2]\n        result += [n]\n      endfor\n    else\n      for n in [3, 4]\n        result += [n]\n      endfor\n    endif\n    assert_equal([3, 4], result)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # test skipped blocks at inside of function\n  lines =<< trim END\n    def DefTrue()\n      var result = []\n      if true\n        for n in [1, 2]\n          result += [n]\n        endfor\n      else\n        for n in [3, 4]\n          result += [n]\n        endfor\n      endif\n      assert_equal([1, 2], result)\n    enddef\n    DefTrue()\n\n    def DefFalse()\n      var result = []\n      if false\n        for n in [1, 2]\n          result += [n]\n        endfor\n      else\n        for n in [3, 4]\n          result += [n]\n        endfor\n      endif\n      assert_equal([3, 4], result)\n    enddef\n    DefFalse()\n\n    def BuildDiagrams()\n      var diagrams: list<any>\n      if false\n        var max = 0\n        for v in diagrams\n          var l = 3\n          if max < l | max = l | endif\n          v->add(l)\n        endfor\n      endif\n    enddef\n    BuildDiagrams()\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_skipped_redir()\n  var lines =<< trim END\n      def T()\n        if 0\n          redir =>l[0]\n          redir END\n        endif\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_for_loop()\n  var lines =<< trim END\n      var result = ''\n      for cnt in range(7)\n        if cnt == 4\n          break\n        endif\n        if cnt == 2\n          continue\n        endif\n        result ..= cnt .. '_'\n      endfor\n      assert_equal('0_1_3_', result)\n\n      var concat = ''\n      for str in eval('[\"one\", \"two\"]')\n        concat ..= str\n      endfor\n      assert_equal('onetwo', concat)\n\n      var total = 0\n      for nr in\n          [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for nr\n        in [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for nr\n        in\n        [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      # with type\n      total = 0\n      for n: number in [1, 2, 3]\n        total += n\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for b in 0z010203\n        total += b\n      endfor\n      assert_equal(6, total)\n\n      var chars = ''\n      for s: string in 'foobar'\n        chars ..= s\n      endfor\n      assert_equal('foobar', chars)\n\n      chars = ''\n      for x: string in {a: 'a', b: 'b'}->values()\n        chars ..= x\n      endfor\n      assert_equal('ab', chars)\n\n      # unpack with type\n      var res = ''\n      for [n: number, s: string] in [[1, 'a'], [2, 'b']]\n        res ..= n .. s\n      endfor\n      assert_equal('1a2b', res)\n\n      # unpack with one var\n      var reslist = []\n      for [x] in [['aaa'], ['bbb']]\n        reslist->add(x)\n      endfor\n      assert_equal(['aaa', 'bbb'], reslist)\n\n      # loop over string\n      res = ''\n      for c in 'a\u00e9c\u0300d'\n        res ..= c .. '-'\n      endfor\n      assert_equal('a-\u00e9-c\u0300-d-', res)\n\n      res = ''\n      for c in ''\n        res ..= c .. '-'\n      endfor\n      assert_equal('', res)\n\n      res = ''\n      for c in test_null_string()\n        res ..= c .. '-'\n      endfor\n      assert_equal('', res)\n\n      total = 0\n      for c in null_list\n        total += 1\n      endfor\n      assert_equal(0, total)\n\n      for c in null_blob\n        total += 1\n      endfor\n      assert_equal(0, total)\n\n      var foo: list<dict<any>> = [\n              {a: 'Cat'}\n            ]\n      for dd in foo\n        dd.counter = 12\n      endfor\n      assert_equal([{a: 'Cat', counter: 12}], foo)\n\n      reslist = []\n      for _ in range(3)\n        reslist->add('x')\n      endfor\n      assert_equal(['x', 'x', 'x'], reslist)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop_with_closure()\n  var lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        flist[i] = () => inloop\n      endfor\n      for i in range(5)\n        assert_equal(4, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        flist[i] = () => {\n              return inloop\n            }\n      endfor\n      for i in range(5)\n        assert_equal(4, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop_fails()\n  v9.CheckDefAndScriptFailure(['for '], ['E1097:', 'E690:'])\n  v9.CheckDefAndScriptFailure(['for x'], ['E1097:', 'E690:'])\n  v9.CheckDefAndScriptFailure(['for x in'], ['E1097:', 'E15:'])\n  v9.CheckDefAndScriptFailure(['for # in range(5)'], 'E690:')\n  v9.CheckDefAndScriptFailure(['for i In range(5)'], 'E690:')\n  v9.CheckDefAndScriptFailure(['var x = 5', 'for x in range(5)', 'endfor'], ['E1017:', 'E1041:'])\n  v9.CheckScriptFailure(['vim9script', 'var x = 5', 'for x in range(5)', '# comment', 'endfor'], 'E1041:', 3)\n  v9.CheckScriptFailure(['def Func(arg: any)', 'for arg in range(5)', 'enddef', 'defcompile'], 'E1006:')\n  delfunc! g:Func\n  v9.CheckDefFailure(['for i in xxx'], 'E1001:')\n  v9.CheckDefFailure(['endfor'], 'E588:')\n  v9.CheckDefFailure(['for i in range(3)', 'echo 3'], 'E170:')\n\n  # wrong type detected at compile time\n  v9.CheckDefFailure(['for i in {a: 1}', 'echo 3', 'endfor'], 'E1177: For loop on dict not supported')\n\n  # wrong type detected at runtime\n  g:adict = {a: 1}\n  v9.CheckDefExecFailure(['for i in g:adict', 'echo 3', 'endfor'], 'E1177: For loop on dict not supported')\n  unlet g:adict\n\n  var lines =<< trim END\n      var d: list<dict<any>> = [{a: 0}]\n      for e in d\n        e = {a: 0, b: ''}\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1018:', 'E46:'], 3)\n\n  lines =<< trim END\n      for nr: number in ['foo']\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012: Type mismatch; expected number but got string', 1)\n\n  lines =<< trim END\n      for n : number in [1, 2]\n        echo n\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1059:', 1)\n\n  lines =<< trim END\n      var d: dict<number> = {a: 1, b: 2}\n      for [k: job, v: job] in d->items()\n        echo k v\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1163: Variable 1: type mismatch, expected job but got string', 'E1012: Type mismatch; expected job but got string'], 2)\n\n  lines =<< trim END\n      var i = 0\n      for i in [1, 2, 3]\n        echo i\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1017:', 'E1041:'])\n\n  lines =<< trim END\n      var l = [0]\n      for l[0] in [1, 2, 3]\n        echo l[0]\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E461:', 'E1017:'])\n\n  lines =<< trim END\n      var d = {x: 0}\n      for d.x in [1, 2, 3]\n        echo d.x\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E461:', 'E1017:'])\n\n  lines =<< trim END\n      var l: list<dict<any>> = [{a: 1, b: 'x'}]\n      for item: dict<number> in l\n        echo item\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1012: Type mismatch; expected dict<number> but got dict<any>')\n\n  lines =<< trim END\n      var l: list<dict<any>> = [{n: 1}]\n      for item: dict<number> in l\n        item->extend({s: ''})\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected dict<number> but got dict<string>')\nenddef\n\ndef Test_for_loop_script_var()\n  # cannot use s:var in a :def function\n  v9.CheckDefFailure(['for s:var in range(3)', 'echo 3'], 'E1254:')\n\n  # can use s:var in Vim9 script, with or without s:\n  var lines =<< trim END\n    vim9script\n    var total = 0\n    for s:var in [1, 2, 3]\n      total += s:var\n    endfor\n    assert_equal(6, total)\n\n    total = 0\n    for var in [1, 2, 3]\n      total += var\n    endfor\n    assert_equal(6, total)\n  END\nenddef\n\ndef Test_for_loop_unpack()\n  var lines =<< trim END\n      var result = []\n      for [v1, v2] in [[1, 2], [3, 4]]\n        result->add(v1)\n        result->add(v2)\n      endfor\n      assert_equal([1, 2, 3, 4], result)\n\n      result = []\n      for [v1, v2; v3] in [[1, 2], [3, 4, 5, 6]]\n        result->add(v1)\n        result->add(v2)\n        result->add(v3)\n      endfor\n      assert_equal([1, 2, [], 3, 4, [5, 6]], result)\n\n      result = []\n      for [&ts, &sw] in [[1, 2], [3, 4]]\n        result->add(&ts)\n        result->add(&sw)\n      endfor\n      assert_equal([1, 2, 3, 4], result)\n\n      var slist: list<string>\n      for [$LOOPVAR, @r, v:errmsg] in [['a', 'b', 'c'], ['d', 'e', 'f']]\n        slist->add($LOOPVAR)\n        slist->add(@r)\n        slist->add(v:errmsg)\n      endfor\n      assert_equal(['a', 'b', 'c', 'd', 'e', 'f'], slist)\n\n      slist = []\n      for [g:globalvar, b:bufvar, w:winvar, t:tabvar] in [['global', 'buf', 'win', 'tab'], ['1', '2', '3', '4']]\n        slist->add(g:globalvar)\n        slist->add(b:bufvar)\n        slist->add(w:winvar)\n        slist->add(t:tabvar)\n      endfor\n      assert_equal(['global', 'buf', 'win', 'tab', '1', '2', '3', '4'], slist)\n      unlet! g:globalvar b:bufvar w:winvar t:tabvar\n\n      var res = []\n      for [_, n, _] in [[1, 2, 3], [4, 5, 6]]\n        res->add(n)\n      endfor\n      assert_equal([2, 5], res)\n\n      var text: list<string> = [\"hello there\", \"goodbye now\"]\n      var splitted = ''\n      for [first; next] in mapnew(text, (i, v) => split(v))\n          splitted ..= string(first) .. string(next) .. '/'\n      endfor\n      assert_equal(\"'hello'['there']/'goodbye'['now']/\", splitted)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      for [v1, v2] in [[1, 2, 3], [3, 4]]\n        echo v1 v2\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E710:', 1)\n\n  lines =<< trim END\n      for [v1, v2] in [[1], [3, 4]]\n        echo v1 v2\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E711:', 1)\n\n  lines =<< trim END\n      for [v1, v1] in [[1, 2], [3, 4]]\n        echo v1\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E1017:', 1)\n\n  lines =<< trim END\n      for [a, b] in g:listlist\n        echo a\n      endfor\n  END\n  g:listlist = [1, 2, 3]\n  v9.CheckDefExecFailure(lines, 'E1140:', 1)\nenddef\n\ndef Test_for_loop_with_try_continue()\n  var lines =<< trim END\n      var looped = 0\n      var cleanup = 0\n      for i in range(3)\n        looped += 1\n        try\n          eval [][0]\n        catch\n          continue\n        finally\n          cleanup += 1\n        endtry\n      endfor\n      assert_equal(3, looped)\n      assert_equal(3, cleanup)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_while_skipped_block()\n  # test skipped blocks at outside of function\n  var lines =<< trim END\n    var result = []\n    var n = 0\n    if true\n      n = 1\n      while n < 3\n        result += [n]\n        n += 1\n      endwhile\n    else\n      n = 3\n      while n < 5\n        result += [n]\n        n += 1\n      endwhile\n    endif\n    assert_equal([1, 2], result)\n\n    result = []\n    if false\n      n = 1\n      while n < 3\n        result += [n]\n        n += 1\n      endwhile\n    else\n      n = 3\n      while n < 5\n        result += [n]\n        n += 1\n      endwhile\n    endif\n    assert_equal([3, 4], result)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # test skipped blocks at inside of function\n  lines =<< trim END\n    def DefTrue()\n      var result = []\n      var n = 0\n      if true\n        n = 1\n        while n < 3\n          result += [n]\n          n += 1\n        endwhile\n      else\n        n = 3\n        while n < 5\n          result += [n]\n          n += 1\n        endwhile\n      endif\n      assert_equal([1, 2], result)\n    enddef\n    DefTrue()\n\n    def DefFalse()\n      var result = []\n      var n = 0\n      if false\n        n = 1\n        while n < 3\n          result += [n]\n          n += 1\n        endwhile\n      else\n        n = 3\n        while n < 5\n          result += [n]\n          n += 1\n        endwhile\n      endif\n      assert_equal([3, 4], result)\n    enddef\n    DefFalse()\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_while_loop()\n  var result = ''\n  var cnt = 0\n  while cnt < 555\n    if cnt == 3\n      break\n    endif\n    cnt += 1\n    if cnt == 2\n      continue\n    endif\n    result ..= cnt .. '_'\n  endwhile\n  assert_equal('1_3_', result)\n\n  var s = ''\n  while s == 'x' # {comment}\n  endwhile\nenddef\n\ndef Test_while_loop_in_script()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n      var cnt = 0\n      while cnt < 3\n        var s = 'v' .. cnt\n        result ..= s\n        cnt += 1\n      endwhile\n      assert_equal('v0v1v2', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_while_loop_fails()\n  v9.CheckDefFailure(['while xxx'], 'E1001:')\n  v9.CheckDefFailure(['endwhile'], 'E588:')\n  v9.CheckDefFailure(['continue'], 'E586:')\n  v9.CheckDefFailure(['if true', 'continue'], 'E586:')\n  v9.CheckDefFailure(['break'], 'E587:')\n  v9.CheckDefFailure(['if true', 'break'], 'E587:')\n  v9.CheckDefFailure(['while 1', 'echo 3'], 'E170:')\n\n  var lines =<< trim END\n      var s = ''\n      while s = ''\n      endwhile\n  END\n  v9.CheckDefFailure(lines, 'E488:')\nenddef\n\ndef Test_interrupt_loop()\n  var caught = false\n  var x = 0\n  try\n    while 1\n      x += 1\n      if x == 100\n        feedkeys(\"\\<C-C>\", 'Lt')\n      endif\n    endwhile\n  catch\n    caught = true\n    assert_equal(100, x)\n  endtry\n  assert_true(caught, 'should have caught an exception')\n  # consume the CTRL-C\n  getchar(0)\nenddef\n\ndef Test_automatic_line_continuation()\n  var mylist = [\n      'one',\n      'two',\n      'three',\n      ] # comment\n  assert_equal(['one', 'two', 'three'], mylist)\n\n  var mydict = {\n      ['one']: 1,\n      ['two']: 2,\n      ['three']:\n          3,\n      } # comment\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n  mydict = {\n      one: 1,  # comment\n      two:     # comment\n           2,  # comment\n      three: 3 # comment\n      }\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n  mydict = {\n      one: 1, \n      two: \n           2, \n      three: 3 \n      }\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n\n  assert_equal(\n        ['one', 'two', 'three'],\n        split('one two three')\n        )\nenddef\n\ndef Test_vim9_comment()\n  v9.CheckScriptSuccess([\n      'vim9script',\n      '# something',\n      '#something',\n      '#{{something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      '#{something',\n      ], 'E1170:')\n\n  split Xfile\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'edit #something',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'edit #{something',\n      ])\n  close\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      ':# something',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      '# something',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      ':# something',\n      ], 'E488:')\n\n  { # block start\n  } # block end\n  v9.CheckDefFailure([\n      '{# comment',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      '{',\n      '}# comment',\n      ], 'E488:')\n\n  echo \"yes\" # comment\n  v9.CheckDefFailure([\n      'echo \"yes\"# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'echo \"yes\" # something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'echo \"yes\"# something',\n      ], 'E121:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'echo# something',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'echo \"yes\" # something',\n      ], 'E121:')\n\n  exe \"echo\" # comment\n  v9.CheckDefFailure([\n      'exe \"echo\"# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'exe \"echo\" # something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'exe \"echo\"# something',\n      ], 'E121:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'exe# something',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'exe \"echo\" # something',\n      ], 'E121:')\n\n  v9.CheckDefFailure([\n      'try# comment',\n      '  echo \"yes\"',\n      'catch',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try# comment',\n      'echo \"yes\"',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  throw#comment',\n      'catch',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  throw \"yes\"#comment',\n      'catch',\n      'endtry',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      'try',\n      '  echo \"yes\"',\n      'catch# comment',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try',\n      '  echo \"yes\"',\n      'catch# comment',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  echo \"yes\"',\n      'catch /pat/# comment',\n      'endtry',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      'try',\n      'echo \"yes\"',\n      'catch',\n      'endtry# comment',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try',\n      '  echo \"yes\"',\n      'catch',\n      'endtry# comment',\n      ], 'E1144:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi Search # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi Search# comment',\n      ], 'E416:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi link This Search # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi link This That# comment',\n      ], 'E413:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi clear This # comment',\n      'hi clear # comment',\n      ])\n  # not tested, because it doesn't give an error but a warning:\n  # hi clear This# comment',\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi clear# comment',\n      ], 'E416:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi Group term=bold',\n      'match Group /todo/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi Group term=bold',\n      'match Group /todo/# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'match # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'match# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'match none # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'match none# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'menutrans clear # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'menutrans clear# comment text',\n      ], 'E474:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax clear # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax clear# comment text',\n      ], 'E28:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax keyword Word some',\n      'syntax clear Word # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax keyword Word some',\n      'syntax clear Word# comment text',\n      ], 'E28:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax list # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax list# comment text',\n      ], 'E28:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ oneline # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ oneline# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax keyword Word word # comm[ent',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax keyword Word word# comm[ent',\n      ], 'E789:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/# comment',\n      ], 'E402:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ contains=Something # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains=Something# comment',\n      ], 'E475:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains= # comment',\n      ], 'E406:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains=# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax region Word start=/pat/ end=/pat/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax region Word start=/pat/ end=/pat/# comment',\n      ], 'E402:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax sync # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax sync# comment',\n      ], 'E404:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax sync ccomment # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax sync ccomment# comment',\n      ], 'E404:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax cluster Some contains=Word # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax cluster Some contains=Word# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'command Echo echo # comment',\n      'command Echo # comment',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo echo# comment',\n      'Echo',\n      ], 'E1144:')\n  delcommand Echo\n\n  var curdir = getcwd()\n  v9.CheckScriptSuccess([\n      'command Echo cd \" comment',\n      'Echo',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'command Echo cd # comment',\n      'Echo',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo cd \" comment',\n      'Echo',\n      ], 'E344:')\n  delcommand Echo\n  chdir(curdir)\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo# comment',\n      ], 'E182:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo echo',\n      'command Echo# comment',\n      ], 'E182:')\n  delcommand Echo\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'function # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'function \" comment',\n      ], 'E129:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'function# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'import \"./vim9.vim\" as v9',\n      'function v9.CheckScriptSuccess # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'import \"./vim9.vim\" as v9',\n      'function v9.CheckScriptSuccess# comment',\n      ], 'E1048: Item not found in script: CheckScriptSuccess#')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func g:DeleteMeA()',\n      'endfunc',\n      'delfunction g:DeleteMeA # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func g:DeleteMeB()',\n      'endfunc',\n      'delfunction g:DeleteMeB# comment',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'call execute(\"ls\") # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'call execute(\"ls\")# comment',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'def Test() \" comment',\n      'enddef',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def Test() \" comment',\n      'enddef',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'func Test() \" comment',\n      'endfunc',\n      'delfunc Test',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func Test() \" comment',\n      'endfunc',\n      ])\n\n  v9.CheckScriptSuccess([\n      'def Test() # comment',\n      'enddef',\n      ])\n  v9.CheckScriptFailure([\n      'func Test() # comment',\n      'endfunc',\n      ], 'E488:')\n\n  var lines =<< trim END\n      vim9script\n      syn region Text\n      \\ start='foo'\n      #\\ comment\n      \\ end='bar'\n      syn region Text start='foo'\n      #\\ comment\n      \\ end='bar'\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      syn region Text\n      \\ start='foo'\n      \"\\ comment\n      \\ end='bar'\n  END\n  v9.CheckScriptFailure(lines, 'E399:')\nenddef\n\ndef Test_vim9_comment_gui()\n  CheckCanRunGui\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'gui#comment'\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'gui -f#comment'\n      ], 'E194:')\nenddef\n\ndef Test_vim9_comment_not_compiled()\n  au TabEnter *.vim g:entered = 1\n  au TabEnter *.x g:entered = 2\n\n  edit test.vim\n  doautocmd TabEnter #comment\n  assert_equal(1, g:entered)\n\n  doautocmd TabEnter f.x\n  assert_equal(2, g:entered)\n\n  g:entered = 0\n  doautocmd TabEnter f.x #comment\n  assert_equal(2, g:entered)\n\n  assert_fails('doautocmd Syntax#comment', 'E216:')\n\n  au! TabEnter\n  unlet g:entered\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'g:var = 123',\n      'b:var = 456',\n      'w:var = 777',\n      't:var = 888',\n      'unlet g:var w:var # something',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'let var = 123',\n      ], 'E1126: Cannot use :let in Vim9 script')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var g:var = 123',\n      ], 'E1016: Cannot declare a global variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var b:var = 123',\n      ], 'E1016: Cannot declare a buffer variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var w:var = 123',\n      ], 'E1016: Cannot declare a window variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var t:var = 123',\n      ], 'E1016: Cannot declare a tab variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var v:version = 123',\n      ], 'E1016: Cannot declare a v: variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var $VARIABLE = \"text\"',\n      ], 'E1016: Cannot declare an environment variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'g:var = 123',\n      'unlet g:var# comment1',\n      ], 'E108:')\n\n  v9.CheckScriptFailure([\n      'let g:var = 123',\n      'unlet g:var # something',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'if 1 # comment2',\n      '  echo \"yes\"',\n      'elseif 2 #comment',\n      '  echo \"no\"',\n      'endif',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'if 1# comment3',\n      '  echo \"yes\"',\n      'endif',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'if 0 # comment4',\n      '  echo \"yes\"',\n      'elseif 2#comment',\n      '  echo \"no\"',\n      'endif',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'var v = 1 # comment5',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var v = 1# comment6',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'new'\n      'setline(1, [\"# define pat\", \"last\"])',\n      ':$',\n      'dsearch /pat/ #comment',\n      'bwipe!',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'new'\n      'setline(1, [\"# define pat\", \"last\"])',\n      ':$',\n      'dsearch /pat/#comment',\n      'bwipe!',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func! SomeFunc()',\n      ], 'E477:')\nenddef\n\ndef Test_finish()\n  var lines =<< trim END\n    vim9script\n    g:res = 'one'\n    if v:false | finish | endif\n    g:res = 'two'\n    finish\n    g:res = 'three'\n  END\n  writefile(lines, 'Xfinished')\n  source Xfinished\n  assert_equal('two', g:res)\n\n  unlet g:res\n  delete('Xfinished')\nenddef\n\ndef Test_forward_declaration()\n  var lines =<< trim END\n    vim9script\n    def GetValue(): string\n      return theVal\n    enddef\n    var theVal = 'something'\n    g:initVal = GetValue()\n    theVal = 'else'\n    g:laterVal = GetValue()\n  END\n  writefile(lines, 'Xforward')\n  source Xforward\n  assert_equal('something', g:initVal)\n  assert_equal('else', g:laterVal)\n\n  unlet g:initVal\n  unlet g:laterVal\n  delete('Xforward')\nenddef\n\ndef Test_declare_script_var_in_func()\n  var lines =<< trim END\n      vim9script\n      func Declare()\n        let s:local = 123\n      endfunc\n      Declare()\n  END\n  v9.CheckScriptFailure(lines, 'E1269:')\nenddef\n        \ndef Test_lock_script_var()\n  var lines =<< trim END\n      vim9script\n      var local = 123\n      assert_equal(123, local)\n\n      var error: string\n      try\n        local = 'asdf'\n      catch\n        error = v:exception\n      endtry\n      assert_match('E1012: Type mismatch; expected number but got string', error)\n\n      lockvar local\n      try\n        local = 999\n      catch\n        error = v:exception\n      endtry\n      assert_match('E741: Value is locked: local', error)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n        \n\nfunc Test_vim9script_not_global()\n  \" check that items defined in Vim9 script are script-local, not global\n  let vim9lines =<< trim END\n    vim9script\n    var name = 'local'\n    func TheFunc()\n      echo 'local'\n    endfunc\n    def DefFunc()\n      echo 'local'\n    enddef\n  END\n  call writefile(vim9lines, 'Xvim9script.vim')\n  source Xvim9script.vim\n  try\n    echo g:var\n    assert_report('did not fail')\n  catch /E121:/\n    \" caught\n  endtry\n  try\n    call TheFunc()\n    assert_report('did not fail')\n  catch /E117:/\n    \" caught\n  endtry\n  try\n    call DefFunc()\n    assert_report('did not fail')\n  catch /E117:/\n    \" caught\n  endtry\n\n  call delete('Xvim9script.vim')\nendfunc\n\ndef Test_vim9_copen()\n  # this was giving an error for setting w:quickfix_title\n  copen\n  quit\nenddef\n\ndef Test_script_var_in_autocmd()\n  # using a script variable from an autocommand, defined in a :def function in a\n  # legacy Vim script, cannot check the variable type.\n  var lines =<< trim END\n    let s:counter = 1\n    def s:Func()\n      au! CursorHold\n      au CursorHold * s:counter += 1\n    enddef\n    call s:Func()\n    doau CursorHold\n    call assert_equal(2, s:counter)\n    au! CursorHold\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_error_in_autoload_script()\n  var save_rtp = &rtp\n  var dir = getcwd() .. '/Xruntime'\n  &rtp = dir\n  mkdir(dir .. '/autoload', 'p')\n\n  var lines =<< trim END\n      vim9script noclear\n      export def Autoloaded()\n      enddef\n      def Broken()\n        var x: any = ''\n        eval x != 0\n      enddef\n      Broken()\n  END\n  writefile(lines, dir .. '/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      def CallAutoloaded()\n        script#Autoloaded()\n      enddef\n\n      function Legacy()\n        try\n          call s:CallAutoloaded()\n        catch\n          call assert_match('E1030: Using a String as a Number', v:exception)\n        endtry\n      endfunction\n\n      Legacy()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_error_in_autoload_script_foldexpr()\n  var save_rtp = &rtp\n  mkdir('Xvim/autoload', 'p')\n  &runtimepath = 'Xvim'\n\n  var lines =<< trim END\n      vim9script\n      eval [][0]\n      echomsg 'no error'\n  END\n  lines->writefile('Xvim/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      import autoload 'script.vim'\n      &foldmethod = 'expr'\n      &foldexpr = 'script.Func()'\n      redraw\n  END\n  v9.CheckScriptFailure(lines, 'E684: List index out of range: 0')\n\n  delete('Xvim', 'rf')\nenddef\n\ndef Test_invalid_sid()\n  assert_fails('func <SNR>1234_func', 'E123:')\n\n  if g:RunVim([], ['wq! Xdidit'], '+\"func <SNR>1_func\"')\n    assert_equal([], readfile('Xdidit'))\n  endif\n  delete('Xdidit')\nenddef\n\ndef Test_restoring_cpo()\n  writefile(['vim9script', 'set nocp'], 'Xsourced')\n  writefile(['call writefile([\"done\"], \"Xdone\")', 'quit!'], 'Xclose')\n  if g:RunVim([], [], '-u NONE +\"set cpo+=a\" -S Xsourced -S Xclose')\n    assert_equal(['done'], readfile('Xdone'))\n  endif\n  delete('Xsourced')\n  delete('Xclose')\n  delete('Xdone')\n\n  writefile(['vim9script', 'g:cpoval = &cpo'], 'XanotherScript')\n  set cpo=aABceFsMny>\n  edit XanotherScript\n  so %\n  assert_equal('aABceFsMny>', &cpo)\n  assert_equal('aABceFs', g:cpoval)\n  :1del\n  setline(1, 'let g:cpoval = &cpo')\n  w\n  so %\n  assert_equal('aABceFsMny>', &cpo)\n  assert_equal('aABceFsMny>', g:cpoval)\n\n  delete('XanotherScript')\n  set cpo&vim\n  unlet g:cpoval\n\n  if has('unix')\n    # 'cpo' is not restored in main vimrc\n    var save_HOME = $HOME\n    $HOME = getcwd() .. '/Xhome'\n    mkdir('Xhome')\n    var lines =<< trim END\n        vim9script\n        writefile(['before: ' .. &cpo], 'Xresult')\n        set cpo+=M\n        writefile(['after: ' .. &cpo], 'Xresult', 'a')\n    END\n    writefile(lines, 'Xhome/.vimrc')\n\n    lines =<< trim END\n        call writefile(['later: ' .. &cpo], 'Xresult', 'a')\n    END\n    writefile(lines, 'Xlegacy')\n\n    lines =<< trim END\n        vim9script\n        call writefile(['vim9: ' .. &cpo], 'Xresult', 'a')\n        qa\n    END\n    writefile(lines, 'Xvim9')\n\n    var cmd = g:GetVimCommand() .. \" -S Xlegacy -S Xvim9\"\n    cmd = substitute(cmd, '-u NONE', '', '')\n    exe \"silent !\" .. cmd\n\n    assert_equal([\n        'before: aABceFs',\n        'after: aABceFsM',\n        'later: aABceFsM',\n        'vim9: aABceFs'], readfile('Xresult'))\n\n    $HOME = save_HOME\n    delete('Xhome', 'rf')\n    delete('Xlegacy')\n    delete('Xvim9')\n    delete('Xresult')\n  endif\nenddef\n\n\" Use :function so we can use Check commands\nfunc Test_no_redraw_when_restoring_cpo()\n  CheckScreendump\n  CheckFeature timers\n  call Run_test_no_redraw_when_restoring_cpo()\nendfunc\n\ndef Run_test_no_redraw_when_restoring_cpo()\n  var lines =<< trim END\n    vim9script\n    export def Func()\n    enddef\n  END\n  mkdir('Xdir/autoload', 'p')\n  writefile(lines, 'Xdir/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      set cpo+=M\n      exe 'set rtp^=' .. getcwd() .. '/Xdir'\n      au CmdlineEnter : ++once timer_start(0, (_) => script#Func())\n      setline(1, 'some text')\n  END\n  writefile(lines, 'XTest_redraw_cpo')\n  var buf = g:RunVimInTerminal('-S XTest_redraw_cpo', {'rows': 6})\n  term_sendkeys(buf, \"V:\")\n  g:VerifyScreenDump(buf, 'Test_vim9_no_redraw', {})\n\n  # clean up\n  term_sendkeys(buf, \"\\<Esc>u\")\n  g:StopVimInTerminal(buf)\n  delete('XTest_redraw_cpo')\n  delete('Xdir', 'rf')\nenddef\n\nfunc Test_reject_declaration()\n  CheckScreendump\n  call Run_test_reject_declaration()\nendfunc\n\ndef Run_test_reject_declaration()\n  var buf = g:RunVimInTerminal('', {'rows': 6})\n  term_sendkeys(buf, \":vim9cmd var x: number\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_vim9_reject_declaration_1', {})\n  term_sendkeys(buf, \":\\<CR>\")\n  term_sendkeys(buf, \":vim9cmd g:foo = 123 | echo g:foo\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_vim9_reject_declaration_2', {})\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\ndef Test_minimal_command_name_length()\n  var names = [\n       'cons',\n       'brea',\n       'cat',\n       'catc',\n       'con',\n       'cont',\n       'conti',\n       'contin',\n       'continu',\n       'el',\n       'els',\n       'elsei',\n       'endfo',\n       'en',\n       'end',\n       'endi',\n       'endw',\n       'endt',\n       'endtr',\n       'exp',\n       'expo',\n       'expor',\n       'fina',\n       'finall',\n       'fini',\n       'finis',\n       'imp',\n       'impo',\n       'impor',\n       'retu',\n       'retur',\n       'th',\n       'thr',\n       'thro',\n       'wh',\n       'whi',\n       'whil',\n      ]\n  for name in names\n    v9.CheckDefAndScriptFailure([name .. ' '], 'E1065:')\n  endfor\n\n  var lines =<< trim END\n      vim9script\n      def SomeFunc()\n      endd\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\n  lines =<< trim END\n      vim9script\n      def SomeFunc()\n      endde\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\nenddef\n\ndef Test_unset_any_variable()\n  var lines =<< trim END\n    var name: any\n    assert_equal(0, name)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc Test_define_func_at_command_line()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_define_func_at_command_line()\nendfunc\n\ndef Run_Test_define_func_at_command_line()\n  # run in a separate Vim instance to avoid the script context\n  var lines =<< trim END\n    func CheckAndQuit()\n      call assert_fails('call Afunc()', 'E117: Unknown function: Bfunc')\n      call writefile(['errors: ' .. string(v:errors)], 'Xdidcmd')\n    endfunc\n  END\n  writefile([''], 'Xdidcmd')\n  writefile(lines, 'XcallFunc')\n  var buf = g:RunVimInTerminal('-S XcallFunc', {rows: 6})\n  # define Afunc() on the command line\n  term_sendkeys(buf, \":def Afunc()\\<CR>Bfunc()\\<CR>enddef\\<CR>\")\n  term_sendkeys(buf, \":call CheckAndQuit()\\<CR>\")\n  g:WaitForAssert(() => assert_equal(['errors: []'], readfile('Xdidcmd')))\n\n  call g:StopVimInTerminal(buf)\n  delete('XcallFunc')\n  delete('Xdidcmd')\nenddef\n\ndef Test_script_var_scope()\n  var lines =<< trim END\n      vim9script\n      if true\n        if true\n          var one = 'one'\n          echo one\n        endif\n        echo one\n      endif\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 7)\n\n  lines =<< trim END\n      vim9script\n      if true\n        if false\n          var one = 'one'\n          echo one\n        else\n          var one = 'one'\n          echo one\n        endif\n        echo one\n      endif\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 10)\n\n  lines =<< trim END\n      vim9script\n      while true\n        var one = 'one'\n        echo one\n        break\n      endwhile\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 7)\n\n  lines =<< trim END\n      vim9script\n      for i in range(1)\n        var one = 'one'\n        echo one\n      endfor\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 6)\n\n  lines =<< trim END\n      vim9script\n      {\n        var one = 'one'\n        assert_equal('one', one)\n      }\n      assert_false(exists('one'))\n      assert_false(exists('s:one'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      {\n        var one = 'one'\n        echo one\n      }\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 6)\nenddef\n\ndef Test_catch_exception_in_callback()\n  var lines =<< trim END\n    vim9script\n    def Callback(...l: list<any>)\n      try\n        var x: string\n        var y: string\n        # this error should be caught with CHECKLEN\n        var sl = ['']\n        [x, y] = sl\n      catch\n        g:caught = 'yes'\n      endtry\n    enddef\n    popup_menu('popup', {callback: Callback})\n    feedkeys(\"\\r\", 'xt')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  unlet g:caught\nenddef\n\ndef Test_no_unknown_error_after_error()\n  if !has('unix') || !has('job')\n    throw 'Skipped: not unix of missing +job feature'\n  endif\n  # FIXME: this check should not be needed\n  if has('win32')\n    throw 'Skipped: does not work on MS-Windows'\n  endif\n  var lines =<< trim END\n      vim9script\n      var source: list<number>\n      def Out_cb(...l: list<any>)\n          eval [][0]\n      enddef\n      def Exit_cb(...l: list<any>)\n          sleep 1m\n          g:did_call_exit_cb = true\n          source += l\n      enddef\n      var myjob = job_start('echo burp', {out_cb: Out_cb, exit_cb: Exit_cb, mode: 'raw'})\n      while job_status(myjob) == 'run'\n        sleep 10m\n      endwhile\n      # wait for Exit_cb() to be called\n      for x in range(100)\n        if exists('g:did_call_exit_cb')\n          unlet g:did_call_exit_cb\n          break\n        endif\n        sleep 10m\n      endfor\n  END\n  writefile(lines, 'Xdef')\n  assert_fails('so Xdef', ['E684:', 'E1012:'])\n  delete('Xdef')\nenddef\n\ndef InvokeNormal()\n  exe \"norm! :m+1\\r\"\nenddef\n\ndef Test_invoke_normal_in_visual_mode()\n  xnoremap <F3> <Cmd>call <SID>InvokeNormal()<CR>\n  new\n  setline(1, ['aaa', 'bbb'])\n  feedkeys(\"V\\<F3>\", 'xt')\n  assert_equal(['bbb', 'aaa'], getline(1, 2))\n  xunmap <F3>\nenddef\n\ndef Test_white_space_after_command()\n  var lines =<< trim END\n    exit_cb: Func})\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1144:', 1)\n\n  lines =<< trim END\n    e#\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1144:', 1)\nenddef\n\ndef Test_script_var_gone_when_sourced_twice()\n  var lines =<< trim END\n      vim9script\n      if exists('g:guard')\n        finish\n      endif\n      g:guard = 1\n      var name = 'thename'\n      def g:GetName(): string\n        return name\n      enddef\n      def g:SetName(arg: string)\n        name = arg\n      enddef\n  END\n  writefile(lines, 'XscriptTwice.vim')\n  so XscriptTwice.vim\n  assert_equal('thename', g:GetName())\n  g:SetName('newname')\n  assert_equal('newname', g:GetName())\n  so XscriptTwice.vim\n  assert_fails('call g:GetName()', 'E1149:')\n  assert_fails('call g:SetName(\"x\")', 'E1149:')\n\n  delfunc g:GetName\n  delfunc g:SetName\n  delete('XscriptTwice.vim')\n  unlet g:guard\nenddef\n\ndef Test_unsupported_commands()\n  var lines =<< trim END\n      ka\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'])\n\n  lines =<< trim END\n      :1ka\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'])\n\n  lines =<< trim END\n      :k a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n      :1k a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:')\n\n  lines =<< trim END\n    t\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    x\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    xit\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    Print\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476: Invalid command: Print', 'E492: Not an editor command: Print'])\n\n  lines =<< trim END\n    mode 4\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476: Invalid command: mode 4', 'E492: Not an editor command: mode 4'])\nenddef\n\ndef Test_mapping_line_number()\n  var lines =<< trim END\n      vim9script\n      def g:FuncA()\n          # Some comment\n          FuncB(0)\n      enddef\n          # Some comment\n      def FuncB(\n          # Some comment\n          n: number\n      )\n          exe 'nno '\n              # Some comment\n              .. '<F3> a'\n              .. 'b'\n              .. 'c'\n      enddef\n  END\n  v9.CheckScriptSuccess(lines)\n  var res = execute('verbose nmap <F3>')\n  assert_match('No mapping found', res)\n\n  g:FuncA()\n  res = execute('verbose nmap <F3>')\n  assert_match(' <F3> .* abc.*Last set from .*XScriptSuccess\\d\\+ line 11', res)\n\n  nunmap <F3>\n  delfunc g:FuncA\nenddef\n\ndef Test_option_set()\n  # legacy script allows for white space\n  var lines =<< trim END\n      set foldlevel  =11\n      call assert_equal(11, &foldlevel)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  set foldlevel\n  set foldlevel=12\n  assert_equal(12, &foldlevel)\n  set foldlevel+=2\n  assert_equal(14, &foldlevel)\n  set foldlevel-=3\n  assert_equal(11, &foldlevel)\n\n  lines =<< trim END\n      set foldlevel =1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: =1')\n\n  lines =<< trim END\n      set foldlevel +=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: +=1')\n\n  lines =<< trim END\n      set foldlevel ^=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: ^=1')\n\n  lines =<< trim END\n      set foldlevel -=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: -=1')\n\n  set foldlevel&\nenddef\n\ndef Test_option_modifier()\n  # legacy script allows for white space\n  var lines =<< trim END\n      set hlsearch &  hlsearch  !\n      call assert_equal(1, &hlsearch)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  set hlsearch\n  set hlsearch!\n  assert_equal(false, &hlsearch)\n\n  set hlsearch\n  set hlsearch&\n  assert_equal(false, &hlsearch)\n\n  lines =<< trim END\n      set hlsearch &\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: &')\n\n  lines =<< trim END\n      set hlsearch   !\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: !')\n\n  set hlsearch&\nenddef\n\n\" This must be called last, it may cause following :def functions to fail\ndef Test_xxx_echoerr_line_number()\n  var lines =<< trim END\n      echoerr 'some'\n         .. ' error'\n         .. ' continued'\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'some error continued', 1)\nenddef\n\nfunc Test_debug_with_lambda()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_debug_with_lambda()\nendfunc\n\ndef Run_Test_debug_with_lambda()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var n = 0\n        echo [0]->filter((_, v) => v == n)\n      enddef\n      breakadd func Func\n      Func()\n  END\n  writefile(lines, 'XdebugFunc')\n  var buf = g:RunVimInTerminal('-S XdebugFunc', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"cont\\<CR>\")\n  g:WaitForAssert(() => assert_match('\\[0\\]', term_getline(buf, 5)))\n\n  g:StopVimInTerminal(buf)\n  delete('XdebugFunc')\nenddef\n\nfunc Test_debug_running_out_of_lines()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_debug_running_out_of_lines()\nendfunc\n\ndef Run_Test_debug_running_out_of_lines()\n  var lines =<< trim END\n      vim9script\n      def Crash()\n          #\n          #\n          #\n          #\n          #\n          #\n          #\n          if true\n              #\n          endif\n      enddef\n      breakadd func Crash\n      Crash()\n  END\n  writefile(lines, 'XdebugFunc')\n  var buf = g:RunVimInTerminal('-S XdebugFunc', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"next\\<CR>\")\n  g:TermWait(buf)\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"cont\\<CR>\")\n  g:TermWait(buf)\n\n  g:StopVimInTerminal(buf)\n  delete('XdebugFunc')\nenddef\n\ndef Test_ambigous_command_error()\n  var lines =<< trim END\n      vim9script\n      command CmdA echomsg 'CmdA'\n      command CmdB echomsg 'CmdB'\n      Cmd\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 4)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        Cmd\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 1)\n\n  lines =<< trim END\n      vim9script\n      nnoremap <F3> <ScriptCmd>Cmd<CR>\n      feedkeys(\"\\<F3>\", 'xt')\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 3)\n\n  delcommand CmdA\n  delcommand CmdB\n  nunmap <F3>\nenddef\n\n\" Execute this near the end, profiling doesn't stop until Vim exits.\n\" This only tests that it works, not the profiling output.\ndef Test_profile_with_lambda()\n  CheckFeature profile\n\n  var lines =<< trim END\n      vim9script\n\n      def ProfiledWithLambda()\n        var n = 3\n        echo [[1, 2], [3, 4]]->filter((_, l) => l[0] == n)\n      enddef\n\n      def ProfiledNested()\n        var x = 0\n        def Nested(): any\n            return x\n        enddef\n        Nested()\n      enddef\n\n      def g:ProfiledNestedProfiled()\n        var x = 0\n        def Nested(): any\n            return x\n        enddef\n        Nested()\n      enddef\n\n      def Profile()\n        ProfiledWithLambda()\n        ProfiledNested()\n\n        # Also profile the nested function.  Use a different function, although\n        # the contents is the same, to make sure it was not already compiled.\n        profile func *\n        g:ProfiledNestedProfiled()\n\n        profdel func *\n        profile pause\n      enddef\n\n      var result = 'done'\n      try\n        # mark functions for profiling now to avoid E1271\n        profile start Xprofile.log\n        profile func ProfiledWithLambda\n        profile func ProfiledNested\n\n        Profile()\n      catch\n        result = 'failed: ' .. v:exception\n      finally\n        writefile([result], 'Xdidprofile')\n      endtry\n  END\n  writefile(lines, 'Xprofile.vim')\n  call system(g:GetVimCommand()\n        .. ' --clean'\n        .. ' -c \"so Xprofile.vim\"'\n        .. ' -c \"qall!\"')\n  call assert_equal(0, v:shell_error)\n\n  assert_equal(['done'], readfile('Xdidprofile'))\n  assert_true(filereadable('Xprofile.log'))\n  delete('Xdidprofile')\n  delete('Xprofile.log')\n  delete('Xprofile.vim')\nenddef\n\nfunc Test_misplaced_type()\n  CheckRunVimInTerminal\n  call Run_Test_misplaced_type()\nendfunc\n\ndef Run_Test_misplaced_type()\n  writefile(['let g:somevar = \"asdf\"'], 'XTest_misplaced_type')\n  var buf = g:RunVimInTerminal('-S XTest_misplaced_type', {'rows': 6})\n  term_sendkeys(buf, \":vim9cmd echo islocked('g:somevar: string')\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_misplaced_type', {})\n\n  g:StopVimInTerminal(buf)\n  delete('XTest_misplaced_type')\nenddef\n\n\" Ensure echo doesn't crash when stringifying empty variables.\ndef Test_echo_uninit_variables()\n  var res: string\n\n  var var_bool: bool\n  var var_num: number\n  var var_float: float\n  var Var_func: func\n  var var_string: string\n  var var_blob: blob\n  var var_list: list<any>\n  var var_dict: dict<any>\n\n  redir => res\n  echo var_bool\n  echo var_num\n  echo var_float\n  echo Var_func\n  echo var_string\n  echo var_blob\n  echo var_list\n  echo var_dict\n  redir END\n\n  assert_equal(['false', '0', '0.0', 'function()', '', '0z', '[]', '{}'], res->split('\\n'))\n\n  if has('job')\n    var var_job: job\n    var var_channel: channel\n\n    redir => res\n    echo var_job\n    echo var_channel\n    redir END\n\n    assert_equal(['no process', 'channel fail'], res->split('\\n'))\n  endif\nenddef\n\n\" Keep this last, it messes up highlighting.\ndef Test_substitute_cmd()\n  new\n  setline(1, 'something')\n  :substitute(some(other(\n  assert_equal('otherthing', getline(1))\n  bwipe!\n\n  # also when the context is Vim9 script\n  var lines =<< trim END\n    vim9script\n    new\n    setline(1, 'something')\n    :substitute(some(other(\n    assert_equal('otherthing', getline(1))\n    bwipe!\n  END\n  writefile(lines, 'Xvim9lines')\n  source Xvim9lines\n\n  delete('Xvim9lines')\nenddef\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * userfunc.c: User defined function support\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * All user-defined functions are found in this hashtable.\n */\nstatic hashtab_T\tfunc_hashtab;\n\n// Used by get_func_tv()\nstatic garray_T funcargs = GA_EMPTY;\n\n// pointer to funccal for currently active function\nstatic funccall_T *current_funccal = NULL;\n\n// Pointer to list of previously used funccal, still around because some\n// item in it is still being used.\nstatic funccall_T *previous_funccal = NULL;\n\nstatic void funccal_unref(funccall_T *fc, ufunc_T *fp, int force);\nstatic void func_clear(ufunc_T *fp, int force);\nstatic int func_free(ufunc_T *fp, int force);\nstatic char_u *untrans_function_name(char_u *name);\n\n    void\nfunc_init()\n{\n    hash_init(&func_hashtab);\n}\n\n#if defined(FEAT_PROFILE) || defined(PROTO)\n/*\n * Return the function hash table\n */\n    hashtab_T *\nfunc_tbl_get(void)\n{\n    return &func_hashtab;\n}\n#endif\n\n/*\n * Get one function argument.\n * If \"argtypes\" is not NULL also get the type: \"arg: type\" (:def function).\n * If \"types_optional\" is TRUE a missing type is OK, use \"any\".\n * If \"evalarg\" is not NULL use it to check for an already declared name.\n * If \"eap\" is not NULL use it to check for an already declared name.\n * Return a pointer to after the type.\n * When something is wrong return \"arg\".\n */\n    static char_u *\none_function_arg(\n\tchar_u\t    *arg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg,\n\texarg_T\t    *eap,\n\tint\t    is_vararg,\n\tint\t    skip)\n{\n    char_u\t*p = arg;\n    char_u\t*arg_copy = NULL;\n    int\t\tis_underscore = FALSE;\n\n    while (ASCII_ISALNUM(*p) || *p == '_')\n\t++p;\n    if (arg == p || isdigit(*arg)\n\t    || (argtypes == NULL\n\t\t&& ((p - arg == 9 && STRNCMP(arg, \"firstline\", 9) == 0)\n\t\t    || (p - arg == 8 && STRNCMP(arg, \"lastline\", 8) == 0))))\n    {\n\tif (!skip)\n\t    semsg(_(e_illegal_argument_str), arg);\n\treturn arg;\n    }\n\n    // Vim9 script: cannot use script var name for argument. In function: also\n    // check local vars and arguments.\n    if (!skip && argtypes != NULL && check_defined(arg, p - arg,\n\t\t\t       evalarg == NULL ? NULL : evalarg->eval_cctx,\n\t\t\t       eap == NULL ? NULL : eap->cstack, TRUE) == FAIL)\n\treturn arg;\n\n    if (newargs != NULL && ga_grow(newargs, 1) == FAIL)\n\treturn arg;\n    if (newargs != NULL)\n    {\n\tint\tc;\n\tint\ti;\n\n\tc = *p;\n\t*p = NUL;\n\targ_copy = vim_strsave(arg);\n\tif (arg_copy == NULL)\n\t{\n\t    *p = c;\n\t    return arg;\n\t}\n\tis_underscore = arg_copy[0] == '_' && arg_copy[1] == NUL;\n\tif (argtypes == NULL || !is_underscore)\n\t    // Check for duplicate argument name.\n\t    for (i = 0; i < newargs->ga_len; ++i)\n\t\tif (STRCMP(((char_u **)(newargs->ga_data))[i], arg_copy) == 0)\n\t\t{\n\t\t    semsg(_(e_duplicate_argument_name_str), arg_copy);\n\t\t    vim_free(arg_copy);\n\t\t    return arg;\n\t\t}\n\t((char_u **)(newargs->ga_data))[newargs->ga_len] = arg_copy;\n\tnewargs->ga_len++;\n\n\t*p = c;\n    }\n\n    // get any type from \"arg: type\"\n    if (argtypes != NULL && (skip || ga_grow(argtypes, 1) == OK))\n    {\n\tchar_u *type = NULL;\n\n\tif (VIM_ISWHITE(*p) && *skipwhite(p) == ':')\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_colon_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    p = skipwhite(p);\n\t}\n\tif (*p == ':')\n\t{\n\t    ++p;\n\t    if (!skip && !VIM_ISWHITE(*p))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p - 1);\n\t\treturn arg;\n\t    }\n\t    type = skipwhite(p);\n\t    p = skip_type(type, TRUE);\n\t    if (!skip)\n\t\ttype = vim_strnsave(type, p - type);\n\t}\n\telse if (*skipwhite(p) != '=' && !types_optional && !is_underscore)\n\t{\n\t    semsg(_(e_missing_argument_type_for_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    return arg;\n\t}\n\tif (!skip)\n\t{\n\t    if (type == NULL && types_optional)\n\t\t// lambda arguments default to \"any\" type\n\t\ttype = vim_strsave((char_u *)\n\t\t\t\t\t    (is_vararg ? \"list<any>\" : \"any\"));\n\t    ((char_u **)argtypes->ga_data)[argtypes->ga_len++] = type;\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Handle line continuation in function arguments or body.\n * Get a next line, store it in \"eap\" if appropriate and put the line in\n * \"lines_to_free\" to free the line later.\n */\n    static char_u *\nget_function_line(\n\texarg_T\t\t*eap,\n\tgarray_T\t*lines_to_free,\n\tint\t\tindent,\n\tgetline_opt_T\tgetline_options)\n{\n    char_u *theline;\n\n    if (eap->getline == NULL)\n\ttheline = getcmdline(':', 0L, indent, 0);\n    else\n\ttheline = eap->getline(':', eap->cookie, indent, getline_options);\n    if (theline != NULL)\n    {\n\tif (lines_to_free->ga_len > 0\n\t\t&& *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)\n\t\t\t\t\t\t   [lines_to_free->ga_len - 1])\n\t    *eap->cmdlinep = theline;\n\tga_add_string(lines_to_free, theline);\n    }\n\n    return theline;\n}\n\n/*\n * Get function arguments.\n * \"argp\" should point to just after the \"(\", possibly to white space.\n * \"argp\" is advanced just after \"endchar\".\n */\n    static int\nget_function_args(\n    char_u\t**argp,\n    char_u\tendchar,\n    garray_T\t*newargs,\n    garray_T\t*argtypes,\t// NULL unless using :def\n    int\t\ttypes_optional,\t// types optional if \"argtypes\" is not NULL\n    evalarg_T\t*evalarg,\t// context or NULL\n    int\t\t*varargs,\n    garray_T\t*default_args,\n    int\t\tskip,\n    exarg_T\t*eap,\t\t// can be NULL\n    garray_T\t*lines_to_free)\n{\n    int\t\tmustend = FALSE;\n    char_u\t*arg;\n    char_u\t*p;\n    int\t\tc;\n    int\t\tany_default = FALSE;\n    char_u\t*expr;\n    char_u\t*whitep = *argp;\n\n    if (newargs != NULL)\n\tga_init2(newargs, sizeof(char_u *), 3);\n    if (argtypes != NULL)\n\tga_init2(argtypes, sizeof(char_u *), 3);\n    if (!skip && default_args != NULL)\n\tga_init2(default_args, sizeof(char_u *), 3);\n\n    if (varargs != NULL)\n\t*varargs = FALSE;\n\n    /*\n     * Isolate the arguments: \"arg1, arg2, ...)\"\n     */\n    arg = skipwhite(*argp);\n    p = arg;\n    while (*p != endchar)\n    {\n\twhile (eap != NULL && eap->getline != NULL\n\t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n\t{\n\t    // End of the line, get the next one.\n\t    char_u *theline = get_function_line(eap, lines_to_free, 0,\n\t\t\t\t\t\t\t  GETLINE_CONCAT_CONT);\n\n\t    if (theline == NULL)\n\t\tbreak;\n\t    whitep = (char_u *)\" \";\n\t    p = skipwhite(theline);\n\t}\n\n\tif (mustend && *p != endchar)\n\t{\n\t    if (!skip)\n\t\tsemsg(_(e_invalid_argument_str), *argp);\n\t    goto err_ret;\n\t}\n\tif (*p == endchar)\n\t    break;\n\n\tif (p[0] == '.' && p[1] == '.' && p[2] == '.')\n\t{\n\t    if (varargs != NULL)\n\t\t*varargs = TRUE;\n\t    p += 3;\n\t    mustend = TRUE;\n\n\t    if (argtypes != NULL)\n\t    {\n\t\t// ...name: list<type>\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    if (!skip)\n\t\t\temsg(_(e_missing_name_after_dots));\n\t\t    goto err_ret;\n\t\t}\n\n\t\targ = p;\n\t\tp = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t     evalarg, eap, TRUE, skip);\n\t\tif (p == arg)\n\t\t    break;\n\t\tif (*skipwhite(p) == '=')\n\t\t{\n\t\t    emsg(_(e_cannot_use_default_for_variable_arguments));\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *np;\n\n\t    arg = p;\n\t    p = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t    evalarg, eap, FALSE, skip);\n\t    if (p == arg)\n\t\tbreak;\n\n\t    // Recognize \" = expr\" but not \" == expr\".  A lambda can have\n\t    // \"(a = expr\" but \"(a == expr\" and \"(a =~ expr\" are not a lambda.\n\t    np = skipwhite(p);\n\t    if (*np == '=' && np[1] != '=' && np[1] != '~'\n\t\t\t\t\t\t       && default_args != NULL)\n\t    {\n\t\ttypval_T\trettv;\n\n\t\t// find the end of the expression (doesn't evaluate it)\n\t\tany_default = TRUE;\n\t\tp = skipwhite(p) + 1;\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t\texpr = p;\n\t\tif (eval1(&p, &rettv, NULL) != FAIL)\n\t\t{\n\t\t    if (!skip)\n\t\t    {\n\t\t\tif (ga_grow(default_args, 1) == FAIL)\n\t\t\t    goto err_ret;\n\n\t\t\t// trim trailing whitespace\n\t\t\twhile (p > expr && VIM_ISWHITE(p[-1]))\n\t\t\t    p--;\n\t\t\tc = *p;\n\t\t\t*p = NUL;\n\t\t\texpr = vim_strsave(expr);\n\t\t\tif (expr == NULL)\n\t\t\t{\n\t\t\t    *p = c;\n\t\t\t    goto err_ret;\n\t\t\t}\n\t\t\t((char_u **)(default_args->ga_data))\n\t\t\t\t\t\t [default_args->ga_len] = expr;\n\t\t\tdefault_args->ga_len++;\n\t\t\t*p = c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    mustend = TRUE;\n\t    }\n\t    else if (any_default)\n\t    {\n\t\temsg(_(e_non_default_argument_follows_default_argument));\n\t\tgoto err_ret;\n\t    }\n\n\t    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')\n\t    {\n\t\t// Be tolerant when skipping\n\t\tif (!skip)\n\t\t{\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t\t    goto err_ret;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\t// Don't give this error when skipping, it makes the \"->\" not\n\t\t// found in \"{k,v -> x}\" and give a confusing error.\n\t\t// Allow missing space after comma in legacy functions.\n\t\tif (!skip && argtypes != NULL\n\t\t\t\t      && !IS_WHITE_OR_NUL(*p) && *p != endchar)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\t    goto err_ret;\n\t\t}\n\t    }\n\t    else\n\t\tmustend = TRUE;\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n\n    if (*p != endchar)\n\tgoto err_ret;\n    ++p;\t// skip \"endchar\"\n\n    *argp = p;\n    return OK;\n\nerr_ret:\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    if (!skip && default_args != NULL)\n\tga_clear_strings(default_args);\n    return FAIL;\n}\n\n/*\n * Parse the argument types, filling \"fp->uf_arg_types\".\n * Return OK or FAIL.\n */\n    static int\nparse_argument_types(ufunc_T *fp, garray_T *argtypes, int varargs)\n{\n    int len = 0;\n\n    ga_init2(&fp->uf_type_list, sizeof(type_T *), 10);\n    if (argtypes->ga_len > 0)\n    {\n\t// When \"varargs\" is set the last name/type goes into uf_va_name\n\t// and uf_va_type.\n\tlen = argtypes->ga_len - (varargs ? 1 : 0);\n\n\tif (len > 0)\n\t    fp->uf_arg_types = ALLOC_CLEAR_MULT(type_T *, len);\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    int\ti;\n\t    type_T\t*type;\n\n\t    for (i = 0; i < len; ++ i)\n\t    {\n\t\tchar_u *p = ((char_u **)argtypes->ga_data)[i];\n\n\t\tif (p == NULL)\n\t\t    // will get the type from the default value\n\t\t    type = &t_unknown;\n\t\telse\n\t\t    type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t\tif (type == NULL)\n\t\t    return FAIL;\n\t\tfp->uf_arg_types[i] = type;\n\t\tif (i < fp->uf_args.ga_len\n\t\t\t&& (type->tt_type == VAR_FUNC\n\t\t\t    || type->tt_type == VAR_PARTIAL)\n\t\t\t&& var_wrong_func_name(\n\t\t\t\t    ((char_u **)fp->uf_args.ga_data)[i], TRUE))\n\t\t    return FAIL;\n\t    }\n\t}\n    }\n\n    if (varargs)\n    {\n\tchar_u *p;\n\n\t// Move the last argument \"...name: type\" to uf_va_name and\n\t// uf_va_type.\n\tfp->uf_va_name = ((char_u **)fp->uf_args.ga_data)\n\t\t\t\t\t      [fp->uf_args.ga_len - 1];\n\t--fp->uf_args.ga_len;\n\tp = ((char_u **)argtypes->ga_data)[len];\n\tif (p == NULL)\n\t    // TODO: get type from default value\n\t    fp->uf_va_type = &t_list_any;\n\telse\n\t{\n\t    fp->uf_va_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t    if (fp->uf_va_type != NULL && fp->uf_va_type->tt_type != VAR_LIST)\n\t    {\n\t\tsemsg(_(e_variable_arguments_type_must_be_list_str),\n\t\t\t\t\t  ((char_u **)argtypes->ga_data)[len]);\n\t\treturn FAIL;\n\t    }\n\t}\n\tif (fp->uf_va_type == NULL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static int\nparse_return_type(ufunc_T *fp, char_u *ret_type)\n{\n    if (ret_type == NULL)\n\tfp->uf_ret_type = &t_void;\n    else\n    {\n\tchar_u *p = ret_type;\n\n\tfp->uf_ret_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\tif (fp->uf_ret_type == NULL)\n\t{\n\t    fp->uf_ret_type = &t_void;\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Register function \"fp\" as using \"current_funccal\" as its scope.\n */\n    static int\nregister_closure(ufunc_T *fp)\n{\n    if (fp->uf_scoped == current_funccal)\n\t// no change\n\treturn OK;\n    funccal_unref(fp->uf_scoped, fp, FALSE);\n    fp->uf_scoped = current_funccal;\n    current_funccal->fc_refcount++;\n\n    if (ga_grow(&current_funccal->fc_funcs, 1) == FAIL)\n\treturn FAIL;\n    ((ufunc_T **)current_funccal->fc_funcs.ga_data)\n\t[current_funccal->fc_funcs.ga_len++] = fp;\n    return OK;\n}\n\n    static void\nset_ufunc_name(ufunc_T *fp, char_u *name)\n{\n    // Add a type cast to avoid a warning for an overflow, the uf_name[] array\n    // actually extends beyond the struct.\n    STRCPY((void *)fp->uf_name, name);\n\n    if (name[0] == K_SPECIAL)\n    {\n\tfp->uf_name_exp = alloc(STRLEN(name) + 3);\n\tif (fp->uf_name_exp != NULL)\n\t{\n\t    STRCPY(fp->uf_name_exp, \"<SNR>\");\n\t    STRCAT(fp->uf_name_exp, fp->uf_name + 3);\n\t}\n    }\n}\n\n/*\n * If \"name\" starts with K_SPECIAL and \"buf[bufsize]\" is big enough\n * return \"buf\" filled with a readable function name.\n * Otherwise just return \"name\", thus the return value can always be used.\n * \"name\" and \"buf\" may be equal.\n */\n    char_u *\nmake_ufunc_name_readable(char_u *name, char_u *buf, size_t bufsize)\n{\n    size_t len;\n\n    if (name[0] != K_SPECIAL)\n\treturn name;\n    len = STRLEN(name);\n    if (len + 3 > bufsize)\n\treturn name;\n\n    mch_memmove(buf + 5, name + 3, len - 2);  // Include trailing NUL\n    mch_memmove(buf, \"<SNR>\", 5);\n    return buf;\n}\n\n/*\n * Get a name for a lambda.  Returned in static memory.\n */\n    char_u *\nget_lambda_name(void)\n{\n    static char_u   name[30];\n    static int\t    lambda_no = 0;\n\n    sprintf((char*)name, \"<lambda>%d\", ++lambda_no);\n    return name;\n}\n\n#if defined(FEAT_LUA) || defined(PROTO)\n/*\n * Registers a native C callback which can be called from Vim script.\n * Returns the name of the Vim script function.\n */\n    char_u *\nregister_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state)\n{\n    char_u\t*name = get_lambda_name();\n    ufunc_T\t*fp;\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (fp == NULL)\n\treturn NULL;\n\n    fp->uf_def_status = UF_NOT_COMPILED;\n    fp->uf_refcount = 1;\n    fp->uf_varargs = TRUE;\n    fp->uf_flags = FC_CFUNC | FC_LAMBDA;\n    fp->uf_calls = 0;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_cb = cb;\n    fp->uf_cb_free = cb_free;\n    fp->uf_cb_state = state;\n\n    set_ufunc_name(fp, name);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    return name;\n}\n#endif\n\n/*\n * Skip over \"->\" or \"=>\" after the arguments of a lambda.\n * If \": type\" is found make \"ret_type\" point to \"type\".\n * If \"white_error\" is not NULL check for correct use of white space and set\n * \"white_error\" to TRUE if there is an error.\n * Return NULL if no valid arrow found.\n */\n    static char_u *\nskip_arrow(\n\tchar_u\t*start,\n\tint\tequal_arrow,\n\tchar_u\t**ret_type,\n\tint\t*white_error)\n{\n    char_u  *s = start;\n    char_u  *bef = start - 2; // \"start\" points to > of ->\n\n    if (equal_arrow)\n    {\n\tif (*s == ':')\n\t{\n\t    if (white_error != NULL && !VIM_ISWHITE(s[1]))\n\t    {\n\t\t*white_error = TRUE;\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", s);\n\t\treturn NULL;\n\t    }\n\t    s = skipwhite(s + 1);\n\t    *ret_type = s;\n\t    s = skip_type(s, TRUE);\n\t    if (s == *ret_type)\n\t    {\n\t\temsg(_(e_missing_return_type));\n\t\treturn NULL;\n\t    }\n\t}\n\tbef = s;\n\ts = skipwhite(s);\n\tif (*s != '=')\n\t    return NULL;\n\t++s;\n    }\n    if (*s != '>')\n\treturn NULL;\n    if (white_error != NULL && ((!VIM_ISWHITE(*bef) && *bef != '{')\n\t\t|| !IS_WHITE_OR_NUL(s[1])))\n    {\n\t*white_error = TRUE;\n\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t       equal_arrow ? \"=>\" : \"->\", bef);\n\treturn NULL;\n    }\n    return skipwhite(s + 1);\n}\n\n/*\n * Check if \"*cmd\" points to a function command and if so advance \"*cmd\" and\n * return TRUE.\n * Otherwise return FALSE;\n * Do not consider \"function(\" to be a command.\n */\n    static int\nis_function_cmd(char_u **cmd)\n{\n    char_u *p = *cmd;\n\n    if (checkforcmd(&p, \"function\", 2))\n    {\n\tif (*p == '(')\n\t    return FALSE;\n\t*cmd = p;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Called when defining a function: The context may be needed for script\n * variables declared in a block that is visible now but not when the function\n * is compiled or called later.\n */\n    static void\nfunction_using_block_scopes(ufunc_T *fp, cstack_T *cstack)\n{\n    if (cstack != NULL && cstack->cs_idx >= 0)\n    {\n\tint\t    count = cstack->cs_idx + 1;\n\tint\t    i;\n\n\tfp->uf_block_ids = ALLOC_MULT(int, count);\n\tif (fp->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(fp->uf_block_ids, cstack->cs_block_id,\n\t\t\t\t\t\t\t  sizeof(int) * count);\n\t    fp->uf_block_depth = count;\n\t}\n\n\t// Set flag in each block to indicate a function was defined.  This\n\t// is used to keep the variable when leaving the block, see\n\t// hide_script_var().\n\tfor (i = 0; i <= cstack->cs_idx; ++i)\n\t    cstack->cs_flags[i] |= CSF_FUNC_DEF;\n    }\n}\n\n/*\n * Read the body of a function, put every line in \"newlines\".\n * This stops at \"}\", \"endfunction\" or \"enddef\".\n * \"newlines\" must already have been initialized.\n * \"eap->cmdidx\" is CMD_function, CMD_def or CMD_block;\n */\n    static int\nget_function_body(\n\texarg_T\t    *eap,\n\tgarray_T    *newlines,\n\tchar_u\t    *line_arg_in,\n\tgarray_T    *lines_to_free)\n{\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n    linenr_T\tsourcing_lnum_off;\n    int\t\tsaved_wait_return = need_wait_return;\n    char_u\t*line_arg = line_arg_in;\n    int\t\tvim9_function = eap->cmdidx == CMD_def\n\t\t\t\t\t\t   || eap->cmdidx == CMD_block;\n#define MAX_FUNC_NESTING 50\n    char\tnesting_def[MAX_FUNC_NESTING];\n    char\tnesting_inline[MAX_FUNC_NESTING];\n    int\t\tnesting = 0;\n    getline_opt_T getline_options;\n    int\t\tindent = 2;\n    char_u\t*skip_until = NULL;\n    int\t\tret = FAIL;\n    int\t\tis_heredoc = FALSE;\n    int\t\theredoc_concat_len = 0;\n    garray_T\theredoc_ga;\n    char_u\t*heredoc_trimmed = NULL;\n\n    ga_init2(&heredoc_ga, 1, 500);\n\n    // Detect having skipped over comment lines to find the return\n    // type.  Add NULL lines to keep the line count correct.\n    sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n    if (SOURCING_LNUM < sourcing_lnum_off)\n    {\n\tsourcing_lnum_off -= SOURCING_LNUM;\n\tif (ga_grow(newlines, sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n    }\n\n    nesting_def[0] = vim9_function;\n    nesting_inline[0] = eap->cmdidx == CMD_block;\n    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n    for (;;)\n    {\n\tchar_u\t*theline;\n\tchar_u\t*p;\n\tchar_u\t*arg;\n\n\tif (KeyTyped)\n\t{\n\t    msg_scroll = TRUE;\n\t    saved_wait_return = FALSE;\n\t}\n\tneed_wait_return = FALSE;\n\n\tif (line_arg != NULL)\n\t{\n\t    // Use eap->arg, split up in parts by line breaks.\n\t    theline = line_arg;\n\t    p = vim_strchr(theline, '\\n');\n\t    if (p == NULL)\n\t\tline_arg += STRLEN(line_arg);\n\t    else\n\t    {\n\t\t*p = NUL;\n\t\tline_arg = p + 1;\n\t    }\n\t}\n\telse\n\t{\n\t    theline = get_function_line(eap, lines_to_free, indent,\n\t\t\t\t\t\t\t      getline_options);\n\t}\n\tif (KeyTyped)\n\t    lines_left = Rows - 1;\n\tif (theline == NULL)\n\t{\n\t    // Use the start of the function for the line number.\n\t    SOURCING_LNUM = sourcing_lnum_top;\n\t    if (skip_until != NULL)\n\t\tsemsg(_(e_missing_heredoc_end_marker_str), skip_until);\n\t    else if (nesting_inline[nesting])\n\t\temsg(_(e_missing_end_block));\n\t    else if (eap->cmdidx == CMD_def)\n\t\temsg(_(e_missing_enddef));\n\t    else\n\t\temsg(_(e_missing_endfunction));\n\t    goto theend;\n\t}\n\n\t// Detect line continuation: SOURCING_LNUM increased more than one.\n\tsourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n\tif (SOURCING_LNUM < sourcing_lnum_off)\n\t    sourcing_lnum_off -= SOURCING_LNUM;\n\telse\n\t    sourcing_lnum_off = 0;\n\n\tif (skip_until != NULL)\n\t{\n\t    // Don't check for \":endfunc\"/\":enddef\" between\n\t    // * \":append\" and \".\"\n\t    // * \":python <<EOF\" and \"EOF\"\n\t    // * \":let {var-name} =<< [trim] {marker}\" and \"{marker}\"\n\t    if (heredoc_trimmed == NULL\n\t\t    || (is_heredoc && skipwhite(theline) == theline)\n\t\t    || STRNCMP(theline, heredoc_trimmed,\n\t\t\t\t\t\t STRLEN(heredoc_trimmed)) == 0)\n\t    {\n\t\tif (heredoc_trimmed == NULL)\n\t\t    p = theline;\n\t\telse if (is_heredoc)\n\t\t    p = skipwhite(theline) == theline\n\t\t\t\t ? theline : theline + STRLEN(heredoc_trimmed);\n\t\telse\n\t\t    p = theline + STRLEN(heredoc_trimmed);\n\t\tif (STRCMP(p, skip_until) == 0)\n\t\t{\n\t\t    VIM_CLEAR(skip_until);\n\t\t    VIM_CLEAR(heredoc_trimmed);\n\t\t    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n\t\t    is_heredoc = FALSE;\n\n\t\t    if (heredoc_concat_len > 0)\n\t\t    {\n\t\t\t// Replace the starting line with all the concatenated\n\t\t\t// lines.\n\t\t\tga_concat(&heredoc_ga, theline);\n\t\t\tvim_free(((char_u **)(newlines->ga_data))[\n\t\t\t\t\t\t      heredoc_concat_len - 1]);\n\t\t\t((char_u **)(newlines->ga_data))[\n\t\t\t\t  heredoc_concat_len - 1] = heredoc_ga.ga_data;\n\t\t\tga_init(&heredoc_ga);\n\t\t\theredoc_concat_len = 0;\n\t\t\ttheline += STRLEN(theline);  // skip the \"EOF\"\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    int\t    c;\n\t    char_u  *end;\n\t    char_u  *cmd;\n\n\t    // skip ':' and blanks\n\t    for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)\n\t\t;\n\n\t    // Check for \"endfunction\", \"enddef\" or \"}\".\n\t    // When a \":\" follows it must be a dict key; \"enddef: value,\"\n\t    cmd = p;\n\t    if (nesting_inline[nesting]\n\t\t    ? *p == '}'\n\t\t    : (checkforcmd(&p, nesting_def[nesting]\n\t\t\t\t\t\t? \"enddef\" : \"endfunction\", 4)\n\t\t\t&& *p != ':'))\n\t    {\n\t\tif (!nesting_inline[nesting] && nesting_def[nesting]\n\t\t\t\t\t\t\t\t&& p < cmd + 6)\n\t\t    semsg(_(e_command_cannot_be_shortened_str), \"enddef\");\n\t\tif (nesting-- == 0)\n\t\t{\n\t\t    char_u *nextcmd = NULL;\n\n\t\t    if (*p == '|' || *p == '}')\n\t\t\tnextcmd = p + 1;\n\t\t    else if (line_arg != NULL && *skipwhite(line_arg) != NUL)\n\t\t\tnextcmd = line_arg;\n\t\t    else if (*p != NUL && *p != (vim9_function ? '#' : '\"')\n\t\t\t\t\t   && (vim9_function || p_verbose > 0))\n\t\t    {\n\t\t\tSOURCING_LNUM = sourcing_lnum_top\n\t\t\t\t\t\t\t+ newlines->ga_len + 1;\n\t\t\tif (eap->cmdidx == CMD_def)\n\t\t\t    semsg(_(e_text_found_after_str_str), \"enddef\", p);\n\t\t\telse\n\t\t\t    give_warning2((char_u *)\n\t\t\t\t   _(\"W22: Text found after :endfunction: %s\"),\n\t\t\t\t   p, TRUE);\n\t\t    }\n\t\t    if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)\n\t\t    {\n\t\t\t// Another command follows. If the line came from \"eap\"\n\t\t\t// we can simply point into it, otherwise we need to\n\t\t\t// change \"eap->cmdlinep\" to point to the last fetched\n\t\t\t// line.\n\t\t\teap->nextcmd = nextcmd;\n\t\t\tif (lines_to_free->ga_len > 0\n\t\t\t\t&& *eap->cmdlinep !=\n\t\t\t\t\t    ((char_u **)lines_to_free->ga_data)\n\t\t\t\t\t\t   [lines_to_free->ga_len - 1])\n\t\t\t{\n\t\t\t    // *cmdlinep will be freed later, thus remove the\n\t\t\t    // line from lines_to_free.\n\t\t\t    vim_free(*eap->cmdlinep);\n\t\t\t    *eap->cmdlinep = ((char_u **)lines_to_free->ga_data)\n\t\t\t\t\t\t   [lines_to_free->ga_len - 1];\n\t\t\t    --lines_to_free->ga_len;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\n\t    // Check for mismatched \"endfunc\" or \"enddef\".\n\t    // We don't check for \"def\" inside \"func\" thus we also can't check\n\t    // for \"enddef\".\n\t    // We continue to find the end of the function, although we might\n\t    // not find it.\n\t    else if (nesting_def[nesting])\n\t    {\n\t\tif (checkforcmd(&p, \"endfunction\", 4) && *p != ':')\n\t\t    emsg(_(e_mismatched_endfunction));\n\t    }\n\t    else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))\n\t\temsg(_(e_mismatched_enddef));\n\n\t    // Increase indent inside \"if\", \"while\", \"for\" and \"try\", decrease\n\t    // at \"end\".\n\t    if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))\n\t\tindent -= 2;\n\t    else if (STRNCMP(p, \"if\", 2) == 0\n\t\t    || STRNCMP(p, \"wh\", 2) == 0\n\t\t    || STRNCMP(p, \"for\", 3) == 0\n\t\t    || STRNCMP(p, \"try\", 3) == 0)\n\t\tindent += 2;\n\n\t    // Check for defining a function inside this function.\n\t    // Only recognize \"def\" inside \"def\", not inside \"function\",\n\t    // For backwards compatibility, see Test_function_python().\n\t    c = *p;\n\t    if (is_function_cmd(&p)\n\t\t    || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))\n\t    {\n\t\tif (*p == '!')\n\t\t    p = skipwhite(p + 1);\n\t\tp += eval_fname_script(p);\n\t\tvim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,\n\t\t\t\t\t\t\t\t  NULL, NULL));\n\t\tif (*skipwhite(p) == '(')\n\t\t{\n\t\t    if (nesting == MAX_FUNC_NESTING - 1)\n\t\t\temsg(_(e_function_nesting_too_deep));\n\t\t    else\n\t\t    {\n\t\t\t++nesting;\n\t\t\tnesting_def[nesting] = (c == 'd');\n\t\t\tnesting_inline[nesting] = FALSE;\n\t\t\tindent += 2;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (nesting_def[nesting] ? *p != '#' : *p != '\"')\n\t    {\n\t\t// Not a comment line: check for nested inline function.\n\t\tend = p + STRLEN(p) - 1;\n\t\twhile (end > p && VIM_ISWHITE(*end))\n\t\t    --end;\n\t\tif (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))\n\t\t{\n\t\t    int\t    is_block;\n\n\t\t    // check for trailing \"=> {\": start of an inline function\n\t\t    --end;\n\t\t    while (end > p && VIM_ISWHITE(*end))\n\t\t\t--end;\n\t\t    is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';\n\t\t    if (!is_block)\n\t\t    {\n\t\t\tchar_u *s = p;\n\n\t\t\t// check for line starting with \"au\" for :autocmd or\n\t\t\t// \"com\" for :command, these can use a {} block\n\t\t\tis_block = checkforcmd_noparen(&s, \"autocmd\", 2)\n\t\t\t\t      || checkforcmd_noparen(&s, \"command\", 3);\n\t\t    }\n\n\t\t    if (is_block)\n\t\t    {\n\t\t\tif (nesting == MAX_FUNC_NESTING - 1)\n\t\t\t    emsg(_(e_function_nesting_too_deep));\n\t\t\telse\n\t\t\t{\n\t\t\t    ++nesting;\n\t\t\t    nesting_def[nesting] = TRUE;\n\t\t\t    nesting_inline[nesting] = TRUE;\n\t\t\t    indent += 2;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Check for \":append\", \":change\", \":insert\".  Not for :def.\n\t    p = skip_range(p, FALSE, NULL);\n\t    if (!vim9_function\n\t\t&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))\n\t\t    || (p[0] == 'c'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'\n\t\t\t\t\t&& (STRNCMP(&p[3], \"nge\", 3) != 0\n\t\t\t\t\t    || !ASCII_ISALPHA(p[6])))))))\n\t\t    || (p[0] == 'i'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2])\n\t\t\t\t    || (p[2] == 's'\n\t\t\t\t\t&& (!ASCII_ISALPHA(p[3])\n\t\t\t\t\t\t|| p[3] == 'e'))))))))\n\t\tskip_until = vim_strsave((char_u *)\".\");\n\n\t    // Check for \":python <<EOF\", \":tcl <<EOF\", etc.\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (arg[0] == '<' && arg[1] =='<'\n\t\t    && ((p[0] == 'p' && p[1] == 'y'\n\t\t\t\t    && (!ASCII_ISALNUM(p[2]) || p[2] == 't'\n\t\t\t\t\t|| ((p[2] == '3' || p[2] == 'x')\n\t\t\t\t\t\t   && !ASCII_ISALPHA(p[3]))))\n\t\t\t|| (p[0] == 'p' && p[1] == 'e'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))\n\t\t\t|| (p[0] == 't' && p[1] == 'c'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))\n\t\t\t|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'\n\t\t\t\t    && !ASCII_ISALPHA(p[3]))\n\t\t\t|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'\n\t\t\t\t    && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))\n\t\t\t|| (p[0] == 'm' && p[1] == 'z'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))\n\t\t\t))\n\t    {\n\t\t// \":python <<\" continues until a dot, like \":append\"\n\t\tp = skipwhite(arg + 2);\n\t\tif (STRNCMP(p, \"trim\", 4) == 0)\n\t\t{\n\t\t    // Ignore leading white space.\n\t\t    p = skipwhite(p + 4);\n\t\t    heredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t}\n\t\tif (*p == NUL)\n\t\t    skip_until = vim_strsave((char_u *)\".\");\n\t\telse\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\tgetline_options = GETLINE_NONE;\n\t\tis_heredoc = TRUE;\n\t\tif (eap->cmdidx == CMD_def && nesting == 0)\n\t\t    heredoc_concat_len = newlines->ga_len + 1;\n\t    }\n\n\t    if (!is_heredoc)\n\t    {\n\t\t// Check for \":cmd v =<< [trim] EOF\"\n\t\t//       and \":cmd [a, b] =<< [trim] EOF\"\n\t\t//       and \"lines =<< [trim] EOF\" for Vim9\n\t\t// Where \"cmd\" can be \"let\", \"var\", \"final\" or \"const\".\n\t\targ = skipwhite(skiptowhite(p));\n\t\tif (*arg == '[')\n\t\t    arg = vim_strchr(arg, ']');\n\t\tif (arg != NULL)\n\t\t{\n\t\t    int found = (eap->cmdidx == CMD_def && arg[0] == '='\n\t\t\t\t\t     && arg[1] == '<' && arg[2] =='<');\n\n\t\t    if (!found)\n\t\t\t// skip over the argument after \"cmd\"\n\t\t\targ = skipwhite(skiptowhite(arg));\n\t\t    if (found || (arg[0] == '=' && arg[1] == '<'\n\t\t\t\t\t\t\t\t&& arg[2] =='<'\n\t\t\t    && (checkforcmd(&p, \"let\", 2)\n\t\t\t\t|| checkforcmd(&p, \"var\", 3)\n\t\t\t\t|| checkforcmd(&p, \"final\", 5)\n\t\t\t\t|| checkforcmd(&p, \"const\", 5))))\n\t\t    {\n\t\t\tp = skipwhite(arg + 3);\n\t\t\twhile (TRUE)\n\t\t\t{\n\t\t\t    if (STRNCMP(p, \"trim\", 4) == 0)\n\t\t\t    {\n\t\t\t\t// Ignore leading white space.\n\t\t\t\tp = skipwhite(p + 4);\n\t\t\t\theredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\tskipwhite(theline) - theline);\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t    if (STRNCMP(p, \"eval\", 4) == 0)\n\t\t\t    {\n\t\t\t\t// Ignore leading white space.\n\t\t\t\tp = skipwhite(p + 4);\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t\tskip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\t\tgetline_options = GETLINE_NONE;\n\t\t\tis_heredoc = TRUE;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Add the line to the function.\n\tif (ga_grow_id(newlines, 1 + sourcing_lnum_off, aid_get_func) == FAIL)\n\t    goto theend;\n\n\tif (heredoc_concat_len > 0)\n\t{\n\t    // For a :def function \"python << EOF\" concatenates all the lines,\n\t    // to be used for the instruction later.\n\t    ga_concat(&heredoc_ga, theline);\n\t    ga_concat(&heredoc_ga, (char_u *)\"\\n\");\n\t    p = vim_strsave((char_u *)\"\");\n\t}\n\telse\n\t{\n\t    // Copy the line to newly allocated memory.  get_one_sourceline()\n\t    // allocates 250 bytes per line, this saves 80% on average.  The\n\t    // cost is an extra alloc/free.\n\t    p = vim_strsave(theline);\n\t}\n\tif (p == NULL)\n\t    goto theend;\n\t((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;\n\n\t// Add NULL lines for continuation lines, so that the line count is\n\t// equal to the index in the growarray.\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n\n\t// Check for end of eap->arg.\n\tif (line_arg != NULL && *line_arg == NUL)\n\t    line_arg = NULL;\n    }\n\n    // Return OK when no error was detected.\n    if (!did_emsg)\n\tret = OK;\n\ntheend:\n    vim_free(skip_until);\n    vim_free(heredoc_trimmed);\n    vim_free(heredoc_ga.ga_data);\n    need_wait_return |= saved_wait_return;\n    return ret;\n}\n\n/*\n * Handle the body of a lambda.  *arg points to the \"{\", process statements\n * until the matching \"}\".\n * When not evaluating \"newargs\" is NULL.\n * When successful \"rettv\" is set to a funcref.\n */\n    static int\nlambda_function_body(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tevalarg_T   *evalarg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    varargs,\n\tgarray_T    *default_args,\n\tchar_u\t    *ret_type)\n{\n    int\t\tevaluate = (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\t*gap = &evalarg->eval_ga;\n    garray_T\t*freegap = &evalarg->eval_freega;\n    ufunc_T\t*ufunc = NULL;\n    exarg_T\teap;\n    garray_T\tnewlines;\n    char_u\t*cmdline = NULL;\n    int\t\tret = FAIL;\n    partial_T\t*pt;\n    char_u\t*name;\n    int\t\tlnum_save = -1;\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n\n    if (!ends_excmd2(*arg, skipwhite(*arg + 1)))\n    {\n\tsemsg(_(e_trailing_characters_str), *arg + 1);\n\treturn FAIL;\n    }\n\n    CLEAR_FIELD(eap);\n    eap.cmdidx = CMD_block;\n    eap.forceit = FALSE;\n    eap.cmdlinep = &cmdline;\n    eap.skip = !evaluate;\n    if (evalarg->eval_cctx != NULL)\n\tfill_exarg_from_cctx(&eap, evalarg->eval_cctx);\n    else\n    {\n\teap.getline = evalarg->eval_getline;\n\teap.cookie = evalarg->eval_cookie;\n    }\n\n    ga_init2(&newlines, sizeof(char_u *), 10);\n    if (get_function_body(&eap, &newlines, NULL,\n\t\t\t\t\t     &evalarg->eval_tofree_ga) == FAIL)\n\tgoto erret;\n\n    // When inside a lambda must add the function lines to evalarg.eval_ga.\n    evalarg->eval_break_count += newlines.ga_len;\n    if (gap->ga_itemsize > 0)\n    {\n\tint\tidx;\n\tchar_u\t*last;\n\tsize_t  plen;\n\tchar_u  *pnl;\n\n\tfor (idx = 0; idx < newlines.ga_len; ++idx)\n\t{\n\t    char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);\n\n\t    if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t\tgoto erret;\n\n\t    // Going to concatenate the lines after parsing.  For an empty or\n\t    // comment line use an empty string.\n\t    // Insert NL characters at the start of each line, the string will\n\t    // be split again later in .get_lambda_tv().\n\t    if (*p == NUL || vim9_comment_start(p))\n\t\tp = (char_u *)\"\";\n\t    plen = STRLEN(p);\n\t    pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\t    if (pnl != NULL)\n\t\tmch_memmove(pnl + 1, p, plen + 1);\n\t    ((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t    ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n\t}\n\tif (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t    goto erret;\n\tif (eap.nextcmd != NULL)\n\t    // more is following after the \"}\", which was skipped\n\t    last = cmdline;\n\telse\n\t    // nothing is following the \"}\"\n\t    last = (char_u *)\"}\";\n\tplen = STRLEN(last);\n\tpnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\tif (pnl != NULL)\n\t    mch_memmove(pnl + 1, last, plen + 1);\n\t((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n    }\n\n    if (eap.nextcmd != NULL)\n    {\n\tgarray_T *tfgap = &evalarg->eval_tofree_ga;\n\n\t// Something comes after the \"}\".\n\t*arg = eap.nextcmd;\n\n\t// \"arg\" points into cmdline, need to keep the line and free it later.\n\tif (ga_grow(tfgap, 1) == OK)\n\t{\n\t    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;\n\t    evalarg->eval_using_cmdline = TRUE;\n\t}\n    }\n    else\n\t*arg = (char_u *)\"\";\n\n    if (!evaluate)\n    {\n\tret = OK;\n\tgoto erret;\n    }\n\n    name = get_lambda_name();\n    ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (ufunc == NULL)\n\tgoto erret;\n    set_ufunc_name(ufunc, name);\n    if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)\n\tgoto erret;\n    ufunc->uf_flags = FC_LAMBDA;\n    ufunc->uf_refcount = 1;\n    ufunc->uf_args = *newargs;\n    newargs->ga_data = NULL;\n    ufunc->uf_def_args = *default_args;\n    default_args->ga_data = NULL;\n    ufunc->uf_func_type = &t_func_any;\n\n    // error messages are for the first function line\n    lnum_save = SOURCING_LNUM;\n    SOURCING_LNUM = sourcing_lnum_top;\n\n    // parse argument types\n    if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)\n    {\n\tSOURCING_LNUM = lnum_save;\n\tgoto erret;\n    }\n\n    // parse the return type, if any\n    if (parse_return_type(ufunc, ret_type) == FAIL)\n\tgoto erret;\n\n    pt = ALLOC_CLEAR_ONE(partial_T);\n    if (pt == NULL)\n\tgoto erret;\n    pt->pt_func = ufunc;\n    pt->pt_refcount = 1;\n\n    ufunc->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if (sandbox)\n\tufunc->uf_flags |= FC_SANDBOX;\n    if (!ASCII_ISUPPER(*ufunc->uf_name))\n\tufunc->uf_flags |= FC_VIM9;\n    ufunc->uf_script_ctx = current_sctx;\n    ufunc->uf_script_ctx_version = current_sctx.sc_version;\n    ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    set_function_type(ufunc);\n\n    function_using_block_scopes(ufunc, evalarg->eval_cstack);\n\n    rettv->vval.v_partial = pt;\n    rettv->v_type = VAR_PARTIAL;\n    ufunc = NULL;\n    ret = OK;\n\nerret:\n    if (lnum_save >= 0)\n\tSOURCING_LNUM = lnum_save;\n    ga_clear_strings(&newlines);\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    ga_clear_strings(default_args);\n    if (ufunc != NULL)\n    {\n\tfunc_clear(ufunc, TRUE);\n\tfunc_free(ufunc, TRUE);\n    }\n    return ret;\n}\n\n/*\n * Parse a lambda expression and get a Funcref from \"*arg\" into \"rettv\".\n * \"arg\" points to the { in \"{arg -> expr}\" or the ( in \"(arg) => expr\"\n * When \"types_optional\" is TRUE optionally take argument types.\n * Return OK or FAIL.  Returns NOTDONE for dict or {expr}.\n */\n    int\nget_lambda_tv(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg)\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\tnewargs;\n    garray_T\tnewlines;\n    garray_T\t*pnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    ufunc_T\t*fp = NULL;\n    partial_T   *pt = NULL;\n    int\t\tvarargs;\n    char_u\t*ret_type = NULL;\n    int\t\tret;\n    char_u\t*s;\n    char_u\t*start, *end;\n    int\t\t*old_eval_lavars = eval_lavars_used;\n    int\t\teval_lavars = FALSE;\n    char_u\t*tofree1 = NULL;\n    char_u\t*tofree2 = NULL;\n    int\t\tequal_arrow = **arg == '(';\n    int\t\twhite_error = FALSE;\n    int\t\tcalled_emsg_start = called_emsg;\n    int\t\tvim9script = in_vim9script();\n    long\tstart_lnum = SOURCING_LNUM;\n\n    if (equal_arrow && !vim9script)\n\treturn NOTDONE;\n\n    ga_init(&newargs);\n    ga_init(&newlines);\n\n    // First, check if this is really a lambda expression. \"->\" or \"=>\" must\n    // be found after the arguments.\n    s = *arg + 1;\n    ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\tNULL, &default_args, TRUE, NULL, NULL);\n    if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\treturn called_emsg == called_emsg_start ? NOTDONE : FAIL;\n    }\n\n    // Parse the arguments for real.\n    if (evaluate)\n\tpnewargs = &newargs;\n    else\n\tpnewargs = NULL;\n    *arg += 1;\n    ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\t    &varargs, &default_args,\n\t\t\t\t\t    FALSE, NULL, NULL);\n    if (ret == FAIL\n\t\t  || (s = skip_arrow(*arg, equal_arrow, &ret_type,\n\t\tequal_arrow || vim9script ? &white_error : NULL)) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\tga_clear_strings(&newargs);\n\treturn white_error ? FAIL : NOTDONE;\n    }\n    *arg = s;\n\n    // Skipping over linebreaks may make \"ret_type\" invalid, make a copy.\n    if (ret_type != NULL)\n    {\n\tret_type = vim_strsave(ret_type);\n\ttofree2 = ret_type;\n    }\n\n    // Set up a flag for checking local variables and arguments.\n    if (evaluate)\n\teval_lavars_used = &eval_lavars;\n\n    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\n    // Recognize \"{\" as the start of a function body.\n    if (equal_arrow && **arg == '{')\n    {\n\tif (evalarg == NULL)\n\t    // cannot happen?\n\t    goto theend;\n\tSOURCING_LNUM = start_lnum;  // used for where lambda is defined\n\tif (lambda_function_body(arg, rettv, evalarg, pnewargs,\n\t\t\t   types_optional ? &argtypes : NULL, varargs,\n\t\t\t   &default_args, ret_type) == FAIL)\n\t    goto errret;\n\tgoto theend;\n    }\n    if (default_args.ga_len > 0)\n    {\n\temsg(_(e_cannot_use_default_values_in_lambda));\n\tgoto errret;\n    }\n\n    // Get the start and the end of the expression.\n    start = *arg;\n    ret = skip_expr_concatenate(arg, &start, &end, evalarg);\n    if (ret == FAIL)\n\tgoto errret;\n    if (evalarg != NULL)\n    {\n\t// avoid that the expression gets freed when another line break follows\n\ttofree1 = evalarg->eval_tofree;\n\tevalarg->eval_tofree = NULL;\n    }\n\n    if (!equal_arrow)\n    {\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != '}')\n\t{\n\t    semsg(_(e_expected_right_curly_str), *arg);\n\t    goto errret;\n\t}\n\t++*arg;\n    }\n\n    if (evaluate)\n    {\n\tint\t    len;\n\tint\t    flags = FC_LAMBDA;\n\tchar_u\t    *p;\n\tchar_u\t    *line_end;\n\tchar_u\t    *name = get_lambda_name();\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto errret;\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\tpt = ALLOC_CLEAR_ONE(partial_T);\n\tif (pt == NULL)\n\t    goto errret;\n\n\tga_init2(&newlines, sizeof(char_u *), 1);\n\tif (ga_grow(&newlines, 1) == FAIL)\n\t    goto errret;\n\n\t// If there are line breaks, we need to split up the string.\n\tline_end = vim_strchr(start, '\\n');\n\tif (line_end == NULL || line_end > end)\n\t    line_end = end;\n\n\t// Add \"return \" before the expression (or the first line).\n\tlen = 7 + (int)(line_end - start) + 1;\n\tp = alloc(len);\n\tif (p == NULL)\n\t    goto errret;\n\t((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;\n\tSTRCPY(p, \"return \");\n\tvim_strncpy(p + 7, start, line_end - start);\n\n\tif (line_end != end)\n\t{\n\t    // Add more lines, split by line breaks.  Thus is used when a\n\t    // lambda with { cmds } is encountered.\n\t    while (*line_end == '\\n')\n\t    {\n\t\tif (ga_grow(&newlines, 1) == FAIL)\n\t\t    goto errret;\n\t\tstart = line_end + 1;\n\t\tline_end = vim_strchr(start, '\\n');\n\t\tif (line_end == NULL)\n\t\t    line_end = end;\n\t\t((char_u **)(newlines.ga_data))[newlines.ga_len++] =\n\t\t\t\t\t vim_strnsave(start, line_end - start);\n\t    }\n\t}\n\n\tif (strstr((char *)p + 7, \"a:\") == NULL)\n\t    // No a: variables are used for sure.\n\t    flags |= FC_NOARGS;\n\n\tfp->uf_refcount = 1;\n\tset_ufunc_name(fp, name);\n\tfp->uf_args = newargs;\n\tga_init(&fp->uf_def_args);\n\tif (types_optional)\n\t{\n\t    if (parse_argument_types(fp, &argtypes,\n\t\t\t\t\t\tvim9script && varargs) == FAIL)\n\t\tgoto errret;\n\t    if (ret_type != NULL)\n\t    {\n\t\tfp->uf_ret_type = parse_type(&ret_type,\n\t\t\t\t\t\t      &fp->uf_type_list, TRUE);\n\t\tif (fp->uf_ret_type == NULL)\n\t\t    goto errret;\n\t    }\n\t    else\n\t\tfp->uf_ret_type = &t_unknown;\n\t}\n\n\tfp->uf_lines = newlines;\n\tif (current_funccal != NULL && eval_lavars)\n\t{\n\t    flags |= FC_CLOSURE;\n\t    if (register_closure(fp) == FAIL)\n\t\tgoto errret;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (prof_def_func())\n\t    func_do_profile(fp);\n#endif\n\tif (sandbox)\n\t    flags |= FC_SANDBOX;\n\t// In legacy script a lambda can be called with more args than\n\t// uf_args.ga_len.  In Vim9 script \"...name\" has to be used.\n\tfp->uf_varargs = !vim9script || varargs;\n\tfp->uf_flags = flags;\n\tfp->uf_calls = 0;\n\tfp->uf_script_ctx = current_sctx;\n\t// Use the line number of the arguments.\n\tfp->uf_script_ctx.sc_lnum += start_lnum;\n\n\tfunction_using_block_scopes(fp, evalarg->eval_cstack);\n\n\tpt->pt_func = fp;\n\tpt->pt_refcount = 1;\n\trettv->vval.v_partial = pt;\n\trettv->v_type = VAR_PARTIAL;\n\n\thash_add(&func_hashtab, UF2HIKEY(fp));\n    }\n\ntheend:\n    eval_lavars_used = old_eval_lavars;\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    if (types_optional)\n\tga_clear_strings(&argtypes);\n\n    return OK;\n\nerrret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&newlines);\n    ga_clear_strings(&default_args);\n    if (types_optional)\n    {\n\tga_clear_strings(&argtypes);\n\tif (fp != NULL)\n\t    vim_free(fp->uf_arg_types);\n    }\n    vim_free(fp);\n    vim_free(pt);\n    if (evalarg != NULL && evalarg->eval_tofree == NULL)\n\tevalarg->eval_tofree = tofree1;\n    else\n\tvim_free(tofree1);\n    vim_free(tofree2);\n    eval_lavars_used = old_eval_lavars;\n    return FAIL;\n}\n\n/*\n * Check if \"name\" is a variable of type VAR_FUNC.  If so, return the function\n * name it contains, otherwise return \"name\".\n * If \"partialp\" is not NULL, and \"name\" is of type VAR_PARTIAL also set\n * \"partialp\".\n * If \"type\" is not NULL and a Vim9 script-local variable is found look up the\n * type of the variable.\n * If \"new_function\" is TRUE the name is for a new function.\n * If \"found_var\" is not NULL and a variable was found set it to TRUE.\n */\n    char_u *\nderef_func_name(\n\tchar_u\t    *name,\n\tint\t    *lenp,\n\tpartial_T   **partialp,\n\ttype_T\t    **type,\n\tint\t    no_autoload,\n\tint\t    new_function,\n\tint\t    *found_var)\n{\n    dictitem_T\t*v;\n    typval_T\t*tv = NULL;\n    int\t\tcc;\n    char_u\t*s = NULL;\n    hashtab_T\t*ht;\n    int\t\tdid_type = FALSE;\n\n    if (partialp != NULL)\n\t*partialp = NULL;\n\n    cc = name[*lenp];\n    name[*lenp] = NUL;\n\n    v = find_var_also_in_script(name, &ht, no_autoload);\n    name[*lenp] = cc;\n    if (v != NULL)\n    {\n\ttv = &v->di_tv;\n    }\n    else if (in_vim9script() || STRNCMP(name, \"s:\", 2) == 0)\n    {\n\timported_T  *import;\n\tchar_u\t    *p = name;\n\tint\t    len = *lenp;\n\n\tif (STRNCMP(name, \"s:\", 2) == 0)\n\t{\n\t    p = name + 2;\n\t    len -= 2;\n\t}\n\timport = find_imported(p, len, FALSE);\n\n\t// imported function from another script\n\tif (import != NULL)\n\t{\n\t    name[len] = NUL;\n\t    if (new_function)\n\t\tsemsg(_(e_redefining_imported_item_str), name);\n\t    else\n\t\tsemsg(_(e_cannot_use_str_itself_it_is_imported), name);\n\t    name[len] = cc;\n\t    *lenp = 0;\n\t    return (char_u *)\"\";\t// just in case\n\t}\n    }\n\n    if (tv != NULL)\n    {\n\tif (found_var != NULL)\n\t    *found_var = TRUE;\n\tif (tv->v_type == VAR_FUNC)\n\t{\n\t    if (tv->vval.v_string == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    s = tv->vval.v_string;\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (tv->v_type == VAR_PARTIAL)\n\t{\n\t    partial_T *pt = tv->vval.v_partial;\n\n\t    if (pt == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    if (partialp != NULL)\n\t\t*partialp = pt;\n\t    s = partial_name(pt);\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (s != NULL)\n\t{\n\t    if (!did_type && type != NULL && ht == get_script_local_ht())\n\t    {\n\t\tsvar_T  *sv = find_typval_in_script(tv, 0, TRUE);\n\n\t\tif (sv != NULL)\n\t\t    *type = sv->sv_type;\n\t    }\n\t    return s;\n\t}\n    }\n\n    return name;\n}\n\n/*\n * Give an error message with a function name.  Handle <SNR> things.\n * \"ermsg\" is to be passed without translation, use N_() instead of _().\n */\n    void\nemsg_funcname(char *ermsg, char_u *name)\n{\n    char_u\t*p = name;\n\n    if (name[0] == K_SPECIAL && name[1] != NUL && name[2] != NUL)\n\tp = concat_str((char_u *)\"<SNR>\", name + 3);\n    semsg(_(ermsg), p);\n    if (p != name)\n\tvim_free(p);\n}\n\n/*\n * Allocate a variable for the result of a function.\n * Return OK or FAIL.\n */\n    int\nget_func_tv(\n    char_u\t*name,\t\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\n    char_u\t**arg,\t\t// argument, pointing to the '('\n    evalarg_T\t*evalarg,\t// for line continuation\n    funcexe_T\t*funcexe)\t// various values\n{\n    char_u\t*argp;\n    int\t\tret = OK;\n    typval_T\targvars[MAX_FUNC_ARGS + 1];\t// vars for arguments\n    int\t\targcount = 0;\t\t// number of arguments found\n    int\t\tvim9script = in_vim9script();\n    int\t\tevaluate = evalarg == NULL\n\t\t\t       ? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    /*\n     * Get the arguments.\n     */\n    argp = *arg;\n    while (argcount < MAX_FUNC_ARGS - (funcexe->fe_partial == NULL ? 0\n\t\t\t\t\t       : funcexe->fe_partial->pt_argc))\n    {\n\t// skip the '(' or ',' and possibly line breaks\n\targp = skipwhite_and_linebreak(argp + 1, evalarg);\n\n\tif (*argp == ')' || *argp == ',' || *argp == NUL)\n\t    break;\n\tif (eval1(&argp, &argvars[argcount], evalarg) == FAIL)\n\t{\n\t    ret = FAIL;\n\t    break;\n\t}\n\t++argcount;\n\t// The comma should come right after the argument, but this wasn't\n\t// checked previously, thus only enforce it in Vim9 script.\n\tif (vim9script)\n\t{\n\t    if (*argp != ',' && *skipwhite(argp) == ',')\n\t    {\n\t\tif (evaluate)\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str),\n\t\t\t\t\t\t\t\t    \",\", argp);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\telse\n\t    argp = skipwhite(argp);\n\tif (*argp != ',')\n\t    break;\n\tif (vim9script && !IS_WHITE_OR_NUL(argp[1]))\n\t{\n\t    if (evaluate)\n\t\tsemsg(_(e_white_space_required_after_str_str), \",\", argp);\n\t    ret = FAIL;\n\t    break;\n\t}\n    }\n    argp = skipwhite_and_linebreak(argp, evalarg);\n    if (*argp == ')')\n\t++argp;\n    else\n\tret = FAIL;\n\n    if (ret == OK)\n    {\n\tint\ti = 0;\n\tint\tdid_emsg_before = did_emsg;\n\n\tif (get_vim_var_nr(VV_TESTING))\n\t{\n\t    // Prepare for calling test_garbagecollect_now(), need to know\n\t    // what variables are used on the call stack.\n\t    if (funcargs.ga_itemsize == 0)\n\t\tga_init2(&funcargs, sizeof(typval_T *), 50);\n\t    for (i = 0; i < argcount; ++i)\n\t\tif (ga_grow(&funcargs, 1) == OK)\n\t\t    ((typval_T **)funcargs.ga_data)[funcargs.ga_len++] =\n\t\t\t\t\t\t\t\t  &argvars[i];\n\t}\n\n\tret = call_func(name, len, rettv, argcount, argvars, funcexe);\n\tif (vim9script && did_emsg > did_emsg_before)\n\t{\n\t    // An error in a builtin function does not return FAIL, but we do\n\t    // want to abort further processing if an error was given.\n\t    ret = FAIL;\n\t    clear_tv(rettv);\n\t}\n\n\tfuncargs.ga_len -= i;\n    }\n    else if (!aborting() && evaluate)\n    {\n\tif (argcount == MAX_FUNC_ARGS)\n\t    emsg_funcname(e_too_many_arguments_for_function_str_2, name);\n\telse\n\t    emsg_funcname(e_invalid_arguments_for_function_str, name);\n    }\n\n    while (--argcount >= 0)\n\tclear_tv(&argvars[argcount]);\n\n    if (vim9script)\n\t*arg = argp;\n    else\n\t*arg = skipwhite(argp);\n    return ret;\n}\n\n/*\n * Return TRUE if \"p\" starts with \"<SID>\" or \"s:\".\n * Only works if eval_fname_script() returned non-zero for \"p\"!\n */\n    static int\neval_fname_sid(char_u *p)\n{\n    return (*p == 's' || TOUPPER_ASC(p[2]) == 'I');\n}\n\n/*\n * In a script change <SID>name() and s:name() to K_SNR 123_name().\n * Change <SNR>123_name() to K_SNR 123_name().\n * Use \"fname_buf[FLEN_FIXED + 1]\" when it fits, otherwise allocate memory\n * (slow).\n */\n    char_u *\nfname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error)\n{\n    int\t\tllen;\n    char_u\t*fname;\n    int\t\ti;\n\n    llen = eval_fname_script(name);\n    if (llen > 0)\n    {\n\tfname_buf[0] = K_SPECIAL;\n\tfname_buf[1] = KS_EXTRA;\n\tfname_buf[2] = (int)KE_SNR;\n\ti = 3;\n\tif (eval_fname_sid(name))\t// \"<SID>\" or \"s:\"\n\t{\n\t    if (current_sctx.sc_sid <= 0)\n\t\t*error = FCERR_SCRIPT;\n\t    else\n\t    {\n\t\tsprintf((char *)fname_buf + 3, \"%ld_\",\n\t\t\t\t\t\t    (long)current_sctx.sc_sid);\n\t\ti = (int)STRLEN(fname_buf);\n\t    }\n\t}\n\tif (i + STRLEN(name + llen) < FLEN_FIXED)\n\t{\n\t    STRCPY(fname_buf + i, name + llen);\n\t    fname = fname_buf;\n\t}\n\telse\n\t{\n\t    fname = alloc(i + STRLEN(name + llen) + 1);\n\t    if (fname == NULL)\n\t\t*error = FCERR_OTHER;\n\t    else\n\t    {\n\t\t*tofree = fname;\n\t\tmch_memmove(fname, fname_buf, (size_t)i);\n\t\tSTRCPY(fname + i, name + llen);\n\t    }\n\t}\n    }\n    else\n\tfname = name;\n    return fname;\n}\n\n/*\n * Concatenate the script ID and function name into  \"<SNR>99_name\".\n * \"buffer\" must have size MAX_FUNC_NAME_LEN.\n */\n    void\nfunc_name_with_sid(char_u *name, int sid, char_u *buffer)\n{\n    // A script-local function is stored as \"<SNR>99_name\".\n    buffer[0] = K_SPECIAL;\n    buffer[1] = KS_EXTRA;\n    buffer[2] = (int)KE_SNR;\n    vim_snprintf((char *)buffer + 3, MAX_FUNC_NAME_LEN - 3, \"%ld_%s\",\n\t\t\t\t\t\t\t      (long)sid, name);\n}\n\n/*\n * Find a function \"name\" in script \"sid\".\n */\n    static ufunc_T *\nfind_func_with_sid(char_u *name, int sid)\n{\n    hashitem_T\t    *hi;\n    char_u\t    buffer[MAX_FUNC_NAME_LEN];\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\t// not in a script\n\n    func_name_with_sid(name, sid, buffer);\n    hi = hash_find(&func_hashtab, buffer);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n    return NULL;\n}\n\n/*\n * Find a function \"name\" in script \"sid\" prefixing the autoload prefix.\n */\n    static ufunc_T *\nfind_func_with_prefix(char_u *name, int sid)\n{\n    hashitem_T\t    *hi;\n    char_u\t    buffer[MAX_FUNC_NAME_LEN];\n    scriptitem_T    *si;\n\n    if (vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\treturn NULL;\t// already has the prefix\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\t// not in a script\n    si = SCRIPT_ITEM(sid);\n    if (si->sn_autoload_prefix != NULL)\n    {\n\tsize_t\tlen = STRLEN(si->sn_autoload_prefix) + STRLEN(name) + 1;\n\tchar_u\t*auto_name;\n\tchar_u\t*namep;\n\n\t// skip a \"<SNR>99_\" prefix\n\tnamep = untrans_function_name(name);\n\tif (namep == NULL)\n\t    namep = name;\n\n\t// An exported function in an autoload script is stored as\n\t// \"dir#path#name\".\n\tif (len < sizeof(buffer))\n\t    auto_name = buffer;\n\telse\n\t    auto_name = alloc(len);\n\tif (auto_name != NULL)\n\t{\n\t    vim_snprintf((char *)auto_name, len, \"%s%s\",\n\t\t\t\t\t\tsi->sn_autoload_prefix, namep);\n\t    hi = hash_find(&func_hashtab, auto_name);\n\t    if (auto_name != buffer)\n\t\tvim_free(auto_name);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\treturn HI2UF(hi);\n\t}\n    }\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * When \"flags\" has FFED_IS_GLOBAL don't find script-local or imported\n * functions.\n * When \"flags\" has \"FFED_NO_GLOBAL\" don't find global functions.\n * Return NULL for unknown function.\n */\n    ufunc_T *\nfind_func_even_dead(char_u *name, int flags)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*func;\n\n    if ((flags & FFED_IS_GLOBAL) == 0)\n    {\n\t// Find script-local function before global one.\n\tif (in_vim9script() && eval_isnamec1(*name)\n\t\t\t\t\t   && (name[1] != ':' || *name == 's'))\n\t{\n\t    func = find_func_with_sid(name[0] == 's' && name[1] == ':'\n\t\t\t\t       ? name + 2 : name, current_sctx.sc_sid);\n\t    if (func != NULL)\n\t\treturn func;\n\t}\n\tif (in_vim9script() && STRNCMP(name, \"<SNR>\", 5) == 0)\n\t{\n\t    char_u  *p = name + 5;\n\t    long    sid;\n\n\t    // printable \"<SNR>123_Name\" form\n\t    sid = getdigits(&p);\n\t    if (*p == '_')\n\t    {\n\t\tfunc = find_func_with_sid(p + 1, (int)sid);\n\t\tif (func != NULL)\n\t\t    return func;\n\t    }\n\t}\n    }\n\n    if ((flags & FFED_NO_GLOBAL) == 0)\n    {\n\thi = hash_find(&func_hashtab,\n\t\t\t\tSTRNCMP(name, \"g:\", 2) == 0 ? name + 2 : name);\n\tif (!HASHITEM_EMPTY(hi))\n\t    return HI2UF(hi);\n    }\n\n    // Find autoload function if this is an autoload script.\n    return find_func_with_prefix(name[0] == 's' && name[1] == ':'\n\t\t\t\t       ? name + 2 : name, current_sctx.sc_sid);\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * \"cctx\" is passed in a :def function to find imported functions.\n * Return NULL for unknown or dead function.\n */\n    ufunc_T *\nfind_func(char_u *name, int is_global)\n{\n    ufunc_T\t*fp = find_func_even_dead(name, is_global ? FFED_IS_GLOBAL : 0);\n\n    if (fp != NULL && (fp->uf_flags & FC_DEAD) == 0)\n\treturn fp;\n    return NULL;\n}\n\n/*\n * Return TRUE if \"ufunc\" is a global function.\n */\n    int\nfunc_is_global(ufunc_T *ufunc)\n{\n    return ufunc->uf_name[0] != K_SPECIAL;\n}\n\n/*\n * Return TRUE if \"ufunc\" must be called with a g: prefix in Vim9 script.\n */\n    int\nfunc_requires_g_prefix(ufunc_T *ufunc)\n{\n    return ufunc->uf_name[0] != K_SPECIAL\n\t    && (ufunc->uf_flags & FC_LAMBDA) == 0\n\t    && vim_strchr(ufunc->uf_name, AUTOLOAD_CHAR) == NULL;\n}\n\n/*\n * Copy the function name of \"fp\" to buffer \"buf\".\n * \"buf\" must be able to hold the function name plus three bytes.\n * Takes care of script-local function names.\n */\n    static void\ncat_func_name(char_u *buf, ufunc_T *fp)\n{\n    if (!func_is_global(fp))\n    {\n\tSTRCPY(buf, \"<SNR>\");\n\tSTRCAT(buf, fp->uf_name + 3);\n    }\n    else\n\tSTRCPY(buf, fp->uf_name);\n}\n\n/*\n * Add a number variable \"name\" to dict \"dp\" with value \"nr\".\n */\n    static void\nadd_nr_var(\n    dict_T\t*dp,\n    dictitem_T\t*v,\n    char\t*name,\n    varnumber_T nr)\n{\n    STRCPY(v->di_key, name);\n    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    hash_add(&dp->dv_hashtab, DI2HIKEY(v));\n    v->di_tv.v_type = VAR_NUMBER;\n    v->di_tv.v_lock = VAR_FIXED;\n    v->di_tv.vval.v_number = nr;\n}\n\n/*\n * Free \"fc\".\n */\n    static void\nfree_funccal(funccall_T *fc)\n{\n    int\ti;\n\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n    {\n\tufunc_T *fp = ((ufunc_T **)(fc->fc_funcs.ga_data))[i];\n\n\t// When garbage collecting a funccall_T may be freed before the\n\t// function that references it, clear its uf_scoped field.\n\t// The function may have been redefined and point to another\n\t// funccall_T, don't clear it then.\n\tif (fp != NULL && fp->uf_scoped == fc)\n\t    fp->uf_scoped = NULL;\n    }\n    ga_clear(&fc->fc_funcs);\n\n    func_ptr_unref(fc->func);\n    vim_free(fc);\n}\n\n/*\n * Free \"fc\" and what it contains.\n * Can be called only when \"fc\" is kept beyond the period of it called,\n * i.e. after cleanup_function_call(fc).\n */\n   static void\nfree_funccal_contents(funccall_T *fc)\n{\n    listitem_T\t*li;\n\n    // Free all l: variables.\n    vars_clear(&fc->l_vars.dv_hashtab);\n\n    // Free all a: variables.\n    vars_clear(&fc->l_avars.dv_hashtab);\n\n    // Free the a:000 variables.\n    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\tclear_tv(&li->li_tv);\n\n    free_funccal(fc);\n}\n\n/*\n * Handle the last part of returning from a function: free the local hashtable.\n * Unless it is still in use by a closure.\n */\n    static void\ncleanup_function_call(funccall_T *fc)\n{\n    int\tmay_free_fc = fc->fc_refcount <= 0;\n    int\tfree_fc = TRUE;\n\n    current_funccal = fc->caller;\n\n    // Free all l: variables if not referred.\n    if (may_free_fc && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear(&fc->l_vars.dv_hashtab);\n    else\n\tfree_fc = FALSE;\n\n    // If the a:000 list and the l: and a: dicts are not referenced and\n    // there is no closure using it, we can free the funccall_T and what's\n    // in it.\n    if (may_free_fc && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear_ext(&fc->l_avars.dv_hashtab, FALSE);\n    else\n    {\n\tint\t    todo;\n\thashitem_T  *hi;\n\tdictitem_T  *di;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a: variables, since we didn't do that above.\n\ttodo = (int)fc->l_avars.dv_hashtab.ht_used;\n\tfor (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tdi = HI2DI(hi);\n\t\tcopy_tv(&di->di_tv, &di->di_tv);\n\t    }\n\t}\n    }\n\n    if (may_free_fc && fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT)\n\tfc->l_varlist.lv_first = NULL;\n    else\n    {\n\tlistitem_T *li;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a:000 items, since we didn't do that above.\n\tFOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\t    copy_tv(&li->li_tv, &li->li_tv);\n    }\n\n    if (free_fc)\n\tfree_funccal(fc);\n    else\n    {\n\tstatic int made_copy = 0;\n\n\t// \"fc\" is still in use.  This can happen when returning \"a:000\",\n\t// assigning \"l:\" to a global variable or defining a closure.\n\t// Link \"fc\" in the list for garbage collection later.\n\tfc->caller = previous_funccal;\n\tprevious_funccal = fc;\n\n\tif (want_garbage_collect)\n\t    // If garbage collector is ready, clear count.\n\t    made_copy = 0;\n\telse if (++made_copy >= (int)((4096 * 1024) / sizeof(*fc)))\n\t{\n\t    // We have made a lot of copies, worth 4 Mbyte.  This can happen\n\t    // when repetitively calling a function that creates a reference to\n\t    // itself somehow.  Call the garbage collector soon to avoid using\n\t    // too much memory.\n\t    made_copy = 0;\n\t    want_garbage_collect = TRUE;\n\t}\n    }\n}\n\n/*\n * Return TRUE if \"name\" is a numbered function, ignoring a \"g:\" prefix.\n */\n    static int\nnumbered_function(char_u *name)\n{\n    return isdigit(*name)\n\t    || (name[0] == 'g' && name[1] == ':' && isdigit(name[2]));\n}\n\n/*\n * There are two kinds of function names:\n * 1. ordinary names, function defined with :function or :def;\n *    can start with \"<SNR>123_\" literally or with K_SPECIAL.\n * 2. Numbered functions and lambdas: \"<lambda>123\"\n * For the first we only count the name stored in func_hashtab as a reference,\n * using function() does not count as a reference, because the function is\n * looked up by name.\n */\n    int\nfunc_name_refcount(char_u *name)\n{\n    return numbered_function(name) || (name[0] == '<' && name[1] == 'l');\n}\n\n/*\n * Unreference \"fc\": decrement the reference count and free it when it\n * becomes zero.  \"fp\" is detached from \"fc\".\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunccal_unref(funccall_T *fc, ufunc_T *fp, int force)\n{\n    funccall_T\t**pfc;\n    int\t\ti;\n\n    if (fc == NULL)\n\treturn;\n\n    if (--fc->fc_refcount <= 0 && (force || (\n\t\tfc->l_varlist.lv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_vars.dv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)))\n\tfor (pfc = &previous_funccal; *pfc != NULL; pfc = &(*pfc)->caller)\n\t{\n\t    if (fc == *pfc)\n\t    {\n\t\t*pfc = fc->caller;\n\t\tfree_funccal_contents(fc);\n\t\treturn;\n\t    }\n\t}\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n\tif (((ufunc_T **)(fc->fc_funcs.ga_data))[i] == fp)\n\t    ((ufunc_T **)(fc->fc_funcs.ga_data))[i] = NULL;\n}\n\n/*\n * Remove the function from the function hashtable.  If the function was\n * deleted while it still has references this was already done.\n * Return TRUE if the entry was deleted, FALSE if it wasn't found.\n */\n    static int\nfunc_remove(ufunc_T *fp)\n{\n    hashitem_T\t*hi;\n\n    // Return if it was already virtually deleted.\n    if (fp->uf_flags & FC_DEAD)\n\treturn FALSE;\n\n    hi = hash_find(&func_hashtab, UF2HIKEY(fp));\n    if (!HASHITEM_EMPTY(hi))\n    {\n\t// When there is a def-function index do not actually remove the\n\t// function, so we can find the index when defining the function again.\n\t// Do remove it when it's a copy.\n\tif (fp->uf_def_status == UF_COMPILED && (fp->uf_flags & FC_COPY) == 0)\n\t{\n\t    fp->uf_flags |= FC_DEAD;\n\t    return FALSE;\n\t}\n\thash_remove(&func_hashtab, hi);\n\tfp->uf_flags |= FC_DELETED;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nfunc_clear_items(ufunc_T *fp)\n{\n    ga_clear_strings(&(fp->uf_args));\n    ga_clear_strings(&(fp->uf_def_args));\n    ga_clear_strings(&(fp->uf_lines));\n    VIM_CLEAR(fp->uf_arg_types);\n    VIM_CLEAR(fp->uf_block_ids);\n    VIM_CLEAR(fp->uf_va_name);\n    clear_type_list(&fp->uf_type_list);\n\n    // Increment the refcount of this function to avoid it being freed\n    // recursively when the partial is freed.\n    fp->uf_refcount += 3;\n    partial_unref(fp->uf_partial);\n    fp->uf_partial = NULL;\n    fp->uf_refcount -= 3;\n\n#ifdef FEAT_LUA\n    if (fp->uf_cb_free != NULL)\n    {\n\tfp->uf_cb_free(fp->uf_cb_state);\n\tfp->uf_cb_free = NULL;\n    }\n\n    fp->uf_cb_state = NULL;\n    fp->uf_cb = NULL;\n#endif\n#ifdef FEAT_PROFILE\n    VIM_CLEAR(fp->uf_tml_count);\n    VIM_CLEAR(fp->uf_tml_total);\n    VIM_CLEAR(fp->uf_tml_self);\n#endif\n}\n\n/*\n * Free all things that a function contains.  Does not free the function\n * itself, use func_free() for that.\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunc_clear(ufunc_T *fp, int force)\n{\n    if (fp->uf_cleared)\n\treturn;\n    fp->uf_cleared = TRUE;\n\n    // clear this function\n    func_clear_items(fp);\n    funccal_unref(fp->uf_scoped, fp, force);\n    unlink_def_function(fp);\n}\n\n/*\n * Free a function and remove it from the list of functions.  Does not free\n * what a function contains, call func_clear() first.\n * When \"force\" is TRUE we are exiting.\n * Returns OK when the function was actually freed.\n */\n    static int\nfunc_free(ufunc_T *fp, int force)\n{\n    // Only remove it when not done already, otherwise we would remove a newer\n    // version of the function with the same name.\n    if ((fp->uf_flags & (FC_DELETED | FC_REMOVED)) == 0)\n\tfunc_remove(fp);\n\n    if ((fp->uf_flags & FC_DEAD) == 0 || force)\n    {\n\tif (fp->uf_dfunc_idx > 0)\n\t    unlink_def_function(fp);\n\tVIM_CLEAR(fp->uf_name_exp);\n\tvim_free(fp);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Free all things that a function contains and free the function itself.\n * When \"force\" is TRUE we are exiting.\n */\n    void\nfunc_clear_free(ufunc_T *fp, int force)\n{\n    func_clear(fp, force);\n    if (force || fp->uf_dfunc_idx == 0 || func_name_refcount(fp->uf_name)\n\t\t\t\t\t\t   || (fp->uf_flags & FC_COPY))\n\tfunc_free(fp, force);\n    else\n\tfp->uf_flags |= FC_DEAD;\n}\n\n/*\n * Copy already defined function \"lambda\" to a new function with name \"global\".\n * This is for when a compiled function defines a global function.\n */\n    int\ncopy_func(char_u *lambda, char_u *global, ectx_T *ectx)\n{\n    ufunc_T *ufunc = find_func_even_dead(lambda, FFED_IS_GLOBAL);\n    ufunc_T *fp = NULL;\n\n    if (ufunc == NULL)\n    {\n\tsemsg(_(e_lambda_function_not_found_str), lambda);\n\treturn FAIL;\n    }\n\n    fp = find_func(global, TRUE);\n    if (fp != NULL)\n    {\n\t// TODO: handle ! to overwrite\n\tsemsg(_(e_function_str_already_exists_add_bang_to_replace), global);\n\treturn FAIL;\n    }\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(global) + 1);\n    if (fp == NULL)\n\treturn FAIL;\n\n    fp->uf_varargs = ufunc->uf_varargs;\n    fp->uf_flags = (ufunc->uf_flags & ~FC_VIM9) | FC_COPY;\n    fp->uf_def_status = ufunc->uf_def_status;\n    fp->uf_dfunc_idx = ufunc->uf_dfunc_idx;\n    if (ga_copy_strings(&ufunc->uf_args, &fp->uf_args) == FAIL\n\t    || ga_copy_strings(&ufunc->uf_def_args, &fp->uf_def_args)\n\t\t\t\t\t\t\t\t    == FAIL\n\t    || ga_copy_strings(&ufunc->uf_lines, &fp->uf_lines) == FAIL)\n\tgoto failed;\n\n    fp->uf_name_exp = ufunc->uf_name_exp == NULL ? NULL\n\t\t\t\t\t : vim_strsave(ufunc->uf_name_exp);\n    if (ufunc->uf_arg_types != NULL)\n    {\n\tfp->uf_arg_types = ALLOC_MULT(type_T *, fp->uf_args.ga_len);\n\tif (fp->uf_arg_types == NULL)\n\t    goto failed;\n\tmch_memmove(fp->uf_arg_types, ufunc->uf_arg_types,\n\t\t\t\t    sizeof(type_T *) * fp->uf_args.ga_len);\n    }\n    if (ufunc->uf_va_name != NULL)\n    {\n\tfp->uf_va_name = vim_strsave(ufunc->uf_va_name);\n\tif (fp->uf_va_name == NULL)\n\t    goto failed;\n    }\n    fp->uf_ret_type = ufunc->uf_ret_type;\n\n    fp->uf_refcount = 1;\n    STRCPY(fp->uf_name, global);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    // the referenced dfunc_T is now used one more time\n    link_def_function(fp);\n\n    // Create a partial to store the context of the function where it was\n    // instantiated.  Only needs to be done once.  Do this on the original\n    // function, \"dfunc->df_ufunc\" will point to it.\n    if ((ufunc->uf_flags & FC_CLOSURE) && ufunc->uf_partial == NULL)\n    {\n\tpartial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt == NULL)\n\t    goto failed;\n\tif (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t{\n\t    vim_free(pt);\n\t    goto failed;\n\t}\n\tufunc->uf_partial = pt;\n\t--pt->pt_refcount;  // not actually referenced here\n    }\n\n    return OK;\n\nfailed:\n    func_clear_free(fp, TRUE);\n    return FAIL;\n}\n\nstatic int\tfuncdepth = 0;\n\n/*\n * Increment the function call depth count.\n * Return FAIL when going over 'maxfuncdepth'.\n * Otherwise return OK, must call funcdepth_decrement() later!\n */\n    int\nfuncdepth_increment(void)\n{\n    if (funcdepth >= p_mfd)\n    {\n\temsg(_(e_function_call_depth_is_higher_than_macfuncdepth));\n\treturn FAIL;\n    }\n    ++funcdepth;\n    return OK;\n}\n\n    void\nfuncdepth_decrement(void)\n{\n    --funcdepth;\n}\n\n/*\n * Get the current function call depth.\n */\n    int\nfuncdepth_get(void)\n{\n    return funcdepth;\n}\n\n/*\n * Restore the function call depth.  This is for cases where there is no\n * guarantee funcdepth_decrement() can be called exactly the same number of\n * times as funcdepth_increment().\n */\n    void\nfuncdepth_restore(int depth)\n{\n    funcdepth = depth;\n}\n\n/*\n * Call a user function.\n */\n    static void\ncall_user_func(\n    ufunc_T\t*fp,\t\t// pointer to function\n    int\t\targcount,\t// nr of args\n    typval_T\t*argvars,\t// arguments\n    typval_T\t*rettv,\t\t// return value\n    funcexe_T\t*funcexe,\t// context\n    dict_T\t*selfdict)\t// Dictionary for \"self\"\n{\n    sctx_T\tsave_current_sctx;\n    int\t\tusing_sandbox = FALSE;\n    int\t\tsave_sticky_cmdmod_flags = sticky_cmdmod_flags;\n    funccall_T\t*fc;\n    int\t\tsave_did_emsg;\n    int\t\tdefault_arg_err = FALSE;\n    dictitem_T\t*v;\n    int\t\tfixvar_idx = 0;\t// index in fixvar[]\n    int\t\ti;\n    int\t\tai;\n    int\t\tislambda = FALSE;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*name;\n    typval_T\t*tv_to_free[MAX_FUNC_ARGS];\n    int\t\ttv_to_free_len = 0;\n#ifdef FEAT_PROFILE\n    profinfo_T\tprofile_info;\n#endif\n    ESTACK_CHECK_DECLARATION\n\n#ifdef FEAT_PROFILE\n    CLEAR_FIELD(profile_info);\n#endif\n\n    // If depth of calling is getting too high, don't execute the function.\n    if (funcdepth_increment() == FAIL)\n    {\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n\treturn;\n    }\n\n    line_breakcheck();\t\t// check for CTRL-C hit\n\n    fc = ALLOC_CLEAR_ONE(funccall_T);\n    if (fc == NULL)\n\treturn;\n    fc->caller = current_funccal;\n    current_funccal = fc;\n    fc->func = fp;\n    fc->rettv = rettv;\n    fc->level = ex_nesting_level;\n    // Check if this function has a breakpoint.\n    fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);\n    fc->dbg_tick = debug_tick;\n    // Set up fields for closure.\n    ga_init2(&fc->fc_funcs, sizeof(ufunc_T *), 1);\n    func_ptr_ref(fp);\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n#ifdef FEAT_PROFILE\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n#endif\n\t// Execute the function, possibly compiling it first.\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES)\n\t    profile_may_start_func(&profile_info, fp, caller);\n#endif\n\tsticky_cmdmod_flags = 0;\n\tcall_def_function(fp, argcount, argvars, funcexe->fe_partial, rettv);\n\tfuncdepth_decrement();\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES && (fp->uf_profiling\n\t\t\t\t  || (caller != NULL && caller->uf_profiling)))\n\t    profile_may_end_func(&profile_info, fp, caller);\n#endif\n\tcurrent_funccal = fc->caller;\n\tfree_funccal(fc);\n\tsticky_cmdmod_flags = save_sticky_cmdmod_flags;\n\treturn;\n    }\n\n    islambda = fp->uf_flags & FC_LAMBDA;\n\n    /*\n     * Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables\n     * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free\n     * each argument variable and saves a lot of time.\n     */\n    /*\n     * Init l: variables.\n     */\n    init_var_dict(&fc->l_vars, &fc->l_vars_var, VAR_DEF_SCOPE);\n    if (selfdict != NULL)\n    {\n\t// Set l:self to \"selfdict\".  Use \"name\" to avoid a warning from\n\t// some compiler that checks the destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"self\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_DICT;\n\tv->di_tv.v_lock = 0;\n\tv->di_tv.vval.v_dict = selfdict;\n\t++selfdict->dv_refcount;\n    }\n\n    /*\n     * Init a: variables, unless none found (in lambda).\n     * Set a:0 to \"argcount\" less number of named arguments, if >= 0.\n     * Set a:000 to a list with room for the \"...\" arguments.\n     */\n    init_var_dict(&fc->l_avars, &fc->l_avars_var, VAR_SCOPE);\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"0\",\n\t\t\t\t(varnumber_T)(argcount >= fp->uf_args.ga_len\n\t\t\t\t    ? argcount - fp->uf_args.ga_len : 0));\n    fc->l_avars.dv_lock = VAR_FIXED;\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\t// Use \"name\" to avoid a warning from some compiler that checks the\n\t// destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"000\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_LIST;\n\tv->di_tv.v_lock = VAR_FIXED;\n\tv->di_tv.vval.v_list = &fc->l_varlist;\n    }\n    CLEAR_FIELD(fc->l_varlist);\n    fc->l_varlist.lv_refcount = DO_NOT_FREE_CNT;\n    fc->l_varlist.lv_lock = VAR_FIXED;\n\n    /*\n     * Set a:firstline to \"firstline\" and a:lastline to \"lastline\".\n     * Set a:name to named arguments.\n     * Set a:N to the \"...\" arguments.\n     * Skipped when no a: variables used (in lambda).\n     */\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"firstline\",\n\t\t\t\t\t   (varnumber_T)funcexe->fe_firstline);\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"lastline\",\n\t\t\t\t\t    (varnumber_T)funcexe->fe_lastline);\n    }\n    for (i = 0; i < argcount || i < fp->uf_args.ga_len; ++i)\n    {\n\tint\t    addlocal = FALSE;\n\ttypval_T    def_rettv;\n\tint\t    isdefault = FALSE;\n\n\tai = i - fp->uf_args.ga_len;\n\tif (ai < 0)\n\t{\n\t    // named argument a:name\n\t    name = FUNCARG(fp, i);\n\t    if (islambda)\n\t\taddlocal = TRUE;\n\n\t    // evaluate named argument default expression\n\t    isdefault = ai + fp->uf_def_args.ga_len >= 0\n\t\t       && (i >= argcount || (argvars[i].v_type == VAR_SPECIAL\n\t\t\t\t   && argvars[i].vval.v_number == VVAL_NONE));\n\t    if (isdefault)\n\t    {\n\t\tchar_u\t    *default_expr = NULL;\n\n\t\tdef_rettv.v_type = VAR_NUMBER;\n\t\tdef_rettv.vval.v_number = -1;\n\n\t\tdefault_expr = ((char_u **)(fp->uf_def_args.ga_data))\n\t\t\t\t\t\t [ai + fp->uf_def_args.ga_len];\n\t\tif (eval1(&default_expr, &def_rettv, &EVALARG_EVALUATE) == FAIL)\n\t\t{\n\t\t    default_arg_err = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    if ((fp->uf_flags & FC_NOARGS) != 0)\n\t\t// Bail out if no a: arguments used (in lambda).\n\t\tbreak;\n\n\t    // \"...\" argument a:1, a:2, etc.\n\t    sprintf((char *)numbuf, \"%d\", ai + 1);\n\t    name = numbuf;\n\t}\n\tif (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)\n\t{\n\t    v = &fc->fixvar[fixvar_idx++].var;\n\t    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\t    STRCPY(v->di_key, name);\n\t}\n\telse\n\t{\n\t    v = dictitem_alloc(name);\n\t    if (v == NULL)\n\t\tbreak;\n\t    v->di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;\n\t}\n\n\t// Note: the values are copied directly to avoid alloc/free.\n\t// \"argvars\" must have VAR_FIXED for v_lock.\n\tv->di_tv = isdefault ? def_rettv : argvars[i];\n\tv->di_tv.v_lock = VAR_FIXED;\n\n\tif (isdefault)\n\t    // Need to free this later, no matter where it's stored.\n\t    tv_to_free[tv_to_free_len++] = &v->di_tv;\n\n\tif (addlocal)\n\t{\n\t    // Named arguments should be accessed without the \"a:\" prefix in\n\t    // lambda expressions.  Add to the l: dict.\n\t    copy_tv(&v->di_tv, &v->di_tv);\n\t    hash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\t}\n\telse\n\t    hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\n\tif (ai >= 0 && ai < MAX_FUNC_ARGS)\n\t{\n\t    listitem_T *li = &fc->l_listitems[ai];\n\n\t    li->li_tv = argvars[i];\n\t    li->li_tv.v_lock = VAR_FIXED;\n\t    list_append(&fc->l_varlist, li);\n\t}\n    }\n\n    // Don't redraw while executing the function.\n    ++RedrawingDisabled;\n\n    if (fp->uf_flags & FC_SANDBOX)\n    {\n\tusing_sandbox = TRUE;\n\t++sandbox;\n    }\n\n    estack_push_ufunc(fp, 1);\n    ESTACK_CHECK_SETUP\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"calling %s\"), SOURCING_NAME);\n\tif (p_verbose >= 14)\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    msg_puts(\"(\");\n\t    for (i = 0; i < argcount; ++i)\n\t    {\n\t\tif (i > 0)\n\t\t    msg_puts(\", \");\n\t\tif (argvars[i].v_type == VAR_NUMBER)\n\t\t    msg_outnum((long)argvars[i].vval.v_number);\n\t\telse\n\t\t{\n\t\t    // Do not want errors such as E724 here.\n\t\t    ++emsg_off;\n\t\t    s = tv2string(&argvars[i], &tofree, numbuf2, 0);\n\t\t    --emsg_off;\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t\t{\n\t\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t\t    s = buf;\n\t\t\t}\n\t\t\tmsg_puts((char *)s);\n\t\t\tvim_free(tofree);\n\t\t    }\n\t\t}\n\t    }\n\t    msg_puts(\")\");\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprofile_may_start_func(&profile_info, fp,\n\t\t\t\t fc->caller == NULL ? NULL : fc->caller->func);\n#endif\n\n    // \"legacy\" does not apply to commands in the function\n    sticky_cmdmod_flags = 0;\n\n    save_current_sctx = current_sctx;\n    current_sctx = fp->uf_script_ctx;\n    save_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    if (default_arg_err && (fp->uf_flags & FC_ABORT))\n\tdid_emsg = TRUE;\n    else if (islambda)\n    {\n\tchar_u *p = *(char_u **)fp->uf_lines.ga_data + 7;\n\n\t// A Lambda always has the command \"return {expr}\".  It is much faster\n\t// to evaluate {expr} directly.\n\t++ex_nesting_level;\n\t(void)eval1(&p, rettv, &EVALARG_EVALUATE);\n\t--ex_nesting_level;\n    }\n    else\n\t// call do_cmdline() to execute the lines\n\tdo_cmdline(NULL, get_func_line, (void *)fc,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n    --RedrawingDisabled;\n\n    // when the function was aborted because of an error, return -1\n    if ((did_emsg && (fp->uf_flags & FC_ABORT)) || rettv->v_type == VAR_UNKNOWN)\n    {\n\tclear_tv(rettv);\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n    }\n\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n\n\tif (fp->uf_profiling || (caller != NULL && caller->uf_profiling))\n\t    profile_may_end_func(&profile_info, fp, caller);\n    }\n#endif\n\n    // when being verbose, mention the return value\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tif (aborting())\n\t    smsg(_(\"%s aborted\"), SOURCING_NAME);\n\telse if (fc->rettv->v_type == VAR_NUMBER)\n\t    smsg(_(\"%s returning #%ld\"), SOURCING_NAME,\n\t\t\t\t\t       (long)fc->rettv->vval.v_number);\n\telse\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    // The value may be very long.  Skip the middle part, so that we\n\t    // have some idea how it starts and ends. smsg() would always\n\t    // truncate it at the end. Don't want errors such as E724 here.\n\t    ++emsg_off;\n\t    s = tv2string(fc->rettv, &tofree, numbuf2, 0);\n\t    --emsg_off;\n\t    if (s != NULL)\n\t    {\n\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t{\n\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t    s = buf;\n\t\t}\n\t\tsmsg(_(\"%s returning %s\"), SOURCING_NAME, s);\n\t\tvim_free(tofree);\n\t    }\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    ESTACK_CHECK_NOW\n    estack_pop();\n    current_sctx = save_current_sctx;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tscript_prof_restore(&profile_info.pi_wait_start);\n#endif\n    if (using_sandbox)\n\t--sandbox;\n    sticky_cmdmod_flags = save_sticky_cmdmod_flags;\n\n    if (p_verbose >= 12 && SOURCING_NAME != NULL)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"continuing in %s\"), SOURCING_NAME);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    did_emsg |= save_did_emsg;\n    funcdepth_decrement();\n    for (i = 0; i < tv_to_free_len; ++i)\n\tclear_tv(tv_to_free[i]);\n    cleanup_function_call(fc);\n}\n\n/*\n * Check the argument count for user function \"fp\".\n * Return FCERR_UNKNOWN if OK, FCERR_TOOFEW or FCERR_TOOMANY otherwise.\n */\n    int\ncheck_user_func_argcount(ufunc_T *fp, int argcount)\n{\n    int regular_args = fp->uf_args.ga_len;\n\n    if (argcount < regular_args - fp->uf_def_args.ga_len)\n\treturn FCERR_TOOFEW;\n    else if (!has_varargs(fp) && argcount > regular_args)\n\treturn FCERR_TOOMANY;\n    return FCERR_UNKNOWN;\n}\n\n/*\n * Call a user function after checking the arguments.\n */\n    int\ncall_user_func_check(\n\tufunc_T\t    *fp,\n\tint\t    argcount,\n\ttypval_T    *argvars,\n\ttypval_T    *rettv,\n\tfuncexe_T   *funcexe,\n\tdict_T\t    *selfdict)\n{\n    int error;\n\n#ifdef FEAT_LUA\n    if (fp->uf_flags & FC_CFUNC)\n    {\n\tcfunc_T cb = fp->uf_cb;\n\n\treturn (*cb)(argcount, argvars, rettv, fp->uf_cb_state);\n    }\n#endif\n\n    if (fp->uf_flags & FC_RANGE && funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = TRUE;\n    error = check_user_func_argcount(fp, argcount);\n    if (error != FCERR_UNKNOWN)\n\treturn error;\n    if ((fp->uf_flags & FC_DICT) && selfdict == NULL)\n\terror = FCERR_DICT;\n    else\n    {\n\tint\t\tdid_save_redo = FALSE;\n\tsave_redo_T\tsave_redo;\n\n\t/*\n\t * Call the user function.\n\t * Save and restore search patterns, script variables and\n\t * redo buffer.\n\t */\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redo = TRUE;\n\t}\n\t++fp->uf_calls;\n\tcall_user_func(fp, argcount, argvars, rettv, funcexe,\n\t\t\t\t   (fp->uf_flags & FC_DICT) ? selfdict : NULL);\n\tif (--fp->uf_calls <= 0 && fp->uf_refcount <= 0)\n\t    // Function was unreferenced while being used, free it now.\n\t    func_clear_free(fp, FALSE);\n\tif (did_save_redo)\n\t    restoreRedobuff(&save_redo);\n\trestore_search_patterns();\n\terror = FCERR_NONE;\n    }\n    return error;\n}\n\nstatic funccal_entry_T *funccal_stack = NULL;\n\n/*\n * Save the current function call pointer, and set it to NULL.\n * Used when executing autocommands and for \":source\".\n */\n    void\nsave_funccal(funccal_entry_T *entry)\n{\n    entry->top_funccal = current_funccal;\n    entry->next = funccal_stack;\n    funccal_stack = entry;\n    current_funccal = NULL;\n}\n\n    void\nrestore_funccal(void)\n{\n    if (funccal_stack == NULL)\n\tiemsg(\"INTERNAL: restore_funccal()\");\n    else\n    {\n\tcurrent_funccal = funccal_stack->top_funccal;\n\tfunccal_stack = funccal_stack->next;\n    }\n}\n\n    funccall_T *\nget_current_funccal(void)\n{\n    return current_funccal;\n}\n\n/*\n * Return TRUE when currently at the script level:\n * - not in a function\n * - not executing an autocommand\n * Note that when an autocommand sources a script the result is FALSE;\n */\n    int\nat_script_level(void)\n{\n    return current_funccal == NULL && autocmd_match == NULL;\n}\n\n/*\n * Mark all functions of script \"sid\" as deleted.\n */\n    void\ndelete_script_functions(int sid)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\ttodo = 1;\n    char_u\tbuf[30];\n    size_t\tlen;\n\n    buf[0] = K_SPECIAL;\n    buf[1] = KS_EXTRA;\n    buf[2] = (int)KE_SNR;\n    sprintf((char *)buf + 3, \"%d_\", sid);\n    len = STRLEN(buf);\n\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tfp = HI2UF(hi);\n\t\tif (STRNCMP(fp->uf_name, buf, len) == 0)\n\t\t{\n\t\t    int changed = func_hashtab.ht_changed;\n\n\t\t    fp->uf_flags |= FC_DEAD;\n\n\t\t    if (fp->uf_calls > 0)\n\t\t    {\n\t\t\t// Function is executing, don't free it but do remove\n\t\t\t// it from the hashtable.\n\t\t\tif (func_remove(fp))\n\t\t\t    fp->uf_refcount--;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfunc_clear(fp, TRUE);\n\t\t\t// When clearing a function another function can be\n\t\t\t// cleared as a side effect.  When that happens start\n\t\t\t// over.\n\t\t\tif (changed != func_hashtab.ht_changed)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_functions(void)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\tskipped = 0;\n    long_u\ttodo = 1;\n    int\t\tchanged;\n\n    // Clean up the current_funccal chain and the funccal stack.\n    while (current_funccal != NULL)\n    {\n\tclear_tv(current_funccal->rettv);\n\tcleanup_function_call(current_funccal);\n\tif (current_funccal == NULL && funccal_stack != NULL)\n\t    restore_funccal();\n    }\n\n    // First clear what the functions contain.  Since this may lower the\n    // reference count of a function, it may also free a function and change\n    // the hash table. Restart if that happens.\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t// clear the def function index now\n\t\tfp = HI2UF(hi);\n\t\tfp->uf_flags &= ~FC_DEAD;\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    func_clear(fp, TRUE);\n\t\t    if (changed != func_hashtab.ht_changed)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n\n    // Now actually free the functions.  Need to start all over every time,\n    // because func_free() may change the hash table.\n    skipped = 0;\n    while (func_hashtab.ht_used > skipped)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tfp = HI2UF(hi);\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    if (func_free(fp, FALSE) == OK)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    // did not actually free it\n\t\t    ++skipped;\n\t\t}\n\t    }\n    }\n    if (skipped == 0)\n\thash_clear(&func_hashtab);\n\n    free_def_functions();\n}\n#endif\n\n/*\n * Return TRUE if \"name\" looks like a builtin function name: starts with a\n * lower case letter, doesn't contain AUTOLOAD_CHAR or ':', no \".\" after the\n * name.\n * \"len\" is the length of \"name\", or -1 for NUL terminated.\n */\n    int\nbuiltin_function(char_u *name, int len)\n{\n    int i;\n\n    if (!ASCII_ISLOWER(name[0]) || name[1] == ':')\n\treturn FALSE;\n    for (i = 0; name[i] != NUL && (len < 0 || i < len); ++i)\n    {\n\tif (name[i] == AUTOLOAD_CHAR)\n\t    return FALSE;\n\tif (!eval_isnamec(name[i]))\n\t{\n\t    // \"name.something\" is not a builtin function\n\t    if (name[i] == '.')\n\t\treturn FALSE;\n\t    break;\n\t}\n    }\n    return TRUE;\n}\n\n    int\nfunc_call(\n    char_u\t*name,\n    typval_T\t*args,\n    partial_T\t*partial,\n    dict_T\t*selfdict,\n    typval_T\t*rettv)\n{\n    list_T\t*l = args->vval.v_list;\n    listitem_T\t*item;\n    typval_T\targv[MAX_FUNC_ARGS + 1];\n    int\t\targc = 0;\n    int\t\tr = 0;\n\n    CHECK_LIST_MATERIALIZE(l);\n    FOR_ALL_LIST_ITEMS(l, item)\n    {\n\tif (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial->pt_argc))\n\t{\n\t    emsg(_(e_too_many_arguments));\n\t    break;\n\t}\n\t// Make a copy of each argument.  This is needed to be able to set\n\t// v_lock to VAR_FIXED in the copy without changing the original list.\n\tcopy_tv(&item->li_tv, &argv[argc++]);\n    }\n\n    if (item == NULL)\n    {\n\tfuncexe_T funcexe;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = TRUE;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = selfdict;\n\tr = call_func(name, -1, rettv, argc, argv, &funcexe);\n    }\n\n    // Free the arguments.\n    while (argc > 0)\n\tclear_tv(&argv[--argc]);\n\n    return r;\n}\n\nstatic int callback_depth = 0;\n\n    int\nget_callback_depth(void)\n{\n    return callback_depth;\n}\n\n/*\n * Invoke call_func() with a callback.\n * Returns FAIL if the callback could not be called.\n */\n    int\ncall_callback(\n    callback_T\t*callback,\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    funcexe_T\tfuncexe;\n    int\t\tret;\n\n    if (callback->cb_name == NULL || *callback->cb_name == NUL)\n\treturn FAIL;\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_evaluate = TRUE;\n    funcexe.fe_partial = callback->cb_partial;\n    ++callback_depth;\n    ret = call_func(callback->cb_name, len, rettv, argcount, argvars, &funcexe);\n    --callback_depth;\n\n    // When a :def function was called that uses :try an error would be turned\n    // into an exception.  Need to give the error here.\n    if (need_rethrow && current_exception != NULL && trylevel == 0)\n    {\n\tneed_rethrow = FALSE;\n\thandle_did_throw();\n    }\n\n    return ret;\n}\n\n/*\n * call the 'callback' function and return the result as a number.\n * Returns -2 when calling the function fails.  Uses argv[0] to argv[argc - 1]\n * for the function arguments. argv[argc] should have type VAR_UNKNOWN.\n */\n    varnumber_T\ncall_callback_retnr(\n    callback_T\t*callback,\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n\n    if (call_callback(callback, -1, &rettv, argcount, argvars) == FAIL)\n\treturn -2;\n\n    retval = tv_get_number_chk(&rettv, NULL);\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Give an error message for the result of a function.\n * Nothing if \"error\" is FCERR_NONE.\n */\n    void\nuser_func_error(int error, char_u *name, funcexe_T *funcexe)\n{\n    switch (error)\n    {\n\tcase FCERR_UNKNOWN:\n\t\tif (funcexe->fe_found_var)\n\t\t    emsg_funcname(e_not_callable_type_str, name);\n\t\telse\n\t\t    emsg_funcname(e_unknown_function_str, name);\n\t\tbreak;\n\tcase FCERR_NOTMETHOD:\n\t\temsg_funcname(e_cannot_use_function_as_method_str, name);\n\t\tbreak;\n\tcase FCERR_DELETED:\n\t\temsg_funcname(e_function_was_deleted_str, name);\n\t\tbreak;\n\tcase FCERR_TOOMANY:\n\t\temsg_funcname(e_too_many_arguments_for_function_str, name);\n\t\tbreak;\n\tcase FCERR_TOOFEW:\n\t\temsg_funcname(e_not_enough_arguments_for_function_str, name);\n\t\tbreak;\n\tcase FCERR_SCRIPT:\n\t\temsg_funcname(e_using_sid_not_in_script_context_str, name);\n\t\tbreak;\n\tcase FCERR_DICT:\n\t\temsg_funcname(e_calling_dict_function_without_dictionary_str,\n\t\t\t\t\t\t\t\t\t name);\n\t\tbreak;\n    }\n}\n\n/*\n * Call a function with its resolved parameters\n *\n * Return FAIL when the function can't be called,  OK otherwise.\n * Also returns OK when an error was encountered while executing the function.\n */\n    int\ncall_func(\n    char_u\t*funcname,\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount_in,\t// number of \"argvars\"\n    typval_T\t*argvars_in,\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n    funcexe_T\t*funcexe)\t// more arguments\n{\n    int\t\tret = FAIL;\n    int\t\terror = FCERR_NONE;\n    int\t\ti;\n    ufunc_T\t*fp = NULL;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname = NULL;\n    char_u\t*name = NULL;\n    int\t\targcount = argcount_in;\n    typval_T\t*argvars = argvars_in;\n    dict_T\t*selfdict = funcexe->fe_selfdict;\n    typval_T\targv[MAX_FUNC_ARGS + 1]; // used when \"partial\" or\n\t\t\t\t\t // \"funcexe->fe_basetv\" is not NULL\n    int\t\targv_clear = 0;\n    int\t\targv_base = 0;\n    partial_T\t*partial = funcexe->fe_partial;\n    type_T\tcheck_type;\n    type_T\t*check_type_args[MAX_FUNC_ARGS];\n\n    // Initialize rettv so that it is safe for caller to invoke clear_tv(rettv)\n    // even when call_func() returns FAIL.\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (partial != NULL)\n\tfp = partial->pt_func;\n    if (fp == NULL)\n    {\n\t// Make a copy of the name, if it comes from a funcref variable it\n\t// could be changed or deleted in the called function.\n\tname = len > 0 ? vim_strnsave(funcname, len) : vim_strsave(funcname);\n\tif (name == NULL)\n\t    return ret;\n\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n    }\n\n    if (funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = FALSE;\n\n    if (partial != NULL)\n    {\n\t// When the function has a partial with a dict and there is a dict\n\t// argument, use the dict argument.  That is backwards compatible.\n\t// When the dict was bound explicitly use the one from the partial.\n\tif (partial->pt_dict != NULL && (selfdict == NULL || !partial->pt_auto))\n\t    selfdict = partial->pt_dict;\n\tif (error == FCERR_NONE && partial->pt_argc > 0)\n\t{\n\t    for (argv_clear = 0; argv_clear < partial->pt_argc; ++argv_clear)\n\t    {\n\t\tif (argv_clear + argcount_in >= MAX_FUNC_ARGS)\n\t\t{\n\t\t    error = FCERR_TOOMANY;\n\t\t    goto theend;\n\t\t}\n\t\tcopy_tv(&partial->pt_argv[argv_clear], &argv[argv_clear]);\n\t    }\n\t    for (i = 0; i < argcount_in; ++i)\n\t\targv[i + argv_clear] = argvars_in[i];\n\t    argvars = argv;\n\t    argcount = partial->pt_argc + argcount_in;\n\n\t    if (funcexe->fe_check_type != NULL\n\t\t\t\t  && funcexe->fe_check_type->tt_argcount != -1)\n\t    {\n\t\t// Now funcexe->fe_check_type is missing the added arguments,\n\t\t// make a copy of the type with the correction.\n\t\tcheck_type = *funcexe->fe_check_type;\n\t\tfuncexe->fe_check_type = &check_type;\n\t\tcheck_type.tt_args = check_type_args;\n\t\tCLEAR_FIELD(check_type_args);\n\t\tfor (i = 0; i < check_type.tt_argcount; ++i)\n\t\t    check_type_args[i + partial->pt_argc] =\n\t\t\t\t\t\t\t check_type.tt_args[i];\n\t\tcheck_type.tt_argcount += partial->pt_argc;\n\t\tcheck_type.tt_min_argcount += partial->pt_argc;\n\t    }\n\t}\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_check_type != NULL\n\t\t\t\t\t\t       && funcexe->fe_evaluate)\n    {\n\t// Check that the argument types are OK for the types of the funcref.\n\tif (check_argument_types(funcexe->fe_check_type,\n\t\t\t\t\t argvars, argcount, funcexe->fe_basetv,\n\t\t\t\t     (name != NULL) ? name : funcname) == FAIL)\n\t    error = FCERR_OTHER;\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_evaluate)\n    {\n\tchar_u *rfname = fname;\n\tint\tis_global = FALSE;\n\n\t// Skip \"g:\" before a function name.\n\tif (fp == NULL && fname[0] == 'g' && fname[1] == ':')\n\t{\n\t    is_global = TRUE;\n\t    rfname = fname + 2;\n\t}\n\n\trettv->v_type = VAR_NUMBER;\t// default rettv is number zero\n\trettv->vval.v_number = 0;\n\terror = FCERR_UNKNOWN;\n\n\tif (fp != NULL || !builtin_function(rfname, -1))\n\t{\n\t    /*\n\t     * User defined function.\n\t     */\n\t    if (fp == NULL)\n\t    {\n\t\tfp = find_func(rfname, is_global);\n\t\tif (fp != NULL && !is_global && in_vim9script()\n\t\t\t\t\t\t && func_requires_g_prefix(fp))\n\t\t    // In Vim9 script g: is required to find a global\n\t\t    // non-autoload function.\n\t\t    fp = NULL;\n\t    }\n\n\t    // Trigger FuncUndefined event, may load the function.\n\t    if (fp == NULL\n\t\t    && apply_autocmds(EVENT_FUNCUNDEFINED,\n\t\t\t\t\t\t    rfname, rfname, TRUE, NULL)\n\t\t    && !aborting())\n\t    {\n\t\t// executed an autocommand, search for the function again\n\t\tfp = find_func(rfname, is_global);\n\t    }\n\t    // Try loading a package.\n\t    if (fp == NULL && script_autoload(rfname, TRUE) && !aborting())\n\t    {\n\t\t// loaded a package, search for the function again\n\t\tfp = find_func(rfname, is_global);\n\t    }\n\t    if (fp == NULL)\n\t    {\n\t\tchar_u *p = untrans_function_name(rfname);\n\n\t\t// If using Vim9 script try not local to the script.\n\t\t// Don't do this if the name starts with \"s:\".\n\t\tif (p != NULL && (funcname[0] != 's' || funcname[1] != ':'))\n\t\t    fp = find_func(p, is_global);\n\t    }\n\n\t    if (fp != NULL && (fp->uf_flags & FC_DELETED))\n\t\terror = FCERR_DELETED;\n\t    else if (fp != NULL)\n\t    {\n\t\tif (funcexe->fe_argv_func != NULL)\n\t\t    // postponed filling in the arguments, do it now\n\t\t    argcount = funcexe->fe_argv_func(argcount, argvars,\n\t\t\t\t\t       argv_clear, fp->uf_args.ga_len);\n\n\t\tif (funcexe->fe_basetv != NULL)\n\t\t{\n\t\t    // Method call: base->Method()\n\t\t    mch_memmove(&argv[1], argvars, sizeof(typval_T) * argcount);\n\t\t    argv[0] = *funcexe->fe_basetv;\n\t\t    argcount++;\n\t\t    argvars = argv;\n\t\t    argv_base = 1;\n\t\t}\n\n\t\terror = call_user_func_check(fp, argcount, argvars, rettv,\n\t\t\t\t\t\t\t    funcexe, selfdict);\n\t    }\n\t}\n\telse if (funcexe->fe_basetv != NULL)\n\t{\n\t    /*\n\t     * expr->method(): Find the method name in the table, call its\n\t     * implementation with the base as one of the arguments.\n\t     */\n\t    error = call_internal_method(fname, argcount, argvars, rettv,\n\t\t\t\t\t\t\t   funcexe->fe_basetv);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Find the function name in the table, call its implementation.\n\t     */\n\t    error = call_internal_func(fname, argcount, argvars, rettv);\n\t}\n\n\t/*\n\t * The function call (or \"FuncUndefined\" autocommand sequence) might\n\t * have been aborted by an error, an interrupt, or an explicitly thrown\n\t * exception that has not been caught so far.  This situation can be\n\t * tested for by calling aborting().  For an error in an internal\n\t * function or for the \"E132\" error in call_user_func(), however, the\n\t * throw point at which the \"force_abort\" flag (temporarily reset by\n\t * emsg()) is normally updated has not been reached yet. We need to\n\t * update that flag first to make aborting() reliable.\n\t */\n\tupdate_force_abort();\n    }\n    if (error == FCERR_NONE)\n\tret = OK;\n\ntheend:\n    /*\n     * Report an error unless the argument evaluation or function call has been\n     * cancelled due to an aborting error, an interrupt, or an exception.\n     */\n    if (!aborting())\n\tuser_func_error(error, (name != NULL) ? name : funcname, funcexe);\n\n    // clear the copies made from the partial\n    while (argv_clear > 0)\n\tclear_tv(&argv[--argv_clear + argv_base]);\n\n    vim_free(tofree);\n    vim_free(name);\n\n    return ret;\n}\n\n    char_u *\nprintable_func_name(ufunc_T *fp)\n{\n    return fp->uf_name_exp != NULL ? fp->uf_name_exp : fp->uf_name;\n}\n\n/*\n * List the head of the function: \"function name(arg1, arg2)\".\n */\n    static void\nlist_func_head(ufunc_T *fp, int indent)\n{\n    int\t\tj;\n\n    msg_start();\n    if (indent)\n\tmsg_puts(\"   \");\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n\tmsg_puts(\"def \");\n    else\n\tmsg_puts(\"function \");\n    msg_puts((char *)printable_func_name(fp));\n    msg_putchar('(');\n    for (j = 0; j < fp->uf_args.ga_len; ++j)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts((char *)FUNCARG(fp, j));\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_arg_types[j], &tofree));\n\t    vim_free(tofree);\n\t}\n\tif (j >= fp->uf_args.ga_len - fp->uf_def_args.ga_len)\n\t{\n\t    msg_puts(\" = \");\n\t    msg_puts(((char **)(fp->uf_def_args.ga_data))\n\t\t       [j - fp->uf_args.ga_len + fp->uf_def_args.ga_len]);\n\t}\n    }\n    if (fp->uf_varargs)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n    }\n    if (fp->uf_va_name != NULL)\n    {\n\tif (!fp->uf_varargs)\n\t{\n\t    if (j)\n\t\tmsg_puts(\", \");\n\t    msg_puts(\"...\");\n\t}\n\tmsg_puts((char *)fp->uf_va_name);\n\tif (fp->uf_va_type != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_va_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    msg_putchar(')');\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n\tif (fp->uf_ret_type != &t_void)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_ret_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    else if (fp->uf_flags & FC_ABORT)\n\tmsg_puts(\" abort\");\n    if (fp->uf_flags & FC_RANGE)\n\tmsg_puts(\" range\");\n    if (fp->uf_flags & FC_DICT)\n\tmsg_puts(\" dict\");\n    if (fp->uf_flags & FC_CLOSURE)\n\tmsg_puts(\" closure\");\n    msg_clr_eos();\n    if (p_verbose > 0)\n\tlast_set_msg(fp->uf_script_ctx);\n}\n\n/*\n * Get a function name, translating \"<SID>\" and \"<SNR>\".\n * Also handles a Funcref in a List or Dictionary.\n * Returns the function name in allocated memory, or NULL for failure.\n * Set \"*is_global\" to TRUE when the function must be global, unless\n * \"is_global\" is NULL.\n * flags:\n * TFN_INT:\t    internal function name OK\n * TFN_QUIET:\t    be quiet\n * TFN_NO_AUTOLOAD: do not use script autoloading\n * TFN_NO_DEREF:    do not dereference a Funcref\n * Advances \"pp\" to just after the function name (if no error).\n */\n    char_u *\ntrans_function_name(\n    char_u\t**pp,\n    int\t\t*is_global,\n    int\t\tskip,\t\t// only find the end, don't evaluate\n    int\t\tflags,\n    funcdict_T\t*fdp,\t\t// return: info about dictionary used\n    partial_T\t**partial,\t// return: partial of a FuncRef\n    type_T\t**type)\t\t// return: type of funcref if not NULL\n{\n    char_u\t*name = NULL;\n    char_u\t*start;\n    char_u\t*end;\n    int\t\tlead;\n    char_u\tsid_buf[20];\n    int\t\tlen;\n    int\t\textra = 0;\n    int\t\tprefix_g = FALSE;\n    lval_T\tlv;\n    int\t\tvim9script = in_vim9script();\n    int\t\tvim9_local;\n\n    if (fdp != NULL)\n\tCLEAR_POINTER(fdp);\n    start = *pp;\n\n    // Check for hard coded <SNR>: already translated function ID (from a user\n    // command).\n    if ((*pp)[0] == K_SPECIAL && (*pp)[1] == KS_EXTRA\n\t\t\t\t\t\t   && (*pp)[2] == (int)KE_SNR)\n    {\n\t*pp += 3;\n\tlen = get_id_len(pp) + 3;\n\treturn vim_strnsave(start, len);\n    }\n\n    // A name starting with \"<SID>\" or \"<SNR>\" is local to a script.  But\n    // don't skip over \"s:\", get_lval() needs it for \"s:dict.func\".\n    lead = eval_fname_script(start);\n    if (lead > 2)\n\tstart += lead;\n\n    // Note that TFN_ flags use the same values as GLV_ flags.\n    end = get_lval(start, NULL, &lv, FALSE, skip, flags | GLV_READ_ONLY,\n\t\t\t\t\t      lead > 2 ? 0 : FNE_CHECK_START);\n    if (end == start || (vim9script && end != NULL\n\t\t\t\t   && end[-1] == AUTOLOAD_CHAR && *end == '('))\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name_required));\n\tgoto theend;\n    }\n    if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range)))\n    {\n\t/*\n\t * Report an invalid expression in braces, unless the expression\n\t * evaluation has been cancelled due to an aborting error, an\n\t * interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t{\n\t    if (end != NULL)\n\t\tsemsg(_(e_invalid_argument_str), start);\n\t}\n\telse\n\t    *pp = find_name_end(start, NULL, NULL, FNE_INCL_BR);\n\tgoto theend;\n    }\n\n    if (lv.ll_tv != NULL)\n    {\n\tif (fdp != NULL)\n\t{\n\t    fdp->fd_dict = lv.ll_dict;\n\t    fdp->fd_newkey = lv.ll_newkey;\n\t    lv.ll_newkey = NULL;\n\t    fdp->fd_di = lv.ll_di;\n\t}\n\tif (lv.ll_tv->v_type == VAR_FUNC && lv.ll_tv->vval.v_string != NULL)\n\t{\n\t    name = vim_strsave(lv.ll_tv->vval.v_string);\n\t    *pp = end;\n\t}\n\telse if (lv.ll_tv->v_type == VAR_PARTIAL\n\t\t\t\t\t  && lv.ll_tv->vval.v_partial != NULL)\n\t{\n\t    name = vim_strsave(partial_name(lv.ll_tv->vval.v_partial));\n\t    *pp = end;\n\t    if (partial != NULL)\n\t\t*partial = lv.ll_tv->vval.v_partial;\n\t}\n\telse\n\t{\n\t    if (!skip && !(flags & TFN_QUIET) && (fdp == NULL\n\t\t\t     || lv.ll_dict == NULL || fdp->fd_newkey == NULL))\n\t\temsg(_(e_funcref_required));\n\t    else\n\t\t*pp = end;\n\t    name = NULL;\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_name == NULL)\n    {\n\t// Error found, but continue after the function name.\n\t*pp = end;\n\tgoto theend;\n    }\n\n    // Check if the name is a Funcref.  If so, use the value.\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tname = deref_func_name(lv.ll_exp_name, &len, partial, type,\n\t\t\t  flags & TFN_NO_AUTOLOAD, flags & TFN_NEW_FUNC, NULL);\n\tif (name == lv.ll_exp_name)\n\t    name = NULL;\n    }\n    else if (lv.ll_sid > 0)\n    {\n\tscriptitem_T\t*si = SCRIPT_ITEM(lv.ll_sid);\n\tint\t\tcc = *lv.ll_name_end;\n\n\t// function in another script.  Prefix <SNR>99_ or the autoload prefix.\n\t*lv.ll_name_end = NUL;\n\tif (si->sn_autoload_prefix != NULL)\n\t{\n\t    name = concat_str(si->sn_autoload_prefix, lv.ll_name);\n\t}\n\telse\n\t{\n\t    sid_buf[0] = K_SPECIAL;\n\t    sid_buf[1] = KS_EXTRA;\n\t    sid_buf[2] = (int)KE_SNR;\n\t    vim_snprintf((char *)sid_buf + 3, sizeof(sid_buf) - 3,\n\t\t\t\t\t\t      \"%ld_\", (long)lv.ll_sid);\n\t    name = concat_str(sid_buf, lv.ll_name);\n\t}\n\t*lv.ll_name_end = cc;\n\t*pp = end;\n\tgoto theend;\n    }\n    else if (!(flags & TFN_NO_DEREF))\n    {\n\tlen = (int)(end - *pp);\n\tname = deref_func_name(*pp, &len, partial, type,\n\t\t\t  flags & TFN_NO_AUTOLOAD, flags & TFN_NEW_FUNC, NULL);\n\tif (name == *pp)\n\t    name = NULL;\n    }\n    if (name != NULL)\n    {\n\tname = vim_strsave(name);\n\t*pp = end;\n\tif (STRNCMP(name, \"<SNR>\", 5) == 0)\n\t{\n\t    // Change \"<SNR>\" to the byte sequence.\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    mch_memmove(name + 3, name + 5, STRLEN(name + 5) + 1);\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tif (lead <= 2 && lv.ll_name == lv.ll_exp_name\n\t\t\t\t\t && STRNCMP(lv.ll_name, \"s:\", 2) == 0)\n\t{\n\t    // When there was \"s:\" already or the name expanded to get a\n\t    // leading \"s:\" then remove it.\n\t    lv.ll_name += 2;\n\t    len -= 2;\n\t    lead = 2;\n\t}\n    }\n    else\n    {\n\t// skip over \"s:\" and \"g:\"\n\tif (lead == 2 || (lv.ll_name[0] == 'g' && lv.ll_name[1] == ':'))\n\t{\n\t    if (lv.ll_name[0] == 'g')\n\t    {\n\t\tif (is_global != NULL)\n\t\t{\n\t\t    *is_global = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // dropping \"g:\" without setting \"is_global\" won't work in\n\t\t    // Vim9script, put it back later\n\t\t    prefix_g = TRUE;\n\t\t    extra = 2;\n\t\t}\n\t    }\n\t    lv.ll_name += 2;\n\t}\n\tlen = (int)(end - lv.ll_name);\n    }\n    if (len <= 0)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name_required));\n\tgoto theend;\n    }\n\n    // In Vim9 script a user function is script-local by default, unless it\n    // starts with a lower case character: dict.func().\n    vim9_local = ASCII_ISUPPER(*start) && vim9script;\n\n    /*\n     * Copy the function name to allocated memory.\n     * Accept <SID>name() inside a script, translate into <SNR>123_name().\n     * Accept <SNR>123_name() outside a script.\n     */\n    if (skip)\n\tlead = 0;\t// do nothing\n    else if (lead > 0 || vim9_local)\n    {\n\tif (!vim9_local)\n\t{\n\t    if (vim9script && lead == 2 && !ASCII_ISUPPER(*lv.ll_name)\n\t\t\t\t\t\t   && current_script_is_vim9())\n\t    {\n\t\tsemsg(_(e_function_name_must_start_with_capital_str), start);\n\t\tgoto theend;\n\t    }\n\t    lead = 3;\n\t}\n\tif (vim9_local || (lv.ll_exp_name != NULL\n\t\t\t\t\t     && eval_fname_sid(lv.ll_exp_name))\n\t\t\t\t\t\t       || eval_fname_sid(*pp))\n\t{\n\t    // It's script-local, \"s:\" or \"<SID>\"\n\t    if (current_sctx.sc_sid <= 0)\n\t    {\n\t\temsg(_(e_using_sid_not_in_script_context));\n\t\tgoto theend;\n\t    }\n\t    sprintf((char *)sid_buf, \"%ld_\", (long)current_sctx.sc_sid);\n\t    if (vim9_local)\n\t\textra = 3 + (int)STRLEN(sid_buf);\n\t    else\n\t\tlead += (int)STRLEN(sid_buf);\n\t}\n    }\n    else if (!(flags & TFN_INT) && (builtin_function(lv.ll_name, len)\n\t\t\t\t   || (vim9script && *lv.ll_name == '_')))\n    {\n\tsemsg(_(vim9script ? e_function_name_must_start_with_capital_str\n\t\t\t   : e_function_name_must_start_with_capital_or_s_str),\n\t\t\t\t\t\t\t\t\tstart);\n\tgoto theend;\n    }\n    if (!skip && !(flags & TFN_QUIET) && !(flags & TFN_NO_DEREF))\n    {\n\tchar_u *cp = vim_strchr(lv.ll_name, ':');\n\n\tif (cp != NULL && cp < end)\n\t{\n\t    semsg(_(e_function_name_cannot_contain_colon_str), start);\n\t    goto theend;\n\t}\n    }\n\n    name = alloc(len + lead + extra + 1);\n    if (name != NULL)\n    {\n\tif (!skip && (lead > 0 || vim9_local))\n\t{\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    if (vim9_local || lead > 3)\t// If it's \"<SID>\"\n\t\tSTRCPY(name + 3, sid_buf);\n\t}\n\telse if (prefix_g)\n\t{\n\t    name[0] = 'g';\n\t    name[1] = ':';\n\t}\n\tmch_memmove(name + lead + extra, lv.ll_name, (size_t)len);\n\tname[lead + extra + len] = NUL;\n    }\n    *pp = end;\n\ntheend:\n    clear_lval(&lv);\n    return name;\n}\n\n/*\n * Assuming \"name\" is the result of trans_function_name() and it was prefixed\n * to use the script-local name, return the unmodified name (points into\n * \"name\").  Otherwise return NULL.\n * This can be used to first search for a script-local function and fall back\n * to the global function if not found.\n */\n    static char_u *\nuntrans_function_name(char_u *name)\n{\n    char_u *p;\n\n    if (*name == K_SPECIAL && in_vim9script())\n    {\n\tp = vim_strchr(name, '_');\n\tif (p != NULL)\n\t    return p + 1;\n    }\n    return NULL;\n}\n\n/*\n * If the 'funcname' starts with \"s:\" or \"<SID>\", then expands it to the\n * current script ID and returns the expanded function name. The caller should\n * free the returned name. If not called from a script context or the function\n * name doesn't start with these prefixes, then returns NULL.\n * This doesn't check whether the script-local function exists or not.\n */\n    char_u *\nget_scriptlocal_funcname(char_u *funcname)\n{\n    char\tsid_buf[25];\n    int\t\toff;\n    char_u\t*newname;\n    char_u\t*p = funcname;\n\n    if (funcname == NULL)\n\treturn NULL;\n\n    if (STRNCMP(funcname, \"s:\", 2) != 0\n\t\t&& STRNCMP(funcname, \"<SID>\", 5) != 0)\n    {\n\tufunc_T\t    *ufunc;\n\n\t// The function name does not have a script-local prefix.  Try finding\n\t// it when in a Vim9 script and there is no \"g:\" prefix.\n\tif (!in_vim9script() || STRNCMP(funcname, \"g:\", 2) == 0)\n\t    return NULL;\n\tufunc = find_func(funcname, FALSE);\n\tif (ufunc == NULL || func_is_global(ufunc)\n\t\t\t      || (p = vim_strchr(ufunc->uf_name, '_')) == NULL)\n\t    return NULL;\n\t++p;\n\toff = 0;\n    }\n    else\n\toff = *funcname == 's' ? 2 : 5;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n    {\n\temsg(_(e_using_sid_not_in_script_context));\n\treturn NULL;\n    }\n    // Expand s: prefix into <SNR>nr_<name>\n    vim_snprintf(sid_buf, sizeof(sid_buf), \"<SNR>%ld_\",\n\t    (long)current_sctx.sc_sid);\n    newname = alloc(STRLEN(sid_buf) + STRLEN(p + off) + 1);\n    if (newname == NULL)\n\treturn NULL;\n    STRCPY(newname, sid_buf);\n    STRCAT(newname, p + off);\n\n    return newname;\n}\n\n/*\n * Return script-local \"fname\" with the 3-byte sequence replaced by\n * printable <SNR> in allocated memory.\n */\n    char_u *\nalloc_printable_func_name(char_u *fname)\n{\n    char_u *n = alloc(STRLEN(fname + 3) + 6);\n\n    if (n != NULL)\n    {\n\tSTRCPY(n, \"<SNR>\");\n\tSTRCPY(n + 5, fname + 3);\n    }\n    return n;\n}\n\n/*\n * Call trans_function_name(), except that a lambda is returned as-is.\n * Returns the name in allocated memory.\n */\n    char_u *\nsave_function_name(\n\tchar_u\t    **name,\n\tint\t    *is_global,\n\tint\t    skip,\n\tint\t    flags,\n\tfuncdict_T  *fudi)\n{\n    char_u *p = *name;\n    char_u *saved;\n\n    if (STRNCMP(p, \"<lambda>\", 8) == 0)\n    {\n\tp += 8;\n\t(void)getdigits(&p);\n\tsaved = vim_strnsave(*name, p - *name);\n\tif (fudi != NULL)\n\t    CLEAR_POINTER(fudi);\n    }\n    else\n\tsaved = trans_function_name(&p, is_global, skip,\n\t\t\t\t\t\t      flags, fudi, NULL, NULL);\n    *name = p;\n    return saved;\n}\n\n/*\n * List functions.  When \"regmatch\" is NULL all of then.\n * Otherwise functions matching \"regmatch\".\n */\n    void\nlist_functions(regmatch_T *regmatch)\n{\n    int\t\tchanged = func_hashtab.ht_changed;\n    long_u\ttodo = func_hashtab.ht_used;\n    hashitem_T\t*hi;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    ufunc_T\t*fp = HI2UF(hi);\n\n\t    --todo;\n\t    if ((fp->uf_flags & FC_DEAD) == 0\n\t\t    && (regmatch == NULL\n\t\t\t? !message_filtered(fp->uf_name)\n\t\t\t    && !func_name_refcount(fp->uf_name)\n\t\t\t: !isdigit(*fp->uf_name)\n\t\t\t    && vim_regexec(regmatch, fp->uf_name, 0)))\n\t    {\n\t\tlist_func_head(fp, FALSE);\n\t\tif (changed != func_hashtab.ht_changed)\n\t\t{\n\t\t    emsg(_(e_function_list_was_modified));\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * \":function\" also supporting nested \":def\".\n * When \"name_arg\" is not NULL this is a nested function, using \"name_arg\" for\n * the function name.\n * \"lines_to_free\" is a list of strings to be freed later.\n * Returns a pointer to the function or NULL if no function defined.\n */\n    ufunc_T *\ndefine_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg = FALSE;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n    garray_T\tnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    garray_T\tnewlines;\n    int\t\tvarargs = FALSE;\n    int\t\tflags = 0;\n    char_u\t*ret_type = NULL;\n    ufunc_T\t*fp = NULL;\n    int\t\tfp_allocated = FALSE;\n    int\t\tfree_fp = FALSE;\n    int\t\toverwrite = FALSE;\n    dictitem_T\t*v;\n    funcdict_T\tfudi;\n    static int\tfunc_nr = 0;\t    // number for nameless function\n    int\t\tparen;\n    hashitem_T\t*hi;\n    linenr_T\tsourcing_lnum_top;\n    int\t\tvim9script = in_vim9script();\n    imported_T\t*import = NULL;\n\n    /*\n     * \":function\" without argument: list functions.\n     */\n    if (ends_excmd2(eap->cmd, eap->arg))\n    {\n\tif (!eap->skip)\n\t    list_functions(NULL);\n\tset_nextcmd(eap, eap->arg);\n\treturn NULL;\n    }\n\n    /*\n     * \":function /pat\": list functions matching pattern.\n     */\n    if (*eap->arg == '/')\n    {\n\tp = skip_regexp(eap->arg + 1, '/', TRUE);\n\tif (!eap->skip)\n\t{\n\t    regmatch_T\tregmatch;\n\n\t    c = *p;\n\t    *p = NUL;\n\t    regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);\n\t    *p = c;\n\t    if (regmatch.regprog != NULL)\n\t    {\n\t\tregmatch.rm_ic = p_ic;\n\t\tlist_functions(&regmatch);\n\t\tvim_regfree(regmatch.regprog);\n\t    }\n\t}\n\tif (*p == '/')\n\t    ++p;\n\tset_nextcmd(eap, p);\n\treturn NULL;\n    }\n\n    ga_init(&newargs);\n    ga_init(&argtypes);\n    ga_init(&default_args);\n\n    /*\n     * Get the function name.  There are these situations:\n     * func\t    normal function name\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" == NULL\n     * dict.func    new dictionary entry\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" == NULL, \"fudi.fd_newkey\" == func\n     * dict.func    existing dict entry with a Funcref\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * dict.func    existing dict entry that's not a Funcref\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * s:func\t    script-local function name\n     * g:func\t    global function name, same as \"func\"\n     */\n    p = eap->arg;\n    if (name_arg != NULL)\n    {\n\t// nested function, argument is (args).\n\tparen = TRUE;\n\tCLEAR_FIELD(fudi);\n    }\n    else\n    {\n\tif (vim9script)\n\t{\n\t    if (p[0] == 's' && p[1] == ':')\n\t    {\n\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str), p);\n\t\treturn NULL;\n\t    }\n\t    p = to_name_end(p, TRUE);\n\t    if (*skipwhite(p) == '.' && vim_strchr(p, '(') != NULL)\n\t    {\n\t\tsemsg(_(e_cannot_define_dict_func_in_vim9_script_str),\n\t\t\t\t\t\t\t\t     eap->arg);\n\t\treturn NULL;\n\t    }\n\t    p = eap->arg;\n\t}\n\n\tname = save_function_name(&p, &is_global, eap->skip,\n\t\t\t\t\tTFN_NO_AUTOLOAD | TFN_NEW_FUNC, &fudi);\n\tparen = (vim_strchr(p, '(') != NULL);\n\tif (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)\n\t{\n\t    /*\n\t     * Return on an invalid expression in braces, unless the expression\n\t     * evaluation has been cancelled due to an aborting error, an\n\t     * interrupt, or an exception.\n\t     */\n\t    if (!aborting())\n\t    {\n\t\tif (!eap->skip && fudi.fd_newkey != NULL)\n\t\t    semsg(_(e_key_not_present_in_dictionary), fudi.fd_newkey);\n\t\tvim_free(fudi.fd_newkey);\n\t\treturn NULL;\n\t    }\n\t    else\n\t\teap->skip = TRUE;\n\t}\n\n\t// For \"export def FuncName()\" in an autoload script the function name\n\t// is stored with the legacy autoload name \"dir#script#FuncName\" so\n\t// that it can also be found in legacy script.\n\tif (is_export && name != NULL)\n\t{\n\t    char_u *prefixed = may_prefix_autoload(name);\n\n\t    if (prefixed != NULL && prefixed != name)\n\t    {\n\t\tvim_free(name);\n\t\tname = prefixed;\n\t    }\n\t}\n\telse if (paren && vim9script && name != NULL\n\t\t\t\t    && vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    emsg(_(e_cannot_use_name_with_hash_in_vim9_script_use_export_instead));\n\t    goto ret_free;\n\t}\n    }\n\n    // An error in a function call during evaluation of an expression in magic\n    // braces should not cause the function not to be defined.\n    saved_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    /*\n     * \":function func\" with only function name: list function.\n     */\n    if (!paren)\n    {\n\tif (!ends_excmd(*skipwhite(p)))\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    goto ret_free;\n\t}\n\tset_nextcmd(eap, p);\n\tif (eap->nextcmd != NULL)\n\t    *p = NUL;\n\tif (!eap->skip && !got_int)\n\t{\n\t    fp = find_func(name, is_global);\n\t    if (fp == NULL && ASCII_ISUPPER(*eap->arg))\n\t    {\n\t\tchar_u *up = untrans_function_name(name);\n\n\t\t// With Vim9 script the name was made script-local, if not\n\t\t// found try again with the original name.\n\t\tif (up != NULL)\n\t\t    fp = find_func(up, FALSE);\n\t    }\n\n\t    if (fp != NULL)\n\t    {\n\t\tlist_func_head(fp, TRUE);\n\t\tfor (j = 0; j < fp->uf_lines.ga_len && !got_int; ++j)\n\t\t{\n\t\t    if (FUNCLINE(fp, j) == NULL)\n\t\t\tcontinue;\n\t\t    msg_putchar('\\n');\n\t\t    msg_outnum((long)(j + 1));\n\t\t    if (j < 9)\n\t\t\tmsg_putchar(' ');\n\t\t    if (j < 99)\n\t\t\tmsg_putchar(' ');\n\t\t    msg_prt_line(FUNCLINE(fp, j), FALSE);\n\t\t    out_flush();\t// show a line at a time\n\t\t    ui_breakcheck();\n\t\t}\n\t\tif (!got_int)\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    if (fp->uf_def_status != UF_NOT_COMPILED)\n\t\t\tmsg_puts(\"   enddef\");\n\t\t    else\n\t\t\tmsg_puts(\"   endfunction\");\n\t\t}\n\t    }\n\t    else\n\t\temsg_funcname(e_undefined_function_str, eap->arg);\n\t}\n\tgoto ret_free;\n    }\n\n    /*\n     * \":function name(arg1, arg2)\" Define function.\n     */\n    p = skipwhite(p);\n    if (*p != '(')\n    {\n\tif (!eap->skip)\n\t{\n\t    semsg(_(e_missing_paren_str), eap->arg);\n\t    goto ret_free;\n\t}\n\t// attempt to continue by skipping some text\n\tif (vim_strchr(p, '(') != NULL)\n\t    p = vim_strchr(p, '(');\n    }\n\n    if ((vim9script || eap->cmdidx == CMD_def) && VIM_ISWHITE(p[-1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", p - 1);\n\tgoto ret_free;\n    }\n\n    // In Vim9 script only global functions can be redefined.\n    if (vim9script && eap->forceit && !is_global)\n    {\n\temsg(_(e_no_bang_allowed));\n\tgoto ret_free;\n    }\n\n    ga_init2(&newlines, sizeof(char_u *), 10);\n\n    if (!eap->skip && name_arg == NULL)\n    {\n\t// Check the name of the function.  Unless it's a dictionary function\n\t// (that we are overwriting).\n\tif (name != NULL)\n\t    arg = name;\n\telse\n\t    arg = fudi.fd_newkey;\n\tif (arg != NULL && (fudi.fd_di == NULL\n\t\t\t\t     || (fudi.fd_di->di_tv.v_type != VAR_FUNC\n\t\t\t\t && fudi.fd_di->di_tv.v_type != VAR_PARTIAL)))\n\t{\n\t    char_u  *name_base = arg;\n\t    int\t    i;\n\n\t    if (*arg == K_SPECIAL)\n\t    {\n\t\tname_base = vim_strchr(arg, '_');\n\t\tif (name_base == NULL)\n\t\t    name_base = arg + 3;\n\t\telse\n\t\t    ++name_base;\n\t    }\n\t    for (i = 0; name_base[i] != NUL && (i == 0\n\t\t\t\t\t? eval_isnamec1(name_base[i])\n\t\t\t\t\t: eval_isnamec(name_base[i])); ++i)\n\t\t;\n\t    if (name_base[i] != NUL)\n\t\temsg_funcname(e_invalid_argument_str, arg);\n\n\t    // In Vim9 script a function cannot have the same name as a\n\t    // variable.\n\t    if (vim9script && *arg == K_SPECIAL\n\t\t&& eval_variable(name_base, (int)STRLEN(name_base), 0, NULL,\n\t\t    NULL, EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT\n\t\t\t\t\t\t     + EVAL_VAR_NO_FUNC) == OK)\n\t    {\n\t\tsemsg(_(e_redefining_script_item_str), name_base);\n\t\tgoto ret_free;\n\t    }\n\t}\n\t// Disallow using the g: dict.\n\tif (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)\n\t{\n\t    emsg(_(e_cannot_use_g_here));\n\t    goto ret_free;\n\t}\n    }\n\n    // This may get more lines and make the pointers into the first line\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, lines_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t// find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_colon_str), p);\n\t\tp = skipwhite(p);\n\t    }\n\t    else if (!IS_WHITE_OR_NUL(p[1]))\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p);\n\t    ret_type = skipwhite(p + 1);\n\t    p = skip_type(ret_type, FALSE);\n\t    if (p > ret_type)\n\t    {\n\t\tret_type = vim_strnsave(ret_type, p - ret_type);\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_expected_type_str), ret_type);\n\t\tret_type = NULL;\n\t    }\n\t}\n\tp = skipwhite(p);\n    }\n    else\n\t// find extra arguments \"range\", \"dict\", \"abort\" and \"closure\"\n\tfor (;;)\n\t{\n\t    whitep = p;\n\t    p = skipwhite(p);\n\t    if (STRNCMP(p, \"range\", 5) == 0)\n\t    {\n\t\tflags |= FC_RANGE;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"dict\", 4) == 0)\n\t    {\n\t\tflags |= FC_DICT;\n\t\tp += 4;\n\t    }\n\t    else if (STRNCMP(p, \"abort\", 5) == 0)\n\t    {\n\t\tflags |= FC_ABORT;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"closure\", 7) == 0)\n\t    {\n\t\tflags |= FC_CLOSURE;\n\t\tp += 7;\n\t\tif (current_funccal == NULL)\n\t\t{\n\t\t    emsg_funcname(e_closure_function_should_not_be_at_top_level,\n\t\t\t    name == NULL ? (char_u *)\"\" : name);\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n\n    // When there is a line break use what follows for the function body.\n    // Makes 'exe \"func Test()\\n...\\nendfunc\"' work.\n    if (*p == '\\n')\n\tline_arg = p + 1;\n    else if (*p != NUL\n\t    && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)\n\t\t\t\t\t\t     && eap->cmdidx != CMD_def)\n\t    && !(VIM_ISWHITE(*whitep) && *p == '#'\n\t\t\t\t     && (vim9script || eap->cmdidx == CMD_def))\n\t    && !eap->skip\n\t    && !did_emsg)\n\tsemsg(_(e_trailing_characters_str), p);\n\n    /*\n     * Read the body of the function, until \"}\", \":endfunction\" or \":enddef\" is\n     * found.\n     */\n    if (KeyTyped)\n    {\n\t// Check if the function already exists, don't let the user type the\n\t// whole function before telling him it doesn't work!  For a script we\n\t// need to skip the body to be able to find what follows.\n\tif (!eap->skip && !eap->forceit)\n\t{\n\t    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)\n\t\temsg(_(e_dictionary_entry_already_exists));\n\t    else if (name != NULL && find_func(name, is_global) != NULL)\n\t\temsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);\n\t}\n\n\tif (!eap->skip && did_emsg)\n\t    goto erret;\n\n\tmsg_putchar('\\n');\t    // don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function\n     */\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n\tchar_u\t\t*find_name = name;\n\tint\t\tvar_conflict = FALSE;\n\tint\t\tffed_flags = is_global ? FFED_IS_GLOBAL : 0;\n\n\tv = find_var(name, &ht, TRUE);\n\tif (v != NULL && (vim9script || v->di_tv.v_type == VAR_FUNC))\n\t    var_conflict = TRUE;\n\n\tif (SCRIPT_ID_VALID(current_sctx.sc_sid))\n\t{\n\t    scriptitem_T *si = SCRIPT_ITEM(current_sctx.sc_sid);\n\n\t    if (si->sn_autoload_prefix != NULL)\n\t    {\n\t\tif (is_export)\n\t\t{\n\t\t    find_name = name + STRLEN(si->sn_autoload_prefix);\n\t\t    v = find_var(find_name, &ht, TRUE);\n\t\t    if (v != NULL)\n\t\t\tvar_conflict = TRUE;\n\t\t    // Only check if the function already exists in the script,\n\t\t    // global functions can be shadowed.\n\t\t    ffed_flags |= FFED_NO_GLOBAL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    char_u *prefixed = may_prefix_autoload(name);\n\n\t\t    if (prefixed != NULL && prefixed != name)\n\t\t    {\n\t\t\tv = find_var(prefixed, &ht, TRUE);\n\t\t\tif (v != NULL)\n\t\t\t    var_conflict = TRUE;\n\t\t\tvim_free(prefixed);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (var_conflict)\n\t{\n\t    emsg_funcname(e_function_name_conflicts_with_variable_str, name);\n\t    goto erret;\n\t}\n\n\tfp = find_func_even_dead(find_name, ffed_flags);\n\tif (vim9script)\n\t{\n\t    char_u *uname = untrans_function_name(name);\n\n\t    import = find_imported(uname == NULL ? name : uname, 0, FALSE);\n\t}\n\n\tif (fp != NULL || import != NULL)\n\t{\n\t    int dead = fp != NULL && (fp->uf_flags & FC_DEAD);\n\n\t    // Function can be replaced with \"function!\" and when sourcing the\n\t    // same script again, but only once.\n\t    // A name that is used by an import can not be overruled.\n\t    if (import != NULL\n\t\t    || (!dead && !eap->forceit\n\t\t\t&& (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)))\n\t    {\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tif (vim9script)\n\t\t    emsg_funcname(e_name_already_defined_str, name);\n\t\telse\n\t\t    emsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_calls > 0)\n\t    {\n\t\temsg_funcname(\n\t\t\t    e_cannot_redefine_function_str_it_is_in_use, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_refcount > 1)\n\t    {\n\t\t// This function is referenced somewhere, don't redefine it but\n\t\t// create a new one.\n\t\t--fp->uf_refcount;\n\t\tfp->uf_flags |= FC_REMOVED;\n\t\tfp = NULL;\n\t\toverwrite = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u *exp_name = fp->uf_name_exp;\n\n\t\t// redefine existing function, keep the expanded name\n\t\tVIM_CLEAR(name);\n\t\tfp->uf_name_exp = NULL;\n\t\tfunc_clear_items(fp);\n\t\tfp->uf_name_exp = exp_name;\n\t\tfp->uf_flags &= ~FC_DEAD;\n#ifdef FEAT_PROFILE\n\t\tfp->uf_profiling = FALSE;\n\t\tfp->uf_prof_initialized = FALSE;\n#endif\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\t    }\n\t}\n    }\n    else\n    {\n\tchar\tnumbuf[20];\n\n\tfp = NULL;\n\tif (fudi.fd_newkey == NULL && !eap->forceit)\n\t{\n\t    emsg(_(e_dictionary_entry_already_exists));\n\t    goto erret;\n\t}\n\tif (fudi.fd_di == NULL)\n\t{\n\t    // Can't add a function to a locked dictionary\n\t    if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))\n\t\tgoto erret;\n\t}\n\t    // Can't change an existing function if it is locked\n\telse if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))\n\t    goto erret;\n\n\t// Give the function a sequential number.  Can only be used with a\n\t// Funcref!\n\tvim_free(name);\n\tsprintf(numbuf, \"%d\", ++func_nr);\n\tname = vim_strsave((char_u *)numbuf);\n\tif (name == NULL)\n\t    goto erret;\n    }\n\n    if (fp == NULL)\n    {\n\tif (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    int\t    slen, plen;\n\t    char_u  *scriptname;\n\n\t    // Check that the autoload name matches the script name.\n\t    j = FAIL;\n\t    if (SOURCING_NAME != NULL)\n\t    {\n\t\tscriptname = autoload_name(name);\n\t\tif (scriptname != NULL)\n\t\t{\n\t\t    p = vim_strchr(scriptname, '/');\n\t\t    plen = (int)STRLEN(p);\n\t\t    slen = (int)STRLEN(SOURCING_NAME);\n\t\t    if (slen > plen && fnamecmp(p,\n\t\t\t\t\t    SOURCING_NAME + slen - plen) == 0)\n\t\t\tj = OK;\n\t\t    vim_free(scriptname);\n\t\t}\n\t    }\n\t    if (j == FAIL)\n\t    {\n\t\tlinenr_T save_lnum = SOURCING_LNUM;\n\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tsemsg(_(e_function_name_does_not_match_script_file_name_str),\n\t\t\t\t\t\t\t\t\t name);\n\t\tSOURCING_LNUM = save_lnum;\n\t\tgoto erret;\n\t    }\n\t}\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto erret;\n\tfp_allocated = TRUE;\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    if (fudi.fd_di == NULL)\n\t    {\n\t\t// add new dict entry\n\t\tfudi.fd_di = dictitem_alloc(fudi.fd_newkey);\n\t\tif (fudi.fd_di == NULL)\n\t\t{\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t\tif (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)\n\t\t{\n\t\t    vim_free(fudi.fd_di);\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\t// overwrite existing dict entry\n\t\tclear_tv(&fudi.fd_di->di_tv);\n\t    fudi.fd_di->di_tv.v_type = VAR_FUNC;\n\t    fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);\n\n\t    // behave like \"dict\" was used\n\t    flags |= FC_DICT;\n\t}\n    }\n    fp->uf_args = newargs;\n    fp->uf_def_args = default_args;\n    fp->uf_ret_type = &t_any;\n    fp->uf_func_type = &t_func_any;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\tint\t    lnum_save = SOURCING_LNUM;\n\tcstack_T    *cstack = eap->cstack;\n\n\tfp->uf_def_status = UF_TO_BE_COMPILED;\n\n\t// error messages are for the first function line\n\tSOURCING_LNUM = sourcing_lnum_top;\n\n\t// The function may use script variables from the context.\n\tfunction_using_block_scopes(fp, cstack);\n\n\tif (parse_argument_types(fp, &argtypes, varargs) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tvarargs = FALSE;\n\n\t// parse the return type, if any\n\tif (parse_return_type(fp, ret_type) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tSOURCING_LNUM = lnum_save;\n    }\n    else\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\n    if (fp_allocated)\n    {\n\t// insert the new function in the function list\n\tset_ufunc_name(fp, name);\n\tif (overwrite)\n\t{\n\t    hi = hash_find(&func_hashtab, name);\n\t    hi->hi_key = UF2HIKEY(fp);\n\t}\n\telse if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)\n\t{\n\t    free_fp = TRUE;\n\t    goto erret;\n\t}\n\tfp->uf_refcount = 1;\n    }\n\n    fp->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if ((flags & FC_CLOSURE) != 0)\n    {\n\tif (register_closure(fp) == FAIL)\n\t    goto erret;\n    }\n    else\n\tfp->uf_scoped = NULL;\n\n#ifdef FEAT_PROFILE\n    if (prof_def_func())\n\tfunc_do_profile(fp);\n#endif\n    fp->uf_varargs = varargs;\n    if (sandbox)\n\tflags |= FC_SANDBOX;\n    if (vim9script && !ASCII_ISUPPER(*fp->uf_name))\n\tflags |= FC_VIM9;\n    fp->uf_flags = flags;\n    fp->uf_calls = 0;\n    fp->uf_cleared = FALSE;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_script_ctx_version = current_sctx.sc_version;\n    fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    if (is_export)\n    {\n\tfp->uf_flags |= FC_EXPORT;\n\t// let ex_export() know the export worked.\n\tis_export = FALSE;\n    }\n\n    if (eap->cmdidx == CMD_def)\n\tset_function_type(fp);\n    else if (fp->uf_script_ctx.sc_version == SCRIPT_VERSION_VIM9)\n\t// :func does not use Vim9 script syntax, even in a Vim9 script file\n\tfp->uf_script_ctx.sc_version = SCRIPT_VERSION_MAX;\n\n    goto ret_free;\n\nerret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&default_args);\n    if (fp != NULL)\n    {\n\tga_init(&fp->uf_args);\n\tga_init(&fp->uf_def_args);\n    }\nerrret_2:\n    ga_clear_strings(&newlines);\n    if (fp != NULL)\n\tVIM_CLEAR(fp->uf_arg_types);\n    if (free_fp)\n    {\n\tvim_free(fp);\n\tfp = NULL;\n    }\nret_free:\n    ga_clear_strings(&argtypes);\n    vim_free(fudi.fd_newkey);\n    if (name != name_arg)\n\tvim_free(name);\n    vim_free(ret_type);\n    did_emsg |= saved_did_emsg;\n\n    return fp;\n}\n\n/*\n * \":function\"\n */\n    void\nex_function(exarg_T *eap)\n{\n    garray_T lines_to_free;\n\n    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n    (void)define_function(eap, NULL, &lines_to_free);\n    ga_clear_strings(&lines_to_free);\n}\n\n/*\n * Find a function by name, including \"<lambda>123\".\n * Check for \"profile\" and \"debug\" arguments and set\"compile_type\".\n * Caller should initialize \"compile_type\" to CT_NONE.\n * Return NULL if not found.\n */\n    ufunc_T *\nfind_func_by_name(char_u *name, compiletype_T *compile_type)\n{\n    char_u\t*arg = name;\n    char_u\t*fname;\n    ufunc_T\t*ufunc;\n    int\t\tis_global = FALSE;\n\n    if (STRNCMP(arg, \"profile\", 7) == 0 && VIM_ISWHITE(arg[7]))\n    {\n\t*compile_type = CT_PROFILE;\n\targ = skipwhite(arg + 7);\n    }\n    else if (STRNCMP(arg, \"debug\", 5) == 0 && VIM_ISWHITE(arg[5]))\n    {\n\t*compile_type = CT_DEBUG;\n\targ = skipwhite(arg + 5);\n    }\n\n    if (STRNCMP(arg, \"<lambda>\", 8) == 0)\n    {\n\targ += 8;\n\t(void)getdigits(&arg);\n\tfname = vim_strnsave(name, arg - name);\n    }\n    else\n\tfname = trans_function_name(&arg, &is_global, FALSE,\n\t\t      TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD, NULL, NULL, NULL);\n    if (fname == NULL)\n    {\n\tsemsg(_(e_invalid_argument_str), name);\n\treturn NULL;\n    }\n    if (!ends_excmd2(name, arg))\n    {\n\tvim_free(fname);\n\temsg(ex_errmsg(e_trailing_characters_str, arg));\n\treturn NULL;\n    }\n\n    ufunc = find_func(fname, is_global);\n    if (ufunc == NULL)\n    {\n\tchar_u *p = untrans_function_name(fname);\n\n\tif (p != NULL)\n\t    // Try again without making it script-local.\n\t    ufunc = find_func(p, FALSE);\n    }\n    vim_free(fname);\n    if (ufunc == NULL)\n\tsemsg(_(e_cannot_find_function_str), name);\n    return ufunc;\n}\n\n/*\n * :defcompile - compile all :def functions in the current script that need to\n * be compiled or the one specified by the argument.\n * Skips dead functions.  Doesn't do profiling.\n */\n    void\nex_defcompile(exarg_T *eap)\n{\n    ufunc_T\t*ufunc;\n\n    if (*eap->arg != NUL)\n    {\n\tcompiletype_T compile_type = CT_NONE;\n\n\tufunc = find_func_by_name(eap->arg, &compile_type);\n\tif (ufunc != NULL)\n\t{\n\t    if (func_needs_compiling(ufunc, compile_type))\n\t\t(void)compile_def_function(ufunc, FALSE, compile_type, NULL);\n\t    else\n\t\tsmsg(_(\"Function %s does not need compiling\"), eap->arg);\n\t}\n    }\n    else\n    {\n\tlong\ttodo = (long)func_hashtab.ht_used;\n\tint\t\tchanged = func_hashtab.ht_changed;\n\thashitem_T\t*hi;\n\n\tfor (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tufunc = HI2UF(hi);\n\t\tif (ufunc->uf_script_ctx.sc_sid == current_sctx.sc_sid\n\t\t\t&& ufunc->uf_def_status == UF_TO_BE_COMPILED\n\t\t\t&& (ufunc->uf_flags & FC_DEAD) == 0)\n\t\t{\n\t\t    (void)compile_def_function(ufunc, FALSE, CT_NONE, NULL);\n\n\t\t    if (func_hashtab.ht_changed != changed)\n\t\t    {\n\t\t\t// a function has been added or removed, need to start\n\t\t\t// over\n\t\t\ttodo = (long)func_hashtab.ht_used;\n\t\t\tchanged = func_hashtab.ht_changed;\n\t\t\thi = func_hashtab.ht_array;\n\t\t\t--hi;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Return 5 if \"p\" starts with \"<SID>\" or \"<SNR>\" (ignoring case).\n * Return 2 if \"p\" starts with \"s:\".\n * Return 0 otherwise.\n */\n    int\neval_fname_script(char_u *p)\n{\n    // Use MB_STRICMP() because in Turkish comparing the \"I\" may not work with\n    // the standard library function.\n    if (p[0] == '<' && (MB_STRNICMP(p + 1, \"SID>\", 4) == 0\n\t\t\t\t       || MB_STRNICMP(p + 1, \"SNR>\", 4) == 0))\n\treturn 5;\n    if (p[0] == 's' && p[1] == ':')\n\treturn 2;\n    return 0;\n}\n\n    int\ntranslated_function_exists(char_u *name, int is_global)\n{\n    if (builtin_function(name, -1))\n\treturn has_internal_func(name);\n    return find_func(name, is_global) != NULL;\n}\n\n/*\n * Return TRUE when \"ufunc\" has old-style \"...\" varargs\n * or named varargs \"...name: type\".\n */\n    int\nhas_varargs(ufunc_T *ufunc)\n{\n    return ufunc->uf_varargs || ufunc->uf_va_name != NULL;\n}\n\n/*\n * Return TRUE if a function \"name\" exists.\n * If \"no_defef\" is TRUE, do not dereference a Funcref.\n */\n    int\nfunction_exists(char_u *name, int no_deref)\n{\n    char_u  *nm = name;\n    char_u  *p;\n    int\t    n = FALSE;\n    int\t    flag;\n    int\t    is_global = FALSE;\n\n    flag = TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD;\n    if (no_deref)\n\tflag |= TFN_NO_DEREF;\n    p = trans_function_name(&nm, &is_global, FALSE, flag, NULL, NULL, NULL);\n    nm = skipwhite(nm);\n\n    // Only accept \"funcname\", \"funcname \", \"funcname (...\" and\n    // \"funcname(...\", not \"funcname!...\".\n    if (p != NULL && (*nm == NUL || *nm == '('))\n\tn = translated_function_exists(p, is_global);\n    vim_free(p);\n    return n;\n}\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    char_u *\nget_expanded_name(char_u *name, int check)\n{\n    char_u\t*nm = name;\n    char_u\t*p;\n    int\t\tis_global = FALSE;\n\n    p = trans_function_name(&nm, &is_global, FALSE,\n\t\t\t\t\t  TFN_INT|TFN_QUIET, NULL, NULL, NULL);\n\n    if (p != NULL && *nm == NUL\n\t\t       && (!check || translated_function_exists(p, is_global)))\n\treturn p;\n\n    vim_free(p);\n    return NULL;\n}\n#endif\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user defined\n * function names.\n */\n    char_u *\nget_user_func_name(expand_T *xp, int idx)\n{\n    static long_u\tdone;\n    static int\t\tchanged;\n    static hashitem_T\t*hi;\n    ufunc_T\t\t*fp;\n\n    if (idx == 0)\n    {\n\tdone = 0;\n\thi = func_hashtab.ht_array;\n\tchanged = func_hashtab.ht_changed;\n    }\n    if (changed == func_hashtab.ht_changed && done < func_hashtab.ht_used)\n    {\n\tif (done++ > 0)\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\tfp = HI2UF(hi);\n\n\t// don't show dead, dict and lambda functions\n\tif ((fp->uf_flags & FC_DEAD) || (fp->uf_flags & FC_DICT)\n\t\t\t\t|| STRNCMP(fp->uf_name, \"<lambda>\", 8) == 0)\n\t    return (char_u *)\"\";\n\n\tif (STRLEN(fp->uf_name) + 4 >= IOSIZE)\n\t    return fp->uf_name;\t// prevents overflow\n\n\tcat_func_name(IObuff, fp);\n\tif (xp->xp_context != EXPAND_USER_FUNC\n\t\t\t\t       && xp->xp_context != EXPAND_DISASSEMBLE)\n\t{\n\t    STRCAT(IObuff, \"(\");\n\t    if (!has_varargs(fp) && fp->uf_args.ga_len == 0)\n\t\tSTRCAT(IObuff, \")\");\n\t}\n\treturn IObuff;\n    }\n    return NULL;\n}\n\n/*\n * \":delfunction {name}\"\n */\n    void\nex_delfunction(exarg_T *eap)\n{\n    ufunc_T\t*fp = NULL;\n    char_u\t*p;\n    char_u\t*name;\n    funcdict_T\tfudi;\n    int\t\tis_global = FALSE;\n\n    p = eap->arg;\n    name = trans_function_name(&p, &is_global, eap->skip, 0, &fudi,\n\t\t\t\t\t\t\t\t   NULL, NULL);\n    vim_free(fudi.fd_newkey);\n    if (name == NULL)\n    {\n\tif (fudi.fd_dict != NULL && !eap->skip)\n\t    emsg(_(e_funcref_required));\n\treturn;\n    }\n    if (!ends_excmd(*skipwhite(p)))\n    {\n\tvim_free(name);\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn;\n    }\n    set_nextcmd(eap, p);\n    if (eap->nextcmd != NULL)\n\t*p = NUL;\n\n    if (numbered_function(name) && fudi.fd_dict == NULL)\n    {\n\tif (!eap->skip)\n\t    semsg(_(e_invalid_argument_str), eap->arg);\n\tvim_free(name);\n\treturn;\n    }\n    if (!eap->skip)\n\tfp = find_func(name, is_global);\n    vim_free(name);\n\n    if (!eap->skip)\n    {\n\tif (fp == NULL)\n\t{\n\t    if (!eap->forceit)\n\t\tsemsg(_(e_unknown_function_str), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_calls > 0)\n\t{\n\t    semsg(_(e_cannot_delete_function_str_it_is_in_use), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_flags & FC_VIM9)\n\t{\n\t    semsg(_(e_cannot_delete_vim9_script_function_str), eap->arg);\n\t    return;\n\t}\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    // Delete the dict item that refers to the function, it will\n\t    // invoke func_unref() and possibly delete the function.\n\t    dictitem_remove(fudi.fd_dict, fudi.fd_di);\n\t}\n\telse\n\t{\n\t    // A normal function (not a numbered function or lambda) has a\n\t    // refcount of 1 for the entry in the hashtable.  When deleting\n\t    // it and the refcount is more than one, it should be kept.\n\t    // A numbered function and lambda should be kept if the refcount is\n\t    // one or more.\n\t    if (fp->uf_refcount > (func_name_refcount(fp->uf_name) ? 0 : 1))\n\t    {\n\t\t// Function is still referenced somewhere.  Don't free it but\n\t\t// do remove it from the hashtable.\n\t\tif (func_remove(fp))\n\t\t    fp->uf_refcount--;\n\t    }\n\t    else\n\t\tfunc_clear_free(fp, FALSE);\n\t}\n    }\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\nfunc_unref(char_u *name)\n{\n    ufunc_T *fp = NULL;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE);\n    if (fp == NULL && numbered_function(name))\n    {\n#ifdef EXITFREE\n\tif (!entered_free_all_mem)\n#endif\n\t    internal_error(\"func_unref()\");\n    }\n    func_ptr_unref(fp);\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n * Also when it becomes one and uf_partial points to the function.\n */\n    void\nfunc_ptr_unref(ufunc_T *fp)\n{\n    if (fp != NULL && (--fp->uf_refcount <= 0\n\t\t|| (fp->uf_refcount == 1 && fp->uf_partial != NULL\n\t\t\t\t\t && fp->uf_partial->pt_refcount <= 1\n\t\t\t\t\t && fp->uf_partial->pt_func == fp)))\n    {\n\t// Only delete it when it's not being used.  Otherwise it's done\n\t// when \"uf_calls\" becomes zero.\n\tif (fp->uf_calls == 0)\n\t    func_clear_free(fp, FALSE);\n    }\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ref(char_u *name)\n{\n    ufunc_T *fp;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE);\n    if (fp != NULL)\n\t++fp->uf_refcount;\n    else if (numbered_function(name))\n\t// Only give an error for a numbered function.\n\t// Fail silently, when named or lambda function isn't found.\n\tinternal_error(\"func_ref()\");\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ptr_ref(ufunc_T *fp)\n{\n    if (fp != NULL)\n\t++fp->uf_refcount;\n}\n\n/*\n * Return TRUE if items in \"fc\" do not have \"copyID\".  That means they are not\n * referenced from anywhere that is in use.\n */\n    static int\ncan_free_funccal(funccall_T *fc, int copyID)\n{\n    return (fc->l_varlist.lv_copyID != copyID\n\t    && fc->l_vars.dv_copyID != copyID\n\t    && fc->l_avars.dv_copyID != copyID\n\t    && fc->fc_copyID != copyID);\n}\n\n/*\n * \":return [expr]\"\n */\n    void\nex_return(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\treturning = FALSE;\n    evalarg_T\tevalarg;\n\n    if (current_funccal == NULL)\n    {\n\temsg(_(e_return_not_inside_function));\n\treturn;\n    }\n\n    init_evalarg(&evalarg);\n    evalarg.eval_flags = eap->skip ? 0 : EVAL_EVALUATE;\n\n    if (eap->skip)\n\t++emsg_skip;\n\n    eap->nextcmd = NULL;\n    if ((*arg != NUL && *arg != '|' && *arg != '\\n')\n\t\t\t\t  && eval0(arg, &rettv, eap, &evalarg) != FAIL)\n    {\n\tif (!eap->skip)\n\t    returning = do_return(eap, FALSE, TRUE, &rettv);\n\telse\n\t    clear_tv(&rettv);\n    }\n    // It's safer to return also on error.\n    else if (!eap->skip)\n    {\n\t// In return statement, cause_abort should be force_abort.\n\tupdate_force_abort();\n\n\t/*\n\t * Return unless the expression evaluation has been cancelled due to an\n\t * aborting error, an interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t    returning = do_return(eap, FALSE, TRUE, NULL);\n    }\n\n    // When skipping or the return gets pending, advance to the next command\n    // in this line (!returning).  Otherwise, ignore the rest of the line.\n    // Following lines will be ignored by get_func_line().\n    if (returning)\n\teap->nextcmd = NULL;\n    else if (eap->nextcmd == NULL)\t    // no argument\n\tset_nextcmd(eap, arg);\n\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n}\n\n/*\n * \":1,25call func(arg1, arg2)\"\tfunction call.\n */\n    void\nex_call(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*startarg;\n    char_u\t*name;\n    char_u\t*tofree;\n    int\t\tlen;\n    typval_T\trettv;\n    linenr_T\tlnum;\n    int\t\tdoesrange;\n    int\t\tfailed = FALSE;\n    funcdict_T\tfudi;\n    partial_T\t*partial = NULL;\n    evalarg_T\tevalarg;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n    int\t\tvim9script = in_vim9script();\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n    if (eap->skip)\n    {\n\t// trans_function_name() doesn't work well when skipping, use eval0()\n\t// instead to skip to any following command, e.g. for:\n\t//   :if 0 | call dict.foo().bar() | endif\n\t++emsg_skip;\n\tif (eval0(eap->arg, &rettv, eap, &evalarg) != FAIL)\n\t    clear_tv(&rettv);\n\t--emsg_skip;\n\tclear_evalarg(&evalarg, eap);\n\treturn;\n    }\n\n    tofree = trans_function_name(&arg, NULL, eap->skip, TFN_INT,\n\t\t\t      &fudi, &partial, vim9script ? &type : NULL);\n    if (fudi.fd_newkey != NULL)\n    {\n\t// Still need to give an error message for missing key.\n\tsemsg(_(e_key_not_present_in_dictionary), fudi.fd_newkey);\n\tvim_free(fudi.fd_newkey);\n    }\n    if (tofree == NULL)\n\treturn;\n\n    // Increase refcount on dictionary, it could get deleted when evaluating\n    // the arguments.\n    if (fudi.fd_dict != NULL)\n\t++fudi.fd_dict->dv_refcount;\n\n    // If it is the name of a variable of type VAR_FUNC or VAR_PARTIAL use its\n    // contents.  For VAR_PARTIAL get its partial, unless we already have one\n    // from trans_function_name().\n    len = (int)STRLEN(tofree);\n    name = deref_func_name(tofree, &len, partial != NULL ? NULL : &partial,\n\t\t\t\tvim9script && type == NULL ? &type : NULL,\n\t\t\t\t\t\t     FALSE, FALSE, &found_var);\n\n    // Skip white space to allow \":call func ()\".  Not good, but required for\n    // backward compatibility.\n    startarg = skipwhite(arg);\n    if (*startarg != '(')\n    {\n\tsemsg(_(e_missing_parenthesis_str), eap->arg);\n\tgoto end;\n    }\n    if (vim9script && startarg > arg)\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", eap->arg);\n\tgoto end;\n    }\n\n    /*\n     * When skipping, evaluate the function once, to find the end of the\n     * arguments.\n     * When the function takes a range, this is discovered after the first\n     * call, and the loop is broken.\n     */\n    if (eap->skip)\n    {\n\t++emsg_skip;\n\tlnum = eap->line2;\t// do it once, also with an invalid range\n    }\n    else\n\tlnum = eap->line1;\n    for ( ; lnum <= eap->line2; ++lnum)\n    {\n\tfuncexe_T funcexe;\n\n\tif (!eap->skip && eap->addr_count > 0)\n\t{\n\t    if (lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// If the function deleted lines or switched to another buffer\n\t\t// the line number may become invalid.\n\t\temsg(_(e_invalid_range));\n\t\tbreak;\n\t    }\n\t    curwin->w_cursor.lnum = lnum;\n\t    curwin->w_cursor.col = 0;\n\t    curwin->w_cursor.coladd = 0;\n\t}\n\targ = startarg;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = eap->line1;\n\tfuncexe.fe_lastline = eap->line2;\n\tfuncexe.fe_doesrange = &doesrange;\n\tfuncexe.fe_evaluate = !eap->skip;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = fudi.fd_dict;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\trettv.v_type = VAR_UNKNOWN;\t// clear_tv() uses this\n\tif (get_func_tv(name, -1, &rettv, &arg, &evalarg, &funcexe) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\tif (has_watchexpr())\n\t    dbg_check_breakpoint(eap);\n\n\t// Handle a function returning a Funcref, Dictionary or List.\n\tif (handle_subscript(&arg, NULL, &rettv,\n\t\t\t   eap->skip ? NULL : &EVALARG_EVALUATE, TRUE) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\n\tclear_tv(&rettv);\n\tif (doesrange || eap->skip)\n\t    break;\n\n\t// Stop when immediately aborting on error, or when an interrupt\n\t// occurred or an exception was thrown but not caught.\n\t// get_func_tv() returned OK, so that the check for trailing\n\t// characters below is executed.\n\tif (aborting())\n\t    break;\n    }\n    if (eap->skip)\n\t--emsg_skip;\n\n    // When inside :try we need to check for following \"| catch\" or \"| endtry\".\n    // Not when there was an error, but do check if an exception was thrown.\n    if ((!aborting() || did_throw)\n\t\t\t\t  && (!failed || eap->cstack->cs_trylevel > 0))\n    {\n\t// Check for trailing illegal characters and a following command.\n\targ = skipwhite(arg);\n\tif (!ends_excmd2(eap->arg, arg))\n\t{\n\t    if (!failed && !aborting())\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_trailing_characters_str), arg);\n\t    }\n\t}\n\telse\n\t    set_nextcmd(eap, arg);\n    }\n    // Must be after using \"arg\", it may point into memory cleared here.\n    clear_evalarg(&evalarg, eap);\n\nend:\n    dict_unref(fudi.fd_dict);\n    vim_free(tofree);\n}\n\n/*\n * Return from a function.  Possibly makes the return pending.  Also called\n * for a pending return at the \":endtry\" or after returning from an extra\n * do_cmdline().  \"reanimate\" is used in the latter case.  \"is_cmd\" is set\n * when called due to a \":return\" command.  \"rettv\" may point to a typval_T\n * with the return rettv.  Returns TRUE when the return can be carried out,\n * FALSE when the return gets pending.\n */\n    int\ndo_return(\n    exarg_T\t*eap,\n    int\t\treanimate,\n    int\t\tis_cmd,\n    void\t*rettv)\n{\n    int\t\tidx;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (reanimate)\n\t// Undo the return.\n\tcurrent_funccal->returned = FALSE;\n\n    /*\n     * Cleanup (and inactivate) conditionals, but stop when a try conditional\n     * not in its finally clause (which then is to be executed next) is found.\n     * In this case, make the \":return\" pending for execution at the \":endtry\".\n     * Otherwise, return normally.\n     */\n    idx = cleanup_conditionals(eap->cstack, 0, TRUE);\n    if (idx >= 0)\n    {\n\tcstack->cs_pending[idx] = CSTP_RETURN;\n\n\tif (!is_cmd && !reanimate)\n\t    // A pending return again gets pending.  \"rettv\" points to an\n\t    // allocated variable with the rettv of the original \":return\"'s\n\t    // argument if present or is NULL else.\n\t    cstack->cs_rettv[idx] = rettv;\n\telse\n\t{\n\t    // When undoing a return in order to make it pending, get the stored\n\t    // return rettv.\n\t    if (reanimate)\n\t\trettv = current_funccal->rettv;\n\n\t    if (rettv != NULL)\n\t    {\n\t\t// Store the value of the pending return.\n\t\tif ((cstack->cs_rettv[idx] = alloc_tv()) != NULL)\n\t\t    *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;\n\t\telse\n\t\t    emsg(_(e_out_of_memory));\n\t    }\n\t    else\n\t\tcstack->cs_rettv[idx] = NULL;\n\n\t    if (reanimate)\n\t    {\n\t\t// The pending return value could be overwritten by a \":return\"\n\t\t// without argument in a finally clause; reset the default\n\t\t// return value.\n\t\tcurrent_funccal->rettv->v_type = VAR_NUMBER;\n\t\tcurrent_funccal->rettv->vval.v_number = 0;\n\t    }\n\t}\n\treport_make_pending(CSTP_RETURN, rettv);\n    }\n    else\n    {\n\tcurrent_funccal->returned = TRUE;\n\n\t// If the return is carried out now, store the return value.  For\n\t// a return immediately after reanimation, the value is already\n\t// there.\n\tif (!reanimate && rettv != NULL)\n\t{\n\t    clear_tv(current_funccal->rettv);\n\t    *current_funccal->rettv = *(typval_T *)rettv;\n\t    if (!is_cmd)\n\t\tvim_free(rettv);\n\t}\n    }\n\n    return idx < 0;\n}\n\n/*\n * Free the variable with a pending return value.\n */\n    void\ndiscard_pending_return(void *rettv)\n{\n    free_tv((typval_T *)rettv);\n}\n\n/*\n * Generate a return command for producing the value of \"rettv\".  The result\n * is an allocated string.  Used by report_pending() for verbose messages.\n */\n    char_u *\nget_return_cmd(void *rettv)\n{\n    char_u\t*s = NULL;\n    char_u\t*tofree = NULL;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    if (rettv != NULL)\n\ts = echo_string((typval_T *)rettv, &tofree, numbuf, 0);\n    if (s == NULL)\n\ts = (char_u *)\"\";\n\n    STRCPY(IObuff, \":return \");\n    STRNCPY(IObuff + 8, s, IOSIZE - 8);\n    if (STRLEN(s) + 8 >= IOSIZE)\n\tSTRCPY(IObuff + IOSIZE - 4, \"...\");\n    vim_free(tofree);\n    return vim_strsave(IObuff);\n}\n\n/*\n * Get next function line.\n * Called by do_cmdline() to get the next line.\n * Returns allocated string, or NULL for end of function.\n */\n    char_u *\nget_func_line(\n    int\t    c UNUSED,\n    void    *cookie,\n    int\t    indent UNUSED,\n    getline_opt_T options UNUSED)\n{\n    funccall_T\t*fcp = (funccall_T *)cookie;\n    ufunc_T\t*fp = fcp->func;\n    char_u\t*retval;\n    garray_T\t*gap;  // growarray with function lines\n\n    // If breakpoints have been added/deleted need to check for it.\n    if (fcp->dbg_tick != debug_tick)\n    {\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tfunc_line_end(cookie);\n#endif\n\n    gap = &fp->uf_lines;\n    if (((fp->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned)\n\tretval = NULL;\n    else\n    {\n\t// Skip NULL lines (continuation lines).\n\twhile (fcp->linenr < gap->ga_len\n\t\t\t  && ((char_u **)(gap->ga_data))[fcp->linenr] == NULL)\n\t    ++fcp->linenr;\n\tif (fcp->linenr >= gap->ga_len)\n\t    retval = NULL;\n\telse\n\t{\n\t    retval = vim_strsave(((char_u **)(gap->ga_data))[fcp->linenr++]);\n\t    SOURCING_LNUM = fcp->linenr;\n#ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t\tfunc_line_start(cookie, SOURCING_LNUM);\n#endif\n\t}\n    }\n\n    // Did we encounter a breakpoint?\n    if (fcp->breakpoint != 0 && fcp->breakpoint <= SOURCING_LNUM)\n    {\n\tdbg_breakpoint(fp->uf_name, SOURCING_LNUM);\n\t// Find next breakpoint.\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if the currently active function should be ended, because a\n * return was encountered or an error occurred.  Used inside a \":while\".\n */\n    int\nfunc_has_ended(void *cookie)\n{\n    funccall_T  *fcp = (funccall_T *)cookie;\n\n    // Ignore the \"abort\" flag if the abortion behavior has been changed due to\n    // an error inside a try conditional.\n    return (((fcp->func->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned);\n}\n\n/*\n * return TRUE if cookie indicates a function which \"abort\"s on errors.\n */\n    int\nfunc_has_abort(\n    void    *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_flags & FC_ABORT;\n}\n\n\n/*\n * Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n * Don't do this when \"Func\" is already a partial that was bound\n * explicitly (pt_auto is FALSE).\n * Changes \"rettv\" in-place.\n * Returns the updated \"selfdict_in\".\n */\n    dict_T *\nmake_partial(dict_T *selfdict_in, typval_T *rettv)\n{\n    char_u\t*fname;\n    ufunc_T\t*fp = NULL;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    int\t\terror;\n    dict_T\t*selfdict = selfdict_in;\n\n    if (rettv->v_type == VAR_PARTIAL  && rettv->vval.v_partial != NULL\n\t\t\t\t     && rettv->vval.v_partial->pt_func != NULL)\n\tfp = rettv->vval.v_partial->pt_func;\n    else\n    {\n\tfname = rettv->v_type == VAR_FUNC ? rettv->vval.v_string\n\t\t\t\t\t : rettv->vval.v_partial == NULL ? NULL\n\t\t\t\t\t      : rettv->vval.v_partial->pt_name;\n\tif (fname == NULL)\n\t{\n\t    // There is no point binding a dict to a NULL function, just create\n\t    // a function reference.\n\t    rettv->v_type = VAR_FUNC;\n\t    rettv->vval.v_string = NULL;\n\t}\n\telse\n\t{\n\t    char_u\t*tofree = NULL;\n\n\t    // Translate \"s:func\" to the stored function name.\n\t    fname = fname_trans_sid(fname, fname_buf, &tofree, &error);\n\t    fp = find_func(fname, FALSE);\n\t    vim_free(tofree);\n\t}\n    }\n\n    if (fp != NULL && (fp->uf_flags & FC_DICT))\n    {\n\tpartial_T\t*pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt != NULL)\n\t{\n\t    pt->pt_refcount = 1;\n\t    pt->pt_dict = selfdict;\n\t    pt->pt_auto = TRUE;\n\t    selfdict = NULL;\n\t    if (rettv->v_type == VAR_FUNC)\n\t    {\n\t\t// Just a function: Take over the function name and use\n\t\t// selfdict.\n\t\tpt->pt_name = rettv->vval.v_string;\n\t    }\n\t    else\n\t    {\n\t\tpartial_T\t*ret_pt = rettv->vval.v_partial;\n\t\tint\t\ti;\n\n\t\t// Partial: copy the function name, use selfdict and copy\n\t\t// args.  Can't take over name or args, the partial might\n\t\t// be referenced elsewhere.\n\t\tif (ret_pt->pt_name != NULL)\n\t\t{\n\t\t    pt->pt_name = vim_strsave(ret_pt->pt_name);\n\t\t    func_ref(pt->pt_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    pt->pt_func = ret_pt->pt_func;\n\t\t    func_ptr_ref(pt->pt_func);\n\t\t}\n\t\tif (ret_pt->pt_argc > 0)\n\t\t{\n\t\t    pt->pt_argv = ALLOC_MULT(typval_T, ret_pt->pt_argc);\n\t\t    if (pt->pt_argv == NULL)\n\t\t\t// out of memory: drop the arguments\n\t\t\tpt->pt_argc = 0;\n\t\t    else\n\t\t    {\n\t\t\tpt->pt_argc = ret_pt->pt_argc;\n\t\t\tfor (i = 0; i < pt->pt_argc; i++)\n\t\t\t    copy_tv(&ret_pt->pt_argv[i], &pt->pt_argv[i]);\n\t\t    }\n\t\t}\n\t\tpartial_unref(ret_pt);\n\t    }\n\t    rettv->v_type = VAR_PARTIAL;\n\t    rettv->vval.v_partial = pt;\n\t}\n    }\n    return selfdict;\n}\n\n/*\n * Return the name of the executed function.\n */\n    char_u *\nfunc_name(void *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_name;\n}\n\n/*\n * Return the address holding the next breakpoint line for a funccall cookie.\n */\n    linenr_T *\nfunc_breakpoint(void *cookie)\n{\n    return &((funccall_T *)cookie)->breakpoint;\n}\n\n/*\n * Return the address holding the debug tick for a funccall cookie.\n */\n    int *\nfunc_dbg_tick(void *cookie)\n{\n    return &((funccall_T *)cookie)->dbg_tick;\n}\n\n/*\n * Return the nesting level for a funccall cookie.\n */\n    int\nfunc_level(void *cookie)\n{\n    return ((funccall_T *)cookie)->level;\n}\n\n/*\n * Return TRUE when a function was ended by a \":return\" command.\n */\n    int\ncurrent_func_returned(void)\n{\n    return current_funccal->returned;\n}\n\n    int\nfree_unref_funccal(int copyID, int testing)\n{\n    int\t\tdid_free = FALSE;\n    int\t\tdid_free_funccal = FALSE;\n    funccall_T\t*fc, **pfc;\n\n    for (pfc = &previous_funccal; *pfc != NULL; )\n    {\n\tif (can_free_funccal(*pfc, copyID))\n\t{\n\t    fc = *pfc;\n\t    *pfc = fc->caller;\n\t    free_funccal_contents(fc);\n\t    did_free = TRUE;\n\t    did_free_funccal = TRUE;\n\t}\n\telse\n\t    pfc = &(*pfc)->caller;\n    }\n    if (did_free_funccal)\n\t// When a funccal was freed some more items might be garbage\n\t// collected, so run again.\n\t(void)garbage_collect(testing);\n\n    return did_free;\n}\n\n/*\n * Get function call environment based on backtrace debug level\n */\n    static funccall_T *\nget_funccal(void)\n{\n    int\t\ti;\n    funccall_T\t*funccal;\n    funccall_T\t*temp_funccal;\n\n    funccal = current_funccal;\n    if (debug_backtrace_level > 0)\n    {\n\tfor (i = 0; i < debug_backtrace_level; i++)\n\t{\n\t    temp_funccal = funccal->caller;\n\t    if (temp_funccal)\n\t\tfunccal = temp_funccal;\n\t    else\n\t\t// backtrace level overflow. reset to max\n\t\tdebug_backtrace_level = i;\n\t}\n    }\n    return funccal;\n}\n\n/*\n * Return the hashtable used for local variables in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_local_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars.dv_hashtab;\n}\n\n/*\n * Return the l: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_local_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars_var;\n}\n\n/*\n * Return the hashtable used for argument in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_args_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars.dv_hashtab;\n}\n\n/*\n * Return the a: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_args_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars_var;\n}\n\n/*\n * List function variables, if there is a function.\n */\n    void\nlist_func_vars(int *first)\n{\n    if (current_funccal != NULL && current_funccal->l_vars.dv_refcount > 0)\n\tlist_hashtable_vars(&current_funccal->l_vars.dv_hashtab,\n\t\t\t\t\t\t\t   \"l:\", FALSE, first);\n}\n\n/*\n * If \"ht\" is the hashtable for local variables in the current funccal, return\n * the dict that contains it.\n * Otherwise return NULL.\n */\n    dict_T *\nget_current_funccal_dict(hashtab_T *ht)\n{\n    if (current_funccal != NULL\n\t    && ht == &current_funccal->l_vars.dv_hashtab)\n\treturn &current_funccal->l_vars;\n    return NULL;\n}\n\n/*\n * Search hashitem in parent scope.\n */\n    hashitem_T *\nfind_hi_in_scoped_ht(char_u *name, hashtab_T **pht)\n{\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    hashitem_T\t*hi = NULL;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n      return NULL;\n\n    // Search in parent scope, which can be referenced from a lambda.\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal != NULL)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    hi = hash_find(ht, varname);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t*pht = ht;\n\t\tbreak;\n\t    }\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return hi;\n}\n\n/*\n * Search variable in parent scope.\n */\n    dictitem_T *\nfind_var_in_scoped_ht(char_u *name, int no_autoload)\n{\n    dictitem_T\t*v = NULL;\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n\treturn NULL;\n\n    // Search in parent scope which is possible to reference from lambda\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    v = find_var_in_ht(ht, *name, varname, no_autoload);\n\t    if (v != NULL)\n\t\tbreak;\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return v;\n}\n\n/*\n * Set \"copyID + 1\" in previous_funccal and callers.\n */\n    int\nset_ref_in_previous_funccal(int copyID)\n{\n    funccall_T\t*fc;\n\n    for (fc = previous_funccal; fc != NULL; fc = fc->caller)\n    {\n\tfc->fc_copyID = copyID + 1;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID + 1, NULL))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n    static int\nset_ref_in_funccal(funccall_T *fc, int copyID)\n{\n    if (fc->fc_copyID != copyID)\n    {\n\tfc->fc_copyID = copyID;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID, NULL)\n\t\t|| set_ref_in_func(NULL, fc->func, copyID))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all local vars and arguments in the call stack.\n */\n    int\nset_ref_in_call_stack(int copyID)\n{\n    funccall_T\t\t*fc;\n    funccal_entry_T\t*entry;\n\n    for (fc = current_funccal; fc != NULL; fc = fc->caller)\n\tif (set_ref_in_funccal(fc, copyID))\n\t    return TRUE;\n\n    // Also go through the funccal_stack.\n    for (entry = funccal_stack; entry != NULL; entry = entry->next)\n\tfor (fc = entry->top_funccal; fc != NULL; fc = fc->caller)\n\t    if (set_ref_in_funccal(fc, copyID))\n\t\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all functions available by name.\n */\n    int\nset_ref_in_functions(int copyID)\n{\n    int\t\ttodo;\n    hashitem_T\t*hi = NULL;\n    ufunc_T\t*fp;\n\n    todo = (int)func_hashtab.ht_used;\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    fp = HI2UF(hi);\n\t    if (!func_name_refcount(fp->uf_name)\n\t\t\t\t\t  && set_ref_in_func(NULL, fp, copyID))\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all function arguments.\n */\n    int\nset_ref_in_func_args(int copyID)\n{\n    int i;\n\n    for (i = 0; i < funcargs.ga_len; ++i)\n\tif (set_ref_in_item(((typval_T **)funcargs.ga_data)[i],\n\t\t\t\t\t\t\t  copyID, NULL, NULL))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through function \"name\" with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID)\n{\n    ufunc_T\t*fp = fp_in;\n    funccall_T\t*fc;\n    int\t\terror = FCERR_NONE;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname;\n    int\t\tabort = FALSE;\n\n    if (name == NULL && fp_in == NULL)\n\treturn FALSE;\n\n    if (fp_in == NULL)\n    {\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE);\n    }\n    if (fp != NULL)\n    {\n\tfor (fc = fp->uf_scoped; fc != NULL; fc = fc->func->uf_scoped)\n\t    abort = abort || set_ref_in_funccal(fc, copyID);\n    }\n\n    vim_free(tofree);\n    return abort;\n}\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * eval.c: Expression evaluation.\n */\n#define USING_FLOAT_STUFF\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n#ifdef VMS\n# include <float.h>\n#endif\n\n#define NAMESPACE_CHAR\t(char_u *)\"abglstvw\"\n\n/*\n * When recursively copying lists and dicts we need to remember which ones we\n * have done to avoid endless recursiveness.  This unique ID is used for that.\n * The last bit is used for previous_funccal, ignored when comparing.\n */\nstatic int current_copyID = 0;\n\n/*\n * Info used by a \":for\" loop.\n */\ntypedef struct\n{\n    int\t\tfi_semicolon;\t// TRUE if ending in '; var]'\n    int\t\tfi_varcount;\t// nr of variables in the list\n    int\t\tfi_break_count;\t// nr of line breaks encountered\n    listwatch_T\tfi_lw;\t\t// keep an eye on the item used.\n    list_T\t*fi_list;\t// list being used\n    int\t\tfi_bi;\t\t// index of blob\n    blob_T\t*fi_blob;\t// blob being used\n    char_u\t*fi_string;\t// copy of string being used\n    int\t\tfi_byte_idx;\t// byte index in fi_string\n} forinfo_T;\n\nstatic int eval2(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval3(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval5(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval6(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nstatic int eval7(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval8(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval9(char_u **arg, typval_T *rettv, evalarg_T *evalarg, int want_string);\nstatic int eval9_leader(typval_T *rettv, int numeric_only, char_u *start_leader, char_u **end_leaderp);\n\nstatic int free_unref_items(int copyID);\nstatic char_u *make_expanded_name(char_u *in_start, char_u *expr_start, char_u *expr_end, char_u *in_end);\n\n/*\n * Return \"n1\" divided by \"n2\", taking care of dividing by zero.\n * If \"failed\" is not NULL set it to TRUE when dividing by zero fails.\n */\n\tvarnumber_T\nnum_divide(varnumber_T n1, varnumber_T n2, int *failed)\n{\n    varnumber_T\tresult;\n\n    if (n2 == 0)\n    {\n\tif (in_vim9script())\n\t{\n\t    emsg(_(e_divide_by_zero));\n\t    if (failed != NULL)\n\t\t*failed = TRUE;\n\t}\n\tif (n1 == 0)\n\t    result = VARNUM_MIN; // similar to NaN\n\telse if (n1 < 0)\n\t    result = -VARNUM_MAX;\n\telse\n\t    result = VARNUM_MAX;\n    }\n    else\n\tresult = n1 / n2;\n\n    return result;\n}\n\n/*\n * Return \"n1\" modulus \"n2\", taking care of dividing by zero.\n * If \"failed\" is not NULL set it to TRUE when dividing by zero fails.\n */\n\tvarnumber_T\nnum_modulus(varnumber_T n1, varnumber_T n2, int *failed)\n{\n    if (n2 == 0 && in_vim9script())\n    {\n\temsg(_(e_divide_by_zero));\n\tif (failed != NULL)\n\t    *failed = TRUE;\n    }\n    return (n2 == 0) ? 0 : (n1 % n2);\n}\n\n/*\n * Initialize the global and v: variables.\n */\n    void\neval_init(void)\n{\n    evalvars_init();\n    func_init();\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\neval_clear(void)\n{\n    evalvars_clear();\n    free_scriptnames();  // must come after evalvars_clear().\n    free_locales();\n\n    // autoloaded script names\n    free_autoload_scriptnames();\n\n    // unreferenced lists and dicts\n    (void)garbage_collect(FALSE);\n\n    // functions not garbage collected\n    free_all_functions();\n}\n#endif\n\n    void\nfill_evalarg_from_eap(evalarg_T *evalarg, exarg_T *eap, int skip)\n{\n    init_evalarg(evalarg);\n    evalarg->eval_flags = skip ? 0 : EVAL_EVALUATE;\n    if (eap != NULL)\n    {\n\tevalarg->eval_cstack = eap->cstack;\n\tif (sourcing_a_script(eap) || eap->getline == get_list_line)\n\t{\n\t    evalarg->eval_getline = eap->getline;\n\t    evalarg->eval_cookie = eap->cookie;\n\t}\n    }\n}\n\n/*\n * Top level evaluation function, returning a boolean.\n * Sets \"error\" to TRUE if there was an error.\n * Return TRUE or FALSE.\n */\n    int\neval_to_bool(\n    char_u\t*arg,\n    int\t\t*error,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    varnumber_T\tretval = FALSE;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL)\n\t*error = TRUE;\n    else\n    {\n\t*error = FALSE;\n\tif (!skip)\n\t{\n\t    if (in_vim9script())\n\t\tretval = tv_get_bool_chk(&tv, error);\n\t    else\n\t\tretval = (tv_get_number_chk(&tv, error) != 0);\n\t    clear_tv(&tv);\n\t}\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return (int)retval;\n}\n\n/*\n * Call eval1() and give an error message if not done at a lower level.\n */\n    static int\neval1_emsg(char_u **arg, typval_T *rettv, exarg_T *eap)\n{\n    char_u\t*start = *arg;\n    int\t\tret;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n\n    ret = eval1(arg, rettv, &evalarg);\n    if (ret == FAIL)\n    {\n\t// Report the invalid expression unless the expression evaluation has\n\t// been cancelled due to an aborting error, an interrupt, or an\n\t// exception, or we already gave a more specific error.\n\t// Also check called_emsg for when using assert_fails().\n\tif (!aborting() && did_emsg == did_emsg_before\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t    semsg(_(e_invalid_expression_str), start);\n    }\n    clear_evalarg(&evalarg, eap);\n    return ret;\n}\n\n/*\n * Return whether a typval is a valid expression to pass to eval_expr_typval()\n * or eval_expr_to_bool().  An empty string returns FALSE;\n */\n    int\neval_expr_valid_arg(typval_T *tv)\n{\n    return tv->v_type != VAR_UNKNOWN\n\t    && (tv->v_type != VAR_STRING\n\t\t  || (tv->vval.v_string != NULL && *tv->vval.v_string != NUL));\n}\n\n/*\n * Evaluate an expression, which can be a function, partial or string.\n * Pass arguments \"argv[argc]\".\n * Return the result in \"rettv\" and OK or FAIL.\n */\n    int\neval_expr_typval(typval_T *expr, typval_T *argv, int argc, typval_T *rettv)\n{\n    char_u\t*s;\n    char_u\tbuf[NUMBUFLEN];\n    funcexe_T\tfuncexe;\n\n    if (expr->v_type == VAR_FUNC)\n    {\n\ts = expr->vval.v_string;\n\tif (s == NULL || *s == NUL)\n\t    return FAIL;\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_evaluate = TRUE;\n\tif (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t    return FAIL;\n    }\n    else if (expr->v_type == VAR_PARTIAL)\n    {\n\tpartial_T   *partial = expr->vval.v_partial;\n\n\tif (partial == NULL)\n\t    return FAIL;\n\n\tif (partial->pt_func != NULL\n\t\t\t  && partial->pt_func->uf_def_status != UF_NOT_COMPILED)\n\t{\n\t    if (call_def_function(partial->pt_func, argc, argv,\n\t\t\t\t\t\t       partial, rettv) == FAIL)\n\t\treturn FAIL;\n\t}\n\telse\n\t{\n\t    s = partial_name(partial);\n\t    if (s == NULL || *s == NUL)\n\t\treturn FAIL;\n\t    CLEAR_FIELD(funcexe);\n\t    funcexe.fe_evaluate = TRUE;\n\t    funcexe.fe_partial = partial;\n\t    if (call_func(s, -1, rettv, argc, argv, &funcexe) == FAIL)\n\t\treturn FAIL;\n\t}\n    }\n    else if (expr->v_type == VAR_INSTR)\n    {\n\treturn exe_typval_instr(expr, rettv);\n    }\n    else\n    {\n\ts = tv_get_string_buf_chk_strict(expr, buf, in_vim9script());\n\tif (s == NULL)\n\t    return FAIL;\n\ts = skipwhite(s);\n\tif (eval1_emsg(&s, rettv, NULL) == FAIL)\n\t    return FAIL;\n\tif (*skipwhite(s) != NUL)  // check for trailing chars after expr\n\t{\n\t    clear_tv(rettv);\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Like eval_to_bool() but using a typval_T instead of a string.\n * Works for string, funcref and partial.\n */\n    int\neval_expr_to_bool(typval_T *expr, int *error)\n{\n    typval_T\trettv;\n    int\t\tres;\n\n    if (eval_expr_typval(expr, NULL, 0, &rettv) == FAIL)\n    {\n\t*error = TRUE;\n\treturn FALSE;\n    }\n    res = (tv_get_bool_chk(&rettv, error) != 0);\n    clear_tv(&rettv);\n    return res;\n}\n\n/*\n * Top level evaluation function, returning a string.  If \"skip\" is TRUE,\n * only parsing to \"nextcmd\" is done, without reporting errors.  Return\n * pointer to allocated memory, or NULL for failure or when \"skip\" is TRUE.\n */\n    char_u *\neval_to_string_skip(\n    char_u\t*arg,\n    exarg_T\t*eap,\n    int\t\tskip)\t    // only parse, don't execute\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, skip);\n    if (skip)\n\t++emsg_skip;\n    if (eval0(arg, &tv, eap, &evalarg) == FAIL || skip)\n\tretval = NULL;\n    else\n    {\n\tretval = vim_strsave(tv_get_string(&tv));\n\tclear_tv(&tv);\n    }\n    if (skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n\n    return retval;\n}\n\n/*\n * Initialize \"evalarg\" for use.\n */\n    void\ninit_evalarg(evalarg_T *evalarg)\n{\n    CLEAR_POINTER(evalarg);\n    ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);\n}\n\n/*\n * If \"evalarg->eval_tofree\" is not NULL free it later.\n * Caller is expected to overwrite \"evalarg->eval_tofree\" next.\n */\n    static void\nfree_eval_tofree_later(evalarg_T *evalarg)\n{\n    if (evalarg->eval_tofree != NULL)\n    {\n\tif (ga_grow(&evalarg->eval_tofree_ga, 1) == OK)\n\t    ((char_u **)evalarg->eval_tofree_ga.ga_data)\n\t\t[evalarg->eval_tofree_ga.ga_len++]\n\t\t= evalarg->eval_tofree;\n\telse\n\t    vim_free(evalarg->eval_tofree);\n    }\n}\n\n/*\n * After using \"evalarg\" filled from \"eap\": free the memory.\n */\n    void\nclear_evalarg(evalarg_T *evalarg, exarg_T *eap)\n{\n    if (evalarg != NULL)\n    {\n\tif (evalarg->eval_tofree != NULL)\n\t{\n\t    if (eap != NULL)\n\t    {\n\t\t// We may need to keep the original command line, e.g. for\n\t\t// \":let\" it has the variable names.  But we may also need the\n\t\t// new one, \"nextcmd\" points into it.  Keep both.\n\t\tvim_free(eap->cmdline_tofree);\n\t\teap->cmdline_tofree = *eap->cmdlinep;\n\t\t*eap->cmdlinep = evalarg->eval_tofree;\n\t    }\n\t    else\n\t\tvim_free(evalarg->eval_tofree);\n\t    evalarg->eval_tofree = NULL;\n\t}\n\n\tga_clear_strings(&evalarg->eval_tofree_ga);\n\tVIM_CLEAR(evalarg->eval_tofree_lambda);\n    }\n}\n\n/*\n * Skip over an expression at \"*pp\".\n * Return FAIL for an error, OK otherwise.\n */\n    int\nskip_expr(char_u **pp, evalarg_T *evalarg)\n{\n    typval_T\trettv;\n\n    *pp = skipwhite(*pp);\n    return eval1(pp, &rettv, evalarg);\n}\n\n/*\n * Skip over an expression at \"*arg\".\n * If in Vim9 script and line breaks are encountered, the lines are\n * concatenated.  \"evalarg->eval_tofree\" will be set accordingly.\n * \"arg\" is advanced to just after the expression.\n * \"start\" is set to the start of the expression, \"end\" to just after the end.\n * Also when the expression is copied to allocated memory.\n * Return FAIL for an error, OK otherwise.\n */\n    int\nskip_expr_concatenate(\n\tchar_u\t    **arg,\n\tchar_u\t    **start,\n\tchar_u\t    **end,\n\tevalarg_T   *evalarg)\n{\n    typval_T\trettv;\n    int\t\tres;\n    int\t\tvim9script = in_vim9script();\n    garray_T    *gap = evalarg == NULL ? NULL : &evalarg->eval_ga;\n    garray_T    *freegap = evalarg == NULL ? NULL : &evalarg->eval_freega;\n    int\t\tsave_flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tevaluate = evalarg == NULL\n\t\t\t       ? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    if (vim9script && evaluate\n\t       && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tga_init2(gap, sizeof(char_u *), 10);\n\t// leave room for \"start\"\n\tif (ga_grow(gap, 1) == OK)\n\t    ++gap->ga_len;\n\tga_init2(freegap, sizeof(char_u *), 10);\n    }\n    *start = *arg;\n\n    // Don't evaluate the expression.\n    if (evalarg != NULL)\n\tevalarg->eval_flags &= ~EVAL_EVALUATE;\n    *arg = skipwhite(*arg);\n    res = eval1(arg, &rettv, evalarg);\n    *end = *arg;\n    if (evalarg != NULL)\n\tevalarg->eval_flags = save_flags;\n\n    if (vim9script && evaluate\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL))\n    {\n\tif (evalarg->eval_ga.ga_len == 1)\n\t{\n\t    // just the one line, no need to concatenate\n\t    ga_clear(gap);\n\t    gap->ga_itemsize = 0;\n\t}\n\telse\n\t{\n\t    char_u\t    *p;\n\t    size_t\t    endoff = STRLEN(*arg);\n\n\t    // Line breaks encountered, concatenate all the lines.\n\t    *((char_u **)gap->ga_data) = *start;\n\t    p = ga_concat_strings(gap, \" \");\n\n\t    // free the lines only when using getsourceline()\n\t    if (evalarg->eval_cookie != NULL)\n\t    {\n\t\t// Do not free the first line, the caller can still use it.\n\t\t*((char_u **)gap->ga_data) = NULL;\n\t\t// Do not free the last line, \"arg\" points into it, free it\n\t\t// later.  Also free \"eval_tofree\" later if needed.\n\t\tfree_eval_tofree_later(evalarg);\n\t\tevalarg->eval_tofree =\n\t\t\t\t    ((char_u **)gap->ga_data)[gap->ga_len - 1];\n\t\t((char_u **)gap->ga_data)[gap->ga_len - 1] = NULL;\n\t\tga_clear_strings(gap);\n\t    }\n\t    else\n\t    {\n\t\tga_clear(gap);\n\n\t\t// free lines that were explicitly marked for freeing\n\t\tga_clear_strings(freegap);\n\t    }\n\n\t    gap->ga_itemsize = 0;\n\t    if (p == NULL)\n\t\treturn FAIL;\n\t    *start = p;\n\t    vim_free(evalarg->eval_tofree_lambda);\n\t    evalarg->eval_tofree_lambda = p;\n\t    // Compute \"end\" relative to the end.\n\t    *end = *start + STRLEN(*start) - endoff;\n\t}\n    }\n\n    return res;\n}\n\n/*\n * Convert \"tv\" to a string.\n * When \"convert\" is TRUE convert a List into a sequence of lines and convert\n * a Float to a String.\n * Returns an allocated string (NULL when out of memory).\n */\n    char_u *\ntypval2string(typval_T *tv, int convert)\n{\n    garray_T\tga;\n    char_u\t*retval;\n#ifdef FEAT_FLOAT\n    char_u\tnumbuf[NUMBUFLEN];\n#endif\n\n    if (convert && tv->v_type == VAR_LIST)\n    {\n\tga_init2(&ga, sizeof(char), 80);\n\tif (tv->vval.v_list != NULL)\n\t{\n\t    list_join(&ga, tv->vval.v_list, (char_u *)\"\\n\", TRUE, FALSE, 0);\n\t    if (tv->vval.v_list->lv_len > 0)\n\t\tga_append(&ga, NL);\n\t}\n\tga_append(&ga, NUL);\n\tretval = (char_u *)ga.ga_data;\n    }\n#ifdef FEAT_FLOAT\n    else if (convert && tv->v_type == VAR_FLOAT)\n    {\n\tvim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);\n\tretval = vim_strsave(numbuf);\n    }\n#endif\n    else\n\tretval = vim_strsave(tv_get_string(tv));\n    return retval;\n}\n\n/*\n * Top level evaluation function, returning a string.  Does not handle line\n * breaks.\n * When \"convert\" is TRUE convert a List into a sequence of lines and convert\n * a Float to a String.\n * Return pointer to allocated memory, or NULL for failure.\n */\n    char_u *\neval_to_string_eap(\n    char_u\t*arg,\n    int\t\tconvert,\n    exarg_T\t*eap)\n{\n    typval_T\ttv;\n    char_u\t*retval;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n    if (eval0(arg, &tv, NULL, &evalarg) == FAIL)\n\tretval = NULL;\n    else\n    {\n\tretval = typval2string(&tv, convert);\n\tclear_tv(&tv);\n    }\n    clear_evalarg(&evalarg, NULL);\n\n    return retval;\n}\n\n    char_u *\neval_to_string(\n    char_u\t*arg,\n    int\t\tconvert)\n{\n    return eval_to_string_eap(arg, convert, NULL);\n}\n\n/*\n * Call eval_to_string() without using current local variables and using\n * textlock.  When \"use_sandbox\" is TRUE use the sandbox.\n * Use legacy Vim script syntax.\n */\n    char_u *\neval_to_string_safe(\n    char_u\t*arg,\n    int\t\tuse_sandbox,\n    int\t\tkeep_script_version)\n{\n    char_u\t*retval;\n    funccal_entry_T funccal_entry;\n    int\t\tsave_sc_version = current_sctx.sc_version;\n    int\t\tsave_garbage = may_garbage_collect;\n\n    if (!keep_script_version)\n\tcurrent_sctx.sc_version = 1;\n    save_funccal(&funccal_entry);\n    if (use_sandbox)\n\t++sandbox;\n    ++textlock;\n    may_garbage_collect = FALSE;\n    retval = eval_to_string(arg, FALSE);\n    if (use_sandbox)\n\t--sandbox;\n    --textlock;\n    may_garbage_collect = save_garbage;\n    restore_funccal();\n    current_sctx.sc_version = save_sc_version;\n    return retval;\n}\n\n/*\n * Top level evaluation function, returning a number.\n * Evaluates \"expr\" silently.\n * Returns -1 for an error.\n */\n    varnumber_T\neval_to_number(char_u *expr)\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n    char_u\t*p = skipwhite(expr);\n\n    ++emsg_off;\n\n    if (eval1(&p, &rettv, &EVALARG_EVALUATE) == FAIL)\n\tretval = -1;\n    else\n    {\n\tretval = tv_get_number_chk(&rettv, NULL);\n\tclear_tv(&rettv);\n    }\n    --emsg_off;\n\n    return retval;\n}\n\n/*\n * Top level evaluation function.\n * Returns an allocated typval_T with the result.\n * Returns NULL when there is an error.\n */\n    typval_T *\neval_expr(char_u *arg, exarg_T *eap)\n{\n    typval_T\t*tv;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap != NULL && eap->skip);\n\n    tv = ALLOC_ONE(typval_T);\n    if (tv != NULL && eval0(arg, tv, eap, &evalarg) == FAIL)\n\tVIM_CLEAR(tv);\n\n    clear_evalarg(&evalarg, eap);\n    return tv;\n}\n\n/*\n * \"*arg\" points to what can be a function name in the form of \"import.Name\" or\n * \"Funcref\".  Return the name of the function.  Set \"tofree\" to something that\n * was allocated.\n * If \"verbose\" is FALSE no errors are given.\n * Return NULL for any failure.\n */\n    static char_u *\nderef_function_name(\n\t    char_u\t**arg,\n\t    char_u\t**tofree,\n\t    evalarg_T\t*evalarg,\n\t    int\t\tverbose)\n{\n    typval_T\tref;\n    char_u\t*name = *arg;\n\n    ref.v_type = VAR_UNKNOWN;\n    if (eval9(arg, &ref, evalarg, FALSE) == FAIL)\n    {\n\tdictitem_T\t*v;\n\n\t// If <SID>VarName was used it would not be found, try another way.\n\tv = find_var_also_in_script(name, NULL, FALSE);\n\tif (v == NULL)\n\t    return NULL;\n\tcopy_tv(&v->di_tv, &ref);\n    }\n    if (*skipwhite(*arg) != NUL)\n    {\n\tif (verbose)\n\t    semsg(_(e_trailing_characters_str), *arg);\n\tname = NULL;\n    }\n    else if (ref.v_type == VAR_FUNC && ref.vval.v_string != NULL)\n    {\n\tname = ref.vval.v_string;\n\tref.vval.v_string = NULL;\n\t*tofree = name;\n    }\n    else if (ref.v_type == VAR_PARTIAL && ref.vval.v_partial != NULL)\n    {\n\tif (ref.vval.v_partial->pt_argc > 0\n\t\t|| ref.vval.v_partial->pt_dict != NULL)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_use_partial_here));\n\t    name = NULL;\n\t}\n\telse\n\t{\n\t    name = vim_strsave(partial_name(ref.vval.v_partial));\n\t    *tofree = name;\n\t}\n    }\n    else\n    {\n\tif (verbose)\n\t    semsg(_(e_not_callable_type_str), name);\n\tname = NULL;\n    }\n    clear_tv(&ref);\n    return name;\n}\n\n/*\n * Call some Vim script function and return the result in \"*rettv\".\n * Uses argv[0] to argv[argc - 1] for the function arguments.  argv[argc]\n * should have type VAR_UNKNOWN.\n * Returns OK or FAIL.\n */\n    int\ncall_vim_function(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv,\n    typval_T\t*rettv)\n{\n    int\t\tret;\n    funcexe_T\tfuncexe;\n    char_u\t*arg;\n    char_u\t*name;\n    char_u\t*tofree = NULL;\n    int\t\tignore_errors;\n\n    rettv->v_type = VAR_UNKNOWN;\t\t// clear_tv() uses this\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_firstline = curwin->w_cursor.lnum;\n    funcexe.fe_lastline = curwin->w_cursor.lnum;\n    funcexe.fe_evaluate = TRUE;\n\n    // The name might be \"import.Func\" or \"Funcref\".  We don't know, we need to\n    // ignore errors for an undefined name.  But we do want errors when an\n    // autoload script has errors.  Guess that when there is a dot in the name\n    // showing errors is the right choice.\n    ignore_errors = vim_strchr(func, '.') == NULL;\n    arg = func;\n    if (ignore_errors)\n\t++emsg_off;\n    name = deref_function_name(&arg, &tofree, &EVALARG_EVALUATE, FALSE);\n    if (ignore_errors)\n\t--emsg_off;\n    if (name == NULL)\n\tname = func;\n\n    ret = call_func(name, -1, rettv, argc, argv, &funcexe);\n\n    if (ret == FAIL)\n\tclear_tv(rettv);\n    vim_free(tofree);\n\n    return ret;\n}\n\n/*\n * Call Vim script function \"func\" and return the result as a string.\n * Uses \"argv[0]\" to \"argv[argc - 1]\" for the function arguments. \"argv[argc]\"\n * should have type VAR_UNKNOWN.\n * Returns NULL when calling the function fails.\n */\n    void *\ncall_func_retstr(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv)\n{\n    typval_T\trettv;\n    char_u\t*retval;\n\n    if (call_vim_function(func, argc, argv, &rettv) == FAIL)\n\treturn NULL;\n\n    retval = vim_strsave(tv_get_string(&rettv));\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Call Vim script function \"func\" and return the result as a List.\n * Uses \"argv\" and \"argc\" as call_func_retstr().\n * Returns NULL when there is something wrong.\n */\n    void *\ncall_func_retlist(\n    char_u      *func,\n    int\t\targc,\n    typval_T\t*argv)\n{\n    typval_T\trettv;\n\n    if (call_vim_function(func, argc, argv, &rettv) == FAIL)\n\treturn NULL;\n\n    if (rettv.v_type != VAR_LIST)\n    {\n\tclear_tv(&rettv);\n\treturn NULL;\n    }\n\n    return rettv.vval.v_list;\n}\n\n#if defined(FEAT_FOLDING) || defined(PROTO)\n/*\n * Evaluate \"arg\", which is 'foldexpr'.\n * Note: caller must set \"curwin\" to match \"arg\".\n * Returns the foldlevel, and any character preceding it in \"*cp\".  Doesn't\n * give error messages.\n */\n    int\neval_foldexpr(win_T *wp, int *cp)\n{\n    char_u\t*arg;\n    typval_T\ttv;\n    varnumber_T\tretval;\n    char_u\t*s;\n    sctx_T\tsaved_sctx = current_sctx;\n    int\t\tuse_sandbox = was_set_insecurely((char_u *)\"foldexpr\",\n\t\t\t\t\t\t\t\t   OPT_LOCAL);\n\n    arg = wp->w_p_fde;\n    current_sctx = wp->w_p_script_ctx[WV_FDE];\n\n    ++emsg_off;\n    if (use_sandbox)\n\t++sandbox;\n    ++textlock;\n    *cp = NUL;\n    if (eval0(arg, &tv, NULL, &EVALARG_EVALUATE) == FAIL)\n\tretval = 0;\n    else\n    {\n\t// If the result is a number, just return the number.\n\tif (tv.v_type == VAR_NUMBER)\n\t    retval = tv.vval.v_number;\n\telse if (tv.v_type != VAR_STRING || tv.vval.v_string == NULL)\n\t    retval = 0;\n\telse\n\t{\n\t    // If the result is a string, check if there is a non-digit before\n\t    // the number.\n\t    s = tv.vval.v_string;\n\t    if (!VIM_ISDIGIT(*s) && *s != '-')\n\t\t*cp = *s++;\n\t    retval = atol((char *)s);\n\t}\n\tclear_tv(&tv);\n    }\n    --emsg_off;\n    if (use_sandbox)\n\t--sandbox;\n    --textlock;\n    clear_evalarg(&EVALARG_EVALUATE, NULL);\n    current_sctx = saved_sctx;\n\n    return (int)retval;\n}\n#endif\n\n/*\n * Get an lval: variable, Dict item or List item that can be assigned a value\n * to: \"name\", \"na{me}\", \"name[expr]\", \"name[expr:expr]\", \"name[expr][expr]\",\n * \"name.key\", \"name.key[expr]\" etc.\n * Indexing only works if \"name\" is an existing List or Dictionary.\n * \"name\" points to the start of the name.\n * If \"rettv\" is not NULL it points to the value to be assigned.\n * \"unlet\" is TRUE for \":unlet\": slightly different behavior when something is\n * wrong; must end in space or cmd separator.\n *\n * flags:\n *  GLV_QUIET:       do not give error messages\n *  GLV_READ_ONLY:   will not change the variable\n *  GLV_NO_AUTOLOAD: do not use script autoloading\n *\n * Returns a pointer to just after the name, including indexes.\n * When an evaluation error occurs \"lp->ll_name\" is NULL;\n * Returns NULL for a parsing error.  Still need to free items in \"lp\"!\n */\n    char_u *\nget_lval(\n    char_u\t*name,\n    typval_T\t*rettv,\n    lval_T\t*lp,\n    int\t\tunlet,\n    int\t\tskip,\n    int\t\tflags,\t    // GLV_ values\n    int\t\tfne_flags)  // flags for find_name_end()\n{\n    char_u\t*p;\n    char_u\t*expr_start, *expr_end;\n    int\t\tcc;\n    dictitem_T\t*v;\n    typval_T\tvar1;\n    typval_T\tvar2;\n    int\t\tempty1 = FALSE;\n    char_u\t*key = NULL;\n    int\t\tlen;\n    hashtab_T\t*ht = NULL;\n    int\t\tquiet = flags & GLV_QUIET;\n    int\t\twriting;\n    int\t\tvim9script = in_vim9script();\n\n    // Clear everything in \"lp\".\n    CLEAR_POINTER(lp);\n\n    if (skip || (flags & GLV_COMPILING))\n    {\n\t// When skipping or compiling just find the end of the name.\n\tlp->ll_name = name;\n\tlp->ll_name_end = find_name_end(name, NULL, NULL,\n\t\t\t\t\t\t      FNE_INCL_BR | fne_flags);\n\treturn lp->ll_name_end;\n    }\n\n    // Cannot use \"s:var\" at the Vim9 script level.  \"s: type\" is OK.\n    if (vim9script && at_script_level()\n\t\t  && name[0] == 's' && name[1] == ':' && !VIM_ISWHITE(name[2]))\n    {\n\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str), name);\n\treturn NULL;\n    }\n\n    // Find the end of the name.\n    p = find_name_end(name, &expr_start, &expr_end, fne_flags);\n    lp->ll_name_end = p;\n    if (expr_start != NULL)\n    {\n\t// Don't expand the name when we already know there is an error.\n\tif (unlet && !VIM_ISWHITE(*p) && !ends_excmd(*p)\n\t\t\t\t\t\t    && *p != '[' && *p != '.')\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    return NULL;\n\t}\n\n\tlp->ll_exp_name = make_expanded_name(name, expr_start, expr_end, p);\n\tif (lp->ll_exp_name == NULL)\n\t{\n\t    // Report an invalid expression in braces, unless the\n\t    // expression evaluation has been cancelled due to an\n\t    // aborting error, an interrupt, or an exception.\n\t    if (!aborting() && !quiet)\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_invalid_argument_str), name);\n\t\treturn NULL;\n\t    }\n\t}\n\tlp->ll_name = lp->ll_exp_name;\n    }\n    else\n    {\n\tlp->ll_name = name;\n\n\tif (vim9script)\n\t{\n\t    // \"a: type\" is declaring variable \"a\" with a type, not \"a:\".\n\t    // However, \"g:[key]\" is indexing a dictionary.\n\t    if (p == name + 2 && p[-1] == ':' && *p != '[')\n\t    {\n\t\t--p;\n\t\tlp->ll_name_end = p;\n\t    }\n\t    if (*p == ':')\n\t    {\n\t\tchar_u\t    *tp = skipwhite(p + 1);\n\n\t\tif (tp == p + 1 && !quiet)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \":\", p);\n\t\t    return NULL;\n\t\t}\n\n\t\tif (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n\t\t{\n\t\t    semsg(_(e_using_type_not_in_script_context_str), p);\n\t\t    return NULL;\n\t\t}\n\n\t\t// parse the type after the name\n\t\tlp->ll_type = parse_type(&tp,\n\t\t\t       &SCRIPT_ITEM(current_sctx.sc_sid)->sn_type_list,\n\t\t\t       !quiet);\n\t\tif (lp->ll_type == NULL && !quiet)\n\t\t    return NULL;\n\t\tlp->ll_name_end = tp;\n\t    }\n\t}\n    }\n    if (lp->ll_name == NULL)\n\treturn p;\n\n    if (*p == '.')\n    {\n\timported_T *import = find_imported(lp->ll_name, p - lp->ll_name, TRUE);\n\n\tif (import != NULL)\n\t{\n\t    ufunc_T *ufunc;\n\t    type_T *type;\n\n\t    lp->ll_sid = import->imp_sid;\n\t    lp->ll_name = skipwhite(p + 1);\n\t    p = find_name_end(lp->ll_name, NULL, NULL, fne_flags);\n\t    lp->ll_name_end = p;\n\n\t    // check the item is exported\n\t    cc = *p;\n\t    *p = NUL;\n\t    if (find_exported(import->imp_sid, lp->ll_name, &ufunc, &type,\n\t\t\t\t\t\t       NULL, NULL, TRUE) == -1)\n\t    {\n\t\t*p = cc;\n\t\treturn NULL;\n\t    }\n\t    *p = cc;\n\t}\n    }\n\n    // Without [idx] or .key we are done.\n    if ((*p != '[' && *p != '.'))\n\treturn p;\n\n    if (vim9script && lval_root != NULL)\n    {\n\t// using local variable\n\tlp->ll_tv = lval_root;\n\tv = NULL;\n    }\n    else\n    {\n\tcc = *p;\n\t*p = NUL;\n\t// When we would write to the variable pass &ht and prevent autoload.\n\twriting = !(flags & GLV_READ_ONLY);\n\tv = find_var(lp->ll_name, writing ? &ht : NULL,\n\t\t\t\t\t (flags & GLV_NO_AUTOLOAD) || writing);\n\tif (v == NULL && !quiet)\n\t    semsg(_(e_undefined_variable_str), lp->ll_name);\n\t*p = cc;\n\tif (v == NULL)\n\t    return NULL;\n\tlp->ll_tv = &v->di_tv;\n    }\n\n    if (vim9script && (flags & GLV_NO_DECL) == 0)\n    {\n\tif (!quiet)\n\t    semsg(_(e_variable_already_declared), lp->ll_name);\n\treturn NULL;\n    }\n\n    /*\n     * Loop until no more [idx] or .key is following.\n     */\n    var1.v_type = VAR_UNKNOWN;\n    var2.v_type = VAR_UNKNOWN;\n    while (*p == '[' || (*p == '.' && p[1] != '=' && p[1] != '.'))\n    {\n\tif (*p == '.' && lp->ll_tv->v_type != VAR_DICT)\n\t{\n\t    if (!quiet)\n\t\tsemsg(_(e_dot_can_only_be_used_on_dictionary_str), name);\n\t    return NULL;\n\t}\n\tif (lp->ll_tv->v_type != VAR_LIST\n\t\t&& lp->ll_tv->v_type != VAR_DICT\n\t\t&& lp->ll_tv->v_type != VAR_BLOB)\n\t{\n\t    if (!quiet)\n\t\temsg(_(e_can_only_index_list_dictionary_or_blob));\n\t    return NULL;\n\t}\n\n\t// a NULL list/blob works like an empty list/blob, allocate one now.\n\tif (lp->ll_tv->v_type == VAR_LIST && lp->ll_tv->vval.v_list == NULL)\n\t    rettv_list_alloc(lp->ll_tv);\n\telse if (lp->ll_tv->v_type == VAR_BLOB\n\t\t\t\t\t     && lp->ll_tv->vval.v_blob == NULL)\n\t    rettv_blob_alloc(lp->ll_tv);\n\n\tif (lp->ll_range)\n\t{\n\t    if (!quiet)\n\t\temsg(_(e_slice_must_come_last));\n\t    return NULL;\n\t}\n\n\tif (vim9script && lp->ll_valtype == NULL\n\t\t&& v != NULL\n\t\t&& lp->ll_tv == &v->di_tv\n\t\t&& ht != NULL && ht == get_script_local_ht())\n\t{\n\t    svar_T  *sv = find_typval_in_script(lp->ll_tv, 0, TRUE);\n\n\t    // Vim9 script local variable: get the type\n\t    if (sv != NULL)\n\t\tlp->ll_valtype = sv->sv_type;\n\t}\n\n\tlen = -1;\n\tif (*p == '.')\n\t{\n\t    key = p + 1;\n\t    for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; ++len)\n\t\t;\n\t    if (len == 0)\n\t    {\n\t\tif (!quiet)\n\t\t    emsg(_(e_cannot_use_empty_key_for_dictionary));\n\t\treturn NULL;\n\t    }\n\t    p = key + len;\n\t}\n\telse\n\t{\n\t    // Get the index [expr] or the first index [expr: ].\n\t    p = skipwhite(p + 1);\n\t    if (*p == ':')\n\t\tempty1 = TRUE;\n\t    else\n\t    {\n\t\tempty1 = FALSE;\n\t\tif (eval1(&p, &var1, &EVALARG_EVALUATE) == FAIL)  // recursive!\n\t\t    return NULL;\n\t\tif (tv_get_string_chk(&var1) == NULL)\n\t\t{\n\t\t    // not a number or string\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\n\t    // Optionally get the second index [ :expr].\n\t    if (*p == ':')\n\t    {\n\t\tif (lp->ll_tv->v_type == VAR_DICT)\n\t\t{\n\t\t    if (!quiet)\n\t\t\temsg(_(e_cannot_slice_dictionary));\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tif (rettv != NULL\n\t\t\t&& !(rettv->v_type == VAR_LIST\n\t\t\t\t\t\t && rettv->vval.v_list != NULL)\n\t\t\t&& !(rettv->v_type == VAR_BLOB\n\t\t\t\t\t\t&& rettv->vval.v_blob != NULL))\n\t\t{\n\t\t    if (!quiet)\n\t\t\temsg(_(e_slice_requires_list_or_blob_value));\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tp = skipwhite(p + 1);\n\t\tif (*p == ']')\n\t\t    lp->ll_empty2 = TRUE;\n\t\telse\n\t\t{\n\t\t    lp->ll_empty2 = FALSE;\n\t\t    // recursive!\n\t\t    if (eval1(&p, &var2, &EVALARG_EVALUATE) == FAIL)\n\t\t    {\n\t\t\tclear_tv(&var1);\n\t\t\treturn NULL;\n\t\t    }\n\t\t    if (tv_get_string_chk(&var2) == NULL)\n\t\t    {\n\t\t\t// not a number or string\n\t\t\tclear_tv(&var1);\n\t\t\tclear_tv(&var2);\n\t\t\treturn NULL;\n\t\t    }\n\t\t}\n\t\tlp->ll_range = TRUE;\n\t    }\n\t    else\n\t\tlp->ll_range = FALSE;\n\n\t    if (*p != ']')\n\t    {\n\t\tif (!quiet)\n\t\t    emsg(_(e_missing_closing_square_brace));\n\t\tclear_tv(&var1);\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\n\t    // Skip to past ']'.\n\t    ++p;\n\t}\n\n\tif (lp->ll_tv->v_type == VAR_DICT)\n\t{\n\t    if (len == -1)\n\t    {\n\t\t// \"[key]\": get key from \"var1\"\n\t\tkey = tv_get_string_chk(&var1);\t// is number or string\n\t\tif (key == NULL)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t    }\n\t    lp->ll_list = NULL;\n\n\t    // a NULL dict is equivalent with an empty dict\n\t    if (lp->ll_tv->vval.v_dict == NULL)\n\t    {\n\t\tlp->ll_tv->vval.v_dict = dict_alloc();\n\t\tif (lp->ll_tv->vval.v_dict == NULL)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\t++lp->ll_tv->vval.v_dict->dv_refcount;\n\t    }\n\t    lp->ll_dict = lp->ll_tv->vval.v_dict;\n\n\t    lp->ll_di = dict_find(lp->ll_dict, key, len);\n\n\t    // When assigning to a scope dictionary check that a function and\n\t    // variable name is valid (only variable name unless it is l: or\n\t    // g: dictionary). Disallow overwriting a builtin function.\n\t    if (rettv != NULL && lp->ll_dict->dv_scope != 0)\n\t    {\n\t\tint prevval;\n\t\tint wrong;\n\n\t\tif (len != -1)\n\t\t{\n\t\t    prevval = key[len];\n\t\t    key[len] = NUL;\n\t\t}\n\t\telse\n\t\t    prevval = 0; // avoid compiler warning\n\t\twrong = (lp->ll_dict->dv_scope == VAR_DEF_SCOPE\n\t\t\t       && rettv->v_type == VAR_FUNC\n\t\t\t       && var_wrong_func_name(key, lp->ll_di == NULL))\n\t\t\t|| !valid_varname(key, -1, TRUE);\n\t\tif (len != -1)\n\t\t    key[len] = prevval;\n\t\tif (wrong)\n\t\t{\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t    }\n\n\t    if (lp->ll_valtype != NULL)\n\t\t// use the type of the member\n\t\tlp->ll_valtype = lp->ll_valtype->tt_member;\n\n\t    if (lp->ll_di == NULL)\n\t    {\n\t\t// Can't add \"v:\" or \"a:\" variable.\n\t\tif (lp->ll_dict == get_vimvar_dict()\n\t\t\t || &lp->ll_dict->dv_hashtab == get_funccal_args_ht())\n\t\t{\n\t\t    semsg(_(e_illegal_variable_name_str), name);\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\n\t\t// Key does not exist in dict: may need to add it.\n\t\tif (*p == '[' || *p == '.' || unlet)\n\t\t{\n\t\t    if (!quiet)\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\t\t    clear_tv(&var1);\n\t\t    return NULL;\n\t\t}\n\t\tif (len == -1)\n\t\t    lp->ll_newkey = vim_strsave(key);\n\t\telse\n\t\t    lp->ll_newkey = vim_strnsave(key, len);\n\t\tclear_tv(&var1);\n\t\tif (lp->ll_newkey == NULL)\n\t\t    p = NULL;\n\t\tbreak;\n\t    }\n\t    // existing variable, need to check if it can be changed\n\t    else if ((flags & GLV_READ_ONLY) == 0\n\t\t\t&& (var_check_ro(lp->ll_di->di_flags, name, FALSE)\n\t\t\t  || var_check_lock(lp->ll_di->di_flags, name, FALSE)))\n\t    {\n\t\tclear_tv(&var1);\n\t\treturn NULL;\n\t    }\n\n\t    clear_tv(&var1);\n\t    lp->ll_tv = &lp->ll_di->di_tv;\n\t}\n\telse if (lp->ll_tv->v_type == VAR_BLOB)\n\t{\n\t    long bloblen = blob_len(lp->ll_tv->vval.v_blob);\n\n\t    /*\n\t     * Get the number and item for the only or first index of the List.\n\t     */\n\t    if (empty1)\n\t\tlp->ll_n1 = 0;\n\t    else\n\t\t// is number or string\n\t\tlp->ll_n1 = (long)tv_get_number(&var1);\n\t    clear_tv(&var1);\n\n\t    if (check_blob_index(bloblen, lp->ll_n1, quiet) == FAIL)\n\t    {\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\t    if (lp->ll_range && !lp->ll_empty2)\n\t    {\n\t\tlp->ll_n2 = (long)tv_get_number(&var2);\n\t\tclear_tv(&var2);\n\t\tif (check_blob_range(bloblen, lp->ll_n1, lp->ll_n2, quiet)\n\t\t\t\t\t\t\t\t       == FAIL)\n\t\t    return NULL;\n\t    }\n\t    lp->ll_blob = lp->ll_tv->vval.v_blob;\n\t    lp->ll_tv = NULL;\n\t    break;\n\t}\n\telse\n\t{\n\t    /*\n\t     * Get the number and item for the only or first index of the List.\n\t     */\n\t    if (empty1)\n\t\tlp->ll_n1 = 0;\n\t    else\n\t\t// is number or string\n\t\tlp->ll_n1 = (long)tv_get_number(&var1);\n\t    clear_tv(&var1);\n\n\t    lp->ll_dict = NULL;\n\t    lp->ll_list = lp->ll_tv->vval.v_list;\n\t    lp->ll_li = check_range_index_one(lp->ll_list, &lp->ll_n1,\n\t\t\t\t     (flags & GLV_ASSIGN_WITH_OP) == 0, quiet);\n\t    if (lp->ll_li == NULL)\n\t    {\n\t\tclear_tv(&var2);\n\t\treturn NULL;\n\t    }\n\n\t    if (lp->ll_valtype != NULL)\n\t\t// use the type of the member\n\t\tlp->ll_valtype = lp->ll_valtype->tt_member;\n\n\t    /*\n\t     * May need to find the item or absolute index for the second\n\t     * index of a range.\n\t     * When no index given: \"lp->ll_empty2\" is TRUE.\n\t     * Otherwise \"lp->ll_n2\" is set to the second index.\n\t     */\n\t    if (lp->ll_range && !lp->ll_empty2)\n\t    {\n\t\tlp->ll_n2 = (long)tv_get_number(&var2);\n\t\t\t\t\t\t    // is number or string\n\t\tclear_tv(&var2);\n\t\tif (check_range_index_two(lp->ll_list,\n\t\t\t\t\t    &lp->ll_n1, lp->ll_li,\n\t\t\t\t\t    &lp->ll_n2, quiet) == FAIL)\n\t\t    return NULL;\n\t    }\n\n\t    lp->ll_tv = &lp->ll_li->li_tv;\n\t}\n    }\n\n    clear_tv(&var1);\n    lp->ll_name_end = p;\n    return p;\n}\n\n/*\n * Clear lval \"lp\" that was filled by get_lval().\n */\n    void\nclear_lval(lval_T *lp)\n{\n    vim_free(lp->ll_exp_name);\n    vim_free(lp->ll_newkey);\n}\n\n/*\n * Set a variable that was parsed by get_lval() to \"rettv\".\n * \"endp\" points to just after the parsed name.\n * \"op\" is NULL, \"+\" for \"+=\", \"-\" for \"-=\", \"*\" for \"*=\", \"/\" for \"/=\",\n * \"%\" for \"%=\", \".\" for \".=\" or \"=\" for \"=\".\n */\n    void\nset_var_lval(\n    lval_T\t*lp,\n    char_u\t*endp,\n    typval_T\t*rettv,\n    int\t\tcopy,\n    int\t\tflags,\t    // ASSIGN_CONST, ASSIGN_NO_DECL\n    char_u\t*op,\n    int\t\tvar_idx)    // index for \"let [a, b] = list\"\n{\n    int\t\tcc;\n    dictitem_T\t*di;\n\n    if (lp->ll_tv == NULL)\n    {\n\tcc = *endp;\n\t*endp = NUL;\n\tif (in_vim9script() && check_reserved_name(lp->ll_name) == FAIL)\n\t    return;\n\n\tif (lp->ll_blob != NULL)\n\t{\n\t    int\t    error = FALSE, val;\n\n\t    if (op != NULL && *op != '=')\n\t    {\n\t\tsemsg(_(e_wrong_variable_type_for_str_equal), op);\n\t\treturn;\n\t    }\n\t    if (value_check_lock(lp->ll_blob->bv_lock, lp->ll_name, FALSE))\n\t\treturn;\n\n\t    if (lp->ll_range && rettv->v_type == VAR_BLOB)\n\t    {\n\t\tif (lp->ll_empty2)\n\t\t    lp->ll_n2 = blob_len(lp->ll_blob) - 1;\n\n\t\tif (blob_set_range(lp->ll_blob, lp->ll_n1, lp->ll_n2,\n\t\t\t\t\t\t\t\trettv) == FAIL)\n\t\t    return;\n\t    }\n\t    else\n\t    {\n\t\tval = (int)tv_get_number_chk(rettv, &error);\n\t\tif (!error)\n\t\t    blob_set_append(lp->ll_blob, lp->ll_n1, val);\n\t    }\n\t}\n\telse if (op != NULL && *op != '=')\n\t{\n\t    typval_T tv;\n\n\t    if ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t    {\n\t\temsg(_(e_cannot_modify_existing_variable));\n\t\t*endp = cc;\n\t\treturn;\n\t    }\n\n\t    // handle +=, -=, *=, /=, %= and .=\n\t    di = NULL;\n\t    if (eval_variable(lp->ll_name, (int)STRLEN(lp->ll_name),\n\t\t\t\t lp->ll_sid, &tv, &di, EVAL_VAR_VERBOSE) == OK)\n\t    {\n\t\tif ((di == NULL\n\t\t\t || (!var_check_ro(di->di_flags, lp->ll_name, FALSE)\n\t\t\t   && !tv_check_lock(&di->di_tv, lp->ll_name, FALSE)))\n\t\t\t&& tv_op(&tv, rettv, op) == OK)\n\t\t    set_var_const(lp->ll_name, lp->ll_sid, NULL, &tv, FALSE,\n\t\t\t\t\t\t\t    ASSIGN_NO_DECL, 0);\n\t\tclear_tv(&tv);\n\t    }\n\t}\n\telse\n\t{\n\t    if (lp->ll_type != NULL && check_typval_arg_type(lp->ll_type, rettv,\n\t\t\t\t\t\t\t      NULL, 0) == FAIL)\n\t\treturn;\n\t    set_var_const(lp->ll_name, lp->ll_sid, lp->ll_type, rettv, copy,\n\t\t\t\t\t\t\t       flags, var_idx);\n\t}\n\t*endp = cc;\n    }\n    else if (value_check_lock(lp->ll_newkey == NULL\n\t\t? lp->ll_tv->v_lock\n\t\t: lp->ll_tv->vval.v_dict->dv_lock, lp->ll_name, FALSE))\n\t;\n    else if (lp->ll_range)\n    {\n\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t{\n\t    emsg(_(e_cannot_lock_range));\n\t    return;\n\t}\n\n\t(void)list_assign_range(lp->ll_list, rettv->vval.v_list,\n\t\t\t lp->ll_n1, lp->ll_n2, lp->ll_empty2, op, lp->ll_name);\n    }\n    else\n    {\n\t/*\n\t * Assign to a List or Dictionary item.\n\t */\n\tif ((flags & (ASSIGN_CONST | ASSIGN_FINAL))\n\t\t\t\t\t     && (flags & ASSIGN_FOR_LOOP) == 0)\n\t{\n\t    emsg(_(e_cannot_lock_list_or_dict));\n\t    return;\n\t}\n\n\tif (lp->ll_valtype != NULL\n\t\t    && check_typval_arg_type(lp->ll_valtype, rettv,\n\t\t\t\t\t\t\t      NULL, 0) == FAIL)\n\t    return;\n\n\tif (lp->ll_newkey != NULL)\n\t{\n\t    if (op != NULL && *op != '=')\n\t    {\n\t\tsemsg(_(e_key_not_present_in_dictionary), lp->ll_newkey);\n\t\treturn;\n\t    }\n\t    if (dict_wrong_func_name(lp->ll_tv->vval.v_dict, rettv,\n\t\t\t\t\t\t\t\tlp->ll_newkey))\n\t\treturn;\n\n\t    // Need to add an item to the Dictionary.\n\t    di = dictitem_alloc(lp->ll_newkey);\n\t    if (di == NULL)\n\t\treturn;\n\t    if (dict_add(lp->ll_tv->vval.v_dict, di) == FAIL)\n\t    {\n\t\tvim_free(di);\n\t\treturn;\n\t    }\n\t    lp->ll_tv = &di->di_tv;\n\t}\n\telse if (op != NULL && *op != '=')\n\t{\n\t    tv_op(lp->ll_tv, rettv, op);\n\t    return;\n\t}\n\telse\n\t    clear_tv(lp->ll_tv);\n\n\t/*\n\t * Assign the value to the variable or list item.\n\t */\n\tif (copy)\n\t    copy_tv(rettv, lp->ll_tv);\n\telse\n\t{\n\t    *lp->ll_tv = *rettv;\n\t    lp->ll_tv->v_lock = 0;\n\t    init_tv(rettv);\n\t}\n    }\n}\n\n/*\n * Handle \"tv1 += tv2\", \"tv1 -= tv2\", \"tv1 *= tv2\", \"tv1 /= tv2\", \"tv1 %= tv2\"\n * and \"tv1 .= tv2\"\n * Returns OK or FAIL.\n */\n    int\ntv_op(typval_T *tv1, typval_T *tv2, char_u *op)\n{\n    varnumber_T\tn;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*s;\n    int\t\tfailed = FALSE;\n\n    // Can't do anything with a Funcref or Dict on the right.\n    // v:true and friends only work with \"..=\".\n    if (tv2->v_type != VAR_FUNC && tv2->v_type != VAR_DICT\n\t\t    && ((tv2->v_type != VAR_BOOL && tv2->v_type != VAR_SPECIAL)\n\t\t\t\t\t\t\t\t|| *op == '.'))\n    {\n\tswitch (tv1->v_type)\n\t{\n\t    case VAR_UNKNOWN:\n\t    case VAR_ANY:\n\t    case VAR_VOID:\n\t    case VAR_DICT:\n\t    case VAR_FUNC:\n\t    case VAR_PARTIAL:\n\t    case VAR_BOOL:\n\t    case VAR_SPECIAL:\n\t    case VAR_JOB:\n\t    case VAR_CHANNEL:\n\t    case VAR_INSTR:\n\t\tbreak;\n\n\t    case VAR_BLOB:\n\t\tif (*op != '+' || tv2->v_type != VAR_BLOB)\n\t\t    break;\n\t\t// BLOB += BLOB\n\t\tif (tv1->vval.v_blob != NULL && tv2->vval.v_blob != NULL)\n\t\t{\n\t\t    blob_T  *b1 = tv1->vval.v_blob;\n\t\t    blob_T  *b2 = tv2->vval.v_blob;\n\t\t    int\ti, len = blob_len(b2);\n\t\t    for (i = 0; i < len; i++)\n\t\t\tga_append(&b1->bv_ga, blob_get(b2, i));\n\t\t}\n\t\treturn OK;\n\n\t    case VAR_LIST:\n\t\tif (*op != '+' || tv2->v_type != VAR_LIST)\n\t\t    break;\n\t\t// List += List\n\t\tif (tv2->vval.v_list != NULL)\n\t\t{\n\t\t    if (tv1->vval.v_list == NULL)\n\t\t    {\n\t\t\ttv1->vval.v_list = tv2->vval.v_list;\n\t\t\t++tv1->vval.v_list->lv_refcount;\n\t\t    }\n\t\t    else\n\t\t\tlist_extend(tv1->vval.v_list, tv2->vval.v_list, NULL);\n\t\t}\n\t\treturn OK;\n\n\t    case VAR_NUMBER:\n\t    case VAR_STRING:\n\t\tif (tv2->v_type == VAR_LIST)\n\t\t    break;\n\t\tif (vim_strchr((char_u *)\"+-*/%\", *op) != NULL)\n\t\t{\n\t\t    // nr += nr , nr -= nr , nr *=nr , nr /= nr , nr %= nr\n\t\t    n = tv_get_number(tv1);\n#ifdef FEAT_FLOAT\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t    {\n\t\t\tfloat_T f = n;\n\n\t\t\tif (*op == '%')\n\t\t\t    break;\n\t\t\tswitch (*op)\n\t\t\t{\n\t\t\t    case '+': f += tv2->vval.v_float; break;\n\t\t\t    case '-': f -= tv2->vval.v_float; break;\n\t\t\t    case '*': f *= tv2->vval.v_float; break;\n\t\t\t    case '/': f /= tv2->vval.v_float; break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\ttv1->v_type = VAR_FLOAT;\n\t\t\ttv1->vval.v_float = f;\n\t\t    }\n\t\t    else\n#endif\n\t\t    {\n\t\t\tswitch (*op)\n\t\t\t{\n\t\t\t    case '+': n += tv_get_number(tv2); break;\n\t\t\t    case '-': n -= tv_get_number(tv2); break;\n\t\t\t    case '*': n *= tv_get_number(tv2); break;\n\t\t\t    case '/': n = num_divide(n, tv_get_number(tv2),\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\t    case '%': n = num_modulus(n, tv_get_number(tv2),\n\t\t\t\t\t\t\t       &failed); break;\n\t\t\t}\n\t\t\tclear_tv(tv1);\n\t\t\ttv1->v_type = VAR_NUMBER;\n\t\t\ttv1->vval.v_number = n;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t\tbreak;\n\n\t\t    // str .= str\n\t\t    s = tv_get_string(tv1);\n\t\t    s = concat_str(s, tv_get_string_buf(tv2, numbuf));\n\t\t    clear_tv(tv1);\n\t\t    tv1->v_type = VAR_STRING;\n\t\t    tv1->vval.v_string = s;\n\t\t}\n\t\treturn failed ? FAIL : OK;\n\n\t    case VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t\t{\n\t\t    float_T f;\n\n\t\t    if (*op == '%' || *op == '.'\n\t\t\t\t   || (tv2->v_type != VAR_FLOAT\n\t\t\t\t    && tv2->v_type != VAR_NUMBER\n\t\t\t\t    && tv2->v_type != VAR_STRING))\n\t\t\tbreak;\n\t\t    if (tv2->v_type == VAR_FLOAT)\n\t\t\tf = tv2->vval.v_float;\n\t\t    else\n\t\t\tf = tv_get_number(tv2);\n\t\t    switch (*op)\n\t\t    {\n\t\t\tcase '+': tv1->vval.v_float += f; break;\n\t\t\tcase '-': tv1->vval.v_float -= f; break;\n\t\t\tcase '*': tv1->vval.v_float *= f; break;\n\t\t\tcase '/': tv1->vval.v_float /= f; break;\n\t\t    }\n\t\t}\n#endif\n\t\treturn OK;\n\t}\n    }\n\n    semsg(_(e_wrong_variable_type_for_str_equal), op);\n    return FAIL;\n}\n\n/*\n * Evaluate the expression used in a \":for var in expr\" command.\n * \"arg\" points to \"var\".\n * Set \"*errp\" to TRUE for an error, FALSE otherwise;\n * Return a pointer that holds the info.  Null when there is an error.\n */\n    void *\neval_for_line(\n    char_u\t*arg,\n    int\t\t*errp,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg)\n{\n    forinfo_T\t*fi;\n    char_u\t*var_list_end;\n    char_u\t*expr;\n    typval_T\ttv;\n    list_T\t*l;\n    int\t\tskip = !(evalarg->eval_flags & EVAL_EVALUATE);\n\n    *errp = TRUE;\t// default: there is an error\n\n    fi = ALLOC_CLEAR_ONE(forinfo_T);\n    if (fi == NULL)\n\treturn NULL;\n\n    var_list_end = skip_var_list(arg, TRUE, &fi->fi_varcount,\n\t\t\t\t\t\t     &fi->fi_semicolon, FALSE);\n    if (var_list_end == NULL)\n\treturn fi;\n\n    expr = skipwhite_and_linebreak(var_list_end, evalarg);\n    if (expr[0] != 'i' || expr[1] != 'n'\n\t\t\t\t  || !(expr[2] == NUL || VIM_ISWHITE(expr[2])))\n    {\n\tif (in_vim9script() && *expr == ':' && expr != var_list_end)\n\t    semsg(_(e_no_white_space_allowed_before_colon_str), expr);\n\telse\n\t    emsg(_(e_missing_in_after_for));\n\treturn fi;\n    }\n\n    if (skip)\n\t++emsg_skip;\n    expr = skipwhite_and_linebreak(expr + 2, evalarg);\n    if (eval0(expr, &tv, eap, evalarg) == OK)\n    {\n\t*errp = FALSE;\n\tif (!skip)\n\t{\n\t    if (tv.v_type == VAR_LIST)\n\t    {\n\t\tl = tv.vval.v_list;\n\t\tif (l == NULL)\n\t\t{\n\t\t    // a null list is like an empty list: do nothing\n\t\t    clear_tv(&tv);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Need a real list here.\n\t\t    CHECK_LIST_MATERIALIZE(l);\n\n\t\t    // No need to increment the refcount, it's already set for\n\t\t    // the list being used in \"tv\".\n\t\t    fi->fi_list = l;\n\t\t    list_add_watch(l, &fi->fi_lw);\n\t\t    fi->fi_lw.lw_item = l->lv_first;\n\t\t}\n\t    }\n\t    else if (tv.v_type == VAR_BLOB)\n\t    {\n\t\tfi->fi_bi = 0;\n\t\tif (tv.vval.v_blob != NULL)\n\t\t{\n\t\t    typval_T btv;\n\n\t\t    // Make a copy, so that the iteration still works when the\n\t\t    // blob is changed.\n\t\t    blob_copy(tv.vval.v_blob, &btv);\n\t\t    fi->fi_blob = btv.vval.v_blob;\n\t\t}\n\t\tclear_tv(&tv);\n\t    }\n\t    else if (tv.v_type == VAR_STRING)\n\t    {\n\t\tfi->fi_byte_idx = 0;\n\t\tfi->fi_string = tv.vval.v_string;\n\t\ttv.vval.v_string = NULL;\n\t\tif (fi->fi_string == NULL)\n\t\t    fi->fi_string = vim_strsave((char_u *)\"\");\n\t    }\n\t    else\n\t    {\n\t\temsg(_(e_string_list_or_blob_required));\n\t\tclear_tv(&tv);\n\t    }\n\t}\n    }\n    if (skip)\n\t--emsg_skip;\n    fi->fi_break_count = evalarg->eval_break_count;\n\n    return fi;\n}\n\n/*\n * Used when looping over a :for line, skip the \"in expr\" part.\n */\n    void\nskip_for_lines(void *fi_void, evalarg_T *evalarg)\n{\n    forinfo_T\t*fi = (forinfo_T *)fi_void;\n    int\t\ti;\n\n    for (i = 0; i < fi->fi_break_count; ++i)\n\teval_next_line(NULL, evalarg);\n}\n\n/*\n * Use the first item in a \":for\" list.  Advance to the next.\n * Assign the values to the variable (list).  \"arg\" points to the first one.\n * Return TRUE when a valid item was found, FALSE when at end of list or\n * something wrong.\n */\n    int\nnext_for_item(void *fi_void, char_u *arg)\n{\n    forinfo_T\t*fi = (forinfo_T *)fi_void;\n    int\t\tresult;\n    int\t\tflag = ASSIGN_FOR_LOOP | (in_vim9script()\n\t\t\t ? (ASSIGN_FINAL\n\t\t\t     // first round: error if variable exists\n\t\t\t     | (fi->fi_bi == 0 ? 0 : ASSIGN_DECL)\n\t\t\t     | ASSIGN_NO_MEMBER_TYPE)\n\t\t\t : 0);\n    listitem_T\t*item;\n    int\t\tskip_assign = in_vim9script() && arg[0] == '_'\n\t\t\t\t\t\t      && !eval_isnamec(arg[1]);\n\n    if (fi->fi_blob != NULL)\n    {\n\ttypval_T\ttv;\n\n\tif (fi->fi_bi >= blob_len(fi->fi_blob))\n\t    return FALSE;\n\ttv.v_type = VAR_NUMBER;\n\ttv.v_lock = VAR_FIXED;\n\ttv.vval.v_number = blob_get(fi->fi_blob, fi->fi_bi);\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    return TRUE;\n\treturn ex_let_vars(arg, &tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t    fi->fi_varcount, flag, NULL) == OK;\n    }\n\n    if (fi->fi_string != NULL)\n    {\n\ttypval_T\ttv;\n\tint\t\tlen;\n\n\tlen = mb_ptr2len(fi->fi_string + fi->fi_byte_idx);\n\tif (len == 0)\n\t    return FALSE;\n\ttv.v_type = VAR_STRING;\n\ttv.v_lock = VAR_FIXED;\n\ttv.vval.v_string = vim_strnsave(fi->fi_string + fi->fi_byte_idx, len);\n\tfi->fi_byte_idx += len;\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    result = TRUE;\n\telse\n\t    result = ex_let_vars(arg, &tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t    fi->fi_varcount, flag, NULL) == OK;\n\tvim_free(tv.vval.v_string);\n\treturn result;\n    }\n\n    item = fi->fi_lw.lw_item;\n    if (item == NULL)\n\tresult = FALSE;\n    else\n    {\n\tfi->fi_lw.lw_item = item->li_next;\n\t++fi->fi_bi;\n\tif (skip_assign)\n\t    result = TRUE;\n\telse\n\t    result = (ex_let_vars(arg, &item->li_tv, TRUE, fi->fi_semicolon,\n\t\t\t\t\t   fi->fi_varcount, flag, NULL) == OK);\n    }\n    return result;\n}\n\n/*\n * Free the structure used to store info used by \":for\".\n */\n    void\nfree_for_info(void *fi_void)\n{\n    forinfo_T    *fi = (forinfo_T *)fi_void;\n\n    if (fi == NULL)\n\treturn;\n    if (fi->fi_list != NULL)\n    {\n\tlist_rem_watch(fi->fi_list, &fi->fi_lw);\n\tlist_unref(fi->fi_list);\n    }\n    else if (fi->fi_blob != NULL)\n\tblob_unref(fi->fi_blob);\n    else\n\tvim_free(fi->fi_string);\n    vim_free(fi);\n}\n\n    void\nset_context_for_expression(\n    expand_T\t*xp,\n    char_u\t*arg,\n    cmdidx_T\tcmdidx)\n{\n    int\t\thas_expr = cmdidx != CMD_let && cmdidx != CMD_var;\n    int\t\tc;\n    char_u\t*p;\n\n    if (cmdidx == CMD_let || cmdidx == CMD_var\n\t\t\t\t || cmdidx == CMD_const || cmdidx == CMD_final)\n    {\n\txp->xp_context = EXPAND_USER_VARS;\n\tif (vim_strpbrk(arg, (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\") == NULL)\n\t{\n\t    // \":let var1 var2 ...\": find last space.\n\t    for (p = arg + STRLEN(arg); p >= arg; )\n\t    {\n\t\txp->xp_pattern = p;\n\t\tMB_PTR_BACK(arg, p);\n\t\tif (VIM_ISWHITE(*p))\n\t\t    break;\n\t    }\n\t    return;\n\t}\n    }\n    else\n\txp->xp_context = cmdidx == CMD_call ? EXPAND_FUNCTIONS\n\t\t\t\t\t\t\t  : EXPAND_EXPRESSION;\n    while ((xp->xp_pattern = vim_strpbrk(arg,\n\t\t\t\t  (char_u *)\"\\\"'+-*/%.=!?~|&$([<>,#\")) != NULL)\n    {\n\tc = *xp->xp_pattern;\n\tif (c == '&')\n\t{\n\t    c = xp->xp_pattern[1];\n\t    if (c == '&')\n\t    {\n\t\t++xp->xp_pattern;\n\t\txp->xp_context = has_expr ? EXPAND_EXPRESSION : EXPAND_NOTHING;\n\t    }\n\t    else if (c != ' ')\n\t    {\n\t\txp->xp_context = EXPAND_SETTINGS;\n\t\tif ((c == 'l' || c == 'g') && xp->xp_pattern[2] == ':')\n\t\t    xp->xp_pattern += 2;\n\n\t    }\n\t}\n\telse if (c == '$')\n\t{\n\t    // environment variable\n\t    xp->xp_context = EXPAND_ENV_VARS;\n\t}\n\telse if (c == '=')\n\t{\n\t    has_expr = TRUE;\n\t    xp->xp_context = EXPAND_EXPRESSION;\n\t}\n\telse if (c == '#'\n\t\t&& xp->xp_context == EXPAND_EXPRESSION)\n\t{\n\t    // Autoload function/variable contains '#'.\n\t    break;\n\t}\n\telse if ((c == '<' || c == '#')\n\t\t&& xp->xp_context == EXPAND_FUNCTIONS\n\t\t&& vim_strchr(xp->xp_pattern, '(') == NULL)\n\t{\n\t    // Function name can start with \"<SNR>\" and contain '#'.\n\t    break;\n\t}\n\telse if (has_expr)\n\t{\n\t    if (c == '\"')\t    // string\n\t    {\n\t\twhile ((c = *++xp->xp_pattern) != NUL && c != '\"')\n\t\t    if (c == '\\\\' && xp->xp_pattern[1] != NUL)\n\t\t\t++xp->xp_pattern;\n\t\txp->xp_context = EXPAND_NOTHING;\n\t    }\n\t    else if (c == '\\'')\t    // literal string\n\t    {\n\t\t// Trick: '' is like stopping and starting a literal string.\n\t\twhile ((c = *++xp->xp_pattern) != NUL && c != '\\'')\n\t\t    /* skip */ ;\n\t\txp->xp_context = EXPAND_NOTHING;\n\t    }\n\t    else if (c == '|')\n\t    {\n\t\tif (xp->xp_pattern[1] == '|')\n\t\t{\n\t\t    ++xp->xp_pattern;\n\t\t    xp->xp_context = EXPAND_EXPRESSION;\n\t\t}\n\t\telse\n\t\t    xp->xp_context = EXPAND_COMMANDS;\n\t    }\n\t    else\n\t\txp->xp_context = EXPAND_EXPRESSION;\n\t}\n\telse\n\t    // Doesn't look like something valid, expand as an expression\n\t    // anyway.\n\t    xp->xp_context = EXPAND_EXPRESSION;\n\targ = xp->xp_pattern;\n\tif (*arg != NUL)\n\t    while ((c = *++arg) != NUL && (c == ' ' || c == '\\t'))\n\t\t/* skip */ ;\n    }\n\n    // \":exe one two\" completes \"two\"\n    if ((cmdidx == CMD_execute\n\t\t|| cmdidx == CMD_echo\n\t\t|| cmdidx == CMD_echon\n\t\t|| cmdidx == CMD_echomsg)\n\t    && xp->xp_context == EXPAND_EXPRESSION)\n    {\n\tfor (;;)\n\t{\n\t    char_u *n = skiptowhite(arg);\n\n\t    if (n == arg || IS_WHITE_OR_NUL(*skipwhite(n)))\n\t\tbreak;\n\t    arg = skipwhite(n);\n\t}\n    }\n\n    xp->xp_pattern = arg;\n}\n\n/*\n * Return TRUE if \"pat\" matches \"text\".\n * Does not use 'cpo' and always uses 'magic'.\n */\n    int\npattern_match(char_u *pat, char_u *text, int ic)\n{\n    int\t\tmatches = FALSE;\n    char_u\t*save_cpo;\n    regmatch_T\tregmatch;\n\n    // avoid 'l' flag in 'cpoptions'\n    save_cpo = p_cpo;\n    p_cpo = empty_option;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog != NULL)\n    {\n\tregmatch.rm_ic = ic;\n\tmatches = vim_regexec_nl(&regmatch, text, (colnr_T)0);\n\tvim_regfree(regmatch.regprog);\n    }\n    p_cpo = save_cpo;\n    return matches;\n}\n\n/*\n * Handle a name followed by \"(\".  Both for just \"name(arg)\" and for\n * \"expr->name(arg)\".\n * Returns OK or FAIL.\n */\n    static int\neval_func(\n\tchar_u\t    **arg,\t// points to \"(\", will be advanced\n\tevalarg_T   *evalarg,\n\tchar_u\t    *name,\n\tint\t    name_len,\n\ttypval_T    *rettv,\n\tint\t    flags,\n\ttypval_T    *basetv)\t// \"expr\" for \"expr->name(arg)\"\n{\n    int\t\tevaluate = flags & EVAL_EVALUATE;\n    char_u\t*s = name;\n    int\t\tlen = name_len;\n    partial_T\t*partial;\n    int\t\tret = OK;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n\n    if (!evaluate)\n\tcheck_vars(s, len);\n\n    // If \"s\" is the name of a variable of type VAR_FUNC\n    // use its contents.\n    s = deref_func_name(s, &len, &partial,\n\t\t in_vim9script() ? &type : NULL, !evaluate, FALSE, &found_var);\n\n    // Need to make a copy, in case evaluating the arguments makes\n    // the name invalid.\n    s = vim_strsave(s);\n    if (s == NULL || (evaluate && (*s == NUL || (flags & EVAL_CONSTANT))))\n\tret = FAIL;\n    else\n    {\n\tfuncexe_T funcexe;\n\n\t// Invoke the function.\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = evaluate;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_basetv = basetv;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\tret = get_func_tv(s, len, rettv, arg, evalarg, &funcexe);\n    }\n    vim_free(s);\n\n    // If evaluate is FALSE rettv->v_type was not set in\n    // get_func_tv, but it's needed in handle_subscript() to parse\n    // what follows. So set it here.\n    if (rettv->v_type == VAR_UNKNOWN && !evaluate && **arg == '(')\n    {\n\trettv->vval.v_string = NULL;\n\trettv->v_type = VAR_FUNC;\n    }\n\n    // Stop the expression evaluation when immediately\n    // aborting on error, or when an interrupt occurred or\n    // an exception was thrown but not caught.\n    if (evaluate && aborting())\n    {\n\tif (ret == OK)\n\t    clear_tv(rettv);\n\tret = FAIL;\n    }\n    return ret;\n}\n\n/*\n * After a NL, skip over empty lines and comment-only lines.\n */\n    static char_u *\nnewline_skip_comments(char_u *arg)\n{\n    char_u *p = arg + 1;\n\n    for (;;)\n    {\n\tp = skipwhite(p);\n\n\tif (*p == NUL)\n\t    break;\n\tif (vim9_comment_start(p))\n\t{\n\t    char_u *nl = vim_strchr(p, NL);\n\n\t    if (nl == NULL)\n\t\t    break;\n\t    p = nl;\n\t}\n\tif (*p != NL)\n\t    break;\n\t++p;  // skip another NL\n    }\n    return p;\n}\n\n/*\n * Get the next line source line without advancing.  But do skip over comment\n * lines.\n * Only called for Vim9 script.\n */\n    static char_u *\ngetline_peek_skip_comments(evalarg_T *evalarg)\n{\n    for (;;)\n    {\n\tchar_u *next = getline_peek(evalarg->eval_getline,\n\t\t\t\t\t\t\t evalarg->eval_cookie);\n\tchar_u *p;\n\n\tif (next == NULL)\n\t    break;\n\tp = skipwhite(next);\n\tif (*p != NUL && !vim9_comment_start(p))\n\t    return next;\n\tif (eval_next_line(NULL, evalarg) == NULL)\n\t    break;\n    }\n    return NULL;\n}\n\n/*\n * If inside Vim9 script, \"arg\" points to the end of a line (ignoring a #\n * comment) and there is a next line, return the next line (skipping blanks)\n * and set \"getnext\".\n * Otherwise return the next non-white at or after \"arg\" and set \"getnext\" to\n * FALSE.\n * \"arg\" must point somewhere inside a line, not at the start.\n */\n    char_u *\neval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext)\n{\n    char_u *p = skipwhite(arg);\n\n    *getnext = FALSE;\n    if (in_vim9script()\n\t    && evalarg != NULL\n\t    && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL\n\t\t\t\t\t\t\t\t   || *p == NL)\n\t    && (*p == NUL || *p == NL\n\t\t\t     || (vim9_comment_start(p) && VIM_ISWHITE(p[-1]))))\n    {\n\tchar_u *next;\n\n\tif (*p == NL)\n\t    next = newline_skip_comments(p);\n\telse if (evalarg->eval_cookie != NULL)\n\t    next = getline_peek_skip_comments(evalarg);\n\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = TRUE;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}\n\n/*\n * To be called after eval_next_non_blank() sets \"getnext\" to TRUE.\n * Only called for Vim9 script.\n */\n    char_u *\neval_next_line(char_u *arg, evalarg_T *evalarg)\n{\n    garray_T\t*gap = &evalarg->eval_ga;\n    char_u\t*line;\n\n    if (arg != NULL)\n    {\n\tif (*arg == NL)\n\t    return newline_skip_comments(arg);\n\t// Truncate before a trailing comment, so that concatenating the lines\n\t// won't turn the rest into a comment.\n\tif (*skipwhite(arg) == '#')\n\t    *arg = NUL;\n    }\n\n    if (evalarg->eval_cookie != NULL)\n\tline = evalarg->eval_getline(0, evalarg->eval_cookie, 0,\n\t\t\t\t\t\t\t   GETLINE_CONCAT_ALL);\n    else\n\tline = next_line_from_context(evalarg->eval_cctx, TRUE);\n    if (line == NULL)\n\treturn NULL;\n\n    ++evalarg->eval_break_count;\n    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)\n    {\n\tchar_u *p = skipwhite(line);\n\n\t// Going to concatenate the lines after parsing.  For an empty or\n\t// comment line use an empty string.\n\tif (*p == NUL || vim9_comment_start(p))\n\t{\n\t    vim_free(line);\n\t    line = vim_strsave((char_u *)\"\");\n\t}\n\n\t((char_u **)gap->ga_data)[gap->ga_len] = line;\n\t++gap->ga_len;\n    }\n    else if (evalarg->eval_cookie != NULL)\n    {\n\tfree_eval_tofree_later(evalarg);\n\tevalarg->eval_tofree = line;\n    }\n\n    // Advanced to the next line, \"arg\" no longer points into the previous\n    // line.\n    evalarg->eval_using_cmdline = FALSE;\n    return skipwhite(line);\n}\n\n/*\n * Call eval_next_non_blank() and get the next line if needed.\n */\n    char_u *\nskipwhite_and_linebreak(char_u *arg, evalarg_T *evalarg)\n{\n    int\t    getnext;\n    char_u  *p = skipwhite_and_nl(arg);\n\n    if (evalarg == NULL)\n\treturn skipwhite(arg);\n    eval_next_non_blank(p, evalarg, &getnext);\n    if (getnext)\n\treturn eval_next_line(arg, evalarg);\n    return p;\n}\n\n/*\n * The \"evaluate\" argument: When FALSE, the argument is only parsed but not\n * executed.  The function may return OK, but the rettv will be of type\n * VAR_UNKNOWN.  The function still returns FAIL for a syntax error.\n */\n\n/*\n * Handle zero level expression.\n * This calls eval1() and handles error message and nextcmd.\n * Put the result in \"rettv\" when returning OK and \"evaluate\" is TRUE.\n * Note: \"rettv.v_lock\" is not set.\n * \"evalarg\" can be NULL, EVALARG_EVALUATE or a pointer.\n * Return OK or FAIL.\n */\n    int\neval0(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg)\n{\n    return eval0_retarg(arg, rettv, eap, evalarg, NULL);\n}\n\n/*\n * Like eval0() but when \"retarg\" is not NULL store the pointer to after the\n * expression and don't check what comes after the expression.\n */\n    int\neval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n\n    if (ret != FAIL)\n    {\n\texpr_end = p;\n\tp = skipwhite(p);\n\n\t// In Vim9 script a command block is not split at NL characters for\n\t// commands using an expression argument.  Skip over a '#' comment to\n\t// check for a following NL.  Require white space before the '#'.\n\tif (in_vim9script() && p > expr_end && retarg == NULL)\n\t    while (*p == '#')\n\t    {\n\t\tchar_u *nl = vim_strchr(p, NL);\n\n\t\tif (nl == NULL)\n\t\t    break;\n\t\tp = skipwhite(nl + 1);\n\t\tif (eap != NULL && *p != NUL)\n\t\t    eap->nextcmd = p;\n\t\tcheck_for_end = FALSE;\n\t    }\n\n\tif (check_for_end)\n\t    end_error = !ends_excmd2(arg, p);\n    }\n\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\t/*\n\t * Report the invalid expression unless the expression evaluation has\n\t * been cancelled due to an aborting error, an interrupt, or an\n\t * exception, or we already gave a more specific error.\n\t * Also check called_emsg for when using assert_fails().\n\t */\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\n\t// Some of the expression may not have been consumed.  Do not check for\n\t// a next command to avoid more errors, unless \"|\" is following, which\n\t// could only be a command separator.\n\tif (eap != NULL && p != NULL\n\t\t\t  &&  skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n\n    return ret;\n}\n\n/*\n * Handle top level expression:\n *\texpr2 ? expr1 : expr1\n *\texpr2 ?? expr1\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Note: \"rettv.v_lock\" is not set.\n *\n * Return OK or FAIL.\n */\n    int\neval1(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u  *p;\n    int\t    getnext;\n\n    CLEAR_POINTER(rettv);\n\n    /*\n     * Get the first variable.\n     */\n    if (eval2(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (*p == '?')\n    {\n\tint\t\top_falsy = p[1] == '?';\n\tint\t\tresult;\n\ttypval_T\tvar2;\n\tevalarg_T\t*evalarg_used = evalarg;\n\tevalarg_T\tlocal_evalarg;\n\tint\t\torig_flags;\n\tint\t\tevaluate;\n\tint\t\tvim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = evalarg_used->eval_flags & EVAL_EVALUATE;\n\n\tif (getnext)\n\t    *arg = eval_next_line(*arg, evalarg_used);\n\telse\n\t{\n\t    if (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t    {\n\t\terror_white_both(p, op_falsy ? 2 : 1);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\n\tresult = FALSE;\n\tif (evaluate)\n\t{\n\t    int\t\terror = FALSE;\n\n\t    if (op_falsy)\n\t\tresult = tv2bool(rettv);\n\t    else if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) != 0)\n\t\tresult = TRUE;\n\t    if (error || !op_falsy || !result)\n\t\tclear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Get the second variable.  Recursive!\n\t */\n\tif (op_falsy)\n\t    ++*arg;\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[1]))\n\t{\n\t    error_white_both(*arg - (op_falsy ? 1 : 0), op_falsy ? 2 : 1);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg_used);\n\tevalarg_used->eval_flags = (op_falsy ? !result : result)\n\t\t\t\t    ? orig_flags : orig_flags & ~EVAL_EVALUATE;\n\tif (eval1(arg, &var2, evalarg_used) == FAIL)\n\t{\n\t    evalarg_used->eval_flags = orig_flags;\n\t    return FAIL;\n\t}\n\tif (!op_falsy || !result)\n\t    *rettv = var2;\n\n\tif (!op_falsy)\n\t{\n\t    /*\n\t     * Check for the \":\".\n\t     */\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t    if (*p != ':')\n\t    {\n\t\temsg(_(e_missing_colon_after_questionmark));\n\t\tif (evaluate && result)\n\t\t    clear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    if (getnext)\n\t\t*arg = eval_next_line(*arg, evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 1);\n\t\t    clear_tv(rettv);\n\t\t    evalarg_used->eval_flags = orig_flags;\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the third variable.  Recursive!\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[1]))\n\t    {\n\t\terror_white_both(*arg, 1);\n\t\tclear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg_used);\n\t    evalarg_used->eval_flags = !result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    if (eval1(arg, &var2, evalarg_used) == FAIL)\n\t    {\n\t\tif (evaluate && result)\n\t\t    clear_tv(rettv);\n\t\tevalarg_used->eval_flags = orig_flags;\n\t\treturn FAIL;\n\t    }\n\t    if (evaluate && !result)\n\t\t*rettv = var2;\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle first level expression:\n *\texpr2 || expr2 || expr2\t    logical OR\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval2(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n\n    /*\n     * Get the first expression.\n     */\n    if (eval3(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Handle the  \"||\" operator.\n     */\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (p[0] == '|' && p[1] == '|')\n    {\n\tevalarg_T   *evalarg_used = evalarg;\n\tevalarg_T   local_evalarg;\n\tint\t    evaluate;\n\tint\t    orig_flags;\n\tlong\t    result = FALSE;\n\ttypval_T    var2;\n\tint\t    error = FALSE;\n\tint\t    vim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = orig_flags & EVAL_EVALUATE;\n\tif (evaluate)\n\t{\n\t    if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) != 0)\n\t\tresult = TRUE;\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Repeat until there is no following \"||\".\n\t */\n\twhile (p[0] == '|' && p[1] == '|')\n\t{\n\t    if (getnext)\n\t\t*arg = eval_next_line(*arg, evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 2);\n\t\t    clear_tv(rettv);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the second variable.\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[2]))\n\t    {\n\t\terror_white_both(*arg, 2);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 2, evalarg_used);\n\t    evalarg_used->eval_flags = !result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    if (eval3(arg, &var2, evalarg_used) == FAIL)\n\t\treturn FAIL;\n\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (evaluate && !result)\n\t    {\n\t\tif (vim9script)\n\t\t    result = tv_get_bool_chk(&var2, &error);\n\t\telse if (tv_get_number_chk(&var2, &error) != 0)\n\t\t    result = TRUE;\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    if (evaluate)\n\t    {\n\t\tif (vim9script)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = result ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = result;\n\t\t}\n\t    }\n\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle second level expression:\n *\texpr3 && expr3 && expr3\t    logical AND\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval3(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n\n    /*\n     * Get the first expression.\n     */\n    if (eval4(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Handle the \"&&\" operator.\n     */\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n    if (p[0] == '&' && p[1] == '&')\n    {\n\tevalarg_T   *evalarg_used = evalarg;\n\tevalarg_T   local_evalarg;\n\tint\t    orig_flags;\n\tint\t    evaluate;\n\tlong\t    result = TRUE;\n\ttypval_T    var2;\n\tint\t    error = FALSE;\n\tint\t    vim9script = in_vim9script();\n\n\tif (evalarg == NULL)\n\t{\n\t    init_evalarg(&local_evalarg);\n\t    evalarg_used = &local_evalarg;\n\t}\n\torig_flags = evalarg_used->eval_flags;\n\tevaluate = orig_flags & EVAL_EVALUATE;\n\tif (evaluate)\n\t{\n\t    if (vim9script)\n\t\tresult = tv_get_bool_chk(rettv, &error);\n\t    else if (tv_get_number_chk(rettv, &error) == 0)\n\t\tresult = FALSE;\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\n\t/*\n\t * Repeat until there is no following \"&&\".\n\t */\n\twhile (p[0] == '&' && p[1] == '&')\n\t{\n\t    if (getnext)\n\t\t*arg = eval_next_line(*arg, evalarg_used);\n\t    else\n\t    {\n\t\tif (evaluate && vim9script && !VIM_ISWHITE(p[-1]))\n\t\t{\n\t\t    error_white_both(p, 2);\n\t\t    clear_tv(rettv);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = p;\n\t    }\n\n\t    /*\n\t     * Get the second variable.\n\t     */\n\t    if (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[2]))\n\t    {\n\t\terror_white_both(*arg, 2);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg + 2, evalarg_used);\n\t    evalarg_used->eval_flags = result ? orig_flags\n\t\t\t\t\t\t : orig_flags & ~EVAL_EVALUATE;\n\t    CLEAR_FIELD(var2);\n\t    if (eval4(arg, &var2, evalarg_used) == FAIL)\n\t\treturn FAIL;\n\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (evaluate && result)\n\t    {\n\t\tif (vim9script)\n\t\t    result = tv_get_bool_chk(&var2, &error);\n\t\telse if (tv_get_number_chk(&var2, &error) == 0)\n\t\t    result = FALSE;\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n\t    }\n\t    if (evaluate)\n\t    {\n\t\tif (vim9script)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = result ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = result;\n\t\t}\n\t    }\n\n\t    p = eval_next_non_blank(*arg, evalarg_used, &getnext);\n\t}\n\n\tif (evalarg == NULL)\n\t    clear_evalarg(&local_evalarg, NULL);\n\telse\n\t    evalarg->eval_flags = orig_flags;\n    }\n\n    return OK;\n}\n\n/*\n * Handle third level expression:\n *\tvar1 == var2\n *\tvar1 =~ var2\n *\tvar1 != var2\n *\tvar1 !~ var2\n *\tvar1 > var2\n *\tvar1 >= var2\n *\tvar1 < var2\n *\tvar1 <= var2\n *\tvar1 is var2\n *\tvar1 isnot var2\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval4(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    char_u\t*p;\n    int\t\tgetnext;\n    exprtype_T\ttype = EXPR_UNKNOWN;\n    int\t\tlen = 2;\n    int\t\ttype_is = FALSE;\n\n    /*\n     * Get the first expression.\n     */\n    if (eval5(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    p = eval_next_non_blank(*arg, evalarg, &getnext);\n\n    type = get_compare_type(p, &len, &type_is);\n\n    /*\n     * If there is a comparative operator, use it.\n     */\n    if (type != EXPR_UNKNOWN)\n    {\n\ttypval_T    var2;\n\tint\t    ic;\n\tint\t    vim9script = in_vim9script();\n\tint\t    evaluate = evalarg == NULL\n\t\t\t\t   ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tlong\t    comp_lnum = SOURCING_LNUM;\n\n\tif (getnext)\n\t{\n\t    *arg = eval_next_line(*arg, evalarg);\n\t    p = *arg;\n\t}\n\telse if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t{\n\t    error_white_both(*arg, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (vim9script && type_is && (p[len] == '?' || p[len] == '#'))\n\t{\n\t    semsg(_(e_invalid_expression_str), p);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\t// extra question mark appended: ignore case\n\tif (p[len] == '?')\n\t{\n\t    ic = TRUE;\n\t    ++len;\n\t}\n\t// extra '#' appended: match case\n\telse if (p[len] == '#')\n\t{\n\t    ic = FALSE;\n\t    ++len;\n\t}\n\t// nothing appended: use 'ignorecase' if not in Vim script\n\telse\n\t    ic = vim9script ? FALSE : p_ic;\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL(p[len]))\n\t{\n\t    error_white_both(p, len);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(p + len, evalarg);\n\tif (eval5(arg, &var2, evalarg) == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\tif (evaluate)\n\t{\n\t    int ret;\n\n\t    // use the line of the comparison for messages\n\t    SOURCING_LNUM = comp_lnum;\n\t    if (vim9script && check_compare_types(type, rettv, &var2) == FAIL)\n\t    {\n\t\tret = FAIL;\n\t\tclear_tv(rettv);\n\t    }\n\t    else\n\t\tret = typval_compare(rettv, &var2, type, ic);\n\t    clear_tv(&var2);\n\t    return ret;\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Make a copy of blob \"tv1\" and append blob \"tv2\".\n */\n    void\neval_addblob(typval_T *tv1, typval_T *tv2)\n{\n    blob_T  *b1 = tv1->vval.v_blob;\n    blob_T  *b2 = tv2->vval.v_blob;\n    blob_T  *b = blob_alloc();\n    int\t    i;\n\n    if (b != NULL)\n    {\n\tfor (i = 0; i < blob_len(b1); i++)\n\t    ga_append(&b->bv_ga, blob_get(b1, i));\n\tfor (i = 0; i < blob_len(b2); i++)\n\t    ga_append(&b->bv_ga, blob_get(b2, i));\n\n\tclear_tv(tv1);\n\trettv_blob_set(tv1, b);\n    }\n}\n\n/*\n * Make a copy of list \"tv1\" and append list \"tv2\".\n */\n    int\neval_addlist(typval_T *tv1, typval_T *tv2)\n{\n    typval_T var3;\n\n    // concatenate Lists\n    if (list_concat(tv1->vval.v_list, tv2->vval.v_list, &var3) == FAIL)\n    {\n\tclear_tv(tv1);\n\tclear_tv(tv2);\n\treturn FAIL;\n    }\n    clear_tv(tv1);\n    *tv1 = var3;\n    return OK;\n}\n\n/*\n * Handle the bitwise left/right shift operator expression:\n *\tvar1 << var2\n *\tvar1 >> var2\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval5(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    /*\n     * Get the first expression.\n     */\n    if (eval6(arg, rettv, evalarg) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '<<' or '>>' is following.\n     */\n    for (;;)\n    {\n\tchar_u\t\t*p;\n\tint\t\tgetnext;\n\texprtype_T\ttype;\n\tint\t\tevaluate;\n\ttypval_T\tvar2;\n\tint\t\tvim9script;\n\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\tif (p[0] == '<' && p[1] == '<')\n\t    type = EXPR_LSHIFT;\n\telse if (p[0] == '>' && p[1] == '>')\n\t    type = EXPR_RSHIFT;\n\telse\n\t    return OK;\n\n\t// Handle a bitwise left or right shift operator\n\tif (rettv->v_type != VAR_NUMBER)\n\t{\n\t    // left operand should be a number\n\t    emsg(_(e_bitshift_ops_must_be_number));\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tvim9script = in_vim9script();\n\tif (getnext)\n\t{\n\t    *arg = eval_next_line(*arg, evalarg);\n\t    p = *arg;\n\t}\n\telse if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t{\n\t    error_white_both(*arg, 2);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL(p[2]))\n\t{\n\t    error_white_both(p, 2);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(p + 2, evalarg);\n\tif (eval6(arg, &var2, evalarg) == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (var2.v_type != VAR_NUMBER || var2.vval.v_number < 0)\n\t{\n\t    // right operand should be a positive number\n\t    if (var2.v_type != VAR_NUMBER)\n\t\temsg(_(e_bitshift_ops_must_be_number));\n\t    else\n\t\temsg(_(e_bitshift_ops_must_be_postive));\n\t    clear_tv(rettv);\n\t    clear_tv(&var2);\n\t    return FAIL;\n\t}\n\n\tif (evaluate)\n\t{\n\t    if (var2.vval.v_number > MAX_LSHIFT_BITS)\n\t\t// shifting more bits than we have always results in zero\n\t\trettv->vval.v_number = 0;\n\t    else if (type == EXPR_LSHIFT)\n\t\trettv->vval.v_number =\n\t\t      (uvarnumber_T)rettv->vval.v_number << var2.vval.v_number;\n\t    else\n\t\trettv->vval.v_number =\n\t\t      (uvarnumber_T)rettv->vval.v_number >> var2.vval.v_number;\n\t}\n\n\tclear_tv(&var2);\n    }\n\n    return OK;\n}\n\n/*\n * Handle fifth level expression:\n *\t+\tnumber addition, concatenation of list or blob\n *\t-\tnumber subtraction\n *\t.\tstring concatenation (if script version is 1)\n *\t..\tstring concatenation\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval6(char_u **arg, typval_T *rettv, evalarg_T *evalarg)\n{\n    /*\n     * Get the first expression.\n     */\n    if (eval7(arg, rettv, evalarg, FALSE) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '+', '-' or '.' is following.\n     */\n    for (;;)\n    {\n\tint\t    evaluate;\n\tint\t    getnext;\n\tchar_u\t    *p;\n\tint\t    op;\n\tint\t    oplen;\n\tint\t    concat;\n\ttypval_T    var2;\n\tint\t    vim9script = in_vim9script();\n\n\t// \".\" is only string concatenation when scriptversion is 1\n\t// \"+=\", \"-=\" and \"..=\" are assignments\n\t// \"++\" and \"--\" on the next line are a separate command.\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\top = *p;\n\tconcat = op == '.' && (*(p + 1) == '.' || in_old_script(2));\n\tif ((op != '+' && op != '-' && !concat) || p[1] == '='\n\t\t\t\t\t       || (p[1] == '.' && p[2] == '='))\n\t    break;\n\tif (getnext && (op == '+' || op == '-') && p[0] == p[1])\n\t    break;\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\toplen = (concat && p[1] == '.') ? 2 : 1;\n\tif (getnext)\n\t    *arg = eval_next_line(*arg, evalarg);\n\telse\n\t{\n\t    if (evaluate && vim9script && !VIM_ISWHITE(**arg))\n\t    {\n\t\terror_white_both(*arg, oplen);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\tif ((op != '+' || (rettv->v_type != VAR_LIST\n\t\t\t\t\t\t && rettv->v_type != VAR_BLOB))\n#ifdef FEAT_FLOAT\n\t\t&& (op == '.' || rettv->v_type != VAR_FLOAT)\n#endif\n\t\t&& evaluate)\n\t{\n\t    int\t\terror = FALSE;\n\n\t    // For \"list + ...\", an illegal use of the first operand as\n\t    // a number cannot be determined before evaluating the 2nd\n\t    // operand: if this is also a list, all is ok.\n\t    // For \"something . ...\", \"something - ...\" or \"non-list + ...\",\n\t    // we know that the first operand needs to be a string or number\n\t    // without evaluating the 2nd operand.  So check before to avoid\n\t    // side effects after an error.\n\t    if (op != '.')\n\t\ttv_get_number_chk(rettv, &error);\n\t    if ((op == '.' && tv_get_string_chk(rettv) == NULL) || error)\n\t    {\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && vim9script && !IS_WHITE_OR_NUL((*arg)[oplen]))\n\t{\n\t    error_white_both(*arg, oplen);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + oplen, evalarg);\n\tif (eval7(arg, &var2, evalarg, !vim9script && op == '.') == FAIL)\n\t{\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\n\tif (evaluate)\n\t{\n\t    /*\n\t     * Compute the result.\n\t     */\n\t    if (op == '.')\n\t    {\n\t\tchar_u\tbuf1[NUMBUFLEN], buf2[NUMBUFLEN];\n\t\tchar_u\t*s1 = tv_get_string_buf(rettv, buf1);\n\t\tchar_u\t*s2 = NULL;\n\n\t\tif (vim9script && (var2.v_type == VAR_VOID\n\t\t\t|| var2.v_type == VAR_CHANNEL\n\t\t\t|| var2.v_type == VAR_JOB))\n\t\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t   vartype_name(var2.v_type));\n#ifdef FEAT_FLOAT\n\t\telse if (vim9script && var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    vim_snprintf((char *)buf2, NUMBUFLEN, \"%g\",\n\t\t\t\t\t\t\t    var2.vval.v_float);\n\t\t    s2 = buf2;\n\t\t}\n#endif\n\t\telse\n\t\t    s2 = tv_get_string_buf_chk(&var2, buf2);\n\t\tif (s2 == NULL)\t\t// type error ?\n\t\t{\n\t\t    clear_tv(rettv);\n\t\t    clear_tv(&var2);\n\t\t    return FAIL;\n\t\t}\n\t\tp = concat_str(s1, s2);\n\t\tclear_tv(rettv);\n\t\trettv->v_type = VAR_STRING;\n\t\trettv->vval.v_string = p;\n\t    }\n\t    else if (op == '+' && rettv->v_type == VAR_BLOB\n\t\t\t\t\t\t   && var2.v_type == VAR_BLOB)\n\t\teval_addblob(rettv, &var2);\n\t    else if (op == '+' && rettv->v_type == VAR_LIST\n\t\t\t\t\t\t   && var2.v_type == VAR_LIST)\n\t    {\n\t\tif (eval_addlist(rettv, &var2) == FAIL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tint\t\terror = FALSE;\n\t\tvarnumber_T\tn1, n2;\n#ifdef FEAT_FLOAT\n\t\tfloat_T\t    f1 = 0, f2 = 0;\n\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t{\n\t\t    f1 = rettv->vval.v_float;\n\t\t    n1 = 0;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    n1 = tv_get_number_chk(rettv, &error);\n\t\t    if (error)\n\t\t    {\n\t\t\t// This can only happen for \"list + non-list\" or\n\t\t\t// \"blob + non-blob\".  For \"non-list + ...\" or\n\t\t\t// \"something - ...\", we returned before evaluating the\n\t\t\t// 2nd operand.\n\t\t\tclear_tv(rettv);\n\t\t\tclear_tv(&var2);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (var2.v_type == VAR_FLOAT)\n\t\t\tf1 = n1;\n#endif\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    f2 = var2.vval.v_float;\n\t\t    n2 = 0;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    n2 = tv_get_number_chk(&var2, &error);\n\t\t    if (error)\n\t\t    {\n\t\t\tclear_tv(rettv);\n\t\t\tclear_tv(&var2);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_FLOAT\n\t\t    if (rettv->v_type == VAR_FLOAT)\n\t\t\tf2 = n2;\n#endif\n\t\t}\n\t\tclear_tv(rettv);\n\n#ifdef FEAT_FLOAT\n\t\t// If there is a float on either side the result is a float.\n\t\tif (rettv->v_type == VAR_FLOAT || var2.v_type == VAR_FLOAT)\n\t\t{\n\t\t    if (op == '+')\n\t\t\tf1 = f1 + f2;\n\t\t    else\n\t\t\tf1 = f1 - f2;\n\t\t    rettv->v_type = VAR_FLOAT;\n\t\t    rettv->vval.v_float = f1;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    if (op == '+')\n\t\t\tn1 = n1 + n2;\n\t\t    else\n\t\t\tn1 = n1 - n2;\n\t\t    rettv->v_type = VAR_NUMBER;\n\t\t    rettv->vval.v_number = n1;\n\t\t}\n\t    }\n\t    clear_tv(&var2);\n\t}\n    }\n    return OK;\n}\n\n/*\n * Handle sixth level expression:\n *\t*\tnumber multiplication\n *\t/\tnumber division\n *\t%\tnumber modulo\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval7(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)  // after \".\" operator\n{\n#ifdef FEAT_FLOAT\n    int\t    use_float = FALSE;\n#endif\n\n    /*\n     * Get the first expression.\n     */\n    if (eval8(arg, rettv, evalarg, want_string) == FAIL)\n\treturn FAIL;\n\n    /*\n     * Repeat computing, until no '*', '/' or '%' is following.\n     */\n    for (;;)\n    {\n\tint\t    evaluate;\n\tint\t    getnext;\n\ttypval_T    var2;\n\tchar_u\t    *p;\n\tint\t    op;\n\tvarnumber_T n1, n2;\n#ifdef FEAT_FLOAT\n\tfloat_T\t    f1, f2;\n#endif\n\tint\t    error;\n\n\t// \"*=\", \"/=\" and \"%=\" are assignments\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\top = *p;\n\tif ((op != '*' && op != '/' && op != '%') || p[1] == '=')\n\t    break;\n\n\tevaluate = evalarg == NULL ? 0 : (evalarg->eval_flags & EVAL_EVALUATE);\n\tif (getnext)\n\t    *arg = eval_next_line(*arg, evalarg);\n\telse\n\t{\n\t    if (evaluate && in_vim9script() && !VIM_ISWHITE(**arg))\n\t    {\n\t\terror_white_both(*arg, 1);\n\t\tclear_tv(rettv);\n\t\treturn FAIL;\n\t    }\n\t    *arg = p;\n\t}\n\n#ifdef FEAT_FLOAT\n\tf1 = 0;\n\tf2 = 0;\n#endif\n\terror = FALSE;\n\tif (evaluate)\n\t{\n#ifdef FEAT_FLOAT\n\t    if (rettv->v_type == VAR_FLOAT)\n\t    {\n\t\tf1 = rettv->vval.v_float;\n\t\tuse_float = TRUE;\n\t\tn1 = 0;\n\t    }\n\t    else\n#endif\n\t\tn1 = tv_get_number_chk(rettv, &error);\n\t    clear_tv(rettv);\n\t    if (error)\n\t\treturn FAIL;\n\t}\n\telse\n\t    n1 = 0;\n\n\t/*\n\t * Get the second variable.\n\t */\n\tif (evaluate && in_vim9script() && !IS_WHITE_OR_NUL((*arg)[1]))\n\t{\n\t    error_white_both(*arg, 1);\n\t    clear_tv(rettv);\n\t    return FAIL;\n\t}\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\tif (eval8(arg, &var2, evalarg, FALSE) == FAIL)\n\t    return FAIL;\n\n\tif (evaluate)\n\t{\n#ifdef FEAT_FLOAT\n\t    if (var2.v_type == VAR_FLOAT)\n\t    {\n\t\tif (!use_float)\n\t\t{\n\t\t    f1 = n1;\n\t\t    use_float = TRUE;\n\t\t}\n\t\tf2 = var2.vval.v_float;\n\t\tn2 = 0;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tn2 = tv_get_number_chk(&var2, &error);\n\t\tclear_tv(&var2);\n\t\tif (error)\n\t\t    return FAIL;\n#ifdef FEAT_FLOAT\n\t\tif (use_float)\n\t\t    f2 = n2;\n#endif\n\t    }\n\n\t    /*\n\t     * Compute the result.\n\t     * When either side is a float the result is a float.\n\t     */\n#ifdef FEAT_FLOAT\n\t    if (use_float)\n\t    {\n\t\tif (op == '*')\n\t\t    f1 = f1 * f2;\n\t\telse if (op == '/')\n\t\t{\n# ifdef VMS\n\t\t    // VMS crashes on divide by zero, work around it\n\t\t    if (f2 == 0.0)\n\t\t    {\n\t\t\tif (f1 == 0)\n\t\t\t    f1 = -1 * __F_FLT_MAX - 1L;   // similar to NaN\n\t\t\telse if (f1 < 0)\n\t\t\t    f1 = -1 * __F_FLT_MAX;\n\t\t\telse\n\t\t\t    f1 = __F_FLT_MAX;\n\t\t    }\n\t\t    else\n\t\t\tf1 = f1 / f2;\n# else\n\t\t    // We rely on the floating point library to handle divide\n\t\t    // by zero to result in \"inf\" and not a crash.\n\t\t    f1 = f1 / f2;\n# endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    emsg(_(e_cannot_use_percent_with_float));\n\t\t    return FAIL;\n\t\t}\n\t\trettv->v_type = VAR_FLOAT;\n\t\trettv->vval.v_float = f1;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tint\t    failed = FALSE;\n\n\t\tif (op == '*')\n\t\t    n1 = n1 * n2;\n\t\telse if (op == '/')\n\t\t    n1 = num_divide(n1, n2, &failed);\n\t\telse\n\t\t    n1 = num_modulus(n1, n2, &failed);\n\t\tif (failed)\n\t\t    return FAIL;\n\n\t\trettv->v_type = VAR_NUMBER;\n\t\trettv->vval.v_number = n1;\n\t    }\n\t}\n    }\n\n    return OK;\n}\n\n/*\n * Handle a type cast before a base level expression.\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n * Return OK or FAIL.\n */\n    static int\neval8(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    type_T\t*want_type = NULL;\n    garray_T\ttype_list;\t    // list of pointers to allocated types\n    int\t\tres;\n    int\t\tevaluate = evalarg == NULL ? 0\n\t\t\t\t       : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    // Recognize <type> in Vim9 script only.\n    if (in_vim9script() && **arg == '<' && eval_isnamec1((*arg)[1])\n\t\t\t\t\t     && STRNCMP(*arg, \"<SNR>\", 5) != 0)\n    {\n\t++*arg;\n\tga_init2(&type_list, sizeof(type_T *), 10);\n\twant_type = parse_type(arg, &type_list, TRUE);\n\tif (want_type == NULL && (evaluate || **arg != '>'))\n\t{\n\t    clear_type_list(&type_list);\n\t    return FAIL;\n\t}\n\n\tif (**arg != '>')\n\t{\n\t    if (*skipwhite(*arg) == '>')\n\t\tsemsg(_(e_no_white_space_allowed_before_str_str), \">\", *arg);\n\t    else\n\t\temsg(_(e_missing_gt));\n\t    clear_type_list(&type_list);\n\t    return FAIL;\n\t}\n\t++*arg;\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n    }\n\n    res = eval9(arg, rettv, evalarg, want_string);\n\n    if (want_type != NULL && evaluate)\n    {\n\tif (res == OK)\n\t{\n\t    type_T *actual = typval2type(rettv, get_copyID(), &type_list,\n\t\t\t\t\t\t\t       TVTT_DO_MEMBER);\n\n\t    if (!equal_type(want_type, actual, 0))\n\t    {\n\t\tif (want_type == &t_bool && actual != &t_bool\n\t\t\t\t\t&& (actual->tt_flags & TTFLAG_BOOL_OK))\n\t\t{\n\t\t    int n = tv2bool(rettv);\n\n\t\t    // can use \"0\" and \"1\" for boolean in some places\n\t\t    clear_tv(rettv);\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = n ? VVAL_TRUE : VVAL_FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    where_T where = WHERE_INIT;\n\n\t\t    where.wt_variable = TRUE;\n\t\t    res = check_type(want_type, actual, TRUE, where);\n\t\t}\n\t    }\n\t}\n\tclear_type_list(&type_list);\n    }\n\n    return res;\n}\n\n    int\neval_leader(char_u **arg, int vim9)\n{\n    char_u\t*s = *arg;\n    char_u\t*p = *arg;\n\n    while (*p == '!' || *p == '-' || *p == '+')\n    {\n\tchar_u *n = skipwhite(p + 1);\n\n\t// ++, --, -+ and +- are not accepted in Vim9 script\n\tif (vim9 && (*p == '-' || *p == '+') && (*n == '-' || *n == '+'))\n\t{\n\t    semsg(_(e_invalid_expression_str), s);\n\t    return FAIL;\n\t}\n\tp = n;\n    }\n    *arg = p;\n    return OK;\n}\n\n/*\n * Check for a predefined value \"true\", \"false\" and \"null.*\".\n * Return OK when recognized.\n */\n    int\nhandle_predefined(char_u *s, int len, typval_T *rettv)\n{\n    switch (len)\n    {\n\tcase 4: if (STRNCMP(s, \"true\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_TRUE;\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s, \"null\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 5: if (STRNCMP(s, \"false\", 5) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BOOL;\n\t\t    rettv->vval.v_number = VVAL_FALSE;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 8: if (STRNCMP(s, \"null_job\", 8) == 0)\n\t\t{\n#ifdef FEAT_JOB_CHANNEL\n\t\t    rettv->v_type = VAR_JOB;\n\t\t    rettv->vval.v_job = NULL;\n#else\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n#endif\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 9:\n\t\tif (STRNCMP(s, \"null_\", 5) != 0)\n\t\t    break;\n\t\tif (STRNCMP(s + 5, \"list\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_LIST;\n\t\t    rettv->vval.v_list = NULL;\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s + 5, \"dict\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_DICT;\n\t\t    rettv->vval.v_dict = NULL;\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s + 5, \"blob\", 4) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_BLOB;\n\t\t    rettv->vval.v_blob = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 11: if (STRNCMP(s, \"null_string\", 11) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_STRING;\n\t\t    rettv->vval.v_string = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 12:\n\t\tif (STRNCMP(s, \"null_channel\", 12) == 0)\n\t\t{\n#ifdef FEAT_JOB_CHANNEL\n\t\t    rettv->v_type = VAR_CHANNEL;\n\t\t    rettv->vval.v_channel = NULL;\n#else\n\t\t    rettv->v_type = VAR_SPECIAL;\n\t\t    rettv->vval.v_number = VVAL_NULL;\n#endif\n\t\t    return OK;\n\t\t}\n\t\tif (STRNCMP(s, \"null_partial\", 12) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_PARTIAL;\n\t\t    rettv->vval.v_partial = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n\tcase 13: if (STRNCMP(s, \"null_function\", 13) == 0)\n\t\t{\n\t\t    rettv->v_type = VAR_FUNC;\n\t\t    rettv->vval.v_string = NULL;\n\t\t    return OK;\n\t\t}\n\t\tbreak;\n    }\n    return FAIL;\n}\n\n/*\n * Handle sixth level expression:\n *  number\t\tnumber constant\n *  0zFFFFFFFF\t\tBlob constant\n *  \"string\"\t\tstring constant\n *  'string'\t\tliteral string constant\n *  &option-name\toption value\n *  @r\t\t\tregister contents\n *  identifier\t\tvariable value\n *  function()\t\tfunction call\n *  $VAR\t\tenvironment variable\n *  (expression)\tnested expression\n *  [expr, expr]\tList\n *  {arg, arg -> expr}\tLambda\n *  {key: val, key: val}   Dictionary\n *  #{key: val, key: val}  Dictionary with literal keys\n *\n *  Also handle:\n *  ! in front\t\tlogical NOT\n *  - in front\t\tunary minus\n *  + in front\t\tunary plus (ignored)\n *  trailing []\t\tsubscript in String or List\n *  trailing .name\tentry in Dictionary\n *  trailing ->name()\tmethod call\n *\n * \"arg\" must point to the first non-white of the expression.\n * \"arg\" is advanced to just after the recognized expression.\n *\n * Return OK or FAIL.\n */\n    static int\neval9(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\twant_string)\t// after \".\" operator\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tlen;\n    char_u\t*s;\n    char_u\t*name_start = NULL;\n    char_u\t*start_leader, *end_leader;\n    int\t\tret = OK;\n    char_u\t*alias;\n    static int\trecurse = 0;\n    int\t\tvim9script = in_vim9script();\n\n    /*\n     * Initialise variable so that clear_tv() can't mistake this for a\n     * string and free a string that isn't there.\n     */\n    rettv->v_type = VAR_UNKNOWN;\n\n    /*\n     * Skip '!', '-' and '+' characters.  They are handled later.\n     */\n    start_leader = *arg;\n    if (eval_leader(arg, vim9script) == FAIL)\n\treturn FAIL;\n    end_leader = *arg;\n\n    if (**arg == '.' && (!isdigit(*(*arg + 1))\n#ifdef FEAT_FLOAT\n\t    || in_old_script(2)\n#endif\n\t    ))\n    {\n\tsemsg(_(e_invalid_expression_str), *arg);\n\t++*arg;\n\treturn FAIL;\n    }\n\n    // Limit recursion to 1000 levels.  At least at 10000 we run out of stack\n    // and crash.  With MSVC the stack is smaller.\n    if (recurse ==\n#ifdef _MSC_VER\n\t\t    300\n#else\n\t\t    1000\n#endif\n\t\t    )\n    {\n\tsemsg(_(e_expression_too_recursive_str), *arg);\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (**arg)\n    {\n    /*\n     * Number constant.\n     */\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n    case '.':\tret = eval_number(arg, rettv, evaluate, want_string);\n\n\t\t// Apply prefixed \"-\" and \"+\" now.  Matters especially when\n\t\t// \"->\" follows.\n\t\tif (ret == OK && evaluate && end_leader > start_leader\n\t\t\t\t\t\t  && rettv->v_type != VAR_BLOB)\n\t\t    ret = eval9_leader(rettv, TRUE, start_leader, &end_leader);\n\t\tbreak;\n\n    /*\n     * String constant: \"string\".\n     */\n    case '\"':\tret = eval_string(arg, rettv, evaluate, FALSE);\n\t\tbreak;\n\n    /*\n     * Literal string constant: 'str''ing'.\n     */\n    case '\\'':\tret = eval_lit_string(arg, rettv, evaluate, FALSE);\n\t\tbreak;\n\n    /*\n     * List: [expr, expr]\n     */\n    case '[':\tret = eval_list(arg, rettv, evalarg, TRUE);\n\t\tbreak;\n\n    /*\n     * Dictionary: #{key: val, key: val}\n     */\n    case '#':\tif (vim9script)\n\t\t{\n\t\t    ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE;\n\t\t}\n\t\telse if ((*arg)[1] == '{')\n\t\t{\n\t\t    ++*arg;\n\t\t    ret = eval_dict(arg, rettv, evalarg, TRUE);\n\t\t}\n\t\telse\n\t\t    ret = NOTDONE;\n\t\tbreak;\n\n    /*\n     * Lambda: {arg, arg -> expr}\n     * Dictionary: {'key': val, 'key': val}\n     */\n    case '{':\tif (vim9script)\n\t\t    ret = NOTDONE;\n\t\telse\n\t\t    ret = get_lambda_tv(arg, rettv, vim9script, evalarg);\n\t\tif (ret == NOTDONE)\n\t\t    ret = eval_dict(arg, rettv, evalarg, FALSE);\n\t\tbreak;\n\n    /*\n     * Option value: &name\n     */\n    case '&':\tret = eval_option(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Environment variable: $VAR.\n     * Interpolated string: $\"string\" or $'string'.\n     */\n    case '$':\tif ((*arg)[1] == '\"' || (*arg)[1] == '\\'')\n\t\t    ret = eval_interp_string(arg, rettv, evaluate);\n\t\telse\n\t\t    ret = eval_env_var(arg, rettv, evaluate);\n\t\tbreak;\n\n    /*\n     * Register contents: @r.\n     */\n    case '@':\t++*arg;\n\t\tif (evaluate)\n\t\t{\n\t\t    if (vim9script && IS_WHITE_OR_NUL(**arg))\n\t\t\tsemsg(_(e_syntax_error_at_str), *arg);\n\t\t    else if (vim9script && !valid_yank_reg(**arg, FALSE))\n\t\t\temsg_invreg(**arg);\n\t\t    else\n\t\t    {\n\t\t\trettv->v_type = VAR_STRING;\n\t\t\trettv->vval.v_string = get_reg_contents(**arg,\n\t\t\t\t\t\t\t\tGREG_EXPR_SRC);\n\t\t    }\n\t\t}\n\t\tif (**arg != NUL)\n\t\t    ++*arg;\n\t\tbreak;\n\n    /*\n     * nested expression: (expression).\n     * or lambda: (arg) => expr\n     */\n    case '(':\tret = NOTDONE;\n\t\tif (vim9script)\n\t\t{\n\t\t    ret = get_lambda_tv(arg, rettv, TRUE, evalarg);\n\t\t    if (ret == OK && evaluate)\n\t\t    {\n\t\t\tufunc_T *ufunc = rettv->vval.v_partial->pt_func;\n\n\t\t\t// Compile it here to get the return type.  The return\n\t\t\t// type is optional, when it's missing use t_unknown.\n\t\t\t// This is recognized in compile_return().\n\t\t\tif (ufunc->uf_ret_type->tt_type == VAR_VOID)\n\t\t\t    ufunc->uf_ret_type = &t_unknown;\n\t\t\tif (compile_def_function(ufunc, FALSE,\n\t\t\t\t\tget_compile_type(ufunc), NULL) == FAIL)\n\t\t\t{\n\t\t\t    clear_tv(rettv);\n\t\t\t    ret = FAIL;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (ret == NOTDONE)\n\t\t{\n\t\t    *arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\t\t    ret = eval1(arg, rettv, evalarg);\t// recursive!\n\n\t\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t\t    if (**arg == ')')\n\t\t\t++*arg;\n\t\t    else if (ret == OK)\n\t\t    {\n\t\t\temsg(_(e_missing_closing_paren));\n\t\t\tclear_tv(rettv);\n\t\t\tret = FAIL;\n\t\t    }\n\t\t}\n\t\tbreak;\n\n    default:\tret = NOTDONE;\n\t\tbreak;\n    }\n\n    if (ret == NOTDONE)\n    {\n\t/*\n\t * Must be a variable or function name.\n\t * Can also be a curly-braces kind of name: {expr}.\n\t */\n\ts = *arg;\n\tlen = get_name_len(arg, &alias, evaluate, TRUE);\n\tif (alias != NULL)\n\t    s = alias;\n\n\tif (len <= 0)\n\t    ret = FAIL;\n\telse\n\t{\n\t    int\t    flags = evalarg == NULL ? 0 : evalarg->eval_flags;\n\n\t    if (evaluate && vim9script && len == 1 && *s == '_')\n\t    {\n\t\temsg(_(e_cannot_use_underscore_here));\n\t\tret = FAIL;\n\t    }\n\t    else if (evaluate && vim9script && len > 2\n\t\t\t\t\t\t && s[0] == 's' && s[1] == ':')\n\t    {\n\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str), s);\n\t\tret = FAIL;\n\t    }\n\t    else if ((vim9script ? **arg : *skipwhite(*arg)) == '(')\n\t    {\n\t\t// \"name(...\"  recursive!\n\t\t*arg = skipwhite(*arg);\n\t\tret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);\n\t    }\n\t    else if (flags & EVAL_CONSTANT)\n\t\tret = FAIL;\n\t    else if (evaluate)\n\t    {\n\t\t// get the value of \"true\", \"false\", etc. or a variable\n\t\tret = FAIL;\n\t\tif (vim9script)\n\t\t    ret = handle_predefined(s, len, rettv);\n\t\tif (ret == FAIL)\n\t\t{\n\t\t    name_start = s;\n\t\t    ret = eval_variable(s, len, 0, rettv, NULL,\n\t\t\t\t\t   EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// skip the name\n\t\tcheck_vars(s, len);\n\t\tret = OK;\n\t    }\n\t}\n\tvim_free(alias);\n    }\n\n    // Handle following '[', '(' and '.' for expr[expr], expr.name,\n    // expr(expr), expr->name(expr)\n    if (ret == OK)\n\tret = handle_subscript(arg, name_start, rettv, evalarg, TRUE);\n\n    /*\n     * Apply logical NOT and unary '-', from right to left, ignore '+'.\n     */\n    if (ret == OK && evaluate && end_leader > start_leader)\n\tret = eval9_leader(rettv, FALSE, start_leader, &end_leader);\n\n    --recurse;\n    return ret;\n}\n\n/*\n * Apply the leading \"!\" and \"-\" before an eval9 expression to \"rettv\".\n * When \"numeric_only\" is TRUE only handle \"+\" and \"-\".\n * Adjusts \"end_leaderp\" until it is at \"start_leader\".\n */\n    static int\neval9_leader(\n\ttypval_T    *rettv,\n\tint\t    numeric_only,\n\tchar_u\t    *start_leader,\n\tchar_u\t    **end_leaderp)\n{\n    char_u\t*end_leader = *end_leaderp;\n    int\t\tret = OK;\n    int\t\terror = FALSE;\n    varnumber_T val = 0;\n    vartype_T\ttype = rettv->v_type;\n    int\t\tvim9script = in_vim9script();\n#ifdef FEAT_FLOAT\n    float_T\t    f = 0.0;\n\n    if (rettv->v_type == VAR_FLOAT)\n\tf = rettv->vval.v_float;\n    else\n#endif\n    {\n\twhile (VIM_ISWHITE(end_leader[-1]))\n\t    --end_leader;\n\tif (vim9script && end_leader[-1] == '!')\n\t    val = tv2bool(rettv);\n\telse\n\t    val = tv_get_number_chk(rettv, &error);\n    }\n    if (error)\n    {\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n    {\n\twhile (end_leader > start_leader)\n\t{\n\t    --end_leader;\n\t    if (*end_leader == '!')\n\t    {\n\t\tif (numeric_only)\n\t\t{\n\t\t    ++end_leader;\n\t\t    break;\n\t\t}\n#ifdef FEAT_FLOAT\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t{\n\t\t    if (vim9script)\n\t\t    {\n\t\t\trettv->v_type = VAR_BOOL;\n\t\t\tval = f == 0.0 ? VVAL_TRUE : VVAL_FALSE;\n\t\t    }\n\t\t    else\n\t\t\tf = !f;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    val = !val;\n\t\t    type = VAR_BOOL;\n\t\t}\n\t    }\n\t    else if (*end_leader == '-')\n\t    {\n#ifdef FEAT_FLOAT\n\t\tif (rettv->v_type == VAR_FLOAT)\n\t\t    f = -f;\n\t\telse\n#endif\n\t\t{\n\t\t    val = -val;\n\t\t    type = VAR_NUMBER;\n\t\t}\n\t    }\n\t}\n#ifdef FEAT_FLOAT\n\tif (rettv->v_type == VAR_FLOAT)\n\t{\n\t    clear_tv(rettv);\n\t    rettv->vval.v_float = f;\n\t}\n\telse\n#endif\n\t{\n\t    clear_tv(rettv);\n\t    if (vim9script)\n\t\trettv->v_type = type;\n\t    else\n\t\trettv->v_type = VAR_NUMBER;\n\t    rettv->vval.v_number = val;\n\t}\n    }\n    *end_leaderp = end_leader;\n    return ret;\n}\n\n/*\n * Call the function referred to in \"rettv\".\n */\n    static int\ncall_func_rettv(\n\tchar_u\t    **arg,\n\tevalarg_T   *evalarg,\n\ttypval_T    *rettv,\n\tint\t    evaluate,\n\tdict_T\t    *selfdict,\n\ttypval_T    *basetv)\n{\n    partial_T\t*pt = NULL;\n    funcexe_T\tfuncexe;\n    typval_T\tfunctv;\n    char_u\t*s;\n    int\t\tret;\n\n    // need to copy the funcref so that we can clear rettv\n    if (evaluate)\n    {\n\tfunctv = *rettv;\n\trettv->v_type = VAR_UNKNOWN;\n\n\t// Invoke the function.  Recursive!\n\tif (functv.v_type == VAR_PARTIAL)\n\t{\n\t    pt = functv.vval.v_partial;\n\t    s = partial_name(pt);\n\t}\n\telse\n\t{\n\t    s = functv.vval.v_string;\n\t    if (s == NULL || *s == NUL)\n\t    {\n\t\temsg(_(e_empty_function_name));\n\t\tret = FAIL;\n\t\tgoto theend;\n\t    }\n\t}\n    }\n    else\n\ts = (char_u *)\"\";\n\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_firstline = curwin->w_cursor.lnum;\n    funcexe.fe_lastline = curwin->w_cursor.lnum;\n    funcexe.fe_evaluate = evaluate;\n    funcexe.fe_partial = pt;\n    funcexe.fe_selfdict = selfdict;\n    funcexe.fe_basetv = basetv;\n    ret = get_func_tv(s, -1, rettv, arg, evalarg, &funcexe);\n\ntheend:\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&functv);\n\n    return ret;\n}\n\n/*\n * Evaluate \"->method()\".\n * \"*arg\" points to \"method\".\n * Returns FAIL or OK. \"*arg\" is advanced to after the ')'.\n */\n    static int\neval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (**arg == '{')\n    {\n\t// ->{lambda}()\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t// ->(lambda)()\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ')')\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    return FAIL;\n\t}\n\tif (rettv->v_type != VAR_STRING && rettv->v_type != VAR_FUNC\n\t\t\t\t\t       && rettv->v_type != VAR_PARTIAL)\n\t{\n\t    emsg(_(e_string_or_function_required_for_arrow_parens_expr));\n\t    return FAIL;\n\t}\n\t++*arg;\n    }\n    if (ret != OK)\n\treturn FAIL;\n\n    if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n\n    return ret;\n}\n\n/*\n * Evaluate \"->method()\".\n * \"*arg\" points to \"method\".\n * Returns FAIL or OK. \"*arg\" is advanced to after the ')'.\n */\n    static int\neval_method(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    char_u\t*name;\n    long\tlen;\n    char_u\t*alias;\n    char_u\t*tofree = NULL;\n    typval_T\tbase = *rettv;\n    int\t\tret = OK;\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    name = *arg;\n    len = get_name_len(arg, &alias, evaluate, TRUE);\n    if (alias != NULL)\n\tname = alias;\n\n    if (len <= 0)\n    {\n\tif (verbose)\n\t    emsg(_(e_missing_name_after_method));\n\tret = FAIL;\n    }\n    else\n    {\n\tchar_u *paren;\n\n\t// If there is no \"(\" immediately following, but there is further on,\n\t// it can be \"import.Func()\", \"dict.Func()\", \"list[nr]\", etc.\n\t// Does not handle anything where \"(\" is part of the expression.\n\t*arg = skipwhite(*arg);\n\n\tif (**arg != '(' && alias == NULL\n\t\t\t\t    && (paren = vim_strchr(*arg, '(')) != NULL)\n\t{\n\t    char_u *deref;\n\n\t    *arg = name;\n\t    *paren = NUL;\n\t    deref = deref_function_name(arg, &tofree, evalarg, verbose);\n\t    if (deref == NULL)\n\t    {\n\t\t*arg = name + len;\n\t\tret = FAIL;\n\t    }\n\t    else\n\t    {\n\t\tname = deref;\n\t\tlen = (long)STRLEN(name);\n\t    }\n\t    *paren = '(';\n\t}\n\n\tif (ret == OK)\n\t{\n\t    *arg = skipwhite(*arg);\n\n\t    if (**arg != '(')\n\t    {\n\t\tif (verbose)\n\t\t    semsg(_(e_missing_parenthesis_str), name);\n\t\tret = FAIL;\n\t    }\n\t    else if (VIM_ISWHITE((*arg)[-1]))\n\t    {\n\t\tif (verbose)\n\t\t    emsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\tret = FAIL;\n\t    }\n\t    else\n\t\tret = eval_func(arg, evalarg, name, len, rettv,\n\t\t\t\t\t  evaluate ? EVAL_EVALUATE : 0, &base);\n\t}\n    }\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n    vim_free(tofree);\n\n    return ret;\n}\n\n/*\n * Evaluate an \"[expr]\" or \"[expr:expr]\" index.  Also \"dict.key\".\n * \"*arg\" points to the '[' or '.'.\n * Returns FAIL or OK. \"*arg\" is advanced to after the ']'.\n */\n    static int\neval_index(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tempty1 = FALSE, empty2 = FALSE;\n    typval_T\tvar1, var2;\n    int\t\trange = FALSE;\n    char_u\t*key = NULL;\n    int\t\tkeylen = -1;\n    int\t\tvim9script = in_vim9script();\n\n    if (check_can_index(rettv, evaluate, verbose) == FAIL)\n\treturn FAIL;\n\n    init_tv(&var1);\n    init_tv(&var2);\n    if (**arg == '.')\n    {\n\t/*\n\t * dict.name\n\t */\n\tkey = *arg + 1;\n\tfor (keylen = 0; eval_isdictc(key[keylen]); ++keylen)\n\t    ;\n\tif (keylen == 0)\n\t    return FAIL;\n\t*arg = key + keylen;\n    }\n    else\n    {\n\t/*\n\t * something[idx]\n\t *\n\t * Get the (first) variable from inside the [].\n\t */\n\t*arg = skipwhite_and_linebreak(*arg + 1, evalarg);\n\tif (**arg == ':')\n\t    empty1 = TRUE;\n\telse if (eval1(arg, &var1, evalarg) == FAIL)\t// recursive!\n\t    return FAIL;\n\telse if (vim9script && **arg == ':')\n\t{\n\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t    \":\", *arg);\n\t    clear_tv(&var1);\n\t    return FAIL;\n\t}\n\telse if (evaluate)\n\t{\n\t    int error = FALSE;\n\n#ifdef FEAT_FLOAT\n\t    // allow for indexing with float\n\t    if (vim9script && rettv->v_type == VAR_DICT\n\t\t\t\t\t\t   && var1.v_type == VAR_FLOAT)\n\t    {\n\t\tvar1.vval.v_string = typval_tostring(&var1, TRUE);\n\t\tvar1.v_type = VAR_STRING;\n\t    }\n#endif\n\t    if (vim9script && rettv->v_type == VAR_LIST)\n\t\ttv_get_number_chk(&var1, &error);\n\t    else\n\t\terror = tv_get_string_chk(&var1) == NULL;\n\t    if (error)\n\t    {\n\t\t// not a number or string\n\t\tclear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t/*\n\t * Get the second variable from inside the [:].\n\t */\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ':')\n\t{\n\t    range = TRUE;\n\t    ++*arg;\n\t    if (vim9script && !IS_WHITE_OR_NUL(**arg) && **arg != ']')\n\t    {\n\t\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\t\":\", *arg - 1);\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\t    if (**arg == ']')\n\t\tempty2 = TRUE;\n\t    else if (eval1(arg, &var2, evalarg) == FAIL)\t// recursive!\n\t    {\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\treturn FAIL;\n\t    }\n\t    else if (evaluate && tv_get_string_chk(&var2) == NULL)\n\t    {\n\t\t// not a number or string\n\t\tif (!empty1)\n\t\t    clear_tv(&var1);\n\t\tclear_tv(&var2);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// Check for the ']'.\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ']')\n\t{\n\t    if (verbose)\n\t\temsg(_(e_missing_closing_square_brace));\n\t    clear_tv(&var1);\n\t    if (range)\n\t\tclear_tv(&var2);\n\t    return FAIL;\n\t}\n\t*arg = *arg + 1;\t// skip over the ']'\n    }\n\n    if (evaluate)\n    {\n\tint res = eval_index_inner(rettv, range,\n\t\tempty1 ? NULL : &var1, empty2 ? NULL : &var2, FALSE,\n\t\tkey, keylen, verbose);\n\n\tif (!empty1)\n\t    clear_tv(&var1);\n\tif (range)\n\t    clear_tv(&var2);\n\treturn res;\n    }\n    return OK;\n}\n\n/*\n * Check if \"rettv\" can have an [index] or [sli:ce]\n */\n    int\ncheck_can_index(typval_T *rettv, int evaluate, int verbose)\n{\n    switch (rettv->v_type)\n    {\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\t    if (verbose)\n\t\temsg(_(e_cannot_index_a_funcref));\n\t    return FAIL;\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    if (verbose)\n\t\temsg(_(e_using_float_as_string));\n\t    return FAIL;\n#endif\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    if (verbose)\n\t\temsg(_(e_cannot_index_special_variable));\n\t    return FAIL;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    if (evaluate)\n\t    {\n\t\temsg(_(e_cannot_index_special_variable));\n\t\treturn FAIL;\n\t    }\n\t    // FALLTHROUGH\n\n\tcase VAR_STRING:\n\tcase VAR_LIST:\n\tcase VAR_DICT:\n\tcase VAR_BLOB:\n\t    break;\n\tcase VAR_NUMBER:\n\t    if (in_vim9script())\n\t\temsg(_(e_cannot_index_number));\n\t    break;\n    }\n    return OK;\n}\n\n/*\n * slice() function\n */\n    void\nf_slice(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && ((argvars[0].v_type != VAR_STRING\n\t\t    && argvars[0].v_type != VAR_LIST\n\t\t    && argvars[0].v_type != VAR_BLOB\n\t\t    && check_for_list_arg(argvars, 0) == FAIL)\n\t\t|| check_for_number_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_number_arg(argvars, 2) == FAIL))\n\treturn;\n\n    if (check_can_index(argvars, TRUE, FALSE) == OK)\n    {\n\tcopy_tv(argvars, rettv);\n\teval_index_inner(rettv, TRUE, argvars + 1,\n\t\targvars[2].v_type == VAR_UNKNOWN ? NULL : argvars + 2,\n\t\tTRUE, NULL, 0, FALSE);\n    }\n}\n\n/*\n * Apply index or range to \"rettv\".\n * \"var1\" is the first index, NULL for [:expr].\n * \"var2\" is the second index, NULL for [expr] and [expr: ]\n * \"exclusive\" is TRUE for slice(): second index is exclusive, use character\n * index for string.\n * Alternatively, \"key\" is not NULL, then key[keylen] is the dict index.\n */\n    int\neval_index_inner(\n\ttypval_T    *rettv,\n\tint\t    is_range,\n\ttypval_T    *var1,\n\ttypval_T    *var2,\n\tint\t    exclusive,\n\tchar_u\t    *key,\n\tint\t    keylen,\n\tint\t    verbose)\n{\n    varnumber_T\t    n1, n2 = 0;\n    long\t    len;\n\n    n1 = 0;\n    if (var1 != NULL && rettv->v_type != VAR_DICT)\n\tn1 = tv_get_number(var1);\n\n    if (is_range)\n    {\n\tif (rettv->v_type == VAR_DICT)\n\t{\n\t    if (verbose)\n\t\temsg(_(e_cannot_slice_dictionary));\n\t    return FAIL;\n\t}\n\tif (var2 != NULL)\n\t    n2 = tv_get_number(var2);\n\telse\n\t    n2 = VARNUM_MAX;\n    }\n\n    switch (rettv->v_type)\n    {\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_FLOAT:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    break; // not evaluating, skipping over subscript\n\n\tcase VAR_NUMBER:\n\tcase VAR_STRING:\n\t    {\n\t\tchar_u\t*s = tv_get_string(rettv);\n\n\t\tlen = (long)STRLEN(s);\n\t\tif (in_vim9script() || exclusive)\n\t\t{\n\t\t    if (is_range)\n\t\t\ts = string_slice(s, n1, n2, exclusive);\n\t\t    else\n\t\t\ts = char_from_string(s, n1);\n\t\t}\n\t\telse if (is_range)\n\t\t{\n\t\t    // The resulting variable is a substring.  If the indexes\n\t\t    // are out of range the result is empty.\n\t\t    if (n1 < 0)\n\t\t    {\n\t\t\tn1 = len + n1;\n\t\t\tif (n1 < 0)\n\t\t\t    n1 = 0;\n\t\t    }\n\t\t    if (n2 < 0)\n\t\t\tn2 = len + n2;\n\t\t    else if (n2 >= len)\n\t\t\tn2 = len;\n\t\t    if (n1 >= len || n2 < 0 || n1 > n2)\n\t\t\ts = NULL;\n\t\t    else\n\t\t\ts = vim_strnsave(s + n1, n2 - n1 + 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // The resulting variable is a string of a single\n\t\t    // character.  If the index is too big or negative the\n\t\t    // result is empty.\n\t\t    if (n1 >= len || n1 < 0)\n\t\t\ts = NULL;\n\t\t    else\n\t\t\ts = vim_strnsave(s + n1, 1);\n\t\t}\n\t\tclear_tv(rettv);\n\t\trettv->v_type = VAR_STRING;\n\t\trettv->vval.v_string = s;\n\t    }\n\t    break;\n\n\tcase VAR_BLOB:\n\t    blob_slice_or_index(rettv->vval.v_blob, is_range, n1, n2,\n\t\t\t\t\t\t\t     exclusive, rettv);\n\t    break;\n\n\tcase VAR_LIST:\n\t    if (var1 == NULL)\n\t\tn1 = 0;\n\t    if (var2 == NULL)\n\t\tn2 = VARNUM_MAX;\n\t    if (list_slice_or_index(rettv->vval.v_list,\n\t\t\t  is_range, n1, n2, exclusive, rettv, verbose) == FAIL)\n\t\treturn FAIL;\n\t    break;\n\n\tcase VAR_DICT:\n\t    {\n\t\tdictitem_T\t*item;\n\t\ttypval_T\ttmp;\n\n\t\tif (key == NULL)\n\t\t{\n\t\t    key = tv_get_string_chk(var1);\n\t\t    if (key == NULL)\n\t\t\treturn FAIL;\n\t\t}\n\n\t\titem = dict_find(rettv->vval.v_dict, key, keylen);\n\n\t\tif (item == NULL)\n\t\t{\n\t\t    if (verbose)\n\t\t    {\n\t\t\tif (keylen > 0)\n\t\t\t    key[keylen] = NUL;\n\t\t\tsemsg(_(e_key_not_present_in_dictionary), key);\n\t\t    }\n\t\t    return FAIL;\n\t\t}\n\n\t\tcopy_tv(&item->di_tv, &tmp);\n\t\tclear_tv(rettv);\n\t\t*rettv = tmp;\n\t    }\n\t    break;\n    }\n    return OK;\n}\n\n/*\n * Return the function name of partial \"pt\".\n */\n    char_u *\npartial_name(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (pt->pt_name != NULL)\n\t    return pt->pt_name;\n\tif (pt->pt_func != NULL)\n\t    return pt->pt_func->uf_name;\n    }\n    return (char_u *)\"\";\n}\n\n    static void\npartial_free(partial_T *pt)\n{\n    int i;\n\n    for (i = 0; i < pt->pt_argc; ++i)\n\tclear_tv(&pt->pt_argv[i]);\n    vim_free(pt->pt_argv);\n    dict_unref(pt->pt_dict);\n    if (pt->pt_name != NULL)\n    {\n\tfunc_unref(pt->pt_name);\n\tvim_free(pt->pt_name);\n    }\n    else\n\tfunc_ptr_unref(pt->pt_func);\n\n    // \"out_up\" is no longer used, decrement refcount on partial that owns it.\n    partial_unref(pt->pt_outer.out_up_partial);\n\n    // Using pt_outer from another partial.\n    partial_unref(pt->pt_outer_partial);\n\n    // Decrease the reference count for the context of a closure.  If down\n    // to the minimum it may be time to free it.\n    if (pt->pt_funcstack != NULL)\n    {\n\t--pt->pt_funcstack->fs_refcount;\n\tfuncstack_check_refcount(pt->pt_funcstack);\n    }\n\n    vim_free(pt);\n}\n\n/*\n * Unreference a closure: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\npartial_unref(partial_T *pt)\n{\n    if (pt != NULL)\n    {\n\tif (--pt->pt_refcount <= 0)\n\t    partial_free(pt);\n\n\t// If the reference count goes down to one, the funcstack may be the\n\t// only reference and can be freed if no other partials reference it.\n\telse if (pt->pt_refcount == 1 && pt->pt_funcstack != NULL)\n\t    funcstack_check_refcount(pt->pt_funcstack);\n    }\n}\n\n/*\n * Return the next (unique) copy ID.\n * Used for serializing nested structures.\n */\n    int\nget_copyID(void)\n{\n    current_copyID += COPYID_INC;\n    return current_copyID;\n}\n\n/*\n * Garbage collection for lists and dictionaries.\n *\n * We use reference counts to be able to free most items right away when they\n * are no longer used.  But for composite items it's possible that it becomes\n * unused while the reference count is > 0: When there is a recursive\n * reference.  Example:\n *\t:let l = [1, 2, 3]\n *\t:let d = {9: l}\n *\t:let l[1] = d\n *\n * Since this is quite unusual we handle this with garbage collection: every\n * once in a while find out which lists and dicts are not referenced from any\n * variable.\n *\n * Here is a good reference text about garbage collection (refers to Python\n * but it applies to all reference-counting mechanisms):\n *\thttp://python.ca/nas/python/gc/\n */\n\n/*\n * Do garbage collection for lists and dicts.\n * When \"testing\" is TRUE this is called from test_garbagecollect_now().\n * Return TRUE if some memory was freed.\n */\n    int\ngarbage_collect(int testing)\n{\n    int\t\tcopyID;\n    int\t\tabort = FALSE;\n    buf_T\t*buf;\n    win_T\t*wp;\n    int\t\tdid_free = FALSE;\n    tabpage_T\t*tp;\n\n    if (!testing)\n    {\n\t// Only do this once.\n\twant_garbage_collect = FALSE;\n\tmay_garbage_collect = FALSE;\n\tgarbage_collect_at_exit = FALSE;\n    }\n\n    // The execution stack can grow big, limit the size.\n    if (exestack.ga_maxlen - exestack.ga_len > 500)\n    {\n\tsize_t\tnew_len;\n\tchar_u\t*pp;\n\tint\tn;\n\n\t// Keep 150% of the current size, with a minimum of the growth size.\n\tn = exestack.ga_len / 2;\n\tif (n < exestack.ga_growsize)\n\t    n = exestack.ga_growsize;\n\n\t// Don't make it bigger though.\n\tif (exestack.ga_len + n < exestack.ga_maxlen)\n\t{\n\t    new_len = (size_t)exestack.ga_itemsize * (exestack.ga_len + n);\n\t    pp = vim_realloc(exestack.ga_data, new_len);\n\t    if (pp == NULL)\n\t\treturn FAIL;\n\t    exestack.ga_maxlen = exestack.ga_len + n;\n\t    exestack.ga_data = pp;\n\t}\n    }\n\n    // We advance by two because we add one for items referenced through\n    // previous_funccal.\n    copyID = get_copyID();\n\n    /*\n     * 1. Go through all accessible variables and mark all lists and dicts\n     *    with copyID.\n     */\n\n    // Don't free variables in the previous_funccal list unless they are only\n    // referenced through previous_funccal.  This must be first, because if\n    // the item is referenced elsewhere the funccal must not be freed.\n    abort = abort || set_ref_in_previous_funccal(copyID);\n\n    // script-local variables\n    abort = abort || garbage_collect_scriptvars(copyID);\n\n    // buffer-local variables\n    FOR_ALL_BUFFERS(buf)\n\tabort = abort || set_ref_in_item(&buf->b_bufvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n\n    // window-local variables\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    if (aucmd_win != NULL)\n\tabort = abort || set_ref_in_item(&aucmd_win->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n#ifdef FEAT_PROP_POPUP\n    FOR_ALL_POPUPWINS(wp)\n\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    FOR_ALL_TABPAGES(tp)\n\tFOR_ALL_POPUPWINS_IN_TAB(tp, wp)\n\t\tabort = abort || set_ref_in_item(&wp->w_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n#endif\n\n    // tabpage-local variables\n    FOR_ALL_TABPAGES(tp)\n\tabort = abort || set_ref_in_item(&tp->tp_winvar.di_tv, copyID,\n\t\t\t\t\t\t\t\t  NULL, NULL);\n    // global variables\n    abort = abort || garbage_collect_globvars(copyID);\n\n    // function-local variables\n    abort = abort || set_ref_in_call_stack(copyID);\n\n    // named functions (matters for closures)\n    abort = abort || set_ref_in_functions(copyID);\n\n    // function call arguments, if v:testing is set.\n    abort = abort || set_ref_in_func_args(copyID);\n\n    // funcstacks keep variables for closures\n    abort = abort || set_ref_in_funcstacks(copyID);\n\n    // v: vars\n    abort = abort || garbage_collect_vimvars(copyID);\n\n    // callbacks in buffers\n    abort = abort || set_ref_in_buffers(copyID);\n\n    // 'completefunc', 'omnifunc' and 'thesaurusfunc' callbacks\n    abort = abort || set_ref_in_insexpand_funcs(copyID);\n\n    // 'operatorfunc' callback\n    abort = abort || set_ref_in_opfunc(copyID);\n\n    // 'tagfunc' callback\n    abort = abort || set_ref_in_tagfunc(copyID);\n\n    // 'imactivatefunc' and 'imstatusfunc' callbacks\n    abort = abort || set_ref_in_im_funcs(copyID);\n\n#ifdef FEAT_LUA\n    abort = abort || set_ref_in_lua(copyID);\n#endif\n\n#ifdef FEAT_PYTHON\n    abort = abort || set_ref_in_python(copyID);\n#endif\n\n#ifdef FEAT_PYTHON3\n    abort = abort || set_ref_in_python3(copyID);\n#endif\n\n#ifdef FEAT_JOB_CHANNEL\n    abort = abort || set_ref_in_channel(copyID);\n    abort = abort || set_ref_in_job(copyID);\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    abort = abort || set_ref_in_nb_channel(copyID);\n#endif\n\n#ifdef FEAT_TIMERS\n    abort = abort || set_ref_in_timer(copyID);\n#endif\n\n#ifdef FEAT_QUICKFIX\n    abort = abort || set_ref_in_quickfix(copyID);\n#endif\n\n#ifdef FEAT_TERMINAL\n    abort = abort || set_ref_in_term(copyID);\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    abort = abort || set_ref_in_popups(copyID);\n#endif\n\n    if (!abort)\n    {\n\t/*\n\t * 2. Free lists and dictionaries that are not referenced.\n\t */\n\tdid_free = free_unref_items(copyID);\n\n\t/*\n\t * 3. Check if any funccal can be freed now.\n\t *    This may call us back recursively.\n\t */\n\tfree_unref_funccal(copyID, testing);\n    }\n    else if (p_verbose > 0)\n    {\n\tverb_msg(_(\"Not enough memory to set references, garbage collection aborted!\"));\n    }\n\n    return did_free;\n}\n\n/*\n * Free lists, dictionaries, channels and jobs that are no longer referenced.\n */\n    static int\nfree_unref_items(int copyID)\n{\n    int\t\tdid_free = FALSE;\n\n    // Let all \"free\" functions know that we are here.  This means no\n    // dictionaries, lists, channels or jobs are to be freed, because we will\n    // do that here.\n    in_free_unref_items = TRUE;\n\n    /*\n     * PASS 1: free the contents of the items.  We don't free the items\n     * themselves yet, so that it is possible to decrement refcount counters\n     */\n\n    // Go through the list of dicts and free items without the copyID.\n    did_free |= dict_free_nonref(copyID);\n\n    // Go through the list of lists and free items without the copyID.\n    did_free |= list_free_nonref(copyID);\n\n#ifdef FEAT_JOB_CHANNEL\n    // Go through the list of jobs and free items without the copyID. This\n    // must happen before doing channels, because jobs refer to channels, but\n    // the reference from the channel to the job isn't tracked.\n    did_free |= free_unused_jobs_contents(copyID, COPYID_MASK);\n\n    // Go through the list of channels and free items without the copyID.\n    did_free |= free_unused_channels_contents(copyID, COPYID_MASK);\n#endif\n\n    /*\n     * PASS 2: free the items themselves.\n     */\n    dict_free_items(copyID);\n    list_free_items(copyID);\n\n#ifdef FEAT_JOB_CHANNEL\n    // Go through the list of jobs and free items without the copyID. This\n    // must happen before doing channels, because jobs refer to channels, but\n    // the reference from the channel to the job isn't tracked.\n    free_unused_jobs(copyID, COPYID_MASK);\n\n    // Go through the list of channels and free items without the copyID.\n    free_unused_channels(copyID, COPYID_MASK);\n#endif\n\n    in_free_unref_items = FALSE;\n\n    return did_free;\n}\n\n/*\n * Mark all lists and dicts referenced through hashtab \"ht\" with \"copyID\".\n * \"list_stack\" is used to add lists to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack)\n{\n    int\t\ttodo;\n    int\t\tabort = FALSE;\n    hashitem_T\t*hi;\n    hashtab_T\t*cur_ht;\n    ht_stack_T\t*ht_stack = NULL;\n    ht_stack_T\t*tempitem;\n\n    cur_ht = ht;\n    for (;;)\n    {\n\tif (!abort)\n\t{\n\t    // Mark each item in the hashtab.  If the item contains a hashtab\n\t    // it is added to ht_stack, if it contains a list it is added to\n\t    // list_stack.\n\t    todo = (int)cur_ht->ht_used;\n\t    for (hi = cur_ht->ht_array; todo > 0; ++hi)\n\t\tif (!HASHITEM_EMPTY(hi))\n\t\t{\n\t\t    --todo;\n\t\t    abort = abort || set_ref_in_item(&HI2DI(hi)->di_tv, copyID,\n\t\t\t\t\t\t       &ht_stack, list_stack);\n\t\t}\n\t}\n\n\tif (ht_stack == NULL)\n\t    break;\n\n\t// take an item from the stack\n\tcur_ht = ht_stack->ht;\n\ttempitem = ht_stack;\n\tht_stack = ht_stack->prev;\n\tfree(tempitem);\n    }\n\n    return abort;\n}\n\n#if defined(FEAT_LUA) || defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) \\\n\t\t\t\t\t\t\t|| defined(PROTO)\n/*\n * Mark a dict and its items with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_dict(dict_T *d, int copyID)\n{\n    if (d != NULL && d->dv_copyID != copyID)\n    {\n\td->dv_copyID = copyID;\n\treturn set_ref_in_ht(&d->dv_hashtab, copyID, NULL);\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Mark a list and its items with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_list(list_T *ll, int copyID)\n{\n    if (ll != NULL && ll->lv_copyID != copyID)\n    {\n\tll->lv_copyID = copyID;\n\treturn set_ref_in_list_items(ll, copyID, NULL);\n    }\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through list \"l\" with \"copyID\".\n * \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_list_items(list_T *l, int copyID, ht_stack_T **ht_stack)\n{\n    listitem_T\t *li;\n    int\t\t abort = FALSE;\n    list_T\t *cur_l;\n    list_stack_T *list_stack = NULL;\n    list_stack_T *tempitem;\n\n    cur_l = l;\n    for (;;)\n    {\n\tif (!abort && cur_l->lv_first != &range_list_item)\n\t    // Mark each item in the list.  If the item contains a hashtab\n\t    // it is added to ht_stack, if it contains a list it is added to\n\t    // list_stack.\n\t    for (li = cur_l->lv_first; !abort && li != NULL; li = li->li_next)\n\t\tabort = abort || set_ref_in_item(&li->li_tv, copyID,\n\t\t\t\t\t\t       ht_stack, &list_stack);\n\tif (list_stack == NULL)\n\t    break;\n\n\t// take an item from the stack\n\tcur_l = list_stack->list;\n\ttempitem = list_stack;\n\tlist_stack = list_stack->prev;\n\tfree(tempitem);\n    }\n\n    return abort;\n}\n\n/*\n * Mark the partial in callback 'cb' with \"copyID\".\n */\n    int\nset_ref_in_callback(callback_T *cb, int copyID)\n{\n    typval_T tv;\n\n    if (cb->cb_name == NULL || *cb->cb_name == NUL || cb->cb_partial == NULL)\n\treturn FALSE;\n\n    tv.v_type = VAR_PARTIAL;\n    tv.vval.v_partial = cb->cb_partial;\n    return set_ref_in_item(&tv, copyID, NULL, NULL);\n}\n\n/*\n * Mark all lists and dicts referenced through typval \"tv\" with \"copyID\".\n * \"list_stack\" is used to add lists to be marked.  Can be NULL.\n * \"ht_stack\" is used to add hashtabs to be marked.  Can be NULL.\n *\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_item(\n    typval_T\t    *tv,\n    int\t\t    copyID,\n    ht_stack_T\t    **ht_stack,\n    list_stack_T    **list_stack)\n{\n    int\t\tabort = FALSE;\n\n    if (tv->v_type == VAR_DICT)\n    {\n\tdict_T\t*dd = tv->vval.v_dict;\n\n\tif (dd != NULL && dd->dv_copyID != copyID)\n\t{\n\t    // Didn't see this dict yet.\n\t    dd->dv_copyID = copyID;\n\t    if (ht_stack == NULL)\n\t    {\n\t\tabort = set_ref_in_ht(&dd->dv_hashtab, copyID, list_stack);\n\t    }\n\t    else\n\t    {\n\t\tht_stack_T *newitem = ALLOC_ONE(ht_stack_T);\n\n\t\tif (newitem == NULL)\n\t\t    abort = TRUE;\n\t\telse\n\t\t{\n\t\t    newitem->ht = &dd->dv_hashtab;\n\t\t    newitem->prev = *ht_stack;\n\t\t    *ht_stack = newitem;\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_LIST)\n    {\n\tlist_T\t*ll = tv->vval.v_list;\n\n\tif (ll != NULL && ll->lv_copyID != copyID)\n\t{\n\t    // Didn't see this list yet.\n\t    ll->lv_copyID = copyID;\n\t    if (list_stack == NULL)\n\t    {\n\t\tabort = set_ref_in_list_items(ll, copyID, ht_stack);\n\t    }\n\t    else\n\t    {\n\t\tlist_stack_T *newitem = ALLOC_ONE(list_stack_T);\n\n\t\tif (newitem == NULL)\n\t\t    abort = TRUE;\n\t\telse\n\t\t{\n\t\t    newitem->list = ll;\n\t\t    newitem->prev = *list_stack;\n\t\t    *list_stack = newitem;\n\t\t}\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_FUNC)\n    {\n\tabort = set_ref_in_func(tv->vval.v_string, NULL, copyID);\n    }\n    else if (tv->v_type == VAR_PARTIAL)\n    {\n\tpartial_T\t*pt = tv->vval.v_partial;\n\tint\t\ti;\n\n\tif (pt != NULL && pt->pt_copyID != copyID)\n\t{\n\t    // Didn't see this partial yet.\n\t    pt->pt_copyID = copyID;\n\n\t    abort = set_ref_in_func(pt->pt_name, pt->pt_func, copyID);\n\n\t    if (pt->pt_dict != NULL)\n\t    {\n\t\ttypval_T dtv;\n\n\t\tdtv.v_type = VAR_DICT;\n\t\tdtv.vval.v_dict = pt->pt_dict;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\n\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\tabort = abort || set_ref_in_item(&pt->pt_argv[i], copyID,\n\t\t\t\t\t\t\tht_stack, list_stack);\n\t    // pt_funcstack is handled in set_ref_in_funcstacks()\n\t}\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (tv->v_type == VAR_JOB)\n    {\n\tjob_T\t    *job = tv->vval.v_job;\n\ttypval_T    dtv;\n\n\tif (job != NULL && job->jv_copyID != copyID)\n\t{\n\t    job->jv_copyID = copyID;\n\t    if (job->jv_channel != NULL)\n\t    {\n\t\tdtv.v_type = VAR_CHANNEL;\n\t\tdtv.vval.v_channel = job->jv_channel;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t    if (job->jv_exit_cb.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = job->jv_exit_cb.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t}\n    }\n    else if (tv->v_type == VAR_CHANNEL)\n    {\n\tchannel_T   *ch =tv->vval.v_channel;\n\tch_part_T   part;\n\ttypval_T    dtv;\n\tjsonq_T\t    *jq;\n\tcbq_T\t    *cq;\n\n\tif (ch != NULL && ch->ch_copyID != copyID)\n\t{\n\t    ch->ch_copyID = copyID;\n\t    for (part = PART_SOCK; part < PART_COUNT; ++part)\n\t    {\n\t\tfor (jq = ch->ch_part[part].ch_json_head.jq_next; jq != NULL;\n\t\t\t\t\t\t\t     jq = jq->jq_next)\n\t\t    set_ref_in_item(jq->jq_value, copyID, ht_stack, list_stack);\n\t\tfor (cq = ch->ch_part[part].ch_cb_head.cq_next; cq != NULL;\n\t\t\t\t\t\t\t     cq = cq->cq_next)\n\t\t    if (cq->cq_callback.cb_partial != NULL)\n\t\t    {\n\t\t\tdtv.v_type = VAR_PARTIAL;\n\t\t\tdtv.vval.v_partial = cq->cq_callback.cb_partial;\n\t\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t\t    }\n\t\tif (ch->ch_part[part].ch_callback.cb_partial != NULL)\n\t\t{\n\t\t    dtv.v_type = VAR_PARTIAL;\n\t\t    dtv.vval.v_partial =\n\t\t\t\t      ch->ch_part[part].ch_callback.cb_partial;\n\t\t    set_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t\t}\n\t    }\n\t    if (ch->ch_callback.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = ch->ch_callback.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t    if (ch->ch_close_cb.cb_partial != NULL)\n\t    {\n\t\tdtv.v_type = VAR_PARTIAL;\n\t\tdtv.vval.v_partial = ch->ch_close_cb.cb_partial;\n\t\tset_ref_in_item(&dtv, copyID, ht_stack, list_stack);\n\t    }\n\t}\n    }\n#endif\n    return abort;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * When \"copyID\" is not NULL replace recursive lists and dicts with \"...\".\n * When both \"echo_style\" and \"composite_val\" are FALSE, put quotes around\n * strings as \"string()\", otherwise does not put quotes around strings, as\n * \":echo\" displays values.\n * When \"restore_copyID\" is FALSE, repeated items in dictionaries and lists\n * are replaced with \"...\".\n * May return NULL.\n */\n    char_u *\necho_string_core(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID,\n    int\t\techo_style,\n    int\t\trestore_copyID,\n    int\t\tcomposite_val)\n{\n    static int\trecurse = 0;\n    char_u\t*r = NULL;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\tif (!did_echo_string_emsg)\n\t{\n\t    // Only give this message once for a recursive call to avoid\n\t    // flooding the user with errors.  And stop iterating over lists\n\t    // and dicts.\n\t    did_echo_string_emsg = TRUE;\n\t    emsg(_(e_variable_nested_too_deep_for_displaying));\n\t}\n\t*tofree = NULL;\n\treturn (char_u *)\"{E724}\";\n    }\n    ++recurse;\n\n    switch (tv->v_type)\n    {\n\tcase VAR_STRING:\n\t    if (echo_style && !composite_val)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = tv->vval.v_string;\n\t\tif (r == NULL)\n\t\t    r = (char_u *)\"\";\n\t    }\n\t    else\n\t    {\n\t\t*tofree = string_quote(tv->vval.v_string, FALSE);\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_FUNC:\n\t    {\n\t\tchar_u buf[MAX_FUNC_NAME_LEN];\n\n\t\tif (echo_style)\n\t\t{\n\t\t    r = tv->vval.v_string == NULL ? (char_u *)\"function()\"\n\t\t\t\t  : make_ufunc_name_readable(tv->vval.v_string,\n\t\t\t\t\t\t       buf, MAX_FUNC_NAME_LEN);\n\t\t    if (r == buf)\n\t\t    {\n\t\t\tr = vim_strsave(buf);\n\t\t\t*tofree = r;\n\t\t    }\n\t\t    else\n\t\t\t*tofree = NULL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *tofree = string_quote(tv->vval.v_string == NULL ? NULL\n\t\t\t    : make_ufunc_name_readable(\n\t\t\t\ttv->vval.v_string, buf, MAX_FUNC_NAME_LEN),\n\t\t\t\t\t\t\t\t\t TRUE);\n\t\t    r = *tofree;\n\t\t}\n\t    }\n\t    break;\n\n\tcase VAR_PARTIAL:\n\t    {\n\t\tpartial_T   *pt = tv->vval.v_partial;\n\t\tchar_u\t    *fname = string_quote(pt == NULL ? NULL\n\t\t\t\t\t\t    : partial_name(pt), FALSE);\n\t\tgarray_T    ga;\n\t\tint\t    i;\n\t\tchar_u\t    *tf;\n\n\t\tga_init2(&ga, 1, 100);\n\t\tga_concat(&ga, (char_u *)\"function(\");\n\t\tif (fname != NULL)\n\t\t{\n\t\t    // When using uf_name prepend \"g:\" for a global function.\n\t\t    if (pt != NULL && pt->pt_name == NULL && fname[0] == '\\''\n\t\t\t\t\t\t      && vim_isupper(fname[1]))\n\t\t    {\n\t\t\tga_concat(&ga, (char_u *)\"'g:\");\n\t\t\tga_concat(&ga, fname + 1);\n\t\t    }\n\t\t    else\n\t\t\tga_concat(&ga, fname);\n\t\t    vim_free(fname);\n\t\t}\n\t\tif (pt != NULL && pt->pt_argc > 0)\n\t\t{\n\t\t    ga_concat(&ga, (char_u *)\", [\");\n\t\t    for (i = 0; i < pt->pt_argc; ++i)\n\t\t    {\n\t\t\tif (i > 0)\n\t\t\t    ga_concat(&ga, (char_u *)\", \");\n\t\t\tga_concat(&ga,\n\t\t\t     tv2string(&pt->pt_argv[i], &tf, numbuf, copyID));\n\t\t\tvim_free(tf);\n\t\t    }\n\t\t    ga_concat(&ga, (char_u *)\"]\");\n\t\t}\n\t\tif (pt != NULL && pt->pt_dict != NULL)\n\t\t{\n\t\t    typval_T dtv;\n\n\t\t    ga_concat(&ga, (char_u *)\", \");\n\t\t    dtv.v_type = VAR_DICT;\n\t\t    dtv.vval.v_dict = pt->pt_dict;\n\t\t    ga_concat(&ga, tv2string(&dtv, &tf, numbuf, copyID));\n\t\t    vim_free(tf);\n\t\t}\n\t\t// terminate with ')' and a NUL\n\t\tga_concat_len(&ga, (char_u *)\")\", 2);\n\n\t\t*tofree = ga.ga_data;\n\t\tr = *tofree;\n\t\tbreak;\n\t    }\n\n\tcase VAR_BLOB:\n\t    r = blob2string(tv->vval.v_blob, tofree, numbuf);\n\t    break;\n\n\tcase VAR_LIST:\n\t    if (tv->vval.v_list == NULL)\n\t    {\n\t\t// NULL list is equivalent to empty list.\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"[]\";\n\t    }\n\t    else if (copyID != 0 && tv->vval.v_list->lv_copyID == copyID\n\t\t    && tv->vval.v_list->lv_len > 0)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"[...]\";\n\t    }\n\t    else\n\t    {\n\t\tint old_copyID = tv->vval.v_list->lv_copyID;\n\n\t\ttv->vval.v_list->lv_copyID = copyID;\n\t\t*tofree = list2string(tv, copyID, restore_copyID);\n\t\tif (restore_copyID)\n\t\t    tv->vval.v_list->lv_copyID = old_copyID;\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_DICT:\n\t    if (tv->vval.v_dict == NULL)\n\t    {\n\t\t// NULL dict is equivalent to empty dict.\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"{}\";\n\t    }\n\t    else if (copyID != 0 && tv->vval.v_dict->dv_copyID == copyID\n\t\t    && tv->vval.v_dict->dv_hashtab.ht_used != 0)\n\t    {\n\t\t*tofree = NULL;\n\t\tr = (char_u *)\"{...}\";\n\t    }\n\t    else\n\t    {\n\t\tint old_copyID = tv->vval.v_dict->dv_copyID;\n\n\t\ttv->vval.v_dict->dv_copyID = copyID;\n\t\t*tofree = dict2string(tv, copyID, restore_copyID);\n\t\tif (restore_copyID)\n\t\t    tv->vval.v_dict->dv_copyID = old_copyID;\n\t\tr = *tofree;\n\t    }\n\t    break;\n\n\tcase VAR_NUMBER:\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    *tofree = NULL;\n\t    r = tv_get_string_buf(tv, numbuf);\n\t    break;\n\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n#ifdef FEAT_JOB_CHANNEL\n\t    *tofree = NULL;\n\t    r = tv->v_type == VAR_JOB ? job_to_string_buf(tv, numbuf)\n\t\t\t\t\t   : channel_to_string_buf(tv, numbuf);\n\t    if (composite_val)\n\t    {\n\t\t*tofree = string_quote(r, FALSE);\n\t\tr = *tofree;\n\t    }\n#endif\n\t    break;\n\n\tcase VAR_INSTR:\n\t    *tofree = NULL;\n\t    r = (char_u *)\"instructions\";\n\t    break;\n\n\tcase VAR_FLOAT:\n#ifdef FEAT_FLOAT\n\t    *tofree = NULL;\n\t    vim_snprintf((char *)numbuf, NUMBUFLEN, \"%g\", tv->vval.v_float);\n\t    r = numbuf;\n\t    break;\n#endif\n\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\t    *tofree = NULL;\n\t    r = (char_u *)get_var_special_name(tv->vval.v_number);\n\t    break;\n    }\n\n    if (--recurse == 0)\n\tdid_echo_string_emsg = FALSE;\n    return r;\n}\n\n/*\n * Return a string with the string representation of a variable.\n * If the memory is allocated \"tofree\" is set to it, otherwise NULL.\n * \"numbuf\" is used for a number.\n * Does not put quotes around strings, as \":echo\" displays values.\n * When \"copyID\" is not NULL replace recursive lists and dicts with \"...\".\n * May return NULL.\n */\n    char_u *\necho_string(\n    typval_T\t*tv,\n    char_u\t**tofree,\n    char_u\t*numbuf,\n    int\t\tcopyID)\n{\n    return echo_string_core(tv, tofree, numbuf, copyID, TRUE, FALSE, FALSE);\n}\n\n/*\n * Convert the specified byte index of line 'lnum' in buffer 'buf' to a\n * character index.  Works only for loaded buffers. Returns -1 on failure.\n * The index of the first byte and the first character is zero.\n */\n    int\nbuf_byteidx_to_charidx(buf_T *buf, int lnum, int byteidx)\n{\n    char_u\t*str;\n    char_u\t*t;\n    int\t\tcount;\n\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\treturn -1;\n\n    if (lnum > buf->b_ml.ml_line_count)\n\tlnum = buf->b_ml.ml_line_count;\n\n    str = ml_get_buf(buf, lnum, FALSE);\n    if (str == NULL)\n\treturn -1;\n\n    if (*str == NUL)\n\treturn 0;\n\n    // count the number of characters\n    t = str;\n    for (count = 0; *t != NUL && t <= str + byteidx; count++)\n\tt += mb_ptr2len(t);\n\n    // In insert mode, when the cursor is at the end of a non-empty line,\n    // byteidx points to the NUL character immediately past the end of the\n    // string. In this case, add one to the character count.\n    if (*t == NUL && byteidx != 0 && t == str + byteidx)\n\tcount++;\n\n    return count - 1;\n}\n\n/*\n * Convert the specified character index of line 'lnum' in buffer 'buf' to a\n * byte index.  Works only for loaded buffers. Returns -1 on failure.\n * The index of the first byte and the first character is zero.\n */\n    int\nbuf_charidx_to_byteidx(buf_T *buf, int lnum, int charidx)\n{\n    char_u\t*str;\n    char_u\t*t;\n\n    if (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\treturn -1;\n\n    if (lnum > buf->b_ml.ml_line_count)\n\tlnum = buf->b_ml.ml_line_count;\n\n    str = ml_get_buf(buf, lnum, FALSE);\n    if (str == NULL)\n\treturn -1;\n\n    // Convert the character offset to a byte offset\n    t = str;\n    while (*t != NUL && --charidx > 0)\n\tt += mb_ptr2len(t);\n\n    return t - str;\n}\n\n/*\n * Translate a String variable into a position.\n * Returns NULL when there is an error.\n */\n    pos_T *\nvar2fpos(\n    typval_T\t*varp,\n    int\t\tdollar_lnum,\t// TRUE when $ is last line\n    int\t\t*fnum,\t\t// set to fnum for '0, 'A, etc.\n    int\t\tcharcol)\t// return character column\n{\n    char_u\t\t*name;\n    static pos_T\tpos;\n    pos_T\t\t*pp;\n\n    // Argument can be [lnum, col, coladd].\n    if (varp->v_type == VAR_LIST)\n    {\n\tlist_T\t\t*l;\n\tint\t\tlen;\n\tint\t\terror = FALSE;\n\tlistitem_T\t*li;\n\n\tl = varp->vval.v_list;\n\tif (l == NULL)\n\t    return NULL;\n\n\t// Get the line number\n\tpos.lnum = list_find_nr(l, 0L, &error);\n\tif (error || pos.lnum <= 0 || pos.lnum > curbuf->b_ml.ml_line_count)\n\t    return NULL;\t// invalid line number\n\tif (charcol)\n\t    len = (long)mb_charlen(ml_get(pos.lnum));\n\telse\n\t    len = (long)STRLEN(ml_get(pos.lnum));\n\n\t// Get the column number\n\t// We accept \"$\" for the column number: last column.\n\tli = list_find(l, 1L);\n\tif (li != NULL && li->li_tv.v_type == VAR_STRING\n\t\t&& li->li_tv.vval.v_string != NULL\n\t\t&& STRCMP(li->li_tv.vval.v_string, \"$\") == 0)\n\t{\n\t    pos.col = len + 1;\n\t}\n\telse\n\t{\n\t    pos.col = list_find_nr(l, 1L, &error);\n\t    if (error)\n\t\treturn NULL;\n\t}\n\n\t// Accept a position up to the NUL after the line.\n\tif (pos.col == 0 || (int)pos.col > len + 1)\n\t    return NULL;\t// invalid column number\n\t--pos.col;\n\n\t// Get the virtual offset.  Defaults to zero.\n\tpos.coladd = list_find_nr(l, 2L, &error);\n\tif (error)\n\t    pos.coladd = 0;\n\n\treturn &pos;\n    }\n\n    if (in_vim9script() && check_for_string_arg(varp, 0) == FAIL)\n\treturn NULL;\n\n    name = tv_get_string_chk(varp);\n    if (name == NULL)\n\treturn NULL;\n\n    pos.lnum = 0;\n    if (name[0] == '.' && (!in_vim9script() || name[1] == NUL))\n    {\n\t// cursor\n\tpos = curwin->w_cursor;\n    }\n    else if (name[0] == 'v' && name[1] == NUL)\n    {\n\t// Visual start\n\tif (VIsual_active)\n\t    pos = VIsual;\n\telse\n\t    pos = curwin->w_cursor;\n    }\n    else if (name[0] == '\\'' && (!in_vim9script()\n\t\t\t\t\t|| (name[1] != NUL && name[2] == NUL)))\n    {\n\t// mark\n\tpp = getmark_buf_fnum(curbuf, name[1], FALSE, fnum);\n\tif (pp == NULL || pp == (pos_T *)-1 || pp->lnum <= 0)\n\t    return NULL;\n\tpos = *pp;\n    }\n    if (pos.lnum != 0)\n    {\n\tif (charcol)\n\t    pos.col = buf_byteidx_to_charidx(curbuf, pos.lnum, pos.col);\n\treturn &pos;\n    }\n\n    pos.coladd = 0;\n\n    if (name[0] == 'w' && dollar_lnum)\n    {\n\tpos.col = 0;\n\tif (name[1] == '0')\t\t// \"w0\": first visible line\n\t{\n\t    update_topline();\n\t    // In silent Ex mode topline is zero, but that's not a valid line\n\t    // number; use one instead.\n\t    pos.lnum = curwin->w_topline > 0 ? curwin->w_topline : 1;\n\t    return &pos;\n\t}\n\telse if (name[1] == '$')\t// \"w$\": last visible line\n\t{\n\t    validate_botline();\n\t    // In silent Ex mode botline is zero, return zero then.\n\t    pos.lnum = curwin->w_botline > 0 ? curwin->w_botline - 1 : 0;\n\t    return &pos;\n\t}\n    }\n    else if (name[0] == '$')\t\t// last column or line\n    {\n\tif (dollar_lnum)\n\t{\n\t    pos.lnum = curbuf->b_ml.ml_line_count;\n\t    pos.col = 0;\n\t}\n\telse\n\t{\n\t    pos.lnum = curwin->w_cursor.lnum;\n\t    if (charcol)\n\t\tpos.col = (colnr_T)mb_charlen(ml_get_curline());\n\t    else\n\t\tpos.col = (colnr_T)STRLEN(ml_get_curline());\n\t}\n\treturn &pos;\n    }\n    if (in_vim9script())\n\tsemsg(_(e_invalid_value_for_line_number_str), name);\n    return NULL;\n}\n\n/*\n * Convert list in \"arg\" into a position and optional file number.\n * When \"fnump\" is NULL there is no file number, only 3 items.\n * Note that the column is passed on as-is, the caller may want to decrement\n * it to use 1 for the first column.\n * Return FAIL when conversion is not possible, doesn't check the position for\n * validity.\n */\n    int\nlist2fpos(\n    typval_T\t*arg,\n    pos_T\t*posp,\n    int\t\t*fnump,\n    colnr_T\t*curswantp,\n    int\t\tcharcol)\n{\n    list_T\t*l = arg->vval.v_list;\n    long\ti = 0;\n    long\tn;\n\n    // List must be: [fnum, lnum, col, coladd, curswant], where \"fnum\" is only\n    // there when \"fnump\" isn't NULL; \"coladd\" and \"curswant\" are optional.\n    if (arg->v_type != VAR_LIST\n\t    || l == NULL\n\t    || l->lv_len < (fnump == NULL ? 2 : 3)\n\t    || l->lv_len > (fnump == NULL ? 4 : 5))\n\treturn FAIL;\n\n    if (fnump != NULL)\n    {\n\tn = list_find_nr(l, i++, NULL);\t// fnum\n\tif (n < 0)\n\t    return FAIL;\n\tif (n == 0)\n\t    n = curbuf->b_fnum;\t\t// current buffer\n\t*fnump = n;\n    }\n\n    n = list_find_nr(l, i++, NULL);\t// lnum\n    if (n < 0)\n\treturn FAIL;\n    posp->lnum = n;\n\n    n = list_find_nr(l, i++, NULL);\t// col\n    if (n < 0)\n\treturn FAIL;\n    // If character position is specified, then convert to byte position\n    if (charcol)\n    {\n\tbuf_T\t*buf;\n\n\t// Get the text for the specified line in a loaded buffer\n\tbuf = buflist_findnr(fnump == NULL ? curbuf->b_fnum : *fnump);\n\tif (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\t    return FAIL;\n\n\tn = buf_charidx_to_byteidx(buf, posp->lnum, n) + 1;\n    }\n    posp->col = n;\n\n    n = list_find_nr(l, i, NULL);\t// off\n    if (n < 0)\n\tposp->coladd = 0;\n    else\n\tposp->coladd = n;\n\n    if (curswantp != NULL)\n\t*curswantp = list_find_nr(l, i + 1, NULL);  // curswant\n\n    return OK;\n}\n\n/*\n * Get the length of an environment variable name.\n * Advance \"arg\" to the first character after the name.\n * Return 0 for error.\n */\n    int\nget_env_len(char_u **arg)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    for (p = *arg; vim_isIDc(*p); ++p)\n\t;\n    if (p == *arg)\t    // no name found\n\treturn 0;\n\n    len = (int)(p - *arg);\n    *arg = p;\n    return len;\n}\n\n/*\n * Get the length of the name of a function or internal variable.\n * \"arg\" is advanced to after the name.\n * Return 0 if something is wrong.\n */\n    int\nget_id_len(char_u **arg)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    // Find the end of the name.\n    for (p = *arg; eval_isnamec(*p); ++p)\n    {\n\tif (*p == ':')\n\t{\n\t    // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n\t    // slice \"[n:]\".  Also \"xx:\" is not a namespace.\n\t    len = (int)(p - *arg);\n\t    if ((len == 1 && vim_strchr(NAMESPACE_CHAR, **arg) == NULL)\n\t\t    || len > 1)\n\t\tbreak;\n\t}\n    }\n    if (p == *arg)\t    // no name found\n\treturn 0;\n\n    len = (int)(p - *arg);\n    *arg = p;\n\n    return len;\n}\n\n/*\n * Get the length of the name of a variable or function.\n * Only the name is recognized, does not handle \".key\" or \"[idx]\".\n * \"arg\" is advanced to the first non-white character after the name.\n * Return -1 if curly braces expansion failed.\n * Return 0 if something else is wrong.\n * If the name contains 'magic' {}'s, expand them and return the\n * expanded name in an allocated string via 'alias' - caller must free.\n */\n    int\nget_name_len(\n    char_u\t**arg,\n    char_u\t**alias,\n    int\t\tevaluate,\n    int\t\tverbose)\n{\n    int\t\tlen;\n    char_u\t*p;\n    char_u\t*expr_start;\n    char_u\t*expr_end;\n\n    *alias = NULL;  // default to no alias\n\n    if ((*arg)[0] == K_SPECIAL && (*arg)[1] == KS_EXTRA\n\t\t\t\t\t\t  && (*arg)[2] == (int)KE_SNR)\n    {\n\t// hard coded <SNR>, already translated\n\t*arg += 3;\n\treturn get_id_len(arg) + 3;\n    }\n    len = eval_fname_script(*arg);\n    if (len > 0)\n    {\n\t// literal \"<SID>\", \"s:\" or \"<SNR>\"\n\t*arg += len;\n    }\n\n    /*\n     * Find the end of the name; check for {} construction.\n     */\n    p = find_name_end(*arg, &expr_start, &expr_end,\n\t\t\t\t\t       len > 0 ? 0 : FNE_CHECK_START);\n    if (expr_start != NULL)\n    {\n\tchar_u\t*temp_string;\n\n\tif (!evaluate)\n\t{\n\t    len += (int)(p - *arg);\n\t    *arg = skipwhite(p);\n\t    return len;\n\t}\n\n\t/*\n\t * Include any <SID> etc in the expanded string:\n\t * Thus the -len here.\n\t */\n\ttemp_string = make_expanded_name(*arg - len, expr_start, expr_end, p);\n\tif (temp_string == NULL)\n\t    return -1;\n\t*alias = temp_string;\n\t*arg = skipwhite(p);\n\treturn (int)STRLEN(temp_string);\n    }\n\n    len += get_id_len(arg);\n    // Only give an error when there is something, otherwise it will be\n    // reported at a higher level.\n    if (len == 0 && verbose && **arg != NUL)\n\tsemsg(_(e_invalid_expression_str), *arg);\n\n    return len;\n}\n\n/*\n * Find the end of a variable or function name, taking care of magic braces.\n * If \"expr_start\" is not NULL then \"expr_start\" and \"expr_end\" are set to the\n * start and end of the first magic braces item.\n * \"flags\" can have FNE_INCL_BR and FNE_CHECK_START.\n * Return a pointer to just after the name.  Equal to \"arg\" if there is no\n * valid name.\n */\n    char_u *\nfind_name_end(\n    char_u\t*arg,\n    char_u\t**expr_start,\n    char_u\t**expr_end,\n    int\t\tflags)\n{\n    int\t\tmb_nest = 0;\n    int\t\tbr_nest = 0;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tvim9script = in_vim9script();\n\n    if (expr_start != NULL)\n    {\n\t*expr_start = NULL;\n\t*expr_end = NULL;\n    }\n\n    // Quick check for valid starting character.\n    if ((flags & FNE_CHECK_START) && !eval_isnamec1(*arg)\n\t\t\t\t\t\t&& (*arg != '{' || vim9script))\n\treturn arg;\n\n    for (p = arg; *p != NUL\n\t\t    && (eval_isnamec(*p)\n\t\t\t|| (*p == '{' && !vim9script)\n\t\t\t|| ((flags & FNE_INCL_BR) && (*p == '['\n\t\t\t\t\t || (*p == '.' && eval_isdictc(p[1]))))\n\t\t\t|| mb_nest != 0\n\t\t\t|| br_nest != 0); MB_PTR_ADV(p))\n    {\n\tif (*p == '\\'')\n\t{\n\t    // skip over 'string' to avoid counting [ and ] inside it.\n\t    for (p = p + 1; *p != NUL && *p != '\\''; MB_PTR_ADV(p))\n\t\t;\n\t    if (*p == NUL)\n\t\tbreak;\n\t}\n\telse if (*p == '\"')\n\t{\n\t    // skip over \"str\\\"ing\" to avoid counting [ and ] inside it.\n\t    for (p = p + 1; *p != NUL && *p != '\"'; MB_PTR_ADV(p))\n\t\tif (*p == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t    if (*p == NUL)\n\t\tbreak;\n\t}\n\telse if (br_nest == 0 && mb_nest == 0 && *p == ':')\n\t{\n\t    // \"s:\" is start of \"s:var\", but \"n:\" is not and can be used in\n\t    // slice \"[n:]\".  Also \"xx:\" is not a namespace. But {ns}: is.\n\t    len = (int)(p - arg);\n\t    if ((len == 1 && vim_strchr(NAMESPACE_CHAR, *arg) == NULL)\n\t\t    || (len > 1 && p[-1] != '}'))\n\t\tbreak;\n\t}\n\n\tif (mb_nest == 0)\n\t{\n\t    if (*p == '[')\n\t\t++br_nest;\n\t    else if (*p == ']')\n\t\t--br_nest;\n\t}\n\n\tif (br_nest == 0 && !vim9script)\n\t{\n\t    if (*p == '{')\n\t    {\n\t\tmb_nest++;\n\t\tif (expr_start != NULL && *expr_start == NULL)\n\t\t    *expr_start = p;\n\t    }\n\t    else if (*p == '}')\n\t    {\n\t\tmb_nest--;\n\t\tif (expr_start != NULL && mb_nest == 0 && *expr_end == NULL)\n\t\t    *expr_end = p;\n\t    }\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Expands out the 'magic' {}'s in a variable/function name.\n * Note that this can call itself recursively, to deal with\n * constructs like foo{bar}{baz}{bam}\n * The four pointer arguments point to \"foo{expre}ss{ion}bar\"\n *\t\t\t\"in_start\"      ^\n *\t\t\t\"expr_start\"\t   ^\n *\t\t\t\"expr_end\"\t\t ^\n *\t\t\t\"in_end\"\t\t\t    ^\n *\n * Returns a new allocated string, which the caller must free.\n * Returns NULL for failure.\n */\n    static char_u *\nmake_expanded_name(\n    char_u\t*in_start,\n    char_u\t*expr_start,\n    char_u\t*expr_end,\n    char_u\t*in_end)\n{\n    char_u\tc1;\n    char_u\t*retval = NULL;\n    char_u\t*temp_result;\n\n    if (expr_end == NULL || in_end == NULL)\n\treturn NULL;\n    *expr_start\t= NUL;\n    *expr_end = NUL;\n    c1 = *in_end;\n    *in_end = NUL;\n\n    temp_result = eval_to_string(expr_start + 1, FALSE);\n    if (temp_result != NULL)\n    {\n\tretval = alloc(STRLEN(temp_result) + (expr_start - in_start)\n\t\t\t\t\t\t   + (in_end - expr_end) + 1);\n\tif (retval != NULL)\n\t{\n\t    STRCPY(retval, in_start);\n\t    STRCAT(retval, temp_result);\n\t    STRCAT(retval, expr_end + 1);\n\t}\n    }\n    vim_free(temp_result);\n\n    *in_end = c1;\t\t// put char back for error messages\n    *expr_start = '{';\n    *expr_end = '}';\n\n    if (retval != NULL)\n    {\n\ttemp_result = find_name_end(retval, &expr_start, &expr_end, 0);\n\tif (expr_start != NULL)\n\t{\n\t    // Further expansion!\n\t    temp_result = make_expanded_name(retval, expr_start,\n\t\t\t\t\t\t       expr_end, temp_result);\n\t    vim_free(retval);\n\t    retval = temp_result;\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if character \"c\" can be used in a variable or function name.\n * Does not include '{' or '}' for magic braces.\n */\n    int\neval_isnamec(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_' || c == ':' || c == AUTOLOAD_CHAR;\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character in a\n * variable or function name (excluding '{' and '}').\n */\n    int\neval_isnamec1(int c)\n{\n    return ASCII_ISALPHA(c) || c == '_';\n}\n\n/*\n * Return TRUE if character \"c\" can be used as the first character of a\n * dictionary key.\n */\n    int\neval_isdictc(int c)\n{\n    return ASCII_ISALNUM(c) || c == '_';\n}\n\n/*\n * Handle:\n * - expr[expr], expr[expr:expr] subscript\n * - \".name\" lookup\n * - function call with Funcref variable: func(expr)\n * - method call: var->method()\n *\n * Can all be combined in any order: dict.func(expr)[idx]['func'](expr)->len()\n * \"name_start\" points to a variable before the subscript or is NULL.\n */\n    int\nhandle_subscript(\n    char_u\t**arg,\n    char_u\t*name_start,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    int\t\tret = OK;\n    dict_T\t*selfdict = NULL;\n    int\t\tcheck_white = TRUE;\n    int\t\tgetnext;\n    char_u\t*p;\n\n    while (ret == OK)\n    {\n\t// When at the end of the line and \".name\" or \"->{\" or \"->X\" follows in\n\t// the next line then consume the line break.\n\tp = eval_next_non_blank(*arg, evalarg, &getnext);\n\tif (getnext\n\t    && ((rettv->v_type == VAR_DICT && *p == '.' && eval_isdictc(p[1]))\n\t\t|| (p[0] == '-' && p[1] == '>' && (p[2] == '{'\n\t\t\t|| ASCII_ISALPHA(in_vim9script() ? *skipwhite(p + 2)\n\t\t\t\t\t\t\t\t    : p[2])))))\n\t{\n\t    *arg = eval_next_line(*arg, evalarg);\n\t    p = *arg;\n\t    check_white = FALSE;\n\t}\n\n\tif (rettv->v_type == VAR_ANY)\n\t{\n\t    char_u\t*exp_name;\n\t    int\t\tcc;\n\t    int\t\tidx;\n\t    ufunc_T\t*ufunc;\n\t    type_T\t*type;\n\n\t    // Found script from \"import {name} as name\", script item name must\n\t    // follow.  \"rettv->vval.v_number\" has the script ID.\n\t    if (**arg != '.')\n\t    {\n\t\tif (verbose)\n\t\t    semsg(_(e_expected_dot_after_name_str),\n\t\t\t\t\tname_start != NULL ? name_start: *arg);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    ++*arg;\n\t    if (IS_WHITE_OR_NUL(**arg))\n\t    {\n\t\tif (verbose)\n\t\t    emsg(_(e_no_white_space_allowed_after_dot));\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\n\t    // isolate the name\n\t    exp_name = *arg;\n\t    while (eval_isnamec(**arg))\n\t\t++*arg;\n\t    cc = **arg;\n\t    **arg = NUL;\n\n\t    idx = find_exported(rettv->vval.v_number, exp_name, &ufunc, &type,\n\t\t\t    evalarg->eval_cctx, evalarg->eval_cstack, verbose);\n\t    **arg = cc;\n\n\t    if (idx < 0 && ufunc == NULL)\n\t    {\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    if (idx >= 0)\n\t    {\n\t\tscriptitem_T    *si = SCRIPT_ITEM(rettv->vval.v_number);\n\t\tsvar_T\t\t*sv = ((svar_T *)si->sn_var_vals.ga_data) + idx;\n\n\t\tcopy_tv(sv->sv_tv, rettv);\n\t    }\n\t    else\n\t    {\n\t\trettv->v_type = VAR_FUNC;\n\t\trettv->vval.v_string = vim_strsave(ufunc->uf_name);\n\t    }\n\t    continue;\n\t}\n\n\tif ((**arg == '(' && (!evaluate || rettv->v_type == VAR_FUNC\n\t\t\t    || rettv->v_type == VAR_PARTIAL))\n\t\t    && (!check_white || !VIM_ISWHITE(*(*arg - 1))))\n\t{\n\t    ret = call_func_rettv(arg, evalarg, rettv, evaluate,\n\t\t\t\t\t\t\t       selfdict, NULL);\n\n\t    // Stop the expression evaluation when immediately aborting on\n\t    // error, or when an interrupt occurred or an exception was thrown\n\t    // but not caught.\n\t    if (aborting())\n\t    {\n\t\tif (ret == OK)\n\t\t    clear_tv(rettv);\n\t\tret = FAIL;\n\t    }\n\t    dict_unref(selfdict);\n\t    selfdict = NULL;\n\t}\n\telse if (p[0] == '-' && p[1] == '>')\n\t{\n\t    if (in_vim9script())\n\t\t*arg = skipwhite(p + 2);\n\t    else\n\t\t*arg = p + 2;\n\t    if (ret == OK)\n\t    {\n\t\tif (VIM_ISWHITE(**arg))\n\t\t{\n\t\t    emsg(_(e_no_white_space_allowed_before_parenthesis));\n\t\t    ret = FAIL;\n\t\t}\n\t\telse if ((**arg == '{' && !in_vim9script()) || **arg == '(')\n\t\t    // expr->{lambda}() or expr->(lambda)()\n\t\t    ret = eval_lambda(arg, rettv, evalarg, verbose);\n\t\telse\n\t\t    // expr->name()\n\t\t    ret = eval_method(arg, rettv, evalarg, verbose);\n\t    }\n\t}\n\t// \".\" is \".name\" lookup when we found a dict or when evaluating and\n\t// scriptversion is at least 2, where string concatenation is \"..\".\n\telse if (**arg == '['\n\t\t|| (**arg == '.' && (rettv->v_type == VAR_DICT\n\t\t\t|| (!evaluate\n\t\t\t    && (*arg)[1] != '.'\n\t\t\t    && !in_old_script(2)))))\n\t{\n\t    dict_unref(selfdict);\n\t    if (rettv->v_type == VAR_DICT)\n\t    {\n\t\tselfdict = rettv->vval.v_dict;\n\t\tif (selfdict != NULL)\n\t\t    ++selfdict->dv_refcount;\n\t    }\n\t    else\n\t\tselfdict = NULL;\n\t    if (eval_index(arg, rettv, evalarg, verbose) == FAIL)\n\t    {\n\t\tclear_tv(rettv);\n\t\tret = FAIL;\n\t    }\n\t}\n\telse\n\t    break;\n    }\n\n    // Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n    // Don't do this when \"Func\" is already a partial that was bound\n    // explicitly (pt_auto is FALSE).\n    if (selfdict != NULL\n\t    && (rettv->v_type == VAR_FUNC\n\t\t|| (rettv->v_type == VAR_PARTIAL\n\t\t    && (rettv->vval.v_partial->pt_auto\n\t\t\t|| rettv->vval.v_partial->pt_dict == NULL))))\n\tselfdict = make_partial(selfdict, rettv);\n\n    dict_unref(selfdict);\n    return ret;\n}\n\n/*\n * Make a copy of an item.\n * Lists and Dictionaries are also copied.  A deep copy if \"deep\" is set.\n * \"top\" is TRUE for the toplevel of copy().\n * For deepcopy() \"copyID\" is zero for a full copy or the ID for when a\n * reference to an already copied list/dict can be used.\n * Returns FAIL or OK.\n */\n    int\nitem_copy(\n    typval_T\t*from,\n    typval_T\t*to,\n    int\t\tdeep,\n    int\t\ttop,\n    int\t\tcopyID)\n{\n    static int\trecurse = 0;\n    int\t\tret = OK;\n\n    if (recurse >= DICT_MAXNEST)\n    {\n\temsg(_(e_variable_nested_too_deep_for_making_copy));\n\treturn FAIL;\n    }\n    ++recurse;\n\n    switch (from->v_type)\n    {\n\tcase VAR_NUMBER:\n\tcase VAR_FLOAT:\n\tcase VAR_STRING:\n\tcase VAR_FUNC:\n\tcase VAR_PARTIAL:\n\tcase VAR_BOOL:\n\tcase VAR_SPECIAL:\n\tcase VAR_JOB:\n\tcase VAR_CHANNEL:\n\tcase VAR_INSTR:\n\t    copy_tv(from, to);\n\t    break;\n\tcase VAR_LIST:\n\t    to->v_type = VAR_LIST;\n\t    to->v_lock = 0;\n\t    if (from->vval.v_list == NULL)\n\t\tto->vval.v_list = NULL;\n\t    else if (copyID != 0 && from->vval.v_list->lv_copyID == copyID)\n\t    {\n\t\t// use the copy made earlier\n\t\tto->vval.v_list = from->vval.v_list->lv_copylist;\n\t\t++to->vval.v_list->lv_refcount;\n\t    }\n\t    else\n\t\tto->vval.v_list = list_copy(from->vval.v_list,\n\t\t\t\t\t\t\t    deep, top, copyID);\n\t    if (to->vval.v_list == NULL)\n\t\tret = FAIL;\n\t    break;\n\tcase VAR_BLOB:\n\t    ret = blob_copy(from->vval.v_blob, to);\n\t    break;\n\tcase VAR_DICT:\n\t    to->v_type = VAR_DICT;\n\t    to->v_lock = 0;\n\t    if (from->vval.v_dict == NULL)\n\t\tto->vval.v_dict = NULL;\n\t    else if (copyID != 0 && from->vval.v_dict->dv_copyID == copyID)\n\t    {\n\t\t// use the copy made earlier\n\t\tto->vval.v_dict = from->vval.v_dict->dv_copydict;\n\t\t++to->vval.v_dict->dv_refcount;\n\t    }\n\t    else\n\t\tto->vval.v_dict = dict_copy(from->vval.v_dict,\n\t\t\t\t\t\t\t    deep, top, copyID);\n\t    if (to->vval.v_dict == NULL)\n\t\tret = FAIL;\n\t    break;\n\tcase VAR_UNKNOWN:\n\tcase VAR_ANY:\n\tcase VAR_VOID:\n\t    internal_error_no_abort(\"item_copy(UNKNOWN)\");\n\t    ret = FAIL;\n    }\n    --recurse;\n    return ret;\n}\n\n    void\necho_one(typval_T *rettv, int with_space, int *atstart, int *needclr)\n{\n    char_u\t*tofree;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*p = echo_string(rettv, &tofree, numbuf, get_copyID());\n\n    if (*atstart)\n    {\n\t*atstart = FALSE;\n\t// Call msg_start() after eval1(), evaluating the expression\n\t// may cause a message to appear.\n\tif (with_space)\n\t{\n\t    // Mark the saved text as finishing the line, so that what\n\t    // follows is displayed on a new line when scrolling back\n\t    // at the more prompt.\n\t    msg_sb_eol();\n\t    msg_start();\n\t}\n    }\n    else if (with_space)\n\tmsg_puts_attr(\" \", echo_attr);\n\n    if (p != NULL)\n\tfor ( ; *p != NUL && !got_int; ++p)\n\t{\n\t    if (*p == '\\n' || *p == '\\r' || *p == TAB)\n\t    {\n\t\tif (*p != TAB && *needclr)\n\t\t{\n\t\t    // remove any text still there from the command\n\t\t    msg_clr_eos();\n\t\t    *needclr = FALSE;\n\t\t}\n\t\tmsg_putchar_attr(*p, echo_attr);\n\t    }\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int i = (*mb_ptr2len)(p);\n\n\t\t    (void)msg_outtrans_len_attr(p, i, echo_attr);\n\t\t    p += i - 1;\n\t\t}\n\t\telse\n\t\t    (void)msg_outtrans_len_attr(p, 1, echo_attr);\n\t    }\n\t}\n    vim_free(tofree);\n}\n\n/*\n * \":echo expr1 ...\"\tprint each argument separated with a space, add a\n *\t\t\tnewline at the end.\n * \":echon expr1 ...\"\tprint each argument plain.\n */\n    void\nex_echo(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    char_u\t*arg_start;\n    int\t\tneedclr = TRUE;\n    int\t\tatstart = TRUE;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    evalarg_T\tevalarg;\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n\n    if (eap->skip)\n\t++emsg_skip;\n    while ((!ends_excmd2(eap->cmd, arg) || *arg == '\"') && !got_int)\n    {\n\t// If eval1() causes an error message the text from the command may\n\t// still need to be cleared. E.g., \"echo 22,44\".\n\tneed_clr_eos = needclr;\n\n\targ_start = arg;\n\tif (eval1(&arg, &rettv, &evalarg) == FAIL)\n\t{\n\t    /*\n\t     * Report the invalid expression unless the expression evaluation\n\t     * has been cancelled due to an aborting error, an interrupt, or an\n\t     * exception.\n\t     */\n\t    if (!aborting() && did_emsg == did_emsg_before\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t\tsemsg(_(e_invalid_expression_str), arg_start);\n\t    need_clr_eos = FALSE;\n\t    break;\n\t}\n\tneed_clr_eos = FALSE;\n\n\tif (!eap->skip)\n\t{\n\t    if (rettv.v_type == VAR_VOID)\n\t    {\n\t\tsemsg(_(e_expression_does_not_result_in_value_str), arg_start);\n\t\tbreak;\n\t    }\n\t    echo_one(&rettv, eap->cmdidx == CMD_echo, &atstart, &needclr);\n\t}\n\n\tclear_tv(&rettv);\n\targ = skipwhite(arg);\n    }\n    set_nextcmd(eap, arg);\n    clear_evalarg(&evalarg, eap);\n\n    if (eap->skip)\n\t--emsg_skip;\n    else\n    {\n\t// remove text that may still be there from the command\n\tif (needclr)\n\t    msg_clr_eos();\n\tif (eap->cmdidx == CMD_echo)\n\t    msg_end();\n    }\n}\n\n/*\n * \":echohl {name}\".\n */\n    void\nex_echohl(exarg_T *eap)\n{\n    echo_attr = syn_name2attr(eap->arg);\n}\n\n/*\n * Returns the :echo attribute\n */\n    int\nget_echo_attr(void)\n{\n    return echo_attr;\n}\n\n/*\n * \":execute expr1 ...\"\texecute the result of an expression.\n * \":echomsg expr1 ...\"\tPrint a message\n * \":echoerr expr1 ...\"\tPrint an error\n * \":echoconsole expr1 ...\" Print a message on stdout\n * Each gets spaces around each argument and a newline at the end for\n * echo commands\n */\n    void\nex_execute(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\tret = OK;\n    char_u\t*p;\n    garray_T\tga;\n    int\t\tlen;\n    long\tstart_lnum = SOURCING_LNUM;\n\n    ga_init2(&ga, 1, 80);\n\n    if (eap->skip)\n\t++emsg_skip;\n    while (!ends_excmd2(eap->cmd, arg) || *arg == '\"')\n    {\n\tret = eval1_emsg(&arg, &rettv, eap);\n\tif (ret == FAIL)\n\t    break;\n\n\tif (!eap->skip)\n\t{\n\t    char_u   buf[NUMBUFLEN];\n\n\t    if (eap->cmdidx == CMD_execute)\n\t    {\n\t\tif (rettv.v_type == VAR_CHANNEL || rettv.v_type == VAR_JOB)\n\t\t{\n\t\t    semsg(_(e_using_invalid_value_as_string_str),\n\t\t\t\t\t\t  vartype_name(rettv.v_type));\n\t\t    p = NULL;\n\t\t}\n\t\telse\n\t\t    p = tv_get_string_buf(&rettv, buf);\n\t    }\n\t    else\n\t\tp = tv_stringify(&rettv, buf);\n\t    if (p == NULL)\n\t    {\n\t\tclear_tv(&rettv);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    len = (int)STRLEN(p);\n\t    if (ga_grow(&ga, len + 2) == FAIL)\n\t    {\n\t\tclear_tv(&rettv);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t    if (ga.ga_len)\n\t\t((char_u *)(ga.ga_data))[ga.ga_len++] = ' ';\n\t    STRCPY((char_u *)(ga.ga_data) + ga.ga_len, p);\n\t    ga.ga_len += len;\n\t}\n\n\tclear_tv(&rettv);\n\targ = skipwhite(arg);\n    }\n\n    if (ret != FAIL && ga.ga_data != NULL)\n    {\n\t// use the first line of continuation lines for messages\n\tSOURCING_LNUM = start_lnum;\n\n\tif (eap->cmdidx == CMD_echomsg || eap->cmdidx == CMD_echoerr)\n\t{\n\t    // Mark the already saved text as finishing the line, so that what\n\t    // follows is displayed on a new line when scrolling back at the\n\t    // more prompt.\n\t    msg_sb_eol();\n\t}\n\n\tif (eap->cmdidx == CMD_echomsg)\n\t{\n\t    msg_attr(ga.ga_data, echo_attr);\n\t    out_flush();\n\t}\n\telse if (eap->cmdidx == CMD_echoconsole)\n\t{\n\t    ui_write(ga.ga_data, (int)STRLEN(ga.ga_data), TRUE);\n\t    ui_write((char_u *)\"\\r\\n\", 2, TRUE);\n\t}\n\telse if (eap->cmdidx == CMD_echoerr)\n\t{\n\t    int\t\tsave_did_emsg = did_emsg;\n\n\t    // We don't want to abort following commands, restore did_emsg.\n\t    emsg(ga.ga_data);\n\t    if (!force_abort)\n\t\tdid_emsg = save_did_emsg;\n\t}\n\telse if (eap->cmdidx == CMD_execute)\n\t{\n\t    int save_sticky_cmdmod_flags = sticky_cmdmod_flags;\n\n\t    // \"legacy exe cmd\" and \"vim9cmd exe cmd\" applies to \"cmd\".\n\t    sticky_cmdmod_flags = cmdmod.cmod_flags\n\t\t\t\t\t\t& (CMOD_LEGACY | CMOD_VIM9CMD);\n\t    do_cmdline((char_u *)ga.ga_data,\n\t\t       eap->getline, eap->cookie, DOCMD_NOWAIT|DOCMD_VERBOSE);\n\t    sticky_cmdmod_flags = save_sticky_cmdmod_flags;\n\t}\n    }\n\n    ga_clear(&ga);\n\n    if (eap->skip)\n\t--emsg_skip;\n\n    set_nextcmd(eap, arg);\n}\n\n/*\n * Skip over the name of an option: \"&option\", \"&g:option\" or \"&l:option\".\n * \"arg\" points to the \"&\" or '+' when called, to \"option\" when returning.\n * Returns NULL when no option name found.  Otherwise pointer to the char\n * after the option name.\n */\n    char_u *\nfind_option_end(char_u **arg, int *scope)\n{\n    char_u\t*p = *arg;\n\n    ++p;\n    if (*p == 'g' && p[1] == ':')\n    {\n\t*scope = OPT_GLOBAL;\n\tp += 2;\n    }\n    else if (*p == 'l' && p[1] == ':')\n    {\n\t*scope = OPT_LOCAL;\n\tp += 2;\n    }\n    else\n\t*scope = 0;\n\n    if (!ASCII_ISALPHA(*p))\n\treturn NULL;\n    *arg = p;\n\n    if (p[0] == 't' && p[1] == '_' && p[2] != NUL && p[3] != NUL)\n\tp += 4;\t    // termcap option\n    else\n\twhile (ASCII_ISALPHA(*p))\n\t    ++p;\n    return p;\n}\n\n/*\n * Display script name where an item was last set.\n * Should only be invoked when 'verbose' is non-zero.\n */\n    void\nlast_set_msg(sctx_T script_ctx)\n{\n    char_u *p;\n\n    if (script_ctx.sc_sid != 0)\n    {\n\tp = home_replace_save(NULL, get_scriptname(script_ctx.sc_sid));\n\tif (p != NULL)\n\t{\n\t    verbose_enter();\n\t    msg_puts(_(\"\\n\\tLast set from \"));\n\t    msg_puts((char *)p);\n\t    if (script_ctx.sc_lnum > 0)\n\t    {\n\t\tmsg_puts(_(line_msg));\n\t\tmsg_outnum((long)script_ctx.sc_lnum);\n\t    }\n\t    verbose_leave();\n\t    vim_free(p);\n\t}\n    }\n}\n\n#endif // FEAT_EVAL\n\n/*\n * Perform a substitution on \"str\" with pattern \"pat\" and substitute \"sub\".\n * When \"sub\" is NULL \"expr\" is used, must be a VAR_FUNC or VAR_PARTIAL.\n * \"flags\" can be \"g\" to do a global substitute.\n * Returns an allocated string, NULL for error.\n */\n    char_u *\ndo_string_sub(\n    char_u\t*str,\n    char_u\t*pat,\n    char_u\t*sub,\n    typval_T\t*expr,\n    char_u\t*flags)\n{\n    int\t\tsublen;\n    regmatch_T\tregmatch;\n    int\t\ti;\n    int\t\tdo_all;\n    char_u\t*tail;\n    char_u\t*end;\n    garray_T\tga;\n    char_u\t*ret;\n    char_u\t*save_cpo;\n    char_u\t*zero_width = NULL;\n\n    // Make 'cpoptions' empty, so that the 'l' flag doesn't work here\n    save_cpo = p_cpo;\n    p_cpo = empty_option;\n\n    ga_init2(&ga, 1, 200);\n\n    do_all = (flags[0] == 'g');\n\n    regmatch.rm_ic = p_ic;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    if (regmatch.regprog != NULL)\n    {\n\ttail = str;\n\tend = str + STRLEN(str);\n\twhile (vim_regexec_nl(&regmatch, str, (colnr_T)(tail - str)))\n\t{\n\t    // Skip empty match except for first match.\n\t    if (regmatch.startp[0] == regmatch.endp[0])\n\t    {\n\t\tif (zero_width == regmatch.startp[0])\n\t\t{\n\t\t    // avoid getting stuck on a match with an empty string\n\t\t    i = mb_ptr2len(tail);\n\t\t    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail,\n\t\t\t\t\t\t\t\t   (size_t)i);\n\t\t    ga.ga_len += i;\n\t\t    tail += i;\n\t\t    continue;\n\t\t}\n\t\tzero_width = regmatch.startp[0];\n\t    }\n\n\t    /*\n\t     * Get some space for a temporary buffer to do the substitution\n\t     * into.  It will contain:\n\t     * - The text up to where the match is.\n\t     * - The substituted text.\n\t     * - The text after the match.\n\t     */\n\t    sublen = vim_regsub(&regmatch, sub, expr, tail, 0, REGSUB_MAGIC);\n\t    if (ga_grow(&ga, (int)((end - tail) + sublen -\n\t\t\t    (regmatch.endp[0] - regmatch.startp[0]))) == FAIL)\n\t    {\n\t\tga_clear(&ga);\n\t\tbreak;\n\t    }\n\n\t    // copy the text up to where the match is\n\t    i = (int)(regmatch.startp[0] - tail);\n\t    mch_memmove((char_u *)ga.ga_data + ga.ga_len, tail, (size_t)i);\n\t    // add the substituted text\n\t    (void)vim_regsub(&regmatch, sub, expr,\n\t\t\t\t  (char_u *)ga.ga_data + ga.ga_len + i, sublen,\n\t\t\t\t  REGSUB_COPY | REGSUB_MAGIC);\n\t    ga.ga_len += i + sublen - 1;\n\t    tail = regmatch.endp[0];\n\t    if (*tail == NUL)\n\t\tbreak;\n\t    if (!do_all)\n\t\tbreak;\n\t}\n\n\tif (ga.ga_data != NULL)\n\t    STRCPY((char *)ga.ga_data + ga.ga_len, tail);\n\n\tvim_regfree(regmatch.regprog);\n    }\n\n    ret = vim_strsave(ga.ga_data == NULL ? str : (char_u *)ga.ga_data);\n    ga_clear(&ga);\n    if (p_cpo == empty_option)\n\tp_cpo = save_cpo;\n    else\n    {\n\t// Darn, evaluating {sub} expression or {expr} changed the value.\n\t// If it's still empty it was changed and restored, need to restore in\n\t// the complicated way.\n\tif (*p_cpo == NUL)\n\t    set_option_value_give_err((char_u *)\"cpo\", 0L, save_cpo, 0);\n\tfree_string_option(save_cpo);\n    }\n\n    return ret;\n}\n", "/* eval.c */\nvarnumber_T num_divide(varnumber_T n1, varnumber_T n2, int *failed);\nvarnumber_T num_modulus(varnumber_T n1, varnumber_T n2, int *failed);\nvoid eval_init(void);\nvoid eval_clear(void);\nvoid fill_evalarg_from_eap(evalarg_T *evalarg, exarg_T *eap, int skip);\nint eval_to_bool(char_u *arg, int *error, exarg_T *eap, int skip);\nint eval_expr_valid_arg(typval_T *tv);\nint eval_expr_typval(typval_T *expr, typval_T *argv, int argc, typval_T *rettv);\nint eval_expr_to_bool(typval_T *expr, int *error);\nchar_u *eval_to_string_skip(char_u *arg, exarg_T *eap, int skip);\nvoid init_evalarg(evalarg_T *evalarg);\nvoid clear_evalarg(evalarg_T *evalarg, exarg_T *eap);\nint skip_expr(char_u **pp, evalarg_T *evalarg);\nint skip_expr_concatenate(char_u **arg, char_u **start, char_u **end, evalarg_T *evalarg);\nchar_u *typval2string(typval_T *tv, int convert);\nchar_u *eval_to_string_eap(char_u *arg, int convert, exarg_T *eap);\nchar_u *eval_to_string(char_u *arg, int convert);\nchar_u *eval_to_string_safe(char_u *arg, int use_sandbox, int keep_script_version);\nvarnumber_T eval_to_number(char_u *expr);\ntypval_T *eval_expr(char_u *arg, exarg_T *eap);\nint call_vim_function(char_u *func, int argc, typval_T *argv, typval_T *rettv);\nvoid *call_func_retstr(char_u *func, int argc, typval_T *argv);\nvoid *call_func_retlist(char_u *func, int argc, typval_T *argv);\nint eval_foldexpr(win_T *wp, int *cp);\nchar_u *get_lval(char_u *name, typval_T *rettv, lval_T *lp, int unlet, int skip, int flags, int fne_flags);\nvoid clear_lval(lval_T *lp);\nvoid set_var_lval(lval_T *lp, char_u *endp, typval_T *rettv, int copy, int flags, char_u *op, int var_idx);\nint tv_op(typval_T *tv1, typval_T *tv2, char_u *op);\nvoid *eval_for_line(char_u *arg, int *errp, exarg_T *eap, evalarg_T *evalarg);\nvoid skip_for_lines(void *fi_void, evalarg_T *evalarg);\nint next_for_item(void *fi_void, char_u *arg);\nvoid free_for_info(void *fi_void);\nvoid set_context_for_expression(expand_T *xp, char_u *arg, cmdidx_T cmdidx);\nint pattern_match(char_u *pat, char_u *text, int ic);\nchar_u *eval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext);\nchar_u *eval_next_line(char_u *arg, evalarg_T *evalarg);\nchar_u *skipwhite_and_linebreak(char_u *arg, evalarg_T *evalarg);\nint eval0(char_u *arg, typval_T *rettv, exarg_T *eap, evalarg_T *evalarg);\nint eval0_retarg(char_u *arg, typval_T *rettv, exarg_T *eap, evalarg_T *evalarg, char_u **retarg);\nint eval1(char_u **arg, typval_T *rettv, evalarg_T *evalarg);\nvoid eval_addblob(typval_T *tv1, typval_T *tv2);\nint eval_addlist(typval_T *tv1, typval_T *tv2);\nint eval_leader(char_u **arg, int vim9);\nint handle_predefined(char_u *s, int len, typval_T *rettv);\nint check_can_index(typval_T *rettv, int evaluate, int verbose);\nvoid f_slice(typval_T *argvars, typval_T *rettv);\nint eval_index_inner(typval_T *rettv, int is_range, typval_T *var1, typval_T *var2, int exclusive, char_u *key, int keylen, int verbose);\nchar_u *partial_name(partial_T *pt);\nvoid partial_unref(partial_T *pt);\nint get_copyID(void);\nint garbage_collect(int testing);\nint set_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack);\nint set_ref_in_dict(dict_T *d, int copyID);\nint set_ref_in_list(list_T *ll, int copyID);\nint set_ref_in_list_items(list_T *l, int copyID, ht_stack_T **ht_stack);\nint set_ref_in_callback(callback_T *cb, int copyID);\nint set_ref_in_item(typval_T *tv, int copyID, ht_stack_T **ht_stack, list_stack_T **list_stack);\nchar_u *echo_string_core(typval_T *tv, char_u **tofree, char_u *numbuf, int copyID, int echo_style, int restore_copyID, int composite_val);\nchar_u *echo_string(typval_T *tv, char_u **tofree, char_u *numbuf, int copyID);\nint buf_byteidx_to_charidx(buf_T *buf, int lnum, int byteidx);\nint buf_charidx_to_byteidx(buf_T *buf, int lnum, int charidx);\npos_T *var2fpos(typval_T *varp, int dollar_lnum, int *fnum, int charcol);\nint list2fpos(typval_T *arg, pos_T *posp, int *fnump, colnr_T *curswantp, int charcol);\nint get_env_len(char_u **arg);\nint get_id_len(char_u **arg);\nint get_name_len(char_u **arg, char_u **alias, int evaluate, int verbose);\nchar_u *find_name_end(char_u *arg, char_u **expr_start, char_u **expr_end, int flags);\nint eval_isnamec(int c);\nint eval_isnamec1(int c);\nint eval_isdictc(int c);\nint handle_subscript(char_u **arg, char_u *name_start, typval_T *rettv, evalarg_T *evalarg, int verbose);\nint item_copy(typval_T *from, typval_T *to, int deep, int top, int copyID);\nvoid echo_one(typval_T *rettv, int with_space, int *atstart, int *needclr);\nvoid ex_echo(exarg_T *eap);\nvoid ex_echohl(exarg_T *eap);\nint get_echo_attr(void);\nvoid ex_execute(exarg_T *eap);\nchar_u *find_option_end(char_u **arg, int *scope);\nvoid last_set_msg(sctx_T script_ctx);\nchar_u *do_string_sub(char_u *str, char_u *pat, char_u *sub, typval_T *expr, char_u *flags);\n/* vim: set ft=c : */\n", "\" Test various aspects of the Vim9 script language.\n\nsource check.vim\nsource term_util.vim\nimport './vim9.vim' as v9\nsource screendump.vim\nsource shared.vim\n\ndef Test_vim9script_feature()\n  # example from the help, here the feature is always present\n  var lines =<< trim END\n      \" old style comment\n      if !has('vim9script')\n        \" legacy commands would go here\n        finish\n      endif\n      vim9script\n      # Vim9 script commands go here\n      g:didit = true\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal(true, g:didit)\n  unlet g:didit\nenddef\n\ndef Test_range_only()\n  new\n  setline(1, ['blah', 'Blah'])\n  :/Blah/\n  assert_equal(2, getcurpos()[1])\n  bwipe!\n\n  # without range commands use current line\n  new\n  setline(1, ['one', 'two', 'three'])\n  :2\n  print\n  assert_equal('two', g:Screenline(&lines))\n  :3\n  list\n  assert_equal('three$', g:Screenline(&lines))\n\n  # missing command does not print the line\n  var lines =<< trim END\n    vim9script\n    :1|\n    assert_equal('three$', g:Screenline(&lines))\n    :|\n    assert_equal('three$', g:Screenline(&lines))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  bwipe!\n\n  lines =<< trim END\n      set cpo+=-\n      :1,999\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E16:', 2)\n  set cpo&vim\n\n  v9.CheckDefExecAndScriptFailure([\":'x\"], 'E20:', 1)\n\n  # won't generate anything\n  if false\n    :123\n  endif\nenddef\n\ndef Test_invalid_range()\n  var lines =<< trim END\n      :123 eval 1 + 2\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 if true\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 echo 'yes'\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\n\n  lines =<< trim END\n      :123 cd there\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:', 1)\nenddef\n\nlet g:alist = [7]\nlet g:astring = 'text'\nlet g:anumber = 123\n\ndef Test_delfunction()\n  # Check function is defined in script namespace\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func CheckMe()',\n      '  return 123',\n      'endfunc',\n      'func DoTest()',\n      '  call assert_equal(123, s:CheckMe())',\n      'endfunc',\n      'DoTest()',\n      ])\n\n  # Check function in script namespace cannot be deleted\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func DeleteMe1()',\n      'endfunc',\n      'delfunction DeleteMe1',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func DeleteMe2()',\n      'endfunc',\n      'def DoThat()',\n      '  delfunction DeleteMe2',\n      'enddef',\n      'DoThat()',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def DeleteMe3()',\n      'enddef',\n      'delfunction DeleteMe3',\n      ], 'E1084:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def DeleteMe4()',\n      'enddef',\n      'def DoThat()',\n      '  delfunction DeleteMe4',\n      'enddef',\n      'DoThat()',\n      ], 'E1084:')\n\n  # Check that global :def function can be replaced and deleted\n  var lines =<< trim END\n      vim9script\n      def g:Global(): string\n        return \"yes\"\n      enddef\n      assert_equal(\"yes\", g:Global())\n      def! g:Global(): string\n        return \"no\"\n      enddef\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Check that global function can be replaced by a :def function and deleted\n  lines =<< trim END\n      vim9script\n      func g:Global()\n        return \"yes\"\n      endfunc\n      assert_equal(\"yes\", g:Global())\n      def! g:Global(): string\n        return \"no\"\n      enddef\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # Check that global :def function can be replaced by a function and deleted\n  lines =<< trim END\n      vim9script\n      def g:Global(): string\n        return \"yes\"\n      enddef\n      assert_equal(\"yes\", g:Global())\n      func! g:Global()\n        return \"no\"\n      endfunc\n      assert_equal(\"no\", g:Global())\n      delfunc g:Global\n      assert_false(exists('*g:Global'))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_wrong_type()\n  v9.CheckDefFailure(['var name: list<nothing>'], 'E1010:')\n  v9.CheckDefFailure(['var name: list<list<nothing>>'], 'E1010:')\n  v9.CheckDefFailure(['var name: dict<nothing>'], 'E1010:')\n  v9.CheckDefFailure(['var name: dict<dict<nothing>>'], 'E1010:')\n\n  v9.CheckDefFailure(['var name: dict<number'], 'E1009:')\n  v9.CheckDefFailure(['var name: dict<list<number>'], 'E1009:')\n\n  v9.CheckDefFailure(['var name: ally'], 'E1010:')\n  v9.CheckDefFailure(['var name: bram'], 'E1010:')\n  v9.CheckDefFailure(['var name: cathy'], 'E1010:')\n  v9.CheckDefFailure(['var name: dom'], 'E1010:')\n  v9.CheckDefFailure(['var name: freddy'], 'E1010:')\n  v9.CheckDefFailure(['var name: john'], 'E1010:')\n  v9.CheckDefFailure(['var name: larry'], 'E1010:')\n  v9.CheckDefFailure(['var name: ned'], 'E1010:')\n  v9.CheckDefFailure(['var name: pam'], 'E1010:')\n  v9.CheckDefFailure(['var name: sam'], 'E1010:')\n  v9.CheckDefFailure(['var name: vim'], 'E1010:')\n\n  v9.CheckDefFailure(['var Ref: number', 'Ref()'], 'E1085:')\n  v9.CheckDefFailure(['var Ref: string', 'var res = Ref()'], 'E1085:')\nenddef\n\ndef Test_script_namespace()\n  # defining a function or variable with s: is not allowed\n  var lines =<< trim END\n      vim9script\n      def s:Function()\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n\n  for decl in ['var', 'const', 'final']\n    lines =<< trim END\n        vim9script\n        var s:var = 'var'\n    END\n    v9.CheckScriptFailure([\n        'vim9script',\n        decl .. ' s:var = \"var\"',\n        ], 'E1268:')\n  endfor\n\n  # Calling a function or using a variable with s: is not allowed at script\n  # level\n  lines =<< trim END\n      vim9script\n      def Function()\n      enddef\n      s:Function()\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n  lines =<< trim END\n      vim9script\n      def Function()\n      enddef\n      call s:Function()\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\n  lines =<< trim END\n      vim9script\n      var var = 'var'\n      echo s:var\n  END\n  v9.CheckScriptFailure(lines, 'E1268:')\nenddef\n\ndef Test_script_wrong_type()\n  var lines =<< trim END\n      vim9script\n      var dict: dict<string>\n      dict['a'] = ['x']\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected string but got list<string>', 3)\nenddef\n\ndef Test_const()\n  v9.CheckDefFailure(['final name = 234', 'name = 99'], 'E1018:')\n  v9.CheckDefFailure(['final one = 234', 'var one = 99'], 'E1017:')\n  v9.CheckDefFailure(['final list = [1, 2]', 'var list = [3, 4]'], 'E1017:')\n  v9.CheckDefFailure(['final two'], 'E1125:')\n  v9.CheckDefFailure(['final &option'], 'E996:')\n\n  var lines =<< trim END\n    final list = [1, 2, 3]\n    list[0] = 4\n    list->assert_equal([4, 2, 3])\n    const other = [5, 6, 7]\n    other->assert_equal([5, 6, 7])\n\n    var varlist = [7, 8]\n    const constlist = [1, varlist, 3]\n    varlist[0] = 77\n    constlist[1][1] = 88\n    var cl = constlist[1]\n    cl[1] = 88\n    constlist->assert_equal([1, [77, 88], 3])\n\n    var vardict = {five: 5, six: 6}\n    const constdict = {one: 1, two: vardict, three: 3}\n    vardict['five'] = 55\n    constdict['two']['six'] = 66\n    var cd = constdict['two']\n    cd['six'] = 66\n    constdict->assert_equal({one: 1, two: {five: 55, six: 66}, three: 3})\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_const_bang()\n  var lines =<< trim END\n      const var = 234\n      var = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1018:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E46:', 3)\n\n  lines =<< trim END\n      const ll = [2, 3, 4]\n      ll[0] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1119:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\n\n  lines =<< trim END\n      const ll = [2, 3, 4]\n      ll[3] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1118:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E684:', 3)\n\n  lines =<< trim END\n      const dd = {one: 1, two: 2}\n      dd[\"one\"] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1121:', 2)\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\n\n  lines =<< trim END\n      const dd = {one: 1, two: 2}\n      dd[\"three\"] = 99\n  END\n  v9.CheckDefExecFailure(lines, 'E1120:')\n  v9.CheckScriptFailure(['vim9script'] + lines, 'E741:', 3)\nenddef\n\ndef Test_range_no_colon()\n  v9.CheckDefFailure(['%s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['+ s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['- s/a/b/'], 'E1050:')\n  v9.CheckDefFailure(['. s/a/b/'], 'E1050:')\nenddef\n\n\ndef Test_block()\n  var outer = 1\n  {\n    var inner = 2\n    assert_equal(1, outer)\n    assert_equal(2, inner)\n  }\n  assert_equal(1, outer)\n\n  {|echo 'yes'|}\nenddef\n\ndef Test_block_failure()\n  v9.CheckDefFailure(['{', 'var inner = 1', '}', 'echo inner'], 'E1001:')\n  v9.CheckDefFailure(['}'], 'E1025:')\n  v9.CheckDefFailure(['{', 'echo 1'], 'E1026:')\nenddef\n\ndef Test_block_local_vars()\n  var lines =<< trim END\n      vim9script\n      v:testing = 1\n      if true\n        var text = ['hello']\n        def SayHello(): list<string>\n          return text\n        enddef\n        def SetText(v: string)\n          text = [v]\n        enddef\n      endif\n\n      if true\n        var text = ['again']\n        def SayAgain(): list<string>\n          return text\n        enddef\n      endif\n\n      # test that the \"text\" variables are not cleaned up\n      test_garbagecollect_now()\n\n      defcompile\n\n      assert_equal(['hello'], SayHello())\n      assert_equal(['again'], SayAgain())\n\n      SetText('foobar')\n      assert_equal(['foobar'], SayHello())\n\n      call writefile(['ok'], 'Xdidit')\n      qall!\n  END\n\n  # need to execute this with a separate Vim instance to avoid the current\n  # context gets garbage collected.\n  writefile(lines, 'Xscript')\n  g:RunVim([], [], '-S Xscript')\n  assert_equal(['ok'], readfile('Xdidit'))\n\n  delete('Xscript')\n  delete('Xdidit')\nenddef\n\ndef Test_block_local_vars_with_func()\n  var lines =<< trim END\n      vim9script\n      if true\n        var foo = 'foo'\n        if true\n          var bar = 'bar'\n          def Func(): list<string>\n            return [foo, bar]\n          enddef\n        endif\n      endif\n      # function is compiled here, after blocks have finished, can still access\n      # \"foo\" and \"bar\"\n      assert_equal(['foo', 'bar'], Func())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\n\" legacy func for command that's defined later\nfunc s:InvokeSomeCommand()\n  SomeCommand\nendfunc\n\ndef Test_autocommand_block()\n  com SomeCommand {\n      g:someVar = 'some'\n    }\n  InvokeSomeCommand()\n  assert_equal('some', g:someVar)\n\n  delcommand SomeCommand\n  unlet g:someVar\nenddef\n\ndef Test_command_block()\n  au BufNew *.xml {\n      g:otherVar = 'other'\n    }\n  split other.xml\n  assert_equal('other', g:otherVar)\n\n  bwipe!\n  au! BufNew *.xml\n  unlet g:otherVar\nenddef\n\nfunc g:NoSuchFunc()\n  echo 'none'\nendfunc\n\ndef Test_try_catch_throw()\n  var l = []\n  try # comment\n    add(l, '1')\n    throw 'wrong'\n    add(l, '2')\n  catch # comment\n    add(l, v:exception)\n  finally # comment\n    add(l, '3')\n  endtry # comment\n  assert_equal(['1', 'wrong', '3'], l)\n\n  l = []\n  try\n    try\n      add(l, '1')\n      throw 'wrong'\n      add(l, '2')\n    catch /right/\n      add(l, v:exception)\n    endtry\n  catch /wrong/\n    add(l, 'caught')\n  finally\n    add(l, 'finally')\n  endtry\n  assert_equal(['1', 'caught', 'finally'], l)\n\n  var n: number\n  try\n    n = l[3]\n  catch /E684:/\n    n = 99\n  endtry\n  assert_equal(99, n)\n\n  var done = 'no'\n  if 0\n    try | catch | endtry\n  else\n    done = 'yes'\n  endif\n  assert_equal('yes', done)\n\n  done = 'no'\n  if 1\n    done = 'yes'\n  else\n    try | catch | endtry\n    done = 'never'\n  endif\n  assert_equal('yes', done)\n\n  if 1\n  else\n    try | catch /pat/ | endtry\n    try | catch /pat/ \n    endtry\n    try \n    catch /pat/ | endtry\n    try \n    catch /pat/ \n    endtry\n  endif\n\n  try\n    # string slice returns a string, not a number\n    n = g:astring[3]\n  catch /E1012:/\n    n = 77\n  endtry\n  assert_equal(77, n)\n\n  try\n    n = l[g:astring]\n  catch /E1012:/\n    n = 88\n  endtry\n  assert_equal(88, n)\n\n  try\n    n = s:does_not_exist\n  catch /E121:/\n    n = 111\n  endtry\n  assert_equal(111, n)\n\n  try\n    n = g:does_not_exist\n  catch /E121:/\n    n = 121\n  endtry\n  assert_equal(121, n)\n\n  var d = {one: 1}\n  try\n    n = d[g:astring]\n  catch /E716:/\n    n = 222\n  endtry\n  assert_equal(222, n)\n\n  try\n    n = -g:astring\n  catch /E1012:/\n    n = 233\n  endtry\n  assert_equal(233, n)\n\n  try\n    n = +g:astring\n  catch /E1012:/\n    n = 244\n  endtry\n  assert_equal(244, n)\n\n  try\n    n = +g:alist\n  catch /E1012:/\n    n = 255\n  endtry\n  assert_equal(255, n)\n\n  var nd: dict<any>\n  try\n    nd = {[g:alist]: 1}\n  catch /E1105:/\n    n = 266\n  endtry\n  assert_equal(266, n)\n\n  l = [1, 2, 3] \n  try\n    [n] = l\n  catch /E1093:/\n    n = 277\n  endtry\n  assert_equal(277, n)\n\n  try\n    &ts = g:astring\n  catch /E1012:/\n    n = 288\n  endtry\n  assert_equal(288, n)\n\n  try\n    &backspace = 'asdf'\n  catch /E474:/\n    n = 299\n  endtry\n  assert_equal(299, n)\n\n  l = [1]\n  try\n    l[3] = 3\n  catch /E684:/\n    n = 300\n  endtry\n  assert_equal(300, n)\n\n  try\n    unlet g:does_not_exist\n  catch /E108:/\n    n = 322\n  endtry\n  assert_equal(322, n)\n\n  try\n    d = {text: 1, [g:astring]: 2}\n  catch /E721:/\n    n = 333\n  endtry\n  assert_equal(333, n)\n\n  try\n    l = g:DeletedFunc()\n  catch /E933:/\n    n = 344\n  endtry\n  assert_equal(344, n)\n\n  try\n    echo range(1, 2, 0)\n  catch /E726:/\n    n = 355\n  endtry\n  assert_equal(355, n)\n\n  var P = function('g:NoSuchFunc')\n  delfunc g:NoSuchFunc\n  try\n    echo P()\n  catch /E117:/\n    n = 366\n  endtry\n  assert_equal(366, n)\n\n  try\n    echo g:NoSuchFunc()\n  catch /E117:/\n    n = 377\n  endtry\n  assert_equal(377, n)\n\n  try\n    echo g:alist + 4\n  catch /E745:/\n    n = 388\n  endtry\n  assert_equal(388, n)\n\n  try\n    echo 4 + g:alist\n  catch /E745:/\n    n = 399\n  endtry\n  assert_equal(399, n)\n\n  try\n    echo g:alist.member\n  catch /E715:/\n    n = 400\n  endtry\n  assert_equal(400, n)\n\n  try\n    echo d.member\n  catch /E716:/\n    n = 411\n  endtry\n  assert_equal(411, n)\n\n  var counter = 0\n  for i in range(4)\n    try\n      eval [][0]\n    catch\n    endtry\n    counter += 1\n  endfor\n  assert_equal(4, counter)\n\n  # no requirement for spaces before |\n  try|echo 0|catch|endtry\n\n  # return in try with finally\n  def ReturnInTry(): number\n    var ret = 4\n    try\n      return ret\n    catch /this/\n      return -1\n    catch /that/\n      return -1\n    finally\n      # changing ret has no effect\n      ret = 7\n    endtry\n    return -2\n  enddef\n  assert_equal(4, ReturnInTry())\n\n  # return in catch with finally\n  def ReturnInCatch(): number\n    var ret = 5\n    try\n      throw 'getout'\n      return -1\n    catch /getout/\n      # ret is evaluated here\n      return ret\n    finally\n      # changing ret later has no effect\n      ret = -3\n    endtry\n    return -2\n  enddef\n  assert_equal(5, ReturnInCatch())\n\n  # return in finally after empty catch\n  def ReturnInFinally(): number\n    try\n    finally\n      return 6\n    endtry\n  enddef\n  assert_equal(6, ReturnInFinally())\n\n  var lines =<< trim END\n      vim9script\n      try\n        acos('0.5')\n          ->setline(1)\n      catch\n        g:caught = v:exception\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_match('E1219: Float or Number required for argument 1', g:caught)\n  unlet g:caught\n\n  # missing catch and/or finally\n  lines =<< trim END\n      vim9script\n      try\n        echo 'something'\n      endtry\n  END\n  v9.CheckScriptFailure(lines, 'E1032:')\n\n  # skipping try-finally-endtry when try-finally-endtry is used in another block\n  lines =<< trim END\n      if v:true\n        try\n        finally\n        endtry\n      else\n        try\n        finally\n        endtry\n      endif\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_try_var_decl()\n  var lines =<< trim END\n      vim9script\n      try\n        var in_try = 1\n        assert_equal(1, get(s:, 'in_try', -1))\n        throw \"getout\"\n      catch\n        var in_catch = 2\n        assert_equal(-1, get(s:, 'in_try', -1))\n        assert_equal(2, get(s:, 'in_catch', -1))\n      finally\n        var in_finally = 3\n        assert_equal(-1, get(s:, 'in_try', -1))\n        assert_equal(-1, get(s:, 'in_catch', -1))\n        assert_equal(3, get(s:, 'in_finally', -1))\n      endtry\n      assert_equal(-1, get(s:, 'in_try', -1))\n      assert_equal(-1, get(s:, 'in_catch', -1))\n      assert_equal(-1, get(s:, 'in_finally', -1))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_try_ends_in_return()\n  var lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch\n          return 'caught'\n        endtry\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch\n          return 'caught'\n        endtry\n        echo 'notreached'\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptFailure(lines, 'E1095:')\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          return 'foo'\n        catch /x/\n          return 'caught'\n        endtry\n      enddef\n      assert_equal('foo', Foo())\n  END\n  v9.CheckScriptFailure(lines, 'E1027:')\n\n  lines =<< trim END\n      vim9script\n      def Foo(): string\n        try\n          echo 'foo'\n        catch\n          echo 'caught'\n        finally\n          return 'done'\n        endtry\n      enddef\n      assert_equal('done', Foo())\n  END\n  v9.CheckScriptSuccess(lines)\n\nenddef\n\ndef Test_try_in_catch()\n  var lines =<< trim END\n      vim9script\n      var seq = []\n      def DoIt()\n        try\n          seq->add('throw 1')\n          eval [][0]\n          seq->add('notreached')\n        catch\n          seq->add('catch')\n          try\n            seq->add('throw 2')\n            eval [][0]\n            seq->add('notreached')\n          catch /nothing/\n            seq->add('notreached')\n          endtry\n          seq->add('done')\n        endtry\n      enddef\n      DoIt()\n      assert_equal(['throw 1', 'catch', 'throw 2', 'done'], seq)\n  END\nenddef\n\ndef Test_error_in_catch()\n  var lines =<< trim END\n      try\n        eval [][0]\n      catch /E684:/\n        eval [][0]\n      endtry\n  END\n  v9.CheckDefExecFailure(lines, 'E684:', 4)\nenddef\n\n\" :while at the very start of a function that :continue jumps to\ndef s:TryContinueFunc()\n while g:Count < 2\n   g:sequence ..= 't'\n    try\n      echoerr 'Test'\n    catch\n      g:Count += 1\n      g:sequence ..= 'c'\n      continue\n    endtry\n    g:sequence ..= 'e'\n    g:Count += 1\n  endwhile\nenddef\n\ndef Test_continue_in_try_in_while()\n  g:Count = 0\n  g:sequence = ''\n  TryContinueFunc()\n  assert_equal('tctc', g:sequence)\n  unlet g:Count\n  unlet g:sequence\nenddef\n\ndef Test_break_in_try_in_for()\n  var lines =<< trim END\n      vim9script\n      def Ls(): list<string>\n        var ls: list<string>\n        for s in ['abc', 'def']\n          for _ in [123, 456]\n            try\n              eval [][0]\n            catch\n              break\n            endtry\n          endfor\n          ls += [s]\n        endfor\n        return ls\n      enddef\n      assert_equal(['abc', 'def'], Ls())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_nocatch_return_in_try()\n  # return in try block returns normally\n  def ReturnInTry(): string\n    try\n      return '\"some message\"'\n    catch\n    endtry\n    return 'not reached'\n  enddef\n  exe 'echoerr ' .. ReturnInTry()\nenddef\n\ndef Test_cnext_works_in_catch()\n  var lines =<< trim END\n      vim9script\n      au BufEnter * eval 1 + 2\n      writefile(['text'], 'Xfile1')\n      writefile(['text'], 'Xfile2')\n      var items = [\n          {lnum: 1, filename: 'Xfile1', valid: true},\n          {lnum: 1, filename: 'Xfile2', valid: true}\n        ]\n      setqflist([], ' ', {items: items})\n      cwindow\n\n      def CnextOrCfirst()\n        # if cnext fails, cfirst is used\n        try\n          cnext\n        catch\n          cfirst\n        endtry\n      enddef\n\n      CnextOrCfirst()\n      CnextOrCfirst()\n      writefile([getqflist({idx: 0}).idx], 'Xresult')\n      qall\n  END\n  writefile(lines, 'XCatchCnext')\n  g:RunVim([], [], '--clean -S XCatchCnext')\n  assert_equal(['1'], readfile('Xresult'))\n\n  delete('Xfile1')\n  delete('Xfile2')\n  delete('XCatchCnext')\n  delete('Xresult')\nenddef\n\ndef Test_throw_skipped()\n  if 0\n    throw dontgethere\n  endif\nenddef\n\ndef Test_nocatch_throw_silenced()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      throw 'error'\n    enddef\n    silent! Func()\n  END\n  writefile(lines, 'XthrowSilenced')\n  source XthrowSilenced\n  delete('XthrowSilenced')\nenddef\n\ndef DeletedFunc(): list<any>\n  return ['delete me']\nenddef\ndefcompile\ndelfunc DeletedFunc\n\ndef s:ThrowFromDef()\n  throw \"getout\" # comment\nenddef\n\nfunc s:CatchInFunc()\n  try\n    call s:ThrowFromDef()\n  catch\n    let g:thrown_func = v:exception\n  endtry\nendfunc\n\ndef s:CatchInDef()\n  try\n    ThrowFromDef()\n  catch\n    g:thrown_def = v:exception\n  endtry\nenddef\n\ndef s:ReturnFinally(): string\n  try\n    return 'intry'\n  finally\n    g:in_finally = 'finally'\n  endtry\n  return 'end'\nenddef\n\ndef Test_try_catch_nested()\n  CatchInFunc()\n  assert_equal('getout', g:thrown_func)\n\n  CatchInDef()\n  assert_equal('getout', g:thrown_def)\n\n  assert_equal('intry', ReturnFinally())\n  assert_equal('finally', g:in_finally)\n\n  var l = []\n  try\n    l->add('1')\n    throw 'bad'\n    l->add('x')\n  catch /bad/\n    l->add('2')\n    try\n      l->add('3')\n      throw 'one'\n      l->add('x')\n    catch /one/\n      l->add('4')\n      try\n        l->add('5')\n        throw 'more'\n        l->add('x')\n      catch /more/\n        l->add('6')\n      endtry\n    endtry\n  endtry\n  assert_equal(['1', '2', '3', '4', '5', '6'], l)\n\n  l = []\n  try\n    try\n      l->add('1')\n      throw 'foo'\n      l->add('x')\n    catch\n      l->add('2')\n      throw 'bar'\n      l->add('x')\n    finally\n      l->add('3')\n    endtry\n    l->add('x')\n  catch /bar/\n    l->add('4')\n  endtry\n  assert_equal(['1', '2', '3', '4'], l)\nenddef\n\ndef s:TryOne(): number\n  try\n    return 0\n  catch\n  endtry\n  return 0\nenddef\n\ndef s:TryTwo(n: number): string\n  try\n    var x = {}\n  catch\n  endtry\n  return 'text'\nenddef\n\ndef Test_try_catch_twice()\n  assert_equal('text', TryOne()->TryTwo())\nenddef\n\ndef Test_try_catch_match()\n  var seq = 'a'\n  try\n    throw 'something'\n  catch /nothing/\n    seq ..= 'x'\n  catch /some/\n    seq ..= 'b'\n  catch /asdf/\n    seq ..= 'x'\n  catch ?a\\?sdf?\n    seq ..= 'y'\n  finally\n    seq ..= 'c'\n  endtry\n  assert_equal('abc', seq)\nenddef\n\ndef Test_try_catch_fails()\n  v9.CheckDefFailure(['catch'], 'E603:')\n  v9.CheckDefFailure(['try', 'echo 0', 'catch', 'catch'], 'E1033:')\n  v9.CheckDefFailure(['try', 'echo 0', 'catch /pat'], 'E1067:')\n  v9.CheckDefFailure(['finally'], 'E606:')\n  v9.CheckDefFailure(['try', 'echo 0', 'finally', 'echo 1', 'finally'], 'E607:')\n  v9.CheckDefFailure(['endtry'], 'E602:')\n  v9.CheckDefFailure(['while 1', 'endtry'], 'E170:')\n  v9.CheckDefFailure(['for i in range(5)', 'endtry'], 'E170:')\n  v9.CheckDefFailure(['if 1', 'endtry'], 'E171:')\n  v9.CheckDefFailure(['try', 'echo 1', 'endtry'], 'E1032:')\n\n  v9.CheckDefFailure(['throw'], 'E1143:')\n  v9.CheckDefFailure(['throw xxx'], 'E1001:')\nenddef\n\ndef Try_catch_skipped()\n  var l = []\n  try\n  finally\n  endtry\n\n  if 1\n  else\n    try\n    endtry\n  endif\nenddef\n\n\" The skipped try/endtry was updating the wrong instruction.\ndef Test_try_catch_skipped()\n  var instr = execute('disassemble Try_catch_skipped')\n  assert_match(\"NEWLIST size 0\\n\", instr)\nenddef\n\ndef Test_throw_line_number()\n  def Func()\n    eval 1 + 1\n    eval 2 + 2\n    throw 'exception'\n  enddef\n  try\n    Func()\n  catch /exception/\n    assert_match('line 3', v:throwpoint)\n  endtry\nenddef\n\n\ndef Test_throw_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      try\n        throw 'one'\n              .. 'two'\n      catch\n        assert_equal('onetwo', v:exception)\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    @r = ''\n    def Func()\n      throw @r\n    enddef\n    var result = ''\n    try\n      Func()\n    catch /E1129:/\n      result = 'caught'\n    endtry\n    assert_equal('caught', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_error_in_nested_function()\n  # an error in a nested :function aborts executing in the calling :def function\n  var lines =<< trim END\n      vim9script\n      def Func()\n        Error()\n        g:test_var = 1\n      enddef\n      func Error() abort\n        eval [][0]\n      endfunc\n      Func()\n  END\n  g:test_var = 0\n  v9.CheckScriptFailure(lines, 'E684:')\n  assert_equal(0, g:test_var)\nenddef\n\ndef Test_abort_after_error()\n  var lines =<< trim END\n      vim9script\n      while true\n        echo notfound\n      endwhile\n      g:gotthere = true\n  END\n  g:gotthere = false\n  v9.CheckScriptFailure(lines, 'E121:')\n  assert_false(g:gotthere)\n  unlet g:gotthere\nenddef\n\ndef Test_cexpr_vimscript()\n  # only checks line continuation\n  set errorformat=File\\ %f\\ line\\ %l\n  var lines =<< trim END\n      vim9script\n      cexpr 'File'\n                .. ' someFile' ..\n                   ' line 19'\n      assert_equal(19, getqflist()[0].lnum)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      def CexprFail()\n        au QuickfixCmdPre * echo g:doesnotexist\n        cexpr 'File otherFile line 99'\n        g:didContinue = 'yes'\n      enddef\n      CexprFail()\n      g:didContinue = 'also'\n  END\n  g:didContinue = 'no'\n  v9.CheckScriptFailure(lines, 'E121: Undefined variable: g:doesnotexist')\n  assert_equal('no', g:didContinue)\n  au! QuickfixCmdPre\n\n  lines =<< trim END\n      vim9script\n      def CexprFail()\n        cexpr g:aNumber\n        g:didContinue = 'yes'\n      enddef\n      CexprFail()\n      g:didContinue = 'also'\n  END\n  g:aNumber = 123\n  g:didContinue = 'no'\n  v9.CheckScriptFailure(lines, 'E777: String or List expected')\n  assert_equal('no', g:didContinue)\n  unlet g:didContinue\n\n  set errorformat&\nenddef\n\ndef Test_statusline_syntax()\n  # legacy syntax is used for 'statusline'\n  var lines =<< trim END\n      vim9script\n      func g:Status()\n        return '%{\"x\" is# \"x\"}'\n      endfunc\n      set laststatus=2 statusline=%!Status()\n      redrawstatus\n      set laststatus statusline= \n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_vimscript()\n  # checks line continuation and comments\n  var lines =<< trim END\n      vim9script\n      var mylist = [\n            'one',\n            # comment\n            'two', # empty line follows\n\n            'three',\n            ]\n      assert_equal(['one', 'two', 'three'], mylist)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # check all lines from heredoc are kept\n  lines =<< trim END\n      # comment 1\n      two\n      # comment 3\n\n      five\n      # comment 6\n  END\n  assert_equal(['# comment 1', 'two', '# comment 3', '', 'five', '# comment 6'], lines)\n\n  lines =<< trim END\n    [{\n      a: 0}]->string()->assert_equal(\"[{'a': 0}]\")\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nif has('channel')\n  let someJob = test_null_job()\n\n  def FuncWithError()\n    echomsg g:someJob\n  enddef\n\n  func Test_convert_emsg_to_exception()\n    try\n      call FuncWithError()\n    catch\n      call assert_match('Vim:E908:', v:exception)\n    endtry\n  endfunc\nendif\n\ndef Test_vim9script_mix()\n  var lines =<< trim END\n    if has(g:feature)\n      \" legacy script\n      let g:legacy = 1\n      finish\n    endif\n    vim9script\n    g:legacy = 0\n  END\n  g:feature = 'eval'\n  g:legacy = -1\n  v9.CheckScriptSuccess(lines)\n  assert_equal(1, g:legacy)\n\n  g:feature = 'noteval'\n  g:legacy = -1\n  v9.CheckScriptSuccess(lines)\n  assert_equal(0, g:legacy)\nenddef\n\ndef Test_vim9script_fails()\n  v9.CheckScriptFailure(['scriptversion 2', 'vim9script'], 'E1039:')\n  v9.CheckScriptFailure(['vim9script', 'scriptversion 2'], 'E1040:')\n\n  v9.CheckScriptFailure(['vim9script', 'var str: string', 'str = 1234'], 'E1012:')\n  v9.CheckScriptFailure(['vim9script', 'const str = \"asdf\"', 'str = \"xxx\"'], 'E46:')\n\n  assert_fails('vim9script', 'E1038:')\n  v9.CheckDefFailure(['vim9script'], 'E1038:')\n\n  # no error when skipping\n  if has('nothing')\n    vim9script\n  endif\nenddef\n\ndef Test_script_var_shadows_function()\n  var lines =<< trim END\n      vim9script\n      def Func(): number\n        return 123\n      enddef\n      var Func = 1\n  END\n  v9.CheckScriptFailure(lines, 'E1041:', 5)\nenddef\n\ndef Test_function_shadows_script_var()\n  var lines =<< trim END\n      vim9script\n      var Func = 1\n      def Func(): number\n        return 123\n      enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1041:', 3)\nenddef\n\ndef Test_script_var_shadows_command()\n  var lines =<< trim END\n      var undo = 1\n      undo = 2\n      assert_equal(2, undo)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var undo = 1\n      undo\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1207:', 2)\nenddef\n\ndef Test_vim9script_call_wrong_type()\n  var lines =<< trim END\n      vim9script\n      var Time = 'localtime'\n      Time()\n  END\n  v9.CheckScriptFailure(lines, 'E1085:')\nenddef\n\ndef Test_vim9script_reload_delfunc()\n  var first_lines =<< trim END\n    vim9script\n    def FuncYes(): string\n      return 'yes'\n    enddef\n  END\n  var withno_lines =<< trim END\n    def FuncNo(): string\n      return 'no'\n    enddef\n    def g:DoCheck(no_exists: bool)\n      assert_equal('yes', FuncYes())\n      assert_equal('no', FuncNo())\n    enddef\n  END\n  var nono_lines =<< trim END\n    def g:DoCheck(no_exists: bool)\n      assert_equal('yes', FuncYes())\n      assert_fails('FuncNo()', 'E117:', '', 2, 'DoCheck')\n    enddef\n  END\n\n  # FuncNo() is defined\n  writefile(first_lines + withno_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(true)\n\n  # FuncNo() is not redefined\n  writefile(first_lines + nono_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(false)\n\n  # FuncNo() is back\n  writefile(first_lines + withno_lines, 'Xreloaded.vim')\n  source Xreloaded.vim\n  g:DoCheck(false)\n\n  delete('Xreloaded.vim')\nenddef\n\ndef Test_vim9script_reload_delvar()\n  # write the script with a script-local variable\n  var lines =<< trim END\n    vim9script\n    var name = 'string'\n  END\n  writefile(lines, 'XreloadVar.vim')\n  source XreloadVar.vim\n\n  # now write the script using the same variable locally - works\n  lines =<< trim END\n    vim9script\n    def Func()\n      var name = 'string'\n    enddef\n  END\n  writefile(lines, 'XreloadVar.vim')\n  source XreloadVar.vim\n\n  delete('XreloadVar.vim')\nenddef\n\ndef Test_func_redefine_error()\n  var lines = [\n        'vim9script',\n        'def Func()',\n        '  eval [][0]',\n        'enddef',\n        'Func()',\n        ]\n  writefile(lines, 'Xtestscript.vim')\n\n  for count in range(3)\n    try\n      source Xtestscript.vim\n    catch /E684/\n      # function name should contain <SNR> every time\n      assert_match('E684: List index out of range', v:exception)\n      assert_match('function <SNR>\\d\\+_Func, line 1', v:throwpoint)\n    endtry\n  endfor\n\n  delete('Xtestscript.vim')\nenddef\n\ndef Test_func_redefine_fails()\n  var lines =<< trim END\n    vim9script\n    def Func()\n      echo 'one'\n    enddef\n    def Func()\n      echo 'two'\n    enddef\n  END\n  v9.CheckScriptFailure(lines, 'E1073:')\n\n  lines =<< trim END\n    vim9script\n    def Foo(): string\n      return 'foo'\n    enddef\n    def Func()\n      var  Foo = {-> 'lambda'}\n    enddef\n    defcompile\n  END\n  v9.CheckScriptFailure(lines, 'E1073:')\nenddef\n\ndef Test_lambda_split()\n  # this was using freed memory, because of the split expression\n  var lines =<< trim END\n      vim9script\n      try\n      0\n      0->(0\n        ->a.0(\n        ->u\n  END\n  v9.CheckScriptFailure(lines, 'E1050:')\nenddef\n\ndef Test_fixed_size_list()\n  # will be allocated as one piece of memory, check that changes work\n  var l = [1, 2, 3, 4]\n  l->remove(0)\n  l->add(5)\n  l->insert(99, 1)\n  assert_equal([2, 99, 3, 4, 5], l)\nenddef\n\ndef Test_no_insert_xit()\n  v9.CheckDefExecFailure(['a = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['c = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['i = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['t = 1'], 'E1100:')\n  v9.CheckDefExecFailure(['x = 1'], 'E1100:')\n\n  v9.CheckScriptFailure(['vim9script', 'a = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'a'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'c = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'c'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'i = 1'], 'E488:')\n  v9.CheckScriptFailure(['vim9script', 'i'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'o = 1'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'o'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 't'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 't = 1'], 'E1100:')\n  v9.CheckScriptFailure(['vim9script', 'x = 1'], 'E1100:')\nenddef\n\ndef s:IfElse(what: number): string\n  var res = ''\n  if what == 1\n    res = \"one\"\n  elseif what == 2\n    res = \"two\"\n  else\n    res = \"three\"\n  endif\n  return res\nenddef\n\ndef Test_if_elseif_else()\n  assert_equal('one', IfElse(1))\n  assert_equal('two', IfElse(2))\n  assert_equal('three', IfElse(3))\nenddef\n\ndef Test_if_elseif_else_fails()\n  v9.CheckDefFailure(['elseif true'], 'E582:')\n  v9.CheckDefFailure(['else'], 'E581:')\n  v9.CheckDefFailure(['endif'], 'E580:')\n  v9.CheckDefFailure(['if g:abool', 'elseif xxx'], 'E1001:')\n  v9.CheckDefFailure(['if true', 'echo 1'], 'E171:')\n\n  var lines =<< trim END\n      var s = ''\n      if s = ''\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E488:')\n\n  lines =<< trim END\n      var s = ''\n      if s == ''\n      elseif s = ''\n      endif\n  END\n  v9.CheckDefFailure(lines, 'E488:')\n\n  lines =<< trim END\n      var cond = true\n      if cond\n        echo 'true'\n      elseif\n        echo 'false'\n      endif\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1143:', 'E15:'], 4)\nenddef\n\ndef Test_if_else_func_using_var()\n  var lines =<< trim END\n      vim9script\n\n      const debug = true\n      if debug\n        var mode_chars = 'something'\n        def Bits2Ascii()\n          var x = mode_chars\n          g:where = 'in true'\n        enddef\n      else\n        def Bits2Ascii()\n          g:where = 'in false'\n        enddef\n      endif\n\n      Bits2Ascii()\n  END\n  v9.CheckScriptSuccess(lines)\n  assert_equal('in true', g:where)\n  unlet g:where\n\n  lines =<< trim END\n      vim9script\n\n      const debug = false\n      if debug\n        var mode_chars = 'something'\n        def Bits2Ascii()\n          g:where = 'in true'\n        enddef\n      else\n        def Bits2Ascii()\n          var x = mode_chars\n          g:where = 'in false'\n        enddef\n      endif\n\n      Bits2Ascii()\n  END\n  v9.CheckScriptFailure(lines, 'E1001: Variable not found: mode_chars')\nenddef\n\nlet g:bool_true = v:true\nlet g:bool_false = v:false\n\ndef Test_if_const_expr()\n  var res = false\n  if true ? true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  g:glob = 2\n  if false\n    execute('g:glob = 3')\n  endif\n  assert_equal(2, g:glob)\n  if true\n    execute('g:glob = 3')\n  endif\n  assert_equal(3, g:glob)\n\n  res = false\n  if g:bool_true ? true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? g:bool_true : false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? true : g:bool_false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true ? false : true\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if false ? false : true\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if false ? true : false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if has('xyz') ? true : false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true && true\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if g:bool_true && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true && g:bool_false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if false && false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  res = false\n  if true || false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if g:bool_true || false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if true || g:bool_false\n    res = true\n  endif\n  assert_equal(true, res)\n\n  res = false\n  if false || false\n    res = true\n  endif\n  assert_equal(false, res)\n\n  # with constant \"false\" expression may be invalid so long as the syntax is OK\n  if false | eval 1 + 2 | endif\n  if false | eval burp + 234 | endif\n  if false | echo burp 234 'asd' | endif\n  if false\n    burp\n  endif\n\n  if 0\n    if 1\n      echo nothing\n    elseif 1\n      echo still nothing\n    endif\n  endif\n\n  # expression with line breaks skipped\n  if false\n      ('aaa'\n      .. 'bbb'\n      .. 'ccc'\n      )->setline(1)\n  endif\nenddef\n\ndef Test_if_const_expr_fails()\n  v9.CheckDefFailure(['if \"aaa\" == \"bbb'], 'E114:')\n  v9.CheckDefFailure([\"if 'aaa' == 'bbb\"], 'E115:')\n  v9.CheckDefFailure([\"if has('aaa'\"], 'E110:')\n  v9.CheckDefFailure([\"if has('aaa') ? true false\"], 'E109:')\nenddef\n\ndef s:RunNested(i: number): number\n  var x: number = 0\n  if i % 2\n    if 1\n      # comment\n    else\n      # comment\n    endif\n    x += 1\n  else\n    x += 1000\n  endif\n  return x\nenddef\n\ndef Test_nested_if()\n  assert_equal(1, RunNested(1))\n  assert_equal(1000, RunNested(2))\nenddef\n\ndef Test_execute_cmd()\n  # missing argument is ignored\n  execute\n  execute # comment\n\n  new\n  setline(1, 'default')\n  execute 'setline(1, \"execute-string\")'\n  assert_equal('execute-string', getline(1))\n\n  execute \"setline(1, 'execute-string')\"\n  assert_equal('execute-string', getline(1))\n\n  var cmd1 = 'setline(1,'\n  var cmd2 = '\"execute-var\")'\n  execute cmd1 cmd2 # comment\n  assert_equal('execute-var', getline(1))\n\n  execute cmd1 cmd2 '|setline(1, \"execute-var-string\")'\n  assert_equal('execute-var-string', getline(1))\n\n  var cmd_first = 'call '\n  var cmd_last = 'setline(1, \"execute-var-var\")'\n  execute cmd_first .. cmd_last\n  assert_equal('execute-var-var', getline(1))\n  bwipe!\n\n  var n = true\n  execute 'echomsg' (n ? '\"true\"' : '\"no\"')\n  assert_match('^true$', g:Screenline(&lines))\n\n  echomsg [1, 2, 3] {a: 1, b: 2}\n  assert_match('^\\[1, 2, 3\\] {''a'': 1, ''b'': 2}$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['execute xxx'], 'E1001:', 1)\n  v9.CheckDefExecFailure(['execute \"tabnext \" .. 8'], 'E475:', 1)\n  v9.CheckDefFailure(['execute \"cmd\"# comment'], 'E488:', 1)\n  if has('channel')\n    v9.CheckDefExecFailure(['execute test_null_channel()'], 'E908:', 1)\n  endif\nenddef\n\ndef Test_execute_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      execute 'g:someVar'\n                .. ' = ' ..\n                   '28'\n      assert_equal(28, g:someVar)\n      unlet g:someVar\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_execute_finish()\n  # the empty lines are relevant here\n  var lines =<< trim END\n      vim9script\n\n      var vname = \"g:hello\"\n\n      if exists(vname) | finish | endif | execute vname '= \"world\"'\n\n      assert_equal('world', g:hello)\n\n      if exists(vname) | finish | endif | execute vname '= \"world\"'\n\n      assert_report('should not be reached')\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echo_cmd()\n  echo 'some' # comment\n  echon 'thing'\n  assert_match('^something$', g:Screenline(&lines))\n\n  echo \"some\" # comment\n  echon \"thing\"\n  assert_match('^something$', g:Screenline(&lines))\n\n  var str1 = 'some'\n  var str2 = 'more'\n  echo str1 str2\n  assert_match('^some more$', g:Screenline(&lines))\n\n  echo \"one\\ntwo\"\n  assert_match('^one$', g:Screenline(&lines - 1))\n  assert_match('^two$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['echo \"xxx\"# comment'], 'E488:')\nenddef\n\ndef Test_echomsg_cmd()\n  echomsg 'some' 'more' # comment\n  assert_match('^some more$', g:Screenline(&lines))\n  echo 'clear'\n  :1messages\n  assert_match('^some more$', g:Screenline(&lines))\n\n  v9.CheckDefFailure(['echomsg \"xxx\"# comment'], 'E488:')\nenddef\n\ndef Test_echomsg_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      echomsg 'here'\n                .. ' is ' ..\n                   'a message'\n      assert_match('^here is a message$', g:Screenline(&lines))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echoerr_cmd()\n  var local = 'local'\n  try\n    echoerr 'something' local 'wrong' # comment\n  catch\n    assert_match('something local wrong', v:exception)\n  endtry\nenddef\n\ndef Test_echoerr_cmd_vimscript()\n  # only checks line continuation\n  var lines =<< trim END\n      vim9script\n      try\n        echoerr 'this'\n                .. ' is ' ..\n                   'wrong'\n      catch\n        assert_match('this is wrong', v:exception)\n      endtry\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_echoconsole_cmd()\n  var local = 'local'\n  echoconsole 'something' local # comment\n  # output goes anywhere\nenddef\n\ndef Test_for_outside_of_function()\n  var lines =<< trim END\n    vim9script\n    new\n    for var in range(0, 3)\n      append(line('$'), var)\n    endfor\n    assert_equal(['', '0', '1', '2', '3'], getline(1, '$'))\n    bwipe!\n\n    var result = ''\n    for i in [1, 2, 3]\n      var loop = ' loop ' .. i\n      result ..= loop\n    endfor\n    assert_equal(' loop 1 loop 2 loop 3', result)\n  END\n  writefile(lines, 'Xvim9for.vim')\n  source Xvim9for.vim\n  delete('Xvim9for.vim')\nenddef\n\ndef Test_for_skipped_block()\n  # test skipped blocks at outside of function\n  var lines =<< trim END\n    var result = []\n    if true\n      for n in [1, 2]\n        result += [n]\n      endfor\n    else\n      for n in [3, 4]\n        result += [n]\n      endfor\n    endif\n    assert_equal([1, 2], result)\n\n    result = []\n    if false\n      for n in [1, 2]\n        result += [n]\n      endfor\n    else\n      for n in [3, 4]\n        result += [n]\n      endfor\n    endif\n    assert_equal([3, 4], result)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # test skipped blocks at inside of function\n  lines =<< trim END\n    def DefTrue()\n      var result = []\n      if true\n        for n in [1, 2]\n          result += [n]\n        endfor\n      else\n        for n in [3, 4]\n          result += [n]\n        endfor\n      endif\n      assert_equal([1, 2], result)\n    enddef\n    DefTrue()\n\n    def DefFalse()\n      var result = []\n      if false\n        for n in [1, 2]\n          result += [n]\n        endfor\n      else\n        for n in [3, 4]\n          result += [n]\n        endfor\n      endif\n      assert_equal([3, 4], result)\n    enddef\n    DefFalse()\n\n    def BuildDiagrams()\n      var diagrams: list<any>\n      if false\n        var max = 0\n        for v in diagrams\n          var l = 3\n          if max < l | max = l | endif\n          v->add(l)\n        endfor\n      endif\n    enddef\n    BuildDiagrams()\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_skipped_redir()\n  var lines =<< trim END\n      def T()\n        if 0\n          redir =>l[0]\n          redir END\n        endif\n      enddef\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_for_loop()\n  var lines =<< trim END\n      var result = ''\n      for cnt in range(7)\n        if cnt == 4\n          break\n        endif\n        if cnt == 2\n          continue\n        endif\n        result ..= cnt .. '_'\n      endfor\n      assert_equal('0_1_3_', result)\n\n      var concat = ''\n      for str in eval('[\"one\", \"two\"]')\n        concat ..= str\n      endfor\n      assert_equal('onetwo', concat)\n\n      var total = 0\n      for nr in\n          [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for nr\n        in [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for nr\n        in\n        [1, 2, 3]\n        total += nr\n      endfor\n      assert_equal(6, total)\n\n      # with type\n      total = 0\n      for n: number in [1, 2, 3]\n        total += n\n      endfor\n      assert_equal(6, total)\n\n      total = 0\n      for b in 0z010203\n        total += b\n      endfor\n      assert_equal(6, total)\n\n      var chars = ''\n      for s: string in 'foobar'\n        chars ..= s\n      endfor\n      assert_equal('foobar', chars)\n\n      chars = ''\n      for x: string in {a: 'a', b: 'b'}->values()\n        chars ..= x\n      endfor\n      assert_equal('ab', chars)\n\n      # unpack with type\n      var res = ''\n      for [n: number, s: string] in [[1, 'a'], [2, 'b']]\n        res ..= n .. s\n      endfor\n      assert_equal('1a2b', res)\n\n      # unpack with one var\n      var reslist = []\n      for [x] in [['aaa'], ['bbb']]\n        reslist->add(x)\n      endfor\n      assert_equal(['aaa', 'bbb'], reslist)\n\n      # loop over string\n      res = ''\n      for c in 'a\u00e9c\u0300d'\n        res ..= c .. '-'\n      endfor\n      assert_equal('a-\u00e9-c\u0300-d-', res)\n\n      res = ''\n      for c in ''\n        res ..= c .. '-'\n      endfor\n      assert_equal('', res)\n\n      res = ''\n      for c in test_null_string()\n        res ..= c .. '-'\n      endfor\n      assert_equal('', res)\n\n      total = 0\n      for c in null_list\n        total += 1\n      endfor\n      assert_equal(0, total)\n\n      for c in null_blob\n        total += 1\n      endfor\n      assert_equal(0, total)\n\n      var foo: list<dict<any>> = [\n              {a: 'Cat'}\n            ]\n      for dd in foo\n        dd.counter = 12\n      endfor\n      assert_equal([{a: 'Cat', counter: 12}], foo)\n\n      reslist = []\n      for _ in range(3)\n        reslist->add('x')\n      endfor\n      assert_equal(['x', 'x', 'x'], reslist)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop_with_closure()\n  var lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        flist[i] = () => inloop\n      endfor\n      for i in range(5)\n        assert_equal(4, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      var flist: list<func>\n      for i in range(5)\n        var inloop = i\n        flist[i] = () => {\n              return inloop\n            }\n      endfor\n      for i in range(5)\n        assert_equal(4, flist[i]())\n      endfor\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_for_loop_fails()\n  v9.CheckDefAndScriptFailure(['for '], ['E1097:', 'E690:'])\n  v9.CheckDefAndScriptFailure(['for x'], ['E1097:', 'E690:'])\n  v9.CheckDefAndScriptFailure(['for x in'], ['E1097:', 'E15:'])\n  v9.CheckDefAndScriptFailure(['for # in range(5)'], 'E690:')\n  v9.CheckDefAndScriptFailure(['for i In range(5)'], 'E690:')\n  v9.CheckDefAndScriptFailure(['var x = 5', 'for x in range(5)', 'endfor'], ['E1017:', 'E1041:'])\n  v9.CheckScriptFailure(['vim9script', 'var x = 5', 'for x in range(5)', '# comment', 'endfor'], 'E1041:', 3)\n  v9.CheckScriptFailure(['def Func(arg: any)', 'for arg in range(5)', 'enddef', 'defcompile'], 'E1006:')\n  delfunc! g:Func\n  v9.CheckDefFailure(['for i in xxx'], 'E1001:')\n  v9.CheckDefFailure(['endfor'], 'E588:')\n  v9.CheckDefFailure(['for i in range(3)', 'echo 3'], 'E170:')\n\n  # wrong type detected at compile time\n  v9.CheckDefFailure(['for i in {a: 1}', 'echo 3', 'endfor'], 'E1177: For loop on dict not supported')\n\n  # wrong type detected at runtime\n  g:adict = {a: 1}\n  v9.CheckDefExecFailure(['for i in g:adict', 'echo 3', 'endfor'], 'E1177: For loop on dict not supported')\n  unlet g:adict\n\n  var lines =<< trim END\n      var d: list<dict<any>> = [{a: 0}]\n      for e in d\n        e = {a: 0, b: ''}\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E1018:', 'E46:'], 3)\n\n  lines =<< trim END\n      for nr: number in ['foo']\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1012: Type mismatch; expected number but got string', 1)\n\n  lines =<< trim END\n      for n : number in [1, 2]\n        echo n\n      endfor\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1059:', 1)\n\n  lines =<< trim END\n      var d: dict<number> = {a: 1, b: 2}\n      for [k: job, v: job] in d->items()\n        echo k v\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1163: Variable 1: type mismatch, expected job but got string', 'E1012: Type mismatch; expected job but got string'], 2)\n\n  lines =<< trim END\n      var i = 0\n      for i in [1, 2, 3]\n        echo i\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E1017:', 'E1041:'])\n\n  lines =<< trim END\n      var l = [0]\n      for l[0] in [1, 2, 3]\n        echo l[0]\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E461:', 'E1017:'])\n\n  lines =<< trim END\n      var d = {x: 0}\n      for d.x in [1, 2, 3]\n        echo d.x\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E461:', 'E1017:'])\n\n  lines =<< trim END\n      var l: list<dict<any>> = [{a: 1, b: 'x'}]\n      for item: dict<number> in l\n        echo item\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1012: Type mismatch; expected dict<number> but got dict<any>')\n\n  lines =<< trim END\n      var l: list<dict<any>> = [{n: 1}]\n      for item: dict<number> in l\n        item->extend({s: ''})\n      endfor\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1013: Argument 2: type mismatch, expected dict<number> but got dict<string>')\nenddef\n\ndef Test_for_loop_script_var()\n  # cannot use s:var in a :def function\n  v9.CheckDefFailure(['for s:var in range(3)', 'echo 3'], 'E1254:')\n\n  # can use s:var in Vim9 script, with or without s:\n  var lines =<< trim END\n    vim9script\n    var total = 0\n    for s:var in [1, 2, 3]\n      total += s:var\n    endfor\n    assert_equal(6, total)\n\n    total = 0\n    for var in [1, 2, 3]\n      total += var\n    endfor\n    assert_equal(6, total)\n  END\nenddef\n\ndef Test_for_loop_unpack()\n  var lines =<< trim END\n      var result = []\n      for [v1, v2] in [[1, 2], [3, 4]]\n        result->add(v1)\n        result->add(v2)\n      endfor\n      assert_equal([1, 2, 3, 4], result)\n\n      result = []\n      for [v1, v2; v3] in [[1, 2], [3, 4, 5, 6]]\n        result->add(v1)\n        result->add(v2)\n        result->add(v3)\n      endfor\n      assert_equal([1, 2, [], 3, 4, [5, 6]], result)\n\n      result = []\n      for [&ts, &sw] in [[1, 2], [3, 4]]\n        result->add(&ts)\n        result->add(&sw)\n      endfor\n      assert_equal([1, 2, 3, 4], result)\n\n      var slist: list<string>\n      for [$LOOPVAR, @r, v:errmsg] in [['a', 'b', 'c'], ['d', 'e', 'f']]\n        slist->add($LOOPVAR)\n        slist->add(@r)\n        slist->add(v:errmsg)\n      endfor\n      assert_equal(['a', 'b', 'c', 'd', 'e', 'f'], slist)\n\n      slist = []\n      for [g:globalvar, b:bufvar, w:winvar, t:tabvar] in [['global', 'buf', 'win', 'tab'], ['1', '2', '3', '4']]\n        slist->add(g:globalvar)\n        slist->add(b:bufvar)\n        slist->add(w:winvar)\n        slist->add(t:tabvar)\n      endfor\n      assert_equal(['global', 'buf', 'win', 'tab', '1', '2', '3', '4'], slist)\n      unlet! g:globalvar b:bufvar w:winvar t:tabvar\n\n      var res = []\n      for [_, n, _] in [[1, 2, 3], [4, 5, 6]]\n        res->add(n)\n      endfor\n      assert_equal([2, 5], res)\n\n      var text: list<string> = [\"hello there\", \"goodbye now\"]\n      var splitted = ''\n      for [first; next] in mapnew(text, (i, v) => split(v))\n          splitted ..= string(first) .. string(next) .. '/'\n      endfor\n      assert_equal(\"'hello'['there']/'goodbye'['now']/\", splitted)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  lines =<< trim END\n      for [v1, v2] in [[1, 2, 3], [3, 4]]\n        echo v1 v2\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E710:', 1)\n\n  lines =<< trim END\n      for [v1, v2] in [[1], [3, 4]]\n        echo v1 v2\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E711:', 1)\n\n  lines =<< trim END\n      for [v1, v1] in [[1, 2], [3, 4]]\n        echo v1\n      endfor\n  END\n  v9.CheckDefExecFailure(lines, 'E1017:', 1)\n\n  lines =<< trim END\n      for [a, b] in g:listlist\n        echo a\n      endfor\n  END\n  g:listlist = [1, 2, 3]\n  v9.CheckDefExecFailure(lines, 'E1140:', 1)\nenddef\n\ndef Test_for_loop_with_try_continue()\n  var lines =<< trim END\n      var looped = 0\n      var cleanup = 0\n      for i in range(3)\n        looped += 1\n        try\n          eval [][0]\n        catch\n          continue\n        finally\n          cleanup += 1\n        endtry\n      endfor\n      assert_equal(3, looped)\n      assert_equal(3, cleanup)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_while_skipped_block()\n  # test skipped blocks at outside of function\n  var lines =<< trim END\n    var result = []\n    var n = 0\n    if true\n      n = 1\n      while n < 3\n        result += [n]\n        n += 1\n      endwhile\n    else\n      n = 3\n      while n < 5\n        result += [n]\n        n += 1\n      endwhile\n    endif\n    assert_equal([1, 2], result)\n\n    result = []\n    if false\n      n = 1\n      while n < 3\n        result += [n]\n        n += 1\n      endwhile\n    else\n      n = 3\n      while n < 5\n        result += [n]\n        n += 1\n      endwhile\n    endif\n    assert_equal([3, 4], result)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\n\n  # test skipped blocks at inside of function\n  lines =<< trim END\n    def DefTrue()\n      var result = []\n      var n = 0\n      if true\n        n = 1\n        while n < 3\n          result += [n]\n          n += 1\n        endwhile\n      else\n        n = 3\n        while n < 5\n          result += [n]\n          n += 1\n        endwhile\n      endif\n      assert_equal([1, 2], result)\n    enddef\n    DefTrue()\n\n    def DefFalse()\n      var result = []\n      var n = 0\n      if false\n        n = 1\n        while n < 3\n          result += [n]\n          n += 1\n        endwhile\n      else\n        n = 3\n        while n < 5\n          result += [n]\n          n += 1\n        endwhile\n      endif\n      assert_equal([3, 4], result)\n    enddef\n    DefFalse()\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\ndef Test_while_loop()\n  var result = ''\n  var cnt = 0\n  while cnt < 555\n    if cnt == 3\n      break\n    endif\n    cnt += 1\n    if cnt == 2\n      continue\n    endif\n    result ..= cnt .. '_'\n  endwhile\n  assert_equal('1_3_', result)\n\n  var s = ''\n  while s == 'x' # {comment}\n  endwhile\nenddef\n\ndef Test_while_loop_in_script()\n  var lines =<< trim END\n      vim9script\n      var result = ''\n      var cnt = 0\n      while cnt < 3\n        var s = 'v' .. cnt\n        result ..= s\n        cnt += 1\n      endwhile\n      assert_equal('v0v1v2', result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_while_loop_fails()\n  v9.CheckDefFailure(['while xxx'], 'E1001:')\n  v9.CheckDefFailure(['endwhile'], 'E588:')\n  v9.CheckDefFailure(['continue'], 'E586:')\n  v9.CheckDefFailure(['if true', 'continue'], 'E586:')\n  v9.CheckDefFailure(['break'], 'E587:')\n  v9.CheckDefFailure(['if true', 'break'], 'E587:')\n  v9.CheckDefFailure(['while 1', 'echo 3'], 'E170:')\n\n  var lines =<< trim END\n      var s = ''\n      while s = ''\n      endwhile\n  END\n  v9.CheckDefFailure(lines, 'E488:')\nenddef\n\ndef Test_interrupt_loop()\n  var caught = false\n  var x = 0\n  try\n    while 1\n      x += 1\n      if x == 100\n        feedkeys(\"\\<C-C>\", 'Lt')\n      endif\n    endwhile\n  catch\n    caught = true\n    assert_equal(100, x)\n  endtry\n  assert_true(caught, 'should have caught an exception')\n  # consume the CTRL-C\n  getchar(0)\nenddef\n\ndef Test_automatic_line_continuation()\n  var mylist = [\n      'one',\n      'two',\n      'three',\n      ] # comment\n  assert_equal(['one', 'two', 'three'], mylist)\n\n  var mydict = {\n      ['one']: 1,\n      ['two']: 2,\n      ['three']:\n          3,\n      } # comment\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n  mydict = {\n      one: 1,  # comment\n      two:     # comment\n           2,  # comment\n      three: 3 # comment\n      }\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n  mydict = {\n      one: 1, \n      two: \n           2, \n      three: 3 \n      }\n  assert_equal({one: 1, two: 2, three: 3}, mydict)\n\n  assert_equal(\n        ['one', 'two', 'three'],\n        split('one two three')\n        )\nenddef\n\ndef Test_vim9_comment()\n  v9.CheckScriptSuccess([\n      'vim9script',\n      '# something',\n      '#something',\n      '#{{something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      '#{something',\n      ], 'E1170:')\n\n  split Xfile\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'edit #something',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'edit #{something',\n      ])\n  close\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      ':# something',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      '# something',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      ':# something',\n      ], 'E488:')\n\n  { # block start\n  } # block end\n  v9.CheckDefFailure([\n      '{# comment',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      '{',\n      '}# comment',\n      ], 'E488:')\n\n  echo \"yes\" # comment\n  v9.CheckDefFailure([\n      'echo \"yes\"# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'echo \"yes\" # something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'echo \"yes\"# something',\n      ], 'E121:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'echo# something',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'echo \"yes\" # something',\n      ], 'E121:')\n\n  exe \"echo\" # comment\n  v9.CheckDefFailure([\n      'exe \"echo\"# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'exe \"echo\" # something',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'exe \"echo\"# something',\n      ], 'E121:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'exe# something',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'exe \"echo\" # something',\n      ], 'E121:')\n\n  v9.CheckDefFailure([\n      'try# comment',\n      '  echo \"yes\"',\n      'catch',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try# comment',\n      'echo \"yes\"',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  throw#comment',\n      'catch',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  throw \"yes\"#comment',\n      'catch',\n      'endtry',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      'try',\n      '  echo \"yes\"',\n      'catch# comment',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try',\n      '  echo \"yes\"',\n      'catch# comment',\n      'endtry',\n      ], 'E1144:')\n  v9.CheckDefFailure([\n      'try',\n      '  echo \"yes\"',\n      'catch /pat/# comment',\n      'endtry',\n      ], 'E488:')\n  v9.CheckDefFailure([\n      'try',\n      'echo \"yes\"',\n      'catch',\n      'endtry# comment',\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'try',\n      '  echo \"yes\"',\n      'catch',\n      'endtry# comment',\n      ], 'E1144:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi Search # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi Search# comment',\n      ], 'E416:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi link This Search # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi link This That# comment',\n      ], 'E413:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi clear This # comment',\n      'hi clear # comment',\n      ])\n  # not tested, because it doesn't give an error but a warning:\n  # hi clear This# comment',\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi clear# comment',\n      ], 'E416:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'hi Group term=bold',\n      'match Group /todo/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'hi Group term=bold',\n      'match Group /todo/# comment',\n      ], 'E488:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'match # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'match# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'match none # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'match none# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'menutrans clear # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'menutrans clear# comment text',\n      ], 'E474:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax clear # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax clear# comment text',\n      ], 'E28:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax keyword Word some',\n      'syntax clear Word # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax keyword Word some',\n      'syntax clear Word# comment text',\n      ], 'E28:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax list # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax list# comment text',\n      ], 'E28:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ oneline # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ oneline# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax keyword Word word # comm[ent',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax keyword Word word# comm[ent',\n      ], 'E789:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/# comment',\n      ], 'E402:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax match Word /pat/ contains=Something # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains=Something# comment',\n      ], 'E475:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains= # comment',\n      ], 'E406:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax match Word /pat/ contains=# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax region Word start=/pat/ end=/pat/ # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax region Word start=/pat/ end=/pat/# comment',\n      ], 'E402:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax sync # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax sync# comment',\n      ], 'E404:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax sync ccomment # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax sync ccomment# comment',\n      ], 'E404:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'syntax cluster Some contains=Word # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'syntax cluster Some contains=Word# comment',\n      ], 'E475:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'command Echo echo # comment',\n      'command Echo # comment',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo echo# comment',\n      'Echo',\n      ], 'E1144:')\n  delcommand Echo\n\n  var curdir = getcwd()\n  v9.CheckScriptSuccess([\n      'command Echo cd \" comment',\n      'Echo',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'command Echo cd # comment',\n      'Echo',\n      'delcommand Echo',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo cd \" comment',\n      'Echo',\n      ], 'E344:')\n  delcommand Echo\n  chdir(curdir)\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo# comment',\n      ], 'E182:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'command Echo echo',\n      'command Echo# comment',\n      ], 'E182:')\n  delcommand Echo\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'function # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'function \" comment',\n      ], 'E129:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'function# comment',\n      ], 'E1144:')\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'import \"./vim9.vim\" as v9',\n      'function v9.CheckScriptSuccess # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'import \"./vim9.vim\" as v9',\n      'function v9.CheckScriptSuccess# comment',\n      ], 'E1048: Item not found in script: CheckScriptSuccess#')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func g:DeleteMeA()',\n      'endfunc',\n      'delfunction g:DeleteMeA # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func g:DeleteMeB()',\n      'endfunc',\n      'delfunction g:DeleteMeB# comment',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'call execute(\"ls\") # comment',\n      ])\n  v9.CheckScriptFailure([\n      'vim9script',\n      'call execute(\"ls\")# comment',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'def Test() \" comment',\n      'enddef',\n      ], 'E488:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'def Test() \" comment',\n      'enddef',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'func Test() \" comment',\n      'endfunc',\n      'delfunc Test',\n      ])\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'func Test() \" comment',\n      'endfunc',\n      ])\n\n  v9.CheckScriptSuccess([\n      'def Test() # comment',\n      'enddef',\n      ])\n  v9.CheckScriptFailure([\n      'func Test() # comment',\n      'endfunc',\n      ], 'E488:')\n\n  var lines =<< trim END\n      vim9script\n      syn region Text\n      \\ start='foo'\n      #\\ comment\n      \\ end='bar'\n      syn region Text start='foo'\n      #\\ comment\n      \\ end='bar'\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      syn region Text\n      \\ start='foo'\n      \"\\ comment\n      \\ end='bar'\n  END\n  v9.CheckScriptFailure(lines, 'E399:')\nenddef\n\ndef Test_vim9_comment_gui()\n  CheckCanRunGui\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'gui#comment'\n      ], 'E1144:')\n  v9.CheckScriptFailure([\n      'vim9script',\n      'gui -f#comment'\n      ], 'E194:')\nenddef\n\ndef Test_vim9_comment_not_compiled()\n  au TabEnter *.vim g:entered = 1\n  au TabEnter *.x g:entered = 2\n\n  edit test.vim\n  doautocmd TabEnter #comment\n  assert_equal(1, g:entered)\n\n  doautocmd TabEnter f.x\n  assert_equal(2, g:entered)\n\n  g:entered = 0\n  doautocmd TabEnter f.x #comment\n  assert_equal(2, g:entered)\n\n  assert_fails('doautocmd Syntax#comment', 'E216:')\n\n  au! TabEnter\n  unlet g:entered\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'g:var = 123',\n      'b:var = 456',\n      'w:var = 777',\n      't:var = 888',\n      'unlet g:var w:var # something',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'let var = 123',\n      ], 'E1126: Cannot use :let in Vim9 script')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var g:var = 123',\n      ], 'E1016: Cannot declare a global variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var b:var = 123',\n      ], 'E1016: Cannot declare a buffer variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var w:var = 123',\n      ], 'E1016: Cannot declare a window variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var t:var = 123',\n      ], 'E1016: Cannot declare a tab variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var v:version = 123',\n      ], 'E1016: Cannot declare a v: variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var $VARIABLE = \"text\"',\n      ], 'E1016: Cannot declare an environment variable:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'g:var = 123',\n      'unlet g:var# comment1',\n      ], 'E108:')\n\n  v9.CheckScriptFailure([\n      'let g:var = 123',\n      'unlet g:var # something',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'if 1 # comment2',\n      '  echo \"yes\"',\n      'elseif 2 #comment',\n      '  echo \"no\"',\n      'endif',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'if 1# comment3',\n      '  echo \"yes\"',\n      'endif',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'if 0 # comment4',\n      '  echo \"yes\"',\n      'elseif 2#comment',\n      '  echo \"no\"',\n      'endif',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'var v = 1 # comment5',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'var v = 1# comment6',\n      ], 'E488:')\n\n  v9.CheckScriptSuccess([\n      'vim9script',\n      'new'\n      'setline(1, [\"# define pat\", \"last\"])',\n      ':$',\n      'dsearch /pat/ #comment',\n      'bwipe!',\n      ])\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'new'\n      'setline(1, [\"# define pat\", \"last\"])',\n      ':$',\n      'dsearch /pat/#comment',\n      'bwipe!',\n      ], 'E488:')\n\n  v9.CheckScriptFailure([\n      'vim9script',\n      'func! SomeFunc()',\n      ], 'E477:')\nenddef\n\ndef Test_finish()\n  var lines =<< trim END\n    vim9script\n    g:res = 'one'\n    if v:false | finish | endif\n    g:res = 'two'\n    finish\n    g:res = 'three'\n  END\n  writefile(lines, 'Xfinished')\n  source Xfinished\n  assert_equal('two', g:res)\n\n  unlet g:res\n  delete('Xfinished')\nenddef\n\ndef Test_forward_declaration()\n  var lines =<< trim END\n    vim9script\n    def GetValue(): string\n      return theVal\n    enddef\n    var theVal = 'something'\n    g:initVal = GetValue()\n    theVal = 'else'\n    g:laterVal = GetValue()\n  END\n  writefile(lines, 'Xforward')\n  source Xforward\n  assert_equal('something', g:initVal)\n  assert_equal('else', g:laterVal)\n\n  unlet g:initVal\n  unlet g:laterVal\n  delete('Xforward')\nenddef\n\ndef Test_declare_script_var_in_func()\n  var lines =<< trim END\n      vim9script\n      func Declare()\n        let s:local = 123\n      endfunc\n      Declare()\n  END\n  v9.CheckScriptFailure(lines, 'E1269:')\nenddef\n        \ndef Test_lock_script_var()\n  var lines =<< trim END\n      vim9script\n      var local = 123\n      assert_equal(123, local)\n\n      var error: string\n      try\n        local = 'asdf'\n      catch\n        error = v:exception\n      endtry\n      assert_match('E1012: Type mismatch; expected number but got string', error)\n\n      lockvar local\n      try\n        local = 999\n      catch\n        error = v:exception\n      endtry\n      assert_match('E741: Value is locked: local', error)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n        \n\nfunc Test_vim9script_not_global()\n  \" check that items defined in Vim9 script are script-local, not global\n  let vim9lines =<< trim END\n    vim9script\n    var name = 'local'\n    func TheFunc()\n      echo 'local'\n    endfunc\n    def DefFunc()\n      echo 'local'\n    enddef\n  END\n  call writefile(vim9lines, 'Xvim9script.vim')\n  source Xvim9script.vim\n  try\n    echo g:var\n    assert_report('did not fail')\n  catch /E121:/\n    \" caught\n  endtry\n  try\n    call TheFunc()\n    assert_report('did not fail')\n  catch /E117:/\n    \" caught\n  endtry\n  try\n    call DefFunc()\n    assert_report('did not fail')\n  catch /E117:/\n    \" caught\n  endtry\n\n  call delete('Xvim9script.vim')\nendfunc\n\ndef Test_vim9_copen()\n  # this was giving an error for setting w:quickfix_title\n  copen\n  quit\nenddef\n\ndef Test_script_var_in_autocmd()\n  # using a script variable from an autocommand, defined in a :def function in a\n  # legacy Vim script, cannot check the variable type.\n  var lines =<< trim END\n    let s:counter = 1\n    def s:Func()\n      au! CursorHold\n      au CursorHold * s:counter += 1\n    enddef\n    call s:Func()\n    doau CursorHold\n    call assert_equal(2, s:counter)\n    au! CursorHold\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_error_in_autoload_script()\n  var save_rtp = &rtp\n  var dir = getcwd() .. '/Xruntime'\n  &rtp = dir\n  mkdir(dir .. '/autoload', 'p')\n\n  var lines =<< trim END\n      vim9script noclear\n      export def Autoloaded()\n      enddef\n      def Broken()\n        var x: any = ''\n        eval x != 0\n      enddef\n      Broken()\n  END\n  writefile(lines, dir .. '/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      def CallAutoloaded()\n        script#Autoloaded()\n      enddef\n\n      function Legacy()\n        try\n          call s:CallAutoloaded()\n        catch\n          call assert_match('E1030: Using a String as a Number', v:exception)\n        endtry\n      endfunction\n\n      Legacy()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  &rtp = save_rtp\n  delete(dir, 'rf')\nenddef\n\ndef Test_error_in_autoload_script_foldexpr()\n  var save_rtp = &rtp\n  mkdir('Xvim/autoload', 'p')\n  &runtimepath = 'Xvim'\n\n  var lines =<< trim END\n      vim9script\n      eval [][0]\n      echomsg 'no error'\n  END\n  lines->writefile('Xvim/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      import autoload 'script.vim'\n      &foldmethod = 'expr'\n      &foldexpr = 'script.Func()'\n      redraw\n  END\n  v9.CheckScriptFailure(lines, 'E684: List index out of range: 0')\n\n  delete('Xvim', 'rf')\nenddef\n\ndef Test_invalid_sid()\n  assert_fails('func <SNR>1234_func', 'E123:')\n\n  if g:RunVim([], ['wq! Xdidit'], '+\"func <SNR>1_func\"')\n    assert_equal([], readfile('Xdidit'))\n  endif\n  delete('Xdidit')\nenddef\n\ndef Test_restoring_cpo()\n  writefile(['vim9script', 'set nocp'], 'Xsourced')\n  writefile(['call writefile([\"done\"], \"Xdone\")', 'quit!'], 'Xclose')\n  if g:RunVim([], [], '-u NONE +\"set cpo+=a\" -S Xsourced -S Xclose')\n    assert_equal(['done'], readfile('Xdone'))\n  endif\n  delete('Xsourced')\n  delete('Xclose')\n  delete('Xdone')\n\n  writefile(['vim9script', 'g:cpoval = &cpo'], 'XanotherScript')\n  set cpo=aABceFsMny>\n  edit XanotherScript\n  so %\n  assert_equal('aABceFsMny>', &cpo)\n  assert_equal('aABceFs', g:cpoval)\n  :1del\n  setline(1, 'let g:cpoval = &cpo')\n  w\n  so %\n  assert_equal('aABceFsMny>', &cpo)\n  assert_equal('aABceFsMny>', g:cpoval)\n\n  delete('XanotherScript')\n  set cpo&vim\n  unlet g:cpoval\n\n  if has('unix')\n    # 'cpo' is not restored in main vimrc\n    var save_HOME = $HOME\n    $HOME = getcwd() .. '/Xhome'\n    mkdir('Xhome')\n    var lines =<< trim END\n        vim9script\n        writefile(['before: ' .. &cpo], 'Xresult')\n        set cpo+=M\n        writefile(['after: ' .. &cpo], 'Xresult', 'a')\n    END\n    writefile(lines, 'Xhome/.vimrc')\n\n    lines =<< trim END\n        call writefile(['later: ' .. &cpo], 'Xresult', 'a')\n    END\n    writefile(lines, 'Xlegacy')\n\n    lines =<< trim END\n        vim9script\n        call writefile(['vim9: ' .. &cpo], 'Xresult', 'a')\n        qa\n    END\n    writefile(lines, 'Xvim9')\n\n    var cmd = g:GetVimCommand() .. \" -S Xlegacy -S Xvim9\"\n    cmd = substitute(cmd, '-u NONE', '', '')\n    exe \"silent !\" .. cmd\n\n    assert_equal([\n        'before: aABceFs',\n        'after: aABceFsM',\n        'later: aABceFsM',\n        'vim9: aABceFs'], readfile('Xresult'))\n\n    $HOME = save_HOME\n    delete('Xhome', 'rf')\n    delete('Xlegacy')\n    delete('Xvim9')\n    delete('Xresult')\n  endif\nenddef\n\n\" Use :function so we can use Check commands\nfunc Test_no_redraw_when_restoring_cpo()\n  CheckScreendump\n  CheckFeature timers\n  call Run_test_no_redraw_when_restoring_cpo()\nendfunc\n\ndef Run_test_no_redraw_when_restoring_cpo()\n  var lines =<< trim END\n    vim9script\n    export def Func()\n    enddef\n  END\n  mkdir('Xdir/autoload', 'p')\n  writefile(lines, 'Xdir/autoload/script.vim')\n\n  lines =<< trim END\n      vim9script\n      set cpo+=M\n      exe 'set rtp^=' .. getcwd() .. '/Xdir'\n      au CmdlineEnter : ++once timer_start(0, (_) => script#Func())\n      setline(1, 'some text')\n  END\n  writefile(lines, 'XTest_redraw_cpo')\n  var buf = g:RunVimInTerminal('-S XTest_redraw_cpo', {'rows': 6})\n  term_sendkeys(buf, \"V:\")\n  g:VerifyScreenDump(buf, 'Test_vim9_no_redraw', {})\n\n  # clean up\n  term_sendkeys(buf, \"\\<Esc>u\")\n  g:StopVimInTerminal(buf)\n  delete('XTest_redraw_cpo')\n  delete('Xdir', 'rf')\nenddef\n\nfunc Test_reject_declaration()\n  CheckScreendump\n  call Run_test_reject_declaration()\nendfunc\n\ndef Run_test_reject_declaration()\n  var buf = g:RunVimInTerminal('', {'rows': 6})\n  term_sendkeys(buf, \":vim9cmd var x: number\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_vim9_reject_declaration_1', {})\n  term_sendkeys(buf, \":\\<CR>\")\n  term_sendkeys(buf, \":vim9cmd g:foo = 123 | echo g:foo\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_vim9_reject_declaration_2', {})\n\n  # clean up\n  g:StopVimInTerminal(buf)\nenddef\n\ndef Test_minimal_command_name_length()\n  var names = [\n       'cons',\n       'brea',\n       'cat',\n       'catc',\n       'con',\n       'cont',\n       'conti',\n       'contin',\n       'continu',\n       'el',\n       'els',\n       'elsei',\n       'endfo',\n       'en',\n       'end',\n       'endi',\n       'endw',\n       'endt',\n       'endtr',\n       'exp',\n       'expo',\n       'expor',\n       'fina',\n       'finall',\n       'fini',\n       'finis',\n       'imp',\n       'impo',\n       'impor',\n       'retu',\n       'retur',\n       'th',\n       'thr',\n       'thro',\n       'wh',\n       'whi',\n       'whil',\n      ]\n  for name in names\n    v9.CheckDefAndScriptFailure([name .. ' '], 'E1065:')\n  endfor\n\n  var lines =<< trim END\n      vim9script\n      def SomeFunc()\n      endd\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\n  lines =<< trim END\n      vim9script\n      def SomeFunc()\n      endde\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\nenddef\n\ndef Test_unset_any_variable()\n  var lines =<< trim END\n    var name: any\n    assert_equal(0, name)\n  END\n  v9.CheckDefAndScriptSuccess(lines)\nenddef\n\nfunc Test_define_func_at_command_line()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_define_func_at_command_line()\nendfunc\n\ndef Run_Test_define_func_at_command_line()\n  # run in a separate Vim instance to avoid the script context\n  var lines =<< trim END\n    func CheckAndQuit()\n      call assert_fails('call Afunc()', 'E117: Unknown function: Bfunc')\n      call writefile(['errors: ' .. string(v:errors)], 'Xdidcmd')\n    endfunc\n  END\n  writefile([''], 'Xdidcmd')\n  writefile(lines, 'XcallFunc')\n  var buf = g:RunVimInTerminal('-S XcallFunc', {rows: 6})\n  # define Afunc() on the command line\n  term_sendkeys(buf, \":def Afunc()\\<CR>Bfunc()\\<CR>enddef\\<CR>\")\n  term_sendkeys(buf, \":call CheckAndQuit()\\<CR>\")\n  g:WaitForAssert(() => assert_equal(['errors: []'], readfile('Xdidcmd')))\n\n  call g:StopVimInTerminal(buf)\n  delete('XcallFunc')\n  delete('Xdidcmd')\nenddef\n\ndef Test_script_var_scope()\n  var lines =<< trim END\n      vim9script\n      if true\n        if true\n          var one = 'one'\n          echo one\n        endif\n        echo one\n      endif\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 7)\n\n  lines =<< trim END\n      vim9script\n      if true\n        if false\n          var one = 'one'\n          echo one\n        else\n          var one = 'one'\n          echo one\n        endif\n        echo one\n      endif\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 10)\n\n  lines =<< trim END\n      vim9script\n      while true\n        var one = 'one'\n        echo one\n        break\n      endwhile\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 7)\n\n  lines =<< trim END\n      vim9script\n      for i in range(1)\n        var one = 'one'\n        echo one\n      endfor\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 6)\n\n  lines =<< trim END\n      vim9script\n      {\n        var one = 'one'\n        assert_equal('one', one)\n      }\n      assert_false(exists('one'))\n      assert_false(exists('s:one'))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      {\n        var one = 'one'\n        echo one\n      }\n      echo one\n  END\n  v9.CheckScriptFailure(lines, 'E121:', 6)\nenddef\n\ndef Test_catch_exception_in_callback()\n  var lines =<< trim END\n    vim9script\n    def Callback(...l: list<any>)\n      try\n        var x: string\n        var y: string\n        # this error should be caught with CHECKLEN\n        var sl = ['']\n        [x, y] = sl\n      catch\n        g:caught = 'yes'\n      endtry\n    enddef\n    popup_menu('popup', {callback: Callback})\n    feedkeys(\"\\r\", 'xt')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  unlet g:caught\nenddef\n\ndef Test_no_unknown_error_after_error()\n  if !has('unix') || !has('job')\n    throw 'Skipped: not unix of missing +job feature'\n  endif\n  # FIXME: this check should not be needed\n  if has('win32')\n    throw 'Skipped: does not work on MS-Windows'\n  endif\n  var lines =<< trim END\n      vim9script\n      var source: list<number>\n      def Out_cb(...l: list<any>)\n          eval [][0]\n      enddef\n      def Exit_cb(...l: list<any>)\n          sleep 1m\n          g:did_call_exit_cb = true\n          source += l\n      enddef\n      var myjob = job_start('echo burp', {out_cb: Out_cb, exit_cb: Exit_cb, mode: 'raw'})\n      while job_status(myjob) == 'run'\n        sleep 10m\n      endwhile\n      # wait for Exit_cb() to be called\n      for x in range(100)\n        if exists('g:did_call_exit_cb')\n          unlet g:did_call_exit_cb\n          break\n        endif\n        sleep 10m\n      endfor\n  END\n  writefile(lines, 'Xdef')\n  assert_fails('so Xdef', ['E684:', 'E1012:'])\n  delete('Xdef')\nenddef\n\ndef InvokeNormal()\n  exe \"norm! :m+1\\r\"\nenddef\n\ndef Test_invoke_normal_in_visual_mode()\n  xnoremap <F3> <Cmd>call <SID>InvokeNormal()<CR>\n  new\n  setline(1, ['aaa', 'bbb'])\n  feedkeys(\"V\\<F3>\", 'xt')\n  assert_equal(['bbb', 'aaa'], getline(1, 2))\n  xunmap <F3>\nenddef\n\ndef Test_white_space_after_command()\n  var lines =<< trim END\n    exit_cb: Func})\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1144:', 1)\n\n  lines =<< trim END\n    e#\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1144:', 1)\nenddef\n\ndef Test_script_var_gone_when_sourced_twice()\n  var lines =<< trim END\n      vim9script\n      if exists('g:guard')\n        finish\n      endif\n      g:guard = 1\n      var name = 'thename'\n      def g:GetName(): string\n        return name\n      enddef\n      def g:SetName(arg: string)\n        name = arg\n      enddef\n  END\n  writefile(lines, 'XscriptTwice.vim')\n  so XscriptTwice.vim\n  assert_equal('thename', g:GetName())\n  g:SetName('newname')\n  assert_equal('newname', g:GetName())\n  so XscriptTwice.vim\n  assert_fails('call g:GetName()', 'E1149:')\n  assert_fails('call g:SetName(\"x\")', 'E1149:')\n\n  delfunc g:GetName\n  delfunc g:SetName\n  delete('XscriptTwice.vim')\n  unlet g:guard\nenddef\n\ndef Test_unsupported_commands()\n  var lines =<< trim END\n      ka\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'])\n\n  lines =<< trim END\n      :1ka\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476:', 'E492:'])\n\n  lines =<< trim END\n      :k a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n      :1k a\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E481:')\n\n  lines =<< trim END\n    t\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    x\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    xit\n  END\n  v9.CheckDefAndScriptFailure(lines, 'E1100:')\n\n  lines =<< trim END\n    Print\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476: Invalid command: Print', 'E492: Not an editor command: Print'])\n\n  lines =<< trim END\n    mode 4\n  END\n  v9.CheckDefAndScriptFailure(lines, ['E476: Invalid command: mode 4', 'E492: Not an editor command: mode 4'])\nenddef\n\ndef Test_mapping_line_number()\n  var lines =<< trim END\n      vim9script\n      def g:FuncA()\n          # Some comment\n          FuncB(0)\n      enddef\n          # Some comment\n      def FuncB(\n          # Some comment\n          n: number\n      )\n          exe 'nno '\n              # Some comment\n              .. '<F3> a'\n              .. 'b'\n              .. 'c'\n      enddef\n  END\n  v9.CheckScriptSuccess(lines)\n  var res = execute('verbose nmap <F3>')\n  assert_match('No mapping found', res)\n\n  g:FuncA()\n  res = execute('verbose nmap <F3>')\n  assert_match(' <F3> .* abc.*Last set from .*XScriptSuccess\\d\\+ line 11', res)\n\n  nunmap <F3>\n  delfunc g:FuncA\nenddef\n\ndef Test_option_set()\n  # legacy script allows for white space\n  var lines =<< trim END\n      set foldlevel  =11\n      call assert_equal(11, &foldlevel)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  set foldlevel\n  set foldlevel=12\n  assert_equal(12, &foldlevel)\n  set foldlevel+=2\n  assert_equal(14, &foldlevel)\n  set foldlevel-=3\n  assert_equal(11, &foldlevel)\n\n  lines =<< trim END\n      set foldlevel =1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: =1')\n\n  lines =<< trim END\n      set foldlevel +=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: +=1')\n\n  lines =<< trim END\n      set foldlevel ^=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: ^=1')\n\n  lines =<< trim END\n      set foldlevel -=1\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: -=1')\n\n  set foldlevel&\nenddef\n\ndef Test_option_modifier()\n  # legacy script allows for white space\n  var lines =<< trim END\n      set hlsearch &  hlsearch  !\n      call assert_equal(1, &hlsearch)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  set hlsearch\n  set hlsearch!\n  assert_equal(false, &hlsearch)\n\n  set hlsearch\n  set hlsearch&\n  assert_equal(false, &hlsearch)\n\n  lines =<< trim END\n      set hlsearch &\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: &')\n\n  lines =<< trim END\n      set hlsearch   !\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'E1205: No white space allowed between option and: !')\n\n  set hlsearch&\nenddef\n\n\" This must be called last, it may cause following :def functions to fail\ndef Test_xxx_echoerr_line_number()\n  var lines =<< trim END\n      echoerr 'some'\n         .. ' error'\n         .. ' continued'\n  END\n  v9.CheckDefExecAndScriptFailure(lines, 'some error continued', 1)\nenddef\n\nfunc Test_debug_with_lambda()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_debug_with_lambda()\nendfunc\n\ndef Run_Test_debug_with_lambda()\n  var lines =<< trim END\n      vim9script\n      def Func()\n        var n = 0\n        echo [0]->filter((_, v) => v == n)\n      enddef\n      breakadd func Func\n      Func()\n  END\n  writefile(lines, 'XdebugFunc')\n  var buf = g:RunVimInTerminal('-S XdebugFunc', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"cont\\<CR>\")\n  g:WaitForAssert(() => assert_match('\\[0\\]', term_getline(buf, 5)))\n\n  g:StopVimInTerminal(buf)\n  delete('XdebugFunc')\nenddef\n\nfunc Test_debug_running_out_of_lines()\n  CheckRunVimInTerminal\n\n  \" call indirectly to avoid compilation error for missing functions\n  call Run_Test_debug_running_out_of_lines()\nendfunc\n\ndef Run_Test_debug_running_out_of_lines()\n  var lines =<< trim END\n      vim9script\n      def Crash()\n          #\n          #\n          #\n          #\n          #\n          #\n          #\n          if true\n              #\n          endif\n      enddef\n      breakadd func Crash\n      Crash()\n  END\n  writefile(lines, 'XdebugFunc')\n  var buf = g:RunVimInTerminal('-S XdebugFunc', {rows: 6, wait_for_ruler: 0})\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"next\\<CR>\")\n  g:TermWait(buf)\n  g:WaitForAssert(() => assert_match('^>', term_getline(buf, 6)))\n\n  term_sendkeys(buf, \"cont\\<CR>\")\n  g:TermWait(buf)\n\n  g:StopVimInTerminal(buf)\n  delete('XdebugFunc')\nenddef\n\ndef Test_ambigous_command_error()\n  var lines =<< trim END\n      vim9script\n      command CmdA echomsg 'CmdA'\n      command CmdB echomsg 'CmdB'\n      Cmd\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 4)\n\n  lines =<< trim END\n      vim9script\n      def Func()\n        Cmd\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 1)\n\n  lines =<< trim END\n      vim9script\n      nnoremap <F3> <ScriptCmd>Cmd<CR>\n      feedkeys(\"\\<F3>\", 'xt')\n  END\n  v9.CheckScriptFailure(lines, 'E464: Ambiguous use of user-defined command: Cmd', 3)\n\n  delcommand CmdA\n  delcommand CmdB\n  nunmap <F3>\nenddef\n\n\" Execute this near the end, profiling doesn't stop until Vim exits.\n\" This only tests that it works, not the profiling output.\ndef Test_profile_with_lambda()\n  CheckFeature profile\n\n  var lines =<< trim END\n      vim9script\n\n      def ProfiledWithLambda()\n        var n = 3\n        echo [[1, 2], [3, 4]]->filter((_, l) => l[0] == n)\n      enddef\n\n      def ProfiledNested()\n        var x = 0\n        def Nested(): any\n            return x\n        enddef\n        Nested()\n      enddef\n\n      def g:ProfiledNestedProfiled()\n        var x = 0\n        def Nested(): any\n            return x\n        enddef\n        Nested()\n      enddef\n\n      def Profile()\n        ProfiledWithLambda()\n        ProfiledNested()\n\n        # Also profile the nested function.  Use a different function, although\n        # the contents is the same, to make sure it was not already compiled.\n        profile func *\n        g:ProfiledNestedProfiled()\n\n        profdel func *\n        profile pause\n      enddef\n\n      var result = 'done'\n      try\n        # mark functions for profiling now to avoid E1271\n        profile start Xprofile.log\n        profile func ProfiledWithLambda\n        profile func ProfiledNested\n\n        Profile()\n      catch\n        result = 'failed: ' .. v:exception\n      finally\n        writefile([result], 'Xdidprofile')\n      endtry\n  END\n  writefile(lines, 'Xprofile.vim')\n  call system(g:GetVimCommand()\n        .. ' --clean'\n        .. ' -c \"so Xprofile.vim\"'\n        .. ' -c \"qall!\"')\n  call assert_equal(0, v:shell_error)\n\n  assert_equal(['done'], readfile('Xdidprofile'))\n  assert_true(filereadable('Xprofile.log'))\n  delete('Xdidprofile')\n  delete('Xprofile.log')\n  delete('Xprofile.vim')\nenddef\n\nfunc Test_misplaced_type()\n  CheckRunVimInTerminal\n  call Run_Test_misplaced_type()\nendfunc\n\ndef Run_Test_misplaced_type()\n  writefile(['let g:somevar = \"asdf\"'], 'XTest_misplaced_type')\n  var buf = g:RunVimInTerminal('-S XTest_misplaced_type', {'rows': 6})\n  term_sendkeys(buf, \":vim9cmd echo islocked('g:somevar: string')\\<CR>\")\n  g:VerifyScreenDump(buf, 'Test_misplaced_type', {})\n\n  g:StopVimInTerminal(buf)\n  delete('XTest_misplaced_type')\nenddef\n\n\" Ensure echo doesn't crash when stringifying empty variables.\ndef Test_echo_uninit_variables()\n  var res: string\n\n  var var_bool: bool\n  var var_num: number\n  var var_float: float\n  var Var_func: func\n  var var_string: string\n  var var_blob: blob\n  var var_list: list<any>\n  var var_dict: dict<any>\n\n  redir => res\n  echo var_bool\n  echo var_num\n  echo var_float\n  echo Var_func\n  echo var_string\n  echo var_blob\n  echo var_list\n  echo var_dict\n  redir END\n\n  assert_equal(['false', '0', '0.0', 'function()', '', '0z', '[]', '{}'], res->split('\\n'))\n\n  if has('job')\n    var var_job: job\n    var var_channel: channel\n\n    redir => res\n    echo var_job\n    echo var_channel\n    redir END\n\n    assert_equal(['no process', 'channel fail'], res->split('\\n'))\n  endif\nenddef\n\n\" Keep this last, it messes up highlighting.\ndef Test_substitute_cmd()\n  new\n  setline(1, 'something')\n  :substitute(some(other(\n  assert_equal('otherthing', getline(1))\n  bwipe!\n\n  # also when the context is Vim9 script\n  var lines =<< trim END\n    vim9script\n    new\n    setline(1, 'something')\n    :substitute(some(other(\n    assert_equal('otherthing', getline(1))\n    bwipe!\n  END\n  writefile(lines, 'Xvim9lines')\n  source Xvim9lines\n\n  delete('Xvim9lines')\nenddef\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * userfunc.c: User defined function support\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * All user-defined functions are found in this hashtable.\n */\nstatic hashtab_T\tfunc_hashtab;\n\n// Used by get_func_tv()\nstatic garray_T funcargs = GA_EMPTY;\n\n// pointer to funccal for currently active function\nstatic funccall_T *current_funccal = NULL;\n\n// Pointer to list of previously used funccal, still around because some\n// item in it is still being used.\nstatic funccall_T *previous_funccal = NULL;\n\nstatic void funccal_unref(funccall_T *fc, ufunc_T *fp, int force);\nstatic void func_clear(ufunc_T *fp, int force);\nstatic int func_free(ufunc_T *fp, int force);\nstatic char_u *untrans_function_name(char_u *name);\n\n    void\nfunc_init()\n{\n    hash_init(&func_hashtab);\n}\n\n#if defined(FEAT_PROFILE) || defined(PROTO)\n/*\n * Return the function hash table\n */\n    hashtab_T *\nfunc_tbl_get(void)\n{\n    return &func_hashtab;\n}\n#endif\n\n/*\n * Get one function argument.\n * If \"argtypes\" is not NULL also get the type: \"arg: type\" (:def function).\n * If \"types_optional\" is TRUE a missing type is OK, use \"any\".\n * If \"evalarg\" is not NULL use it to check for an already declared name.\n * If \"eap\" is not NULL use it to check for an already declared name.\n * Return a pointer to after the type.\n * When something is wrong return \"arg\".\n */\n    static char_u *\none_function_arg(\n\tchar_u\t    *arg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg,\n\texarg_T\t    *eap,\n\tint\t    is_vararg,\n\tint\t    skip)\n{\n    char_u\t*p = arg;\n    char_u\t*arg_copy = NULL;\n    int\t\tis_underscore = FALSE;\n\n    while (ASCII_ISALNUM(*p) || *p == '_')\n\t++p;\n    if (arg == p || isdigit(*arg)\n\t    || (argtypes == NULL\n\t\t&& ((p - arg == 9 && STRNCMP(arg, \"firstline\", 9) == 0)\n\t\t    || (p - arg == 8 && STRNCMP(arg, \"lastline\", 8) == 0))))\n    {\n\tif (!skip)\n\t    semsg(_(e_illegal_argument_str), arg);\n\treturn arg;\n    }\n\n    // Vim9 script: cannot use script var name for argument. In function: also\n    // check local vars and arguments.\n    if (!skip && argtypes != NULL && check_defined(arg, p - arg,\n\t\t\t       evalarg == NULL ? NULL : evalarg->eval_cctx,\n\t\t\t       eap == NULL ? NULL : eap->cstack, TRUE) == FAIL)\n\treturn arg;\n\n    if (newargs != NULL && ga_grow(newargs, 1) == FAIL)\n\treturn arg;\n    if (newargs != NULL)\n    {\n\tint\tc;\n\tint\ti;\n\n\tc = *p;\n\t*p = NUL;\n\targ_copy = vim_strsave(arg);\n\tif (arg_copy == NULL)\n\t{\n\t    *p = c;\n\t    return arg;\n\t}\n\tis_underscore = arg_copy[0] == '_' && arg_copy[1] == NUL;\n\tif (argtypes == NULL || !is_underscore)\n\t    // Check for duplicate argument name.\n\t    for (i = 0; i < newargs->ga_len; ++i)\n\t\tif (STRCMP(((char_u **)(newargs->ga_data))[i], arg_copy) == 0)\n\t\t{\n\t\t    semsg(_(e_duplicate_argument_name_str), arg_copy);\n\t\t    vim_free(arg_copy);\n\t\t    return arg;\n\t\t}\n\t((char_u **)(newargs->ga_data))[newargs->ga_len] = arg_copy;\n\tnewargs->ga_len++;\n\n\t*p = c;\n    }\n\n    // get any type from \"arg: type\"\n    if (argtypes != NULL && (skip || ga_grow(argtypes, 1) == OK))\n    {\n\tchar_u *type = NULL;\n\n\tif (VIM_ISWHITE(*p) && *skipwhite(p) == ':')\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_colon_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    p = skipwhite(p);\n\t}\n\tif (*p == ':')\n\t{\n\t    ++p;\n\t    if (!skip && !VIM_ISWHITE(*p))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p - 1);\n\t\treturn arg;\n\t    }\n\t    type = skipwhite(p);\n\t    p = skip_type(type, TRUE);\n\t    if (!skip)\n\t\ttype = vim_strnsave(type, p - type);\n\t}\n\telse if (*skipwhite(p) != '=' && !types_optional && !is_underscore)\n\t{\n\t    semsg(_(e_missing_argument_type_for_str),\n\t\t\t\t\t    arg_copy == NULL ? arg : arg_copy);\n\t    return arg;\n\t}\n\tif (!skip)\n\t{\n\t    if (type == NULL && types_optional)\n\t\t// lambda arguments default to \"any\" type\n\t\ttype = vim_strsave((char_u *)\n\t\t\t\t\t    (is_vararg ? \"list<any>\" : \"any\"));\n\t    ((char_u **)argtypes->ga_data)[argtypes->ga_len++] = type;\n\t}\n    }\n\n    return p;\n}\n\n/*\n * Handle line continuation in function arguments or body.\n * Get a next line, store it in \"eap\" if appropriate and put the line in\n * \"lines_to_free\" to free the line later.\n */\n    static char_u *\nget_function_line(\n\texarg_T\t\t*eap,\n\tgarray_T\t*lines_to_free,\n\tint\t\tindent,\n\tgetline_opt_T\tgetline_options)\n{\n    char_u *theline;\n\n    if (eap->getline == NULL)\n\ttheline = getcmdline(':', 0L, indent, 0);\n    else\n\ttheline = eap->getline(':', eap->cookie, indent, getline_options);\n    if (theline != NULL)\n    {\n\tif (lines_to_free->ga_len > 0\n\t\t&& *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)\n\t\t\t\t\t\t   [lines_to_free->ga_len - 1])\n\t    *eap->cmdlinep = theline;\n\tga_add_string(lines_to_free, theline);\n    }\n\n    return theline;\n}\n\n/*\n * Get function arguments.\n * \"argp\" should point to just after the \"(\", possibly to white space.\n * \"argp\" is advanced just after \"endchar\".\n */\n    static int\nget_function_args(\n    char_u\t**argp,\n    char_u\tendchar,\n    garray_T\t*newargs,\n    garray_T\t*argtypes,\t// NULL unless using :def\n    int\t\ttypes_optional,\t// types optional if \"argtypes\" is not NULL\n    evalarg_T\t*evalarg,\t// context or NULL\n    int\t\t*varargs,\n    garray_T\t*default_args,\n    int\t\tskip,\n    exarg_T\t*eap,\t\t// can be NULL\n    garray_T\t*lines_to_free)\n{\n    int\t\tmustend = FALSE;\n    char_u\t*arg;\n    char_u\t*p;\n    int\t\tc;\n    int\t\tany_default = FALSE;\n    char_u\t*expr;\n    char_u\t*whitep = *argp;\n\n    if (newargs != NULL)\n\tga_init2(newargs, sizeof(char_u *), 3);\n    if (argtypes != NULL)\n\tga_init2(argtypes, sizeof(char_u *), 3);\n    if (!skip && default_args != NULL)\n\tga_init2(default_args, sizeof(char_u *), 3);\n\n    if (varargs != NULL)\n\t*varargs = FALSE;\n\n    /*\n     * Isolate the arguments: \"arg1, arg2, ...)\"\n     */\n    arg = skipwhite(*argp);\n    p = arg;\n    while (*p != endchar)\n    {\n\twhile (eap != NULL && eap->getline != NULL\n\t\t\t && (*p == NUL || (VIM_ISWHITE(*whitep) && *p == '#')))\n\t{\n\t    // End of the line, get the next one.\n\t    char_u *theline = get_function_line(eap, lines_to_free, 0,\n\t\t\t\t\t\t\t  GETLINE_CONCAT_CONT);\n\n\t    if (theline == NULL)\n\t\tbreak;\n\t    whitep = (char_u *)\" \";\n\t    p = skipwhite(theline);\n\t}\n\n\tif (mustend && *p != endchar)\n\t{\n\t    if (!skip)\n\t\tsemsg(_(e_invalid_argument_str), *argp);\n\t    goto err_ret;\n\t}\n\tif (*p == endchar)\n\t    break;\n\n\tif (p[0] == '.' && p[1] == '.' && p[2] == '.')\n\t{\n\t    if (varargs != NULL)\n\t\t*varargs = TRUE;\n\t    p += 3;\n\t    mustend = TRUE;\n\n\t    if (argtypes != NULL)\n\t    {\n\t\t// ...name: list<type>\n\t\tif (!eval_isnamec1(*p))\n\t\t{\n\t\t    if (!skip)\n\t\t\temsg(_(e_missing_name_after_dots));\n\t\t    goto err_ret;\n\t\t}\n\n\t\targ = p;\n\t\tp = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t     evalarg, eap, TRUE, skip);\n\t\tif (p == arg)\n\t\t    break;\n\t\tif (*skipwhite(p) == '=')\n\t\t{\n\t\t    emsg(_(e_cannot_use_default_for_variable_arguments));\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    char_u *np;\n\n\t    arg = p;\n\t    p = one_function_arg(p, newargs, argtypes, types_optional,\n\t\t\t\t\t\t    evalarg, eap, FALSE, skip);\n\t    if (p == arg)\n\t\tbreak;\n\n\t    // Recognize \" = expr\" but not \" == expr\".  A lambda can have\n\t    // \"(a = expr\" but \"(a == expr\" and \"(a =~ expr\" are not a lambda.\n\t    np = skipwhite(p);\n\t    if (*np == '=' && np[1] != '=' && np[1] != '~'\n\t\t\t\t\t\t       && default_args != NULL)\n\t    {\n\t\ttypval_T\trettv;\n\n\t\t// find the end of the expression (doesn't evaluate it)\n\t\tany_default = TRUE;\n\t\tp = skipwhite(p) + 1;\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t\texpr = p;\n\t\tif (eval1(&p, &rettv, NULL) != FAIL)\n\t\t{\n\t\t    if (!skip)\n\t\t    {\n\t\t\tif (ga_grow(default_args, 1) == FAIL)\n\t\t\t    goto err_ret;\n\n\t\t\t// trim trailing whitespace\n\t\t\twhile (p > expr && VIM_ISWHITE(p[-1]))\n\t\t\t    p--;\n\t\t\tc = *p;\n\t\t\t*p = NUL;\n\t\t\texpr = vim_strsave(expr);\n\t\t\tif (expr == NULL)\n\t\t\t{\n\t\t\t    *p = c;\n\t\t\t    goto err_ret;\n\t\t\t}\n\t\t\t((char_u **)(default_args->ga_data))\n\t\t\t\t\t\t [default_args->ga_len] = expr;\n\t\t\tdefault_args->ga_len++;\n\t\t\t*p = c;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    mustend = TRUE;\n\t    }\n\t    else if (any_default)\n\t    {\n\t\temsg(_(e_non_default_argument_follows_default_argument));\n\t\tgoto err_ret;\n\t    }\n\n\t    if (VIM_ISWHITE(*p) && *skipwhite(p) == ',')\n\t    {\n\t\t// Be tolerant when skipping\n\t\tif (!skip)\n\t\t{\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str), \",\", p);\n\t\t    goto err_ret;\n\t\t}\n\t\tp = skipwhite(p);\n\t    }\n\t    if (*p == ',')\n\t    {\n\t\t++p;\n\t\t// Don't give this error when skipping, it makes the \"->\" not\n\t\t// found in \"{k,v -> x}\" and give a confusing error.\n\t\t// Allow missing space after comma in legacy functions.\n\t\tif (!skip && argtypes != NULL\n\t\t\t\t      && !IS_WHITE_OR_NUL(*p) && *p != endchar)\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_str_str), \",\", p - 1);\n\t\t    goto err_ret;\n\t\t}\n\t    }\n\t    else\n\t\tmustend = TRUE;\n\t}\n\twhitep = p;\n\tp = skipwhite(p);\n    }\n\n    if (*p != endchar)\n\tgoto err_ret;\n    ++p;\t// skip \"endchar\"\n\n    *argp = p;\n    return OK;\n\nerr_ret:\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    if (!skip && default_args != NULL)\n\tga_clear_strings(default_args);\n    return FAIL;\n}\n\n/*\n * Parse the argument types, filling \"fp->uf_arg_types\".\n * Return OK or FAIL.\n */\n    static int\nparse_argument_types(ufunc_T *fp, garray_T *argtypes, int varargs)\n{\n    int len = 0;\n\n    ga_init2(&fp->uf_type_list, sizeof(type_T *), 10);\n    if (argtypes->ga_len > 0)\n    {\n\t// When \"varargs\" is set the last name/type goes into uf_va_name\n\t// and uf_va_type.\n\tlen = argtypes->ga_len - (varargs ? 1 : 0);\n\n\tif (len > 0)\n\t    fp->uf_arg_types = ALLOC_CLEAR_MULT(type_T *, len);\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    int\ti;\n\t    type_T\t*type;\n\n\t    for (i = 0; i < len; ++ i)\n\t    {\n\t\tchar_u *p = ((char_u **)argtypes->ga_data)[i];\n\n\t\tif (p == NULL)\n\t\t    // will get the type from the default value\n\t\t    type = &t_unknown;\n\t\telse\n\t\t    type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t\tif (type == NULL)\n\t\t    return FAIL;\n\t\tfp->uf_arg_types[i] = type;\n\t\tif (i < fp->uf_args.ga_len\n\t\t\t&& (type->tt_type == VAR_FUNC\n\t\t\t    || type->tt_type == VAR_PARTIAL)\n\t\t\t&& var_wrong_func_name(\n\t\t\t\t    ((char_u **)fp->uf_args.ga_data)[i], TRUE))\n\t\t    return FAIL;\n\t    }\n\t}\n    }\n\n    if (varargs)\n    {\n\tchar_u *p;\n\n\t// Move the last argument \"...name: type\" to uf_va_name and\n\t// uf_va_type.\n\tfp->uf_va_name = ((char_u **)fp->uf_args.ga_data)\n\t\t\t\t\t      [fp->uf_args.ga_len - 1];\n\t--fp->uf_args.ga_len;\n\tp = ((char_u **)argtypes->ga_data)[len];\n\tif (p == NULL)\n\t    // TODO: get type from default value\n\t    fp->uf_va_type = &t_list_any;\n\telse\n\t{\n\t    fp->uf_va_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\t    if (fp->uf_va_type != NULL && fp->uf_va_type->tt_type != VAR_LIST)\n\t    {\n\t\tsemsg(_(e_variable_arguments_type_must_be_list_str),\n\t\t\t\t\t  ((char_u **)argtypes->ga_data)[len]);\n\t\treturn FAIL;\n\t    }\n\t}\n\tif (fp->uf_va_type == NULL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n    static int\nparse_return_type(ufunc_T *fp, char_u *ret_type)\n{\n    if (ret_type == NULL)\n\tfp->uf_ret_type = &t_void;\n    else\n    {\n\tchar_u *p = ret_type;\n\n\tfp->uf_ret_type = parse_type(&p, &fp->uf_type_list, TRUE);\n\tif (fp->uf_ret_type == NULL)\n\t{\n\t    fp->uf_ret_type = &t_void;\n\t    return FAIL;\n\t}\n    }\n    return OK;\n}\n\n/*\n * Register function \"fp\" as using \"current_funccal\" as its scope.\n */\n    static int\nregister_closure(ufunc_T *fp)\n{\n    if (fp->uf_scoped == current_funccal)\n\t// no change\n\treturn OK;\n    funccal_unref(fp->uf_scoped, fp, FALSE);\n    fp->uf_scoped = current_funccal;\n    current_funccal->fc_refcount++;\n\n    if (ga_grow(&current_funccal->fc_funcs, 1) == FAIL)\n\treturn FAIL;\n    ((ufunc_T **)current_funccal->fc_funcs.ga_data)\n\t[current_funccal->fc_funcs.ga_len++] = fp;\n    return OK;\n}\n\n    static void\nset_ufunc_name(ufunc_T *fp, char_u *name)\n{\n    // Add a type cast to avoid a warning for an overflow, the uf_name[] array\n    // actually extends beyond the struct.\n    STRCPY((void *)fp->uf_name, name);\n\n    if (name[0] == K_SPECIAL)\n    {\n\tfp->uf_name_exp = alloc(STRLEN(name) + 3);\n\tif (fp->uf_name_exp != NULL)\n\t{\n\t    STRCPY(fp->uf_name_exp, \"<SNR>\");\n\t    STRCAT(fp->uf_name_exp, fp->uf_name + 3);\n\t}\n    }\n}\n\n/*\n * If \"name\" starts with K_SPECIAL and \"buf[bufsize]\" is big enough\n * return \"buf\" filled with a readable function name.\n * Otherwise just return \"name\", thus the return value can always be used.\n * \"name\" and \"buf\" may be equal.\n */\n    char_u *\nmake_ufunc_name_readable(char_u *name, char_u *buf, size_t bufsize)\n{\n    size_t len;\n\n    if (name[0] != K_SPECIAL)\n\treturn name;\n    len = STRLEN(name);\n    if (len + 3 > bufsize)\n\treturn name;\n\n    mch_memmove(buf + 5, name + 3, len - 2);  // Include trailing NUL\n    mch_memmove(buf, \"<SNR>\", 5);\n    return buf;\n}\n\n/*\n * Get a name for a lambda.  Returned in static memory.\n */\n    char_u *\nget_lambda_name(void)\n{\n    static char_u   name[30];\n    static int\t    lambda_no = 0;\n\n    sprintf((char*)name, \"<lambda>%d\", ++lambda_no);\n    return name;\n}\n\n#if defined(FEAT_LUA) || defined(PROTO)\n/*\n * Registers a native C callback which can be called from Vim script.\n * Returns the name of the Vim script function.\n */\n    char_u *\nregister_cfunc(cfunc_T cb, cfunc_free_T cb_free, void *state)\n{\n    char_u\t*name = get_lambda_name();\n    ufunc_T\t*fp;\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (fp == NULL)\n\treturn NULL;\n\n    fp->uf_def_status = UF_NOT_COMPILED;\n    fp->uf_refcount = 1;\n    fp->uf_varargs = TRUE;\n    fp->uf_flags = FC_CFUNC | FC_LAMBDA;\n    fp->uf_calls = 0;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_cb = cb;\n    fp->uf_cb_free = cb_free;\n    fp->uf_cb_state = state;\n\n    set_ufunc_name(fp, name);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    return name;\n}\n#endif\n\n/*\n * Skip over \"->\" or \"=>\" after the arguments of a lambda.\n * If \": type\" is found make \"ret_type\" point to \"type\".\n * If \"white_error\" is not NULL check for correct use of white space and set\n * \"white_error\" to TRUE if there is an error.\n * Return NULL if no valid arrow found.\n */\n    static char_u *\nskip_arrow(\n\tchar_u\t*start,\n\tint\tequal_arrow,\n\tchar_u\t**ret_type,\n\tint\t*white_error)\n{\n    char_u  *s = start;\n    char_u  *bef = start - 2; // \"start\" points to > of ->\n\n    if (equal_arrow)\n    {\n\tif (*s == ':')\n\t{\n\t    if (white_error != NULL && !VIM_ISWHITE(s[1]))\n\t    {\n\t\t*white_error = TRUE;\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", s);\n\t\treturn NULL;\n\t    }\n\t    s = skipwhite(s + 1);\n\t    *ret_type = s;\n\t    s = skip_type(s, TRUE);\n\t    if (s == *ret_type)\n\t    {\n\t\temsg(_(e_missing_return_type));\n\t\treturn NULL;\n\t    }\n\t}\n\tbef = s;\n\ts = skipwhite(s);\n\tif (*s != '=')\n\t    return NULL;\n\t++s;\n    }\n    if (*s != '>')\n\treturn NULL;\n    if (white_error != NULL && ((!VIM_ISWHITE(*bef) && *bef != '{')\n\t\t|| !IS_WHITE_OR_NUL(s[1])))\n    {\n\t*white_error = TRUE;\n\tsemsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t       equal_arrow ? \"=>\" : \"->\", bef);\n\treturn NULL;\n    }\n    return skipwhite(s + 1);\n}\n\n/*\n * Check if \"*cmd\" points to a function command and if so advance \"*cmd\" and\n * return TRUE.\n * Otherwise return FALSE;\n * Do not consider \"function(\" to be a command.\n */\n    static int\nis_function_cmd(char_u **cmd)\n{\n    char_u *p = *cmd;\n\n    if (checkforcmd(&p, \"function\", 2))\n    {\n\tif (*p == '(')\n\t    return FALSE;\n\t*cmd = p;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Called when defining a function: The context may be needed for script\n * variables declared in a block that is visible now but not when the function\n * is compiled or called later.\n */\n    static void\nfunction_using_block_scopes(ufunc_T *fp, cstack_T *cstack)\n{\n    if (cstack != NULL && cstack->cs_idx >= 0)\n    {\n\tint\t    count = cstack->cs_idx + 1;\n\tint\t    i;\n\n\tfp->uf_block_ids = ALLOC_MULT(int, count);\n\tif (fp->uf_block_ids != NULL)\n\t{\n\t    mch_memmove(fp->uf_block_ids, cstack->cs_block_id,\n\t\t\t\t\t\t\t  sizeof(int) * count);\n\t    fp->uf_block_depth = count;\n\t}\n\n\t// Set flag in each block to indicate a function was defined.  This\n\t// is used to keep the variable when leaving the block, see\n\t// hide_script_var().\n\tfor (i = 0; i <= cstack->cs_idx; ++i)\n\t    cstack->cs_flags[i] |= CSF_FUNC_DEF;\n    }\n}\n\n/*\n * Read the body of a function, put every line in \"newlines\".\n * This stops at \"}\", \"endfunction\" or \"enddef\".\n * \"newlines\" must already have been initialized.\n * \"eap->cmdidx\" is CMD_function, CMD_def or CMD_block;\n */\n    static int\nget_function_body(\n\texarg_T\t    *eap,\n\tgarray_T    *newlines,\n\tchar_u\t    *line_arg_in,\n\tgarray_T    *lines_to_free)\n{\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n    linenr_T\tsourcing_lnum_off;\n    int\t\tsaved_wait_return = need_wait_return;\n    char_u\t*line_arg = line_arg_in;\n    int\t\tvim9_function = eap->cmdidx == CMD_def\n\t\t\t\t\t\t   || eap->cmdidx == CMD_block;\n#define MAX_FUNC_NESTING 50\n    char\tnesting_def[MAX_FUNC_NESTING];\n    char\tnesting_inline[MAX_FUNC_NESTING];\n    int\t\tnesting = 0;\n    getline_opt_T getline_options;\n    int\t\tindent = 2;\n    char_u\t*skip_until = NULL;\n    int\t\tret = FAIL;\n    int\t\tis_heredoc = FALSE;\n    int\t\theredoc_concat_len = 0;\n    garray_T\theredoc_ga;\n    char_u\t*heredoc_trimmed = NULL;\n\n    ga_init2(&heredoc_ga, 1, 500);\n\n    // Detect having skipped over comment lines to find the return\n    // type.  Add NULL lines to keep the line count correct.\n    sourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n    if (SOURCING_LNUM < sourcing_lnum_off)\n    {\n\tsourcing_lnum_off -= SOURCING_LNUM;\n\tif (ga_grow(newlines, sourcing_lnum_off) == FAIL)\n\t    goto theend;\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n    }\n\n    nesting_def[0] = vim9_function;\n    nesting_inline[0] = eap->cmdidx == CMD_block;\n    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n    for (;;)\n    {\n\tchar_u\t*theline;\n\tchar_u\t*p;\n\tchar_u\t*arg;\n\n\tif (KeyTyped)\n\t{\n\t    msg_scroll = TRUE;\n\t    saved_wait_return = FALSE;\n\t}\n\tneed_wait_return = FALSE;\n\n\tif (line_arg != NULL)\n\t{\n\t    // Use eap->arg, split up in parts by line breaks.\n\t    theline = line_arg;\n\t    p = vim_strchr(theline, '\\n');\n\t    if (p == NULL)\n\t\tline_arg += STRLEN(line_arg);\n\t    else\n\t    {\n\t\t*p = NUL;\n\t\tline_arg = p + 1;\n\t    }\n\t}\n\telse\n\t{\n\t    theline = get_function_line(eap, lines_to_free, indent,\n\t\t\t\t\t\t\t      getline_options);\n\t}\n\tif (KeyTyped)\n\t    lines_left = Rows - 1;\n\tif (theline == NULL)\n\t{\n\t    // Use the start of the function for the line number.\n\t    SOURCING_LNUM = sourcing_lnum_top;\n\t    if (skip_until != NULL)\n\t\tsemsg(_(e_missing_heredoc_end_marker_str), skip_until);\n\t    else if (nesting_inline[nesting])\n\t\temsg(_(e_missing_end_block));\n\t    else if (eap->cmdidx == CMD_def)\n\t\temsg(_(e_missing_enddef));\n\t    else\n\t\temsg(_(e_missing_endfunction));\n\t    goto theend;\n\t}\n\n\t// Detect line continuation: SOURCING_LNUM increased more than one.\n\tsourcing_lnum_off = get_sourced_lnum(eap->getline, eap->cookie);\n\tif (SOURCING_LNUM < sourcing_lnum_off)\n\t    sourcing_lnum_off -= SOURCING_LNUM;\n\telse\n\t    sourcing_lnum_off = 0;\n\n\tif (skip_until != NULL)\n\t{\n\t    // Don't check for \":endfunc\"/\":enddef\" between\n\t    // * \":append\" and \".\"\n\t    // * \":python <<EOF\" and \"EOF\"\n\t    // * \":let {var-name} =<< [trim] {marker}\" and \"{marker}\"\n\t    if (heredoc_trimmed == NULL\n\t\t    || (is_heredoc && skipwhite(theline) == theline)\n\t\t    || STRNCMP(theline, heredoc_trimmed,\n\t\t\t\t\t\t STRLEN(heredoc_trimmed)) == 0)\n\t    {\n\t\tif (heredoc_trimmed == NULL)\n\t\t    p = theline;\n\t\telse if (is_heredoc)\n\t\t    p = skipwhite(theline) == theline\n\t\t\t\t ? theline : theline + STRLEN(heredoc_trimmed);\n\t\telse\n\t\t    p = theline + STRLEN(heredoc_trimmed);\n\t\tif (STRCMP(p, skip_until) == 0)\n\t\t{\n\t\t    VIM_CLEAR(skip_until);\n\t\t    VIM_CLEAR(heredoc_trimmed);\n\t\t    getline_options = vim9_function\n\t\t\t\t? GETLINE_CONCAT_CONTBAR : GETLINE_CONCAT_CONT;\n\t\t    is_heredoc = FALSE;\n\n\t\t    if (heredoc_concat_len > 0)\n\t\t    {\n\t\t\t// Replace the starting line with all the concatenated\n\t\t\t// lines.\n\t\t\tga_concat(&heredoc_ga, theline);\n\t\t\tvim_free(((char_u **)(newlines->ga_data))[\n\t\t\t\t\t\t      heredoc_concat_len - 1]);\n\t\t\t((char_u **)(newlines->ga_data))[\n\t\t\t\t  heredoc_concat_len - 1] = heredoc_ga.ga_data;\n\t\t\tga_init(&heredoc_ga);\n\t\t\theredoc_concat_len = 0;\n\t\t\ttheline += STRLEN(theline);  // skip the \"EOF\"\n\t\t    }\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    int\t    c;\n\t    char_u  *end;\n\t    char_u  *cmd;\n\n\t    // skip ':' and blanks\n\t    for (p = theline; VIM_ISWHITE(*p) || *p == ':'; ++p)\n\t\t;\n\n\t    // Check for \"endfunction\", \"enddef\" or \"}\".\n\t    // When a \":\" follows it must be a dict key; \"enddef: value,\"\n\t    cmd = p;\n\t    if (nesting_inline[nesting]\n\t\t    ? *p == '}'\n\t\t    : (checkforcmd(&p, nesting_def[nesting]\n\t\t\t\t\t\t? \"enddef\" : \"endfunction\", 4)\n\t\t\t&& *p != ':'))\n\t    {\n\t\tif (!nesting_inline[nesting] && nesting_def[nesting]\n\t\t\t\t\t\t\t\t&& p < cmd + 6)\n\t\t    semsg(_(e_command_cannot_be_shortened_str), \"enddef\");\n\t\tif (nesting-- == 0)\n\t\t{\n\t\t    char_u *nextcmd = NULL;\n\n\t\t    if (*p == '|' || *p == '}')\n\t\t\tnextcmd = p + 1;\n\t\t    else if (line_arg != NULL && *skipwhite(line_arg) != NUL)\n\t\t\tnextcmd = line_arg;\n\t\t    else if (*p != NUL && *p != (vim9_function ? '#' : '\"')\n\t\t\t\t\t   && (vim9_function || p_verbose > 0))\n\t\t    {\n\t\t\tSOURCING_LNUM = sourcing_lnum_top\n\t\t\t\t\t\t\t+ newlines->ga_len + 1;\n\t\t\tif (eap->cmdidx == CMD_def)\n\t\t\t    semsg(_(e_text_found_after_str_str), \"enddef\", p);\n\t\t\telse\n\t\t\t    give_warning2((char_u *)\n\t\t\t\t   _(\"W22: Text found after :endfunction: %s\"),\n\t\t\t\t   p, TRUE);\n\t\t    }\n\t\t    if (nextcmd != NULL && *skipwhite(nextcmd) != NUL)\n\t\t    {\n\t\t\t// Another command follows. If the line came from \"eap\"\n\t\t\t// we can simply point into it, otherwise we need to\n\t\t\t// change \"eap->cmdlinep\" to point to the last fetched\n\t\t\t// line.\n\t\t\teap->nextcmd = nextcmd;\n\t\t\tif (lines_to_free->ga_len > 0\n\t\t\t\t&& *eap->cmdlinep !=\n\t\t\t\t\t    ((char_u **)lines_to_free->ga_data)\n\t\t\t\t\t\t   [lines_to_free->ga_len - 1])\n\t\t\t{\n\t\t\t    // *cmdlinep will be freed later, thus remove the\n\t\t\t    // line from lines_to_free.\n\t\t\t    vim_free(*eap->cmdlinep);\n\t\t\t    *eap->cmdlinep = ((char_u **)lines_to_free->ga_data)\n\t\t\t\t\t\t   [lines_to_free->ga_len - 1];\n\t\t\t    --lines_to_free->ga_len;\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\n\t    // Check for mismatched \"endfunc\" or \"enddef\".\n\t    // We don't check for \"def\" inside \"func\" thus we also can't check\n\t    // for \"enddef\".\n\t    // We continue to find the end of the function, although we might\n\t    // not find it.\n\t    else if (nesting_def[nesting])\n\t    {\n\t\tif (checkforcmd(&p, \"endfunction\", 4) && *p != ':')\n\t\t    emsg(_(e_mismatched_endfunction));\n\t    }\n\t    else if (eap->cmdidx == CMD_def && checkforcmd(&p, \"enddef\", 4))\n\t\temsg(_(e_mismatched_enddef));\n\n\t    // Increase indent inside \"if\", \"while\", \"for\" and \"try\", decrease\n\t    // at \"end\".\n\t    if (indent > 2 && (*p == '}' || STRNCMP(p, \"end\", 3) == 0))\n\t\tindent -= 2;\n\t    else if (STRNCMP(p, \"if\", 2) == 0\n\t\t    || STRNCMP(p, \"wh\", 2) == 0\n\t\t    || STRNCMP(p, \"for\", 3) == 0\n\t\t    || STRNCMP(p, \"try\", 3) == 0)\n\t\tindent += 2;\n\n\t    // Check for defining a function inside this function.\n\t    // Only recognize \"def\" inside \"def\", not inside \"function\",\n\t    // For backwards compatibility, see Test_function_python().\n\t    c = *p;\n\t    if (is_function_cmd(&p)\n\t\t    || (eap->cmdidx == CMD_def && checkforcmd(&p, \"def\", 3)))\n\t    {\n\t\tif (*p == '!')\n\t\t    p = skipwhite(p + 1);\n\t\tp += eval_fname_script(p);\n\t\tvim_free(trans_function_name(&p, NULL, TRUE, 0, NULL,\n\t\t\t\t\t\t\t\t  NULL, NULL));\n\t\tif (*skipwhite(p) == '(')\n\t\t{\n\t\t    if (nesting == MAX_FUNC_NESTING - 1)\n\t\t\temsg(_(e_function_nesting_too_deep));\n\t\t    else\n\t\t    {\n\t\t\t++nesting;\n\t\t\tnesting_def[nesting] = (c == 'd');\n\t\t\tnesting_inline[nesting] = FALSE;\n\t\t\tindent += 2;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (nesting_def[nesting] ? *p != '#' : *p != '\"')\n\t    {\n\t\t// Not a comment line: check for nested inline function.\n\t\tend = p + STRLEN(p) - 1;\n\t\twhile (end > p && VIM_ISWHITE(*end))\n\t\t    --end;\n\t\tif (end > p + 1 && *end == '{' && VIM_ISWHITE(end[-1]))\n\t\t{\n\t\t    int\t    is_block;\n\n\t\t    // check for trailing \"=> {\": start of an inline function\n\t\t    --end;\n\t\t    while (end > p && VIM_ISWHITE(*end))\n\t\t\t--end;\n\t\t    is_block = end > p + 2 && end[-1] == '=' && end[0] == '>';\n\t\t    if (!is_block)\n\t\t    {\n\t\t\tchar_u *s = p;\n\n\t\t\t// check for line starting with \"au\" for :autocmd or\n\t\t\t// \"com\" for :command, these can use a {} block\n\t\t\tis_block = checkforcmd_noparen(&s, \"autocmd\", 2)\n\t\t\t\t      || checkforcmd_noparen(&s, \"command\", 3);\n\t\t    }\n\n\t\t    if (is_block)\n\t\t    {\n\t\t\tif (nesting == MAX_FUNC_NESTING - 1)\n\t\t\t    emsg(_(e_function_nesting_too_deep));\n\t\t\telse\n\t\t\t{\n\t\t\t    ++nesting;\n\t\t\t    nesting_def[nesting] = TRUE;\n\t\t\t    nesting_inline[nesting] = TRUE;\n\t\t\t    indent += 2;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    // Check for \":append\", \":change\", \":insert\".  Not for :def.\n\t    p = skip_range(p, FALSE, NULL);\n\t    if (!vim9_function\n\t\t&& ((p[0] == 'a' && (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))\n\t\t    || (p[0] == 'c'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'h'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2]) || (p[2] == 'a'\n\t\t\t\t\t&& (STRNCMP(&p[3], \"nge\", 3) != 0\n\t\t\t\t\t    || !ASCII_ISALPHA(p[6])))))))\n\t\t    || (p[0] == 'i'\n\t\t\t&& (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'\n\t\t\t\t&& (!ASCII_ISALPHA(p[2])\n\t\t\t\t    || (p[2] == 's'\n\t\t\t\t\t&& (!ASCII_ISALPHA(p[3])\n\t\t\t\t\t\t|| p[3] == 'e'))))))))\n\t\tskip_until = vim_strsave((char_u *)\".\");\n\n\t    // Check for \":python <<EOF\", \":tcl <<EOF\", etc.\n\t    arg = skipwhite(skiptowhite(p));\n\t    if (arg[0] == '<' && arg[1] =='<'\n\t\t    && ((p[0] == 'p' && p[1] == 'y'\n\t\t\t\t    && (!ASCII_ISALNUM(p[2]) || p[2] == 't'\n\t\t\t\t\t|| ((p[2] == '3' || p[2] == 'x')\n\t\t\t\t\t\t   && !ASCII_ISALPHA(p[3]))))\n\t\t\t|| (p[0] == 'p' && p[1] == 'e'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))\n\t\t\t|| (p[0] == 't' && p[1] == 'c'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))\n\t\t\t|| (p[0] == 'l' && p[1] == 'u' && p[2] == 'a'\n\t\t\t\t    && !ASCII_ISALPHA(p[3]))\n\t\t\t|| (p[0] == 'r' && p[1] == 'u' && p[2] == 'b'\n\t\t\t\t    && (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))\n\t\t\t|| (p[0] == 'm' && p[1] == 'z'\n\t\t\t\t    && (!ASCII_ISALPHA(p[2]) || p[2] == 's'))\n\t\t\t))\n\t    {\n\t\t// \":python <<\" continues until a dot, like \":append\"\n\t\tp = skipwhite(arg + 2);\n\t\tif (STRNCMP(p, \"trim\", 4) == 0)\n\t\t{\n\t\t    // Ignore leading white space.\n\t\t    p = skipwhite(p + 4);\n\t\t    heredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\t\t skipwhite(theline) - theline);\n\t\t}\n\t\tif (*p == NUL)\n\t\t    skip_until = vim_strsave((char_u *)\".\");\n\t\telse\n\t\t    skip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\tgetline_options = GETLINE_NONE;\n\t\tis_heredoc = TRUE;\n\t\tif (eap->cmdidx == CMD_def && nesting == 0)\n\t\t    heredoc_concat_len = newlines->ga_len + 1;\n\t    }\n\n\t    if (!is_heredoc)\n\t    {\n\t\t// Check for \":cmd v =<< [trim] EOF\"\n\t\t//       and \":cmd [a, b] =<< [trim] EOF\"\n\t\t//       and \"lines =<< [trim] EOF\" for Vim9\n\t\t// Where \"cmd\" can be \"let\", \"var\", \"final\" or \"const\".\n\t\targ = skipwhite(skiptowhite(p));\n\t\tif (*arg == '[')\n\t\t    arg = vim_strchr(arg, ']');\n\t\tif (arg != NULL)\n\t\t{\n\t\t    int found = (eap->cmdidx == CMD_def && arg[0] == '='\n\t\t\t\t\t     && arg[1] == '<' && arg[2] =='<');\n\n\t\t    if (!found)\n\t\t\t// skip over the argument after \"cmd\"\n\t\t\targ = skipwhite(skiptowhite(arg));\n\t\t    if (found || (arg[0] == '=' && arg[1] == '<'\n\t\t\t\t\t\t\t\t&& arg[2] =='<'\n\t\t\t    && (checkforcmd(&p, \"let\", 2)\n\t\t\t\t|| checkforcmd(&p, \"var\", 3)\n\t\t\t\t|| checkforcmd(&p, \"final\", 5)\n\t\t\t\t|| checkforcmd(&p, \"const\", 5))))\n\t\t    {\n\t\t\tp = skipwhite(arg + 3);\n\t\t\twhile (TRUE)\n\t\t\t{\n\t\t\t    if (STRNCMP(p, \"trim\", 4) == 0)\n\t\t\t    {\n\t\t\t\t// Ignore leading white space.\n\t\t\t\tp = skipwhite(p + 4);\n\t\t\t\theredoc_trimmed = vim_strnsave(theline,\n\t\t\t\t\tskipwhite(theline) - theline);\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t    if (STRNCMP(p, \"eval\", 4) == 0)\n\t\t\t    {\n\t\t\t\t// Ignore leading white space.\n\t\t\t\tp = skipwhite(p + 4);\n\t\t\t\tcontinue;\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t\tskip_until = vim_strnsave(p, skiptowhite(p) - p);\n\t\t\tgetline_options = GETLINE_NONE;\n\t\t\tis_heredoc = TRUE;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\t// Add the line to the function.\n\tif (ga_grow_id(newlines, 1 + sourcing_lnum_off, aid_get_func) == FAIL)\n\t    goto theend;\n\n\tif (heredoc_concat_len > 0)\n\t{\n\t    // For a :def function \"python << EOF\" concatenates all the lines,\n\t    // to be used for the instruction later.\n\t    ga_concat(&heredoc_ga, theline);\n\t    ga_concat(&heredoc_ga, (char_u *)\"\\n\");\n\t    p = vim_strsave((char_u *)\"\");\n\t}\n\telse\n\t{\n\t    // Copy the line to newly allocated memory.  get_one_sourceline()\n\t    // allocates 250 bytes per line, this saves 80% on average.  The\n\t    // cost is an extra alloc/free.\n\t    p = vim_strsave(theline);\n\t}\n\tif (p == NULL)\n\t    goto theend;\n\t((char_u **)(newlines->ga_data))[newlines->ga_len++] = p;\n\n\t// Add NULL lines for continuation lines, so that the line count is\n\t// equal to the index in the growarray.\n\twhile (sourcing_lnum_off-- > 0)\n\t    ((char_u **)(newlines->ga_data))[newlines->ga_len++] = NULL;\n\n\t// Check for end of eap->arg.\n\tif (line_arg != NULL && *line_arg == NUL)\n\t    line_arg = NULL;\n    }\n\n    // Return OK when no error was detected.\n    if (!did_emsg)\n\tret = OK;\n\ntheend:\n    vim_free(skip_until);\n    vim_free(heredoc_trimmed);\n    vim_free(heredoc_ga.ga_data);\n    need_wait_return |= saved_wait_return;\n    return ret;\n}\n\n/*\n * Handle the body of a lambda.  *arg points to the \"{\", process statements\n * until the matching \"}\".\n * When not evaluating \"newargs\" is NULL.\n * When successful \"rettv\" is set to a funcref.\n */\n    static int\nlambda_function_body(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tevalarg_T   *evalarg,\n\tgarray_T    *newargs,\n\tgarray_T    *argtypes,\n\tint\t    varargs,\n\tgarray_T    *default_args,\n\tchar_u\t    *ret_type)\n{\n    int\t\tevaluate = (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\t*gap = &evalarg->eval_ga;\n    garray_T\t*freegap = &evalarg->eval_freega;\n    ufunc_T\t*ufunc = NULL;\n    exarg_T\teap;\n    garray_T\tnewlines;\n    char_u\t*cmdline = NULL;\n    int\t\tret = FAIL;\n    partial_T\t*pt;\n    char_u\t*name;\n    int\t\tlnum_save = -1;\n    linenr_T\tsourcing_lnum_top = SOURCING_LNUM;\n\n    if (!ends_excmd2(*arg, skipwhite(*arg + 1)))\n    {\n\tsemsg(_(e_trailing_characters_str), *arg + 1);\n\treturn FAIL;\n    }\n\n    CLEAR_FIELD(eap);\n    eap.cmdidx = CMD_block;\n    eap.forceit = FALSE;\n    eap.cmdlinep = &cmdline;\n    eap.skip = !evaluate;\n    if (evalarg->eval_cctx != NULL)\n\tfill_exarg_from_cctx(&eap, evalarg->eval_cctx);\n    else\n    {\n\teap.getline = evalarg->eval_getline;\n\teap.cookie = evalarg->eval_cookie;\n    }\n\n    ga_init2(&newlines, sizeof(char_u *), 10);\n    if (get_function_body(&eap, &newlines, NULL,\n\t\t\t\t\t     &evalarg->eval_tofree_ga) == FAIL)\n\tgoto erret;\n\n    // When inside a lambda must add the function lines to evalarg.eval_ga.\n    evalarg->eval_break_count += newlines.ga_len;\n    if (gap->ga_itemsize > 0)\n    {\n\tint\tidx;\n\tchar_u\t*last;\n\tsize_t  plen;\n\tchar_u  *pnl;\n\n\tfor (idx = 0; idx < newlines.ga_len; ++idx)\n\t{\n\t    char_u  *p = skipwhite(((char_u **)newlines.ga_data)[idx]);\n\n\t    if (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t\tgoto erret;\n\n\t    // Going to concatenate the lines after parsing.  For an empty or\n\t    // comment line use an empty string.\n\t    // Insert NL characters at the start of each line, the string will\n\t    // be split again later in .get_lambda_tv().\n\t    if (*p == NUL || vim9_comment_start(p))\n\t\tp = (char_u *)\"\";\n\t    plen = STRLEN(p);\n\t    pnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\t    if (pnl != NULL)\n\t\tmch_memmove(pnl + 1, p, plen + 1);\n\t    ((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t    ((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n\t}\n\tif (ga_grow(gap, 1) == FAIL || ga_grow(freegap, 1) == FAIL)\n\t    goto erret;\n\tif (eap.nextcmd != NULL)\n\t    // more is following after the \"}\", which was skipped\n\t    last = cmdline;\n\telse\n\t    // nothing is following the \"}\"\n\t    last = (char_u *)\"}\";\n\tplen = STRLEN(last);\n\tpnl = vim_strnsave((char_u *)\"\\n\", plen + 1);\n\tif (pnl != NULL)\n\t    mch_memmove(pnl + 1, last, plen + 1);\n\t((char_u **)gap->ga_data)[gap->ga_len++] = pnl;\n\t((char_u **)freegap->ga_data)[freegap->ga_len++] = pnl;\n    }\n\n    if (eap.nextcmd != NULL)\n    {\n\tgarray_T *tfgap = &evalarg->eval_tofree_ga;\n\n\t// Something comes after the \"}\".\n\t*arg = eap.nextcmd;\n\n\t// \"arg\" points into cmdline, need to keep the line and free it later.\n\tif (ga_grow(tfgap, 1) == OK)\n\t{\n\t    ((char_u **)(tfgap->ga_data))[tfgap->ga_len++] = cmdline;\n\t    evalarg->eval_using_cmdline = TRUE;\n\t}\n    }\n    else\n\t*arg = (char_u *)\"\";\n\n    if (!evaluate)\n    {\n\tret = OK;\n\tgoto erret;\n    }\n\n    name = get_lambda_name();\n    ufunc = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n    if (ufunc == NULL)\n\tgoto erret;\n    set_ufunc_name(ufunc, name);\n    if (hash_add(&func_hashtab, UF2HIKEY(ufunc)) == FAIL)\n\tgoto erret;\n    ufunc->uf_flags = FC_LAMBDA;\n    ufunc->uf_refcount = 1;\n    ufunc->uf_args = *newargs;\n    newargs->ga_data = NULL;\n    ufunc->uf_def_args = *default_args;\n    default_args->ga_data = NULL;\n    ufunc->uf_func_type = &t_func_any;\n\n    // error messages are for the first function line\n    lnum_save = SOURCING_LNUM;\n    SOURCING_LNUM = sourcing_lnum_top;\n\n    // parse argument types\n    if (parse_argument_types(ufunc, argtypes, varargs) == FAIL)\n    {\n\tSOURCING_LNUM = lnum_save;\n\tgoto erret;\n    }\n\n    // parse the return type, if any\n    if (parse_return_type(ufunc, ret_type) == FAIL)\n\tgoto erret;\n\n    pt = ALLOC_CLEAR_ONE(partial_T);\n    if (pt == NULL)\n\tgoto erret;\n    pt->pt_func = ufunc;\n    pt->pt_refcount = 1;\n\n    ufunc->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if (sandbox)\n\tufunc->uf_flags |= FC_SANDBOX;\n    if (!ASCII_ISUPPER(*ufunc->uf_name))\n\tufunc->uf_flags |= FC_VIM9;\n    ufunc->uf_script_ctx = current_sctx;\n    ufunc->uf_script_ctx_version = current_sctx.sc_version;\n    ufunc->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    set_function_type(ufunc);\n\n    function_using_block_scopes(ufunc, evalarg->eval_cstack);\n\n    rettv->vval.v_partial = pt;\n    rettv->v_type = VAR_PARTIAL;\n    ufunc = NULL;\n    ret = OK;\n\nerret:\n    if (lnum_save >= 0)\n\tSOURCING_LNUM = lnum_save;\n    ga_clear_strings(&newlines);\n    if (newargs != NULL)\n\tga_clear_strings(newargs);\n    ga_clear_strings(default_args);\n    if (ufunc != NULL)\n    {\n\tfunc_clear(ufunc, TRUE);\n\tfunc_free(ufunc, TRUE);\n    }\n    return ret;\n}\n\n/*\n * Parse a lambda expression and get a Funcref from \"*arg\" into \"rettv\".\n * \"arg\" points to the { in \"{arg -> expr}\" or the ( in \"(arg) => expr\"\n * When \"types_optional\" is TRUE optionally take argument types.\n * Return OK or FAIL.  Returns NOTDONE for dict or {expr}.\n */\n    int\nget_lambda_tv(\n\tchar_u\t    **arg,\n\ttypval_T    *rettv,\n\tint\t    types_optional,\n\tevalarg_T   *evalarg)\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    garray_T\tnewargs;\n    garray_T\tnewlines;\n    garray_T\t*pnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    ufunc_T\t*fp = NULL;\n    partial_T   *pt = NULL;\n    int\t\tvarargs;\n    char_u\t*ret_type = NULL;\n    int\t\tret;\n    char_u\t*s;\n    char_u\t*start, *end;\n    int\t\t*old_eval_lavars = eval_lavars_used;\n    int\t\teval_lavars = FALSE;\n    char_u\t*tofree2 = NULL;\n    int\t\tequal_arrow = **arg == '(';\n    int\t\twhite_error = FALSE;\n    int\t\tcalled_emsg_start = called_emsg;\n    int\t\tvim9script = in_vim9script();\n    long\tstart_lnum = SOURCING_LNUM;\n\n    if (equal_arrow && !vim9script)\n\treturn NOTDONE;\n\n    ga_init(&newargs);\n    ga_init(&newlines);\n\n    // First, check if this is really a lambda expression. \"->\" or \"=>\" must\n    // be found after the arguments.\n    s = *arg + 1;\n    ret = get_function_args(&s, equal_arrow ? ')' : '-', NULL,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\tNULL, &default_args, TRUE, NULL, NULL);\n    if (ret == FAIL || skip_arrow(s, equal_arrow, &ret_type, NULL) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\treturn called_emsg == called_emsg_start ? NOTDONE : FAIL;\n    }\n\n    // Parse the arguments for real.\n    if (evaluate)\n\tpnewargs = &newargs;\n    else\n\tpnewargs = NULL;\n    *arg += 1;\n    ret = get_function_args(arg, equal_arrow ? ')' : '-', pnewargs,\n\t    types_optional ? &argtypes : NULL, types_optional, evalarg,\n\t\t\t\t\t    &varargs, &default_args,\n\t\t\t\t\t    FALSE, NULL, NULL);\n    if (ret == FAIL\n\t\t  || (s = skip_arrow(*arg, equal_arrow, &ret_type,\n\t\tequal_arrow || vim9script ? &white_error : NULL)) == NULL)\n    {\n\tif (types_optional)\n\t    ga_clear_strings(&argtypes);\n\tga_clear_strings(&newargs);\n\treturn white_error ? FAIL : NOTDONE;\n    }\n    *arg = s;\n\n    // Skipping over linebreaks may make \"ret_type\" invalid, make a copy.\n    if (ret_type != NULL)\n    {\n\tret_type = vim_strsave(ret_type);\n\ttofree2 = ret_type;\n    }\n\n    // Set up a flag for checking local variables and arguments.\n    if (evaluate)\n\teval_lavars_used = &eval_lavars;\n\n    *arg = skipwhite_and_linebreak(*arg, evalarg);\n\n    // Recognize \"{\" as the start of a function body.\n    if (equal_arrow && **arg == '{')\n    {\n\tif (evalarg == NULL)\n\t    // cannot happen?\n\t    goto theend;\n\tSOURCING_LNUM = start_lnum;  // used for where lambda is defined\n\tif (lambda_function_body(arg, rettv, evalarg, pnewargs,\n\t\t\t   types_optional ? &argtypes : NULL, varargs,\n\t\t\t   &default_args, ret_type) == FAIL)\n\t    goto errret;\n\tgoto theend;\n    }\n    if (default_args.ga_len > 0)\n    {\n\temsg(_(e_cannot_use_default_values_in_lambda));\n\tgoto errret;\n    }\n\n    // Get the start and the end of the expression.\n    start = *arg;\n    ret = skip_expr_concatenate(arg, &start, &end, evalarg);\n    if (ret == FAIL)\n\tgoto errret;\n\n    if (!equal_arrow)\n    {\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != '}')\n\t{\n\t    semsg(_(e_expected_right_curly_str), *arg);\n\t    goto errret;\n\t}\n\t++*arg;\n    }\n\n    if (evaluate)\n    {\n\tint\t    len;\n\tint\t    flags = FC_LAMBDA;\n\tchar_u\t    *p;\n\tchar_u\t    *line_end;\n\tchar_u\t    *name = get_lambda_name();\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto errret;\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\tpt = ALLOC_CLEAR_ONE(partial_T);\n\tif (pt == NULL)\n\t    goto errret;\n\n\tga_init2(&newlines, sizeof(char_u *), 1);\n\tif (ga_grow(&newlines, 1) == FAIL)\n\t    goto errret;\n\n\t// If there are line breaks, we need to split up the string.\n\tline_end = vim_strchr(start, '\\n');\n\tif (line_end == NULL || line_end > end)\n\t    line_end = end;\n\n\t// Add \"return \" before the expression (or the first line).\n\tlen = 7 + (int)(line_end - start) + 1;\n\tp = alloc(len);\n\tif (p == NULL)\n\t    goto errret;\n\t((char_u **)(newlines.ga_data))[newlines.ga_len++] = p;\n\tSTRCPY(p, \"return \");\n\tvim_strncpy(p + 7, start, line_end - start);\n\n\tif (line_end != end)\n\t{\n\t    // Add more lines, split by line breaks.  Thus is used when a\n\t    // lambda with { cmds } is encountered.\n\t    while (*line_end == '\\n')\n\t    {\n\t\tif (ga_grow(&newlines, 1) == FAIL)\n\t\t    goto errret;\n\t\tstart = line_end + 1;\n\t\tline_end = vim_strchr(start, '\\n');\n\t\tif (line_end == NULL)\n\t\t    line_end = end;\n\t\t((char_u **)(newlines.ga_data))[newlines.ga_len++] =\n\t\t\t\t\t vim_strnsave(start, line_end - start);\n\t    }\n\t}\n\n\tif (strstr((char *)p + 7, \"a:\") == NULL)\n\t    // No a: variables are used for sure.\n\t    flags |= FC_NOARGS;\n\n\tfp->uf_refcount = 1;\n\tset_ufunc_name(fp, name);\n\tfp->uf_args = newargs;\n\tga_init(&fp->uf_def_args);\n\tif (types_optional)\n\t{\n\t    if (parse_argument_types(fp, &argtypes,\n\t\t\t\t\t\tvim9script && varargs) == FAIL)\n\t\tgoto errret;\n\t    if (ret_type != NULL)\n\t    {\n\t\tfp->uf_ret_type = parse_type(&ret_type,\n\t\t\t\t\t\t      &fp->uf_type_list, TRUE);\n\t\tif (fp->uf_ret_type == NULL)\n\t\t    goto errret;\n\t    }\n\t    else\n\t\tfp->uf_ret_type = &t_unknown;\n\t}\n\n\tfp->uf_lines = newlines;\n\tif (current_funccal != NULL && eval_lavars)\n\t{\n\t    flags |= FC_CLOSURE;\n\t    if (register_closure(fp) == FAIL)\n\t\tgoto errret;\n\t}\n\n#ifdef FEAT_PROFILE\n\tif (prof_def_func())\n\t    func_do_profile(fp);\n#endif\n\tif (sandbox)\n\t    flags |= FC_SANDBOX;\n\t// In legacy script a lambda can be called with more args than\n\t// uf_args.ga_len.  In Vim9 script \"...name\" has to be used.\n\tfp->uf_varargs = !vim9script || varargs;\n\tfp->uf_flags = flags;\n\tfp->uf_calls = 0;\n\tfp->uf_script_ctx = current_sctx;\n\t// Use the line number of the arguments.\n\tfp->uf_script_ctx.sc_lnum += start_lnum;\n\n\tfunction_using_block_scopes(fp, evalarg->eval_cstack);\n\n\tpt->pt_func = fp;\n\tpt->pt_refcount = 1;\n\trettv->vval.v_partial = pt;\n\trettv->v_type = VAR_PARTIAL;\n\n\thash_add(&func_hashtab, UF2HIKEY(fp));\n    }\n\ntheend:\n    eval_lavars_used = old_eval_lavars;\n    vim_free(tofree2);\n    if (types_optional)\n\tga_clear_strings(&argtypes);\n\n    return OK;\n\nerrret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&newlines);\n    ga_clear_strings(&default_args);\n    if (types_optional)\n    {\n\tga_clear_strings(&argtypes);\n\tif (fp != NULL)\n\t    vim_free(fp->uf_arg_types);\n    }\n    vim_free(fp);\n    vim_free(pt);\n    vim_free(tofree2);\n    eval_lavars_used = old_eval_lavars;\n    return FAIL;\n}\n\n/*\n * Check if \"name\" is a variable of type VAR_FUNC.  If so, return the function\n * name it contains, otherwise return \"name\".\n * If \"partialp\" is not NULL, and \"name\" is of type VAR_PARTIAL also set\n * \"partialp\".\n * If \"type\" is not NULL and a Vim9 script-local variable is found look up the\n * type of the variable.\n * If \"new_function\" is TRUE the name is for a new function.\n * If \"found_var\" is not NULL and a variable was found set it to TRUE.\n */\n    char_u *\nderef_func_name(\n\tchar_u\t    *name,\n\tint\t    *lenp,\n\tpartial_T   **partialp,\n\ttype_T\t    **type,\n\tint\t    no_autoload,\n\tint\t    new_function,\n\tint\t    *found_var)\n{\n    dictitem_T\t*v;\n    typval_T\t*tv = NULL;\n    int\t\tcc;\n    char_u\t*s = NULL;\n    hashtab_T\t*ht;\n    int\t\tdid_type = FALSE;\n\n    if (partialp != NULL)\n\t*partialp = NULL;\n\n    cc = name[*lenp];\n    name[*lenp] = NUL;\n\n    v = find_var_also_in_script(name, &ht, no_autoload);\n    name[*lenp] = cc;\n    if (v != NULL)\n    {\n\ttv = &v->di_tv;\n    }\n    else if (in_vim9script() || STRNCMP(name, \"s:\", 2) == 0)\n    {\n\timported_T  *import;\n\tchar_u\t    *p = name;\n\tint\t    len = *lenp;\n\n\tif (STRNCMP(name, \"s:\", 2) == 0)\n\t{\n\t    p = name + 2;\n\t    len -= 2;\n\t}\n\timport = find_imported(p, len, FALSE);\n\n\t// imported function from another script\n\tif (import != NULL)\n\t{\n\t    name[len] = NUL;\n\t    if (new_function)\n\t\tsemsg(_(e_redefining_imported_item_str), name);\n\t    else\n\t\tsemsg(_(e_cannot_use_str_itself_it_is_imported), name);\n\t    name[len] = cc;\n\t    *lenp = 0;\n\t    return (char_u *)\"\";\t// just in case\n\t}\n    }\n\n    if (tv != NULL)\n    {\n\tif (found_var != NULL)\n\t    *found_var = TRUE;\n\tif (tv->v_type == VAR_FUNC)\n\t{\n\t    if (tv->vval.v_string == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    s = tv->vval.v_string;\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (tv->v_type == VAR_PARTIAL)\n\t{\n\t    partial_T *pt = tv->vval.v_partial;\n\n\t    if (pt == NULL)\n\t    {\n\t\t*lenp = 0;\n\t\treturn (char_u *)\"\";\t// just in case\n\t    }\n\t    if (partialp != NULL)\n\t\t*partialp = pt;\n\t    s = partial_name(pt);\n\t    *lenp = (int)STRLEN(s);\n\t}\n\n\tif (s != NULL)\n\t{\n\t    if (!did_type && type != NULL && ht == get_script_local_ht())\n\t    {\n\t\tsvar_T  *sv = find_typval_in_script(tv, 0, TRUE);\n\n\t\tif (sv != NULL)\n\t\t    *type = sv->sv_type;\n\t    }\n\t    return s;\n\t}\n    }\n\n    return name;\n}\n\n/*\n * Give an error message with a function name.  Handle <SNR> things.\n * \"ermsg\" is to be passed without translation, use N_() instead of _().\n */\n    void\nemsg_funcname(char *ermsg, char_u *name)\n{\n    char_u\t*p = name;\n\n    if (name[0] == K_SPECIAL && name[1] != NUL && name[2] != NUL)\n\tp = concat_str((char_u *)\"<SNR>\", name + 3);\n    semsg(_(ermsg), p);\n    if (p != name)\n\tvim_free(p);\n}\n\n/*\n * Allocate a variable for the result of a function.\n * Return OK or FAIL.\n */\n    int\nget_func_tv(\n    char_u\t*name,\t\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\n    char_u\t**arg,\t\t// argument, pointing to the '('\n    evalarg_T\t*evalarg,\t// for line continuation\n    funcexe_T\t*funcexe)\t// various values\n{\n    char_u\t*argp;\n    int\t\tret = OK;\n    typval_T\targvars[MAX_FUNC_ARGS + 1];\t// vars for arguments\n    int\t\targcount = 0;\t\t// number of arguments found\n    int\t\tvim9script = in_vim9script();\n    int\t\tevaluate = evalarg == NULL\n\t\t\t       ? FALSE : (evalarg->eval_flags & EVAL_EVALUATE);\n\n    /*\n     * Get the arguments.\n     */\n    argp = *arg;\n    while (argcount < MAX_FUNC_ARGS - (funcexe->fe_partial == NULL ? 0\n\t\t\t\t\t       : funcexe->fe_partial->pt_argc))\n    {\n\t// skip the '(' or ',' and possibly line breaks\n\targp = skipwhite_and_linebreak(argp + 1, evalarg);\n\n\tif (*argp == ')' || *argp == ',' || *argp == NUL)\n\t    break;\n\tif (eval1(&argp, &argvars[argcount], evalarg) == FAIL)\n\t{\n\t    ret = FAIL;\n\t    break;\n\t}\n\t++argcount;\n\t// The comma should come right after the argument, but this wasn't\n\t// checked previously, thus only enforce it in Vim9 script.\n\tif (vim9script)\n\t{\n\t    if (*argp != ',' && *skipwhite(argp) == ',')\n\t    {\n\t\tif (evaluate)\n\t\t    semsg(_(e_no_white_space_allowed_before_str_str),\n\t\t\t\t\t\t\t\t    \",\", argp);\n\t\tret = FAIL;\n\t\tbreak;\n\t    }\n\t}\n\telse\n\t    argp = skipwhite(argp);\n\tif (*argp != ',')\n\t    break;\n\tif (vim9script && !IS_WHITE_OR_NUL(argp[1]))\n\t{\n\t    if (evaluate)\n\t\tsemsg(_(e_white_space_required_after_str_str), \",\", argp);\n\t    ret = FAIL;\n\t    break;\n\t}\n    }\n    argp = skipwhite_and_linebreak(argp, evalarg);\n    if (*argp == ')')\n\t++argp;\n    else\n\tret = FAIL;\n\n    if (ret == OK)\n    {\n\tint\ti = 0;\n\tint\tdid_emsg_before = did_emsg;\n\n\tif (get_vim_var_nr(VV_TESTING))\n\t{\n\t    // Prepare for calling test_garbagecollect_now(), need to know\n\t    // what variables are used on the call stack.\n\t    if (funcargs.ga_itemsize == 0)\n\t\tga_init2(&funcargs, sizeof(typval_T *), 50);\n\t    for (i = 0; i < argcount; ++i)\n\t\tif (ga_grow(&funcargs, 1) == OK)\n\t\t    ((typval_T **)funcargs.ga_data)[funcargs.ga_len++] =\n\t\t\t\t\t\t\t\t  &argvars[i];\n\t}\n\n\tret = call_func(name, len, rettv, argcount, argvars, funcexe);\n\tif (vim9script && did_emsg > did_emsg_before)\n\t{\n\t    // An error in a builtin function does not return FAIL, but we do\n\t    // want to abort further processing if an error was given.\n\t    ret = FAIL;\n\t    clear_tv(rettv);\n\t}\n\n\tfuncargs.ga_len -= i;\n    }\n    else if (!aborting() && evaluate)\n    {\n\tif (argcount == MAX_FUNC_ARGS)\n\t    emsg_funcname(e_too_many_arguments_for_function_str_2, name);\n\telse\n\t    emsg_funcname(e_invalid_arguments_for_function_str, name);\n    }\n\n    while (--argcount >= 0)\n\tclear_tv(&argvars[argcount]);\n\n    if (vim9script)\n\t*arg = argp;\n    else\n\t*arg = skipwhite(argp);\n    return ret;\n}\n\n/*\n * Return TRUE if \"p\" starts with \"<SID>\" or \"s:\".\n * Only works if eval_fname_script() returned non-zero for \"p\"!\n */\n    static int\neval_fname_sid(char_u *p)\n{\n    return (*p == 's' || TOUPPER_ASC(p[2]) == 'I');\n}\n\n/*\n * In a script change <SID>name() and s:name() to K_SNR 123_name().\n * Change <SNR>123_name() to K_SNR 123_name().\n * Use \"fname_buf[FLEN_FIXED + 1]\" when it fits, otherwise allocate memory\n * (slow).\n */\n    char_u *\nfname_trans_sid(char_u *name, char_u *fname_buf, char_u **tofree, int *error)\n{\n    int\t\tllen;\n    char_u\t*fname;\n    int\t\ti;\n\n    llen = eval_fname_script(name);\n    if (llen > 0)\n    {\n\tfname_buf[0] = K_SPECIAL;\n\tfname_buf[1] = KS_EXTRA;\n\tfname_buf[2] = (int)KE_SNR;\n\ti = 3;\n\tif (eval_fname_sid(name))\t// \"<SID>\" or \"s:\"\n\t{\n\t    if (current_sctx.sc_sid <= 0)\n\t\t*error = FCERR_SCRIPT;\n\t    else\n\t    {\n\t\tsprintf((char *)fname_buf + 3, \"%ld_\",\n\t\t\t\t\t\t    (long)current_sctx.sc_sid);\n\t\ti = (int)STRLEN(fname_buf);\n\t    }\n\t}\n\tif (i + STRLEN(name + llen) < FLEN_FIXED)\n\t{\n\t    STRCPY(fname_buf + i, name + llen);\n\t    fname = fname_buf;\n\t}\n\telse\n\t{\n\t    fname = alloc(i + STRLEN(name + llen) + 1);\n\t    if (fname == NULL)\n\t\t*error = FCERR_OTHER;\n\t    else\n\t    {\n\t\t*tofree = fname;\n\t\tmch_memmove(fname, fname_buf, (size_t)i);\n\t\tSTRCPY(fname + i, name + llen);\n\t    }\n\t}\n    }\n    else\n\tfname = name;\n    return fname;\n}\n\n/*\n * Concatenate the script ID and function name into  \"<SNR>99_name\".\n * \"buffer\" must have size MAX_FUNC_NAME_LEN.\n */\n    void\nfunc_name_with_sid(char_u *name, int sid, char_u *buffer)\n{\n    // A script-local function is stored as \"<SNR>99_name\".\n    buffer[0] = K_SPECIAL;\n    buffer[1] = KS_EXTRA;\n    buffer[2] = (int)KE_SNR;\n    vim_snprintf((char *)buffer + 3, MAX_FUNC_NAME_LEN - 3, \"%ld_%s\",\n\t\t\t\t\t\t\t      (long)sid, name);\n}\n\n/*\n * Find a function \"name\" in script \"sid\".\n */\n    static ufunc_T *\nfind_func_with_sid(char_u *name, int sid)\n{\n    hashitem_T\t    *hi;\n    char_u\t    buffer[MAX_FUNC_NAME_LEN];\n\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\t// not in a script\n\n    func_name_with_sid(name, sid, buffer);\n    hi = hash_find(&func_hashtab, buffer);\n    if (!HASHITEM_EMPTY(hi))\n\treturn HI2UF(hi);\n    return NULL;\n}\n\n/*\n * Find a function \"name\" in script \"sid\" prefixing the autoload prefix.\n */\n    static ufunc_T *\nfind_func_with_prefix(char_u *name, int sid)\n{\n    hashitem_T\t    *hi;\n    char_u\t    buffer[MAX_FUNC_NAME_LEN];\n    scriptitem_T    *si;\n\n    if (vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\treturn NULL;\t// already has the prefix\n    if (!SCRIPT_ID_VALID(sid))\n\treturn NULL;\t// not in a script\n    si = SCRIPT_ITEM(sid);\n    if (si->sn_autoload_prefix != NULL)\n    {\n\tsize_t\tlen = STRLEN(si->sn_autoload_prefix) + STRLEN(name) + 1;\n\tchar_u\t*auto_name;\n\tchar_u\t*namep;\n\n\t// skip a \"<SNR>99_\" prefix\n\tnamep = untrans_function_name(name);\n\tif (namep == NULL)\n\t    namep = name;\n\n\t// An exported function in an autoload script is stored as\n\t// \"dir#path#name\".\n\tif (len < sizeof(buffer))\n\t    auto_name = buffer;\n\telse\n\t    auto_name = alloc(len);\n\tif (auto_name != NULL)\n\t{\n\t    vim_snprintf((char *)auto_name, len, \"%s%s\",\n\t\t\t\t\t\tsi->sn_autoload_prefix, namep);\n\t    hi = hash_find(&func_hashtab, auto_name);\n\t    if (auto_name != buffer)\n\t\tvim_free(auto_name);\n\t    if (!HASHITEM_EMPTY(hi))\n\t\treturn HI2UF(hi);\n\t}\n    }\n\n    return NULL;\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * When \"flags\" has FFED_IS_GLOBAL don't find script-local or imported\n * functions.\n * When \"flags\" has \"FFED_NO_GLOBAL\" don't find global functions.\n * Return NULL for unknown function.\n */\n    ufunc_T *\nfind_func_even_dead(char_u *name, int flags)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*func;\n\n    if ((flags & FFED_IS_GLOBAL) == 0)\n    {\n\t// Find script-local function before global one.\n\tif (in_vim9script() && eval_isnamec1(*name)\n\t\t\t\t\t   && (name[1] != ':' || *name == 's'))\n\t{\n\t    func = find_func_with_sid(name[0] == 's' && name[1] == ':'\n\t\t\t\t       ? name + 2 : name, current_sctx.sc_sid);\n\t    if (func != NULL)\n\t\treturn func;\n\t}\n\tif (in_vim9script() && STRNCMP(name, \"<SNR>\", 5) == 0)\n\t{\n\t    char_u  *p = name + 5;\n\t    long    sid;\n\n\t    // printable \"<SNR>123_Name\" form\n\t    sid = getdigits(&p);\n\t    if (*p == '_')\n\t    {\n\t\tfunc = find_func_with_sid(p + 1, (int)sid);\n\t\tif (func != NULL)\n\t\t    return func;\n\t    }\n\t}\n    }\n\n    if ((flags & FFED_NO_GLOBAL) == 0)\n    {\n\thi = hash_find(&func_hashtab,\n\t\t\t\tSTRNCMP(name, \"g:\", 2) == 0 ? name + 2 : name);\n\tif (!HASHITEM_EMPTY(hi))\n\t    return HI2UF(hi);\n    }\n\n    // Find autoload function if this is an autoload script.\n    return find_func_with_prefix(name[0] == 's' && name[1] == ':'\n\t\t\t\t       ? name + 2 : name, current_sctx.sc_sid);\n}\n\n/*\n * Find a function by name, return pointer to it in ufuncs.\n * \"cctx\" is passed in a :def function to find imported functions.\n * Return NULL for unknown or dead function.\n */\n    ufunc_T *\nfind_func(char_u *name, int is_global)\n{\n    ufunc_T\t*fp = find_func_even_dead(name, is_global ? FFED_IS_GLOBAL : 0);\n\n    if (fp != NULL && (fp->uf_flags & FC_DEAD) == 0)\n\treturn fp;\n    return NULL;\n}\n\n/*\n * Return TRUE if \"ufunc\" is a global function.\n */\n    int\nfunc_is_global(ufunc_T *ufunc)\n{\n    return ufunc->uf_name[0] != K_SPECIAL;\n}\n\n/*\n * Return TRUE if \"ufunc\" must be called with a g: prefix in Vim9 script.\n */\n    int\nfunc_requires_g_prefix(ufunc_T *ufunc)\n{\n    return ufunc->uf_name[0] != K_SPECIAL\n\t    && (ufunc->uf_flags & FC_LAMBDA) == 0\n\t    && vim_strchr(ufunc->uf_name, AUTOLOAD_CHAR) == NULL;\n}\n\n/*\n * Copy the function name of \"fp\" to buffer \"buf\".\n * \"buf\" must be able to hold the function name plus three bytes.\n * Takes care of script-local function names.\n */\n    static void\ncat_func_name(char_u *buf, ufunc_T *fp)\n{\n    if (!func_is_global(fp))\n    {\n\tSTRCPY(buf, \"<SNR>\");\n\tSTRCAT(buf, fp->uf_name + 3);\n    }\n    else\n\tSTRCPY(buf, fp->uf_name);\n}\n\n/*\n * Add a number variable \"name\" to dict \"dp\" with value \"nr\".\n */\n    static void\nadd_nr_var(\n    dict_T\t*dp,\n    dictitem_T\t*v,\n    char\t*name,\n    varnumber_T nr)\n{\n    STRCPY(v->di_key, name);\n    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n    hash_add(&dp->dv_hashtab, DI2HIKEY(v));\n    v->di_tv.v_type = VAR_NUMBER;\n    v->di_tv.v_lock = VAR_FIXED;\n    v->di_tv.vval.v_number = nr;\n}\n\n/*\n * Free \"fc\".\n */\n    static void\nfree_funccal(funccall_T *fc)\n{\n    int\ti;\n\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n    {\n\tufunc_T *fp = ((ufunc_T **)(fc->fc_funcs.ga_data))[i];\n\n\t// When garbage collecting a funccall_T may be freed before the\n\t// function that references it, clear its uf_scoped field.\n\t// The function may have been redefined and point to another\n\t// funccall_T, don't clear it then.\n\tif (fp != NULL && fp->uf_scoped == fc)\n\t    fp->uf_scoped = NULL;\n    }\n    ga_clear(&fc->fc_funcs);\n\n    func_ptr_unref(fc->func);\n    vim_free(fc);\n}\n\n/*\n * Free \"fc\" and what it contains.\n * Can be called only when \"fc\" is kept beyond the period of it called,\n * i.e. after cleanup_function_call(fc).\n */\n   static void\nfree_funccal_contents(funccall_T *fc)\n{\n    listitem_T\t*li;\n\n    // Free all l: variables.\n    vars_clear(&fc->l_vars.dv_hashtab);\n\n    // Free all a: variables.\n    vars_clear(&fc->l_avars.dv_hashtab);\n\n    // Free the a:000 variables.\n    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\tclear_tv(&li->li_tv);\n\n    free_funccal(fc);\n}\n\n/*\n * Handle the last part of returning from a function: free the local hashtable.\n * Unless it is still in use by a closure.\n */\n    static void\ncleanup_function_call(funccall_T *fc)\n{\n    int\tmay_free_fc = fc->fc_refcount <= 0;\n    int\tfree_fc = TRUE;\n\n    current_funccal = fc->caller;\n\n    // Free all l: variables if not referred.\n    if (may_free_fc && fc->l_vars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear(&fc->l_vars.dv_hashtab);\n    else\n\tfree_fc = FALSE;\n\n    // If the a:000 list and the l: and a: dicts are not referenced and\n    // there is no closure using it, we can free the funccall_T and what's\n    // in it.\n    if (may_free_fc && fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)\n\tvars_clear_ext(&fc->l_avars.dv_hashtab, FALSE);\n    else\n    {\n\tint\t    todo;\n\thashitem_T  *hi;\n\tdictitem_T  *di;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a: variables, since we didn't do that above.\n\ttodo = (int)fc->l_avars.dv_hashtab.ht_used;\n\tfor (hi = fc->l_avars.dv_hashtab.ht_array; todo > 0; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tdi = HI2DI(hi);\n\t\tcopy_tv(&di->di_tv, &di->di_tv);\n\t    }\n\t}\n    }\n\n    if (may_free_fc && fc->l_varlist.lv_refcount == DO_NOT_FREE_CNT)\n\tfc->l_varlist.lv_first = NULL;\n    else\n    {\n\tlistitem_T *li;\n\n\tfree_fc = FALSE;\n\n\t// Make a copy of the a:000 items, since we didn't do that above.\n\tFOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\t    copy_tv(&li->li_tv, &li->li_tv);\n    }\n\n    if (free_fc)\n\tfree_funccal(fc);\n    else\n    {\n\tstatic int made_copy = 0;\n\n\t// \"fc\" is still in use.  This can happen when returning \"a:000\",\n\t// assigning \"l:\" to a global variable or defining a closure.\n\t// Link \"fc\" in the list for garbage collection later.\n\tfc->caller = previous_funccal;\n\tprevious_funccal = fc;\n\n\tif (want_garbage_collect)\n\t    // If garbage collector is ready, clear count.\n\t    made_copy = 0;\n\telse if (++made_copy >= (int)((4096 * 1024) / sizeof(*fc)))\n\t{\n\t    // We have made a lot of copies, worth 4 Mbyte.  This can happen\n\t    // when repetitively calling a function that creates a reference to\n\t    // itself somehow.  Call the garbage collector soon to avoid using\n\t    // too much memory.\n\t    made_copy = 0;\n\t    want_garbage_collect = TRUE;\n\t}\n    }\n}\n\n/*\n * Return TRUE if \"name\" is a numbered function, ignoring a \"g:\" prefix.\n */\n    static int\nnumbered_function(char_u *name)\n{\n    return isdigit(*name)\n\t    || (name[0] == 'g' && name[1] == ':' && isdigit(name[2]));\n}\n\n/*\n * There are two kinds of function names:\n * 1. ordinary names, function defined with :function or :def;\n *    can start with \"<SNR>123_\" literally or with K_SPECIAL.\n * 2. Numbered functions and lambdas: \"<lambda>123\"\n * For the first we only count the name stored in func_hashtab as a reference,\n * using function() does not count as a reference, because the function is\n * looked up by name.\n */\n    int\nfunc_name_refcount(char_u *name)\n{\n    return numbered_function(name) || (name[0] == '<' && name[1] == 'l');\n}\n\n/*\n * Unreference \"fc\": decrement the reference count and free it when it\n * becomes zero.  \"fp\" is detached from \"fc\".\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunccal_unref(funccall_T *fc, ufunc_T *fp, int force)\n{\n    funccall_T\t**pfc;\n    int\t\ti;\n\n    if (fc == NULL)\n\treturn;\n\n    if (--fc->fc_refcount <= 0 && (force || (\n\t\tfc->l_varlist.lv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_vars.dv_refcount == DO_NOT_FREE_CNT\n\t\t&& fc->l_avars.dv_refcount == DO_NOT_FREE_CNT)))\n\tfor (pfc = &previous_funccal; *pfc != NULL; pfc = &(*pfc)->caller)\n\t{\n\t    if (fc == *pfc)\n\t    {\n\t\t*pfc = fc->caller;\n\t\tfree_funccal_contents(fc);\n\t\treturn;\n\t    }\n\t}\n    for (i = 0; i < fc->fc_funcs.ga_len; ++i)\n\tif (((ufunc_T **)(fc->fc_funcs.ga_data))[i] == fp)\n\t    ((ufunc_T **)(fc->fc_funcs.ga_data))[i] = NULL;\n}\n\n/*\n * Remove the function from the function hashtable.  If the function was\n * deleted while it still has references this was already done.\n * Return TRUE if the entry was deleted, FALSE if it wasn't found.\n */\n    static int\nfunc_remove(ufunc_T *fp)\n{\n    hashitem_T\t*hi;\n\n    // Return if it was already virtually deleted.\n    if (fp->uf_flags & FC_DEAD)\n\treturn FALSE;\n\n    hi = hash_find(&func_hashtab, UF2HIKEY(fp));\n    if (!HASHITEM_EMPTY(hi))\n    {\n\t// When there is a def-function index do not actually remove the\n\t// function, so we can find the index when defining the function again.\n\t// Do remove it when it's a copy.\n\tif (fp->uf_def_status == UF_COMPILED && (fp->uf_flags & FC_COPY) == 0)\n\t{\n\t    fp->uf_flags |= FC_DEAD;\n\t    return FALSE;\n\t}\n\thash_remove(&func_hashtab, hi);\n\tfp->uf_flags |= FC_DELETED;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n    static void\nfunc_clear_items(ufunc_T *fp)\n{\n    ga_clear_strings(&(fp->uf_args));\n    ga_clear_strings(&(fp->uf_def_args));\n    ga_clear_strings(&(fp->uf_lines));\n    VIM_CLEAR(fp->uf_arg_types);\n    VIM_CLEAR(fp->uf_block_ids);\n    VIM_CLEAR(fp->uf_va_name);\n    clear_type_list(&fp->uf_type_list);\n\n    // Increment the refcount of this function to avoid it being freed\n    // recursively when the partial is freed.\n    fp->uf_refcount += 3;\n    partial_unref(fp->uf_partial);\n    fp->uf_partial = NULL;\n    fp->uf_refcount -= 3;\n\n#ifdef FEAT_LUA\n    if (fp->uf_cb_free != NULL)\n    {\n\tfp->uf_cb_free(fp->uf_cb_state);\n\tfp->uf_cb_free = NULL;\n    }\n\n    fp->uf_cb_state = NULL;\n    fp->uf_cb = NULL;\n#endif\n#ifdef FEAT_PROFILE\n    VIM_CLEAR(fp->uf_tml_count);\n    VIM_CLEAR(fp->uf_tml_total);\n    VIM_CLEAR(fp->uf_tml_self);\n#endif\n}\n\n/*\n * Free all things that a function contains.  Does not free the function\n * itself, use func_free() for that.\n * When \"force\" is TRUE we are exiting.\n */\n    static void\nfunc_clear(ufunc_T *fp, int force)\n{\n    if (fp->uf_cleared)\n\treturn;\n    fp->uf_cleared = TRUE;\n\n    // clear this function\n    func_clear_items(fp);\n    funccal_unref(fp->uf_scoped, fp, force);\n    unlink_def_function(fp);\n}\n\n/*\n * Free a function and remove it from the list of functions.  Does not free\n * what a function contains, call func_clear() first.\n * When \"force\" is TRUE we are exiting.\n * Returns OK when the function was actually freed.\n */\n    static int\nfunc_free(ufunc_T *fp, int force)\n{\n    // Only remove it when not done already, otherwise we would remove a newer\n    // version of the function with the same name.\n    if ((fp->uf_flags & (FC_DELETED | FC_REMOVED)) == 0)\n\tfunc_remove(fp);\n\n    if ((fp->uf_flags & FC_DEAD) == 0 || force)\n    {\n\tif (fp->uf_dfunc_idx > 0)\n\t    unlink_def_function(fp);\n\tVIM_CLEAR(fp->uf_name_exp);\n\tvim_free(fp);\n\treturn OK;\n    }\n    return FAIL;\n}\n\n/*\n * Free all things that a function contains and free the function itself.\n * When \"force\" is TRUE we are exiting.\n */\n    void\nfunc_clear_free(ufunc_T *fp, int force)\n{\n    func_clear(fp, force);\n    if (force || fp->uf_dfunc_idx == 0 || func_name_refcount(fp->uf_name)\n\t\t\t\t\t\t   || (fp->uf_flags & FC_COPY))\n\tfunc_free(fp, force);\n    else\n\tfp->uf_flags |= FC_DEAD;\n}\n\n/*\n * Copy already defined function \"lambda\" to a new function with name \"global\".\n * This is for when a compiled function defines a global function.\n */\n    int\ncopy_func(char_u *lambda, char_u *global, ectx_T *ectx)\n{\n    ufunc_T *ufunc = find_func_even_dead(lambda, FFED_IS_GLOBAL);\n    ufunc_T *fp = NULL;\n\n    if (ufunc == NULL)\n    {\n\tsemsg(_(e_lambda_function_not_found_str), lambda);\n\treturn FAIL;\n    }\n\n    fp = find_func(global, TRUE);\n    if (fp != NULL)\n    {\n\t// TODO: handle ! to overwrite\n\tsemsg(_(e_function_str_already_exists_add_bang_to_replace), global);\n\treturn FAIL;\n    }\n\n    fp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(global) + 1);\n    if (fp == NULL)\n\treturn FAIL;\n\n    fp->uf_varargs = ufunc->uf_varargs;\n    fp->uf_flags = (ufunc->uf_flags & ~FC_VIM9) | FC_COPY;\n    fp->uf_def_status = ufunc->uf_def_status;\n    fp->uf_dfunc_idx = ufunc->uf_dfunc_idx;\n    if (ga_copy_strings(&ufunc->uf_args, &fp->uf_args) == FAIL\n\t    || ga_copy_strings(&ufunc->uf_def_args, &fp->uf_def_args)\n\t\t\t\t\t\t\t\t    == FAIL\n\t    || ga_copy_strings(&ufunc->uf_lines, &fp->uf_lines) == FAIL)\n\tgoto failed;\n\n    fp->uf_name_exp = ufunc->uf_name_exp == NULL ? NULL\n\t\t\t\t\t : vim_strsave(ufunc->uf_name_exp);\n    if (ufunc->uf_arg_types != NULL)\n    {\n\tfp->uf_arg_types = ALLOC_MULT(type_T *, fp->uf_args.ga_len);\n\tif (fp->uf_arg_types == NULL)\n\t    goto failed;\n\tmch_memmove(fp->uf_arg_types, ufunc->uf_arg_types,\n\t\t\t\t    sizeof(type_T *) * fp->uf_args.ga_len);\n    }\n    if (ufunc->uf_va_name != NULL)\n    {\n\tfp->uf_va_name = vim_strsave(ufunc->uf_va_name);\n\tif (fp->uf_va_name == NULL)\n\t    goto failed;\n    }\n    fp->uf_ret_type = ufunc->uf_ret_type;\n\n    fp->uf_refcount = 1;\n    STRCPY(fp->uf_name, global);\n    hash_add(&func_hashtab, UF2HIKEY(fp));\n\n    // the referenced dfunc_T is now used one more time\n    link_def_function(fp);\n\n    // Create a partial to store the context of the function where it was\n    // instantiated.  Only needs to be done once.  Do this on the original\n    // function, \"dfunc->df_ufunc\" will point to it.\n    if ((ufunc->uf_flags & FC_CLOSURE) && ufunc->uf_partial == NULL)\n    {\n\tpartial_T   *pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt == NULL)\n\t    goto failed;\n\tif (fill_partial_and_closure(pt, ufunc, ectx) == FAIL)\n\t{\n\t    vim_free(pt);\n\t    goto failed;\n\t}\n\tufunc->uf_partial = pt;\n\t--pt->pt_refcount;  // not actually referenced here\n    }\n\n    return OK;\n\nfailed:\n    func_clear_free(fp, TRUE);\n    return FAIL;\n}\n\nstatic int\tfuncdepth = 0;\n\n/*\n * Increment the function call depth count.\n * Return FAIL when going over 'maxfuncdepth'.\n * Otherwise return OK, must call funcdepth_decrement() later!\n */\n    int\nfuncdepth_increment(void)\n{\n    if (funcdepth >= p_mfd)\n    {\n\temsg(_(e_function_call_depth_is_higher_than_macfuncdepth));\n\treturn FAIL;\n    }\n    ++funcdepth;\n    return OK;\n}\n\n    void\nfuncdepth_decrement(void)\n{\n    --funcdepth;\n}\n\n/*\n * Get the current function call depth.\n */\n    int\nfuncdepth_get(void)\n{\n    return funcdepth;\n}\n\n/*\n * Restore the function call depth.  This is for cases where there is no\n * guarantee funcdepth_decrement() can be called exactly the same number of\n * times as funcdepth_increment().\n */\n    void\nfuncdepth_restore(int depth)\n{\n    funcdepth = depth;\n}\n\n/*\n * Call a user function.\n */\n    static void\ncall_user_func(\n    ufunc_T\t*fp,\t\t// pointer to function\n    int\t\targcount,\t// nr of args\n    typval_T\t*argvars,\t// arguments\n    typval_T\t*rettv,\t\t// return value\n    funcexe_T\t*funcexe,\t// context\n    dict_T\t*selfdict)\t// Dictionary for \"self\"\n{\n    sctx_T\tsave_current_sctx;\n    int\t\tusing_sandbox = FALSE;\n    int\t\tsave_sticky_cmdmod_flags = sticky_cmdmod_flags;\n    funccall_T\t*fc;\n    int\t\tsave_did_emsg;\n    int\t\tdefault_arg_err = FALSE;\n    dictitem_T\t*v;\n    int\t\tfixvar_idx = 0;\t// index in fixvar[]\n    int\t\ti;\n    int\t\tai;\n    int\t\tislambda = FALSE;\n    char_u\tnumbuf[NUMBUFLEN];\n    char_u\t*name;\n    typval_T\t*tv_to_free[MAX_FUNC_ARGS];\n    int\t\ttv_to_free_len = 0;\n#ifdef FEAT_PROFILE\n    profinfo_T\tprofile_info;\n#endif\n    ESTACK_CHECK_DECLARATION\n\n#ifdef FEAT_PROFILE\n    CLEAR_FIELD(profile_info);\n#endif\n\n    // If depth of calling is getting too high, don't execute the function.\n    if (funcdepth_increment() == FAIL)\n    {\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n\treturn;\n    }\n\n    line_breakcheck();\t\t// check for CTRL-C hit\n\n    fc = ALLOC_CLEAR_ONE(funccall_T);\n    if (fc == NULL)\n\treturn;\n    fc->caller = current_funccal;\n    current_funccal = fc;\n    fc->func = fp;\n    fc->rettv = rettv;\n    fc->level = ex_nesting_level;\n    // Check if this function has a breakpoint.\n    fc->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name, (linenr_T)0);\n    fc->dbg_tick = debug_tick;\n    // Set up fields for closure.\n    ga_init2(&fc->fc_funcs, sizeof(ufunc_T *), 1);\n    func_ptr_ref(fp);\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n#ifdef FEAT_PROFILE\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n#endif\n\t// Execute the function, possibly compiling it first.\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES)\n\t    profile_may_start_func(&profile_info, fp, caller);\n#endif\n\tsticky_cmdmod_flags = 0;\n\tcall_def_function(fp, argcount, argvars, funcexe->fe_partial, rettv);\n\tfuncdepth_decrement();\n#ifdef FEAT_PROFILE\n\tif (do_profiling == PROF_YES && (fp->uf_profiling\n\t\t\t\t  || (caller != NULL && caller->uf_profiling)))\n\t    profile_may_end_func(&profile_info, fp, caller);\n#endif\n\tcurrent_funccal = fc->caller;\n\tfree_funccal(fc);\n\tsticky_cmdmod_flags = save_sticky_cmdmod_flags;\n\treturn;\n    }\n\n    islambda = fp->uf_flags & FC_LAMBDA;\n\n    /*\n     * Note about using fc->fixvar[]: This is an array of FIXVAR_CNT variables\n     * with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free\n     * each argument variable and saves a lot of time.\n     */\n    /*\n     * Init l: variables.\n     */\n    init_var_dict(&fc->l_vars, &fc->l_vars_var, VAR_DEF_SCOPE);\n    if (selfdict != NULL)\n    {\n\t// Set l:self to \"selfdict\".  Use \"name\" to avoid a warning from\n\t// some compiler that checks the destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"self\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_DICT;\n\tv->di_tv.v_lock = 0;\n\tv->di_tv.vval.v_dict = selfdict;\n\t++selfdict->dv_refcount;\n    }\n\n    /*\n     * Init a: variables, unless none found (in lambda).\n     * Set a:0 to \"argcount\" less number of named arguments, if >= 0.\n     * Set a:000 to a list with room for the \"...\" arguments.\n     */\n    init_var_dict(&fc->l_avars, &fc->l_avars_var, VAR_SCOPE);\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"0\",\n\t\t\t\t(varnumber_T)(argcount >= fp->uf_args.ga_len\n\t\t\t\t    ? argcount - fp->uf_args.ga_len : 0));\n    fc->l_avars.dv_lock = VAR_FIXED;\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\t// Use \"name\" to avoid a warning from some compiler that checks the\n\t// destination size.\n\tv = &fc->fixvar[fixvar_idx++].var;\n\tname = v->di_key;\n\tSTRCPY(name, \"000\");\n\tv->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\thash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\tv->di_tv.v_type = VAR_LIST;\n\tv->di_tv.v_lock = VAR_FIXED;\n\tv->di_tv.vval.v_list = &fc->l_varlist;\n    }\n    CLEAR_FIELD(fc->l_varlist);\n    fc->l_varlist.lv_refcount = DO_NOT_FREE_CNT;\n    fc->l_varlist.lv_lock = VAR_FIXED;\n\n    /*\n     * Set a:firstline to \"firstline\" and a:lastline to \"lastline\".\n     * Set a:name to named arguments.\n     * Set a:N to the \"...\" arguments.\n     * Skipped when no a: variables used (in lambda).\n     */\n    if ((fp->uf_flags & FC_NOARGS) == 0)\n    {\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"firstline\",\n\t\t\t\t\t   (varnumber_T)funcexe->fe_firstline);\n\tadd_nr_var(&fc->l_avars, &fc->fixvar[fixvar_idx++].var, \"lastline\",\n\t\t\t\t\t    (varnumber_T)funcexe->fe_lastline);\n    }\n    for (i = 0; i < argcount || i < fp->uf_args.ga_len; ++i)\n    {\n\tint\t    addlocal = FALSE;\n\ttypval_T    def_rettv;\n\tint\t    isdefault = FALSE;\n\n\tai = i - fp->uf_args.ga_len;\n\tif (ai < 0)\n\t{\n\t    // named argument a:name\n\t    name = FUNCARG(fp, i);\n\t    if (islambda)\n\t\taddlocal = TRUE;\n\n\t    // evaluate named argument default expression\n\t    isdefault = ai + fp->uf_def_args.ga_len >= 0\n\t\t       && (i >= argcount || (argvars[i].v_type == VAR_SPECIAL\n\t\t\t\t   && argvars[i].vval.v_number == VVAL_NONE));\n\t    if (isdefault)\n\t    {\n\t\tchar_u\t    *default_expr = NULL;\n\n\t\tdef_rettv.v_type = VAR_NUMBER;\n\t\tdef_rettv.vval.v_number = -1;\n\n\t\tdefault_expr = ((char_u **)(fp->uf_def_args.ga_data))\n\t\t\t\t\t\t [ai + fp->uf_def_args.ga_len];\n\t\tif (eval1(&default_expr, &def_rettv, &EVALARG_EVALUATE) == FAIL)\n\t\t{\n\t\t    default_arg_err = 1;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    if ((fp->uf_flags & FC_NOARGS) != 0)\n\t\t// Bail out if no a: arguments used (in lambda).\n\t\tbreak;\n\n\t    // \"...\" argument a:1, a:2, etc.\n\t    sprintf((char *)numbuf, \"%d\", ai + 1);\n\t    name = numbuf;\n\t}\n\tif (fixvar_idx < FIXVAR_CNT && STRLEN(name) <= VAR_SHORT_LEN)\n\t{\n\t    v = &fc->fixvar[fixvar_idx++].var;\n\t    v->di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;\n\t    STRCPY(v->di_key, name);\n\t}\n\telse\n\t{\n\t    v = dictitem_alloc(name);\n\t    if (v == NULL)\n\t\tbreak;\n\t    v->di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;\n\t}\n\n\t// Note: the values are copied directly to avoid alloc/free.\n\t// \"argvars\" must have VAR_FIXED for v_lock.\n\tv->di_tv = isdefault ? def_rettv : argvars[i];\n\tv->di_tv.v_lock = VAR_FIXED;\n\n\tif (isdefault)\n\t    // Need to free this later, no matter where it's stored.\n\t    tv_to_free[tv_to_free_len++] = &v->di_tv;\n\n\tif (addlocal)\n\t{\n\t    // Named arguments should be accessed without the \"a:\" prefix in\n\t    // lambda expressions.  Add to the l: dict.\n\t    copy_tv(&v->di_tv, &v->di_tv);\n\t    hash_add(&fc->l_vars.dv_hashtab, DI2HIKEY(v));\n\t}\n\telse\n\t    hash_add(&fc->l_avars.dv_hashtab, DI2HIKEY(v));\n\n\tif (ai >= 0 && ai < MAX_FUNC_ARGS)\n\t{\n\t    listitem_T *li = &fc->l_listitems[ai];\n\n\t    li->li_tv = argvars[i];\n\t    li->li_tv.v_lock = VAR_FIXED;\n\t    list_append(&fc->l_varlist, li);\n\t}\n    }\n\n    // Don't redraw while executing the function.\n    ++RedrawingDisabled;\n\n    if (fp->uf_flags & FC_SANDBOX)\n    {\n\tusing_sandbox = TRUE;\n\t++sandbox;\n    }\n\n    estack_push_ufunc(fp, 1);\n    ESTACK_CHECK_SETUP\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"calling %s\"), SOURCING_NAME);\n\tif (p_verbose >= 14)\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    msg_puts(\"(\");\n\t    for (i = 0; i < argcount; ++i)\n\t    {\n\t\tif (i > 0)\n\t\t    msg_puts(\", \");\n\t\tif (argvars[i].v_type == VAR_NUMBER)\n\t\t    msg_outnum((long)argvars[i].vval.v_number);\n\t\telse\n\t\t{\n\t\t    // Do not want errors such as E724 here.\n\t\t    ++emsg_off;\n\t\t    s = tv2string(&argvars[i], &tofree, numbuf2, 0);\n\t\t    --emsg_off;\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t\t{\n\t\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t\t    s = buf;\n\t\t\t}\n\t\t\tmsg_puts((char *)s);\n\t\t\tvim_free(tofree);\n\t\t    }\n\t\t}\n\t    }\n\t    msg_puts(\")\");\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tprofile_may_start_func(&profile_info, fp,\n\t\t\t\t fc->caller == NULL ? NULL : fc->caller->func);\n#endif\n\n    // \"legacy\" does not apply to commands in the function\n    sticky_cmdmod_flags = 0;\n\n    save_current_sctx = current_sctx;\n    current_sctx = fp->uf_script_ctx;\n    save_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    if (default_arg_err && (fp->uf_flags & FC_ABORT))\n\tdid_emsg = TRUE;\n    else if (islambda)\n    {\n\tchar_u *p = *(char_u **)fp->uf_lines.ga_data + 7;\n\n\t// A Lambda always has the command \"return {expr}\".  It is much faster\n\t// to evaluate {expr} directly.\n\t++ex_nesting_level;\n\t(void)eval1(&p, rettv, &EVALARG_EVALUATE);\n\t--ex_nesting_level;\n    }\n    else\n\t// call do_cmdline() to execute the lines\n\tdo_cmdline(NULL, get_func_line, (void *)fc,\n\t\t\t\t     DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);\n\n    --RedrawingDisabled;\n\n    // when the function was aborted because of an error, return -1\n    if ((did_emsg && (fp->uf_flags & FC_ABORT)) || rettv->v_type == VAR_UNKNOWN)\n    {\n\tclear_tv(rettv);\n\trettv->v_type = VAR_NUMBER;\n\trettv->vval.v_number = -1;\n    }\n\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n    {\n\tufunc_T *caller = fc->caller == NULL ? NULL : fc->caller->func;\n\n\tif (fp->uf_profiling || (caller != NULL && caller->uf_profiling))\n\t    profile_may_end_func(&profile_info, fp, caller);\n    }\n#endif\n\n    // when being verbose, mention the return value\n    if (p_verbose >= 12)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tif (aborting())\n\t    smsg(_(\"%s aborted\"), SOURCING_NAME);\n\telse if (fc->rettv->v_type == VAR_NUMBER)\n\t    smsg(_(\"%s returning #%ld\"), SOURCING_NAME,\n\t\t\t\t\t       (long)fc->rettv->vval.v_number);\n\telse\n\t{\n\t    char_u\tbuf[MSG_BUF_LEN];\n\t    char_u\tnumbuf2[NUMBUFLEN];\n\t    char_u\t*tofree;\n\t    char_u\t*s;\n\n\t    // The value may be very long.  Skip the middle part, so that we\n\t    // have some idea how it starts and ends. smsg() would always\n\t    // truncate it at the end. Don't want errors such as E724 here.\n\t    ++emsg_off;\n\t    s = tv2string(fc->rettv, &tofree, numbuf2, 0);\n\t    --emsg_off;\n\t    if (s != NULL)\n\t    {\n\t\tif (vim_strsize(s) > MSG_BUF_CLEN)\n\t\t{\n\t\t    trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);\n\t\t    s = buf;\n\t\t}\n\t\tsmsg(_(\"%s returning %s\"), SOURCING_NAME, s);\n\t\tvim_free(tofree);\n\t    }\n\t}\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    ESTACK_CHECK_NOW\n    estack_pop();\n    current_sctx = save_current_sctx;\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tscript_prof_restore(&profile_info.pi_wait_start);\n#endif\n    if (using_sandbox)\n\t--sandbox;\n    sticky_cmdmod_flags = save_sticky_cmdmod_flags;\n\n    if (p_verbose >= 12 && SOURCING_NAME != NULL)\n    {\n\t++no_wait_return;\n\tverbose_enter_scroll();\n\n\tsmsg(_(\"continuing in %s\"), SOURCING_NAME);\n\tmsg_puts(\"\\n\");   // don't overwrite this either\n\n\tverbose_leave_scroll();\n\t--no_wait_return;\n    }\n\n    did_emsg |= save_did_emsg;\n    funcdepth_decrement();\n    for (i = 0; i < tv_to_free_len; ++i)\n\tclear_tv(tv_to_free[i]);\n    cleanup_function_call(fc);\n}\n\n/*\n * Check the argument count for user function \"fp\".\n * Return FCERR_UNKNOWN if OK, FCERR_TOOFEW or FCERR_TOOMANY otherwise.\n */\n    int\ncheck_user_func_argcount(ufunc_T *fp, int argcount)\n{\n    int regular_args = fp->uf_args.ga_len;\n\n    if (argcount < regular_args - fp->uf_def_args.ga_len)\n\treturn FCERR_TOOFEW;\n    else if (!has_varargs(fp) && argcount > regular_args)\n\treturn FCERR_TOOMANY;\n    return FCERR_UNKNOWN;\n}\n\n/*\n * Call a user function after checking the arguments.\n */\n    int\ncall_user_func_check(\n\tufunc_T\t    *fp,\n\tint\t    argcount,\n\ttypval_T    *argvars,\n\ttypval_T    *rettv,\n\tfuncexe_T   *funcexe,\n\tdict_T\t    *selfdict)\n{\n    int error;\n\n#ifdef FEAT_LUA\n    if (fp->uf_flags & FC_CFUNC)\n    {\n\tcfunc_T cb = fp->uf_cb;\n\n\treturn (*cb)(argcount, argvars, rettv, fp->uf_cb_state);\n    }\n#endif\n\n    if (fp->uf_flags & FC_RANGE && funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = TRUE;\n    error = check_user_func_argcount(fp, argcount);\n    if (error != FCERR_UNKNOWN)\n\treturn error;\n    if ((fp->uf_flags & FC_DICT) && selfdict == NULL)\n\terror = FCERR_DICT;\n    else\n    {\n\tint\t\tdid_save_redo = FALSE;\n\tsave_redo_T\tsave_redo;\n\n\t/*\n\t * Call the user function.\n\t * Save and restore search patterns, script variables and\n\t * redo buffer.\n\t */\n\tsave_search_patterns();\n\tif (!ins_compl_active())\n\t{\n\t    saveRedobuff(&save_redo);\n\t    did_save_redo = TRUE;\n\t}\n\t++fp->uf_calls;\n\tcall_user_func(fp, argcount, argvars, rettv, funcexe,\n\t\t\t\t   (fp->uf_flags & FC_DICT) ? selfdict : NULL);\n\tif (--fp->uf_calls <= 0 && fp->uf_refcount <= 0)\n\t    // Function was unreferenced while being used, free it now.\n\t    func_clear_free(fp, FALSE);\n\tif (did_save_redo)\n\t    restoreRedobuff(&save_redo);\n\trestore_search_patterns();\n\terror = FCERR_NONE;\n    }\n    return error;\n}\n\nstatic funccal_entry_T *funccal_stack = NULL;\n\n/*\n * Save the current function call pointer, and set it to NULL.\n * Used when executing autocommands and for \":source\".\n */\n    void\nsave_funccal(funccal_entry_T *entry)\n{\n    entry->top_funccal = current_funccal;\n    entry->next = funccal_stack;\n    funccal_stack = entry;\n    current_funccal = NULL;\n}\n\n    void\nrestore_funccal(void)\n{\n    if (funccal_stack == NULL)\n\tiemsg(\"INTERNAL: restore_funccal()\");\n    else\n    {\n\tcurrent_funccal = funccal_stack->top_funccal;\n\tfunccal_stack = funccal_stack->next;\n    }\n}\n\n    funccall_T *\nget_current_funccal(void)\n{\n    return current_funccal;\n}\n\n/*\n * Return TRUE when currently at the script level:\n * - not in a function\n * - not executing an autocommand\n * Note that when an autocommand sources a script the result is FALSE;\n */\n    int\nat_script_level(void)\n{\n    return current_funccal == NULL && autocmd_match == NULL;\n}\n\n/*\n * Mark all functions of script \"sid\" as deleted.\n */\n    void\ndelete_script_functions(int sid)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\ttodo = 1;\n    char_u\tbuf[30];\n    size_t\tlen;\n\n    buf[0] = K_SPECIAL;\n    buf[1] = KS_EXTRA;\n    buf[2] = (int)KE_SNR;\n    sprintf((char *)buf + 3, \"%d_\", sid);\n    len = STRLEN(buf);\n\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\tfp = HI2UF(hi);\n\t\tif (STRNCMP(fp->uf_name, buf, len) == 0)\n\t\t{\n\t\t    int changed = func_hashtab.ht_changed;\n\n\t\t    fp->uf_flags |= FC_DEAD;\n\n\t\t    if (fp->uf_calls > 0)\n\t\t    {\n\t\t\t// Function is executing, don't free it but do remove\n\t\t\t// it from the hashtable.\n\t\t\tif (func_remove(fp))\n\t\t\t    fp->uf_refcount--;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tfunc_clear(fp, TRUE);\n\t\t\t// When clearing a function another function can be\n\t\t\t// cleared as a side effect.  When that happens start\n\t\t\t// over.\n\t\t\tif (changed != func_hashtab.ht_changed)\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_all_functions(void)\n{\n    hashitem_T\t*hi;\n    ufunc_T\t*fp;\n    long_u\tskipped = 0;\n    long_u\ttodo = 1;\n    int\t\tchanged;\n\n    // Clean up the current_funccal chain and the funccal stack.\n    while (current_funccal != NULL)\n    {\n\tclear_tv(current_funccal->rettv);\n\tcleanup_function_call(current_funccal);\n\tif (current_funccal == NULL && funccal_stack != NULL)\n\t    restore_funccal();\n    }\n\n    // First clear what the functions contain.  Since this may lower the\n    // reference count of a function, it may also free a function and change\n    // the hash table. Restart if that happens.\n    while (todo > 0)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t// clear the def function index now\n\t\tfp = HI2UF(hi);\n\t\tfp->uf_flags &= ~FC_DEAD;\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    changed = func_hashtab.ht_changed;\n\t\t    func_clear(fp, TRUE);\n\t\t    if (changed != func_hashtab.ht_changed)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t--todo;\n\t    }\n    }\n\n    // Now actually free the functions.  Need to start all over every time,\n    // because func_free() may change the hash table.\n    skipped = 0;\n    while (func_hashtab.ht_used > skipped)\n    {\n\ttodo = func_hashtab.ht_used;\n\tfor (hi = func_hashtab.ht_array; todo > 0; ++hi)\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\t// Only free functions that are not refcounted, those are\n\t\t// supposed to be freed when no longer referenced.\n\t\tfp = HI2UF(hi);\n\t\tif (func_name_refcount(fp->uf_name))\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    if (func_free(fp, FALSE) == OK)\n\t\t    {\n\t\t\tskipped = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    // did not actually free it\n\t\t    ++skipped;\n\t\t}\n\t    }\n    }\n    if (skipped == 0)\n\thash_clear(&func_hashtab);\n\n    free_def_functions();\n}\n#endif\n\n/*\n * Return TRUE if \"name\" looks like a builtin function name: starts with a\n * lower case letter, doesn't contain AUTOLOAD_CHAR or ':', no \".\" after the\n * name.\n * \"len\" is the length of \"name\", or -1 for NUL terminated.\n */\n    int\nbuiltin_function(char_u *name, int len)\n{\n    int i;\n\n    if (!ASCII_ISLOWER(name[0]) || name[1] == ':')\n\treturn FALSE;\n    for (i = 0; name[i] != NUL && (len < 0 || i < len); ++i)\n    {\n\tif (name[i] == AUTOLOAD_CHAR)\n\t    return FALSE;\n\tif (!eval_isnamec(name[i]))\n\t{\n\t    // \"name.something\" is not a builtin function\n\t    if (name[i] == '.')\n\t\treturn FALSE;\n\t    break;\n\t}\n    }\n    return TRUE;\n}\n\n    int\nfunc_call(\n    char_u\t*name,\n    typval_T\t*args,\n    partial_T\t*partial,\n    dict_T\t*selfdict,\n    typval_T\t*rettv)\n{\n    list_T\t*l = args->vval.v_list;\n    listitem_T\t*item;\n    typval_T\targv[MAX_FUNC_ARGS + 1];\n    int\t\targc = 0;\n    int\t\tr = 0;\n\n    CHECK_LIST_MATERIALIZE(l);\n    FOR_ALL_LIST_ITEMS(l, item)\n    {\n\tif (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial->pt_argc))\n\t{\n\t    emsg(_(e_too_many_arguments));\n\t    break;\n\t}\n\t// Make a copy of each argument.  This is needed to be able to set\n\t// v_lock to VAR_FIXED in the copy without changing the original list.\n\tcopy_tv(&item->li_tv, &argv[argc++]);\n    }\n\n    if (item == NULL)\n    {\n\tfuncexe_T funcexe;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = curwin->w_cursor.lnum;\n\tfuncexe.fe_lastline = curwin->w_cursor.lnum;\n\tfuncexe.fe_evaluate = TRUE;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = selfdict;\n\tr = call_func(name, -1, rettv, argc, argv, &funcexe);\n    }\n\n    // Free the arguments.\n    while (argc > 0)\n\tclear_tv(&argv[--argc]);\n\n    return r;\n}\n\nstatic int callback_depth = 0;\n\n    int\nget_callback_depth(void)\n{\n    return callback_depth;\n}\n\n/*\n * Invoke call_func() with a callback.\n * Returns FAIL if the callback could not be called.\n */\n    int\ncall_callback(\n    callback_T\t*callback,\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    funcexe_T\tfuncexe;\n    int\t\tret;\n\n    if (callback->cb_name == NULL || *callback->cb_name == NUL)\n\treturn FAIL;\n    CLEAR_FIELD(funcexe);\n    funcexe.fe_evaluate = TRUE;\n    funcexe.fe_partial = callback->cb_partial;\n    ++callback_depth;\n    ret = call_func(callback->cb_name, len, rettv, argcount, argvars, &funcexe);\n    --callback_depth;\n\n    // When a :def function was called that uses :try an error would be turned\n    // into an exception.  Need to give the error here.\n    if (need_rethrow && current_exception != NULL && trylevel == 0)\n    {\n\tneed_rethrow = FALSE;\n\thandle_did_throw();\n    }\n\n    return ret;\n}\n\n/*\n * call the 'callback' function and return the result as a number.\n * Returns -2 when calling the function fails.  Uses argv[0] to argv[argc - 1]\n * for the function arguments. argv[argc] should have type VAR_UNKNOWN.\n */\n    varnumber_T\ncall_callback_retnr(\n    callback_T\t*callback,\n    int\t\targcount,\t// number of \"argvars\"\n    typval_T\t*argvars)\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n{\n    typval_T\trettv;\n    varnumber_T\tretval;\n\n    if (call_callback(callback, -1, &rettv, argcount, argvars) == FAIL)\n\treturn -2;\n\n    retval = tv_get_number_chk(&rettv, NULL);\n    clear_tv(&rettv);\n    return retval;\n}\n\n/*\n * Give an error message for the result of a function.\n * Nothing if \"error\" is FCERR_NONE.\n */\n    void\nuser_func_error(int error, char_u *name, funcexe_T *funcexe)\n{\n    switch (error)\n    {\n\tcase FCERR_UNKNOWN:\n\t\tif (funcexe->fe_found_var)\n\t\t    emsg_funcname(e_not_callable_type_str, name);\n\t\telse\n\t\t    emsg_funcname(e_unknown_function_str, name);\n\t\tbreak;\n\tcase FCERR_NOTMETHOD:\n\t\temsg_funcname(e_cannot_use_function_as_method_str, name);\n\t\tbreak;\n\tcase FCERR_DELETED:\n\t\temsg_funcname(e_function_was_deleted_str, name);\n\t\tbreak;\n\tcase FCERR_TOOMANY:\n\t\temsg_funcname(e_too_many_arguments_for_function_str, name);\n\t\tbreak;\n\tcase FCERR_TOOFEW:\n\t\temsg_funcname(e_not_enough_arguments_for_function_str, name);\n\t\tbreak;\n\tcase FCERR_SCRIPT:\n\t\temsg_funcname(e_using_sid_not_in_script_context_str, name);\n\t\tbreak;\n\tcase FCERR_DICT:\n\t\temsg_funcname(e_calling_dict_function_without_dictionary_str,\n\t\t\t\t\t\t\t\t\t name);\n\t\tbreak;\n    }\n}\n\n/*\n * Call a function with its resolved parameters\n *\n * Return FAIL when the function can't be called,  OK otherwise.\n * Also returns OK when an error was encountered while executing the function.\n */\n    int\ncall_func(\n    char_u\t*funcname,\t// name of the function\n    int\t\tlen,\t\t// length of \"name\" or -1 to use strlen()\n    typval_T\t*rettv,\t\t// return value goes here\n    int\t\targcount_in,\t// number of \"argvars\"\n    typval_T\t*argvars_in,\t// vars for arguments, must have \"argcount\"\n\t\t\t\t// PLUS ONE elements!\n    funcexe_T\t*funcexe)\t// more arguments\n{\n    int\t\tret = FAIL;\n    int\t\terror = FCERR_NONE;\n    int\t\ti;\n    ufunc_T\t*fp = NULL;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname = NULL;\n    char_u\t*name = NULL;\n    int\t\targcount = argcount_in;\n    typval_T\t*argvars = argvars_in;\n    dict_T\t*selfdict = funcexe->fe_selfdict;\n    typval_T\targv[MAX_FUNC_ARGS + 1]; // used when \"partial\" or\n\t\t\t\t\t // \"funcexe->fe_basetv\" is not NULL\n    int\t\targv_clear = 0;\n    int\t\targv_base = 0;\n    partial_T\t*partial = funcexe->fe_partial;\n    type_T\tcheck_type;\n    type_T\t*check_type_args[MAX_FUNC_ARGS];\n\n    // Initialize rettv so that it is safe for caller to invoke clear_tv(rettv)\n    // even when call_func() returns FAIL.\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (partial != NULL)\n\tfp = partial->pt_func;\n    if (fp == NULL)\n    {\n\t// Make a copy of the name, if it comes from a funcref variable it\n\t// could be changed or deleted in the called function.\n\tname = len > 0 ? vim_strnsave(funcname, len) : vim_strsave(funcname);\n\tif (name == NULL)\n\t    return ret;\n\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n    }\n\n    if (funcexe->fe_doesrange != NULL)\n\t*funcexe->fe_doesrange = FALSE;\n\n    if (partial != NULL)\n    {\n\t// When the function has a partial with a dict and there is a dict\n\t// argument, use the dict argument.  That is backwards compatible.\n\t// When the dict was bound explicitly use the one from the partial.\n\tif (partial->pt_dict != NULL && (selfdict == NULL || !partial->pt_auto))\n\t    selfdict = partial->pt_dict;\n\tif (error == FCERR_NONE && partial->pt_argc > 0)\n\t{\n\t    for (argv_clear = 0; argv_clear < partial->pt_argc; ++argv_clear)\n\t    {\n\t\tif (argv_clear + argcount_in >= MAX_FUNC_ARGS)\n\t\t{\n\t\t    error = FCERR_TOOMANY;\n\t\t    goto theend;\n\t\t}\n\t\tcopy_tv(&partial->pt_argv[argv_clear], &argv[argv_clear]);\n\t    }\n\t    for (i = 0; i < argcount_in; ++i)\n\t\targv[i + argv_clear] = argvars_in[i];\n\t    argvars = argv;\n\t    argcount = partial->pt_argc + argcount_in;\n\n\t    if (funcexe->fe_check_type != NULL\n\t\t\t\t  && funcexe->fe_check_type->tt_argcount != -1)\n\t    {\n\t\t// Now funcexe->fe_check_type is missing the added arguments,\n\t\t// make a copy of the type with the correction.\n\t\tcheck_type = *funcexe->fe_check_type;\n\t\tfuncexe->fe_check_type = &check_type;\n\t\tcheck_type.tt_args = check_type_args;\n\t\tCLEAR_FIELD(check_type_args);\n\t\tfor (i = 0; i < check_type.tt_argcount; ++i)\n\t\t    check_type_args[i + partial->pt_argc] =\n\t\t\t\t\t\t\t check_type.tt_args[i];\n\t\tcheck_type.tt_argcount += partial->pt_argc;\n\t\tcheck_type.tt_min_argcount += partial->pt_argc;\n\t    }\n\t}\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_check_type != NULL\n\t\t\t\t\t\t       && funcexe->fe_evaluate)\n    {\n\t// Check that the argument types are OK for the types of the funcref.\n\tif (check_argument_types(funcexe->fe_check_type,\n\t\t\t\t\t argvars, argcount, funcexe->fe_basetv,\n\t\t\t\t     (name != NULL) ? name : funcname) == FAIL)\n\t    error = FCERR_OTHER;\n    }\n\n    if (error == FCERR_NONE && funcexe->fe_evaluate)\n    {\n\tchar_u *rfname = fname;\n\tint\tis_global = FALSE;\n\n\t// Skip \"g:\" before a function name.\n\tif (fp == NULL && fname[0] == 'g' && fname[1] == ':')\n\t{\n\t    is_global = TRUE;\n\t    rfname = fname + 2;\n\t}\n\n\trettv->v_type = VAR_NUMBER;\t// default rettv is number zero\n\trettv->vval.v_number = 0;\n\terror = FCERR_UNKNOWN;\n\n\tif (fp != NULL || !builtin_function(rfname, -1))\n\t{\n\t    /*\n\t     * User defined function.\n\t     */\n\t    if (fp == NULL)\n\t    {\n\t\tfp = find_func(rfname, is_global);\n\t\tif (fp != NULL && !is_global && in_vim9script()\n\t\t\t\t\t\t && func_requires_g_prefix(fp))\n\t\t    // In Vim9 script g: is required to find a global\n\t\t    // non-autoload function.\n\t\t    fp = NULL;\n\t    }\n\n\t    // Trigger FuncUndefined event, may load the function.\n\t    if (fp == NULL\n\t\t    && apply_autocmds(EVENT_FUNCUNDEFINED,\n\t\t\t\t\t\t    rfname, rfname, TRUE, NULL)\n\t\t    && !aborting())\n\t    {\n\t\t// executed an autocommand, search for the function again\n\t\tfp = find_func(rfname, is_global);\n\t    }\n\t    // Try loading a package.\n\t    if (fp == NULL && script_autoload(rfname, TRUE) && !aborting())\n\t    {\n\t\t// loaded a package, search for the function again\n\t\tfp = find_func(rfname, is_global);\n\t    }\n\t    if (fp == NULL)\n\t    {\n\t\tchar_u *p = untrans_function_name(rfname);\n\n\t\t// If using Vim9 script try not local to the script.\n\t\t// Don't do this if the name starts with \"s:\".\n\t\tif (p != NULL && (funcname[0] != 's' || funcname[1] != ':'))\n\t\t    fp = find_func(p, is_global);\n\t    }\n\n\t    if (fp != NULL && (fp->uf_flags & FC_DELETED))\n\t\terror = FCERR_DELETED;\n\t    else if (fp != NULL)\n\t    {\n\t\tif (funcexe->fe_argv_func != NULL)\n\t\t    // postponed filling in the arguments, do it now\n\t\t    argcount = funcexe->fe_argv_func(argcount, argvars,\n\t\t\t\t\t       argv_clear, fp->uf_args.ga_len);\n\n\t\tif (funcexe->fe_basetv != NULL)\n\t\t{\n\t\t    // Method call: base->Method()\n\t\t    mch_memmove(&argv[1], argvars, sizeof(typval_T) * argcount);\n\t\t    argv[0] = *funcexe->fe_basetv;\n\t\t    argcount++;\n\t\t    argvars = argv;\n\t\t    argv_base = 1;\n\t\t}\n\n\t\terror = call_user_func_check(fp, argcount, argvars, rettv,\n\t\t\t\t\t\t\t    funcexe, selfdict);\n\t    }\n\t}\n\telse if (funcexe->fe_basetv != NULL)\n\t{\n\t    /*\n\t     * expr->method(): Find the method name in the table, call its\n\t     * implementation with the base as one of the arguments.\n\t     */\n\t    error = call_internal_method(fname, argcount, argvars, rettv,\n\t\t\t\t\t\t\t   funcexe->fe_basetv);\n\t}\n\telse\n\t{\n\t    /*\n\t     * Find the function name in the table, call its implementation.\n\t     */\n\t    error = call_internal_func(fname, argcount, argvars, rettv);\n\t}\n\n\t/*\n\t * The function call (or \"FuncUndefined\" autocommand sequence) might\n\t * have been aborted by an error, an interrupt, or an explicitly thrown\n\t * exception that has not been caught so far.  This situation can be\n\t * tested for by calling aborting().  For an error in an internal\n\t * function or for the \"E132\" error in call_user_func(), however, the\n\t * throw point at which the \"force_abort\" flag (temporarily reset by\n\t * emsg()) is normally updated has not been reached yet. We need to\n\t * update that flag first to make aborting() reliable.\n\t */\n\tupdate_force_abort();\n    }\n    if (error == FCERR_NONE)\n\tret = OK;\n\ntheend:\n    /*\n     * Report an error unless the argument evaluation or function call has been\n     * cancelled due to an aborting error, an interrupt, or an exception.\n     */\n    if (!aborting())\n\tuser_func_error(error, (name != NULL) ? name : funcname, funcexe);\n\n    // clear the copies made from the partial\n    while (argv_clear > 0)\n\tclear_tv(&argv[--argv_clear + argv_base]);\n\n    vim_free(tofree);\n    vim_free(name);\n\n    return ret;\n}\n\n    char_u *\nprintable_func_name(ufunc_T *fp)\n{\n    return fp->uf_name_exp != NULL ? fp->uf_name_exp : fp->uf_name;\n}\n\n/*\n * List the head of the function: \"function name(arg1, arg2)\".\n */\n    static void\nlist_func_head(ufunc_T *fp, int indent)\n{\n    int\t\tj;\n\n    msg_start();\n    if (indent)\n\tmsg_puts(\"   \");\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n\tmsg_puts(\"def \");\n    else\n\tmsg_puts(\"function \");\n    msg_puts((char *)printable_func_name(fp));\n    msg_putchar('(');\n    for (j = 0; j < fp->uf_args.ga_len; ++j)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts((char *)FUNCARG(fp, j));\n\tif (fp->uf_arg_types != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_arg_types[j], &tofree));\n\t    vim_free(tofree);\n\t}\n\tif (j >= fp->uf_args.ga_len - fp->uf_def_args.ga_len)\n\t{\n\t    msg_puts(\" = \");\n\t    msg_puts(((char **)(fp->uf_def_args.ga_data))\n\t\t       [j - fp->uf_args.ga_len + fp->uf_def_args.ga_len]);\n\t}\n    }\n    if (fp->uf_varargs)\n    {\n\tif (j)\n\t    msg_puts(\", \");\n\tmsg_puts(\"...\");\n    }\n    if (fp->uf_va_name != NULL)\n    {\n\tif (!fp->uf_varargs)\n\t{\n\t    if (j)\n\t\tmsg_puts(\", \");\n\t    msg_puts(\"...\");\n\t}\n\tmsg_puts((char *)fp->uf_va_name);\n\tif (fp->uf_va_type != NULL)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_va_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    msg_putchar(')');\n\n    if (fp->uf_def_status != UF_NOT_COMPILED)\n    {\n\tif (fp->uf_ret_type != &t_void)\n\t{\n\t    char *tofree;\n\n\t    msg_puts(\": \");\n\t    msg_puts(type_name(fp->uf_ret_type, &tofree));\n\t    vim_free(tofree);\n\t}\n    }\n    else if (fp->uf_flags & FC_ABORT)\n\tmsg_puts(\" abort\");\n    if (fp->uf_flags & FC_RANGE)\n\tmsg_puts(\" range\");\n    if (fp->uf_flags & FC_DICT)\n\tmsg_puts(\" dict\");\n    if (fp->uf_flags & FC_CLOSURE)\n\tmsg_puts(\" closure\");\n    msg_clr_eos();\n    if (p_verbose > 0)\n\tlast_set_msg(fp->uf_script_ctx);\n}\n\n/*\n * Get a function name, translating \"<SID>\" and \"<SNR>\".\n * Also handles a Funcref in a List or Dictionary.\n * Returns the function name in allocated memory, or NULL for failure.\n * Set \"*is_global\" to TRUE when the function must be global, unless\n * \"is_global\" is NULL.\n * flags:\n * TFN_INT:\t    internal function name OK\n * TFN_QUIET:\t    be quiet\n * TFN_NO_AUTOLOAD: do not use script autoloading\n * TFN_NO_DEREF:    do not dereference a Funcref\n * Advances \"pp\" to just after the function name (if no error).\n */\n    char_u *\ntrans_function_name(\n    char_u\t**pp,\n    int\t\t*is_global,\n    int\t\tskip,\t\t// only find the end, don't evaluate\n    int\t\tflags,\n    funcdict_T\t*fdp,\t\t// return: info about dictionary used\n    partial_T\t**partial,\t// return: partial of a FuncRef\n    type_T\t**type)\t\t// return: type of funcref if not NULL\n{\n    char_u\t*name = NULL;\n    char_u\t*start;\n    char_u\t*end;\n    int\t\tlead;\n    char_u\tsid_buf[20];\n    int\t\tlen;\n    int\t\textra = 0;\n    int\t\tprefix_g = FALSE;\n    lval_T\tlv;\n    int\t\tvim9script = in_vim9script();\n    int\t\tvim9_local;\n\n    if (fdp != NULL)\n\tCLEAR_POINTER(fdp);\n    start = *pp;\n\n    // Check for hard coded <SNR>: already translated function ID (from a user\n    // command).\n    if ((*pp)[0] == K_SPECIAL && (*pp)[1] == KS_EXTRA\n\t\t\t\t\t\t   && (*pp)[2] == (int)KE_SNR)\n    {\n\t*pp += 3;\n\tlen = get_id_len(pp) + 3;\n\treturn vim_strnsave(start, len);\n    }\n\n    // A name starting with \"<SID>\" or \"<SNR>\" is local to a script.  But\n    // don't skip over \"s:\", get_lval() needs it for \"s:dict.func\".\n    lead = eval_fname_script(start);\n    if (lead > 2)\n\tstart += lead;\n\n    // Note that TFN_ flags use the same values as GLV_ flags.\n    end = get_lval(start, NULL, &lv, FALSE, skip, flags | GLV_READ_ONLY,\n\t\t\t\t\t      lead > 2 ? 0 : FNE_CHECK_START);\n    if (end == start || (vim9script && end != NULL\n\t\t\t\t   && end[-1] == AUTOLOAD_CHAR && *end == '('))\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name_required));\n\tgoto theend;\n    }\n    if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range)))\n    {\n\t/*\n\t * Report an invalid expression in braces, unless the expression\n\t * evaluation has been cancelled due to an aborting error, an\n\t * interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t{\n\t    if (end != NULL)\n\t\tsemsg(_(e_invalid_argument_str), start);\n\t}\n\telse\n\t    *pp = find_name_end(start, NULL, NULL, FNE_INCL_BR);\n\tgoto theend;\n    }\n\n    if (lv.ll_tv != NULL)\n    {\n\tif (fdp != NULL)\n\t{\n\t    fdp->fd_dict = lv.ll_dict;\n\t    fdp->fd_newkey = lv.ll_newkey;\n\t    lv.ll_newkey = NULL;\n\t    fdp->fd_di = lv.ll_di;\n\t}\n\tif (lv.ll_tv->v_type == VAR_FUNC && lv.ll_tv->vval.v_string != NULL)\n\t{\n\t    name = vim_strsave(lv.ll_tv->vval.v_string);\n\t    *pp = end;\n\t}\n\telse if (lv.ll_tv->v_type == VAR_PARTIAL\n\t\t\t\t\t  && lv.ll_tv->vval.v_partial != NULL)\n\t{\n\t    name = vim_strsave(partial_name(lv.ll_tv->vval.v_partial));\n\t    *pp = end;\n\t    if (partial != NULL)\n\t\t*partial = lv.ll_tv->vval.v_partial;\n\t}\n\telse\n\t{\n\t    if (!skip && !(flags & TFN_QUIET) && (fdp == NULL\n\t\t\t     || lv.ll_dict == NULL || fdp->fd_newkey == NULL))\n\t\temsg(_(e_funcref_required));\n\t    else\n\t\t*pp = end;\n\t    name = NULL;\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_name == NULL)\n    {\n\t// Error found, but continue after the function name.\n\t*pp = end;\n\tgoto theend;\n    }\n\n    // Check if the name is a Funcref.  If so, use the value.\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tname = deref_func_name(lv.ll_exp_name, &len, partial, type,\n\t\t\t  flags & TFN_NO_AUTOLOAD, flags & TFN_NEW_FUNC, NULL);\n\tif (name == lv.ll_exp_name)\n\t    name = NULL;\n    }\n    else if (lv.ll_sid > 0)\n    {\n\tscriptitem_T\t*si = SCRIPT_ITEM(lv.ll_sid);\n\tint\t\tcc = *lv.ll_name_end;\n\n\t// function in another script.  Prefix <SNR>99_ or the autoload prefix.\n\t*lv.ll_name_end = NUL;\n\tif (si->sn_autoload_prefix != NULL)\n\t{\n\t    name = concat_str(si->sn_autoload_prefix, lv.ll_name);\n\t}\n\telse\n\t{\n\t    sid_buf[0] = K_SPECIAL;\n\t    sid_buf[1] = KS_EXTRA;\n\t    sid_buf[2] = (int)KE_SNR;\n\t    vim_snprintf((char *)sid_buf + 3, sizeof(sid_buf) - 3,\n\t\t\t\t\t\t      \"%ld_\", (long)lv.ll_sid);\n\t    name = concat_str(sid_buf, lv.ll_name);\n\t}\n\t*lv.ll_name_end = cc;\n\t*pp = end;\n\tgoto theend;\n    }\n    else if (!(flags & TFN_NO_DEREF))\n    {\n\tlen = (int)(end - *pp);\n\tname = deref_func_name(*pp, &len, partial, type,\n\t\t\t  flags & TFN_NO_AUTOLOAD, flags & TFN_NEW_FUNC, NULL);\n\tif (name == *pp)\n\t    name = NULL;\n    }\n    if (name != NULL)\n    {\n\tname = vim_strsave(name);\n\t*pp = end;\n\tif (STRNCMP(name, \"<SNR>\", 5) == 0)\n\t{\n\t    // Change \"<SNR>\" to the byte sequence.\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    mch_memmove(name + 3, name + 5, STRLEN(name + 5) + 1);\n\t}\n\tgoto theend;\n    }\n\n    if (lv.ll_exp_name != NULL)\n    {\n\tlen = (int)STRLEN(lv.ll_exp_name);\n\tif (lead <= 2 && lv.ll_name == lv.ll_exp_name\n\t\t\t\t\t && STRNCMP(lv.ll_name, \"s:\", 2) == 0)\n\t{\n\t    // When there was \"s:\" already or the name expanded to get a\n\t    // leading \"s:\" then remove it.\n\t    lv.ll_name += 2;\n\t    len -= 2;\n\t    lead = 2;\n\t}\n    }\n    else\n    {\n\t// skip over \"s:\" and \"g:\"\n\tif (lead == 2 || (lv.ll_name[0] == 'g' && lv.ll_name[1] == ':'))\n\t{\n\t    if (lv.ll_name[0] == 'g')\n\t    {\n\t\tif (is_global != NULL)\n\t\t{\n\t\t    *is_global = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // dropping \"g:\" without setting \"is_global\" won't work in\n\t\t    // Vim9script, put it back later\n\t\t    prefix_g = TRUE;\n\t\t    extra = 2;\n\t\t}\n\t    }\n\t    lv.ll_name += 2;\n\t}\n\tlen = (int)(end - lv.ll_name);\n    }\n    if (len <= 0)\n    {\n\tif (!skip)\n\t    emsg(_(e_function_name_required));\n\tgoto theend;\n    }\n\n    // In Vim9 script a user function is script-local by default, unless it\n    // starts with a lower case character: dict.func().\n    vim9_local = ASCII_ISUPPER(*start) && vim9script;\n\n    /*\n     * Copy the function name to allocated memory.\n     * Accept <SID>name() inside a script, translate into <SNR>123_name().\n     * Accept <SNR>123_name() outside a script.\n     */\n    if (skip)\n\tlead = 0;\t// do nothing\n    else if (lead > 0 || vim9_local)\n    {\n\tif (!vim9_local)\n\t{\n\t    if (vim9script && lead == 2 && !ASCII_ISUPPER(*lv.ll_name)\n\t\t\t\t\t\t   && current_script_is_vim9())\n\t    {\n\t\tsemsg(_(e_function_name_must_start_with_capital_str), start);\n\t\tgoto theend;\n\t    }\n\t    lead = 3;\n\t}\n\tif (vim9_local || (lv.ll_exp_name != NULL\n\t\t\t\t\t     && eval_fname_sid(lv.ll_exp_name))\n\t\t\t\t\t\t       || eval_fname_sid(*pp))\n\t{\n\t    // It's script-local, \"s:\" or \"<SID>\"\n\t    if (current_sctx.sc_sid <= 0)\n\t    {\n\t\temsg(_(e_using_sid_not_in_script_context));\n\t\tgoto theend;\n\t    }\n\t    sprintf((char *)sid_buf, \"%ld_\", (long)current_sctx.sc_sid);\n\t    if (vim9_local)\n\t\textra = 3 + (int)STRLEN(sid_buf);\n\t    else\n\t\tlead += (int)STRLEN(sid_buf);\n\t}\n    }\n    else if (!(flags & TFN_INT) && (builtin_function(lv.ll_name, len)\n\t\t\t\t   || (vim9script && *lv.ll_name == '_')))\n    {\n\tsemsg(_(vim9script ? e_function_name_must_start_with_capital_str\n\t\t\t   : e_function_name_must_start_with_capital_or_s_str),\n\t\t\t\t\t\t\t\t\tstart);\n\tgoto theend;\n    }\n    if (!skip && !(flags & TFN_QUIET) && !(flags & TFN_NO_DEREF))\n    {\n\tchar_u *cp = vim_strchr(lv.ll_name, ':');\n\n\tif (cp != NULL && cp < end)\n\t{\n\t    semsg(_(e_function_name_cannot_contain_colon_str), start);\n\t    goto theend;\n\t}\n    }\n\n    name = alloc(len + lead + extra + 1);\n    if (name != NULL)\n    {\n\tif (!skip && (lead > 0 || vim9_local))\n\t{\n\t    name[0] = K_SPECIAL;\n\t    name[1] = KS_EXTRA;\n\t    name[2] = (int)KE_SNR;\n\t    if (vim9_local || lead > 3)\t// If it's \"<SID>\"\n\t\tSTRCPY(name + 3, sid_buf);\n\t}\n\telse if (prefix_g)\n\t{\n\t    name[0] = 'g';\n\t    name[1] = ':';\n\t}\n\tmch_memmove(name + lead + extra, lv.ll_name, (size_t)len);\n\tname[lead + extra + len] = NUL;\n    }\n    *pp = end;\n\ntheend:\n    clear_lval(&lv);\n    return name;\n}\n\n/*\n * Assuming \"name\" is the result of trans_function_name() and it was prefixed\n * to use the script-local name, return the unmodified name (points into\n * \"name\").  Otherwise return NULL.\n * This can be used to first search for a script-local function and fall back\n * to the global function if not found.\n */\n    static char_u *\nuntrans_function_name(char_u *name)\n{\n    char_u *p;\n\n    if (*name == K_SPECIAL && in_vim9script())\n    {\n\tp = vim_strchr(name, '_');\n\tif (p != NULL)\n\t    return p + 1;\n    }\n    return NULL;\n}\n\n/*\n * If the 'funcname' starts with \"s:\" or \"<SID>\", then expands it to the\n * current script ID and returns the expanded function name. The caller should\n * free the returned name. If not called from a script context or the function\n * name doesn't start with these prefixes, then returns NULL.\n * This doesn't check whether the script-local function exists or not.\n */\n    char_u *\nget_scriptlocal_funcname(char_u *funcname)\n{\n    char\tsid_buf[25];\n    int\t\toff;\n    char_u\t*newname;\n    char_u\t*p = funcname;\n\n    if (funcname == NULL)\n\treturn NULL;\n\n    if (STRNCMP(funcname, \"s:\", 2) != 0\n\t\t&& STRNCMP(funcname, \"<SID>\", 5) != 0)\n    {\n\tufunc_T\t    *ufunc;\n\n\t// The function name does not have a script-local prefix.  Try finding\n\t// it when in a Vim9 script and there is no \"g:\" prefix.\n\tif (!in_vim9script() || STRNCMP(funcname, \"g:\", 2) == 0)\n\t    return NULL;\n\tufunc = find_func(funcname, FALSE);\n\tif (ufunc == NULL || func_is_global(ufunc)\n\t\t\t      || (p = vim_strchr(ufunc->uf_name, '_')) == NULL)\n\t    return NULL;\n\t++p;\n\toff = 0;\n    }\n    else\n\toff = *funcname == 's' ? 2 : 5;\n\n    if (!SCRIPT_ID_VALID(current_sctx.sc_sid))\n    {\n\temsg(_(e_using_sid_not_in_script_context));\n\treturn NULL;\n    }\n    // Expand s: prefix into <SNR>nr_<name>\n    vim_snprintf(sid_buf, sizeof(sid_buf), \"<SNR>%ld_\",\n\t    (long)current_sctx.sc_sid);\n    newname = alloc(STRLEN(sid_buf) + STRLEN(p + off) + 1);\n    if (newname == NULL)\n\treturn NULL;\n    STRCPY(newname, sid_buf);\n    STRCAT(newname, p + off);\n\n    return newname;\n}\n\n/*\n * Return script-local \"fname\" with the 3-byte sequence replaced by\n * printable <SNR> in allocated memory.\n */\n    char_u *\nalloc_printable_func_name(char_u *fname)\n{\n    char_u *n = alloc(STRLEN(fname + 3) + 6);\n\n    if (n != NULL)\n    {\n\tSTRCPY(n, \"<SNR>\");\n\tSTRCPY(n + 5, fname + 3);\n    }\n    return n;\n}\n\n/*\n * Call trans_function_name(), except that a lambda is returned as-is.\n * Returns the name in allocated memory.\n */\n    char_u *\nsave_function_name(\n\tchar_u\t    **name,\n\tint\t    *is_global,\n\tint\t    skip,\n\tint\t    flags,\n\tfuncdict_T  *fudi)\n{\n    char_u *p = *name;\n    char_u *saved;\n\n    if (STRNCMP(p, \"<lambda>\", 8) == 0)\n    {\n\tp += 8;\n\t(void)getdigits(&p);\n\tsaved = vim_strnsave(*name, p - *name);\n\tif (fudi != NULL)\n\t    CLEAR_POINTER(fudi);\n    }\n    else\n\tsaved = trans_function_name(&p, is_global, skip,\n\t\t\t\t\t\t      flags, fudi, NULL, NULL);\n    *name = p;\n    return saved;\n}\n\n/*\n * List functions.  When \"regmatch\" is NULL all of then.\n * Otherwise functions matching \"regmatch\".\n */\n    void\nlist_functions(regmatch_T *regmatch)\n{\n    int\t\tchanged = func_hashtab.ht_changed;\n    long_u\ttodo = func_hashtab.ht_used;\n    hashitem_T\t*hi;\n\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    ufunc_T\t*fp = HI2UF(hi);\n\n\t    --todo;\n\t    if ((fp->uf_flags & FC_DEAD) == 0\n\t\t    && (regmatch == NULL\n\t\t\t? !message_filtered(fp->uf_name)\n\t\t\t    && !func_name_refcount(fp->uf_name)\n\t\t\t: !isdigit(*fp->uf_name)\n\t\t\t    && vim_regexec(regmatch, fp->uf_name, 0)))\n\t    {\n\t\tlist_func_head(fp, FALSE);\n\t\tif (changed != func_hashtab.ht_changed)\n\t\t{\n\t\t    emsg(_(e_function_list_was_modified));\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * \":function\" also supporting nested \":def\".\n * When \"name_arg\" is not NULL this is a nested function, using \"name_arg\" for\n * the function name.\n * \"lines_to_free\" is a list of strings to be freed later.\n * Returns a pointer to the function or NULL if no function defined.\n */\n    ufunc_T *\ndefine_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg = FALSE;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n    garray_T\tnewargs;\n    garray_T\targtypes;\n    garray_T\tdefault_args;\n    garray_T\tnewlines;\n    int\t\tvarargs = FALSE;\n    int\t\tflags = 0;\n    char_u\t*ret_type = NULL;\n    ufunc_T\t*fp = NULL;\n    int\t\tfp_allocated = FALSE;\n    int\t\tfree_fp = FALSE;\n    int\t\toverwrite = FALSE;\n    dictitem_T\t*v;\n    funcdict_T\tfudi;\n    static int\tfunc_nr = 0;\t    // number for nameless function\n    int\t\tparen;\n    hashitem_T\t*hi;\n    linenr_T\tsourcing_lnum_top;\n    int\t\tvim9script = in_vim9script();\n    imported_T\t*import = NULL;\n\n    /*\n     * \":function\" without argument: list functions.\n     */\n    if (ends_excmd2(eap->cmd, eap->arg))\n    {\n\tif (!eap->skip)\n\t    list_functions(NULL);\n\tset_nextcmd(eap, eap->arg);\n\treturn NULL;\n    }\n\n    /*\n     * \":function /pat\": list functions matching pattern.\n     */\n    if (*eap->arg == '/')\n    {\n\tp = skip_regexp(eap->arg + 1, '/', TRUE);\n\tif (!eap->skip)\n\t{\n\t    regmatch_T\tregmatch;\n\n\t    c = *p;\n\t    *p = NUL;\n\t    regmatch.regprog = vim_regcomp(eap->arg + 1, RE_MAGIC);\n\t    *p = c;\n\t    if (regmatch.regprog != NULL)\n\t    {\n\t\tregmatch.rm_ic = p_ic;\n\t\tlist_functions(&regmatch);\n\t\tvim_regfree(regmatch.regprog);\n\t    }\n\t}\n\tif (*p == '/')\n\t    ++p;\n\tset_nextcmd(eap, p);\n\treturn NULL;\n    }\n\n    ga_init(&newargs);\n    ga_init(&argtypes);\n    ga_init(&default_args);\n\n    /*\n     * Get the function name.  There are these situations:\n     * func\t    normal function name\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" == NULL\n     * dict.func    new dictionary entry\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" == NULL, \"fudi.fd_newkey\" == func\n     * dict.func    existing dict entry with a Funcref\n     *\t\t    \"name\" == func, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * dict.func    existing dict entry that's not a Funcref\n     *\t\t    \"name\" == NULL, \"fudi.fd_dict\" set,\n     *\t\t    \"fudi.fd_di\" set, \"fudi.fd_newkey\" == NULL\n     * s:func\t    script-local function name\n     * g:func\t    global function name, same as \"func\"\n     */\n    p = eap->arg;\n    if (name_arg != NULL)\n    {\n\t// nested function, argument is (args).\n\tparen = TRUE;\n\tCLEAR_FIELD(fudi);\n    }\n    else\n    {\n\tif (vim9script)\n\t{\n\t    if (p[0] == 's' && p[1] == ':')\n\t    {\n\t\tsemsg(_(e_cannot_use_s_colon_in_vim9_script_str), p);\n\t\treturn NULL;\n\t    }\n\t    p = to_name_end(p, TRUE);\n\t    if (*skipwhite(p) == '.' && vim_strchr(p, '(') != NULL)\n\t    {\n\t\tsemsg(_(e_cannot_define_dict_func_in_vim9_script_str),\n\t\t\t\t\t\t\t\t     eap->arg);\n\t\treturn NULL;\n\t    }\n\t    p = eap->arg;\n\t}\n\n\tname = save_function_name(&p, &is_global, eap->skip,\n\t\t\t\t\tTFN_NO_AUTOLOAD | TFN_NEW_FUNC, &fudi);\n\tparen = (vim_strchr(p, '(') != NULL);\n\tif (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip)\n\t{\n\t    /*\n\t     * Return on an invalid expression in braces, unless the expression\n\t     * evaluation has been cancelled due to an aborting error, an\n\t     * interrupt, or an exception.\n\t     */\n\t    if (!aborting())\n\t    {\n\t\tif (!eap->skip && fudi.fd_newkey != NULL)\n\t\t    semsg(_(e_key_not_present_in_dictionary), fudi.fd_newkey);\n\t\tvim_free(fudi.fd_newkey);\n\t\treturn NULL;\n\t    }\n\t    else\n\t\teap->skip = TRUE;\n\t}\n\n\t// For \"export def FuncName()\" in an autoload script the function name\n\t// is stored with the legacy autoload name \"dir#script#FuncName\" so\n\t// that it can also be found in legacy script.\n\tif (is_export && name != NULL)\n\t{\n\t    char_u *prefixed = may_prefix_autoload(name);\n\n\t    if (prefixed != NULL && prefixed != name)\n\t    {\n\t\tvim_free(name);\n\t\tname = prefixed;\n\t    }\n\t}\n\telse if (paren && vim9script && name != NULL\n\t\t\t\t    && vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    emsg(_(e_cannot_use_name_with_hash_in_vim9_script_use_export_instead));\n\t    goto ret_free;\n\t}\n    }\n\n    // An error in a function call during evaluation of an expression in magic\n    // braces should not cause the function not to be defined.\n    saved_did_emsg = did_emsg;\n    did_emsg = FALSE;\n\n    /*\n     * \":function func\" with only function name: list function.\n     */\n    if (!paren)\n    {\n\tif (!ends_excmd(*skipwhite(p)))\n\t{\n\t    semsg(_(e_trailing_characters_str), p);\n\t    goto ret_free;\n\t}\n\tset_nextcmd(eap, p);\n\tif (eap->nextcmd != NULL)\n\t    *p = NUL;\n\tif (!eap->skip && !got_int)\n\t{\n\t    fp = find_func(name, is_global);\n\t    if (fp == NULL && ASCII_ISUPPER(*eap->arg))\n\t    {\n\t\tchar_u *up = untrans_function_name(name);\n\n\t\t// With Vim9 script the name was made script-local, if not\n\t\t// found try again with the original name.\n\t\tif (up != NULL)\n\t\t    fp = find_func(up, FALSE);\n\t    }\n\n\t    if (fp != NULL)\n\t    {\n\t\tlist_func_head(fp, TRUE);\n\t\tfor (j = 0; j < fp->uf_lines.ga_len && !got_int; ++j)\n\t\t{\n\t\t    if (FUNCLINE(fp, j) == NULL)\n\t\t\tcontinue;\n\t\t    msg_putchar('\\n');\n\t\t    msg_outnum((long)(j + 1));\n\t\t    if (j < 9)\n\t\t\tmsg_putchar(' ');\n\t\t    if (j < 99)\n\t\t\tmsg_putchar(' ');\n\t\t    msg_prt_line(FUNCLINE(fp, j), FALSE);\n\t\t    out_flush();\t// show a line at a time\n\t\t    ui_breakcheck();\n\t\t}\n\t\tif (!got_int)\n\t\t{\n\t\t    msg_putchar('\\n');\n\t\t    if (fp->uf_def_status != UF_NOT_COMPILED)\n\t\t\tmsg_puts(\"   enddef\");\n\t\t    else\n\t\t\tmsg_puts(\"   endfunction\");\n\t\t}\n\t    }\n\t    else\n\t\temsg_funcname(e_undefined_function_str, eap->arg);\n\t}\n\tgoto ret_free;\n    }\n\n    /*\n     * \":function name(arg1, arg2)\" Define function.\n     */\n    p = skipwhite(p);\n    if (*p != '(')\n    {\n\tif (!eap->skip)\n\t{\n\t    semsg(_(e_missing_paren_str), eap->arg);\n\t    goto ret_free;\n\t}\n\t// attempt to continue by skipping some text\n\tif (vim_strchr(p, '(') != NULL)\n\t    p = vim_strchr(p, '(');\n    }\n\n    if ((vim9script || eap->cmdidx == CMD_def) && VIM_ISWHITE(p[-1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", p - 1);\n\tgoto ret_free;\n    }\n\n    // In Vim9 script only global functions can be redefined.\n    if (vim9script && eap->forceit && !is_global)\n    {\n\temsg(_(e_no_bang_allowed));\n\tgoto ret_free;\n    }\n\n    ga_init2(&newlines, sizeof(char_u *), 10);\n\n    if (!eap->skip && name_arg == NULL)\n    {\n\t// Check the name of the function.  Unless it's a dictionary function\n\t// (that we are overwriting).\n\tif (name != NULL)\n\t    arg = name;\n\telse\n\t    arg = fudi.fd_newkey;\n\tif (arg != NULL && (fudi.fd_di == NULL\n\t\t\t\t     || (fudi.fd_di->di_tv.v_type != VAR_FUNC\n\t\t\t\t && fudi.fd_di->di_tv.v_type != VAR_PARTIAL)))\n\t{\n\t    char_u  *name_base = arg;\n\t    int\t    i;\n\n\t    if (*arg == K_SPECIAL)\n\t    {\n\t\tname_base = vim_strchr(arg, '_');\n\t\tif (name_base == NULL)\n\t\t    name_base = arg + 3;\n\t\telse\n\t\t    ++name_base;\n\t    }\n\t    for (i = 0; name_base[i] != NUL && (i == 0\n\t\t\t\t\t? eval_isnamec1(name_base[i])\n\t\t\t\t\t: eval_isnamec(name_base[i])); ++i)\n\t\t;\n\t    if (name_base[i] != NUL)\n\t\temsg_funcname(e_invalid_argument_str, arg);\n\n\t    // In Vim9 script a function cannot have the same name as a\n\t    // variable.\n\t    if (vim9script && *arg == K_SPECIAL\n\t\t&& eval_variable(name_base, (int)STRLEN(name_base), 0, NULL,\n\t\t    NULL, EVAL_VAR_NOAUTOLOAD + EVAL_VAR_IMPORT\n\t\t\t\t\t\t     + EVAL_VAR_NO_FUNC) == OK)\n\t    {\n\t\tsemsg(_(e_redefining_script_item_str), name_base);\n\t\tgoto ret_free;\n\t    }\n\t}\n\t// Disallow using the g: dict.\n\tif (fudi.fd_dict != NULL && fudi.fd_dict->dv_scope == VAR_DEF_SCOPE)\n\t{\n\t    emsg(_(e_cannot_use_g_here));\n\t    goto ret_free;\n\t}\n    }\n\n    // This may get more lines and make the pointers into the first line\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, lines_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t// find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\t\tsemsg(_(e_no_white_space_allowed_before_colon_str), p);\n\t\tp = skipwhite(p);\n\t    }\n\t    else if (!IS_WHITE_OR_NUL(p[1]))\n\t\tsemsg(_(e_white_space_required_after_str_str), \":\", p);\n\t    ret_type = skipwhite(p + 1);\n\t    p = skip_type(ret_type, FALSE);\n\t    if (p > ret_type)\n\t    {\n\t\tret_type = vim_strnsave(ret_type, p - ret_type);\n\t\twhitep = p;\n\t\tp = skipwhite(p);\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_expected_type_str), ret_type);\n\t\tret_type = NULL;\n\t    }\n\t}\n\tp = skipwhite(p);\n    }\n    else\n\t// find extra arguments \"range\", \"dict\", \"abort\" and \"closure\"\n\tfor (;;)\n\t{\n\t    whitep = p;\n\t    p = skipwhite(p);\n\t    if (STRNCMP(p, \"range\", 5) == 0)\n\t    {\n\t\tflags |= FC_RANGE;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"dict\", 4) == 0)\n\t    {\n\t\tflags |= FC_DICT;\n\t\tp += 4;\n\t    }\n\t    else if (STRNCMP(p, \"abort\", 5) == 0)\n\t    {\n\t\tflags |= FC_ABORT;\n\t\tp += 5;\n\t    }\n\t    else if (STRNCMP(p, \"closure\", 7) == 0)\n\t    {\n\t\tflags |= FC_CLOSURE;\n\t\tp += 7;\n\t\tif (current_funccal == NULL)\n\t\t{\n\t\t    emsg_funcname(e_closure_function_should_not_be_at_top_level,\n\t\t\t    name == NULL ? (char_u *)\"\" : name);\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n\n    // When there is a line break use what follows for the function body.\n    // Makes 'exe \"func Test()\\n...\\nendfunc\"' work.\n    if (*p == '\\n')\n\tline_arg = p + 1;\n    else if (*p != NUL\n\t    && !(*p == '\"' && (!vim9script || eap->cmdidx == CMD_function)\n\t\t\t\t\t\t     && eap->cmdidx != CMD_def)\n\t    && !(VIM_ISWHITE(*whitep) && *p == '#'\n\t\t\t\t     && (vim9script || eap->cmdidx == CMD_def))\n\t    && !eap->skip\n\t    && !did_emsg)\n\tsemsg(_(e_trailing_characters_str), p);\n\n    /*\n     * Read the body of the function, until \"}\", \":endfunction\" or \":enddef\" is\n     * found.\n     */\n    if (KeyTyped)\n    {\n\t// Check if the function already exists, don't let the user type the\n\t// whole function before telling him it doesn't work!  For a script we\n\t// need to skip the body to be able to find what follows.\n\tif (!eap->skip && !eap->forceit)\n\t{\n\t    if (fudi.fd_dict != NULL && fudi.fd_newkey == NULL)\n\t\temsg(_(e_dictionary_entry_already_exists));\n\t    else if (name != NULL && find_func(name, is_global) != NULL)\n\t\temsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);\n\t}\n\n\tif (!eap->skip && did_emsg)\n\t    goto erret;\n\n\tmsg_putchar('\\n');\t    // don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function\n     */\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n\tchar_u\t\t*find_name = name;\n\tint\t\tvar_conflict = FALSE;\n\tint\t\tffed_flags = is_global ? FFED_IS_GLOBAL : 0;\n\n\tv = find_var(name, &ht, TRUE);\n\tif (v != NULL && (vim9script || v->di_tv.v_type == VAR_FUNC))\n\t    var_conflict = TRUE;\n\n\tif (SCRIPT_ID_VALID(current_sctx.sc_sid))\n\t{\n\t    scriptitem_T *si = SCRIPT_ITEM(current_sctx.sc_sid);\n\n\t    if (si->sn_autoload_prefix != NULL)\n\t    {\n\t\tif (is_export)\n\t\t{\n\t\t    find_name = name + STRLEN(si->sn_autoload_prefix);\n\t\t    v = find_var(find_name, &ht, TRUE);\n\t\t    if (v != NULL)\n\t\t\tvar_conflict = TRUE;\n\t\t    // Only check if the function already exists in the script,\n\t\t    // global functions can be shadowed.\n\t\t    ffed_flags |= FFED_NO_GLOBAL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    char_u *prefixed = may_prefix_autoload(name);\n\n\t\t    if (prefixed != NULL && prefixed != name)\n\t\t    {\n\t\t\tv = find_var(prefixed, &ht, TRUE);\n\t\t\tif (v != NULL)\n\t\t\t    var_conflict = TRUE;\n\t\t\tvim_free(prefixed);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (var_conflict)\n\t{\n\t    emsg_funcname(e_function_name_conflicts_with_variable_str, name);\n\t    goto erret;\n\t}\n\n\tfp = find_func_even_dead(find_name, ffed_flags);\n\tif (vim9script)\n\t{\n\t    char_u *uname = untrans_function_name(name);\n\n\t    import = find_imported(uname == NULL ? name : uname, 0, FALSE);\n\t}\n\n\tif (fp != NULL || import != NULL)\n\t{\n\t    int dead = fp != NULL && (fp->uf_flags & FC_DEAD);\n\n\t    // Function can be replaced with \"function!\" and when sourcing the\n\t    // same script again, but only once.\n\t    // A name that is used by an import can not be overruled.\n\t    if (import != NULL\n\t\t    || (!dead && !eap->forceit\n\t\t\t&& (fp->uf_script_ctx.sc_sid != current_sctx.sc_sid\n\t\t\t  || fp->uf_script_ctx.sc_seq == current_sctx.sc_seq)))\n\t    {\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tif (vim9script)\n\t\t    emsg_funcname(e_name_already_defined_str, name);\n\t\telse\n\t\t    emsg_funcname(e_function_str_already_exists_add_bang_to_replace, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_calls > 0)\n\t    {\n\t\temsg_funcname(\n\t\t\t    e_cannot_redefine_function_str_it_is_in_use, name);\n\t\tgoto erret;\n\t    }\n\t    if (fp->uf_refcount > 1)\n\t    {\n\t\t// This function is referenced somewhere, don't redefine it but\n\t\t// create a new one.\n\t\t--fp->uf_refcount;\n\t\tfp->uf_flags |= FC_REMOVED;\n\t\tfp = NULL;\n\t\toverwrite = TRUE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u *exp_name = fp->uf_name_exp;\n\n\t\t// redefine existing function, keep the expanded name\n\t\tVIM_CLEAR(name);\n\t\tfp->uf_name_exp = NULL;\n\t\tfunc_clear_items(fp);\n\t\tfp->uf_name_exp = exp_name;\n\t\tfp->uf_flags &= ~FC_DEAD;\n#ifdef FEAT_PROFILE\n\t\tfp->uf_profiling = FALSE;\n\t\tfp->uf_prof_initialized = FALSE;\n#endif\n\t\tfp->uf_def_status = UF_NOT_COMPILED;\n\t    }\n\t}\n    }\n    else\n    {\n\tchar\tnumbuf[20];\n\n\tfp = NULL;\n\tif (fudi.fd_newkey == NULL && !eap->forceit)\n\t{\n\t    emsg(_(e_dictionary_entry_already_exists));\n\t    goto erret;\n\t}\n\tif (fudi.fd_di == NULL)\n\t{\n\t    // Can't add a function to a locked dictionary\n\t    if (value_check_lock(fudi.fd_dict->dv_lock, eap->arg, FALSE))\n\t\tgoto erret;\n\t}\n\t    // Can't change an existing function if it is locked\n\telse if (value_check_lock(fudi.fd_di->di_tv.v_lock, eap->arg, FALSE))\n\t    goto erret;\n\n\t// Give the function a sequential number.  Can only be used with a\n\t// Funcref!\n\tvim_free(name);\n\tsprintf(numbuf, \"%d\", ++func_nr);\n\tname = vim_strsave((char_u *)numbuf);\n\tif (name == NULL)\n\t    goto erret;\n    }\n\n    if (fp == NULL)\n    {\n\tif (fudi.fd_dict == NULL && vim_strchr(name, AUTOLOAD_CHAR) != NULL)\n\t{\n\t    int\t    slen, plen;\n\t    char_u  *scriptname;\n\n\t    // Check that the autoload name matches the script name.\n\t    j = FAIL;\n\t    if (SOURCING_NAME != NULL)\n\t    {\n\t\tscriptname = autoload_name(name);\n\t\tif (scriptname != NULL)\n\t\t{\n\t\t    p = vim_strchr(scriptname, '/');\n\t\t    plen = (int)STRLEN(p);\n\t\t    slen = (int)STRLEN(SOURCING_NAME);\n\t\t    if (slen > plen && fnamecmp(p,\n\t\t\t\t\t    SOURCING_NAME + slen - plen) == 0)\n\t\t\tj = OK;\n\t\t    vim_free(scriptname);\n\t\t}\n\t    }\n\t    if (j == FAIL)\n\t    {\n\t\tlinenr_T save_lnum = SOURCING_LNUM;\n\n\t\tSOURCING_LNUM = sourcing_lnum_top;\n\t\tsemsg(_(e_function_name_does_not_match_script_file_name_str),\n\t\t\t\t\t\t\t\t\t name);\n\t\tSOURCING_LNUM = save_lnum;\n\t\tgoto erret;\n\t    }\n\t}\n\n\tfp = alloc_clear(offsetof(ufunc_T, uf_name) + STRLEN(name) + 1);\n\tif (fp == NULL)\n\t    goto erret;\n\tfp_allocated = TRUE;\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    if (fudi.fd_di == NULL)\n\t    {\n\t\t// add new dict entry\n\t\tfudi.fd_di = dictitem_alloc(fudi.fd_newkey);\n\t\tif (fudi.fd_di == NULL)\n\t\t{\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t\tif (dict_add(fudi.fd_dict, fudi.fd_di) == FAIL)\n\t\t{\n\t\t    vim_free(fudi.fd_di);\n\t\t    vim_free(fp);\n\t\t    fp = NULL;\n\t\t    goto erret;\n\t\t}\n\t    }\n\t    else\n\t\t// overwrite existing dict entry\n\t\tclear_tv(&fudi.fd_di->di_tv);\n\t    fudi.fd_di->di_tv.v_type = VAR_FUNC;\n\t    fudi.fd_di->di_tv.vval.v_string = vim_strsave(name);\n\n\t    // behave like \"dict\" was used\n\t    flags |= FC_DICT;\n\t}\n    }\n    fp->uf_args = newargs;\n    fp->uf_def_args = default_args;\n    fp->uf_ret_type = &t_any;\n    fp->uf_func_type = &t_func_any;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\tint\t    lnum_save = SOURCING_LNUM;\n\tcstack_T    *cstack = eap->cstack;\n\n\tfp->uf_def_status = UF_TO_BE_COMPILED;\n\n\t// error messages are for the first function line\n\tSOURCING_LNUM = sourcing_lnum_top;\n\n\t// The function may use script variables from the context.\n\tfunction_using_block_scopes(fp, cstack);\n\n\tif (parse_argument_types(fp, &argtypes, varargs) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tvarargs = FALSE;\n\n\t// parse the return type, if any\n\tif (parse_return_type(fp, ret_type) == FAIL)\n\t{\n\t    SOURCING_LNUM = lnum_save;\n\t    free_fp = fp_allocated;\n\t    goto erret;\n\t}\n\tSOURCING_LNUM = lnum_save;\n    }\n    else\n\tfp->uf_def_status = UF_NOT_COMPILED;\n\n    if (fp_allocated)\n    {\n\t// insert the new function in the function list\n\tset_ufunc_name(fp, name);\n\tif (overwrite)\n\t{\n\t    hi = hash_find(&func_hashtab, name);\n\t    hi->hi_key = UF2HIKEY(fp);\n\t}\n\telse if (hash_add(&func_hashtab, UF2HIKEY(fp)) == FAIL)\n\t{\n\t    free_fp = TRUE;\n\t    goto erret;\n\t}\n\tfp->uf_refcount = 1;\n    }\n\n    fp->uf_lines = newlines;\n    newlines.ga_data = NULL;\n    if ((flags & FC_CLOSURE) != 0)\n    {\n\tif (register_closure(fp) == FAIL)\n\t    goto erret;\n    }\n    else\n\tfp->uf_scoped = NULL;\n\n#ifdef FEAT_PROFILE\n    if (prof_def_func())\n\tfunc_do_profile(fp);\n#endif\n    fp->uf_varargs = varargs;\n    if (sandbox)\n\tflags |= FC_SANDBOX;\n    if (vim9script && !ASCII_ISUPPER(*fp->uf_name))\n\tflags |= FC_VIM9;\n    fp->uf_flags = flags;\n    fp->uf_calls = 0;\n    fp->uf_cleared = FALSE;\n    fp->uf_script_ctx = current_sctx;\n    fp->uf_script_ctx_version = current_sctx.sc_version;\n    fp->uf_script_ctx.sc_lnum += sourcing_lnum_top;\n    if (is_export)\n    {\n\tfp->uf_flags |= FC_EXPORT;\n\t// let ex_export() know the export worked.\n\tis_export = FALSE;\n    }\n\n    if (eap->cmdidx == CMD_def)\n\tset_function_type(fp);\n    else if (fp->uf_script_ctx.sc_version == SCRIPT_VERSION_VIM9)\n\t// :func does not use Vim9 script syntax, even in a Vim9 script file\n\tfp->uf_script_ctx.sc_version = SCRIPT_VERSION_MAX;\n\n    goto ret_free;\n\nerret:\n    ga_clear_strings(&newargs);\n    ga_clear_strings(&default_args);\n    if (fp != NULL)\n    {\n\tga_init(&fp->uf_args);\n\tga_init(&fp->uf_def_args);\n    }\nerrret_2:\n    ga_clear_strings(&newlines);\n    if (fp != NULL)\n\tVIM_CLEAR(fp->uf_arg_types);\n    if (free_fp)\n    {\n\tvim_free(fp);\n\tfp = NULL;\n    }\nret_free:\n    ga_clear_strings(&argtypes);\n    vim_free(fudi.fd_newkey);\n    if (name != name_arg)\n\tvim_free(name);\n    vim_free(ret_type);\n    did_emsg |= saved_did_emsg;\n\n    return fp;\n}\n\n/*\n * \":function\"\n */\n    void\nex_function(exarg_T *eap)\n{\n    garray_T lines_to_free;\n\n    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n    (void)define_function(eap, NULL, &lines_to_free);\n    ga_clear_strings(&lines_to_free);\n}\n\n/*\n * Find a function by name, including \"<lambda>123\".\n * Check for \"profile\" and \"debug\" arguments and set\"compile_type\".\n * Caller should initialize \"compile_type\" to CT_NONE.\n * Return NULL if not found.\n */\n    ufunc_T *\nfind_func_by_name(char_u *name, compiletype_T *compile_type)\n{\n    char_u\t*arg = name;\n    char_u\t*fname;\n    ufunc_T\t*ufunc;\n    int\t\tis_global = FALSE;\n\n    if (STRNCMP(arg, \"profile\", 7) == 0 && VIM_ISWHITE(arg[7]))\n    {\n\t*compile_type = CT_PROFILE;\n\targ = skipwhite(arg + 7);\n    }\n    else if (STRNCMP(arg, \"debug\", 5) == 0 && VIM_ISWHITE(arg[5]))\n    {\n\t*compile_type = CT_DEBUG;\n\targ = skipwhite(arg + 5);\n    }\n\n    if (STRNCMP(arg, \"<lambda>\", 8) == 0)\n    {\n\targ += 8;\n\t(void)getdigits(&arg);\n\tfname = vim_strnsave(name, arg - name);\n    }\n    else\n\tfname = trans_function_name(&arg, &is_global, FALSE,\n\t\t      TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD, NULL, NULL, NULL);\n    if (fname == NULL)\n    {\n\tsemsg(_(e_invalid_argument_str), name);\n\treturn NULL;\n    }\n    if (!ends_excmd2(name, arg))\n    {\n\tvim_free(fname);\n\temsg(ex_errmsg(e_trailing_characters_str, arg));\n\treturn NULL;\n    }\n\n    ufunc = find_func(fname, is_global);\n    if (ufunc == NULL)\n    {\n\tchar_u *p = untrans_function_name(fname);\n\n\tif (p != NULL)\n\t    // Try again without making it script-local.\n\t    ufunc = find_func(p, FALSE);\n    }\n    vim_free(fname);\n    if (ufunc == NULL)\n\tsemsg(_(e_cannot_find_function_str), name);\n    return ufunc;\n}\n\n/*\n * :defcompile - compile all :def functions in the current script that need to\n * be compiled or the one specified by the argument.\n * Skips dead functions.  Doesn't do profiling.\n */\n    void\nex_defcompile(exarg_T *eap)\n{\n    ufunc_T\t*ufunc;\n\n    if (*eap->arg != NUL)\n    {\n\tcompiletype_T compile_type = CT_NONE;\n\n\tufunc = find_func_by_name(eap->arg, &compile_type);\n\tif (ufunc != NULL)\n\t{\n\t    if (func_needs_compiling(ufunc, compile_type))\n\t\t(void)compile_def_function(ufunc, FALSE, compile_type, NULL);\n\t    else\n\t\tsmsg(_(\"Function %s does not need compiling\"), eap->arg);\n\t}\n    }\n    else\n    {\n\tlong\ttodo = (long)func_hashtab.ht_used;\n\tint\t\tchanged = func_hashtab.ht_changed;\n\thashitem_T\t*hi;\n\n\tfor (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n\t{\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t--todo;\n\t\tufunc = HI2UF(hi);\n\t\tif (ufunc->uf_script_ctx.sc_sid == current_sctx.sc_sid\n\t\t\t&& ufunc->uf_def_status == UF_TO_BE_COMPILED\n\t\t\t&& (ufunc->uf_flags & FC_DEAD) == 0)\n\t\t{\n\t\t    (void)compile_def_function(ufunc, FALSE, CT_NONE, NULL);\n\n\t\t    if (func_hashtab.ht_changed != changed)\n\t\t    {\n\t\t\t// a function has been added or removed, need to start\n\t\t\t// over\n\t\t\ttodo = (long)func_hashtab.ht_used;\n\t\t\tchanged = func_hashtab.ht_changed;\n\t\t\thi = func_hashtab.ht_array;\n\t\t\t--hi;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n}\n\n/*\n * Return 5 if \"p\" starts with \"<SID>\" or \"<SNR>\" (ignoring case).\n * Return 2 if \"p\" starts with \"s:\".\n * Return 0 otherwise.\n */\n    int\neval_fname_script(char_u *p)\n{\n    // Use MB_STRICMP() because in Turkish comparing the \"I\" may not work with\n    // the standard library function.\n    if (p[0] == '<' && (MB_STRNICMP(p + 1, \"SID>\", 4) == 0\n\t\t\t\t       || MB_STRNICMP(p + 1, \"SNR>\", 4) == 0))\n\treturn 5;\n    if (p[0] == 's' && p[1] == ':')\n\treturn 2;\n    return 0;\n}\n\n    int\ntranslated_function_exists(char_u *name, int is_global)\n{\n    if (builtin_function(name, -1))\n\treturn has_internal_func(name);\n    return find_func(name, is_global) != NULL;\n}\n\n/*\n * Return TRUE when \"ufunc\" has old-style \"...\" varargs\n * or named varargs \"...name: type\".\n */\n    int\nhas_varargs(ufunc_T *ufunc)\n{\n    return ufunc->uf_varargs || ufunc->uf_va_name != NULL;\n}\n\n/*\n * Return TRUE if a function \"name\" exists.\n * If \"no_defef\" is TRUE, do not dereference a Funcref.\n */\n    int\nfunction_exists(char_u *name, int no_deref)\n{\n    char_u  *nm = name;\n    char_u  *p;\n    int\t    n = FALSE;\n    int\t    flag;\n    int\t    is_global = FALSE;\n\n    flag = TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD;\n    if (no_deref)\n\tflag |= TFN_NO_DEREF;\n    p = trans_function_name(&nm, &is_global, FALSE, flag, NULL, NULL, NULL);\n    nm = skipwhite(nm);\n\n    // Only accept \"funcname\", \"funcname \", \"funcname (...\" and\n    // \"funcname(...\", not \"funcname!...\".\n    if (p != NULL && (*nm == NUL || *nm == '('))\n\tn = translated_function_exists(p, is_global);\n    vim_free(p);\n    return n;\n}\n\n#if defined(FEAT_PYTHON) || defined(FEAT_PYTHON3) || defined(PROTO)\n    char_u *\nget_expanded_name(char_u *name, int check)\n{\n    char_u\t*nm = name;\n    char_u\t*p;\n    int\t\tis_global = FALSE;\n\n    p = trans_function_name(&nm, &is_global, FALSE,\n\t\t\t\t\t  TFN_INT|TFN_QUIET, NULL, NULL, NULL);\n\n    if (p != NULL && *nm == NUL\n\t\t       && (!check || translated_function_exists(p, is_global)))\n\treturn p;\n\n    vim_free(p);\n    return NULL;\n}\n#endif\n\n/*\n * Function given to ExpandGeneric() to obtain the list of user defined\n * function names.\n */\n    char_u *\nget_user_func_name(expand_T *xp, int idx)\n{\n    static long_u\tdone;\n    static int\t\tchanged;\n    static hashitem_T\t*hi;\n    ufunc_T\t\t*fp;\n\n    if (idx == 0)\n    {\n\tdone = 0;\n\thi = func_hashtab.ht_array;\n\tchanged = func_hashtab.ht_changed;\n    }\n    if (changed == func_hashtab.ht_changed && done < func_hashtab.ht_used)\n    {\n\tif (done++ > 0)\n\t    ++hi;\n\twhile (HASHITEM_EMPTY(hi))\n\t    ++hi;\n\tfp = HI2UF(hi);\n\n\t// don't show dead, dict and lambda functions\n\tif ((fp->uf_flags & FC_DEAD) || (fp->uf_flags & FC_DICT)\n\t\t\t\t|| STRNCMP(fp->uf_name, \"<lambda>\", 8) == 0)\n\t    return (char_u *)\"\";\n\n\tif (STRLEN(fp->uf_name) + 4 >= IOSIZE)\n\t    return fp->uf_name;\t// prevents overflow\n\n\tcat_func_name(IObuff, fp);\n\tif (xp->xp_context != EXPAND_USER_FUNC\n\t\t\t\t       && xp->xp_context != EXPAND_DISASSEMBLE)\n\t{\n\t    STRCAT(IObuff, \"(\");\n\t    if (!has_varargs(fp) && fp->uf_args.ga_len == 0)\n\t\tSTRCAT(IObuff, \")\");\n\t}\n\treturn IObuff;\n    }\n    return NULL;\n}\n\n/*\n * \":delfunction {name}\"\n */\n    void\nex_delfunction(exarg_T *eap)\n{\n    ufunc_T\t*fp = NULL;\n    char_u\t*p;\n    char_u\t*name;\n    funcdict_T\tfudi;\n    int\t\tis_global = FALSE;\n\n    p = eap->arg;\n    name = trans_function_name(&p, &is_global, eap->skip, 0, &fudi,\n\t\t\t\t\t\t\t\t   NULL, NULL);\n    vim_free(fudi.fd_newkey);\n    if (name == NULL)\n    {\n\tif (fudi.fd_dict != NULL && !eap->skip)\n\t    emsg(_(e_funcref_required));\n\treturn;\n    }\n    if (!ends_excmd(*skipwhite(p)))\n    {\n\tvim_free(name);\n\tsemsg(_(e_trailing_characters_str), p);\n\treturn;\n    }\n    set_nextcmd(eap, p);\n    if (eap->nextcmd != NULL)\n\t*p = NUL;\n\n    if (numbered_function(name) && fudi.fd_dict == NULL)\n    {\n\tif (!eap->skip)\n\t    semsg(_(e_invalid_argument_str), eap->arg);\n\tvim_free(name);\n\treturn;\n    }\n    if (!eap->skip)\n\tfp = find_func(name, is_global);\n    vim_free(name);\n\n    if (!eap->skip)\n    {\n\tif (fp == NULL)\n\t{\n\t    if (!eap->forceit)\n\t\tsemsg(_(e_unknown_function_str), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_calls > 0)\n\t{\n\t    semsg(_(e_cannot_delete_function_str_it_is_in_use), eap->arg);\n\t    return;\n\t}\n\tif (fp->uf_flags & FC_VIM9)\n\t{\n\t    semsg(_(e_cannot_delete_vim9_script_function_str), eap->arg);\n\t    return;\n\t}\n\n\tif (fudi.fd_dict != NULL)\n\t{\n\t    // Delete the dict item that refers to the function, it will\n\t    // invoke func_unref() and possibly delete the function.\n\t    dictitem_remove(fudi.fd_dict, fudi.fd_di);\n\t}\n\telse\n\t{\n\t    // A normal function (not a numbered function or lambda) has a\n\t    // refcount of 1 for the entry in the hashtable.  When deleting\n\t    // it and the refcount is more than one, it should be kept.\n\t    // A numbered function and lambda should be kept if the refcount is\n\t    // one or more.\n\t    if (fp->uf_refcount > (func_name_refcount(fp->uf_name) ? 0 : 1))\n\t    {\n\t\t// Function is still referenced somewhere.  Don't free it but\n\t\t// do remove it from the hashtable.\n\t\tif (func_remove(fp))\n\t\t    fp->uf_refcount--;\n\t    }\n\t    else\n\t\tfunc_clear_free(fp, FALSE);\n\t}\n    }\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n */\n    void\nfunc_unref(char_u *name)\n{\n    ufunc_T *fp = NULL;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE);\n    if (fp == NULL && numbered_function(name))\n    {\n#ifdef EXITFREE\n\tif (!entered_free_all_mem)\n#endif\n\t    internal_error(\"func_unref()\");\n    }\n    func_ptr_unref(fp);\n}\n\n/*\n * Unreference a Function: decrement the reference count and free it when it\n * becomes zero.\n * Also when it becomes one and uf_partial points to the function.\n */\n    void\nfunc_ptr_unref(ufunc_T *fp)\n{\n    if (fp != NULL && (--fp->uf_refcount <= 0\n\t\t|| (fp->uf_refcount == 1 && fp->uf_partial != NULL\n\t\t\t\t\t && fp->uf_partial->pt_refcount <= 1\n\t\t\t\t\t && fp->uf_partial->pt_func == fp)))\n    {\n\t// Only delete it when it's not being used.  Otherwise it's done\n\t// when \"uf_calls\" becomes zero.\n\tif (fp->uf_calls == 0)\n\t    func_clear_free(fp, FALSE);\n    }\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ref(char_u *name)\n{\n    ufunc_T *fp;\n\n    if (name == NULL || !func_name_refcount(name))\n\treturn;\n    fp = find_func(name, FALSE);\n    if (fp != NULL)\n\t++fp->uf_refcount;\n    else if (numbered_function(name))\n\t// Only give an error for a numbered function.\n\t// Fail silently, when named or lambda function isn't found.\n\tinternal_error(\"func_ref()\");\n}\n\n/*\n * Count a reference to a Function.\n */\n    void\nfunc_ptr_ref(ufunc_T *fp)\n{\n    if (fp != NULL)\n\t++fp->uf_refcount;\n}\n\n/*\n * Return TRUE if items in \"fc\" do not have \"copyID\".  That means they are not\n * referenced from anywhere that is in use.\n */\n    static int\ncan_free_funccal(funccall_T *fc, int copyID)\n{\n    return (fc->l_varlist.lv_copyID != copyID\n\t    && fc->l_vars.dv_copyID != copyID\n\t    && fc->l_avars.dv_copyID != copyID\n\t    && fc->fc_copyID != copyID);\n}\n\n/*\n * \":return [expr]\"\n */\n    void\nex_return(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    typval_T\trettv;\n    int\t\treturning = FALSE;\n    evalarg_T\tevalarg;\n\n    if (current_funccal == NULL)\n    {\n\temsg(_(e_return_not_inside_function));\n\treturn;\n    }\n\n    init_evalarg(&evalarg);\n    evalarg.eval_flags = eap->skip ? 0 : EVAL_EVALUATE;\n\n    if (eap->skip)\n\t++emsg_skip;\n\n    eap->nextcmd = NULL;\n    if ((*arg != NUL && *arg != '|' && *arg != '\\n')\n\t\t\t\t  && eval0(arg, &rettv, eap, &evalarg) != FAIL)\n    {\n\tif (!eap->skip)\n\t    returning = do_return(eap, FALSE, TRUE, &rettv);\n\telse\n\t    clear_tv(&rettv);\n    }\n    // It's safer to return also on error.\n    else if (!eap->skip)\n    {\n\t// In return statement, cause_abort should be force_abort.\n\tupdate_force_abort();\n\n\t/*\n\t * Return unless the expression evaluation has been cancelled due to an\n\t * aborting error, an interrupt, or an exception.\n\t */\n\tif (!aborting())\n\t    returning = do_return(eap, FALSE, TRUE, NULL);\n    }\n\n    // When skipping or the return gets pending, advance to the next command\n    // in this line (!returning).  Otherwise, ignore the rest of the line.\n    // Following lines will be ignored by get_func_line().\n    if (returning)\n\teap->nextcmd = NULL;\n    else if (eap->nextcmd == NULL)\t    // no argument\n\tset_nextcmd(eap, arg);\n\n    if (eap->skip)\n\t--emsg_skip;\n    clear_evalarg(&evalarg, eap);\n}\n\n/*\n * \":1,25call func(arg1, arg2)\"\tfunction call.\n */\n    void\nex_call(exarg_T *eap)\n{\n    char_u\t*arg = eap->arg;\n    char_u\t*startarg;\n    char_u\t*name;\n    char_u\t*tofree;\n    int\t\tlen;\n    typval_T\trettv;\n    linenr_T\tlnum;\n    int\t\tdoesrange;\n    int\t\tfailed = FALSE;\n    funcdict_T\tfudi;\n    partial_T\t*partial = NULL;\n    evalarg_T\tevalarg;\n    type_T\t*type = NULL;\n    int\t\tfound_var = FALSE;\n    int\t\tvim9script = in_vim9script();\n\n    fill_evalarg_from_eap(&evalarg, eap, eap->skip);\n    if (eap->skip)\n    {\n\t// trans_function_name() doesn't work well when skipping, use eval0()\n\t// instead to skip to any following command, e.g. for:\n\t//   :if 0 | call dict.foo().bar() | endif\n\t++emsg_skip;\n\tif (eval0(eap->arg, &rettv, eap, &evalarg) != FAIL)\n\t    clear_tv(&rettv);\n\t--emsg_skip;\n\tclear_evalarg(&evalarg, eap);\n\treturn;\n    }\n\n    tofree = trans_function_name(&arg, NULL, eap->skip, TFN_INT,\n\t\t\t      &fudi, &partial, vim9script ? &type : NULL);\n    if (fudi.fd_newkey != NULL)\n    {\n\t// Still need to give an error message for missing key.\n\tsemsg(_(e_key_not_present_in_dictionary), fudi.fd_newkey);\n\tvim_free(fudi.fd_newkey);\n    }\n    if (tofree == NULL)\n\treturn;\n\n    // Increase refcount on dictionary, it could get deleted when evaluating\n    // the arguments.\n    if (fudi.fd_dict != NULL)\n\t++fudi.fd_dict->dv_refcount;\n\n    // If it is the name of a variable of type VAR_FUNC or VAR_PARTIAL use its\n    // contents.  For VAR_PARTIAL get its partial, unless we already have one\n    // from trans_function_name().\n    len = (int)STRLEN(tofree);\n    name = deref_func_name(tofree, &len, partial != NULL ? NULL : &partial,\n\t\t\t\tvim9script && type == NULL ? &type : NULL,\n\t\t\t\t\t\t     FALSE, FALSE, &found_var);\n\n    // Skip white space to allow \":call func ()\".  Not good, but required for\n    // backward compatibility.\n    startarg = skipwhite(arg);\n    if (*startarg != '(')\n    {\n\tsemsg(_(e_missing_parenthesis_str), eap->arg);\n\tgoto end;\n    }\n    if (vim9script && startarg > arg)\n    {\n\tsemsg(_(e_no_white_space_allowed_before_str_str), \"(\", eap->arg);\n\tgoto end;\n    }\n\n    /*\n     * When skipping, evaluate the function once, to find the end of the\n     * arguments.\n     * When the function takes a range, this is discovered after the first\n     * call, and the loop is broken.\n     */\n    if (eap->skip)\n    {\n\t++emsg_skip;\n\tlnum = eap->line2;\t// do it once, also with an invalid range\n    }\n    else\n\tlnum = eap->line1;\n    for ( ; lnum <= eap->line2; ++lnum)\n    {\n\tfuncexe_T funcexe;\n\n\tif (!eap->skip && eap->addr_count > 0)\n\t{\n\t    if (lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// If the function deleted lines or switched to another buffer\n\t\t// the line number may become invalid.\n\t\temsg(_(e_invalid_range));\n\t\tbreak;\n\t    }\n\t    curwin->w_cursor.lnum = lnum;\n\t    curwin->w_cursor.col = 0;\n\t    curwin->w_cursor.coladd = 0;\n\t}\n\targ = startarg;\n\n\tCLEAR_FIELD(funcexe);\n\tfuncexe.fe_firstline = eap->line1;\n\tfuncexe.fe_lastline = eap->line2;\n\tfuncexe.fe_doesrange = &doesrange;\n\tfuncexe.fe_evaluate = !eap->skip;\n\tfuncexe.fe_partial = partial;\n\tfuncexe.fe_selfdict = fudi.fd_dict;\n\tfuncexe.fe_check_type = type;\n\tfuncexe.fe_found_var = found_var;\n\trettv.v_type = VAR_UNKNOWN;\t// clear_tv() uses this\n\tif (get_func_tv(name, -1, &rettv, &arg, &evalarg, &funcexe) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\tif (has_watchexpr())\n\t    dbg_check_breakpoint(eap);\n\n\t// Handle a function returning a Funcref, Dictionary or List.\n\tif (handle_subscript(&arg, NULL, &rettv,\n\t\t\t   eap->skip ? NULL : &EVALARG_EVALUATE, TRUE) == FAIL)\n\t{\n\t    failed = TRUE;\n\t    break;\n\t}\n\n\tclear_tv(&rettv);\n\tif (doesrange || eap->skip)\n\t    break;\n\n\t// Stop when immediately aborting on error, or when an interrupt\n\t// occurred or an exception was thrown but not caught.\n\t// get_func_tv() returned OK, so that the check for trailing\n\t// characters below is executed.\n\tif (aborting())\n\t    break;\n    }\n    if (eap->skip)\n\t--emsg_skip;\n\n    // When inside :try we need to check for following \"| catch\" or \"| endtry\".\n    // Not when there was an error, but do check if an exception was thrown.\n    if ((!aborting() || did_throw)\n\t\t\t\t  && (!failed || eap->cstack->cs_trylevel > 0))\n    {\n\t// Check for trailing illegal characters and a following command.\n\targ = skipwhite(arg);\n\tif (!ends_excmd2(eap->arg, arg))\n\t{\n\t    if (!failed && !aborting())\n\t    {\n\t\temsg_severe = TRUE;\n\t\tsemsg(_(e_trailing_characters_str), arg);\n\t    }\n\t}\n\telse\n\t    set_nextcmd(eap, arg);\n    }\n    // Must be after using \"arg\", it may point into memory cleared here.\n    clear_evalarg(&evalarg, eap);\n\nend:\n    dict_unref(fudi.fd_dict);\n    vim_free(tofree);\n}\n\n/*\n * Return from a function.  Possibly makes the return pending.  Also called\n * for a pending return at the \":endtry\" or after returning from an extra\n * do_cmdline().  \"reanimate\" is used in the latter case.  \"is_cmd\" is set\n * when called due to a \":return\" command.  \"rettv\" may point to a typval_T\n * with the return rettv.  Returns TRUE when the return can be carried out,\n * FALSE when the return gets pending.\n */\n    int\ndo_return(\n    exarg_T\t*eap,\n    int\t\treanimate,\n    int\t\tis_cmd,\n    void\t*rettv)\n{\n    int\t\tidx;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (reanimate)\n\t// Undo the return.\n\tcurrent_funccal->returned = FALSE;\n\n    /*\n     * Cleanup (and inactivate) conditionals, but stop when a try conditional\n     * not in its finally clause (which then is to be executed next) is found.\n     * In this case, make the \":return\" pending for execution at the \":endtry\".\n     * Otherwise, return normally.\n     */\n    idx = cleanup_conditionals(eap->cstack, 0, TRUE);\n    if (idx >= 0)\n    {\n\tcstack->cs_pending[idx] = CSTP_RETURN;\n\n\tif (!is_cmd && !reanimate)\n\t    // A pending return again gets pending.  \"rettv\" points to an\n\t    // allocated variable with the rettv of the original \":return\"'s\n\t    // argument if present or is NULL else.\n\t    cstack->cs_rettv[idx] = rettv;\n\telse\n\t{\n\t    // When undoing a return in order to make it pending, get the stored\n\t    // return rettv.\n\t    if (reanimate)\n\t\trettv = current_funccal->rettv;\n\n\t    if (rettv != NULL)\n\t    {\n\t\t// Store the value of the pending return.\n\t\tif ((cstack->cs_rettv[idx] = alloc_tv()) != NULL)\n\t\t    *(typval_T *)cstack->cs_rettv[idx] = *(typval_T *)rettv;\n\t\telse\n\t\t    emsg(_(e_out_of_memory));\n\t    }\n\t    else\n\t\tcstack->cs_rettv[idx] = NULL;\n\n\t    if (reanimate)\n\t    {\n\t\t// The pending return value could be overwritten by a \":return\"\n\t\t// without argument in a finally clause; reset the default\n\t\t// return value.\n\t\tcurrent_funccal->rettv->v_type = VAR_NUMBER;\n\t\tcurrent_funccal->rettv->vval.v_number = 0;\n\t    }\n\t}\n\treport_make_pending(CSTP_RETURN, rettv);\n    }\n    else\n    {\n\tcurrent_funccal->returned = TRUE;\n\n\t// If the return is carried out now, store the return value.  For\n\t// a return immediately after reanimation, the value is already\n\t// there.\n\tif (!reanimate && rettv != NULL)\n\t{\n\t    clear_tv(current_funccal->rettv);\n\t    *current_funccal->rettv = *(typval_T *)rettv;\n\t    if (!is_cmd)\n\t\tvim_free(rettv);\n\t}\n    }\n\n    return idx < 0;\n}\n\n/*\n * Free the variable with a pending return value.\n */\n    void\ndiscard_pending_return(void *rettv)\n{\n    free_tv((typval_T *)rettv);\n}\n\n/*\n * Generate a return command for producing the value of \"rettv\".  The result\n * is an allocated string.  Used by report_pending() for verbose messages.\n */\n    char_u *\nget_return_cmd(void *rettv)\n{\n    char_u\t*s = NULL;\n    char_u\t*tofree = NULL;\n    char_u\tnumbuf[NUMBUFLEN];\n\n    if (rettv != NULL)\n\ts = echo_string((typval_T *)rettv, &tofree, numbuf, 0);\n    if (s == NULL)\n\ts = (char_u *)\"\";\n\n    STRCPY(IObuff, \":return \");\n    STRNCPY(IObuff + 8, s, IOSIZE - 8);\n    if (STRLEN(s) + 8 >= IOSIZE)\n\tSTRCPY(IObuff + IOSIZE - 4, \"...\");\n    vim_free(tofree);\n    return vim_strsave(IObuff);\n}\n\n/*\n * Get next function line.\n * Called by do_cmdline() to get the next line.\n * Returns allocated string, or NULL for end of function.\n */\n    char_u *\nget_func_line(\n    int\t    c UNUSED,\n    void    *cookie,\n    int\t    indent UNUSED,\n    getline_opt_T options UNUSED)\n{\n    funccall_T\t*fcp = (funccall_T *)cookie;\n    ufunc_T\t*fp = fcp->func;\n    char_u\t*retval;\n    garray_T\t*gap;  // growarray with function lines\n\n    // If breakpoints have been added/deleted need to check for it.\n    if (fcp->dbg_tick != debug_tick)\n    {\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n#ifdef FEAT_PROFILE\n    if (do_profiling == PROF_YES)\n\tfunc_line_end(cookie);\n#endif\n\n    gap = &fp->uf_lines;\n    if (((fp->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned)\n\tretval = NULL;\n    else\n    {\n\t// Skip NULL lines (continuation lines).\n\twhile (fcp->linenr < gap->ga_len\n\t\t\t  && ((char_u **)(gap->ga_data))[fcp->linenr] == NULL)\n\t    ++fcp->linenr;\n\tif (fcp->linenr >= gap->ga_len)\n\t    retval = NULL;\n\telse\n\t{\n\t    retval = vim_strsave(((char_u **)(gap->ga_data))[fcp->linenr++]);\n\t    SOURCING_LNUM = fcp->linenr;\n#ifdef FEAT_PROFILE\n\t    if (do_profiling == PROF_YES)\n\t\tfunc_line_start(cookie, SOURCING_LNUM);\n#endif\n\t}\n    }\n\n    // Did we encounter a breakpoint?\n    if (fcp->breakpoint != 0 && fcp->breakpoint <= SOURCING_LNUM)\n    {\n\tdbg_breakpoint(fp->uf_name, SOURCING_LNUM);\n\t// Find next breakpoint.\n\tfcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,\n\t\t\t\t\t\t\t       SOURCING_LNUM);\n\tfcp->dbg_tick = debug_tick;\n    }\n\n    return retval;\n}\n\n/*\n * Return TRUE if the currently active function should be ended, because a\n * return was encountered or an error occurred.  Used inside a \":while\".\n */\n    int\nfunc_has_ended(void *cookie)\n{\n    funccall_T  *fcp = (funccall_T *)cookie;\n\n    // Ignore the \"abort\" flag if the abortion behavior has been changed due to\n    // an error inside a try conditional.\n    return (((fcp->func->uf_flags & FC_ABORT) && did_emsg && !aborted_in_try())\n\t    || fcp->returned);\n}\n\n/*\n * return TRUE if cookie indicates a function which \"abort\"s on errors.\n */\n    int\nfunc_has_abort(\n    void    *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_flags & FC_ABORT;\n}\n\n\n/*\n * Turn \"dict.Func\" into a partial for \"Func\" bound to \"dict\".\n * Don't do this when \"Func\" is already a partial that was bound\n * explicitly (pt_auto is FALSE).\n * Changes \"rettv\" in-place.\n * Returns the updated \"selfdict_in\".\n */\n    dict_T *\nmake_partial(dict_T *selfdict_in, typval_T *rettv)\n{\n    char_u\t*fname;\n    ufunc_T\t*fp = NULL;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    int\t\terror;\n    dict_T\t*selfdict = selfdict_in;\n\n    if (rettv->v_type == VAR_PARTIAL  && rettv->vval.v_partial != NULL\n\t\t\t\t     && rettv->vval.v_partial->pt_func != NULL)\n\tfp = rettv->vval.v_partial->pt_func;\n    else\n    {\n\tfname = rettv->v_type == VAR_FUNC ? rettv->vval.v_string\n\t\t\t\t\t : rettv->vval.v_partial == NULL ? NULL\n\t\t\t\t\t      : rettv->vval.v_partial->pt_name;\n\tif (fname == NULL)\n\t{\n\t    // There is no point binding a dict to a NULL function, just create\n\t    // a function reference.\n\t    rettv->v_type = VAR_FUNC;\n\t    rettv->vval.v_string = NULL;\n\t}\n\telse\n\t{\n\t    char_u\t*tofree = NULL;\n\n\t    // Translate \"s:func\" to the stored function name.\n\t    fname = fname_trans_sid(fname, fname_buf, &tofree, &error);\n\t    fp = find_func(fname, FALSE);\n\t    vim_free(tofree);\n\t}\n    }\n\n    if (fp != NULL && (fp->uf_flags & FC_DICT))\n    {\n\tpartial_T\t*pt = ALLOC_CLEAR_ONE(partial_T);\n\n\tif (pt != NULL)\n\t{\n\t    pt->pt_refcount = 1;\n\t    pt->pt_dict = selfdict;\n\t    pt->pt_auto = TRUE;\n\t    selfdict = NULL;\n\t    if (rettv->v_type == VAR_FUNC)\n\t    {\n\t\t// Just a function: Take over the function name and use\n\t\t// selfdict.\n\t\tpt->pt_name = rettv->vval.v_string;\n\t    }\n\t    else\n\t    {\n\t\tpartial_T\t*ret_pt = rettv->vval.v_partial;\n\t\tint\t\ti;\n\n\t\t// Partial: copy the function name, use selfdict and copy\n\t\t// args.  Can't take over name or args, the partial might\n\t\t// be referenced elsewhere.\n\t\tif (ret_pt->pt_name != NULL)\n\t\t{\n\t\t    pt->pt_name = vim_strsave(ret_pt->pt_name);\n\t\t    func_ref(pt->pt_name);\n\t\t}\n\t\telse\n\t\t{\n\t\t    pt->pt_func = ret_pt->pt_func;\n\t\t    func_ptr_ref(pt->pt_func);\n\t\t}\n\t\tif (ret_pt->pt_argc > 0)\n\t\t{\n\t\t    pt->pt_argv = ALLOC_MULT(typval_T, ret_pt->pt_argc);\n\t\t    if (pt->pt_argv == NULL)\n\t\t\t// out of memory: drop the arguments\n\t\t\tpt->pt_argc = 0;\n\t\t    else\n\t\t    {\n\t\t\tpt->pt_argc = ret_pt->pt_argc;\n\t\t\tfor (i = 0; i < pt->pt_argc; i++)\n\t\t\t    copy_tv(&ret_pt->pt_argv[i], &pt->pt_argv[i]);\n\t\t    }\n\t\t}\n\t\tpartial_unref(ret_pt);\n\t    }\n\t    rettv->v_type = VAR_PARTIAL;\n\t    rettv->vval.v_partial = pt;\n\t}\n    }\n    return selfdict;\n}\n\n/*\n * Return the name of the executed function.\n */\n    char_u *\nfunc_name(void *cookie)\n{\n    return ((funccall_T *)cookie)->func->uf_name;\n}\n\n/*\n * Return the address holding the next breakpoint line for a funccall cookie.\n */\n    linenr_T *\nfunc_breakpoint(void *cookie)\n{\n    return &((funccall_T *)cookie)->breakpoint;\n}\n\n/*\n * Return the address holding the debug tick for a funccall cookie.\n */\n    int *\nfunc_dbg_tick(void *cookie)\n{\n    return &((funccall_T *)cookie)->dbg_tick;\n}\n\n/*\n * Return the nesting level for a funccall cookie.\n */\n    int\nfunc_level(void *cookie)\n{\n    return ((funccall_T *)cookie)->level;\n}\n\n/*\n * Return TRUE when a function was ended by a \":return\" command.\n */\n    int\ncurrent_func_returned(void)\n{\n    return current_funccal->returned;\n}\n\n    int\nfree_unref_funccal(int copyID, int testing)\n{\n    int\t\tdid_free = FALSE;\n    int\t\tdid_free_funccal = FALSE;\n    funccall_T\t*fc, **pfc;\n\n    for (pfc = &previous_funccal; *pfc != NULL; )\n    {\n\tif (can_free_funccal(*pfc, copyID))\n\t{\n\t    fc = *pfc;\n\t    *pfc = fc->caller;\n\t    free_funccal_contents(fc);\n\t    did_free = TRUE;\n\t    did_free_funccal = TRUE;\n\t}\n\telse\n\t    pfc = &(*pfc)->caller;\n    }\n    if (did_free_funccal)\n\t// When a funccal was freed some more items might be garbage\n\t// collected, so run again.\n\t(void)garbage_collect(testing);\n\n    return did_free;\n}\n\n/*\n * Get function call environment based on backtrace debug level\n */\n    static funccall_T *\nget_funccal(void)\n{\n    int\t\ti;\n    funccall_T\t*funccal;\n    funccall_T\t*temp_funccal;\n\n    funccal = current_funccal;\n    if (debug_backtrace_level > 0)\n    {\n\tfor (i = 0; i < debug_backtrace_level; i++)\n\t{\n\t    temp_funccal = funccal->caller;\n\t    if (temp_funccal)\n\t\tfunccal = temp_funccal;\n\t    else\n\t\t// backtrace level overflow. reset to max\n\t\tdebug_backtrace_level = i;\n\t}\n    }\n    return funccal;\n}\n\n/*\n * Return the hashtable used for local variables in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_local_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars.dv_hashtab;\n}\n\n/*\n * Return the l: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_local_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_vars_var;\n}\n\n/*\n * Return the hashtable used for argument in the current funccal.\n * Return NULL if there is no current funccal.\n */\n    hashtab_T *\nget_funccal_args_ht()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars.dv_hashtab;\n}\n\n/*\n * Return the a: scope variable.\n * Return NULL if there is no current funccal.\n */\n    dictitem_T *\nget_funccal_args_var()\n{\n    if (current_funccal == NULL || current_funccal->l_vars.dv_refcount == 0)\n\treturn NULL;\n    return &get_funccal()->l_avars_var;\n}\n\n/*\n * List function variables, if there is a function.\n */\n    void\nlist_func_vars(int *first)\n{\n    if (current_funccal != NULL && current_funccal->l_vars.dv_refcount > 0)\n\tlist_hashtable_vars(&current_funccal->l_vars.dv_hashtab,\n\t\t\t\t\t\t\t   \"l:\", FALSE, first);\n}\n\n/*\n * If \"ht\" is the hashtable for local variables in the current funccal, return\n * the dict that contains it.\n * Otherwise return NULL.\n */\n    dict_T *\nget_current_funccal_dict(hashtab_T *ht)\n{\n    if (current_funccal != NULL\n\t    && ht == &current_funccal->l_vars.dv_hashtab)\n\treturn &current_funccal->l_vars;\n    return NULL;\n}\n\n/*\n * Search hashitem in parent scope.\n */\n    hashitem_T *\nfind_hi_in_scoped_ht(char_u *name, hashtab_T **pht)\n{\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    hashitem_T\t*hi = NULL;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n      return NULL;\n\n    // Search in parent scope, which can be referenced from a lambda.\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal != NULL)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    hi = hash_find(ht, varname);\n\t    if (!HASHITEM_EMPTY(hi))\n\t    {\n\t\t*pht = ht;\n\t\tbreak;\n\t    }\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return hi;\n}\n\n/*\n * Search variable in parent scope.\n */\n    dictitem_T *\nfind_var_in_scoped_ht(char_u *name, int no_autoload)\n{\n    dictitem_T\t*v = NULL;\n    funccall_T\t*old_current_funccal = current_funccal;\n    hashtab_T\t*ht;\n    char_u\t*varname;\n\n    if (current_funccal == NULL || current_funccal->func->uf_scoped == NULL)\n\treturn NULL;\n\n    // Search in parent scope which is possible to reference from lambda\n    current_funccal = current_funccal->func->uf_scoped;\n    while (current_funccal)\n    {\n\tht = find_var_ht(name, &varname);\n\tif (ht != NULL && *varname != NUL)\n\t{\n\t    v = find_var_in_ht(ht, *name, varname, no_autoload);\n\t    if (v != NULL)\n\t\tbreak;\n\t}\n\tif (current_funccal == current_funccal->func->uf_scoped)\n\t    break;\n\tcurrent_funccal = current_funccal->func->uf_scoped;\n    }\n    current_funccal = old_current_funccal;\n\n    return v;\n}\n\n/*\n * Set \"copyID + 1\" in previous_funccal and callers.\n */\n    int\nset_ref_in_previous_funccal(int copyID)\n{\n    funccall_T\t*fc;\n\n    for (fc = previous_funccal; fc != NULL; fc = fc->caller)\n    {\n\tfc->fc_copyID = copyID + 1;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID + 1, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID + 1, NULL))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n    static int\nset_ref_in_funccal(funccall_T *fc, int copyID)\n{\n    if (fc->fc_copyID != copyID)\n    {\n\tfc->fc_copyID = copyID;\n\tif (set_ref_in_ht(&fc->l_vars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_ht(&fc->l_avars.dv_hashtab, copyID, NULL)\n\t\t|| set_ref_in_list_items(&fc->l_varlist, copyID, NULL)\n\t\t|| set_ref_in_func(NULL, fc->func, copyID))\n\t    return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all local vars and arguments in the call stack.\n */\n    int\nset_ref_in_call_stack(int copyID)\n{\n    funccall_T\t\t*fc;\n    funccal_entry_T\t*entry;\n\n    for (fc = current_funccal; fc != NULL; fc = fc->caller)\n\tif (set_ref_in_funccal(fc, copyID))\n\t    return TRUE;\n\n    // Also go through the funccal_stack.\n    for (entry = funccal_stack; entry != NULL; entry = entry->next)\n\tfor (fc = entry->top_funccal; fc != NULL; fc = fc->caller)\n\t    if (set_ref_in_funccal(fc, copyID))\n\t\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all functions available by name.\n */\n    int\nset_ref_in_functions(int copyID)\n{\n    int\t\ttodo;\n    hashitem_T\t*hi = NULL;\n    ufunc_T\t*fp;\n\n    todo = (int)func_hashtab.ht_used;\n    for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi)\n    {\n\tif (!HASHITEM_EMPTY(hi))\n\t{\n\t    --todo;\n\t    fp = HI2UF(hi);\n\t    if (!func_name_refcount(fp->uf_name)\n\t\t\t\t\t  && set_ref_in_func(NULL, fp, copyID))\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Set \"copyID\" in all function arguments.\n */\n    int\nset_ref_in_func_args(int copyID)\n{\n    int i;\n\n    for (i = 0; i < funcargs.ga_len; ++i)\n\tif (set_ref_in_item(((typval_T **)funcargs.ga_data)[i],\n\t\t\t\t\t\t\t  copyID, NULL, NULL))\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Mark all lists and dicts referenced through function \"name\" with \"copyID\".\n * Returns TRUE if setting references failed somehow.\n */\n    int\nset_ref_in_func(char_u *name, ufunc_T *fp_in, int copyID)\n{\n    ufunc_T\t*fp = fp_in;\n    funccall_T\t*fc;\n    int\t\terror = FCERR_NONE;\n    char_u\tfname_buf[FLEN_FIXED + 1];\n    char_u\t*tofree = NULL;\n    char_u\t*fname;\n    int\t\tabort = FALSE;\n\n    if (name == NULL && fp_in == NULL)\n\treturn FALSE;\n\n    if (fp_in == NULL)\n    {\n\tfname = fname_trans_sid(name, fname_buf, &tofree, &error);\n\tfp = find_func(fname, FALSE);\n    }\n    if (fp != NULL)\n    {\n\tfor (fc = fp->uf_scoped; fc != NULL; fc = fc->func->uf_scoped)\n\t    abort = abort || set_ref_in_funccal(fc, copyID);\n    }\n\n    vim_free(tofree);\n    return abort;\n}\n\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/eval.c", "src/proto/eval.pro", "src/testdir/test_vim9_script.vim", "src/userfunc.c", "src/version.c"], "buggy_code_start_loc": [356, 11, 1560, 1375, 733], "buggy_code_end_loc": [2341, 39, 1560, 1614, 733], "fixing_code_start_loc": [357, 12, 1561, 1374, 734], "fixing_code_end_loc": [2358, 38, 1574, 1598, 736], "type": "CWE-416", "message": "Use After Free in GitHub repository vim/vim prior to 9.0.0225.", "other": {"cve": {"id": "CVE-2022-2889", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-19T13:15:08.423", "lastModified": "2023-05-03T12:16:06.983", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository vim/vim prior to 9.0.0225."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio GitHub vim/vim versiones anteriores a 9.0.0225."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0225", "matchCriteriaId": "3490901E-1154-4F88-8DD1-1D2D68D92390"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/d1ac9817-825d-49ce-b514-1d5b12b6bdaa", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/C72HDIMR3KTTAO7QGTXWUMPBNFUFIBRD/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/91c7cbfe31bbef57d5fcf7d76989fc159f73ef15"}}