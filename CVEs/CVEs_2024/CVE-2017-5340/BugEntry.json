{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | Zend Engine                                                          |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1998-2016 Zend Technologies Ltd. (http://www.zend.com) |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 2.00 of the Zend license,     |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.zend.com/license/2_00.txt.                                |\n   | If you did not receive a copy of the Zend license and are unable to  |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@zend.com so we can mail you a copy immediately.              |\n   +----------------------------------------------------------------------+\n   | Authors: Andi Gutmans <andi@zend.com>                                |\n   |          Zeev Suraski <zeev@zend.com>                                |\n   |          Dmitry Stogov <dmitry@zend.com>                             |\n   +----------------------------------------------------------------------+\n*/\n\n/* $Id$ */\n\n#include \"zend.h\"\n#include \"zend_globals.h\"\n#include \"zend_variables.h\"\n\n#define HT_DEBUG 0\n#if HT_DEBUG\n# define HT_ASSERT(c) ZEND_ASSERT(c)\n#else\n# define HT_ASSERT(c)\n#endif\n\n#define HT_POISONED_PTR ((HashTable *) (intptr_t) -1)\n\n#if ZEND_DEBUG\n/*\n#define HASH_MASK_CONSISTENCY\t0xc0\n*/\n#define HT_OK\t\t\t\t\t0x00\n#define HT_IS_DESTROYING\t\t0x40\n#define HT_DESTROYED\t\t\t0x80\n#define HT_CLEANING\t\t\t\t0xc0\n\nstatic void _zend_is_inconsistent(const HashTable *ht, const char *file, int line)\n{\n\tif ((ht->u.flags & HASH_MASK_CONSISTENCY) == HT_OK) {\n\t\treturn;\n\t}\n\tswitch ((ht->u.flags & HASH_MASK_CONSISTENCY)) {\n\t\tcase HT_IS_DESTROYING:\n\t\t\tzend_output_debug_string(1, \"%s(%d) : ht=%p is being destroyed\", file, line, ht);\n\t\t\tbreak;\n\t\tcase HT_DESTROYED:\n\t\t\tzend_output_debug_string(1, \"%s(%d) : ht=%p is already destroyed\", file, line, ht);\n\t\t\tbreak;\n\t\tcase HT_CLEANING:\n\t\t\tzend_output_debug_string(1, \"%s(%d) : ht=%p is being cleaned\", file, line, ht);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzend_output_debug_string(1, \"%s(%d) : ht=%p is inconsistent\", file, line, ht);\n\t\t\tbreak;\n\t}\n\tzend_bailout();\n}\n#define IS_CONSISTENT(a) _zend_is_inconsistent(a, __FILE__, __LINE__);\n#define SET_INCONSISTENT(n) do { \\\n\t\t(ht)->u.flags |= n; \\\n\t} while (0)\n#else\n#define IS_CONSISTENT(a)\n#define SET_INCONSISTENT(n)\n#endif\n\n#define HASH_PROTECT_RECURSION(ht)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif ((ht)->u.flags & HASH_FLAG_APPLY_PROTECTION) {\t\t\t\t\t\t\t\t\t\\\n\t\tif (((ht)->u.flags & ZEND_HASH_APPLY_COUNT_MASK) >= (3 << 8)) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tzend_error_noreturn(E_ERROR, \"Nesting level too deep - recursive dependency?\");\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tZEND_HASH_INC_APPLY_COUNT(ht);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define HASH_UNPROTECT_RECURSION(ht)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif ((ht)->u.flags & HASH_FLAG_APPLY_PROTECTION) {\t\t\t\t\t\t\t\t\t\\\n\t\tZEND_HASH_DEC_APPLY_COUNT(ht);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define ZEND_HASH_IF_FULL_DO_RESIZE(ht)\t\t\t\t\\\n\tif ((ht)->nNumUsed >= (ht)->nTableSize) {\t\t\\\n\t\tzend_hash_do_resize(ht);\t\t\t\t\t\\\n\t}\n\nstatic void ZEND_FASTCALL zend_hash_do_resize(HashTable *ht);\n\nstatic uint32_t zend_always_inline zend_hash_check_size(uint32_t nSize)\n{\n#if defined(ZEND_WIN32)\n\tunsigned long index;\n#endif\n\n\t/* Use big enough power of 2 */\n\t/* size should be between HT_MIN_SIZE and HT_MAX_SIZE */\n\tif (nSize < HT_MIN_SIZE) {\n\t\tnSize = HT_MIN_SIZE;\n\t} else if (UNEXPECTED(nSize >= HT_MAX_SIZE)) {\n\t\tzend_error_noreturn(E_ERROR, \"Possible integer overflow in memory allocation (%zu * %zu + %zu)\", nSize, sizeof(Bucket), sizeof(Bucket));\n\t}\n\n#if defined(ZEND_WIN32)\n\tif (BitScanReverse(&index, nSize - 1)) {\n\t\treturn 0x2 << ((31 - index) ^ 0x1f);\n\t} else {\n\t\t/* nSize is ensured to be in the valid range, fall back to it\n\t\t   rather than using an undefined bis scan result. */\n\t\treturn nSize;\n\t}\n#elif (defined(__GNUC__) || __has_builtin(__builtin_clz))  && defined(PHP_HAVE_BUILTIN_CLZ)\n\treturn 0x2 << (__builtin_clz(nSize - 1) ^ 0x1f);\n#else\n\tnSize -= 1;\n\tnSize |= (nSize >> 1);\n\tnSize |= (nSize >> 2);\n\tnSize |= (nSize >> 4);\n\tnSize |= (nSize >> 8);\n\tnSize |= (nSize >> 16);\n\treturn nSize + 1;\n#endif\n}\n\nstatic void zend_always_inline zend_hash_real_init_ex(HashTable *ht, int packed)\n{\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tZEND_ASSERT(!((ht)->u.flags & HASH_FLAG_INITIALIZED));\n\tif (packed) {\n\t\tHT_SET_DATA_ADDR(ht, pemalloc(HT_SIZE(ht), (ht)->u.flags & HASH_FLAG_PERSISTENT));\n\t\t(ht)->u.flags |= HASH_FLAG_INITIALIZED | HASH_FLAG_PACKED;\n\t\tHT_HASH_RESET_PACKED(ht);\n\t} else {\n\t\t(ht)->nTableMask = -(ht)->nTableSize;\n\t\tHT_SET_DATA_ADDR(ht, pemalloc(HT_SIZE(ht), (ht)->u.flags & HASH_FLAG_PERSISTENT));\n\t\t(ht)->u.flags |= HASH_FLAG_INITIALIZED;\n\t\tif (EXPECTED(ht->nTableMask == -8)) {\n\t\t\tBucket *arData = ht->arData;\n\n\t\t\tHT_HASH_EX(arData, -8) = -1;\n\t\t\tHT_HASH_EX(arData, -7) = -1;\n\t\t\tHT_HASH_EX(arData, -6) = -1;\n\t\t\tHT_HASH_EX(arData, -5) = -1;\n\t\t\tHT_HASH_EX(arData, -4) = -1;\n\t\t\tHT_HASH_EX(arData, -3) = -1;\n\t\t\tHT_HASH_EX(arData, -2) = -1;\n\t\t\tHT_HASH_EX(arData, -1) = -1;\n\t\t} else {\n\t\t\tHT_HASH_RESET(ht);\n\t\t}\n\t}\n}\n\nstatic void zend_always_inline zend_hash_check_init(HashTable *ht, int packed)\n{\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tif (UNEXPECTED(!((ht)->u.flags & HASH_FLAG_INITIALIZED))) {\n\t\tzend_hash_real_init_ex(ht, packed);\n\t}\n}\n\n#define CHECK_INIT(ht, packed) \\\n\tzend_hash_check_init(ht, packed)\n\nstatic const uint32_t uninitialized_bucket[-HT_MIN_MASK] =\n\t{HT_INVALID_IDX, HT_INVALID_IDX};\n\nZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n}\n\nstatic void ZEND_FASTCALL zend_hash_packed_grow(HashTable *ht)\n{\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tif (ht->nTableSize >= HT_MAX_SIZE) {\n\t\tzend_error_noreturn(E_ERROR, \"Possible integer overflow in memory allocation (%zu * %zu + %zu)\", ht->nTableSize * 2, sizeof(Bucket), sizeof(Bucket));\n\t}\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tht->nTableSize += ht->nTableSize;\n\tHT_SET_DATA_ADDR(ht, perealloc2(HT_GET_DATA_ADDR(ht), HT_SIZE(ht), HT_USED_SIZE(ht), ht->u.flags & HASH_FLAG_PERSISTENT));\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_real_init(HashTable *ht, zend_bool packed)\n{\n\tIS_CONSISTENT(ht);\n\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tzend_hash_real_init_ex(ht, packed);\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_packed_to_hash(HashTable *ht)\n{\n\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\tBucket *old_buckets = ht->arData;\n\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tht->u.flags &= ~HASH_FLAG_PACKED;\n\tnew_data = pemalloc(HT_SIZE_EX(ht->nTableSize, -ht->nTableSize), (ht)->u.flags & HASH_FLAG_PERSISTENT);\n\tht->nTableMask = -ht->nTableSize;\n\tHT_SET_DATA_ADDR(ht, new_data);\n\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\tpefree(old_data, (ht)->u.flags & HASH_FLAG_PERSISTENT);\n\tzend_hash_rehash(ht);\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_to_packed(HashTable *ht)\n{\n\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\tBucket *old_buckets = ht->arData;\n\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tnew_data = pemalloc(HT_SIZE_EX(ht->nTableSize, HT_MIN_MASK), (ht)->u.flags & HASH_FLAG_PERSISTENT);\n\tht->u.flags |= HASH_FLAG_PACKED | HASH_FLAG_STATIC_KEYS;\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, new_data);\n\tHT_HASH_RESET_PACKED(ht);\n\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\tpefree(old_data, (ht)->u.flags & HASH_FLAG_PERSISTENT);\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n}\n\nZEND_API void ZEND_FASTCALL _zend_hash_init_ex(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent, zend_bool bApplyProtection ZEND_FILE_LINE_DC)\n{\n\t_zend_hash_init(ht, nSize, pDestructor, persistent ZEND_FILE_LINE_RELAY_CC);\n\tif (!bApplyProtection) {\n\t\tht->u.flags &= ~HASH_FLAG_APPLY_PROTECTION;\n\t}\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_extend(HashTable *ht, uint32_t nSize, zend_bool packed)\n{\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tif (nSize == 0) return;\n\tif (UNEXPECTED(!((ht)->u.flags & HASH_FLAG_INITIALIZED))) {\n\t\tif (nSize > ht->nTableSize) {\n\t\t\tht->nTableSize = zend_hash_check_size(nSize);\n\t\t}\n\t\tzend_hash_check_init(ht, packed);\n\t} else {\n\t\tif (packed) {\n\t\t\tZEND_ASSERT(ht->u.flags & HASH_FLAG_PACKED);\n\t\t\tif (nSize > ht->nTableSize) {\n\t\t\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t\t\tht->nTableSize = zend_hash_check_size(nSize);\n\t\t\t\tHT_SET_DATA_ADDR(ht, perealloc2(HT_GET_DATA_ADDR(ht), HT_SIZE(ht), HT_USED_SIZE(ht), ht->u.flags & HASH_FLAG_PERSISTENT));\n\t\t\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t\t\t}\n\t\t} else {\n\t\t\tZEND_ASSERT(!(ht->u.flags & HASH_FLAG_PACKED));\n\t\t\tif (nSize > ht->nTableSize) {\n\t\t\t\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\t\t\t\tBucket *old_buckets = ht->arData;\n\t\t\t\tnSize = zend_hash_check_size(nSize);\n\t\t\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t\t\tnew_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\t\t\tht->nTableSize = nSize;\n\t\t\t\tht->nTableMask = -ht->nTableSize;\n\t\t\t\tHT_SET_DATA_ADDR(ht, new_data);\n\t\t\t\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\t\t\t\tpefree(old_data, ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\t\t\tzend_hash_rehash(ht);\n\t\t\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic uint32_t zend_array_recalc_elements(HashTable *ht)\n{\n       zval *val;\n       uint32_t num = ht->nNumOfElements;\n\n\t   ZEND_HASH_FOREACH_VAL(ht, val) {\n\t\t   if (Z_TYPE_P(val) == IS_UNDEF) continue;\n\t\t   if (Z_TYPE_P(val) == IS_INDIRECT) {\n\t\t\t   if (UNEXPECTED(Z_TYPE_P(Z_INDIRECT_P(val)) == IS_UNDEF)) {\n\t\t\t\t   num--;\n\t\t\t   }\n\t\t   }\n       } ZEND_HASH_FOREACH_END();\n       return num;\n}\n/* }}} */\n\nZEND_API uint32_t zend_array_count(HashTable *ht)\n{\n\tuint32_t num;\n\tif (UNEXPECTED(ht->u.v.flags & HASH_FLAG_HAS_EMPTY_IND)) {\n\t\tnum = zend_array_recalc_elements(ht);\n\t\tif (UNEXPECTED(ht->nNumOfElements == num)) {\n\t\t\tht->u.v.flags &= ~HASH_FLAG_HAS_EMPTY_IND;\n\t\t}\n\t} else if (UNEXPECTED(ht == &EG(symbol_table))) {\n\t\tnum = zend_array_recalc_elements(ht);\n\t} else {\n\t\tnum = zend_hash_num_elements(ht);\n\t}\n\treturn num;\n}\n/* }}} */\n\nZEND_API void ZEND_FASTCALL zend_hash_set_apply_protection(HashTable *ht, zend_bool bApplyProtection)\n{\n\tif (bApplyProtection) {\n\t\tht->u.flags |= HASH_FLAG_APPLY_PROTECTION;\n\t} else {\n\t\tht->u.flags &= ~HASH_FLAG_APPLY_PROTECTION;\n\t}\n}\n\nZEND_API uint32_t ZEND_FASTCALL zend_hash_iterator_add(HashTable *ht, HashPosition pos)\n{\n\tHashTableIterator *iter = EG(ht_iterators);\n\tHashTableIterator *end  = iter + EG(ht_iterators_count);\n\tuint32_t idx;\n\n\tif (EXPECTED(ht->u.v.nIteratorsCount != 255)) {\n\t\tht->u.v.nIteratorsCount++;\n\t}\n\twhile (iter != end) {\n\t\tif (iter->ht == NULL) {\n\t\t\titer->ht = ht;\n\t\t\titer->pos = pos;\n\t\t\tidx = iter - EG(ht_iterators);\n\t\t\tif (idx + 1 > EG(ht_iterators_used)) {\n\t\t\t\tEG(ht_iterators_used) = idx + 1;\n\t\t\t}\n\t\t\treturn idx;\n\t\t}\n\t\titer++;\n\t}\n\tif (EG(ht_iterators) == EG(ht_iterators_slots)) {\n\t\tEG(ht_iterators) = emalloc(sizeof(HashTableIterator) * (EG(ht_iterators_count) + 8));\n\t\tmemcpy(EG(ht_iterators), EG(ht_iterators_slots), sizeof(HashTableIterator) * EG(ht_iterators_count));\n\t} else {\n\t\tEG(ht_iterators) = erealloc(EG(ht_iterators), sizeof(HashTableIterator) * (EG(ht_iterators_count) + 8));\n\t}\n\titer = EG(ht_iterators) + EG(ht_iterators_count);\n\tEG(ht_iterators_count) += 8;\n\titer->ht = ht;\n\titer->pos = pos;\n\tmemset(iter + 1, 0, sizeof(HashTableIterator) * 7);\n\tidx = iter - EG(ht_iterators);\n\tEG(ht_iterators_used) = idx + 1;\n\treturn idx;\n}\n\nZEND_API HashPosition ZEND_FASTCALL zend_hash_iterator_pos(uint32_t idx, HashTable *ht)\n{\n\tHashTableIterator *iter = EG(ht_iterators) + idx;\n\n\tZEND_ASSERT(idx != (uint32_t)-1);\n\tif (iter->pos == HT_INVALID_IDX) {\n\t\treturn HT_INVALID_IDX;\n\t} else if (UNEXPECTED(iter->ht != ht)) {\n\t\tif (EXPECTED(iter->ht) && EXPECTED(iter->ht != HT_POISONED_PTR)\n\t\t\t\t&& EXPECTED(iter->ht->u.v.nIteratorsCount != 255)) {\n\t\t\titer->ht->u.v.nIteratorsCount--;\n\t\t}\n\t\tif (EXPECTED(ht->u.v.nIteratorsCount != 255)) {\n\t\t\tht->u.v.nIteratorsCount++;\n\t\t}\n\t\titer->ht = ht;\n\t\titer->pos = ht->nInternalPointer;\n\t}\n\treturn iter->pos;\n}\n\nZEND_API HashPosition ZEND_FASTCALL zend_hash_iterator_pos_ex(uint32_t idx, zval *array)\n{\n\tHashTable *ht = Z_ARRVAL_P(array);\n\tHashTableIterator *iter = EG(ht_iterators) + idx;\n\n\tZEND_ASSERT(idx != (uint32_t)-1);\n\tif (iter->pos == HT_INVALID_IDX) {\n\t\treturn HT_INVALID_IDX;\n\t} else if (UNEXPECTED(iter->ht != ht)) {\n\t\tif (EXPECTED(iter->ht) && EXPECTED(iter->ht != HT_POISONED_PTR)\n\t\t\t\t&& EXPECTED(iter->ht->u.v.nIteratorsCount != 255)) {\n\t\t\titer->ht->u.v.nIteratorsCount--;\n\t\t}\n\t\tSEPARATE_ARRAY(array);\n\t\tht = Z_ARRVAL_P(array);\n\t\tif (EXPECTED(ht->u.v.nIteratorsCount != 255)) {\n\t\t\tht->u.v.nIteratorsCount++;\n\t\t}\n\t\titer->ht = ht;\n\t\titer->pos = ht->nInternalPointer;\n\t}\n\treturn iter->pos;\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_iterator_del(uint32_t idx)\n{\n\tHashTableIterator *iter = EG(ht_iterators) + idx;\n\n\tZEND_ASSERT(idx != (uint32_t)-1);\n\n\tif (EXPECTED(iter->ht) && EXPECTED(iter->ht != HT_POISONED_PTR)\n\t\t\t&& EXPECTED(iter->ht->u.v.nIteratorsCount != 255)) {\n\t\titer->ht->u.v.nIteratorsCount--;\n\t}\n\titer->ht = NULL;\n\n\tif (idx == EG(ht_iterators_used) - 1) {\n\t\twhile (idx > 0 && EG(ht_iterators)[idx - 1].ht == NULL) {\n\t\t\tidx--;\n\t\t}\n\t\tEG(ht_iterators_used) = idx;\n\t}\n}\n\nstatic zend_never_inline void ZEND_FASTCALL _zend_hash_iterators_remove(HashTable *ht)\n{\n\tHashTableIterator *iter = EG(ht_iterators);\n\tHashTableIterator *end  = iter + EG(ht_iterators_used);\n\n\twhile (iter != end) {\n\t\tif (iter->ht == ht) {\n\t\t\titer->ht = HT_POISONED_PTR;\n\t\t}\n\t\titer++;\n\t}\n}\n\nstatic zend_always_inline void zend_hash_iterators_remove(HashTable *ht)\n{\n\tif (UNEXPECTED(ht->u.v.nIteratorsCount)) {\n\t\t_zend_hash_iterators_remove(ht);\n\t}\n}\n\nZEND_API HashPosition ZEND_FASTCALL zend_hash_iterators_lower_pos(HashTable *ht, HashPosition start)\n{\n\tHashTableIterator *iter = EG(ht_iterators);\n\tHashTableIterator *end  = iter + EG(ht_iterators_used);\n\tHashPosition res = HT_INVALID_IDX;\n\n\twhile (iter != end) {\n\t\tif (iter->ht == ht) {\n\t\t\tif (iter->pos >= start && iter->pos < res) {\n\t\t\t\tres = iter->pos;\n\t\t\t}\n\t\t}\n\t\titer++;\n\t}\n\treturn res;\n}\n\nZEND_API void ZEND_FASTCALL _zend_hash_iterators_update(HashTable *ht, HashPosition from, HashPosition to)\n{\n\tHashTableIterator *iter = EG(ht_iterators);\n\tHashTableIterator *end  = iter + EG(ht_iterators_used);\n\n\twhile (iter != end) {\n\t\tif (iter->ht == ht && iter->pos == from) {\n\t\t\titer->pos = to;\n\t\t}\n\t\titer++;\n\t}\n}\n\nstatic zend_always_inline Bucket *zend_hash_find_bucket(const HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p, *arData;\n\n\th = zend_string_hash_val(key);\n\tarData = ht->arData;\n\tnIndex = h | ht->nTableMask;\n\tidx = HT_HASH_EX(arData, nIndex);\n\twhile (EXPECTED(idx != HT_INVALID_IDX)) {\n\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);\n\t\tif (EXPECTED(p->key == key)) { /* check for the same interned string */\n\t\t\treturn p;\n\t\t} else if (EXPECTED(p->h == h) &&\n\t\t     EXPECTED(p->key) &&\n\t\t     EXPECTED(ZSTR_LEN(p->key) == ZSTR_LEN(key)) &&\n\t\t     EXPECTED(memcmp(ZSTR_VAL(p->key), ZSTR_VAL(key), ZSTR_LEN(key)) == 0)) {\n\t\t\treturn p;\n\t\t}\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn NULL;\n}\n\nstatic zend_always_inline Bucket *zend_hash_str_find_bucket(const HashTable *ht, const char *str, size_t len, zend_ulong h)\n{\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p, *arData;\n\n\tarData = ht->arData;\n\tnIndex = h | ht->nTableMask;\n\tidx = HT_HASH_EX(arData, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tZEND_ASSERT(idx < HT_IDX_TO_HASH(ht->nTableSize));\n\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);\n\t\tif ((p->h == h)\n\t\t\t && p->key\n\t\t\t && (ZSTR_LEN(p->key) == len)\n\t\t\t && !memcmp(ZSTR_VAL(p->key), str, len)) {\n\t\t\treturn p;\n\t\t}\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn NULL;\n}\n\nstatic zend_always_inline Bucket *zend_hash_index_find_bucket(const HashTable *ht, zend_ulong h)\n{\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p, *arData;\n\n\tarData = ht->arData;\n\tnIndex = h | ht->nTableMask;\n\tidx = HT_HASH_EX(arData, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tZEND_ASSERT(idx < HT_IDX_TO_HASH(ht->nTableSize));\n\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);\n\t\tif (p->h == h && !p->key) {\n\t\t\treturn p;\n\t\t}\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn NULL;\n}\n\nstatic zend_always_inline zval *_zend_hash_add_or_update_i(HashTable *ht, zend_string *key, zval *pData, uint32_t flag ZEND_FILE_LINE_DC)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (UNEXPECTED(!(ht->u.flags & HASH_FLAG_INITIALIZED))) {\n\t\tCHECK_INIT(ht, 0);\n\t\tgoto add_to_hash;\n\t} else if (ht->u.flags & HASH_FLAG_PACKED) {\n\t\tzend_hash_packed_to_hash(ht);\n\t} else if ((flag & HASH_ADD_NEW) == 0) {\n\t\tp = zend_hash_find_bucket(ht, key);\n\n\t\tif (p) {\n\t\t\tzval *data;\n\n\t\t\tif (flag & HASH_ADD) {\n\t\t\t\tif (!(flag & HASH_UPDATE_INDIRECT)) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tZEND_ASSERT(&p->val != pData);\n\t\t\t\tdata = &p->val;\n\t\t\t\tif (Z_TYPE_P(data) == IS_INDIRECT) {\n\t\t\t\t\tdata = Z_INDIRECT_P(data);\n\t\t\t\t\tif (Z_TYPE_P(data) != IS_UNDEF) {\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tZEND_ASSERT(&p->val != pData);\n\t\t\t\tdata = &p->val;\n\t\t\t\tif ((flag & HASH_UPDATE_INDIRECT) && Z_TYPE_P(data) == IS_INDIRECT) {\n\t\t\t\t\tdata = Z_INDIRECT_P(data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t\tif (ht->pDestructor) {\n\t\t\t\tht->pDestructor(data);\n\t\t\t}\n\t\t\tZVAL_COPY_VALUE(data, pData);\n\t\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t\t\treturn data;\n\t\t}\n\t}\n\n\tZEND_HASH_IF_FULL_DO_RESIZE(ht);\t\t/* If the Hash table is full, resize it */\n\nadd_to_hash:\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tidx = ht->nNumUsed++;\n\tht->nNumOfElements++;\n\tif (ht->nInternalPointer == HT_INVALID_IDX) {\n\t\tht->nInternalPointer = idx;\n\t}\n\tzend_hash_iterators_update(ht, HT_INVALID_IDX, idx);\n\tp = ht->arData + idx;\n\tp->key = key;\n\tif (!ZSTR_IS_INTERNED(key)) {\n\t\tzend_string_addref(key);\n\t\tht->u.flags &= ~HASH_FLAG_STATIC_KEYS;\n\t\tzend_string_hash_val(key);\n\t}\n\tp->h = h = ZSTR_H(key);\n\tZVAL_COPY_VALUE(&p->val, pData);\n\tnIndex = h | ht->nTableMask;\n\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\n\treturn &p->val;\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_add_or_update(HashTable *ht, zend_string *key, zval *pData, uint32_t flag ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_add_or_update_i(ht, key, pData, flag ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_add(HashTable *ht, zend_string *key, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_add_or_update_i(ht, key, pData, HASH_ADD ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_update(HashTable *ht, zend_string *key, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_add_or_update_i(ht, key, pData, HASH_UPDATE ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_update_ind(HashTable *ht, zend_string *key, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_add_or_update_i(ht, key, pData, HASH_UPDATE | HASH_UPDATE_INDIRECT ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_add_new(HashTable *ht, zend_string *key, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_add_or_update_i(ht, key, pData, HASH_ADD_NEW ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_str_add_or_update(HashTable *ht, const char *str, size_t len, zval *pData, uint32_t flag ZEND_FILE_LINE_DC)\n{\n\tzend_string *key = zend_string_init(str, len, ht->u.flags & HASH_FLAG_PERSISTENT);\n\tzval *ret = _zend_hash_add_or_update_i(ht, key, pData, flag ZEND_FILE_LINE_RELAY_CC);\n\tzend_string_release(key);\n\treturn ret;\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_str_update(HashTable *ht, const char *str, size_t len, zval *pData ZEND_FILE_LINE_DC)\n{\n\tzend_string *key = zend_string_init(str, len, ht->u.flags & HASH_FLAG_PERSISTENT);\n\tzval *ret = _zend_hash_add_or_update_i(ht, key, pData, HASH_UPDATE ZEND_FILE_LINE_RELAY_CC);\n\tzend_string_release(key);\n\treturn ret;\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_str_update_ind(HashTable *ht, const char *str, size_t len, zval *pData ZEND_FILE_LINE_DC)\n{\n\tzend_string *key = zend_string_init(str, len, ht->u.flags & HASH_FLAG_PERSISTENT);\n\tzval *ret = _zend_hash_add_or_update_i(ht, key, pData, HASH_UPDATE | HASH_UPDATE_INDIRECT ZEND_FILE_LINE_RELAY_CC);\n\tzend_string_release(key);\n\treturn ret;\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_str_add(HashTable *ht, const char *str, size_t len, zval *pData ZEND_FILE_LINE_DC)\n{\n\tzend_string *key = zend_string_init(str, len, ht->u.flags & HASH_FLAG_PERSISTENT);\n\tzval *ret = _zend_hash_add_or_update_i(ht, key, pData, HASH_ADD ZEND_FILE_LINE_RELAY_CC);\n\tzend_string_release(key);\n\treturn ret;\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_str_add_new(HashTable *ht, const char *str, size_t len, zval *pData ZEND_FILE_LINE_DC)\n{\n\tzend_string *key = zend_string_init(str, len, ht->u.flags & HASH_FLAG_PERSISTENT);\n\tzval *ret = _zend_hash_add_or_update_i(ht, key, pData, HASH_ADD_NEW ZEND_FILE_LINE_RELAY_CC);\n\tzend_string_delref(key);\n\treturn ret;\n}\n\nZEND_API zval* ZEND_FASTCALL zend_hash_index_add_empty_element(HashTable *ht, zend_ulong h)\n{\n\tzval dummy;\n\n\tZVAL_NULL(&dummy);\n\treturn zend_hash_index_add(ht, h, &dummy);\n}\n\nZEND_API zval* ZEND_FASTCALL zend_hash_add_empty_element(HashTable *ht, zend_string *key)\n{\n\tzval dummy;\n\n\tZVAL_NULL(&dummy);\n\treturn zend_hash_add(ht, key, &dummy);\n}\n\nZEND_API zval* ZEND_FASTCALL zend_hash_str_add_empty_element(HashTable *ht, const char *str, size_t len)\n{\n\tzval dummy;\n\n\tZVAL_NULL(&dummy);\n\treturn zend_hash_str_add(ht, str, len, &dummy);\n}\n\nstatic zend_always_inline zval *_zend_hash_index_add_or_update_i(HashTable *ht, zend_ulong h, zval *pData, uint32_t flag ZEND_FILE_LINE_DC)\n{\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (UNEXPECTED(!(ht->u.flags & HASH_FLAG_INITIALIZED))) {\n\t\tCHECK_INIT(ht, h < ht->nTableSize);\n\t\tif (h < ht->nTableSize) {\n\t\t\tp = ht->arData + h;\n\t\t\tgoto add_to_packed;\n\t\t}\n\t\tgoto add_to_hash;\n\t} else if (ht->u.flags & HASH_FLAG_PACKED) {\n\t\tif (h < ht->nNumUsed) {\n\t\t\tp = ht->arData + h;\n\t\t\tif (Z_TYPE(p->val) != IS_UNDEF) {\n\t\t\t\tif (flag & HASH_ADD) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (ht->pDestructor) {\n\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t}\n\t\t\t\tZVAL_COPY_VALUE(&p->val, pData);\n\t\t\t\tif ((zend_long)h >= (zend_long)ht->nNextFreeElement) {\n\t\t\t\t\tht->nNextFreeElement = h < ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX;\n\t\t\t\t}\n\t\t\t\treturn &p->val;\n\t\t\t} else { /* we have to keep the order :( */\n\t\t\t\tgoto convert_to_hash;\n\t\t\t}\n\t\t} else if (EXPECTED(h < ht->nTableSize)) {\n\t\t\tp = ht->arData + h;\n\t\t} else if ((h >> 1) < ht->nTableSize &&\n\t\t           (ht->nTableSize >> 1) < ht->nNumOfElements) {\n\t\t\tzend_hash_packed_grow(ht);\n\t\t\tp = ht->arData + h;\n\t\t} else {\n\t\t\tgoto convert_to_hash;\n\t\t}\n\nadd_to_packed:\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t/* incremental initialization of empty Buckets */\n\t\tif ((flag & (HASH_ADD_NEW|HASH_ADD_NEXT)) == (HASH_ADD_NEW|HASH_ADD_NEXT)) {\n\t\t\tht->nNumUsed = h + 1;\n\t\t} else if (h >= ht->nNumUsed) {\n\t\t\tif (h > ht->nNumUsed) {\n\t\t\t\tBucket *q = ht->arData + ht->nNumUsed;\n\t\t\t\twhile (q != p) {\n\t\t\t\t\tZVAL_UNDEF(&q->val);\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tht->nNumUsed = h + 1;\n\t\t}\n\t\tht->nNumOfElements++;\n\t\tif (ht->nInternalPointer == HT_INVALID_IDX) {\n\t\t\tht->nInternalPointer = h;\n\t\t}\n\t\tzend_hash_iterators_update(ht, HT_INVALID_IDX, h);\n\t\tif ((zend_long)h >= (zend_long)ht->nNextFreeElement) {\n\t\t\tht->nNextFreeElement = h < ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX;\n\t\t}\n\t\tp->h = h;\n\t\tp->key = NULL;\n\t\tZVAL_COPY_VALUE(&p->val, pData);\n\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\n\t\treturn &p->val;\n\nconvert_to_hash:\n\t\tzend_hash_packed_to_hash(ht);\n\t} else if ((flag & HASH_ADD_NEW) == 0) {\n\t\tp = zend_hash_index_find_bucket(ht, h);\n\t\tif (p) {\n\t\t\tif (flag & HASH_ADD) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tZEND_ASSERT(&p->val != pData);\n\t\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t\tif (ht->pDestructor) {\n\t\t\t\tht->pDestructor(&p->val);\n\t\t\t}\n\t\t\tZVAL_COPY_VALUE(&p->val, pData);\n\t\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t\t\tif ((zend_long)h >= (zend_long)ht->nNextFreeElement) {\n\t\t\t\tht->nNextFreeElement = h < ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX;\n\t\t\t}\n\t\t\treturn &p->val;\n\t\t}\n\t}\n\n\tZEND_HASH_IF_FULL_DO_RESIZE(ht);\t\t/* If the Hash table is full, resize it */\n\nadd_to_hash:\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tidx = ht->nNumUsed++;\n\tht->nNumOfElements++;\n\tif (ht->nInternalPointer == HT_INVALID_IDX) {\n\t\tht->nInternalPointer = idx;\n\t}\n\tzend_hash_iterators_update(ht, HT_INVALID_IDX, idx);\n\tif ((zend_long)h >= (zend_long)ht->nNextFreeElement) {\n\t\tht->nNextFreeElement = h < ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX;\n\t}\n\tp = ht->arData + idx;\n\tp->h = h;\n\tp->key = NULL;\n\tnIndex = h | ht->nTableMask;\n\tZVAL_COPY_VALUE(&p->val, pData);\n\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\n\treturn &p->val;\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_index_add_or_update(HashTable *ht, zend_ulong h, zval *pData, uint32_t flag ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, h, pData, flag ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_index_add(HashTable *ht, zend_ulong h, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, h, pData, HASH_ADD ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_index_add_new(HashTable *ht, zend_ulong h, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, h, pData, HASH_ADD | HASH_ADD_NEW ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_index_update(HashTable *ht, zend_ulong h, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, h, pData, HASH_UPDATE ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_next_index_insert(HashTable *ht, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, ht->nNextFreeElement, pData, HASH_ADD | HASH_ADD_NEXT ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_next_index_insert_new(HashTable *ht, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, ht->nNextFreeElement, pData, HASH_ADD | HASH_ADD_NEW | HASH_ADD_NEXT ZEND_FILE_LINE_RELAY_CC);\n}\n\nstatic void ZEND_FASTCALL zend_hash_do_resize(HashTable *ht)\n{\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (ht->nNumUsed > ht->nNumOfElements + (ht->nNumOfElements >> 5)) { /* additional term is there to amortize the cost of compaction */\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\tzend_hash_rehash(ht);\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t} else if (ht->nTableSize < HT_MAX_SIZE) {\t/* Let's double the table size */\n\t\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\t\tuint32_t nSize = ht->nTableSize + ht->nTableSize;\n\t\tBucket *old_buckets = ht->arData;\n\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\tnew_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\tht->nTableSize = nSize;\n\t\tht->nTableMask = -ht->nTableSize;\n\t\tHT_SET_DATA_ADDR(ht, new_data);\n\t\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\t\tpefree(old_data, ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\tzend_hash_rehash(ht);\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t} else {\n\t\tzend_error_noreturn(E_ERROR, \"Possible integer overflow in memory allocation (%zu * %zu + %zu)\", ht->nTableSize * 2, sizeof(Bucket) + sizeof(uint32_t), sizeof(Bucket));\n\t}\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_rehash(HashTable *ht)\n{\n\tBucket *p;\n\tuint32_t nIndex, i;\n\n\tIS_CONSISTENT(ht);\n\n\tif (UNEXPECTED(ht->nNumOfElements == 0)) {\n\t\tif (ht->u.flags & HASH_FLAG_INITIALIZED) {\n\t\t\tht->nNumUsed = 0;\n\t\t\tHT_HASH_RESET(ht);\n\t\t}\n\t\treturn SUCCESS;\n\t}\n\n\tHT_HASH_RESET(ht);\n\ti = 0;\n\tp = ht->arData;\n\tif (ht->nNumUsed == ht->nNumOfElements) {\n\t\tdo {\n\t\t\tnIndex = p->h | ht->nTableMask;\n\t\t\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\t\t\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i);\n\t\t\tp++;\n\t\t} while (++i < ht->nNumUsed);\n\t} else {\n\t\tdo {\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) {\n\t\t\t\tuint32_t j = i;\n\t\t\t\tBucket *q = p;\n\n\t\t\t\tif (EXPECTED(ht->u.v.nIteratorsCount == 0)) {\n\t\t\t\t\twhile (++i < ht->nNumUsed) {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (EXPECTED(Z_TYPE_INFO(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\t\tZVAL_COPY_VALUE(&q->val, &p->val);\n\t\t\t\t\t\t\tq->h = p->h;\n\t\t\t\t\t\t\tnIndex = q->h | ht->nTableMask;\n\t\t\t\t\t\t\tq->key = p->key;\n\t\t\t\t\t\t\tZ_NEXT(q->val) = HT_HASH(ht, nIndex);\n\t\t\t\t\t\t\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(j);\n\t\t\t\t\t\t\tif (UNEXPECTED(ht->nInternalPointer == i)) {\n\t\t\t\t\t\t\t\tht->nInternalPointer = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuint32_t iter_pos = zend_hash_iterators_lower_pos(ht, 0);\n\n\t\t\t\t\twhile (++i < ht->nNumUsed) {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (EXPECTED(Z_TYPE_INFO(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\t\tZVAL_COPY_VALUE(&q->val, &p->val);\n\t\t\t\t\t\t\tq->h = p->h;\n\t\t\t\t\t\t\tnIndex = q->h | ht->nTableMask;\n\t\t\t\t\t\t\tq->key = p->key;\n\t\t\t\t\t\t\tZ_NEXT(q->val) = HT_HASH(ht, nIndex);\n\t\t\t\t\t\t\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(j);\n\t\t\t\t\t\t\tif (UNEXPECTED(ht->nInternalPointer == i)) {\n\t\t\t\t\t\t\t\tht->nInternalPointer = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (UNEXPECTED(i == iter_pos)) {\n\t\t\t\t\t\t\t\tzend_hash_iterators_update(ht, i, j);\n\t\t\t\t\t\t\t\titer_pos = zend_hash_iterators_lower_pos(ht, iter_pos + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tht->nNumUsed = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnIndex = p->h | ht->nTableMask;\n\t\t\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\t\t\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i);\n\t\t\tp++;\n\t\t} while (++i < ht->nNumUsed);\n\t}\n\treturn SUCCESS;\n}\n\nstatic zend_always_inline void _zend_hash_del_el_ex(HashTable *ht, uint32_t idx, Bucket *p, Bucket *prev)\n{\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tif (!(ht->u.flags & HASH_FLAG_PACKED)) {\n\t\tif (prev) {\n\t\t\tZ_NEXT(prev->val) = Z_NEXT(p->val);\n\t\t} else {\n\t\t\tHT_HASH(ht, p->h | ht->nTableMask) = Z_NEXT(p->val);\n\t\t}\n\t}\n\tif (HT_IDX_TO_HASH(ht->nNumUsed - 1) == idx) {\n\t\tdo {\n\t\t\tht->nNumUsed--;\n\t\t} while (ht->nNumUsed > 0 && (UNEXPECTED(Z_TYPE(ht->arData[ht->nNumUsed-1].val) == IS_UNDEF)));\n\t}\n\tht->nNumOfElements--;\n\tif (HT_IDX_TO_HASH(ht->nInternalPointer) == idx || UNEXPECTED(ht->u.v.nIteratorsCount)) {\n\t\tuint32_t new_idx;\n\n\t\tnew_idx = idx = HT_HASH_TO_IDX(idx);\n\t\twhile (1) {\n\t\t\tnew_idx++;\n\t\t\tif (new_idx >= ht->nNumUsed) {\n\t\t\t\tnew_idx = HT_INVALID_IDX;\n\t\t\t\tbreak;\n\t\t\t} else if (Z_TYPE(ht->arData[new_idx].val) != IS_UNDEF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ht->nInternalPointer == idx) {\n\t\t\tht->nInternalPointer = new_idx;\n\t\t}\n\t\tzend_hash_iterators_update(ht, idx, new_idx);\n\t}\n\tif (p->key) {\n\t\tzend_string_release(p->key);\n\t}\n\tif (ht->pDestructor) {\n\t\tzval tmp;\n\t\tZVAL_COPY_VALUE(&tmp, &p->val);\n\t\tZVAL_UNDEF(&p->val);\n\t\tht->pDestructor(&tmp);\n\t} else {\n\t\tZVAL_UNDEF(&p->val);\n\t}\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n}\n\nstatic zend_always_inline void _zend_hash_del_el(HashTable *ht, uint32_t idx, Bucket *p)\n{\n\tBucket *prev = NULL;\n\n\tif (!(ht->u.flags & HASH_FLAG_PACKED)) {\n\t\tuint32_t nIndex = p->h | ht->nTableMask;\n\t\tuint32_t i = HT_HASH(ht, nIndex);\n\n\t\tif (i != idx) {\n\t\t\tprev = HT_HASH_TO_BUCKET(ht, i);\n\t\t\twhile (Z_NEXT(prev->val) != idx) {\n\t\t\t\ti = Z_NEXT(prev->val);\n\t\t\t\tprev = HT_HASH_TO_BUCKET(ht, i);\n\t\t\t}\n\t \t}\n\t}\n\n\t_zend_hash_del_el_ex(ht, idx, p, prev);\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_del_bucket(HashTable *ht, Bucket *p)\n{\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(p - ht->arData), p);\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_del(HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\th = zend_string_hash_val(key);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->key == key) ||\n\t\t\t(p->h == h &&\n\t\t     p->key &&\n\t\t     ZSTR_LEN(p->key) == ZSTR_LEN(key) &&\n\t\t     memcmp(ZSTR_VAL(p->key), ZSTR_VAL(key), ZSTR_LEN(key)) == 0)) {\n\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_del_ind(HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\th = zend_string_hash_val(key);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->key == key) ||\n\t\t\t(p->h == h &&\n\t\t     p->key &&\n\t\t     ZSTR_LEN(p->key) == ZSTR_LEN(key) &&\n\t\t     memcmp(ZSTR_VAL(p->key), ZSTR_VAL(key), ZSTR_LEN(key)) == 0)) {\n\t\t\tif (Z_TYPE(p->val) == IS_INDIRECT) {\n\t\t\t\tzval *data = Z_INDIRECT(p->val);\n\n\t\t\t\tif (UNEXPECTED(Z_TYPE_P(data) == IS_UNDEF)) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tif (ht->pDestructor) {\n\t\t\t\t\t\tzval tmp;\n\t\t\t\t\t\tZVAL_COPY_VALUE(&tmp, data);\n\t\t\t\t\t\tZVAL_UNDEF(data);\n\t\t\t\t\t\tht->pDestructor(&tmp);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tZVAL_UNDEF(data);\n\t\t\t\t\t}\n\t\t\t\t\tht->u.v.flags |= HASH_FLAG_HAS_EMPTY_IND;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_str_del_ind(HashTable *ht, const char *str, size_t len)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\th = zend_inline_hash_func(str, len);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->h == h)\n\t\t\t && p->key\n\t\t\t && (ZSTR_LEN(p->key) == len)\n\t\t\t && !memcmp(ZSTR_VAL(p->key), str, len)) {\n\t\t\tif (Z_TYPE(p->val) == IS_INDIRECT) {\n\t\t\t\tzval *data = Z_INDIRECT(p->val);\n\n\t\t\t\tif (UNEXPECTED(Z_TYPE_P(data) == IS_UNDEF)) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tif (ht->pDestructor) {\n\t\t\t\t\t\tht->pDestructor(data);\n\t\t\t\t\t}\n\t\t\t\t\tZVAL_UNDEF(data);\n\t\t\t\t\tht->u.v.flags |= HASH_FLAG_HAS_EMPTY_IND;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_str_del(HashTable *ht, const char *str, size_t len)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\th = zend_inline_hash_func(str, len);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->h == h)\n\t\t\t && p->key\n\t\t\t && (ZSTR_LEN(p->key) == len)\n\t\t\t && !memcmp(ZSTR_VAL(p->key), str, len)) {\n\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_index_del(HashTable *ht, zend_ulong h)\n{\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (ht->u.flags & HASH_FLAG_PACKED) {\n\t\tif (h < ht->nNumUsed) {\n\t\t\tp = ht->arData + h;\n\t\t\tif (Z_TYPE(p->val) != IS_UNDEF) {\n\t\t\t\t_zend_hash_del_el_ex(ht, HT_IDX_TO_HASH(h), p, NULL);\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t}\n\t\treturn FAILURE;\n\t}\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->h == h) && (p->key == NULL)) {\n\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_destroy(HashTable *ht)\n{\n\tBucket *p, *end;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) <= 1);\n\n\tif (ht->nNumUsed) {\n\t\tp = ht->arData;\n\t\tend = p + ht->nNumUsed;\n\t\tif (ht->pDestructor) {\n\t\t\tSET_INCONSISTENT(HT_IS_DESTROYING);\n\n\t\t\tif (ht->u.flags & (HASH_FLAG_PACKED|HASH_FLAG_STATIC_KEYS)) {\n\t\t\t\tif (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t}\n\t\t\t} else if (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\t\tdo {\n\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t}\n\n\t\t\tSET_INCONSISTENT(HT_DESTROYED);\n\t\t} else {\n\t\t\tif (!(ht->u.flags & (HASH_FLAG_PACKED|HASH_FLAG_STATIC_KEYS))) {\n\t\t\t\tdo {\n\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t}\n\t\t}\n\t\tzend_hash_iterators_remove(ht);\n\t} else if (EXPECTED(!(ht->u.flags & HASH_FLAG_INITIALIZED))) {\n\t\treturn;\n\t}\n\tpefree(HT_GET_DATA_ADDR(ht), ht->u.flags & HASH_FLAG_PERSISTENT);\n}\n\nZEND_API void ZEND_FASTCALL zend_array_destroy(HashTable *ht)\n{\n\tBucket *p, *end;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) <= 1);\n\n\t/* break possible cycles */\n\tGC_REMOVE_FROM_BUFFER(ht);\n\tGC_TYPE_INFO(ht) = IS_NULL | (GC_WHITE << 16);\n\n\tif (ht->nNumUsed) {\n\t\t/* In some rare cases destructors of regular arrays may be changed */\n\t\tif (UNEXPECTED(ht->pDestructor != ZVAL_PTR_DTOR)) {\n\t\t\tzend_hash_destroy(ht);\n\t\t\tgoto free_ht;\n\t\t}\n\n\t\tp = ht->arData;\n\t\tend = p + ht->nNumUsed;\n\t\tSET_INCONSISTENT(HT_IS_DESTROYING);\n\n\t\tif (ht->u.flags & (HASH_FLAG_PACKED|HASH_FLAG_STATIC_KEYS)) {\n\t\t\tdo {\n\t\t\t\ti_zval_ptr_dtor(&p->val ZEND_FILE_LINE_CC);\n\t\t\t} while (++p != end);\n\t\t} else if (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\tdo {\n\t\t\t\ti_zval_ptr_dtor(&p->val ZEND_FILE_LINE_CC);\n\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t}\n\t\t\t} while (++p != end);\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\ti_zval_ptr_dtor(&p->val ZEND_FILE_LINE_CC);\n\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (++p != end);\n\t\t}\n\t\tzend_hash_iterators_remove(ht);\n\t\tSET_INCONSISTENT(HT_DESTROYED);\n\t} else if (EXPECTED(!(ht->u.flags & HASH_FLAG_INITIALIZED))) {\n\t\tgoto free_ht;\n\t}\n\tefree(HT_GET_DATA_ADDR(ht));\nfree_ht:\n\tFREE_HASHTABLE(ht);\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_clean(HashTable *ht)\n{\n\tBucket *p, *end;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (ht->nNumUsed) {\n\t\tp = ht->arData;\n\t\tend = p + ht->nNumUsed;\n\t\tif (ht->pDestructor) {\n\t\t\tif (ht->u.flags & (HASH_FLAG_PACKED|HASH_FLAG_STATIC_KEYS)) {\n\t\t\t\tif (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t}\n\t\t\t} else if (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\t\tdo {\n\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(ht->u.flags & (HASH_FLAG_PACKED|HASH_FLAG_STATIC_KEYS))) {\n\t\t\t\tif (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!(ht->u.flags & HASH_FLAG_PACKED)) {\n\t\t\tHT_HASH_RESET(ht);\n\t\t}\n\t}\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nNextFreeElement = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n}\n\nZEND_API void ZEND_FASTCALL zend_symtable_clean(HashTable *ht)\n{\n\tBucket *p, *end;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (ht->nNumUsed) {\n\t\tp = ht->arData;\n\t\tend = p + ht->nNumUsed;\n\t\tif (ht->u.flags & HASH_FLAG_STATIC_KEYS) {\n\t\t\tdo {\n\t\t\t\ti_zval_ptr_dtor(&p->val ZEND_FILE_LINE_CC);\n\t\t\t} while (++p != end);\n\t\t} else if (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\tdo {\n\t\t\t\ti_zval_ptr_dtor(&p->val ZEND_FILE_LINE_CC);\n\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t}\n\t\t\t} while (++p != end);\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\ti_zval_ptr_dtor(&p->val ZEND_FILE_LINE_CC);\n\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (++p != end);\n\t\t}\n\t\tHT_HASH_RESET(ht);\n\t}\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nNextFreeElement = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_graceful_destroy(HashTable *ht)\n{\n\tuint32_t idx;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tp = ht->arData;\n\tfor (idx = 0; idx < ht->nNumUsed; idx++, p++) {\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t}\n\tif (ht->u.flags & HASH_FLAG_INITIALIZED) {\n\t\tpefree(HT_GET_DATA_ADDR(ht), ht->u.flags & HASH_FLAG_PERSISTENT);\n\t}\n\n\tSET_INCONSISTENT(HT_DESTROYED);\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_graceful_reverse_destroy(HashTable *ht)\n{\n\tuint32_t idx;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tidx = ht->nNumUsed;\n\tp = ht->arData + ht->nNumUsed;\n\twhile (idx > 0) {\n\t\tidx--;\n\t\tp--;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t}\n\n\tif (ht->u.flags & HASH_FLAG_INITIALIZED) {\n\t\tpefree(HT_GET_DATA_ADDR(ht), ht->u.flags & HASH_FLAG_PERSISTENT);\n\t}\n\n\tSET_INCONSISTENT(HT_DESTROYED);\n}\n\n/* This is used to recurse elements and selectively delete certain entries\n * from a hashtable. apply_func() receives the data and decides if the entry\n * should be deleted or recursion should be stopped. The following three\n * return codes are possible:\n * ZEND_HASH_APPLY_KEEP   - continue\n * ZEND_HASH_APPLY_STOP   - stop iteration\n * ZEND_HASH_APPLY_REMOVE - delete the element, combineable with the former\n */\n\nZEND_API void ZEND_FASTCALL zend_hash_apply(HashTable *ht, apply_func_t apply_func)\n{\n\tuint32_t idx;\n\tBucket *p;\n\tint result;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tHASH_PROTECT_RECURSION(ht);\n\tfor (idx = 0; idx < ht->nNumUsed; idx++) {\n\t\tp = ht->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\tresult = apply_func(&p->val);\n\n\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t\t}\n\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tHASH_UNPROTECT_RECURSION(ht);\n}\n\n\nZEND_API void ZEND_FASTCALL zend_hash_apply_with_argument(HashTable *ht, apply_func_arg_t apply_func, void *argument)\n{\n    uint32_t idx;\n\tBucket *p;\n\tint result;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tHASH_PROTECT_RECURSION(ht);\n\tfor (idx = 0; idx < ht->nNumUsed; idx++) {\n\t\tp = ht->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\tresult = apply_func(&p->val, argument);\n\n\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t\t}\n\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tHASH_UNPROTECT_RECURSION(ht);\n}\n\n\nZEND_API void ZEND_FASTCALL zend_hash_apply_with_arguments(HashTable *ht, apply_func_args_t apply_func, int num_args, ...)\n{\n\tuint32_t idx;\n\tBucket *p;\n\tva_list args;\n\tzend_hash_key hash_key;\n\tint result;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tHASH_PROTECT_RECURSION(ht);\n\n\tfor (idx = 0; idx < ht->nNumUsed; idx++) {\n\t\tp = ht->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\tva_start(args, num_args);\n\t\thash_key.h = p->h;\n\t\thash_key.key = p->key;\n\n\t\tresult = apply_func(&p->val, num_args, args, &hash_key);\n\n\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t\t}\n\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\tva_end(args);\n\t\t\tbreak;\n\t\t}\n\t\tva_end(args);\n\t}\n\n\tHASH_UNPROTECT_RECURSION(ht);\n}\n\n\nZEND_API void ZEND_FASTCALL zend_hash_reverse_apply(HashTable *ht, apply_func_t apply_func)\n{\n\tuint32_t idx;\n\tBucket *p;\n\tint result;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tHASH_PROTECT_RECURSION(ht);\n\tidx = ht->nNumUsed;\n\twhile (idx > 0) {\n\t\tidx--;\n\t\tp = ht->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\n\t\tresult = apply_func(&p->val);\n\n\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t\t}\n\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tHASH_UNPROTECT_RECURSION(ht);\n}\n\n\nZEND_API void ZEND_FASTCALL zend_hash_copy(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor)\n{\n    uint32_t idx;\n\tBucket *p;\n\tzval *new_entry, *data;\n\tzend_bool setTargetPointer;\n\n\tIS_CONSISTENT(source);\n\tIS_CONSISTENT(target);\n\tHT_ASSERT(GC_REFCOUNT(target) == 1);\n\n\tsetTargetPointer = (target->nInternalPointer == HT_INVALID_IDX);\n\tfor (idx = 0; idx < source->nNumUsed; idx++) {\n\t\tp = source->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\n\t\tif (setTargetPointer && source->nInternalPointer == idx) {\n\t\t\ttarget->nInternalPointer = HT_INVALID_IDX;\n\t\t}\n\t\t/* INDIRECT element may point to UNDEF-ined slots */\n\t\tdata = &p->val;\n\t\tif (Z_TYPE_P(data) == IS_INDIRECT) {\n\t\t\tdata = Z_INDIRECT_P(data);\n\t\t\tif (UNEXPECTED(Z_TYPE_P(data) == IS_UNDEF)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (p->key) {\n\t\t\tnew_entry = zend_hash_update(target, p->key, data);\n\t\t} else {\n\t\t\tnew_entry = zend_hash_index_update(target, p->h, data);\n\t\t}\n\t\tif (pCopyConstructor) {\n\t\t\tpCopyConstructor(new_entry);\n\t\t}\n\t}\n\tif (target->nInternalPointer == HT_INVALID_IDX && target->nNumOfElements > 0) {\n\t\tidx = 0;\n\t\twhile (Z_TYPE(target->arData[idx].val) == IS_UNDEF) {\n\t\t\tidx++;\n\t\t}\n\t\ttarget->nInternalPointer = idx;\n\t}\n}\n\n\nstatic zend_always_inline int zend_array_dup_element(HashTable *source, HashTable *target, uint32_t idx, Bucket *p, Bucket *q, int packed, int static_keys, int with_holes)\n{\n\tzval *data = &p->val;\n\n\tif (with_holes) {\n\t\tif (!packed && Z_TYPE_INFO_P(data) == IS_INDIRECT) {\n\t\t\tdata = Z_INDIRECT_P(data);\n\t\t}\n\t\tif (UNEXPECTED(Z_TYPE_INFO_P(data) == IS_UNDEF)) {\n\t\t\treturn 0;\n\t\t}\n\t} else if (!packed) {\n\t\t/* INDIRECT element may point to UNDEF-ined slots */\n\t\tif (Z_TYPE_INFO_P(data) == IS_INDIRECT) {\n\t\t\tdata = Z_INDIRECT_P(data);\n\t\t\tif (UNEXPECTED(Z_TYPE_INFO_P(data) == IS_UNDEF)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tdo {\n\t\tif (Z_OPT_REFCOUNTED_P(data)) {\n\t\t\tif (Z_ISREF_P(data) && Z_REFCOUNT_P(data) == 1 &&\n\t\t\t    (Z_TYPE_P(Z_REFVAL_P(data)) != IS_ARRAY ||\n\t\t\t      Z_ARRVAL_P(Z_REFVAL_P(data)) != source)) {\n\t\t\t\tdata = Z_REFVAL_P(data);\n\t\t\t\tif (!Z_OPT_REFCOUNTED_P(data)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tZ_ADDREF_P(data);\n\t\t}\n\t} while (0);\n\tZVAL_COPY_VALUE(&q->val, data);\n\n\tq->h = p->h;\n\tif (packed) {\n\t\tq->key = NULL;\n\t} else {\n\t\tuint32_t nIndex;\n\n\t\tq->key = p->key;\n\t\tif (!static_keys && q->key) {\n\t\t\tzend_string_addref(q->key);\n\t\t}\n\n\t\tnIndex = q->h | target->nTableMask;\n\t\tZ_NEXT(q->val) = HT_HASH(target, nIndex);\n\t\tHT_HASH(target, nIndex) = HT_IDX_TO_HASH(idx);\n\t}\n\treturn 1;\n}\n\nstatic zend_always_inline void zend_array_dup_packed_elements(HashTable *source, HashTable *target, int with_holes)\n{\n\tBucket *p = source->arData;\n\tBucket *q = target->arData;\n\tBucket *end = p + source->nNumUsed;\n\n\tdo {\n\t\tif (!zend_array_dup_element(source, target, 0, p, q, 1, 1, with_holes)) {\n\t\t\tif (with_holes) {\n\t\t\t\tZVAL_UNDEF(&q->val);\n\t\t\t}\n\t\t}\n\t\tp++; q++;\n\t} while (p != end);\n}\n\nstatic zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)\n{\n\tuint32_t idx = 0;\n\tBucket *p = source->arData;\n\tBucket *q = target->arData;\n\tBucket *end = p + source->nNumUsed;\n\n\tdo {\n\t\tif (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {\n\t\t\tuint32_t target_idx = idx;\n\n\t\t\tidx++; p++;\n\t\t\twhile (p != end) {\n\t\t\t\tif (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {\n\t\t\t\t\tif (source->nInternalPointer == idx) {\n\t\t\t\t\t\ttarget->nInternalPointer = target_idx;\n\t\t\t\t\t}\n\t\t\t\t\ttarget_idx++; q++;\n\t\t\t\t}\n\t\t\t\tidx++; p++;\n\t\t\t}\n\t\t\treturn target_idx;\n\t\t}\n\t\tidx++; p++; q++;\n\t} while (p != end);\n\treturn idx;\n}\n\nZEND_API HashTable* ZEND_FASTCALL zend_array_dup(HashTable *source)\n{\n\tuint32_t idx;\n\tHashTable *target;\n\n\tIS_CONSISTENT(source);\n\n\tALLOC_HASHTABLE(target);\n\tGC_REFCOUNT(target) = 1;\n\tGC_TYPE_INFO(target) = IS_ARRAY;\n\n\ttarget->nTableSize = source->nTableSize;\n\ttarget->pDestructor = source->pDestructor;\n\n\tif (source->nNumUsed == 0) {\n\t\ttarget->u.flags = (source->u.flags & ~(HASH_FLAG_INITIALIZED|HASH_FLAG_PACKED|HASH_FLAG_PERSISTENT|ZEND_HASH_APPLY_COUNT_MASK)) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\t\ttarget->nTableMask = HT_MIN_MASK;\n\t\ttarget->nNumUsed = 0;\n\t\ttarget->nNumOfElements = 0;\n\t\ttarget->nNextFreeElement = 0;\n\t\ttarget->nInternalPointer = HT_INVALID_IDX;\n\t\tHT_SET_DATA_ADDR(target, &uninitialized_bucket);\n\t} else if (GC_FLAGS(source) & IS_ARRAY_IMMUTABLE) {\n\t\ttarget->u.flags = (source->u.flags & ~HASH_FLAG_PERSISTENT) | HASH_FLAG_APPLY_PROTECTION;\n\t\ttarget->nTableMask = source->nTableMask;\n\t\ttarget->nNumUsed = source->nNumUsed;\n\t\ttarget->nNumOfElements = source->nNumOfElements;\n\t\ttarget->nNextFreeElement = source->nNextFreeElement;\n\t\tHT_SET_DATA_ADDR(target, emalloc(HT_SIZE(target)));\n\t\ttarget->nInternalPointer = source->nInternalPointer;\n\t\tmemcpy(HT_GET_DATA_ADDR(target), HT_GET_DATA_ADDR(source), HT_USED_SIZE(source));\n\t\tif (target->nNumOfElements > 0 &&\n\t\t    target->nInternalPointer == HT_INVALID_IDX) {\n\t\t\tidx = 0;\n\t\t\twhile (Z_TYPE(target->arData[idx].val) == IS_UNDEF) {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\ttarget->nInternalPointer = idx;\n\t\t}\n\t} else if (source->u.flags & HASH_FLAG_PACKED) {\n\t\ttarget->u.flags = (source->u.flags & ~(HASH_FLAG_PERSISTENT|ZEND_HASH_APPLY_COUNT_MASK)) | HASH_FLAG_APPLY_PROTECTION;\n\t\ttarget->nTableMask = source->nTableMask;\n\t\ttarget->nNumUsed = source->nNumUsed;\n\t\ttarget->nNumOfElements = source->nNumOfElements;\n\t\ttarget->nNextFreeElement = source->nNextFreeElement;\n\t\tHT_SET_DATA_ADDR(target, emalloc(HT_SIZE(target)));\n\t\ttarget->nInternalPointer = source->nInternalPointer;\n\t\tHT_HASH_RESET_PACKED(target);\n\n\t\tif (target->nNumUsed == target->nNumOfElements) {\n\t\t\tzend_array_dup_packed_elements(source, target, 0);\n\t\t} else {\n\t\t\tzend_array_dup_packed_elements(source, target, 1);\n\t\t}\n\t\tif (target->nNumOfElements > 0 &&\n\t\t    target->nInternalPointer == HT_INVALID_IDX) {\n\t\t\tidx = 0;\n\t\t\twhile (Z_TYPE(target->arData[idx].val) == IS_UNDEF) {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\ttarget->nInternalPointer = idx;\n\t\t}\n\t} else {\n\t\ttarget->u.flags = (source->u.flags & ~(HASH_FLAG_PERSISTENT|ZEND_HASH_APPLY_COUNT_MASK)) | HASH_FLAG_APPLY_PROTECTION;\n\t\ttarget->nTableMask = source->nTableMask;\n\t\ttarget->nNextFreeElement = source->nNextFreeElement;\n\t\ttarget->nInternalPointer = source->nInternalPointer;\n\n\t\tHT_SET_DATA_ADDR(target, emalloc(HT_SIZE(target)));\n\t\tHT_HASH_RESET(target);\n\n\t\tif (target->u.flags & HASH_FLAG_STATIC_KEYS) {\n\t\t\tif (source->nNumUsed == source->nNumOfElements) {\n\t\t\t\tidx = zend_array_dup_elements(source, target, 1, 0);\n\t\t\t} else {\n\t\t\t\tidx = zend_array_dup_elements(source, target, 1, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tif (source->nNumUsed == source->nNumOfElements) {\n\t\t\t\tidx = zend_array_dup_elements(source, target, 0, 0);\n\t\t\t} else {\n\t\t\t\tidx = zend_array_dup_elements(source, target, 0, 1);\n\t\t\t}\n\t\t}\n\t\ttarget->nNumUsed = idx;\n\t\ttarget->nNumOfElements = idx;\n\t\tif (idx > 0 && target->nInternalPointer == HT_INVALID_IDX) {\n\t\t\ttarget->nInternalPointer = 0;\n\t\t}\n\t}\n\treturn target;\n}\n\n\nZEND_API void ZEND_FASTCALL _zend_hash_merge(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor, zend_bool overwrite ZEND_FILE_LINE_DC)\n{\n    uint32_t idx;\n\tBucket *p;\n\tzval *t;\n\n\tIS_CONSISTENT(source);\n\tIS_CONSISTENT(target);\n\tHT_ASSERT(GC_REFCOUNT(target) == 1);\n\n\tif (overwrite) {\n\t\tfor (idx = 0; idx < source->nNumUsed; idx++) {\n\t\t\tp = source->arData + idx;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_INDIRECT) &&\n\t\t\t    UNEXPECTED(Z_TYPE_P(Z_INDIRECT(p->val)) == IS_UNDEF)) {\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (p->key) {\n\t\t\t\tt = _zend_hash_add_or_update_i(target, p->key, &p->val, HASH_UPDATE | HASH_UPDATE_INDIRECT ZEND_FILE_LINE_RELAY_CC);\n\t\t\t\tif (t && pCopyConstructor) {\n\t\t\t\t\tpCopyConstructor(t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt = zend_hash_index_update(target, p->h, &p->val);\n\t\t\t\tif (t && pCopyConstructor) {\n\t\t\t\t\tpCopyConstructor(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (idx = 0; idx < source->nNumUsed; idx++) {\n\t\t\tp = source->arData + idx;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_INDIRECT) &&\n\t\t\t    UNEXPECTED(Z_TYPE_P(Z_INDIRECT(p->val)) == IS_UNDEF)) {\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (p->key) {\n\t\t\t\tt = _zend_hash_add_or_update_i(target, p->key, &p->val, HASH_ADD | HASH_UPDATE_INDIRECT ZEND_FILE_LINE_RELAY_CC);\n\t\t\t\tif (t && pCopyConstructor) {\n\t\t\t\t\tpCopyConstructor(t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt = zend_hash_index_add(target, p->h, &p->val);\n\t\t\t\tif (t && pCopyConstructor) {\n\t\t\t\t\tpCopyConstructor(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (target->nNumOfElements > 0) {\n\t\tidx = 0;\n\t\twhile (Z_TYPE(target->arData[idx].val) == IS_UNDEF) {\n\t\t\tidx++;\n\t\t}\n\t\ttarget->nInternalPointer = idx;\n\t}\n}\n\n\nstatic zend_bool ZEND_FASTCALL zend_hash_replace_checker_wrapper(HashTable *target, zval *source_data, Bucket *p, void *pParam, merge_checker_func_t merge_checker_func)\n{\n\tzend_hash_key hash_key;\n\n\thash_key.h = p->h;\n\thash_key.key = p->key;\n\treturn merge_checker_func(target, source_data, &hash_key, pParam);\n}\n\n\nZEND_API void ZEND_FASTCALL zend_hash_merge_ex(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor, merge_checker_func_t pMergeSource, void *pParam)\n{\n\tuint32_t idx;\n\tBucket *p;\n\tzval *t;\n\n\tIS_CONSISTENT(source);\n\tIS_CONSISTENT(target);\n\tHT_ASSERT(GC_REFCOUNT(target) == 1);\n\n\tfor (idx = 0; idx < source->nNumUsed; idx++) {\n\t\tp = source->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\tif (zend_hash_replace_checker_wrapper(target, &p->val, p, pParam, pMergeSource)) {\n\t\t\tt = zend_hash_update(target, p->key, &p->val);\n\t\t\tif (t && pCopyConstructor) {\n\t\t\t\tpCopyConstructor(t);\n\t\t\t}\n\t\t}\n\t}\n\tif (target->nNumOfElements > 0) {\n\t\tidx = 0;\n\t\twhile (Z_TYPE(target->arData[idx].val) == IS_UNDEF) {\n\t\t\tidx++;\n\t\t}\n\t\ttarget->nInternalPointer = idx;\n\t}\n}\n\n\n/* Returns the hash table data if found and NULL if not. */\nZEND_API zval* ZEND_FASTCALL zend_hash_find(const HashTable *ht, zend_string *key)\n{\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\n\tp = zend_hash_find_bucket(ht, key);\n\treturn p ? &p->val : NULL;\n}\n\nZEND_API zval* ZEND_FASTCALL zend_hash_str_find(const HashTable *ht, const char *str, size_t len)\n{\n\tzend_ulong h;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\n\th = zend_inline_hash_func(str, len);\n\tp = zend_hash_str_find_bucket(ht, str, len, h);\n\treturn p ? &p->val : NULL;\n}\n\nZEND_API zend_bool ZEND_FASTCALL zend_hash_exists(const HashTable *ht, zend_string *key)\n{\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\n\tp = zend_hash_find_bucket(ht, key);\n\treturn p ? 1 : 0;\n}\n\nZEND_API zend_bool ZEND_FASTCALL zend_hash_str_exists(const HashTable *ht, const char *str, size_t len)\n{\n\tzend_ulong h;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\n\th = zend_inline_hash_func(str, len);\n\tp = zend_hash_str_find_bucket(ht, str, len, h);\n\treturn p ? 1 : 0;\n}\n\nZEND_API zval* ZEND_FASTCALL zend_hash_index_find(const HashTable *ht, zend_ulong h)\n{\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\n\tif (ht->u.flags & HASH_FLAG_PACKED) {\n\t\tif (h < ht->nNumUsed) {\n\t\t\tp = ht->arData + h;\n\t\t\tif (Z_TYPE(p->val) != IS_UNDEF) {\n\t\t\t\treturn &p->val;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tp = zend_hash_index_find_bucket(ht, h);\n\treturn p ? &p->val : NULL;\n}\n\n\nZEND_API zend_bool ZEND_FASTCALL zend_hash_index_exists(const HashTable *ht, zend_ulong h)\n{\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\n\tif (ht->u.flags & HASH_FLAG_PACKED) {\n\t\tif (h < ht->nNumUsed) {\n\t\t\tif (Z_TYPE(ht->arData[h].val) != IS_UNDEF) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tp = zend_hash_index_find_bucket(ht, h);\n\treturn p ? 1 : 0;\n}\n\n\nZEND_API void ZEND_FASTCALL zend_hash_internal_pointer_reset_ex(HashTable *ht, HashPosition *pos)\n{\n    uint32_t idx;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(&ht->nInternalPointer != pos || GC_REFCOUNT(ht) == 1);\n\n\tfor (idx = 0; idx < ht->nNumUsed; idx++) {\n\t\tif (Z_TYPE(ht->arData[idx].val) != IS_UNDEF) {\n\t\t\t*pos = idx;\n\t\t\treturn;\n\t\t}\n\t}\n\t*pos = HT_INVALID_IDX;\n}\n\n\n/* This function will be extremely optimized by remembering\n * the end of the list\n */\nZEND_API void ZEND_FASTCALL zend_hash_internal_pointer_end_ex(HashTable *ht, HashPosition *pos)\n{\n\tuint32_t idx;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(&ht->nInternalPointer != pos || GC_REFCOUNT(ht) == 1);\n\n\tidx = ht->nNumUsed;\n\twhile (idx > 0) {\n\t\tidx--;\n\t\tif (Z_TYPE(ht->arData[idx].val) != IS_UNDEF) {\n\t\t\t*pos = idx;\n\t\t\treturn;\n\t\t}\n\t}\n\t*pos = HT_INVALID_IDX;\n}\n\n\nZEND_API int ZEND_FASTCALL zend_hash_move_forward_ex(HashTable *ht, HashPosition *pos)\n{\n\tuint32_t idx = *pos;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(&ht->nInternalPointer != pos || GC_REFCOUNT(ht) == 1);\n\n\tif (idx != HT_INVALID_IDX) {\n\t\twhile (1) {\n\t\t\tidx++;\n\t\t\tif (idx >= ht->nNumUsed) {\n\t\t\t\t*pos = HT_INVALID_IDX;\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\tif (Z_TYPE(ht->arData[idx].val) != IS_UNDEF) {\n\t\t\t\t*pos = idx;\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t}\n\t} else {\n \t\treturn FAILURE;\n\t}\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_move_backwards_ex(HashTable *ht, HashPosition *pos)\n{\n\tuint32_t idx = *pos;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(&ht->nInternalPointer != pos || GC_REFCOUNT(ht) == 1);\n\n\tif (idx != HT_INVALID_IDX) {\n\t\twhile (idx > 0) {\n\t\t\tidx--;\n\t\t\tif (Z_TYPE(ht->arData[idx].val) != IS_UNDEF) {\n\t\t\t\t*pos = idx;\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t}\n\t\t*pos = HT_INVALID_IDX;\n \t\treturn SUCCESS;\n\t} else {\n \t\treturn FAILURE;\n\t}\n}\n\n\n/* This function should be made binary safe  */\nZEND_API int ZEND_FASTCALL zend_hash_get_current_key_ex(const HashTable *ht, zend_string **str_index, zend_ulong *num_index, HashPosition *pos)\n{\n\tuint32_t idx = *pos;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tif (idx != HT_INVALID_IDX) {\n\t\tp = ht->arData + idx;\n\t\tif (p->key) {\n\t\t\t*str_index = p->key;\n\t\t\treturn HASH_KEY_IS_STRING;\n\t\t} else {\n\t\t\t*num_index = p->h;\n\t\t\treturn HASH_KEY_IS_LONG;\n\t\t}\n\t}\n\treturn HASH_KEY_NON_EXISTENT;\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_get_current_key_zval_ex(const HashTable *ht, zval *key, HashPosition *pos)\n{\n\tuint32_t idx = *pos;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tif (idx == HT_INVALID_IDX) {\n\t\tZVAL_NULL(key);\n\t} else {\n\t\tp = ht->arData + idx;\n\t\tif (p->key) {\n\t\t\tZVAL_STR_COPY(key, p->key);\n\t\t} else {\n\t\t\tZVAL_LONG(key, p->h);\n\t\t}\n\t}\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_get_current_key_type_ex(HashTable *ht, HashPosition *pos)\n{\n    uint32_t idx = *pos;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tif (idx != HT_INVALID_IDX) {\n\t\tp = ht->arData + idx;\n\t\tif (p->key) {\n\t\t\treturn HASH_KEY_IS_STRING;\n\t\t} else {\n\t\t\treturn HASH_KEY_IS_LONG;\n\t\t}\n\t}\n\treturn HASH_KEY_NON_EXISTENT;\n}\n\n\nZEND_API zval* ZEND_FASTCALL zend_hash_get_current_data_ex(HashTable *ht, HashPosition *pos)\n{\n\tuint32_t idx = *pos;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tif (idx != HT_INVALID_IDX) {\n\t\tp = ht->arData + idx;\n\t\treturn &p->val;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nZEND_API void zend_hash_bucket_swap(Bucket *p, Bucket *q)\n{\n\tzval val;\n\tzend_ulong h;\n\tzend_string *key;\n\n\tZVAL_COPY_VALUE(&val, &p->val);\n\th = p->h;\n\tkey = p->key;\n\n\tZVAL_COPY_VALUE(&p->val, &q->val);\n\tp->h = q->h;\n\tp->key = q->key;\n\n\tZVAL_COPY_VALUE(&q->val, &val);\n\tq->h = h;\n\tq->key = key;\n}\n\nZEND_API void zend_hash_bucket_renum_swap(Bucket *p, Bucket *q)\n{\n\tzval val;\n\n\tZVAL_COPY_VALUE(&val, &p->val);\n\tZVAL_COPY_VALUE(&p->val, &q->val);\n\tZVAL_COPY_VALUE(&q->val, &val);\n}\n\nZEND_API void zend_hash_bucket_packed_swap(Bucket *p, Bucket *q)\n{\n\tzval val;\n\tzend_ulong h;\n\n\tZVAL_COPY_VALUE(&val, &p->val);\n\th = p->h;\n\n\tZVAL_COPY_VALUE(&p->val, &q->val);\n\tp->h = q->h;\n\n\tZVAL_COPY_VALUE(&q->val, &val);\n\tq->h = h;\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_sort_ex(HashTable *ht, sort_func_t sort, compare_func_t compar, zend_bool renumber)\n{\n\tBucket *p;\n\tuint32_t i, j;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (!(ht->nNumOfElements>1) && !(renumber && ht->nNumOfElements>0)) { /* Doesn't require sorting */\n\t\treturn SUCCESS;\n\t}\n\n\tif (ht->nNumUsed == ht->nNumOfElements) {\n\t\ti = ht->nNumUsed;\n\t} else {\n\t\tfor (j = 0, i = 0; j < ht->nNumUsed; j++) {\n\t\t\tp = ht->arData + j;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\t\tif (i != j) {\n\t\t\t\tht->arData[i] = *p;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tsort((void *)ht->arData, i, sizeof(Bucket), compar,\n\t\t\t(swap_func_t)(renumber? zend_hash_bucket_renum_swap :\n\t\t\t\t((ht->u.flags & HASH_FLAG_PACKED) ? zend_hash_bucket_packed_swap : zend_hash_bucket_swap)));\n\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tht->nNumUsed = i;\n\tht->nInternalPointer = 0;\n\n\tif (renumber) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tp = ht->arData + j;\n\t\t\tp->h = j;\n\t\t\tif (p->key) {\n\t\t\t\tzend_string_release(p->key);\n\t\t\t\tp->key = NULL;\n\t\t\t}\n\t\t}\n\n\t\tht->nNextFreeElement = i;\n\t}\n\tif (ht->u.flags & HASH_FLAG_PACKED) {\n\t\tif (!renumber) {\n\t\t\tzend_hash_packed_to_hash(ht);\n\t\t}\n\t} else {\n\t\tif (renumber) {\n\t\t\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\t\t\tBucket *old_buckets = ht->arData;\n\n\t\t\tnew_data = pemalloc(HT_SIZE_EX(ht->nTableSize, HT_MIN_MASK), (ht->u.flags & HASH_FLAG_PERSISTENT));\n\t\t\tht->u.flags |= HASH_FLAG_PACKED | HASH_FLAG_STATIC_KEYS;\n\t\t\tht->nTableMask = HT_MIN_MASK;\n\t\t\tHT_SET_DATA_ADDR(ht, new_data);\n\t\t\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\t\t\tpefree(old_data, ht->u.flags & HASH_FLAG_PERSISTENT & HASH_FLAG_PERSISTENT);\n\t\t\tHT_HASH_RESET_PACKED(ht);\n\t\t} else {\n\t\t\tzend_hash_rehash(ht);\n\t\t}\n\t}\n\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\n\treturn SUCCESS;\n}\n\nstatic zend_always_inline int zend_hash_compare_impl(HashTable *ht1, HashTable *ht2, compare_func_t compar, zend_bool ordered) {\n\tuint32_t idx1, idx2;\n\n\tif (ht1->nNumOfElements != ht2->nNumOfElements) {\n\t\treturn ht1->nNumOfElements > ht2->nNumOfElements ? 1 : -1;\n\t}\n\n\tfor (idx1 = 0, idx2 = 0; idx1 < ht1->nNumUsed; idx1++) {\n\t\tBucket *p1 = ht1->arData + idx1, *p2;\n\t\tzval *pData1, *pData2;\n\t\tint result;\n\n\t\tif (Z_TYPE(p1->val) == IS_UNDEF) continue;\n\t\tif (ordered) {\n\t\t\twhile (1) {\n\t\t\t\tZEND_ASSERT(idx2 != ht2->nNumUsed);\n\t\t\t\tp2 = ht2->arData + idx2;\n\t\t\t\tif (Z_TYPE(p2->val) != IS_UNDEF) break;\n\t\t\t\tidx2++;\n\t\t\t}\n\t\t\tif (p1->key == NULL && p2->key == NULL) { /* numeric indices */\n\t\t\t\tif (p1->h != p2->h) {\n\t\t\t\t\treturn p1->h > p2->h ? 1 : -1;\n\t\t\t\t}\n\t\t\t} else if (p1->key != NULL && p2->key != NULL) { /* string indices */\n\t\t\t\tif (ZSTR_LEN(p1->key) != ZSTR_LEN(p2->key)) {\n\t\t\t\t\treturn ZSTR_LEN(p1->key) > ZSTR_LEN(p2->key) ? 1 : -1;\n\t\t\t\t}\n\n\t\t\t\tresult = memcmp(ZSTR_VAL(p1->key), ZSTR_VAL(p2->key), ZSTR_LEN(p1->key));\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Mixed key types: A string key is considered as larger */\n\t\t\t\treturn p1->key != NULL ? 1 : -1;\n\t\t\t}\n\t\t\tpData2 = &p2->val;\n\t\t\tidx2++;\n\t\t} else {\n\t\t\tif (p1->key == NULL) { /* numeric index */\n\t\t\t\tpData2 = zend_hash_index_find(ht2, p1->h);\n\t\t\t\tif (pData2 == NULL) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else { /* string index */\n\t\t\t\tpData2 = zend_hash_find(ht2, p1->key);\n\t\t\t\tif (pData2 == NULL) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpData1 = &p1->val;\n\t\tif (Z_TYPE_P(pData1) == IS_INDIRECT) {\n\t\t\tpData1 = Z_INDIRECT_P(pData1);\n\t\t}\n\t\tif (Z_TYPE_P(pData2) == IS_INDIRECT) {\n\t\t\tpData2 = Z_INDIRECT_P(pData2);\n\t\t}\n\n\t\tif (Z_TYPE_P(pData1) == IS_UNDEF) {\n\t\t\tif (Z_TYPE_P(pData2) != IS_UNDEF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (Z_TYPE_P(pData2) == IS_UNDEF) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tresult = compar(pData1, pData2);\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nZEND_API int zend_hash_compare(HashTable *ht1, HashTable *ht2, compare_func_t compar, zend_bool ordered)\n{\n\tint result;\n\tIS_CONSISTENT(ht1);\n\tIS_CONSISTENT(ht2);\n\n\tHASH_PROTECT_RECURSION(ht1);\n\tHASH_PROTECT_RECURSION(ht2);\n\tresult = zend_hash_compare_impl(ht1, ht2, compar, ordered);\n\tHASH_UNPROTECT_RECURSION(ht1);\n\tHASH_UNPROTECT_RECURSION(ht2);\n\n\treturn result;\n}\n\n\nZEND_API zval* ZEND_FASTCALL zend_hash_minmax(const HashTable *ht, compare_func_t compar, uint32_t flag)\n{\n\tuint32_t idx;\n\tBucket *p, *res;\n\n\tIS_CONSISTENT(ht);\n\n\tif (ht->nNumOfElements == 0 ) {\n\t\treturn NULL;\n\t}\n\n\tidx = 0;\n\twhile (1) {\n\t\tif (idx == ht->nNumUsed) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (Z_TYPE(ht->arData[idx].val) != IS_UNDEF) break;\n\t\tidx++;\n\t}\n\tres = ht->arData + idx;\n\tfor (; idx < ht->nNumUsed; idx++) {\n\t\tp = ht->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\n\t\tif (flag) {\n\t\t\tif (compar(res, p) < 0) { /* max */\n\t\t\t\tres = p;\n\t\t\t}\n\t\t} else {\n\t\t\tif (compar(res, p) > 0) { /* min */\n\t\t\t\tres = p;\n\t\t\t}\n\t\t}\n\t}\n\treturn &res->val;\n}\n\nZEND_API int ZEND_FASTCALL _zend_handle_numeric_str_ex(const char *key, size_t length, zend_ulong *idx)\n{\n\tregister const char *tmp = key;\n\n\tconst char *end = key + length;\n\n\tif (*tmp == '-') {\n\t\ttmp++;\n\t}\n\n\tif ((*tmp == '0' && length > 1) /* numbers with leading zeros */\n\t || (end - tmp > MAX_LENGTH_OF_LONG - 1) /* number too long */\n\t || (SIZEOF_ZEND_LONG == 4 &&\n\t     end - tmp == MAX_LENGTH_OF_LONG - 1 &&\n\t     *tmp > '2')) { /* overflow */\n\t\treturn 0;\n\t}\n\t*idx = (*tmp - '0');\n\twhile (1) {\n\t\t++tmp;\n\t\tif (tmp == end) {\n\t\t\tif (*key == '-') {\n\t\t\t\tif (*idx-1 > ZEND_LONG_MAX) { /* overflow */\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*idx = 0 - *idx;\n\t\t\t} else if (*idx > ZEND_LONG_MAX) { /* overflow */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (*tmp <= '9' && *tmp >= '0') {\n\t\t\t*idx = (*idx * 10) + (*tmp - '0');\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * indent-tabs-mode: t\n * End:\n */\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | Zend Engine                                                          |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1998-2016 Zend Technologies Ltd. (http://www.zend.com) |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 2.00 of the Zend license,     |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.zend.com/license/2_00.txt.                                |\n   | If you did not receive a copy of the Zend license and are unable to  |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@zend.com so we can mail you a copy immediately.              |\n   +----------------------------------------------------------------------+\n   | Authors: Andi Gutmans <andi@zend.com>                                |\n   |          Zeev Suraski <zeev@zend.com>                                |\n   |          Dmitry Stogov <dmitry@zend.com>                             |\n   +----------------------------------------------------------------------+\n*/\n\n/* $Id$ */\n\n#include \"zend.h\"\n#include \"zend_globals.h\"\n#include \"zend_variables.h\"\n\n#define HT_DEBUG 0\n#if HT_DEBUG\n# define HT_ASSERT(c) ZEND_ASSERT(c)\n#else\n# define HT_ASSERT(c)\n#endif\n\n#define HT_POISONED_PTR ((HashTable *) (intptr_t) -1)\n\n#if ZEND_DEBUG\n/*\n#define HASH_MASK_CONSISTENCY\t0xc0\n*/\n#define HT_OK\t\t\t\t\t0x00\n#define HT_IS_DESTROYING\t\t0x40\n#define HT_DESTROYED\t\t\t0x80\n#define HT_CLEANING\t\t\t\t0xc0\n\nstatic void _zend_is_inconsistent(const HashTable *ht, const char *file, int line)\n{\n\tif ((ht->u.flags & HASH_MASK_CONSISTENCY) == HT_OK) {\n\t\treturn;\n\t}\n\tswitch ((ht->u.flags & HASH_MASK_CONSISTENCY)) {\n\t\tcase HT_IS_DESTROYING:\n\t\t\tzend_output_debug_string(1, \"%s(%d) : ht=%p is being destroyed\", file, line, ht);\n\t\t\tbreak;\n\t\tcase HT_DESTROYED:\n\t\t\tzend_output_debug_string(1, \"%s(%d) : ht=%p is already destroyed\", file, line, ht);\n\t\t\tbreak;\n\t\tcase HT_CLEANING:\n\t\t\tzend_output_debug_string(1, \"%s(%d) : ht=%p is being cleaned\", file, line, ht);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tzend_output_debug_string(1, \"%s(%d) : ht=%p is inconsistent\", file, line, ht);\n\t\t\tbreak;\n\t}\n\tzend_bailout();\n}\n#define IS_CONSISTENT(a) _zend_is_inconsistent(a, __FILE__, __LINE__);\n#define SET_INCONSISTENT(n) do { \\\n\t\t(ht)->u.flags |= n; \\\n\t} while (0)\n#else\n#define IS_CONSISTENT(a)\n#define SET_INCONSISTENT(n)\n#endif\n\n#define HASH_PROTECT_RECURSION(ht)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif ((ht)->u.flags & HASH_FLAG_APPLY_PROTECTION) {\t\t\t\t\t\t\t\t\t\\\n\t\tif (((ht)->u.flags & ZEND_HASH_APPLY_COUNT_MASK) >= (3 << 8)) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tzend_error_noreturn(E_ERROR, \"Nesting level too deep - recursive dependency?\");\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tZEND_HASH_INC_APPLY_COUNT(ht);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define HASH_UNPROTECT_RECURSION(ht)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif ((ht)->u.flags & HASH_FLAG_APPLY_PROTECTION) {\t\t\t\t\t\t\t\t\t\\\n\t\tZEND_HASH_DEC_APPLY_COUNT(ht);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define ZEND_HASH_IF_FULL_DO_RESIZE(ht)\t\t\t\t\\\n\tif ((ht)->nNumUsed >= (ht)->nTableSize) {\t\t\\\n\t\tzend_hash_do_resize(ht);\t\t\t\t\t\\\n\t}\n\nstatic void ZEND_FASTCALL zend_hash_do_resize(HashTable *ht);\n\nstatic uint32_t zend_always_inline zend_hash_check_size(uint32_t nSize)\n{\n#if defined(ZEND_WIN32)\n\tunsigned long index;\n#endif\n\n\t/* Use big enough power of 2 */\n\t/* size should be between HT_MIN_SIZE and HT_MAX_SIZE */\n\tif (nSize < HT_MIN_SIZE) {\n\t\tnSize = HT_MIN_SIZE;\n\t} else if (UNEXPECTED(nSize >= HT_MAX_SIZE)) {\n\t\tzend_error_noreturn(E_ERROR, \"Possible integer overflow in memory allocation (%zu * %zu + %zu)\", nSize, sizeof(Bucket), sizeof(Bucket));\n\t}\n\n#if defined(ZEND_WIN32)\n\tif (BitScanReverse(&index, nSize - 1)) {\n\t\treturn 0x2 << ((31 - index) ^ 0x1f);\n\t} else {\n\t\t/* nSize is ensured to be in the valid range, fall back to it\n\t\t   rather than using an undefined bis scan result. */\n\t\treturn nSize;\n\t}\n#elif (defined(__GNUC__) || __has_builtin(__builtin_clz))  && defined(PHP_HAVE_BUILTIN_CLZ)\n\treturn 0x2 << (__builtin_clz(nSize - 1) ^ 0x1f);\n#else\n\tnSize -= 1;\n\tnSize |= (nSize >> 1);\n\tnSize |= (nSize >> 2);\n\tnSize |= (nSize >> 4);\n\tnSize |= (nSize >> 8);\n\tnSize |= (nSize >> 16);\n\treturn nSize + 1;\n#endif\n}\n\nstatic void zend_always_inline zend_hash_real_init_ex(HashTable *ht, int packed)\n{\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tZEND_ASSERT(!((ht)->u.flags & HASH_FLAG_INITIALIZED));\n\tif (packed) {\n\t\tHT_SET_DATA_ADDR(ht, pemalloc(HT_SIZE(ht), (ht)->u.flags & HASH_FLAG_PERSISTENT));\n\t\t(ht)->u.flags |= HASH_FLAG_INITIALIZED | HASH_FLAG_PACKED;\n\t\tHT_HASH_RESET_PACKED(ht);\n\t} else {\n\t\t(ht)->nTableMask = -(ht)->nTableSize;\n\t\tHT_SET_DATA_ADDR(ht, pemalloc(HT_SIZE(ht), (ht)->u.flags & HASH_FLAG_PERSISTENT));\n\t\t(ht)->u.flags |= HASH_FLAG_INITIALIZED;\n\t\tif (EXPECTED(ht->nTableMask == -8)) {\n\t\t\tBucket *arData = ht->arData;\n\n\t\t\tHT_HASH_EX(arData, -8) = -1;\n\t\t\tHT_HASH_EX(arData, -7) = -1;\n\t\t\tHT_HASH_EX(arData, -6) = -1;\n\t\t\tHT_HASH_EX(arData, -5) = -1;\n\t\t\tHT_HASH_EX(arData, -4) = -1;\n\t\t\tHT_HASH_EX(arData, -3) = -1;\n\t\t\tHT_HASH_EX(arData, -2) = -1;\n\t\t\tHT_HASH_EX(arData, -1) = -1;\n\t\t} else {\n\t\t\tHT_HASH_RESET(ht);\n\t\t}\n\t}\n}\n\nstatic void zend_always_inline zend_hash_check_init(HashTable *ht, int packed)\n{\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tif (UNEXPECTED(!((ht)->u.flags & HASH_FLAG_INITIALIZED))) {\n\t\tzend_hash_real_init_ex(ht, packed);\n\t}\n}\n\n#define CHECK_INIT(ht, packed) \\\n\tzend_hash_check_init(ht, packed)\n\nstatic const uint32_t uninitialized_bucket[-HT_MIN_MASK] =\n\t{HT_INVALID_IDX, HT_INVALID_IDX};\n\nZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n\tht->nTableSize = zend_hash_check_size(nSize);\n}\n\nstatic void ZEND_FASTCALL zend_hash_packed_grow(HashTable *ht)\n{\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tif (ht->nTableSize >= HT_MAX_SIZE) {\n\t\tzend_error_noreturn(E_ERROR, \"Possible integer overflow in memory allocation (%zu * %zu + %zu)\", ht->nTableSize * 2, sizeof(Bucket), sizeof(Bucket));\n\t}\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tht->nTableSize += ht->nTableSize;\n\tHT_SET_DATA_ADDR(ht, perealloc2(HT_GET_DATA_ADDR(ht), HT_SIZE(ht), HT_USED_SIZE(ht), ht->u.flags & HASH_FLAG_PERSISTENT));\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_real_init(HashTable *ht, zend_bool packed)\n{\n\tIS_CONSISTENT(ht);\n\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tzend_hash_real_init_ex(ht, packed);\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_packed_to_hash(HashTable *ht)\n{\n\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\tBucket *old_buckets = ht->arData;\n\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tht->u.flags &= ~HASH_FLAG_PACKED;\n\tnew_data = pemalloc(HT_SIZE_EX(ht->nTableSize, -ht->nTableSize), (ht)->u.flags & HASH_FLAG_PERSISTENT);\n\tht->nTableMask = -ht->nTableSize;\n\tHT_SET_DATA_ADDR(ht, new_data);\n\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\tpefree(old_data, (ht)->u.flags & HASH_FLAG_PERSISTENT);\n\tzend_hash_rehash(ht);\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_to_packed(HashTable *ht)\n{\n\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\tBucket *old_buckets = ht->arData;\n\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tnew_data = pemalloc(HT_SIZE_EX(ht->nTableSize, HT_MIN_MASK), (ht)->u.flags & HASH_FLAG_PERSISTENT);\n\tht->u.flags |= HASH_FLAG_PACKED | HASH_FLAG_STATIC_KEYS;\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, new_data);\n\tHT_HASH_RESET_PACKED(ht);\n\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\tpefree(old_data, (ht)->u.flags & HASH_FLAG_PERSISTENT);\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n}\n\nZEND_API void ZEND_FASTCALL _zend_hash_init_ex(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent, zend_bool bApplyProtection ZEND_FILE_LINE_DC)\n{\n\t_zend_hash_init(ht, nSize, pDestructor, persistent ZEND_FILE_LINE_RELAY_CC);\n\tif (!bApplyProtection) {\n\t\tht->u.flags &= ~HASH_FLAG_APPLY_PROTECTION;\n\t}\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_extend(HashTable *ht, uint32_t nSize, zend_bool packed)\n{\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\tif (nSize == 0) return;\n\tif (UNEXPECTED(!((ht)->u.flags & HASH_FLAG_INITIALIZED))) {\n\t\tif (nSize > ht->nTableSize) {\n\t\t\tht->nTableSize = zend_hash_check_size(nSize);\n\t\t}\n\t\tzend_hash_check_init(ht, packed);\n\t} else {\n\t\tif (packed) {\n\t\t\tZEND_ASSERT(ht->u.flags & HASH_FLAG_PACKED);\n\t\t\tif (nSize > ht->nTableSize) {\n\t\t\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t\t\tht->nTableSize = zend_hash_check_size(nSize);\n\t\t\t\tHT_SET_DATA_ADDR(ht, perealloc2(HT_GET_DATA_ADDR(ht), HT_SIZE(ht), HT_USED_SIZE(ht), ht->u.flags & HASH_FLAG_PERSISTENT));\n\t\t\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t\t\t}\n\t\t} else {\n\t\t\tZEND_ASSERT(!(ht->u.flags & HASH_FLAG_PACKED));\n\t\t\tif (nSize > ht->nTableSize) {\n\t\t\t\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\t\t\t\tBucket *old_buckets = ht->arData;\n\t\t\t\tnSize = zend_hash_check_size(nSize);\n\t\t\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t\t\tnew_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\t\t\tht->nTableSize = nSize;\n\t\t\t\tht->nTableMask = -ht->nTableSize;\n\t\t\t\tHT_SET_DATA_ADDR(ht, new_data);\n\t\t\t\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\t\t\t\tpefree(old_data, ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\t\t\tzend_hash_rehash(ht);\n\t\t\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic uint32_t zend_array_recalc_elements(HashTable *ht)\n{\n       zval *val;\n       uint32_t num = ht->nNumOfElements;\n\n\t   ZEND_HASH_FOREACH_VAL(ht, val) {\n\t\t   if (Z_TYPE_P(val) == IS_UNDEF) continue;\n\t\t   if (Z_TYPE_P(val) == IS_INDIRECT) {\n\t\t\t   if (UNEXPECTED(Z_TYPE_P(Z_INDIRECT_P(val)) == IS_UNDEF)) {\n\t\t\t\t   num--;\n\t\t\t   }\n\t\t   }\n       } ZEND_HASH_FOREACH_END();\n       return num;\n}\n/* }}} */\n\nZEND_API uint32_t zend_array_count(HashTable *ht)\n{\n\tuint32_t num;\n\tif (UNEXPECTED(ht->u.v.flags & HASH_FLAG_HAS_EMPTY_IND)) {\n\t\tnum = zend_array_recalc_elements(ht);\n\t\tif (UNEXPECTED(ht->nNumOfElements == num)) {\n\t\t\tht->u.v.flags &= ~HASH_FLAG_HAS_EMPTY_IND;\n\t\t}\n\t} else if (UNEXPECTED(ht == &EG(symbol_table))) {\n\t\tnum = zend_array_recalc_elements(ht);\n\t} else {\n\t\tnum = zend_hash_num_elements(ht);\n\t}\n\treturn num;\n}\n/* }}} */\n\nZEND_API void ZEND_FASTCALL zend_hash_set_apply_protection(HashTable *ht, zend_bool bApplyProtection)\n{\n\tif (bApplyProtection) {\n\t\tht->u.flags |= HASH_FLAG_APPLY_PROTECTION;\n\t} else {\n\t\tht->u.flags &= ~HASH_FLAG_APPLY_PROTECTION;\n\t}\n}\n\nZEND_API uint32_t ZEND_FASTCALL zend_hash_iterator_add(HashTable *ht, HashPosition pos)\n{\n\tHashTableIterator *iter = EG(ht_iterators);\n\tHashTableIterator *end  = iter + EG(ht_iterators_count);\n\tuint32_t idx;\n\n\tif (EXPECTED(ht->u.v.nIteratorsCount != 255)) {\n\t\tht->u.v.nIteratorsCount++;\n\t}\n\twhile (iter != end) {\n\t\tif (iter->ht == NULL) {\n\t\t\titer->ht = ht;\n\t\t\titer->pos = pos;\n\t\t\tidx = iter - EG(ht_iterators);\n\t\t\tif (idx + 1 > EG(ht_iterators_used)) {\n\t\t\t\tEG(ht_iterators_used) = idx + 1;\n\t\t\t}\n\t\t\treturn idx;\n\t\t}\n\t\titer++;\n\t}\n\tif (EG(ht_iterators) == EG(ht_iterators_slots)) {\n\t\tEG(ht_iterators) = emalloc(sizeof(HashTableIterator) * (EG(ht_iterators_count) + 8));\n\t\tmemcpy(EG(ht_iterators), EG(ht_iterators_slots), sizeof(HashTableIterator) * EG(ht_iterators_count));\n\t} else {\n\t\tEG(ht_iterators) = erealloc(EG(ht_iterators), sizeof(HashTableIterator) * (EG(ht_iterators_count) + 8));\n\t}\n\titer = EG(ht_iterators) + EG(ht_iterators_count);\n\tEG(ht_iterators_count) += 8;\n\titer->ht = ht;\n\titer->pos = pos;\n\tmemset(iter + 1, 0, sizeof(HashTableIterator) * 7);\n\tidx = iter - EG(ht_iterators);\n\tEG(ht_iterators_used) = idx + 1;\n\treturn idx;\n}\n\nZEND_API HashPosition ZEND_FASTCALL zend_hash_iterator_pos(uint32_t idx, HashTable *ht)\n{\n\tHashTableIterator *iter = EG(ht_iterators) + idx;\n\n\tZEND_ASSERT(idx != (uint32_t)-1);\n\tif (iter->pos == HT_INVALID_IDX) {\n\t\treturn HT_INVALID_IDX;\n\t} else if (UNEXPECTED(iter->ht != ht)) {\n\t\tif (EXPECTED(iter->ht) && EXPECTED(iter->ht != HT_POISONED_PTR)\n\t\t\t\t&& EXPECTED(iter->ht->u.v.nIteratorsCount != 255)) {\n\t\t\titer->ht->u.v.nIteratorsCount--;\n\t\t}\n\t\tif (EXPECTED(ht->u.v.nIteratorsCount != 255)) {\n\t\t\tht->u.v.nIteratorsCount++;\n\t\t}\n\t\titer->ht = ht;\n\t\titer->pos = ht->nInternalPointer;\n\t}\n\treturn iter->pos;\n}\n\nZEND_API HashPosition ZEND_FASTCALL zend_hash_iterator_pos_ex(uint32_t idx, zval *array)\n{\n\tHashTable *ht = Z_ARRVAL_P(array);\n\tHashTableIterator *iter = EG(ht_iterators) + idx;\n\n\tZEND_ASSERT(idx != (uint32_t)-1);\n\tif (iter->pos == HT_INVALID_IDX) {\n\t\treturn HT_INVALID_IDX;\n\t} else if (UNEXPECTED(iter->ht != ht)) {\n\t\tif (EXPECTED(iter->ht) && EXPECTED(iter->ht != HT_POISONED_PTR)\n\t\t\t\t&& EXPECTED(iter->ht->u.v.nIteratorsCount != 255)) {\n\t\t\titer->ht->u.v.nIteratorsCount--;\n\t\t}\n\t\tSEPARATE_ARRAY(array);\n\t\tht = Z_ARRVAL_P(array);\n\t\tif (EXPECTED(ht->u.v.nIteratorsCount != 255)) {\n\t\t\tht->u.v.nIteratorsCount++;\n\t\t}\n\t\titer->ht = ht;\n\t\titer->pos = ht->nInternalPointer;\n\t}\n\treturn iter->pos;\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_iterator_del(uint32_t idx)\n{\n\tHashTableIterator *iter = EG(ht_iterators) + idx;\n\n\tZEND_ASSERT(idx != (uint32_t)-1);\n\n\tif (EXPECTED(iter->ht) && EXPECTED(iter->ht != HT_POISONED_PTR)\n\t\t\t&& EXPECTED(iter->ht->u.v.nIteratorsCount != 255)) {\n\t\titer->ht->u.v.nIteratorsCount--;\n\t}\n\titer->ht = NULL;\n\n\tif (idx == EG(ht_iterators_used) - 1) {\n\t\twhile (idx > 0 && EG(ht_iterators)[idx - 1].ht == NULL) {\n\t\t\tidx--;\n\t\t}\n\t\tEG(ht_iterators_used) = idx;\n\t}\n}\n\nstatic zend_never_inline void ZEND_FASTCALL _zend_hash_iterators_remove(HashTable *ht)\n{\n\tHashTableIterator *iter = EG(ht_iterators);\n\tHashTableIterator *end  = iter + EG(ht_iterators_used);\n\n\twhile (iter != end) {\n\t\tif (iter->ht == ht) {\n\t\t\titer->ht = HT_POISONED_PTR;\n\t\t}\n\t\titer++;\n\t}\n}\n\nstatic zend_always_inline void zend_hash_iterators_remove(HashTable *ht)\n{\n\tif (UNEXPECTED(ht->u.v.nIteratorsCount)) {\n\t\t_zend_hash_iterators_remove(ht);\n\t}\n}\n\nZEND_API HashPosition ZEND_FASTCALL zend_hash_iterators_lower_pos(HashTable *ht, HashPosition start)\n{\n\tHashTableIterator *iter = EG(ht_iterators);\n\tHashTableIterator *end  = iter + EG(ht_iterators_used);\n\tHashPosition res = HT_INVALID_IDX;\n\n\twhile (iter != end) {\n\t\tif (iter->ht == ht) {\n\t\t\tif (iter->pos >= start && iter->pos < res) {\n\t\t\t\tres = iter->pos;\n\t\t\t}\n\t\t}\n\t\titer++;\n\t}\n\treturn res;\n}\n\nZEND_API void ZEND_FASTCALL _zend_hash_iterators_update(HashTable *ht, HashPosition from, HashPosition to)\n{\n\tHashTableIterator *iter = EG(ht_iterators);\n\tHashTableIterator *end  = iter + EG(ht_iterators_used);\n\n\twhile (iter != end) {\n\t\tif (iter->ht == ht && iter->pos == from) {\n\t\t\titer->pos = to;\n\t\t}\n\t\titer++;\n\t}\n}\n\nstatic zend_always_inline Bucket *zend_hash_find_bucket(const HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p, *arData;\n\n\th = zend_string_hash_val(key);\n\tarData = ht->arData;\n\tnIndex = h | ht->nTableMask;\n\tidx = HT_HASH_EX(arData, nIndex);\n\twhile (EXPECTED(idx != HT_INVALID_IDX)) {\n\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);\n\t\tif (EXPECTED(p->key == key)) { /* check for the same interned string */\n\t\t\treturn p;\n\t\t} else if (EXPECTED(p->h == h) &&\n\t\t     EXPECTED(p->key) &&\n\t\t     EXPECTED(ZSTR_LEN(p->key) == ZSTR_LEN(key)) &&\n\t\t     EXPECTED(memcmp(ZSTR_VAL(p->key), ZSTR_VAL(key), ZSTR_LEN(key)) == 0)) {\n\t\t\treturn p;\n\t\t}\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn NULL;\n}\n\nstatic zend_always_inline Bucket *zend_hash_str_find_bucket(const HashTable *ht, const char *str, size_t len, zend_ulong h)\n{\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p, *arData;\n\n\tarData = ht->arData;\n\tnIndex = h | ht->nTableMask;\n\tidx = HT_HASH_EX(arData, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tZEND_ASSERT(idx < HT_IDX_TO_HASH(ht->nTableSize));\n\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);\n\t\tif ((p->h == h)\n\t\t\t && p->key\n\t\t\t && (ZSTR_LEN(p->key) == len)\n\t\t\t && !memcmp(ZSTR_VAL(p->key), str, len)) {\n\t\t\treturn p;\n\t\t}\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn NULL;\n}\n\nstatic zend_always_inline Bucket *zend_hash_index_find_bucket(const HashTable *ht, zend_ulong h)\n{\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p, *arData;\n\n\tarData = ht->arData;\n\tnIndex = h | ht->nTableMask;\n\tidx = HT_HASH_EX(arData, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tZEND_ASSERT(idx < HT_IDX_TO_HASH(ht->nTableSize));\n\t\tp = HT_HASH_TO_BUCKET_EX(arData, idx);\n\t\tif (p->h == h && !p->key) {\n\t\t\treturn p;\n\t\t}\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn NULL;\n}\n\nstatic zend_always_inline zval *_zend_hash_add_or_update_i(HashTable *ht, zend_string *key, zval *pData, uint32_t flag ZEND_FILE_LINE_DC)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (UNEXPECTED(!(ht->u.flags & HASH_FLAG_INITIALIZED))) {\n\t\tCHECK_INIT(ht, 0);\n\t\tgoto add_to_hash;\n\t} else if (ht->u.flags & HASH_FLAG_PACKED) {\n\t\tzend_hash_packed_to_hash(ht);\n\t} else if ((flag & HASH_ADD_NEW) == 0) {\n\t\tp = zend_hash_find_bucket(ht, key);\n\n\t\tif (p) {\n\t\t\tzval *data;\n\n\t\t\tif (flag & HASH_ADD) {\n\t\t\t\tif (!(flag & HASH_UPDATE_INDIRECT)) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tZEND_ASSERT(&p->val != pData);\n\t\t\t\tdata = &p->val;\n\t\t\t\tif (Z_TYPE_P(data) == IS_INDIRECT) {\n\t\t\t\t\tdata = Z_INDIRECT_P(data);\n\t\t\t\t\tif (Z_TYPE_P(data) != IS_UNDEF) {\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tZEND_ASSERT(&p->val != pData);\n\t\t\t\tdata = &p->val;\n\t\t\t\tif ((flag & HASH_UPDATE_INDIRECT) && Z_TYPE_P(data) == IS_INDIRECT) {\n\t\t\t\t\tdata = Z_INDIRECT_P(data);\n\t\t\t\t}\n\t\t\t}\n\t\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t\tif (ht->pDestructor) {\n\t\t\t\tht->pDestructor(data);\n\t\t\t}\n\t\t\tZVAL_COPY_VALUE(data, pData);\n\t\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t\t\treturn data;\n\t\t}\n\t}\n\n\tZEND_HASH_IF_FULL_DO_RESIZE(ht);\t\t/* If the Hash table is full, resize it */\n\nadd_to_hash:\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tidx = ht->nNumUsed++;\n\tht->nNumOfElements++;\n\tif (ht->nInternalPointer == HT_INVALID_IDX) {\n\t\tht->nInternalPointer = idx;\n\t}\n\tzend_hash_iterators_update(ht, HT_INVALID_IDX, idx);\n\tp = ht->arData + idx;\n\tp->key = key;\n\tif (!ZSTR_IS_INTERNED(key)) {\n\t\tzend_string_addref(key);\n\t\tht->u.flags &= ~HASH_FLAG_STATIC_KEYS;\n\t\tzend_string_hash_val(key);\n\t}\n\tp->h = h = ZSTR_H(key);\n\tZVAL_COPY_VALUE(&p->val, pData);\n\tnIndex = h | ht->nTableMask;\n\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\n\treturn &p->val;\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_add_or_update(HashTable *ht, zend_string *key, zval *pData, uint32_t flag ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_add_or_update_i(ht, key, pData, flag ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_add(HashTable *ht, zend_string *key, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_add_or_update_i(ht, key, pData, HASH_ADD ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_update(HashTable *ht, zend_string *key, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_add_or_update_i(ht, key, pData, HASH_UPDATE ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_update_ind(HashTable *ht, zend_string *key, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_add_or_update_i(ht, key, pData, HASH_UPDATE | HASH_UPDATE_INDIRECT ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_add_new(HashTable *ht, zend_string *key, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_add_or_update_i(ht, key, pData, HASH_ADD_NEW ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_str_add_or_update(HashTable *ht, const char *str, size_t len, zval *pData, uint32_t flag ZEND_FILE_LINE_DC)\n{\n\tzend_string *key = zend_string_init(str, len, ht->u.flags & HASH_FLAG_PERSISTENT);\n\tzval *ret = _zend_hash_add_or_update_i(ht, key, pData, flag ZEND_FILE_LINE_RELAY_CC);\n\tzend_string_release(key);\n\treturn ret;\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_str_update(HashTable *ht, const char *str, size_t len, zval *pData ZEND_FILE_LINE_DC)\n{\n\tzend_string *key = zend_string_init(str, len, ht->u.flags & HASH_FLAG_PERSISTENT);\n\tzval *ret = _zend_hash_add_or_update_i(ht, key, pData, HASH_UPDATE ZEND_FILE_LINE_RELAY_CC);\n\tzend_string_release(key);\n\treturn ret;\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_str_update_ind(HashTable *ht, const char *str, size_t len, zval *pData ZEND_FILE_LINE_DC)\n{\n\tzend_string *key = zend_string_init(str, len, ht->u.flags & HASH_FLAG_PERSISTENT);\n\tzval *ret = _zend_hash_add_or_update_i(ht, key, pData, HASH_UPDATE | HASH_UPDATE_INDIRECT ZEND_FILE_LINE_RELAY_CC);\n\tzend_string_release(key);\n\treturn ret;\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_str_add(HashTable *ht, const char *str, size_t len, zval *pData ZEND_FILE_LINE_DC)\n{\n\tzend_string *key = zend_string_init(str, len, ht->u.flags & HASH_FLAG_PERSISTENT);\n\tzval *ret = _zend_hash_add_or_update_i(ht, key, pData, HASH_ADD ZEND_FILE_LINE_RELAY_CC);\n\tzend_string_release(key);\n\treturn ret;\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_str_add_new(HashTable *ht, const char *str, size_t len, zval *pData ZEND_FILE_LINE_DC)\n{\n\tzend_string *key = zend_string_init(str, len, ht->u.flags & HASH_FLAG_PERSISTENT);\n\tzval *ret = _zend_hash_add_or_update_i(ht, key, pData, HASH_ADD_NEW ZEND_FILE_LINE_RELAY_CC);\n\tzend_string_delref(key);\n\treturn ret;\n}\n\nZEND_API zval* ZEND_FASTCALL zend_hash_index_add_empty_element(HashTable *ht, zend_ulong h)\n{\n\tzval dummy;\n\n\tZVAL_NULL(&dummy);\n\treturn zend_hash_index_add(ht, h, &dummy);\n}\n\nZEND_API zval* ZEND_FASTCALL zend_hash_add_empty_element(HashTable *ht, zend_string *key)\n{\n\tzval dummy;\n\n\tZVAL_NULL(&dummy);\n\treturn zend_hash_add(ht, key, &dummy);\n}\n\nZEND_API zval* ZEND_FASTCALL zend_hash_str_add_empty_element(HashTable *ht, const char *str, size_t len)\n{\n\tzval dummy;\n\n\tZVAL_NULL(&dummy);\n\treturn zend_hash_str_add(ht, str, len, &dummy);\n}\n\nstatic zend_always_inline zval *_zend_hash_index_add_or_update_i(HashTable *ht, zend_ulong h, zval *pData, uint32_t flag ZEND_FILE_LINE_DC)\n{\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (UNEXPECTED(!(ht->u.flags & HASH_FLAG_INITIALIZED))) {\n\t\tCHECK_INIT(ht, h < ht->nTableSize);\n\t\tif (h < ht->nTableSize) {\n\t\t\tp = ht->arData + h;\n\t\t\tgoto add_to_packed;\n\t\t}\n\t\tgoto add_to_hash;\n\t} else if (ht->u.flags & HASH_FLAG_PACKED) {\n\t\tif (h < ht->nNumUsed) {\n\t\t\tp = ht->arData + h;\n\t\t\tif (Z_TYPE(p->val) != IS_UNDEF) {\n\t\t\t\tif (flag & HASH_ADD) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif (ht->pDestructor) {\n\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t}\n\t\t\t\tZVAL_COPY_VALUE(&p->val, pData);\n\t\t\t\tif ((zend_long)h >= (zend_long)ht->nNextFreeElement) {\n\t\t\t\t\tht->nNextFreeElement = h < ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX;\n\t\t\t\t}\n\t\t\t\treturn &p->val;\n\t\t\t} else { /* we have to keep the order :( */\n\t\t\t\tgoto convert_to_hash;\n\t\t\t}\n\t\t} else if (EXPECTED(h < ht->nTableSize)) {\n\t\t\tp = ht->arData + h;\n\t\t} else if ((h >> 1) < ht->nTableSize &&\n\t\t           (ht->nTableSize >> 1) < ht->nNumOfElements) {\n\t\t\tzend_hash_packed_grow(ht);\n\t\t\tp = ht->arData + h;\n\t\t} else {\n\t\t\tgoto convert_to_hash;\n\t\t}\n\nadd_to_packed:\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t/* incremental initialization of empty Buckets */\n\t\tif ((flag & (HASH_ADD_NEW|HASH_ADD_NEXT)) == (HASH_ADD_NEW|HASH_ADD_NEXT)) {\n\t\t\tht->nNumUsed = h + 1;\n\t\t} else if (h >= ht->nNumUsed) {\n\t\t\tif (h > ht->nNumUsed) {\n\t\t\t\tBucket *q = ht->arData + ht->nNumUsed;\n\t\t\t\twhile (q != p) {\n\t\t\t\t\tZVAL_UNDEF(&q->val);\n\t\t\t\t\tq++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tht->nNumUsed = h + 1;\n\t\t}\n\t\tht->nNumOfElements++;\n\t\tif (ht->nInternalPointer == HT_INVALID_IDX) {\n\t\t\tht->nInternalPointer = h;\n\t\t}\n\t\tzend_hash_iterators_update(ht, HT_INVALID_IDX, h);\n\t\tif ((zend_long)h >= (zend_long)ht->nNextFreeElement) {\n\t\t\tht->nNextFreeElement = h < ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX;\n\t\t}\n\t\tp->h = h;\n\t\tp->key = NULL;\n\t\tZVAL_COPY_VALUE(&p->val, pData);\n\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\n\t\treturn &p->val;\n\nconvert_to_hash:\n\t\tzend_hash_packed_to_hash(ht);\n\t} else if ((flag & HASH_ADD_NEW) == 0) {\n\t\tp = zend_hash_index_find_bucket(ht, h);\n\t\tif (p) {\n\t\t\tif (flag & HASH_ADD) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tZEND_ASSERT(&p->val != pData);\n\t\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\t\tif (ht->pDestructor) {\n\t\t\t\tht->pDestructor(&p->val);\n\t\t\t}\n\t\t\tZVAL_COPY_VALUE(&p->val, pData);\n\t\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t\t\tif ((zend_long)h >= (zend_long)ht->nNextFreeElement) {\n\t\t\t\tht->nNextFreeElement = h < ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX;\n\t\t\t}\n\t\t\treturn &p->val;\n\t\t}\n\t}\n\n\tZEND_HASH_IF_FULL_DO_RESIZE(ht);\t\t/* If the Hash table is full, resize it */\n\nadd_to_hash:\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tidx = ht->nNumUsed++;\n\tht->nNumOfElements++;\n\tif (ht->nInternalPointer == HT_INVALID_IDX) {\n\t\tht->nInternalPointer = idx;\n\t}\n\tzend_hash_iterators_update(ht, HT_INVALID_IDX, idx);\n\tif ((zend_long)h >= (zend_long)ht->nNextFreeElement) {\n\t\tht->nNextFreeElement = h < ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX;\n\t}\n\tp = ht->arData + idx;\n\tp->h = h;\n\tp->key = NULL;\n\tnIndex = h | ht->nTableMask;\n\tZVAL_COPY_VALUE(&p->val, pData);\n\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\n\treturn &p->val;\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_index_add_or_update(HashTable *ht, zend_ulong h, zval *pData, uint32_t flag ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, h, pData, flag ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_index_add(HashTable *ht, zend_ulong h, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, h, pData, HASH_ADD ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_index_add_new(HashTable *ht, zend_ulong h, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, h, pData, HASH_ADD | HASH_ADD_NEW ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_index_update(HashTable *ht, zend_ulong h, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, h, pData, HASH_UPDATE ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_next_index_insert(HashTable *ht, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, ht->nNextFreeElement, pData, HASH_ADD | HASH_ADD_NEXT ZEND_FILE_LINE_RELAY_CC);\n}\n\nZEND_API zval* ZEND_FASTCALL _zend_hash_next_index_insert_new(HashTable *ht, zval *pData ZEND_FILE_LINE_DC)\n{\n\treturn _zend_hash_index_add_or_update_i(ht, ht->nNextFreeElement, pData, HASH_ADD | HASH_ADD_NEW | HASH_ADD_NEXT ZEND_FILE_LINE_RELAY_CC);\n}\n\nstatic void ZEND_FASTCALL zend_hash_do_resize(HashTable *ht)\n{\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (ht->nNumUsed > ht->nNumOfElements + (ht->nNumOfElements >> 5)) { /* additional term is there to amortize the cost of compaction */\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\tzend_hash_rehash(ht);\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t} else if (ht->nTableSize < HT_MAX_SIZE) {\t/* Let's double the table size */\n\t\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\t\tuint32_t nSize = ht->nTableSize + ht->nTableSize;\n\t\tBucket *old_buckets = ht->arData;\n\n\t\tHANDLE_BLOCK_INTERRUPTIONS();\n\t\tnew_data = pemalloc(HT_SIZE_EX(nSize, -nSize), ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\tht->nTableSize = nSize;\n\t\tht->nTableMask = -ht->nTableSize;\n\t\tHT_SET_DATA_ADDR(ht, new_data);\n\t\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\t\tpefree(old_data, ht->u.flags & HASH_FLAG_PERSISTENT);\n\t\tzend_hash_rehash(ht);\n\t\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\t} else {\n\t\tzend_error_noreturn(E_ERROR, \"Possible integer overflow in memory allocation (%zu * %zu + %zu)\", ht->nTableSize * 2, sizeof(Bucket) + sizeof(uint32_t), sizeof(Bucket));\n\t}\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_rehash(HashTable *ht)\n{\n\tBucket *p;\n\tuint32_t nIndex, i;\n\n\tIS_CONSISTENT(ht);\n\n\tif (UNEXPECTED(ht->nNumOfElements == 0)) {\n\t\tif (ht->u.flags & HASH_FLAG_INITIALIZED) {\n\t\t\tht->nNumUsed = 0;\n\t\t\tHT_HASH_RESET(ht);\n\t\t}\n\t\treturn SUCCESS;\n\t}\n\n\tHT_HASH_RESET(ht);\n\ti = 0;\n\tp = ht->arData;\n\tif (ht->nNumUsed == ht->nNumOfElements) {\n\t\tdo {\n\t\t\tnIndex = p->h | ht->nTableMask;\n\t\t\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\t\t\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i);\n\t\t\tp++;\n\t\t} while (++i < ht->nNumUsed);\n\t} else {\n\t\tdo {\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) {\n\t\t\t\tuint32_t j = i;\n\t\t\t\tBucket *q = p;\n\n\t\t\t\tif (EXPECTED(ht->u.v.nIteratorsCount == 0)) {\n\t\t\t\t\twhile (++i < ht->nNumUsed) {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (EXPECTED(Z_TYPE_INFO(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\t\tZVAL_COPY_VALUE(&q->val, &p->val);\n\t\t\t\t\t\t\tq->h = p->h;\n\t\t\t\t\t\t\tnIndex = q->h | ht->nTableMask;\n\t\t\t\t\t\t\tq->key = p->key;\n\t\t\t\t\t\t\tZ_NEXT(q->val) = HT_HASH(ht, nIndex);\n\t\t\t\t\t\t\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(j);\n\t\t\t\t\t\t\tif (UNEXPECTED(ht->nInternalPointer == i)) {\n\t\t\t\t\t\t\t\tht->nInternalPointer = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tuint32_t iter_pos = zend_hash_iterators_lower_pos(ht, 0);\n\n\t\t\t\t\twhile (++i < ht->nNumUsed) {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t\tif (EXPECTED(Z_TYPE_INFO(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\t\tZVAL_COPY_VALUE(&q->val, &p->val);\n\t\t\t\t\t\t\tq->h = p->h;\n\t\t\t\t\t\t\tnIndex = q->h | ht->nTableMask;\n\t\t\t\t\t\t\tq->key = p->key;\n\t\t\t\t\t\t\tZ_NEXT(q->val) = HT_HASH(ht, nIndex);\n\t\t\t\t\t\t\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(j);\n\t\t\t\t\t\t\tif (UNEXPECTED(ht->nInternalPointer == i)) {\n\t\t\t\t\t\t\t\tht->nInternalPointer = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (UNEXPECTED(i == iter_pos)) {\n\t\t\t\t\t\t\t\tzend_hash_iterators_update(ht, i, j);\n\t\t\t\t\t\t\t\titer_pos = zend_hash_iterators_lower_pos(ht, iter_pos + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tht->nNumUsed = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnIndex = p->h | ht->nTableMask;\n\t\t\tZ_NEXT(p->val) = HT_HASH(ht, nIndex);\n\t\t\tHT_HASH(ht, nIndex) = HT_IDX_TO_HASH(i);\n\t\t\tp++;\n\t\t} while (++i < ht->nNumUsed);\n\t}\n\treturn SUCCESS;\n}\n\nstatic zend_always_inline void _zend_hash_del_el_ex(HashTable *ht, uint32_t idx, Bucket *p, Bucket *prev)\n{\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tif (!(ht->u.flags & HASH_FLAG_PACKED)) {\n\t\tif (prev) {\n\t\t\tZ_NEXT(prev->val) = Z_NEXT(p->val);\n\t\t} else {\n\t\t\tHT_HASH(ht, p->h | ht->nTableMask) = Z_NEXT(p->val);\n\t\t}\n\t}\n\tif (HT_IDX_TO_HASH(ht->nNumUsed - 1) == idx) {\n\t\tdo {\n\t\t\tht->nNumUsed--;\n\t\t} while (ht->nNumUsed > 0 && (UNEXPECTED(Z_TYPE(ht->arData[ht->nNumUsed-1].val) == IS_UNDEF)));\n\t}\n\tht->nNumOfElements--;\n\tif (HT_IDX_TO_HASH(ht->nInternalPointer) == idx || UNEXPECTED(ht->u.v.nIteratorsCount)) {\n\t\tuint32_t new_idx;\n\n\t\tnew_idx = idx = HT_HASH_TO_IDX(idx);\n\t\twhile (1) {\n\t\t\tnew_idx++;\n\t\t\tif (new_idx >= ht->nNumUsed) {\n\t\t\t\tnew_idx = HT_INVALID_IDX;\n\t\t\t\tbreak;\n\t\t\t} else if (Z_TYPE(ht->arData[new_idx].val) != IS_UNDEF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ht->nInternalPointer == idx) {\n\t\t\tht->nInternalPointer = new_idx;\n\t\t}\n\t\tzend_hash_iterators_update(ht, idx, new_idx);\n\t}\n\tif (p->key) {\n\t\tzend_string_release(p->key);\n\t}\n\tif (ht->pDestructor) {\n\t\tzval tmp;\n\t\tZVAL_COPY_VALUE(&tmp, &p->val);\n\t\tZVAL_UNDEF(&p->val);\n\t\tht->pDestructor(&tmp);\n\t} else {\n\t\tZVAL_UNDEF(&p->val);\n\t}\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n}\n\nstatic zend_always_inline void _zend_hash_del_el(HashTable *ht, uint32_t idx, Bucket *p)\n{\n\tBucket *prev = NULL;\n\n\tif (!(ht->u.flags & HASH_FLAG_PACKED)) {\n\t\tuint32_t nIndex = p->h | ht->nTableMask;\n\t\tuint32_t i = HT_HASH(ht, nIndex);\n\n\t\tif (i != idx) {\n\t\t\tprev = HT_HASH_TO_BUCKET(ht, i);\n\t\t\twhile (Z_NEXT(prev->val) != idx) {\n\t\t\t\ti = Z_NEXT(prev->val);\n\t\t\t\tprev = HT_HASH_TO_BUCKET(ht, i);\n\t\t\t}\n\t \t}\n\t}\n\n\t_zend_hash_del_el_ex(ht, idx, p, prev);\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_del_bucket(HashTable *ht, Bucket *p)\n{\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(p - ht->arData), p);\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_del(HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\th = zend_string_hash_val(key);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->key == key) ||\n\t\t\t(p->h == h &&\n\t\t     p->key &&\n\t\t     ZSTR_LEN(p->key) == ZSTR_LEN(key) &&\n\t\t     memcmp(ZSTR_VAL(p->key), ZSTR_VAL(key), ZSTR_LEN(key)) == 0)) {\n\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_del_ind(HashTable *ht, zend_string *key)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\th = zend_string_hash_val(key);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->key == key) ||\n\t\t\t(p->h == h &&\n\t\t     p->key &&\n\t\t     ZSTR_LEN(p->key) == ZSTR_LEN(key) &&\n\t\t     memcmp(ZSTR_VAL(p->key), ZSTR_VAL(key), ZSTR_LEN(key)) == 0)) {\n\t\t\tif (Z_TYPE(p->val) == IS_INDIRECT) {\n\t\t\t\tzval *data = Z_INDIRECT(p->val);\n\n\t\t\t\tif (UNEXPECTED(Z_TYPE_P(data) == IS_UNDEF)) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tif (ht->pDestructor) {\n\t\t\t\t\t\tzval tmp;\n\t\t\t\t\t\tZVAL_COPY_VALUE(&tmp, data);\n\t\t\t\t\t\tZVAL_UNDEF(data);\n\t\t\t\t\t\tht->pDestructor(&tmp);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tZVAL_UNDEF(data);\n\t\t\t\t\t}\n\t\t\t\t\tht->u.v.flags |= HASH_FLAG_HAS_EMPTY_IND;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_str_del_ind(HashTable *ht, const char *str, size_t len)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\th = zend_inline_hash_func(str, len);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->h == h)\n\t\t\t && p->key\n\t\t\t && (ZSTR_LEN(p->key) == len)\n\t\t\t && !memcmp(ZSTR_VAL(p->key), str, len)) {\n\t\t\tif (Z_TYPE(p->val) == IS_INDIRECT) {\n\t\t\t\tzval *data = Z_INDIRECT(p->val);\n\n\t\t\t\tif (UNEXPECTED(Z_TYPE_P(data) == IS_UNDEF)) {\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t} else {\n\t\t\t\t\tif (ht->pDestructor) {\n\t\t\t\t\t\tht->pDestructor(data);\n\t\t\t\t\t}\n\t\t\t\t\tZVAL_UNDEF(data);\n\t\t\t\t\tht->u.v.flags |= HASH_FLAG_HAS_EMPTY_IND;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_str_del(HashTable *ht, const char *str, size_t len)\n{\n\tzend_ulong h;\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\th = zend_inline_hash_func(str, len);\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->h == h)\n\t\t\t && p->key\n\t\t\t && (ZSTR_LEN(p->key) == len)\n\t\t\t && !memcmp(ZSTR_VAL(p->key), str, len)) {\n\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_index_del(HashTable *ht, zend_ulong h)\n{\n\tuint32_t nIndex;\n\tuint32_t idx;\n\tBucket *p;\n\tBucket *prev = NULL;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (ht->u.flags & HASH_FLAG_PACKED) {\n\t\tif (h < ht->nNumUsed) {\n\t\t\tp = ht->arData + h;\n\t\t\tif (Z_TYPE(p->val) != IS_UNDEF) {\n\t\t\t\t_zend_hash_del_el_ex(ht, HT_IDX_TO_HASH(h), p, NULL);\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t}\n\t\treturn FAILURE;\n\t}\n\tnIndex = h | ht->nTableMask;\n\n\tidx = HT_HASH(ht, nIndex);\n\twhile (idx != HT_INVALID_IDX) {\n\t\tp = HT_HASH_TO_BUCKET(ht, idx);\n\t\tif ((p->h == h) && (p->key == NULL)) {\n\t\t\t_zend_hash_del_el_ex(ht, idx, p, prev);\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tprev = p;\n\t\tidx = Z_NEXT(p->val);\n\t}\n\treturn FAILURE;\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_destroy(HashTable *ht)\n{\n\tBucket *p, *end;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) <= 1);\n\n\tif (ht->nNumUsed) {\n\t\tp = ht->arData;\n\t\tend = p + ht->nNumUsed;\n\t\tif (ht->pDestructor) {\n\t\t\tSET_INCONSISTENT(HT_IS_DESTROYING);\n\n\t\t\tif (ht->u.flags & (HASH_FLAG_PACKED|HASH_FLAG_STATIC_KEYS)) {\n\t\t\t\tif (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t}\n\t\t\t} else if (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\t\tdo {\n\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t}\n\n\t\t\tSET_INCONSISTENT(HT_DESTROYED);\n\t\t} else {\n\t\t\tif (!(ht->u.flags & (HASH_FLAG_PACKED|HASH_FLAG_STATIC_KEYS))) {\n\t\t\t\tdo {\n\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t}\n\t\t}\n\t\tzend_hash_iterators_remove(ht);\n\t} else if (EXPECTED(!(ht->u.flags & HASH_FLAG_INITIALIZED))) {\n\t\treturn;\n\t}\n\tpefree(HT_GET_DATA_ADDR(ht), ht->u.flags & HASH_FLAG_PERSISTENT);\n}\n\nZEND_API void ZEND_FASTCALL zend_array_destroy(HashTable *ht)\n{\n\tBucket *p, *end;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) <= 1);\n\n\t/* break possible cycles */\n\tGC_REMOVE_FROM_BUFFER(ht);\n\tGC_TYPE_INFO(ht) = IS_NULL | (GC_WHITE << 16);\n\n\tif (ht->nNumUsed) {\n\t\t/* In some rare cases destructors of regular arrays may be changed */\n\t\tif (UNEXPECTED(ht->pDestructor != ZVAL_PTR_DTOR)) {\n\t\t\tzend_hash_destroy(ht);\n\t\t\tgoto free_ht;\n\t\t}\n\n\t\tp = ht->arData;\n\t\tend = p + ht->nNumUsed;\n\t\tSET_INCONSISTENT(HT_IS_DESTROYING);\n\n\t\tif (ht->u.flags & (HASH_FLAG_PACKED|HASH_FLAG_STATIC_KEYS)) {\n\t\t\tdo {\n\t\t\t\ti_zval_ptr_dtor(&p->val ZEND_FILE_LINE_CC);\n\t\t\t} while (++p != end);\n\t\t} else if (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\tdo {\n\t\t\t\ti_zval_ptr_dtor(&p->val ZEND_FILE_LINE_CC);\n\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t}\n\t\t\t} while (++p != end);\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\ti_zval_ptr_dtor(&p->val ZEND_FILE_LINE_CC);\n\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (++p != end);\n\t\t}\n\t\tzend_hash_iterators_remove(ht);\n\t\tSET_INCONSISTENT(HT_DESTROYED);\n\t} else if (EXPECTED(!(ht->u.flags & HASH_FLAG_INITIALIZED))) {\n\t\tgoto free_ht;\n\t}\n\tefree(HT_GET_DATA_ADDR(ht));\nfree_ht:\n\tFREE_HASHTABLE(ht);\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_clean(HashTable *ht)\n{\n\tBucket *p, *end;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (ht->nNumUsed) {\n\t\tp = ht->arData;\n\t\tend = p + ht->nNumUsed;\n\t\tif (ht->pDestructor) {\n\t\t\tif (ht->u.flags & (HASH_FLAG_PACKED|HASH_FLAG_STATIC_KEYS)) {\n\t\t\t\tif (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t}\n\t\t\t} else if (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\t\tdo {\n\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\tht->pDestructor(&p->val);\n\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (++p != end);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(ht->u.flags & (HASH_FLAG_PACKED|HASH_FLAG_STATIC_KEYS))) {\n\t\t\t\tif (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (++p != end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!(ht->u.flags & HASH_FLAG_PACKED)) {\n\t\t\tHT_HASH_RESET(ht);\n\t\t}\n\t}\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nNextFreeElement = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n}\n\nZEND_API void ZEND_FASTCALL zend_symtable_clean(HashTable *ht)\n{\n\tBucket *p, *end;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (ht->nNumUsed) {\n\t\tp = ht->arData;\n\t\tend = p + ht->nNumUsed;\n\t\tif (ht->u.flags & HASH_FLAG_STATIC_KEYS) {\n\t\t\tdo {\n\t\t\t\ti_zval_ptr_dtor(&p->val ZEND_FILE_LINE_CC);\n\t\t\t} while (++p != end);\n\t\t} else if (ht->nNumUsed == ht->nNumOfElements) {\n\t\t\tdo {\n\t\t\t\ti_zval_ptr_dtor(&p->val ZEND_FILE_LINE_CC);\n\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t}\n\t\t\t} while (++p != end);\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tif (EXPECTED(Z_TYPE(p->val) != IS_UNDEF)) {\n\t\t\t\t\ti_zval_ptr_dtor(&p->val ZEND_FILE_LINE_CC);\n\t\t\t\t\tif (EXPECTED(p->key)) {\n\t\t\t\t\t\tzend_string_release(p->key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (++p != end);\n\t\t}\n\t\tHT_HASH_RESET(ht);\n\t}\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nNextFreeElement = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_graceful_destroy(HashTable *ht)\n{\n\tuint32_t idx;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tp = ht->arData;\n\tfor (idx = 0; idx < ht->nNumUsed; idx++, p++) {\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t}\n\tif (ht->u.flags & HASH_FLAG_INITIALIZED) {\n\t\tpefree(HT_GET_DATA_ADDR(ht), ht->u.flags & HASH_FLAG_PERSISTENT);\n\t}\n\n\tSET_INCONSISTENT(HT_DESTROYED);\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_graceful_reverse_destroy(HashTable *ht)\n{\n\tuint32_t idx;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tidx = ht->nNumUsed;\n\tp = ht->arData + ht->nNumUsed;\n\twhile (idx > 0) {\n\t\tidx--;\n\t\tp--;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t}\n\n\tif (ht->u.flags & HASH_FLAG_INITIALIZED) {\n\t\tpefree(HT_GET_DATA_ADDR(ht), ht->u.flags & HASH_FLAG_PERSISTENT);\n\t}\n\n\tSET_INCONSISTENT(HT_DESTROYED);\n}\n\n/* This is used to recurse elements and selectively delete certain entries\n * from a hashtable. apply_func() receives the data and decides if the entry\n * should be deleted or recursion should be stopped. The following three\n * return codes are possible:\n * ZEND_HASH_APPLY_KEEP   - continue\n * ZEND_HASH_APPLY_STOP   - stop iteration\n * ZEND_HASH_APPLY_REMOVE - delete the element, combineable with the former\n */\n\nZEND_API void ZEND_FASTCALL zend_hash_apply(HashTable *ht, apply_func_t apply_func)\n{\n\tuint32_t idx;\n\tBucket *p;\n\tint result;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tHASH_PROTECT_RECURSION(ht);\n\tfor (idx = 0; idx < ht->nNumUsed; idx++) {\n\t\tp = ht->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\tresult = apply_func(&p->val);\n\n\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t\t}\n\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tHASH_UNPROTECT_RECURSION(ht);\n}\n\n\nZEND_API void ZEND_FASTCALL zend_hash_apply_with_argument(HashTable *ht, apply_func_arg_t apply_func, void *argument)\n{\n    uint32_t idx;\n\tBucket *p;\n\tint result;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tHASH_PROTECT_RECURSION(ht);\n\tfor (idx = 0; idx < ht->nNumUsed; idx++) {\n\t\tp = ht->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\tresult = apply_func(&p->val, argument);\n\n\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t\t}\n\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tHASH_UNPROTECT_RECURSION(ht);\n}\n\n\nZEND_API void ZEND_FASTCALL zend_hash_apply_with_arguments(HashTable *ht, apply_func_args_t apply_func, int num_args, ...)\n{\n\tuint32_t idx;\n\tBucket *p;\n\tva_list args;\n\tzend_hash_key hash_key;\n\tint result;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tHASH_PROTECT_RECURSION(ht);\n\n\tfor (idx = 0; idx < ht->nNumUsed; idx++) {\n\t\tp = ht->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\tva_start(args, num_args);\n\t\thash_key.h = p->h;\n\t\thash_key.key = p->key;\n\n\t\tresult = apply_func(&p->val, num_args, args, &hash_key);\n\n\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t\t}\n\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\tva_end(args);\n\t\t\tbreak;\n\t\t}\n\t\tva_end(args);\n\t}\n\n\tHASH_UNPROTECT_RECURSION(ht);\n}\n\n\nZEND_API void ZEND_FASTCALL zend_hash_reverse_apply(HashTable *ht, apply_func_t apply_func)\n{\n\tuint32_t idx;\n\tBucket *p;\n\tint result;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tHASH_PROTECT_RECURSION(ht);\n\tidx = ht->nNumUsed;\n\twhile (idx > 0) {\n\t\tidx--;\n\t\tp = ht->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\n\t\tresult = apply_func(&p->val);\n\n\t\tif (result & ZEND_HASH_APPLY_REMOVE) {\n\t\t\t_zend_hash_del_el(ht, HT_IDX_TO_HASH(idx), p);\n\t\t}\n\t\tif (result & ZEND_HASH_APPLY_STOP) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tHASH_UNPROTECT_RECURSION(ht);\n}\n\n\nZEND_API void ZEND_FASTCALL zend_hash_copy(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor)\n{\n    uint32_t idx;\n\tBucket *p;\n\tzval *new_entry, *data;\n\tzend_bool setTargetPointer;\n\n\tIS_CONSISTENT(source);\n\tIS_CONSISTENT(target);\n\tHT_ASSERT(GC_REFCOUNT(target) == 1);\n\n\tsetTargetPointer = (target->nInternalPointer == HT_INVALID_IDX);\n\tfor (idx = 0; idx < source->nNumUsed; idx++) {\n\t\tp = source->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\n\t\tif (setTargetPointer && source->nInternalPointer == idx) {\n\t\t\ttarget->nInternalPointer = HT_INVALID_IDX;\n\t\t}\n\t\t/* INDIRECT element may point to UNDEF-ined slots */\n\t\tdata = &p->val;\n\t\tif (Z_TYPE_P(data) == IS_INDIRECT) {\n\t\t\tdata = Z_INDIRECT_P(data);\n\t\t\tif (UNEXPECTED(Z_TYPE_P(data) == IS_UNDEF)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (p->key) {\n\t\t\tnew_entry = zend_hash_update(target, p->key, data);\n\t\t} else {\n\t\t\tnew_entry = zend_hash_index_update(target, p->h, data);\n\t\t}\n\t\tif (pCopyConstructor) {\n\t\t\tpCopyConstructor(new_entry);\n\t\t}\n\t}\n\tif (target->nInternalPointer == HT_INVALID_IDX && target->nNumOfElements > 0) {\n\t\tidx = 0;\n\t\twhile (Z_TYPE(target->arData[idx].val) == IS_UNDEF) {\n\t\t\tidx++;\n\t\t}\n\t\ttarget->nInternalPointer = idx;\n\t}\n}\n\n\nstatic zend_always_inline int zend_array_dup_element(HashTable *source, HashTable *target, uint32_t idx, Bucket *p, Bucket *q, int packed, int static_keys, int with_holes)\n{\n\tzval *data = &p->val;\n\n\tif (with_holes) {\n\t\tif (!packed && Z_TYPE_INFO_P(data) == IS_INDIRECT) {\n\t\t\tdata = Z_INDIRECT_P(data);\n\t\t}\n\t\tif (UNEXPECTED(Z_TYPE_INFO_P(data) == IS_UNDEF)) {\n\t\t\treturn 0;\n\t\t}\n\t} else if (!packed) {\n\t\t/* INDIRECT element may point to UNDEF-ined slots */\n\t\tif (Z_TYPE_INFO_P(data) == IS_INDIRECT) {\n\t\t\tdata = Z_INDIRECT_P(data);\n\t\t\tif (UNEXPECTED(Z_TYPE_INFO_P(data) == IS_UNDEF)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tdo {\n\t\tif (Z_OPT_REFCOUNTED_P(data)) {\n\t\t\tif (Z_ISREF_P(data) && Z_REFCOUNT_P(data) == 1 &&\n\t\t\t    (Z_TYPE_P(Z_REFVAL_P(data)) != IS_ARRAY ||\n\t\t\t      Z_ARRVAL_P(Z_REFVAL_P(data)) != source)) {\n\t\t\t\tdata = Z_REFVAL_P(data);\n\t\t\t\tif (!Z_OPT_REFCOUNTED_P(data)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tZ_ADDREF_P(data);\n\t\t}\n\t} while (0);\n\tZVAL_COPY_VALUE(&q->val, data);\n\n\tq->h = p->h;\n\tif (packed) {\n\t\tq->key = NULL;\n\t} else {\n\t\tuint32_t nIndex;\n\n\t\tq->key = p->key;\n\t\tif (!static_keys && q->key) {\n\t\t\tzend_string_addref(q->key);\n\t\t}\n\n\t\tnIndex = q->h | target->nTableMask;\n\t\tZ_NEXT(q->val) = HT_HASH(target, nIndex);\n\t\tHT_HASH(target, nIndex) = HT_IDX_TO_HASH(idx);\n\t}\n\treturn 1;\n}\n\nstatic zend_always_inline void zend_array_dup_packed_elements(HashTable *source, HashTable *target, int with_holes)\n{\n\tBucket *p = source->arData;\n\tBucket *q = target->arData;\n\tBucket *end = p + source->nNumUsed;\n\n\tdo {\n\t\tif (!zend_array_dup_element(source, target, 0, p, q, 1, 1, with_holes)) {\n\t\t\tif (with_holes) {\n\t\t\t\tZVAL_UNDEF(&q->val);\n\t\t\t}\n\t\t}\n\t\tp++; q++;\n\t} while (p != end);\n}\n\nstatic zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)\n{\n\tuint32_t idx = 0;\n\tBucket *p = source->arData;\n\tBucket *q = target->arData;\n\tBucket *end = p + source->nNumUsed;\n\n\tdo {\n\t\tif (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {\n\t\t\tuint32_t target_idx = idx;\n\n\t\t\tidx++; p++;\n\t\t\twhile (p != end) {\n\t\t\t\tif (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {\n\t\t\t\t\tif (source->nInternalPointer == idx) {\n\t\t\t\t\t\ttarget->nInternalPointer = target_idx;\n\t\t\t\t\t}\n\t\t\t\t\ttarget_idx++; q++;\n\t\t\t\t}\n\t\t\t\tidx++; p++;\n\t\t\t}\n\t\t\treturn target_idx;\n\t\t}\n\t\tidx++; p++; q++;\n\t} while (p != end);\n\treturn idx;\n}\n\nZEND_API HashTable* ZEND_FASTCALL zend_array_dup(HashTable *source)\n{\n\tuint32_t idx;\n\tHashTable *target;\n\n\tIS_CONSISTENT(source);\n\n\tALLOC_HASHTABLE(target);\n\tGC_REFCOUNT(target) = 1;\n\tGC_TYPE_INFO(target) = IS_ARRAY;\n\n\ttarget->nTableSize = source->nTableSize;\n\ttarget->pDestructor = source->pDestructor;\n\n\tif (source->nNumUsed == 0) {\n\t\ttarget->u.flags = (source->u.flags & ~(HASH_FLAG_INITIALIZED|HASH_FLAG_PACKED|HASH_FLAG_PERSISTENT|ZEND_HASH_APPLY_COUNT_MASK)) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\t\ttarget->nTableMask = HT_MIN_MASK;\n\t\ttarget->nNumUsed = 0;\n\t\ttarget->nNumOfElements = 0;\n\t\ttarget->nNextFreeElement = 0;\n\t\ttarget->nInternalPointer = HT_INVALID_IDX;\n\t\tHT_SET_DATA_ADDR(target, &uninitialized_bucket);\n\t} else if (GC_FLAGS(source) & IS_ARRAY_IMMUTABLE) {\n\t\ttarget->u.flags = (source->u.flags & ~HASH_FLAG_PERSISTENT) | HASH_FLAG_APPLY_PROTECTION;\n\t\ttarget->nTableMask = source->nTableMask;\n\t\ttarget->nNumUsed = source->nNumUsed;\n\t\ttarget->nNumOfElements = source->nNumOfElements;\n\t\ttarget->nNextFreeElement = source->nNextFreeElement;\n\t\tHT_SET_DATA_ADDR(target, emalloc(HT_SIZE(target)));\n\t\ttarget->nInternalPointer = source->nInternalPointer;\n\t\tmemcpy(HT_GET_DATA_ADDR(target), HT_GET_DATA_ADDR(source), HT_USED_SIZE(source));\n\t\tif (target->nNumOfElements > 0 &&\n\t\t    target->nInternalPointer == HT_INVALID_IDX) {\n\t\t\tidx = 0;\n\t\t\twhile (Z_TYPE(target->arData[idx].val) == IS_UNDEF) {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\ttarget->nInternalPointer = idx;\n\t\t}\n\t} else if (source->u.flags & HASH_FLAG_PACKED) {\n\t\ttarget->u.flags = (source->u.flags & ~(HASH_FLAG_PERSISTENT|ZEND_HASH_APPLY_COUNT_MASK)) | HASH_FLAG_APPLY_PROTECTION;\n\t\ttarget->nTableMask = source->nTableMask;\n\t\ttarget->nNumUsed = source->nNumUsed;\n\t\ttarget->nNumOfElements = source->nNumOfElements;\n\t\ttarget->nNextFreeElement = source->nNextFreeElement;\n\t\tHT_SET_DATA_ADDR(target, emalloc(HT_SIZE(target)));\n\t\ttarget->nInternalPointer = source->nInternalPointer;\n\t\tHT_HASH_RESET_PACKED(target);\n\n\t\tif (target->nNumUsed == target->nNumOfElements) {\n\t\t\tzend_array_dup_packed_elements(source, target, 0);\n\t\t} else {\n\t\t\tzend_array_dup_packed_elements(source, target, 1);\n\t\t}\n\t\tif (target->nNumOfElements > 0 &&\n\t\t    target->nInternalPointer == HT_INVALID_IDX) {\n\t\t\tidx = 0;\n\t\t\twhile (Z_TYPE(target->arData[idx].val) == IS_UNDEF) {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\ttarget->nInternalPointer = idx;\n\t\t}\n\t} else {\n\t\ttarget->u.flags = (source->u.flags & ~(HASH_FLAG_PERSISTENT|ZEND_HASH_APPLY_COUNT_MASK)) | HASH_FLAG_APPLY_PROTECTION;\n\t\ttarget->nTableMask = source->nTableMask;\n\t\ttarget->nNextFreeElement = source->nNextFreeElement;\n\t\ttarget->nInternalPointer = source->nInternalPointer;\n\n\t\tHT_SET_DATA_ADDR(target, emalloc(HT_SIZE(target)));\n\t\tHT_HASH_RESET(target);\n\n\t\tif (target->u.flags & HASH_FLAG_STATIC_KEYS) {\n\t\t\tif (source->nNumUsed == source->nNumOfElements) {\n\t\t\t\tidx = zend_array_dup_elements(source, target, 1, 0);\n\t\t\t} else {\n\t\t\t\tidx = zend_array_dup_elements(source, target, 1, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tif (source->nNumUsed == source->nNumOfElements) {\n\t\t\t\tidx = zend_array_dup_elements(source, target, 0, 0);\n\t\t\t} else {\n\t\t\t\tidx = zend_array_dup_elements(source, target, 0, 1);\n\t\t\t}\n\t\t}\n\t\ttarget->nNumUsed = idx;\n\t\ttarget->nNumOfElements = idx;\n\t\tif (idx > 0 && target->nInternalPointer == HT_INVALID_IDX) {\n\t\t\ttarget->nInternalPointer = 0;\n\t\t}\n\t}\n\treturn target;\n}\n\n\nZEND_API void ZEND_FASTCALL _zend_hash_merge(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor, zend_bool overwrite ZEND_FILE_LINE_DC)\n{\n    uint32_t idx;\n\tBucket *p;\n\tzval *t;\n\n\tIS_CONSISTENT(source);\n\tIS_CONSISTENT(target);\n\tHT_ASSERT(GC_REFCOUNT(target) == 1);\n\n\tif (overwrite) {\n\t\tfor (idx = 0; idx < source->nNumUsed; idx++) {\n\t\t\tp = source->arData + idx;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_INDIRECT) &&\n\t\t\t    UNEXPECTED(Z_TYPE_P(Z_INDIRECT(p->val)) == IS_UNDEF)) {\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (p->key) {\n\t\t\t\tt = _zend_hash_add_or_update_i(target, p->key, &p->val, HASH_UPDATE | HASH_UPDATE_INDIRECT ZEND_FILE_LINE_RELAY_CC);\n\t\t\t\tif (t && pCopyConstructor) {\n\t\t\t\t\tpCopyConstructor(t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt = zend_hash_index_update(target, p->h, &p->val);\n\t\t\t\tif (t && pCopyConstructor) {\n\t\t\t\t\tpCopyConstructor(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (idx = 0; idx < source->nNumUsed; idx++) {\n\t\t\tp = source->arData + idx;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_INDIRECT) &&\n\t\t\t    UNEXPECTED(Z_TYPE_P(Z_INDIRECT(p->val)) == IS_UNDEF)) {\n\t\t\t    continue;\n\t\t\t}\n\t\t\tif (p->key) {\n\t\t\t\tt = _zend_hash_add_or_update_i(target, p->key, &p->val, HASH_ADD | HASH_UPDATE_INDIRECT ZEND_FILE_LINE_RELAY_CC);\n\t\t\t\tif (t && pCopyConstructor) {\n\t\t\t\t\tpCopyConstructor(t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt = zend_hash_index_add(target, p->h, &p->val);\n\t\t\t\tif (t && pCopyConstructor) {\n\t\t\t\t\tpCopyConstructor(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (target->nNumOfElements > 0) {\n\t\tidx = 0;\n\t\twhile (Z_TYPE(target->arData[idx].val) == IS_UNDEF) {\n\t\t\tidx++;\n\t\t}\n\t\ttarget->nInternalPointer = idx;\n\t}\n}\n\n\nstatic zend_bool ZEND_FASTCALL zend_hash_replace_checker_wrapper(HashTable *target, zval *source_data, Bucket *p, void *pParam, merge_checker_func_t merge_checker_func)\n{\n\tzend_hash_key hash_key;\n\n\thash_key.h = p->h;\n\thash_key.key = p->key;\n\treturn merge_checker_func(target, source_data, &hash_key, pParam);\n}\n\n\nZEND_API void ZEND_FASTCALL zend_hash_merge_ex(HashTable *target, HashTable *source, copy_ctor_func_t pCopyConstructor, merge_checker_func_t pMergeSource, void *pParam)\n{\n\tuint32_t idx;\n\tBucket *p;\n\tzval *t;\n\n\tIS_CONSISTENT(source);\n\tIS_CONSISTENT(target);\n\tHT_ASSERT(GC_REFCOUNT(target) == 1);\n\n\tfor (idx = 0; idx < source->nNumUsed; idx++) {\n\t\tp = source->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\tif (zend_hash_replace_checker_wrapper(target, &p->val, p, pParam, pMergeSource)) {\n\t\t\tt = zend_hash_update(target, p->key, &p->val);\n\t\t\tif (t && pCopyConstructor) {\n\t\t\t\tpCopyConstructor(t);\n\t\t\t}\n\t\t}\n\t}\n\tif (target->nNumOfElements > 0) {\n\t\tidx = 0;\n\t\twhile (Z_TYPE(target->arData[idx].val) == IS_UNDEF) {\n\t\t\tidx++;\n\t\t}\n\t\ttarget->nInternalPointer = idx;\n\t}\n}\n\n\n/* Returns the hash table data if found and NULL if not. */\nZEND_API zval* ZEND_FASTCALL zend_hash_find(const HashTable *ht, zend_string *key)\n{\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\n\tp = zend_hash_find_bucket(ht, key);\n\treturn p ? &p->val : NULL;\n}\n\nZEND_API zval* ZEND_FASTCALL zend_hash_str_find(const HashTable *ht, const char *str, size_t len)\n{\n\tzend_ulong h;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\n\th = zend_inline_hash_func(str, len);\n\tp = zend_hash_str_find_bucket(ht, str, len, h);\n\treturn p ? &p->val : NULL;\n}\n\nZEND_API zend_bool ZEND_FASTCALL zend_hash_exists(const HashTable *ht, zend_string *key)\n{\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\n\tp = zend_hash_find_bucket(ht, key);\n\treturn p ? 1 : 0;\n}\n\nZEND_API zend_bool ZEND_FASTCALL zend_hash_str_exists(const HashTable *ht, const char *str, size_t len)\n{\n\tzend_ulong h;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\n\th = zend_inline_hash_func(str, len);\n\tp = zend_hash_str_find_bucket(ht, str, len, h);\n\treturn p ? 1 : 0;\n}\n\nZEND_API zval* ZEND_FASTCALL zend_hash_index_find(const HashTable *ht, zend_ulong h)\n{\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\n\tif (ht->u.flags & HASH_FLAG_PACKED) {\n\t\tif (h < ht->nNumUsed) {\n\t\t\tp = ht->arData + h;\n\t\t\tif (Z_TYPE(p->val) != IS_UNDEF) {\n\t\t\t\treturn &p->val;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\n\tp = zend_hash_index_find_bucket(ht, h);\n\treturn p ? &p->val : NULL;\n}\n\n\nZEND_API zend_bool ZEND_FASTCALL zend_hash_index_exists(const HashTable *ht, zend_ulong h)\n{\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\n\tif (ht->u.flags & HASH_FLAG_PACKED) {\n\t\tif (h < ht->nNumUsed) {\n\t\t\tif (Z_TYPE(ht->arData[h].val) != IS_UNDEF) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tp = zend_hash_index_find_bucket(ht, h);\n\treturn p ? 1 : 0;\n}\n\n\nZEND_API void ZEND_FASTCALL zend_hash_internal_pointer_reset_ex(HashTable *ht, HashPosition *pos)\n{\n    uint32_t idx;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(&ht->nInternalPointer != pos || GC_REFCOUNT(ht) == 1);\n\n\tfor (idx = 0; idx < ht->nNumUsed; idx++) {\n\t\tif (Z_TYPE(ht->arData[idx].val) != IS_UNDEF) {\n\t\t\t*pos = idx;\n\t\t\treturn;\n\t\t}\n\t}\n\t*pos = HT_INVALID_IDX;\n}\n\n\n/* This function will be extremely optimized by remembering\n * the end of the list\n */\nZEND_API void ZEND_FASTCALL zend_hash_internal_pointer_end_ex(HashTable *ht, HashPosition *pos)\n{\n\tuint32_t idx;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(&ht->nInternalPointer != pos || GC_REFCOUNT(ht) == 1);\n\n\tidx = ht->nNumUsed;\n\twhile (idx > 0) {\n\t\tidx--;\n\t\tif (Z_TYPE(ht->arData[idx].val) != IS_UNDEF) {\n\t\t\t*pos = idx;\n\t\t\treturn;\n\t\t}\n\t}\n\t*pos = HT_INVALID_IDX;\n}\n\n\nZEND_API int ZEND_FASTCALL zend_hash_move_forward_ex(HashTable *ht, HashPosition *pos)\n{\n\tuint32_t idx = *pos;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(&ht->nInternalPointer != pos || GC_REFCOUNT(ht) == 1);\n\n\tif (idx != HT_INVALID_IDX) {\n\t\twhile (1) {\n\t\t\tidx++;\n\t\t\tif (idx >= ht->nNumUsed) {\n\t\t\t\t*pos = HT_INVALID_IDX;\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t\tif (Z_TYPE(ht->arData[idx].val) != IS_UNDEF) {\n\t\t\t\t*pos = idx;\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t}\n\t} else {\n \t\treturn FAILURE;\n\t}\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_move_backwards_ex(HashTable *ht, HashPosition *pos)\n{\n\tuint32_t idx = *pos;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(&ht->nInternalPointer != pos || GC_REFCOUNT(ht) == 1);\n\n\tif (idx != HT_INVALID_IDX) {\n\t\twhile (idx > 0) {\n\t\t\tidx--;\n\t\t\tif (Z_TYPE(ht->arData[idx].val) != IS_UNDEF) {\n\t\t\t\t*pos = idx;\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t}\n\t\t*pos = HT_INVALID_IDX;\n \t\treturn SUCCESS;\n\t} else {\n \t\treturn FAILURE;\n\t}\n}\n\n\n/* This function should be made binary safe  */\nZEND_API int ZEND_FASTCALL zend_hash_get_current_key_ex(const HashTable *ht, zend_string **str_index, zend_ulong *num_index, HashPosition *pos)\n{\n\tuint32_t idx = *pos;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tif (idx != HT_INVALID_IDX) {\n\t\tp = ht->arData + idx;\n\t\tif (p->key) {\n\t\t\t*str_index = p->key;\n\t\t\treturn HASH_KEY_IS_STRING;\n\t\t} else {\n\t\t\t*num_index = p->h;\n\t\t\treturn HASH_KEY_IS_LONG;\n\t\t}\n\t}\n\treturn HASH_KEY_NON_EXISTENT;\n}\n\nZEND_API void ZEND_FASTCALL zend_hash_get_current_key_zval_ex(const HashTable *ht, zval *key, HashPosition *pos)\n{\n\tuint32_t idx = *pos;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tif (idx == HT_INVALID_IDX) {\n\t\tZVAL_NULL(key);\n\t} else {\n\t\tp = ht->arData + idx;\n\t\tif (p->key) {\n\t\t\tZVAL_STR_COPY(key, p->key);\n\t\t} else {\n\t\t\tZVAL_LONG(key, p->h);\n\t\t}\n\t}\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_get_current_key_type_ex(HashTable *ht, HashPosition *pos)\n{\n    uint32_t idx = *pos;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tif (idx != HT_INVALID_IDX) {\n\t\tp = ht->arData + idx;\n\t\tif (p->key) {\n\t\t\treturn HASH_KEY_IS_STRING;\n\t\t} else {\n\t\t\treturn HASH_KEY_IS_LONG;\n\t\t}\n\t}\n\treturn HASH_KEY_NON_EXISTENT;\n}\n\n\nZEND_API zval* ZEND_FASTCALL zend_hash_get_current_data_ex(HashTable *ht, HashPosition *pos)\n{\n\tuint32_t idx = *pos;\n\tBucket *p;\n\n\tIS_CONSISTENT(ht);\n\tif (idx != HT_INVALID_IDX) {\n\t\tp = ht->arData + idx;\n\t\treturn &p->val;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nZEND_API void zend_hash_bucket_swap(Bucket *p, Bucket *q)\n{\n\tzval val;\n\tzend_ulong h;\n\tzend_string *key;\n\n\tZVAL_COPY_VALUE(&val, &p->val);\n\th = p->h;\n\tkey = p->key;\n\n\tZVAL_COPY_VALUE(&p->val, &q->val);\n\tp->h = q->h;\n\tp->key = q->key;\n\n\tZVAL_COPY_VALUE(&q->val, &val);\n\tq->h = h;\n\tq->key = key;\n}\n\nZEND_API void zend_hash_bucket_renum_swap(Bucket *p, Bucket *q)\n{\n\tzval val;\n\n\tZVAL_COPY_VALUE(&val, &p->val);\n\tZVAL_COPY_VALUE(&p->val, &q->val);\n\tZVAL_COPY_VALUE(&q->val, &val);\n}\n\nZEND_API void zend_hash_bucket_packed_swap(Bucket *p, Bucket *q)\n{\n\tzval val;\n\tzend_ulong h;\n\n\tZVAL_COPY_VALUE(&val, &p->val);\n\th = p->h;\n\n\tZVAL_COPY_VALUE(&p->val, &q->val);\n\tp->h = q->h;\n\n\tZVAL_COPY_VALUE(&q->val, &val);\n\tq->h = h;\n}\n\nZEND_API int ZEND_FASTCALL zend_hash_sort_ex(HashTable *ht, sort_func_t sort, compare_func_t compar, zend_bool renumber)\n{\n\tBucket *p;\n\tuint32_t i, j;\n\n\tIS_CONSISTENT(ht);\n\tHT_ASSERT(GC_REFCOUNT(ht) == 1);\n\n\tif (!(ht->nNumOfElements>1) && !(renumber && ht->nNumOfElements>0)) { /* Doesn't require sorting */\n\t\treturn SUCCESS;\n\t}\n\n\tif (ht->nNumUsed == ht->nNumOfElements) {\n\t\ti = ht->nNumUsed;\n\t} else {\n\t\tfor (j = 0, i = 0; j < ht->nNumUsed; j++) {\n\t\t\tp = ht->arData + j;\n\t\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\t\t\tif (i != j) {\n\t\t\t\tht->arData[i] = *p;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\n\tsort((void *)ht->arData, i, sizeof(Bucket), compar,\n\t\t\t(swap_func_t)(renumber? zend_hash_bucket_renum_swap :\n\t\t\t\t((ht->u.flags & HASH_FLAG_PACKED) ? zend_hash_bucket_packed_swap : zend_hash_bucket_swap)));\n\n\tHANDLE_BLOCK_INTERRUPTIONS();\n\tht->nNumUsed = i;\n\tht->nInternalPointer = 0;\n\n\tif (renumber) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tp = ht->arData + j;\n\t\t\tp->h = j;\n\t\t\tif (p->key) {\n\t\t\t\tzend_string_release(p->key);\n\t\t\t\tp->key = NULL;\n\t\t\t}\n\t\t}\n\n\t\tht->nNextFreeElement = i;\n\t}\n\tif (ht->u.flags & HASH_FLAG_PACKED) {\n\t\tif (!renumber) {\n\t\t\tzend_hash_packed_to_hash(ht);\n\t\t}\n\t} else {\n\t\tif (renumber) {\n\t\t\tvoid *new_data, *old_data = HT_GET_DATA_ADDR(ht);\n\t\t\tBucket *old_buckets = ht->arData;\n\n\t\t\tnew_data = pemalloc(HT_SIZE_EX(ht->nTableSize, HT_MIN_MASK), (ht->u.flags & HASH_FLAG_PERSISTENT));\n\t\t\tht->u.flags |= HASH_FLAG_PACKED | HASH_FLAG_STATIC_KEYS;\n\t\t\tht->nTableMask = HT_MIN_MASK;\n\t\t\tHT_SET_DATA_ADDR(ht, new_data);\n\t\t\tmemcpy(ht->arData, old_buckets, sizeof(Bucket) * ht->nNumUsed);\n\t\t\tpefree(old_data, ht->u.flags & HASH_FLAG_PERSISTENT & HASH_FLAG_PERSISTENT);\n\t\t\tHT_HASH_RESET_PACKED(ht);\n\t\t} else {\n\t\t\tzend_hash_rehash(ht);\n\t\t}\n\t}\n\n\tHANDLE_UNBLOCK_INTERRUPTIONS();\n\n\treturn SUCCESS;\n}\n\nstatic zend_always_inline int zend_hash_compare_impl(HashTable *ht1, HashTable *ht2, compare_func_t compar, zend_bool ordered) {\n\tuint32_t idx1, idx2;\n\n\tif (ht1->nNumOfElements != ht2->nNumOfElements) {\n\t\treturn ht1->nNumOfElements > ht2->nNumOfElements ? 1 : -1;\n\t}\n\n\tfor (idx1 = 0, idx2 = 0; idx1 < ht1->nNumUsed; idx1++) {\n\t\tBucket *p1 = ht1->arData + idx1, *p2;\n\t\tzval *pData1, *pData2;\n\t\tint result;\n\n\t\tif (Z_TYPE(p1->val) == IS_UNDEF) continue;\n\t\tif (ordered) {\n\t\t\twhile (1) {\n\t\t\t\tZEND_ASSERT(idx2 != ht2->nNumUsed);\n\t\t\t\tp2 = ht2->arData + idx2;\n\t\t\t\tif (Z_TYPE(p2->val) != IS_UNDEF) break;\n\t\t\t\tidx2++;\n\t\t\t}\n\t\t\tif (p1->key == NULL && p2->key == NULL) { /* numeric indices */\n\t\t\t\tif (p1->h != p2->h) {\n\t\t\t\t\treturn p1->h > p2->h ? 1 : -1;\n\t\t\t\t}\n\t\t\t} else if (p1->key != NULL && p2->key != NULL) { /* string indices */\n\t\t\t\tif (ZSTR_LEN(p1->key) != ZSTR_LEN(p2->key)) {\n\t\t\t\t\treturn ZSTR_LEN(p1->key) > ZSTR_LEN(p2->key) ? 1 : -1;\n\t\t\t\t}\n\n\t\t\t\tresult = memcmp(ZSTR_VAL(p1->key), ZSTR_VAL(p2->key), ZSTR_LEN(p1->key));\n\t\t\t\tif (result != 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* Mixed key types: A string key is considered as larger */\n\t\t\t\treturn p1->key != NULL ? 1 : -1;\n\t\t\t}\n\t\t\tpData2 = &p2->val;\n\t\t\tidx2++;\n\t\t} else {\n\t\t\tif (p1->key == NULL) { /* numeric index */\n\t\t\t\tpData2 = zend_hash_index_find(ht2, p1->h);\n\t\t\t\tif (pData2 == NULL) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else { /* string index */\n\t\t\t\tpData2 = zend_hash_find(ht2, p1->key);\n\t\t\t\tif (pData2 == NULL) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpData1 = &p1->val;\n\t\tif (Z_TYPE_P(pData1) == IS_INDIRECT) {\n\t\t\tpData1 = Z_INDIRECT_P(pData1);\n\t\t}\n\t\tif (Z_TYPE_P(pData2) == IS_INDIRECT) {\n\t\t\tpData2 = Z_INDIRECT_P(pData2);\n\t\t}\n\n\t\tif (Z_TYPE_P(pData1) == IS_UNDEF) {\n\t\t\tif (Z_TYPE_P(pData2) != IS_UNDEF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (Z_TYPE_P(pData2) == IS_UNDEF) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tresult = compar(pData1, pData2);\n\t\t\tif (result != 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nZEND_API int zend_hash_compare(HashTable *ht1, HashTable *ht2, compare_func_t compar, zend_bool ordered)\n{\n\tint result;\n\tIS_CONSISTENT(ht1);\n\tIS_CONSISTENT(ht2);\n\n\tHASH_PROTECT_RECURSION(ht1);\n\tHASH_PROTECT_RECURSION(ht2);\n\tresult = zend_hash_compare_impl(ht1, ht2, compar, ordered);\n\tHASH_UNPROTECT_RECURSION(ht1);\n\tHASH_UNPROTECT_RECURSION(ht2);\n\n\treturn result;\n}\n\n\nZEND_API zval* ZEND_FASTCALL zend_hash_minmax(const HashTable *ht, compare_func_t compar, uint32_t flag)\n{\n\tuint32_t idx;\n\tBucket *p, *res;\n\n\tIS_CONSISTENT(ht);\n\n\tif (ht->nNumOfElements == 0 ) {\n\t\treturn NULL;\n\t}\n\n\tidx = 0;\n\twhile (1) {\n\t\tif (idx == ht->nNumUsed) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (Z_TYPE(ht->arData[idx].val) != IS_UNDEF) break;\n\t\tidx++;\n\t}\n\tres = ht->arData + idx;\n\tfor (; idx < ht->nNumUsed; idx++) {\n\t\tp = ht->arData + idx;\n\t\tif (UNEXPECTED(Z_TYPE(p->val) == IS_UNDEF)) continue;\n\n\t\tif (flag) {\n\t\t\tif (compar(res, p) < 0) { /* max */\n\t\t\t\tres = p;\n\t\t\t}\n\t\t} else {\n\t\t\tif (compar(res, p) > 0) { /* min */\n\t\t\t\tres = p;\n\t\t\t}\n\t\t}\n\t}\n\treturn &res->val;\n}\n\nZEND_API int ZEND_FASTCALL _zend_handle_numeric_str_ex(const char *key, size_t length, zend_ulong *idx)\n{\n\tregister const char *tmp = key;\n\n\tconst char *end = key + length;\n\n\tif (*tmp == '-') {\n\t\ttmp++;\n\t}\n\n\tif ((*tmp == '0' && length > 1) /* numbers with leading zeros */\n\t || (end - tmp > MAX_LENGTH_OF_LONG - 1) /* number too long */\n\t || (SIZEOF_ZEND_LONG == 4 &&\n\t     end - tmp == MAX_LENGTH_OF_LONG - 1 &&\n\t     *tmp > '2')) { /* overflow */\n\t\treturn 0;\n\t}\n\t*idx = (*tmp - '0');\n\twhile (1) {\n\t\t++tmp;\n\t\tif (tmp == end) {\n\t\t\tif (*key == '-') {\n\t\t\t\tif (*idx-1 > ZEND_LONG_MAX) { /* overflow */\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t*idx = 0 - *idx;\n\t\t\t} else if (*idx > ZEND_LONG_MAX) { /* overflow */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tif (*tmp <= '9' && *tmp >= '0') {\n\t\t\t*idx = (*idx * 10) + (*tmp - '0');\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * indent-tabs-mode: t\n * End:\n */\n"], "filenames": ["Zend/zend_hash.c"], "buggy_code_start_loc": [178], "buggy_code_end_loc": [185], "fixing_code_start_loc": [177], "fixing_code_end_loc": [186], "type": "CWE-190", "message": "Zend/zend_hash.c in PHP before 7.0.15 and 7.1.x before 7.1.1 mishandles certain cases that require large array allocations, which allows remote attackers to execute arbitrary code or cause a denial of service (integer overflow, uninitialized memory access, and use of arbitrary destructor function pointers) via crafted serialized data.", "other": {"cve": {"id": "CVE-2017-5340", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-11T06:59:00.160", "lastModified": "2022-07-20T16:46:08.717", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Zend/zend_hash.c in PHP before 7.0.15 and 7.1.x before 7.1.1 mishandles certain cases that require large array allocations, which allows remote attackers to execute arbitrary code or cause a denial of service (integer overflow, uninitialized memory access, and use of arbitrary destructor function pointers) via crafted serialized data."}, {"lang": "es", "value": "Zend/zend_hash.c en PHP en versiones anteriores a 7.0.15 y 7.1.x en versiones anteriores a 7.1.1 no maneja adecuadamente ciertos casos que requieren asignaciones de array grandes, lo que permite a atacantes remotos ejecutar c\u00f3digo arbitrario o provocar una denegaci\u00f3n de servicio (desbordamiento de enteros, acceso a memoria no inicializada y uso de punteros de la funci\u00f3n de destructor arbitrarios) a trav\u00e9s de datos serializados manipulados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.15", "matchCriteriaId": "3A59822F-11EA-4F4D-9721-6D3DD9842FC8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.1.0", "versionEndExcluding": "7.1.1", "matchCriteriaId": "473456E3-B45F-46C0-AEF8-72D78487CF38"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:clustered_data_ontap:-:*:*:*:*:*:*:*", "matchCriteriaId": "1FE996B1-6951-4F85-AA58-B99A379D2163"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/95371", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1037659", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1296", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.php.net/bug.php?id=73832", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "VDB Entry", "Vendor Advisory"]}, {"url": "https://github.com/php/php-src/commit/4cc0286f2f3780abc6084bcdae5dce595daa3c12", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20180112-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/php/php-src/commit/4cc0286f2f3780abc6084bcdae5dce595daa3c12"}}