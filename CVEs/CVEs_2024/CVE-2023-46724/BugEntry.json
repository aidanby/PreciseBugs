{"buggy_code": ["/*\n * Copyright (C) 1996-2023 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n/* DEBUG: section 23    URL Parsing */\n\n#include \"squid.h\"\n#include \"anyp/Uri.h\"\n#include \"base/Raw.h\"\n#include \"globals.h\"\n#include \"HttpRequest.h\"\n#include \"parser/Tokenizer.h\"\n#include \"rfc1738.h\"\n#include \"SquidConfig.h\"\n#include \"SquidMath.h\"\n#include \"SquidString.h\"\n\nstatic const char valid_hostname_chars_u[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"0123456789-._\"\n    \"[:]\"\n    ;\nstatic const char valid_hostname_chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"0123456789-.\"\n    \"[:]\"\n    ;\n\n/// Characters which are valid within a URI userinfo section\nstatic const CharacterSet &\nUserInfoChars()\n{\n    /*\n     * RFC 3986 section 3.2.1\n     *\n     *  userinfo      = *( unreserved / pct-encoded / sub-delims / \":\" )\n     *  unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n     *  pct-encoded   = \"%\" HEXDIG HEXDIG\n     *  sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n     */\n    static const auto userInfoValid = CharacterSet(\"userinfo\", \":-._~%!$&'()*+,;=\") +\n                                      CharacterSet::ALPHA +\n                                      CharacterSet::DIGIT;\n    return userInfoValid;\n}\n\n/**\n * Governed by RFC 3986 section 2.1\n */\nSBuf\nAnyP::Uri::Encode(const SBuf &buf, const CharacterSet &ignore)\n{\n    if (buf.isEmpty())\n        return buf;\n\n    Parser::Tokenizer tk(buf);\n    SBuf goodSection;\n    // optimization for the arguably common \"no encoding necessary\" case\n    if (tk.prefix(goodSection, ignore) && tk.atEnd())\n        return buf;\n\n    SBuf output;\n    output.reserveSpace(buf.length() * 3); // worst case: encode all chars\n    output.append(goodSection); // may be empty\n\n    while (!tk.atEnd()) {\n        // TODO: Add Tokenizer::parseOne(void).\n        const auto ch = tk.remaining()[0];\n        output.appendf(\"%%%02X\", static_cast<unsigned int>(static_cast<unsigned char>(ch))); // TODO: Optimize using a table\n        (void)tk.skip(ch);\n\n        if (tk.prefix(goodSection, ignore))\n            output.append(goodSection);\n    }\n\n    return output;\n}\n\nconst SBuf &\nAnyP::Uri::Asterisk()\n{\n    static SBuf star(\"*\");\n    return star;\n}\n\nconst SBuf &\nAnyP::Uri::SlashPath()\n{\n    static SBuf slash(\"/\");\n    return slash;\n}\n\nvoid\nAnyP::Uri::host(const char *src)\n{\n    hostAddr_.fromHost(src);\n    if (hostAddr_.isAnyAddr()) {\n        xstrncpy(host_, src, sizeof(host_));\n        hostIsNumeric_ = false;\n    } else {\n        hostAddr_.toHostStr(host_, sizeof(host_));\n        debugs(23, 3, \"given IP: \" << hostAddr_);\n        hostIsNumeric_ = 1;\n    }\n    touch();\n}\n\nSBuf\nAnyP::Uri::hostOrIp() const\n{\n    if (hostIsNumeric()) {\n        static char ip[MAX_IPSTRLEN];\n        const auto hostStrLen = hostIP().toHostStr(ip, sizeof(ip));\n        return SBuf(ip, hostStrLen);\n    } else\n        return SBuf(host());\n}\n\nconst SBuf &\nAnyP::Uri::path() const\n{\n    // RFC 3986 section 3.3 says path can be empty (path-abempty).\n    // RFC 7230 sections 2.7.3, 5.3.1, 5.7.2 - says path cannot be empty, default to \"/\"\n    // at least when sending and using. We must still accept path-abempty as input.\n    if (path_.isEmpty() && (scheme_ == AnyP::PROTO_HTTP || scheme_ == AnyP::PROTO_HTTPS))\n        return SlashPath();\n\n    return path_;\n}\n\nvoid\nurlInitialize(void)\n{\n    debugs(23, 5, \"urlInitialize: Initializing...\");\n    /* this ensures that the number of protocol strings is the same as\n     * the enum slots allocated because the last enum is always 'MAX'.\n     */\n    assert(strcmp(AnyP::ProtocolType_str[AnyP::PROTO_MAX], \"MAX\") == 0);\n    /*\n     * These test that our matchDomainName() function works the\n     * way we expect it to.\n     */\n    assert(0 == matchDomainName(\"foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"y.x.foo.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"x.foo.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\"foo.com\", \"x.foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \".foo.com\"));\n    assert(0 < matchDomainName(\"zzz.com\", \"foo.com\"));\n    assert(0 > matchDomainName(\"aaa.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"FOO.com\", \"foo.COM\"));\n    assert(0 < matchDomainName(\"bfoo.com\", \"afoo.com\"));\n    assert(0 > matchDomainName(\"afoo.com\", \"bfoo.com\"));\n    assert(0 < matchDomainName(\"x-foo.com\", \".foo.com\"));\n\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\"y.x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\".x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n\n    assert(0 == matchDomainName(\"*.foo.com\", \"x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".foo.com\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"*.foo.com\", \"foo.com\", mdnHonorWildcards));\n\n    /* more cases? */\n}\n\n/**\n * Extract the URI scheme and ':' delimiter from the given input buffer.\n *\n * Schemes up to 16 characters are accepted.\n *\n * Governed by RFC 3986 section 3.1\n */\nstatic AnyP::UriScheme\nuriParseScheme(Parser::Tokenizer &tok)\n{\n    /*\n     * RFC 3986 section 3.1 paragraph 2:\n     *\n     * Scheme names consist of a sequence of characters beginning with a\n     * letter and followed by any combination of letters, digits, plus\n     * (\"+\"), period (\".\"), or hyphen (\"-\").\n     */\n    static const auto schemeChars = CharacterSet(\"scheme\", \"+.-\") + CharacterSet::ALPHA + CharacterSet::DIGIT;\n\n    SBuf str;\n    if (tok.prefix(str, schemeChars, 16) && tok.skip(':') && CharacterSet::ALPHA[str.at(0)]) {\n        const auto protocol = AnyP::UriScheme::FindProtocolType(str);\n        if (protocol == AnyP::PROTO_UNKNOWN)\n            return AnyP::UriScheme(protocol, str.c_str());\n        return AnyP::UriScheme(protocol, nullptr);\n    }\n\n    throw TextException(\"invalid URI scheme\", Here());\n}\n\n/**\n * Appends configured append_domain to hostname, assuming\n * the given buffer is at least SQUIDHOSTNAMELEN bytes long,\n * and that the host FQDN is not a 'dotless' TLD.\n *\n * \\returns false if and only if there is not enough space to append\n */\nbool\nurlAppendDomain(char *host)\n{\n    /* For IPv4 addresses check for a dot */\n    /* For IPv6 addresses also check for a colon */\n    if (Config.appendDomain && !strchr(host, '.') && !strchr(host, ':')) {\n        const uint64_t dlen = strlen(host);\n        const uint64_t want = dlen + Config.appendDomainLen;\n        if (want > SQUIDHOSTNAMELEN - 1) {\n            debugs(23, 2, \"URL domain too large (\" << dlen << \" bytes)\");\n            return false;\n        }\n        strncat(host, Config.appendDomain, SQUIDHOSTNAMELEN - dlen - 1);\n    }\n    return true;\n}\n\n/*\n * Parse a URI/URL.\n *\n * It is assumed that the URL is complete -\n * ie, the end of the string is the end of the URL. Don't pass a partial\n * URL here as this routine doesn't have any way of knowing whether\n * it is partial or not (ie, it handles the case of no trailing slash as\n * being \"end of host with implied path of /\".\n *\n * method is used to switch parsers. If method is Http::METHOD_CONNECT,\n * then rather than a URL a hostname:port is looked for.\n */\nbool\nAnyP::Uri::parse(const HttpRequestMethod& method, const SBuf &rawUrl)\n{\n    try {\n\n        LOCAL_ARRAY(char, login, MAX_URL);\n        LOCAL_ARRAY(char, foundHost, MAX_URL);\n        LOCAL_ARRAY(char, urlpath, MAX_URL);\n        char *t = nullptr;\n        char *q = nullptr;\n        int foundPort;\n        int l;\n        int i;\n        const char *src;\n        char *dst;\n        foundHost[0] = urlpath[0] = login[0] = '\\0';\n\n        if ((l = rawUrl.length()) + Config.appendDomainLen > (MAX_URL - 1)) {\n            debugs(23, DBG_IMPORTANT, MYNAME << \"URL too large (\" << l << \" bytes)\");\n            return false;\n        }\n\n        if ((method == Http::METHOD_OPTIONS || method == Http::METHOD_TRACE) &&\n                Asterisk().cmp(rawUrl) == 0) {\n            // XXX: these methods might also occur in HTTPS traffic. Handle this better.\n            setScheme(AnyP::PROTO_HTTP, nullptr);\n            port(getScheme().defaultPort());\n            path(Asterisk());\n            return true;\n        }\n\n        Parser::Tokenizer tok(rawUrl);\n        AnyP::UriScheme scheme;\n\n        if (method == Http::METHOD_CONNECT) {\n            // For CONNECTs, RFC 9110 Section 9.3.6 requires \"only the host and\n            // port number of the tunnel destination, separated by a colon\".\n\n            const auto rawHost = parseHost(tok);\n            Assure(rawHost.length() < sizeof(foundHost));\n            SBufToCstring(foundHost, rawHost);\n\n            if (!tok.skip(':'))\n                throw TextException(\"missing required :port in CONNECT target\", Here());\n            foundPort = parsePort(tok);\n\n            if (!tok.remaining().isEmpty())\n                throw TextException(\"garbage after host:port in CONNECT target\", Here());\n        } else {\n\n            scheme = uriParseScheme(tok);\n\n            if (scheme == AnyP::PROTO_NONE)\n                return false; // invalid scheme\n\n            if (scheme == AnyP::PROTO_URN) {\n                parseUrn(tok); // throws on any error\n                return true;\n            }\n\n            // URLs then have \"//\"\n            static const SBuf doubleSlash(\"//\");\n            if (!tok.skip(doubleSlash))\n                return false;\n\n            auto B = tok.remaining();\n            const char *url = B.c_str();\n\n            /* Parse the URL: */\n            src = url;\n            i = 0;\n\n            /* Then everything until first /; that's host (and port; which we'll look for here later) */\n            // bug 1881: If we don't get a \"/\" then we imply it was there\n            // bug 3074: We could just be given a \"?\" or \"#\". These also imply \"/\"\n            // bug 3233: whitespace is also a hostname delimiter.\n            for (dst = foundHost; i < l && *src != '/' && *src != '?' && *src != '#' && *src != '\\0' && !xisspace(*src); ++i, ++src, ++dst) {\n                *dst = *src;\n            }\n\n            /*\n             * We can't check for \"i >= l\" here because we could be at the end of the line\n             * and have a perfectly valid URL w/ no trailing '/'. In this case we assume we've\n             * been -given- a valid URL and the path is just '/'.\n             */\n            if (i > l)\n                return false;\n            *dst = '\\0';\n\n            // We are looking at path-abempty.\n            if (*src != '/') {\n                // path-empty, including the end of the `src` c-string cases\n                urlpath[0] = '/';\n                dst = &urlpath[1];\n            } else {\n                dst = urlpath;\n            }\n            /* Then everything from / (inclusive) until \\r\\n or \\0 - that's urlpath */\n            for (; i < l && *src != '\\r' && *src != '\\n' && *src != '\\0'; ++i, ++src, ++dst) {\n                *dst = *src;\n            }\n\n            /* We -could- be at the end of the buffer here */\n            if (i > l)\n                return false;\n            *dst = '\\0';\n\n            // If the parsed scheme has no (known) default port, and there is no\n            // explicit port, then we will reject the zero port during foundPort\n            // validation, often resulting in a misleading 400/ERR_INVALID_URL.\n            // TODO: Remove this hack when switching to Tokenizer-based parsing.\n            foundPort = scheme.defaultPort().value_or(0); // may be reset later\n\n            /* Is there any login information? (we should eventually parse it above) */\n            t = strrchr(foundHost, '@');\n            if (t != nullptr) {\n                strncpy((char *) login, (char *) foundHost, sizeof(login)-1);\n                login[sizeof(login)-1] = '\\0';\n                t = strrchr(login, '@');\n                *t = 0;\n                strncpy((char *) foundHost, t + 1, sizeof(foundHost)-1);\n                foundHost[sizeof(foundHost)-1] = '\\0';\n                // Bug 4498: URL-unescape the login info after extraction\n                rfc1738_unescape(login);\n            }\n\n            /* Is there any host information? (we should eventually parse it above) */\n            if (*foundHost == '[') {\n                /* strip any IPA brackets. valid under IPv6. */\n                dst = foundHost;\n                /* only for IPv6 sadly, pre-IPv6/URL code can't handle the clean result properly anyway. */\n                src = foundHost;\n                ++src;\n                l = strlen(foundHost);\n                i = 1;\n                for (; i < l && *src != ']' && *src != '\\0'; ++i, ++src, ++dst) {\n                    *dst = *src;\n                }\n\n                /* we moved in-place, so truncate the actual hostname found */\n                *dst = '\\0';\n                ++dst;\n\n                /* skip ahead to either start of port, or original EOS */\n                while (*dst != '\\0' && *dst != ':')\n                    ++dst;\n                t = dst;\n            } else {\n                t = strrchr(foundHost, ':');\n\n                if (t != strchr(foundHost,':') ) {\n                    /* RFC 2732 states IPv6 \"SHOULD\" be bracketed. allowing for times when its not. */\n                    /* RFC 3986 'update' simply modifies this to an \"is\" with no emphasis at all! */\n                    /* therefore we MUST accept the case where they are not bracketed at all. */\n                    t = nullptr;\n                }\n            }\n\n            // Bug 3183 sanity check: If scheme is present, host must be too.\n            if (scheme != AnyP::PROTO_NONE && foundHost[0] == '\\0') {\n                debugs(23, DBG_IMPORTANT, \"SECURITY ALERT: Missing hostname in URL '\" << url << \"'. see access.log for details.\");\n                return false;\n            }\n\n            if (t && *t == ':') {\n                *t = '\\0';\n                ++t;\n                foundPort = atoi(t);\n            }\n        }\n\n        for (t = foundHost; *t; ++t)\n            *t = xtolower(*t);\n\n        if (stringHasWhitespace(foundHost)) {\n            if (URI_WHITESPACE_STRIP == Config.uri_whitespace) {\n                t = q = foundHost;\n                while (*t) {\n                    if (!xisspace(*t)) {\n                        *q = *t;\n                        ++q;\n                    }\n                    ++t;\n                }\n                *q = '\\0';\n            }\n        }\n\n        debugs(23, 3, \"Split URL '\" << rawUrl << \"' into proto='\" << scheme.image() << \"', host='\" << foundHost << \"', port='\" << foundPort << \"', path='\" << urlpath << \"'\");\n\n        if (Config.onoff.check_hostnames &&\n                strspn(foundHost, Config.onoff.allow_underscore ? valid_hostname_chars_u : valid_hostname_chars) != strlen(foundHost)) {\n            debugs(23, DBG_IMPORTANT, MYNAME << \"Illegal character in hostname '\" << foundHost << \"'\");\n            return false;\n        }\n\n        if (!urlAppendDomain(foundHost))\n            return false;\n\n        /* remove trailing dots from hostnames */\n        while ((l = strlen(foundHost)) > 0 && foundHost[--l] == '.')\n            foundHost[l] = '\\0';\n\n        /* reject duplicate or leading dots */\n        if (strstr(foundHost, \"..\") || *foundHost == '.') {\n            debugs(23, DBG_IMPORTANT, MYNAME << \"Illegal hostname '\" << foundHost << \"'\");\n            return false;\n        }\n\n        if (foundPort < 1 || foundPort > 65535) {\n            debugs(23, 3, \"Invalid port '\" << foundPort << \"'\");\n            return false;\n        }\n\n        if (stringHasWhitespace(urlpath)) {\n            debugs(23, 2, \"URI has whitespace: {\" << rawUrl << \"}\");\n\n            switch (Config.uri_whitespace) {\n\n            case URI_WHITESPACE_DENY:\n                return false;\n\n            case URI_WHITESPACE_ALLOW:\n                break;\n\n            case URI_WHITESPACE_ENCODE:\n                t = rfc1738_escape_unescaped(urlpath);\n                xstrncpy(urlpath, t, MAX_URL);\n                break;\n\n            case URI_WHITESPACE_CHOP:\n                *(urlpath + strcspn(urlpath, w_space)) = '\\0';\n                break;\n\n            case URI_WHITESPACE_STRIP:\n            default:\n                t = q = urlpath;\n                while (*t) {\n                    if (!xisspace(*t)) {\n                        *q = *t;\n                        ++q;\n                    }\n                    ++t;\n                }\n                *q = '\\0';\n            }\n        }\n\n        setScheme(scheme);\n        path(urlpath);\n        host(foundHost);\n        userInfo(SBuf(login));\n        port(foundPort);\n        return true;\n\n    } catch (...) {\n        debugs(23, 2, \"error: \" << CurrentException << \" \" << Raw(\"rawUrl\", rawUrl.rawContent(), rawUrl.length()));\n        return false;\n    }\n}\n\n/**\n * Governed by RFC 8141 section 2:\n *\n *  assigned-name = \"urn\" \":\" NID \":\" NSS\n *  NID           = (alphanum) 0*30(ldh) (alphanum)\n *  ldh           = alphanum / \"-\"\n *  NSS           = pchar *(pchar / \"/\")\n *\n * RFC 3986 Appendix D.2 defines (as deprecated):\n *\n *   alphanum     = ALPHA / DIGIT\n *\n * Notice that NID is exactly 2-32 characters in length.\n */\nvoid\nAnyP::Uri::parseUrn(Parser::Tokenizer &tok)\n{\n    static const auto nidChars = CharacterSet(\"NID\",\"-\") + CharacterSet::ALPHA + CharacterSet::DIGIT;\n    static const auto alphanum = (CharacterSet::ALPHA + CharacterSet::DIGIT).rename(\"alphanum\");\n    SBuf nid;\n    if (!tok.prefix(nid, nidChars, 32))\n        throw TextException(\"NID not found\", Here());\n\n    if (!tok.skip(':'))\n        throw TextException(\"NID too long or missing ':' delimiter\", Here());\n\n    if (nid.length() < 2)\n        throw TextException(\"NID too short\", Here());\n\n    if (!alphanum[*nid.begin()])\n        throw TextException(\"NID prefix is not alphanumeric\", Here());\n\n    if (!alphanum[*nid.rbegin()])\n        throw TextException(\"NID suffix is not alphanumeric\", Here());\n\n    setScheme(AnyP::PROTO_URN, nullptr);\n    host(nid.c_str());\n    // TODO validate path characters\n    path(tok.remaining());\n    debugs(23, 3, \"Split URI into proto=urn, nid=\" << nid << \", \" << Raw(\"path\",path().rawContent(),path().length()));\n}\n\n/// Extracts and returns a (suspected but only partially validated) uri-host\n/// IPv6address, IPv4address, or reg-name component. This function uses (and\n/// quotes) RFC 3986, Section 3.2.2 syntax rules.\nSBuf\nAnyP::Uri::parseHost(Parser::Tokenizer &tok) const\n{\n    // host = IP-literal / IPv4address / reg-name\n\n    // XXX: CharacterSets below reject uri-host values containing whitespace\n    // (e.g., \"10.0.0. 1\"). That is not a bug, but the uri_whitespace directive\n    // can be interpreted as if it applies to uri-host and this code. TODO: Fix\n    // uri_whitespace and the code using it to exclude uri-host (and URI scheme,\n    // port, etc.) from that directive scope.\n\n    // IP-literal = \"[\" ( IPv6address / IPvFuture  ) \"]\"\n    if (tok.skip('[')) {\n        // Add \".\" because IPv6address in RFC 3986 includes ls32, which includes\n        // IPv4address: ls32 = ( h16 \":\" h16 ) / IPv4address\n        // This set rejects IPvFuture that needs a \"v\" character.\n        static const CharacterSet IPv6chars = (\n                CharacterSet::HEXDIG + CharacterSet(\"colon\", \":\") + CharacterSet(\"period\", \".\")).rename(\"IPv6\");\n        SBuf ipv6ish;\n        if (!tok.prefix(ipv6ish, IPv6chars))\n            throw TextException(\"malformed or unsupported bracketed IP address in uri-host\", Here());\n\n        if (!tok.skip(']'))\n            throw TextException(\"IPv6 address is missing a closing bracket in uri-host\", Here());\n\n        // This rejects bracketed IPv4address and domain names because they lack \":\".\n        if (ipv6ish.find(':') == SBuf::npos)\n            throw TextException(\"bracketed IPv6 address is missing a colon in uri-host\", Here());\n\n        // This rejects bracketed non-IP addresses that our caller would have\n        // otherwise mistaken for a domain name (e.g., '[127.0.0:1]').\n        Ip::Address ipv6check;\n        if (!ipv6check.fromHost(ipv6ish.c_str()))\n            throw TextException(\"malformed bracketed IPv6 address in uri-host\", Here());\n\n        return ipv6ish;\n    }\n\n    // no brackets implies we are looking at IPv4address or reg-name\n\n    // XXX: This code does not detect/reject some bad host values (e.g. \"!#$%&\"\n    // and \"1.2.3.4.5\"). TODO: Add more checks here, after migrating the\n    // non-CONNECT uri-host parsing code to use us.\n\n    SBuf otherHost; // IPv4address-ish or reg-name-ish;\n    // \":\" is not in TCHAR so we will stop before any port specification\n    if (tok.prefix(otherHost, CharacterSet::TCHAR))\n        return otherHost;\n\n    throw TextException(\"malformed IPv4 address or host name in uri-host\", Here());\n}\n\n/// Extracts and returns an RFC 3986 URI authority port value (with additional\n/// restrictions). The RFC defines port as a possibly empty sequence of decimal\n/// digits. We reject certain ports (that are syntactically valid from the RFC\n/// point of view) because we are worried that Squid and other traffic handlers\n/// may dangerously mishandle unusual (and virtually always bogus) port numbers.\n/// Rejected ports cannot be successfully used by Squid itself.\nint\nAnyP::Uri::parsePort(Parser::Tokenizer &tok) const\n{\n    if (tok.skip('0'))\n        throw TextException(\"zero or zero-prefixed port\", Here());\n\n    int64_t rawPort = 0;\n    if (!tok.int64(rawPort, 10, false)) // port = *DIGIT\n        throw TextException(\"malformed or missing port\", Here());\n\n    Assure(rawPort > 0);\n    constexpr KnownPort portMax = 65535; // TODO: Make this a class-scope constant and REuse it.\n    constexpr auto portStorageMax = std::numeric_limits<Port::value_type>::max();\n    static_assert(!Less(portStorageMax, portMax), \"Port type can represent the maximum valid port number\");\n    if (Less(portMax, rawPort))\n        throw TextException(\"huge port\", Here());\n\n    // TODO: Return KnownPort after migrating the non-CONNECT uri-host parsing\n    // code to use us (so that foundPort \"int\" disappears or starts using Port).\n    return NaturalCast<int>(rawPort);\n}\n\nvoid\nAnyP::Uri::touch()\n{\n    absolute_.clear();\n    authorityHttp_.clear();\n    authorityWithPort_.clear();\n}\n\nSBuf &\nAnyP::Uri::authority(bool requirePort) const\n{\n    if (authorityHttp_.isEmpty()) {\n\n        // both formats contain Host/IP\n        authorityWithPort_.append(host());\n        authorityHttp_ = authorityWithPort_;\n\n        if (port().has_value()) {\n            authorityWithPort_.appendf(\":%hu\", *port());\n            // authorityHttp_ only has :port for known non-default ports\n            if (port() != getScheme().defaultPort())\n                authorityHttp_ = authorityWithPort_;\n        }\n        // else XXX: We made authorityWithPort_ that does not have a port.\n        // TODO: Audit callers and refuse to give out broken authorityWithPort_.\n    }\n\n    return requirePort ? authorityWithPort_ : authorityHttp_;\n}\n\nSBuf &\nAnyP::Uri::absolute() const\n{\n    if (absolute_.isEmpty()) {\n        // TODO: most URL will be much shorter, avoid allocating this much\n        absolute_.reserveCapacity(MAX_URL);\n\n        absolute_.append(getScheme().image());\n        absolute_.append(\":\",1);\n        if (getScheme() != AnyP::PROTO_URN) {\n            absolute_.append(\"//\", 2);\n            const bool allowUserInfo = getScheme() == AnyP::PROTO_FTP ||\n                                       getScheme() == AnyP::PROTO_UNKNOWN;\n\n            if (allowUserInfo && !userInfo().isEmpty()) {\n                static const CharacterSet uiChars = CharacterSet(UserInfoChars())\n                                                    .remove('%')\n                                                    .rename(\"userinfo-reserved\");\n                absolute_.append(Encode(userInfo(), uiChars));\n                absolute_.append(\"@\", 1);\n            }\n            absolute_.append(authority());\n        } else {\n            absolute_.append(host());\n            absolute_.append(\":\", 1);\n        }\n        absolute_.append(path()); // TODO: Encode each URI subcomponent in path_ as needed.\n    }\n\n    return absolute_;\n}\n\n/* XXX: Performance: This is an *almost* duplicate of HttpRequest::effectiveRequestUri(). But elides the query-string.\n *        After copying it on in the first place! Would be less code to merge the two with a flag parameter.\n *        and never copy the query-string part in the first place\n */\nchar *\nurlCanonicalCleanWithoutRequest(const SBuf &url, const HttpRequestMethod &method, const AnyP::UriScheme &scheme)\n{\n    LOCAL_ARRAY(char, buf, MAX_URL);\n\n    snprintf(buf, sizeof(buf), SQUIDSBUFPH, SQUIDSBUFPRINT(url));\n    buf[sizeof(buf)-1] = '\\0';\n\n    // URN, CONNECT method, and non-stripped URIs can go straight out\n    if (Config.onoff.strip_query_terms && !(method == Http::METHOD_CONNECT || scheme == AnyP::PROTO_URN)) {\n        // strip anything AFTER a question-mark\n        // leaving the '?' in place\n        if (auto t = strchr(buf, '?')) {\n            *(++t) = '\\0';\n        }\n    }\n\n    if (stringHasCntl(buf))\n        xstrncpy(buf, rfc1738_escape_unescaped(buf), MAX_URL);\n\n    return buf;\n}\n\n/**\n * Yet another alternative to urlCanonical.\n * This one adds the https:// parts to Http::METHOD_CONNECT URL\n * for use in error page outputs.\n * Luckily we can leverage the others instead of duplicating.\n */\nconst char *\nurlCanonicalFakeHttps(const HttpRequest * request)\n{\n    LOCAL_ARRAY(char, buf, MAX_URL);\n\n    // method CONNECT and port HTTPS\n    if (request->method == Http::METHOD_CONNECT && request->url.port() == 443) {\n        snprintf(buf, MAX_URL, \"https://%s/*\", request->url.host());\n        return buf;\n    }\n\n    // else do the normal complete canonical thing.\n    return request->canonicalCleanUrl();\n}\n\n/**\n * Test if a URL is a relative reference.\n *\n * Governed by RFC 3986 section 4.2\n *\n *  relative-ref  = relative-part [ \"?\" query ] [ \"#\" fragment ]\n *\n *  relative-part = \"//\" authority path-abempty\n *                / path-absolute\n *                / path-noscheme\n *                / path-empty\n */\nbool\nurlIsRelative(const char *url)\n{\n    if (!url)\n        return false; // no URL\n\n    /*\n     * RFC 3986 section 5.2.3\n     *\n     * path          = path-abempty    ; begins with \"/\" or is empty\n     *               / path-absolute   ; begins with \"/\" but not \"//\"\n     *               / path-noscheme   ; begins with a non-colon segment\n     *               / path-rootless   ; begins with a segment\n     *               / path-empty      ; zero characters\n     */\n\n    if (*url == '\\0')\n        return true; // path-empty\n\n    if (*url == '/') {\n        // RFC 3986 section 5.2.3\n        // path-absolute   ; begins with \"/\" but not \"//\"\n        if (url[1] == '/')\n            return true; // network-path reference, aka. 'scheme-relative URI'\n        else\n            return true; // path-absolute, aka 'absolute-path reference'\n    }\n\n    for (const auto *p = url; *p != '\\0' && *p != '/' && *p != '?' && *p != '#'; ++p) {\n        if (*p == ':')\n            return false; // colon is forbidden in first segment\n    }\n\n    return true; // path-noscheme, path-abempty, path-rootless\n}\n\nvoid\nAnyP::Uri::addRelativePath(const char *relUrl)\n{\n    // URN cannot be merged\n    if (getScheme() == AnyP::PROTO_URN)\n        return;\n\n    // TODO: Handle . and .. segment normalization\n\n    const auto lastSlashPos = path_.rfind('/');\n    // TODO: To optimize and simplify, add and use SBuf::replace().\n    const auto relUrlLength = strlen(relUrl);\n    if (lastSlashPos == SBuf::npos) {\n        // start replacing the whole path\n        path_.reserveCapacity(1 + relUrlLength);\n        path_.assign(\"/\", 1);\n    } else {\n        // start replacing just the last segment\n        path_.reserveCapacity(lastSlashPos + 1 + relUrlLength);\n        path_.chop(0, lastSlashPos+1);\n    }\n    path_.append(relUrl, relUrlLength);\n}\n\nint\nmatchDomainName(const char *h, const char *d, MatchDomainNameFlags flags)\n{\n    int dl;\n    int hl;\n\n    const bool hostIncludesSubdomains = (*h == '.');\n    while ('.' == *h)\n        ++h;\n\n    hl = strlen(h);\n\n    if (hl == 0)\n        return -1;\n\n    dl = strlen(d);\n\n    /*\n     * Start at the ends of the two strings and work towards the\n     * beginning.\n     */\n    while (xtolower(h[--hl]) == xtolower(d[--dl])) {\n        if (hl == 0 && dl == 0) {\n            /*\n             * We made it all the way to the beginning of both\n             * strings without finding any difference.\n             */\n            return 0;\n        }\n\n        if (0 == hl) {\n            /*\n             * The host string is shorter than the domain string.\n             * There is only one case when this can be a match.\n             * If the domain is just one character longer, and if\n             * that character is a leading '.' then we call it a\n             * match.\n             */\n\n            if (1 == dl && '.' == d[0])\n                return 0;\n            else\n                return -1;\n        }\n\n        if (0 == dl) {\n            /*\n             * The domain string is shorter than the host string.\n             * This is a match only if the first domain character\n             * is a leading '.'.\n             */\n\n            if ('.' == d[0]) {\n                if (flags & mdnRejectSubsubDomains) {\n                    // Check for sub-sub domain and reject\n                    while(--hl >= 0 && h[hl] != '.');\n                    if (hl < 0) {\n                        // No sub-sub domain found, but reject if there is a\n                        // leading dot in given host string (which is removed\n                        // before the check is started).\n                        return hostIncludesSubdomains ? 1 : 0;\n                    } else\n                        return 1; // sub-sub domain, reject\n                } else\n                    return 0;\n            } else\n                return 1;\n        }\n    }\n\n    /*\n     * We found different characters in the same position (from the end).\n     */\n\n    // If the h has a form of \"*.foo.com\" and d has a form of \"x.foo.com\"\n    // then the h[hl] points to '*', h[hl+1] to '.' and d[dl] to 'x'\n    // The following checks are safe, the \"h[hl + 1]\" in the worst case is '\\0'.\n    if ((flags & mdnHonorWildcards) && h[hl] == '*' && h[hl + 1] == '.')\n        return 0;\n\n    /*\n     * If one of those character is '.' then its special.  In order\n     * for splay tree sorting to work properly, \"x-foo.com\" must\n     * be greater than \".foo.com\" even though '-' is less than '.'.\n     */\n    if ('.' == d[dl])\n        return 1;\n\n    if ('.' == h[hl])\n        return -1;\n\n    return (xtolower(h[hl]) - xtolower(d[dl]));\n}\n\n/*\n * return true if we can serve requests for this method.\n */\nbool\nurlCheckRequest(const HttpRequest * r)\n{\n    /* protocol \"independent\" methods\n     *\n     * actually these methods are specific to HTTP:\n     * they are methods we receive on our HTTP port,\n     * and if we had a FTP listener would not be relevant\n     * there.\n     *\n     * So, we should delegate them to HTTP. The problem is that we\n     * do not have a default protocol from the client side of HTTP.\n     */\n\n    if (r->method == Http::METHOD_CONNECT)\n        return true;\n\n    // we support OPTIONS and TRACE directed at us (with a 501 reply, for now)\n    // we also support forwarding OPTIONS and TRACE, except for the *-URI ones\n    if (r->method == Http::METHOD_OPTIONS || r->method == Http::METHOD_TRACE)\n        return (r->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0 || r->url.path() != AnyP::Uri::Asterisk());\n\n    if (r->method == Http::METHOD_PURGE)\n        return true;\n\n    /* does method match the protocol? */\n    switch (r->url.getScheme()) {\n\n    case AnyP::PROTO_URN:\n    case AnyP::PROTO_HTTP:\n        return true;\n\n    case AnyP::PROTO_FTP:\n        if (r->method == Http::METHOD_PUT ||\n                r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD )\n            return true;\n        return false;\n\n    case AnyP::PROTO_WAIS:\n    case AnyP::PROTO_WHOIS:\n        if (r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD)\n            return true;\n        return false;\n\n    case AnyP::PROTO_HTTPS:\n#if USE_OPENSSL || USE_GNUTLS\n        return true;\n#else\n        /*\n         * Squid can't originate an SSL connection, so it should\n         * never receive an \"https:\" URL.  It should always be\n         * CONNECT instead.\n         */\n        return false;\n#endif\n\n    default:\n        return false;\n    }\n\n    /* notreached */\n    return false;\n}\n\nAnyP::Uri::Uri(AnyP::UriScheme const &aScheme) :\n    scheme_(aScheme),\n    hostIsNumeric_(false)\n{\n    *host_=0;\n}\n\n// TODO: fix code duplication with AnyP::Uri::parse()\nchar *\nAnyP::Uri::cleanup(const char *uri)\n{\n    char *cleanedUri = nullptr;\n    switch (Config.uri_whitespace) {\n    case URI_WHITESPACE_ALLOW: {\n        const auto flags = RFC1738_ESCAPE_NOSPACE | RFC1738_ESCAPE_UNESCAPED;\n        cleanedUri = xstrndup(rfc1738_do_escape(uri, flags), MAX_URL);\n        break;\n    }\n\n    case URI_WHITESPACE_ENCODE:\n        cleanedUri = xstrndup(rfc1738_do_escape(uri, RFC1738_ESCAPE_UNESCAPED), MAX_URL);\n        break;\n\n    case URI_WHITESPACE_CHOP: {\n        const auto pos = strcspn(uri, w_space);\n        char *choppedUri = nullptr;\n        if (pos < strlen(uri))\n            choppedUri = xstrndup(uri, pos + 1);\n        cleanedUri = xstrndup(rfc1738_do_escape(choppedUri ? choppedUri : uri,\n                                                RFC1738_ESCAPE_UNESCAPED), MAX_URL);\n        cleanedUri[pos] = '\\0';\n        xfree(choppedUri);\n        break;\n    }\n\n    case URI_WHITESPACE_DENY:\n    case URI_WHITESPACE_STRIP:\n    default: {\n        // TODO: avoid duplication with urlParse()\n        const char *t;\n        char *tmp_uri = static_cast<char*>(xmalloc(strlen(uri) + 1));\n        char *q = tmp_uri;\n        t = uri;\n        while (*t) {\n            if (!xisspace(*t)) {\n                *q = *t;\n                ++q;\n            }\n            ++t;\n        }\n        *q = '\\0';\n        cleanedUri = xstrndup(rfc1738_escape_unescaped(tmp_uri), MAX_URL);\n        xfree(tmp_uri);\n        break;\n    }\n    }\n\n    assert(cleanedUri);\n    return cleanedUri;\n}\n\n"], "fixing_code": ["/*\n * Copyright (C) 1996-2023 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n/* DEBUG: section 23    URL Parsing */\n\n#include \"squid.h\"\n#include \"anyp/Uri.h\"\n#include \"base/Raw.h\"\n#include \"globals.h\"\n#include \"HttpRequest.h\"\n#include \"parser/Tokenizer.h\"\n#include \"rfc1738.h\"\n#include \"SquidConfig.h\"\n#include \"SquidMath.h\"\n#include \"SquidString.h\"\n\nstatic const char valid_hostname_chars_u[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"0123456789-._\"\n    \"[:]\"\n    ;\nstatic const char valid_hostname_chars[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"0123456789-.\"\n    \"[:]\"\n    ;\n\n/// Characters which are valid within a URI userinfo section\nstatic const CharacterSet &\nUserInfoChars()\n{\n    /*\n     * RFC 3986 section 3.2.1\n     *\n     *  userinfo      = *( unreserved / pct-encoded / sub-delims / \":\" )\n     *  unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n     *  pct-encoded   = \"%\" HEXDIG HEXDIG\n     *  sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n     */\n    static const auto userInfoValid = CharacterSet(\"userinfo\", \":-._~%!$&'()*+,;=\") +\n                                      CharacterSet::ALPHA +\n                                      CharacterSet::DIGIT;\n    return userInfoValid;\n}\n\n/**\n * Governed by RFC 3986 section 2.1\n */\nSBuf\nAnyP::Uri::Encode(const SBuf &buf, const CharacterSet &ignore)\n{\n    if (buf.isEmpty())\n        return buf;\n\n    Parser::Tokenizer tk(buf);\n    SBuf goodSection;\n    // optimization for the arguably common \"no encoding necessary\" case\n    if (tk.prefix(goodSection, ignore) && tk.atEnd())\n        return buf;\n\n    SBuf output;\n    output.reserveSpace(buf.length() * 3); // worst case: encode all chars\n    output.append(goodSection); // may be empty\n\n    while (!tk.atEnd()) {\n        // TODO: Add Tokenizer::parseOne(void).\n        const auto ch = tk.remaining()[0];\n        output.appendf(\"%%%02X\", static_cast<unsigned int>(static_cast<unsigned char>(ch))); // TODO: Optimize using a table\n        (void)tk.skip(ch);\n\n        if (tk.prefix(goodSection, ignore))\n            output.append(goodSection);\n    }\n\n    return output;\n}\n\nconst SBuf &\nAnyP::Uri::Asterisk()\n{\n    static SBuf star(\"*\");\n    return star;\n}\n\nconst SBuf &\nAnyP::Uri::SlashPath()\n{\n    static SBuf slash(\"/\");\n    return slash;\n}\n\nvoid\nAnyP::Uri::host(const char *src)\n{\n    hostAddr_.fromHost(src);\n    if (hostAddr_.isAnyAddr()) {\n        xstrncpy(host_, src, sizeof(host_));\n        hostIsNumeric_ = false;\n    } else {\n        hostAddr_.toHostStr(host_, sizeof(host_));\n        debugs(23, 3, \"given IP: \" << hostAddr_);\n        hostIsNumeric_ = 1;\n    }\n    touch();\n}\n\nSBuf\nAnyP::Uri::hostOrIp() const\n{\n    if (hostIsNumeric()) {\n        static char ip[MAX_IPSTRLEN];\n        const auto hostStrLen = hostIP().toHostStr(ip, sizeof(ip));\n        return SBuf(ip, hostStrLen);\n    } else\n        return SBuf(host());\n}\n\nconst SBuf &\nAnyP::Uri::path() const\n{\n    // RFC 3986 section 3.3 says path can be empty (path-abempty).\n    // RFC 7230 sections 2.7.3, 5.3.1, 5.7.2 - says path cannot be empty, default to \"/\"\n    // at least when sending and using. We must still accept path-abempty as input.\n    if (path_.isEmpty() && (scheme_ == AnyP::PROTO_HTTP || scheme_ == AnyP::PROTO_HTTPS))\n        return SlashPath();\n\n    return path_;\n}\n\nvoid\nurlInitialize(void)\n{\n    debugs(23, 5, \"urlInitialize: Initializing...\");\n    /* this ensures that the number of protocol strings is the same as\n     * the enum slots allocated because the last enum is always 'MAX'.\n     */\n    assert(strcmp(AnyP::ProtocolType_str[AnyP::PROTO_MAX], \"MAX\") == 0);\n    /*\n     * These test that our matchDomainName() function works the\n     * way we expect it to.\n     */\n    assert(0 == matchDomainName(\"foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"y.x.foo.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"x.foo.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\"foo.com\", \"x.foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \".foo.com\"));\n    assert(0 < matchDomainName(\"zzz.com\", \"foo.com\"));\n    assert(0 > matchDomainName(\"aaa.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"FOO.com\", \"foo.COM\"));\n    assert(0 < matchDomainName(\"bfoo.com\", \"afoo.com\"));\n    assert(0 > matchDomainName(\"afoo.com\", \"bfoo.com\"));\n    assert(0 < matchDomainName(\"x-foo.com\", \".foo.com\"));\n\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\"y.x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\".x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n\n    assert(0 == matchDomainName(\"*.foo.com\", \"x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".foo.com\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"*.foo.com\", \"foo.com\", mdnHonorWildcards));\n\n    assert(0 != matchDomainName(\"foo.com\", \"\"));\n    assert(0 != matchDomainName(\"foo.com\", \"\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"foo.com\", \"\", mdnRejectSubsubDomains));\n\n    /* more cases? */\n}\n\n/**\n * Extract the URI scheme and ':' delimiter from the given input buffer.\n *\n * Schemes up to 16 characters are accepted.\n *\n * Governed by RFC 3986 section 3.1\n */\nstatic AnyP::UriScheme\nuriParseScheme(Parser::Tokenizer &tok)\n{\n    /*\n     * RFC 3986 section 3.1 paragraph 2:\n     *\n     * Scheme names consist of a sequence of characters beginning with a\n     * letter and followed by any combination of letters, digits, plus\n     * (\"+\"), period (\".\"), or hyphen (\"-\").\n     */\n    static const auto schemeChars = CharacterSet(\"scheme\", \"+.-\") + CharacterSet::ALPHA + CharacterSet::DIGIT;\n\n    SBuf str;\n    if (tok.prefix(str, schemeChars, 16) && tok.skip(':') && CharacterSet::ALPHA[str.at(0)]) {\n        const auto protocol = AnyP::UriScheme::FindProtocolType(str);\n        if (protocol == AnyP::PROTO_UNKNOWN)\n            return AnyP::UriScheme(protocol, str.c_str());\n        return AnyP::UriScheme(protocol, nullptr);\n    }\n\n    throw TextException(\"invalid URI scheme\", Here());\n}\n\n/**\n * Appends configured append_domain to hostname, assuming\n * the given buffer is at least SQUIDHOSTNAMELEN bytes long,\n * and that the host FQDN is not a 'dotless' TLD.\n *\n * \\returns false if and only if there is not enough space to append\n */\nbool\nurlAppendDomain(char *host)\n{\n    /* For IPv4 addresses check for a dot */\n    /* For IPv6 addresses also check for a colon */\n    if (Config.appendDomain && !strchr(host, '.') && !strchr(host, ':')) {\n        const uint64_t dlen = strlen(host);\n        const uint64_t want = dlen + Config.appendDomainLen;\n        if (want > SQUIDHOSTNAMELEN - 1) {\n            debugs(23, 2, \"URL domain too large (\" << dlen << \" bytes)\");\n            return false;\n        }\n        strncat(host, Config.appendDomain, SQUIDHOSTNAMELEN - dlen - 1);\n    }\n    return true;\n}\n\n/*\n * Parse a URI/URL.\n *\n * It is assumed that the URL is complete -\n * ie, the end of the string is the end of the URL. Don't pass a partial\n * URL here as this routine doesn't have any way of knowing whether\n * it is partial or not (ie, it handles the case of no trailing slash as\n * being \"end of host with implied path of /\".\n *\n * method is used to switch parsers. If method is Http::METHOD_CONNECT,\n * then rather than a URL a hostname:port is looked for.\n */\nbool\nAnyP::Uri::parse(const HttpRequestMethod& method, const SBuf &rawUrl)\n{\n    try {\n\n        LOCAL_ARRAY(char, login, MAX_URL);\n        LOCAL_ARRAY(char, foundHost, MAX_URL);\n        LOCAL_ARRAY(char, urlpath, MAX_URL);\n        char *t = nullptr;\n        char *q = nullptr;\n        int foundPort;\n        int l;\n        int i;\n        const char *src;\n        char *dst;\n        foundHost[0] = urlpath[0] = login[0] = '\\0';\n\n        if ((l = rawUrl.length()) + Config.appendDomainLen > (MAX_URL - 1)) {\n            debugs(23, DBG_IMPORTANT, MYNAME << \"URL too large (\" << l << \" bytes)\");\n            return false;\n        }\n\n        if ((method == Http::METHOD_OPTIONS || method == Http::METHOD_TRACE) &&\n                Asterisk().cmp(rawUrl) == 0) {\n            // XXX: these methods might also occur in HTTPS traffic. Handle this better.\n            setScheme(AnyP::PROTO_HTTP, nullptr);\n            port(getScheme().defaultPort());\n            path(Asterisk());\n            return true;\n        }\n\n        Parser::Tokenizer tok(rawUrl);\n        AnyP::UriScheme scheme;\n\n        if (method == Http::METHOD_CONNECT) {\n            // For CONNECTs, RFC 9110 Section 9.3.6 requires \"only the host and\n            // port number of the tunnel destination, separated by a colon\".\n\n            const auto rawHost = parseHost(tok);\n            Assure(rawHost.length() < sizeof(foundHost));\n            SBufToCstring(foundHost, rawHost);\n\n            if (!tok.skip(':'))\n                throw TextException(\"missing required :port in CONNECT target\", Here());\n            foundPort = parsePort(tok);\n\n            if (!tok.remaining().isEmpty())\n                throw TextException(\"garbage after host:port in CONNECT target\", Here());\n        } else {\n\n            scheme = uriParseScheme(tok);\n\n            if (scheme == AnyP::PROTO_NONE)\n                return false; // invalid scheme\n\n            if (scheme == AnyP::PROTO_URN) {\n                parseUrn(tok); // throws on any error\n                return true;\n            }\n\n            // URLs then have \"//\"\n            static const SBuf doubleSlash(\"//\");\n            if (!tok.skip(doubleSlash))\n                return false;\n\n            auto B = tok.remaining();\n            const char *url = B.c_str();\n\n            /* Parse the URL: */\n            src = url;\n            i = 0;\n\n            /* Then everything until first /; that's host (and port; which we'll look for here later) */\n            // bug 1881: If we don't get a \"/\" then we imply it was there\n            // bug 3074: We could just be given a \"?\" or \"#\". These also imply \"/\"\n            // bug 3233: whitespace is also a hostname delimiter.\n            for (dst = foundHost; i < l && *src != '/' && *src != '?' && *src != '#' && *src != '\\0' && !xisspace(*src); ++i, ++src, ++dst) {\n                *dst = *src;\n            }\n\n            /*\n             * We can't check for \"i >= l\" here because we could be at the end of the line\n             * and have a perfectly valid URL w/ no trailing '/'. In this case we assume we've\n             * been -given- a valid URL and the path is just '/'.\n             */\n            if (i > l)\n                return false;\n            *dst = '\\0';\n\n            // We are looking at path-abempty.\n            if (*src != '/') {\n                // path-empty, including the end of the `src` c-string cases\n                urlpath[0] = '/';\n                dst = &urlpath[1];\n            } else {\n                dst = urlpath;\n            }\n            /* Then everything from / (inclusive) until \\r\\n or \\0 - that's urlpath */\n            for (; i < l && *src != '\\r' && *src != '\\n' && *src != '\\0'; ++i, ++src, ++dst) {\n                *dst = *src;\n            }\n\n            /* We -could- be at the end of the buffer here */\n            if (i > l)\n                return false;\n            *dst = '\\0';\n\n            // If the parsed scheme has no (known) default port, and there is no\n            // explicit port, then we will reject the zero port during foundPort\n            // validation, often resulting in a misleading 400/ERR_INVALID_URL.\n            // TODO: Remove this hack when switching to Tokenizer-based parsing.\n            foundPort = scheme.defaultPort().value_or(0); // may be reset later\n\n            /* Is there any login information? (we should eventually parse it above) */\n            t = strrchr(foundHost, '@');\n            if (t != nullptr) {\n                strncpy((char *) login, (char *) foundHost, sizeof(login)-1);\n                login[sizeof(login)-1] = '\\0';\n                t = strrchr(login, '@');\n                *t = 0;\n                strncpy((char *) foundHost, t + 1, sizeof(foundHost)-1);\n                foundHost[sizeof(foundHost)-1] = '\\0';\n                // Bug 4498: URL-unescape the login info after extraction\n                rfc1738_unescape(login);\n            }\n\n            /* Is there any host information? (we should eventually parse it above) */\n            if (*foundHost == '[') {\n                /* strip any IPA brackets. valid under IPv6. */\n                dst = foundHost;\n                /* only for IPv6 sadly, pre-IPv6/URL code can't handle the clean result properly anyway. */\n                src = foundHost;\n                ++src;\n                l = strlen(foundHost);\n                i = 1;\n                for (; i < l && *src != ']' && *src != '\\0'; ++i, ++src, ++dst) {\n                    *dst = *src;\n                }\n\n                /* we moved in-place, so truncate the actual hostname found */\n                *dst = '\\0';\n                ++dst;\n\n                /* skip ahead to either start of port, or original EOS */\n                while (*dst != '\\0' && *dst != ':')\n                    ++dst;\n                t = dst;\n            } else {\n                t = strrchr(foundHost, ':');\n\n                if (t != strchr(foundHost,':') ) {\n                    /* RFC 2732 states IPv6 \"SHOULD\" be bracketed. allowing for times when its not. */\n                    /* RFC 3986 'update' simply modifies this to an \"is\" with no emphasis at all! */\n                    /* therefore we MUST accept the case where they are not bracketed at all. */\n                    t = nullptr;\n                }\n            }\n\n            // Bug 3183 sanity check: If scheme is present, host must be too.\n            if (scheme != AnyP::PROTO_NONE && foundHost[0] == '\\0') {\n                debugs(23, DBG_IMPORTANT, \"SECURITY ALERT: Missing hostname in URL '\" << url << \"'. see access.log for details.\");\n                return false;\n            }\n\n            if (t && *t == ':') {\n                *t = '\\0';\n                ++t;\n                foundPort = atoi(t);\n            }\n        }\n\n        for (t = foundHost; *t; ++t)\n            *t = xtolower(*t);\n\n        if (stringHasWhitespace(foundHost)) {\n            if (URI_WHITESPACE_STRIP == Config.uri_whitespace) {\n                t = q = foundHost;\n                while (*t) {\n                    if (!xisspace(*t)) {\n                        *q = *t;\n                        ++q;\n                    }\n                    ++t;\n                }\n                *q = '\\0';\n            }\n        }\n\n        debugs(23, 3, \"Split URL '\" << rawUrl << \"' into proto='\" << scheme.image() << \"', host='\" << foundHost << \"', port='\" << foundPort << \"', path='\" << urlpath << \"'\");\n\n        if (Config.onoff.check_hostnames &&\n                strspn(foundHost, Config.onoff.allow_underscore ? valid_hostname_chars_u : valid_hostname_chars) != strlen(foundHost)) {\n            debugs(23, DBG_IMPORTANT, MYNAME << \"Illegal character in hostname '\" << foundHost << \"'\");\n            return false;\n        }\n\n        if (!urlAppendDomain(foundHost))\n            return false;\n\n        /* remove trailing dots from hostnames */\n        while ((l = strlen(foundHost)) > 0 && foundHost[--l] == '.')\n            foundHost[l] = '\\0';\n\n        /* reject duplicate or leading dots */\n        if (strstr(foundHost, \"..\") || *foundHost == '.') {\n            debugs(23, DBG_IMPORTANT, MYNAME << \"Illegal hostname '\" << foundHost << \"'\");\n            return false;\n        }\n\n        if (foundPort < 1 || foundPort > 65535) {\n            debugs(23, 3, \"Invalid port '\" << foundPort << \"'\");\n            return false;\n        }\n\n        if (stringHasWhitespace(urlpath)) {\n            debugs(23, 2, \"URI has whitespace: {\" << rawUrl << \"}\");\n\n            switch (Config.uri_whitespace) {\n\n            case URI_WHITESPACE_DENY:\n                return false;\n\n            case URI_WHITESPACE_ALLOW:\n                break;\n\n            case URI_WHITESPACE_ENCODE:\n                t = rfc1738_escape_unescaped(urlpath);\n                xstrncpy(urlpath, t, MAX_URL);\n                break;\n\n            case URI_WHITESPACE_CHOP:\n                *(urlpath + strcspn(urlpath, w_space)) = '\\0';\n                break;\n\n            case URI_WHITESPACE_STRIP:\n            default:\n                t = q = urlpath;\n                while (*t) {\n                    if (!xisspace(*t)) {\n                        *q = *t;\n                        ++q;\n                    }\n                    ++t;\n                }\n                *q = '\\0';\n            }\n        }\n\n        setScheme(scheme);\n        path(urlpath);\n        host(foundHost);\n        userInfo(SBuf(login));\n        port(foundPort);\n        return true;\n\n    } catch (...) {\n        debugs(23, 2, \"error: \" << CurrentException << \" \" << Raw(\"rawUrl\", rawUrl.rawContent(), rawUrl.length()));\n        return false;\n    }\n}\n\n/**\n * Governed by RFC 8141 section 2:\n *\n *  assigned-name = \"urn\" \":\" NID \":\" NSS\n *  NID           = (alphanum) 0*30(ldh) (alphanum)\n *  ldh           = alphanum / \"-\"\n *  NSS           = pchar *(pchar / \"/\")\n *\n * RFC 3986 Appendix D.2 defines (as deprecated):\n *\n *   alphanum     = ALPHA / DIGIT\n *\n * Notice that NID is exactly 2-32 characters in length.\n */\nvoid\nAnyP::Uri::parseUrn(Parser::Tokenizer &tok)\n{\n    static const auto nidChars = CharacterSet(\"NID\",\"-\") + CharacterSet::ALPHA + CharacterSet::DIGIT;\n    static const auto alphanum = (CharacterSet::ALPHA + CharacterSet::DIGIT).rename(\"alphanum\");\n    SBuf nid;\n    if (!tok.prefix(nid, nidChars, 32))\n        throw TextException(\"NID not found\", Here());\n\n    if (!tok.skip(':'))\n        throw TextException(\"NID too long or missing ':' delimiter\", Here());\n\n    if (nid.length() < 2)\n        throw TextException(\"NID too short\", Here());\n\n    if (!alphanum[*nid.begin()])\n        throw TextException(\"NID prefix is not alphanumeric\", Here());\n\n    if (!alphanum[*nid.rbegin()])\n        throw TextException(\"NID suffix is not alphanumeric\", Here());\n\n    setScheme(AnyP::PROTO_URN, nullptr);\n    host(nid.c_str());\n    // TODO validate path characters\n    path(tok.remaining());\n    debugs(23, 3, \"Split URI into proto=urn, nid=\" << nid << \", \" << Raw(\"path\",path().rawContent(),path().length()));\n}\n\n/// Extracts and returns a (suspected but only partially validated) uri-host\n/// IPv6address, IPv4address, or reg-name component. This function uses (and\n/// quotes) RFC 3986, Section 3.2.2 syntax rules.\nSBuf\nAnyP::Uri::parseHost(Parser::Tokenizer &tok) const\n{\n    // host = IP-literal / IPv4address / reg-name\n\n    // XXX: CharacterSets below reject uri-host values containing whitespace\n    // (e.g., \"10.0.0. 1\"). That is not a bug, but the uri_whitespace directive\n    // can be interpreted as if it applies to uri-host and this code. TODO: Fix\n    // uri_whitespace and the code using it to exclude uri-host (and URI scheme,\n    // port, etc.) from that directive scope.\n\n    // IP-literal = \"[\" ( IPv6address / IPvFuture  ) \"]\"\n    if (tok.skip('[')) {\n        // Add \".\" because IPv6address in RFC 3986 includes ls32, which includes\n        // IPv4address: ls32 = ( h16 \":\" h16 ) / IPv4address\n        // This set rejects IPvFuture that needs a \"v\" character.\n        static const CharacterSet IPv6chars = (\n                CharacterSet::HEXDIG + CharacterSet(\"colon\", \":\") + CharacterSet(\"period\", \".\")).rename(\"IPv6\");\n        SBuf ipv6ish;\n        if (!tok.prefix(ipv6ish, IPv6chars))\n            throw TextException(\"malformed or unsupported bracketed IP address in uri-host\", Here());\n\n        if (!tok.skip(']'))\n            throw TextException(\"IPv6 address is missing a closing bracket in uri-host\", Here());\n\n        // This rejects bracketed IPv4address and domain names because they lack \":\".\n        if (ipv6ish.find(':') == SBuf::npos)\n            throw TextException(\"bracketed IPv6 address is missing a colon in uri-host\", Here());\n\n        // This rejects bracketed non-IP addresses that our caller would have\n        // otherwise mistaken for a domain name (e.g., '[127.0.0:1]').\n        Ip::Address ipv6check;\n        if (!ipv6check.fromHost(ipv6ish.c_str()))\n            throw TextException(\"malformed bracketed IPv6 address in uri-host\", Here());\n\n        return ipv6ish;\n    }\n\n    // no brackets implies we are looking at IPv4address or reg-name\n\n    // XXX: This code does not detect/reject some bad host values (e.g. \"!#$%&\"\n    // and \"1.2.3.4.5\"). TODO: Add more checks here, after migrating the\n    // non-CONNECT uri-host parsing code to use us.\n\n    SBuf otherHost; // IPv4address-ish or reg-name-ish;\n    // \":\" is not in TCHAR so we will stop before any port specification\n    if (tok.prefix(otherHost, CharacterSet::TCHAR))\n        return otherHost;\n\n    throw TextException(\"malformed IPv4 address or host name in uri-host\", Here());\n}\n\n/// Extracts and returns an RFC 3986 URI authority port value (with additional\n/// restrictions). The RFC defines port as a possibly empty sequence of decimal\n/// digits. We reject certain ports (that are syntactically valid from the RFC\n/// point of view) because we are worried that Squid and other traffic handlers\n/// may dangerously mishandle unusual (and virtually always bogus) port numbers.\n/// Rejected ports cannot be successfully used by Squid itself.\nint\nAnyP::Uri::parsePort(Parser::Tokenizer &tok) const\n{\n    if (tok.skip('0'))\n        throw TextException(\"zero or zero-prefixed port\", Here());\n\n    int64_t rawPort = 0;\n    if (!tok.int64(rawPort, 10, false)) // port = *DIGIT\n        throw TextException(\"malformed or missing port\", Here());\n\n    Assure(rawPort > 0);\n    constexpr KnownPort portMax = 65535; // TODO: Make this a class-scope constant and REuse it.\n    constexpr auto portStorageMax = std::numeric_limits<Port::value_type>::max();\n    static_assert(!Less(portStorageMax, portMax), \"Port type can represent the maximum valid port number\");\n    if (Less(portMax, rawPort))\n        throw TextException(\"huge port\", Here());\n\n    // TODO: Return KnownPort after migrating the non-CONNECT uri-host parsing\n    // code to use us (so that foundPort \"int\" disappears or starts using Port).\n    return NaturalCast<int>(rawPort);\n}\n\nvoid\nAnyP::Uri::touch()\n{\n    absolute_.clear();\n    authorityHttp_.clear();\n    authorityWithPort_.clear();\n}\n\nSBuf &\nAnyP::Uri::authority(bool requirePort) const\n{\n    if (authorityHttp_.isEmpty()) {\n\n        // both formats contain Host/IP\n        authorityWithPort_.append(host());\n        authorityHttp_ = authorityWithPort_;\n\n        if (port().has_value()) {\n            authorityWithPort_.appendf(\":%hu\", *port());\n            // authorityHttp_ only has :port for known non-default ports\n            if (port() != getScheme().defaultPort())\n                authorityHttp_ = authorityWithPort_;\n        }\n        // else XXX: We made authorityWithPort_ that does not have a port.\n        // TODO: Audit callers and refuse to give out broken authorityWithPort_.\n    }\n\n    return requirePort ? authorityWithPort_ : authorityHttp_;\n}\n\nSBuf &\nAnyP::Uri::absolute() const\n{\n    if (absolute_.isEmpty()) {\n        // TODO: most URL will be much shorter, avoid allocating this much\n        absolute_.reserveCapacity(MAX_URL);\n\n        absolute_.append(getScheme().image());\n        absolute_.append(\":\",1);\n        if (getScheme() != AnyP::PROTO_URN) {\n            absolute_.append(\"//\", 2);\n            const bool allowUserInfo = getScheme() == AnyP::PROTO_FTP ||\n                                       getScheme() == AnyP::PROTO_UNKNOWN;\n\n            if (allowUserInfo && !userInfo().isEmpty()) {\n                static const CharacterSet uiChars = CharacterSet(UserInfoChars())\n                                                    .remove('%')\n                                                    .rename(\"userinfo-reserved\");\n                absolute_.append(Encode(userInfo(), uiChars));\n                absolute_.append(\"@\", 1);\n            }\n            absolute_.append(authority());\n        } else {\n            absolute_.append(host());\n            absolute_.append(\":\", 1);\n        }\n        absolute_.append(path()); // TODO: Encode each URI subcomponent in path_ as needed.\n    }\n\n    return absolute_;\n}\n\n/* XXX: Performance: This is an *almost* duplicate of HttpRequest::effectiveRequestUri(). But elides the query-string.\n *        After copying it on in the first place! Would be less code to merge the two with a flag parameter.\n *        and never copy the query-string part in the first place\n */\nchar *\nurlCanonicalCleanWithoutRequest(const SBuf &url, const HttpRequestMethod &method, const AnyP::UriScheme &scheme)\n{\n    LOCAL_ARRAY(char, buf, MAX_URL);\n\n    snprintf(buf, sizeof(buf), SQUIDSBUFPH, SQUIDSBUFPRINT(url));\n    buf[sizeof(buf)-1] = '\\0';\n\n    // URN, CONNECT method, and non-stripped URIs can go straight out\n    if (Config.onoff.strip_query_terms && !(method == Http::METHOD_CONNECT || scheme == AnyP::PROTO_URN)) {\n        // strip anything AFTER a question-mark\n        // leaving the '?' in place\n        if (auto t = strchr(buf, '?')) {\n            *(++t) = '\\0';\n        }\n    }\n\n    if (stringHasCntl(buf))\n        xstrncpy(buf, rfc1738_escape_unescaped(buf), MAX_URL);\n\n    return buf;\n}\n\n/**\n * Yet another alternative to urlCanonical.\n * This one adds the https:// parts to Http::METHOD_CONNECT URL\n * for use in error page outputs.\n * Luckily we can leverage the others instead of duplicating.\n */\nconst char *\nurlCanonicalFakeHttps(const HttpRequest * request)\n{\n    LOCAL_ARRAY(char, buf, MAX_URL);\n\n    // method CONNECT and port HTTPS\n    if (request->method == Http::METHOD_CONNECT && request->url.port() == 443) {\n        snprintf(buf, MAX_URL, \"https://%s/*\", request->url.host());\n        return buf;\n    }\n\n    // else do the normal complete canonical thing.\n    return request->canonicalCleanUrl();\n}\n\n/**\n * Test if a URL is a relative reference.\n *\n * Governed by RFC 3986 section 4.2\n *\n *  relative-ref  = relative-part [ \"?\" query ] [ \"#\" fragment ]\n *\n *  relative-part = \"//\" authority path-abempty\n *                / path-absolute\n *                / path-noscheme\n *                / path-empty\n */\nbool\nurlIsRelative(const char *url)\n{\n    if (!url)\n        return false; // no URL\n\n    /*\n     * RFC 3986 section 5.2.3\n     *\n     * path          = path-abempty    ; begins with \"/\" or is empty\n     *               / path-absolute   ; begins with \"/\" but not \"//\"\n     *               / path-noscheme   ; begins with a non-colon segment\n     *               / path-rootless   ; begins with a segment\n     *               / path-empty      ; zero characters\n     */\n\n    if (*url == '\\0')\n        return true; // path-empty\n\n    if (*url == '/') {\n        // RFC 3986 section 5.2.3\n        // path-absolute   ; begins with \"/\" but not \"//\"\n        if (url[1] == '/')\n            return true; // network-path reference, aka. 'scheme-relative URI'\n        else\n            return true; // path-absolute, aka 'absolute-path reference'\n    }\n\n    for (const auto *p = url; *p != '\\0' && *p != '/' && *p != '?' && *p != '#'; ++p) {\n        if (*p == ':')\n            return false; // colon is forbidden in first segment\n    }\n\n    return true; // path-noscheme, path-abempty, path-rootless\n}\n\nvoid\nAnyP::Uri::addRelativePath(const char *relUrl)\n{\n    // URN cannot be merged\n    if (getScheme() == AnyP::PROTO_URN)\n        return;\n\n    // TODO: Handle . and .. segment normalization\n\n    const auto lastSlashPos = path_.rfind('/');\n    // TODO: To optimize and simplify, add and use SBuf::replace().\n    const auto relUrlLength = strlen(relUrl);\n    if (lastSlashPos == SBuf::npos) {\n        // start replacing the whole path\n        path_.reserveCapacity(1 + relUrlLength);\n        path_.assign(\"/\", 1);\n    } else {\n        // start replacing just the last segment\n        path_.reserveCapacity(lastSlashPos + 1 + relUrlLength);\n        path_.chop(0, lastSlashPos+1);\n    }\n    path_.append(relUrl, relUrlLength);\n}\n\nint\nmatchDomainName(const char *h, const char *d, MatchDomainNameFlags flags)\n{\n    int dl;\n    int hl;\n\n    const bool hostIncludesSubdomains = (*h == '.');\n    while ('.' == *h)\n        ++h;\n\n    hl = strlen(h);\n\n    if (hl == 0)\n        return -1;\n\n    dl = strlen(d);\n    if (dl == 0)\n        return 1;\n\n    /*\n     * Start at the ends of the two strings and work towards the\n     * beginning.\n     */\n    while (xtolower(h[--hl]) == xtolower(d[--dl])) {\n        if (hl == 0 && dl == 0) {\n            /*\n             * We made it all the way to the beginning of both\n             * strings without finding any difference.\n             */\n            return 0;\n        }\n\n        if (0 == hl) {\n            /*\n             * The host string is shorter than the domain string.\n             * There is only one case when this can be a match.\n             * If the domain is just one character longer, and if\n             * that character is a leading '.' then we call it a\n             * match.\n             */\n\n            if (1 == dl && '.' == d[0])\n                return 0;\n            else\n                return -1;\n        }\n\n        if (0 == dl) {\n            /*\n             * The domain string is shorter than the host string.\n             * This is a match only if the first domain character\n             * is a leading '.'.\n             */\n\n            if ('.' == d[0]) {\n                if (flags & mdnRejectSubsubDomains) {\n                    // Check for sub-sub domain and reject\n                    while(--hl >= 0 && h[hl] != '.');\n                    if (hl < 0) {\n                        // No sub-sub domain found, but reject if there is a\n                        // leading dot in given host string (which is removed\n                        // before the check is started).\n                        return hostIncludesSubdomains ? 1 : 0;\n                    } else\n                        return 1; // sub-sub domain, reject\n                } else\n                    return 0;\n            } else\n                return 1;\n        }\n    }\n\n    /*\n     * We found different characters in the same position (from the end).\n     */\n\n    // If the h has a form of \"*.foo.com\" and d has a form of \"x.foo.com\"\n    // then the h[hl] points to '*', h[hl+1] to '.' and d[dl] to 'x'\n    // The following checks are safe, the \"h[hl + 1]\" in the worst case is '\\0'.\n    if ((flags & mdnHonorWildcards) && h[hl] == '*' && h[hl + 1] == '.')\n        return 0;\n\n    /*\n     * If one of those character is '.' then its special.  In order\n     * for splay tree sorting to work properly, \"x-foo.com\" must\n     * be greater than \".foo.com\" even though '-' is less than '.'.\n     */\n    if ('.' == d[dl])\n        return 1;\n\n    if ('.' == h[hl])\n        return -1;\n\n    return (xtolower(h[hl]) - xtolower(d[dl]));\n}\n\n/*\n * return true if we can serve requests for this method.\n */\nbool\nurlCheckRequest(const HttpRequest * r)\n{\n    /* protocol \"independent\" methods\n     *\n     * actually these methods are specific to HTTP:\n     * they are methods we receive on our HTTP port,\n     * and if we had a FTP listener would not be relevant\n     * there.\n     *\n     * So, we should delegate them to HTTP. The problem is that we\n     * do not have a default protocol from the client side of HTTP.\n     */\n\n    if (r->method == Http::METHOD_CONNECT)\n        return true;\n\n    // we support OPTIONS and TRACE directed at us (with a 501 reply, for now)\n    // we also support forwarding OPTIONS and TRACE, except for the *-URI ones\n    if (r->method == Http::METHOD_OPTIONS || r->method == Http::METHOD_TRACE)\n        return (r->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0 || r->url.path() != AnyP::Uri::Asterisk());\n\n    if (r->method == Http::METHOD_PURGE)\n        return true;\n\n    /* does method match the protocol? */\n    switch (r->url.getScheme()) {\n\n    case AnyP::PROTO_URN:\n    case AnyP::PROTO_HTTP:\n        return true;\n\n    case AnyP::PROTO_FTP:\n        if (r->method == Http::METHOD_PUT ||\n                r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD )\n            return true;\n        return false;\n\n    case AnyP::PROTO_WAIS:\n    case AnyP::PROTO_WHOIS:\n        if (r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD)\n            return true;\n        return false;\n\n    case AnyP::PROTO_HTTPS:\n#if USE_OPENSSL || USE_GNUTLS\n        return true;\n#else\n        /*\n         * Squid can't originate an SSL connection, so it should\n         * never receive an \"https:\" URL.  It should always be\n         * CONNECT instead.\n         */\n        return false;\n#endif\n\n    default:\n        return false;\n    }\n\n    /* notreached */\n    return false;\n}\n\nAnyP::Uri::Uri(AnyP::UriScheme const &aScheme) :\n    scheme_(aScheme),\n    hostIsNumeric_(false)\n{\n    *host_=0;\n}\n\n// TODO: fix code duplication with AnyP::Uri::parse()\nchar *\nAnyP::Uri::cleanup(const char *uri)\n{\n    char *cleanedUri = nullptr;\n    switch (Config.uri_whitespace) {\n    case URI_WHITESPACE_ALLOW: {\n        const auto flags = RFC1738_ESCAPE_NOSPACE | RFC1738_ESCAPE_UNESCAPED;\n        cleanedUri = xstrndup(rfc1738_do_escape(uri, flags), MAX_URL);\n        break;\n    }\n\n    case URI_WHITESPACE_ENCODE:\n        cleanedUri = xstrndup(rfc1738_do_escape(uri, RFC1738_ESCAPE_UNESCAPED), MAX_URL);\n        break;\n\n    case URI_WHITESPACE_CHOP: {\n        const auto pos = strcspn(uri, w_space);\n        char *choppedUri = nullptr;\n        if (pos < strlen(uri))\n            choppedUri = xstrndup(uri, pos + 1);\n        cleanedUri = xstrndup(rfc1738_do_escape(choppedUri ? choppedUri : uri,\n                                                RFC1738_ESCAPE_UNESCAPED), MAX_URL);\n        cleanedUri[pos] = '\\0';\n        xfree(choppedUri);\n        break;\n    }\n\n    case URI_WHITESPACE_DENY:\n    case URI_WHITESPACE_STRIP:\n    default: {\n        // TODO: avoid duplication with urlParse()\n        const char *t;\n        char *tmp_uri = static_cast<char*>(xmalloc(strlen(uri) + 1));\n        char *q = tmp_uri;\n        t = uri;\n        while (*t) {\n            if (!xisspace(*t)) {\n                *q = *t;\n                ++q;\n            }\n            ++t;\n        }\n        *q = '\\0';\n        cleanedUri = xstrndup(rfc1738_escape_unescaped(tmp_uri), MAX_URL);\n        xfree(tmp_uri);\n        break;\n    }\n    }\n\n    assert(cleanedUri);\n    return cleanedUri;\n}\n\n"], "filenames": ["src/anyp/Uri.cc"], "buggy_code_start_loc": [177], "buggy_code_end_loc": [830], "fixing_code_start_loc": [178], "fixing_code_end_loc": [837], "type": "CWE-295", "message": " Squid is a caching proxy for the Web. Due to an Improper Validation of Specified Index bug, Squid versions 3.3.0.1 through 5.9 and 6.0 prior to 6.4 compiled using `--with-openssl` are vulnerable to a Denial of Service attack against SSL Certificate validation. This problem allows a remote server to perform Denial of Service against Squid Proxy by initiating a TLS Handshake with a specially crafted SSL Certificate in a server certificate chain. This attack is limited to HTTPS and SSL-Bump. This bug is fixed in Squid version 6.4. In addition, patches addressing this problem for the stable releases can be found in Squid's patch archives. Those who you use a prepackaged version of Squid should refer to the package vendor for availability information on updated packages.", "other": {"cve": {"id": "CVE-2023-46724", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-01T20:15:08.800", "lastModified": "2023-12-29T03:15:10.793", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": " Squid is a caching proxy for the Web. Due to an Improper Validation of Specified Index bug, Squid versions 3.3.0.1 through 5.9 and 6.0 prior to 6.4 compiled using `--with-openssl` are vulnerable to a Denial of Service attack against SSL Certificate validation. This problem allows a remote server to perform Denial of Service against Squid Proxy by initiating a TLS Handshake with a specially crafted SSL Certificate in a server certificate chain. This attack is limited to HTTPS and SSL-Bump. This bug is fixed in Squid version 6.4. In addition, patches addressing this problem for the stable releases can be found in Squid's patch archives. Those who you use a prepackaged version of Squid should refer to the package vendor for availability information on updated packages."}, {"lang": "es", "value": "Squid es un proxy de almacenamiento en cach\u00e9 para la Web. Debido a un error de validaci\u00f3n incorrecta del \u00edndice especificado, las versiones de Squid 3.3.0.1 a 5.9 y 6.0 anteriores a 6.4 compiladas usando `--with-openssl` son vulnerables a un ataque de Denegaci\u00f3n de Servicio contra la validaci\u00f3n del certificado SSL. Este problema permite que un servidor remoto realice una denegaci\u00f3n de servicio contra Squid Proxy iniciando un protocolo de enlace TLS con un certificado SSL especialmente manipulado en una cadena de certificados de servidor. Este ataque se limita a HTTPS y SSL-Bump. Este error se solucion\u00f3 en la versi\u00f3n 6.4 de Squid. Adem\u00e1s, los parches que solucionan este problema para las versiones estables se pueden encontrar en los archivos de parches de Squid. Aquellos que utilicen una versi\u00f3n empaquetada de Squid deben consultar al proveedor del paquete para obtener informaci\u00f3n sobre la disponibilidad de paquetes actualizados."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-1285"}, {"lang": "en", "value": "CWE-129"}, {"lang": "en", "value": "CWE-786"}, {"lang": "en", "value": "CWE-823"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3.0.1", "versionEndExcluding": "6.4", "matchCriteriaId": "E8CC0157-8647-4BC3-AD22-4325B85D8A78"}]}]}], "references": [{"url": "http://www.squid-cache.org/Versions/v5/SQUID-2023_4.patch", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch"]}, {"url": "http://www.squid-cache.org/Versions/v6/SQUID-2023_4.patch", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch"]}, {"url": "https://github.com/squid-cache/squid/commit/b70f864940225dfe69f9f653f948e787f99c3810", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/squid-cache/squid/security/advisories/GHSA-73m6-jm96-c6r3", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/A5QASTMCUSUEW3UOMKHZJB3FTONWSRXS/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MEV66D3PAAY6K7TWDT3WZBLCPLASFJDC/", "source": "security-advisories@github.com"}, {"url": "https://security.netapp.com/advisory/ntap-20231208-0001/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/squid-cache/squid/commit/b70f864940225dfe69f9f653f948e787f99c3810"}}