{"buggy_code": ["/*******************************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *******************************************************************************/\n\npackage org.apache.ofbiz.common.login;\n\nimport java.sql.Timestamp;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.transaction.Transaction;\n\nimport org.apache.ofbiz.base.crypto.HashCrypt;\nimport org.apache.ofbiz.base.util.Debug;\nimport org.apache.ofbiz.base.util.UtilDateTime;\nimport org.apache.ofbiz.base.util.UtilMisc;\nimport org.apache.ofbiz.base.util.UtilProperties;\nimport org.apache.ofbiz.base.util.UtilValidate;\nimport org.apache.ofbiz.common.authentication.AuthHelper;\nimport org.apache.ofbiz.common.authentication.api.AuthenticatorException;\nimport org.apache.ofbiz.entity.Delegator;\nimport org.apache.ofbiz.entity.GenericEntityException;\nimport org.apache.ofbiz.entity.GenericValue;\nimport org.apache.ofbiz.entity.condition.EntityCondition;\nimport org.apache.ofbiz.entity.condition.EntityFunction;\nimport org.apache.ofbiz.entity.condition.EntityOperator;\nimport org.apache.ofbiz.entity.model.ModelEntity;\nimport org.apache.ofbiz.entity.transaction.GenericTransactionException;\nimport org.apache.ofbiz.entity.transaction.TransactionUtil;\nimport org.apache.ofbiz.entity.util.EntityListIterator;\nimport org.apache.ofbiz.entity.util.EntityQuery;\nimport org.apache.ofbiz.entity.util.EntityUtilProperties;\nimport org.apache.ofbiz.security.Security;\nimport org.apache.ofbiz.service.DispatchContext;\nimport org.apache.ofbiz.service.GenericServiceException;\nimport org.apache.ofbiz.service.LocalDispatcher;\nimport org.apache.ofbiz.service.ModelService;\nimport org.apache.ofbiz.service.ServiceUtil;\nimport org.apache.ofbiz.webapp.control.LoginWorker;\n\nimport org.apache.tomcat.util.res.StringManager;\n\n/**\n * <b>Title:</b> Login Services\n */\npublic class LoginServices {\n\n    public static final String module = LoginServices.class.getName();\n    public static final String resource = \"SecurityextUiLabels\";\n\n    /** Login service to authenticate username and password\n     * @return Map of results including (userLogin) GenericValue object\n     */\n    public static Map<String, Object> userLogin(DispatchContext ctx, Map<String, ?> context) {\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        Locale locale = (Locale) context.get(\"locale\");\n        Delegator delegator = ctx.getDelegator();\n\n        // load the external auth modules -- note: this will only run once and cache the objects\n        if (!AuthHelper.authenticatorsLoaded()) {\n            AuthHelper.loadAuthenticators(dispatcher);\n        }\n\n        // Authenticate to LDAP if configured to do so\n        // TODO: this should be moved to using the NEW Authenticator API\n        if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.enable\", delegator))) {\n            if (!LdapAuthenticationServices.userLogin(ctx, context)) {\n                String errMsg = UtilProperties.getMessage(resource, \"loginservices.ldap_authentication_failed\", locale);\n                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.fail.login\", delegator))) {\n                    return ServiceUtil.returnError(errMsg);\n                }\n                Debug.logInfo(errMsg, module);\n            }\n        }\n\n        Map<String, Object> result =  new LinkedHashMap<>();\n        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));\n\n        // if isServiceAuth is not specified, default to not a service auth\n        boolean isServiceAuth = context.get(\"isServiceAuth\") != null && ((Boolean) context.get(\"isServiceAuth\")).booleanValue();\n\n        String username = (String) context.get(\"login.username\");\n        if (username == null) {\n            username = (String) context.get(\"username\");\n        }\n        String password = (String) context.get(\"login.password\");\n        if (password == null) {\n            password = (String) context.get(\"password\");\n        }\n\n        // get the visitId for the history entity\n        String visitId = (String) context.get(\"visitId\");\n\n        String errMsg = \"\";\n        if (UtilValidate.isEmpty(username)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.username_missing\", locale);\n        } else if (UtilValidate.isEmpty(password)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_missing\", locale);\n        } else {\n\n            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"username.lowercase\", delegator))) {\n                username = username.toLowerCase(Locale.getDefault());\n            }\n            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"password.lowercase\", delegator))) {\n                password = password.toLowerCase(Locale.getDefault());\n            }\n\n            boolean repeat = true;\n            // starts at zero but it incremented at the beginning so in the first pass passNumber will be 1\n            int passNumber = 0;\n\n            while (repeat) {\n                repeat = false;\n                // pass number is incremented here because there are continues in this loop so it may never get to the end\n                passNumber++;\n\n                GenericValue userLogin = null;\n\n                try {\n                    // only get userLogin from cache for service calls; for web and other manual logins there is less time sensitivity\n                    userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();\n                } catch (GenericEntityException e) {\n                    Debug.logWarning(e, \"\", module);\n                }\n\n\n                // see if any external auth modules want to sync the user info\n                if (userLogin == null) {\n                    try {\n                        AuthHelper.syncUser(username);\n                    } catch (AuthenticatorException e) {\n                        Debug.logWarning(e, module);\n                    }\n\n                    // check the user login object again\n                    try {\n                        userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();\n                    } catch (GenericEntityException e) {\n                        Debug.logWarning(e, \"\", module);\n                    }\n                }\n\n                if (userLogin != null) {\n                    String ldmStr = EntityUtilProperties.getPropertyValue(\"security\", \"login.disable.minutes\", delegator);\n                    long loginDisableMinutes;\n\n                    try {\n                        loginDisableMinutes = Long.parseLong(ldmStr);\n                    } catch (Exception e) {\n                        loginDisableMinutes = 30;\n                        Debug.logWarning(\"Could not parse login.disable.minutes from security.properties, using default of 30\", module);\n                    }\n\n                    Timestamp disabledDateTime = userLogin.getTimestamp(\"disabledDateTime\");\n                    Timestamp reEnableTime = null;\n\n                    if (loginDisableMinutes > 0 && disabledDateTime != null) {\n                        reEnableTime = new Timestamp(disabledDateTime.getTime() + loginDisableMinutes * 60000);\n                    }\n\n                    boolean doStore = true;\n                    // we might change & store this userLogin, so we should clone it here to get a mutable copy\n                    userLogin = GenericValue.create(userLogin);\n\n                    // get the is system flag -- system accounts can only be used for service authentication\n                    boolean isSystem = (isServiceAuth && userLogin.get(\"isSystem\") != null) ?\n                            \"Y\".equalsIgnoreCase(userLogin.getString(\"isSystem\")) : false;\n\n                    // grab the hasLoggedOut flag\n                    Boolean hasLoggedOut = userLogin.getBoolean(\"hasLoggedOut\");\n\n                    if ((UtilValidate.isEmpty(userLogin.getString(\"enabled\")) || \"Y\".equals(userLogin.getString(\"enabled\")) ||\n                            (reEnableTime != null && reEnableTime.before(UtilDateTime.nowTimestamp())) || (isSystem)) && UtilValidate.isEmpty(userLogin.getString(\"disabledBy\"))) {\n\n                        String successfulLogin;\n\n                        if (!isSystem) {\n                            userLogin.set(\"enabled\", \"Y\");\n                            userLogin.set(\"disabledBy\", null);\n                        }\n\n                        // attempt to authenticate with Authenticator class(es)\n                        boolean authFatalError = false;\n                        boolean externalAuth = false;\n                        try {\n                            externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);\n                        } catch (AuthenticatorException e) {\n                            // fatal error -- or single authenticator found -- fail now\n                            Debug.logWarning(e, module);\n                            authFatalError = true;\n\n                        }\n\n                        // check whether to sign in with Tomcat SSO\n                        boolean useTomcatSSO = EntityUtilProperties.propertyValueEquals(\"security\", \"security.login.tomcat.sso\", \"true\");\n                        HttpServletRequest request = (javax.servlet.http.HttpServletRequest) context.get(\"request\");\n                        // when request is not supplied, we will treat that SSO is not required as\n                        // in the usage of userLogin service in ICalWorker.java and XmlRpcEventHandler.java.\n                        useTomcatSSO = useTomcatSSO && (request!=null);\n\n                        // if the password.accept.encrypted.and.plain property in security is set to true allow plain or encrypted passwords\n                        // if this is a system account don't bother checking the passwords\n                        // if externalAuth passed; this is run as well\n                        if ((!authFatalError && externalAuth) || (useTomcatSSO ? TomcatSSOLogin(request, username, password) : checkPassword(userLogin.getString(\"currentPassword\"), useEncryption, password) )) {\n                            Debug.logVerbose(\"[LoginServices.userLogin] : Password Matched\", module);\n\n                            // update the hasLoggedOut flag\n                            if (hasLoggedOut == null || hasLoggedOut) {\n                                userLogin.set(\"hasLoggedOut\", \"N\");\n                            }\n\n                            // reset failed login count if necessry\n                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");\n                            if (currentFailedLogins != null && currentFailedLogins.longValue() > 0) {\n                                userLogin.set(\"successiveFailedLogins\", Long.valueOf(0));\n                            } else if (hasLoggedOut != null && !hasLoggedOut) {\n                                // successful login & no loggout flag, no need to change anything, so don't do the store\n                                doStore = false;\n                            }\n\n                            successfulLogin = \"Y\";\n\n                            if (!isServiceAuth) {\n                                // get the UserLoginSession if this is not a service auth\n                                Map<?, ?> userLoginSessionMap = LoginWorker.getUserLoginSession(userLogin);\n\n                                // return the UserLoginSession Map\n                                if (userLoginSessionMap != null) {\n                                    result.put(\"userLoginSession\", userLoginSessionMap);\n                                }\n                            }\n\n                            result.put(\"userLogin\", userLogin);\n                            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                        } else {\n                            // password is incorrect, but this may be the result of a stale cache entry,\n                            // so lets clear the cache and try again if this is the first pass\n                            // but only if authFatalError is not true; this would mean the single authenticator failed\n                            if (!authFatalError && isServiceAuth && passNumber <= 1) {\n                                delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));\n                                repeat = true;\n                                continue;\n                            }\n\n                            Debug.logInfo(\"[LoginServices.userLogin] : Password Incorrect\", module);\n                            // password invalid...\n                            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_incorrect\", locale);\n\n                            // increment failed login count\n                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");\n\n                            if (currentFailedLogins == null) {\n                                currentFailedLogins = Long.valueOf(1);\n                            } else {\n                                currentFailedLogins = Long.valueOf(currentFailedLogins.longValue() + 1);\n                            }\n                            userLogin.set(\"successiveFailedLogins\", currentFailedLogins);\n\n                            // if failed logins over amount in properties file, disable account\n                            String mflStr = EntityUtilProperties.getPropertyValue(\"security\", \"max.failed.logins\", delegator);\n                            long maxFailedLogins = 3;\n                            try {\n                                maxFailedLogins = Long.parseLong(mflStr);\n                            } catch (Exception e) {\n                                maxFailedLogins = 3;\n                                Debug.logWarning(\"Could not parse max.failed.logins from security.properties, using default of 3\", module);\n                            }\n\n                            if (maxFailedLogins > 0 && currentFailedLogins.longValue() >= maxFailedLogins) {\n                                userLogin.set(\"enabled\", \"N\");\n                                userLogin.set(\"disabledDateTime\", UtilDateTime.nowTimestamp());\n                            }\n\n                            successfulLogin = \"N\";\n                        }\n\n                        // this section is being done in its own transaction rather than in the\n                        //current/existing transaction because we may return error and we don't\n                        //want that to stop this from getting stored\n                        Transaction parentTx = null;\n                        boolean beganTransaction = false;\n\n                        try {\n                            try {\n                                parentTx = TransactionUtil.suspend();\n                            } catch (GenericTransactionException e) {\n                                Debug.logError(e, \"Could not suspend transaction: \" + e.getMessage(), module);\n                            }\n\n                            try {\n                                beganTransaction = TransactionUtil.begin();\n\n                                if (doStore) {\n                                    userLogin.store();\n                                }\n\n                                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history\", delegator))) {\n                                    boolean createHistory = true;\n\n                                    // only save info on service auth if option set to true to do so\n                                    if (isServiceAuth && !\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history.on.service.auth\", delegator))) {\n                                        createHistory = false;\n                                    }\n\n                                    if (createHistory) {\n                                        Map<String, Object> ulhCreateMap = UtilMisc.toMap(\"userLoginId\", username, \"visitId\", visitId,\n                                                \"fromDate\", UtilDateTime.nowTimestamp(), \"successfulLogin\", successfulLogin);\n\n                                        ModelEntity modelUserLogin = userLogin.getModelEntity();\n                                        if (modelUserLogin.isField(\"partyId\")) {\n                                            ulhCreateMap.put(\"partyId\", userLogin.get(\"partyId\"));\n                                        }\n\n                                        // ONLY save the password if it was incorrect\n                                        if (\"N\".equals(successfulLogin) && !\"false\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history.incorrect.password\", delegator))) {\n                                            ulhCreateMap.put(\"passwordUsed\", password);\n                                        }\n\n                                        delegator.create(\"UserLoginHistory\", ulhCreateMap);\n                                    }\n                                }\n                            } catch (GenericEntityException e) {\n                                String geeErrMsg = \"Error saving UserLoginHistory\";\n                                if (doStore) {\n                                    geeErrMsg += \" and updating login status to reset hasLoggedOut, unsuccessful login count, etc.\";\n                                }\n                                geeErrMsg += \": \" + e.toString();\n                                try {\n                                    TransactionUtil.rollback(beganTransaction, geeErrMsg, e);\n                                } catch (GenericTransactionException e2) {\n                                    Debug.logError(e2, \"Could not rollback nested transaction: \" + e2.getMessage(), module);\n                                }\n\n                                // if doStore is true then this error should not be ignored and we shouldn't consider it a successful login if this happens as there is something very wrong lower down that will bite us again later\n                                if (doStore) {\n                                    return ServiceUtil.returnError(geeErrMsg);\n                                }\n                            } finally {\n                                try {\n                                    TransactionUtil.commit(beganTransaction);\n                                } catch (GenericTransactionException e) {\n                                    Debug.logError(e, \"Could not commit nested transaction: \" + e.getMessage(), module);\n                                }\n                            }\n                        } finally {\n                            // resume/restore parent transaction\n                            if (parentTx != null) {\n                                try {\n                                    TransactionUtil.resume(parentTx);\n                                    Debug.logVerbose(\"Resumed the parent transaction.\", module);\n                                } catch (GenericTransactionException e) {\n                                    Debug.logError(e, \"Could not resume parent nested transaction: \" + e.getMessage(), module);\n                                }\n                            }\n                        }\n                    } else {\n                        // account is disabled, but this may be the result of a stale cache entry,\n                        // so lets clear the cache and try again if this is the first pass\n                        if (isServiceAuth && passNumber <= 1) {\n                            delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));\n                            repeat = true;\n                            continue;\n                        }\n\n                        Map<String, Object> messageMap = UtilMisc.<String, Object>toMap(\"username\", username);\n                        errMsg = UtilProperties.getMessage(resource,\"loginservices.account_for_user_login_id_disabled\",messageMap ,locale);\n                        if (disabledDateTime != null) {\n                            messageMap = UtilMisc.<String, Object>toMap(\"disabledDateTime\", disabledDateTime);\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.since_datetime\",messageMap ,locale);\n                        } else {\n                            errMsg += \".\";\n                        }\n\n                        if (loginDisableMinutes > 0 && reEnableTime != null) {\n                            messageMap = UtilMisc.<String, Object>toMap(\"reEnableTime\", reEnableTime);\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.will_be_reenabled\",messageMap ,locale);\n                        } else {\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.not_scheduled_to_be_reenabled\",locale);\n                        }\n                    }\n                } else {\n                    // no userLogin object; there may be a non-syncing authenticator\n                    boolean externalAuth = false;\n                    try {\n                        externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);\n                    } catch (AuthenticatorException e) {\n                        errMsg = e.getMessage();\n                        Debug.logError(e, \"External Authenticator had fatal exception : \" + e.getMessage(), module);\n                    }\n                    if (externalAuth) {\n                        // external auth passed - create a placeholder object for session\n                        userLogin = delegator.makeValue(\"UserLogin\");\n                        userLogin.set(\"userLoginId\", username);\n                        userLogin.set(\"enabled\", \"Y\");\n                        userLogin.set(\"hasLoggedOut\", \"N\");\n                        result.put(\"userLogin\", userLogin);\n                        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                        //TODO: more than this is needed to support 100% external authentication\n                        //TODO: party + security information is needed; Userlogin will need to be stored\n                    } else {\n                        // userLogin record not found, user does not exist\n                        errMsg = UtilProperties.getMessage(resource, \"loginservices.user_not_found\", locale);\n                        Debug.logInfo(\"[LoginServices.userLogin] Invalid User : '\" + username + \"'; \" + errMsg, module);\n                    }\n                }\n            }\n        }\n\n        if (errMsg.length() > 0) {\n            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_FAIL);\n            result.put(ModelService.ERROR_MESSAGE, errMsg);\n        }\n        return result;\n    }\n\n    public static void createUserLoginPasswordHistory(GenericValue userLogin) throws GenericEntityException{\n        int passwordChangeHistoryLimit = 0;\n        Delegator delegator = userLogin.getDelegator();\n        String userLoginId = userLogin.getString(\"userLoginId\");\n        String currentPassword = userLogin.getString(\"currentPassword\");\n        try {\n            passwordChangeHistoryLimit = EntityUtilProperties.getPropertyAsInteger(\"security\", \"password.change.history.limit\", 0).intValue();\n        } catch (NumberFormatException nfe) {\n            //No valid value is found so don't bother to save any password history\n            passwordChangeHistoryLimit = 0;\n        }\n        if (passwordChangeHistoryLimit == 0 || passwordChangeHistoryLimit < 0) {\n            // Not saving password history, so return from here.\n            return;\n        }\n        EntityQuery eq = EntityQuery.use(delegator)\n                .from(\"UserLoginPasswordHistory\")\n                .where(\"userLoginId\", userLoginId)\n                .orderBy(\"-fromDate\")\n                .cursorScrollInsensitive();\n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n        \n        try (EntityListIterator eli = eq.queryIterator()) {\n            GenericValue pwdHist;\n            if ((pwdHist = eli.next()) != null) {\n                // updating password so set end date on previous password in history\n                pwdHist.set(\"thruDate\", nowTimestamp);\n                pwdHist.store();\n                // check if we have hit the limit on number of password changes to be saved. If we did then delete the oldest password from history.\n                eli.last();\n                int rowIndex = eli.currentIndex();\n                if (rowIndex==passwordChangeHistoryLimit) {\n                    eli.afterLast();\n                    pwdHist = eli.previous();\n                    pwdHist.remove();\n                }\n            }\n        }\n\n        // save this password in history\n        GenericValue userLoginPwdHistToCreate = delegator.makeValue(\"UserLoginPasswordHistory\", UtilMisc.toMap(\"userLoginId\", userLoginId,\"fromDate\", nowTimestamp));\n        userLoginPwdHistToCreate.set(\"currentPassword\", currentPassword);\n        userLoginPwdHistToCreate.create();\n    }\n\n    /** Creates a UserLogin\n     *@param ctx The DispatchContext that this service is operating in\n     *@param context Map containing the input parameters\n     *@return Map with the result of the service, the output parameters\n     */\n    public static Map<String, Object> createUserLogin(DispatchContext ctx, Map<String, ?> context) {\n        Map<String, Object> result =  new LinkedHashMap<>();\n        Delegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        Security security = ctx.getSecurity();\n        GenericValue loggedInUserLogin = (GenericValue) context.get(\"userLogin\");\n        List<String> errorMessageList = new LinkedList<>();\n        Locale locale = (Locale) context.get(\"locale\");\n\n        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));\n\n        String userLoginId = (String) context.get(\"userLoginId\");\n        String partyId = (String) context.get(\"partyId\");\n        String currentPassword = (String) context.get(\"currentPassword\");\n        String currentPasswordVerify = (String) context.get(\"currentPasswordVerify\");\n        String enabled = (String) context.get(\"enabled\");\n        String passwordHint = (String) context.get(\"passwordHint\");\n        String requirePasswordChange = (String) context.get(\"requirePasswordChange\");\n        String externalAuthId = (String) context.get(\"externalAuthId\");\n        String errMsg = null;\n\n        String questionEnumId = (String) context.get(\"securityQuestion\");\n        String securityAnswer = (String) context.get(\"securityAnswer\");\n        \n        // security: don't create a user login if the specified partyId (if not empty) already exists\n        // unless the logged in user has permission to do so (same partyId or PARTYMGR_CREATE)\n        if (UtilValidate.isNotEmpty(partyId)) {\n            GenericValue party = null;\n\n            try {\n                party = EntityQuery.use(delegator).from(\"Party\").where(\"partyId\", partyId).queryOne();\n            } catch (GenericEntityException e) {\n                Debug.logWarning(e, \"\", module);\n            }\n\n            if (party != null) {\n                if (loggedInUserLogin != null) {\n                    // <b>security check</b>: userLogin partyId must equal partyId, or must have PARTYMGR_CREATE permission\n                    if (!partyId.equals(loggedInUserLogin.getString(\"partyId\"))) {\n                        if (!security.hasEntityPermission(\"PARTYMGR\", \"_CREATE\", loggedInUserLogin)) {\n\n                            errMsg = UtilProperties.getMessage(resource,\"loginservices.party_with_specified_party_ID_exists_not_have_permission\", locale);\n                            errorMessageList.add(errMsg);\n                        }\n                    }\n                } else {\n                    errMsg = UtilProperties.getMessage(resource,\"loginservices.must_be_logged_in_and_permission_create_login_party_ID_exists\", locale);\n                    errorMessageList.add(errMsg);\n                }\n            }\n        }\n\n        GenericValue userLoginToCreate = delegator.makeValue(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", userLoginId));\n        checkNewPassword(userLoginToCreate, null, currentPassword, currentPasswordVerify, passwordHint, errorMessageList, true, locale);\n        userLoginToCreate.set(\"externalAuthId\", externalAuthId);\n        userLoginToCreate.set(\"passwordHint\", passwordHint);\n        userLoginToCreate.set(\"enabled\", enabled);\n        userLoginToCreate.set(\"requirePasswordChange\", requirePasswordChange);\n        userLoginToCreate.set(\"currentPassword\", useEncryption ? HashCrypt.cryptUTF8(getHashType(), null, currentPassword) : currentPassword);\n        try {\n            userLoginToCreate.set(\"partyId\", partyId);\n        } catch (Exception e) {\n            // Will get thrown in framework-only installation\n            Debug.logInfo(e, \"Exception thrown while setting UserLogin partyId field: \", module);\n        }\n\n        try {\n            EntityCondition condition = EntityCondition.makeCondition(EntityFunction.UPPER_FIELD(\"userLoginId\"), EntityOperator.EQUALS, EntityFunction.UPPER(userLoginId));\n            if (UtilValidate.isNotEmpty(EntityQuery.use(delegator).from(\"UserLogin\").where(condition).queryList())) {\n                Map<String, String> messageMap = UtilMisc.toMap(\"userLoginId\", userLoginId);\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_with_ID_exists\", messageMap, locale);\n                errorMessageList.add(errMsg);\n            }\n        } catch (GenericEntityException e) {\n            Debug.logWarning(e, \"\", module);\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_read_failure\", messageMap, locale);\n            errorMessageList.add(errMsg);\n        }\n\n        if (errorMessageList.size() > 0) {\n            return ServiceUtil.returnError(errorMessageList);\n        }\n\n        try {\n            userLoginToCreate.create();\n            createUserLoginPasswordHistory(userLoginToCreate);\n        } catch (GenericEntityException e) {\n            Debug.logWarning(e, \"\", module);\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_write_failure\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        try {\n            if (UtilValidate.isNotEmpty(securityAnswer)) {\n                Map<String, Object> resultMap = dispatcher.runSync(\"createUserLoginSecurityQuestion\",\n                        UtilMisc.toMap(\"userLogin\", loggedInUserLogin, \"userLoginId\", userLoginId, \"questionEnumId\", questionEnumId, \"securityAnswer\", securityAnswer));\n                if (ServiceUtil.isError(resultMap)) {\n                    errMsg = ServiceUtil.getErrorMessage(resultMap);\n                    errorMessageList.add(errMsg);\n                    Debug.logError(errMsg, module);\n                }\n            }\n        } catch (GenericServiceException e1) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.error_setting_security_question\", locale);\n            Debug.logError(e1, errMsg, module);\n        }\n        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n        return result;\n    }\n\n    /** Updates UserLogin Password info\n     *@param ctx The DispatchContext that this service is operating in\n     *@param context Map containing the input parameters\n     *@return Map with the result of the service, the output parameters\n     */\n    public static Map<String, Object> updatePassword(DispatchContext ctx, Map<String, ?> context) {\n        Delegator delegator = ctx.getDelegator();\n        Security security = ctx.getSecurity();\n        GenericValue loggedInUserLogin = (GenericValue) context.get(\"userLogin\");\n        Locale locale = (Locale) context.get(\"locale\");\n        Map<String, Object> result = ServiceUtil.returnSuccess(UtilProperties.getMessage(resource, \"loginevents.password_was_changed_with_success\", locale));\n\n        // load the external auth modules -- note: this will only run once and cache the objects\n        if (!AuthHelper.authenticatorsLoaded()) {\n            AuthHelper.loadAuthenticators(ctx.getDispatcher());\n        }\n\n        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));\n        boolean adminUser = false;\n\n        String userLoginId = (String) context.get(\"userLoginId\");\n        String errMsg = null;\n\n        if (UtilValidate.isEmpty(userLoginId)) {\n            userLoginId = loggedInUserLogin.getString(\"userLoginId\");\n        }\n\n        // <b>security check</b>: userLogin userLoginId must equal userLoginId, or must have PARTYMGR_UPDATE permission\n        // NOTE: must check permission first so that admin users can set own password without specifying old password\n        // TODO: change this security group because we can't use permission groups defined in the applications from the framework.\n        if (!security.hasEntityPermission(\"PARTYMGR\", \"_UPDATE\", loggedInUserLogin)) {\n            if (!userLoginId.equals(loggedInUserLogin.getString(\"userLoginId\"))) {\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.not_have_permission_update_password_for_user_login\", locale);\n                return ServiceUtil.returnError(errMsg);\n            }\n        } else {\n            adminUser = true;\n        }\n\n        String currentPassword = (String) context.get(\"currentPassword\");\n        String newPassword = (String) context.get(\"newPassword\");\n        String newPasswordVerify = (String) context.get(\"newPasswordVerify\");\n        String passwordHint = (String) context.get(\"passwordHint\");\n\n        GenericValue userLoginToUpdate = null;\n\n        try {\n            userLoginToUpdate = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", userLoginId).queryOne();\n        } catch (GenericEntityException e) {\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_read_failure\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        if (userLoginToUpdate == null) {\n            // this may be a full external authenticator; first try authenticating\n            boolean authenticated = false;\n            try {\n                authenticated = AuthHelper.authenticate(userLoginId, currentPassword, true);\n            } catch (AuthenticatorException e) {\n                // safe to ignore this; but we'll log it just in case\n                Debug.logWarning(e, e.getMessage(), module);\n            }\n\n            // call update password if auth passed\n            if (authenticated) {\n                try {\n                    AuthHelper.updatePassword(userLoginId, currentPassword, newPassword);\n                } catch (AuthenticatorException e) {\n                    Debug.logError(e, e.getMessage(), module);\n                    Map<String, String> messageMap = UtilMisc.toMap(\"userLoginId\", userLoginId);\n                    errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_userlogin_with_id_not_exist\", messageMap, locale);\n                    return ServiceUtil.returnError(errMsg);\n                }\n                //result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                result.put(\"updatedUserLogin\", null);\n                return result;\n            }\n            Map<String, String> messageMap = UtilMisc.toMap(\"userLoginId\", userLoginId);\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_userlogin_with_id_not_exist\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.lowercase\", delegator))) {\n            currentPassword = currentPassword.toLowerCase(Locale.getDefault());\n            newPassword = newPassword.toLowerCase(Locale.getDefault());\n            newPasswordVerify = newPasswordVerify.toLowerCase(Locale.getDefault());\n        }\n\n        List<String> errorMessageList = new LinkedList<>();\n        if (newPassword != null) {\n            checkNewPassword(userLoginToUpdate, currentPassword, newPassword, newPasswordVerify,\n                passwordHint, errorMessageList, adminUser, locale);\n        }\n\n        if (errorMessageList.size() > 0) {\n            return ServiceUtil.returnError(errorMessageList);\n        }\n\n        String externalAuthId = userLoginToUpdate.getString(\"externalAuthId\");\n        if (UtilValidate.isNotEmpty(externalAuthId)) {\n            // external auth is set; don't update the database record\n            try {\n                AuthHelper.updatePassword(externalAuthId, currentPassword, newPassword);\n            } catch (AuthenticatorException e) {\n                Debug.logError(e, e.getMessage(), module);\n                Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_write_failure\", messageMap, locale);\n                return ServiceUtil.returnError(errMsg);\n            }\n        } else {\n            userLoginToUpdate.set(\"currentPassword\", useEncryption ? HashCrypt.cryptUTF8(getHashType(), null, newPassword) : newPassword, false);\n            userLoginToUpdate.set(\"passwordHint\", passwordHint, false);\n            userLoginToUpdate.set(\"requirePasswordChange\", \"N\");\n\n            try {\n                userLoginToUpdate.store();\n                createUserLoginPasswordHistory(userLoginToUpdate);\n            } catch (GenericEntityException e) {\n                Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_write_failure\", messageMap, locale);\n                return ServiceUtil.returnError(errMsg);\n            }\n        }\n\n        result.put(\"updatedUserLogin\", userLoginToUpdate);\n        return result;\n    }\n\n    /** Updates the UserLoginId for a party, replicating password, etc from\n     *    current login and expiring the old login.\n     *@param ctx The DispatchContext that this service is operating in\n     *@param context Map containing the input parameters\n     *@return Map with the result of the service, the output parameters\n     */\n    public static Map<String, Object> updateUserLoginId(DispatchContext ctx, Map<String, ?> context) {\n        Map<String, Object> result =  new LinkedHashMap<>();\n        Delegator delegator = ctx.getDelegator();\n        GenericValue loggedInUserLogin = (GenericValue) context.get(\"userLogin\");\n        List<String> errorMessageList = new LinkedList<>();\n        Locale locale = (Locale) context.get(\"locale\");\n\n        String userLoginId = (String) context.get(\"userLoginId\");\n        String errMsg = null;\n\n        if ((userLoginId != null) && (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"username.lowercase\", delegator)))) {\n            userLoginId = userLoginId.toLowerCase(Locale.getDefault());\n        }\n\n        String partyId = loggedInUserLogin.getString(\"partyId\");\n        String password = loggedInUserLogin.getString(\"currentPassword\");\n        String passwordHint = loggedInUserLogin.getString(\"passwordHint\");\n\n        // security: don't create a user login if the specified partyId (if not empty) already exists\n        // unless the logged in user has permission to do so (same partyId or PARTYMGR_CREATE)\n        if (UtilValidate.isNotEmpty(partyId)) {\n            if (!loggedInUserLogin.isEmpty()) {\n                // security check: userLogin partyId must equal partyId, or must have PARTYMGR_CREATE permission\n                if (!partyId.equals(loggedInUserLogin.getString(\"partyId\"))) {\n                    errMsg = UtilProperties.getMessage(resource,\"loginservices.party_with_party_id_exists_not_permission_create_user_login\", locale);\n                    errorMessageList.add(errMsg);\n                }\n            } else {\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.must_logged_in_have_permission_create_user_login_exists\", locale);\n                errorMessageList.add(errMsg);\n            }\n        }\n\n        GenericValue newUserLogin = null;\n        boolean doCreate = true;\n\n        // check to see if there's a matching login and use it if it's for the same party\n        try {\n            newUserLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", userLoginId).queryOne();\n        } catch (GenericEntityException e) {\n            Debug.logWarning(e, \"\", module);\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_read_failure\", messageMap, locale);\n            errorMessageList.add(errMsg);\n        }\n\n        if (newUserLogin != null) {\n            if (!newUserLogin.get(\"partyId\").equals(partyId)) {\n                Map<String, String> messageMap = UtilMisc.toMap(\"userLoginId\", userLoginId);\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_with_ID_exists\", messageMap, locale);\n                errorMessageList.add(errMsg);\n            } else {\n                doCreate = false;\n            }\n        } else {\n            newUserLogin = delegator.makeValue(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", userLoginId));\n        }\n\n        newUserLogin.set(\"passwordHint\", passwordHint);\n        newUserLogin.set(\"partyId\", partyId);\n        newUserLogin.set(\"currentPassword\", password);\n        newUserLogin.set(\"enabled\", \"Y\");\n        newUserLogin.set(\"disabledDateTime\", null);\n\n        if (errorMessageList.size() > 0) {\n            return ServiceUtil.returnError(errorMessageList);\n        }\n\n        try {\n            if (doCreate) {\n                newUserLogin.create();\n            } else {\n                newUserLogin.store();\n            }\n        } catch (GenericEntityException e) {\n            Debug.logWarning(e, \"\", module);\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_write_failure\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        // Deactivate 'old' UserLogin and do not set disabledDateTime here, otherwise the 'old' UserLogin would be reenabled by next login\n        loggedInUserLogin.set(\"enabled\", \"N\");\n        loggedInUserLogin.set(\"disabledDateTime\", null);\n\n        try {\n            loggedInUserLogin.store();\n        } catch (GenericEntityException e) {\n            Debug.logWarning(e, \"\", module);\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_disable_old_login_user_write_failure\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n        result.put(\"newUserLogin\", newUserLogin);\n        return result;\n    }\n\n    /** Updates UserLogin Security info\n     *@param ctx The DispatchContext that this service is operating in\n     *@param context Map containing the input parameters\n     *@return Map with the result of the service, the output parameters\n     */\n    public static Map<String, Object> updateUserLoginSecurity(DispatchContext ctx, Map<String, ?> context) {\n        Map<String, Object> result =  new LinkedHashMap<>();\n        Delegator delegator = ctx.getDelegator();\n        Security security = ctx.getSecurity();\n        GenericValue loggedInUserLogin = (GenericValue) context.get(\"userLogin\");\n        Locale locale = (Locale) context.get(\"locale\");\n\n        String userLoginId = (String) context.get(\"userLoginId\");\n        String errMsg = null;\n\n        if (UtilValidate.isEmpty(userLoginId)) {\n            userLoginId = loggedInUserLogin.getString(\"userLoginId\");\n        }\n\n        // <b>security check</b>: must have PARTYMGR_UPDATE permission\n        if (!security.hasEntityPermission(\"PARTYMGR\", \"_UPDATE\", loggedInUserLogin) && !security.hasEntityPermission(\"SECURITY\", \"_UPDATE\", loggedInUserLogin)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.not_permission_update_security_info_for_user_login\", locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        GenericValue userLoginToUpdate = null;\n\n        try {\n            userLoginToUpdate = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", userLoginId).queryOne();\n        } catch (GenericEntityException e) {\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_read_failure\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        if (userLoginToUpdate == null) {\n            Map<String, String> messageMap = UtilMisc.toMap(\"userLoginId\", userLoginId);\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_userlogin_with_id_not_exist\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        boolean wasEnabled = !\"N\".equals(userLoginToUpdate.get(\"enabled\"));\n\n        if (context.containsKey(\"enabled\")) {\n            userLoginToUpdate.set(\"enabled\", context.get(\"enabled\"), true);\n        }\n        if (context.containsKey(\"disabledDateTime\")) {\n            userLoginToUpdate.set(\"disabledDateTime\", context.get(\"disabledDateTime\"), true);\n        }\n        if (context.containsKey(\"successiveFailedLogins\")) {\n            userLoginToUpdate.set(\"successiveFailedLogins\", context.get(\"successiveFailedLogins\"), true);\n        }\n        if (context.containsKey(\"externalAuthId\")) {\n            userLoginToUpdate.set(\"externalAuthId\", context.get(\"externalAuthId\"), true);\n        }\n        if (context.containsKey(\"userLdapDn\")) {\n            userLoginToUpdate.set(\"userLdapDn\", context.get(\"userLdapDn\"), true);\n        }\n        if (context.containsKey(\"requirePasswordChange\")) {\n            userLoginToUpdate.set(\"requirePasswordChange\", context.get(\"requirePasswordChange\"), true);\n        }\n\n        // if was disabled and we are enabling it, clear disabledDateTime\n        if (!wasEnabled && \"Y\".equals(context.get(\"enabled\"))) {\n            userLoginToUpdate.set(\"disabledDateTime\", null);\n            userLoginToUpdate.set(\"disabledBy\", null);\n        }\n\n        if (\"N\".equals(context.get(\"enabled\"))) {\n            userLoginToUpdate.set(\"disabledBy\", loggedInUserLogin.getString(\"userLoginId\"));\n        }\n\n        try {\n            userLoginToUpdate.store();\n        } catch (GenericEntityException e) {\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_write_failure\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n        return result;\n    }\n\n    public static void checkNewPassword(GenericValue userLogin, String currentPassword, String newPassword, String newPasswordVerify, String passwordHint, List<String> errorMessageList, boolean ignoreCurrentPassword, Locale locale) {\n        Delegator delegator = userLogin.getDelegator();\n        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));\n\n        String errMsg = null;\n\n        if (!ignoreCurrentPassword) {\n            // if the password.accept.encrypted.and.plain property in security is set to true allow plain or encrypted passwords\n            // if this is a system account don't bother checking the passwords\n            boolean passwordMatches = checkPassword(userLogin.getString(\"currentPassword\"), useEncryption, currentPassword);\n            if ((currentPassword == null) || (!passwordMatches)) {\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.old_password_not_correct_reenter\", locale);\n                errorMessageList.add(errMsg);\n            }\n            if (checkPassword(userLogin.getString(\"currentPassword\"), useEncryption, newPassword)) {\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.new_password_is_equal_to_old_password\", locale);\n                errorMessageList.add(errMsg);\n            }\n\n        }\n\n        if (UtilValidate.isEmpty(newPassword) || UtilValidate.isEmpty(newPasswordVerify)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_or_verify_missing\", locale);\n            errorMessageList.add(errMsg);\n        } else if (!newPassword.equals(newPasswordVerify)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_did_not_match_verify_password\", locale);\n            errorMessageList.add(errMsg);\n        }\n\n        int passwordChangeHistoryLimit = 0;\n        try {\n            passwordChangeHistoryLimit = EntityUtilProperties.getPropertyAsInteger(\"security\", \"password.change.history.limit\", 0).intValue();\n        } catch (NumberFormatException nfe) {\n            //No valid value is found so don't bother to save any password history\n            passwordChangeHistoryLimit = 0;\n        }\n        Debug.logInfo(\" password.change.history.limit is set to \" + passwordChangeHistoryLimit, module);\n        if (passwordChangeHistoryLimit > 0) {\n            Debug.logInfo(\" checkNewPassword Checking if user is tyring to use old password \" + passwordChangeHistoryLimit, module);\n            try {\n                List<GenericValue> pwdHistList = EntityQuery.use(delegator)\n                                                            .from(\"UserLoginPasswordHistory\")\n                                                            .where(\"userLoginId\",userLogin.getString(\"userLoginId\"))\n                                                            .orderBy(\"-fromDate\")\n                                                            .queryList();\n                for (GenericValue pwdHistValue : pwdHistList) {\n                    if (checkPassword(pwdHistValue.getString(\"currentPassword\"), useEncryption, newPassword)) {\n                        Map<String, Integer> messageMap = UtilMisc.toMap(\"passwordChangeHistoryLimit\", passwordChangeHistoryLimit);\n                        errMsg = UtilProperties.getMessage(resource,\"loginservices.password_must_be_different_from_last_passwords\", messageMap, locale);\n                        errorMessageList.add(errMsg);\n                        break;\n                    }\n                }\n            } catch (GenericEntityException e) {\n                Debug.logWarning(e, \"\", module);\n                Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n                errMsg = UtilProperties.getMessage(resource,\"loginevents.error_accessing_password_change_history\", messageMap, locale);\n            }\n\n        }\n\n        int minPasswordLength = 0;\n\n        try {\n            minPasswordLength = EntityUtilProperties.getPropertyAsInteger(\"security\", \"password.length.min\", 0).intValue();\n        } catch (NumberFormatException nfe) {\n            minPasswordLength = 0;\n        }\n\n        if (newPassword != null) {\n            // Matching password with pattern\n            String passwordPattern = EntityUtilProperties.getPropertyValue(\"security\", \"security.login.password.pattern\", \"^.*(?=.{5,}).*$\", delegator);\n            boolean usePasswordPattern = UtilProperties.getPropertyAsBoolean(\"security\", \"security.login.password.pattern.enable\", true);\n            if (usePasswordPattern) {\n                Pattern pattern = Pattern.compile(passwordPattern);\n                Matcher matcher = pattern.matcher(newPassword);\n                boolean matched = matcher.matches();\n                if (!matched) {\n                    // This is a mix to handle the OOTB pattern which is only a fixed length\n                    Map<String, String> messageMap = UtilMisc.toMap(\"minPasswordLength\", Integer.toString(minPasswordLength));\n                    String passwordPatternMessage = EntityUtilProperties.getPropertyValue(\"security\",\n                            \"security.login.password.pattern.description\", \"loginservices.password_must_be_least_characters_long\", delegator);\n                    errMsg = UtilProperties.getMessage(resource, passwordPatternMessage, messageMap, locale);\n                    errorMessageList.add(errMsg);\n                }\n            } else {\n                if (!(newPassword.length() >= minPasswordLength)) {\n                    Map<String, String> messageMap = UtilMisc.toMap(\"minPasswordLength\", Integer.toString(minPasswordLength));\n                    errMsg = UtilProperties.getMessage(resource,\"loginservices.password_must_be_least_characters_long\", messageMap, locale);\n                    errorMessageList.add(errMsg);\n                }\n            }\n            if (newPassword.equalsIgnoreCase(userLogin.getString(\"userLoginId\"))) {\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.password_may_not_equal_username\", locale);\n                errorMessageList.add(errMsg);\n            }\n            if (UtilValidate.isNotEmpty(passwordHint) && (passwordHint.toUpperCase(Locale.getDefault()).indexOf(newPassword.toUpperCase(Locale.getDefault())) >= 0)) {\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.password_hint_may_not_contain_password\", locale);\n                errorMessageList.add(errMsg);\n            }\n        }\n    }\n\n    public static String getHashType() {\n        String hashType = UtilProperties.getPropertyValue(\"security\", \"password.encrypt.hash.type\");\n\n        if (UtilValidate.isEmpty(hashType)) {\n            Debug.logWarning(\"Password encrypt hash type is not specified in security.properties, use SHA\", module);\n            hashType = \"SHA\";\n        }\n\n        return hashType;\n    }\n\n    public static boolean checkPassword(String oldPassword, boolean useEncryption, String currentPassword) {\n        boolean passwordMatches = false;\n        if (oldPassword != null) {\n            if (useEncryption) {\n                passwordMatches = HashCrypt.comparePassword(oldPassword, getHashType(), currentPassword);\n            } else {\n                passwordMatches = oldPassword.equals(currentPassword);\n            }\n        }\n        if (!passwordMatches && \"true\".equals(UtilProperties.getPropertyValue(\"security\", \"password.accept.encrypted.and.plain\"))) {\n            passwordMatches = currentPassword.equals(oldPassword);\n        }\n        return passwordMatches;\n    }\n\n    private static boolean TomcatSSOLogin(HttpServletRequest request, String userName, String currentPassword) {\n        try {\n            request.login(userName, currentPassword);\n        } catch (ServletException e) {\n\n            StringManager sm = StringManager.getManager(\"org.apache.catalina.connector\");\n            if (sm.getString(\"coyoteRequest.alreadyAuthenticated\").equals(e.getMessage())){\n                return true;\n            } else {\n                Debug.logError(e, module);\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"], "fixing_code": ["/*******************************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *******************************************************************************/\n\npackage org.apache.ofbiz.common.login;\n\nimport java.sql.Timestamp;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.transaction.Transaction;\n\nimport org.apache.ofbiz.base.crypto.HashCrypt;\nimport org.apache.ofbiz.base.util.Debug;\nimport org.apache.ofbiz.base.util.UtilDateTime;\nimport org.apache.ofbiz.base.util.UtilMisc;\nimport org.apache.ofbiz.base.util.UtilProperties;\nimport org.apache.ofbiz.base.util.UtilValidate;\nimport org.apache.ofbiz.common.authentication.AuthHelper;\nimport org.apache.ofbiz.common.authentication.api.AuthenticatorException;\nimport org.apache.ofbiz.entity.Delegator;\nimport org.apache.ofbiz.entity.GenericEntityException;\nimport org.apache.ofbiz.entity.GenericValue;\nimport org.apache.ofbiz.entity.condition.EntityCondition;\nimport org.apache.ofbiz.entity.condition.EntityFunction;\nimport org.apache.ofbiz.entity.condition.EntityOperator;\nimport org.apache.ofbiz.entity.model.ModelEntity;\nimport org.apache.ofbiz.entity.model.ModelField;\nimport org.apache.ofbiz.entity.transaction.GenericTransactionException;\nimport org.apache.ofbiz.entity.transaction.TransactionUtil;\nimport org.apache.ofbiz.entity.util.EntityListIterator;\nimport org.apache.ofbiz.entity.util.EntityQuery;\nimport org.apache.ofbiz.entity.util.EntityUtilProperties;\nimport org.apache.ofbiz.security.Security;\nimport org.apache.ofbiz.service.DispatchContext;\nimport org.apache.ofbiz.service.GenericServiceException;\nimport org.apache.ofbiz.service.LocalDispatcher;\nimport org.apache.ofbiz.service.ModelService;\nimport org.apache.ofbiz.service.ServiceUtil;\nimport org.apache.ofbiz.webapp.control.LoginWorker;\n\nimport org.apache.tomcat.util.res.StringManager;\n\n/**\n * <b>Title:</b> Login Services\n */\npublic class LoginServices {\n\n    public static final String module = LoginServices.class.getName();\n    public static final String resource = \"SecurityextUiLabels\";\n\n    /** Login service to authenticate username and password\n     * @return Map of results including (userLogin) GenericValue object\n     */\n    public static Map<String, Object> userLogin(DispatchContext ctx, Map<String, ?> context) {\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        Locale locale = (Locale) context.get(\"locale\");\n        Delegator delegator = ctx.getDelegator();\n\n        // load the external auth modules -- note: this will only run once and cache the objects\n        if (!AuthHelper.authenticatorsLoaded()) {\n            AuthHelper.loadAuthenticators(dispatcher);\n        }\n\n        // Authenticate to LDAP if configured to do so\n        // TODO: this should be moved to using the NEW Authenticator API\n        if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.enable\", delegator))) {\n            if (!LdapAuthenticationServices.userLogin(ctx, context)) {\n                String errMsg = UtilProperties.getMessage(resource, \"loginservices.ldap_authentication_failed\", locale);\n                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"security.ldap.fail.login\", delegator))) {\n                    return ServiceUtil.returnError(errMsg);\n                }\n                Debug.logInfo(errMsg, module);\n            }\n        }\n\n        Map<String, Object> result =  new LinkedHashMap<>();\n        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));\n\n        // if isServiceAuth is not specified, default to not a service auth\n        boolean isServiceAuth = context.get(\"isServiceAuth\") != null && ((Boolean) context.get(\"isServiceAuth\")).booleanValue();\n\n        String username = (String) context.get(\"login.username\");\n        if (username == null) {\n            username = (String) context.get(\"username\");\n        }\n        String password = (String) context.get(\"login.password\");\n        if (password == null) {\n            password = (String) context.get(\"password\");\n        }\n\n        // get the visitId for the history entity\n        String visitId = (String) context.get(\"visitId\");\n\n        String errMsg = \"\";\n        if (UtilValidate.isEmpty(username)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.username_missing\", locale);\n        } else if (UtilValidate.isEmpty(password)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_missing\", locale);\n        } else {\n\n            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"username.lowercase\", delegator))) {\n                username = username.toLowerCase(Locale.getDefault());\n            }\n            if (\"true\".equalsIgnoreCase(EntityUtilProperties.getPropertyValue(\"security\", \"password.lowercase\", delegator))) {\n                password = password.toLowerCase(Locale.getDefault());\n            }\n\n            boolean repeat = true;\n            // starts at zero but it incremented at the beginning so in the first pass passNumber will be 1\n            int passNumber = 0;\n\n            while (repeat) {\n                repeat = false;\n                // pass number is incremented here because there are continues in this loop so it may never get to the end\n                passNumber++;\n\n                GenericValue userLogin = null;\n\n                try {\n                    // only get userLogin from cache for service calls; for web and other manual logins there is less time sensitivity\n                    userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();\n                } catch (GenericEntityException e) {\n                    Debug.logWarning(e, \"\", module);\n                }\n\n\n                // see if any external auth modules want to sync the user info\n                if (userLogin == null) {\n                    try {\n                        AuthHelper.syncUser(username);\n                    } catch (AuthenticatorException e) {\n                        Debug.logWarning(e, module);\n                    }\n\n                    // check the user login object again\n                    try {\n                        userLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", username).cache(isServiceAuth).queryOne();\n                    } catch (GenericEntityException e) {\n                        Debug.logWarning(e, \"\", module);\n                    }\n                }\n\n                if (userLogin != null) {\n                    String ldmStr = EntityUtilProperties.getPropertyValue(\"security\", \"login.disable.minutes\", delegator);\n                    long loginDisableMinutes;\n\n                    try {\n                        loginDisableMinutes = Long.parseLong(ldmStr);\n                    } catch (Exception e) {\n                        loginDisableMinutes = 30;\n                        Debug.logWarning(\"Could not parse login.disable.minutes from security.properties, using default of 30\", module);\n                    }\n\n                    Timestamp disabledDateTime = userLogin.getTimestamp(\"disabledDateTime\");\n                    Timestamp reEnableTime = null;\n\n                    if (loginDisableMinutes > 0 && disabledDateTime != null) {\n                        reEnableTime = new Timestamp(disabledDateTime.getTime() + loginDisableMinutes * 60000);\n                    }\n\n                    boolean doStore = true;\n                    // we might change & store this userLogin, so we should clone it here to get a mutable copy\n                    userLogin = GenericValue.create(userLogin);\n\n                    // get the is system flag -- system accounts can only be used for service authentication\n                    boolean isSystem = (isServiceAuth && userLogin.get(\"isSystem\") != null) ?\n                            \"Y\".equalsIgnoreCase(userLogin.getString(\"isSystem\")) : false;\n\n                    // grab the hasLoggedOut flag\n                    Boolean hasLoggedOut = userLogin.getBoolean(\"hasLoggedOut\");\n\n                    if ((UtilValidate.isEmpty(userLogin.getString(\"enabled\")) || \"Y\".equals(userLogin.getString(\"enabled\")) ||\n                            (reEnableTime != null && reEnableTime.before(UtilDateTime.nowTimestamp())) || (isSystem)) && UtilValidate.isEmpty(userLogin.getString(\"disabledBy\"))) {\n\n                        String successfulLogin;\n\n                        if (!isSystem) {\n                            userLogin.set(\"enabled\", \"Y\");\n                            userLogin.set(\"disabledBy\", null);\n                        }\n\n                        // attempt to authenticate with Authenticator class(es)\n                        boolean authFatalError = false;\n                        boolean externalAuth = false;\n                        try {\n                            externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);\n                        } catch (AuthenticatorException e) {\n                            // fatal error -- or single authenticator found -- fail now\n                            Debug.logWarning(e, module);\n                            authFatalError = true;\n\n                        }\n\n                        // check whether to sign in with Tomcat SSO\n                        boolean useTomcatSSO = EntityUtilProperties.propertyValueEquals(\"security\", \"security.login.tomcat.sso\", \"true\");\n                        HttpServletRequest request = (javax.servlet.http.HttpServletRequest) context.get(\"request\");\n                        // when request is not supplied, we will treat that SSO is not required as\n                        // in the usage of userLogin service in ICalWorker.java and XmlRpcEventHandler.java.\n                        useTomcatSSO = useTomcatSSO && (request!=null);\n\n                        // if the password.accept.encrypted.and.plain property in security is set to true allow plain or encrypted passwords\n                        // if this is a system account don't bother checking the passwords\n                        // if externalAuth passed; this is run as well\n                        if ((!authFatalError && externalAuth) || (useTomcatSSO ? TomcatSSOLogin(request, username, password) : checkPassword(userLogin.getString(\"currentPassword\"), useEncryption, password) )) {\n                            Debug.logVerbose(\"[LoginServices.userLogin] : Password Matched\", module);\n\n                            // update the hasLoggedOut flag\n                            if (hasLoggedOut == null || hasLoggedOut) {\n                                userLogin.set(\"hasLoggedOut\", \"N\");\n                            }\n\n                            // reset failed login count if necessry\n                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");\n                            if (currentFailedLogins != null && currentFailedLogins.longValue() > 0) {\n                                userLogin.set(\"successiveFailedLogins\", Long.valueOf(0));\n                            } else if (hasLoggedOut != null && !hasLoggedOut) {\n                                // successful login & no loggout flag, no need to change anything, so don't do the store\n                                doStore = false;\n                            }\n\n                            successfulLogin = \"Y\";\n\n                            if (!isServiceAuth) {\n                                // get the UserLoginSession if this is not a service auth\n                                Map<?, ?> userLoginSessionMap = LoginWorker.getUserLoginSession(userLogin);\n\n                                // return the UserLoginSession Map\n                                if (userLoginSessionMap != null) {\n                                    result.put(\"userLoginSession\", userLoginSessionMap);\n                                }\n                            }\n\n                            result.put(\"userLogin\", userLogin);\n                            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                        } else {\n                            // password is incorrect, but this may be the result of a stale cache entry,\n                            // so lets clear the cache and try again if this is the first pass\n                            // but only if authFatalError is not true; this would mean the single authenticator failed\n                            if (!authFatalError && isServiceAuth && passNumber <= 1) {\n                                delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));\n                                repeat = true;\n                                continue;\n                            }\n\n                            Debug.logInfo(\"[LoginServices.userLogin] : Password Incorrect\", module);\n                            // password invalid...\n                            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_incorrect\", locale);\n\n                            // increment failed login count\n                            Long currentFailedLogins = userLogin.getLong(\"successiveFailedLogins\");\n\n                            if (currentFailedLogins == null) {\n                                currentFailedLogins = Long.valueOf(1);\n                            } else {\n                                currentFailedLogins = Long.valueOf(currentFailedLogins.longValue() + 1);\n                            }\n                            userLogin.set(\"successiveFailedLogins\", currentFailedLogins);\n\n                            // if failed logins over amount in properties file, disable account\n                            String mflStr = EntityUtilProperties.getPropertyValue(\"security\", \"max.failed.logins\", delegator);\n                            long maxFailedLogins = 3;\n                            try {\n                                maxFailedLogins = Long.parseLong(mflStr);\n                            } catch (Exception e) {\n                                maxFailedLogins = 3;\n                                Debug.logWarning(\"Could not parse max.failed.logins from security.properties, using default of 3\", module);\n                            }\n\n                            if (maxFailedLogins > 0 && currentFailedLogins.longValue() >= maxFailedLogins) {\n                                userLogin.set(\"enabled\", \"N\");\n                                userLogin.set(\"disabledDateTime\", UtilDateTime.nowTimestamp());\n                            }\n\n                            successfulLogin = \"N\";\n                        }\n\n                        // this section is being done in its own transaction rather than in the\n                        //current/existing transaction because we may return error and we don't\n                        //want that to stop this from getting stored\n                        Transaction parentTx = null;\n                        boolean beganTransaction = false;\n\n                        try {\n                            try {\n                                parentTx = TransactionUtil.suspend();\n                            } catch (GenericTransactionException e) {\n                                Debug.logError(e, \"Could not suspend transaction: \" + e.getMessage(), module);\n                            }\n\n                            try {\n                                beganTransaction = TransactionUtil.begin();\n\n                                if (doStore) {\n                                    userLogin.store();\n                                }\n\n                                if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history\", delegator))) {\n                                    boolean createHistory = true;\n\n                                    // only save info on service auth if option set to true to do so\n                                    if (isServiceAuth && !\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"store.login.history.on.service.auth\", delegator))) {\n                                        createHistory = false;\n                                    }\n\n                                    if (createHistory) {\n                                        Map<String, Object> ulhCreateMap = UtilMisc.toMap(\"userLoginId\", username, \"visitId\", visitId,\n                                                \"fromDate\", UtilDateTime.nowTimestamp(), \"successfulLogin\", successfulLogin);\n\n                                        ModelEntity modelUserLogin = userLogin.getModelEntity();\n                                        if (modelUserLogin.isField(\"partyId\")) {\n                                            ulhCreateMap.put(\"partyId\", userLogin.get(\"partyId\"));\n                                        }\n\n                                        // ONLY save the password if it was incorrect\n                                        // we will check in the hash size isn't too huge for the store other wise store a fix string\n                                        if (\"N\".equals(successfulLogin) && !\"false\".equals(EntityUtilProperties.getPropertyValue(\"security\",\n                                                \"store.login.history.incorrect.password\", delegator))) {\n                                            ulhCreateMap.put(\"passwordUsed\", isGivenPasswordCanBeStored(delegator, password)\n                                                    ? \" TOO LONG FOR STORAGE \"\n                                                    : password);\n                                        }\n\n                                        delegator.create(\"UserLoginHistory\", ulhCreateMap);\n                                    }\n                                }\n                            } catch (GenericEntityException e) {\n                                String geeErrMsg = \"Error saving UserLoginHistory\";\n                                if (doStore) {\n                                    geeErrMsg += \" and updating login status to reset hasLoggedOut, unsuccessful login count, etc.\";\n                                }\n                                try {\n                                    TransactionUtil.rollback(beganTransaction, geeErrMsg, e);\n                                } catch (GenericTransactionException e2) {\n                                    Debug.logError(e2, \"Could not rollback nested transaction: \" + e2.getMessage(), module);\n                                }\n\n                                // if doStore is true then this error should not be ignored and we shouldn't consider it a successful login if this happens as there is something very wrong lower down that will bite us again later\n                                if (doStore) {\n                                    return ServiceUtil.returnError(geeErrMsg);\n                                }\n                            } finally {\n                                try {\n                                    TransactionUtil.commit(beganTransaction);\n                                } catch (GenericTransactionException e) {\n                                    Debug.logError(e, \"Could not commit nested transaction: \" + e.getMessage(), module);\n                                }\n                            }\n                        } finally {\n                            // resume/restore parent transaction\n                            if (parentTx != null) {\n                                try {\n                                    TransactionUtil.resume(parentTx);\n                                    Debug.logVerbose(\"Resumed the parent transaction.\", module);\n                                } catch (GenericTransactionException e) {\n                                    Debug.logError(e, \"Could not resume parent nested transaction: \" + e.getMessage(), module);\n                                }\n                            }\n                        }\n                    } else {\n                        // account is disabled, but this may be the result of a stale cache entry,\n                        // so lets clear the cache and try again if this is the first pass\n                        if (isServiceAuth && passNumber <= 1) {\n                            delegator.clearCacheLine(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", username));\n                            repeat = true;\n                            continue;\n                        }\n\n                        Map<String, Object> messageMap = UtilMisc.<String, Object>toMap(\"username\", username);\n                        errMsg = UtilProperties.getMessage(resource,\"loginservices.account_for_user_login_id_disabled\",messageMap ,locale);\n                        if (disabledDateTime != null) {\n                            messageMap = UtilMisc.<String, Object>toMap(\"disabledDateTime\", disabledDateTime);\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.since_datetime\",messageMap ,locale);\n                        } else {\n                            errMsg += \".\";\n                        }\n\n                        if (loginDisableMinutes > 0 && reEnableTime != null) {\n                            messageMap = UtilMisc.<String, Object>toMap(\"reEnableTime\", reEnableTime);\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.will_be_reenabled\",messageMap ,locale);\n                        } else {\n                            errMsg += \" \" + UtilProperties.getMessage(resource,\"loginservices.not_scheduled_to_be_reenabled\",locale);\n                        }\n                    }\n                } else {\n                    // no userLogin object; there may be a non-syncing authenticator\n                    boolean externalAuth = false;\n                    try {\n                        externalAuth = AuthHelper.authenticate(username, password, isServiceAuth);\n                    } catch (AuthenticatorException e) {\n                        errMsg = e.getMessage();\n                        Debug.logError(e, \"External Authenticator had fatal exception : \" + e.getMessage(), module);\n                    }\n                    if (externalAuth) {\n                        // external auth passed - create a placeholder object for session\n                        userLogin = delegator.makeValue(\"UserLogin\");\n                        userLogin.set(\"userLoginId\", username);\n                        userLogin.set(\"enabled\", \"Y\");\n                        userLogin.set(\"hasLoggedOut\", \"N\");\n                        result.put(\"userLogin\", userLogin);\n                        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                        //TODO: more than this is needed to support 100% external authentication\n                        //TODO: party + security information is needed; Userlogin will need to be stored\n                    } else {\n                        // userLogin record not found, user does not exist\n                        errMsg = UtilProperties.getMessage(resource, \"loginservices.user_not_found\", locale);\n                        Debug.logInfo(\"[LoginServices.userLogin] Invalid User : '\" + username + \"'; \" + errMsg, module);\n                    }\n                }\n            }\n        }\n\n        if (errMsg.length() > 0) {\n            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_FAIL);\n            result.put(ModelService.ERROR_MESSAGE, errMsg);\n        }\n        return result;\n    }\n\n    /**\n     * To escape an exception when the password store due to limitation size for passwordUsed field, we analyse if it's possible.\n     * @param delegator\n     * @param password\n     * @return\n     * @throws GenericEntityException\n     */\n    private static boolean isGivenPasswordCanBeStored(Delegator delegator, String password)\n            throws GenericEntityException {\n        ModelEntity modelEntityUserLoginHistory = delegator.getModelEntity(\"UserLoginHistory\");\n        ModelField passwordUsedField = modelEntityUserLoginHistory.getField(\"passwordUsed\");\n        int maxPasswordSize = delegator.getEntityFieldType(\n                modelEntityUserLoginHistory,\n                passwordUsedField.getType()).stringLength();\n        int passwordUsedCurrentSize = password.length();\n\n        // if the field is encrypted, we check the size of the hashed result\n        ModelField.EncryptMethod encryptMethod = passwordUsedField.getEncryptMethod();\n        if (encryptMethod.isEncrypted()) {\n            passwordUsedCurrentSize = delegator.encryptFieldValue(\"UserLoginHistory\", encryptMethod, password).toString().length();\n        }\n        return passwordUsedCurrentSize > maxPasswordSize;\n    }\n\n    public static void createUserLoginPasswordHistory(GenericValue userLogin) throws GenericEntityException{\n        int passwordChangeHistoryLimit = 0;\n        Delegator delegator = userLogin.getDelegator();\n        String userLoginId = userLogin.getString(\"userLoginId\");\n        String currentPassword = userLogin.getString(\"currentPassword\");\n        try {\n            passwordChangeHistoryLimit = EntityUtilProperties.getPropertyAsInteger(\"security\", \"password.change.history.limit\", 0).intValue();\n        } catch (NumberFormatException nfe) {\n            //No valid value is found so don't bother to save any password history\n            passwordChangeHistoryLimit = 0;\n        }\n        if (passwordChangeHistoryLimit == 0 || passwordChangeHistoryLimit < 0) {\n            // Not saving password history, so return from here.\n            return;\n        }\n        EntityQuery eq = EntityQuery.use(delegator)\n                .from(\"UserLoginPasswordHistory\")\n                .where(\"userLoginId\", userLoginId)\n                .orderBy(\"-fromDate\")\n                .cursorScrollInsensitive();\n        Timestamp nowTimestamp = UtilDateTime.nowTimestamp();\n        \n        try (EntityListIterator eli = eq.queryIterator()) {\n            GenericValue pwdHist;\n            if ((pwdHist = eli.next()) != null) {\n                // updating password so set end date on previous password in history\n                pwdHist.set(\"thruDate\", nowTimestamp);\n                pwdHist.store();\n                // check if we have hit the limit on number of password changes to be saved. If we did then delete the oldest password from history.\n                eli.last();\n                int rowIndex = eli.currentIndex();\n                if (rowIndex==passwordChangeHistoryLimit) {\n                    eli.afterLast();\n                    pwdHist = eli.previous();\n                    pwdHist.remove();\n                }\n            }\n        }\n\n        // save this password in history\n        GenericValue userLoginPwdHistToCreate = delegator.makeValue(\"UserLoginPasswordHistory\", UtilMisc.toMap(\"userLoginId\", userLoginId,\"fromDate\", nowTimestamp));\n        userLoginPwdHistToCreate.set(\"currentPassword\", currentPassword);\n        userLoginPwdHistToCreate.create();\n    }\n\n    /** Creates a UserLogin\n     *@param ctx The DispatchContext that this service is operating in\n     *@param context Map containing the input parameters\n     *@return Map with the result of the service, the output parameters\n     */\n    public static Map<String, Object> createUserLogin(DispatchContext ctx, Map<String, ?> context) {\n        Map<String, Object> result =  new LinkedHashMap<>();\n        Delegator delegator = ctx.getDelegator();\n        LocalDispatcher dispatcher = ctx.getDispatcher();\n        Security security = ctx.getSecurity();\n        GenericValue loggedInUserLogin = (GenericValue) context.get(\"userLogin\");\n        List<String> errorMessageList = new LinkedList<>();\n        Locale locale = (Locale) context.get(\"locale\");\n\n        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));\n\n        String userLoginId = (String) context.get(\"userLoginId\");\n        String partyId = (String) context.get(\"partyId\");\n        String currentPassword = (String) context.get(\"currentPassword\");\n        String currentPasswordVerify = (String) context.get(\"currentPasswordVerify\");\n        String enabled = (String) context.get(\"enabled\");\n        String passwordHint = (String) context.get(\"passwordHint\");\n        String requirePasswordChange = (String) context.get(\"requirePasswordChange\");\n        String externalAuthId = (String) context.get(\"externalAuthId\");\n        String errMsg = null;\n\n        String questionEnumId = (String) context.get(\"securityQuestion\");\n        String securityAnswer = (String) context.get(\"securityAnswer\");\n        \n        // security: don't create a user login if the specified partyId (if not empty) already exists\n        // unless the logged in user has permission to do so (same partyId or PARTYMGR_CREATE)\n        if (UtilValidate.isNotEmpty(partyId)) {\n            GenericValue party = null;\n\n            try {\n                party = EntityQuery.use(delegator).from(\"Party\").where(\"partyId\", partyId).queryOne();\n            } catch (GenericEntityException e) {\n                Debug.logWarning(e, \"\", module);\n            }\n\n            if (party != null) {\n                if (loggedInUserLogin != null) {\n                    // <b>security check</b>: userLogin partyId must equal partyId, or must have PARTYMGR_CREATE permission\n                    if (!partyId.equals(loggedInUserLogin.getString(\"partyId\"))) {\n                        if (!security.hasEntityPermission(\"PARTYMGR\", \"_CREATE\", loggedInUserLogin)) {\n\n                            errMsg = UtilProperties.getMessage(resource,\"loginservices.party_with_specified_party_ID_exists_not_have_permission\", locale);\n                            errorMessageList.add(errMsg);\n                        }\n                    }\n                } else {\n                    errMsg = UtilProperties.getMessage(resource,\"loginservices.must_be_logged_in_and_permission_create_login_party_ID_exists\", locale);\n                    errorMessageList.add(errMsg);\n                }\n            }\n        }\n\n        GenericValue userLoginToCreate = delegator.makeValue(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", userLoginId));\n        checkNewPassword(userLoginToCreate, null, currentPassword, currentPasswordVerify, passwordHint, errorMessageList, true, locale);\n        userLoginToCreate.set(\"externalAuthId\", externalAuthId);\n        userLoginToCreate.set(\"passwordHint\", passwordHint);\n        userLoginToCreate.set(\"enabled\", enabled);\n        userLoginToCreate.set(\"requirePasswordChange\", requirePasswordChange);\n        userLoginToCreate.set(\"currentPassword\", useEncryption ? HashCrypt.cryptUTF8(getHashType(), null, currentPassword) : currentPassword);\n        try {\n            userLoginToCreate.set(\"partyId\", partyId);\n        } catch (Exception e) {\n            // Will get thrown in framework-only installation\n            Debug.logInfo(e, \"Exception thrown while setting UserLogin partyId field: \", module);\n        }\n\n        try {\n            EntityCondition condition = EntityCondition.makeCondition(EntityFunction.UPPER_FIELD(\"userLoginId\"), EntityOperator.EQUALS, EntityFunction.UPPER(userLoginId));\n            if (UtilValidate.isNotEmpty(EntityQuery.use(delegator).from(\"UserLogin\").where(condition).queryList())) {\n                Map<String, String> messageMap = UtilMisc.toMap(\"userLoginId\", userLoginId);\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_with_ID_exists\", messageMap, locale);\n                errorMessageList.add(errMsg);\n            }\n        } catch (GenericEntityException e) {\n            Debug.logWarning(e, \"\", module);\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_read_failure\", messageMap, locale);\n            errorMessageList.add(errMsg);\n        }\n\n        if (errorMessageList.size() > 0) {\n            return ServiceUtil.returnError(errorMessageList);\n        }\n\n        try {\n            userLoginToCreate.create();\n            createUserLoginPasswordHistory(userLoginToCreate);\n        } catch (GenericEntityException e) {\n            Debug.logWarning(e, \"\", module);\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_write_failure\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        try {\n            if (UtilValidate.isNotEmpty(securityAnswer)) {\n                Map<String, Object> resultMap = dispatcher.runSync(\"createUserLoginSecurityQuestion\",\n                        UtilMisc.toMap(\"userLogin\", loggedInUserLogin, \"userLoginId\", userLoginId, \"questionEnumId\", questionEnumId, \"securityAnswer\", securityAnswer));\n                if (ServiceUtil.isError(resultMap)) {\n                    errMsg = ServiceUtil.getErrorMessage(resultMap);\n                    errorMessageList.add(errMsg);\n                    Debug.logError(errMsg, module);\n                }\n            }\n        } catch (GenericServiceException e1) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.error_setting_security_question\", locale);\n            Debug.logError(e1, errMsg, module);\n        }\n        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n        return result;\n    }\n\n    /** Updates UserLogin Password info\n     *@param ctx The DispatchContext that this service is operating in\n     *@param context Map containing the input parameters\n     *@return Map with the result of the service, the output parameters\n     */\n    public static Map<String, Object> updatePassword(DispatchContext ctx, Map<String, ?> context) {\n        Delegator delegator = ctx.getDelegator();\n        Security security = ctx.getSecurity();\n        GenericValue loggedInUserLogin = (GenericValue) context.get(\"userLogin\");\n        Locale locale = (Locale) context.get(\"locale\");\n        Map<String, Object> result = ServiceUtil.returnSuccess(UtilProperties.getMessage(resource, \"loginevents.password_was_changed_with_success\", locale));\n\n        // load the external auth modules -- note: this will only run once and cache the objects\n        if (!AuthHelper.authenticatorsLoaded()) {\n            AuthHelper.loadAuthenticators(ctx.getDispatcher());\n        }\n\n        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));\n        boolean adminUser = false;\n\n        String userLoginId = (String) context.get(\"userLoginId\");\n        String errMsg = null;\n\n        if (UtilValidate.isEmpty(userLoginId)) {\n            userLoginId = loggedInUserLogin.getString(\"userLoginId\");\n        }\n\n        // <b>security check</b>: userLogin userLoginId must equal userLoginId, or must have PARTYMGR_UPDATE permission\n        // NOTE: must check permission first so that admin users can set own password without specifying old password\n        // TODO: change this security group because we can't use permission groups defined in the applications from the framework.\n        if (!security.hasEntityPermission(\"PARTYMGR\", \"_UPDATE\", loggedInUserLogin)) {\n            if (!userLoginId.equals(loggedInUserLogin.getString(\"userLoginId\"))) {\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.not_have_permission_update_password_for_user_login\", locale);\n                return ServiceUtil.returnError(errMsg);\n            }\n        } else {\n            adminUser = true;\n        }\n\n        String currentPassword = (String) context.get(\"currentPassword\");\n        String newPassword = (String) context.get(\"newPassword\");\n        String newPasswordVerify = (String) context.get(\"newPasswordVerify\");\n        String passwordHint = (String) context.get(\"passwordHint\");\n\n        GenericValue userLoginToUpdate = null;\n\n        try {\n            userLoginToUpdate = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", userLoginId).queryOne();\n        } catch (GenericEntityException e) {\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_read_failure\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        if (userLoginToUpdate == null) {\n            // this may be a full external authenticator; first try authenticating\n            boolean authenticated = false;\n            try {\n                authenticated = AuthHelper.authenticate(userLoginId, currentPassword, true);\n            } catch (AuthenticatorException e) {\n                // safe to ignore this; but we'll log it just in case\n                Debug.logWarning(e, e.getMessage(), module);\n            }\n\n            // call update password if auth passed\n            if (authenticated) {\n                try {\n                    AuthHelper.updatePassword(userLoginId, currentPassword, newPassword);\n                } catch (AuthenticatorException e) {\n                    Debug.logError(e, e.getMessage(), module);\n                    Map<String, String> messageMap = UtilMisc.toMap(\"userLoginId\", userLoginId);\n                    errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_userlogin_with_id_not_exist\", messageMap, locale);\n                    return ServiceUtil.returnError(errMsg);\n                }\n                //result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n                result.put(\"updatedUserLogin\", null);\n                return result;\n            }\n            Map<String, String> messageMap = UtilMisc.toMap(\"userLoginId\", userLoginId);\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_userlogin_with_id_not_exist\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        if (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.lowercase\", delegator))) {\n            currentPassword = currentPassword.toLowerCase(Locale.getDefault());\n            newPassword = newPassword.toLowerCase(Locale.getDefault());\n            newPasswordVerify = newPasswordVerify.toLowerCase(Locale.getDefault());\n        }\n\n        List<String> errorMessageList = new LinkedList<>();\n        if (newPassword != null) {\n            checkNewPassword(userLoginToUpdate, currentPassword, newPassword, newPasswordVerify,\n                passwordHint, errorMessageList, adminUser, locale);\n        }\n\n        if (errorMessageList.size() > 0) {\n            return ServiceUtil.returnError(errorMessageList);\n        }\n\n        String externalAuthId = userLoginToUpdate.getString(\"externalAuthId\");\n        if (UtilValidate.isNotEmpty(externalAuthId)) {\n            // external auth is set; don't update the database record\n            try {\n                AuthHelper.updatePassword(externalAuthId, currentPassword, newPassword);\n            } catch (AuthenticatorException e) {\n                Debug.logError(e, e.getMessage(), module);\n                Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_write_failure\", messageMap, locale);\n                return ServiceUtil.returnError(errMsg);\n            }\n        } else {\n            userLoginToUpdate.set(\"currentPassword\", useEncryption ? HashCrypt.cryptUTF8(getHashType(), null, newPassword) : newPassword, false);\n            userLoginToUpdate.set(\"passwordHint\", passwordHint, false);\n            userLoginToUpdate.set(\"requirePasswordChange\", \"N\");\n\n            try {\n                userLoginToUpdate.store();\n                createUserLoginPasswordHistory(userLoginToUpdate);\n            } catch (GenericEntityException e) {\n                Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_write_failure\", messageMap, locale);\n                return ServiceUtil.returnError(errMsg);\n            }\n        }\n\n        result.put(\"updatedUserLogin\", userLoginToUpdate);\n        return result;\n    }\n\n    /** Updates the UserLoginId for a party, replicating password, etc from\n     *    current login and expiring the old login.\n     *@param ctx The DispatchContext that this service is operating in\n     *@param context Map containing the input parameters\n     *@return Map with the result of the service, the output parameters\n     */\n    public static Map<String, Object> updateUserLoginId(DispatchContext ctx, Map<String, ?> context) {\n        Map<String, Object> result =  new LinkedHashMap<>();\n        Delegator delegator = ctx.getDelegator();\n        GenericValue loggedInUserLogin = (GenericValue) context.get(\"userLogin\");\n        List<String> errorMessageList = new LinkedList<>();\n        Locale locale = (Locale) context.get(\"locale\");\n\n        String userLoginId = (String) context.get(\"userLoginId\");\n        String errMsg = null;\n\n        if ((userLoginId != null) && (\"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"username.lowercase\", delegator)))) {\n            userLoginId = userLoginId.toLowerCase(Locale.getDefault());\n        }\n\n        String partyId = loggedInUserLogin.getString(\"partyId\");\n        String password = loggedInUserLogin.getString(\"currentPassword\");\n        String passwordHint = loggedInUserLogin.getString(\"passwordHint\");\n\n        // security: don't create a user login if the specified partyId (if not empty) already exists\n        // unless the logged in user has permission to do so (same partyId or PARTYMGR_CREATE)\n        if (UtilValidate.isNotEmpty(partyId)) {\n            if (!loggedInUserLogin.isEmpty()) {\n                // security check: userLogin partyId must equal partyId, or must have PARTYMGR_CREATE permission\n                if (!partyId.equals(loggedInUserLogin.getString(\"partyId\"))) {\n                    errMsg = UtilProperties.getMessage(resource,\"loginservices.party_with_party_id_exists_not_permission_create_user_login\", locale);\n                    errorMessageList.add(errMsg);\n                }\n            } else {\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.must_logged_in_have_permission_create_user_login_exists\", locale);\n                errorMessageList.add(errMsg);\n            }\n        }\n\n        GenericValue newUserLogin = null;\n        boolean doCreate = true;\n\n        // check to see if there's a matching login and use it if it's for the same party\n        try {\n            newUserLogin = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", userLoginId).queryOne();\n        } catch (GenericEntityException e) {\n            Debug.logWarning(e, \"\", module);\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_read_failure\", messageMap, locale);\n            errorMessageList.add(errMsg);\n        }\n\n        if (newUserLogin != null) {\n            if (!newUserLogin.get(\"partyId\").equals(partyId)) {\n                Map<String, String> messageMap = UtilMisc.toMap(\"userLoginId\", userLoginId);\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_with_ID_exists\", messageMap, locale);\n                errorMessageList.add(errMsg);\n            } else {\n                doCreate = false;\n            }\n        } else {\n            newUserLogin = delegator.makeValue(\"UserLogin\", UtilMisc.toMap(\"userLoginId\", userLoginId));\n        }\n\n        newUserLogin.set(\"passwordHint\", passwordHint);\n        newUserLogin.set(\"partyId\", partyId);\n        newUserLogin.set(\"currentPassword\", password);\n        newUserLogin.set(\"enabled\", \"Y\");\n        newUserLogin.set(\"disabledDateTime\", null);\n\n        if (errorMessageList.size() > 0) {\n            return ServiceUtil.returnError(errorMessageList);\n        }\n\n        try {\n            if (doCreate) {\n                newUserLogin.create();\n            } else {\n                newUserLogin.store();\n            }\n        } catch (GenericEntityException e) {\n            Debug.logWarning(e, \"\", module);\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_create_login_user_write_failure\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        // Deactivate 'old' UserLogin and do not set disabledDateTime here, otherwise the 'old' UserLogin would be reenabled by next login\n        loggedInUserLogin.set(\"enabled\", \"N\");\n        loggedInUserLogin.set(\"disabledDateTime\", null);\n\n        try {\n            loggedInUserLogin.store();\n        } catch (GenericEntityException e) {\n            Debug.logWarning(e, \"\", module);\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_disable_old_login_user_write_failure\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n        result.put(\"newUserLogin\", newUserLogin);\n        return result;\n    }\n\n    /** Updates UserLogin Security info\n     *@param ctx The DispatchContext that this service is operating in\n     *@param context Map containing the input parameters\n     *@return Map with the result of the service, the output parameters\n     */\n    public static Map<String, Object> updateUserLoginSecurity(DispatchContext ctx, Map<String, ?> context) {\n        Map<String, Object> result =  new LinkedHashMap<>();\n        Delegator delegator = ctx.getDelegator();\n        Security security = ctx.getSecurity();\n        GenericValue loggedInUserLogin = (GenericValue) context.get(\"userLogin\");\n        Locale locale = (Locale) context.get(\"locale\");\n\n        String userLoginId = (String) context.get(\"userLoginId\");\n        String errMsg = null;\n\n        if (UtilValidate.isEmpty(userLoginId)) {\n            userLoginId = loggedInUserLogin.getString(\"userLoginId\");\n        }\n\n        // <b>security check</b>: must have PARTYMGR_UPDATE permission\n        if (!security.hasEntityPermission(\"PARTYMGR\", \"_UPDATE\", loggedInUserLogin) && !security.hasEntityPermission(\"SECURITY\", \"_UPDATE\", loggedInUserLogin)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.not_permission_update_security_info_for_user_login\", locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        GenericValue userLoginToUpdate = null;\n\n        try {\n            userLoginToUpdate = EntityQuery.use(delegator).from(\"UserLogin\").where(\"userLoginId\", userLoginId).queryOne();\n        } catch (GenericEntityException e) {\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_read_failure\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        if (userLoginToUpdate == null) {\n            Map<String, String> messageMap = UtilMisc.toMap(\"userLoginId\", userLoginId);\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_userlogin_with_id_not_exist\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        boolean wasEnabled = !\"N\".equals(userLoginToUpdate.get(\"enabled\"));\n\n        if (context.containsKey(\"enabled\")) {\n            userLoginToUpdate.set(\"enabled\", context.get(\"enabled\"), true);\n        }\n        if (context.containsKey(\"disabledDateTime\")) {\n            userLoginToUpdate.set(\"disabledDateTime\", context.get(\"disabledDateTime\"), true);\n        }\n        if (context.containsKey(\"successiveFailedLogins\")) {\n            userLoginToUpdate.set(\"successiveFailedLogins\", context.get(\"successiveFailedLogins\"), true);\n        }\n        if (context.containsKey(\"externalAuthId\")) {\n            userLoginToUpdate.set(\"externalAuthId\", context.get(\"externalAuthId\"), true);\n        }\n        if (context.containsKey(\"userLdapDn\")) {\n            userLoginToUpdate.set(\"userLdapDn\", context.get(\"userLdapDn\"), true);\n        }\n        if (context.containsKey(\"requirePasswordChange\")) {\n            userLoginToUpdate.set(\"requirePasswordChange\", context.get(\"requirePasswordChange\"), true);\n        }\n\n        // if was disabled and we are enabling it, clear disabledDateTime\n        if (!wasEnabled && \"Y\".equals(context.get(\"enabled\"))) {\n            userLoginToUpdate.set(\"disabledDateTime\", null);\n            userLoginToUpdate.set(\"disabledBy\", null);\n        }\n\n        if (\"N\".equals(context.get(\"enabled\"))) {\n            userLoginToUpdate.set(\"disabledBy\", loggedInUserLogin.getString(\"userLoginId\"));\n        }\n\n        try {\n            userLoginToUpdate.store();\n        } catch (GenericEntityException e) {\n            Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.could_not_change_password_write_failure\", messageMap, locale);\n            return ServiceUtil.returnError(errMsg);\n        }\n\n        result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_SUCCESS);\n        return result;\n    }\n\n    public static void checkNewPassword(GenericValue userLogin, String currentPassword, String newPassword, String newPasswordVerify, String passwordHint, List<String> errorMessageList, boolean ignoreCurrentPassword, Locale locale) {\n        Delegator delegator = userLogin.getDelegator();\n        boolean useEncryption = \"true\".equals(EntityUtilProperties.getPropertyValue(\"security\", \"password.encrypt\", delegator));\n\n        String errMsg = null;\n\n        if (!ignoreCurrentPassword) {\n            // if the password.accept.encrypted.and.plain property in security is set to true allow plain or encrypted passwords\n            // if this is a system account don't bother checking the passwords\n            boolean passwordMatches = checkPassword(userLogin.getString(\"currentPassword\"), useEncryption, currentPassword);\n            if ((currentPassword == null) || (!passwordMatches)) {\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.old_password_not_correct_reenter\", locale);\n                errorMessageList.add(errMsg);\n            }\n            if (checkPassword(userLogin.getString(\"currentPassword\"), useEncryption, newPassword)) {\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.new_password_is_equal_to_old_password\", locale);\n                errorMessageList.add(errMsg);\n            }\n\n        }\n\n        if (UtilValidate.isEmpty(newPassword) || UtilValidate.isEmpty(newPasswordVerify)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_or_verify_missing\", locale);\n            errorMessageList.add(errMsg);\n        } else if (!newPassword.equals(newPasswordVerify)) {\n            errMsg = UtilProperties.getMessage(resource,\"loginservices.password_did_not_match_verify_password\", locale);\n            errorMessageList.add(errMsg);\n        }\n\n        int passwordChangeHistoryLimit = 0;\n        try {\n            passwordChangeHistoryLimit = EntityUtilProperties.getPropertyAsInteger(\"security\", \"password.change.history.limit\", 0).intValue();\n        } catch (NumberFormatException nfe) {\n            //No valid value is found so don't bother to save any password history\n            passwordChangeHistoryLimit = 0;\n        }\n        Debug.logInfo(\" password.change.history.limit is set to \" + passwordChangeHistoryLimit, module);\n        if (passwordChangeHistoryLimit > 0) {\n            Debug.logInfo(\" checkNewPassword Checking if user is tyring to use old password \" + passwordChangeHistoryLimit, module);\n            try {\n                List<GenericValue> pwdHistList = EntityQuery.use(delegator)\n                                                            .from(\"UserLoginPasswordHistory\")\n                                                            .where(\"userLoginId\",userLogin.getString(\"userLoginId\"))\n                                                            .orderBy(\"-fromDate\")\n                                                            .queryList();\n                for (GenericValue pwdHistValue : pwdHistList) {\n                    if (checkPassword(pwdHistValue.getString(\"currentPassword\"), useEncryption, newPassword)) {\n                        Map<String, Integer> messageMap = UtilMisc.toMap(\"passwordChangeHistoryLimit\", passwordChangeHistoryLimit);\n                        errMsg = UtilProperties.getMessage(resource,\"loginservices.password_must_be_different_from_last_passwords\", messageMap, locale);\n                        errorMessageList.add(errMsg);\n                        break;\n                    }\n                }\n            } catch (GenericEntityException e) {\n                Debug.logWarning(e, \"\", module);\n                Map<String, String> messageMap = UtilMisc.toMap(\"errorMessage\", e.getMessage());\n                errMsg = UtilProperties.getMessage(resource,\"loginevents.error_accessing_password_change_history\", messageMap, locale);\n            }\n\n        }\n\n        int minPasswordLength = 0;\n\n        try {\n            minPasswordLength = EntityUtilProperties.getPropertyAsInteger(\"security\", \"password.length.min\", 0).intValue();\n        } catch (NumberFormatException nfe) {\n            minPasswordLength = 0;\n        }\n\n        if (newPassword != null) {\n            // Matching password with pattern\n            String passwordPattern = EntityUtilProperties.getPropertyValue(\"security\", \"security.login.password.pattern\", \"^.*(?=.{5,}).*$\", delegator);\n            boolean usePasswordPattern = UtilProperties.getPropertyAsBoolean(\"security\", \"security.login.password.pattern.enable\", true);\n            if (usePasswordPattern) {\n                Pattern pattern = Pattern.compile(passwordPattern);\n                Matcher matcher = pattern.matcher(newPassword);\n                boolean matched = matcher.matches();\n                if (!matched) {\n                    // This is a mix to handle the OOTB pattern which is only a fixed length\n                    Map<String, String> messageMap = UtilMisc.toMap(\"minPasswordLength\", Integer.toString(minPasswordLength));\n                    String passwordPatternMessage = EntityUtilProperties.getPropertyValue(\"security\",\n                            \"security.login.password.pattern.description\", \"loginservices.password_must_be_least_characters_long\", delegator);\n                    errMsg = UtilProperties.getMessage(resource, passwordPatternMessage, messageMap, locale);\n                    errorMessageList.add(errMsg);\n                }\n            } else {\n                if (!(newPassword.length() >= minPasswordLength)) {\n                    Map<String, String> messageMap = UtilMisc.toMap(\"minPasswordLength\", Integer.toString(minPasswordLength));\n                    errMsg = UtilProperties.getMessage(resource,\"loginservices.password_must_be_least_characters_long\", messageMap, locale);\n                    errorMessageList.add(errMsg);\n                }\n            }\n            if (newPassword.equalsIgnoreCase(userLogin.getString(\"userLoginId\"))) {\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.password_may_not_equal_username\", locale);\n                errorMessageList.add(errMsg);\n            }\n            if (UtilValidate.isNotEmpty(passwordHint) && (passwordHint.toUpperCase(Locale.getDefault()).indexOf(newPassword.toUpperCase(Locale.getDefault())) >= 0)) {\n                errMsg = UtilProperties.getMessage(resource,\"loginservices.password_hint_may_not_contain_password\", locale);\n                errorMessageList.add(errMsg);\n            }\n        }\n    }\n\n    public static String getHashType() {\n        String hashType = UtilProperties.getPropertyValue(\"security\", \"password.encrypt.hash.type\");\n\n        if (UtilValidate.isEmpty(hashType)) {\n            Debug.logWarning(\"Password encrypt hash type is not specified in security.properties, use SHA\", module);\n            hashType = \"SHA\";\n        }\n\n        return hashType;\n    }\n\n    public static boolean checkPassword(String oldPassword, boolean useEncryption, String currentPassword) {\n        boolean passwordMatches = false;\n        if (oldPassword != null) {\n            if (useEncryption) {\n                passwordMatches = HashCrypt.comparePassword(oldPassword, getHashType(), currentPassword);\n            } else {\n                passwordMatches = oldPassword.equals(currentPassword);\n            }\n        }\n        if (!passwordMatches && \"true\".equals(UtilProperties.getPropertyValue(\"security\", \"password.accept.encrypted.and.plain\"))) {\n            passwordMatches = currentPassword.equals(oldPassword);\n        }\n        return passwordMatches;\n    }\n\n    private static boolean TomcatSSOLogin(HttpServletRequest request, String userName, String currentPassword) {\n        try {\n            request.login(userName, currentPassword);\n        } catch (ServletException e) {\n\n            StringManager sm = StringManager.getManager(\"org.apache.catalina.connector\");\n            if (sm.getString(\"coyoteRequest.alreadyAuthenticated\").equals(e.getMessage())){\n                return true;\n            } else {\n                Debug.logError(e, module);\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"], "filenames": ["framework/common/src/main/java/org/apache/ofbiz/common/login/LoginServices.java"], "buggy_code_start_loc": [49], "buggy_code_end_loc": [437], "fixing_code_start_loc": [50], "fixing_code_end_loc": [466], "type": "CWE-209", "message": "In Apache Ofbiz, versions v17.12.01 to v17.12.07 implement a try catch exception to handle errors at multiple locations but leaks out sensitive table info which may aid the attacker for further recon. A user can register with a very long password, but when he tries to login with it an exception occurs.", "other": {"cve": {"id": "CVE-2021-25958", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2021-08-30T14:15:07.117", "lastModified": "2021-09-02T15:14:04.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Apache Ofbiz, versions v17.12.01 to v17.12.07 implement a try catch exception to handle errors at multiple locations but leaks out sensitive table info which may aid the attacker for further recon. A user can register with a very long password, but when he tries to login with it an exception occurs."}, {"lang": "es", "value": "En Apache Ofbiz, las versiones v17.12.01 a v17.12.07, implementan una excepci\u00f3n try catch para manejar errores en m\u00faltiples ubicaciones, pero filtran informaci\u00f3n confidencial de la tabla que puede ayudar al atacante para su posterior reconocimiento. Un usuario puede registrarse con una contrase\u00f1a muy larga, pero cuando intenta iniciar sesi\u00f3n con ella es producida una excepci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-209"}]}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-209"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:ofbiz:*:*:*:*:*:*:*:*", "versionStartIncluding": "17.12.01", "versionEndExcluding": "17.12.08", "matchCriteriaId": "A269C71D-89E3-44D4-BBC4-17CD51405392"}]}]}], "references": [{"url": "https://github.com/apache/ofbiz-framework/commit/2f5b8d33e32c4d9a48243cf9e503236acd5aec5c", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25958", "source": "vulnerabilitylab@mend.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/apache/ofbiz-framework/commit/2f5b8d33e32c4d9a48243cf9e503236acd5aec5c"}}