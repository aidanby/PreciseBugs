{"buggy_code": ["// Copyright 2005-2019 The Mumble Developers. All rights reserved.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file at the root of the\n// Mumble source tree or at <https://www.mumble.info/LICENSE>.\n\n#include \"mumble_pch.hpp\"\n\n#include \"ConnectDialog.h\"\n\n#ifdef USE_BONJOUR\n#include \"BonjourClient.h\"\n#include \"BonjourServiceBrowser.h\"\n#include \"BonjourServiceResolver.h\"\n#endif\n\n#include \"Channel.h\"\n#include \"Database.h\"\n#include \"ServerHandler.h\"\n#include \"WebFetch.h\"\n#include \"ServerResolver.h\"\n\n// We define a global macro called 'g'. This can lead to issues when included code uses 'g' as a type or parameter name (like protobuf 3.7 does). As such, for now, we have to make this our last include.\n#include \"Global.h\"\n\nQMap<QString, QIcon> ServerItem::qmIcons;\nQList<PublicInfo> ConnectDialog::qlPublicServers;\nQString ConnectDialog::qsUserCountry, ConnectDialog::qsUserCountryCode, ConnectDialog::qsUserContinentCode;\nTimer ConnectDialog::tPublicServers;\n\n\nPingStats::PingStats() {\n\tinit();\n}\n\nPingStats::~PingStats() {\n\tdelete asQuantile;\n}\n\nvoid PingStats::init() {\n\tboost::array<double, 3> probs = {{0.75, 0.80, 0.95 }};\n\n\tasQuantile = new asQuantileType(boost::accumulators::tag::extended_p_square::probabilities = probs);\n\tdPing = 0.0;\n\tuiPing = 0;\n\tuiPingSort = 0;\n\tuiUsers = 0;\n\tuiMaxUsers = 0;\n\tuiBandwidth = 0;\n\tuiSent = 0;\n\tuiRecv = 0;\n\tuiVersion = 0;\n}\n\nvoid PingStats::reset() {\n\tdelete asQuantile;\n\tinit();\n}\n\nServerViewDelegate::ServerViewDelegate(QObject *p) : QStyledItemDelegate(p) {\n}\n\nServerViewDelegate::~ServerViewDelegate() {\n}\n\nvoid ServerViewDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const {\n\t// Allow a ServerItem's BackgroundRole to override the current theme's default color.\n\tQVariant bg = index.data(Qt::BackgroundRole);\n\tif (bg.isValid()) {\n\t\tpainter->fillRect(option.rect, bg.value<QBrush>());\n\t}\n\n\tQStyledItemDelegate::paint(painter, option, index);\n}\n\nServerView::ServerView(QWidget *p) : QTreeWidget(p) {\n\tsiFavorite = new ServerItem(tr(\"Favorite\"), ServerItem::FavoriteType);\n\taddTopLevelItem(siFavorite);\n\tsiFavorite->setExpanded(true);\n\tsiFavorite->setHidden(true);\n\n#ifdef USE_BONJOUR\n\tsiLAN = new ServerItem(tr(\"LAN\"), ServerItem::LANType);\n\taddTopLevelItem(siLAN);\n\tsiLAN->setExpanded(true);\n\tsiLAN->setHidden(true);\n#else\n\tsiLAN = NULL;\n#endif\n\n\tif (!g.s.disablePublicList) {\n\t\tsiPublic = new ServerItem(tr(\"Public Internet\"), ServerItem::PublicType);\n\t\tsiPublic->setChildIndicatorPolicy(QTreeWidgetItem::ShowIndicator);\n\t\taddTopLevelItem(siPublic);\n\n\t\tsiPublic->setExpanded(false);\n\n\t\t// The continent code is empty when the server's IP address is not in the GeoIP database\n\t\tqmContinentNames.insert(QLatin1String(\"\"), tr(\"Unknown\"));\n\n\t\tqmContinentNames.insert(QLatin1String(\"af\"), tr(\"Africa\"));\n\t\tqmContinentNames.insert(QLatin1String(\"as\"), tr(\"Asia\"));\n\t\tqmContinentNames.insert(QLatin1String(\"na\"), tr(\"North America\"));\n\t\tqmContinentNames.insert(QLatin1String(\"sa\"), tr(\"South America\"));\n\t\tqmContinentNames.insert(QLatin1String(\"eu\"), tr(\"Europe\"));\n\t\tqmContinentNames.insert(QLatin1String(\"oc\"), tr(\"Oceania\"));\n\t} else {\n\t\tqWarning()<< \"Public list disabled\";\n\n\t\tsiPublic = NULL;\n\t}\n}\n\nServerView::~ServerView() {\n\tdelete siFavorite;\n\tdelete siLAN;\n\tdelete siPublic;\n}\n\nQMimeData *ServerView::mimeData(const QList<QTreeWidgetItem *> mimeitems) const {\n\tif (mimeitems.isEmpty())\n\t\treturn NULL;\n\n\tServerItem *si = static_cast<ServerItem *>(mimeitems.first());\n\treturn si->toMimeData();\n}\n\nQStringList ServerView::mimeTypes() const {\n\tQStringList qsl;\n\tqsl << QStringList(QLatin1String(\"text/uri-list\"));\n\tqsl << QStringList(QLatin1String(\"text/plain\"));\n\treturn qsl;\n}\n\nQt::DropActions ServerView::supportedDropActions() const {\n\treturn Qt::CopyAction | Qt::LinkAction;\n}\n\n/* Extract and append (2), (3) etc to the end of a servers name if it is cloned. */\nvoid ServerView::fixupName(ServerItem *si) {\n\tQString name = si->qsName;\n\n\tint tag = 1;\n\n\tQRegExp tmatch(QLatin1String(\"(.+)\\\\((\\\\d+)\\\\)\"));\n\ttmatch.setMinimal(true);\n\tif (tmatch.exactMatch(name)) {\n\t\tname = tmatch.capturedTexts().at(1).trimmed();\n\t\ttag = tmatch.capturedTexts().at(2).toInt();\n\t}\n\n\tbool found;\n\tQString cmpname;\n\tdo {\n\t\tfound = false;\n\t\tif (tag > 1)\n\t\t\tcmpname = name + QString::fromLatin1(\" (%1)\").arg(tag);\n\t\telse\n\t\t\tcmpname = name;\n\n\t\tforeach(ServerItem *f, siFavorite->qlChildren)\n\t\t\tif (f->qsName == cmpname)\n\t\t\t\tfound = true;\n\n\t\t++tag;\n\t} while (found);\n\n\tsi->qsName = cmpname;\n}\n\nbool ServerView::dropMimeData(QTreeWidgetItem *, int, const QMimeData *mime, Qt::DropAction) {\n\tServerItem *si = ServerItem::fromMimeData(mime);\n\tif (! si)\n\t\treturn false;\n\n\tfixupName(si);\n\n\tqobject_cast<ConnectDialog *>(parent())->qlItems << si;\n\tsiFavorite->addServerItem(si);\n\n\tqobject_cast<ConnectDialog *>(parent())->startDns(si);\n\n\tsetCurrentItem(si);\n\n\treturn true;\n}\n\nServerItem *ServerView::getParent(const QString &continentcode, const QString &countrycode, const QString &countryname, const QString &usercontinent, const QString &usercountry) {\n\tServerItem *continent = qmContinent.value(continentcode);\n\tif (!continent) {\n\t\tQString name = qmContinentNames.value(continentcode);\n\t\tif (name.isEmpty())\n\t\t\tname = continentcode;\n\t\tcontinent = new ServerItem(name, ServerItem::PublicType, continentcode);\n\t\tqmContinent.insert(continentcode, continent);\n\t\tsiPublic->addServerItem(continent);\n\n\t\tif (!continentcode.isEmpty()) {\n\t\t\tif (continentcode == usercontinent) {\n\t\t\t\tcontinent->setExpanded(true);\n\t\t\t\tscrollToItem(continent, QAbstractItemView::PositionAtTop);\n\t\t\t}\n\t\t} else {\n\t\t\tcontinent->setChildIndicatorPolicy(QTreeWidgetItem::ShowIndicator);\n\t\t}\n\t}\n\n\t// If the continent code is empty, we put the server directly into the \"Unknown\" continent\n\tif (continentcode.isEmpty()) {\n\t\treturn continent;\n\t}\n\n\tServerItem *country = qmCountry.value(countrycode);\n\tif (!country) {\n\t\tcountry = new ServerItem(countryname, ServerItem::PublicType, continentcode, countrycode);\n\t\tqmCountry.insert(countrycode, country);\n\t\tcountry->setChildIndicatorPolicy(QTreeWidgetItem::ShowIndicator);\n\n\t\tcontinent->addServerItem(country);\n\n\t\tif (!countrycode.isEmpty() && countrycode == usercountry) {\n\t\t\tcountry->setExpanded(true);\n\t\t\tscrollToItem(country, QAbstractItemView::PositionAtTop);\n\t\t}\n\t}\n\treturn country;\n}\n\n\nvoid ServerItem::init() {\n\t// Without this, columncount is wrong.\n\tsetData(0, Qt::DisplayRole, QVariant());\n\tsetData(1, Qt::DisplayRole, QVariant());\n\tsetData(2, Qt::DisplayRole, QVariant());\n\temitDataChanged();\n}\n\nServerItem::ServerItem(const FavoriteServer &fs) : QTreeWidgetItem(QTreeWidgetItem::UserType) {\n\tsiParent = NULL;\n\tbParent = false;\n\n\titType = FavoriteType;\n\tqsName = fs.qsName;\n\tusPort = fs.usPort;\n\n\tqsUsername = fs.qsUsername;\n\tqsPassword = fs.qsPassword;\n\n\tqsUrl = fs.qsUrl;\n\n\tbCA = false;\n\n\tif (fs.qsHostname.startsWith(QLatin1Char('@'))) {\n\t\tqsBonjourHost = fs.qsHostname.mid(1);\n\t\tbrRecord = BonjourRecord(qsBonjourHost, QLatin1String(\"_mumble._tcp.\"), QLatin1String(\"local.\"));\n\t} else {\n\t\tqsHostname = fs.qsHostname;\n\t}\n\n\tinit();\n}\n\nServerItem::ServerItem(const PublicInfo &pi) : QTreeWidgetItem(QTreeWidgetItem::UserType) {\n\tsiParent = NULL;\n\tbParent = false;\n\titType = PublicType;\n\tqsName = pi.qsName;\n\tqsHostname = pi.qsIp;\n\tusPort = pi.usPort;\n\tqsUrl = pi.quUrl.toString();\n\tqsCountry = pi.qsCountry;\n\tqsCountryCode = pi.qsCountryCode;\n\tqsContinentCode = pi.qsContinentCode;\n\tbCA = pi.bCA;\n\n\tinit();\n}\n\nServerItem::ServerItem(const QString &name, const QString &host, unsigned short port, const QString &username, const QString &password) : QTreeWidgetItem(QTreeWidgetItem::UserType) {\n\tsiParent = NULL;\n\tbParent = false;\n\titType = FavoriteType;\n\tqsName = name;\n\tusPort = port;\n\tqsUsername = username;\n\tqsPassword = password;\n\n\tbCA = false;\n\n\tif (host.startsWith(QLatin1Char('@'))) {\n\t\tqsBonjourHost = host.mid(1);\n\t\tbrRecord = BonjourRecord(qsBonjourHost, QLatin1String(\"_mumble._tcp.\"), QLatin1String(\"local.\"));\n\t} else {\n\t\tqsHostname = host;\n\t}\n\n\tinit();\n}\n\nServerItem::ServerItem(const BonjourRecord &br) : QTreeWidgetItem(QTreeWidgetItem::UserType) {\n\tsiParent = NULL;\n\tbParent = false;\n\titType = LANType;\n\tqsName = br.serviceName;\n\tqsBonjourHost = qsName;\n\tbrRecord = br;\n\tusPort = 0;\n\tbCA = false;\n\n\tinit();\n}\n\nServerItem::ServerItem(const QString &name, ItemType itype, const QString &continent, const QString &country) {\n\tsiParent = NULL;\n\tbParent = true;\n\tqsName = name;\n\titType = itype;\n\tif (itType == PublicType) {\n\t\tqsCountryCode = country;\n\t\tqsContinentCode = continent;\n\t}\n\tsetFlags(flags() & ~Qt::ItemIsDragEnabled);\n\tbCA = false;\n\n\tinit();\n}\n\nServerItem::ServerItem(const ServerItem *si) {\n\tsiParent = NULL;\n\tbParent = false;\n\titType = FavoriteType;\n\n\tqsName = si->qsName;\n\tqsHostname = si->qsHostname;\n\tusPort = si->usPort;\n\tqsUsername = si->qsUsername;\n\tqsPassword = si->qsPassword;\n\tqsCountry = si->qsCountry;\n\tqsCountryCode = si->qsCountryCode;\n\tqsContinentCode = si->qsContinentCode;\n\tqsUrl = si->qsUrl;\n\tqsBonjourHost = si->qsBonjourHost;\n\tbrRecord = si->brRecord;\n\tqlAddresses = si->qlAddresses;\n\tbCA = si->bCA;\n\n\tuiVersion = si->uiVersion;\n\tuiPing = si->uiPing;\n\tuiPingSort = si->uiPing;\n\tuiUsers = si->uiUsers;\n\tuiMaxUsers = si->uiMaxUsers;\n\tuiBandwidth = si->uiBandwidth;\n\tuiSent = si->uiSent;\n\tdPing = si->dPing;\n\t*asQuantile = * si->asQuantile;\n}\n\nServerItem::~ServerItem() {\n\tif (siParent) {\n\t\tsiParent->qlChildren.removeAll(this);\n\t\tif (siParent->bParent && siParent->qlChildren.isEmpty())\n\t\t\tsiParent->setHidden(true);\n\t}\n\n\t// This is just for cleanup when exiting the dialog, it won't stop pending DNS for the children.\n\tforeach(ServerItem *si, qlChildren)\n\t\tdelete si;\n}\n\nServerItem *ServerItem::fromMimeData(const QMimeData *mime, bool default_name, QWidget *p, bool convertHttpUrls) {\n\tif (mime->hasFormat(QLatin1String(\"OriginatedInMumble\")))\n\t\treturn NULL;\n\n\tQUrl url;\n\tif (mime->hasUrls() && ! mime->urls().isEmpty())\n\t\turl = mime->urls().at(0);\n\telse if (mime->hasText())\n\t\turl = QUrl::fromEncoded(mime->text().toUtf8());\n\n\tQString qsFile = url.toLocalFile();\n\tif (! qsFile.isEmpty()) {\n\t\tQFile f(qsFile);\n\t\t// Make sure we don't accidently read something big the user\n\t\t// happened to have in his clipboard. We only want to look\n\t\t// at small link files.\n\t\tif (f.open(QIODevice::ReadOnly) && f.size() < 10240) {\n\t\t\tQByteArray qba = f.readAll();\n\t\t\tf.close();\n\n\t\t\turl = QUrl::fromEncoded(qba, QUrl::StrictMode);\n\t\t\tif (! url.isValid()) {\n\t\t\t\t// Windows internet shortcut files (.url) are an ini with an URL value\n\t\t\t\tQSettings qs(qsFile, QSettings::IniFormat);\n\t\t\t\turl = QUrl::fromEncoded(qs.value(QLatin1String(\"InternetShortcut/URL\")).toByteArray(), QUrl::StrictMode);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (default_name) {\n#if QT_VERSION >= 0x050000\n\t\tQUrlQuery query(url);\n\t\tif (! query.hasQueryItem(QLatin1String(\"title\"))) {\n\t\t\tquery.addQueryItem(QLatin1String(\"title\"), url.host());\n\t\t}\n#else\n\t\tif (! url.hasQueryItem(QLatin1String(\"title\"))) {\n\t\t\turl.addQueryItem(QLatin1String(\"title\"), url.host());\n\t\t}\n#endif\n\t}\n\n\tif (! url.isValid()) {\n\t\treturn NULL;\n\t}\n\n\t// An URL from text without a scheme will have the hostname text\n\t// in the QUrl scheme and no hostname. We do not want to use that.\n\tif (url.host().isEmpty()) {\n\t\treturn NULL;\n\t}\n\n\t// Some communication programs automatically create http links from domains.\n\t// When a user sends another user a domain to connect to, and http is added wrongly,\n\t// we do our best to remove it again.\n\tif (convertHttpUrls && (\n\t    url.scheme() == QLatin1String(\"http\")\n\t    || url.scheme() == QLatin1String(\"https\"))) {\n\t\turl.setScheme(QLatin1String(\"mumble\"));\n\t}\n\n\treturn fromUrl(url, p);\n}\n\nServerItem *ServerItem::fromUrl(QUrl url, QWidget *p) {\n\tif (! url.isValid() || (url.scheme() != QLatin1String(\"mumble\"))) {\n\t\treturn NULL;\n\t}\n\n#if QT_VERSION >= 0x050000\n\tQUrlQuery query(url);\n#endif\n\n\tif (url.userName().isEmpty()) {\n\t\tif (g.s.qsUsername.isEmpty()) {\n\t\t\tbool ok;\n\t\t\tQString defUserName = QInputDialog::getText(p, ConnectDialog::tr(\"Adding host %1\").arg(url.host()), ConnectDialog::tr(\"Enter username\"), QLineEdit::Normal, g.s.qsUsername, &ok).trimmed();\n\t\t\tif (! ok)\n\t\t\t\treturn NULL;\n\t\t\tif (defUserName.isEmpty())\n\t\t\t\treturn NULL;\n\t\t\tg.s.qsUsername = defUserName;\n\t\t}\n\t\turl.setUserName(g.s.qsUsername);\n\t}\n\n#if QT_VERSION >= 0x050000\n\tServerItem *si = new ServerItem(query.queryItemValue(QLatin1String(\"title\")), url.host(), static_cast<unsigned short>(url.port(DEFAULT_MUMBLE_PORT)), url.userName(), url.password());\n\n\tif (query.hasQueryItem(QLatin1String(\"url\")))\n\t\tsi->qsUrl = query.queryItemValue(QLatin1String(\"url\"));\n#else\n\tServerItem *si = new ServerItem(url.queryItemValue(QLatin1String(\"title\")), url.host(), static_cast<unsigned short>(url.port(DEFAULT_MUMBLE_PORT)), url.userName(), url.password());\n\n\tif (url.hasQueryItem(QLatin1String(\"url\")))\n\t\tsi->qsUrl = url.queryItemValue(QLatin1String(\"url\"));\n#endif\n\n\treturn si;\n}\n\nQVariant ServerItem::data(int column, int role) const {\n\tif (bParent) {\n\t\tif (column == 0) {\n\t\t\tswitch (role) {\n\t\t\t\tcase Qt::DisplayRole:\n\t\t\t\t\treturn qsName;\n\t\t\t\tcase Qt::DecorationRole:\n\t\t\t\t\tif (itType == FavoriteType)\n\t\t\t\t\t\treturn loadIcon(QLatin1String(\"skin:emblems/emblem-favorite.svg\"));\n\t\t\t\t\telse if (itType == LANType)\n\t\t\t\t\t\treturn loadIcon(QLatin1String(\"skin:places/network-workgroup.svg\"));\n\t\t\t\t\telse if (! qsCountryCode.isEmpty()) {\n\t\t\t\t\t\tQString flag = QString::fromLatin1(\":/flags/%1.svg\").arg(qsCountryCode);\n\t\t\t\t\t\tif (!QFileInfo(flag).exists()) {\n\t\t\t\t\t\t\tflag = QLatin1String(\"skin:categories/applications-internet.svg\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn loadIcon(flag);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\treturn loadIcon(QLatin1String(\"skin:categories/applications-internet.svg\"));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (role == Qt::DisplayRole) {\n\t\t\tswitch (column) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn qsName;\n\t\t\t\tcase 1:\n\t\t\t\t\treturn (dPing > 0.0) ? QString::number(uiPing) : QVariant();\n\t\t\t\tcase 2:\n\t\t\t\t\treturn uiUsers ? QString::fromLatin1(\"%1/%2 \").arg(uiUsers).arg(uiMaxUsers) : QVariant();\n\t\t\t}\n\t\t} else if (role == Qt::ToolTipRole) {\n\t\t\tQStringList qsl;\n\t\t\tforeach(const ServerAddress &addr, qlAddresses) {\n\t\t\t\tqsl << Qt::escape(addr.host.toString() + QLatin1String(\":\") + QString::number(static_cast<unsigned long>(addr.port)));\n\t\t\t}\n\n\t\t\tdouble ploss = 100.0;\n\n\t\t\tif (uiSent > 0)\n\t\t\t\tploss = (uiSent - qMin(uiRecv, uiSent)) * 100. / uiSent;\n\n\t\t\tQString qs;\n\t\t\tqs +=\n\t\t\t    QLatin1String(\"<table>\") +\n\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Servername\"), Qt::escape(qsName)) +\n\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Hostname\"), Qt::escape(qsHostname));\n\n\t\t\tif (! qsBonjourHost.isEmpty())\n\t\t\t\tqs += QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Bonjour name\"), Qt::escape(qsBonjourHost));\n\n\t\t\tqs +=\n\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Port\")).arg(usPort) +\n\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Addresses\"), qsl.join(QLatin1String(\", \")));\n\n\t\t\tif (! qsUrl.isEmpty())\n\t\t\t\tqs += QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Website\"), Qt::escape(qsUrl));\n\n\t\t\tif (uiSent > 0) {\n\t\t\t\tqs += QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Packet loss\"), QString::fromLatin1(\"%1% (%2/%3)\").arg(ploss, 0, 'f', 1).arg(uiRecv).arg(uiSent));\n\t\t\t\tif (uiRecv > 0) {\n\t\t\t\t\tqs +=\n\t\t\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Ping (80%)\"), ConnectDialog::tr(\"%1 ms\").\n\t\t\t\t\t            arg(boost::accumulators::extended_p_square(* asQuantile)[1] / 1000., 0, 'f', 2)) +\n\t\t\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Ping (95%)\"), ConnectDialog::tr(\"%1 ms\").\n\t\t\t\t\t            arg(boost::accumulators::extended_p_square(* asQuantile)[2] / 1000., 0, 'f', 2)) +\n\t\t\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Bandwidth\"), ConnectDialog::tr(\"%1 kbit/s\").arg(uiBandwidth / 1000)) +\n\t\t\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Users\"), QString::fromLatin1(\"%1/%2\").arg(uiUsers).arg(uiMaxUsers)) +\n\t\t\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Version\")).arg(MumbleVersion::toString(uiVersion));\n\t\t\t\t}\n\t\t\t}\n\t\t\tqs += QLatin1String(\"</table>\");\n\t\t\treturn qs;\n\t\t} else if (role == Qt::BackgroundRole) {\n\t\t\tif (bCA) {\n\t\t\t\tQColor qc(Qt::green);\n\t\t\t\tqc.setAlpha(32);\n\t\t\t\treturn qc;\n\t\t\t}\n\t\t}\n\t}\n\treturn QTreeWidgetItem::data(column, role);\n}\n\nvoid ServerItem::addServerItem(ServerItem *childitem) {\n\tQ_ASSERT(childitem->siParent == NULL);\n\n\tchilditem->siParent = this;\n\tqlChildren.append(childitem);\n\tchilditem->hideCheck();\n\n\tif (bParent && (itType != PublicType) && isHidden())\n\t\tsetHidden(false);\n}\n\n// If all child items are hidden, there is no child indicator, regardless of policy, so we have to add/remove instead.\nvoid ServerItem::hideCheck() {\n\tbool hide = false;\n\tbool ishidden = (parent() == NULL);\n\n\tif (! bParent && (itType == PublicType)) {\n\t\tif (g.s.ssFilter == Settings::ShowReachable)\n\t\t\thide = (dPing == 0.0);\n\t\telse if (g.s.ssFilter == Settings::ShowPopulated)\n\t\t\thide = (uiUsers == 0);\n\t}\n\tif (hide != ishidden) {\n\t\tif (hide)\n\t\t\tsiParent->removeChild(this);\n\t\telse\n\t\t\tsiParent->addChild(this);\n\t}\n}\n\nvoid ServerItem::setDatas(double elapsed, quint32 users, quint32 maxusers) {\n\tif (elapsed == 0.0) {\n\t\temitDataChanged();\n\t\treturn;\n\t}\n\n\t(*asQuantile)(static_cast<double>(elapsed));\n\tdPing = boost::accumulators::extended_p_square(*asQuantile)[0];\n\tif (dPing == 0.0)\n\t\tdPing = elapsed;\n\n\tquint32 ping = static_cast<quint32>(lround(dPing / 1000.));\n\tuiRecv = static_cast<quint32>(boost::accumulators::count(* asQuantile));\n\n\tbool changed = (ping != uiPing) || (users != uiUsers) || (maxusers != uiMaxUsers);\n\n\tuiUsers = users;\n\tuiMaxUsers = maxusers;\n\tuiPing = ping;\n\n\tdouble grace = qMax(5000., 50. * uiPingSort);\n\tdouble diff = fabs(1000. * uiPingSort - dPing);\n\n\tif ((uiPingSort == 0) || ((uiSent >= 10) && (diff >= grace)))\n\t\tuiPingSort = ping;\n\n\tif (changed)\n\t\temitDataChanged();\n}\n\nFavoriteServer ServerItem::toFavoriteServer() const {\n\tFavoriteServer fs;\n\tfs.qsName = qsName;\n\tif (! qsBonjourHost.isEmpty())\n\t\tfs.qsHostname = QLatin1Char('@') + qsBonjourHost;\n\telse\n\t\tfs.qsHostname = qsHostname;\n\tfs.usPort = usPort;\n\tfs.qsUsername = qsUsername;\n\tfs.qsPassword = qsPassword;\n\tfs.qsUrl = qsUrl;\n\treturn fs;\n}\n\n\n/**\n * This function turns a ServerItem object into a QMimeData object holding a URL to the server.\n */\nQMimeData *ServerItem::toMimeData() const {\n\tQMimeData *mime = ServerItem::toMimeData(qsName, qsHostname, usPort);\n\n\tif (itType == FavoriteType)\n\t\tmime->setData(QLatin1String(\"OriginatedInMumble\"), QByteArray());\n\n\treturn mime;\n}\n\n/**\n * This function creates a QMimeData object containing a URL to the server at host and port. name is passed in the\n * query string as \"title\", which is used for adding a server to favorites. channel may be omitted, but if specified it\n * should be in the format of \"/path/to/channel\".\n */\nQMimeData *ServerItem::toMimeData(const QString &name, const QString &host, unsigned short port, const QString &channel) {\n\tQUrl url;\n\turl.setScheme(QLatin1String(\"mumble\"));\n\turl.setHost(host);\n\tif (port != DEFAULT_MUMBLE_PORT)\n\t\turl.setPort(port);\n\turl.setPath(channel);\n\n#if QT_VERSION >= 0x050000\n\tQUrlQuery query;\n\tquery.addQueryItem(QLatin1String(\"title\"), name);\n\tquery.addQueryItem(QLatin1String(\"version\"), QLatin1String(\"1.2.0\"));\n\turl.setQuery(query);\n#else\n\turl.addQueryItem(QLatin1String(\"title\"), name);\n\turl.addQueryItem(QLatin1String(\"version\"), QLatin1String(\"1.2.0\"));\n#endif\n\n\tQString qs = QLatin1String(url.toEncoded());\n\n\tQMimeData *mime = new QMimeData;\n\n#ifdef Q_OS_WIN\n\tQString contents = QString::fromLatin1(\"[InternetShortcut]\\r\\nURL=%1\\r\\n\").arg(qs);\n\tQString urlname = QString::fromLatin1(\"%1.url\").arg(name);\n\n\tFILEGROUPDESCRIPTORA fgda;\n\tZeroMemory(&fgda, sizeof(fgda));\n\tfgda.cItems = 1;\n\tfgda.fgd[0].dwFlags = FD_LINKUI | FD_FILESIZE;\n\tfgda.fgd[0].nFileSizeLow=contents.length();\n\tstrcpy_s(fgda.fgd[0].cFileName, MAX_PATH, urlname.toLocal8Bit().constData());\n\tmime->setData(QLatin1String(\"FileGroupDescriptor\"), QByteArray(reinterpret_cast<const char *>(&fgda), sizeof(fgda)));\n\n\tFILEGROUPDESCRIPTORW fgdw;\n\tZeroMemory(&fgdw, sizeof(fgdw));\n\tfgdw.cItems = 1;\n\tfgdw.fgd[0].dwFlags = FD_LINKUI | FD_FILESIZE;\n\tfgdw.fgd[0].nFileSizeLow=contents.length();\n\twcscpy_s(fgdw.fgd[0].cFileName, MAX_PATH, urlname.toStdWString().c_str());\n\tmime->setData(QLatin1String(\"FileGroupDescriptorW\"), QByteArray(reinterpret_cast<const char *>(&fgdw), sizeof(fgdw)));\n\n\tmime->setData(QString::fromWCharArray(CFSTR_FILECONTENTS), contents.toLocal8Bit());\n\n\tDWORD context[4];\n\tcontext[0] = 0;\n\tcontext[1] = 1;\n\tcontext[2] = 0;\n\tcontext[3] = 0;\n\tmime->setData(QLatin1String(\"DragContext\"), QByteArray(reinterpret_cast<const char *>(&context[0]), sizeof(context)));\n\n\tDWORD dropaction;\n\tdropaction = DROPEFFECT_LINK;\n\tmime->setData(QString::fromWCharArray(CFSTR_PREFERREDDROPEFFECT), QByteArray(reinterpret_cast<const char *>(&dropaction), sizeof(dropaction)));\n#endif\n\tQList<QUrl> urls;\n\turls << url;\n\tmime->setUrls(urls);\n\n\tmime->setText(qs);\n\tmime->setHtml(QString::fromLatin1(\"<a href=\\\"%1\\\">%2</a>\").arg(qs).arg(Qt::escape(name)));\n\n\treturn mime;\n}\n\nbool ServerItem::operator <(const QTreeWidgetItem &o) const {\n\tconst ServerItem &other = static_cast<const ServerItem &>(o);\n\tconst QTreeWidget *w = treeWidget();\n\n\tconst int column = w ? w->sortColumn() : 0;\n\n\tif (itType != other.itType) {\n\t\tconst bool inverse = w ? (w->header()->sortIndicatorOrder() == Qt::DescendingOrder) : false;\n\t\tbool less;\n\n\t\tif (itType == FavoriteType)\n\t\t\tless = true;\n\t\telse if ((itType == LANType) && (other.itType == PublicType))\n\t\t\tless = true;\n\t\telse\n\t\t\tless = false;\n\t\treturn less ^ inverse;\n\t}\n\n\tif (bParent) {\n\t\tconst bool inverse = w ? (w->header()->sortIndicatorOrder() == Qt::DescendingOrder) : false;\n\t\treturn (qsName < other.qsName) ^ inverse;\n\t}\n\n\tif (column == 0) {\n\t\tQString a = qsName.toLower();\n\t\tQString b = other.qsName.toLower();\n\n\t\tQRegExp re(QLatin1String(\"[^0-9a-z]\"));\n\t\ta.remove(re);\n\t\tb.remove(re);\n\t\treturn a < b;\n\t} else if (column == 1) {\n\t\tquint32 a = uiPingSort ? uiPingSort : UINT_MAX;\n\t\tquint32 b = other.uiPingSort ? other.uiPingSort : UINT_MAX;\n\t\treturn a < b;\n\t} else if (column == 2) {\n\t\treturn uiUsers < other.uiUsers;\n\t}\n\treturn false;\n}\n\nQIcon ServerItem::loadIcon(const QString &name) {\n\tif (! qmIcons.contains(name))\n\t\tqmIcons.insert(name, QIcon(name));\n\treturn qmIcons.value(name);\n}\n\nConnectDialogEdit::ConnectDialogEdit(QWidget *p, const QString &name, const QString &host, const QString &user, unsigned short port, const QString &password) : QDialog(p) {\n\tsetupUi(this);\n\tinit();\n\n\tbCustomLabel = ! name.simplified().isEmpty();\n\n\tqleName->setText(name);\n\tqleServer->setText(host);\n\tqleUsername->setText(user);\n\tqlePort->setText(QString::number(port));\n\tqlePassword->setText(password);\n\n\tvalidate();\n}\n\nConnectDialogEdit::ConnectDialogEdit(QWidget *parent) : QDialog(parent) {\n\tsetupUi(this);\n\tsetWindowTitle(tr(\"Add Server\"));\n\tinit();\n\n\tif (!updateFromClipboard()) {\n\t\t// If connected to a server assume the user wants to add it\n\t\tif (g.sh && g.sh->isRunning()) {\n\t\t\tQString host, name, user, pw;\n\t\t\tunsigned short port = DEFAULT_MUMBLE_PORT;\n\n\t\t\tg.sh->getConnectionInfo(host, port, user, pw);\n\t\t\tChannel *c = Channel::get(0);\n\t\t\tif (c && c->qsName != QLatin1String(\"Root\")) {\n\t\t\t\tname = c->qsName;\n\t\t\t}\n\n\t\t\tshowNotice(tr(\"You are currently connected to a server.\\nDo you want to fill the dialog with the connection data of this server?\\nHost: %1 Port: %2\").arg(host).arg(port));\n\t\t\tm_si = new ServerItem(name, host, port, user, pw);\n\t\t}\n\t}\n\tqleUsername->setText(g.s.qsUsername);\n}\n\nvoid ConnectDialogEdit::init() {\n\tm_si = NULL;\n\tusPort = 0;\n\tbOk = true;\n\tbCustomLabel = false;\n\n\tqwInlineNotice->hide();\n\n\tqlePort->setValidator(new QIntValidator(1, 65535, qlePort));\n\tqlePort->setText(QString::number(DEFAULT_MUMBLE_PORT));\n\tqlePassword->setEchoMode(QLineEdit::Password);\n\n\tconnect(qleName, SIGNAL(textChanged(const QString &)), this, SLOT(validate()));\n\tconnect(qleServer, SIGNAL(textChanged(const QString &)), this, SLOT(validate()));\n\tconnect(qlePort, SIGNAL(textChanged(const QString &)), this, SLOT(validate()));\n\tconnect(qleUsername, SIGNAL(textChanged(const QString &)), this, SLOT(validate()));\n\tconnect(qlePassword, SIGNAL(textChanged(const QString &)), this, SLOT(validate()));\n\n\tvalidate();\n}\n\nConnectDialogEdit::~ConnectDialogEdit() {\n\tdelete m_si;\n}\n\nvoid ConnectDialogEdit::showNotice(const QString &text) {\n\tQLabel *label = qwInlineNotice->findChild<QLabel *>(QLatin1String(\"qlPasteNotice\"));\n\tQ_ASSERT(label);\n\tlabel->setText(text);\n\tqwInlineNotice->show();\n\tadjustSize();\n}\n\nbool ConnectDialogEdit::updateFromClipboard() {\n\tdelete m_si;\n\tm_si = ServerItem::fromMimeData(QApplication::clipboard()->mimeData(), false, NULL, true);\n\tbool hasServerData = m_si != NULL;\n\tif (hasServerData) {\n\t\tshowNotice(tr(\"You have an URL in your clipboard.\\nDo you want to fill the dialog with this data?\\nHost: %1 Port: %2\").arg(m_si->qsHostname).arg(m_si->usPort));\n\t\treturn true;\n\t} else {\n\t\tqwInlineNotice->hide();\n\t\tadjustSize();\n\t\treturn false;\n\t}\n}\n\nvoid ConnectDialogEdit::on_qbFill_clicked() {\n\tQ_ASSERT(m_si);\n\n\tqwInlineNotice->hide();\n\tadjustSize();\n\n\tqleName->setText(m_si->qsName);\n\tqleServer->setText(m_si->qsHostname);\n\tqleUsername->setText(m_si->qsUsername);\n\tqlePort->setText(QString::number(m_si->usPort));\n\tqlePassword->setText(m_si->qsPassword);\n\n\tdelete m_si;\n\tm_si = NULL;\n}\n\nvoid ConnectDialogEdit::on_qbDiscard_clicked() {\n\tqwInlineNotice->hide();\n\tadjustSize();\n}\n\nvoid ConnectDialogEdit::on_qleName_textEdited(const QString& name) {\n\tif (bCustomLabel) {\n\t\t// If empty, then reset to automatic label.\n\t\t// NOTE(nik@jnstw.us): You may be tempted to set qleName to qleServer, but that results in the odd\n\t\t// UI behavior that clearing the field doesn't clear it; it'll immediately equal qleServer. Instead,\n\t\t// leave it empty and let it update the next time qleServer updates. Code in accept will default it\n\t\t// to qleServer if it isn't updated beforehand.\n\t\tif (name.simplified().isEmpty()) {\n\t\t\tbCustomLabel = false;\n\t\t}\n\t} else {\n\t\t// If manually edited, set to Custom\n\t\tbCustomLabel = true;\n\t}\n}\n\nvoid ConnectDialogEdit::on_qleServer_textEdited(const QString& server) {\n\t// If using automatic label, update it\n\tif (!bCustomLabel) {\n\t\tqleName->setText(server);\n\t}\n}\n\nvoid ConnectDialogEdit::validate() {\n\tqsName = qleName->text().simplified();\n\tqsHostname = qleServer->text().simplified();\n\tusPort = qlePort->text().toUShort();\n\tqsUsername = qleUsername->text().simplified();\n\tqsPassword = qlePassword->text();\n\n\t// For bonjour hosts disable the port field as it's auto-detected\n\tqlePort->setDisabled(!qsHostname.isEmpty() && qsHostname.startsWith(QLatin1Char('@')));\n\n\t// For SuperUser show password edit\n\tif (qsUsername.toLower() == QLatin1String(\"superuser\")) {\n\t\tqliPassword->setVisible(true);\n\t\tqlePassword->setVisible(true);\n\t\tqcbShowPassword->setVisible(true);\n\t\tadjustSize();\n\t} else if (qsPassword.isEmpty()) {\n\t\tqliPassword->setVisible(false);\n\t\tqlePassword->setVisible(false);\n\t\tqcbShowPassword->setVisible(false);\n\t\tadjustSize();\n\t}\n\n\tbOk = ! qsHostname.isEmpty() && ! qsUsername.isEmpty() && usPort;\n\tqdbbButtonBox->button(QDialogButtonBox::Ok)->setEnabled(bOk);\n}\n\nvoid ConnectDialogEdit::accept() {\n\tvalidate();\n\tif (bOk) {\n\t\tQString server = qleServer->text().simplified();\n\n\t\t// If the user accidentally added a schema or path part, drop it now.\n\t\t// We can't do so during editing as that is quite jarring.\n\t\tconst int schemaPos = server.indexOf(QLatin1String(\"://\"));\n\t\tif (schemaPos != -1) {\n\t\t\tserver.remove(0, schemaPos + 3);\n\t\t}\n\n\t\tconst int pathPos = server.indexOf(QLatin1Char('/'));\n\t\tif (pathPos != -1) {\n\t\t\tserver.resize(pathPos);\n\t\t}\n\n\t\tqleServer->setText(server);\n\n\t\tif (qleName->text().simplified().isEmpty() || !bCustomLabel) {\n\t\t\tqleName->setText(server);\n\t\t}\n\n\t\tQDialog::accept();\n\t}\n}\n\nvoid ConnectDialogEdit::on_qcbShowPassword_toggled(bool checked) {\n\tqlePassword->setEchoMode(checked ? QLineEdit::Normal : QLineEdit::Password);\n}\n\nConnectDialog::ConnectDialog(QWidget *p, bool autoconnect) : QDialog(p), bAutoConnect(autoconnect) {\n\tsetupUi(this);\n#ifdef Q_OS_MAC\n\tsetWindowModality(Qt::WindowModal);\n#endif\n\tbPublicInit = false;\n\n\tsiAutoConnect = NULL;\n\n\tbAllowPing = g.s.ptProxyType == Settings::NoProxy;\n\tbAllowHostLookup = g.s.ptProxyType == Settings::NoProxy;\n\tbAllowBonjour = g.s.ptProxyType == Settings::NoProxy;\n\tbAllowFilters = g.s.ptProxyType == Settings::NoProxy;\n\n\tif (tPublicServers.elapsed() >= 60 * 24 * 1000000ULL) {\n\t\tqlPublicServers.clear();\n\t}\n\n\tqdbbButtonBox->button(QDialogButtonBox::Ok)->setEnabled(false);\n\tqdbbButtonBox->button(QDialogButtonBox::Ok)->setText(tr(\"&Connect\"));\n\n\tQPushButton *qpbAdd = new QPushButton(tr(\"&Add New...\"), this);\n\tqpbAdd->setDefault(false);\n\tqpbAdd->setAutoDefault(false);\n\tconnect(qpbAdd, SIGNAL(clicked()), qaFavoriteAddNew, SIGNAL(triggered()));\n\tqdbbButtonBox->addButton(qpbAdd, QDialogButtonBox::ActionRole);\n\n\t\n\tqpbEdit = new QPushButton(tr(\"&Edit...\"), this);\n\tqpbEdit->setEnabled(false);\n\tqpbEdit->setDefault(false);\n\tqpbEdit->setAutoDefault(false);\n\tconnect(qpbEdit, SIGNAL(clicked()), qaFavoriteEdit, SIGNAL(triggered()));\n\tqdbbButtonBox->addButton(qpbEdit, QDialogButtonBox::ActionRole);\n\t\n\tqpbAdd->setHidden(g.s.disableConnectDialogEditing);\n\tqpbEdit->setHidden(g.s.disableConnectDialogEditing);\n\n\tqtwServers->setItemDelegate(new ServerViewDelegate());\n\n\t// Hide ping and user count if we are not allowed to ping.\n\tif (!bAllowPing) {\n\t\tqtwServers->setColumnCount(1);\n\t}\n\n\tqtwServers->sortItems(1, Qt::AscendingOrder);\n\n#if QT_VERSION >= 0x050000\n\tqtwServers->header()->setSectionResizeMode(0, QHeaderView::Stretch);\n\tif (qtwServers->columnCount() >= 2) {\n\t\tqtwServers->header()->setSectionResizeMode(1, QHeaderView::ResizeToContents);\n\t}\n\tif (qtwServers->columnCount() >= 3) {\n\t\tqtwServers->header()->setSectionResizeMode(2, QHeaderView::ResizeToContents);\n\t}\n#else\n\tqtwServers->header()->setResizeMode(0, QHeaderView::Stretch);\n\tif (qtwServers->columnCount() >= 2) {\n\t\tqtwServers->header()->setResizeMode(1, QHeaderView::ResizeToContents);\n\t}\n\tif (qtwServers->columnCount() >= 3) {\n\t\tqtwServers->header()->setResizeMode(2, QHeaderView::ResizeToContents);\n\t}\n#endif\n\n\tconnect(qtwServers->header(), SIGNAL(sortIndicatorChanged(int, Qt::SortOrder)), this, SLOT(OnSortChanged(int, Qt::SortOrder)));\n\n\tqaShowAll->setChecked(false);\n\tqaShowReachable->setChecked(false);\n\tqaShowPopulated->setChecked(false);\n\n\tif (bAllowFilters) {\n\t\tswitch (g.s.ssFilter) {\n\t\t\tcase Settings::ShowPopulated:\n\t\t\t\tqaShowPopulated->setChecked(true);\n\t\t\t\tbreak;\n\t\t\tcase Settings::ShowReachable:\n\t\t\t\tqaShowReachable->setChecked(true);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqaShowAll->setChecked(true);\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tqaShowAll->setChecked(true);\n\t}\n\n\tqagFilters = new QActionGroup(this);\n\tqagFilters->addAction(qaShowAll);\n\tqagFilters->addAction(qaShowReachable);\n\tqagFilters->addAction(qaShowPopulated);\n\n\tconnect(qagFilters, SIGNAL(triggered(QAction *)), this, SLOT(onFiltersTriggered(QAction *)));\n\n\tqmPopup = new QMenu(this);\n\tqmFilters = new QMenu(tr(\"&Filters\"), this);\n\tqmFilters->addAction(qaShowAll);\n\tqmFilters->addAction(qaShowReachable);\n\tqmFilters->addAction(qaShowPopulated);\n\n\tif (!bAllowFilters) {\n\t\tqmFilters->setEnabled(false);\n\t}\n\n\tQList<QTreeWidgetItem *> ql;\n\tQList<FavoriteServer> favorites = g.db->getFavorites();\n\n\tforeach(const FavoriteServer &fs, favorites) {\n\t\tServerItem *si = new ServerItem(fs);\n\t\tqlItems << si;\n\t\tstartDns(si);\n\t\tqtwServers->siFavorite->addServerItem(si);\n\t}\n\n#ifdef USE_BONJOUR\n\t// Make sure the we got the objects we need, then wire them up\n\tif (bAllowBonjour && g.bc->bsbBrowser && g.bc->bsrResolver) {\n\t\tconnect(g.bc->bsbBrowser, SIGNAL(error(DNSServiceErrorType)),\n\t\t        this, SLOT(onLanBrowseError(DNSServiceErrorType)));\n\t\tconnect(g.bc->bsbBrowser, SIGNAL(currentBonjourRecordsChanged(const QList<BonjourRecord> &)),\n\t\t        this, SLOT(onUpdateLanList(const QList<BonjourRecord> &)));\n\t\tconnect(g.bc->bsrResolver, SIGNAL(error(BonjourRecord, DNSServiceErrorType)),\n\t\t        this, SLOT(onLanResolveError(BonjourRecord, DNSServiceErrorType)));\n\t\tconnect(g.bc->bsrResolver, SIGNAL(bonjourRecordResolved(BonjourRecord, QString, int)),\n\t\t        this, SLOT(onResolved(BonjourRecord, QString, int)));\n\t\tonUpdateLanList(g.bc->bsbBrowser->currentRecords());\n\t}\n#endif\n\n\tqtPingTick = new QTimer(this);\n\tconnect(qtPingTick, SIGNAL(timeout()), this, SLOT(timeTick()));\n\n\tqusSocket4 = new QUdpSocket(this);\n\tqusSocket6 = new QUdpSocket(this);\n\tbIPv4 = qusSocket4->bind(QHostAddress(QHostAddress::Any), 0);\n\tbIPv6 = qusSocket6->bind(QHostAddress(QHostAddress::AnyIPv6), 0);\n\tconnect(qusSocket4, SIGNAL(readyRead()), this, SLOT(udpReply()));\n\tconnect(qusSocket6, SIGNAL(readyRead()), this, SLOT(udpReply()));\n\n\tif (qtwServers->siFavorite->isHidden()\n\t    && (!qtwServers->siLAN || qtwServers->siLAN->isHidden())\n\t    && qtwServers->siPublic != NULL) {\n\t\tqtwServers->siPublic->setExpanded(true);\n\t}\n\n\tiPingIndex = -1;\n\tqtPingTick->start(50);\n\n\tnew QShortcut(QKeySequence(QKeySequence::Copy), this, SLOT(on_qaFavoriteCopy_triggered()));\n\tnew QShortcut(QKeySequence(QKeySequence::Paste), this, SLOT(on_qaFavoritePaste_triggered()));\n\n\tqtwServers->setCurrentItem(NULL);\n\tbLastFound = false;\n\n\tqmPingCache = g.db->getPingCache();\n\n\tif (! g.s.qbaConnectDialogGeometry.isEmpty())\n\t\trestoreGeometry(g.s.qbaConnectDialogGeometry);\n\tif (! g.s.qbaConnectDialogHeader.isEmpty())\n\t\tqtwServers->header()->restoreState(g.s.qbaConnectDialogHeader);\n}\n\nConnectDialog::~ConnectDialog() {\n\tServerItem::qmIcons.clear();\n\n\tQList<FavoriteServer> ql;\n\tqmPingCache.clear();\n\n\tforeach(ServerItem *si, qlItems) {\n\t\tif (si->uiPing)\n\t\t\tqmPingCache.insert(UnresolvedServerAddress(si->qsHostname, si->usPort), si->uiPing);\n\n\t\tif (si->itType != ServerItem::FavoriteType)\n\t\t\tcontinue;\n\t\tql << si->toFavoriteServer();\n\t}\n\tg.db->setFavorites(ql);\n\tg.db->setPingCache(qmPingCache);\n\n\tg.s.qbaConnectDialogHeader = qtwServers->header()->saveState();\n\tg.s.qbaConnectDialogGeometry = saveGeometry();\n}\n\nvoid ConnectDialog::accept() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (bAllowHostLookup && si->qlAddresses.isEmpty()) || si->qsHostname.isEmpty()) {\n\t\tqWarning() << \"Invalid server\";\n\t\treturn;\n\t}\n\n\tqsPassword = si->qsPassword;\n\tqsServer = si->qsHostname;\n\tusPort = si->usPort;\n\n\tif (si->qsUsername.isEmpty()) {\n\t\tbool ok;\n\t\tQString defUserName = QInputDialog::getText(this, tr(\"Connecting to %1\").arg(si->qsName), tr(\"Enter username\"), QLineEdit::Normal, g.s.qsUsername, &ok).trimmed();\n\t\tif (! ok)\n\t\t\treturn;\n\t\tg.s.qsUsername = si->qsUsername = defUserName;\n\t}\n\n\tqsUsername = si->qsUsername;\n\n\tg.s.qsLastServer = si->qsName;\n\n\tQDialog::accept();\n}\n\nvoid ConnectDialog::OnSortChanged(int logicalIndex, Qt::SortOrder) {\n\tif (logicalIndex != 2) {\n\t\treturn;\n\t}\n\n\tforeach(ServerItem *si, qlItems) {\n\t\tif (si->uiPing && (si->uiPing != si->uiPingSort)) {\n\t\t\tsi->uiPingSort = si->uiPing;\n\t\t\tsi->setDatas();\n\t\t}\n\t}\n}\n\nvoid ConnectDialog::on_qaFavoriteAdd_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (si->itType == ServerItem::FavoriteType))\n\t\treturn;\n\n\tsi = new ServerItem(si);\n\tqtwServers->fixupName(si);\n\tqlItems << si;\n\tqtwServers->siFavorite->addServerItem(si);\n\tqtwServers->setCurrentItem(si);\n\tstartDns(si);\n}\n\nvoid ConnectDialog::on_qaFavoriteAddNew_triggered() {\n\tConnectDialogEdit *cde = new ConnectDialogEdit(this);\n\n\tif (cde->exec() == QDialog::Accepted) {\n\t\tServerItem *si = new ServerItem(cde->qsName, cde->qsHostname, cde->usPort, cde->qsUsername, cde->qsPassword);\n\t\tqlItems << si;\n\t\tqtwServers->siFavorite->addServerItem(si);\n\t\tqtwServers->setCurrentItem(si);\n\t\tstartDns(si);\n\t}\n\tdelete cde;\n}\n\nvoid ConnectDialog::on_qaFavoriteEdit_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (si->itType != ServerItem::FavoriteType))\n\t\treturn;\n\n\tQString host;\n\tif (! si->qsBonjourHost.isEmpty())\n\t\thost = QLatin1Char('@') + si->qsBonjourHost;\n\telse\n\t\thost = si->qsHostname;\n\n\tConnectDialogEdit *cde = new ConnectDialogEdit(this, si->qsName, host, si->qsUsername, si->usPort, si->qsPassword);\n\n\tif (cde->exec() == QDialog::Accepted) {\n\n\t\tsi->qsName = cde->qsName;\n\t\tsi->qsUsername = cde->qsUsername;\n\t\tsi->qsPassword = cde->qsPassword;\n\t\tif ((cde->qsHostname != host) || (cde->usPort != si->usPort)) {\n\t\t\tstopDns(si);\n\n\t\t\tsi->qlAddresses.clear();\n\t\t\tsi->reset();\n\n\t\t\tsi->usPort = cde->usPort;\n\n\t\t\tif (cde->qsHostname.startsWith(QLatin1Char('@'))) {\n\t\t\t\tsi->qsHostname = QString();\n\t\t\t\tsi->qsBonjourHost = cde->qsHostname.mid(1);\n\t\t\t\tsi->brRecord = BonjourRecord(si->qsBonjourHost, QLatin1String(\"_mumble._tcp.\"), QLatin1String(\"local.\"));\n\t\t\t} else {\n\t\t\t\tsi->qsHostname = cde->qsHostname;\n\t\t\t\tsi->qsBonjourHost = QString();\n\t\t\t\tsi->brRecord = BonjourRecord();\n\t\t\t}\n\t\t\tstartDns(si);\n\t\t}\n\t\tsi->setDatas();\n\t}\n\tdelete cde;\n}\n\nvoid ConnectDialog::on_qaFavoriteRemove_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (si->itType != ServerItem::FavoriteType))\n\t\treturn;\n\n\tstopDns(si);\n\tqlItems.removeAll(si);\n\tdelete si;\n}\n\nvoid ConnectDialog::on_qaFavoriteCopy_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si)\n\t\treturn;\n\n\tQApplication::clipboard()->setMimeData(si->toMimeData());\n}\n\nvoid ConnectDialog::on_qaFavoritePaste_triggered() {\n\tServerItem *si = ServerItem::fromMimeData(QApplication::clipboard()->mimeData());\n\tif (! si)\n\t\treturn;\n\n\tqlItems << si;\n\tqtwServers->siFavorite->addServerItem(si);\n\tqtwServers->setCurrentItem(si);\n\tstartDns(si);\n}\n\nvoid ConnectDialog::on_qaUrl_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || si->qsUrl.isEmpty())\n\t\treturn;\n\n\tQDesktopServices::openUrl(QUrl(si->qsUrl));\n}\n\nvoid ConnectDialog::onFiltersTriggered(QAction *act) {\n\tif (act == qaShowAll)\n\t\tg.s.ssFilter = Settings::ShowAll;\n\telse if (act == qaShowReachable)\n\t\tg.s.ssFilter = Settings::ShowReachable;\n\telse if (act == qaShowPopulated)\n\t\tg.s.ssFilter = Settings::ShowPopulated;\n\n\tforeach(ServerItem *si, qlItems)\n\t\tsi->hideCheck();\n}\n\nvoid ConnectDialog::on_qtwServers_customContextMenuRequested(const QPoint &mpos) {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->itemAt(mpos));\n\tqmPopup->clear();\n\n\tif (si != NULL && si->bParent) {\n\t\tsi = NULL;\n\t}\n\t\n\tif (si != NULL) {\n\n\t\tif (!g.s.disableConnectDialogEditing) {\n\t\t\tif (si->itType == ServerItem::FavoriteType) {\n\t\t\t\tqmPopup->addAction(qaFavoriteEdit);\n\t\t\t\tqmPopup->addAction(qaFavoriteRemove);\n\t\t\t} else {\n\t\t\t\tqmPopup->addAction(qaFavoriteAdd);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!si->qsUrl.isEmpty()) {\n\t\t\tqmPopup->addAction(qaUrl);\n\t\t}\n\t}\n\t\n\tif (! qmPopup->isEmpty()) {\n\t\tqmPopup->addSeparator();\n\t}\n\t\n\tqmPopup->addMenu(qmFilters);\n\n\tqmPopup->popup(qtwServers->viewport()->mapToGlobal(mpos), NULL);\n}\n\nvoid ConnectDialog::on_qtwServers_itemDoubleClicked(QTreeWidgetItem *item, int) {\n\tqtwServers->setCurrentItem(item);\n\taccept();\n}\n\nvoid ConnectDialog::on_qtwServers_currentItemChanged(QTreeWidgetItem *item, QTreeWidgetItem *) {\n\tServerItem *si = static_cast<ServerItem *>(item);\n\n\tif (si->siParent == qtwServers->siFavorite) {\n\t\tqpbEdit->setEnabled(true);\n\t} else {\n\t\tqpbEdit->setEnabled(false);\n\t}\n\t\n\tbool bOk = !si->qlAddresses.isEmpty();\n\tif (!bAllowHostLookup) {\n\t\tbOk = true;\n\t}\n\tqdbbButtonBox->button(QDialogButtonBox::Ok)->setEnabled(bOk);\n\n\tbLastFound = true;\n}\n\nvoid ConnectDialog::on_qtwServers_itemExpanded(QTreeWidgetItem *item) {\n\tif (qtwServers->siPublic != NULL && item == qtwServers->siPublic) {\n\t\tinitList();\n\t\tfillList();\n\t}\n\n\tServerItem *p = static_cast<ServerItem *>(item);\n\n\tforeach(ServerItem *si, p->qlChildren)\n\t\tstartDns(si);\n}\n\nvoid ConnectDialog::initList() {\n\tif (bPublicInit || (qlPublicServers.count() > 0))\n\t\treturn;\n\n\tbPublicInit = true;\n\n\tQUrl url;\n\turl.setPath(QLatin1String(\"/v1/list\"));\n#if QT_VERSION >= 0x050000\n\tQUrlQuery query;\n\tquery.addQueryItem(QLatin1String(\"version\"), QLatin1String(MUMTEXT(MUMBLE_VERSION_STRING)));\n\turl.setQuery(query);\n#else\n\turl.addQueryItem(QLatin1String(\"version\"), QLatin1String(MUMTEXT(MUMBLE_VERSION_STRING)));\n#endif\n\n\tWebFetch::fetch(QLatin1String(\"publist\"), url, this, SLOT(fetched(QByteArray,QUrl,QMap<QString,QString>)));\n}\n\n#ifdef USE_BONJOUR\nvoid ConnectDialog::onResolved(BonjourRecord record, QString host, int port) {\n\tqlBonjourActive.removeAll(record);\n\tforeach(ServerItem *si, qlItems) {\n\t\tif (si->brRecord == record) {\n\t\t\tunsigned short usport = static_cast<unsigned short>(port);\n\t\t\tif ((host != si->qsHostname) || (usport != si->usPort)) {\n\t\t\t\tstopDns(si);\n\t\t\t\tsi->usPort = static_cast<unsigned short>(port);\n\t\t\t\tsi->qsHostname = host;\n\t\t\t\tstartDns(si);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ConnectDialog::onUpdateLanList(const QList<BonjourRecord> &list) {\n\tQSet<ServerItem *> items;\n\tQSet<ServerItem *> old = qtwServers->siLAN->qlChildren.toSet();\n\n\tforeach(const BonjourRecord &record, list) {\n\t\tbool found = false;\n\t\tforeach(ServerItem *si, old) {\n\t\t\tif (si->brRecord == record) {\n\t\t\t\titems.insert(si);\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! found) {\n\t\t\tServerItem *si = new ServerItem(record);\n\t\t\tqlItems << si;\n\t\t\tg.bc->bsrResolver->resolveBonjourRecord(record);\n\t\t\tstartDns(si);\n\t\t\tqtwServers->siLAN->addServerItem(si);\n\t\t}\n\t}\n\tQSet<ServerItem *> remove = old.subtract(items);\n\tforeach(ServerItem *si, remove) {\n\t\tstopDns(si);\n\t\tqlItems.removeAll(si);\n\t\tdelete si;\n\t}\n}\n\nvoid ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {\n\tqWarning()<<\"Bonjour reported browser error \"<< err;\n}\n\nvoid ConnectDialog::onLanResolveError(BonjourRecord br, DNSServiceErrorType err) {\n\tqlBonjourActive.removeAll(br);\n\tqWarning()<<\"Bonjour reported resolver error \"<< err;\n}\n#endif\n\nvoid ConnectDialog::fillList() {\n\tQList<QTreeWidgetItem *> ql;\n\tQList<QTreeWidgetItem *> qlNew;\n\n\tforeach(const PublicInfo &pi, qlPublicServers) {\n\t\tbool found = false;\n\t\tforeach(ServerItem *si, qlItems) {\n\t\t\tif ((pi.qsIp == si->qsHostname) && (pi.usPort == si->usPort)) {\n\t\t\t\tsi->qsCountry = pi.qsCountry;\n\t\t\t\tsi->qsCountryCode = pi.qsCountryCode;\n\t\t\t\tsi->qsContinentCode = pi.qsContinentCode;\n\t\t\t\tsi->qsUrl = pi.quUrl.toString();\n\t\t\t\tsi->bCA = pi.bCA;\n\t\t\t\tsi->setDatas();\n\n\t\t\t\tif (si->itType == ServerItem::PublicType)\n\t\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\tif (! found)\n\t\t\tql << new ServerItem(pi);\n\t}\n\n\twhile (! ql.isEmpty()) {\n\t\tServerItem *si = static_cast<ServerItem *>(ql.takeAt(qrand() % ql.count()));\n\t\tqlNew << si;\n\t\tqlItems << si;\n\t}\n\n\tforeach(QTreeWidgetItem *qtwi, qlNew) {\n\t\tServerItem *si = static_cast<ServerItem *>(qtwi);\n\t\tServerItem *p = qtwServers->getParent(si->qsContinentCode, si->qsCountryCode, si->qsCountry, qsUserContinentCode, qsUserCountryCode);\n\t\tp->addServerItem(si);\n\n\t\tif (p->isExpanded() && p->parent()->isExpanded())\n\t\t\tstartDns(si);\n\t}\n}\n\nvoid ConnectDialog::timeTick() {\n\tif (! bLastFound && ! g.s.qsLastServer.isEmpty()) {\n\t\tQList<QTreeWidgetItem *> items = qtwServers->findItems(g.s.qsLastServer, Qt::MatchExactly | Qt::MatchRecursive);\n\t\tif (!items.isEmpty()) {\n\t\t\tbLastFound = true;\n\t\t\tqtwServers->setCurrentItem(items.at(0));\n\t\t\tif (g.s.bAutoConnect && bAutoConnect) {\n\t\t\t\tsiAutoConnect = static_cast<ServerItem *>(items.at(0));\n\t\t\t\tif (! siAutoConnect->qlAddresses.isEmpty()) {\n\t\t\t\t\taccept();\n\t\t\t\t\treturn;\n\t\t\t\t} else if (!bAllowHostLookup) {\n\t\t\t\t\taccept();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bAllowHostLookup) {\n\t\t// Start DNS Lookup of first unknown hostname\n\t\tforeach(const UnresolvedServerAddress &unresolved, qlDNSLookup) {\n\t\t\tif (qsDNSActive.contains(unresolved)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tqlDNSLookup.removeAll(unresolved);\n\t\t\tqlDNSLookup.append(unresolved);\n\n\t\t\tqsDNSActive.insert(unresolved);\n\t\t\tServerResolver *sr = new ServerResolver();\n\t\t\tQObject::connect(sr, SIGNAL(resolved()), this, SLOT(lookedUp()));\n\t\t\tsr->resolve(unresolved.hostname, unresolved.port);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tServerItem *current = static_cast<ServerItem *>(qtwServers->currentItem());\n\tServerItem *hover = static_cast<ServerItem *>(qtwServers->itemAt(qtwServers->viewport()->mapFromGlobal(QCursor::pos())));\n\n\tServerItem *si = NULL;\n\n\tif (tCurrent.elapsed() >= 1000000ULL)\n\t\tsi = current;\n\tif (! si && (tHover.elapsed() >= 1000000ULL))\n\t\tsi = hover;\n\n\tif (si) {\n\t\tQString hostname = si->qsHostname.toLower();\n\t\tunsigned short port = si->usPort;\n\t\tUnresolvedServerAddress unresolved(hostname, port);\n\n\t\tif (si->qlAddresses.isEmpty()) {\n\t\t\tif (! hostname.isEmpty()) {\n\t\t\t\tqlDNSLookup.removeAll(unresolved);\n\t\t\t\tqlDNSLookup.prepend(unresolved);\n\t\t\t}\n\t\t\tsi = NULL;\n\t\t}\n\t}\n\n\tif (!si) {\n\t\tif (qlItems.isEmpty())\n\t\t\treturn;\n\n\t\tbool expanded;\n\n\t\tdo {\n\t\t\t++iPingIndex;\n\t\t\tif (iPingIndex >= qlItems.count()) {\n\t\t\t\tif (tRestart.isElapsed(1000000ULL))\n\t\t\t\t\tiPingIndex = 0;\n\t\t\t\telse\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tsi = qlItems.at(iPingIndex);\n\n\t\t\tServerItem *p = si->siParent;\n\t\t\texpanded = true;\n\t\t\twhile (p && expanded) {\n\t\t\t\texpanded = expanded && p->isExpanded();\n\t\t\t\tp = p->siParent;\n\t\t\t}\n\t\t} while (si->qlAddresses.isEmpty() || ! expanded);\n\t}\n\n\tif (si == current)\n\t\ttCurrent.restart();\n\tif (si == hover)\n\t\ttHover.restart();\n\n\tforeach(const ServerAddress &addr, si->qlAddresses) {\n\t\tsendPing(addr.host.toAddress(), addr.port);\n\t}\n}\n\n\nvoid ConnectDialog::startDns(ServerItem *si) {\n\tif (!bAllowHostLookup) {\n\t\treturn;\n\t}\n\n\tQString hostname = si->qsHostname.toLower();\n\tunsigned short port = si->usPort;\n\tUnresolvedServerAddress unresolved(hostname, port);\n\n\tif (si->qlAddresses.isEmpty()) {\n\t\t// Determine if qsHostname is an IP address\n\t\t// or a hostname. If it is an IP address, we\n\t\t// can treat it as resolved as-is.\n\t\tQHostAddress qha(si->qsHostname);\n\t\tbool hostnameIsIPAddress = !qha.isNull();\n\t\tif (hostnameIsIPAddress) {\n\t\t\tsi->qlAddresses.append(ServerAddress(HostAddress(qha), port));\n\t\t} else {\n\t\t\tsi->qlAddresses = qhDNSCache.value(unresolved);\n\t\t}\n\t}\n\n\tif (qtwServers->currentItem() == si)\n\t\tqdbbButtonBox->button(QDialogButtonBox::Ok)->setEnabled(! si->qlAddresses.isEmpty());\n\n\tif (! si->qlAddresses.isEmpty()) {\n\t\tforeach(const ServerAddress &addr, si->qlAddresses) {\n\t\t\tqhPings[addr].insert(si);\n\t\t}\n\t\treturn;\n\t}\n\n#ifdef USE_BONJOUR\n\tif (bAllowBonjour && si->qsHostname.isEmpty() && ! si->brRecord.serviceName.isEmpty()) {\n\t\tif (! qlBonjourActive.contains(si->brRecord)) {\n\t\t\tg.bc->bsrResolver->resolveBonjourRecord(si->brRecord);\n\t\t\tqlBonjourActive.append(si->brRecord);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n\tif (! qhDNSWait.contains(unresolved)) {\n\t\tif (si->itType == ServerItem::PublicType)\n\t\t\tqlDNSLookup.append(unresolved);\n\t\telse\n\t\t\tqlDNSLookup.prepend(unresolved);\n\t}\n\tqhDNSWait[unresolved].insert(si);\n}\n\nvoid ConnectDialog::stopDns(ServerItem *si) {\n\tif (!bAllowHostLookup) {\n\t\treturn;\n\t}\n\n\tforeach(const ServerAddress &addr, si->qlAddresses) {\n\t\tif (qhPings.contains(addr)) {\n\t\t\tqhPings[addr].remove(si);\n\t\t\tif (qhPings[addr].isEmpty()) {\n\t\t\t\tqhPings.remove(addr);\n\t\t\t\tqhPingRand.remove(addr);\n\t\t\t}\n\t\t}\n\t}\n\n\tQString hostname = si->qsHostname.toLower();\n\tunsigned short port = si->usPort;\n\tUnresolvedServerAddress unresolved(hostname, port);\n\n\tif (qhDNSWait.contains(unresolved)) {\n\t\tqhDNSWait[unresolved].remove(si);\n\t\tif (qhDNSWait[unresolved].isEmpty()) {\n\t\t\tqhDNSWait.remove(unresolved);\n\t\t\tqlDNSLookup.removeAll(unresolved);\n\t\t}\n\t}\n}\n\nvoid ConnectDialog::lookedUp() {\n\tServerResolver *sr = qobject_cast<ServerResolver *>(QObject::sender());\n\tsr->deleteLater();\n\n\tQString hostname = sr->hostname().toLower();\n\tunsigned short port = sr->port();\n\tUnresolvedServerAddress unresolved(hostname, port);\n\n\tqsDNSActive.remove(unresolved);\n\n\t// An error occurred, or no records were found.\n\tif (sr->records().size() == 0) {\n\t\treturn;\n\t}\n\n\tQSet<ServerAddress> qs;\n\tforeach (ServerResolverRecord record, sr->records()) {\n\t\tforeach(const HostAddress &ha, record.addresses()) {\n\t\t\tqs.insert(ServerAddress(ha, record.port()));\n\t\t}\n\t}\n\n\tQSet<ServerItem *> waiting = qhDNSWait[unresolved];\n\tforeach(ServerItem *si, waiting) {\n\t\tforeach (const ServerAddress &addr, qs) {\n\t\t\tqhPings[addr].insert(si);\n\t\t}\n\n\t\tsi->qlAddresses = qs.toList();\n\t}\n\n\tqlDNSLookup.removeAll(unresolved);\n\tqhDNSCache.insert(unresolved, qs.toList());\n\tqhDNSWait.remove(unresolved);\n\n\tforeach(ServerItem *si, waiting) {\n\t\tif (si == qtwServers->currentItem()) {\n\t\t\ton_qtwServers_currentItemChanged(si, si);\n\t\t\tif (si == siAutoConnect)\n\t\t\t\taccept();\n\t\t}\n\t}\n\n\tif (bAllowPing) {\n\t\tforeach(const ServerAddress &addr, qs) {\n\t\t\tsendPing(addr.host.toAddress(), addr.port);\n\t\t}\n\t}\n}\n\nvoid ConnectDialog::sendPing(const QHostAddress &host, unsigned short port) {\n\tchar blob[16];\n\n\tServerAddress addr(HostAddress(host), port);\n\n\tquint64 uiRand;\n\tif (qhPingRand.contains(addr)) {\n\t\tuiRand = qhPingRand.value(addr);\n\t} else {\n\t\tuiRand = (static_cast<quint64>(qrand()) << 32) | static_cast<quint64>(qrand());\n\t\tqhPingRand.insert(addr, uiRand);\n\t}\n\n\tmemset(blob, 0, sizeof(blob));\n\t* reinterpret_cast<quint64 *>(blob+8) = tPing.elapsed() ^ uiRand;\n\n\tif (bIPv4 && host.protocol() == QAbstractSocket::IPv4Protocol)\n\t\tqusSocket4->writeDatagram(blob+4, 12, host, port);\n\telse if (bIPv6 && host.protocol() == QAbstractSocket::IPv6Protocol)\n\t\tqusSocket6->writeDatagram(blob+4, 12, host, port);\n\telse\n\t\treturn;\n\n\tconst QSet<ServerItem *> &qs = qhPings.value(addr);\n\n\tforeach(ServerItem *si, qs)\n\t\t++ si->uiSent;\n}\n\nvoid ConnectDialog::udpReply() {\n\tQUdpSocket *sock = qobject_cast<QUdpSocket *>(sender());\n\n\twhile (sock->hasPendingDatagrams()) {\n\t\tchar blob[64];\n\n\t\tQHostAddress host;\n\t\tunsigned short port;\n\n\t\tqint64 len = sock->readDatagram(blob+4, 24, &host, &port);\n\t\tif (len == 24) {\n\t\t\tif (host.scopeId() == QLatin1String(\"0\"))\n\t\t\t\thost.setScopeId(QLatin1String(\"\"));\n\n\t\t\tServerAddress address(HostAddress(host), port);\n\n\t\t\tif (qhPings.contains(address)) {\n\t\t\t\tquint32 *ping = reinterpret_cast<quint32 *>(blob+4);\n\t\t\t\tquint64 *ts = reinterpret_cast<quint64 *>(blob+8);\n\n\t\t\t\tquint64 elapsed = tPing.elapsed() - (*ts ^ qhPingRand.value(address));\n\n\t\t\t\tforeach(ServerItem *si, qhPings.value(address)) {\n\t\t\t\t\tsi->uiVersion = qFromBigEndian(ping[0]);\n\t\t\t\t\tquint32 users = qFromBigEndian(ping[3]);\n\t\t\t\t\tquint32 maxusers = qFromBigEndian(ping[4]);\n\t\t\t\t\tsi->uiBandwidth = qFromBigEndian(ping[5]);\n\n\t\t\t\t\tif (! si->uiPingSort)\n\t\t\t\t\t\tsi->uiPingSort = qmPingCache.value(UnresolvedServerAddress(si->qsHostname, si->usPort));\n\n\t\t\t\t\tsi->setDatas(static_cast<double>(elapsed), users, maxusers);\n\t\t\t\t\tsi->hideCheck();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ConnectDialog::fetched(QByteArray xmlData, QUrl, QMap<QString, QString> headers) {\n\tif (xmlData.isNull()) {\n\t\tQMessageBox::warning(this, QLatin1String(\"Mumble\"), tr(\"Failed to fetch server list\"), QMessageBox::Ok);\n\t\treturn;\n\t}\n\n\tQDomDocument doc;\n\tdoc.setContent(xmlData);\n\n\tqlPublicServers.clear();\n\tqsUserCountry = headers.value(QLatin1String(\"Geo-Country\"));\n\tqsUserCountryCode = headers.value(QLatin1String(\"Geo-Country-Code\")).toLower();\n\tqsUserContinentCode = headers.value(QLatin1String(\"Geo-Continent-Code\")).toLower();\n\n\tQDomElement root=doc.documentElement();\n\tQDomNode n = root.firstChild();\n\twhile (!n.isNull()) {\n\t\tQDomElement e = n.toElement();\n\t\tif (!e.isNull()) {\n\t\t\tif (e.tagName() == QLatin1String(\"server\")) {\n\t\t\t\tPublicInfo pi;\n\t\t\t\tpi.qsName = e.attribute(QLatin1String(\"name\"));\n\t\t\t\tpi.quUrl = e.attribute(QLatin1String(\"url\"));\n\t\t\t\tpi.qsIp = e.attribute(QLatin1String(\"ip\"));\n\t\t\t\tpi.usPort = e.attribute(QLatin1String(\"port\")).toUShort();\n\t\t\t\tpi.qsCountry = e.attribute(QLatin1String(\"country\"), tr(\"Unknown\"));\n\t\t\t\tpi.qsCountryCode = e.attribute(QLatin1String(\"country_code\")).toLower();\n\t\t\t\tpi.qsContinentCode = e.attribute(QLatin1String(\"continent_code\")).toLower();\n\t\t\t\tpi.bCA = e.attribute(QLatin1String(\"ca\")).toInt() ? true : false;\n\n\t\t\t\tqlPublicServers << pi;\n\t\t\t}\n\t\t}\n\t\tn = n.nextSibling();\n\t}\n\n\ttPublicServers.restart();\n\n\tfillList();\n}\n"], "fixing_code": ["// Copyright 2005-2019 The Mumble Developers. All rights reserved.\n// Use of this source code is governed by a BSD-style license\n// that can be found in the LICENSE file at the root of the\n// Mumble source tree or at <https://www.mumble.info/LICENSE>.\n\n#include \"mumble_pch.hpp\"\n\n#include \"ConnectDialog.h\"\n\n#ifdef USE_BONJOUR\n#include \"BonjourClient.h\"\n#include \"BonjourServiceBrowser.h\"\n#include \"BonjourServiceResolver.h\"\n#endif\n\n#include \"Channel.h\"\n#include \"Database.h\"\n#include \"ServerHandler.h\"\n#include \"WebFetch.h\"\n#include \"ServerResolver.h\"\n\n// We define a global macro called 'g'. This can lead to issues when included code uses 'g' as a type or parameter name (like protobuf 3.7 does). As such, for now, we have to make this our last include.\n#include \"Global.h\"\n\nQMap<QString, QIcon> ServerItem::qmIcons;\nQList<PublicInfo> ConnectDialog::qlPublicServers;\nQString ConnectDialog::qsUserCountry, ConnectDialog::qsUserCountryCode, ConnectDialog::qsUserContinentCode;\nTimer ConnectDialog::tPublicServers;\n\n\nPingStats::PingStats() {\n\tinit();\n}\n\nPingStats::~PingStats() {\n\tdelete asQuantile;\n}\n\nvoid PingStats::init() {\n\tboost::array<double, 3> probs = {{0.75, 0.80, 0.95 }};\n\n\tasQuantile = new asQuantileType(boost::accumulators::tag::extended_p_square::probabilities = probs);\n\tdPing = 0.0;\n\tuiPing = 0;\n\tuiPingSort = 0;\n\tuiUsers = 0;\n\tuiMaxUsers = 0;\n\tuiBandwidth = 0;\n\tuiSent = 0;\n\tuiRecv = 0;\n\tuiVersion = 0;\n}\n\nvoid PingStats::reset() {\n\tdelete asQuantile;\n\tinit();\n}\n\nServerViewDelegate::ServerViewDelegate(QObject *p) : QStyledItemDelegate(p) {\n}\n\nServerViewDelegate::~ServerViewDelegate() {\n}\n\nvoid ServerViewDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const {\n\t// Allow a ServerItem's BackgroundRole to override the current theme's default color.\n\tQVariant bg = index.data(Qt::BackgroundRole);\n\tif (bg.isValid()) {\n\t\tpainter->fillRect(option.rect, bg.value<QBrush>());\n\t}\n\n\tQStyledItemDelegate::paint(painter, option, index);\n}\n\nServerView::ServerView(QWidget *p) : QTreeWidget(p) {\n\tsiFavorite = new ServerItem(tr(\"Favorite\"), ServerItem::FavoriteType);\n\taddTopLevelItem(siFavorite);\n\tsiFavorite->setExpanded(true);\n\tsiFavorite->setHidden(true);\n\n#ifdef USE_BONJOUR\n\tsiLAN = new ServerItem(tr(\"LAN\"), ServerItem::LANType);\n\taddTopLevelItem(siLAN);\n\tsiLAN->setExpanded(true);\n\tsiLAN->setHidden(true);\n#else\n\tsiLAN = NULL;\n#endif\n\n\tif (!g.s.disablePublicList) {\n\t\tsiPublic = new ServerItem(tr(\"Public Internet\"), ServerItem::PublicType);\n\t\tsiPublic->setChildIndicatorPolicy(QTreeWidgetItem::ShowIndicator);\n\t\taddTopLevelItem(siPublic);\n\n\t\tsiPublic->setExpanded(false);\n\n\t\t// The continent code is empty when the server's IP address is not in the GeoIP database\n\t\tqmContinentNames.insert(QLatin1String(\"\"), tr(\"Unknown\"));\n\n\t\tqmContinentNames.insert(QLatin1String(\"af\"), tr(\"Africa\"));\n\t\tqmContinentNames.insert(QLatin1String(\"as\"), tr(\"Asia\"));\n\t\tqmContinentNames.insert(QLatin1String(\"na\"), tr(\"North America\"));\n\t\tqmContinentNames.insert(QLatin1String(\"sa\"), tr(\"South America\"));\n\t\tqmContinentNames.insert(QLatin1String(\"eu\"), tr(\"Europe\"));\n\t\tqmContinentNames.insert(QLatin1String(\"oc\"), tr(\"Oceania\"));\n\t} else {\n\t\tqWarning()<< \"Public list disabled\";\n\n\t\tsiPublic = NULL;\n\t}\n}\n\nServerView::~ServerView() {\n\tdelete siFavorite;\n\tdelete siLAN;\n\tdelete siPublic;\n}\n\nQMimeData *ServerView::mimeData(const QList<QTreeWidgetItem *> mimeitems) const {\n\tif (mimeitems.isEmpty())\n\t\treturn NULL;\n\n\tServerItem *si = static_cast<ServerItem *>(mimeitems.first());\n\treturn si->toMimeData();\n}\n\nQStringList ServerView::mimeTypes() const {\n\tQStringList qsl;\n\tqsl << QStringList(QLatin1String(\"text/uri-list\"));\n\tqsl << QStringList(QLatin1String(\"text/plain\"));\n\treturn qsl;\n}\n\nQt::DropActions ServerView::supportedDropActions() const {\n\treturn Qt::CopyAction | Qt::LinkAction;\n}\n\n/* Extract and append (2), (3) etc to the end of a servers name if it is cloned. */\nvoid ServerView::fixupName(ServerItem *si) {\n\tQString name = si->qsName;\n\n\tint tag = 1;\n\n\tQRegExp tmatch(QLatin1String(\"(.+)\\\\((\\\\d+)\\\\)\"));\n\ttmatch.setMinimal(true);\n\tif (tmatch.exactMatch(name)) {\n\t\tname = tmatch.capturedTexts().at(1).trimmed();\n\t\ttag = tmatch.capturedTexts().at(2).toInt();\n\t}\n\n\tbool found;\n\tQString cmpname;\n\tdo {\n\t\tfound = false;\n\t\tif (tag > 1)\n\t\t\tcmpname = name + QString::fromLatin1(\" (%1)\").arg(tag);\n\t\telse\n\t\t\tcmpname = name;\n\n\t\tforeach(ServerItem *f, siFavorite->qlChildren)\n\t\t\tif (f->qsName == cmpname)\n\t\t\t\tfound = true;\n\n\t\t++tag;\n\t} while (found);\n\n\tsi->qsName = cmpname;\n}\n\nbool ServerView::dropMimeData(QTreeWidgetItem *, int, const QMimeData *mime, Qt::DropAction) {\n\tServerItem *si = ServerItem::fromMimeData(mime);\n\tif (! si)\n\t\treturn false;\n\n\tfixupName(si);\n\n\tqobject_cast<ConnectDialog *>(parent())->qlItems << si;\n\tsiFavorite->addServerItem(si);\n\n\tqobject_cast<ConnectDialog *>(parent())->startDns(si);\n\n\tsetCurrentItem(si);\n\n\treturn true;\n}\n\nServerItem *ServerView::getParent(const QString &continentcode, const QString &countrycode, const QString &countryname, const QString &usercontinent, const QString &usercountry) {\n\tServerItem *continent = qmContinent.value(continentcode);\n\tif (!continent) {\n\t\tQString name = qmContinentNames.value(continentcode);\n\t\tif (name.isEmpty())\n\t\t\tname = continentcode;\n\t\tcontinent = new ServerItem(name, ServerItem::PublicType, continentcode);\n\t\tqmContinent.insert(continentcode, continent);\n\t\tsiPublic->addServerItem(continent);\n\n\t\tif (!continentcode.isEmpty()) {\n\t\t\tif (continentcode == usercontinent) {\n\t\t\t\tcontinent->setExpanded(true);\n\t\t\t\tscrollToItem(continent, QAbstractItemView::PositionAtTop);\n\t\t\t}\n\t\t} else {\n\t\t\tcontinent->setChildIndicatorPolicy(QTreeWidgetItem::ShowIndicator);\n\t\t}\n\t}\n\n\t// If the continent code is empty, we put the server directly into the \"Unknown\" continent\n\tif (continentcode.isEmpty()) {\n\t\treturn continent;\n\t}\n\n\tServerItem *country = qmCountry.value(countrycode);\n\tif (!country) {\n\t\tcountry = new ServerItem(countryname, ServerItem::PublicType, continentcode, countrycode);\n\t\tqmCountry.insert(countrycode, country);\n\t\tcountry->setChildIndicatorPolicy(QTreeWidgetItem::ShowIndicator);\n\n\t\tcontinent->addServerItem(country);\n\n\t\tif (!countrycode.isEmpty() && countrycode == usercountry) {\n\t\t\tcountry->setExpanded(true);\n\t\t\tscrollToItem(country, QAbstractItemView::PositionAtTop);\n\t\t}\n\t}\n\treturn country;\n}\n\n\nvoid ServerItem::init() {\n\t// Without this, columncount is wrong.\n\tsetData(0, Qt::DisplayRole, QVariant());\n\tsetData(1, Qt::DisplayRole, QVariant());\n\tsetData(2, Qt::DisplayRole, QVariant());\n\temitDataChanged();\n}\n\nServerItem::ServerItem(const FavoriteServer &fs) : QTreeWidgetItem(QTreeWidgetItem::UserType) {\n\tsiParent = NULL;\n\tbParent = false;\n\n\titType = FavoriteType;\n\tqsName = fs.qsName;\n\tusPort = fs.usPort;\n\n\tqsUsername = fs.qsUsername;\n\tqsPassword = fs.qsPassword;\n\n\tqsUrl = fs.qsUrl;\n\n\tbCA = false;\n\n\tif (fs.qsHostname.startsWith(QLatin1Char('@'))) {\n\t\tqsBonjourHost = fs.qsHostname.mid(1);\n\t\tbrRecord = BonjourRecord(qsBonjourHost, QLatin1String(\"_mumble._tcp.\"), QLatin1String(\"local.\"));\n\t} else {\n\t\tqsHostname = fs.qsHostname;\n\t}\n\n\tinit();\n}\n\nServerItem::ServerItem(const PublicInfo &pi) : QTreeWidgetItem(QTreeWidgetItem::UserType) {\n\tsiParent = NULL;\n\tbParent = false;\n\titType = PublicType;\n\tqsName = pi.qsName;\n\tqsHostname = pi.qsIp;\n\tusPort = pi.usPort;\n\tqsUrl = pi.quUrl.toString();\n\tqsCountry = pi.qsCountry;\n\tqsCountryCode = pi.qsCountryCode;\n\tqsContinentCode = pi.qsContinentCode;\n\tbCA = pi.bCA;\n\n\tinit();\n}\n\nServerItem::ServerItem(const QString &name, const QString &host, unsigned short port, const QString &username, const QString &password) : QTreeWidgetItem(QTreeWidgetItem::UserType) {\n\tsiParent = NULL;\n\tbParent = false;\n\titType = FavoriteType;\n\tqsName = name;\n\tusPort = port;\n\tqsUsername = username;\n\tqsPassword = password;\n\n\tbCA = false;\n\n\tif (host.startsWith(QLatin1Char('@'))) {\n\t\tqsBonjourHost = host.mid(1);\n\t\tbrRecord = BonjourRecord(qsBonjourHost, QLatin1String(\"_mumble._tcp.\"), QLatin1String(\"local.\"));\n\t} else {\n\t\tqsHostname = host;\n\t}\n\n\tinit();\n}\n\nServerItem::ServerItem(const BonjourRecord &br) : QTreeWidgetItem(QTreeWidgetItem::UserType) {\n\tsiParent = NULL;\n\tbParent = false;\n\titType = LANType;\n\tqsName = br.serviceName;\n\tqsBonjourHost = qsName;\n\tbrRecord = br;\n\tusPort = 0;\n\tbCA = false;\n\n\tinit();\n}\n\nServerItem::ServerItem(const QString &name, ItemType itype, const QString &continent, const QString &country) {\n\tsiParent = NULL;\n\tbParent = true;\n\tqsName = name;\n\titType = itype;\n\tif (itType == PublicType) {\n\t\tqsCountryCode = country;\n\t\tqsContinentCode = continent;\n\t}\n\tsetFlags(flags() & ~Qt::ItemIsDragEnabled);\n\tbCA = false;\n\n\tinit();\n}\n\nServerItem::ServerItem(const ServerItem *si) {\n\tsiParent = NULL;\n\tbParent = false;\n\titType = FavoriteType;\n\n\tqsName = si->qsName;\n\tqsHostname = si->qsHostname;\n\tusPort = si->usPort;\n\tqsUsername = si->qsUsername;\n\tqsPassword = si->qsPassword;\n\tqsCountry = si->qsCountry;\n\tqsCountryCode = si->qsCountryCode;\n\tqsContinentCode = si->qsContinentCode;\n\tqsUrl = si->qsUrl;\n\tqsBonjourHost = si->qsBonjourHost;\n\tbrRecord = si->brRecord;\n\tqlAddresses = si->qlAddresses;\n\tbCA = si->bCA;\n\n\tuiVersion = si->uiVersion;\n\tuiPing = si->uiPing;\n\tuiPingSort = si->uiPing;\n\tuiUsers = si->uiUsers;\n\tuiMaxUsers = si->uiMaxUsers;\n\tuiBandwidth = si->uiBandwidth;\n\tuiSent = si->uiSent;\n\tdPing = si->dPing;\n\t*asQuantile = * si->asQuantile;\n}\n\nServerItem::~ServerItem() {\n\tif (siParent) {\n\t\tsiParent->qlChildren.removeAll(this);\n\t\tif (siParent->bParent && siParent->qlChildren.isEmpty())\n\t\t\tsiParent->setHidden(true);\n\t}\n\n\t// This is just for cleanup when exiting the dialog, it won't stop pending DNS for the children.\n\tforeach(ServerItem *si, qlChildren)\n\t\tdelete si;\n}\n\nServerItem *ServerItem::fromMimeData(const QMimeData *mime, bool default_name, QWidget *p, bool convertHttpUrls) {\n\tif (mime->hasFormat(QLatin1String(\"OriginatedInMumble\")))\n\t\treturn NULL;\n\n\tQUrl url;\n\tif (mime->hasUrls() && ! mime->urls().isEmpty())\n\t\turl = mime->urls().at(0);\n\telse if (mime->hasText())\n\t\turl = QUrl::fromEncoded(mime->text().toUtf8());\n\n\tQString qsFile = url.toLocalFile();\n\tif (! qsFile.isEmpty()) {\n\t\tQFile f(qsFile);\n\t\t// Make sure we don't accidently read something big the user\n\t\t// happened to have in his clipboard. We only want to look\n\t\t// at small link files.\n\t\tif (f.open(QIODevice::ReadOnly) && f.size() < 10240) {\n\t\t\tQByteArray qba = f.readAll();\n\t\t\tf.close();\n\n\t\t\turl = QUrl::fromEncoded(qba, QUrl::StrictMode);\n\t\t\tif (! url.isValid()) {\n\t\t\t\t// Windows internet shortcut files (.url) are an ini with an URL value\n\t\t\t\tQSettings qs(qsFile, QSettings::IniFormat);\n\t\t\t\turl = QUrl::fromEncoded(qs.value(QLatin1String(\"InternetShortcut/URL\")).toByteArray(), QUrl::StrictMode);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (default_name) {\n#if QT_VERSION >= 0x050000\n\t\tQUrlQuery query(url);\n\t\tif (! query.hasQueryItem(QLatin1String(\"title\"))) {\n\t\t\tquery.addQueryItem(QLatin1String(\"title\"), url.host());\n\t\t}\n#else\n\t\tif (! url.hasQueryItem(QLatin1String(\"title\"))) {\n\t\t\turl.addQueryItem(QLatin1String(\"title\"), url.host());\n\t\t}\n#endif\n\t}\n\n\tif (! url.isValid()) {\n\t\treturn NULL;\n\t}\n\n\t// An URL from text without a scheme will have the hostname text\n\t// in the QUrl scheme and no hostname. We do not want to use that.\n\tif (url.host().isEmpty()) {\n\t\treturn NULL;\n\t}\n\n\t// Some communication programs automatically create http links from domains.\n\t// When a user sends another user a domain to connect to, and http is added wrongly,\n\t// we do our best to remove it again.\n\tif (convertHttpUrls && (\n\t    url.scheme() == QLatin1String(\"http\")\n\t    || url.scheme() == QLatin1String(\"https\"))) {\n\t\turl.setScheme(QLatin1String(\"mumble\"));\n\t}\n\n\treturn fromUrl(url, p);\n}\n\nServerItem *ServerItem::fromUrl(QUrl url, QWidget *p) {\n\tif (! url.isValid() || (url.scheme() != QLatin1String(\"mumble\"))) {\n\t\treturn NULL;\n\t}\n\n#if QT_VERSION >= 0x050000\n\tQUrlQuery query(url);\n#endif\n\n\tif (url.userName().isEmpty()) {\n\t\tif (g.s.qsUsername.isEmpty()) {\n\t\t\tbool ok;\n\t\t\tQString defUserName = QInputDialog::getText(p, ConnectDialog::tr(\"Adding host %1\").arg(url.host()), ConnectDialog::tr(\"Enter username\"), QLineEdit::Normal, g.s.qsUsername, &ok).trimmed();\n\t\t\tif (! ok)\n\t\t\t\treturn NULL;\n\t\t\tif (defUserName.isEmpty())\n\t\t\t\treturn NULL;\n\t\t\tg.s.qsUsername = defUserName;\n\t\t}\n\t\turl.setUserName(g.s.qsUsername);\n\t}\n\n#if QT_VERSION >= 0x050000\n\tServerItem *si = new ServerItem(query.queryItemValue(QLatin1String(\"title\")), url.host(), static_cast<unsigned short>(url.port(DEFAULT_MUMBLE_PORT)), url.userName(), url.password());\n\n\tif (query.hasQueryItem(QLatin1String(\"url\")))\n\t\tsi->qsUrl = query.queryItemValue(QLatin1String(\"url\"));\n#else\n\tServerItem *si = new ServerItem(url.queryItemValue(QLatin1String(\"title\")), url.host(), static_cast<unsigned short>(url.port(DEFAULT_MUMBLE_PORT)), url.userName(), url.password());\n\n\tif (url.hasQueryItem(QLatin1String(\"url\")))\n\t\tsi->qsUrl = url.queryItemValue(QLatin1String(\"url\"));\n#endif\n\n\treturn si;\n}\n\nQVariant ServerItem::data(int column, int role) const {\n\tif (bParent) {\n\t\tif (column == 0) {\n\t\t\tswitch (role) {\n\t\t\t\tcase Qt::DisplayRole:\n\t\t\t\t\treturn qsName;\n\t\t\t\tcase Qt::DecorationRole:\n\t\t\t\t\tif (itType == FavoriteType)\n\t\t\t\t\t\treturn loadIcon(QLatin1String(\"skin:emblems/emblem-favorite.svg\"));\n\t\t\t\t\telse if (itType == LANType)\n\t\t\t\t\t\treturn loadIcon(QLatin1String(\"skin:places/network-workgroup.svg\"));\n\t\t\t\t\telse if (! qsCountryCode.isEmpty()) {\n\t\t\t\t\t\tQString flag = QString::fromLatin1(\":/flags/%1.svg\").arg(qsCountryCode);\n\t\t\t\t\t\tif (!QFileInfo(flag).exists()) {\n\t\t\t\t\t\t\tflag = QLatin1String(\"skin:categories/applications-internet.svg\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn loadIcon(flag);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\treturn loadIcon(QLatin1String(\"skin:categories/applications-internet.svg\"));\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (role == Qt::DisplayRole) {\n\t\t\tswitch (column) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn qsName;\n\t\t\t\tcase 1:\n\t\t\t\t\treturn (dPing > 0.0) ? QString::number(uiPing) : QVariant();\n\t\t\t\tcase 2:\n\t\t\t\t\treturn uiUsers ? QString::fromLatin1(\"%1/%2 \").arg(uiUsers).arg(uiMaxUsers) : QVariant();\n\t\t\t}\n\t\t} else if (role == Qt::ToolTipRole) {\n\t\t\tQStringList qsl;\n\t\t\tforeach(const ServerAddress &addr, qlAddresses) {\n\t\t\t\tqsl << Qt::escape(addr.host.toString() + QLatin1String(\":\") + QString::number(static_cast<unsigned long>(addr.port)));\n\t\t\t}\n\n\t\t\tdouble ploss = 100.0;\n\n\t\t\tif (uiSent > 0)\n\t\t\t\tploss = (uiSent - qMin(uiRecv, uiSent)) * 100. / uiSent;\n\n\t\t\tQString qs;\n\t\t\tqs +=\n\t\t\t    QLatin1String(\"<table>\") +\n\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Servername\"), Qt::escape(qsName)) +\n\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Hostname\"), Qt::escape(qsHostname));\n\n\t\t\tif (! qsBonjourHost.isEmpty())\n\t\t\t\tqs += QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Bonjour name\"), Qt::escape(qsBonjourHost));\n\n\t\t\tqs +=\n\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Port\")).arg(usPort) +\n\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Addresses\"), qsl.join(QLatin1String(\", \")));\n\n\t\t\tif (! qsUrl.isEmpty())\n\t\t\t\tqs += QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Website\"), Qt::escape(qsUrl));\n\n\t\t\tif (uiSent > 0) {\n\t\t\t\tqs += QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Packet loss\"), QString::fromLatin1(\"%1% (%2/%3)\").arg(ploss, 0, 'f', 1).arg(uiRecv).arg(uiSent));\n\t\t\t\tif (uiRecv > 0) {\n\t\t\t\t\tqs +=\n\t\t\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Ping (80%)\"), ConnectDialog::tr(\"%1 ms\").\n\t\t\t\t\t            arg(boost::accumulators::extended_p_square(* asQuantile)[1] / 1000., 0, 'f', 2)) +\n\t\t\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Ping (95%)\"), ConnectDialog::tr(\"%1 ms\").\n\t\t\t\t\t            arg(boost::accumulators::extended_p_square(* asQuantile)[2] / 1000., 0, 'f', 2)) +\n\t\t\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Bandwidth\"), ConnectDialog::tr(\"%1 kbit/s\").arg(uiBandwidth / 1000)) +\n\t\t\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Users\"), QString::fromLatin1(\"%1/%2\").arg(uiUsers).arg(uiMaxUsers)) +\n\t\t\t\t\t    QString::fromLatin1(\"<tr><th align=left>%1</th><td>%2</td></tr>\").arg(ConnectDialog::tr(\"Version\")).arg(MumbleVersion::toString(uiVersion));\n\t\t\t\t}\n\t\t\t}\n\t\t\tqs += QLatin1String(\"</table>\");\n\t\t\treturn qs;\n\t\t} else if (role == Qt::BackgroundRole) {\n\t\t\tif (bCA) {\n\t\t\t\tQColor qc(Qt::green);\n\t\t\t\tqc.setAlpha(32);\n\t\t\t\treturn qc;\n\t\t\t}\n\t\t}\n\t}\n\treturn QTreeWidgetItem::data(column, role);\n}\n\nvoid ServerItem::addServerItem(ServerItem *childitem) {\n\tQ_ASSERT(childitem->siParent == NULL);\n\n\tchilditem->siParent = this;\n\tqlChildren.append(childitem);\n\tchilditem->hideCheck();\n\n\tif (bParent && (itType != PublicType) && isHidden())\n\t\tsetHidden(false);\n}\n\n// If all child items are hidden, there is no child indicator, regardless of policy, so we have to add/remove instead.\nvoid ServerItem::hideCheck() {\n\tbool hide = false;\n\tbool ishidden = (parent() == NULL);\n\n\tif (! bParent && (itType == PublicType)) {\n\t\tif (g.s.ssFilter == Settings::ShowReachable)\n\t\t\thide = (dPing == 0.0);\n\t\telse if (g.s.ssFilter == Settings::ShowPopulated)\n\t\t\thide = (uiUsers == 0);\n\t}\n\tif (hide != ishidden) {\n\t\tif (hide)\n\t\t\tsiParent->removeChild(this);\n\t\telse\n\t\t\tsiParent->addChild(this);\n\t}\n}\n\nvoid ServerItem::setDatas(double elapsed, quint32 users, quint32 maxusers) {\n\tif (elapsed == 0.0) {\n\t\temitDataChanged();\n\t\treturn;\n\t}\n\n\t(*asQuantile)(static_cast<double>(elapsed));\n\tdPing = boost::accumulators::extended_p_square(*asQuantile)[0];\n\tif (dPing == 0.0)\n\t\tdPing = elapsed;\n\n\tquint32 ping = static_cast<quint32>(lround(dPing / 1000.));\n\tuiRecv = static_cast<quint32>(boost::accumulators::count(* asQuantile));\n\n\tbool changed = (ping != uiPing) || (users != uiUsers) || (maxusers != uiMaxUsers);\n\n\tuiUsers = users;\n\tuiMaxUsers = maxusers;\n\tuiPing = ping;\n\n\tdouble grace = qMax(5000., 50. * uiPingSort);\n\tdouble diff = fabs(1000. * uiPingSort - dPing);\n\n\tif ((uiPingSort == 0) || ((uiSent >= 10) && (diff >= grace)))\n\t\tuiPingSort = ping;\n\n\tif (changed)\n\t\temitDataChanged();\n}\n\nFavoriteServer ServerItem::toFavoriteServer() const {\n\tFavoriteServer fs;\n\tfs.qsName = qsName;\n\tif (! qsBonjourHost.isEmpty())\n\t\tfs.qsHostname = QLatin1Char('@') + qsBonjourHost;\n\telse\n\t\tfs.qsHostname = qsHostname;\n\tfs.usPort = usPort;\n\tfs.qsUsername = qsUsername;\n\tfs.qsPassword = qsPassword;\n\tfs.qsUrl = qsUrl;\n\treturn fs;\n}\n\n\n/**\n * This function turns a ServerItem object into a QMimeData object holding a URL to the server.\n */\nQMimeData *ServerItem::toMimeData() const {\n\tQMimeData *mime = ServerItem::toMimeData(qsName, qsHostname, usPort);\n\n\tif (itType == FavoriteType)\n\t\tmime->setData(QLatin1String(\"OriginatedInMumble\"), QByteArray());\n\n\treturn mime;\n}\n\n/**\n * This function creates a QMimeData object containing a URL to the server at host and port. name is passed in the\n * query string as \"title\", which is used for adding a server to favorites. channel may be omitted, but if specified it\n * should be in the format of \"/path/to/channel\".\n */\nQMimeData *ServerItem::toMimeData(const QString &name, const QString &host, unsigned short port, const QString &channel) {\n\tQUrl url;\n\turl.setScheme(QLatin1String(\"mumble\"));\n\turl.setHost(host);\n\tif (port != DEFAULT_MUMBLE_PORT)\n\t\turl.setPort(port);\n\turl.setPath(channel);\n\n#if QT_VERSION >= 0x050000\n\tQUrlQuery query;\n\tquery.addQueryItem(QLatin1String(\"title\"), name);\n\tquery.addQueryItem(QLatin1String(\"version\"), QLatin1String(\"1.2.0\"));\n\turl.setQuery(query);\n#else\n\turl.addQueryItem(QLatin1String(\"title\"), name);\n\turl.addQueryItem(QLatin1String(\"version\"), QLatin1String(\"1.2.0\"));\n#endif\n\n\tQString qs = QLatin1String(url.toEncoded());\n\n\tQMimeData *mime = new QMimeData;\n\n#ifdef Q_OS_WIN\n\tQString contents = QString::fromLatin1(\"[InternetShortcut]\\r\\nURL=%1\\r\\n\").arg(qs);\n\tQString urlname = QString::fromLatin1(\"%1.url\").arg(name);\n\n\tFILEGROUPDESCRIPTORA fgda;\n\tZeroMemory(&fgda, sizeof(fgda));\n\tfgda.cItems = 1;\n\tfgda.fgd[0].dwFlags = FD_LINKUI | FD_FILESIZE;\n\tfgda.fgd[0].nFileSizeLow=contents.length();\n\tstrcpy_s(fgda.fgd[0].cFileName, MAX_PATH, urlname.toLocal8Bit().constData());\n\tmime->setData(QLatin1String(\"FileGroupDescriptor\"), QByteArray(reinterpret_cast<const char *>(&fgda), sizeof(fgda)));\n\n\tFILEGROUPDESCRIPTORW fgdw;\n\tZeroMemory(&fgdw, sizeof(fgdw));\n\tfgdw.cItems = 1;\n\tfgdw.fgd[0].dwFlags = FD_LINKUI | FD_FILESIZE;\n\tfgdw.fgd[0].nFileSizeLow=contents.length();\n\twcscpy_s(fgdw.fgd[0].cFileName, MAX_PATH, urlname.toStdWString().c_str());\n\tmime->setData(QLatin1String(\"FileGroupDescriptorW\"), QByteArray(reinterpret_cast<const char *>(&fgdw), sizeof(fgdw)));\n\n\tmime->setData(QString::fromWCharArray(CFSTR_FILECONTENTS), contents.toLocal8Bit());\n\n\tDWORD context[4];\n\tcontext[0] = 0;\n\tcontext[1] = 1;\n\tcontext[2] = 0;\n\tcontext[3] = 0;\n\tmime->setData(QLatin1String(\"DragContext\"), QByteArray(reinterpret_cast<const char *>(&context[0]), sizeof(context)));\n\n\tDWORD dropaction;\n\tdropaction = DROPEFFECT_LINK;\n\tmime->setData(QString::fromWCharArray(CFSTR_PREFERREDDROPEFFECT), QByteArray(reinterpret_cast<const char *>(&dropaction), sizeof(dropaction)));\n#endif\n\tQList<QUrl> urls;\n\turls << url;\n\tmime->setUrls(urls);\n\n\tmime->setText(qs);\n\tmime->setHtml(QString::fromLatin1(\"<a href=\\\"%1\\\">%2</a>\").arg(qs).arg(Qt::escape(name)));\n\n\treturn mime;\n}\n\nbool ServerItem::operator <(const QTreeWidgetItem &o) const {\n\tconst ServerItem &other = static_cast<const ServerItem &>(o);\n\tconst QTreeWidget *w = treeWidget();\n\n\tconst int column = w ? w->sortColumn() : 0;\n\n\tif (itType != other.itType) {\n\t\tconst bool inverse = w ? (w->header()->sortIndicatorOrder() == Qt::DescendingOrder) : false;\n\t\tbool less;\n\n\t\tif (itType == FavoriteType)\n\t\t\tless = true;\n\t\telse if ((itType == LANType) && (other.itType == PublicType))\n\t\t\tless = true;\n\t\telse\n\t\t\tless = false;\n\t\treturn less ^ inverse;\n\t}\n\n\tif (bParent) {\n\t\tconst bool inverse = w ? (w->header()->sortIndicatorOrder() == Qt::DescendingOrder) : false;\n\t\treturn (qsName < other.qsName) ^ inverse;\n\t}\n\n\tif (column == 0) {\n\t\tQString a = qsName.toLower();\n\t\tQString b = other.qsName.toLower();\n\n\t\tQRegExp re(QLatin1String(\"[^0-9a-z]\"));\n\t\ta.remove(re);\n\t\tb.remove(re);\n\t\treturn a < b;\n\t} else if (column == 1) {\n\t\tquint32 a = uiPingSort ? uiPingSort : UINT_MAX;\n\t\tquint32 b = other.uiPingSort ? other.uiPingSort : UINT_MAX;\n\t\treturn a < b;\n\t} else if (column == 2) {\n\t\treturn uiUsers < other.uiUsers;\n\t}\n\treturn false;\n}\n\nQIcon ServerItem::loadIcon(const QString &name) {\n\tif (! qmIcons.contains(name))\n\t\tqmIcons.insert(name, QIcon(name));\n\treturn qmIcons.value(name);\n}\n\nConnectDialogEdit::ConnectDialogEdit(QWidget *p, const QString &name, const QString &host, const QString &user, unsigned short port, const QString &password) : QDialog(p) {\n\tsetupUi(this);\n\tinit();\n\n\tbCustomLabel = ! name.simplified().isEmpty();\n\n\tqleName->setText(name);\n\tqleServer->setText(host);\n\tqleUsername->setText(user);\n\tqlePort->setText(QString::number(port));\n\tqlePassword->setText(password);\n\n\tvalidate();\n}\n\nConnectDialogEdit::ConnectDialogEdit(QWidget *parent) : QDialog(parent) {\n\tsetupUi(this);\n\tsetWindowTitle(tr(\"Add Server\"));\n\tinit();\n\n\tif (!updateFromClipboard()) {\n\t\t// If connected to a server assume the user wants to add it\n\t\tif (g.sh && g.sh->isRunning()) {\n\t\t\tQString host, name, user, pw;\n\t\t\tunsigned short port = DEFAULT_MUMBLE_PORT;\n\n\t\t\tg.sh->getConnectionInfo(host, port, user, pw);\n\t\t\tChannel *c = Channel::get(0);\n\t\t\tif (c && c->qsName != QLatin1String(\"Root\")) {\n\t\t\t\tname = c->qsName;\n\t\t\t}\n\n\t\t\tshowNotice(tr(\"You are currently connected to a server.\\nDo you want to fill the dialog with the connection data of this server?\\nHost: %1 Port: %2\").arg(host).arg(port));\n\t\t\tm_si = new ServerItem(name, host, port, user, pw);\n\t\t}\n\t}\n\tqleUsername->setText(g.s.qsUsername);\n}\n\nvoid ConnectDialogEdit::init() {\n\tm_si = NULL;\n\tusPort = 0;\n\tbOk = true;\n\tbCustomLabel = false;\n\n\tqwInlineNotice->hide();\n\n\tqlePort->setValidator(new QIntValidator(1, 65535, qlePort));\n\tqlePort->setText(QString::number(DEFAULT_MUMBLE_PORT));\n\tqlePassword->setEchoMode(QLineEdit::Password);\n\n\tconnect(qleName, SIGNAL(textChanged(const QString &)), this, SLOT(validate()));\n\tconnect(qleServer, SIGNAL(textChanged(const QString &)), this, SLOT(validate()));\n\tconnect(qlePort, SIGNAL(textChanged(const QString &)), this, SLOT(validate()));\n\tconnect(qleUsername, SIGNAL(textChanged(const QString &)), this, SLOT(validate()));\n\tconnect(qlePassword, SIGNAL(textChanged(const QString &)), this, SLOT(validate()));\n\n\tvalidate();\n}\n\nConnectDialogEdit::~ConnectDialogEdit() {\n\tdelete m_si;\n}\n\nvoid ConnectDialogEdit::showNotice(const QString &text) {\n\tQLabel *label = qwInlineNotice->findChild<QLabel *>(QLatin1String(\"qlPasteNotice\"));\n\tQ_ASSERT(label);\n\tlabel->setText(text);\n\tqwInlineNotice->show();\n\tadjustSize();\n}\n\nbool ConnectDialogEdit::updateFromClipboard() {\n\tdelete m_si;\n\tm_si = ServerItem::fromMimeData(QApplication::clipboard()->mimeData(), false, NULL, true);\n\tbool hasServerData = m_si != NULL;\n\tif (hasServerData) {\n\t\tshowNotice(tr(\"You have an URL in your clipboard.\\nDo you want to fill the dialog with this data?\\nHost: %1 Port: %2\").arg(m_si->qsHostname).arg(m_si->usPort));\n\t\treturn true;\n\t} else {\n\t\tqwInlineNotice->hide();\n\t\tadjustSize();\n\t\treturn false;\n\t}\n}\n\nvoid ConnectDialogEdit::on_qbFill_clicked() {\n\tQ_ASSERT(m_si);\n\n\tqwInlineNotice->hide();\n\tadjustSize();\n\n\tqleName->setText(m_si->qsName);\n\tqleServer->setText(m_si->qsHostname);\n\tqleUsername->setText(m_si->qsUsername);\n\tqlePort->setText(QString::number(m_si->usPort));\n\tqlePassword->setText(m_si->qsPassword);\n\n\tdelete m_si;\n\tm_si = NULL;\n}\n\nvoid ConnectDialogEdit::on_qbDiscard_clicked() {\n\tqwInlineNotice->hide();\n\tadjustSize();\n}\n\nvoid ConnectDialogEdit::on_qleName_textEdited(const QString& name) {\n\tif (bCustomLabel) {\n\t\t// If empty, then reset to automatic label.\n\t\t// NOTE(nik@jnstw.us): You may be tempted to set qleName to qleServer, but that results in the odd\n\t\t// UI behavior that clearing the field doesn't clear it; it'll immediately equal qleServer. Instead,\n\t\t// leave it empty and let it update the next time qleServer updates. Code in accept will default it\n\t\t// to qleServer if it isn't updated beforehand.\n\t\tif (name.simplified().isEmpty()) {\n\t\t\tbCustomLabel = false;\n\t\t}\n\t} else {\n\t\t// If manually edited, set to Custom\n\t\tbCustomLabel = true;\n\t}\n}\n\nvoid ConnectDialogEdit::on_qleServer_textEdited(const QString& server) {\n\t// If using automatic label, update it\n\tif (!bCustomLabel) {\n\t\tqleName->setText(server);\n\t}\n}\n\nvoid ConnectDialogEdit::validate() {\n\tqsName = qleName->text().simplified();\n\tqsHostname = qleServer->text().simplified();\n\tusPort = qlePort->text().toUShort();\n\tqsUsername = qleUsername->text().simplified();\n\tqsPassword = qlePassword->text();\n\n\t// For bonjour hosts disable the port field as it's auto-detected\n\tqlePort->setDisabled(!qsHostname.isEmpty() && qsHostname.startsWith(QLatin1Char('@')));\n\n\t// For SuperUser show password edit\n\tif (qsUsername.toLower() == QLatin1String(\"superuser\")) {\n\t\tqliPassword->setVisible(true);\n\t\tqlePassword->setVisible(true);\n\t\tqcbShowPassword->setVisible(true);\n\t\tadjustSize();\n\t} else if (qsPassword.isEmpty()) {\n\t\tqliPassword->setVisible(false);\n\t\tqlePassword->setVisible(false);\n\t\tqcbShowPassword->setVisible(false);\n\t\tadjustSize();\n\t}\n\n\tbOk = ! qsHostname.isEmpty() && ! qsUsername.isEmpty() && usPort;\n\tqdbbButtonBox->button(QDialogButtonBox::Ok)->setEnabled(bOk);\n}\n\nvoid ConnectDialogEdit::accept() {\n\tvalidate();\n\tif (bOk) {\n\t\tQString server = qleServer->text().simplified();\n\n\t\t// If the user accidentally added a schema or path part, drop it now.\n\t\t// We can't do so during editing as that is quite jarring.\n\t\tconst int schemaPos = server.indexOf(QLatin1String(\"://\"));\n\t\tif (schemaPos != -1) {\n\t\t\tserver.remove(0, schemaPos + 3);\n\t\t}\n\n\t\tconst int pathPos = server.indexOf(QLatin1Char('/'));\n\t\tif (pathPos != -1) {\n\t\t\tserver.resize(pathPos);\n\t\t}\n\n\t\tqleServer->setText(server);\n\n\t\tif (qleName->text().simplified().isEmpty() || !bCustomLabel) {\n\t\t\tqleName->setText(server);\n\t\t}\n\n\t\tQDialog::accept();\n\t}\n}\n\nvoid ConnectDialogEdit::on_qcbShowPassword_toggled(bool checked) {\n\tqlePassword->setEchoMode(checked ? QLineEdit::Normal : QLineEdit::Password);\n}\n\nConnectDialog::ConnectDialog(QWidget *p, bool autoconnect) : QDialog(p), bAutoConnect(autoconnect) {\n\tsetupUi(this);\n#ifdef Q_OS_MAC\n\tsetWindowModality(Qt::WindowModal);\n#endif\n\tbPublicInit = false;\n\n\tsiAutoConnect = NULL;\n\n\tbAllowPing = g.s.ptProxyType == Settings::NoProxy;\n\tbAllowHostLookup = g.s.ptProxyType == Settings::NoProxy;\n\tbAllowBonjour = g.s.ptProxyType == Settings::NoProxy;\n\tbAllowFilters = g.s.ptProxyType == Settings::NoProxy;\n\n\tif (tPublicServers.elapsed() >= 60 * 24 * 1000000ULL) {\n\t\tqlPublicServers.clear();\n\t}\n\n\tqdbbButtonBox->button(QDialogButtonBox::Ok)->setEnabled(false);\n\tqdbbButtonBox->button(QDialogButtonBox::Ok)->setText(tr(\"&Connect\"));\n\n\tQPushButton *qpbAdd = new QPushButton(tr(\"&Add New...\"), this);\n\tqpbAdd->setDefault(false);\n\tqpbAdd->setAutoDefault(false);\n\tconnect(qpbAdd, SIGNAL(clicked()), qaFavoriteAddNew, SIGNAL(triggered()));\n\tqdbbButtonBox->addButton(qpbAdd, QDialogButtonBox::ActionRole);\n\n\t\n\tqpbEdit = new QPushButton(tr(\"&Edit...\"), this);\n\tqpbEdit->setEnabled(false);\n\tqpbEdit->setDefault(false);\n\tqpbEdit->setAutoDefault(false);\n\tconnect(qpbEdit, SIGNAL(clicked()), qaFavoriteEdit, SIGNAL(triggered()));\n\tqdbbButtonBox->addButton(qpbEdit, QDialogButtonBox::ActionRole);\n\t\n\tqpbAdd->setHidden(g.s.disableConnectDialogEditing);\n\tqpbEdit->setHidden(g.s.disableConnectDialogEditing);\n\n\tqtwServers->setItemDelegate(new ServerViewDelegate());\n\n\t// Hide ping and user count if we are not allowed to ping.\n\tif (!bAllowPing) {\n\t\tqtwServers->setColumnCount(1);\n\t}\n\n\tqtwServers->sortItems(1, Qt::AscendingOrder);\n\n#if QT_VERSION >= 0x050000\n\tqtwServers->header()->setSectionResizeMode(0, QHeaderView::Stretch);\n\tif (qtwServers->columnCount() >= 2) {\n\t\tqtwServers->header()->setSectionResizeMode(1, QHeaderView::ResizeToContents);\n\t}\n\tif (qtwServers->columnCount() >= 3) {\n\t\tqtwServers->header()->setSectionResizeMode(2, QHeaderView::ResizeToContents);\n\t}\n#else\n\tqtwServers->header()->setResizeMode(0, QHeaderView::Stretch);\n\tif (qtwServers->columnCount() >= 2) {\n\t\tqtwServers->header()->setResizeMode(1, QHeaderView::ResizeToContents);\n\t}\n\tif (qtwServers->columnCount() >= 3) {\n\t\tqtwServers->header()->setResizeMode(2, QHeaderView::ResizeToContents);\n\t}\n#endif\n\n\tconnect(qtwServers->header(), SIGNAL(sortIndicatorChanged(int, Qt::SortOrder)), this, SLOT(OnSortChanged(int, Qt::SortOrder)));\n\n\tqaShowAll->setChecked(false);\n\tqaShowReachable->setChecked(false);\n\tqaShowPopulated->setChecked(false);\n\n\tif (bAllowFilters) {\n\t\tswitch (g.s.ssFilter) {\n\t\t\tcase Settings::ShowPopulated:\n\t\t\t\tqaShowPopulated->setChecked(true);\n\t\t\t\tbreak;\n\t\t\tcase Settings::ShowReachable:\n\t\t\t\tqaShowReachable->setChecked(true);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqaShowAll->setChecked(true);\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tqaShowAll->setChecked(true);\n\t}\n\n\tqagFilters = new QActionGroup(this);\n\tqagFilters->addAction(qaShowAll);\n\tqagFilters->addAction(qaShowReachable);\n\tqagFilters->addAction(qaShowPopulated);\n\n\tconnect(qagFilters, SIGNAL(triggered(QAction *)), this, SLOT(onFiltersTriggered(QAction *)));\n\n\tqmPopup = new QMenu(this);\n\tqmFilters = new QMenu(tr(\"&Filters\"), this);\n\tqmFilters->addAction(qaShowAll);\n\tqmFilters->addAction(qaShowReachable);\n\tqmFilters->addAction(qaShowPopulated);\n\n\tif (!bAllowFilters) {\n\t\tqmFilters->setEnabled(false);\n\t}\n\n\tQList<QTreeWidgetItem *> ql;\n\tQList<FavoriteServer> favorites = g.db->getFavorites();\n\n\tforeach(const FavoriteServer &fs, favorites) {\n\t\tServerItem *si = new ServerItem(fs);\n\t\tqlItems << si;\n\t\tstartDns(si);\n\t\tqtwServers->siFavorite->addServerItem(si);\n\t}\n\n#ifdef USE_BONJOUR\n\t// Make sure the we got the objects we need, then wire them up\n\tif (bAllowBonjour && g.bc->bsbBrowser && g.bc->bsrResolver) {\n\t\tconnect(g.bc->bsbBrowser, SIGNAL(error(DNSServiceErrorType)),\n\t\t        this, SLOT(onLanBrowseError(DNSServiceErrorType)));\n\t\tconnect(g.bc->bsbBrowser, SIGNAL(currentBonjourRecordsChanged(const QList<BonjourRecord> &)),\n\t\t        this, SLOT(onUpdateLanList(const QList<BonjourRecord> &)));\n\t\tconnect(g.bc->bsrResolver, SIGNAL(error(BonjourRecord, DNSServiceErrorType)),\n\t\t        this, SLOT(onLanResolveError(BonjourRecord, DNSServiceErrorType)));\n\t\tconnect(g.bc->bsrResolver, SIGNAL(bonjourRecordResolved(BonjourRecord, QString, int)),\n\t\t        this, SLOT(onResolved(BonjourRecord, QString, int)));\n\t\tonUpdateLanList(g.bc->bsbBrowser->currentRecords());\n\t}\n#endif\n\n\tqtPingTick = new QTimer(this);\n\tconnect(qtPingTick, SIGNAL(timeout()), this, SLOT(timeTick()));\n\n\tqusSocket4 = new QUdpSocket(this);\n\tqusSocket6 = new QUdpSocket(this);\n\tbIPv4 = qusSocket4->bind(QHostAddress(QHostAddress::Any), 0);\n\tbIPv6 = qusSocket6->bind(QHostAddress(QHostAddress::AnyIPv6), 0);\n\tconnect(qusSocket4, SIGNAL(readyRead()), this, SLOT(udpReply()));\n\tconnect(qusSocket6, SIGNAL(readyRead()), this, SLOT(udpReply()));\n\n\tif (qtwServers->siFavorite->isHidden()\n\t    && (!qtwServers->siLAN || qtwServers->siLAN->isHidden())\n\t    && qtwServers->siPublic != NULL) {\n\t\tqtwServers->siPublic->setExpanded(true);\n\t}\n\n\tiPingIndex = -1;\n\tqtPingTick->start(50);\n\n\tnew QShortcut(QKeySequence(QKeySequence::Copy), this, SLOT(on_qaFavoriteCopy_triggered()));\n\tnew QShortcut(QKeySequence(QKeySequence::Paste), this, SLOT(on_qaFavoritePaste_triggered()));\n\n\tqtwServers->setCurrentItem(NULL);\n\tbLastFound = false;\n\n\tqmPingCache = g.db->getPingCache();\n\n\tif (! g.s.qbaConnectDialogGeometry.isEmpty())\n\t\trestoreGeometry(g.s.qbaConnectDialogGeometry);\n\tif (! g.s.qbaConnectDialogHeader.isEmpty())\n\t\tqtwServers->header()->restoreState(g.s.qbaConnectDialogHeader);\n}\n\nConnectDialog::~ConnectDialog() {\n\tServerItem::qmIcons.clear();\n\n\tQList<FavoriteServer> ql;\n\tqmPingCache.clear();\n\n\tforeach(ServerItem *si, qlItems) {\n\t\tif (si->uiPing)\n\t\t\tqmPingCache.insert(UnresolvedServerAddress(si->qsHostname, si->usPort), si->uiPing);\n\n\t\tif (si->itType != ServerItem::FavoriteType)\n\t\t\tcontinue;\n\t\tql << si->toFavoriteServer();\n\t}\n\tg.db->setFavorites(ql);\n\tg.db->setPingCache(qmPingCache);\n\n\tg.s.qbaConnectDialogHeader = qtwServers->header()->saveState();\n\tg.s.qbaConnectDialogGeometry = saveGeometry();\n}\n\nvoid ConnectDialog::accept() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (bAllowHostLookup && si->qlAddresses.isEmpty()) || si->qsHostname.isEmpty()) {\n\t\tqWarning() << \"Invalid server\";\n\t\treturn;\n\t}\n\n\tqsPassword = si->qsPassword;\n\tqsServer = si->qsHostname;\n\tusPort = si->usPort;\n\n\tif (si->qsUsername.isEmpty()) {\n\t\tbool ok;\n\t\tQString defUserName = QInputDialog::getText(this, tr(\"Connecting to %1\").arg(si->qsName), tr(\"Enter username\"), QLineEdit::Normal, g.s.qsUsername, &ok).trimmed();\n\t\tif (! ok)\n\t\t\treturn;\n\t\tg.s.qsUsername = si->qsUsername = defUserName;\n\t}\n\n\tqsUsername = si->qsUsername;\n\n\tg.s.qsLastServer = si->qsName;\n\n\tQDialog::accept();\n}\n\nvoid ConnectDialog::OnSortChanged(int logicalIndex, Qt::SortOrder) {\n\tif (logicalIndex != 2) {\n\t\treturn;\n\t}\n\n\tforeach(ServerItem *si, qlItems) {\n\t\tif (si->uiPing && (si->uiPing != si->uiPingSort)) {\n\t\t\tsi->uiPingSort = si->uiPing;\n\t\t\tsi->setDatas();\n\t\t}\n\t}\n}\n\nvoid ConnectDialog::on_qaFavoriteAdd_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (si->itType == ServerItem::FavoriteType))\n\t\treturn;\n\n\tsi = new ServerItem(si);\n\tqtwServers->fixupName(si);\n\tqlItems << si;\n\tqtwServers->siFavorite->addServerItem(si);\n\tqtwServers->setCurrentItem(si);\n\tstartDns(si);\n}\n\nvoid ConnectDialog::on_qaFavoriteAddNew_triggered() {\n\tConnectDialogEdit *cde = new ConnectDialogEdit(this);\n\n\tif (cde->exec() == QDialog::Accepted) {\n\t\tServerItem *si = new ServerItem(cde->qsName, cde->qsHostname, cde->usPort, cde->qsUsername, cde->qsPassword);\n\t\tqlItems << si;\n\t\tqtwServers->siFavorite->addServerItem(si);\n\t\tqtwServers->setCurrentItem(si);\n\t\tstartDns(si);\n\t}\n\tdelete cde;\n}\n\nvoid ConnectDialog::on_qaFavoriteEdit_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (si->itType != ServerItem::FavoriteType))\n\t\treturn;\n\n\tQString host;\n\tif (! si->qsBonjourHost.isEmpty())\n\t\thost = QLatin1Char('@') + si->qsBonjourHost;\n\telse\n\t\thost = si->qsHostname;\n\n\tConnectDialogEdit *cde = new ConnectDialogEdit(this, si->qsName, host, si->qsUsername, si->usPort, si->qsPassword);\n\n\tif (cde->exec() == QDialog::Accepted) {\n\n\t\tsi->qsName = cde->qsName;\n\t\tsi->qsUsername = cde->qsUsername;\n\t\tsi->qsPassword = cde->qsPassword;\n\t\tif ((cde->qsHostname != host) || (cde->usPort != si->usPort)) {\n\t\t\tstopDns(si);\n\n\t\t\tsi->qlAddresses.clear();\n\t\t\tsi->reset();\n\n\t\t\tsi->usPort = cde->usPort;\n\n\t\t\tif (cde->qsHostname.startsWith(QLatin1Char('@'))) {\n\t\t\t\tsi->qsHostname = QString();\n\t\t\t\tsi->qsBonjourHost = cde->qsHostname.mid(1);\n\t\t\t\tsi->brRecord = BonjourRecord(si->qsBonjourHost, QLatin1String(\"_mumble._tcp.\"), QLatin1String(\"local.\"));\n\t\t\t} else {\n\t\t\t\tsi->qsHostname = cde->qsHostname;\n\t\t\t\tsi->qsBonjourHost = QString();\n\t\t\t\tsi->brRecord = BonjourRecord();\n\t\t\t}\n\t\t\tstartDns(si);\n\t\t}\n\t\tsi->setDatas();\n\t}\n\tdelete cde;\n}\n\nvoid ConnectDialog::on_qaFavoriteRemove_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || (si->itType != ServerItem::FavoriteType))\n\t\treturn;\n\n\tstopDns(si);\n\tqlItems.removeAll(si);\n\tdelete si;\n}\n\nvoid ConnectDialog::on_qaFavoriteCopy_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si)\n\t\treturn;\n\n\tQApplication::clipboard()->setMimeData(si->toMimeData());\n}\n\nvoid ConnectDialog::on_qaFavoritePaste_triggered() {\n\tServerItem *si = ServerItem::fromMimeData(QApplication::clipboard()->mimeData());\n\tif (! si)\n\t\treturn;\n\n\tqlItems << si;\n\tqtwServers->siFavorite->addServerItem(si);\n\tqtwServers->setCurrentItem(si);\n\tstartDns(si);\n}\n\nvoid ConnectDialog::on_qaUrl_triggered() {\n\tauto *si = static_cast< const ServerItem * >(qtwServers->currentItem());\n\tif (!si || si->qsUrl.isEmpty()) {\n\t\treturn;\n\t}\n\n\tconst QStringList allowedSchemes = { QLatin1String(\"http\"), QLatin1String(\"https\") };\n\n\tconst auto url = QUrl(si->qsUrl);\n\tif (allowedSchemes.contains(url.scheme())) {\n\t\tQDesktopServices::openUrl(url);\n\t} else {\n\t\t// Inform user that the requested URL has been blocked\n\t\tQMessageBox msgBox;\n\t\tmsgBox.setText(QObject::tr(\"<b>Blocked URL scheme \\\"%1\\\"</b>\").arg(url.scheme()));\n\t\tmsgBox.setInformativeText(QObject::tr(\"The URL uses a scheme that has been blocked for security reasons.\"));\n\t\tmsgBox.setDetailedText(QObject::tr(\"Blocked URL: \\\"%1\\\"\").arg(url.toString()));\n\t\tmsgBox.setIcon(QMessageBox::Warning);\n\t\tmsgBox.exec();\n\t}\n}\n\nvoid ConnectDialog::onFiltersTriggered(QAction *act) {\n\tif (act == qaShowAll)\n\t\tg.s.ssFilter = Settings::ShowAll;\n\telse if (act == qaShowReachable)\n\t\tg.s.ssFilter = Settings::ShowReachable;\n\telse if (act == qaShowPopulated)\n\t\tg.s.ssFilter = Settings::ShowPopulated;\n\n\tforeach(ServerItem *si, qlItems)\n\t\tsi->hideCheck();\n}\n\nvoid ConnectDialog::on_qtwServers_customContextMenuRequested(const QPoint &mpos) {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->itemAt(mpos));\n\tqmPopup->clear();\n\n\tif (si != NULL && si->bParent) {\n\t\tsi = NULL;\n\t}\n\t\n\tif (si != NULL) {\n\n\t\tif (!g.s.disableConnectDialogEditing) {\n\t\t\tif (si->itType == ServerItem::FavoriteType) {\n\t\t\t\tqmPopup->addAction(qaFavoriteEdit);\n\t\t\t\tqmPopup->addAction(qaFavoriteRemove);\n\t\t\t} else {\n\t\t\t\tqmPopup->addAction(qaFavoriteAdd);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!si->qsUrl.isEmpty()) {\n\t\t\tqmPopup->addAction(qaUrl);\n\t\t}\n\t}\n\t\n\tif (! qmPopup->isEmpty()) {\n\t\tqmPopup->addSeparator();\n\t}\n\t\n\tqmPopup->addMenu(qmFilters);\n\n\tqmPopup->popup(qtwServers->viewport()->mapToGlobal(mpos), NULL);\n}\n\nvoid ConnectDialog::on_qtwServers_itemDoubleClicked(QTreeWidgetItem *item, int) {\n\tqtwServers->setCurrentItem(item);\n\taccept();\n}\n\nvoid ConnectDialog::on_qtwServers_currentItemChanged(QTreeWidgetItem *item, QTreeWidgetItem *) {\n\tServerItem *si = static_cast<ServerItem *>(item);\n\n\tif (si->siParent == qtwServers->siFavorite) {\n\t\tqpbEdit->setEnabled(true);\n\t} else {\n\t\tqpbEdit->setEnabled(false);\n\t}\n\t\n\tbool bOk = !si->qlAddresses.isEmpty();\n\tif (!bAllowHostLookup) {\n\t\tbOk = true;\n\t}\n\tqdbbButtonBox->button(QDialogButtonBox::Ok)->setEnabled(bOk);\n\n\tbLastFound = true;\n}\n\nvoid ConnectDialog::on_qtwServers_itemExpanded(QTreeWidgetItem *item) {\n\tif (qtwServers->siPublic != NULL && item == qtwServers->siPublic) {\n\t\tinitList();\n\t\tfillList();\n\t}\n\n\tServerItem *p = static_cast<ServerItem *>(item);\n\n\tforeach(ServerItem *si, p->qlChildren)\n\t\tstartDns(si);\n}\n\nvoid ConnectDialog::initList() {\n\tif (bPublicInit || (qlPublicServers.count() > 0))\n\t\treturn;\n\n\tbPublicInit = true;\n\n\tQUrl url;\n\turl.setPath(QLatin1String(\"/v1/list\"));\n#if QT_VERSION >= 0x050000\n\tQUrlQuery query;\n\tquery.addQueryItem(QLatin1String(\"version\"), QLatin1String(MUMTEXT(MUMBLE_VERSION_STRING)));\n\turl.setQuery(query);\n#else\n\turl.addQueryItem(QLatin1String(\"version\"), QLatin1String(MUMTEXT(MUMBLE_VERSION_STRING)));\n#endif\n\n\tWebFetch::fetch(QLatin1String(\"publist\"), url, this, SLOT(fetched(QByteArray,QUrl,QMap<QString,QString>)));\n}\n\n#ifdef USE_BONJOUR\nvoid ConnectDialog::onResolved(BonjourRecord record, QString host, int port) {\n\tqlBonjourActive.removeAll(record);\n\tforeach(ServerItem *si, qlItems) {\n\t\tif (si->brRecord == record) {\n\t\t\tunsigned short usport = static_cast<unsigned short>(port);\n\t\t\tif ((host != si->qsHostname) || (usport != si->usPort)) {\n\t\t\t\tstopDns(si);\n\t\t\t\tsi->usPort = static_cast<unsigned short>(port);\n\t\t\t\tsi->qsHostname = host;\n\t\t\t\tstartDns(si);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ConnectDialog::onUpdateLanList(const QList<BonjourRecord> &list) {\n\tQSet<ServerItem *> items;\n\tQSet<ServerItem *> old = qtwServers->siLAN->qlChildren.toSet();\n\n\tforeach(const BonjourRecord &record, list) {\n\t\tbool found = false;\n\t\tforeach(ServerItem *si, old) {\n\t\t\tif (si->brRecord == record) {\n\t\t\t\titems.insert(si);\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (! found) {\n\t\t\tServerItem *si = new ServerItem(record);\n\t\t\tqlItems << si;\n\t\t\tg.bc->bsrResolver->resolveBonjourRecord(record);\n\t\t\tstartDns(si);\n\t\t\tqtwServers->siLAN->addServerItem(si);\n\t\t}\n\t}\n\tQSet<ServerItem *> remove = old.subtract(items);\n\tforeach(ServerItem *si, remove) {\n\t\tstopDns(si);\n\t\tqlItems.removeAll(si);\n\t\tdelete si;\n\t}\n}\n\nvoid ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {\n\tqWarning()<<\"Bonjour reported browser error \"<< err;\n}\n\nvoid ConnectDialog::onLanResolveError(BonjourRecord br, DNSServiceErrorType err) {\n\tqlBonjourActive.removeAll(br);\n\tqWarning()<<\"Bonjour reported resolver error \"<< err;\n}\n#endif\n\nvoid ConnectDialog::fillList() {\n\tQList<QTreeWidgetItem *> ql;\n\tQList<QTreeWidgetItem *> qlNew;\n\n\tforeach(const PublicInfo &pi, qlPublicServers) {\n\t\tbool found = false;\n\t\tforeach(ServerItem *si, qlItems) {\n\t\t\tif ((pi.qsIp == si->qsHostname) && (pi.usPort == si->usPort)) {\n\t\t\t\tsi->qsCountry = pi.qsCountry;\n\t\t\t\tsi->qsCountryCode = pi.qsCountryCode;\n\t\t\t\tsi->qsContinentCode = pi.qsContinentCode;\n\t\t\t\tsi->qsUrl = pi.quUrl.toString();\n\t\t\t\tsi->bCA = pi.bCA;\n\t\t\t\tsi->setDatas();\n\n\t\t\t\tif (si->itType == ServerItem::PublicType)\n\t\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\tif (! found)\n\t\t\tql << new ServerItem(pi);\n\t}\n\n\twhile (! ql.isEmpty()) {\n\t\tServerItem *si = static_cast<ServerItem *>(ql.takeAt(qrand() % ql.count()));\n\t\tqlNew << si;\n\t\tqlItems << si;\n\t}\n\n\tforeach(QTreeWidgetItem *qtwi, qlNew) {\n\t\tServerItem *si = static_cast<ServerItem *>(qtwi);\n\t\tServerItem *p = qtwServers->getParent(si->qsContinentCode, si->qsCountryCode, si->qsCountry, qsUserContinentCode, qsUserCountryCode);\n\t\tp->addServerItem(si);\n\n\t\tif (p->isExpanded() && p->parent()->isExpanded())\n\t\t\tstartDns(si);\n\t}\n}\n\nvoid ConnectDialog::timeTick() {\n\tif (! bLastFound && ! g.s.qsLastServer.isEmpty()) {\n\t\tQList<QTreeWidgetItem *> items = qtwServers->findItems(g.s.qsLastServer, Qt::MatchExactly | Qt::MatchRecursive);\n\t\tif (!items.isEmpty()) {\n\t\t\tbLastFound = true;\n\t\t\tqtwServers->setCurrentItem(items.at(0));\n\t\t\tif (g.s.bAutoConnect && bAutoConnect) {\n\t\t\t\tsiAutoConnect = static_cast<ServerItem *>(items.at(0));\n\t\t\t\tif (! siAutoConnect->qlAddresses.isEmpty()) {\n\t\t\t\t\taccept();\n\t\t\t\t\treturn;\n\t\t\t\t} else if (!bAllowHostLookup) {\n\t\t\t\t\taccept();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bAllowHostLookup) {\n\t\t// Start DNS Lookup of first unknown hostname\n\t\tforeach(const UnresolvedServerAddress &unresolved, qlDNSLookup) {\n\t\t\tif (qsDNSActive.contains(unresolved)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tqlDNSLookup.removeAll(unresolved);\n\t\t\tqlDNSLookup.append(unresolved);\n\n\t\t\tqsDNSActive.insert(unresolved);\n\t\t\tServerResolver *sr = new ServerResolver();\n\t\t\tQObject::connect(sr, SIGNAL(resolved()), this, SLOT(lookedUp()));\n\t\t\tsr->resolve(unresolved.hostname, unresolved.port);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tServerItem *current = static_cast<ServerItem *>(qtwServers->currentItem());\n\tServerItem *hover = static_cast<ServerItem *>(qtwServers->itemAt(qtwServers->viewport()->mapFromGlobal(QCursor::pos())));\n\n\tServerItem *si = NULL;\n\n\tif (tCurrent.elapsed() >= 1000000ULL)\n\t\tsi = current;\n\tif (! si && (tHover.elapsed() >= 1000000ULL))\n\t\tsi = hover;\n\n\tif (si) {\n\t\tQString hostname = si->qsHostname.toLower();\n\t\tunsigned short port = si->usPort;\n\t\tUnresolvedServerAddress unresolved(hostname, port);\n\n\t\tif (si->qlAddresses.isEmpty()) {\n\t\t\tif (! hostname.isEmpty()) {\n\t\t\t\tqlDNSLookup.removeAll(unresolved);\n\t\t\t\tqlDNSLookup.prepend(unresolved);\n\t\t\t}\n\t\t\tsi = NULL;\n\t\t}\n\t}\n\n\tif (!si) {\n\t\tif (qlItems.isEmpty())\n\t\t\treturn;\n\n\t\tbool expanded;\n\n\t\tdo {\n\t\t\t++iPingIndex;\n\t\t\tif (iPingIndex >= qlItems.count()) {\n\t\t\t\tif (tRestart.isElapsed(1000000ULL))\n\t\t\t\t\tiPingIndex = 0;\n\t\t\t\telse\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tsi = qlItems.at(iPingIndex);\n\n\t\t\tServerItem *p = si->siParent;\n\t\t\texpanded = true;\n\t\t\twhile (p && expanded) {\n\t\t\t\texpanded = expanded && p->isExpanded();\n\t\t\t\tp = p->siParent;\n\t\t\t}\n\t\t} while (si->qlAddresses.isEmpty() || ! expanded);\n\t}\n\n\tif (si == current)\n\t\ttCurrent.restart();\n\tif (si == hover)\n\t\ttHover.restart();\n\n\tforeach(const ServerAddress &addr, si->qlAddresses) {\n\t\tsendPing(addr.host.toAddress(), addr.port);\n\t}\n}\n\n\nvoid ConnectDialog::startDns(ServerItem *si) {\n\tif (!bAllowHostLookup) {\n\t\treturn;\n\t}\n\n\tQString hostname = si->qsHostname.toLower();\n\tunsigned short port = si->usPort;\n\tUnresolvedServerAddress unresolved(hostname, port);\n\n\tif (si->qlAddresses.isEmpty()) {\n\t\t// Determine if qsHostname is an IP address\n\t\t// or a hostname. If it is an IP address, we\n\t\t// can treat it as resolved as-is.\n\t\tQHostAddress qha(si->qsHostname);\n\t\tbool hostnameIsIPAddress = !qha.isNull();\n\t\tif (hostnameIsIPAddress) {\n\t\t\tsi->qlAddresses.append(ServerAddress(HostAddress(qha), port));\n\t\t} else {\n\t\t\tsi->qlAddresses = qhDNSCache.value(unresolved);\n\t\t}\n\t}\n\n\tif (qtwServers->currentItem() == si)\n\t\tqdbbButtonBox->button(QDialogButtonBox::Ok)->setEnabled(! si->qlAddresses.isEmpty());\n\n\tif (! si->qlAddresses.isEmpty()) {\n\t\tforeach(const ServerAddress &addr, si->qlAddresses) {\n\t\t\tqhPings[addr].insert(si);\n\t\t}\n\t\treturn;\n\t}\n\n#ifdef USE_BONJOUR\n\tif (bAllowBonjour && si->qsHostname.isEmpty() && ! si->brRecord.serviceName.isEmpty()) {\n\t\tif (! qlBonjourActive.contains(si->brRecord)) {\n\t\t\tg.bc->bsrResolver->resolveBonjourRecord(si->brRecord);\n\t\t\tqlBonjourActive.append(si->brRecord);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n\tif (! qhDNSWait.contains(unresolved)) {\n\t\tif (si->itType == ServerItem::PublicType)\n\t\t\tqlDNSLookup.append(unresolved);\n\t\telse\n\t\t\tqlDNSLookup.prepend(unresolved);\n\t}\n\tqhDNSWait[unresolved].insert(si);\n}\n\nvoid ConnectDialog::stopDns(ServerItem *si) {\n\tif (!bAllowHostLookup) {\n\t\treturn;\n\t}\n\n\tforeach(const ServerAddress &addr, si->qlAddresses) {\n\t\tif (qhPings.contains(addr)) {\n\t\t\tqhPings[addr].remove(si);\n\t\t\tif (qhPings[addr].isEmpty()) {\n\t\t\t\tqhPings.remove(addr);\n\t\t\t\tqhPingRand.remove(addr);\n\t\t\t}\n\t\t}\n\t}\n\n\tQString hostname = si->qsHostname.toLower();\n\tunsigned short port = si->usPort;\n\tUnresolvedServerAddress unresolved(hostname, port);\n\n\tif (qhDNSWait.contains(unresolved)) {\n\t\tqhDNSWait[unresolved].remove(si);\n\t\tif (qhDNSWait[unresolved].isEmpty()) {\n\t\t\tqhDNSWait.remove(unresolved);\n\t\t\tqlDNSLookup.removeAll(unresolved);\n\t\t}\n\t}\n}\n\nvoid ConnectDialog::lookedUp() {\n\tServerResolver *sr = qobject_cast<ServerResolver *>(QObject::sender());\n\tsr->deleteLater();\n\n\tQString hostname = sr->hostname().toLower();\n\tunsigned short port = sr->port();\n\tUnresolvedServerAddress unresolved(hostname, port);\n\n\tqsDNSActive.remove(unresolved);\n\n\t// An error occurred, or no records were found.\n\tif (sr->records().size() == 0) {\n\t\treturn;\n\t}\n\n\tQSet<ServerAddress> qs;\n\tforeach (ServerResolverRecord record, sr->records()) {\n\t\tforeach(const HostAddress &ha, record.addresses()) {\n\t\t\tqs.insert(ServerAddress(ha, record.port()));\n\t\t}\n\t}\n\n\tQSet<ServerItem *> waiting = qhDNSWait[unresolved];\n\tforeach(ServerItem *si, waiting) {\n\t\tforeach (const ServerAddress &addr, qs) {\n\t\t\tqhPings[addr].insert(si);\n\t\t}\n\n\t\tsi->qlAddresses = qs.toList();\n\t}\n\n\tqlDNSLookup.removeAll(unresolved);\n\tqhDNSCache.insert(unresolved, qs.toList());\n\tqhDNSWait.remove(unresolved);\n\n\tforeach(ServerItem *si, waiting) {\n\t\tif (si == qtwServers->currentItem()) {\n\t\t\ton_qtwServers_currentItemChanged(si, si);\n\t\t\tif (si == siAutoConnect)\n\t\t\t\taccept();\n\t\t}\n\t}\n\n\tif (bAllowPing) {\n\t\tforeach(const ServerAddress &addr, qs) {\n\t\t\tsendPing(addr.host.toAddress(), addr.port);\n\t\t}\n\t}\n}\n\nvoid ConnectDialog::sendPing(const QHostAddress &host, unsigned short port) {\n\tchar blob[16];\n\n\tServerAddress addr(HostAddress(host), port);\n\n\tquint64 uiRand;\n\tif (qhPingRand.contains(addr)) {\n\t\tuiRand = qhPingRand.value(addr);\n\t} else {\n\t\tuiRand = (static_cast<quint64>(qrand()) << 32) | static_cast<quint64>(qrand());\n\t\tqhPingRand.insert(addr, uiRand);\n\t}\n\n\tmemset(blob, 0, sizeof(blob));\n\t* reinterpret_cast<quint64 *>(blob+8) = tPing.elapsed() ^ uiRand;\n\n\tif (bIPv4 && host.protocol() == QAbstractSocket::IPv4Protocol)\n\t\tqusSocket4->writeDatagram(blob+4, 12, host, port);\n\telse if (bIPv6 && host.protocol() == QAbstractSocket::IPv6Protocol)\n\t\tqusSocket6->writeDatagram(blob+4, 12, host, port);\n\telse\n\t\treturn;\n\n\tconst QSet<ServerItem *> &qs = qhPings.value(addr);\n\n\tforeach(ServerItem *si, qs)\n\t\t++ si->uiSent;\n}\n\nvoid ConnectDialog::udpReply() {\n\tQUdpSocket *sock = qobject_cast<QUdpSocket *>(sender());\n\n\twhile (sock->hasPendingDatagrams()) {\n\t\tchar blob[64];\n\n\t\tQHostAddress host;\n\t\tunsigned short port;\n\n\t\tqint64 len = sock->readDatagram(blob+4, 24, &host, &port);\n\t\tif (len == 24) {\n\t\t\tif (host.scopeId() == QLatin1String(\"0\"))\n\t\t\t\thost.setScopeId(QLatin1String(\"\"));\n\n\t\t\tServerAddress address(HostAddress(host), port);\n\n\t\t\tif (qhPings.contains(address)) {\n\t\t\t\tquint32 *ping = reinterpret_cast<quint32 *>(blob+4);\n\t\t\t\tquint64 *ts = reinterpret_cast<quint64 *>(blob+8);\n\n\t\t\t\tquint64 elapsed = tPing.elapsed() - (*ts ^ qhPingRand.value(address));\n\n\t\t\t\tforeach(ServerItem *si, qhPings.value(address)) {\n\t\t\t\t\tsi->uiVersion = qFromBigEndian(ping[0]);\n\t\t\t\t\tquint32 users = qFromBigEndian(ping[3]);\n\t\t\t\t\tquint32 maxusers = qFromBigEndian(ping[4]);\n\t\t\t\t\tsi->uiBandwidth = qFromBigEndian(ping[5]);\n\n\t\t\t\t\tif (! si->uiPingSort)\n\t\t\t\t\t\tsi->uiPingSort = qmPingCache.value(UnresolvedServerAddress(si->qsHostname, si->usPort));\n\n\t\t\t\t\tsi->setDatas(static_cast<double>(elapsed), users, maxusers);\n\t\t\t\t\tsi->hideCheck();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid ConnectDialog::fetched(QByteArray xmlData, QUrl, QMap<QString, QString> headers) {\n\tif (xmlData.isNull()) {\n\t\tQMessageBox::warning(this, QLatin1String(\"Mumble\"), tr(\"Failed to fetch server list\"), QMessageBox::Ok);\n\t\treturn;\n\t}\n\n\tQDomDocument doc;\n\tdoc.setContent(xmlData);\n\n\tqlPublicServers.clear();\n\tqsUserCountry = headers.value(QLatin1String(\"Geo-Country\"));\n\tqsUserCountryCode = headers.value(QLatin1String(\"Geo-Country-Code\")).toLower();\n\tqsUserContinentCode = headers.value(QLatin1String(\"Geo-Continent-Code\")).toLower();\n\n\tQDomElement root=doc.documentElement();\n\tQDomNode n = root.firstChild();\n\twhile (!n.isNull()) {\n\t\tQDomElement e = n.toElement();\n\t\tif (!e.isNull()) {\n\t\t\tif (e.tagName() == QLatin1String(\"server\")) {\n\t\t\t\tPublicInfo pi;\n\t\t\t\tpi.qsName = e.attribute(QLatin1String(\"name\"));\n\t\t\t\tpi.quUrl = e.attribute(QLatin1String(\"url\"));\n\t\t\t\tpi.qsIp = e.attribute(QLatin1String(\"ip\"));\n\t\t\t\tpi.usPort = e.attribute(QLatin1String(\"port\")).toUShort();\n\t\t\t\tpi.qsCountry = e.attribute(QLatin1String(\"country\"), tr(\"Unknown\"));\n\t\t\t\tpi.qsCountryCode = e.attribute(QLatin1String(\"country_code\")).toLower();\n\t\t\t\tpi.qsContinentCode = e.attribute(QLatin1String(\"continent_code\")).toLower();\n\t\t\t\tpi.bCA = e.attribute(QLatin1String(\"ca\")).toInt() ? true : false;\n\n\t\t\t\tqlPublicServers << pi;\n\t\t\t}\n\t\t}\n\t\tn = n.nextSibling();\n\t}\n\n\ttPublicServers.restart();\n\n\tfillList();\n}\n"], "filenames": ["src/mumble/ConnectDialog.cpp"], "buggy_code_start_loc": [1268], "buggy_code_end_loc": [1273], "fixing_code_start_loc": [1268], "fixing_code_end_loc": [1287], "type": "CWE-59", "message": "Mumble before 1.3.4 allows remote code execution if a victim navigates to a crafted URL on a server list and clicks on the Open Webpage text.", "other": {"cve": {"id": "CVE-2021-27229", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-16T04:15:12.733", "lastModified": "2022-05-06T21:00:06.523", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Mumble before 1.3.4 allows remote code execution if a victim navigates to a crafted URL on a server list and clicks on the Open Webpage text."}, {"lang": "es", "value": "Mumble versiones anteriores a 1.3.4, permite una ejecuci\u00f3n de c\u00f3digo remota si una v\u00edctima navega hacia una URL dise\u00f1ada en una lista de servidores y hace clic sobre el texto Open Webpage"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mumble:mumble:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.4", "matchCriteriaId": "C23B5471-A5C4-4024-89B8-373397CA9204"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/mumble-voip/mumble/commit/e59ee87abe249f345908c7d568f6879d16bfd648", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mumble-voip/mumble/compare/1.3.3...1.3.4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mumble-voip/mumble/pull/4733", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/02/msg00022.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202105-13", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mumble-voip/mumble/commit/e59ee87abe249f345908c7d568f6879d16bfd648"}}