{"buggy_code": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\n  Copyright \u00a9 2008-2012 Joel Schaerer\n  Copyright \u00a9 2012      William Ting\n\n  *  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 3, or (at your option)\n  any later version.\n\n  *  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  *  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n\"\"\"\n\nfrom __future__ import division, print_function\n\nimport sys\nimport os\ntry:\n    import argparse\nexcept ImportError:\n    sys.path.append(os.path.dirname(os.path.realpath(__file__)))\n    import autojump_argparse as argparse\n    sys.path.pop()\nfrom operator import itemgetter\nimport re\nimport shutil\nfrom tempfile import NamedTemporaryFile\n\nVERSION = 'release-v21.5.5'\nMAX_KEYWEIGHT = 1000\nMAX_STORED_PATHS = 1000\nCOMPLETION_SEPARATOR = '__'\nARGS = None\n\nCONFIG_DIR = None\nDB_FILE = None\nTESTING = False\n\n# load config from environmental variables\nif 'AUTOJUMP_DATA_DIR' in os.environ:\n    CONFIG_DIR = os.environ.get('AUTOJUMP_DATA_DIR')\nelse:\n    xdg_data_dir = os.environ.get('XDG_DATA_HOME') or \\\n        os.path.join(os.environ['HOME'], '.local', 'share')\n    CONFIG_DIR = os.path.join(xdg_data_dir, 'autojump')\n\nKEEP_ALL_ENTRIES = False\nif 'AUTOJUMP_KEEP_ALL_ENTRIES' in os.environ and \\\n        os.environ.get('AUTOJUMP_KEEP_ALL_ENTRIES') == '1':\n    KEEP_ALL_ENTRIES = True\n\nALWAYS_IGNORE_CASE = False\nif 'AUTOJUMP_IGNORE_CASE' in os.environ and \\\n        os.environ.get('AUTOJUMP_IGNORE_CASE') == '1':\n    ALWAYS_IGNORE_CASE = True\n\nKEEP_SYMLINKS = False\nif 'AUTOJUMP_KEEP_SYMLINKS' in os.environ and \\\n        os.environ.get('AUTOJUMP_KEEP_SYMLINKS') == '1':\n    KEEP_SYMLINKS = True\n\nif CONFIG_DIR == os.path.expanduser('~'):\n    DB_FILE = CONFIG_DIR + '/.autojump.txt'\nelse:\n    DB_FILE = CONFIG_DIR + '/autojump.txt'\n\nclass Database:\n    \"\"\"\n    Object for interfacing with autojump database.\n    \"\"\"\n\n    def __init__(self, filename):\n        self.filename = filename\n        self.data = {}\n        self.load()\n\n    def __len__(self):\n        return len(self.data)\n\n    def add(self, path, increment = 10):\n        \"\"\"\n        Increase weight of existing paths or initialize new ones to 10.\n        \"\"\"\n        path = path.rstrip(os.sep)\n        if path not in self.data:\n            self.data[path] = increment\n        else:\n            import math\n            self.data[path] = math.sqrt((self.data[path]**2) + (increment**2))\n        self.save()\n\n    def decrease(self, path, increment = 15):\n        \"\"\"\n        Decrease weight of existing path. Unknown ones are ignored.\n        \"\"\"\n        if path in self.data:\n            if self.data[path] < increment:\n                self.data[path] = 0\n            else:\n                self.data[path] -= increment\n            self.save()\n\n    def decay(self):\n        \"\"\"\n        Decay database entries.\n        \"\"\"\n        for k in self.data.keys():\n            self.data[k] *= 0.9\n\n    def get_weight(self, path):\n        \"\"\"\n        Return path weight.\n        \"\"\"\n        if path in self.data:\n            return self.data[path]\n        else:\n            return 0\n\n    def load(self, error_recovery = False):\n        \"\"\"\n        Try to open the database file, recovering from backup if needed.\n        \"\"\"\n        if os.path.exists(self.filename):\n            try:\n                if sys.version_info >= (3, 0):\n                    with open(self.filename, 'r', encoding = 'utf-8') as f:\n                        for line in f.readlines():\n                            weight, path = line[:-1].split(\"\\t\", 1)\n                            path = decode(path, 'utf-8')\n                            self.data[path] = float(weight)\n                else:\n                    with open(self.filename, 'r') as f:\n                        for line in f.readlines():\n                            weight, path = line[:-1].split(\"\\t\", 1)\n                            path = decode(path, 'utf-8')\n                            self.data[path] = float(weight)\n            except (IOError, EOFError):\n                self.load_backup(error_recovery)\n        else:\n            self.load_backup(error_recovery)\n\n    def load_backup(self, error_recovery = False):\n        \"\"\"\n        Loads database from backup file.\n        \"\"\"\n        if os.path.exists(self.filename + '.bak'):\n            if not error_recovery:\n                print('Problem with autojump database,\\\n                        trying to recover from backup...', file=sys.stderr)\n                shutil.copy(self.filename + '.bak', self.filename)\n                return self.load(True)\n\n    def maintenance(self):\n        \"\"\"\n        Trims and decays database entries when exceeding settings.\n        \"\"\"\n        if sum(self.data.values()) > MAX_KEYWEIGHT:\n            self.decay()\n        if len(self.data) > MAX_STORED_PATHS:\n            self.trim()\n        self.save()\n\n    def purge(self):\n        \"\"\"\n        Deletes all entries that no longer exist on system.\n        \"\"\"\n        removed = []\n        for path in list(self.data.keys()):\n            if not os.path.exists(path):\n                removed.append(path)\n                del self.data[path]\n        self.save()\n        return removed\n\n    def save(self):\n        \"\"\"\n        Save database atomically and preserve backup, creating new database if\n        needed.\n        \"\"\"\n        # check file existence and permissions\n        if ((not os.path.exists(self.filename)) or\n                os.name == 'nt' or\n                os.getuid() == os.stat(self.filename)[4]):\n            temp = NamedTemporaryFile(dir = CONFIG_DIR, delete = False)\n            for path, weight in sorted(self.data.items(),\n                    key=itemgetter(1),\n                    reverse=True):\n                temp.write((unico(\"%s\\t%s\\n\" % (weight, path)).encode(\"utf-8\")))\n\n            # catching disk errors and skipping save when file handle can't\n            # be closed.\n            try:\n                # http://thunk.org/tytso/blog/2009/03/15/dont-fear-the-fsync/\n                temp.flush()\n                os.fsync(temp)\n                temp.close()\n            except IOError as ex:\n                print(\"Error saving autojump database (disk full?)\" %\n                        ex, file=sys.stderr)\n                return\n\n            shutil.move(temp.name, self.filename)\n            try: # backup file\n                import time\n                if (not os.path.exists(self.filename+\".bak\") or\n                        time.time()-os.path.getmtime(self.filename+\".bak\") \\\n                                > 86400):\n                    shutil.copy(self.filename, self.filename+\".bak\")\n            except OSError as ex:\n                print(\"Error while creating backup autojump file. (%s)\" %\n                        ex, file=sys.stderr)\n\n    def trim(self, percent=0.1):\n        \"\"\"\n        If database has exceeded MAX_STORED_PATHS, removes bottom 10%.\n        \"\"\"\n        dirs = list(self.data.items())\n        dirs.sort(key=itemgetter(1))\n        remove_cnt = int(percent * len(dirs))\n        for path, _ in dirs[:remove_cnt]:\n            del self.data[path]\n\n\ndef options():\n    \"\"\"\n    Parse command line options.\n    \"\"\"\n    global ARGS\n\n    parser = argparse.ArgumentParser(\n            description='Automatically jump to \\\n            directory passed as an argument.',\n            epilog=\"Please see autojump(1) man pages for full documentation.\")\n    parser.add_argument(\n            'directory', metavar='DIRECTORY', nargs='*', default='',\n            help='directory to jump to')\n    parser.add_argument(\n            '-a', '--add', '--increase', metavar='DIRECTORY',\n            help='manually add path to database, or increase path weight for \\\n            existing paths')\n    parser.add_argument(\n            '-d', '--decrease', metavar='WEIGHT', nargs='?', type=int,\n            const=15, default=False,\n            help='manually decrease path weight in database')\n    parser.add_argument(\n            '-b', '--bash', action=\"store_true\", default=False,\n            help='enclose directory quotes to prevent errors')\n    parser.add_argument(\n            '--complete', action=\"store_true\", default=False,\n            help='used for tab completion')\n    parser.add_argument(\n            '--purge', action=\"store_true\", default=False,\n            help='delete all database entries that no longer exist on system')\n    parser.add_argument(\n            '-s', '--stat', action=\"store_true\", default=False,\n            help='show database entries and their key weights')\n    parser.add_argument(\n            '-v', '--version', action=\"version\", version=\"%(prog)s \" + VERSION,\n            help='show version information and exit')\n\n    ARGS = parser.parse_args()\n\n    # The home dir can be reached quickly by \"cd\" and may interfere with other\n    # directories\n    if (ARGS.add):\n        if(ARGS.add != os.path.expanduser(\"~\")):\n            db = Database(DB_FILE)\n            db.add(decode(ARGS.add))\n        return True\n\n    if (ARGS.decrease):\n        if(ARGS.decrease != os.path.expanduser(\"~\")):\n            db = Database(DB_FILE)\n            # FIXME: handle symlinks?\n            db.decrease(os.getcwd(), ARGS.decrease)\n        return True\n\n    if (ARGS.purge):\n        db = Database(DB_FILE)\n        removed = db.purge()\n        if len(removed) > 0:\n            for dir in removed:\n                output(unico(dir))\n        print(\"Number of database entries removed: %d\" % len(removed))\n        return True\n\n    if (ARGS.stat):\n        db = Database(DB_FILE)\n        dirs = list(db.data.items())\n        dirs.sort(key=itemgetter(1))\n        for path, count in dirs[-100:]:\n            output(unico(\"%.1f:\\t%s\") % (count, path))\n\n        print(\"________________________________________\\n\")\n        print(\"%d:\\t total key weight\" % sum(db.data.values()))\n        print(\"%d:\\t stored directories\" % len(dirs))\n        print(\"db file: %s\" % DB_FILE)\n        return True\n    return False\n\ndef decode(text, encoding=None, errors=\"strict\"):\n    \"\"\"\n    Decoding step for Python 2 which does not default to unicode.\n    \"\"\"\n    if sys.version_info[0] > 2:\n        return text\n    else:\n        if encoding is None:\n            encoding = sys.getfilesystemencoding()\n        return text.decode(encoding, errors)\n\ndef output(unicode_text, encoding=None):\n    \"\"\"\n    Wrapper for the print function, using the filesystem encoding by default\n    to minimize encoding mismatch problems in directory names.\n    \"\"\"\n    if sys.version_info[0] > 2:\n        print(unicode_text)\n    else:\n        if encoding is None:\n            encoding = sys.getfilesystemencoding()\n        print(unicode_text.encode(encoding))\n\ndef unico(text):\n    \"\"\"\n    If Python 2, convert to a unicode object.\n    \"\"\"\n    if sys.version_info[0] > 2:\n        return text\n    else:\n        return unicode(text)\n\ndef match_last(pattern):\n    \"\"\"\n    If the last pattern contains a full path, jump there.\n    The regexp is because we need to support stuff like\n    \"j wo jo__3__/home/joel/workspace/joel\" for zsh.\n    \"\"\"\n    last_pattern_path = re.sub(\"(.*)\"+COMPLETION_SEPARATOR, \"\", pattern[-1])\n    if (len(last_pattern_path) > 0 and\n            last_pattern_path[0] == \"/\" and\n            os.path.exists(last_pattern_path)):\n        if not ARGS.complete:\n            output(last_pattern_path)\n            return True\n    return False\n\ndef match(path, pattern, only_end=False, ignore_case=False):\n    \"\"\"\n    Check whether a path matches a particular pattern, and return\n    the remaining part of the string.\n    \"\"\"\n    if only_end:\n        match_path = \"/\".join(path.split('/')[-1-pattern.count('/'):])\n    else:\n        match_path = path\n\n    if ignore_case:\n        match_path = match_path.lower()\n        pattern = pattern.lower()\n\n    find_idx = match_path.find(pattern)\n    # truncate path to avoid matching a pattern multiple times\n    if find_idx != -1:\n        return (True, path)\n    else:\n        return (False, path[find_idx+len(pattern):])\n\ndef find_matches(db, patterns, max_matches=1, ignore_case=False, fuzzy=False):\n    \"\"\"\n    Find max_matches paths that match the pattern, and add them to the\n    result_list.\n    \"\"\"\n    try:\n        current_dir = decode(os.path.realpath(os.curdir))\n    except OSError:\n        current_dir = None\n\n    dirs = list(db.data.items())\n    dirs.sort(key=itemgetter(1), reverse=True)\n    results = []\n    if fuzzy:\n        from difflib import get_close_matches\n\n        # create dictionary of end paths to compare against\n        end_dirs = {}\n        for d in dirs:\n            if ignore_case:\n                end = d[0].split('/')[-1].lower()\n            else:\n                end = d[0].split('/')[-1]\n\n            # collisions: ignore lower weight paths\n            if end not in end_dirs:\n                end_dirs[end] = d[0]\n\n        # find the first match (heighest weight)\n        while True:\n            found = get_close_matches(patterns[-1], end_dirs, n=1, cutoff=.6)\n            if not found:\n                break\n            # avoid jumping to current directory\n            if (os.path.exists(found[0]) or TESTING) and \\\n                current_dir != os.path.realpath(found[0]):\n                break\n            # continue with the last found directory removed\n            del end_dirs[found[0]]\n\n        if found:\n            found = found[0]\n            results.append(end_dirs[found])\n            return results\n        else:\n            return []\n\n    current_dir_match = False\n    for path, _ in dirs:\n        found, tmp = True, path\n        for n, p in enumerate(patterns):\n            # for single/last pattern, only check end of path\n            if n == len(patterns)-1:\n                found, tmp = match(tmp, p, True, ignore_case)\n            else:\n                found, tmp = match(tmp, p, False, ignore_case)\n            if not found: break\n\n        if found and (os.path.exists(path) or TESTING):\n            # avoid jumping to current directory\n            # (call out to realpath this late to not stat all dirs)\n            if current_dir == os.path.realpath(path):\n                current_dir_match = True\n                continue\n\n            if path not in results:\n                results.append(path)\n            if len(results) >= max_matches:\n                break\n\n    # if current directory is the only match, add it to results\n    if len(results) == 0 and current_dir_match:\n        results.append(current_dir)\n\n    return results\n\ndef shell_utility():\n    \"\"\"\n    Run this when autojump is called as a shell utility.\n    \"\"\"\n    if options(): return True\n    db = Database(DB_FILE)\n\n    # if no directories, add empty string\n    if (ARGS.directory == ''):\n        patterns = [unico('')]\n    else:\n        patterns = [decode(a) for a in ARGS.directory]\n\n    # check last pattern for full path\n    # FIXME: disabled until zsh tab completion is fixed on the shell side\n    # if match_last(patterns): return True\n\n    # check for tab completion\n    tab_choice = -1\n    tab_match = re.search(COMPLETION_SEPARATOR+\"([0-9]+)\", patterns[-1])\n    if tab_match: # user has selected a tab completion entry\n        tab_choice = int(tab_match.group(1))\n        patterns[-1] = re.sub(COMPLETION_SEPARATOR+\"[0-9]+.*\", \"\", patterns[-1])\n    else: # user hasn't selected a tab completion, display choices again\n        tab_match = re.match(\"(.*)\"+COMPLETION_SEPARATOR, patterns[-1])\n        if tab_match:\n            patterns[-1] = tab_match.group(1)\n\n    # on tab completion always show all results\n    if ARGS.complete or tab_choice != -1:\n        max_matches = 9\n    else:\n        max_matches = 1\n\n    results = []\n    if not ALWAYS_IGNORE_CASE:\n        results = find_matches(db, patterns, max_matches, ignore_case=False)\n\n    # if no results, try ignoring case\n    if ARGS.complete or not results:\n        results = find_matches(db, patterns, max_matches, ignore_case=True)\n\n    # if no results, try approximate matching\n    if not results:\n        results = find_matches(db, patterns, max_matches, ignore_case=True,\n                fuzzy=True)\n\n    quotes = \"\"\n    if ARGS.complete and ARGS.bash: quotes = \"'\"\n\n    if tab_choice != -1:\n        if len(results) > tab_choice-1:\n            output(unico(\"%s%s%s\") % (quotes,results[tab_choice-1],quotes))\n    elif len(results) > 1 and ARGS.complete:\n        output(\"\\n\".join((\"%s%s%d%s%s\" % (patterns[-1],\n            COMPLETION_SEPARATOR, n+1, COMPLETION_SEPARATOR, r)\n            for n, r in enumerate(results[:8]))))\n    elif results:\n        output(unico(\"%s%s%s\")%(quotes,results[0],quotes))\n    else:\n        return False\n\n    if not KEEP_ALL_ENTRIES:\n        db.maintenance()\n\n    return True\n\nif __name__ == \"__main__\":\n    if not shell_utility():\n        sys.exit(1)\n", "# source autojump on BASH or ZSH depending on the shell\n\nshell=`echo ${SHELL} | awk -F/ '{ print $NF }'`\n\n# prevent circular loop for sh shells\nif [ \"${shell}\" = \"sh\" ]; then\n\treturn 0\n\n# check local install\nelif [ -s ~/.autojump/etc/profile.d/autojump.${shell} ]; then\n\tsource ~/.autojump/etc/profile.d/autojump.${shell}\n\n# check global install\nelif [ -s /etc/profile.d/autojump.${shell} ]; then\n\tsource /etc/profile.d/autojump.${shell}\n\n# check custom install locations (modified by Homebrew or using --destdir option)\nelif [ -s custom_install/autojump.${shell} ]; then\n\tsource custom_install/autojump.${shell}\n\nfi\n", "#!/usr/bin/env bash\n\nfunction help_msg {\n    echo \"./install.sh [OPTION..]\"\n    echo\n    echo \" -a, --auto           Try to determine destdir, prefix (and zshshare if applicable)\"\n    echo \" -g, --global         Use default global settings (destdir=/; prefix=usr)\"\n    echo \" -l, --local          Use default local settings (destdir=~/.autojump)\"\n    echo\n    echo \" -d, --destdir PATH   Set install destination to PATH\"\n    echo \" -p, --prefix PATH    Use PATH as prefix\"\n    echo \" -Z, --zshshare PATH  Use PATH as zsh share destination\"\n    echo\n    echo \" -f, --force          Ignore Python version check\"\n    echo \" -n, --dry_run        Only show installation paths, don't install anything\"\n    echo\n    echo \"Will install autojump into:\"\n    echo\n    echo ' Binaries:        $destdir$prefix/bin'\n    echo ' Documentation:   $destdir$prefix/share/man/man1'\n    echo ' Icon:            $destdir$prefix/share/autojump'\n    echo ' Shell scripts:   $destdir/etc/profile.d'\n    echo ' zsh functions:   $destdir$zshsharedir'\n    echo\n    echo 'Unless specified, $zshshare will be :'\n    echo ' - $destdir$prefix/functions for local installations'\n    echo ' - $destdir$prefix/share/zsh/site-functions for all other installations'\n}\n\ndry_run=\nlocal=\nglobal=\nforce=\nshell=`echo ${SHELL} | awk -F/ '{ print $NF }'`\ndestdir=\nprefix=\"usr/local\"\nzshsharedir=\n\n# If no arguments passed, default to --auto.\nif [[ ${#} == 0 ]]; then\n    set -- \"--auto\"\nfi\n\n# Only dry-run should also default to --auto\nif [[ ${#} == 1 ]] && ([[ $1 = \"-n\" ]] || [[ $1 = \"--dry-run\" ]]); then\n    set -- \"-n\" \"--auto\"\nfi\n\n# Command line parsing\nwhile true; do\n    case \"$1\" in\n        -a|--auto)\n            if [[ ${UID} -eq 0 ]]; then\n                set -- \"--global\" \"${@:2}\"\n            else\n                set -- \"--local\" \"${@:2}\"\n            fi\n            ;;\n        -d|--destdir)\n            if [ $# -gt 1 ]; then\n                destdir=$2; shift 2\n            else\n                echo \"--destdir or -d requires an argument\" 1>&2\n            fi\n            ;;\n        -f|--force)\n            force=true\n            shift\n            if [[ ${#} == 0 ]]; then\n                set -- \"--auto\"\n            fi\n            ;;\n        -g|--global)\n            global=true\n            destdir=\n            prefix=usr\n            shift\n            ;;\n        -h|--help|-\\?)\n            help_msg;\n            exit 0\n            ;;\n        -l|--local)\n            local=true\n            destdir=~/.autojump\n            prefix=\n            shift\n            ;;\n        -n|--dry_run)\n            dry_run=true\n            shift\n            ;;\n        -p|--prefix)\n            if [ $# -gt 1 ]; then\n                prefix=$2; shift 2\n            else\n                echo \"--prefix or -p requires an argument\" 1>&2\n                exit 1\n            fi\n            ;;\n        -Z|--zshshare)\n            if [ $# -gt 1 ]; then\n                zshsharedir=$2; shift 2\n            else\n                echo \"--zshshare or -Z requires an argument\" 1>&2\n                exit 1\n            fi\n            ;;\n        --)\n            shift\n            break\n            ;;\n        -*)\n            echo \"invalid option: $1\" 1>&2;\n            help_msg;\n            exit 1\n            ;;\n        *)\n            break\n            ;;\n    esac\ndone\n\n# destdir must be a full path, and end with a slash\nif [[ -n ${destdir} ]]; then\n    if [[ ${destdir:0:1} != \"/\" ]]; then\n        echo \"Error: destdir must be a full path\" 1>&2\n        exit 1\n    fi\n    len=${#destdir}\n    if [[ ${destdir:len - 1} != \"/\" ]]; then\n        destdir=\"$destdir/\"\n    fi\nelse\n    destdir=\"/\"\nfi\n\n# prefix should not start with, and end with, a slash\nif [[ -n ${prefix} ]]; then\n    if [[ ${prefix:0:1} == \"/\" ]]; then\n        prefix=${prefix:1}\n    fi\n    len=${#prefix}\n    if [[ ${prefix:len - 1} != \"/\" ]]; then\n        prefix=\"$prefix/\"\n    fi\nfi\n\n# check shell support\nif [[ ${shell} != \"bash\" ]] && [[ ${shell} != \"zsh\" ]]; then\n    echo \"Unsupported shell (${shell}). Only Bash and Zsh shells are supported.\"\n    exit 1\nfi\n\n# zsh functions\nif [[ $shell == \"zsh\" ]]; then\n    if [[ -z $zshsharedir ]]; then\n        # if not set, use a default\n        if [[ $local ]]; then\n            zshsharedir=\"${prefix}functions\"\n        else\n            zshsharedir=\"${prefix}share/zsh/site-functions\"\n        fi\n    fi\nfi\n\n# check Python version\nif [ ! ${force} ]; then\n    python_version=`python -c 'import sys; print(sys.version_info[:])'`\n\n    if [[ ${python_version:1:1} -eq 2 && ${python_version:4:1} -lt 6 ]]; then\n        echo\n        echo \"Incompatible Python version, please upgrade to v2.6+.\"\n        if [[ ${python_version:4:1} -ge 4 ]]; then\n            echo\n            echo \"Alternatively, you can download v12 that supports Python v2.4+ from:\"\n            echo\n            echo -e \"\\thttps://github.com/joelthelion/autojump/downloads\"\n            echo\n        fi\n        exit 1\n    fi\nfi\n\necho\necho \"Installating autojump...\"\necho\necho \"Destination:      $destdir\"\nif [[ -n $prefix ]]; then\n    echo \"Prefix:           /$prefix\"\nfi\necho\necho \"Binary:           ${destdir}${prefix}bin/\"\necho \"Documentation:    ${destdir}${prefix}share/man/man1/\"\necho \"Icon:             ${destdir}${prefix}share/autojump/\"\necho \"Shell scripts:    ${destdir}etc/profile.d/\"\nif [[ -z $shell ]] || [[ $shell == \"zsh\" ]]; then\n    echo \"zsh functions:    ${destdir}${zshsharedir}\"\nfi\necho\n\nif [[ $dry_run ]]; then\n    echo \"--dry_run (-n) used, stopping\"\n    exit\nfi\n\n# INSTALL AUTOJUMP\nmkdir -p ${destdir}${prefix}share/autojump/ || exit 1\nmkdir -p ${destdir}${prefix}bin/ || exit 1\nmkdir -p ${destdir}${prefix}share/man/man1/ || exit 1\ncp -v ./bin/icon.png ${destdir}${prefix}share/autojump/ || exit 1\ncp -v ./bin/autojump ${destdir}${prefix}bin/ || exit 1\ncp -v ./bin/autojump_argparse.py ${destdir}${prefix}bin/ || exit 1\ncp -v ./docs/autojump.1 ${destdir}${prefix}share/man/man1/ || exit 1\nmkdir -p ${destdir}etc/profile.d/ || exit 1\ncp -v ./bin/autojump.sh ${destdir}etc/profile.d/ || exit 1\ncp -v ./bin/autojump.bash ${destdir}etc/profile.d/ || exit 1\ncp -v ./bin/autojump.zsh ${destdir}etc/profile.d/ || exit 1\nmkdir -p ${destdir}${zshsharedir} || exit 1\n# TODO: remove unused _j function (2013.02.01_1348, ting)\ninstall -v -m 0755 ./bin/_j ${destdir}${zshsharedir} || exit 1\n\n# MODIFY AUTOJUMP.SH FOR CUSTOM INSTALLS\nif [[ -z ${local} ]] && [[ -z ${global} ]]; then\n    sed -i \"s:custom_install:${destdir}etc/profile.d:g\" ${destdir}etc/profile.d/autojump.sh\nfi\n\n# DISPLAY ADD MESSAGE\nrc_file=\"~/.${shell}rc\"\nif [[ `uname` == \"Darwin\" ]] && [[ ${shell} == \"bash\" ]]; then\n    rc_file=\"~/.bash_profile\"\nfi\n\naj_shell_file=\"${destdir}etc/profile.d/autojump.sh\"\nif [[ ${local} ]]; then\n    aj_shell_file=\"~/.autojump/etc/profile.d/autojump.sh\"\nfi\n\necho\necho \"Please add the line to ${rc_file} :\"\necho\necho -e \"[[ -s ${aj_shell_file} ]] && . ${aj_shell_file}\"\necho\necho \"You need to run 'source ${rc_file}' before you can start using autojump. To remove autojump, run './uninstall.sh'\"\necho\n"], "fixing_code": ["#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\n  Copyright \u00a9 2008-2012 Joel Schaerer\n  Copyright \u00a9 2012      William Ting\n\n  *  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 3, or (at your option)\n  any later version.\n\n  *  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  *  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n\"\"\"\n\nfrom __future__ import division, print_function\n\nimport sys\nimport os\ntry:\n    import argparse\nexcept ImportError:\n    sys.path.append(os.path.dirname(os.path.realpath(__file__)))\n    import autojump_argparse as argparse\n    sys.path.pop()\nfrom operator import itemgetter\nimport re\nimport shutil\nfrom tempfile import NamedTemporaryFile\n\nVERSION = 'release-v21.5.6'\nMAX_KEYWEIGHT = 1000\nMAX_STORED_PATHS = 1000\nCOMPLETION_SEPARATOR = '__'\nARGS = None\n\nCONFIG_DIR = None\nDB_FILE = None\nTESTING = False\n\n# load config from environmental variables\nif 'AUTOJUMP_DATA_DIR' in os.environ:\n    CONFIG_DIR = os.environ.get('AUTOJUMP_DATA_DIR')\nelse:\n    xdg_data_dir = os.environ.get('XDG_DATA_HOME') or \\\n        os.path.join(os.environ['HOME'], '.local', 'share')\n    CONFIG_DIR = os.path.join(xdg_data_dir, 'autojump')\n\nKEEP_ALL_ENTRIES = False\nif 'AUTOJUMP_KEEP_ALL_ENTRIES' in os.environ and \\\n        os.environ.get('AUTOJUMP_KEEP_ALL_ENTRIES') == '1':\n    KEEP_ALL_ENTRIES = True\n\nALWAYS_IGNORE_CASE = False\nif 'AUTOJUMP_IGNORE_CASE' in os.environ and \\\n        os.environ.get('AUTOJUMP_IGNORE_CASE') == '1':\n    ALWAYS_IGNORE_CASE = True\n\nKEEP_SYMLINKS = False\nif 'AUTOJUMP_KEEP_SYMLINKS' in os.environ and \\\n        os.environ.get('AUTOJUMP_KEEP_SYMLINKS') == '1':\n    KEEP_SYMLINKS = True\n\nif CONFIG_DIR == os.path.expanduser('~'):\n    DB_FILE = CONFIG_DIR + '/.autojump.txt'\nelse:\n    DB_FILE = CONFIG_DIR + '/autojump.txt'\n\nclass Database:\n    \"\"\"\n    Object for interfacing with autojump database.\n    \"\"\"\n\n    def __init__(self, filename):\n        self.filename = filename\n        self.data = {}\n        self.load()\n\n    def __len__(self):\n        return len(self.data)\n\n    def add(self, path, increment = 10):\n        \"\"\"\n        Increase weight of existing paths or initialize new ones to 10.\n        \"\"\"\n        path = path.rstrip(os.sep)\n        if path not in self.data:\n            self.data[path] = increment\n        else:\n            import math\n            self.data[path] = math.sqrt((self.data[path]**2) + (increment**2))\n        self.save()\n\n    def decrease(self, path, increment = 15):\n        \"\"\"\n        Decrease weight of existing path. Unknown ones are ignored.\n        \"\"\"\n        if path in self.data:\n            if self.data[path] < increment:\n                self.data[path] = 0\n            else:\n                self.data[path] -= increment\n            self.save()\n\n    def decay(self):\n        \"\"\"\n        Decay database entries.\n        \"\"\"\n        for k in self.data.keys():\n            self.data[k] *= 0.9\n\n    def get_weight(self, path):\n        \"\"\"\n        Return path weight.\n        \"\"\"\n        if path in self.data:\n            return self.data[path]\n        else:\n            return 0\n\n    def load(self, error_recovery = False):\n        \"\"\"\n        Try to open the database file, recovering from backup if needed.\n        \"\"\"\n        if os.path.exists(self.filename):\n            try:\n                if sys.version_info >= (3, 0):\n                    with open(self.filename, 'r', encoding = 'utf-8') as f:\n                        for line in f.readlines():\n                            weight, path = line[:-1].split(\"\\t\", 1)\n                            path = decode(path, 'utf-8')\n                            self.data[path] = float(weight)\n                else:\n                    with open(self.filename, 'r') as f:\n                        for line in f.readlines():\n                            weight, path = line[:-1].split(\"\\t\", 1)\n                            path = decode(path, 'utf-8')\n                            self.data[path] = float(weight)\n            except (IOError, EOFError):\n                self.load_backup(error_recovery)\n        else:\n            self.load_backup(error_recovery)\n\n    def load_backup(self, error_recovery = False):\n        \"\"\"\n        Loads database from backup file.\n        \"\"\"\n        if os.path.exists(self.filename + '.bak'):\n            if not error_recovery:\n                print('Problem with autojump database,\\\n                        trying to recover from backup...', file=sys.stderr)\n                shutil.copy(self.filename + '.bak', self.filename)\n                return self.load(True)\n\n    def maintenance(self):\n        \"\"\"\n        Trims and decays database entries when exceeding settings.\n        \"\"\"\n        if sum(self.data.values()) > MAX_KEYWEIGHT:\n            self.decay()\n        if len(self.data) > MAX_STORED_PATHS:\n            self.trim()\n        self.save()\n\n    def purge(self):\n        \"\"\"\n        Deletes all entries that no longer exist on system.\n        \"\"\"\n        removed = []\n        for path in list(self.data.keys()):\n            if not os.path.exists(path):\n                removed.append(path)\n                del self.data[path]\n        self.save()\n        return removed\n\n    def save(self):\n        \"\"\"\n        Save database atomically and preserve backup, creating new database if\n        needed.\n        \"\"\"\n        # check file existence and permissions\n        if ((not os.path.exists(self.filename)) or\n                os.name == 'nt' or\n                os.getuid() == os.stat(self.filename)[4]):\n            temp = NamedTemporaryFile(dir = CONFIG_DIR, delete = False)\n            for path, weight in sorted(self.data.items(),\n                    key=itemgetter(1),\n                    reverse=True):\n                temp.write((unico(\"%s\\t%s\\n\" % (weight, path)).encode(\"utf-8\")))\n\n            # catching disk errors and skipping save when file handle can't\n            # be closed.\n            try:\n                # http://thunk.org/tytso/blog/2009/03/15/dont-fear-the-fsync/\n                temp.flush()\n                os.fsync(temp)\n                temp.close()\n            except IOError as ex:\n                print(\"Error saving autojump database (disk full?)\" %\n                        ex, file=sys.stderr)\n                return\n\n            shutil.move(temp.name, self.filename)\n            try: # backup file\n                import time\n                if (not os.path.exists(self.filename+\".bak\") or\n                        time.time()-os.path.getmtime(self.filename+\".bak\") \\\n                                > 86400):\n                    shutil.copy(self.filename, self.filename+\".bak\")\n            except OSError as ex:\n                print(\"Error while creating backup autojump file. (%s)\" %\n                        ex, file=sys.stderr)\n\n    def trim(self, percent=0.1):\n        \"\"\"\n        If database has exceeded MAX_STORED_PATHS, removes bottom 10%.\n        \"\"\"\n        dirs = list(self.data.items())\n        dirs.sort(key=itemgetter(1))\n        remove_cnt = int(percent * len(dirs))\n        for path, _ in dirs[:remove_cnt]:\n            del self.data[path]\n\n\ndef options():\n    \"\"\"\n    Parse command line options.\n    \"\"\"\n    global ARGS\n\n    parser = argparse.ArgumentParser(\n            description='Automatically jump to \\\n            directory passed as an argument.',\n            epilog=\"Please see autojump(1) man pages for full documentation.\")\n    parser.add_argument(\n            'directory', metavar='DIRECTORY', nargs='*', default='',\n            help='directory to jump to')\n    parser.add_argument(\n            '-a', '--add', '--increase', metavar='DIRECTORY',\n            help='manually add path to database, or increase path weight for \\\n            existing paths')\n    parser.add_argument(\n            '-d', '--decrease', metavar='WEIGHT', nargs='?', type=int,\n            const=15, default=False,\n            help='manually decrease path weight in database')\n    parser.add_argument(\n            '-b', '--bash', action=\"store_true\", default=False,\n            help='enclose directory quotes to prevent errors')\n    parser.add_argument(\n            '--complete', action=\"store_true\", default=False,\n            help='used for tab completion')\n    parser.add_argument(\n            '--purge', action=\"store_true\", default=False,\n            help='delete all database entries that no longer exist on system')\n    parser.add_argument(\n            '-s', '--stat', action=\"store_true\", default=False,\n            help='show database entries and their key weights')\n    parser.add_argument(\n            '-v', '--version', action=\"version\", version=\"%(prog)s \" + VERSION,\n            help='show version information and exit')\n\n    ARGS = parser.parse_args()\n\n    # The home dir can be reached quickly by \"cd\" and may interfere with other\n    # directories\n    if (ARGS.add):\n        if(ARGS.add != os.path.expanduser(\"~\")):\n            db = Database(DB_FILE)\n            db.add(decode(ARGS.add))\n        return True\n\n    if (ARGS.decrease):\n        if(ARGS.decrease != os.path.expanduser(\"~\")):\n            db = Database(DB_FILE)\n            # FIXME: handle symlinks?\n            db.decrease(os.getcwd(), ARGS.decrease)\n        return True\n\n    if (ARGS.purge):\n        db = Database(DB_FILE)\n        removed = db.purge()\n        if len(removed) > 0:\n            for dir in removed:\n                output(unico(dir))\n        print(\"Number of database entries removed: %d\" % len(removed))\n        return True\n\n    if (ARGS.stat):\n        db = Database(DB_FILE)\n        dirs = list(db.data.items())\n        dirs.sort(key=itemgetter(1))\n        for path, count in dirs[-100:]:\n            output(unico(\"%.1f:\\t%s\") % (count, path))\n\n        print(\"________________________________________\\n\")\n        print(\"%d:\\t total key weight\" % sum(db.data.values()))\n        print(\"%d:\\t stored directories\" % len(dirs))\n        print(\"db file: %s\" % DB_FILE)\n        return True\n    return False\n\ndef decode(text, encoding=None, errors=\"strict\"):\n    \"\"\"\n    Decoding step for Python 2 which does not default to unicode.\n    \"\"\"\n    if sys.version_info[0] > 2:\n        return text\n    else:\n        if encoding is None:\n            encoding = sys.getfilesystemencoding()\n        return text.decode(encoding, errors)\n\ndef output(unicode_text, encoding=None):\n    \"\"\"\n    Wrapper for the print function, using the filesystem encoding by default\n    to minimize encoding mismatch problems in directory names.\n    \"\"\"\n    if sys.version_info[0] > 2:\n        print(unicode_text)\n    else:\n        if encoding is None:\n            encoding = sys.getfilesystemencoding()\n        print(unicode_text.encode(encoding))\n\ndef unico(text):\n    \"\"\"\n    If Python 2, convert to a unicode object.\n    \"\"\"\n    if sys.version_info[0] > 2:\n        return text\n    else:\n        return unicode(text)\n\ndef match_last(pattern):\n    \"\"\"\n    If the last pattern contains a full path, jump there.\n    The regexp is because we need to support stuff like\n    \"j wo jo__3__/home/joel/workspace/joel\" for zsh.\n    \"\"\"\n    last_pattern_path = re.sub(\"(.*)\"+COMPLETION_SEPARATOR, \"\", pattern[-1])\n    if (len(last_pattern_path) > 0 and\n            last_pattern_path[0] == \"/\" and\n            os.path.exists(last_pattern_path)):\n        if not ARGS.complete:\n            output(last_pattern_path)\n            return True\n    return False\n\ndef match(path, pattern, only_end=False, ignore_case=False):\n    \"\"\"\n    Check whether a path matches a particular pattern, and return\n    the remaining part of the string.\n    \"\"\"\n    if only_end:\n        match_path = \"/\".join(path.split('/')[-1-pattern.count('/'):])\n    else:\n        match_path = path\n\n    if ignore_case:\n        match_path = match_path.lower()\n        pattern = pattern.lower()\n\n    find_idx = match_path.find(pattern)\n    # truncate path to avoid matching a pattern multiple times\n    if find_idx != -1:\n        return (True, path)\n    else:\n        return (False, path[find_idx+len(pattern):])\n\ndef find_matches(db, patterns, max_matches=1, ignore_case=False, fuzzy=False):\n    \"\"\"\n    Find max_matches paths that match the pattern, and add them to the\n    result_list.\n    \"\"\"\n    try:\n        current_dir = decode(os.path.realpath(os.curdir))\n    except OSError:\n        current_dir = None\n\n    dirs = list(db.data.items())\n    dirs.sort(key=itemgetter(1), reverse=True)\n    results = []\n    if fuzzy:\n        from difflib import get_close_matches\n\n        # create dictionary of end paths to compare against\n        end_dirs = {}\n        for d in dirs:\n            if ignore_case:\n                end = d[0].split('/')[-1].lower()\n            else:\n                end = d[0].split('/')[-1]\n\n            # collisions: ignore lower weight paths\n            if end not in end_dirs:\n                end_dirs[end] = d[0]\n\n        # find the first match (heighest weight)\n        while True:\n            found = get_close_matches(patterns[-1], end_dirs, n=1, cutoff=.6)\n            if not found:\n                break\n            # avoid jumping to current directory\n            if (os.path.exists(found[0]) or TESTING) and \\\n                current_dir != os.path.realpath(found[0]):\n                break\n            # continue with the last found directory removed\n            del end_dirs[found[0]]\n\n        if found:\n            found = found[0]\n            results.append(end_dirs[found])\n            return results\n        else:\n            return []\n\n    current_dir_match = False\n    for path, _ in dirs:\n        found, tmp = True, path\n        for n, p in enumerate(patterns):\n            # for single/last pattern, only check end of path\n            if n == len(patterns)-1:\n                found, tmp = match(tmp, p, True, ignore_case)\n            else:\n                found, tmp = match(tmp, p, False, ignore_case)\n            if not found: break\n\n        if found and (os.path.exists(path) or TESTING):\n            # avoid jumping to current directory\n            # (call out to realpath this late to not stat all dirs)\n            if current_dir == os.path.realpath(path):\n                current_dir_match = True\n                continue\n\n            if path not in results:\n                results.append(path)\n            if len(results) >= max_matches:\n                break\n\n    # if current directory is the only match, add it to results\n    if len(results) == 0 and current_dir_match:\n        results.append(current_dir)\n\n    return results\n\ndef shell_utility():\n    \"\"\"\n    Run this when autojump is called as a shell utility.\n    \"\"\"\n    if options(): return True\n    db = Database(DB_FILE)\n\n    # if no directories, add empty string\n    if (ARGS.directory == ''):\n        patterns = [unico('')]\n    else:\n        patterns = [decode(a) for a in ARGS.directory]\n\n    # check last pattern for full path\n    # FIXME: disabled until zsh tab completion is fixed on the shell side\n    # if match_last(patterns): return True\n\n    # check for tab completion\n    tab_choice = -1\n    tab_match = re.search(COMPLETION_SEPARATOR+\"([0-9]+)\", patterns[-1])\n    if tab_match: # user has selected a tab completion entry\n        tab_choice = int(tab_match.group(1))\n        patterns[-1] = re.sub(COMPLETION_SEPARATOR+\"[0-9]+.*\", \"\", patterns[-1])\n    else: # user hasn't selected a tab completion, display choices again\n        tab_match = re.match(\"(.*)\"+COMPLETION_SEPARATOR, patterns[-1])\n        if tab_match:\n            patterns[-1] = tab_match.group(1)\n\n    # on tab completion always show all results\n    if ARGS.complete or tab_choice != -1:\n        max_matches = 9\n    else:\n        max_matches = 1\n\n    results = []\n    if not ALWAYS_IGNORE_CASE:\n        results = find_matches(db, patterns, max_matches, ignore_case=False)\n\n    # if no results, try ignoring case\n    if ARGS.complete or not results:\n        results = find_matches(db, patterns, max_matches, ignore_case=True)\n\n    # if no results, try approximate matching\n    if not results:\n        results = find_matches(db, patterns, max_matches, ignore_case=True,\n                fuzzy=True)\n\n    quotes = \"\"\n    if ARGS.complete and ARGS.bash: quotes = \"'\"\n\n    if tab_choice != -1:\n        if len(results) > tab_choice-1:\n            output(unico(\"%s%s%s\") % (quotes,results[tab_choice-1],quotes))\n    elif len(results) > 1 and ARGS.complete:\n        output(\"\\n\".join((\"%s%s%d%s%s\" % (patterns[-1],\n            COMPLETION_SEPARATOR, n+1, COMPLETION_SEPARATOR, r)\n            for n, r in enumerate(results[:8]))))\n    elif results:\n        output(unico(\"%s%s%s\")%(quotes,results[0],quotes))\n    else:\n        return False\n\n    if not KEEP_ALL_ENTRIES:\n        db.maintenance()\n\n    return True\n\nif __name__ == \"__main__\":\n    if not shell_utility():\n        sys.exit(1)\n", "# source autojump on BASH or ZSH depending on the shell\n\nshell=`echo ${SHELL} | awk -F/ '{ print $NF }'`\n\n# prevent circular loop for sh shells\nif [ \"${shell}\" = \"sh\" ]; then\n\treturn 0\n\n# check local install\nelif [ -s ~/.autojump/etc/profile.d/autojump.${shell} ]; then\n\tsource ~/.autojump/etc/profile.d/autojump.${shell}\n\n# check global install\nelif [ -s /etc/profile.d/autojump.${shell} ]; then\n\tsource /etc/profile.d/autojump.${shell}\n\n# check custom install locations (modified by Homebrew or using --destdir option)\nelif [ -s /destdir_${RANDOM}_install/autojump.${shell} ]; then\n\tsource /destdir_${RANDOM}_install/autojump.${shell}\n\nfi\n", "#!/usr/bin/env bash\n\nfunction help_msg {\n    echo \"./install.sh [OPTION..]\"\n    echo\n    echo \" -a, --auto           Try to determine destdir, prefix (and zshshare if applicable)\"\n    echo \" -g, --global         Use default global settings (destdir=/; prefix=usr)\"\n    echo \" -l, --local          Use default local settings (destdir=~/.autojump)\"\n    echo\n    echo \" -d, --destdir PATH   Set install destination to PATH\"\n    echo \" -p, --prefix PATH    Use PATH as prefix\"\n    echo \" -Z, --zshshare PATH  Use PATH as zsh share destination\"\n    echo\n    echo \" -f, --force          Ignore Python version check\"\n    echo \" -n, --dry_run        Only show installation paths, don't install anything\"\n    echo\n    echo \"Will install autojump into:\"\n    echo\n    echo ' Binaries:        $destdir$prefix/bin'\n    echo ' Documentation:   $destdir$prefix/share/man/man1'\n    echo ' Icon:            $destdir$prefix/share/autojump'\n    echo ' Shell scripts:   $destdir/etc/profile.d'\n    echo ' zsh functions:   $destdir$zshsharedir'\n    echo\n    echo 'Unless specified, $zshshare will be :'\n    echo ' - $destdir$prefix/functions for local installations'\n    echo ' - $destdir$prefix/share/zsh/site-functions for all other installations'\n}\n\ndry_run=\nlocal=\nglobal=\nforce=\nshell=`echo ${SHELL} | awk -F/ '{ print $NF }'`\ndestdir=\nprefix=\"usr/local\"\nzshsharedir=\n\n# If no arguments passed, default to --auto.\nif [[ ${#} == 0 ]]; then\n    set -- \"--auto\"\nfi\n\n# Only dry-run should also default to --auto\nif [[ ${#} == 1 ]] && ([[ $1 = \"-n\" ]] || [[ $1 = \"--dry-run\" ]]); then\n    set -- \"-n\" \"--auto\"\nfi\n\n# Command line parsing\nwhile true; do\n    case \"$1\" in\n        -a|--auto)\n            if [[ ${UID} -eq 0 ]]; then\n                set -- \"--global\" \"${@:2}\"\n            else\n                set -- \"--local\" \"${@:2}\"\n            fi\n            ;;\n        -d|--destdir)\n            if [ $# -gt 1 ]; then\n                destdir=$2; shift 2\n            else\n                echo \"--destdir or -d requires an argument\" 1>&2\n            fi\n            ;;\n        -f|--force)\n            force=true\n            shift\n            if [[ ${#} == 0 ]]; then\n                set -- \"--auto\"\n            fi\n            ;;\n        -g|--global)\n            global=true\n            destdir=\n            prefix=usr\n            shift\n            ;;\n        -h|--help|-\\?)\n            help_msg;\n            exit 0\n            ;;\n        -l|--local)\n            local=true\n            destdir=~/.autojump\n            prefix=\n            shift\n            ;;\n        -n|--dry_run)\n            dry_run=true\n            shift\n            ;;\n        -p|--prefix)\n            if [ $# -gt 1 ]; then\n                prefix=$2; shift 2\n            else\n                echo \"--prefix or -p requires an argument\" 1>&2\n                exit 1\n            fi\n            ;;\n        -Z|--zshshare)\n            if [ $# -gt 1 ]; then\n                zshsharedir=$2; shift 2\n            else\n                echo \"--zshshare or -Z requires an argument\" 1>&2\n                exit 1\n            fi\n            ;;\n        --)\n            shift\n            break\n            ;;\n        -*)\n            echo \"invalid option: $1\" 1>&2;\n            help_msg;\n            exit 1\n            ;;\n        *)\n            break\n            ;;\n    esac\ndone\n\n# destdir must be a full path, and end with a slash\nif [[ -n ${destdir} ]]; then\n    if [[ ${destdir:0:1} != \"/\" ]]; then\n        echo \"Error: destdir must be a full path\" 1>&2\n        exit 1\n    fi\n    len=${#destdir}\n    if [[ ${destdir:len - 1} != \"/\" ]]; then\n        destdir=\"$destdir/\"\n    fi\nelse\n    destdir=\"/\"\nfi\n\n# prefix should not start with, and end with, a slash\nif [[ -n ${prefix} ]]; then\n    if [[ ${prefix:0:1} == \"/\" ]]; then\n        prefix=${prefix:1}\n    fi\n    len=${#prefix}\n    if [[ ${prefix:len - 1} != \"/\" ]]; then\n        prefix=\"$prefix/\"\n    fi\nfi\n\n# check shell support\nif [[ ${shell} != \"bash\" ]] && [[ ${shell} != \"zsh\" ]]; then\n    echo \"Unsupported shell (${shell}). Only Bash and Zsh shells are supported.\"\n    exit 1\nfi\n\n# zsh functions\nif [[ $shell == \"zsh\" ]]; then\n    if [[ -z $zshsharedir ]]; then\n        # if not set, use a default\n        if [[ $local ]]; then\n            zshsharedir=\"${prefix}functions\"\n        else\n            zshsharedir=\"${prefix}share/zsh/site-functions\"\n        fi\n    fi\nfi\n\n# check Python version\nif [ ! ${force} ]; then\n    python_version=`python -c 'import sys; print(sys.version_info[:])'`\n\n    if [[ ${python_version:1:1} -eq 2 && ${python_version:4:1} -lt 6 ]]; then\n        echo\n        echo \"Incompatible Python version, please upgrade to v2.6+.\"\n        if [[ ${python_version:4:1} -ge 4 ]]; then\n            echo\n            echo \"Alternatively, you can download v12 that supports Python v2.4+ from:\"\n            echo\n            echo -e \"\\thttps://github.com/joelthelion/autojump/downloads\"\n            echo\n        fi\n        exit 1\n    fi\nfi\n\necho\necho \"Installating autojump...\"\necho\necho \"Destination:      $destdir\"\nif [[ -n $prefix ]]; then\n    echo \"Prefix:           /$prefix\"\nfi\necho\necho \"Binary:           ${destdir}${prefix}bin/\"\necho \"Documentation:    ${destdir}${prefix}share/man/man1/\"\necho \"Icon:             ${destdir}${prefix}share/autojump/\"\necho \"Shell scripts:    ${destdir}etc/profile.d/\"\nif [[ -z $shell ]] || [[ $shell == \"zsh\" ]]; then\n    echo \"zsh functions:    ${destdir}${zshsharedir}\"\nfi\necho\n\nif [[ $dry_run ]]; then\n    echo \"--dry_run (-n) used, stopping\"\n    exit\nfi\n\n# INSTALL AUTOJUMP\nmkdir -p ${destdir}${prefix}share/autojump/ || exit 1\nmkdir -p ${destdir}${prefix}bin/ || exit 1\nmkdir -p ${destdir}${prefix}share/man/man1/ || exit 1\ncp -v ./bin/icon.png ${destdir}${prefix}share/autojump/ || exit 1\ncp -v ./bin/autojump ${destdir}${prefix}bin/ || exit 1\ncp -v ./bin/autojump_argparse.py ${destdir}${prefix}bin/ || exit 1\ncp -v ./docs/autojump.1 ${destdir}${prefix}share/man/man1/ || exit 1\nmkdir -p ${destdir}etc/profile.d/ || exit 1\ncp -v ./bin/autojump.sh ${destdir}etc/profile.d/ || exit 1\ncp -v ./bin/autojump.bash ${destdir}etc/profile.d/ || exit 1\ncp -v ./bin/autojump.zsh ${destdir}etc/profile.d/ || exit 1\nmkdir -p ${destdir}${zshsharedir} || exit 1\n# TODO: remove unused _j function (2013.02.01_1348, ting)\ninstall -v -m 0755 ./bin/_j ${destdir}${zshsharedir} || exit 1\n\n# MODIFY AUTOJUMP.SH FOR CUSTOM INSTALLS\nif [[ -z ${local} ]] && [[ -z ${global} ]]; then\n    sed -i \"s:/destdir_.*_install:${destdir}etc/profile.d:g\" ${destdir}etc/profile.d/autojump.sh\nfi\n\n# DISPLAY ADD MESSAGE\nrc_file=\"~/.${shell}rc\"\nif [[ `uname` == \"Darwin\" ]] && [[ ${shell} == \"bash\" ]]; then\n    rc_file=\"~/.bash_profile\"\nfi\n\naj_shell_file=\"${destdir}etc/profile.d/autojump.sh\"\nif [[ ${local} ]]; then\n    aj_shell_file=\"~/.autojump/etc/profile.d/autojump.sh\"\nfi\n\necho\necho \"Please add the line to ${rc_file} :\"\necho\necho -e \"[[ -s ${aj_shell_file} ]] && . ${aj_shell_file}\"\necho\necho \"You need to run 'source ${rc_file}' before you can start using autojump. To remove autojump, run './uninstall.sh'\"\necho\n"], "filenames": ["bin/autojump", "bin/autojump.sh", "install.sh"], "buggy_code_start_loc": [37, 18, 225], "buggy_code_end_loc": [38, 20, 226], "fixing_code_start_loc": [37, 18, 225], "fixing_code_end_loc": [38, 20, 226], "type": "CWE-269", "message": "autojump before 21.5.8 allows local users to gain privileges via a Trojan horse custom_install directory in the current working directory.", "other": {"cve": {"id": "CVE-2013-2012", "sourceIdentifier": "secalert@redhat.com", "published": "2019-10-31T20:15:10.833", "lastModified": "2020-08-18T15:05:49.313", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "autojump before 21.5.8 allows local users to gain privileges via a Trojan horse custom_install directory in the current working directory."}, {"lang": "es", "value": "autojump versiones anteriores a 21.5.8, permite a usuarios locales conseguir privilegios por medio de un directorio custom_install de tipo caballo de Troya en el directorio de trabajo actual."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:autojump_project:autojump:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.5.8", "matchCriteriaId": "2033EB44-BAD3-470F-ABAA-B8B4CB2B4B4D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2013/04/25/14", "source": "secalert@redhat.com", "tags": ["Mailing List"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2013-2012", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/83827", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/wting/autojump/commit/ad09ee27d402be797b3456abff6edeb4291edfec", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/wting/autojump/commit/c763b2afadb188ab52849c21d43d2e8fe5b8800a", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2013-2012", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wting/autojump/commit/ad09ee27d402be797b3456abff6edeb4291edfec"}}