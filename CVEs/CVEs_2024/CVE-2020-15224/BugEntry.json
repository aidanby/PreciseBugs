{"buggy_code": ["// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n/*\n**==============================================================================\n**\n** socket.edl:\n**\n**     This file declares OCALLs needed by the enclave to implement socket I/O.\n**\n**     Note that some of the syscalls in fcntl.edl can also be passed a socket\n**     file descriptor.\n**\n**     TODO: Document which file OCalls support socket descriptors.\n**\n**==============================================================================\n*/\n\nenclave\n{\n\n\n    // Headers needed for integral types\n    include \"openenclave/corelibc/bits/types.h\"\n    include \"openenclave/bits/edl/syscall_types.h\"\n\n    struct oe_sockaddr\n    {\n        oe_sa_family_t sa_family;\n        char sa_data[14];\n    };\n\n    struct oe_addrinfo\n    {\n        int ai_flags;\n        int ai_family;\n        int ai_socktype;\n        int ai_protocol;\n        oe_socklen_t ai_addrlen;\n        [size=ai_addrlen] struct oe_sockaddr* ai_addr;\n        char* ai_canonname;\n        struct oe_addrinfo* ai_next;\n    };\n\n    untrusted\n    {\n        int oe_syscall_close_socket_ocall(\n            oe_host_fd_t sockfd)\n            propagate_errno;\n\n       oe_host_fd_t oe_syscall_socket_ocall(\n            int domain,\n            int type,\n            int protocol)\n            propagate_errno;\n\n        int oe_syscall_shutdown_sockets_device_ocall(\n            oe_host_fd_t sockfd)\n            propagate_errno;\n\n        int oe_syscall_socketpair_ocall(\n            int domain,\n            int type,\n            int protocol,\n            [out] oe_host_fd_t sv[2])\n            propagate_errno;\n\n        int oe_syscall_connect_ocall(\n            oe_host_fd_t sockfd,\n            [in, size=addrlen] const struct oe_sockaddr* addr,\n            oe_socklen_t addrlen)\n            propagate_errno;\n\n        oe_host_fd_t oe_syscall_accept_ocall(\n            oe_host_fd_t sockfd,\n            [in, out, size=addrlen_in] struct oe_sockaddr* addr,\n            oe_socklen_t addrlen_in,\n            [out, count=1] oe_socklen_t* addrlen_out)\n            propagate_errno;\n\n        int oe_syscall_bind_ocall(\n            oe_host_fd_t sockfd,\n            [in, size=addrlen] const struct oe_sockaddr* addr,\n            oe_socklen_t addrlen)\n            propagate_errno;\n\n        int oe_syscall_listen_ocall(\n            oe_host_fd_t sockfd,\n            int backlog)\n            propagate_errno;\n\n        ssize_t oe_syscall_recvmsg_ocall(\n            oe_host_fd_t sockfd,\n            [out, size=msg_namelen] void* msg_name,\n            oe_socklen_t msg_namelen,\n            [out, count=1] oe_socklen_t* msg_namelen_out,\n            [in, out, size=msg_iov_buf_size] void* msg_iov_buf,\n            size_t msg_iovlen,\n            size_t msg_iov_buf_size,\n            [out, size=msg_controllen] void* msg_control,\n            size_t msg_controllen,\n            [out, count=1] size_t* msg_controllen_out,\n            int flags)\n            propagate_errno;\n\n        ssize_t oe_syscall_sendmsg_ocall(\n            oe_host_fd_t sockfd,\n            [in, size=msg_namelen] const void* msg_name,\n            oe_socklen_t msg_namelen,\n            [in, size=msg_iov_buf_size] void* msg_iov_buf,\n            size_t msg_iovlen,\n            size_t msg_iov_buf_size,\n            [in, size=msg_controllen] const void* msg_control,\n            size_t msg_controllen,\n            int flags)\n            propagate_errno;\n\n        ssize_t oe_syscall_recv_ocall(\n            oe_host_fd_t sockfd,\n            [in, out, size=len] void* buf,\n            size_t len,\n            int flags)\n            propagate_errno;\n\n        ssize_t oe_syscall_recvfrom_ocall(\n            oe_host_fd_t sockfd,\n            [out, size=len] void* buf,\n            size_t len,\n            int flags,\n            [in, out, size=addrlen_in] struct oe_sockaddr* src_addr,\n            oe_socklen_t addrlen_in,\n            [out, count=1] oe_socklen_t* addrlen_out)\n            propagate_errno;\n\n        ssize_t oe_syscall_send_ocall(\n            oe_host_fd_t sockfd,\n            [in, size=len] const void* buf,\n            size_t len,\n            int flags)\n            propagate_errno;\n\n        ssize_t oe_syscall_sendto_ocall(\n            oe_host_fd_t sockfd,\n            [in, size=len] const void* buf,\n            size_t len,\n            int flags,\n            [in, size=addrlen] const struct oe_sockaddr* dest_addr,\n            oe_socklen_t addrlen)\n            propagate_errno;\n\n        ssize_t oe_syscall_recvv_ocall(\n            oe_host_fd_t fd,\n            [in, out, size=iov_buf_size] void* iov_buf,\n            int iovcnt,\n            size_t iov_buf_size)\n            propagate_errno;\n\n        ssize_t oe_syscall_sendv_ocall(\n            oe_host_fd_t fd,\n            [in, size=iov_buf_size] const void* iov_buf,\n            int iovcnt,\n            size_t iov_buf_size)\n            propagate_errno;\n\n        int oe_syscall_shutdown_ocall(\n            oe_host_fd_t sockfd,\n            int how)\n            propagate_errno;\n\n        int oe_syscall_setsockopt_ocall(\n            oe_host_fd_t sockfd,\n            int level,\n            int optname,\n            [in, size=optlen] const void* optval,\n            oe_socklen_t optlen)\n            propagate_errno;\n\n        int oe_syscall_getsockopt_ocall(\n            oe_host_fd_t sockfd,\n            int level,\n            int optname,\n            [out, size=optlen_in] void* optval,\n            oe_socklen_t optlen_in,\n            [out] oe_socklen_t* optlen_out)\n            propagate_errno;\n\n        int oe_syscall_getsockname_ocall(\n            oe_host_fd_t sockfd,\n            [in, out, size=addrlen_in] struct oe_sockaddr* addr,\n            oe_socklen_t addrlen_in,\n            [out, size=1] oe_socklen_t* addrlen_out)\n            propagate_errno;\n\n        int oe_syscall_getpeername_ocall(\n            oe_host_fd_t sockfd,\n            [in, out, size=addrlen_in] struct oe_sockaddr* addr,\n            oe_socklen_t addrlen_in,\n            [out, size=1] oe_socklen_t* addrlen_out)\n            propagate_errno;\n\n        int oe_syscall_getaddrinfo_open_ocall(\n            [in, string] const char* node,\n            [in, string] const char* service,\n            [in, count=1] const struct oe_addrinfo* hints,\n            [out, count=1] uint64_t* handle)\n            propagate_errno;\n\n        int oe_syscall_getaddrinfo_read_ocall(\n            uint64_t handle,\n            [out, count=1] int* ai_flags,\n            [out, count=1] int* ai_family,\n            [out, count=1] int* ai_socktype,\n            [out, count=1] int* ai_protocol,\n            oe_socklen_t ai_addrlen_in,\n            [out, count=1] oe_socklen_t* ai_addrlen,\n            [out, size=ai_addrlen_in] struct oe_sockaddr* ai_addr,\n            size_t ai_canonnamelen_in,\n            [out, count=1] size_t* ai_canonnamelen,\n            [out, size=ai_canonnamelen_in] char* ai_canonname)\n            propagate_errno;\n\n        int oe_syscall_getaddrinfo_close_ocall(\n            uint64_t handle)\n            propagate_errno;\n\n        int oe_syscall_getnameinfo_ocall(\n            [in, size=salen] const struct oe_sockaddr* sa,\n            oe_socklen_t salen,\n            [out, size=hostlen] char* host,\n            oe_socklen_t hostlen,\n            [out, size=servlen] char* serv,\n            oe_socklen_t servlen,\n            int flags)\n            propagate_errno;\n    };\n};\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#ifndef _OE_SYSCALL_FD_H\n#define _OE_SYSCALL_FD_H\n\n#include <openenclave/bits/defs.h>\n#include <openenclave/bits/types.h>\n#include <openenclave/internal/syscall/sys/epoll.h>\n#include <openenclave/internal/syscall/sys/socket.h>\n#include <openenclave/internal/syscall/sys/stat.h>\n#include <openenclave/internal/syscall/sys/uio.h>\n#include <openenclave/internal/syscall/types.h>\n\nOE_EXTERNC_BEGIN\n\ntypedef enum _oe_fd_type\n{\n    OE_FD_TYPE_NONE = 0,\n    OE_FD_TYPE_ANY,\n    OE_FD_TYPE_FILE,\n    OE_FD_TYPE_SOCKET,\n    OE_FD_TYPE_EPOLL,\n} oe_fd_type_t;\n\ntypedef struct _oe_fd oe_fd_t;\n\n/* Common operations on file-descriptor objects. */\ntypedef struct _oe_fd_ops\n{\n    ssize_t (*read)(oe_fd_t* desc, void* buf, size_t count);\n\n    ssize_t (*write)(oe_fd_t* desc, const void* buf, size_t count);\n\n    ssize_t (*readv)(oe_fd_t* desc, const struct oe_iovec* iov, int iovcnt);\n\n    ssize_t (*writev)(oe_fd_t* desc, const struct oe_iovec* iov, int iovcnt);\n\n    int (*flock)(oe_fd_t* desc, int operation);\n\n    int (*dup)(oe_fd_t* desc, oe_fd_t** new_fd);\n\n    int (*ioctl)(oe_fd_t* desc, unsigned long request, uint64_t arg);\n\n    int (*fcntl)(oe_fd_t* desc, int cmd, uint64_t arg);\n\n    int (*close)(oe_fd_t* desc);\n\n    oe_host_fd_t (*get_host_fd)(oe_fd_t* desc);\n} oe_fd_ops_t;\n\n/* File operations. */\ntypedef struct _oe_file_ops\n{\n    /* Inherited operations. */\n    oe_fd_ops_t fd;\n\n    oe_off_t (*lseek)(oe_fd_t* file, oe_off_t offset, int whence);\n\n    ssize_t (*pread)(oe_fd_t* desc, void* buf, size_t count, oe_off_t offset);\n\n    ssize_t (\n        *pwrite)(oe_fd_t* desc, const void* buf, size_t count, oe_off_t offset);\n\n    int (*getdents64)(oe_fd_t* file, struct oe_dirent* dirp, uint32_t count);\n\n    int (*fstat)(oe_fd_t* file, struct oe_stat_t* buf);\n\n    int (*fsync)(oe_fd_t* file);\n    int (*fdatasync)(oe_fd_t* file);\n} oe_file_ops_t;\n\n/* Socket operations .*/\ntypedef struct _oe_socket_ops\n{\n    /* Inherited operations. */\n    oe_fd_ops_t fd;\n\n    int (*connect)(\n        oe_fd_t* sock,\n        const struct oe_sockaddr* addr,\n        oe_socklen_t addrlen);\n\n    oe_fd_t* (*accept)(\n        oe_fd_t* sock,\n        struct oe_sockaddr* addr,\n        oe_socklen_t* addrlen);\n\n    int (*bind)(\n        oe_fd_t* sock,\n        const struct oe_sockaddr* addr,\n        oe_socklen_t addrlen);\n\n    int (*listen)(oe_fd_t* sock, int backlog);\n\n    ssize_t (*send)(oe_fd_t* sock, const void* buf, size_t len, int flags);\n\n    ssize_t (*recv)(oe_fd_t* sock, void* buf, size_t len, int flags);\n\n    ssize_t (*sendto)(\n        oe_fd_t* sock,\n        const void* buf,\n        size_t len,\n        int flags,\n        const struct oe_sockaddr* dest_addr,\n        oe_socklen_t addrlen);\n\n    ssize_t (*recvfrom)(\n        oe_fd_t* sock,\n        void* buf,\n        size_t len,\n        int flags,\n        const struct oe_sockaddr* src_addr,\n        oe_socklen_t* addrlen);\n\n    ssize_t (*sendmsg)(oe_fd_t* sock, const struct oe_msghdr* msg, int flags);\n\n    ssize_t (*recvmsg)(oe_fd_t* sock, struct oe_msghdr* msg, int flags);\n\n    int (*shutdown)(oe_fd_t* sock, int how);\n\n    int (*getsockopt)(\n        oe_fd_t* sock,\n        int level,\n        int optname,\n        void* optval,\n        oe_socklen_t* optlen);\n\n    int (*setsockopt)(\n        oe_fd_t* sock,\n        int level,\n        int optname,\n        const void* optval,\n        oe_socklen_t optlen);\n\n    int (*getpeername)(\n        oe_fd_t* sock,\n        struct oe_sockaddr* addr,\n        oe_socklen_t* addrlen);\n\n    int (*getsockname)(\n        oe_fd_t* sock,\n        struct oe_sockaddr* addr,\n        oe_socklen_t* addrlen);\n} oe_socket_ops_t;\n\n/* epoll operations. */\ntypedef struct _oe_epoll_ops\n{\n    /* Inherited operations. */\n    oe_fd_ops_t fd;\n\n    int (*epoll_ctl)(\n        oe_fd_t* epoll,\n        int op,\n        int fd,\n        struct oe_epoll_event* event);\n\n    int (*epoll_wait)(\n        oe_fd_t* epoll,\n        struct oe_epoll_event* events,\n        int maxevents,\n        int timeout);\n\n    void (*on_close)(oe_fd_t* epoll, int fd);\n} oe_epoll_ops_t;\n\nstruct _oe_fd\n{\n    oe_fd_type_t type;\n    union {\n        oe_fd_ops_t fd;\n        oe_file_ops_t file;\n        oe_socket_ops_t socket;\n        oe_epoll_ops_t epoll;\n    } ops;\n};\n\nOE_EXTERNC_END\n\n// clang-format on\n#endif // _OE_SYSCALL_FD_H\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#ifndef _OE_SYSCALL_IOV_H\n#define _OE_SYSCALL_IOV_H\n\n#include <openenclave/bits/fs.h>\n#include <openenclave/bits/result.h>\n#include <openenclave/internal/syscall/fd.h>\n#include <openenclave/internal/syscall/sys/stat.h>\n\nOE_EXTERNC_BEGIN\n\nint oe_iov_pack(\n    const struct oe_iovec* iov,\n    int iovcnt,\n    void** buf_out,\n    size_t* buf_size_out);\n\nint oe_iov_sync(\n    const struct oe_iovec* iov,\n    int iovcnt,\n    const void* buf_,\n    size_t buf_size);\n\nOE_EXTERNC_END\n\n#endif // _OE_SYSCALL_IOV_H\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#ifndef _OE_SYSCALL_SYS_SOCKET_H\n#define _OE_SYSCALL_SYS_SOCKET_H\n\n#include <openenclave/bits/defs.h>\n#include <openenclave/bits/types.h>\n#include <openenclave/corelibc/bits/types.h>\n#include <openenclave/internal/bits/socket.h>\n#include <openenclave/internal/syscall/sys/uio.h>\n\nOE_EXTERNC_BEGIN\n\n/* Protocol families.  */\n#define OE_PF_UNSPEC 0      /* Unspecified.  */\n#define OE_PF_LOCAL 1       /* Local to host (pipes and file-domain).  */\n#define OE_PF_UNIX PF_LOCAL /* POSIX name for PF_LOCAL.  */\n#define OE_PF_FILE PF_LOCAL /* Another non-standard name for PF_LOCAL.  */\n#define OE_PF_INET 2        /* IP protocol family.  */\n#define OE_PF_AX25 3        /* Amateur Radio AX.25.  */\n#define OE_PF_IPX 4         /* Novell Internet Protocol.  */\n#define OE_PF_APPLETALK 5   /* Appletalk DDP.  */\n#define OE_PF_NETROM 6      /* Amateur radio NetROM.  */\n#define OE_PF_BRIDGE 7      /* Multiprotocol bridge.  */\n#define OE_PF_ATMPVC 8      /* ATM PVCs.  */\n#define OE_PF_X25 9         /* Reserved for X.25 project.  */\n#define OE_PF_INET6 10      /* IP version 6.  */\n#define OE_PF_ROSE 11       /* Amateur Radio X.25 PLP.  */\n#define OE_PF_DECnet 12     /* Reserved for DECnet project.  */\n#define OE_PF_NETBEUI 13    /* Reserved for 802.2LLC project.  */\n#define OE_PF_SECURITY 14   /* Security callback pseudo AF.  */\n#define OE_PF_KEY 15        /* PF_KEY key management API.  */\n#define OE_PF_NETLINK 16\n#define OE_PF_ROUTE PF_NETLINK /* Alias to emulate 4.4BSD.  */\n#define OE_PF_PACKET 17        /* Packet family.  */\n#define OE_PF_ASH 18           /* Ash.  */\n#define OE_PF_ECONET 19        /* Acorn Econet.  */\n#define OE_PF_ATMSVC 20        /* ATM SVCs.  */\n#define OE_PF_RDS 21           /* RDS sockets.  */\n#define OE_PF_SNA 22           /* Linux SNA Project */\n#define OE_PF_IRDA 23          /* IRDA sockets.  */\n#define OE_PF_PPPOX 24         /* PPPoX sockets.  */\n#define OE_PF_WANPIPE 25       /* Wanpipe API sockets.  */\n#define OE_PF_LLC 26           /* Linux LLC.  */\n#define OE_PF_IB 27            /* Native InfiniBand address.  */\n#define OE_PF_MPLS 28          /* MPLS.  */\n#define OE_PF_CAN 29           /* Controller Area Network.  */\n#define OE_PF_TIPC 30          /* TIPC sockets.  */\n#define OE_PF_BLUETOOTH 31     /* Bluetooth sockets.  */\n#define OE_PF_IUCV 32          /* IUCV sockets.  */\n#define OE_PF_RXRPC 33         /* RxRPC sockets.  */\n#define OE_PF_ISDN 34          /* mISDN sockets.  */\n#define OE_PF_PHONET 35        /* Phonet sockets.  */\n#define OE_PF_IEEE802154 36    /* IEEE 802.15.4 sockets.  */\n#define OE_PF_CAIF 37          /* CAIF sockets.  */\n#define OE_PF_ALG 38           /* Algorithm sockets.  */\n#define OE_PF_NFC 39           /* NFC sockets.  */\n#define OE_PF_VSOCK 40         /* vSockets.  */\n#define OE_PF_KCM 41           /* Kernel Connection Multiplexor.  */\n#define OE_PF_QIPCRTR 42       /* Qualcomm IPC Router.  */\n#define OE_PF_SMC 43           /* SMC sockets.  */\n#define OE_PF_HOST 51          /* non-secure host sockets */\n#define OE_PF_MAX 51           /* For now..  */\n\n/* Address families.  */\n#define OE_AF_UNSPEC OE_PF_UNSPEC\n#define OE_AF_LOCAL OE_PF_LOCAL\n#define OE_AF_UNIX OE_PF_UNIX\n#define OE_AF_FILE OE_PF_FILE\n#define OE_AF_INET OE_PF_INET\n#define OE_AF_AX25 OE_PF_AX25\n#define OE_AF_IPX OE_PF_IPX\n#define OE_AF_APPLETALK OE_PF_APPLETALK\n#define OE_AF_NETROM OE_PF_NETROM\n#define OE_AF_BRIDGE OE_PF_BRIDGE\n#define OE_AF_ATMPVC OE_PF_ATMPVC\n#define OE_AF_X25 OE_PF_X25\n#define OE_AF_INET6 OE_PF_INET6\n#define OE_AF_ROSE OE_PF_ROSE\n#define OE_AF_DECnet OE_PF_DECnet\n#define OE_AF_NETBEUI OE_PF_NETBEUI\n#define OE_AF_SECURITY OE_PF_SECURITY\n#define OE_AF_KEY OE_PF_KEY\n#define OE_AF_NETLINK OE_PF_NETLINK\n#define OE_AF_ROUTE OE_PF_ROUTE\n#define OE_AF_PACKET OE_PF_PACKET\n#define OE_AF_ASH OE_PF_ASH\n#define OE_AF_ECONET OE_PF_ECONET\n#define OE_AF_ATMSVC OE_PF_ATMSVC\n#define OE_AF_RDS OE_PF_RDS\n#define OE_AF_SNA OE_PF_SNA\n#define OE_AF_IRDA OE_PF_IRDA\n#define OE_AF_PPPOX OE_PF_PPPOX\n#define OE_AF_WANPIPE OE_PF_WANPIPE\n#define OE_AF_LLC OE_PF_LLC\n#define OE_AF_IB OE_PF_IB\n#define OE_AF_MPLS OE_PF_MPLS\n#define OE_AF_CAN OE_PF_CAN\n#define OE_AF_TIPC OE_PF_TIPC\n#define OE_AF_BLUETOOTH OE_PF_BLUETOOTH\n#define OE_AF_IUCV OE_PF_IUCV\n#define OE_AF_RXRPC OE_PF_RXRPC\n#define OE_AF_ISDN OE_PF_ISDN\n#define OE_AF_PHONET OE_PF_PHONET\n#define OE_AF_IEEE802154 OE_PF_IEEE802154\n#define OE_AF_CAIF OE_PF_CAIF\n#define OE_AF_ALG OE_PF_ALG\n#define OE_AF_NFC OE_PF_NFC\n#define OE_AF_VSOCK OE_PF_VSOCK\n#define OE_AF_KCM OE_PF_KCM\n#define OE_AF_QIPCRTR OE_PF_QIPCRTR\n#define OE_AF_SMC OE_PF_SMC\n#define OE_AF_MAX OE_PF_MAX\n\n/* oe_setsockopt()/oe_getsockopt() options. */\n#define OE_SOL_SOCKET 1\n#define OE_SO_DEBUG 1\n#define OE_SO_REUSEADDR 2\n#define OE_SO_TYPE 3\n#define OE_SO_ERROR 4\n#define OE_SO_DONTROUTE 5\n#define OE_SO_BROADCAST 6\n#define OE_SO_SNDBUF 7\n#define OE_SO_RCVBUF 8\n#define OE_SO_SNDBUFFORCE 32\n#define OE_SO_RCVBUFFORCE 33\n#define OE_SO_KEEPALIVE 9\n#define OE_SO_OOBINLINE 10\n#define OE_SO_NO_CHECK 11\n#define OE_SO_PRIORITY 12\n#define OE_SO_LINGER 13\n#define OE_SO_BSDCOMPAT 14\n#define OE_SO_REUSEPORT 15\n\n/* oe_shutdown() options. */\n#define OE_SHUT_RD 0\n#define OE_SHUT_WR 1\n#define OE_SHUT_RDWR 2\n\n#define OE_MSG_PEEK 0x0002\n\n#define __OE_SOCKADDR_STORAGE oe_sockaddr_storage\n#include <openenclave/internal/syscall/sys/bits/sockaddr_storage.h>\n#undef __OE_SOCKADDR_STORAGE\n\n#define __OE_IOVEC oe_iovec\n#define __OE_MSGHDR oe_msghdr\n#include <openenclave/internal/syscall/sys/bits/msghdr.h>\n#undef __OE_IOVEC\n#undef __OE_MSGHDR\n\nvoid oe_set_default_socket_devid(uint64_t devid);\n\nuint64_t oe_get_default_socket_devid(void);\n\nint oe_socket(int domain, int type, int protocol);\n\nint oe_socket_d(uint64_t devid, int domain, int type, int protocol);\n\nint oe_socketpair(int domain, int type, int protocol, int rtnfd[2]);\n\nint oe_accept(int sockfd, struct oe_sockaddr* addr, oe_socklen_t* addrlen);\n\nint oe_bind(int sockfd, const struct oe_sockaddr* addr, oe_socklen_t namelen);\n\nint oe_connect(\n    int sockfd,\n    const struct oe_sockaddr* addr,\n    oe_socklen_t namelen);\n\nint oe_shutdown(int sockfd, int how);\n\nint oe_listen(int sockfd, int backlog);\n\nint oe_setsockopt(\n    int sockfd,\n    int level,\n    int optname,\n    const void* optval,\n    oe_socklen_t optlen);\n\nint oe_getsockopt(\n    int sockfd,\n    int level,\n    int optname,\n    void* optval,\n    oe_socklen_t* optlen);\n\nssize_t oe_send(int sockfd, const void* buf, size_t len, int flags);\n\nssize_t oe_recv(int sockfd, void* buf, size_t len, int flags);\n\nssize_t oe_sendto(\n    int sockfd,\n    const void* buf,\n    size_t len,\n    int flags,\n    const struct oe_sockaddr* dest_addr,\n    oe_socklen_t addrlen);\n\nssize_t oe_recvfrom(\n    int sockfd,\n    void* buf,\n    size_t len,\n    int flags,\n    const struct oe_sockaddr* src_addr,\n    oe_socklen_t* addrlen);\n\nssize_t oe_sendmsg(int sockfd, const struct oe_msghdr* buf, int flags);\n\nssize_t oe_recvmsg(int sockfd, struct oe_msghdr* buf, int flags);\n\nint oe_getpeername(int sockfd, struct oe_sockaddr* addr, oe_socklen_t* addrlen);\n\nint oe_getsockname(int sockfd, struct oe_sockaddr* addr, oe_socklen_t* addrlen);\n\nOE_EXTERNC_END\n\n#endif /* _OE_SYSCALL_SYS_SOCKET_H */\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#include <openenclave/enclave.h>\n\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/internal/print.h>\n#include <openenclave/internal/syscall/fcntl.h>\n#include <openenclave/internal/syscall/fd.h>\n#include <openenclave/internal/syscall/fdtable.h>\n#include <openenclave/internal/syscall/iov.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/sys/ioctl.h>\n#include <openenclave/internal/syscall/unistd.h>\n#include <openenclave/internal/thread.h>\n#include <openenclave/internal/trace.h>\n#include \"syscall_t.h\"\n\n#define MAGIC 0x0b292bab\n\ntypedef struct _file\n{\n    oe_fd_t base;\n    uint32_t magic;\n    oe_host_fd_t host_fd;\n} file_t;\n\nstatic oe_file_ops_t _get_ops(void);\n\nstatic file_t* _cast_file(const oe_fd_t* file_)\n{\n    file_t* file = (file_t*)file_;\n\n    if (file == NULL || file->magic != MAGIC)\n        return NULL;\n\n    return file;\n}\n\nstatic int _consolefs_dup(oe_fd_t* file_, oe_fd_t** new_file_out)\n{\n    int ret = -1;\n    file_t* file = _cast_file(file_);\n    file_t* new_file = NULL;\n\n    if (new_file_out)\n        *new_file_out = NULL;\n\n    if (!file || !new_file_out)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Allocate and initialize a new file structure. */\n    {\n        if (!(new_file = oe_calloc(1, sizeof(file_t))))\n            OE_RAISE_ERRNO(OE_ENOMEM);\n\n        new_file->base.type = OE_FD_TYPE_FILE;\n        new_file->base.ops.file = _get_ops();\n        new_file->magic = MAGIC;\n    }\n\n    /* Ask the host to perform this operation. */\n    {\n        oe_host_fd_t retval = -1;\n\n        if (oe_syscall_dup_ocall(&retval, file->host_fd) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (retval == -1)\n            OE_RAISE_ERRNO(oe_errno);\n\n        new_file->host_fd = retval;\n    }\n\n    *new_file_out = (oe_fd_t*)new_file;\n\n    ret = 0;\n    new_file = NULL;\n\ndone:\n\n    if (new_file)\n        oe_free(new_file);\n\n    return ret;\n}\n\nstatic int _consolefs_ioctl(oe_fd_t* file_, unsigned long request, uint64_t arg)\n{\n    int ret = -1;\n    file_t* file = _cast_file(file_);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * MUSL uses the TIOCGWINSZ ioctl request to determine whether the file\n     * descriptor refers to a terminal device (such as stdin, stdout, and\n     * stderr) so that it can use line-bufferred input and output. This check\n     * fails when delegated to the host since this implementation opens the\n     * devices by name (/dev/stdin, /dev/stderr, /dev/stdout). So the following\n     * block works around this problem by implementing TIOCGWINSZ on the\n     * enclave side. Other terminal control ioctls are left unimplemented.\n     */\n    if (request == OE_TIOCGWINSZ)\n    {\n        struct winsize\n        {\n            unsigned short int ws_row;\n            unsigned short int ws_col;\n            unsigned short int ws_xpixel;\n            unsigned short int ws_ypixel;\n        };\n        struct winsize* p;\n\n        if (!(p = (struct winsize*)arg))\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        p->ws_row = 24;\n        p->ws_col = 80;\n        p->ws_xpixel = 0;\n        p->ws_ypixel = 0;\n\n        ret = 0;\n        goto done;\n    }\n\n    if (oe_syscall_ioctl_ocall(&ret, file->host_fd, request, arg, 0, NULL) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic int _consolefs_fcntl(oe_fd_t* file_, int cmd, uint64_t arg)\n{\n    int ret = -1;\n    file_t* file = _cast_file(file_);\n    void* argout = NULL;\n    uint64_t argsize = 0;\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    switch (cmd)\n    {\n        case OE_F_GETFD:\n        case OE_F_SETFD:\n        case OE_F_GETFL:\n        case OE_F_SETFL:\n            break;\n\n        case OE_F_GETLK:\n        case OE_F_OFD_GETLK:\n            argsize = sizeof(struct oe_flock);\n            argout = (void*)arg;\n            break;\n\n        case OE_F_SETLKW:\n        case OE_F_SETLK:\n        {\n            void* srcp = (void*)arg;\n            argsize = sizeof(struct oe_flock64);\n            argout = (void*)arg;\n            memcpy(argout, srcp, argsize);\n            break;\n        }\n\n        case OE_F_OFD_SETLK:\n        case OE_F_OFD_SETLKW:\n        {\n            void* srcp = (void*)arg;\n            argsize = sizeof(struct oe_flock64);\n            argout = (void*)arg;\n            memcpy(argout, srcp, argsize);\n            break;\n        }\n\n        // for sockets\n        default:\n        case OE_F_DUPFD:\n        case OE_F_SETOWN:\n        case OE_F_GETOWN:\n        case OE_F_SETSIG:\n        case OE_F_GETSIG:\n        case OE_F_SETOWN_EX:\n        case OE_F_GETOWN_EX:\n        case OE_F_GETOWNER_UIDS:\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (oe_syscall_fcntl_ocall(\n            &ret, file->host_fd, cmd, arg, argsize, argout) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _consolefs_read(oe_fd_t* file_, void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(file_);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_read_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _consolefs_write(oe_fd_t* file_, const void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(file_);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_write_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _consolefs_readv(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!file || !iov || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    if (oe_syscall_readv_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic ssize_t _consolefs_writev(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!file || (!iov && iovcnt) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    if (oe_syscall_writev_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic oe_host_fd_t _consolefs_gethostfd(oe_fd_t* file_)\n{\n    oe_host_fd_t ret = -1;\n    file_t* file = _cast_file(file_);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = file->host_fd;\n\ndone:\n    return ret;\n}\n\nstatic oe_off_t _consolefs_lseek(oe_fd_t* file_, oe_off_t offset, int whence)\n{\n    oe_off_t ret = -1;\n\n    OE_UNUSED(file_);\n    OE_UNUSED(offset);\n    OE_UNUSED(whence);\n    OE_RAISE_ERRNO(OE_ESPIPE);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _consolefs_pread(\n    oe_fd_t* file_,\n    void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n\n    OE_UNUSED(file_);\n    OE_UNUSED(buf);\n    OE_UNUSED(count);\n    OE_UNUSED(offset);\n    OE_RAISE_ERRNO(OE_ESPIPE);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _consolefs_pwrite(\n    oe_fd_t* file_,\n    const void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n\n    OE_UNUSED(file_);\n    OE_UNUSED(buf);\n    OE_UNUSED(count);\n    OE_UNUSED(offset);\n    OE_RAISE_ERRNO(OE_ESPIPE);\n\ndone:\n    return ret;\n}\n\nstatic int _consolefs_close(oe_fd_t* file_)\n{\n    int ret = -1;\n    file_t* file = _cast_file(file_);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Ask the host to perform this operation. */\n    {\n        if (oe_syscall_close_ocall(&ret, file->host_fd) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (ret == -1)\n            OE_RAISE_ERRNO(oe_errno);\n    }\n\n    /* Free the file structure. */\n    oe_free(file);\n\ndone:\n    return ret;\n}\n\nstatic int _consolefs_getdents64(\n    oe_fd_t* file,\n    struct oe_dirent* dirp,\n    uint32_t count)\n{\n    OE_UNUSED(file);\n    OE_UNUSED(dirp);\n    OE_UNUSED(count);\n\n    /* The standard devices are not directories, so this is unsupported. */\n    OE_RAISE_ERRNO(OE_ENOTSUP);\n\ndone:\n    return -1;\n}\n\nstatic int _consolefs_fstat(oe_fd_t* file, struct oe_stat_t* buf)\n{\n    OE_UNUSED(file);\n    OE_UNUSED(buf);\n    OE_RAISE_ERRNO(OE_ENOTSUP);\ndone:\n    return -1;\n}\n\nstatic int _consolefs_fsync(oe_fd_t* file)\n{\n    OE_UNUSED(file);\n    OE_RAISE_ERRNO(OE_EINVAL);\ndone:\n    return -1;\n}\n\nstatic oe_file_ops_t _ops = {\n    .fd.read = _consolefs_read,\n    .fd.write = _consolefs_write,\n    .fd.readv = _consolefs_readv,\n    .fd.writev = _consolefs_writev,\n    .fd.dup = _consolefs_dup,\n    .fd.ioctl = _consolefs_ioctl,\n    .fd.fcntl = _consolefs_fcntl,\n    .fd.close = _consolefs_close,\n    .fd.get_host_fd = _consolefs_gethostfd,\n    .lseek = _consolefs_lseek,\n    .pread = _consolefs_pread,\n    .pwrite = _consolefs_pwrite,\n    .getdents64 = _consolefs_getdents64,\n    .fstat = _consolefs_fstat,\n    .fsync = _consolefs_fsync,\n    .fdatasync = _consolefs_fsync,\n};\n\nstatic oe_file_ops_t _get_ops(void)\n{\n    return _ops;\n}\n\nstatic oe_fd_t* _new_file(uint32_t fileno)\n{\n    oe_fd_t* ret = NULL;\n    file_t* file = NULL;\n\n    if (fileno > OE_STDERR_FILENO)\n        goto done;\n\n    /* Create the file struct. */\n    {\n        if (!(file = oe_calloc(1, sizeof(file_t))))\n            goto done;\n\n        file->base.type = OE_FD_TYPE_FILE;\n        file->base.ops.file = _ops;\n        file->magic = MAGIC;\n    }\n\n    /* Ask the host to duplicate the file descriptor. */\n    {\n        oe_host_fd_t retval;\n\n        if (oe_syscall_dup_ocall(&retval, fileno) != OE_OK)\n            goto done;\n\n        if (retval < 0)\n            goto done;\n\n        file->host_fd = retval;\n    }\n\n    ret = &file->base;\n    file = NULL;\n\ndone:\n\n    if (file)\n        oe_free(file);\n\n    return ret;\n}\n\noe_fd_t* oe_consolefs_create_file(uint32_t fileno)\n{\n    switch (fileno)\n    {\n        case OE_STDIN_FILENO:\n            return _new_file(OE_STDIN_FILENO);\n        case OE_STDOUT_FILENO:\n            return _new_file(OE_STDOUT_FILENO);\n        case OE_STDERR_FILENO:\n            return _new_file(OE_STDERR_FILENO);\n        default:\n            return NULL;\n    }\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#define _GNU_SOURCE\n\n#include <openenclave/enclave.h>\n\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/internal/calls.h>\n#include <openenclave/internal/raise.h>\n#include <openenclave/internal/safecrt.h>\n#include <openenclave/internal/syscall/device.h>\n#include <openenclave/internal/syscall/fcntl.h>\n#include <openenclave/internal/syscall/fdtable.h>\n#include <openenclave/internal/syscall/iov.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/sys/ioctl.h>\n#include <openenclave/internal/thread.h>\n#include <openenclave/internal/trace.h>\n#include <openenclave/internal/utils.h>\n#include \"syscall_t.h\"\n\n/* The map allocation grows in multiples of the chunk size. */\n#define MAP_CHUNK_SIZE 1024\n\n#define DEVICE_MAGIC 0x4504f4c\n#define EPOLL_MAGIC 0x708f5a51\n\n/* epoll_ctl() adds/modifies/deletes this mapping. */\ntypedef struct _mapping\n{\n    /* The fd parameter from epoll_ctl(). */\n    int fd;\n\n    /* The event parameter from epoll_ctl(). */\n    struct oe_epoll_event event;\n} mapping_t;\n\n/* The epoll device. */\ntypedef struct _device\n{\n    struct _oe_device base;\n\n    /* Should be DEVICE_MAGIC */\n    uint32_t magic;\n} device_t;\n\ntypedef struct _epoll\n{\n    oe_fd_t base;\n\n    /* Should be EPOLL_MAGIC */\n    uint32_t magic;\n\n    /* The host file descriptor created by epoll_create(). */\n    oe_host_fd_t host_fd;\n\n    /* Mappings added by epoll_ctl(OE_EPOLL_CTL_ADD) */\n    mapping_t* map;\n    size_t map_size;\n    size_t map_capacity;\n\n    /* Synchronizes access to this structure. */\n    oe_mutex_t lock;\n} epoll_t;\n\nstatic oe_epoll_ops_t _get_epoll_ops(void);\n\nstatic device_t* _cast_device(const oe_device_t* device_)\n{\n    device_t* device = (device_t*)device_;\n\n    if (device == NULL || device->magic != DEVICE_MAGIC)\n        return NULL;\n\n    return device;\n}\n\nstatic epoll_t* _cast_epoll(const oe_fd_t* epoll_)\n{\n    epoll_t* epoll = (epoll_t*)epoll_;\n\n    if (epoll == NULL || epoll->magic != EPOLL_MAGIC)\n        return NULL;\n\n    return epoll;\n}\n\n/* Reserve space in the mapping array (does not change map_size). */\nstatic int _map_reserve(epoll_t* epoll, size_t new_capacity)\n{\n    int ret = -1;\n\n    new_capacity = oe_round_up_to_multiple(new_capacity, MAP_CHUNK_SIZE);\n\n    if (new_capacity > epoll->map_capacity)\n    {\n        mapping_t* p;\n        const size_t n = new_capacity;\n\n        /* Reallocate the table. */\n        if (!(p = oe_realloc(epoll->map, n * sizeof(mapping_t))))\n            goto done;\n\n        /* Zero-fill the unused portion. */\n        {\n            const size_t num_bytes = (n - epoll->map_size) * sizeof(mapping_t);\n            void* ptr = p + epoll->map_size;\n\n            if (oe_memset_s(ptr, num_bytes, 0, num_bytes) != OE_OK)\n                goto done;\n        }\n\n        epoll->map = p;\n        epoll->map_capacity = n;\n    }\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Find the mapping for the given file descriptor. */\nstatic mapping_t* _map_find(epoll_t* epoll, int fd)\n{\n    size_t i;\n\n    for (i = 0; i < epoll->map_size; i++)\n    {\n        mapping_t* mapping = &epoll->map[i];\n\n        if (mapping->fd == fd)\n            return mapping;\n    }\n\n    /* Not found */\n    return NULL;\n}\n\n/* Called by oe_epoll_create1(). */\nstatic oe_fd_t* _epoll_create1(oe_device_t* device_, int32_t flags)\n{\n    oe_fd_t* ret = NULL;\n    epoll_t* epoll = NULL;\n    device_t* device = _cast_device(device_);\n    oe_host_fd_t retval;\n\n    oe_errno = 0;\n\n    if (!device)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(epoll = oe_calloc(1, sizeof(epoll_t))))\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    if (oe_syscall_epoll_create1_ocall(&retval, flags) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (retval < 0)\n        goto done;\n\n    epoll->base.type = OE_FD_TYPE_EPOLL;\n    epoll->base.ops.epoll = _get_epoll_ops();\n    epoll->magic = EPOLL_MAGIC;\n    epoll->host_fd = retval;\n\n    ret = &epoll->base;\n    epoll = NULL;\n\ndone:\n\n    if (epoll)\n        oe_free(epoll);\n\n    return ret;\n}\n\n/* Called by oe_epoll_create(). */\nstatic oe_fd_t* _epoll_create(oe_device_t* device_, int size)\n{\n    /* The size argument is ignored according to the manpage. */\n    OE_UNUSED(size);\n\n    /* Delegate with flags=0. */\n    return _epoll_create1(device_, 0);\n}\n\nstatic int _epoll_ctl_add(epoll_t* epoll, int fd, struct oe_epoll_event* event)\n{\n    int ret = -1;\n    oe_fd_t* desc;\n    oe_host_fd_t host_epfd;\n    oe_host_fd_t host_fd;\n    struct oe_epoll_event host_event;\n    int retval;\n    bool locked = false;\n\n    oe_errno = 0;\n\n    /* Check parameters. */\n    if (!epoll || !event)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(desc = oe_fdtable_get(fd, OE_FD_TYPE_ANY)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* Get the host fd for the epoll object. */\n    host_epfd = epoll->host_fd;\n\n    /* Get the host fd for the fd. */\n    if ((host_fd = desc->ops.fd.get_host_fd(desc)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* Initialize the host event. */\n    {\n        const size_t num_bytes = sizeof(host_event);\n\n        if (oe_memset_s(&host_event, num_bytes, 0, num_bytes) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        host_event.events = event->events;\n        host_event.data.fd = fd;\n    }\n\n    // The host call and the map update must be done in an atomic operation.\n    locked = true;\n    oe_mutex_lock(&epoll->lock);\n\n    if (oe_syscall_epoll_ctl_ocall(\n            &retval, host_epfd, OE_EPOLL_CTL_ADD, host_fd, &host_event) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (retval == 0)\n    {\n        if (_map_reserve(epoll, epoll->map_size + 1) != 0)\n            OE_RAISE_ERRNO(OE_ENOMEM);\n\n        epoll->map[epoll->map_size].fd = fd;\n        epoll->map[epoll->map_size].event = *event;\n        epoll->map_size++;\n    }\n\n    ret = retval;\n\ndone:\n\n    if (locked)\n        oe_mutex_unlock(&epoll->lock);\n\n    return ret;\n}\n\nstatic int _epoll_ctl_mod(epoll_t* epoll, int fd, struct oe_epoll_event* event)\n{\n    int ret = -1;\n    oe_fd_t* desc;\n    oe_host_fd_t host_epfd;\n    oe_host_fd_t host_fd;\n    struct oe_epoll_event host_event;\n    int retval;\n    bool locked = false;\n\n    oe_errno = 0;\n\n    /* Check parameters. */\n    if (!epoll || !event)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(desc = oe_fdtable_get(fd, OE_FD_TYPE_ANY)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* Get the host fd for the epoll device. */\n    host_epfd = epoll->host_fd;\n\n    /* Get the host fd for the device. */\n    if ((host_fd = desc->ops.fd.get_host_fd(desc)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* Initialize the host event. */\n    {\n        const size_t num_bytes = sizeof(host_event);\n\n        if (oe_memset_s(&host_event, num_bytes, 0, num_bytes) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        host_event.events = event->events;\n        host_event.data.fd = fd;\n    }\n\n    // The host call and the map update must be done in an atomic operation.\n    locked = true;\n    oe_mutex_lock(&epoll->lock);\n\n    if (oe_syscall_epoll_ctl_ocall(\n            &retval, host_epfd, OE_EPOLL_CTL_MOD, host_fd, &host_event) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(oe_errno);\n    }\n\n    /* Modify the mapping. */\n    if (retval == 0)\n    {\n        mapping_t* const mapping = _map_find(epoll, fd);\n        if (!mapping)\n            OE_RAISE_ERRNO(OE_ENOENT);\n\n        mapping->event = *event;\n    }\n\n    ret = 0;\n\ndone:\n    if (locked)\n        oe_mutex_unlock(&epoll->lock);\n\n    return ret;\n}\n\nstatic int _epoll_ctl_del(epoll_t* epoll, int fd)\n{\n    int ret = -1;\n    oe_fd_t* desc;\n    oe_host_fd_t host_epfd;\n    oe_host_fd_t host_fd;\n    int retval;\n    bool locked = false;\n\n    oe_errno = 0;\n\n    /* Check parameters. */\n    if (!epoll)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(desc = oe_fdtable_get(fd, OE_FD_TYPE_ANY)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* Get the host fd for the epoll device. */\n    host_epfd = epoll->host_fd;\n\n    /* Get the host fd for the device. */\n    if ((host_fd = desc->ops.fd.get_host_fd(desc)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    // The host call and the map update must be done in an atomic operation.\n    locked = true;\n    oe_mutex_lock(&epoll->lock);\n\n    if (oe_syscall_epoll_ctl_ocall(\n            &retval, host_epfd, OE_EPOLL_CTL_DEL, host_fd, NULL) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Delete the mapping. */\n    if (retval == 0)\n    {\n        bool found = false;\n\n        for (size_t i = 0; i < epoll->map_size; i++)\n        {\n            if (epoll->map[i].fd == fd)\n            {\n                /* Swap with last element of array. */\n                epoll->map[i] = epoll->map[--epoll->map_size];\n                found = true;\n                break;\n            }\n        }\n\n        if (!found)\n            OE_RAISE_ERRNO(OE_ENOENT);\n    }\n\n    ret = 0;\n\ndone:\n    if (locked)\n        oe_mutex_unlock(&epoll->lock);\n\n    return ret;\n}\n\n/* Called by oe_epoll_ctl(). */\nstatic int _epoll_ctl(\n    oe_fd_t* epoll_,\n    int op,\n    int fd,\n    struct oe_epoll_event* event)\n{\n    int ret = -1;\n    epoll_t* epoll = _cast_epoll(epoll_);\n\n    if (!epoll)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    switch (op)\n    {\n        case OE_EPOLL_CTL_ADD:\n        {\n            ret = _epoll_ctl_add(epoll, fd, event);\n            goto done;\n        }\n\n        case OE_EPOLL_CTL_MOD:\n        {\n            ret = _epoll_ctl_mod(epoll, fd, event);\n            goto done;\n        }\n\n        case OE_EPOLL_CTL_DEL:\n        {\n            ret = _epoll_ctl_del(epoll, fd);\n            goto done;\n        }\n\n        default:\n        {\n            OE_RAISE_ERRNO(OE_EINVAL);\n            return -1;\n        }\n    }\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Called by oe_epoll_wait(). */\nstatic int _epoll_wait(\n    oe_fd_t* epoll_,\n    struct oe_epoll_event* events,\n    int maxevents,\n    int timeout)\n{\n    int ret = -1;\n    int retval;\n    bool locked = false;\n    epoll_t* epoll = _cast_epoll(epoll_);\n    oe_host_fd_t host_epfd = -1;\n\n    if (!epoll || !events || maxevents <= 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    oe_errno = 0;\n\n    if ((host_epfd = epoll_->ops.fd.get_host_fd(epoll_)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_epoll_wait_ocall(\n            &retval, host_epfd, events, (unsigned int)maxevents, timeout) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (retval > 0)\n    {\n        if (retval > maxevents)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        locked = true;\n        oe_mutex_lock(&epoll->lock);\n\n        for (int i = 0; i < retval; i++)\n        {\n            struct oe_epoll_event* const event = &events[i];\n            const mapping_t* const mapping = _map_find(epoll, event->data.fd);\n\n            if (mapping)\n                event->data.u64 = mapping->event.data.u64;\n            else\n            {\n                // fd has been deleted between the return of epoll_wait and the\n                // acquisition of the lock.\n                --retval;\n                *event = events[retval];\n                --i;\n            }\n        }\n    }\n\n    ret = (int)retval;\n\ndone:\n    if (locked)\n        oe_mutex_unlock(&epoll->lock);\n\n    return ret;\n}\n\n/* Called by oe_close(). */\nstatic int _epoll_close(oe_fd_t* epoll_)\n{\n    int ret = -1;\n    epoll_t* epoll = _cast_epoll(epoll_);\n    int retval = -1;\n\n    oe_errno = 0;\n\n    if (!epoll)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Close the file descriptor on the host side. */\n    if (oe_syscall_epoll_close_ocall(&retval, epoll->host_fd) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (retval == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (epoll->map)\n        oe_free(epoll->map);\n\n    oe_free(epoll);\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\nstatic int _epoll_release(oe_device_t* device_)\n{\n    int ret = -1;\n    device_t* device = _cast_device(device_);\n\n    oe_errno = 0;\n\n    if (!device)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    oe_free(device);\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\nstatic oe_host_fd_t _epoll_get_host_fd(oe_fd_t* epoll_)\n{\n    epoll_t* epoll = _cast_epoll(epoll_);\n    return epoll->host_fd;\n}\n\nstatic int _epoll_ioctl(oe_fd_t* desc, unsigned long request, uint64_t arg)\n{\n    int ret = -1;\n    epoll_t* epoll = _cast_epoll(desc);\n    uint64_t argsize = 0;\n    void* argout = NULL;\n\n    if (!epoll)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * MUSL uses the TIOCGWINSZ ioctl request to determine whether the file\n     * descriptor refers to a terminal device. This request cannot be handled\n     * by Windows hosts, so the error is handled on the enclave side. This is\n     * the correct behavior since epolls are not terminal devices.\n     */\n    switch (request)\n    {\n        default:\n            OE_RAISE_ERRNO(OE_ENOTTY);\n    }\n\n    /* Call the host to perform the ioctl() operation. */\n    if (oe_syscall_ioctl_ocall(\n            &ret, epoll->host_fd, request, arg, argsize, argout) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic int _epoll_fcntl(oe_fd_t* desc, int cmd, uint64_t arg)\n{\n    int ret = -1;\n    epoll_t* epoll = _cast_epoll(desc);\n    void* argout = NULL;\n    uint64_t argsize = 0;\n\n    if (!epoll)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    switch (cmd)\n    {\n        case OE_F_GETFD:\n        case OE_F_SETFD:\n        case OE_F_GETFL:\n        case OE_F_SETFL:\n            break;\n\n        case OE_F_GETLK64:\n        case OE_F_OFD_GETLK:\n            argsize = sizeof(struct oe_flock);\n            argout = (void*)arg;\n            break;\n\n        case OE_F_SETLKW64:\n        case OE_F_SETLK64:\n        {\n            void* srcp = (void*)arg;\n            argsize = sizeof(struct oe_flock64);\n            argout = (void*)arg;\n            memcpy(argout, srcp, argsize);\n            break;\n        }\n\n        case OE_F_OFD_SETLK:\n        case OE_F_OFD_SETLKW:\n        {\n            void* srcp = (void*)arg;\n            argsize = sizeof(struct oe_flock64);\n            argout = (void*)arg;\n            memcpy(argout, srcp, argsize);\n            break;\n        }\n\n        // for sockets\n        default:\n        case OE_F_DUPFD: // Should be handled in posix layer\n        case OE_F_SETOWN:\n        case OE_F_GETOWN:\n        case OE_F_SETSIG:\n        case OE_F_GETSIG:\n        case OE_F_SETOWN_EX:\n        case OE_F_GETOWN_EX:\n        case OE_F_GETOWNER_UIDS:\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (oe_syscall_fcntl_ocall(\n            &ret, epoll->host_fd, cmd, arg, argsize, argout) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _epoll_read(oe_fd_t* epoll_, void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(epoll_);\n\n    oe_errno = 0;\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_read_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _epoll_write(oe_fd_t* epoll_, const void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    epoll_t* epoll = _cast_epoll(epoll_);\n\n    oe_errno = 0;\n\n    /* Call the host. */\n    if (oe_syscall_write_ocall(&ret, epoll->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _epoll_readv(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!file || (iovcnt && !iov) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    if (oe_syscall_readv_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic ssize_t _epoll_writev(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!file || (iovcnt && !iov) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    if (oe_syscall_writev_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic int _epoll_dup(oe_fd_t* epoll_, oe_fd_t** new_epoll_out)\n{\n    int ret = -1;\n    epoll_t* epoll = _cast_epoll(epoll_);\n    epoll_t* new_epoll = NULL;\n    oe_host_fd_t retval;\n\n    oe_errno = 0;\n\n    /* Check parameters. */\n    if (!new_epoll_out)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!epoll)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call host: */\n    {\n        if (oe_syscall_dup_ocall(&retval, epoll->host_fd) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (retval == -1)\n            OE_RAISE_ERRNO(oe_errno);\n    }\n\n    /* Create the new epoll object. */\n    {\n        if (!(new_epoll = oe_calloc(1, sizeof(epoll_t))))\n            OE_RAISE_ERRNO(oe_errno);\n\n        new_epoll->base.type = OE_FD_TYPE_EPOLL;\n        new_epoll->base.ops.epoll = _get_epoll_ops();\n        new_epoll->magic = EPOLL_MAGIC;\n        new_epoll->host_fd = retval;\n\n        if (epoll->map && epoll->map_size)\n        {\n            mapping_t* map;\n\n            if (!(map = oe_calloc(epoll->map_size, sizeof(mapping_t))))\n                OE_RAISE_ERRNO(OE_ENOMEM);\n\n            memcpy(map, epoll->map, epoll->map_size * sizeof(mapping_t));\n            new_epoll->map = map;\n            new_epoll->map_size = epoll->map_size;\n        }\n\n        *new_epoll_out = &new_epoll->base;\n        new_epoll = NULL;\n    }\n\n    ret = 0;\n\ndone:\n\n    if (new_epoll)\n        oe_free(new_epoll);\n\n    return ret;\n}\n\nstatic void _epoll_on_close(oe_fd_t* epoll_, int fd)\n{\n    epoll_t* const epoll = _cast_epoll(epoll_);\n    oe_assert(epoll);\n\n    oe_assert(fd >= 0);\n\n    oe_mutex_lock(&epoll->lock);\n\n    /* Delete the mapping if it exists. */\n    for (size_t i = 0; i < epoll->map_size; i++)\n    {\n        if (epoll->map[i].fd == fd)\n        {\n            /* Swap with last element of array. */\n            epoll->map[i] = epoll->map[--epoll->map_size];\n            break;\n        }\n    }\n\n    oe_mutex_unlock(&epoll->lock);\n}\n\nstatic oe_epoll_ops_t _epoll_ops = {\n    .fd.read = _epoll_read,\n    .fd.write = _epoll_write,\n    .fd.readv = _epoll_readv,\n    .fd.writev = _epoll_writev,\n    .fd.dup = _epoll_dup,\n    .fd.ioctl = _epoll_ioctl,\n    .fd.fcntl = _epoll_fcntl,\n    .fd.close = _epoll_close,\n    .fd.get_host_fd = _epoll_get_host_fd,\n    .epoll_ctl = _epoll_ctl,\n    .epoll_wait = _epoll_wait,\n    .on_close = _epoll_on_close,\n};\n\nstatic oe_epoll_ops_t _get_epoll_ops(void)\n{\n    return _epoll_ops;\n}\n\n// clang-format off\nstatic device_t _device =\n{\n    .base.type = OE_DEVICE_TYPE_EPOLL,\n    .base.name = OE_DEVICE_NAME_HOST_EPOLL,\n    .base.ops.epoll =\n    {\n        .base.release = _epoll_release,\n        .epoll_create = _epoll_create,\n        .epoll_create1 = _epoll_create1,\n    },\n    .magic = DEVICE_MAGIC,\n};\n// clang-format on\n\noe_result_t oe_load_module_host_epoll(void)\n{\n    oe_result_t result = OE_UNEXPECTED;\n    static oe_spinlock_t _lock = OE_SPINLOCK_INITIALIZER;\n    static bool _loaded = false;\n\n    oe_spin_lock(&_lock);\n\n    if (!_loaded)\n    {\n        if (oe_device_table_set(OE_DEVID_HOST_EPOLL, &_device.base) != 0)\n        {\n            /* Do not propagate errno to caller. */\n            oe_errno = 0;\n            OE_RAISE(OE_FAILURE);\n        }\n\n        _loaded = true;\n    }\n\n    result = OE_OK;\n\ndone:\n    oe_spin_unlock(&_lock);\n\n    return result;\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n/*\n**==============================================================================\n**\n** hostfs:\n**\n**     This module implements the host file system, which allows enclaves to\n**     manipulate non-secure host files. To use this module, the enclave\n**     application must:\n**\n**     (1) Link the oehostfs library.\n**     (2) Load the module by calling oe_load_module_host_file_system().\n**     (3) Use the standard C file I/O functions (e.g., open, read, write).\n**\n**==============================================================================\n*/\n\n// clang-format off\n#include <openenclave/enclave.h>\n// clang-format on\n\n#include <openenclave/internal/syscall/device.h>\n#include <openenclave/internal/thread.h>\n#include <openenclave/internal/syscall/dirent.h>\n#include <openenclave/internal/syscall/sys/mount.h>\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/internal/syscall/fcntl.h>\n#include <openenclave/internal/syscall/sys/ioctl.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/iov.h>\n#include <openenclave/internal/raise.h>\n#include <openenclave/internal/hexdump.h>\n#include <openenclave/internal/safecrt.h>\n\n#include \"syscall_t.h\"\n\n#define FS_MAGIC 0x5f35f964\n#define FILE_MAGIC 0xfe48c6ff\n#define DIR_MAGIC 0x8add1b0b\n\n/* Mask to extract the access mode: O_RDONLY, O_WRONLY, O_RDWR. */\n#define ACCESS_MODE_MASK 000000003\n\n/* The host file system device. */\ntypedef struct _device\n{\n    oe_device_t base;\n\n    /* Must be FS_MAGIC. */\n    uint32_t magic;\n\n    /* True if this file system has been mounted. */\n    bool is_mounted;\n\n    /* The parameters that were passed to the mount() function. */\n    struct\n    {\n        unsigned long flags;\n        char source[OE_PATH_MAX];\n        char target[OE_PATH_MAX];\n    } mount;\n} device_t;\n\n/* Create by open(). */\ntypedef struct _file\n{\n    oe_fd_t base;\n\n    /* Must be FILE_MAGIC. */\n    uint32_t magic;\n\n    /* The file descriptor obtained from the host or -1 for directory files. */\n    oe_host_fd_t host_fd;\n\n    /* The file descriptor for an open directory if non-null. */\n    oe_fd_t* dir;\n} file_t;\n\n/* Created by opendir(), updated by readdir(), closed by closedir(). */\ntypedef struct _dir\n{\n    oe_fd_t base;\n\n    /* Must be DIR_MAGIC. */\n    uint32_t magic;\n\n    /* The directory handle obtained from the host by opendir(). */\n    uint64_t host_dir;\n\n    /* The directory entry obtained from the host by readdir(). */\n    struct oe_dirent entry;\n} dir_t;\n\nstatic oe_file_ops_t _get_file_ops(void);\n\nstatic ssize_t _hostfs_read(oe_fd_t* desc, void* buf, size_t count);\n\nstatic int _hostfs_close(oe_fd_t* desc);\n\nstatic oe_fd_t* _hostfs_opendir(oe_device_t* device, const char* name);\n\nstatic int _hostfs_closedir(oe_fd_t* desc);\n\nstatic struct oe_dirent* _hostfs_readdir(oe_fd_t* desc);\n\n/* Return true if the file system was mounted as read-only. */\nOE_INLINE bool _is_read_only(const device_t* fs)\n{\n    return fs->mount.flags & OE_MS_RDONLY;\n}\n\nstatic device_t* _cast_device(const oe_device_t* device)\n{\n    device_t* ret = NULL;\n    device_t* fs = (device_t*)device;\n\n    if (fs == NULL || fs->magic != FS_MAGIC)\n        goto done;\n\n    ret = fs;\n\ndone:\n    return ret;\n}\n\nstatic file_t* _cast_file(const oe_fd_t* desc)\n{\n    file_t* ret = NULL;\n    file_t* file = (file_t*)desc;\n\n    if (file == NULL || file->magic != FILE_MAGIC)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = file;\n\ndone:\n    return ret;\n}\n\nstatic dir_t* _cast_dir(const oe_fd_t* desc)\n{\n    dir_t* ret = NULL;\n    dir_t* dir = (dir_t*)desc;\n\n    if (dir == NULL || dir->magic != DIR_MAGIC)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = dir;\n\ndone:\n    return ret;\n}\n\n/* Expand an enclave path to a host path. */\nstatic int _make_host_path(\n    const device_t* fs,\n    const char* enclave_path,\n    char host_path[OE_PATH_MAX])\n{\n    const size_t n = OE_PATH_MAX;\n    int ret = -1;\n\n    if (oe_strcmp(fs->mount.source, \"/\") == 0)\n    {\n        if (oe_strlcpy(host_path, enclave_path, OE_PATH_MAX) >= n)\n            OE_RAISE_ERRNO(OE_ENAMETOOLONG);\n    }\n    else\n    {\n        if (oe_strlcpy(host_path, fs->mount.source, OE_PATH_MAX) >= n)\n            OE_RAISE_ERRNO(OE_ENAMETOOLONG);\n\n        if (oe_strcmp(enclave_path, \"/\") != 0)\n        {\n            if (oe_strlcat(host_path, \"/\", OE_PATH_MAX) >= n)\n                OE_RAISE_ERRNO(OE_ENAMETOOLONG);\n\n            if (oe_strlcat(host_path, enclave_path, OE_PATH_MAX) >= n)\n                OE_RAISE_ERRNO(OE_ENAMETOOLONG);\n        }\n    }\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Called by oe_mount(). */\nstatic int _hostfs_mount(\n    oe_device_t* device,\n    const char* source,\n    const char* target,\n    const char* filesystemtype,\n    unsigned long flags,\n    const void* data)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n\n    /* Fail if required parameters are null. */\n    if (!fs || !source || !target)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if this file system is already mounted. */\n    if (fs->is_mounted)\n        OE_RAISE_ERRNO(OE_EBUSY);\n\n    /* Cross check the file system type. */\n    if (oe_strcmp(filesystemtype, OE_DEVICE_NAME_HOST_FILE_SYSTEM) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* The data parameter is not supported for host file systems. */\n    if (data)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Remember whether this is a read-only mount. */\n    if ((flags & OE_MS_RDONLY))\n        fs->mount.flags = flags;\n\n    /* ---------------------------------------------------------------------\n     * Only support absolute paths. Hostfs is treated as an external\n     * filesystem. As such, it does not make sense to resolve relative paths\n     * using the enclave's current working directory.\n     * ---------------------------------------------------------------------\n     */\n    if (source && source[0] != '/')\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Save the source parameter (will be needed to form host paths). */\n    oe_strlcpy(fs->mount.source, source, sizeof(fs->mount.source));\n\n    /* Save the target parameter (checked by the umount2() function). */\n    oe_strlcpy(fs->mount.target, target, sizeof(fs->mount.target));\n\n    /* Set the flag indicating that this file system is mounted. */\n    fs->is_mounted = true;\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Called by oe_umount2(). */\nstatic int _hostfs_umount2(oe_device_t* device, const char* target, int flags)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n\n    OE_UNUSED(flags);\n\n    /* Fail if any required parameters are null. */\n    if (!fs || !target)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if this file system is not mounted. */\n    if (!fs->is_mounted)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Cross check target parameter with the one passed to mount(). */\n    if (oe_strcmp(target, fs->mount.target) != 0)\n        OE_RAISE_ERRNO(OE_ENOENT);\n\n    /* Clear the cached mount parameters. */\n    oe_memset_s(&fs->mount, sizeof(fs->mount), 0, sizeof(fs->mount));\n\n    /* Set the flag indicating that this file system is mounted. */\n    fs->is_mounted = false;\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Called by oe_mount() to make a copy of this device. */\nstatic int _hostfs_clone(oe_device_t* device, oe_device_t** new_device)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    device_t* new_fs = NULL;\n\n    if (!fs || !new_device)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(new_fs = oe_calloc(1, sizeof(device_t))))\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    *new_fs = *fs;\n    *new_device = &new_fs->base;\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Called by oe_umount() to release this device. */\nstatic int _hostfs_release(oe_device_t* device)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n\n    if (!fs)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    oe_free(fs);\n    ret = 0;\n\ndone:\n    return ret;\n}\n\nstatic oe_fd_t* _hostfs_open_file(\n    oe_device_t* device,\n    const char* pathname,\n    int flags,\n    oe_mode_t mode)\n{\n    oe_fd_t* ret = NULL;\n    device_t* fs = _cast_device(device);\n    file_t* file = NULL;\n    char host_path[OE_PATH_MAX];\n    oe_host_fd_t retval = -1;\n\n    /* Fail if any required parameters are null. */\n    if (!fs || !pathname)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if attempting to write to a read-only file system. */\n    if (_is_read_only(fs) && (flags & ACCESS_MODE_MASK) != OE_O_RDONLY)\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    /* Create new file struct. */\n    {\n        if (!(file = oe_calloc(1, sizeof(file_t))))\n            OE_RAISE_ERRNO(OE_ENOMEM);\n\n        file->base.type = OE_FD_TYPE_FILE;\n        file->magic = FILE_MAGIC;\n        file->base.ops.file = _get_file_ops();\n    }\n\n    /* Ask the host to open the file. */\n    {\n        if (_make_host_path(fs, pathname, host_path) != 0)\n            OE_RAISE_ERRNO_MSG(oe_errno, \"pathname=%s\", pathname);\n\n        if (oe_syscall_open_ocall(&retval, host_path, flags, mode) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (retval < 0)\n            goto done;\n\n        file->host_fd = retval;\n    }\n\n    ret = &file->base;\n    file = NULL;\n\ndone:\n\n    if (file)\n        oe_free(file);\n\n    return ret;\n}\n\nstatic oe_fd_t* _hostfs_open_directory(\n    oe_device_t* device,\n    const char* pathname,\n    int flags)\n{\n    oe_fd_t* ret = NULL;\n    device_t* fs = _cast_device(device);\n    file_t* file = NULL;\n    oe_fd_t* dir = NULL;\n\n    /* Check parameters */\n    if (!fs || !pathname || !(flags & OE_O_DIRECTORY))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Directories can only be opened for read access. */\n    if ((flags & ACCESS_MODE_MASK) != OE_O_RDONLY)\n        OE_RAISE_ERRNO(OE_EACCES);\n\n    /* Attempt to open the directory. */\n    if (!(dir = _hostfs_opendir(device, pathname)))\n        OE_RAISE_ERRNO_MSG(oe_errno, \"pathname=%s\", pathname);\n\n    /* Allocate and initialize the file struct. */\n    {\n        if (!(file = oe_calloc(1, sizeof(file_t))))\n            OE_RAISE_ERRNO(OE_ENOMEM);\n\n        file->base.type = OE_FD_TYPE_FILE;\n        file->magic = FILE_MAGIC;\n        file->base.ops.file = _get_file_ops();\n        file->host_fd = -1;\n        file->dir = dir;\n    }\n\n    ret = &file->base;\n    file = NULL;\n    dir = NULL;\n\ndone:\n\n    if (file)\n        oe_free(file);\n\n    if (dir)\n        _hostfs_closedir(dir);\n\n    return ret;\n}\n\nstatic oe_fd_t* _hostfs_open(\n    oe_device_t* fs,\n    const char* pathname,\n    int flags,\n    oe_mode_t mode)\n{\n    if ((flags & OE_O_DIRECTORY))\n    {\n        /* Only existing directories can be opened, so mode is ignored. */\n        return _hostfs_open_directory(fs, pathname, flags);\n    }\n    else\n    {\n        return _hostfs_open_file(fs, pathname, flags, mode);\n    }\n}\n\nstatic int _hostfs_flock(oe_fd_t* desc, int operation)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host to perform the flock(). */\n    if (oe_syscall_flock_ocall(&ret, file->host_fd, operation) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_fsync(oe_fd_t* desc)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_fsync_ocall(&ret, file->host_fd) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_fdatasync(oe_fd_t* desc)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_fdatasync_ocall(&ret, file->host_fd) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_dup(oe_fd_t* desc, oe_fd_t** new_file_out)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n    file_t* new_file = NULL;\n\n    if (!new_file_out)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    *new_file_out = NULL;\n\n    /* Check parameters. */\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Create and initialize the new file structure. */\n    {\n        if (!(new_file = oe_calloc(1, sizeof(file_t))))\n            OE_RAISE_ERRNO(oe_errno);\n\n        new_file->base.type = OE_FD_TYPE_FILE;\n        new_file->base.ops.file = _get_file_ops();\n        new_file->magic = FILE_MAGIC;\n    }\n\n    /* Call the host to perform the dup(). */\n    {\n        oe_host_fd_t retval = -1;\n\n        if (oe_syscall_dup_ocall(&retval, file->host_fd) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (retval == -1)\n            OE_RAISE_ERRNO(oe_errno);\n\n        new_file->host_fd = retval;\n    }\n\n    *new_file_out = &new_file->base;\n    new_file = NULL;\n    ret = 0;\n\ndone:\n\n    if (new_file)\n        oe_free(new_file);\n\n    return ret;\n}\n\nstatic ssize_t _hostfs_read(oe_fd_t* desc, void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host to perform the read(). */\n    if (oe_syscall_read_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\n/* Called by oe_getdents64() to handle the getdents64 system call. */\nstatic int _hostfs_getdents64(\n    oe_fd_t* desc,\n    struct oe_dirent* dirp,\n    unsigned int count)\n{\n    int ret = -1;\n    int bytes = 0;\n    file_t* file = _cast_file(desc);\n    unsigned int i;\n    unsigned int n = count / sizeof(struct oe_dirent);\n\n    if (!file || !file->dir || !dirp)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Read the entries one-by-one. */\n    for (i = 0; i < n; i++)\n    {\n        struct oe_dirent* ent;\n\n        oe_errno = 0;\n\n        if (!(ent = _hostfs_readdir(file->dir)))\n        {\n            if (oe_errno)\n            {\n                OE_RAISE_ERRNO(oe_errno);\n                goto done;\n            }\n\n            break;\n        }\n\n        *dirp = *ent;\n        bytes += (int)sizeof(struct oe_dirent);\n        dirp++;\n    }\n\n    ret = bytes;\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostfs_write(oe_fd_t* desc, const void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    /* Check parameters. */\n    if (!file || (count && !buf))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_write_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostfs_readv(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!file || (!iov && iovcnt) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    if (oe_syscall_readv_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (ret > 0)\n    {\n        if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic ssize_t _hostfs_writev(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!file || !iov || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    if (oe_syscall_writev_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic oe_off_t _hostfs_lseek_file(oe_fd_t* desc, oe_off_t offset, int whence)\n{\n    oe_off_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_lseek_ocall(&ret, file->host_fd, offset, whence) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\n/* Perform rewinddir on a dir struct. */\nstatic int _hostfs_rewinddir(oe_fd_t* desc)\n{\n    int ret = -1;\n    dir_t* dir = _cast_dir(desc);\n\n    if (!dir)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_rewinddir_ocall(dir->host_dir) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Perform lseek on a dir struct (only rewind is permitted on a directory). */\nstatic oe_off_t _hostfs_lseek_dir(oe_fd_t* desc, oe_off_t offset, int whence)\n{\n    oe_off_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file || !file->dir || offset != 0 || whence != OE_SEEK_SET)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if ((ret = _hostfs_rewinddir(file->dir)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\ndone:\n    return ret;\n}\n\nstatic oe_off_t _hostfs_lseek(oe_fd_t* desc, oe_off_t offset, int whence)\n{\n    oe_off_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (file->dir)\n        ret = _hostfs_lseek_dir(desc, offset, whence);\n    else\n        ret = _hostfs_lseek_file(desc, offset, whence);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostfs_pread(\n    oe_fd_t* desc,\n    void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pread_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostfs_pwrite(\n    oe_fd_t* desc,\n    const void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pwrite_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_close_file(oe_fd_t* desc)\n{\n    int ret = -1;\n    int retval = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_close_ocall(&retval, file->host_fd) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (retval == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    oe_free(file);\n\n    ret = retval;\n\ndone:\n    return ret;\n}\n\n/* Close a directory file. */\nstatic int _hostfs_close_directory(oe_fd_t* desc)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n\n    /* Check parameters. */\n    if (!file || !file->dir)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Release the directory object. */\n    if (_hostfs_closedir(file->dir) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* Release the file object. */\n    oe_free(file);\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_close(oe_fd_t* desc)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (file->dir)\n        ret = _hostfs_close_directory(desc);\n    else\n        ret = _hostfs_close_file(desc);\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_ioctl(oe_fd_t* desc, unsigned long request, uint64_t arg)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n    uint64_t argsize = 0;\n    void* argout = NULL;\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * MUSL uses the TIOCGWINSZ ioctl request to determine whether the file\n     * descriptor refers to a terminal device. This request cannot be handled\n     * by Windows hosts, so the error is handled on the enclave side. This is\n     * the correct behavior since host files are not terminal devices.\n     */\n    switch (request)\n    {\n        default:\n            OE_RAISE_ERRNO(OE_ENOTTY);\n    }\n\n    /* Call the host to perform the ioctl() operation. */\n    if (oe_syscall_ioctl_ocall(\n            &ret, file->host_fd, request, arg, argsize, argout) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_fcntl(oe_fd_t* desc, int cmd, uint64_t arg)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n    void* argout = NULL;\n    uint64_t argsize = 0;\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    switch (cmd)\n    {\n        case OE_F_GETFD:\n        case OE_F_SETFD:\n        case OE_F_GETFL:\n        case OE_F_SETFL:\n            break;\n\n        case OE_F_GETLK64:\n        case OE_F_OFD_GETLK:\n            argsize = sizeof(struct oe_flock);\n            argout = (void*)arg;\n            break;\n\n        case OE_F_SETLKW64:\n        case OE_F_SETLK64:\n        {\n            void* srcp = (void*)arg;\n            argsize = sizeof(struct oe_flock64);\n            argout = (void*)arg;\n            memcpy(argout, srcp, argsize);\n            break;\n        }\n\n        case OE_F_OFD_SETLK:\n        case OE_F_OFD_SETLKW:\n        {\n            void* srcp = (void*)arg;\n            argsize = sizeof(struct oe_flock64);\n            argout = (void*)arg;\n            memcpy(argout, srcp, argsize);\n            break;\n        }\n\n        // for sockets\n        default:\n        case OE_F_DUPFD: // Should be handled in posix layer\n        case OE_F_SETOWN:\n        case OE_F_GETOWN:\n        case OE_F_SETSIG:\n        case OE_F_GETSIG:\n        case OE_F_SETOWN_EX:\n        case OE_F_GETOWN_EX:\n        case OE_F_GETOWNER_UIDS:\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (oe_syscall_fcntl_ocall(\n            &ret, file->host_fd, cmd, arg, argsize, argout) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\n/* Open a directory file. */\nstatic oe_fd_t* _hostfs_opendir(oe_device_t* device, const char* name)\n{\n    oe_fd_t* ret = NULL;\n    device_t* fs = _cast_device(device);\n    dir_t* dir = NULL;\n    char host_name[OE_PATH_MAX];\n    uint64_t retval = 0;\n\n    if (!fs || !name)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (_make_host_path(fs, name, host_name) != 0)\n        OE_RAISE_ERRNO_MSG(oe_errno, \"name=%s\", name);\n\n    if (!(dir = oe_calloc(1, sizeof(dir_t))))\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    if (oe_syscall_opendir_ocall(&retval, host_name) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!retval)\n        OE_RAISE_ERRNO(oe_errno);\n\n    dir->base.type = OE_FD_TYPE_FILE;\n    dir->magic = DIR_MAGIC;\n    dir->base.ops.file = _get_file_ops();\n    dir->host_dir = retval;\n\n    ret = &dir->base;\n    dir = NULL;\n\ndone:\n\n    if (dir)\n        oe_free(dir);\n\n    return ret;\n}\n\n/* Get the next directory entry from the host. */\nstatic struct oe_dirent* _hostfs_readdir(oe_fd_t* desc)\n{\n    struct oe_dirent* ret = NULL;\n    dir_t* dir = _cast_dir(desc);\n    int retval = -1;\n\n    if (!dir)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host to get the next directory entry. */\n    if (oe_syscall_readdir_ocall(&retval, dir->host_dir, &dir->entry) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Handle any error. */\n    if (retval == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* If end of file, then return NULL. */\n    if (retval == 1)\n        goto done;\n\n    /* Check for an unexpected return value (indicates a coding error). */\n    if (retval != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = &dir->entry;\n\ndone:\n\n    return ret;\n}\n\n/* Close the directory file. */\nstatic int _hostfs_closedir(oe_fd_t* desc)\n{\n    int ret = -1;\n    dir_t* dir = _cast_dir(desc);\n    int retval = -1;\n\n    if (!dir)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_closedir_ocall(&retval, dir->host_dir) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    oe_free(dir);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_stat(\n    oe_device_t* device,\n    const char* pathname,\n    struct oe_stat_t* buf)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_path[OE_PATH_MAX];\n    int retval = -1;\n\n    if (buf)\n        oe_memset_s(buf, sizeof(*buf), 0, sizeof(*buf));\n\n    if (!fs || !pathname || !buf)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (_make_host_path(fs, pathname, host_path) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_stat_ocall(&retval, host_path, buf) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_fstat(oe_fd_t* desc, struct oe_stat_t* buf)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n    int retval = -1;\n\n    if (buf)\n        oe_memset_s(buf, sizeof(*buf), 0, sizeof(*buf));\n\n    if (!file || !buf)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_fstat_ocall(&retval, file->host_fd, buf) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_access(oe_device_t* device, const char* pathname, int mode)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_path[OE_PATH_MAX];\n    const uint32_t MASK = (OE_R_OK | OE_W_OK | OE_X_OK);\n    int retval = -1;\n\n    if (!fs || !pathname || ((uint32_t)mode & ~MASK))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (_make_host_path(fs, pathname, host_path) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_access_ocall(&retval, host_path, mode) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_link(\n    oe_device_t* device,\n    const char* oldpath,\n    const char* newpath)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_oldpath[OE_PATH_MAX];\n    char host_newpath[OE_PATH_MAX];\n    int retval = -1;\n\n    if (!fs || !oldpath || !newpath)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if attempting to write to a read-only file system. */\n    if (_is_read_only(fs))\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    if (_make_host_path(fs, oldpath, host_oldpath) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (_make_host_path(fs, newpath, host_newpath) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_link_ocall(&retval, host_oldpath, host_newpath) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_unlink(oe_device_t* device, const char* pathname)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_path[OE_PATH_MAX];\n    int retval = -1;\n\n    if (!fs)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if attempting to write to a read-only file system. */\n    if (_is_read_only(fs))\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    if (_make_host_path(fs, pathname, host_path) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_unlink_ocall(&retval, host_path) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_rename(\n    oe_device_t* device,\n    const char* oldpath,\n    const char* newpath)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_oldpath[OE_PATH_MAX];\n    char host_newpath[OE_PATH_MAX];\n    int retval = -1;\n\n    if (!fs || !oldpath || !newpath)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (_is_read_only(fs))\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    if (_make_host_path(fs, oldpath, host_oldpath) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (_make_host_path(fs, newpath, host_newpath) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_rename_ocall(&retval, host_oldpath, host_newpath) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_truncate(\n    oe_device_t* device,\n    const char* path,\n    oe_off_t length)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_path[OE_PATH_MAX];\n    int retval = -1;\n\n    if (!fs)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (_is_read_only(fs))\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    if (_make_host_path(fs, path, host_path) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_truncate_ocall(&retval, host_path, length) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_mkdir(\n    oe_device_t* device,\n    const char* pathname,\n    oe_mode_t mode)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_path[OE_PATH_MAX];\n    int retval = -1;\n\n    if (!fs)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if attempting to write to a read-only file system. */\n    if (_is_read_only(fs))\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    if (_make_host_path(fs, pathname, host_path) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_mkdir_ocall(&retval, host_path, mode) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_rmdir(oe_device_t* device, const char* pathname)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_path[OE_PATH_MAX];\n    int retval = -1;\n\n    if (!fs)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if attempting to write to a read-only file system. */\n    if (_is_read_only(fs))\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    if (_make_host_path(fs, pathname, host_path) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_rmdir_ocall(&retval, host_path) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic oe_host_fd_t _hostfs_get_host_fd(oe_fd_t* desc)\n{\n    file_t* file = _cast_file(desc);\n\n    return file ? file->host_fd : -1;\n}\n\n// clang-format off\nstatic oe_file_ops_t _file_ops =\n{\n    .fd.read = _hostfs_read,\n    .fd.write = _hostfs_write,\n    .fd.readv = _hostfs_readv,\n    .fd.writev = _hostfs_writev,\n    .fd.flock = _hostfs_flock,\n    .fd.dup = _hostfs_dup,\n    .fd.ioctl = _hostfs_ioctl,\n    .fd.fcntl = _hostfs_fcntl,\n    .fd.close = _hostfs_close,\n    .fd.get_host_fd = _hostfs_get_host_fd,\n    .lseek = _hostfs_lseek,\n    .pread = _hostfs_pread,\n    .pwrite = _hostfs_pwrite,\n    .getdents64 = _hostfs_getdents64,\n    .fstat = _hostfs_fstat,\n    .fsync = _hostfs_fsync,\n    .fdatasync = _hostfs_fdatasync,\n};\n// clang-format on\n\nstatic oe_file_ops_t _get_file_ops(void)\n{\n    return _file_ops;\n};\n\n// clang-format off\nstatic device_t _hostfs =\n{\n    .base.type = OE_DEVICE_TYPE_FILE_SYSTEM,\n    .base.name = OE_DEVICE_NAME_HOST_FILE_SYSTEM,\n    .base.ops.fs =\n    {\n        .base.release = _hostfs_release,\n        .clone = _hostfs_clone,\n        .mount = _hostfs_mount,\n        .umount2 = _hostfs_umount2,\n        .open = _hostfs_open,\n        .stat = _hostfs_stat,\n        .access = _hostfs_access,\n        .link = _hostfs_link,\n        .unlink = _hostfs_unlink,\n        .rename = _hostfs_rename,\n        .truncate = _hostfs_truncate,\n        .mkdir = _hostfs_mkdir,\n        .rmdir = _hostfs_rmdir,\n    },\n    .magic = FS_MAGIC,\n    .mount =\n    {\n         .source = {'/'},\n    }\n};\n// clang-format on\n\noe_device_t* oe_get_hostfs_device(void)\n{\n    return &_hostfs.base;\n}\n\noe_result_t oe_load_module_host_file_system(void)\n{\n    oe_result_t result = OE_UNEXPECTED;\n    static oe_spinlock_t _lock = OE_SPINLOCK_INITIALIZER;\n    static bool _loaded = false;\n\n    oe_spin_lock(&_lock);\n\n    if (!_loaded)\n    {\n        if (oe_device_table_set(OE_DEVID_HOST_FILE_SYSTEM, &_hostfs.base) != 0)\n        {\n            /* Do not propagate errno to caller. */\n            oe_errno = 0;\n            OE_RAISE(OE_FAILURE);\n        }\n\n        _loaded = true;\n    }\n\n    result = OE_OK;\n\ndone:\n    oe_spin_unlock(&_lock);\n\n    return result;\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#define _GNU_SOURCE\n\n// clang-format off\n#include <openenclave/enclave.h>\n// clang-format on\n\n#include <openenclave/internal/syscall/device.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/sys/socket.h>\n#include <openenclave/internal/syscall/netdb.h>\n#include <openenclave/internal/syscall/resolver.h>\n#include <openenclave/internal/safemath.h>\n#include <openenclave/internal/calls.h>\n#include <openenclave/internal/thread.h>\n#include <openenclave/internal/print.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/bits/module.h>\n#include <openenclave/internal/trace.h>\n#include \"syscall_t.h\"\n\n#define RESOLV_MAGIC 0x536f636b\n\n// The host resolver is not actually a device in the file descriptor sense.\ntypedef struct _resolver\n{\n    struct _oe_resolver base;\n    uint32_t magic;\n} resolver_t;\n\nstatic resolver_t* _cast_resolver(const oe_resolver_t* device)\n{\n    resolver_t* resolver = (resolver_t*)device;\n\n    if (resolver == NULL || resolver->magic != RESOLV_MAGIC)\n        return NULL;\n\n    return resolver;\n}\n\nstatic resolver_t _hostresolver;\n\nstatic int _hostresolver_getnameinfo(\n    oe_resolver_t* dev,\n    const struct oe_sockaddr* sa,\n    oe_socklen_t salen,\n    char* host,\n    oe_socklen_t hostlen,\n    char* serv,\n    oe_socklen_t servlen,\n    int flags)\n{\n    int ret = OE_EAI_FAIL;\n\n    OE_UNUSED(dev);\n\n    oe_errno = 0;\n\n    if (oe_syscall_getnameinfo_ocall(\n            &ret, sa, salen, host, hostlen, serv, servlen, flags) != OE_OK)\n    {\n        goto done;\n    }\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostresolver_getaddrinfo(\n    oe_resolver_t* resolver,\n    const char* node,\n    const char* service,\n    const struct oe_addrinfo* hints,\n    struct oe_addrinfo** res)\n{\n    int ret = OE_EAI_FAIL;\n    uint64_t handle = 0;\n    struct oe_addrinfo* head = NULL;\n    struct oe_addrinfo* tail = NULL;\n    struct oe_addrinfo* p = NULL;\n\n    OE_UNUSED(resolver);\n\n    if (res)\n        *res = NULL;\n\n    if (!res)\n    {\n        ret = OE_EAI_SYSTEM;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Get the handle for enumerating addrinfo structures. */\n    {\n        int retval = OE_EAI_FAIL;\n\n        if (oe_syscall_getaddrinfo_open_ocall(\n                &retval, node, service, hints, &handle) != OE_OK)\n        {\n            ret = OE_EAI_SYSTEM;\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        if (!handle)\n        {\n            ret = retval;\n            goto done;\n        }\n    }\n\n    /* Enumerate addrinfo structures. */\n    for (;;)\n    {\n        int retval = 0;\n        size_t canonnamelen = 0;\n\n        if (!(p = oe_calloc(1, sizeof(struct oe_addrinfo))))\n        {\n            ret = OE_EAI_MEMORY;\n            goto done;\n        }\n\n        /* Determine required size ai_addr and ai_canonname buffers. */\n        if (oe_syscall_getaddrinfo_read_ocall(\n                &retval,\n                handle,\n                &p->ai_flags,\n                &p->ai_family,\n                &p->ai_socktype,\n                &p->ai_protocol,\n                p->ai_addrlen,\n                &p->ai_addrlen,\n                NULL,\n                canonnamelen,\n                &canonnamelen,\n                NULL) != OE_OK)\n        {\n            ret = OE_EAI_SYSTEM;\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        /* If this is the final element in the enumeration. */\n        if (retval == 1)\n            break;\n\n        /* Expecting that addr and canonname buffers were too small. */\n        if (retval != -1 || oe_errno != OE_ENAMETOOLONG)\n        {\n            ret = OE_EAI_SYSTEM;\n            OE_RAISE_ERRNO(oe_errno);\n        }\n\n        if (p->ai_addrlen && !(p->ai_addr = oe_calloc(1, p->ai_addrlen)))\n        {\n            ret = OE_EAI_MEMORY;\n            goto done;\n        }\n\n        if (canonnamelen && !(p->ai_canonname = oe_calloc(1, canonnamelen)))\n        {\n            ret = OE_EAI_MEMORY;\n            goto done;\n        }\n\n        if (oe_syscall_getaddrinfo_read_ocall(\n                &retval,\n                handle,\n                &p->ai_flags,\n                &p->ai_family,\n                &p->ai_socktype,\n                &p->ai_protocol,\n                p->ai_addrlen,\n                &p->ai_addrlen,\n                p->ai_addr,\n                canonnamelen,\n                &canonnamelen,\n                p->ai_canonname) != OE_OK)\n        {\n            ret = OE_EAI_SYSTEM;\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        /* Append to the list. */\n        if (tail)\n        {\n            tail->ai_next = p;\n            tail = p;\n        }\n        else\n        {\n            head = p;\n            tail = p;\n        }\n\n        p = NULL;\n    }\n\n    /* Close the enumeration. */\n    if (handle)\n    {\n        int retval = -1;\n\n        if (oe_syscall_getaddrinfo_close_ocall(&retval, handle) != OE_OK)\n        {\n            ret = OE_EAI_SYSTEM;\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        handle = 0;\n\n        if (retval != 0)\n        {\n            ret = OE_EAI_SYSTEM;\n            OE_RAISE_ERRNO(oe_errno);\n        }\n    }\n\n    /* If the list is empty. */\n    if (!head)\n    {\n        ret = OE_EAI_SYSTEM;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    *res = head;\n    head = NULL;\n    tail = NULL;\n    ret = 0;\n\ndone:\n\n    if (handle)\n    {\n        int retval;\n        oe_syscall_getaddrinfo_close_ocall(&retval, handle);\n    }\n\n    if (head)\n        oe_freeaddrinfo(head);\n\n    if (p)\n        oe_freeaddrinfo(p);\n\n    return ret;\n}\n\nstatic int _hostresolver_release(oe_resolver_t* resolv_)\n{\n    int ret = -1;\n    resolver_t* resolver = _cast_resolver(resolv_);\n\n    oe_errno = 0;\n\n    if (!resolver)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    // resolv_ is a static object, there is no need to free\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n// clang-format off\nstatic oe_resolver_ops_t _ops =\n{\n    .getaddrinfo = _hostresolver_getaddrinfo,\n    .getnameinfo = _hostresolver_getnameinfo,\n    .release = _hostresolver_release\n};\n// clang-format on\n\n// clang-format off\nstatic resolver_t _hostresolver =\n{\n    .base.type = OE_RESOLVER_TYPE_HOST,\n    .base.ops = &_ops,\n    .magic = RESOLV_MAGIC\n};\n// clang-format on\n\noe_result_t oe_load_module_host_resolver(void)\n{\n    oe_result_t result = OE_UNEXPECTED;\n    static oe_spinlock_t _lock = OE_SPINLOCK_INITIALIZER;\n    static bool _loaded = false;\n\n    oe_spin_lock(&_lock);\n\n    if (!_loaded)\n    {\n        if (oe_register_resolver(&_hostresolver.base) != 0)\n            OE_RAISE_ERRNO(oe_errno);\n\n        _loaded = true;\n    }\n\n    result = OE_OK;\n\ndone:\n    oe_spin_unlock(&_lock);\n\n    return result;\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#define _GNU_SOURCE\n\n// clang-format off\n#include <openenclave/enclave.h>\n// clang-format on\n\n#include <openenclave/internal/syscall/device.h>\n#include <openenclave/internal/thread.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/internal/syscall/sys/socket.h>\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/iov.h>\n#include <openenclave/internal/syscall/fd.h>\n#include <openenclave/internal/syscall/iov.h>\n#include <openenclave/internal/syscall/fcntl.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/internal/raise.h>\n#include <openenclave/internal/safecrt.h>\n#include \"syscall_t.h\"\n\n#define DEVICE_MAGIC 0x536f636b\n#define SOCK_MAGIC 0xe57a696d\n\nstatic oe_socket_ops_t _get_socket_ops(void);\n\ntypedef struct _device\n{\n    struct _oe_device base;\n    uint32_t magic;\n    oe_host_fd_t host_fd;\n} device_t;\n\ntypedef struct _sock\n{\n    oe_fd_t base;\n    uint32_t magic;\n    oe_host_fd_t host_fd;\n} sock_t;\n\nstatic sock_t* _new_sock(void)\n{\n    sock_t* sock = NULL;\n\n    if (!(sock = oe_calloc(1, sizeof(sock_t))))\n        return NULL;\n\n    sock->base.type = OE_FD_TYPE_SOCKET;\n    sock->base.ops.socket = _get_socket_ops();\n    sock->magic = SOCK_MAGIC;\n    sock->host_fd = -1;\n\n    return sock;\n}\n\nstatic device_t* _cast_device(const oe_device_t* device)\n{\n    device_t* p = (device_t*)device;\n\n    if (p == NULL || p->magic != DEVICE_MAGIC)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return p;\n}\n\nstatic sock_t* _cast_sock(const oe_fd_t* desc)\n{\n    sock_t* sock = (sock_t*)desc;\n\n    if (sock == NULL || sock->magic != SOCK_MAGIC)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return sock;\n}\n\nstatic ssize_t _hostsock_read(oe_fd_t*, void* buf, size_t count);\n\nstatic int _hostsock_close(oe_fd_t*);\n\nstatic oe_fd_t* _hostsock_device_socket(\n    oe_device_t* dev,\n    int domain,\n    int type,\n    int protocol)\n{\n    oe_fd_t* ret = NULL;\n    device_t* sock = _cast_device(dev);\n    sock_t* new_sock = NULL;\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(new_sock = _new_sock()))\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    {\n        oe_host_fd_t retval = -1;\n\n        if (oe_syscall_socket_ocall(&retval, domain, type, protocol) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (retval == -1)\n            OE_RAISE_ERRNO_MSG(oe_errno, \"retval=%ld\\n\", retval);\n\n        new_sock->host_fd = retval;\n    }\n\n    ret = &new_sock->base;\n    new_sock = NULL;\n\ndone:\n\n    if (new_sock)\n        oe_free(new_sock);\n\n    return ret;\n}\n\nstatic ssize_t _hostsock_device_socketpair(\n    oe_device_t* dev,\n    int domain,\n    int type,\n    int protocol,\n    oe_fd_t* sv[2])\n{\n    int ret = -1;\n    device_t* sock = _cast_device(dev);\n    sock_t* pair[2] = {NULL, NULL};\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Create the new socket devices. */\n    {\n        if (!(pair[0] = _new_sock()))\n            OE_RAISE_ERRNO(OE_ENOMEM);\n\n        if (!(pair[1] = _new_sock()))\n            OE_RAISE_ERRNO(OE_ENOMEM);\n    }\n\n    /* Call the host. */\n    {\n        int retval = -1;\n        oe_host_fd_t host_sv[2];\n\n        if (oe_syscall_socketpair_ocall(\n                &retval, domain, type, protocol, host_sv) != OE_OK)\n        {\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        if (retval == -1)\n        {\n            OE_RAISE_ERRNO_MSG(oe_errno, \"retval=%d\\n\", retval);\n        }\n\n        pair[0]->host_fd = host_sv[0];\n        pair[1]->host_fd = host_sv[1];\n    }\n\n    sv[0] = &pair[0]->base;\n    sv[1] = &pair[1]->base;\n\n    ret = 0;\n    pair[0] = NULL;\n    pair[1] = NULL;\n\ndone:\n\n    if (pair[0])\n        oe_free(pair[0]);\n\n    if (pair[1])\n        oe_free(pair[1]);\n\n    return ret;\n}\n\ntypedef struct\n{\n    struct oe_sockaddr addr;\n    uint8_t extra[1024];\n} sockaddr_t;\n\nstatic int _hostsock_connect(\n    oe_fd_t* sock_,\n    const struct oe_sockaddr* addr,\n    oe_socklen_t addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    sockaddr_t buf;\n\n    oe_errno = 0;\n\n    if (!sock || !addr || sizeof(buf) < addrlen)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_memcpy_s(&buf, sizeof(buf), addr, addrlen) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call host. */\n    if (oe_syscall_connect_ocall(&ret, sock->host_fd, &buf.addr, addrlen) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic oe_fd_t* _hostsock_accept(\n    oe_fd_t* sock_,\n    struct oe_sockaddr* addr,\n    oe_socklen_t* addrlen)\n{\n    oe_fd_t* ret = NULL;\n    sock_t* sock = _cast_sock(sock_);\n    sockaddr_t buf;\n    oe_socklen_t addrlen_in = 0;\n    sock_t* new_sock = NULL;\n\n    oe_errno = 0;\n\n    if (!sock || (addr && !addrlen) || (addrlen && !addr))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_memset_s(&buf, sizeof(buf), 0, sizeof(buf)) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fixup the address. */\n    if (addr && addrlen)\n    {\n        if (sizeof(buf) < *addrlen)\n            OE_RAISE_ERRNO_MSG(OE_EINVAL, \"*addrlen=%u\", *addrlen);\n\n        if (oe_memcpy_s(&buf, sizeof(buf), addr, *addrlen) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        addrlen_in = *addrlen;\n    }\n\n    /* Create the new socket. */\n    if (!(new_sock = _new_sock()))\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    {\n        oe_host_fd_t retval = -1;\n\n        if (oe_syscall_accept_ocall(\n                &retval,\n                sock->host_fd,\n                addr ? &buf.addr : NULL,\n                addrlen_in,\n                addrlen) != OE_OK)\n        {\n            OE_RAISE_ERRNO(oe_errno);\n        }\n\n        if (retval == -1)\n            OE_RAISE_ERRNO_MSG(oe_errno, \"retval=%d\", retval);\n\n        new_sock->host_fd = retval;\n\n        // copy peer addr to out buffer\n        if (addrlen)\n        {\n            oe_assert(addr);\n            if (oe_memcpy_s(addr, addrlen_in, &buf.addr, *addrlen) != OE_OK)\n                OE_RAISE_ERRNO(OE_EINVAL);\n        }\n    }\n\n    ret = &new_sock->base;\n    new_sock = NULL;\n\ndone:\n\n    if (new_sock)\n        oe_free(new_sock);\n\n    return ret;\n}\n\nstatic int _hostsock_bind(\n    oe_fd_t* sock_,\n    const struct oe_sockaddr* addr,\n    oe_socklen_t addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    sockaddr_t buf;\n\n    oe_errno = 0;\n\n    if (!sock || !addr || sizeof(buf) < addrlen)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_memcpy_s(&buf, sizeof(buf), addr, addrlen) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_bind_ocall(&ret, sock->host_fd, &buf.addr, addrlen) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_listen(oe_fd_t* sock_, int backlog)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_listen_ocall(&ret, sock->host_fd, backlog) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostsock_recv(\n    oe_fd_t* sock_,\n    void* buf,\n    size_t count,\n    int flags)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock || (count && !buf))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (buf)\n    {\n        if (oe_memset_s(buf, count, 0, count) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (oe_syscall_recv_ocall(&ret, sock->host_fd, buf, count, flags) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostsock_recvfrom(\n    oe_fd_t* sock_,\n    void* buf,\n    size_t count,\n    int flags,\n    const struct oe_sockaddr* src_addr,\n    oe_socklen_t* addrlen)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t addrlen_in = 0;\n\n    oe_errno = 0;\n\n    if (!sock || (count && !buf))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (addrlen)\n        addrlen_in = *addrlen;\n\n    if (oe_syscall_recvfrom_ocall(\n            &ret,\n            sock->host_fd,\n            buf,\n            count,\n            flags,\n            (struct oe_sockaddr*)src_addr,\n            addrlen_in,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostsock_recvmsg(\n    oe_fd_t* sock_,\n    struct oe_msghdr* msg,\n    int flags)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_errno = 0;\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    /* Check the parameters. */\n    if (!sock || !msg || (msg->msg_iovlen && !msg->msg_iov))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(msg->msg_iov, (int)msg->msg_iovlen, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    {\n        if (oe_syscall_recvmsg_ocall(\n                &ret,\n                sock->host_fd,\n                msg->msg_name,\n                msg->msg_namelen,\n                &msg->msg_namelen,\n                buf,\n                msg->msg_iovlen,\n                buf_size,\n                msg->msg_control,\n                msg->msg_controllen,\n                &msg->msg_controllen,\n                flags) != OE_OK)\n        {\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        if (ret == -1)\n            OE_RAISE_ERRNO(oe_errno);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (oe_iov_sync(msg->msg_iov, (int)msg->msg_iovlen, buf, buf_size) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic ssize_t _hostsock_send(\n    oe_fd_t* sock_,\n    const void* buf,\n    size_t count,\n    int flags)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock || (count && !buf))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_send_ocall(&ret, sock->host_fd, buf, count, flags) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostsock_sendto(\n    oe_fd_t* sock_,\n    const void* buf,\n    size_t count,\n    int flags,\n    const struct oe_sockaddr* dest_addr,\n    oe_socklen_t addrlen)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock || (count && !buf))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_sendto_ocall(\n            &ret,\n            sock->host_fd,\n            buf,\n            count,\n            flags,\n            (struct oe_sockaddr*)dest_addr,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostsock_sendmsg(\n    oe_fd_t* sock_,\n    const struct oe_msghdr* msg,\n    int flags)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    oe_errno = 0;\n\n    /* Check the parameters. */\n    if (!sock || !msg || (msg->msg_iovlen && !msg->msg_iov))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(msg->msg_iov, (int)msg->msg_iovlen, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    if (oe_syscall_sendmsg_ocall(\n            &ret,\n            sock->host_fd,\n            msg->msg_name,\n            msg->msg_namelen,\n            buf,\n            msg->msg_iovlen,\n            buf_size,\n            msg->msg_control,\n            msg->msg_controllen,\n            flags) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic int _hostsock_close(oe_fd_t* sock_)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_close_socket_ocall(&ret, sock->host_fd) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (ret == 0)\n        oe_free(sock);\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_fcntl(oe_fd_t* sock_, int cmd, uint64_t arg)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    void* argout = NULL;\n    uint64_t argsize = 0;\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    switch (cmd)\n    {\n        case OE_F_GETFD:\n        case OE_F_SETFD:\n        case OE_F_GETFL:\n        case OE_F_SETFL:\n            break;\n\n        default:\n        case OE_F_DUPFD:\n        case OE_F_GETLK64:\n        case OE_F_OFD_GETLK:\n        case OE_F_SETLK64:\n        case OE_F_SETLKW64:\n        case OE_F_OFD_SETLK:\n        case OE_F_OFD_SETLKW:\n            OE_RAISE_ERRNO(OE_EINVAL);\n            break;\n\n        // for sockets\n        case OE_F_GETSIG: // Returns in return value\n        case OE_F_SETSIG: // arg is data value\n            break;\n\n        case OE_F_GETOWN: // Returns in return value\n        case OE_F_SETOWN: // arg is data value\n            break;\n\n        case OE_F_SETOWN_EX:\n        case OE_F_GETOWN_EX:\n            argsize = sizeof(struct oe_f_owner_ex);\n            argout = (void*)arg;\n            break;\n\n        case OE_F_GETOWNER_UIDS:\n            argsize = sizeof(oe_uid_t[2]);\n            argout = (void*)arg;\n            break;\n    }\n\n    if (oe_syscall_fcntl_ocall(\n            &ret, sock->host_fd, cmd, arg, argsize, argout) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_dup(oe_fd_t* sock_, oe_fd_t** new_sock_out)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    sock_t* new_sock = NULL;\n\n    oe_errno = 0;\n\n    if (new_sock_out)\n        *new_sock_out = NULL;\n\n    if (!sock || !new_sock_out)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(new_sock = _new_sock()))\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    {\n        oe_host_fd_t retval = -1;\n\n        if (oe_syscall_dup_ocall(&retval, sock->host_fd) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (retval == -1)\n            OE_RAISE_ERRNO(oe_errno);\n\n        new_sock->host_fd = retval;\n    }\n\n    *new_sock_out = &new_sock->base;\n    new_sock = NULL;\n    ret = 0;\n\ndone:\n\n    if (new_sock)\n        oe_free(new_sock);\n\n    return ret;\n}\n\nstatic int _hostsock_getsockopt(\n    oe_fd_t* sock_,\n    int level,\n    int optname,\n    void* optval,\n    oe_socklen_t* optlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t optlen_in = 0;\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (optlen)\n        optlen_in = *optlen;\n\n    if (oe_syscall_getsockopt_ocall(\n            &ret, sock->host_fd, level, optname, optval, optlen_in, optlen) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_setsockopt(\n    oe_fd_t* sock_,\n    int level,\n    int optname,\n    const void* optval,\n    oe_socklen_t optlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock || !optval || !optlen)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_setsockopt_ocall(\n            &ret, sock->host_fd, level, optname, optval, optlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_ioctl(oe_fd_t* sock_, unsigned long request, uint64_t arg)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_ioctl_ocall(&ret, sock->host_fd, request, arg, 0, NULL) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_getpeername(\n    oe_fd_t* sock_,\n    struct oe_sockaddr* addr,\n    oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t addrlen_in = 0;\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (addrlen)\n        addrlen_in = *addrlen;\n\n    if (oe_syscall_getpeername_ocall(\n            &ret,\n            sock->host_fd,\n            (struct oe_sockaddr*)addr,\n            addrlen_in,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_getsockname(\n    oe_fd_t* sock_,\n    struct oe_sockaddr* addr,\n    oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t addrlen_in = 0;\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (addrlen)\n        addrlen_in = *addrlen;\n\n    if (oe_syscall_getsockname_ocall(\n            &ret,\n            sock->host_fd,\n            (struct oe_sockaddr*)addr,\n            addrlen_in,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    return ret;\n}\n\nstatic ssize_t _hostsock_read(oe_fd_t* sock_, void* buf, size_t count)\n{\n    return _hostsock_recv(sock_, buf, count, 0);\n}\n\nstatic ssize_t _hostsock_write(oe_fd_t* sock_, const void* buf, size_t count)\n{\n    return _hostsock_send(sock_, buf, count, 0);\n}\n\nstatic ssize_t _hostsock_readv(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!sock || (!iov && iovcnt) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    if (oe_syscall_recvv_ocall(&ret, sock->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (ret > 0)\n    {\n        if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic ssize_t _hostsock_writev(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!sock || !iov || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    if (oe_syscall_sendv_ocall(&ret, sock->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic int _hostsock_shutdown(oe_fd_t* sock_, int how)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_shutdown_ocall(&ret, sock->host_fd, how) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    return ret;\n}\n\n/* The release method for the socket interface device. */\nstatic int _hostsock_device_release(oe_device_t* device_)\n{\n    int ret = -1;\n    device_t* device = _cast_device(device_);\n\n    oe_errno = 0;\n\n    if (!device)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    // This device is registered by oe_load_module_host_socket_interface() and\n    // is static, so there are no resources to reclaim here.\n\n    ret = 0;\n\ndone:\n\n    return ret;\n}\n\nstatic oe_host_fd_t _hostsock_get_host_fd(oe_fd_t* sock_)\n{\n    sock_t* sock = _cast_sock(sock_);\n    return sock->host_fd;\n}\n\nstatic oe_socket_ops_t _sock_ops = {\n    .fd.dup = _hostsock_dup,\n    .fd.ioctl = _hostsock_ioctl,\n    .fd.fcntl = _hostsock_fcntl,\n    .fd.read = _hostsock_read,\n    .fd.write = _hostsock_write,\n    .fd.readv = _hostsock_readv,\n    .fd.writev = _hostsock_writev,\n    .fd.get_host_fd = _hostsock_get_host_fd,\n    .fd.close = _hostsock_close,\n    .accept = _hostsock_accept,\n    .bind = _hostsock_bind,\n    .listen = _hostsock_listen,\n    .shutdown = _hostsock_shutdown,\n    .getsockopt = _hostsock_getsockopt,\n    .setsockopt = _hostsock_setsockopt,\n    .getpeername = _hostsock_getpeername,\n    .getsockname = _hostsock_getsockname,\n    .recv = _hostsock_recv,\n    .send = _hostsock_send,\n    .recvfrom = _hostsock_recvfrom,\n    .sendto = _hostsock_sendto,\n    .recvmsg = _hostsock_recvmsg,\n    .sendmsg = _hostsock_sendmsg,\n    .connect = _hostsock_connect,\n};\n\nstatic oe_socket_ops_t _get_socket_ops(void)\n{\n    return _sock_ops;\n};\n\n// clang-format off\nstatic device_t _device = {\n    .base.type = OE_DEVICE_TYPE_SOCKET_INTERFACE,\n    .base.name = OE_DEVICE_NAME_HOST_SOCKET_INTERFACE,\n    .base.ops.socket =\n    {\n        .base.release = _hostsock_device_release,\n        .socket = _hostsock_device_socket,\n        .socketpair = _hostsock_device_socketpair,\n    },\n    .magic = DEVICE_MAGIC,\n};\n// clang-format on\n\noe_result_t oe_load_module_host_socket_interface(void)\n{\n    oe_result_t result = OE_UNEXPECTED;\n    static oe_spinlock_t _lock = OE_SPINLOCK_INITIALIZER;\n    static bool _loaded = false;\n\n    oe_spin_lock(&_lock);\n\n    if (!_loaded)\n    {\n        const uint64_t devid = OE_DEVID_HOST_SOCKET_INTERFACE;\n\n        if (oe_device_table_set(devid, &_device.base) != 0)\n        {\n            /* Do not propagate errno to caller. */\n            oe_errno = 0;\n            OE_RAISE(OE_FAILURE);\n        }\n\n        _loaded = true;\n    }\n\n    result = OE_OK;\n\ndone:\n    oe_spin_unlock(&_lock);\n\n    return result;\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#include <openenclave/corelibc/limits.h>\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/internal/print.h>\n#include <openenclave/internal/safecrt.h>\n#include <openenclave/internal/safemath.h>\n#include <openenclave/internal/syscall/iov.h>\n#include <openenclave/internal/syscall/sys/uio.h>\n#include <openenclave/internal/syscall/types.h>\n#include <openenclave/internal/utils.h>\n\nint oe_iov_pack(\n    const struct oe_iovec* iov,\n    int iovcnt,\n    void** buf_out,\n    size_t* buf_size_out)\n{\n    int ret = -1;\n    struct oe_iovec* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    if (buf_out)\n        *buf_out = NULL;\n\n    if (buf_size_out)\n        *buf_size_out = 0;\n\n    /* Reject invalid parameters. */\n    if (iovcnt < 0 || (iovcnt > 0 && !iov) || !buf_out || !buf_size_out)\n        goto done;\n\n    /* Handle zero-sized iovcnt up front. */\n    if (iovcnt == 0)\n    {\n        if (iov)\n        {\n            if (!(buf = oe_calloc(1, sizeof(uint64_t))))\n                goto done;\n\n            buf_size = sizeof(uint64_t);\n        }\n\n        *buf_out = buf;\n        *buf_size_out = buf_size;\n        buf = NULL;\n        ret = 0;\n        goto done;\n    }\n\n    /* Calculate the total number of data bytes. */\n    for (int i = 0; i < iovcnt; i++)\n        data_size += iov[i].iov_len;\n\n    /* Calculate the total size of the resulting buffer. */\n    buf_size = (sizeof(struct oe_iovec) * (size_t)iovcnt) + data_size;\n\n    /* Allocate the output buffer. */\n    if (!(buf = oe_calloc(1, buf_size)))\n        goto done;\n\n    /* Initialize the array elements. */\n    {\n        uint8_t* p = (uint8_t*)&buf[iovcnt];\n        size_t n = data_size;\n        int i;\n\n        for (i = 0; i < iovcnt; i++)\n        {\n            const size_t iov_len = iov[i].iov_len;\n            const void* iov_base = iov[i].iov_base;\n\n            if (iov_len)\n            {\n                buf[i].iov_len = iov_len;\n                buf[i].iov_base = (void*)(p - (uint8_t*)buf);\n\n                if (!iov_base)\n                    goto done;\n\n                if (oe_memcpy_s(p, n, iov_base, iov_len) != OE_OK)\n                    goto done;\n\n                p += iov_len;\n                n -= iov_len;\n            }\n        }\n\n        /* Fail if the data was not exhausted. */\n        if (n != 0)\n            goto done;\n    }\n\n    *buf_out = buf;\n    *buf_size_out = buf_size;\n    buf = NULL;\n    ret = 0;\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nint oe_iov_sync(\n    const struct oe_iovec* iov,\n    int iovcnt,\n    const void* buf_,\n    size_t buf_size)\n{\n    struct oe_iovec* buf = (struct oe_iovec*)buf_;\n    int ret = -1;\n    int i;\n    size_t n;\n\n    /* Reject invalid parameters. */\n    if (iovcnt < 0 || (iovcnt > 0 && !iov))\n        goto done;\n\n    /* Synchronize the data. */\n    for (i = 0, n = buf_size; i < iovcnt; i++)\n    {\n        if (buf[i].iov_len != iov[i].iov_len)\n            goto done;\n\n        if (buf[i].iov_len)\n        {\n            if (buf[i].iov_base && !iov[i].iov_base)\n                goto done;\n\n            if (!buf[i].iov_base && iov[i].iov_base)\n                goto done;\n\n            if (!buf[i].iov_base)\n                continue;\n\n            /* Fail if buffer data is exhausted. */\n            if (n < buf[i].iov_len)\n                goto done;\n\n            /* Sync the base data for this element. */\n            {\n                /* Note: buf[i].iov_base is an offset here (not a pointer). */\n                uint8_t* src = (uint8_t*)buf[i].iov_base + (uint64_t)buf;\n                size_t src_size = buf[i].iov_len;\n                uint8_t* dest = (uint8_t*)iov[i].iov_base;\n                size_t dest_size = iov[i].iov_len;\n\n                if (src_size != dest_size)\n                    goto done;\n\n                if (src < (uint8_t*)buf || src > (uint8_t*)buf + buf_size)\n                    goto done;\n\n                if (oe_memcpy_s(dest, dest_size, src, src_size) != OE_OK)\n                    goto done;\n            }\n        }\n\n        n -= buf[i].iov_len;\n    }\n\n    ret = 0;\n\ndone:\n\n    return ret;\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#include <openenclave/enclave.h>\n\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/internal/print.h>\n#include <openenclave/internal/syscall/device.h>\n#include <openenclave/internal/syscall/fdtable.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/sys/socket.h>\n#include <openenclave/internal/thread.h>\n#include <openenclave/internal/trace.h>\n\nstatic uint64_t _default_socket_devid = OE_DEVID_NONE;\nstatic oe_spinlock_t _default_socket_devid_lock = OE_SPINLOCK_INITIALIZER;\n\nvoid oe_set_default_socket_devid(uint64_t devid)\n{\n    oe_spin_lock(&_default_socket_devid_lock);\n    _default_socket_devid = devid;\n    oe_spin_unlock(&_default_socket_devid_lock);\n}\n\nuint64_t oe_get_default_socket_devid()\n{\n    oe_spin_lock(&_default_socket_devid_lock);\n    uint64_t ret = _default_socket_devid;\n    oe_spin_unlock(&_default_socket_devid_lock);\n    return ret;\n}\n\nint oe_socket_d(uint64_t devid, int domain, int type, int protocol)\n{\n    int ret = -1;\n    int sd;\n    oe_fd_t* sock = NULL;\n    oe_device_t* device;\n\n    if (devid == OE_DEVID_NONE)\n    {\n        /* Only one device today. */\n        devid = OE_DEVID_HOST_SOCKET_INTERFACE;\n    }\n\n    if (!(device = oe_device_table_get(devid, OE_DEVICE_TYPE_SOCKET_INTERFACE)))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(sock = device->ops.socket.socket(device, domain, type, protocol)))\n    {\n        OE_RAISE_ERRNO_MSG(\n            oe_errno,\n            \"devid=%ld domain=%d type=%d protocol=%d\",\n            devid,\n            domain,\n            type,\n            protocol);\n        goto done;\n    }\n\n    if ((sd = oe_fdtable_assign(sock)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sd;\n    sock = NULL;\n\ndone:\n\n    if (sock)\n        sock->ops.fd.close(sock);\n\n    return ret;\n}\n\nint oe_socketpair(int domain, int type, int protocol, int retfd[2])\n{\n    int ret = -1;\n    ssize_t retval;\n    oe_fd_t* socks[2] = {0};\n    oe_device_t* device;\n    uint64_t devid = OE_DEVID_HOST_SOCKET_INTERFACE;\n\n    /* Resolve the device id. */\n    if (!(device = oe_device_table_get(devid, OE_DEVICE_TYPE_SOCKET_INTERFACE)))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if ((retval = device->ops.socket.socketpair(\n             device, domain, type, protocol, socks)) < 0)\n    {\n        OE_RAISE_ERRNO_MSG(\n            OE_EINVAL,\n            \"retval=%zd devid=%lu, domain=%d type=%d protocol=%d\",\n            retval,\n            devid,\n            domain,\n            type,\n            protocol);\n    }\n\n    if ((retfd[0] = oe_fdtable_assign(socks[0])) < 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if ((retfd[1] = oe_fdtable_assign(socks[1])) < 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = (int)retval;\n    socks[0] = NULL;\n    socks[1] = NULL;\n\ndone:\n\n    if (socks[0])\n        socks[0]->ops.fd.close(socks[0]);\n\n    if (socks[1])\n        socks[1]->ops.fd.close(socks[1]);\n\n    return ret;\n}\n\nint oe_socket(int domain, int type, int protocol)\n{\n    uint64_t devid = oe_get_default_socket_devid();\n    return oe_socket_d(devid, domain, type, protocol);\n}\n\nint oe_connect(int sockfd, const struct oe_sockaddr* addr, oe_socklen_t addrlen)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.connect(sock, addr, addrlen);\n\ndone:\n    return ret;\n}\n\nint oe_accept(int sockfd, struct oe_sockaddr* addr, oe_socklen_t* addrlen)\n{\n    oe_fd_t* sock;\n    oe_fd_t* new_sock = NULL;\n    int ret = -1;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    if ((new_sock = sock->ops.socket.accept(sock, addr, addrlen)) == NULL)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if ((ret = oe_fdtable_assign(new_sock)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    new_sock = NULL;\n\ndone:\n\n    if (new_sock)\n        new_sock->ops.fd.close(new_sock);\n\n    return ret;\n}\n\nint oe_listen(int sockfd, int backlog)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.listen(sock, backlog);\n\ndone:\n    return ret;\n}\n\nssize_t oe_recv(int sockfd, void* buf, size_t len, int flags)\n{\n    ssize_t ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.recv(sock, buf, len, flags);\n\ndone:\n    return ret;\n}\n\nssize_t oe_recvfrom(\n    int sockfd,\n    void* buf,\n    size_t len,\n    int flags,\n    const struct oe_sockaddr* src_addr,\n    oe_socklen_t* addrlen)\n{\n    ssize_t ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.recvfrom(sock, buf, len, flags, src_addr, addrlen);\n\ndone:\n    return ret;\n}\n\nssize_t oe_send(int sockfd, const void* buf, size_t len, int flags)\n{\n    ssize_t ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.send(sock, buf, len, flags);\n\ndone:\n    return ret;\n}\n\nssize_t oe_sendto(\n    int sockfd,\n    const void* buf,\n    size_t len,\n    int flags,\n    const struct oe_sockaddr* dest_addr,\n    oe_socklen_t addrlen)\n{\n    ssize_t ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.sendto(sock, buf, len, flags, dest_addr, addrlen);\n\ndone:\n    return ret;\n}\n\nssize_t oe_recvmsg(int sockfd, struct oe_msghdr* buf, int flags)\n{\n    ssize_t ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.recvmsg(sock, buf, flags);\n\ndone:\n    return ret;\n}\n\nssize_t oe_sendmsg(int sockfd, const struct oe_msghdr* buf, int flags)\n{\n    ssize_t ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.sendmsg(sock, buf, flags);\n\ndone:\n    return ret;\n}\n\nint oe_shutdown(int sockfd, int how)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.shutdown(sock, how);\n\ndone:\n    return ret;\n}\n\nint oe_getsockname(int sockfd, struct oe_sockaddr* addr, oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.getsockname(sock, addr, addrlen);\n\ndone:\n    return ret;\n}\n\nint oe_getpeername(int sockfd, struct oe_sockaddr* addr, oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.getpeername(sock, addr, addrlen);\n\ndone:\n    return ret;\n}\n\nint oe_getsockopt(\n    int sockfd,\n    int level,\n    int optname,\n    void* optval,\n    oe_socklen_t* optlen)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.getsockopt(sock, level, optname, optval, optlen);\n\ndone:\n    return ret;\n}\n\nint oe_setsockopt(\n    int sockfd,\n    int level,\n    int optname,\n    const void* optval,\n    oe_socklen_t optlen)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.setsockopt(sock, level, optname, optval, optlen);\n\ndone:\n    return ret;\n}\n\nint oe_bind(int sockfd, const struct oe_sockaddr* name, oe_socklen_t namelen)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.bind(sock, name, namelen);\n\ndone:\n    return ret;\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#include <openenclave/corelibc/errno.h>\n#include <openenclave/corelibc/setjmp.h>\n#include <openenclave/corelibc/stdarg.h>\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/internal/print.h>\n#include <openenclave/internal/safemath.h>\n#include <openenclave/internal/syscall/device.h>\n#include <openenclave/internal/syscall/dirent.h>\n#include <openenclave/internal/syscall/fcntl.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/sys/ioctl.h>\n#include <openenclave/internal/syscall/sys/mount.h>\n#include <openenclave/internal/syscall/sys/poll.h>\n#include <openenclave/internal/syscall/sys/select.h>\n#include <openenclave/internal/syscall/sys/socket.h>\n#include <openenclave/internal/syscall/sys/stat.h>\n#include <openenclave/internal/syscall/sys/syscall.h>\n#include <openenclave/internal/syscall/sys/uio.h>\n#include <openenclave/internal/syscall/sys/utsname.h>\n#include <openenclave/internal/syscall/unistd.h>\n#include <openenclave/internal/trace.h>\n\ntypedef int (*ioctl_proc)(\n    int fd,\n    unsigned long request,\n    long arg1,\n    long arg2,\n    long arg3,\n    long arg4);\n\nstatic long _syscall(\n    long num,\n    long arg1,\n    long arg2,\n    long arg3,\n    long arg4,\n    long arg5,\n    long arg6)\n{\n    long ret = -1;\n    oe_errno = 0;\n\n    /* Handle the software system call. */\n    switch (num)\n    {\n#if defined(OE_SYS_creat)\n        case OE_SYS_creat:\n        {\n            const char* pathname = (const char*)arg1;\n            oe_mode_t mode = (oe_mode_t)arg2;\n            int flags = (OE_O_CREAT | OE_O_WRONLY | OE_O_TRUNC);\n\n            ret = oe_open(pathname, flags, mode);\n\n            if (oe_errno == OE_ENOENT)\n            {\n                /* If the file was not found, give the caller (libc) a chance\n                 * to handle this syscall.\n                 */\n                oe_errno = OE_ENOSYS;\n                goto done;\n            }\n\n            goto done;\n        }\n#endif\n#if defined(OE_SYS_open)\n        case OE_SYS_open:\n        {\n            const char* pathname = (const char*)arg1;\n            int flags = (int)arg2;\n            uint32_t mode = (uint32_t)arg3;\n\n            ret = oe_open(pathname, flags, mode);\n\n            if (ret < 0 && oe_errno == OE_ENOENT)\n                goto done;\n\n            goto done;\n        }\n#endif\n        case OE_SYS_openat:\n        {\n            int dirfd = (int)arg1;\n            const char* pathname = (const char*)arg2;\n            int flags = (int)arg3;\n            uint32_t mode = (uint32_t)arg4;\n\n            if (dirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            ret = oe_open(pathname, flags, mode);\n\n            if (ret < 0 && oe_errno == OE_ENOENT)\n                goto done;\n\n            goto done;\n        }\n        case OE_SYS_lseek:\n        {\n            int fd = (int)arg1;\n            ssize_t off = (ssize_t)arg2;\n            int whence = (int)arg3;\n            ret = oe_lseek(fd, off, whence);\n            goto done;\n        }\n        case OE_SYS_pread64:\n        {\n            const int fd = (int)arg1;\n            void* const buf = (void*)arg2;\n            const size_t count = (size_t)arg3;\n            const oe_off_t offset = (oe_off_t)arg4;\n\n            ret = oe_pread(fd, buf, count, offset);\n            goto done;\n        }\n        case OE_SYS_pwrite64:\n        {\n            const int fd = (int)arg1;\n            const void* const buf = (void*)arg2;\n            const size_t count = (size_t)arg3;\n            const oe_off_t offset = (oe_off_t)arg4;\n\n            ret = oe_pwrite(fd, buf, count, offset);\n            goto done;\n        }\n        case OE_SYS_readv:\n        {\n            int fd = (int)arg1;\n            const struct oe_iovec* iov = (const struct oe_iovec*)arg2;\n            int iovcnt = (int)arg3;\n\n            ret = oe_readv(fd, iov, iovcnt);\n            goto done;\n        }\n        case OE_SYS_writev:\n        {\n            int fd = (int)arg1;\n            const struct oe_iovec* iov = (const struct oe_iovec*)arg2;\n            int iovcnt = (int)arg3;\n\n            ret = oe_writev(fd, iov, iovcnt);\n            goto done;\n        }\n        case OE_SYS_read:\n        {\n            int fd = (int)arg1;\n            void* buf = (void*)arg2;\n            size_t count = (size_t)arg3;\n\n            ret = oe_read(fd, buf, count);\n            goto done;\n        }\n        case OE_SYS_write:\n        {\n            int fd = (int)arg1;\n            const void* buf = (void*)arg2;\n            size_t count = (size_t)arg3;\n\n            ret = oe_write(fd, buf, count);\n            goto done;\n        }\n        case OE_SYS_close:\n        {\n            int fd = (int)arg1;\n\n            ret = oe_close(fd);\n            goto done;\n        }\n        case OE_SYS_dup:\n        {\n            int fd = (int)arg1;\n\n            ret = oe_dup(fd);\n            goto done;\n        }\n        case OE_SYS_flock:\n        {\n            int fd = (int)arg1;\n            int operation = (int)arg2;\n\n            ret = oe_flock(fd, operation);\n            goto done;\n        }\n        case OE_SYS_fsync:\n        {\n            const int fd = (int)arg1;\n\n            ret = oe_fsync(fd);\n            goto done;\n        }\n        case OE_SYS_fdatasync:\n        {\n            const int fd = (int)arg1;\n\n            ret = oe_fdatasync(fd);\n            goto done;\n        }\n#if defined(OE_SYS_dup2)\n        case OE_SYS_dup2:\n        {\n            int oldfd = (int)arg1;\n            int newfd = (int)arg2;\n\n            ret = oe_dup2(oldfd, newfd);\n            goto done;\n        }\n#endif\n        case OE_SYS_dup3:\n        {\n            int oldfd = (int)arg1;\n            int newfd = (int)arg2;\n            int flags = (int)arg3;\n\n            if (flags != 0)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            ret = oe_dup2(oldfd, newfd);\n            goto done;\n        }\n#if defined(OE_SYS_stat)\n        case OE_SYS_stat:\n        {\n            const char* pathname = (const char*)arg1;\n            struct oe_stat_t* buf = (struct oe_stat_t*)arg2;\n            ret = oe_stat(pathname, buf);\n            goto done;\n        }\n#endif\n        case OE_SYS_newfstatat:\n        {\n            int dirfd = (int)arg1;\n            const char* pathname = (const char*)arg2;\n            struct oe_stat_t* buf = (struct oe_stat_t*)arg3;\n            int flags = (int)arg4;\n\n            if (dirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (flags != 0)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            ret = oe_stat(pathname, buf);\n            goto done;\n        }\n        case OE_SYS_fstat:\n        {\n            const int fd = (int)arg1;\n            struct oe_stat_t* const buf = (struct oe_stat_t*)arg2;\n            ret = oe_fstat(fd, buf);\n            goto done;\n        }\n#if defined(OE_SYS_link)\n        case OE_SYS_link:\n        {\n            const char* oldpath = (const char*)arg1;\n            const char* newpath = (const char*)arg2;\n            ret = oe_link(oldpath, newpath);\n            goto done;\n        }\n#endif\n        case OE_SYS_linkat:\n        {\n            int olddirfd = (int)arg1;\n            const char* oldpath = (const char*)arg2;\n            int newdirfd = (int)arg3;\n            const char* newpath = (const char*)arg4;\n            int flags = (int)arg5;\n\n            if (olddirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (newdirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (flags != 0)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            ret = oe_link(oldpath, newpath);\n            goto done;\n        }\n#if defined(OE_SYS_unlink)\n        case OE_SYS_unlink:\n        {\n            const char* pathname = (const char*)arg1;\n\n            ret = oe_unlink(pathname);\n            goto done;\n        }\n#endif\n        case OE_SYS_unlinkat:\n        {\n            int dirfd = (int)arg1;\n            const char* pathname = (const char*)arg2;\n            int flags = (int)arg3;\n\n            if (dirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (flags != OE_AT_REMOVEDIR && flags != 0)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            if (flags == OE_AT_REMOVEDIR)\n                ret = oe_rmdir(pathname);\n            else\n                ret = oe_unlink(pathname);\n\n            goto done;\n        }\n#if defined(OE_SYS_rename)\n        case OE_SYS_rename:\n        {\n            const char* oldpath = (const char*)arg1;\n            const char* newpath = (const char*)arg2;\n\n            ret = oe_rename(oldpath, newpath);\n            goto done;\n        }\n#endif\n        case OE_SYS_renameat:\n        {\n            int olddirfd = (int)arg1;\n            const char* oldpath = (const char*)arg2;\n            int newdirfd = (int)arg3;\n            const char* newpath = (const char*)arg4;\n            int flags = (int)arg5;\n\n            if (olddirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (newdirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (flags != 0)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            ret = oe_rename(oldpath, newpath);\n            goto done;\n        }\n        case OE_SYS_truncate:\n        {\n            const char* path = (const char*)arg1;\n            ssize_t length = (ssize_t)arg2;\n\n            ret = oe_truncate(path, length);\n            goto done;\n        }\n#if defined(OE_SYS_mkdir)\n        case OE_SYS_mkdir:\n        {\n            const char* pathname = (const char*)arg1;\n            uint32_t mode = (uint32_t)arg2;\n\n            ret = oe_mkdir(pathname, mode);\n            goto done;\n        }\n#endif\n        case OE_SYS_mkdirat:\n        {\n            int dirfd = (int)arg1;\n            const char* pathname = (const char*)arg2;\n            uint32_t mode = (uint32_t)arg3;\n\n            if (dirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            ret = oe_mkdir(pathname, mode);\n            goto done;\n        }\n#if defined(OE_SYS_rmdir)\n        case OE_SYS_rmdir:\n        {\n            const char* pathname = (const char*)arg1;\n            ret = oe_rmdir(pathname);\n            goto done;\n        }\n#endif\n#if defined(OE_SYS_access)\n        case OE_SYS_access:\n        {\n            const char* pathname = (const char*)arg1;\n            int mode = (int)arg2;\n\n            ret = oe_access(pathname, mode);\n            goto done;\n        }\n#endif\n        case OE_SYS_faccessat:\n        {\n            int dirfd = (int)arg1;\n            const char* pathname = (const char*)arg2;\n            int mode = (int)arg3;\n            int flags = (int)arg4;\n\n            if (dirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (flags != 0)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            ret = oe_access(pathname, mode);\n            goto done;\n        }\n        case OE_SYS_getdents64:\n        {\n            unsigned int fd = (unsigned int)arg1;\n            struct oe_dirent* ent = (struct oe_dirent*)arg2;\n            unsigned int count = (unsigned int)arg3;\n            ret = oe_getdents64(fd, ent, count);\n            goto done;\n        }\n        case OE_SYS_ioctl:\n        {\n            int fd = (int)arg1;\n            unsigned long request = (unsigned long)arg2;\n            long p1 = arg3;\n            long p2 = arg4;\n            long p3 = arg5;\n            long p4 = arg6;\n\n            ret = oe_ioctl(fd, request, p1, p2, p3, p4);\n            goto done;\n        }\n        case OE_SYS_fcntl:\n        {\n            int fd = (int)arg1;\n            int cmd = (int)arg2;\n            uint64_t arg = (uint64_t)arg3;\n            ret = oe_fcntl(fd, cmd, arg);\n            goto done;\n        }\n        case OE_SYS_mount:\n        {\n            const char* source = (const char*)arg1;\n            const char* target = (const char*)arg2;\n            const char* fstype = (const char*)arg3;\n            unsigned long flags = (unsigned long)arg4;\n            void* data = (void*)arg5;\n\n            ret = oe_mount(source, target, fstype, flags, data);\n            goto done;\n        }\n        case OE_SYS_umount2:\n        {\n            const char* target = (const char*)arg1;\n            int flags = (int)arg2;\n\n            (void)flags;\n\n            ret = oe_umount(target);\n            goto done;\n        }\n        case OE_SYS_getcwd:\n        {\n            char* buf = (char*)arg1;\n            size_t size = (size_t)arg2;\n\n            if (!oe_getcwd(buf, size))\n            {\n                ret = -1;\n            }\n            else\n            {\n                ret = (long)size;\n            }\n\n            goto done;\n        }\n        case OE_SYS_chdir:\n        {\n            char* path = (char*)arg1;\n\n            ret = oe_chdir(path);\n            goto done;\n        }\n        case OE_SYS_socket:\n        {\n            int domain = (int)arg1;\n            int type = (int)arg2;\n            int protocol = (int)arg3;\n            ret = oe_socket(domain, type, protocol);\n            goto done;\n        }\n        case OE_SYS_connect:\n        {\n            int sd = (int)arg1;\n            const struct oe_sockaddr* addr = (const struct oe_sockaddr*)arg2;\n            oe_socklen_t addrlen = (oe_socklen_t)arg3;\n            ret = oe_connect(sd, addr, addrlen);\n            goto done;\n        }\n        case OE_SYS_setsockopt:\n        {\n            int sockfd = (int)arg1;\n            int level = (int)arg2;\n            int optname = (int)arg3;\n            void* optval = (void*)arg4;\n            oe_socklen_t optlen = (oe_socklen_t)arg5;\n            ret = oe_setsockopt(sockfd, level, optname, optval, optlen);\n            goto done;\n        }\n        case OE_SYS_getsockopt:\n        {\n            int sockfd = (int)arg1;\n            int level = (int)arg2;\n            int optname = (int)arg3;\n            void* optval = (void*)arg4;\n            oe_socklen_t* optlen = (oe_socklen_t*)arg5;\n            ret = oe_getsockopt(sockfd, level, optname, optval, optlen);\n            goto done;\n        }\n        case OE_SYS_getpeername:\n        {\n            int sockfd = (int)arg1;\n            struct sockaddr* addr = (struct sockaddr*)arg2;\n            oe_socklen_t* addrlen = (oe_socklen_t*)arg3;\n            ret = oe_getpeername(sockfd, (struct oe_sockaddr*)addr, addrlen);\n            goto done;\n        }\n        case OE_SYS_getsockname:\n        {\n            int sockfd = (int)arg1;\n            struct sockaddr* addr = (struct sockaddr*)arg2;\n            oe_socklen_t* addrlen = (oe_socklen_t*)arg3;\n            ret = oe_getsockname(sockfd, (struct oe_sockaddr*)addr, addrlen);\n            goto done;\n        }\n        case OE_SYS_bind:\n        {\n            int sockfd = (int)arg1;\n            struct oe_sockaddr* addr = (struct oe_sockaddr*)arg2;\n            oe_socklen_t addrlen = (oe_socklen_t)arg3;\n            ret = oe_bind(sockfd, addr, addrlen);\n            goto done;\n        }\n        case OE_SYS_listen:\n        {\n            int sockfd = (int)arg1;\n            int backlog = (int)arg2;\n            ret = oe_listen(sockfd, backlog);\n            goto done;\n        }\n        case OE_SYS_accept:\n        {\n            int sockfd = (int)arg1;\n            struct oe_sockaddr* addr = (struct oe_sockaddr*)arg2;\n            oe_socklen_t* addrlen = (oe_socklen_t*)arg3;\n            ret = oe_accept(sockfd, addr, addrlen);\n            goto done;\n        }\n        case OE_SYS_sendto:\n        {\n            int sockfd = (int)arg1;\n            const void* buf = (void*)arg2;\n            size_t len = (size_t)arg3;\n            int flags = (int)arg4;\n            const struct oe_sockaddr* dest_add =\n                (const struct oe_sockaddr*)arg5;\n            oe_socklen_t addrlen = (oe_socklen_t)arg6;\n\n            ret = oe_sendto(sockfd, buf, len, flags, dest_add, addrlen);\n            goto done;\n        }\n        case OE_SYS_recvfrom:\n        {\n            int sockfd = (int)arg1;\n            void* buf = (void*)arg2;\n            size_t len = (size_t)arg3;\n            int flags = (int)arg4;\n            const struct oe_sockaddr* dest_add =\n                (const struct oe_sockaddr*)arg5;\n            oe_socklen_t* addrlen = (oe_socklen_t*)arg6;\n\n            ret = oe_recvfrom(sockfd, buf, len, flags, dest_add, addrlen);\n            goto done;\n        }\n        case OE_SYS_sendmsg:\n        {\n            int sockfd = (int)arg1;\n            struct msghdr* buf = (struct msghdr*)arg2;\n            int flags = (int)arg3;\n\n            ret = oe_sendmsg(sockfd, (struct oe_msghdr*)buf, flags);\n            goto done;\n        }\n        case OE_SYS_recvmsg:\n        {\n            int sockfd = (int)arg1;\n            struct msghdr* buf = (struct msghdr*)arg2;\n            int flags = (int)arg3;\n\n            ret = oe_recvmsg(sockfd, (struct oe_msghdr*)buf, flags);\n            goto done;\n        }\n        case OE_SYS_socketpair:\n        {\n            int domain = (int)arg1;\n            int type = (int)arg2;\n            int protocol = (int)arg3;\n            int* sv = (int*)arg4;\n\n            ret = oe_socketpair(domain, type, protocol, sv);\n            goto done;\n        }\n        case OE_SYS_shutdown:\n        {\n            int sockfd = (int)arg1;\n            int how = (int)arg2;\n            ret = oe_shutdown(sockfd, how);\n            goto done;\n        }\n        case OE_SYS_uname:\n        {\n            struct oe_utsname* buf = (struct oe_utsname*)arg1;\n            ret = oe_uname(buf);\n            goto done;\n        }\n#if defined(OE_SYS_select)\n        case OE_SYS_select:\n        {\n            int nfds = (int)arg1;\n            oe_fd_set* readfds = (oe_fd_set*)arg2;\n            oe_fd_set* writefds = (oe_fd_set*)arg3;\n            oe_fd_set* efds = (oe_fd_set*)arg4;\n            struct oe_timeval* timeout = (struct oe_timeval*)arg5;\n            ret = oe_select(nfds, readfds, writefds, efds, timeout);\n            goto done;\n        }\n#endif\n        case OE_SYS_pselect6:\n        {\n            int nfds = (int)arg1;\n            oe_fd_set* readfds = (oe_fd_set*)arg2;\n            oe_fd_set* writefds = (oe_fd_set*)arg3;\n            oe_fd_set* exceptfds = (oe_fd_set*)arg4;\n            struct oe_timespec* ts = (struct oe_timespec*)arg5;\n            struct oe_timeval buf;\n            struct oe_timeval* tv = NULL;\n\n            if (ts)\n            {\n                tv = &buf;\n                tv->tv_sec = ts->tv_sec;\n                tv->tv_usec = ts->tv_nsec / 1000;\n            }\n\n            ret = oe_select(nfds, readfds, writefds, exceptfds, tv);\n            goto done;\n        }\n#if defined(OE_SYS_poll)\n        case OE_SYS_poll:\n        {\n            struct oe_pollfd* fds = (struct oe_pollfd*)arg1;\n            oe_nfds_t nfds = (oe_nfds_t)arg2;\n            int millis = (int)arg3;\n            ret = oe_poll(fds, nfds, millis);\n            goto done;\n        }\n#endif\n        case OE_SYS_ppoll:\n        {\n            struct oe_pollfd* fds = (struct oe_pollfd*)arg1;\n            oe_nfds_t nfds = (oe_nfds_t)arg2;\n            struct oe_timespec* ts = (struct oe_timespec*)arg3;\n            void* sigmask = (void*)arg4;\n            int timeout = -1;\n\n            if (sigmask != NULL)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            if (ts)\n            {\n                int64_t mul;\n                int64_t div;\n                int64_t sum;\n\n                if (oe_safe_mul_s64(ts->tv_sec, 1000, &mul) != OE_OK)\n                {\n                    oe_errno = OE_EINVAL;\n                    goto done;\n                }\n\n                div = ts->tv_nsec / 1000000;\n\n                if (oe_safe_add_s64(mul, div, &sum) != OE_OK)\n                {\n                    oe_errno = OE_EINVAL;\n                    goto done;\n                }\n\n                if (sum < OE_INT_MIN || sum > OE_INT_MAX)\n                {\n                    oe_errno = OE_EINVAL;\n                    goto done;\n                }\n\n                timeout = (int)sum;\n            }\n\n            ret = oe_poll(fds, nfds, timeout);\n            goto done;\n        }\n#if defined(OE_SYS_epoll_create)\n        case OE_SYS_epoll_create:\n        {\n            int size = (int)arg1;\n            ret = oe_epoll_create(size);\n            goto done;\n        }\n#endif\n        case OE_SYS_epoll_create1:\n        {\n            int flags = (int)arg1;\n            ret = oe_epoll_create1(flags);\n            goto done;\n        }\n#if defined(OE_SYS_epoll_wait)\n        case OE_SYS_epoll_wait:\n        {\n            int epfd = (int)arg1;\n            struct oe_epoll_event* events = (struct oe_epoll_event*)arg2;\n            int maxevents = (int)arg3;\n            int timeout = (int)arg4;\n            ret = oe_epoll_wait(epfd, events, maxevents, timeout);\n            goto done;\n        }\n#endif\n        case OE_SYS_epoll_pwait:\n        {\n            int epfd = (int)arg1;\n            struct oe_epoll_event* events = (struct oe_epoll_event*)arg2;\n            int maxevents = (int)arg3;\n            int timeout = (int)arg4;\n            const oe_sigset_t* sigmask = (const oe_sigset_t*)arg5;\n            ret = oe_epoll_pwait(epfd, events, maxevents, timeout, sigmask);\n            goto done;\n        }\n        case OE_SYS_epoll_ctl:\n        {\n            int epfd = (int)arg1;\n            int op = (int)arg2;\n            int fd = (int)arg3;\n            struct oe_epoll_event* event = (struct oe_epoll_event*)arg4;\n            ret = oe_epoll_ctl(epfd, op, fd, event);\n            goto done;\n        }\n        case OE_SYS_exit_group:\n        {\n            ret = 0;\n            goto done;\n        }\n        case OE_SYS_exit:\n        {\n            int status = (int)arg1;\n            oe_exit(status);\n            goto done;\n        }\n        case OE_SYS_getpid:\n        {\n            ret = (long)oe_getpid();\n            goto done;\n        }\n        case OE_SYS_getuid:\n        {\n            ret = (long)oe_getuid();\n            goto done;\n        }\n        case OE_SYS_geteuid:\n        {\n            ret = (long)oe_geteuid();\n            goto done;\n        }\n        case OE_SYS_getgid:\n        {\n            ret = (long)oe_getgid();\n            goto done;\n        }\n        case OE_SYS_getpgid:\n        {\n            int pid = (int)arg1;\n            ret = (long)oe_getpgid(pid);\n            goto done;\n        }\n        case OE_SYS_getgroups:\n        {\n            int size = (int)arg1;\n            oe_gid_t* list = (oe_gid_t*)arg2;\n            ret = (long)oe_getgroups(size, list);\n            goto done;\n        }\n        case OE_SYS_getegid:\n        {\n            ret = (long)oe_getegid();\n            goto done;\n        }\n        case OE_SYS_getppid:\n        {\n            ret = (long)oe_getppid();\n            goto done;\n        }\n#if defined(OE_SYS_getpgrp)\n        case OE_SYS_getpgrp:\n        {\n            ret = (long)oe_getpgrp();\n            goto done;\n        }\n#endif\n        case OE_SYS_nanosleep:\n        {\n            struct oe_timespec* req = (struct oe_timespec*)arg1;\n            struct oe_timespec* rem = (struct oe_timespec*)arg2;\n            ret = (long)oe_nanosleep(req, rem);\n            goto done;\n        }\n        default:\n        {\n            oe_errno = OE_ENOSYS;\n            OE_TRACE_WARNING(\"syscall num=%ld not handled\", num);\n            goto done;\n        }\n    }\n\n    /* Unreachable */\ndone:\n    return ret;\n}\n\nlong oe_syscall(long number, ...)\n{\n    long ret;\n\n    oe_va_list ap;\n    oe_va_start(ap, number);\n    long arg1 = oe_va_arg(ap, long);\n    long arg2 = oe_va_arg(ap, long);\n    long arg3 = oe_va_arg(ap, long);\n    long arg4 = oe_va_arg(ap, long);\n    long arg5 = oe_va_arg(ap, long);\n    long arg6 = oe_va_arg(ap, long);\n    ret = _syscall(number, arg1, arg2, arg3, arg4, arg5, arg6);\n    oe_va_end(ap);\n\n    return ret;\n}\n"], "fixing_code": ["// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n/*\n**==============================================================================\n**\n** socket.edl:\n**\n**     This file declares OCALLs needed by the enclave to implement socket I/O.\n**\n**     Note that some of the syscalls in fcntl.edl can also be passed a socket\n**     file descriptor.\n**\n**     TODO: Document which file OCalls support socket descriptors.\n**\n**==============================================================================\n*/\n\nenclave\n{\n    // Headers needed for integral types\n    include \"openenclave/corelibc/bits/types.h\"\n    include \"openenclave/bits/edl/syscall_types.h\"\n\n    struct oe_sockaddr\n    {\n        oe_sa_family_t sa_family;\n        char sa_data[14];\n    };\n\n    struct oe_addrinfo\n    {\n        int ai_flags;\n        int ai_family;\n        int ai_socktype;\n        int ai_protocol;\n        oe_socklen_t ai_addrlen;\n        [size=ai_addrlen] struct oe_sockaddr* ai_addr;\n        char* ai_canonname;\n        struct oe_addrinfo* ai_next;\n    };\n\n    untrusted\n    {\n        int oe_syscall_close_socket_ocall(\n            oe_host_fd_t sockfd)\n            propagate_errno;\n\n       oe_host_fd_t oe_syscall_socket_ocall(\n            int domain,\n            int type,\n            int protocol)\n            propagate_errno;\n\n        int oe_syscall_shutdown_sockets_device_ocall(\n            oe_host_fd_t sockfd)\n            propagate_errno;\n\n        int oe_syscall_socketpair_ocall(\n            int domain,\n            int type,\n            int protocol,\n            [out] oe_host_fd_t sv[2])\n            propagate_errno;\n\n        int oe_syscall_connect_ocall(\n            oe_host_fd_t sockfd,\n            [in, size=addrlen] const struct oe_sockaddr* addr,\n            oe_socklen_t addrlen)\n            propagate_errno;\n\n        oe_host_fd_t oe_syscall_accept_ocall(\n            oe_host_fd_t sockfd,\n            [out, size=addrlen_in] struct oe_sockaddr* addr,\n            oe_socklen_t addrlen_in,\n            [out, count=1] oe_socklen_t* addrlen_out)\n            propagate_errno;\n\n        int oe_syscall_bind_ocall(\n            oe_host_fd_t sockfd,\n            [in, size=addrlen] const struct oe_sockaddr* addr,\n            oe_socklen_t addrlen)\n            propagate_errno;\n\n        int oe_syscall_listen_ocall(\n            oe_host_fd_t sockfd,\n            int backlog)\n            propagate_errno;\n\n        ssize_t oe_syscall_recvmsg_ocall(\n            oe_host_fd_t sockfd,\n            [out, size=msg_namelen] void* msg_name,\n            oe_socklen_t msg_namelen,\n            [out, count=1] oe_socklen_t* msg_namelen_out,\n            [in, out, size=msg_iov_buf_size] void* msg_iov_buf,\n            size_t msg_iovlen,\n            size_t msg_iov_buf_size,\n            [out, size=msg_controllen] void* msg_control,\n            size_t msg_controllen,\n            [out, count=1] size_t* msg_controllen_out,\n            int flags)\n            propagate_errno;\n\n        ssize_t oe_syscall_sendmsg_ocall(\n            oe_host_fd_t sockfd,\n            [in, size=msg_namelen] const void* msg_name,\n            oe_socklen_t msg_namelen,\n            [in, size=msg_iov_buf_size] void* msg_iov_buf,\n            size_t msg_iovlen,\n            size_t msg_iov_buf_size,\n            [in, size=msg_controllen] const void* msg_control,\n            size_t msg_controllen,\n            int flags)\n            propagate_errno;\n\n        ssize_t oe_syscall_recv_ocall(\n            oe_host_fd_t sockfd,\n            [out, size=len] void* buf,\n            size_t len,\n            int flags)\n            propagate_errno;\n\n        ssize_t oe_syscall_recvfrom_ocall(\n            oe_host_fd_t sockfd,\n            [out, size=len] void* buf,\n            size_t len,\n            int flags,\n            [out, size=addrlen_in] struct oe_sockaddr* src_addr,\n            oe_socklen_t addrlen_in,\n            [out, count=1] oe_socklen_t* addrlen_out)\n            propagate_errno;\n\n        ssize_t oe_syscall_send_ocall(\n            oe_host_fd_t sockfd,\n            [in, size=len] const void* buf,\n            size_t len,\n            int flags)\n            propagate_errno;\n\n        ssize_t oe_syscall_sendto_ocall(\n            oe_host_fd_t sockfd,\n            [in, size=len] const void* buf,\n            size_t len,\n            int flags,\n            [in, size=addrlen] const struct oe_sockaddr* dest_addr,\n            oe_socklen_t addrlen)\n            propagate_errno;\n\n        ssize_t oe_syscall_recvv_ocall(\n            oe_host_fd_t fd,\n            [in, out, size=iov_buf_size] void* iov_buf,\n            int iovcnt,\n            size_t iov_buf_size)\n            propagate_errno;\n\n        ssize_t oe_syscall_sendv_ocall(\n            oe_host_fd_t fd,\n            [in, size=iov_buf_size] const void* iov_buf,\n            int iovcnt,\n            size_t iov_buf_size)\n            propagate_errno;\n\n        int oe_syscall_shutdown_ocall(\n            oe_host_fd_t sockfd,\n            int how)\n            propagate_errno;\n\n        int oe_syscall_setsockopt_ocall(\n            oe_host_fd_t sockfd,\n            int level,\n            int optname,\n            [in, size=optlen] const void* optval,\n            oe_socklen_t optlen)\n            propagate_errno;\n\n        int oe_syscall_getsockopt_ocall(\n            oe_host_fd_t sockfd,\n            int level,\n            int optname,\n            [out, size=optlen_in] void* optval,\n            oe_socklen_t optlen_in,\n            [out] oe_socklen_t* optlen_out)\n            propagate_errno;\n\n        int oe_syscall_getsockname_ocall(\n            oe_host_fd_t sockfd,\n            [out, size=addrlen_in] struct oe_sockaddr* addr,\n            oe_socklen_t addrlen_in,\n            [out, size=1] oe_socklen_t* addrlen_out)\n            propagate_errno;\n\n        int oe_syscall_getpeername_ocall(\n            oe_host_fd_t sockfd,\n            [out, size=addrlen_in] struct oe_sockaddr* addr,\n            oe_socklen_t addrlen_in,\n            [out, size=1] oe_socklen_t* addrlen_out)\n            propagate_errno;\n\n        int oe_syscall_getaddrinfo_open_ocall(\n            [in, string] const char* node,\n            [in, string] const char* service,\n            [in, count=1] const struct oe_addrinfo* hints,\n            [out, count=1] uint64_t* handle)\n            propagate_errno;\n\n        int oe_syscall_getaddrinfo_read_ocall(\n            uint64_t handle,\n            [out, count=1] int* ai_flags,\n            [out, count=1] int* ai_family,\n            [out, count=1] int* ai_socktype,\n            [out, count=1] int* ai_protocol,\n            oe_socklen_t ai_addrlen_in,\n            [out, count=1] oe_socklen_t* ai_addrlen,\n            [out, size=ai_addrlen_in] struct oe_sockaddr* ai_addr,\n            size_t ai_canonnamelen_in,\n            [out, count=1] size_t* ai_canonnamelen,\n            [out, size=ai_canonnamelen_in] char* ai_canonname)\n            propagate_errno;\n\n        int oe_syscall_getaddrinfo_close_ocall(\n            uint64_t handle)\n            propagate_errno;\n\n        int oe_syscall_getnameinfo_ocall(\n            [in, size=salen] const struct oe_sockaddr* sa,\n            oe_socklen_t salen,\n            [out, size=hostlen] char* host,\n            oe_socklen_t hostlen,\n            [out, size=servlen] char* serv,\n            oe_socklen_t servlen,\n            int flags)\n            propagate_errno;\n    };\n};\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#ifndef _OE_SYSCALL_FD_H\n#define _OE_SYSCALL_FD_H\n\n#include <openenclave/bits/defs.h>\n#include <openenclave/bits/types.h>\n#include <openenclave/internal/syscall/sys/epoll.h>\n#include <openenclave/internal/syscall/sys/socket.h>\n#include <openenclave/internal/syscall/sys/stat.h>\n#include <openenclave/internal/syscall/sys/uio.h>\n#include <openenclave/internal/syscall/types.h>\n\nOE_EXTERNC_BEGIN\n\ntypedef enum _oe_fd_type\n{\n    OE_FD_TYPE_NONE = 0,\n    OE_FD_TYPE_ANY,\n    OE_FD_TYPE_FILE,\n    OE_FD_TYPE_SOCKET,\n    OE_FD_TYPE_EPOLL,\n} oe_fd_type_t;\n\ntypedef struct _oe_fd oe_fd_t;\n\n/* Common operations on file-descriptor objects. */\ntypedef struct _oe_fd_ops\n{\n    ssize_t (*read)(oe_fd_t* desc, void* buf, size_t count);\n\n    ssize_t (*write)(oe_fd_t* desc, const void* buf, size_t count);\n\n    ssize_t (*readv)(oe_fd_t* desc, const struct oe_iovec* iov, int iovcnt);\n\n    ssize_t (*writev)(oe_fd_t* desc, const struct oe_iovec* iov, int iovcnt);\n\n    int (*flock)(oe_fd_t* desc, int operation);\n\n    int (*dup)(oe_fd_t* desc, oe_fd_t** new_fd);\n\n    int (*ioctl)(oe_fd_t* desc, unsigned long request, uint64_t arg);\n\n    int (*fcntl)(oe_fd_t* desc, int cmd, uint64_t arg);\n\n    int (*close)(oe_fd_t* desc);\n\n    oe_host_fd_t (*get_host_fd)(oe_fd_t* desc);\n} oe_fd_ops_t;\n\n/* File operations. */\ntypedef struct _oe_file_ops\n{\n    /* Inherited operations. */\n    oe_fd_ops_t fd;\n\n    oe_off_t (*lseek)(oe_fd_t* file, oe_off_t offset, int whence);\n\n    ssize_t (*pread)(oe_fd_t* desc, void* buf, size_t count, oe_off_t offset);\n\n    ssize_t (\n        *pwrite)(oe_fd_t* desc, const void* buf, size_t count, oe_off_t offset);\n\n    int (*getdents64)(oe_fd_t* file, struct oe_dirent* dirp, uint32_t count);\n\n    int (*fstat)(oe_fd_t* file, struct oe_stat_t* buf);\n\n    int (*fsync)(oe_fd_t* file);\n    int (*fdatasync)(oe_fd_t* file);\n} oe_file_ops_t;\n\n/* Socket operations .*/\ntypedef struct _oe_socket_ops\n{\n    /* Inherited operations. */\n    oe_fd_ops_t fd;\n\n    int (*connect)(\n        oe_fd_t* sock,\n        const struct oe_sockaddr* addr,\n        oe_socklen_t addrlen);\n\n    oe_fd_t* (*accept)(\n        oe_fd_t* sock,\n        struct oe_sockaddr* addr,\n        oe_socklen_t* addrlen);\n\n    int (*bind)(\n        oe_fd_t* sock,\n        const struct oe_sockaddr* addr,\n        oe_socklen_t addrlen);\n\n    int (*listen)(oe_fd_t* sock, int backlog);\n\n    ssize_t (*send)(oe_fd_t* sock, const void* buf, size_t len, int flags);\n\n    ssize_t (*recv)(oe_fd_t* sock, void* buf, size_t len, int flags);\n\n    ssize_t (*sendto)(\n        oe_fd_t* sock,\n        const void* buf,\n        size_t len,\n        int flags,\n        const struct oe_sockaddr* dest_addr,\n        oe_socklen_t addrlen);\n\n    ssize_t (*recvfrom)(\n        oe_fd_t* sock,\n        void* buf,\n        size_t len,\n        int flags,\n        struct oe_sockaddr* src_addr,\n        oe_socklen_t* addrlen);\n\n    ssize_t (*sendmsg)(oe_fd_t* sock, const struct oe_msghdr* msg, int flags);\n\n    ssize_t (*recvmsg)(oe_fd_t* sock, struct oe_msghdr* msg, int flags);\n\n    int (*shutdown)(oe_fd_t* sock, int how);\n\n    int (*getsockopt)(\n        oe_fd_t* sock,\n        int level,\n        int optname,\n        void* optval,\n        oe_socklen_t* optlen);\n\n    int (*setsockopt)(\n        oe_fd_t* sock,\n        int level,\n        int optname,\n        const void* optval,\n        oe_socklen_t optlen);\n\n    int (*getpeername)(\n        oe_fd_t* sock,\n        struct oe_sockaddr* addr,\n        oe_socklen_t* addrlen);\n\n    int (*getsockname)(\n        oe_fd_t* sock,\n        struct oe_sockaddr* addr,\n        oe_socklen_t* addrlen);\n} oe_socket_ops_t;\n\n/* epoll operations. */\ntypedef struct _oe_epoll_ops\n{\n    /* Inherited operations. */\n    oe_fd_ops_t fd;\n\n    int (*epoll_ctl)(\n        oe_fd_t* epoll,\n        int op,\n        int fd,\n        struct oe_epoll_event* event);\n\n    int (*epoll_wait)(\n        oe_fd_t* epoll,\n        struct oe_epoll_event* events,\n        int maxevents,\n        int timeout);\n\n    void (*on_close)(oe_fd_t* epoll, int fd);\n} oe_epoll_ops_t;\n\nstruct _oe_fd\n{\n    oe_fd_type_t type;\n    union {\n        oe_fd_ops_t fd;\n        oe_file_ops_t file;\n        oe_socket_ops_t socket;\n        oe_epoll_ops_t epoll;\n    } ops;\n};\n\nOE_EXTERNC_END\n\n// clang-format on\n#endif // _OE_SYSCALL_FD_H\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#ifndef _OE_SYSCALL_IOV_H\n#define _OE_SYSCALL_IOV_H\n\n#include <openenclave/bits/fs.h>\n#include <openenclave/bits/result.h>\n#include <openenclave/internal/syscall/fd.h>\n#include <openenclave/internal/syscall/sys/stat.h>\n\nOE_EXTERNC_BEGIN\n\nint oe_iov_pack(\n    const struct oe_iovec* iov,\n    int iovcnt,\n    void** buf_out,\n    size_t* buf_size_out,\n    size_t* data_size_out);\n\nint oe_iov_sync(\n    const struct oe_iovec* iov,\n    int iovcnt,\n    const void* buf_,\n    size_t buf_size);\n\nOE_EXTERNC_END\n\n#endif // _OE_SYSCALL_IOV_H\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#ifndef _OE_SYSCALL_SYS_SOCKET_H\n#define _OE_SYSCALL_SYS_SOCKET_H\n\n#include <openenclave/bits/defs.h>\n#include <openenclave/bits/types.h>\n#include <openenclave/corelibc/bits/types.h>\n#include <openenclave/internal/bits/socket.h>\n#include <openenclave/internal/syscall/sys/uio.h>\n\nOE_EXTERNC_BEGIN\n\n/* Protocol families.  */\n#define OE_PF_UNSPEC 0      /* Unspecified.  */\n#define OE_PF_LOCAL 1       /* Local to host (pipes and file-domain).  */\n#define OE_PF_UNIX PF_LOCAL /* POSIX name for PF_LOCAL.  */\n#define OE_PF_FILE PF_LOCAL /* Another non-standard name for PF_LOCAL.  */\n#define OE_PF_INET 2        /* IP protocol family.  */\n#define OE_PF_AX25 3        /* Amateur Radio AX.25.  */\n#define OE_PF_IPX 4         /* Novell Internet Protocol.  */\n#define OE_PF_APPLETALK 5   /* Appletalk DDP.  */\n#define OE_PF_NETROM 6      /* Amateur radio NetROM.  */\n#define OE_PF_BRIDGE 7      /* Multiprotocol bridge.  */\n#define OE_PF_ATMPVC 8      /* ATM PVCs.  */\n#define OE_PF_X25 9         /* Reserved for X.25 project.  */\n#define OE_PF_INET6 10      /* IP version 6.  */\n#define OE_PF_ROSE 11       /* Amateur Radio X.25 PLP.  */\n#define OE_PF_DECnet 12     /* Reserved for DECnet project.  */\n#define OE_PF_NETBEUI 13    /* Reserved for 802.2LLC project.  */\n#define OE_PF_SECURITY 14   /* Security callback pseudo AF.  */\n#define OE_PF_KEY 15        /* PF_KEY key management API.  */\n#define OE_PF_NETLINK 16\n#define OE_PF_ROUTE PF_NETLINK /* Alias to emulate 4.4BSD.  */\n#define OE_PF_PACKET 17        /* Packet family.  */\n#define OE_PF_ASH 18           /* Ash.  */\n#define OE_PF_ECONET 19        /* Acorn Econet.  */\n#define OE_PF_ATMSVC 20        /* ATM SVCs.  */\n#define OE_PF_RDS 21           /* RDS sockets.  */\n#define OE_PF_SNA 22           /* Linux SNA Project */\n#define OE_PF_IRDA 23          /* IRDA sockets.  */\n#define OE_PF_PPPOX 24         /* PPPoX sockets.  */\n#define OE_PF_WANPIPE 25       /* Wanpipe API sockets.  */\n#define OE_PF_LLC 26           /* Linux LLC.  */\n#define OE_PF_IB 27            /* Native InfiniBand address.  */\n#define OE_PF_MPLS 28          /* MPLS.  */\n#define OE_PF_CAN 29           /* Controller Area Network.  */\n#define OE_PF_TIPC 30          /* TIPC sockets.  */\n#define OE_PF_BLUETOOTH 31     /* Bluetooth sockets.  */\n#define OE_PF_IUCV 32          /* IUCV sockets.  */\n#define OE_PF_RXRPC 33         /* RxRPC sockets.  */\n#define OE_PF_ISDN 34          /* mISDN sockets.  */\n#define OE_PF_PHONET 35        /* Phonet sockets.  */\n#define OE_PF_IEEE802154 36    /* IEEE 802.15.4 sockets.  */\n#define OE_PF_CAIF 37          /* CAIF sockets.  */\n#define OE_PF_ALG 38           /* Algorithm sockets.  */\n#define OE_PF_NFC 39           /* NFC sockets.  */\n#define OE_PF_VSOCK 40         /* vSockets.  */\n#define OE_PF_KCM 41           /* Kernel Connection Multiplexor.  */\n#define OE_PF_QIPCRTR 42       /* Qualcomm IPC Router.  */\n#define OE_PF_SMC 43           /* SMC sockets.  */\n#define OE_PF_HOST 51          /* non-secure host sockets */\n#define OE_PF_MAX 51           /* For now..  */\n\n/* Address families.  */\n#define OE_AF_UNSPEC OE_PF_UNSPEC\n#define OE_AF_LOCAL OE_PF_LOCAL\n#define OE_AF_UNIX OE_PF_UNIX\n#define OE_AF_FILE OE_PF_FILE\n#define OE_AF_INET OE_PF_INET\n#define OE_AF_AX25 OE_PF_AX25\n#define OE_AF_IPX OE_PF_IPX\n#define OE_AF_APPLETALK OE_PF_APPLETALK\n#define OE_AF_NETROM OE_PF_NETROM\n#define OE_AF_BRIDGE OE_PF_BRIDGE\n#define OE_AF_ATMPVC OE_PF_ATMPVC\n#define OE_AF_X25 OE_PF_X25\n#define OE_AF_INET6 OE_PF_INET6\n#define OE_AF_ROSE OE_PF_ROSE\n#define OE_AF_DECnet OE_PF_DECnet\n#define OE_AF_NETBEUI OE_PF_NETBEUI\n#define OE_AF_SECURITY OE_PF_SECURITY\n#define OE_AF_KEY OE_PF_KEY\n#define OE_AF_NETLINK OE_PF_NETLINK\n#define OE_AF_ROUTE OE_PF_ROUTE\n#define OE_AF_PACKET OE_PF_PACKET\n#define OE_AF_ASH OE_PF_ASH\n#define OE_AF_ECONET OE_PF_ECONET\n#define OE_AF_ATMSVC OE_PF_ATMSVC\n#define OE_AF_RDS OE_PF_RDS\n#define OE_AF_SNA OE_PF_SNA\n#define OE_AF_IRDA OE_PF_IRDA\n#define OE_AF_PPPOX OE_PF_PPPOX\n#define OE_AF_WANPIPE OE_PF_WANPIPE\n#define OE_AF_LLC OE_PF_LLC\n#define OE_AF_IB OE_PF_IB\n#define OE_AF_MPLS OE_PF_MPLS\n#define OE_AF_CAN OE_PF_CAN\n#define OE_AF_TIPC OE_PF_TIPC\n#define OE_AF_BLUETOOTH OE_PF_BLUETOOTH\n#define OE_AF_IUCV OE_PF_IUCV\n#define OE_AF_RXRPC OE_PF_RXRPC\n#define OE_AF_ISDN OE_PF_ISDN\n#define OE_AF_PHONET OE_PF_PHONET\n#define OE_AF_IEEE802154 OE_PF_IEEE802154\n#define OE_AF_CAIF OE_PF_CAIF\n#define OE_AF_ALG OE_PF_ALG\n#define OE_AF_NFC OE_PF_NFC\n#define OE_AF_VSOCK OE_PF_VSOCK\n#define OE_AF_KCM OE_PF_KCM\n#define OE_AF_QIPCRTR OE_PF_QIPCRTR\n#define OE_AF_SMC OE_PF_SMC\n#define OE_AF_MAX OE_PF_MAX\n\n/* oe_setsockopt()/oe_getsockopt() options. */\n#define OE_SOL_SOCKET 1\n#define OE_SO_DEBUG 1\n#define OE_SO_REUSEADDR 2\n#define OE_SO_TYPE 3\n#define OE_SO_ERROR 4\n#define OE_SO_DONTROUTE 5\n#define OE_SO_BROADCAST 6\n#define OE_SO_SNDBUF 7\n#define OE_SO_RCVBUF 8\n#define OE_SO_SNDBUFFORCE 32\n#define OE_SO_RCVBUFFORCE 33\n#define OE_SO_KEEPALIVE 9\n#define OE_SO_OOBINLINE 10\n#define OE_SO_NO_CHECK 11\n#define OE_SO_PRIORITY 12\n#define OE_SO_LINGER 13\n#define OE_SO_BSDCOMPAT 14\n#define OE_SO_REUSEPORT 15\n\n/* Socket message flags. */\n#define OE_MSG_CTRUNC 0x0008\n\n/* oe_shutdown() options. */\n#define OE_SHUT_RD 0\n#define OE_SHUT_WR 1\n#define OE_SHUT_RDWR 2\n\n#define OE_MSG_PEEK 0x0002\n\n#define __OE_SOCKADDR_STORAGE oe_sockaddr_storage\n#include <openenclave/internal/syscall/sys/bits/sockaddr_storage.h>\n#undef __OE_SOCKADDR_STORAGE\n\n#define __OE_IOVEC oe_iovec\n#define __OE_MSGHDR oe_msghdr\n#include <openenclave/internal/syscall/sys/bits/msghdr.h>\n#undef __OE_IOVEC\n#undef __OE_MSGHDR\n\nvoid oe_set_default_socket_devid(uint64_t devid);\n\nuint64_t oe_get_default_socket_devid(void);\n\nint oe_socket(int domain, int type, int protocol);\n\nint oe_socket_d(uint64_t devid, int domain, int type, int protocol);\n\nint oe_socketpair(int domain, int type, int protocol, int rtnfd[2]);\n\nint oe_accept(int sockfd, struct oe_sockaddr* addr, oe_socklen_t* addrlen);\n\nint oe_bind(int sockfd, const struct oe_sockaddr* addr, oe_socklen_t namelen);\n\nint oe_connect(\n    int sockfd,\n    const struct oe_sockaddr* addr,\n    oe_socklen_t namelen);\n\nint oe_shutdown(int sockfd, int how);\n\nint oe_listen(int sockfd, int backlog);\n\nint oe_setsockopt(\n    int sockfd,\n    int level,\n    int optname,\n    const void* optval,\n    oe_socklen_t optlen);\n\nint oe_getsockopt(\n    int sockfd,\n    int level,\n    int optname,\n    void* optval,\n    oe_socklen_t* optlen);\n\nssize_t oe_send(int sockfd, const void* buf, size_t len, int flags);\n\nssize_t oe_recv(int sockfd, void* buf, size_t len, int flags);\n\nssize_t oe_sendto(\n    int sockfd,\n    const void* buf,\n    size_t len,\n    int flags,\n    const struct oe_sockaddr* dest_addr,\n    oe_socklen_t addrlen);\n\nssize_t oe_recvfrom(\n    int sockfd,\n    void* buf,\n    size_t len,\n    int flags,\n    struct oe_sockaddr* src_addr,\n    oe_socklen_t* addrlen);\n\nssize_t oe_sendmsg(int sockfd, const struct oe_msghdr* buf, int flags);\n\nssize_t oe_recvmsg(int sockfd, struct oe_msghdr* buf, int flags);\n\nint oe_getpeername(int sockfd, struct oe_sockaddr* addr, oe_socklen_t* addrlen);\n\nint oe_getsockname(int sockfd, struct oe_sockaddr* addr, oe_socklen_t* addrlen);\n\nOE_EXTERNC_END\n\n#endif /* _OE_SYSCALL_SYS_SOCKET_H */\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#include <openenclave/enclave.h>\n\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/internal/print.h>\n#include <openenclave/internal/syscall/fcntl.h>\n#include <openenclave/internal/syscall/fd.h>\n#include <openenclave/internal/syscall/fdtable.h>\n#include <openenclave/internal/syscall/iov.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/sys/ioctl.h>\n#include <openenclave/internal/syscall/unistd.h>\n#include <openenclave/internal/thread.h>\n#include <openenclave/internal/trace.h>\n#include \"syscall_t.h\"\n\n#define MAGIC 0x0b292bab\n\ntypedef struct _file\n{\n    oe_fd_t base;\n    uint32_t magic;\n    oe_host_fd_t host_fd;\n} file_t;\n\nstatic oe_file_ops_t _get_ops(void);\n\nstatic file_t* _cast_file(const oe_fd_t* file_)\n{\n    file_t* file = (file_t*)file_;\n\n    if (file == NULL || file->magic != MAGIC)\n        return NULL;\n\n    return file;\n}\n\nstatic int _consolefs_dup(oe_fd_t* file_, oe_fd_t** new_file_out)\n{\n    int ret = -1;\n    file_t* file = _cast_file(file_);\n    file_t* new_file = NULL;\n\n    if (new_file_out)\n        *new_file_out = NULL;\n\n    if (!file || !new_file_out)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Allocate and initialize a new file structure. */\n    {\n        if (!(new_file = oe_calloc(1, sizeof(file_t))))\n            OE_RAISE_ERRNO(OE_ENOMEM);\n\n        new_file->base.type = OE_FD_TYPE_FILE;\n        new_file->base.ops.file = _get_ops();\n        new_file->magic = MAGIC;\n    }\n\n    /* Ask the host to perform this operation. */\n    {\n        oe_host_fd_t retval = -1;\n\n        if (oe_syscall_dup_ocall(&retval, file->host_fd) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (retval == -1)\n            OE_RAISE_ERRNO(oe_errno);\n\n        new_file->host_fd = retval;\n    }\n\n    *new_file_out = (oe_fd_t*)new_file;\n\n    ret = 0;\n    new_file = NULL;\n\ndone:\n\n    if (new_file)\n        oe_free(new_file);\n\n    return ret;\n}\n\nstatic int _consolefs_ioctl(oe_fd_t* file_, unsigned long request, uint64_t arg)\n{\n    int ret = -1;\n    file_t* file = _cast_file(file_);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * MUSL uses the TIOCGWINSZ ioctl request to determine whether the file\n     * descriptor refers to a terminal device (such as stdin, stdout, and\n     * stderr) so that it can use line-bufferred input and output. This check\n     * fails when delegated to the host since this implementation opens the\n     * devices by name (/dev/stdin, /dev/stderr, /dev/stdout). So the following\n     * block works around this problem by implementing TIOCGWINSZ on the\n     * enclave side. Other terminal control ioctls are left unimplemented.\n     */\n    if (request == OE_TIOCGWINSZ)\n    {\n        struct winsize\n        {\n            unsigned short int ws_row;\n            unsigned short int ws_col;\n            unsigned short int ws_xpixel;\n            unsigned short int ws_ypixel;\n        };\n        struct winsize* p;\n\n        if (!(p = (struct winsize*)arg))\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        p->ws_row = 24;\n        p->ws_col = 80;\n        p->ws_xpixel = 0;\n        p->ws_ypixel = 0;\n\n        ret = 0;\n        goto done;\n    }\n\n    if (oe_syscall_ioctl_ocall(&ret, file->host_fd, request, arg, 0, NULL) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic int _consolefs_fcntl(oe_fd_t* file_, int cmd, uint64_t arg)\n{\n    int ret = -1;\n    file_t* file = _cast_file(file_);\n    void* argout = NULL;\n    uint64_t argsize = 0;\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    switch (cmd)\n    {\n        case OE_F_GETFD:\n        case OE_F_SETFD:\n        case OE_F_GETFL:\n        case OE_F_SETFL:\n            break;\n\n        case OE_F_GETLK:\n        case OE_F_OFD_GETLK:\n            argsize = sizeof(struct oe_flock);\n            argout = (void*)arg;\n            break;\n\n        case OE_F_SETLKW:\n        case OE_F_SETLK:\n        {\n            void* srcp = (void*)arg;\n            argsize = sizeof(struct oe_flock64);\n            argout = (void*)arg;\n            memcpy(argout, srcp, argsize);\n            break;\n        }\n\n        case OE_F_OFD_SETLK:\n        case OE_F_OFD_SETLKW:\n        {\n            void* srcp = (void*)arg;\n            argsize = sizeof(struct oe_flock64);\n            argout = (void*)arg;\n            memcpy(argout, srcp, argsize);\n            break;\n        }\n\n        // for sockets\n        default:\n        case OE_F_DUPFD:\n        case OE_F_SETOWN:\n        case OE_F_GETOWN:\n        case OE_F_SETSIG:\n        case OE_F_GETSIG:\n        case OE_F_SETOWN_EX:\n        case OE_F_GETOWN_EX:\n        case OE_F_GETOWNER_UIDS:\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (oe_syscall_fcntl_ocall(\n            &ret, file->host_fd, cmd, arg, argsize, argout) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _consolefs_read(oe_fd_t* file_, void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(file_);\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html for\n     * for more detail.\n     */\n    if (!file || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_read_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _consolefs_write(oe_fd_t* file_, const void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(file_);\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html for\n     * for more detail.\n     */\n    if (!file || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_write_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _consolefs_readv(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    if (!file || !iov || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size, &data_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /*\n     * According to the POSIX specification, when the data_size is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/readv.html for\n     * for more detail.\n     */\n    if (data_size > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_readv_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed data_size.\n     */\n    if (ret > (ssize_t)data_size)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic ssize_t _consolefs_writev(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    if (!file || (!iov && iovcnt) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size, &data_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /*\n     * According to the POSIX specification, when the data_size is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/writev.html\n     * for more detail.\n     */\n    if (data_size > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_writev_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed data_size.\n     */\n    if (ret > (ssize_t)data_size)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic oe_host_fd_t _consolefs_gethostfd(oe_fd_t* file_)\n{\n    oe_host_fd_t ret = -1;\n    file_t* file = _cast_file(file_);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = file->host_fd;\n\ndone:\n    return ret;\n}\n\nstatic oe_off_t _consolefs_lseek(oe_fd_t* file_, oe_off_t offset, int whence)\n{\n    oe_off_t ret = -1;\n\n    OE_UNUSED(file_);\n    OE_UNUSED(offset);\n    OE_UNUSED(whence);\n    OE_RAISE_ERRNO(OE_ESPIPE);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _consolefs_pread(\n    oe_fd_t* file_,\n    void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n\n    OE_UNUSED(file_);\n    OE_UNUSED(buf);\n    OE_UNUSED(count);\n    OE_UNUSED(offset);\n    OE_RAISE_ERRNO(OE_ESPIPE);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _consolefs_pwrite(\n    oe_fd_t* file_,\n    const void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n\n    OE_UNUSED(file_);\n    OE_UNUSED(buf);\n    OE_UNUSED(count);\n    OE_UNUSED(offset);\n    OE_RAISE_ERRNO(OE_ESPIPE);\n\ndone:\n    return ret;\n}\n\nstatic int _consolefs_close(oe_fd_t* file_)\n{\n    int ret = -1;\n    file_t* file = _cast_file(file_);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Ask the host to perform this operation. */\n    {\n        if (oe_syscall_close_ocall(&ret, file->host_fd) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (ret == -1)\n            OE_RAISE_ERRNO(oe_errno);\n    }\n\n    /* Free the file structure. */\n    oe_free(file);\n\ndone:\n    return ret;\n}\n\nstatic int _consolefs_getdents64(\n    oe_fd_t* file,\n    struct oe_dirent* dirp,\n    uint32_t count)\n{\n    OE_UNUSED(file);\n    OE_UNUSED(dirp);\n    OE_UNUSED(count);\n\n    /* The standard devices are not directories, so this is unsupported. */\n    OE_RAISE_ERRNO(OE_ENOTSUP);\n\ndone:\n    return -1;\n}\n\nstatic int _consolefs_fstat(oe_fd_t* file, struct oe_stat_t* buf)\n{\n    OE_UNUSED(file);\n    OE_UNUSED(buf);\n    OE_RAISE_ERRNO(OE_ENOTSUP);\ndone:\n    return -1;\n}\n\nstatic int _consolefs_fsync(oe_fd_t* file)\n{\n    OE_UNUSED(file);\n    OE_RAISE_ERRNO(OE_EINVAL);\ndone:\n    return -1;\n}\n\nstatic oe_file_ops_t _ops = {\n    .fd.read = _consolefs_read,\n    .fd.write = _consolefs_write,\n    .fd.readv = _consolefs_readv,\n    .fd.writev = _consolefs_writev,\n    .fd.dup = _consolefs_dup,\n    .fd.ioctl = _consolefs_ioctl,\n    .fd.fcntl = _consolefs_fcntl,\n    .fd.close = _consolefs_close,\n    .fd.get_host_fd = _consolefs_gethostfd,\n    .lseek = _consolefs_lseek,\n    .pread = _consolefs_pread,\n    .pwrite = _consolefs_pwrite,\n    .getdents64 = _consolefs_getdents64,\n    .fstat = _consolefs_fstat,\n    .fsync = _consolefs_fsync,\n    .fdatasync = _consolefs_fsync,\n};\n\nstatic oe_file_ops_t _get_ops(void)\n{\n    return _ops;\n}\n\nstatic oe_fd_t* _new_file(uint32_t fileno)\n{\n    oe_fd_t* ret = NULL;\n    file_t* file = NULL;\n\n    if (fileno > OE_STDERR_FILENO)\n        goto done;\n\n    /* Create the file struct. */\n    {\n        if (!(file = oe_calloc(1, sizeof(file_t))))\n            goto done;\n\n        file->base.type = OE_FD_TYPE_FILE;\n        file->base.ops.file = _ops;\n        file->magic = MAGIC;\n    }\n\n    /* Ask the host to duplicate the file descriptor. */\n    {\n        oe_host_fd_t retval;\n\n        if (oe_syscall_dup_ocall(&retval, fileno) != OE_OK)\n            goto done;\n\n        if (retval < 0)\n            goto done;\n\n        file->host_fd = retval;\n    }\n\n    ret = &file->base;\n    file = NULL;\n\ndone:\n\n    if (file)\n        oe_free(file);\n\n    return ret;\n}\n\noe_fd_t* oe_consolefs_create_file(uint32_t fileno)\n{\n    switch (fileno)\n    {\n        case OE_STDIN_FILENO:\n            return _new_file(OE_STDIN_FILENO);\n        case OE_STDOUT_FILENO:\n            return _new_file(OE_STDOUT_FILENO);\n        case OE_STDERR_FILENO:\n            return _new_file(OE_STDERR_FILENO);\n        default:\n            return NULL;\n    }\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#define _GNU_SOURCE\n\n#include <openenclave/enclave.h>\n\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/internal/calls.h>\n#include <openenclave/internal/raise.h>\n#include <openenclave/internal/safecrt.h>\n#include <openenclave/internal/syscall/device.h>\n#include <openenclave/internal/syscall/fcntl.h>\n#include <openenclave/internal/syscall/fdtable.h>\n#include <openenclave/internal/syscall/iov.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/sys/ioctl.h>\n#include <openenclave/internal/thread.h>\n#include <openenclave/internal/trace.h>\n#include <openenclave/internal/utils.h>\n#include \"syscall_t.h\"\n\n/* The map allocation grows in multiples of the chunk size. */\n#define MAP_CHUNK_SIZE 1024\n\n#define DEVICE_MAGIC 0x4504f4c\n#define EPOLL_MAGIC 0x708f5a51\n\n/* epoll_ctl() adds/modifies/deletes this mapping. */\ntypedef struct _mapping\n{\n    /* The fd parameter from epoll_ctl(). */\n    int fd;\n\n    /* The event parameter from epoll_ctl(). */\n    struct oe_epoll_event event;\n} mapping_t;\n\n/* The epoll device. */\ntypedef struct _device\n{\n    struct _oe_device base;\n\n    /* Should be DEVICE_MAGIC */\n    uint32_t magic;\n} device_t;\n\ntypedef struct _epoll\n{\n    oe_fd_t base;\n\n    /* Should be EPOLL_MAGIC */\n    uint32_t magic;\n\n    /* The host file descriptor created by epoll_create(). */\n    oe_host_fd_t host_fd;\n\n    /* Mappings added by epoll_ctl(OE_EPOLL_CTL_ADD) */\n    mapping_t* map;\n    size_t map_size;\n    size_t map_capacity;\n\n    /* Synchronizes access to this structure. */\n    oe_mutex_t lock;\n} epoll_t;\n\nstatic oe_epoll_ops_t _get_epoll_ops(void);\n\nstatic device_t* _cast_device(const oe_device_t* device_)\n{\n    device_t* device = (device_t*)device_;\n\n    if (device == NULL || device->magic != DEVICE_MAGIC)\n        return NULL;\n\n    return device;\n}\n\nstatic epoll_t* _cast_epoll(const oe_fd_t* epoll_)\n{\n    epoll_t* epoll = (epoll_t*)epoll_;\n\n    if (epoll == NULL || epoll->magic != EPOLL_MAGIC)\n        return NULL;\n\n    return epoll;\n}\n\n/* Reserve space in the mapping array (does not change map_size). */\nstatic int _map_reserve(epoll_t* epoll, size_t new_capacity)\n{\n    int ret = -1;\n\n    new_capacity = oe_round_up_to_multiple(new_capacity, MAP_CHUNK_SIZE);\n\n    if (new_capacity > epoll->map_capacity)\n    {\n        mapping_t* p;\n        const size_t n = new_capacity;\n\n        /* Reallocate the table. */\n        if (!(p = oe_realloc(epoll->map, n * sizeof(mapping_t))))\n            goto done;\n\n        /* Zero-fill the unused portion. */\n        {\n            const size_t num_bytes = (n - epoll->map_size) * sizeof(mapping_t);\n            void* ptr = p + epoll->map_size;\n\n            if (oe_memset_s(ptr, num_bytes, 0, num_bytes) != OE_OK)\n                goto done;\n        }\n\n        epoll->map = p;\n        epoll->map_capacity = n;\n    }\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Find the mapping for the given file descriptor. */\nstatic mapping_t* _map_find(epoll_t* epoll, int fd)\n{\n    size_t i;\n\n    for (i = 0; i < epoll->map_size; i++)\n    {\n        mapping_t* mapping = &epoll->map[i];\n\n        if (mapping->fd == fd)\n            return mapping;\n    }\n\n    /* Not found */\n    return NULL;\n}\n\n/* Called by oe_epoll_create1(). */\nstatic oe_fd_t* _epoll_create1(oe_device_t* device_, int32_t flags)\n{\n    oe_fd_t* ret = NULL;\n    epoll_t* epoll = NULL;\n    device_t* device = _cast_device(device_);\n    oe_host_fd_t retval;\n\n    oe_errno = 0;\n\n    if (!device)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(epoll = oe_calloc(1, sizeof(epoll_t))))\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    if (oe_syscall_epoll_create1_ocall(&retval, flags) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (retval < 0)\n        goto done;\n\n    epoll->base.type = OE_FD_TYPE_EPOLL;\n    epoll->base.ops.epoll = _get_epoll_ops();\n    epoll->magic = EPOLL_MAGIC;\n    epoll->host_fd = retval;\n\n    ret = &epoll->base;\n    epoll = NULL;\n\ndone:\n\n    if (epoll)\n        oe_free(epoll);\n\n    return ret;\n}\n\n/* Called by oe_epoll_create(). */\nstatic oe_fd_t* _epoll_create(oe_device_t* device_, int size)\n{\n    /* The size argument is ignored according to the manpage. */\n    OE_UNUSED(size);\n\n    /* Delegate with flags=0. */\n    return _epoll_create1(device_, 0);\n}\n\nstatic int _epoll_ctl_add(epoll_t* epoll, int fd, struct oe_epoll_event* event)\n{\n    int ret = -1;\n    oe_fd_t* desc;\n    oe_host_fd_t host_epfd;\n    oe_host_fd_t host_fd;\n    struct oe_epoll_event host_event;\n    int retval;\n    bool locked = false;\n\n    oe_errno = 0;\n\n    /* Check parameters. */\n    if (!epoll || !event)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(desc = oe_fdtable_get(fd, OE_FD_TYPE_ANY)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* Get the host fd for the epoll object. */\n    host_epfd = epoll->host_fd;\n\n    /* Get the host fd for the fd. */\n    if ((host_fd = desc->ops.fd.get_host_fd(desc)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* Initialize the host event. */\n    {\n        const size_t num_bytes = sizeof(host_event);\n\n        if (oe_memset_s(&host_event, num_bytes, 0, num_bytes) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        host_event.events = event->events;\n        host_event.data.fd = fd;\n    }\n\n    // The host call and the map update must be done in an atomic operation.\n    locked = true;\n    oe_mutex_lock(&epoll->lock);\n\n    if (oe_syscall_epoll_ctl_ocall(\n            &retval, host_epfd, OE_EPOLL_CTL_ADD, host_fd, &host_event) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (retval == 0)\n    {\n        if (_map_reserve(epoll, epoll->map_size + 1) != 0)\n            OE_RAISE_ERRNO(OE_ENOMEM);\n\n        epoll->map[epoll->map_size].fd = fd;\n        epoll->map[epoll->map_size].event = *event;\n        epoll->map_size++;\n    }\n\n    ret = retval;\n\ndone:\n\n    if (locked)\n        oe_mutex_unlock(&epoll->lock);\n\n    return ret;\n}\n\nstatic int _epoll_ctl_mod(epoll_t* epoll, int fd, struct oe_epoll_event* event)\n{\n    int ret = -1;\n    oe_fd_t* desc;\n    oe_host_fd_t host_epfd;\n    oe_host_fd_t host_fd;\n    struct oe_epoll_event host_event;\n    int retval;\n    bool locked = false;\n\n    oe_errno = 0;\n\n    /* Check parameters. */\n    if (!epoll || !event)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(desc = oe_fdtable_get(fd, OE_FD_TYPE_ANY)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* Get the host fd for the epoll device. */\n    host_epfd = epoll->host_fd;\n\n    /* Get the host fd for the device. */\n    if ((host_fd = desc->ops.fd.get_host_fd(desc)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* Initialize the host event. */\n    {\n        const size_t num_bytes = sizeof(host_event);\n\n        if (oe_memset_s(&host_event, num_bytes, 0, num_bytes) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        host_event.events = event->events;\n        host_event.data.fd = fd;\n    }\n\n    // The host call and the map update must be done in an atomic operation.\n    locked = true;\n    oe_mutex_lock(&epoll->lock);\n\n    if (oe_syscall_epoll_ctl_ocall(\n            &retval, host_epfd, OE_EPOLL_CTL_MOD, host_fd, &host_event) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(oe_errno);\n    }\n\n    /* Modify the mapping. */\n    if (retval == 0)\n    {\n        mapping_t* const mapping = _map_find(epoll, fd);\n        if (!mapping)\n            OE_RAISE_ERRNO(OE_ENOENT);\n\n        mapping->event = *event;\n    }\n\n    ret = 0;\n\ndone:\n    if (locked)\n        oe_mutex_unlock(&epoll->lock);\n\n    return ret;\n}\n\nstatic int _epoll_ctl_del(epoll_t* epoll, int fd)\n{\n    int ret = -1;\n    oe_fd_t* desc;\n    oe_host_fd_t host_epfd;\n    oe_host_fd_t host_fd;\n    int retval;\n    bool locked = false;\n\n    oe_errno = 0;\n\n    /* Check parameters. */\n    if (!epoll)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(desc = oe_fdtable_get(fd, OE_FD_TYPE_ANY)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* Get the host fd for the epoll device. */\n    host_epfd = epoll->host_fd;\n\n    /* Get the host fd for the device. */\n    if ((host_fd = desc->ops.fd.get_host_fd(desc)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    // The host call and the map update must be done in an atomic operation.\n    locked = true;\n    oe_mutex_lock(&epoll->lock);\n\n    if (oe_syscall_epoll_ctl_ocall(\n            &retval, host_epfd, OE_EPOLL_CTL_DEL, host_fd, NULL) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Delete the mapping. */\n    if (retval == 0)\n    {\n        bool found = false;\n\n        for (size_t i = 0; i < epoll->map_size; i++)\n        {\n            if (epoll->map[i].fd == fd)\n            {\n                /* Swap with last element of array. */\n                epoll->map[i] = epoll->map[--epoll->map_size];\n                found = true;\n                break;\n            }\n        }\n\n        if (!found)\n            OE_RAISE_ERRNO(OE_ENOENT);\n    }\n\n    ret = 0;\n\ndone:\n    if (locked)\n        oe_mutex_unlock(&epoll->lock);\n\n    return ret;\n}\n\n/* Called by oe_epoll_ctl(). */\nstatic int _epoll_ctl(\n    oe_fd_t* epoll_,\n    int op,\n    int fd,\n    struct oe_epoll_event* event)\n{\n    int ret = -1;\n    epoll_t* epoll = _cast_epoll(epoll_);\n\n    if (!epoll)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    switch (op)\n    {\n        case OE_EPOLL_CTL_ADD:\n        {\n            ret = _epoll_ctl_add(epoll, fd, event);\n            goto done;\n        }\n\n        case OE_EPOLL_CTL_MOD:\n        {\n            ret = _epoll_ctl_mod(epoll, fd, event);\n            goto done;\n        }\n\n        case OE_EPOLL_CTL_DEL:\n        {\n            ret = _epoll_ctl_del(epoll, fd);\n            goto done;\n        }\n\n        default:\n        {\n            OE_RAISE_ERRNO(OE_EINVAL);\n            return -1;\n        }\n    }\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Called by oe_epoll_wait(). */\nstatic int _epoll_wait(\n    oe_fd_t* epoll_,\n    struct oe_epoll_event* events,\n    int maxevents,\n    int timeout)\n{\n    int ret = -1;\n    int retval;\n    bool locked = false;\n    epoll_t* epoll = _cast_epoll(epoll_);\n    oe_host_fd_t host_epfd = -1;\n\n    if (!epoll || !events || maxevents <= 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    oe_errno = 0;\n\n    if ((host_epfd = epoll_->ops.fd.get_host_fd(epoll_)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_epoll_wait_ocall(\n            &retval, host_epfd, events, (unsigned int)maxevents, timeout) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (retval > 0)\n    {\n        if (retval > maxevents)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        locked = true;\n        oe_mutex_lock(&epoll->lock);\n\n        for (int i = 0; i < retval; i++)\n        {\n            struct oe_epoll_event* const event = &events[i];\n            const mapping_t* const mapping = _map_find(epoll, event->data.fd);\n\n            if (mapping)\n                event->data.u64 = mapping->event.data.u64;\n            else\n            {\n                // fd has been deleted between the return of epoll_wait and the\n                // acquisition of the lock.\n                --retval;\n                *event = events[retval];\n                --i;\n            }\n        }\n    }\n\n    ret = (int)retval;\n\ndone:\n    if (locked)\n        oe_mutex_unlock(&epoll->lock);\n\n    return ret;\n}\n\n/* Called by oe_close(). */\nstatic int _epoll_close(oe_fd_t* epoll_)\n{\n    int ret = -1;\n    epoll_t* epoll = _cast_epoll(epoll_);\n    int retval = -1;\n\n    oe_errno = 0;\n\n    if (!epoll)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Close the file descriptor on the host side. */\n    if (oe_syscall_epoll_close_ocall(&retval, epoll->host_fd) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (retval == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (epoll->map)\n        oe_free(epoll->map);\n\n    oe_free(epoll);\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\nstatic int _epoll_release(oe_device_t* device_)\n{\n    int ret = -1;\n    device_t* device = _cast_device(device_);\n\n    oe_errno = 0;\n\n    if (!device)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    oe_free(device);\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\nstatic oe_host_fd_t _epoll_get_host_fd(oe_fd_t* epoll_)\n{\n    epoll_t* epoll = _cast_epoll(epoll_);\n    return epoll->host_fd;\n}\n\nstatic int _epoll_ioctl(oe_fd_t* desc, unsigned long request, uint64_t arg)\n{\n    int ret = -1;\n    epoll_t* epoll = _cast_epoll(desc);\n    uint64_t argsize = 0;\n    void* argout = NULL;\n\n    if (!epoll)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * MUSL uses the TIOCGWINSZ ioctl request to determine whether the file\n     * descriptor refers to a terminal device. This request cannot be handled\n     * by Windows hosts, so the error is handled on the enclave side. This is\n     * the correct behavior since epolls are not terminal devices.\n     */\n    switch (request)\n    {\n        default:\n            OE_RAISE_ERRNO(OE_ENOTTY);\n    }\n\n    /* Call the host to perform the ioctl() operation. */\n    if (oe_syscall_ioctl_ocall(\n            &ret, epoll->host_fd, request, arg, argsize, argout) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic int _epoll_fcntl(oe_fd_t* desc, int cmd, uint64_t arg)\n{\n    int ret = -1;\n    epoll_t* epoll = _cast_epoll(desc);\n    void* argout = NULL;\n    uint64_t argsize = 0;\n\n    if (!epoll)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    switch (cmd)\n    {\n        case OE_F_GETFD:\n        case OE_F_SETFD:\n        case OE_F_GETFL:\n        case OE_F_SETFL:\n            break;\n\n        case OE_F_GETLK64:\n        case OE_F_OFD_GETLK:\n            argsize = sizeof(struct oe_flock);\n            argout = (void*)arg;\n            break;\n\n        case OE_F_SETLKW64:\n        case OE_F_SETLK64:\n        {\n            void* srcp = (void*)arg;\n            argsize = sizeof(struct oe_flock64);\n            argout = (void*)arg;\n            memcpy(argout, srcp, argsize);\n            break;\n        }\n\n        case OE_F_OFD_SETLK:\n        case OE_F_OFD_SETLKW:\n        {\n            void* srcp = (void*)arg;\n            argsize = sizeof(struct oe_flock64);\n            argout = (void*)arg;\n            memcpy(argout, srcp, argsize);\n            break;\n        }\n\n        // for sockets\n        default:\n        case OE_F_DUPFD: // Should be handled in posix layer\n        case OE_F_SETOWN:\n        case OE_F_GETOWN:\n        case OE_F_SETSIG:\n        case OE_F_GETSIG:\n        case OE_F_SETOWN_EX:\n        case OE_F_GETOWN_EX:\n        case OE_F_GETOWNER_UIDS:\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (oe_syscall_fcntl_ocall(\n            &ret, epoll->host_fd, cmd, arg, argsize, argout) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _epoll_read(oe_fd_t* epoll_, void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(epoll_);\n\n    oe_errno = 0;\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html for\n     * for more detail.\n     */\n    if (!file || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_read_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _epoll_write(oe_fd_t* epoll_, const void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(epoll_);\n\n    oe_errno = 0;\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html for\n     * for more detail.\n     */\n    if (!file || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_write_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _epoll_readv(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    if (!file || (iovcnt && !iov) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size, &data_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /*\n     * According to the POSIX specification, when the data_size is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/readv.html for\n     * for more detail.\n     */\n    if (data_size > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_readv_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed data_size.\n     */\n    if (ret > (ssize_t)data_size)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic ssize_t _epoll_writev(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    if (!file || (iovcnt && !iov) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size, &data_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /*\n     * According to the POSIX specification, when the data_size is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/writev.html\n     * for more detail.\n     */\n    if (data_size > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_writev_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed data_size.\n     */\n    if (ret > (ssize_t)data_size)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic int _epoll_dup(oe_fd_t* epoll_, oe_fd_t** new_epoll_out)\n{\n    int ret = -1;\n    epoll_t* epoll = _cast_epoll(epoll_);\n    epoll_t* new_epoll = NULL;\n    oe_host_fd_t retval;\n\n    oe_errno = 0;\n\n    /* Check parameters. */\n    if (!new_epoll_out)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!epoll)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call host: */\n    {\n        if (oe_syscall_dup_ocall(&retval, epoll->host_fd) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (retval == -1)\n            OE_RAISE_ERRNO(oe_errno);\n    }\n\n    /* Create the new epoll object. */\n    {\n        if (!(new_epoll = oe_calloc(1, sizeof(epoll_t))))\n            OE_RAISE_ERRNO(oe_errno);\n\n        new_epoll->base.type = OE_FD_TYPE_EPOLL;\n        new_epoll->base.ops.epoll = _get_epoll_ops();\n        new_epoll->magic = EPOLL_MAGIC;\n        new_epoll->host_fd = retval;\n\n        if (epoll->map && epoll->map_size)\n        {\n            mapping_t* map;\n\n            if (!(map = oe_calloc(epoll->map_size, sizeof(mapping_t))))\n                OE_RAISE_ERRNO(OE_ENOMEM);\n\n            memcpy(map, epoll->map, epoll->map_size * sizeof(mapping_t));\n            new_epoll->map = map;\n            new_epoll->map_size = epoll->map_size;\n        }\n\n        *new_epoll_out = &new_epoll->base;\n        new_epoll = NULL;\n    }\n\n    ret = 0;\n\ndone:\n\n    if (new_epoll)\n        oe_free(new_epoll);\n\n    return ret;\n}\n\nstatic void _epoll_on_close(oe_fd_t* epoll_, int fd)\n{\n    epoll_t* const epoll = _cast_epoll(epoll_);\n    oe_assert(epoll);\n\n    oe_assert(fd >= 0);\n\n    oe_mutex_lock(&epoll->lock);\n\n    /* Delete the mapping if it exists. */\n    for (size_t i = 0; i < epoll->map_size; i++)\n    {\n        if (epoll->map[i].fd == fd)\n        {\n            /* Swap with last element of array. */\n            epoll->map[i] = epoll->map[--epoll->map_size];\n            break;\n        }\n    }\n\n    oe_mutex_unlock(&epoll->lock);\n}\n\nstatic oe_epoll_ops_t _epoll_ops = {\n    .fd.read = _epoll_read,\n    .fd.write = _epoll_write,\n    .fd.readv = _epoll_readv,\n    .fd.writev = _epoll_writev,\n    .fd.dup = _epoll_dup,\n    .fd.ioctl = _epoll_ioctl,\n    .fd.fcntl = _epoll_fcntl,\n    .fd.close = _epoll_close,\n    .fd.get_host_fd = _epoll_get_host_fd,\n    .epoll_ctl = _epoll_ctl,\n    .epoll_wait = _epoll_wait,\n    .on_close = _epoll_on_close,\n};\n\nstatic oe_epoll_ops_t _get_epoll_ops(void)\n{\n    return _epoll_ops;\n}\n\n// clang-format off\nstatic device_t _device =\n{\n    .base.type = OE_DEVICE_TYPE_EPOLL,\n    .base.name = OE_DEVICE_NAME_HOST_EPOLL,\n    .base.ops.epoll =\n    {\n        .base.release = _epoll_release,\n        .epoll_create = _epoll_create,\n        .epoll_create1 = _epoll_create1,\n    },\n    .magic = DEVICE_MAGIC,\n};\n// clang-format on\n\noe_result_t oe_load_module_host_epoll(void)\n{\n    oe_result_t result = OE_UNEXPECTED;\n    static oe_spinlock_t _lock = OE_SPINLOCK_INITIALIZER;\n    static bool _loaded = false;\n\n    oe_spin_lock(&_lock);\n\n    if (!_loaded)\n    {\n        if (oe_device_table_set(OE_DEVID_HOST_EPOLL, &_device.base) != 0)\n        {\n            /* Do not propagate errno to caller. */\n            oe_errno = 0;\n            OE_RAISE(OE_FAILURE);\n        }\n\n        _loaded = true;\n    }\n\n    result = OE_OK;\n\ndone:\n    oe_spin_unlock(&_lock);\n\n    return result;\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n/*\n**==============================================================================\n**\n** hostfs:\n**\n**     This module implements the host file system, which allows enclaves to\n**     manipulate non-secure host files. To use this module, the enclave\n**     application must:\n**\n**     (1) Link the oehostfs library.\n**     (2) Load the module by calling oe_load_module_host_file_system().\n**     (3) Use the standard C file I/O functions (e.g., open, read, write).\n**\n**==============================================================================\n*/\n\n// clang-format off\n#include <openenclave/enclave.h>\n// clang-format on\n\n#include <openenclave/internal/syscall/device.h>\n#include <openenclave/internal/thread.h>\n#include <openenclave/internal/syscall/dirent.h>\n#include <openenclave/internal/syscall/sys/mount.h>\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/internal/syscall/fcntl.h>\n#include <openenclave/internal/syscall/sys/ioctl.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/iov.h>\n#include <openenclave/internal/raise.h>\n#include <openenclave/internal/hexdump.h>\n#include <openenclave/internal/safecrt.h>\n\n#include \"syscall_t.h\"\n\n#define FS_MAGIC 0x5f35f964\n#define FILE_MAGIC 0xfe48c6ff\n#define DIR_MAGIC 0x8add1b0b\n\n/* Mask to extract the access mode: O_RDONLY, O_WRONLY, O_RDWR. */\n#define ACCESS_MODE_MASK 000000003\n\n/* The host file system device. */\ntypedef struct _device\n{\n    oe_device_t base;\n\n    /* Must be FS_MAGIC. */\n    uint32_t magic;\n\n    /* True if this file system has been mounted. */\n    bool is_mounted;\n\n    /* The parameters that were passed to the mount() function. */\n    struct\n    {\n        unsigned long flags;\n        char source[OE_PATH_MAX];\n        char target[OE_PATH_MAX];\n    } mount;\n} device_t;\n\n/* Create by open(). */\ntypedef struct _file\n{\n    oe_fd_t base;\n\n    /* Must be FILE_MAGIC. */\n    uint32_t magic;\n\n    /* The file descriptor obtained from the host or -1 for directory files. */\n    oe_host_fd_t host_fd;\n\n    /* The file descriptor for an open directory if non-null. */\n    oe_fd_t* dir;\n} file_t;\n\n/* Created by opendir(), updated by readdir(), closed by closedir(). */\ntypedef struct _dir\n{\n    oe_fd_t base;\n\n    /* Must be DIR_MAGIC. */\n    uint32_t magic;\n\n    /* The directory handle obtained from the host by opendir(). */\n    uint64_t host_dir;\n\n    /* The directory entry obtained from the host by readdir(). */\n    struct oe_dirent entry;\n} dir_t;\n\nstatic oe_file_ops_t _get_file_ops(void);\n\nstatic ssize_t _hostfs_read(oe_fd_t* desc, void* buf, size_t count);\n\nstatic int _hostfs_close(oe_fd_t* desc);\n\nstatic oe_fd_t* _hostfs_opendir(oe_device_t* device, const char* name);\n\nstatic int _hostfs_closedir(oe_fd_t* desc);\n\nstatic struct oe_dirent* _hostfs_readdir(oe_fd_t* desc);\n\n/* Return true if the file system was mounted as read-only. */\nOE_INLINE bool _is_read_only(const device_t* fs)\n{\n    return fs->mount.flags & OE_MS_RDONLY;\n}\n\nstatic device_t* _cast_device(const oe_device_t* device)\n{\n    device_t* ret = NULL;\n    device_t* fs = (device_t*)device;\n\n    if (fs == NULL || fs->magic != FS_MAGIC)\n        goto done;\n\n    ret = fs;\n\ndone:\n    return ret;\n}\n\nstatic file_t* _cast_file(const oe_fd_t* desc)\n{\n    file_t* ret = NULL;\n    file_t* file = (file_t*)desc;\n\n    if (file == NULL || file->magic != FILE_MAGIC)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = file;\n\ndone:\n    return ret;\n}\n\nstatic dir_t* _cast_dir(const oe_fd_t* desc)\n{\n    dir_t* ret = NULL;\n    dir_t* dir = (dir_t*)desc;\n\n    if (dir == NULL || dir->magic != DIR_MAGIC)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = dir;\n\ndone:\n    return ret;\n}\n\n/* Expand an enclave path to a host path. */\nstatic int _make_host_path(\n    const device_t* fs,\n    const char* enclave_path,\n    char host_path[OE_PATH_MAX])\n{\n    const size_t n = OE_PATH_MAX;\n    int ret = -1;\n\n    if (oe_strcmp(fs->mount.source, \"/\") == 0)\n    {\n        if (oe_strlcpy(host_path, enclave_path, OE_PATH_MAX) >= n)\n            OE_RAISE_ERRNO(OE_ENAMETOOLONG);\n    }\n    else\n    {\n        if (oe_strlcpy(host_path, fs->mount.source, OE_PATH_MAX) >= n)\n            OE_RAISE_ERRNO(OE_ENAMETOOLONG);\n\n        if (oe_strcmp(enclave_path, \"/\") != 0)\n        {\n            if (oe_strlcat(host_path, \"/\", OE_PATH_MAX) >= n)\n                OE_RAISE_ERRNO(OE_ENAMETOOLONG);\n\n            if (oe_strlcat(host_path, enclave_path, OE_PATH_MAX) >= n)\n                OE_RAISE_ERRNO(OE_ENAMETOOLONG);\n        }\n    }\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Called by oe_mount(). */\nstatic int _hostfs_mount(\n    oe_device_t* device,\n    const char* source,\n    const char* target,\n    const char* filesystemtype,\n    unsigned long flags,\n    const void* data)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n\n    /* Fail if required parameters are null. */\n    if (!fs || !source || !target)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if this file system is already mounted. */\n    if (fs->is_mounted)\n        OE_RAISE_ERRNO(OE_EBUSY);\n\n    /* Cross check the file system type. */\n    if (oe_strcmp(filesystemtype, OE_DEVICE_NAME_HOST_FILE_SYSTEM) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* The data parameter is not supported for host file systems. */\n    if (data)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Remember whether this is a read-only mount. */\n    if ((flags & OE_MS_RDONLY))\n        fs->mount.flags = flags;\n\n    /* ---------------------------------------------------------------------\n     * Only support absolute paths. Hostfs is treated as an external\n     * filesystem. As such, it does not make sense to resolve relative paths\n     * using the enclave's current working directory.\n     * ---------------------------------------------------------------------\n     */\n    if (source && source[0] != '/')\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Save the source parameter (will be needed to form host paths). */\n    oe_strlcpy(fs->mount.source, source, sizeof(fs->mount.source));\n\n    /* Save the target parameter (checked by the umount2() function). */\n    oe_strlcpy(fs->mount.target, target, sizeof(fs->mount.target));\n\n    /* Set the flag indicating that this file system is mounted. */\n    fs->is_mounted = true;\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Called by oe_umount2(). */\nstatic int _hostfs_umount2(oe_device_t* device, const char* target, int flags)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n\n    OE_UNUSED(flags);\n\n    /* Fail if any required parameters are null. */\n    if (!fs || !target)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if this file system is not mounted. */\n    if (!fs->is_mounted)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Cross check target parameter with the one passed to mount(). */\n    if (oe_strcmp(target, fs->mount.target) != 0)\n        OE_RAISE_ERRNO(OE_ENOENT);\n\n    /* Clear the cached mount parameters. */\n    oe_memset_s(&fs->mount, sizeof(fs->mount), 0, sizeof(fs->mount));\n\n    /* Set the flag indicating that this file system is mounted. */\n    fs->is_mounted = false;\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Called by oe_mount() to make a copy of this device. */\nstatic int _hostfs_clone(oe_device_t* device, oe_device_t** new_device)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    device_t* new_fs = NULL;\n\n    if (!fs || !new_device)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(new_fs = oe_calloc(1, sizeof(device_t))))\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    *new_fs = *fs;\n    *new_device = &new_fs->base;\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Called by oe_umount() to release this device. */\nstatic int _hostfs_release(oe_device_t* device)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n\n    if (!fs)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    oe_free(fs);\n    ret = 0;\n\ndone:\n    return ret;\n}\n\nstatic oe_fd_t* _hostfs_open_file(\n    oe_device_t* device,\n    const char* pathname,\n    int flags,\n    oe_mode_t mode)\n{\n    oe_fd_t* ret = NULL;\n    device_t* fs = _cast_device(device);\n    file_t* file = NULL;\n    char host_path[OE_PATH_MAX];\n    oe_host_fd_t retval = -1;\n\n    /* Fail if any required parameters are null. */\n    if (!fs || !pathname)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if attempting to write to a read-only file system. */\n    if (_is_read_only(fs) && (flags & ACCESS_MODE_MASK) != OE_O_RDONLY)\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    /* Create new file struct. */\n    {\n        if (!(file = oe_calloc(1, sizeof(file_t))))\n            OE_RAISE_ERRNO(OE_ENOMEM);\n\n        file->base.type = OE_FD_TYPE_FILE;\n        file->magic = FILE_MAGIC;\n        file->base.ops.file = _get_file_ops();\n    }\n\n    /* Ask the host to open the file. */\n    {\n        if (_make_host_path(fs, pathname, host_path) != 0)\n            OE_RAISE_ERRNO_MSG(oe_errno, \"pathname=%s\", pathname);\n\n        if (oe_syscall_open_ocall(&retval, host_path, flags, mode) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (retval < 0)\n            goto done;\n\n        file->host_fd = retval;\n    }\n\n    ret = &file->base;\n    file = NULL;\n\ndone:\n\n    if (file)\n        oe_free(file);\n\n    return ret;\n}\n\nstatic oe_fd_t* _hostfs_open_directory(\n    oe_device_t* device,\n    const char* pathname,\n    int flags)\n{\n    oe_fd_t* ret = NULL;\n    device_t* fs = _cast_device(device);\n    file_t* file = NULL;\n    oe_fd_t* dir = NULL;\n\n    /* Check parameters */\n    if (!fs || !pathname || !(flags & OE_O_DIRECTORY))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Directories can only be opened for read access. */\n    if ((flags & ACCESS_MODE_MASK) != OE_O_RDONLY)\n        OE_RAISE_ERRNO(OE_EACCES);\n\n    /* Attempt to open the directory. */\n    if (!(dir = _hostfs_opendir(device, pathname)))\n        OE_RAISE_ERRNO_MSG(oe_errno, \"pathname=%s\", pathname);\n\n    /* Allocate and initialize the file struct. */\n    {\n        if (!(file = oe_calloc(1, sizeof(file_t))))\n            OE_RAISE_ERRNO(OE_ENOMEM);\n\n        file->base.type = OE_FD_TYPE_FILE;\n        file->magic = FILE_MAGIC;\n        file->base.ops.file = _get_file_ops();\n        file->host_fd = -1;\n        file->dir = dir;\n    }\n\n    ret = &file->base;\n    file = NULL;\n    dir = NULL;\n\ndone:\n\n    if (file)\n        oe_free(file);\n\n    if (dir)\n        _hostfs_closedir(dir);\n\n    return ret;\n}\n\nstatic oe_fd_t* _hostfs_open(\n    oe_device_t* fs,\n    const char* pathname,\n    int flags,\n    oe_mode_t mode)\n{\n    if ((flags & OE_O_DIRECTORY))\n    {\n        /* Only existing directories can be opened, so mode is ignored. */\n        return _hostfs_open_directory(fs, pathname, flags);\n    }\n    else\n    {\n        return _hostfs_open_file(fs, pathname, flags, mode);\n    }\n}\n\nstatic int _hostfs_flock(oe_fd_t* desc, int operation)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host to perform the flock(). */\n    if (oe_syscall_flock_ocall(&ret, file->host_fd, operation) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_fsync(oe_fd_t* desc)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_fsync_ocall(&ret, file->host_fd) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_fdatasync(oe_fd_t* desc)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_fdatasync_ocall(&ret, file->host_fd) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_dup(oe_fd_t* desc, oe_fd_t** new_file_out)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n    file_t* new_file = NULL;\n\n    if (!new_file_out)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    *new_file_out = NULL;\n\n    /* Check parameters. */\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Create and initialize the new file structure. */\n    {\n        if (!(new_file = oe_calloc(1, sizeof(file_t))))\n            OE_RAISE_ERRNO(oe_errno);\n\n        new_file->base.type = OE_FD_TYPE_FILE;\n        new_file->base.ops.file = _get_file_ops();\n        new_file->magic = FILE_MAGIC;\n    }\n\n    /* Call the host to perform the dup(). */\n    {\n        oe_host_fd_t retval = -1;\n\n        if (oe_syscall_dup_ocall(&retval, file->host_fd) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (retval == -1)\n            OE_RAISE_ERRNO(oe_errno);\n\n        new_file->host_fd = retval;\n    }\n\n    *new_file_out = &new_file->base;\n    new_file = NULL;\n    ret = 0;\n\ndone:\n\n    if (new_file)\n        oe_free(new_file);\n\n    return ret;\n}\n\nstatic ssize_t _hostfs_read(oe_fd_t* desc, void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html for\n     * for more detail.\n     */\n    if (!file || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host to perform the read(). */\n    if (oe_syscall_read_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\n/* Called by oe_getdents64() to handle the getdents64 system call. */\nstatic int _hostfs_getdents64(\n    oe_fd_t* desc,\n    struct oe_dirent* dirp,\n    unsigned int count)\n{\n    int ret = -1;\n    int bytes = 0;\n    file_t* file = _cast_file(desc);\n    unsigned int i;\n    unsigned int n = count / sizeof(struct oe_dirent);\n\n    if (!file || !file->dir || !dirp)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Read the entries one-by-one. */\n    for (i = 0; i < n; i++)\n    {\n        struct oe_dirent* ent;\n\n        oe_errno = 0;\n\n        if (!(ent = _hostfs_readdir(file->dir)))\n        {\n            if (oe_errno)\n            {\n                OE_RAISE_ERRNO(oe_errno);\n                goto done;\n            }\n\n            break;\n        }\n\n        *dirp = *ent;\n        bytes += (int)sizeof(struct oe_dirent);\n        dirp++;\n    }\n\n    ret = bytes;\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostfs_write(oe_fd_t* desc, const void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    /*\n     * Check parameters.\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html for\n     * for more detail.\n     */\n    if (!file || (count && !buf) || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_write_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostfs_readv(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    if (!file || (!iov && iovcnt) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size, &data_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /*\n     * According to the POSIX specification, when the data_size is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/readv.html for\n     * for more detail.\n     */\n    if (data_size > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_readv_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed data_size.\n     */\n    if (ret > (ssize_t)data_size)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (ret > 0)\n    {\n        if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic ssize_t _hostfs_writev(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    if (!file || !iov || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size, &data_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /*\n     * According to the POSIX specification, when the data_size is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/writev.html\n     * for more detail.\n     */\n    if (data_size > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_writev_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed data_size.\n     */\n    if (ret > (ssize_t)data_size)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic oe_off_t _hostfs_lseek_file(oe_fd_t* desc, oe_off_t offset, int whence)\n{\n    oe_off_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_lseek_ocall(&ret, file->host_fd, offset, whence) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\n/* Perform rewinddir on a dir struct. */\nstatic int _hostfs_rewinddir(oe_fd_t* desc)\n{\n    int ret = -1;\n    dir_t* dir = _cast_dir(desc);\n\n    if (!dir)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_rewinddir_ocall(dir->host_dir) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n/* Perform lseek on a dir struct (only rewind is permitted on a directory). */\nstatic oe_off_t _hostfs_lseek_dir(oe_fd_t* desc, oe_off_t offset, int whence)\n{\n    oe_off_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file || !file->dir || offset != 0 || whence != OE_SEEK_SET)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if ((ret = _hostfs_rewinddir(file->dir)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\ndone:\n    return ret;\n}\n\nstatic oe_off_t _hostfs_lseek(oe_fd_t* desc, oe_off_t offset, int whence)\n{\n    oe_off_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (file->dir)\n        ret = _hostfs_lseek_dir(desc, offset, whence);\n    else\n        ret = _hostfs_lseek_file(desc, offset, whence);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostfs_pread(\n    oe_fd_t* desc,\n    void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/pread.html for\n     * for more detail.\n     */\n    if (!file || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pread_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostfs_pwrite(\n    oe_fd_t* desc,\n    const void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/pwrite.html\n     * for more detail.\n     */\n    if (!file || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pwrite_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_close_file(oe_fd_t* desc)\n{\n    int ret = -1;\n    int retval = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_close_ocall(&retval, file->host_fd) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (retval == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    oe_free(file);\n\n    ret = retval;\n\ndone:\n    return ret;\n}\n\n/* Close a directory file. */\nstatic int _hostfs_close_directory(oe_fd_t* desc)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n\n    /* Check parameters. */\n    if (!file || !file->dir)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Release the directory object. */\n    if (_hostfs_closedir(file->dir) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* Release the file object. */\n    oe_free(file);\n\n    ret = 0;\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_close(oe_fd_t* desc)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (file->dir)\n        ret = _hostfs_close_directory(desc);\n    else\n        ret = _hostfs_close_file(desc);\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_ioctl(oe_fd_t* desc, unsigned long request, uint64_t arg)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n    uint64_t argsize = 0;\n    void* argout = NULL;\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * MUSL uses the TIOCGWINSZ ioctl request to determine whether the file\n     * descriptor refers to a terminal device. This request cannot be handled\n     * by Windows hosts, so the error is handled on the enclave side. This is\n     * the correct behavior since host files are not terminal devices.\n     */\n    switch (request)\n    {\n        default:\n            OE_RAISE_ERRNO(OE_ENOTTY);\n    }\n\n    /* Call the host to perform the ioctl() operation. */\n    if (oe_syscall_ioctl_ocall(\n            &ret, file->host_fd, request, arg, argsize, argout) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic int _hostfs_fcntl(oe_fd_t* desc, int cmd, uint64_t arg)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n    void* argout = NULL;\n    uint64_t argsize = 0;\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    switch (cmd)\n    {\n        case OE_F_GETFD:\n        case OE_F_SETFD:\n        case OE_F_GETFL:\n        case OE_F_SETFL:\n            break;\n\n        case OE_F_GETLK64:\n        case OE_F_OFD_GETLK:\n            argsize = sizeof(struct oe_flock);\n            argout = (void*)arg;\n            break;\n\n        case OE_F_SETLKW64:\n        case OE_F_SETLK64:\n        {\n            void* srcp = (void*)arg;\n            argsize = sizeof(struct oe_flock64);\n            argout = (void*)arg;\n            memcpy(argout, srcp, argsize);\n            break;\n        }\n\n        case OE_F_OFD_SETLK:\n        case OE_F_OFD_SETLKW:\n        {\n            void* srcp = (void*)arg;\n            argsize = sizeof(struct oe_flock64);\n            argout = (void*)arg;\n            memcpy(argout, srcp, argsize);\n            break;\n        }\n\n        // for sockets\n        default:\n        case OE_F_DUPFD: // Should be handled in posix layer\n        case OE_F_SETOWN:\n        case OE_F_GETOWN:\n        case OE_F_SETSIG:\n        case OE_F_GETSIG:\n        case OE_F_SETOWN_EX:\n        case OE_F_GETOWN_EX:\n        case OE_F_GETOWNER_UIDS:\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (oe_syscall_fcntl_ocall(\n            &ret, file->host_fd, cmd, arg, argsize, argout) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\n/* Open a directory file. */\nstatic oe_fd_t* _hostfs_opendir(oe_device_t* device, const char* name)\n{\n    oe_fd_t* ret = NULL;\n    device_t* fs = _cast_device(device);\n    dir_t* dir = NULL;\n    char host_name[OE_PATH_MAX];\n    uint64_t retval = 0;\n\n    if (!fs || !name)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (_make_host_path(fs, name, host_name) != 0)\n        OE_RAISE_ERRNO_MSG(oe_errno, \"name=%s\", name);\n\n    if (!(dir = oe_calloc(1, sizeof(dir_t))))\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    if (oe_syscall_opendir_ocall(&retval, host_name) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!retval)\n        OE_RAISE_ERRNO(oe_errno);\n\n    dir->base.type = OE_FD_TYPE_FILE;\n    dir->magic = DIR_MAGIC;\n    dir->base.ops.file = _get_file_ops();\n    dir->host_dir = retval;\n\n    ret = &dir->base;\n    dir = NULL;\n\ndone:\n\n    if (dir)\n        oe_free(dir);\n\n    return ret;\n}\n\n/* Get the next directory entry from the host. */\nstatic struct oe_dirent* _hostfs_readdir(oe_fd_t* desc)\n{\n    struct oe_dirent* ret = NULL;\n    dir_t* dir = _cast_dir(desc);\n    int retval = -1;\n\n    if (!dir)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host to get the next directory entry. */\n    if (oe_syscall_readdir_ocall(&retval, dir->host_dir, &dir->entry) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Handle any error. */\n    if (retval == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    /* If end of file, then return NULL. */\n    if (retval == 1)\n        goto done;\n\n    /* Check for an unexpected return value (indicates a coding error). */\n    if (retval != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = &dir->entry;\n\ndone:\n\n    return ret;\n}\n\n/* Close the directory file. */\nstatic int _hostfs_closedir(oe_fd_t* desc)\n{\n    int ret = -1;\n    dir_t* dir = _cast_dir(desc);\n    int retval = -1;\n\n    if (!dir)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_closedir_ocall(&retval, dir->host_dir) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    oe_free(dir);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_stat(\n    oe_device_t* device,\n    const char* pathname,\n    struct oe_stat_t* buf)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_path[OE_PATH_MAX];\n    int retval = -1;\n\n    if (buf)\n        oe_memset_s(buf, sizeof(*buf), 0, sizeof(*buf));\n\n    if (!fs || !pathname || !buf)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (_make_host_path(fs, pathname, host_path) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_stat_ocall(&retval, host_path, buf) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_fstat(oe_fd_t* desc, struct oe_stat_t* buf)\n{\n    int ret = -1;\n    file_t* file = _cast_file(desc);\n    int retval = -1;\n\n    if (buf)\n        oe_memset_s(buf, sizeof(*buf), 0, sizeof(*buf));\n\n    if (!file || !buf)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_fstat_ocall(&retval, file->host_fd, buf) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_access(oe_device_t* device, const char* pathname, int mode)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_path[OE_PATH_MAX];\n    const uint32_t MASK = (OE_R_OK | OE_W_OK | OE_X_OK);\n    int retval = -1;\n\n    if (!fs || !pathname || ((uint32_t)mode & ~MASK))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (_make_host_path(fs, pathname, host_path) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_access_ocall(&retval, host_path, mode) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_link(\n    oe_device_t* device,\n    const char* oldpath,\n    const char* newpath)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_oldpath[OE_PATH_MAX];\n    char host_newpath[OE_PATH_MAX];\n    int retval = -1;\n\n    if (!fs || !oldpath || !newpath)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if attempting to write to a read-only file system. */\n    if (_is_read_only(fs))\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    if (_make_host_path(fs, oldpath, host_oldpath) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (_make_host_path(fs, newpath, host_newpath) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_link_ocall(&retval, host_oldpath, host_newpath) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_unlink(oe_device_t* device, const char* pathname)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_path[OE_PATH_MAX];\n    int retval = -1;\n\n    if (!fs)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if attempting to write to a read-only file system. */\n    if (_is_read_only(fs))\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    if (_make_host_path(fs, pathname, host_path) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_unlink_ocall(&retval, host_path) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_rename(\n    oe_device_t* device,\n    const char* oldpath,\n    const char* newpath)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_oldpath[OE_PATH_MAX];\n    char host_newpath[OE_PATH_MAX];\n    int retval = -1;\n\n    if (!fs || !oldpath || !newpath)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (_is_read_only(fs))\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    if (_make_host_path(fs, oldpath, host_oldpath) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (_make_host_path(fs, newpath, host_newpath) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_rename_ocall(&retval, host_oldpath, host_newpath) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_truncate(\n    oe_device_t* device,\n    const char* path,\n    oe_off_t length)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_path[OE_PATH_MAX];\n    int retval = -1;\n\n    if (!fs)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (_is_read_only(fs))\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    if (_make_host_path(fs, path, host_path) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_truncate_ocall(&retval, host_path, length) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_mkdir(\n    oe_device_t* device,\n    const char* pathname,\n    oe_mode_t mode)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_path[OE_PATH_MAX];\n    int retval = -1;\n\n    if (!fs)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if attempting to write to a read-only file system. */\n    if (_is_read_only(fs))\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    if (_make_host_path(fs, pathname, host_path) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_mkdir_ocall(&retval, host_path, mode) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostfs_rmdir(oe_device_t* device, const char* pathname)\n{\n    int ret = -1;\n    device_t* fs = _cast_device(device);\n    char host_path[OE_PATH_MAX];\n    int retval = -1;\n\n    if (!fs)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fail if attempting to write to a read-only file system. */\n    if (_is_read_only(fs))\n        OE_RAISE_ERRNO(OE_EPERM);\n\n    if (_make_host_path(fs, pathname, host_path) != 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if (oe_syscall_rmdir_ocall(&retval, host_path) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    ret = retval;\n\ndone:\n\n    return ret;\n}\n\nstatic oe_host_fd_t _hostfs_get_host_fd(oe_fd_t* desc)\n{\n    file_t* file = _cast_file(desc);\n\n    return file ? file->host_fd : -1;\n}\n\n// clang-format off\nstatic oe_file_ops_t _file_ops =\n{\n    .fd.read = _hostfs_read,\n    .fd.write = _hostfs_write,\n    .fd.readv = _hostfs_readv,\n    .fd.writev = _hostfs_writev,\n    .fd.flock = _hostfs_flock,\n    .fd.dup = _hostfs_dup,\n    .fd.ioctl = _hostfs_ioctl,\n    .fd.fcntl = _hostfs_fcntl,\n    .fd.close = _hostfs_close,\n    .fd.get_host_fd = _hostfs_get_host_fd,\n    .lseek = _hostfs_lseek,\n    .pread = _hostfs_pread,\n    .pwrite = _hostfs_pwrite,\n    .getdents64 = _hostfs_getdents64,\n    .fstat = _hostfs_fstat,\n    .fsync = _hostfs_fsync,\n    .fdatasync = _hostfs_fdatasync,\n};\n// clang-format on\n\nstatic oe_file_ops_t _get_file_ops(void)\n{\n    return _file_ops;\n};\n\n// clang-format off\nstatic device_t _hostfs =\n{\n    .base.type = OE_DEVICE_TYPE_FILE_SYSTEM,\n    .base.name = OE_DEVICE_NAME_HOST_FILE_SYSTEM,\n    .base.ops.fs =\n    {\n        .base.release = _hostfs_release,\n        .clone = _hostfs_clone,\n        .mount = _hostfs_mount,\n        .umount2 = _hostfs_umount2,\n        .open = _hostfs_open,\n        .stat = _hostfs_stat,\n        .access = _hostfs_access,\n        .link = _hostfs_link,\n        .unlink = _hostfs_unlink,\n        .rename = _hostfs_rename,\n        .truncate = _hostfs_truncate,\n        .mkdir = _hostfs_mkdir,\n        .rmdir = _hostfs_rmdir,\n    },\n    .magic = FS_MAGIC,\n    .mount =\n    {\n         .source = {'/'},\n    }\n};\n// clang-format on\n\noe_device_t* oe_get_hostfs_device(void)\n{\n    return &_hostfs.base;\n}\n\noe_result_t oe_load_module_host_file_system(void)\n{\n    oe_result_t result = OE_UNEXPECTED;\n    static oe_spinlock_t _lock = OE_SPINLOCK_INITIALIZER;\n    static bool _loaded = false;\n\n    oe_spin_lock(&_lock);\n\n    if (!_loaded)\n    {\n        if (oe_device_table_set(OE_DEVID_HOST_FILE_SYSTEM, &_hostfs.base) != 0)\n        {\n            /* Do not propagate errno to caller. */\n            oe_errno = 0;\n            OE_RAISE(OE_FAILURE);\n        }\n\n        _loaded = true;\n    }\n\n    result = OE_OK;\n\ndone:\n    oe_spin_unlock(&_lock);\n\n    return result;\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#define _GNU_SOURCE\n\n// clang-format off\n#include <openenclave/enclave.h>\n// clang-format on\n\n#include <openenclave/internal/syscall/device.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/sys/socket.h>\n#include <openenclave/internal/syscall/netdb.h>\n#include <openenclave/internal/syscall/netinet/in.h>\n#include <openenclave/internal/syscall/resolver.h>\n#include <openenclave/internal/safemath.h>\n#include <openenclave/internal/calls.h>\n#include <openenclave/internal/thread.h>\n#include <openenclave/internal/print.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/bits/module.h>\n#include <openenclave/internal/trace.h>\n#include \"syscall_t.h\"\n\n#define RESOLV_MAGIC 0x536f636b\n\n/*\n * The definition of AF_INET6 on Windows (i.e., 23) is different from that of on\n * Linux (i.e., 10). Given that the internal socket.h conforms to the\n * implementation of Linux, we explicitly define the Windows-specific value\n * here for being compatible with a Windows host.\n */\n#define OE_AF_INET6_WIN 23\n\n// The host resolver is not actually a device in the file descriptor sense.\ntypedef struct _resolver\n{\n    struct _oe_resolver base;\n    uint32_t magic;\n} resolver_t;\n\nstatic resolver_t* _cast_resolver(const oe_resolver_t* device)\n{\n    resolver_t* resolver = (resolver_t*)device;\n\n    if (resolver == NULL || resolver->magic != RESOLV_MAGIC)\n        return NULL;\n\n    return resolver;\n}\n\nstatic resolver_t _hostresolver;\n\nstatic int _hostresolver_getnameinfo(\n    oe_resolver_t* dev,\n    const struct oe_sockaddr* sa,\n    oe_socklen_t salen,\n    char* host,\n    oe_socklen_t hostlen,\n    char* serv,\n    oe_socklen_t servlen,\n    int flags)\n{\n    int ret = OE_EAI_FAIL;\n\n    OE_UNUSED(dev);\n\n    oe_errno = 0;\n\n    if (oe_syscall_getnameinfo_ocall(\n            &ret, sa, salen, host, hostlen, serv, servlen, flags) != OE_OK)\n    {\n        goto done;\n    }\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostresolver_getaddrinfo(\n    oe_resolver_t* resolver,\n    const char* node,\n    const char* service,\n    const struct oe_addrinfo* hints,\n    struct oe_addrinfo** res)\n{\n    int ret = OE_EAI_FAIL;\n    uint64_t handle = 0;\n    struct oe_addrinfo* head = NULL;\n    struct oe_addrinfo* tail = NULL;\n    struct oe_addrinfo* p = NULL;\n\n    OE_UNUSED(resolver);\n\n    if (res)\n        *res = NULL;\n\n    if (!res)\n    {\n        ret = OE_EAI_SYSTEM;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Get the handle for enumerating addrinfo structures. */\n    {\n        int retval = OE_EAI_FAIL;\n\n        if (oe_syscall_getaddrinfo_open_ocall(\n                &retval, node, service, hints, &handle) != OE_OK)\n        {\n            ret = OE_EAI_SYSTEM;\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        if (!handle)\n        {\n            ret = retval;\n            goto done;\n        }\n    }\n\n    /* Enumerate addrinfo structures. */\n    for (;;)\n    {\n        int retval = 0;\n        size_t canonnamelen_in = 0;\n        size_t canonnamelen_out = 0;\n        struct oe_addrinfo p_out;\n\n        memset(&p_out, 0, sizeof(struct oe_addrinfo));\n\n        /* Determine required size ai_addr and ai_canonname buffers. */\n        if (oe_syscall_getaddrinfo_read_ocall(\n                &retval,\n                handle,\n                &p_out.ai_flags,\n                &p_out.ai_family,\n                &p_out.ai_socktype,\n                &p_out.ai_protocol,\n                p_out.ai_addrlen,\n                &p_out.ai_addrlen,\n                NULL,\n                canonnamelen_in,\n                &canonnamelen_out,\n                NULL) != OE_OK)\n        {\n            ret = OE_EAI_SYSTEM;\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        /* If this is the final element in the enumeration. */\n        if (retval == 1)\n            break;\n\n        /* Expecting that addr and canonname buffers were too small. */\n        if (retval != -1 || oe_errno != OE_ENAMETOOLONG)\n        {\n            ret = OE_EAI_SYSTEM;\n            OE_RAISE_ERRNO(oe_errno);\n        }\n\n        /*\n         * Guard the special case that a host sets an arbitrarily large value.\n         * Based on the implementation of MUSL, the ai_addrlen can only be\n         * sizeof(struct sockaddr_in) when the family is AF_INET or\n         * sizeof(struct sockaddr_in6) when the family is AF_INET6.\n         * When the family is AF_UNSPEC, OE checks the ai_addrlen against\n         * sizeof(struct sockaddr_in6) as it should cover AF_INET and\n         * AF_INET6 cases. Besides, OE errors out other family types.\n         */\n        switch (p_out.ai_family)\n        {\n            case OE_AF_INET:\n                if (p_out.ai_addrlen != sizeof(struct oe_sockaddr))\n                {\n                    ret = OE_EAI_FAIL;\n                    goto done;\n                }\n                break;\n            case OE_AF_INET6:\n            case OE_AF_INET6_WIN:\n            case OE_AF_UNSPEC:\n                if (p_out.ai_addrlen != sizeof(struct oe_sockaddr_in6))\n                {\n                    ret = OE_EAI_FAIL;\n                    goto done;\n                }\n                break;\n            default:\n                ret = OE_EAI_FAIL;\n                goto done;\n        }\n\n        if (!(p = oe_calloc(1, sizeof(struct oe_addrinfo))))\n        {\n            ret = OE_EAI_MEMORY;\n            goto done;\n        }\n\n        if (p_out.ai_addrlen && !(p->ai_addr = oe_calloc(1, p_out.ai_addrlen)))\n        {\n            ret = OE_EAI_MEMORY;\n            goto done;\n        }\n\n        if (canonnamelen_out &&\n            !(p->ai_canonname = oe_calloc(1, canonnamelen_out)))\n        {\n            ret = OE_EAI_MEMORY;\n            goto done;\n        }\n\n        /* Set canonnamelen_in to the expected length of p->ai_cannonname\n         * returned by the host. */\n        canonnamelen_in = canonnamelen_out;\n\n        if (oe_syscall_getaddrinfo_read_ocall(\n                &retval,\n                handle,\n                &p->ai_flags,\n                &p->ai_family,\n                &p->ai_socktype,\n                &p->ai_protocol,\n                p_out.ai_addrlen,\n                &p->ai_addrlen,\n                p->ai_addr,\n                canonnamelen_in,\n                &canonnamelen_out,\n                p->ai_canonname) != OE_OK)\n        {\n            ret = OE_EAI_SYSTEM;\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        /*\n         * Lock down the out parameters, which are expected\n         * to be the same as the first invocation. Also,\n         * p->ai_cannonname is expected to be NULL-terminated.\n         */\n        if ((p->ai_flags != p_out.ai_flags) ||\n            (p->ai_family != p_out.ai_family) ||\n            (p->ai_socktype != p_out.ai_socktype) ||\n            (p->ai_protocol != p_out.ai_protocol) ||\n            (p->ai_addrlen != p_out.ai_addrlen) ||\n            (canonnamelen_out != canonnamelen_in) ||\n            (canonnamelen_out && p->ai_canonname[canonnamelen_out - 1] != '\\0'))\n        {\n            ret = OE_EAI_FAIL;\n            goto done;\n        }\n\n        /* Append to the list. */\n        if (tail)\n        {\n            tail->ai_next = p;\n            tail = p;\n        }\n        else\n        {\n            head = p;\n            tail = p;\n        }\n\n        p = NULL;\n    }\n\n    /* Close the enumeration. */\n    if (handle)\n    {\n        int retval = -1;\n\n        if (oe_syscall_getaddrinfo_close_ocall(&retval, handle) != OE_OK)\n        {\n            ret = OE_EAI_SYSTEM;\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        handle = 0;\n\n        if (retval != 0)\n        {\n            ret = OE_EAI_SYSTEM;\n            OE_RAISE_ERRNO(oe_errno);\n        }\n    }\n\n    /* If the list is empty. */\n    if (!head)\n    {\n        ret = OE_EAI_SYSTEM;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    *res = head;\n    head = NULL;\n    tail = NULL;\n    ret = 0;\n\ndone:\n\n    if (handle)\n    {\n        int retval;\n        oe_syscall_getaddrinfo_close_ocall(&retval, handle);\n    }\n\n    if (head)\n        oe_freeaddrinfo(head);\n\n    if (p)\n        oe_freeaddrinfo(p);\n\n    return ret;\n}\n\nstatic int _hostresolver_release(oe_resolver_t* resolv_)\n{\n    int ret = -1;\n    resolver_t* resolver = _cast_resolver(resolv_);\n\n    oe_errno = 0;\n\n    if (!resolver)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    // resolv_ is a static object, there is no need to free\n    ret = 0;\n\ndone:\n    return ret;\n}\n\n// clang-format off\nstatic oe_resolver_ops_t _ops =\n{\n    .getaddrinfo = _hostresolver_getaddrinfo,\n    .getnameinfo = _hostresolver_getnameinfo,\n    .release = _hostresolver_release\n};\n// clang-format on\n\n// clang-format off\nstatic resolver_t _hostresolver =\n{\n    .base.type = OE_RESOLVER_TYPE_HOST,\n    .base.ops = &_ops,\n    .magic = RESOLV_MAGIC\n};\n// clang-format on\n\noe_result_t oe_load_module_host_resolver(void)\n{\n    oe_result_t result = OE_UNEXPECTED;\n    static oe_spinlock_t _lock = OE_SPINLOCK_INITIALIZER;\n    static bool _loaded = false;\n\n    oe_spin_lock(&_lock);\n\n    if (!_loaded)\n    {\n        if (oe_register_resolver(&_hostresolver.base) != 0)\n            OE_RAISE_ERRNO(oe_errno);\n\n        _loaded = true;\n    }\n\n    result = OE_OK;\n\ndone:\n    oe_spin_unlock(&_lock);\n\n    return result;\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#define _GNU_SOURCE\n\n// clang-format off\n#include <openenclave/enclave.h>\n// clang-format on\n\n#include <openenclave/internal/syscall/device.h>\n#include <openenclave/internal/thread.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/internal/syscall/sys/socket.h>\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/iov.h>\n#include <openenclave/internal/syscall/fd.h>\n#include <openenclave/internal/syscall/iov.h>\n#include <openenclave/internal/syscall/fcntl.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/internal/raise.h>\n#include <openenclave/internal/safecrt.h>\n#include \"syscall_t.h\"\n\n#define DEVICE_MAGIC 0x536f636b\n#define SOCK_MAGIC 0xe57a696d\n\nstatic oe_socket_ops_t _get_socket_ops(void);\n\ntypedef struct _device\n{\n    struct _oe_device base;\n    uint32_t magic;\n    oe_host_fd_t host_fd;\n} device_t;\n\ntypedef struct _sock\n{\n    oe_fd_t base;\n    uint32_t magic;\n    oe_host_fd_t host_fd;\n} sock_t;\n\nstatic sock_t* _new_sock(void)\n{\n    sock_t* sock = NULL;\n\n    if (!(sock = oe_calloc(1, sizeof(sock_t))))\n        return NULL;\n\n    sock->base.type = OE_FD_TYPE_SOCKET;\n    sock->base.ops.socket = _get_socket_ops();\n    sock->magic = SOCK_MAGIC;\n    sock->host_fd = -1;\n\n    return sock;\n}\n\nstatic device_t* _cast_device(const oe_device_t* device)\n{\n    device_t* p = (device_t*)device;\n\n    if (p == NULL || p->magic != DEVICE_MAGIC)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return p;\n}\n\nstatic sock_t* _cast_sock(const oe_fd_t* desc)\n{\n    sock_t* sock = (sock_t*)desc;\n\n    if (sock == NULL || sock->magic != SOCK_MAGIC)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return sock;\n}\n\nstatic ssize_t _hostsock_read(oe_fd_t*, void* buf, size_t count);\n\nstatic int _hostsock_close(oe_fd_t*);\n\nstatic oe_fd_t* _hostsock_device_socket(\n    oe_device_t* dev,\n    int domain,\n    int type,\n    int protocol)\n{\n    oe_fd_t* ret = NULL;\n    device_t* sock = _cast_device(dev);\n    sock_t* new_sock = NULL;\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(new_sock = _new_sock()))\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    {\n        oe_host_fd_t retval = -1;\n\n        if (oe_syscall_socket_ocall(&retval, domain, type, protocol) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (retval == -1)\n            OE_RAISE_ERRNO_MSG(oe_errno, \"retval=%ld\\n\", retval);\n\n        new_sock->host_fd = retval;\n    }\n\n    ret = &new_sock->base;\n    new_sock = NULL;\n\ndone:\n\n    if (new_sock)\n        oe_free(new_sock);\n\n    return ret;\n}\n\nstatic ssize_t _hostsock_device_socketpair(\n    oe_device_t* dev,\n    int domain,\n    int type,\n    int protocol,\n    oe_fd_t* sv[2])\n{\n    int ret = -1;\n    device_t* sock = _cast_device(dev);\n    sock_t* pair[2] = {NULL, NULL};\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Create the new socket devices. */\n    {\n        if (!(pair[0] = _new_sock()))\n            OE_RAISE_ERRNO(OE_ENOMEM);\n\n        if (!(pair[1] = _new_sock()))\n            OE_RAISE_ERRNO(OE_ENOMEM);\n    }\n\n    /* Call the host. */\n    {\n        int retval = -1;\n        oe_host_fd_t host_sv[2];\n\n        if (oe_syscall_socketpair_ocall(\n                &retval, domain, type, protocol, host_sv) != OE_OK)\n        {\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        if (retval == -1)\n        {\n            OE_RAISE_ERRNO_MSG(oe_errno, \"retval=%d\\n\", retval);\n        }\n\n        pair[0]->host_fd = host_sv[0];\n        pair[1]->host_fd = host_sv[1];\n    }\n\n    sv[0] = &pair[0]->base;\n    sv[1] = &pair[1]->base;\n\n    ret = 0;\n    pair[0] = NULL;\n    pair[1] = NULL;\n\ndone:\n\n    if (pair[0])\n        oe_free(pair[0]);\n\n    if (pair[1])\n        oe_free(pair[1]);\n\n    return ret;\n}\n\ntypedef struct\n{\n    struct oe_sockaddr addr;\n    uint8_t extra[1024];\n} sockaddr_t;\n\nstatic int _hostsock_connect(\n    oe_fd_t* sock_,\n    const struct oe_sockaddr* addr,\n    oe_socklen_t addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    sockaddr_t buf;\n\n    oe_errno = 0;\n\n    if (!sock || !addr || sizeof(buf) < addrlen)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_memcpy_s(&buf, sizeof(buf), addr, addrlen) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call host. */\n    if (oe_syscall_connect_ocall(&ret, sock->host_fd, &buf.addr, addrlen) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic oe_fd_t* _hostsock_accept(\n    oe_fd_t* sock_,\n    struct oe_sockaddr* addr,\n    oe_socklen_t* addrlen)\n{\n    oe_fd_t* ret = NULL;\n    sock_t* sock = _cast_sock(sock_);\n    sockaddr_t buf;\n    oe_socklen_t addrlen_in = 0;\n    sock_t* new_sock = NULL;\n\n    oe_errno = 0;\n\n    if (!sock || (addr && !addrlen) || (addrlen && !addr))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_memset_s(&buf, sizeof(buf), 0, sizeof(buf)) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Fixup the address. */\n    if (addr && addrlen)\n    {\n        if (sizeof(buf) < *addrlen)\n            OE_RAISE_ERRNO_MSG(OE_EINVAL, \"*addrlen=%u\", *addrlen);\n\n        if (oe_memcpy_s(&buf, sizeof(buf), addr, *addrlen) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        addrlen_in = *addrlen;\n    }\n\n    /* Create the new socket. */\n    if (!(new_sock = _new_sock()))\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    {\n        oe_host_fd_t retval = -1;\n\n        if (oe_syscall_accept_ocall(\n                &retval,\n                sock->host_fd,\n                addr ? &buf.addr : NULL,\n                addrlen_in,\n                addrlen) != OE_OK)\n        {\n            OE_RAISE_ERRNO(oe_errno);\n        }\n\n        if (retval == -1)\n            OE_RAISE_ERRNO_MSG(oe_errno, \"retval=%d\", retval);\n\n        new_sock->host_fd = retval;\n\n        // copy peer addr to out buffer\n        if (addrlen)\n        {\n            oe_assert(addr);\n            if (oe_memcpy_s(addr, addrlen_in, &buf.addr, *addrlen) != OE_OK)\n                OE_RAISE_ERRNO(OE_EINVAL);\n        }\n    }\n\n    ret = &new_sock->base;\n    new_sock = NULL;\n\ndone:\n\n    if (new_sock)\n        oe_free(new_sock);\n\n    return ret;\n}\n\nstatic int _hostsock_bind(\n    oe_fd_t* sock_,\n    const struct oe_sockaddr* addr,\n    oe_socklen_t addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    sockaddr_t buf;\n\n    oe_errno = 0;\n\n    if (!sock || !addr || sizeof(buf) < addrlen)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_memcpy_s(&buf, sizeof(buf), addr, addrlen) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_bind_ocall(&ret, sock->host_fd, &buf.addr, addrlen) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_listen(oe_fd_t* sock_, int backlog)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_listen_ocall(&ret, sock->host_fd, backlog) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostsock_recv(\n    oe_fd_t* sock_,\n    void* buf,\n    size_t count,\n    int flags)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/recv.html\n     * for more detail.\n     */\n    if (!sock || (count && !buf) || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (buf)\n    {\n        if (oe_memset_s(buf, count, 0, count) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (oe_syscall_recv_ocall(&ret, sock->host_fd, buf, count, flags) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The return value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostsock_recvfrom(\n    oe_fd_t* sock_,\n    void* buf,\n    size_t count,\n    int flags,\n    struct oe_sockaddr* src_addr,\n    oe_socklen_t* addrlen)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t addrlen_in = 0;\n    oe_socklen_t addrlen_out = 0;\n\n    oe_errno = 0;\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html\n     * for more detail.\n     */\n    if (!sock || (count && !buf) || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Update the addrlen_in to the value pointed by addrlen\n     * only if both src_addr and addrlen are not NULL.\n     */\n    if (src_addr && addrlen)\n        addrlen_in = *addrlen;\n\n    if (oe_syscall_recvfrom_ocall(\n            &ret,\n            sock->host_fd,\n            buf,\n            count,\n            flags,\n            src_addr,\n            addrlen_in,\n            &addrlen_out) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Update the value pointed by addrlen based on the host-set\n     * addrlen_out only if both src_addr and addrlen are not NULL.\n     */\n    if (src_addr && addrlen)\n    {\n        /*\n         * Error out the case if the addrlen_out is greater than the size\n         * of sockaddr_storage.\n         */\n        if (addrlen_out > sizeof(struct oe_sockaddr_storage))\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        /*\n         * Note that the returned value can still exceed the supplied one,\n         * which indicates a truncation.\n         */\n        *addrlen = addrlen_out;\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The return value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostsock_recvmsg(\n    oe_fd_t* sock_,\n    struct oe_msghdr* msg,\n    int flags)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_errno = 0;\n    void* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n    oe_socklen_t namelen_out = 0;\n    size_t controllen_out = 0;\n\n    /* Check the parameters. */\n    if (!sock || !msg || (msg->msg_iovlen && !msg->msg_iov))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(\n            msg->msg_iov, (int)msg->msg_iovlen, &buf, &buf_size, &data_size) !=\n        0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /*\n     * According to the POSIX specification, when the data_size is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html\n     * for more detail.\n     */\n    if (data_size > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    {\n        if (oe_syscall_recvmsg_ocall(\n                &ret,\n                sock->host_fd,\n                msg->msg_name,\n                msg->msg_namelen,\n                &namelen_out,\n                buf,\n                msg->msg_iovlen,\n                buf_size,\n                msg->msg_control,\n                msg->msg_controllen,\n                &controllen_out,\n                flags) != OE_OK)\n        {\n            OE_RAISE_ERRNO(OE_EINVAL);\n        }\n\n        if (ret == -1)\n            OE_RAISE_ERRNO(oe_errno);\n    }\n\n    if (!msg->msg_name)\n        msg->msg_namelen = 0;\n    else\n    {\n        /*\n         * Error out the case if the namelen_out is greater than the size\n         * of sockaddr_storage.\n         */\n        if (namelen_out > sizeof(struct oe_sockaddr_storage))\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        /*\n         * Note that the returned value can still exceed the supplied one,\n         * which indicates a truncation.\n         */\n        if (msg->msg_namelen >= namelen_out)\n            msg->msg_namelen = namelen_out;\n    }\n\n    if (!msg->msg_control)\n        msg->msg_controllen = 0;\n    else\n    {\n        /*\n         * Update the msg_controllen only if the supplied value is greater than\n         * or equal to the returned value. Otherwise, keep the msg_controllen\n         * unchanged, which indicates a truncation. In addition, explicitly\n         * setting the MSG_CTRUNC flag when the truncation occurs.\n         */\n        if (msg->msg_controllen >= controllen_out)\n            msg->msg_controllen = controllen_out;\n        else\n            msg->msg_flags |= OE_MSG_CTRUNC;\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The return value should not exceed data_size.\n     */\n    if (ret > (ssize_t)data_size)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (oe_iov_sync(msg->msg_iov, (int)msg->msg_iovlen, buf, buf_size) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic ssize_t _hostsock_send(\n    oe_fd_t* sock_,\n    const void* buf,\n    size_t count,\n    int flags)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/send.html for\n     * for more detail.\n     */\n    if (!sock || (count && !buf) || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_send_ocall(&ret, sock->host_fd, buf, count, flags) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The return value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostsock_sendto(\n    oe_fd_t* sock_,\n    const void* buf,\n    size_t count,\n    int flags,\n    const struct oe_sockaddr* dest_addr,\n    oe_socklen_t addrlen)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html\n     * for more detail.\n     */\n    if (!sock || (count && !buf) || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_sendto_ocall(\n            &ret,\n            sock->host_fd,\n            buf,\n            count,\n            flags,\n            (struct oe_sockaddr*)dest_addr,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The return value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}\n\nstatic ssize_t _hostsock_sendmsg(\n    oe_fd_t* sock_,\n    const struct oe_msghdr* msg,\n    int flags)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    void* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    oe_errno = 0;\n\n    /* Check the parameters. */\n    if (!sock || !msg || (msg->msg_iovlen && !msg->msg_iov))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(\n            msg->msg_iov, (int)msg->msg_iovlen, &buf, &buf_size, &data_size) !=\n        0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /*\n     * According to the POSIX specification, when the data_size is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html\n     * for more detail.\n     */\n    if (data_size > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_sendmsg_ocall(\n            &ret,\n            sock->host_fd,\n            msg->msg_name,\n            msg->msg_namelen,\n            buf,\n            msg->msg_iovlen,\n            buf_size,\n            msg->msg_control,\n            msg->msg_controllen,\n            flags) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The return value should not exceed data_size.\n     */\n    if (ret > (ssize_t)data_size)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic int _hostsock_close(oe_fd_t* sock_)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_close_socket_ocall(&ret, sock->host_fd) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (ret == 0)\n        oe_free(sock);\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_fcntl(oe_fd_t* sock_, int cmd, uint64_t arg)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    void* argout = NULL;\n    uint64_t argsize = 0;\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    switch (cmd)\n    {\n        case OE_F_GETFD:\n        case OE_F_SETFD:\n        case OE_F_GETFL:\n        case OE_F_SETFL:\n            break;\n\n        default:\n        case OE_F_DUPFD:\n        case OE_F_GETLK64:\n        case OE_F_OFD_GETLK:\n        case OE_F_SETLK64:\n        case OE_F_SETLKW64:\n        case OE_F_OFD_SETLK:\n        case OE_F_OFD_SETLKW:\n            OE_RAISE_ERRNO(OE_EINVAL);\n            break;\n\n        // for sockets\n        case OE_F_GETSIG: // Returns in return value\n        case OE_F_SETSIG: // arg is data value\n            break;\n\n        case OE_F_GETOWN: // Returns in return value\n        case OE_F_SETOWN: // arg is data value\n            break;\n\n        case OE_F_SETOWN_EX:\n        case OE_F_GETOWN_EX:\n            argsize = sizeof(struct oe_f_owner_ex);\n            argout = (void*)arg;\n            break;\n\n        case OE_F_GETOWNER_UIDS:\n            argsize = sizeof(oe_uid_t[2]);\n            argout = (void*)arg;\n            break;\n    }\n\n    if (oe_syscall_fcntl_ocall(\n            &ret, sock->host_fd, cmd, arg, argsize, argout) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_dup(oe_fd_t* sock_, oe_fd_t** new_sock_out)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    sock_t* new_sock = NULL;\n\n    oe_errno = 0;\n\n    if (new_sock_out)\n        *new_sock_out = NULL;\n\n    if (!sock || !new_sock_out)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(new_sock = _new_sock()))\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /* Call the host. */\n    {\n        oe_host_fd_t retval = -1;\n\n        if (oe_syscall_dup_ocall(&retval, sock->host_fd) != OE_OK)\n            OE_RAISE_ERRNO(OE_EINVAL);\n\n        if (retval == -1)\n            OE_RAISE_ERRNO(oe_errno);\n\n        new_sock->host_fd = retval;\n    }\n\n    *new_sock_out = &new_sock->base;\n    new_sock = NULL;\n    ret = 0;\n\ndone:\n\n    if (new_sock)\n        oe_free(new_sock);\n\n    return ret;\n}\n\nstatic int _hostsock_getsockopt(\n    oe_fd_t* sock_,\n    int level,\n    int optname,\n    void* optval,\n    oe_socklen_t* optlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t optlen_in = 0;\n    oe_socklen_t optlen_out = 0;\n\n    oe_errno = 0;\n\n    if (!sock || !optval || !optlen)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    optlen_in = *optlen;\n\n    if (oe_syscall_getsockopt_ocall(\n            &ret,\n            sock->host_fd,\n            level,\n            optname,\n            optval,\n            optlen_in,\n            &optlen_out) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * The POSIX specification for getsockopt states that if the size of optval\n     * is greater than the input optlen, then the value stored in the object\n     * pointed to by the optval argument shall be silently truncated. We do this\n     * in the enclave to ensure that the untrusted host has not returned an\n     * arbitrarily large optlen value.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockopt.html\n     * for more detail.\n     */\n    if (optlen_out > optlen_in)\n        optlen_out = optlen_in;\n\n    *optlen = optlen_out;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_setsockopt(\n    oe_fd_t* sock_,\n    int level,\n    int optname,\n    const void* optval,\n    oe_socklen_t optlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock || !optval || !optlen)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_setsockopt_ocall(\n            &ret, sock->host_fd, level, optname, optval, optlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_ioctl(oe_fd_t* sock_, unsigned long request, uint64_t arg)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_ioctl_ocall(&ret, sock->host_fd, request, arg, 0, NULL) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_getpeername(\n    oe_fd_t* sock_,\n    struct oe_sockaddr* addr,\n    oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t addrlen_in = 0;\n    oe_socklen_t addrlen_out = 0;\n\n    oe_errno = 0;\n\n    if (!sock || !addr || !addrlen)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    addrlen_in = *addrlen;\n    if (addrlen_in < 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_getpeername_ocall(\n            &ret,\n            sock->host_fd,\n            (struct oe_sockaddr*)addr,\n            addrlen_in,\n            &addrlen_out) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Error out the case if the addrlen_out is greater than the size\n     * of sockaddr_storage.\n     */\n    if (addrlen_out > sizeof(struct oe_sockaddr_storage))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Note that the returned value can still exceed the supplied one,\n     * which indicates a truncation. Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html\n     * for more detail.\n     */\n    *addrlen = addrlen_out;\n\ndone:\n\n    return ret;\n}\n\nstatic int _hostsock_getsockname(\n    oe_fd_t* sock_,\n    struct oe_sockaddr* addr,\n    oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t addrlen_in = 0;\n    oe_socklen_t addrlen_out = 0;\n\n    oe_errno = 0;\n\n    if (!sock || !addr || !addrlen)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    addrlen_in = *addrlen;\n    if (addrlen_in < 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_getsockname_ocall(\n            &ret, sock->host_fd, addr, addrlen_in, &addrlen_out) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Error out the case if the addrlen_out is greater than the size\n     * of sockaddr_storage.\n     */\n    if (addrlen_out > sizeof(struct oe_sockaddr_storage))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Note that the returned value can still exceed the supplied one, which\n     * indicates a truncation. Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html\n     * for more detail.\n     */\n    if (addrlen_in >= addrlen_out)\n        *addrlen = addrlen_out;\n\ndone:\n\n    return ret;\n}\n\nstatic ssize_t _hostsock_read(oe_fd_t* sock_, void* buf, size_t count)\n{\n    return _hostsock_recv(sock_, buf, count, 0);\n}\n\nstatic ssize_t _hostsock_write(oe_fd_t* sock_, const void* buf, size_t count)\n{\n    return _hostsock_send(sock_, buf, count, 0);\n}\n\nstatic ssize_t _hostsock_readv(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    if (!sock || (!iov && iovcnt) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size, &data_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /*\n     * According to the POSIX specification, when the data_size is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/readv.html\n     * for more detail.\n     */\n    if (data_size > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_recvv_ocall(&ret, sock->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed data_size.\n     */\n    if (ret > (ssize_t)(data_size))\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /* Synchronize data read with IO vector. */\n    if (ret > 0)\n    {\n        if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)\n            OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic ssize_t _hostsock_writev(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    if (!sock || !iov || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Flatten the IO vector into contiguous heap memory. */\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size, &data_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    /*\n     * According to the POSIX specification, when the data_size is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/writev.html\n     * for more detail.\n     */\n    if (data_size > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /* Call the host. */\n    if (oe_syscall_sendv_ocall(&ret, sock->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The return value should not exceed data_size.\n     */\n    if (ret > (ssize_t)data_size)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nstatic int _hostsock_shutdown(oe_fd_t* sock_, int how)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_shutdown_ocall(&ret, sock->host_fd, how) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    return ret;\n}\n\n/* The release method for the socket interface device. */\nstatic int _hostsock_device_release(oe_device_t* device_)\n{\n    int ret = -1;\n    device_t* device = _cast_device(device_);\n\n    oe_errno = 0;\n\n    if (!device)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    // This device is registered by oe_load_module_host_socket_interface() and\n    // is static, so there are no resources to reclaim here.\n\n    ret = 0;\n\ndone:\n\n    return ret;\n}\n\nstatic oe_host_fd_t _hostsock_get_host_fd(oe_fd_t* sock_)\n{\n    sock_t* sock = _cast_sock(sock_);\n    return sock->host_fd;\n}\n\nstatic oe_socket_ops_t _sock_ops = {\n    .fd.dup = _hostsock_dup,\n    .fd.ioctl = _hostsock_ioctl,\n    .fd.fcntl = _hostsock_fcntl,\n    .fd.read = _hostsock_read,\n    .fd.write = _hostsock_write,\n    .fd.readv = _hostsock_readv,\n    .fd.writev = _hostsock_writev,\n    .fd.get_host_fd = _hostsock_get_host_fd,\n    .fd.close = _hostsock_close,\n    .accept = _hostsock_accept,\n    .bind = _hostsock_bind,\n    .listen = _hostsock_listen,\n    .shutdown = _hostsock_shutdown,\n    .getsockopt = _hostsock_getsockopt,\n    .setsockopt = _hostsock_setsockopt,\n    .getpeername = _hostsock_getpeername,\n    .getsockname = _hostsock_getsockname,\n    .recv = _hostsock_recv,\n    .send = _hostsock_send,\n    .recvfrom = _hostsock_recvfrom,\n    .sendto = _hostsock_sendto,\n    .recvmsg = _hostsock_recvmsg,\n    .sendmsg = _hostsock_sendmsg,\n    .connect = _hostsock_connect,\n};\n\nstatic oe_socket_ops_t _get_socket_ops(void)\n{\n    return _sock_ops;\n};\n\n// clang-format off\nstatic device_t _device = {\n    .base.type = OE_DEVICE_TYPE_SOCKET_INTERFACE,\n    .base.name = OE_DEVICE_NAME_HOST_SOCKET_INTERFACE,\n    .base.ops.socket =\n    {\n        .base.release = _hostsock_device_release,\n        .socket = _hostsock_device_socket,\n        .socketpair = _hostsock_device_socketpair,\n    },\n    .magic = DEVICE_MAGIC,\n};\n// clang-format on\n\noe_result_t oe_load_module_host_socket_interface(void)\n{\n    oe_result_t result = OE_UNEXPECTED;\n    static oe_spinlock_t _lock = OE_SPINLOCK_INITIALIZER;\n    static bool _loaded = false;\n\n    oe_spin_lock(&_lock);\n\n    if (!_loaded)\n    {\n        const uint64_t devid = OE_DEVID_HOST_SOCKET_INTERFACE;\n\n        if (oe_device_table_set(devid, &_device.base) != 0)\n        {\n            /* Do not propagate errno to caller. */\n            oe_errno = 0;\n            OE_RAISE(OE_FAILURE);\n        }\n\n        _loaded = true;\n    }\n\n    result = OE_OK;\n\ndone:\n    oe_spin_unlock(&_lock);\n\n    return result;\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#include <openenclave/corelibc/limits.h>\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/internal/print.h>\n#include <openenclave/internal/safecrt.h>\n#include <openenclave/internal/safemath.h>\n#include <openenclave/internal/syscall/iov.h>\n#include <openenclave/internal/syscall/sys/uio.h>\n#include <openenclave/internal/syscall/types.h>\n#include <openenclave/internal/utils.h>\n\nint oe_iov_pack(\n    const struct oe_iovec* iov,\n    int iovcnt,\n    void** buf_out,\n    size_t* buf_size_out,\n    size_t* data_size_out)\n{\n    int ret = -1;\n    struct oe_iovec* buf = NULL;\n    size_t buf_size = 0;\n    size_t data_size = 0;\n\n    if (buf_out)\n        *buf_out = NULL;\n\n    if (buf_size_out)\n        *buf_size_out = 0;\n\n    if (data_size_out)\n        *data_size_out = 0;\n\n    /* Reject invalid parameters. */\n    if (iovcnt < 0 || (iovcnt > 0 && !iov) || !buf_out || !buf_size_out ||\n        !data_size_out)\n        goto done;\n\n    /* Handle zero-sized iovcnt up front. */\n    if (iovcnt == 0)\n    {\n        if (iov)\n        {\n            if (!(buf = oe_calloc(1, sizeof(uint64_t))))\n                goto done;\n\n            buf_size = sizeof(uint64_t);\n        }\n\n        *buf_out = buf;\n        *buf_size_out = buf_size;\n        *data_size_out = data_size;\n        buf = NULL;\n        ret = 0;\n        goto done;\n    }\n\n    /* Calculate the total number of data bytes. */\n    for (int i = 0; i < iovcnt; i++)\n        data_size += iov[i].iov_len;\n\n    /* Calculate the total size of the resulting buffer. */\n    buf_size = (sizeof(struct oe_iovec) * (size_t)iovcnt) + data_size;\n\n    /* Allocate the output buffer. */\n    if (!(buf = oe_calloc(1, buf_size)))\n        goto done;\n\n    /* Initialize the array elements. */\n    {\n        uint8_t* p = (uint8_t*)&buf[iovcnt];\n        size_t n = data_size;\n        int i;\n\n        for (i = 0; i < iovcnt; i++)\n        {\n            const size_t iov_len = iov[i].iov_len;\n            const void* iov_base = iov[i].iov_base;\n\n            if (iov_len)\n            {\n                buf[i].iov_len = iov_len;\n                buf[i].iov_base = (void*)(p - (uint8_t*)buf);\n\n                if (!iov_base)\n                    goto done;\n\n                if (oe_memcpy_s(p, n, iov_base, iov_len) != OE_OK)\n                    goto done;\n\n                p += iov_len;\n                n -= iov_len;\n            }\n        }\n\n        /* Fail if the data was not exhausted. */\n        if (n != 0)\n            goto done;\n    }\n\n    *buf_out = buf;\n    *buf_size_out = buf_size;\n    *data_size_out = data_size;\n    buf = NULL;\n    ret = 0;\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}\n\nint oe_iov_sync(\n    const struct oe_iovec* iov,\n    int iovcnt,\n    const void* buf_,\n    size_t buf_size)\n{\n    struct oe_iovec* buf = (struct oe_iovec*)buf_;\n    int ret = -1;\n    int i;\n    size_t n;\n\n    /* Reject invalid parameters. */\n    if (iovcnt < 0 || (iovcnt > 0 && !iov))\n        goto done;\n\n    /* Synchronize the data. */\n    for (i = 0, n = buf_size; i < iovcnt; i++)\n    {\n        if (buf[i].iov_len != iov[i].iov_len)\n            goto done;\n\n        if (buf[i].iov_len)\n        {\n            if (buf[i].iov_base && !iov[i].iov_base)\n                goto done;\n\n            if (!buf[i].iov_base && iov[i].iov_base)\n                goto done;\n\n            if (!buf[i].iov_base)\n                continue;\n\n            /* Fail if buffer data is exhausted. */\n            if (n < buf[i].iov_len)\n                goto done;\n\n            /* Sync the base data for this element. */\n            {\n                /* Note: buf[i].iov_base is an offset here (not a pointer). */\n                uint8_t* src = (uint8_t*)buf[i].iov_base + (uint64_t)buf;\n                size_t src_size = buf[i].iov_len;\n                uint8_t* dest = (uint8_t*)iov[i].iov_base;\n                size_t dest_size = iov[i].iov_len;\n\n                if (src_size != dest_size)\n                    goto done;\n\n                if (src < (uint8_t*)buf || src + src_size < src ||\n                    src + src_size > (uint8_t*)buf + buf_size)\n                    goto done;\n\n                if (oe_memcpy_s(dest, dest_size, src, src_size) != OE_OK)\n                    goto done;\n            }\n        }\n\n        n -= buf[i].iov_len;\n    }\n\n    ret = 0;\n\ndone:\n\n    return ret;\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#include <openenclave/enclave.h>\n\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/internal/print.h>\n#include <openenclave/internal/syscall/device.h>\n#include <openenclave/internal/syscall/fdtable.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/sys/socket.h>\n#include <openenclave/internal/thread.h>\n#include <openenclave/internal/trace.h>\n\nstatic uint64_t _default_socket_devid = OE_DEVID_NONE;\nstatic oe_spinlock_t _default_socket_devid_lock = OE_SPINLOCK_INITIALIZER;\n\nvoid oe_set_default_socket_devid(uint64_t devid)\n{\n    oe_spin_lock(&_default_socket_devid_lock);\n    _default_socket_devid = devid;\n    oe_spin_unlock(&_default_socket_devid_lock);\n}\n\nuint64_t oe_get_default_socket_devid()\n{\n    oe_spin_lock(&_default_socket_devid_lock);\n    uint64_t ret = _default_socket_devid;\n    oe_spin_unlock(&_default_socket_devid_lock);\n    return ret;\n}\n\nint oe_socket_d(uint64_t devid, int domain, int type, int protocol)\n{\n    int ret = -1;\n    int sd;\n    oe_fd_t* sock = NULL;\n    oe_device_t* device;\n\n    if (devid == OE_DEVID_NONE)\n    {\n        /* Only one device today. */\n        devid = OE_DEVID_HOST_SOCKET_INTERFACE;\n    }\n\n    if (!(device = oe_device_table_get(devid, OE_DEVICE_TYPE_SOCKET_INTERFACE)))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (!(sock = device->ops.socket.socket(device, domain, type, protocol)))\n    {\n        OE_RAISE_ERRNO_MSG(\n            oe_errno,\n            \"devid=%ld domain=%d type=%d protocol=%d\",\n            devid,\n            domain,\n            type,\n            protocol);\n        goto done;\n    }\n\n    if ((sd = oe_fdtable_assign(sock)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sd;\n    sock = NULL;\n\ndone:\n\n    if (sock)\n        sock->ops.fd.close(sock);\n\n    return ret;\n}\n\nint oe_socketpair(int domain, int type, int protocol, int retfd[2])\n{\n    int ret = -1;\n    ssize_t retval;\n    oe_fd_t* socks[2] = {0};\n    oe_device_t* device;\n    uint64_t devid = OE_DEVID_HOST_SOCKET_INTERFACE;\n\n    /* Resolve the device id. */\n    if (!(device = oe_device_table_get(devid, OE_DEVICE_TYPE_SOCKET_INTERFACE)))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if ((retval = device->ops.socket.socketpair(\n             device, domain, type, protocol, socks)) < 0)\n    {\n        OE_RAISE_ERRNO_MSG(\n            OE_EINVAL,\n            \"retval=%zd devid=%lu, domain=%d type=%d protocol=%d\",\n            retval,\n            devid,\n            domain,\n            type,\n            protocol);\n    }\n\n    if ((retfd[0] = oe_fdtable_assign(socks[0])) < 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if ((retfd[1] = oe_fdtable_assign(socks[1])) < 0)\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = (int)retval;\n    socks[0] = NULL;\n    socks[1] = NULL;\n\ndone:\n\n    if (socks[0])\n        socks[0]->ops.fd.close(socks[0]);\n\n    if (socks[1])\n        socks[1]->ops.fd.close(socks[1]);\n\n    return ret;\n}\n\nint oe_socket(int domain, int type, int protocol)\n{\n    uint64_t devid = oe_get_default_socket_devid();\n    return oe_socket_d(devid, domain, type, protocol);\n}\n\nint oe_connect(int sockfd, const struct oe_sockaddr* addr, oe_socklen_t addrlen)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.connect(sock, addr, addrlen);\n\ndone:\n    return ret;\n}\n\nint oe_accept(int sockfd, struct oe_sockaddr* addr, oe_socklen_t* addrlen)\n{\n    oe_fd_t* sock;\n    oe_fd_t* new_sock = NULL;\n    int ret = -1;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    if ((new_sock = sock->ops.socket.accept(sock, addr, addrlen)) == NULL)\n        OE_RAISE_ERRNO(oe_errno);\n\n    if ((ret = oe_fdtable_assign(new_sock)) == -1)\n        OE_RAISE_ERRNO(oe_errno);\n\n    new_sock = NULL;\n\ndone:\n\n    if (new_sock)\n        new_sock->ops.fd.close(new_sock);\n\n    return ret;\n}\n\nint oe_listen(int sockfd, int backlog)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.listen(sock, backlog);\n\ndone:\n    return ret;\n}\n\nssize_t oe_recv(int sockfd, void* buf, size_t len, int flags)\n{\n    ssize_t ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.recv(sock, buf, len, flags);\n\ndone:\n    return ret;\n}\n\nssize_t oe_recvfrom(\n    int sockfd,\n    void* buf,\n    size_t len,\n    int flags,\n    struct oe_sockaddr* src_addr,\n    oe_socklen_t* addrlen)\n{\n    ssize_t ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.recvfrom(sock, buf, len, flags, src_addr, addrlen);\n\ndone:\n    return ret;\n}\n\nssize_t oe_send(int sockfd, const void* buf, size_t len, int flags)\n{\n    ssize_t ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.send(sock, buf, len, flags);\n\ndone:\n    return ret;\n}\n\nssize_t oe_sendto(\n    int sockfd,\n    const void* buf,\n    size_t len,\n    int flags,\n    const struct oe_sockaddr* dest_addr,\n    oe_socklen_t addrlen)\n{\n    ssize_t ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.sendto(sock, buf, len, flags, dest_addr, addrlen);\n\ndone:\n    return ret;\n}\n\nssize_t oe_recvmsg(int sockfd, struct oe_msghdr* buf, int flags)\n{\n    ssize_t ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.recvmsg(sock, buf, flags);\n\ndone:\n    return ret;\n}\n\nssize_t oe_sendmsg(int sockfd, const struct oe_msghdr* buf, int flags)\n{\n    ssize_t ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.sendmsg(sock, buf, flags);\n\ndone:\n    return ret;\n}\n\nint oe_shutdown(int sockfd, int how)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.shutdown(sock, how);\n\ndone:\n    return ret;\n}\n\nint oe_getsockname(int sockfd, struct oe_sockaddr* addr, oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.getsockname(sock, addr, addrlen);\n\ndone:\n    return ret;\n}\n\nint oe_getpeername(int sockfd, struct oe_sockaddr* addr, oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.getpeername(sock, addr, addrlen);\n\ndone:\n    return ret;\n}\n\nint oe_getsockopt(\n    int sockfd,\n    int level,\n    int optname,\n    void* optval,\n    oe_socklen_t* optlen)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.getsockopt(sock, level, optname, optval, optlen);\n\ndone:\n    return ret;\n}\n\nint oe_setsockopt(\n    int sockfd,\n    int level,\n    int optname,\n    const void* optval,\n    oe_socklen_t optlen)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.setsockopt(sock, level, optname, optval, optlen);\n\ndone:\n    return ret;\n}\n\nint oe_bind(int sockfd, const struct oe_sockaddr* name, oe_socklen_t namelen)\n{\n    int ret = -1;\n    oe_fd_t* sock;\n\n    if (!(sock = oe_fdtable_get(sockfd, OE_FD_TYPE_SOCKET)))\n        OE_RAISE_ERRNO(oe_errno);\n\n    ret = sock->ops.socket.bind(sock, name, namelen);\n\ndone:\n    return ret;\n}\n", "// Copyright (c) Open Enclave SDK contributors.\n// Licensed under the MIT License.\n\n#include <openenclave/corelibc/errno.h>\n#include <openenclave/corelibc/setjmp.h>\n#include <openenclave/corelibc/stdarg.h>\n#include <openenclave/corelibc/stdio.h>\n#include <openenclave/corelibc/stdlib.h>\n#include <openenclave/corelibc/string.h>\n#include <openenclave/internal/print.h>\n#include <openenclave/internal/safemath.h>\n#include <openenclave/internal/syscall/device.h>\n#include <openenclave/internal/syscall/dirent.h>\n#include <openenclave/internal/syscall/fcntl.h>\n#include <openenclave/internal/syscall/raise.h>\n#include <openenclave/internal/syscall/sys/ioctl.h>\n#include <openenclave/internal/syscall/sys/mount.h>\n#include <openenclave/internal/syscall/sys/poll.h>\n#include <openenclave/internal/syscall/sys/select.h>\n#include <openenclave/internal/syscall/sys/socket.h>\n#include <openenclave/internal/syscall/sys/stat.h>\n#include <openenclave/internal/syscall/sys/syscall.h>\n#include <openenclave/internal/syscall/sys/uio.h>\n#include <openenclave/internal/syscall/sys/utsname.h>\n#include <openenclave/internal/syscall/unistd.h>\n#include <openenclave/internal/trace.h>\n\ntypedef int (*ioctl_proc)(\n    int fd,\n    unsigned long request,\n    long arg1,\n    long arg2,\n    long arg3,\n    long arg4);\n\nstatic long _syscall(\n    long num,\n    long arg1,\n    long arg2,\n    long arg3,\n    long arg4,\n    long arg5,\n    long arg6)\n{\n    long ret = -1;\n    oe_errno = 0;\n\n    /* Handle the software system call. */\n    switch (num)\n    {\n#if defined(OE_SYS_creat)\n        case OE_SYS_creat:\n        {\n            const char* pathname = (const char*)arg1;\n            oe_mode_t mode = (oe_mode_t)arg2;\n            int flags = (OE_O_CREAT | OE_O_WRONLY | OE_O_TRUNC);\n\n            ret = oe_open(pathname, flags, mode);\n\n            if (oe_errno == OE_ENOENT)\n            {\n                /* If the file was not found, give the caller (libc) a chance\n                 * to handle this syscall.\n                 */\n                oe_errno = OE_ENOSYS;\n                goto done;\n            }\n\n            goto done;\n        }\n#endif\n#if defined(OE_SYS_open)\n        case OE_SYS_open:\n        {\n            const char* pathname = (const char*)arg1;\n            int flags = (int)arg2;\n            uint32_t mode = (uint32_t)arg3;\n\n            ret = oe_open(pathname, flags, mode);\n\n            if (ret < 0 && oe_errno == OE_ENOENT)\n                goto done;\n\n            goto done;\n        }\n#endif\n        case OE_SYS_openat:\n        {\n            int dirfd = (int)arg1;\n            const char* pathname = (const char*)arg2;\n            int flags = (int)arg3;\n            uint32_t mode = (uint32_t)arg4;\n\n            if (dirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            ret = oe_open(pathname, flags, mode);\n\n            if (ret < 0 && oe_errno == OE_ENOENT)\n                goto done;\n\n            goto done;\n        }\n        case OE_SYS_lseek:\n        {\n            int fd = (int)arg1;\n            ssize_t off = (ssize_t)arg2;\n            int whence = (int)arg3;\n            ret = oe_lseek(fd, off, whence);\n            goto done;\n        }\n        case OE_SYS_pread64:\n        {\n            const int fd = (int)arg1;\n            void* const buf = (void*)arg2;\n            const size_t count = (size_t)arg3;\n            const oe_off_t offset = (oe_off_t)arg4;\n\n            ret = oe_pread(fd, buf, count, offset);\n            goto done;\n        }\n        case OE_SYS_pwrite64:\n        {\n            const int fd = (int)arg1;\n            const void* const buf = (void*)arg2;\n            const size_t count = (size_t)arg3;\n            const oe_off_t offset = (oe_off_t)arg4;\n\n            ret = oe_pwrite(fd, buf, count, offset);\n            goto done;\n        }\n        case OE_SYS_readv:\n        {\n            int fd = (int)arg1;\n            const struct oe_iovec* iov = (const struct oe_iovec*)arg2;\n            int iovcnt = (int)arg3;\n\n            ret = oe_readv(fd, iov, iovcnt);\n            goto done;\n        }\n        case OE_SYS_writev:\n        {\n            int fd = (int)arg1;\n            const struct oe_iovec* iov = (const struct oe_iovec*)arg2;\n            int iovcnt = (int)arg3;\n\n            ret = oe_writev(fd, iov, iovcnt);\n            goto done;\n        }\n        case OE_SYS_read:\n        {\n            int fd = (int)arg1;\n            void* buf = (void*)arg2;\n            size_t count = (size_t)arg3;\n\n            ret = oe_read(fd, buf, count);\n            goto done;\n        }\n        case OE_SYS_write:\n        {\n            int fd = (int)arg1;\n            const void* buf = (void*)arg2;\n            size_t count = (size_t)arg3;\n\n            ret = oe_write(fd, buf, count);\n            goto done;\n        }\n        case OE_SYS_close:\n        {\n            int fd = (int)arg1;\n\n            ret = oe_close(fd);\n            goto done;\n        }\n        case OE_SYS_dup:\n        {\n            int fd = (int)arg1;\n\n            ret = oe_dup(fd);\n            goto done;\n        }\n        case OE_SYS_flock:\n        {\n            int fd = (int)arg1;\n            int operation = (int)arg2;\n\n            ret = oe_flock(fd, operation);\n            goto done;\n        }\n        case OE_SYS_fsync:\n        {\n            const int fd = (int)arg1;\n\n            ret = oe_fsync(fd);\n            goto done;\n        }\n        case OE_SYS_fdatasync:\n        {\n            const int fd = (int)arg1;\n\n            ret = oe_fdatasync(fd);\n            goto done;\n        }\n#if defined(OE_SYS_dup2)\n        case OE_SYS_dup2:\n        {\n            int oldfd = (int)arg1;\n            int newfd = (int)arg2;\n\n            ret = oe_dup2(oldfd, newfd);\n            goto done;\n        }\n#endif\n        case OE_SYS_dup3:\n        {\n            int oldfd = (int)arg1;\n            int newfd = (int)arg2;\n            int flags = (int)arg3;\n\n            if (flags != 0)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            ret = oe_dup2(oldfd, newfd);\n            goto done;\n        }\n#if defined(OE_SYS_stat)\n        case OE_SYS_stat:\n        {\n            const char* pathname = (const char*)arg1;\n            struct oe_stat_t* buf = (struct oe_stat_t*)arg2;\n            ret = oe_stat(pathname, buf);\n            goto done;\n        }\n#endif\n        case OE_SYS_newfstatat:\n        {\n            int dirfd = (int)arg1;\n            const char* pathname = (const char*)arg2;\n            struct oe_stat_t* buf = (struct oe_stat_t*)arg3;\n            int flags = (int)arg4;\n\n            if (dirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (flags != 0)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            ret = oe_stat(pathname, buf);\n            goto done;\n        }\n        case OE_SYS_fstat:\n        {\n            const int fd = (int)arg1;\n            struct oe_stat_t* const buf = (struct oe_stat_t*)arg2;\n            ret = oe_fstat(fd, buf);\n            goto done;\n        }\n#if defined(OE_SYS_link)\n        case OE_SYS_link:\n        {\n            const char* oldpath = (const char*)arg1;\n            const char* newpath = (const char*)arg2;\n            ret = oe_link(oldpath, newpath);\n            goto done;\n        }\n#endif\n        case OE_SYS_linkat:\n        {\n            int olddirfd = (int)arg1;\n            const char* oldpath = (const char*)arg2;\n            int newdirfd = (int)arg3;\n            const char* newpath = (const char*)arg4;\n            int flags = (int)arg5;\n\n            if (olddirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (newdirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (flags != 0)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            ret = oe_link(oldpath, newpath);\n            goto done;\n        }\n#if defined(OE_SYS_unlink)\n        case OE_SYS_unlink:\n        {\n            const char* pathname = (const char*)arg1;\n\n            ret = oe_unlink(pathname);\n            goto done;\n        }\n#endif\n        case OE_SYS_unlinkat:\n        {\n            int dirfd = (int)arg1;\n            const char* pathname = (const char*)arg2;\n            int flags = (int)arg3;\n\n            if (dirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (flags != OE_AT_REMOVEDIR && flags != 0)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            if (flags == OE_AT_REMOVEDIR)\n                ret = oe_rmdir(pathname);\n            else\n                ret = oe_unlink(pathname);\n\n            goto done;\n        }\n#if defined(OE_SYS_rename)\n        case OE_SYS_rename:\n        {\n            const char* oldpath = (const char*)arg1;\n            const char* newpath = (const char*)arg2;\n\n            ret = oe_rename(oldpath, newpath);\n            goto done;\n        }\n#endif\n        case OE_SYS_renameat:\n        {\n            int olddirfd = (int)arg1;\n            const char* oldpath = (const char*)arg2;\n            int newdirfd = (int)arg3;\n            const char* newpath = (const char*)arg4;\n            int flags = (int)arg5;\n\n            if (olddirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (newdirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (flags != 0)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            ret = oe_rename(oldpath, newpath);\n            goto done;\n        }\n        case OE_SYS_truncate:\n        {\n            const char* path = (const char*)arg1;\n            ssize_t length = (ssize_t)arg2;\n\n            ret = oe_truncate(path, length);\n            goto done;\n        }\n#if defined(OE_SYS_mkdir)\n        case OE_SYS_mkdir:\n        {\n            const char* pathname = (const char*)arg1;\n            uint32_t mode = (uint32_t)arg2;\n\n            ret = oe_mkdir(pathname, mode);\n            goto done;\n        }\n#endif\n        case OE_SYS_mkdirat:\n        {\n            int dirfd = (int)arg1;\n            const char* pathname = (const char*)arg2;\n            uint32_t mode = (uint32_t)arg3;\n\n            if (dirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            ret = oe_mkdir(pathname, mode);\n            goto done;\n        }\n#if defined(OE_SYS_rmdir)\n        case OE_SYS_rmdir:\n        {\n            const char* pathname = (const char*)arg1;\n            ret = oe_rmdir(pathname);\n            goto done;\n        }\n#endif\n#if defined(OE_SYS_access)\n        case OE_SYS_access:\n        {\n            const char* pathname = (const char*)arg1;\n            int mode = (int)arg2;\n\n            ret = oe_access(pathname, mode);\n            goto done;\n        }\n#endif\n        case OE_SYS_faccessat:\n        {\n            int dirfd = (int)arg1;\n            const char* pathname = (const char*)arg2;\n            int mode = (int)arg3;\n            int flags = (int)arg4;\n\n            if (dirfd != OE_AT_FDCWD)\n            {\n                oe_errno = OE_EBADF;\n                goto done;\n            }\n\n            if (flags != 0)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            ret = oe_access(pathname, mode);\n            goto done;\n        }\n        case OE_SYS_getdents64:\n        {\n            unsigned int fd = (unsigned int)arg1;\n            struct oe_dirent* ent = (struct oe_dirent*)arg2;\n            unsigned int count = (unsigned int)arg3;\n            ret = oe_getdents64(fd, ent, count);\n            goto done;\n        }\n        case OE_SYS_ioctl:\n        {\n            int fd = (int)arg1;\n            unsigned long request = (unsigned long)arg2;\n            long p1 = arg3;\n            long p2 = arg4;\n            long p3 = arg5;\n            long p4 = arg6;\n\n            ret = oe_ioctl(fd, request, p1, p2, p3, p4);\n            goto done;\n        }\n        case OE_SYS_fcntl:\n        {\n            int fd = (int)arg1;\n            int cmd = (int)arg2;\n            uint64_t arg = (uint64_t)arg3;\n            ret = oe_fcntl(fd, cmd, arg);\n            goto done;\n        }\n        case OE_SYS_mount:\n        {\n            const char* source = (const char*)arg1;\n            const char* target = (const char*)arg2;\n            const char* fstype = (const char*)arg3;\n            unsigned long flags = (unsigned long)arg4;\n            void* data = (void*)arg5;\n\n            ret = oe_mount(source, target, fstype, flags, data);\n            goto done;\n        }\n        case OE_SYS_umount2:\n        {\n            const char* target = (const char*)arg1;\n            int flags = (int)arg2;\n\n            (void)flags;\n\n            ret = oe_umount(target);\n            goto done;\n        }\n        case OE_SYS_getcwd:\n        {\n            char* buf = (char*)arg1;\n            size_t size = (size_t)arg2;\n\n            if (!oe_getcwd(buf, size))\n            {\n                ret = -1;\n            }\n            else\n            {\n                ret = (long)size;\n            }\n\n            goto done;\n        }\n        case OE_SYS_chdir:\n        {\n            char* path = (char*)arg1;\n\n            ret = oe_chdir(path);\n            goto done;\n        }\n        case OE_SYS_socket:\n        {\n            int domain = (int)arg1;\n            int type = (int)arg2;\n            int protocol = (int)arg3;\n            ret = oe_socket(domain, type, protocol);\n            goto done;\n        }\n        case OE_SYS_connect:\n        {\n            int sd = (int)arg1;\n            const struct oe_sockaddr* addr = (const struct oe_sockaddr*)arg2;\n            oe_socklen_t addrlen = (oe_socklen_t)arg3;\n            ret = oe_connect(sd, addr, addrlen);\n            goto done;\n        }\n        case OE_SYS_setsockopt:\n        {\n            int sockfd = (int)arg1;\n            int level = (int)arg2;\n            int optname = (int)arg3;\n            void* optval = (void*)arg4;\n            oe_socklen_t optlen = (oe_socklen_t)arg5;\n            ret = oe_setsockopt(sockfd, level, optname, optval, optlen);\n            goto done;\n        }\n        case OE_SYS_getsockopt:\n        {\n            int sockfd = (int)arg1;\n            int level = (int)arg2;\n            int optname = (int)arg3;\n            void* optval = (void*)arg4;\n            oe_socklen_t* optlen = (oe_socklen_t*)arg5;\n            ret = oe_getsockopt(sockfd, level, optname, optval, optlen);\n            goto done;\n        }\n        case OE_SYS_getpeername:\n        {\n            int sockfd = (int)arg1;\n            struct sockaddr* addr = (struct sockaddr*)arg2;\n            oe_socklen_t* addrlen = (oe_socklen_t*)arg3;\n            ret = oe_getpeername(sockfd, (struct oe_sockaddr*)addr, addrlen);\n            goto done;\n        }\n        case OE_SYS_getsockname:\n        {\n            int sockfd = (int)arg1;\n            struct sockaddr* addr = (struct sockaddr*)arg2;\n            oe_socklen_t* addrlen = (oe_socklen_t*)arg3;\n            ret = oe_getsockname(sockfd, (struct oe_sockaddr*)addr, addrlen);\n            goto done;\n        }\n        case OE_SYS_bind:\n        {\n            int sockfd = (int)arg1;\n            struct oe_sockaddr* addr = (struct oe_sockaddr*)arg2;\n            oe_socklen_t addrlen = (oe_socklen_t)arg3;\n            ret = oe_bind(sockfd, addr, addrlen);\n            goto done;\n        }\n        case OE_SYS_listen:\n        {\n            int sockfd = (int)arg1;\n            int backlog = (int)arg2;\n            ret = oe_listen(sockfd, backlog);\n            goto done;\n        }\n        case OE_SYS_accept:\n        {\n            int sockfd = (int)arg1;\n            struct oe_sockaddr* addr = (struct oe_sockaddr*)arg2;\n            oe_socklen_t* addrlen = (oe_socklen_t*)arg3;\n            ret = oe_accept(sockfd, addr, addrlen);\n            goto done;\n        }\n        case OE_SYS_sendto:\n        {\n            int sockfd = (int)arg1;\n            const void* buf = (void*)arg2;\n            size_t len = (size_t)arg3;\n            int flags = (int)arg4;\n            const struct oe_sockaddr* dest_add =\n                (const struct oe_sockaddr*)arg5;\n            oe_socklen_t addrlen = (oe_socklen_t)arg6;\n\n            ret = oe_sendto(sockfd, buf, len, flags, dest_add, addrlen);\n            goto done;\n        }\n        case OE_SYS_recvfrom:\n        {\n            int sockfd = (int)arg1;\n            void* buf = (void*)arg2;\n            size_t len = (size_t)arg3;\n            int flags = (int)arg4;\n            struct oe_sockaddr* dest_add = (struct oe_sockaddr*)arg5;\n            oe_socklen_t* addrlen = (oe_socklen_t*)arg6;\n\n            ret = oe_recvfrom(sockfd, buf, len, flags, dest_add, addrlen);\n            goto done;\n        }\n        case OE_SYS_sendmsg:\n        {\n            int sockfd = (int)arg1;\n            struct msghdr* buf = (struct msghdr*)arg2;\n            int flags = (int)arg3;\n\n            ret = oe_sendmsg(sockfd, (struct oe_msghdr*)buf, flags);\n            goto done;\n        }\n        case OE_SYS_recvmsg:\n        {\n            int sockfd = (int)arg1;\n            struct msghdr* buf = (struct msghdr*)arg2;\n            int flags = (int)arg3;\n\n            ret = oe_recvmsg(sockfd, (struct oe_msghdr*)buf, flags);\n            goto done;\n        }\n        case OE_SYS_socketpair:\n        {\n            int domain = (int)arg1;\n            int type = (int)arg2;\n            int protocol = (int)arg3;\n            int* sv = (int*)arg4;\n\n            ret = oe_socketpair(domain, type, protocol, sv);\n            goto done;\n        }\n        case OE_SYS_shutdown:\n        {\n            int sockfd = (int)arg1;\n            int how = (int)arg2;\n            ret = oe_shutdown(sockfd, how);\n            goto done;\n        }\n        case OE_SYS_uname:\n        {\n            struct oe_utsname* buf = (struct oe_utsname*)arg1;\n            ret = oe_uname(buf);\n            goto done;\n        }\n#if defined(OE_SYS_select)\n        case OE_SYS_select:\n        {\n            int nfds = (int)arg1;\n            oe_fd_set* readfds = (oe_fd_set*)arg2;\n            oe_fd_set* writefds = (oe_fd_set*)arg3;\n            oe_fd_set* efds = (oe_fd_set*)arg4;\n            struct oe_timeval* timeout = (struct oe_timeval*)arg5;\n            ret = oe_select(nfds, readfds, writefds, efds, timeout);\n            goto done;\n        }\n#endif\n        case OE_SYS_pselect6:\n        {\n            int nfds = (int)arg1;\n            oe_fd_set* readfds = (oe_fd_set*)arg2;\n            oe_fd_set* writefds = (oe_fd_set*)arg3;\n            oe_fd_set* exceptfds = (oe_fd_set*)arg4;\n            struct oe_timespec* ts = (struct oe_timespec*)arg5;\n            struct oe_timeval buf;\n            struct oe_timeval* tv = NULL;\n\n            if (ts)\n            {\n                tv = &buf;\n                tv->tv_sec = ts->tv_sec;\n                tv->tv_usec = ts->tv_nsec / 1000;\n            }\n\n            ret = oe_select(nfds, readfds, writefds, exceptfds, tv);\n            goto done;\n        }\n#if defined(OE_SYS_poll)\n        case OE_SYS_poll:\n        {\n            struct oe_pollfd* fds = (struct oe_pollfd*)arg1;\n            oe_nfds_t nfds = (oe_nfds_t)arg2;\n            int millis = (int)arg3;\n            ret = oe_poll(fds, nfds, millis);\n            goto done;\n        }\n#endif\n        case OE_SYS_ppoll:\n        {\n            struct oe_pollfd* fds = (struct oe_pollfd*)arg1;\n            oe_nfds_t nfds = (oe_nfds_t)arg2;\n            struct oe_timespec* ts = (struct oe_timespec*)arg3;\n            void* sigmask = (void*)arg4;\n            int timeout = -1;\n\n            if (sigmask != NULL)\n            {\n                oe_errno = OE_EINVAL;\n                goto done;\n            }\n\n            if (ts)\n            {\n                int64_t mul;\n                int64_t div;\n                int64_t sum;\n\n                if (oe_safe_mul_s64(ts->tv_sec, 1000, &mul) != OE_OK)\n                {\n                    oe_errno = OE_EINVAL;\n                    goto done;\n                }\n\n                div = ts->tv_nsec / 1000000;\n\n                if (oe_safe_add_s64(mul, div, &sum) != OE_OK)\n                {\n                    oe_errno = OE_EINVAL;\n                    goto done;\n                }\n\n                if (sum < OE_INT_MIN || sum > OE_INT_MAX)\n                {\n                    oe_errno = OE_EINVAL;\n                    goto done;\n                }\n\n                timeout = (int)sum;\n            }\n\n            ret = oe_poll(fds, nfds, timeout);\n            goto done;\n        }\n#if defined(OE_SYS_epoll_create)\n        case OE_SYS_epoll_create:\n        {\n            int size = (int)arg1;\n            ret = oe_epoll_create(size);\n            goto done;\n        }\n#endif\n        case OE_SYS_epoll_create1:\n        {\n            int flags = (int)arg1;\n            ret = oe_epoll_create1(flags);\n            goto done;\n        }\n#if defined(OE_SYS_epoll_wait)\n        case OE_SYS_epoll_wait:\n        {\n            int epfd = (int)arg1;\n            struct oe_epoll_event* events = (struct oe_epoll_event*)arg2;\n            int maxevents = (int)arg3;\n            int timeout = (int)arg4;\n            ret = oe_epoll_wait(epfd, events, maxevents, timeout);\n            goto done;\n        }\n#endif\n        case OE_SYS_epoll_pwait:\n        {\n            int epfd = (int)arg1;\n            struct oe_epoll_event* events = (struct oe_epoll_event*)arg2;\n            int maxevents = (int)arg3;\n            int timeout = (int)arg4;\n            const oe_sigset_t* sigmask = (const oe_sigset_t*)arg5;\n            ret = oe_epoll_pwait(epfd, events, maxevents, timeout, sigmask);\n            goto done;\n        }\n        case OE_SYS_epoll_ctl:\n        {\n            int epfd = (int)arg1;\n            int op = (int)arg2;\n            int fd = (int)arg3;\n            struct oe_epoll_event* event = (struct oe_epoll_event*)arg4;\n            ret = oe_epoll_ctl(epfd, op, fd, event);\n            goto done;\n        }\n        case OE_SYS_exit_group:\n        {\n            ret = 0;\n            goto done;\n        }\n        case OE_SYS_exit:\n        {\n            int status = (int)arg1;\n            oe_exit(status);\n            goto done;\n        }\n        case OE_SYS_getpid:\n        {\n            ret = (long)oe_getpid();\n            goto done;\n        }\n        case OE_SYS_getuid:\n        {\n            ret = (long)oe_getuid();\n            goto done;\n        }\n        case OE_SYS_geteuid:\n        {\n            ret = (long)oe_geteuid();\n            goto done;\n        }\n        case OE_SYS_getgid:\n        {\n            ret = (long)oe_getgid();\n            goto done;\n        }\n        case OE_SYS_getpgid:\n        {\n            int pid = (int)arg1;\n            ret = (long)oe_getpgid(pid);\n            goto done;\n        }\n        case OE_SYS_getgroups:\n        {\n            int size = (int)arg1;\n            oe_gid_t* list = (oe_gid_t*)arg2;\n            ret = (long)oe_getgroups(size, list);\n            goto done;\n        }\n        case OE_SYS_getegid:\n        {\n            ret = (long)oe_getegid();\n            goto done;\n        }\n        case OE_SYS_getppid:\n        {\n            ret = (long)oe_getppid();\n            goto done;\n        }\n#if defined(OE_SYS_getpgrp)\n        case OE_SYS_getpgrp:\n        {\n            ret = (long)oe_getpgrp();\n            goto done;\n        }\n#endif\n        case OE_SYS_nanosleep:\n        {\n            struct oe_timespec* req = (struct oe_timespec*)arg1;\n            struct oe_timespec* rem = (struct oe_timespec*)arg2;\n            ret = (long)oe_nanosleep(req, rem);\n            goto done;\n        }\n        default:\n        {\n            oe_errno = OE_ENOSYS;\n            OE_TRACE_WARNING(\"syscall num=%ld not handled\", num);\n            goto done;\n        }\n    }\n\n    /* Unreachable */\ndone:\n    return ret;\n}\n\nlong oe_syscall(long number, ...)\n{\n    long ret;\n\n    oe_va_list ap;\n    oe_va_start(ap, number);\n    long arg1 = oe_va_arg(ap, long);\n    long arg2 = oe_va_arg(ap, long);\n    long arg3 = oe_va_arg(ap, long);\n    long arg4 = oe_va_arg(ap, long);\n    long arg5 = oe_va_arg(ap, long);\n    long arg6 = oe_va_arg(ap, long);\n    ret = _syscall(number, arg1, arg2, arg3, arg4, arg5, arg6);\n    oe_va_end(ap);\n\n    return ret;\n}\n"], "filenames": ["include/openenclave/edl/socket.edl", "include/openenclave/internal/syscall/fd.h", "include/openenclave/internal/syscall/iov.h", "include/openenclave/internal/syscall/sys/socket.h", "syscall/consolefs.c", "syscall/devices/hostepoll/hostepoll.c", "syscall/devices/hostfs/hostfs.c", "syscall/devices/hostresolver/hostresolver.c", "syscall/devices/hostsock/hostsock.c", "syscall/iov.c", "syscall/socket.c", "syscall/syscall.c"], "buggy_code_start_loc": [21, 113, 18, 135, 208, 658, 541, 13, 352, 20, 200, 620], "buggy_code_end_loc": [197, 114, 19, 208, 289, 740, 784, 184, 888, 159, 201, 622], "fixing_code_start_loc": [20, 113, 18, 136, 208, 658, 541, 14, 352, 20, 200, 620], "fixing_code_end_loc": [195, 114, 20, 211, 370, 824, 901, 252, 1166, 167, 201, 621], "type": "NVD-CWE-Other", "message": "In Open Enclave before version 0.12.0, an information disclosure vulnerability exists when an enclave application using the syscalls provided by the sockets.edl is loaded by a malicious host application. An attacker who successfully exploited the vulnerability could read privileged data from the enclave heap across trust boundaries. To exploit this vulnerability, an attacker would have to log on to an affected system and run a specially crafted application. The vulnerability would not allow an attacker to elevate user rights directly, but it could be used to obtain information otherwise considered confidential in an enclave, which could be used in further compromises. The issue has been addressed in version 0.12.0 and the current master branch. Users will need to to recompile their applications against the patched libraries to be protected from this vulnerability.", "other": {"cve": {"id": "CVE-2020-15224", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-14T19:15:13.633", "lastModified": "2021-11-18T17:00:11.477", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Open Enclave before version 0.12.0, an information disclosure vulnerability exists when an enclave application using the syscalls provided by the sockets.edl is loaded by a malicious host application. An attacker who successfully exploited the vulnerability could read privileged data from the enclave heap across trust boundaries. To exploit this vulnerability, an attacker would have to log on to an affected system and run a specially crafted application. The vulnerability would not allow an attacker to elevate user rights directly, but it could be used to obtain information otherwise considered confidential in an enclave, which could be used in further compromises. The issue has been addressed in version 0.12.0 and the current master branch. Users will need to to recompile their applications against the patched libraries to be protected from this vulnerability."}, {"lang": "es", "value": "En Open Enclave versiones anteriores a 0.12.0, se presenta una vulnerabilidad de divulgaci\u00f3n de informaci\u00f3n cuando una aplicaci\u00f3n enclave que usa las llamadas al sistema proporcionadas por el archivo sockets.edl es cargada por una aplicaci\u00f3n de host maliciosa.&#xa0;Un atacante que explote con \u00e9xito la vulnerabilidad podr\u00eda leer datos privilegiados de la pila de enclave a trav\u00e9s de l\u00edmites confiables.&#xa0;Para explotar esta vulnerabilidad, un atacante tendr\u00eda que iniciar sesi\u00f3n en un sistema afectado y ejecutar una aplicaci\u00f3n especialmente dise\u00f1ada.&#xa0;La vulnerabilidad no permitir\u00eda a un atacante elevar los derechos de usuarios directamente, pero podr\u00eda ser usada para obtener informaci\u00f3n que de otro modo se considerar\u00eda confidencial en un enclave, que podr\u00eda usarse en compromisos adicionales.&#xa0;El problema ha sido abordado en la versi\u00f3n 0.12.0 y en la rama maestra actual. Los usuarios deber\u00e1n volver a compilar sus aplicaciones con las bibliotecas parcheadas para estar protegidos de esta vulnerabilidad"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.7}, "baseSeverity": "LOW", "exploitabilityScore": 5.1, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-552"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openenclave:openenclave:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.12.0", "matchCriteriaId": "99DFEB28-6E1E-4073-9AFF-F09D44D22F7E"}]}]}], "references": [{"url": "https://github.com/openenclave/openenclave/blob/master/CHANGELOG.md#v0120", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openenclave/openenclave/security/advisories/GHSA-525h-wxcc-f66m", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b"}}