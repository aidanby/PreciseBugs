{"buggy_code": ["# frozen_string_literal: true\nrequire 'logger'\nrequire 'open-uri'\n\nrequire 'asciidoctor/include_ext/version'\nrequire 'asciidoctor/include_ext/reader_ext'\nrequire 'asciidoctor/include_ext/lineno_lines_selector'\nrequire 'asciidoctor/include_ext/logging'\nrequire 'asciidoctor/include_ext/tag_lines_selector'\nrequire 'asciidoctor'\nrequire 'asciidoctor/extensions'\n\nmodule Asciidoctor::IncludeExt\n  # Asciidoctor preprocessor for processing `include::<target>[]` directives\n  # in the source document.\n  #\n  # @see http://asciidoctor.org/docs/user-manual/#include-directive\n  class IncludeProcessor < ::Asciidoctor::Extensions::IncludeProcessor\n\n    # @param selectors [Array<Class>] an array of selectors that can filter\n    #   specified portions of the document to include\n    #   (see <http://asciidoctor.org/docs/user-manual#include-partial>).\n    # @param logger [Logger] the logger to use for logging warning and errors\n    #   from this object and selectors.\n    def initialize(selectors: [LinenoLinesSelector, TagLinesSelector],\n                   logger: Logging.default_logger, **)\n      super\n      @selectors = selectors.dup.freeze\n      @logger = logger\n    end\n\n    # @param reader [Asciidoctor::Reader]\n    # @param target [String] name of the source file to include as specified\n    #   in the target slot of the `include::[]` directive.\n    # @param attributes [Hash<String, String>] parsed attributes of the\n    #   `include::[]` directive.\n    def process(_, reader, target, attributes)\n      unless include_allowed? target, reader\n        reader.unshift_line(\"link:#{target}[]\")\n        return\n      end\n\n      if (max_depth = reader.exceeded_max_depth?)\n        logger.error \"#{reader.line_info}: maximum include depth of #{max_depth} exceeded\"\n        return\n      end\n\n      unless (path = resolve_target_path(target, reader))\n        if attributes.key? 'optional-option'\n          reader.shift\n        else\n          logger.error \"#{reader.line_info}: include target not found: #{target}\"\n          unresolved_include!(target, reader)\n        end\n        return\n      end\n\n      selector = lines_selector_for(target, attributes)\n      begin\n        lines = read_lines(path, selector)\n      rescue => e  # rubocop:disable RescueWithoutErrorClass\n        logger.error \"#{reader.line_info}: failed to read include file: #{path}: #{e}\"\n        unresolved_include!(target, reader)\n        return\n      end\n\n      if selector && selector.respond_to?(:first_included_lineno)\n        incl_offset = selector.first_included_lineno\n      end\n\n      unless lines.empty?\n        reader.push_include(lines, path, target, incl_offset || 1, attributes)\n      end\n    end\n\n    protected\n\n    attr_reader :logger\n\n    # @param target (see #process)\n    # @param reader (see #process)\n    # @return [Boolean] `true` if it's allowed to include the *target*,\n    #   `false` otherwise.\n    def include_allowed?(target, reader)\n      doc = reader.document\n\n      return false if doc.safe >= ::Asciidoctor::SafeMode::SECURE\n      return false if doc.attributes.fetch('max-include-depth', 64).to_i < 1\n      return false if target_uri?(target) && !doc.attributes.key?('allow-uri-read')\n      true\n    end\n\n    # @param target (see #process)\n    # @param reader (see #process)\n    # @return [String, nil] file path or URI of the *target*, or `nil` if not found.\n    def resolve_target_path(target, reader)\n      return target if target_uri? target\n\n      # Include file is resolved relative to dir of the current include,\n      # or base_dir if within original docfile.\n      path = reader.document.normalize_system_path(target, reader.dir, nil,\n                                                   target_name: 'include file')\n      path if ::File.file?(path)\n    end\n\n    # Reads the specified file as individual lines, filters them using the\n    # *selector* (if provided) and returns those lines in an array.\n    #\n    # @param filename [String] path of the file to be read.\n    # @param selector [#to_proc, nil] predicate to filter lines that should be\n    #   included in the output. It must accept two arguments: line and\n    #   the line number. If `nil` is given, all lines are passed.\n    # @return [Array<String>] an array of read lines.\n    def read_lines(filename, selector)\n      if selector\n        IO.foreach(filename).select.with_index(1, &selector)\n      else\n        URI.open(filename, &:read)\n      end\n    end\n\n    # Finds and initializes a lines selector that can handle the specified include.\n    #\n    # @param target (see #process)\n    # @param attributes (see #process)\n    # @return [#to_proc, nil] an instance of lines selector, or `nil` if not found.\n    def lines_selector_for(target, attributes)\n      if (klass = @selectors.find { |s| s.handles? target, attributes })\n        klass.new(target, attributes, logger: logger)\n      end\n    end\n\n    # Replaces the include directive in ouput with a notice that it has not\n    # been resolved.\n    #\n    # @param target (see #process)\n    # @param reader (see #process)\n    def unresolved_include!(target, reader)\n      reader.unshift_line(\"Unresolved directive in #{reader.path} - include::#{target}[]\")\n    end\n\n    private\n\n    # @param target (see #process)\n    # @return [Boolean] `true` if the *target* is an URI, `false` otherwise.\n    def target_uri?(target)\n      ::Asciidoctor::Helpers.uriish?(target)\n    end\n  end\nend\n", "require_relative 'spec_helper'\nrequire 'asciidoctor/include_ext/include_processor'\nrequire 'webrick'\n\nFIXTURES_DIR = File.expand_path('fixtures', __dir__)\n\ndescribe 'Integration tests' do\n\n  subject(:output) { Asciidoctor.convert(input, options) }\n\n  let(:input) { '' }  # this is modified in #given\n  let(:processor) { Asciidoctor::IncludeExt::IncludeProcessor.new }\n\n  let(:options) {\n    processor_ = processor\n    {\n      safe: :safe,\n      header_footer: false,\n      base_dir: FIXTURES_DIR,\n      extensions: proc { include_processor processor_ },\n    }\n  }\n\n  before do\n    # XXX: Ugly hack to get rid of rspec-mocks' warnings about resetting\n    # frozen object; https://github.com/rspec/rspec-mocks/issues/1190.\n    processor.define_singleton_method(:freeze) { self }\n\n    # Make sure that Asciidoctor really calls our processor.\n    expect(processor).to receive(:process).at_least(:once).and_call_original\n  end\n\n  describe 'include::[] directive' do\n\n    it 'is replaced by a link when safe mode is default' do\n      given 'include::include-file.adoc[]', safe: nil\n\n      should match /<a[^>]+href=\"include-file.adoc\"/\n      should_not match /included content/\n    end\n\n    it 'is resolved when safe mode is less than SECURE' do\n      given 'include::include-file.adoc[]'\n\n      should match /included content/\n      should_not match /<a[^>]+href=\"include-file\\.adoc\"/\n    end\n\n    it 'nested includes are resolved with relative paths' do\n      given 'include::a/include-1.adoc[]'\n\n      expect( output.scan(/[^>]*include \\w+/) ).to eq [\n        'begin of include 1', 'include 2a', 'begin of include 2b', 'include 3',\n        'end of include 2b', 'end of include 1'\n      ]\n    end\n\n    it 'is replaced by a warning when target is not found' do\n      given <<~ADOC\n        include::no-such-file.adoc[]\n\n        trailing content\n      ADOC\n\n      should match /unresolved/i\n      should match /trailing content/\n    end\n\n    it 'is skipped when target is not found and optional option is set' do\n      given <<~ADOC\n        include::no-such-file.adoc[opts=optional]\n\n        trailing content\n      ADOC\n\n      should match /trailing content/\n      should_not match /unresolved/i\n    end\n\n    it 'is replaced by a link when target is an URI and attribute allow-uri-read is not set' do\n      using_test_webserver do |host, port|\n        target = \"http://#{host}:#{port}/hello.json\"\n        given \"include::#{target}[]\"\n\n        should match /<a[^>]*href=\"#{target}\"/\n        should_not match /\\{\"message\": \"Hello, world!\"\\}/\n      end\n    end\n\n    it 'retrieves content from URI target when allow-uri-read is set' do\n      using_test_webserver do |host, port|\n        given \"include::http://#{host}:#{port}/hello.json[]\",\n              attributes: { 'allow-uri-read' => '' }\n\n        should match /\\{\"message\": \"Hello, world!\"\\}/\n        should_not match /unresolved/i\n      end\n    end\n\n    it 'supports line selection' do\n      given 'include::include-file.adoc[lines=1;3..4;6..-1]'\n\n      %w[1 3 4 6 7 8].each do |n|\n        should match /line #{n} of included content/\n      end\n      should match /last line/\n\n      should_not match /line 2/\n      should_not match /line 5/\n    end\n\n    it 'supports tagged selection' do\n      given 'include::include-file.adoc[tag=snippet-a]'\n\n      should match /snippet-a content/\n      should_not match /snippet-b content/\n      should_not match /non-tagged content/\n      should_not match /included content/\n    end\n\n    it 'supports multiple tagged selection' do\n      given 'include::include-file.adoc[tags=\"snippet-a,snippet-b\"]'\n\n      should match /snippet-a content/\n      should match /snippet-b content/\n      should_not match /non-tagged content/\n      should_not match /included content/\n    end\n\n    it 'supports tagged selection in language that uses circumfix comments' do\n      given <<~ADOC\n        [source, ml]\n        ----\n        include::include-file.ml[tag=snippet]\n        ----\n      ADOC\n\n      should match /let s = SS.empty;;/\n      should_not match /(?:tag|end)::snippet\\[\\]/\n    end\n  end\n\n\n  #----------  Helpers  ----------\n\n  def given(str, opts = {})\n    input.replace(str)\n    options.merge!(opts)\n  end\n\n  def using_test_webserver\n    started = false\n    server = WEBrick::HTTPServer.new(\n      BindAddress: '127.0.0.1',\n      Port: 0,\n      StartCallback: -> { started = true },\n      AccessLog: [],\n    )\n\n    server.mount_proc '/hello.json' do |_, res|\n      res.body = '{\"message\": \"Hello, world!\"}'\n    end\n\n    Thread.new { server.start }\n    Timeout.timeout(1) { :wait until started }\n\n    begin\n      yield server.config[:BindAddress], server.config[:Port]\n    ensure\n      server.shutdown\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\nrequire 'logger'\nrequire 'open-uri'\nrequire 'uri'\n\nrequire 'asciidoctor/include_ext/version'\nrequire 'asciidoctor/include_ext/reader_ext'\nrequire 'asciidoctor/include_ext/lineno_lines_selector'\nrequire 'asciidoctor/include_ext/logging'\nrequire 'asciidoctor/include_ext/tag_lines_selector'\nrequire 'asciidoctor'\nrequire 'asciidoctor/extensions'\n\nmodule Asciidoctor::IncludeExt\n  # Asciidoctor preprocessor for processing `include::<target>[]` directives\n  # in the source document.\n  #\n  # @see http://asciidoctor.org/docs/user-manual/#include-directive\n  class IncludeProcessor < ::Asciidoctor::Extensions::IncludeProcessor\n\n    # @param selectors [Array<Class>] an array of selectors that can filter\n    #   specified portions of the document to include\n    #   (see <http://asciidoctor.org/docs/user-manual#include-partial>).\n    # @param logger [Logger] the logger to use for logging warning and errors\n    #   from this object and selectors.\n    def initialize(selectors: [LinenoLinesSelector, TagLinesSelector],\n                   logger: Logging.default_logger, **)\n      super\n      @selectors = selectors.dup.freeze\n      @logger = logger\n    end\n\n    # @param reader [Asciidoctor::Reader]\n    # @param target [String] name of the source file to include as specified\n    #   in the target slot of the `include::[]` directive.\n    # @param attributes [Hash<String, String>] parsed attributes of the\n    #   `include::[]` directive.\n    def process(_, reader, target, attributes)\n      unless include_allowed? target, reader\n        reader.unshift_line(\"link:#{target}[]\")\n        return\n      end\n\n      if (max_depth = reader.exceeded_max_depth?)\n        logger.error \"#{reader.line_info}: maximum include depth of #{max_depth} exceeded\"\n        return\n      end\n\n      unless (path = resolve_target_path(target, reader))\n        if attributes.key? 'optional-option'\n          reader.shift\n        else\n          logger.error \"#{reader.line_info}: include target not found: #{target}\"\n          unresolved_include!(target, reader)\n        end\n        return\n      end\n\n      selector = lines_selector_for(target, attributes)\n      begin\n        lines = read_lines(path, selector)\n      rescue => e  # rubocop:disable RescueWithoutErrorClass\n        logger.error \"#{reader.line_info}: failed to read include file: #{path}: #{e}\"\n        unresolved_include!(target, reader)\n        return\n      end\n\n      if selector && selector.respond_to?(:first_included_lineno)\n        incl_offset = selector.first_included_lineno\n      end\n\n      unless lines.empty?\n        reader.push_include(lines, path, target, incl_offset || 1, attributes)\n      end\n    end\n\n    protected\n\n    attr_reader :logger\n\n    # @param target (see #process)\n    # @param reader (see #process)\n    # @return [Boolean] `true` if it's allowed to include the *target*,\n    #   `false` otherwise.\n    def include_allowed?(target, reader)\n      doc = reader.document\n\n      return false if doc.safe >= ::Asciidoctor::SafeMode::SECURE\n      return false if doc.attributes.fetch('max-include-depth', 64).to_i < 1\n      return false if target_http?(target) && !doc.attributes.key?('allow-uri-read')\n      true\n    end\n\n    # @param target (see #process)\n    # @param reader (see #process)\n    # @return [String, nil] file path or URI of the *target*, or `nil` if not found.\n    def resolve_target_path(target, reader)\n      return target if target_http? target\n\n      # Include file is resolved relative to dir of the current include,\n      # or base_dir if within original docfile.\n      path = reader.document.normalize_system_path(target, reader.dir, nil,\n                                                   target_name: 'include file')\n      path if ::File.file?(path)\n    end\n\n    # Reads the specified file as individual lines, filters them using the\n    # *selector* (if provided) and returns those lines in an array.\n    #\n    # @param path [String] URL or path of the file to be read.\n    # @param selector [#to_proc, nil] predicate to filter lines that should be\n    #   included in the output. It must accept two arguments: line and\n    #   the line number. If `nil` is given, all lines are passed.\n    # @return [Array<String>] an array of read lines.\n    def read_lines(path, selector)\n      if selector\n        IO.foreach(path).select.with_index(1, &selector)\n      else\n        URI.open(path, &:read)\n      end\n    end\n\n    # Finds and initializes a lines selector that can handle the specified include.\n    #\n    # @param target (see #process)\n    # @param attributes (see #process)\n    # @return [#to_proc, nil] an instance of lines selector, or `nil` if not found.\n    def lines_selector_for(target, attributes)\n      if (klass = @selectors.find { |s| s.handles? target, attributes })\n        klass.new(target, attributes, logger: logger)\n      end\n    end\n\n    # Replaces the include directive in ouput with a notice that it has not\n    # been resolved.\n    #\n    # @param target (see #process)\n    # @param reader (see #process)\n    def unresolved_include!(target, reader)\n      reader.unshift_line(\"Unresolved directive in #{reader.path} - include::#{target}[]\")\n    end\n\n    private\n\n    # @param target (see #process)\n    # @return [Boolean] `true` if the *target* is a valid HTTP(S) URI, `false` otherwise.\n    def target_http?(target)\n      # First do a fast test, then try to parse it.\n      target.downcase.start_with?('http://', 'https://') \\\n        && URI.parse(target).is_a?(URI::HTTP)\n    rescue URI::InvalidURIError\n      false\n    end\n  end\nend\n", "require_relative 'spec_helper'\nrequire 'asciidoctor/include_ext/include_processor'\nrequire 'webrick'\n\nFIXTURES_DIR = File.expand_path('fixtures', __dir__)\n\ndescribe 'Integration tests' do\n\n  subject(:output) { Asciidoctor.convert(input, options) }\n\n  let(:input) { '' }  # this is modified in #given\n  let(:processor) { Asciidoctor::IncludeExt::IncludeProcessor.new }\n\n  let(:options) {\n    processor_ = processor\n    {\n      safe: :safe,\n      header_footer: false,\n      base_dir: FIXTURES_DIR,\n      extensions: proc { include_processor processor_ },\n    }\n  }\n\n  before do\n    # XXX: Ugly hack to get rid of rspec-mocks' warnings about resetting\n    # frozen object; https://github.com/rspec/rspec-mocks/issues/1190.\n    processor.define_singleton_method(:freeze) { self }\n\n    # Make sure that Asciidoctor really calls our processor.\n    expect(processor).to receive(:process).at_least(:once).and_call_original\n  end\n\n  describe 'include::[] directive' do\n\n    it 'is replaced by a link when safe mode is default' do\n      given 'include::include-file.adoc[]', safe: nil\n\n      should match /<a[^>]+href=\"include-file.adoc\"/\n      should_not match /included content/\n    end\n\n    it 'is resolved when safe mode is less than SECURE' do\n      given 'include::include-file.adoc[]'\n\n      should match /included content/\n      should_not match /<a[^>]+href=\"include-file\\.adoc\"/\n    end\n\n    it 'nested includes are resolved with relative paths' do\n      given 'include::a/include-1.adoc[]'\n\n      expect( output.scan(/[^>]*include \\w+/) ).to eq [\n        'begin of include 1', 'include 2a', 'begin of include 2b', 'include 3',\n        'end of include 2b', 'end of include 1'\n      ]\n    end\n\n    it 'is replaced by a warning when target is not found' do\n      given <<~ADOC\n        include::no-such-file.adoc[]\n\n        trailing content\n      ADOC\n\n      should match /unresolved/i\n      should match /trailing content/\n    end\n\n    it 'is skipped when target is not found and optional option is set' do\n      given <<~ADOC\n        include::no-such-file.adoc[opts=optional]\n\n        trailing content\n      ADOC\n\n      should match /trailing content/\n      should_not match /unresolved/i\n    end\n\n    it 'is replaced by a link when target is an URI and attribute allow-uri-read is not set' do\n      using_test_webserver do |host, port|\n        target = \"http://#{host}:#{port}/hello.json\"\n        given \"include::#{target}[]\"\n\n        should match /<a[^>]*href=\"#{target}\"/\n        should_not match /\\{\"message\": \"Hello, world!\"\\}/\n      end\n    end\n\n    it 'retrieves content from URI target when allow-uri-read is set' do\n      using_test_webserver do |host, port|\n        given \"include::http://#{host}:#{port}/hello.json[]\",\n              attributes: { 'allow-uri-read' => '' }\n\n        should match /\\{\"message\": \"Hello, world!\"\\}/\n        should_not match /unresolved/i\n      end\n    end\n\n    it 'supports line selection' do\n      given 'include::include-file.adoc[lines=1;3..4;6..-1]'\n\n      %w[1 3 4 6 7 8].each do |n|\n        should match /line #{n} of included content/\n      end\n      should match /last line/\n\n      should_not match /line 2/\n      should_not match /line 5/\n    end\n\n    it 'supports tagged selection' do\n      given 'include::include-file.adoc[tag=snippet-a]'\n\n      should match /snippet-a content/\n      should_not match /snippet-b content/\n      should_not match /non-tagged content/\n      should_not match /included content/\n    end\n\n    it 'supports multiple tagged selection' do\n      given 'include::include-file.adoc[tags=\"snippet-a,snippet-b\"]'\n\n      should match /snippet-a content/\n      should match /snippet-b content/\n      should_not match /non-tagged content/\n      should_not match /included content/\n    end\n\n    it 'supports tagged selection in language that uses circumfix comments' do\n      given <<~ADOC\n        [source, ml]\n        ----\n        include::include-file.ml[tag=snippet]\n        ----\n      ADOC\n\n      should match /let s = SS.empty;;/\n      should_not match /(?:tag|end)::snippet\\[\\]/\n    end\n\n    it 'does not allow execution of system command when allow-uri-read is set' do\n      options.merge!(attributes: { 'allow-uri-read' => '' })\n      given <<~ADOC\n        :app-name: |cat LICENSE # + \\\\\n        http://test.com\n\n        include::{app-name}[]\n      ADOC\n\n      should match /unresolved/i\n      should_not match /The MIT License/\n    end\n\n  end\n\n\n  #----------  Helpers  ----------\n\n  def given(str, opts = {})\n    input.replace(str)\n    options.merge!(opts)\n  end\n\n  def using_test_webserver\n    started = false\n    server = WEBrick::HTTPServer.new(\n      BindAddress: '127.0.0.1',\n      Port: 0,\n      StartCallback: -> { started = true },\n      AccessLog: [],\n    )\n\n    server.mount_proc '/hello.json' do |_, res|\n      res.body = '{\"message\": \"Hello, world!\"}'\n    end\n\n    Thread.new { server.start }\n    Timeout.timeout(1) { :wait until started }\n\n    begin\n      yield server.config[:BindAddress], server.config[:Port]\n    ensure\n      server.shutdown\n    end\n  end\nend\n"], "filenames": ["lib/asciidoctor/include_ext/include_processor.rb", "spec/integration_spec.rb"], "buggy_code_start_loc": [3, 140], "buggy_code_end_loc": [148, 140], "fixing_code_start_loc": [4, 141], "fixing_code_end_loc": [153, 155], "type": "CWE-78", "message": "Asciidoctor-include-ext is Asciidoctor\u2019s standard include processor reimplemented as an extension. Versions prior to 0.4.0, when used to render user-supplied input in AsciiDoc markup, may allow an attacker to execute arbitrary system commands on the host operating system. This attack is possible even when `allow-uri-read` is disabled! The problem has been patched in the referenced commits.", "other": {"cve": {"id": "CVE-2022-24803", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-01T00:15:08.950", "lastModified": "2022-04-11T20:15:58.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Asciidoctor-include-ext is Asciidoctor\u2019s standard include processor reimplemented as an extension. Versions prior to 0.4.0, when used to render user-supplied input in AsciiDoc markup, may allow an attacker to execute arbitrary system commands on the host operating system. This attack is possible even when `allow-uri-read` is disabled! The problem has been patched in the referenced commits."}, {"lang": "es", "value": "Asciidoctor-include-ext es el procesador de inclusi\u00f3n est\u00e1ndar de Asciidoctor reimplementado como una extensi\u00f3n. En versiones anteriores a 0.4.0, cuando son usadas para renderizar la entrada suministrada por el usuario en el marcado AsciiDoc, pueden permitir a un atacante ejecutar comandos arbitrarios del sistema en el sistema operativo anfitri\u00f3n. Este ataque es posible incluso cuando \"allow-uri-read\" est\u00e1 deshabilitado. El problema ha sido parcheado en los commits referenciados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:asciidoctor-include-ext_project:asciidoctor-include-ext:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.4.0", "matchCriteriaId": "39AA2467-43AC-4113-A089-325768DC5A00"}]}]}], "references": [{"url": "https://github.com/jirutka/asciidoctor-include-ext/commit/c7ea001a597c7033575342c51483dab7b87ae155", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/jirutka/asciidoctor-include-ext/commit/cbaccf3de533cbca224bf61d0b74e4b84d41d8ee", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jirutka/asciidoctor-include-ext/security/advisories/GHSA-v222-6mr4-qj29", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jirutka/asciidoctor-include-ext/commit/c7ea001a597c7033575342c51483dab7b87ae155"}}