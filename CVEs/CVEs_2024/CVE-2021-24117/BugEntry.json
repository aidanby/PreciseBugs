{"buggy_code": ["[package]\nname = \"base64\"\nversion = \"0.13.0\"\nauthors = [\"Alice Maz <alice@alicemaz.com>\", \"Marshall Pierce <marshall@mpierce.org>\"]\ndescription = \"encodes and decodes base64 as bytes or utf8\"\nrepository = \"https://github.com/marshallpierce/rust-base64\"\ndocumentation = \"https://docs.rs/base64\"\nreadme = \"README.md\"\nkeywords = [\"base64\", \"utf8\", \"encode\", \"decode\", \"no_std\"]\ncategories = [\"encoding\"]\nlicense = \"MIT/Apache-2.0\"\nedition = \"2018\"\n\n[[bench]]\nname = \"benchmarks\"\nharness = false\n\n[dev-dependencies]\n# 0.3.3 requires rust 1.36.0 for stable copied()\ncriterion = \"=0.3.2\"\nrand = \"0.6.1\"\nstructopt = \"0.3\"\n\n[features]\ndefault = [\"std\"]\nalloc = []\nstd = []\n\n[profile.bench]\n# Useful for better disassembly when using `perf record` and `perf annotate`\ndebug = true\n", "use crate::{tables, Config, PAD_BYTE};\n\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\nuse crate::STANDARD;\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\nuse alloc::vec::Vec;\nuse core::fmt;\n#[cfg(any(feature = \"std\", test))]\nuse std::error;\n\n// decode logic operates on chunks of 8 input bytes without padding\nconst INPUT_CHUNK_LEN: usize = 8;\nconst DECODED_CHUNK_LEN: usize = 6;\n// we read a u64 and write a u64, but a u64 of input only yields 6 bytes of output, so the last\n// 2 bytes of any output u64 should not be counted as written to (but must be available in a\n// slice).\nconst DECODED_CHUNK_SUFFIX: usize = 2;\n\n// how many u64's of input to handle at a time\nconst CHUNKS_PER_FAST_LOOP_BLOCK: usize = 4;\nconst INPUT_BLOCK_LEN: usize = CHUNKS_PER_FAST_LOOP_BLOCK * INPUT_CHUNK_LEN;\n// includes the trailing 2 bytes for the final u64 write\nconst DECODED_BLOCK_LEN: usize =\n    CHUNKS_PER_FAST_LOOP_BLOCK * DECODED_CHUNK_LEN + DECODED_CHUNK_SUFFIX;\n\n/// Errors that can occur while decoding.\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum DecodeError {\n    /// An invalid byte was found in the input. The offset and offending byte are provided.\n    InvalidByte(usize, u8),\n    /// The length of the input is invalid.\n    /// A typical cause of this is stray trailing whitespace or other separator bytes.\n    /// In the case where excess trailing bytes have produced an invalid length *and* the last byte\n    /// is also an invalid base64 symbol (as would be the case for whitespace, etc), `InvalidByte`\n    /// will be emitted instead of `InvalidLength` to make the issue easier to debug.\n    InvalidLength,\n    /// The last non-padding input symbol's encoded 6 bits have nonzero bits that will be discarded.\n    /// This is indicative of corrupted or truncated Base64.\n    /// Unlike InvalidByte, which reports symbols that aren't in the alphabet, this error is for\n    /// symbols that are in the alphabet but represent nonsensical encodings.\n    InvalidLastSymbol(usize, u8),\n}\n\nimpl fmt::Display for DecodeError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            DecodeError::InvalidByte(index, byte) => {\n                write!(f, \"Invalid byte {}, offset {}.\", byte, index)\n            }\n            DecodeError::InvalidLength => write!(f, \"Encoded text cannot have a 6-bit remainder.\"),\n            DecodeError::InvalidLastSymbol(index, byte) => {\n                write!(f, \"Invalid last symbol {}, offset {}.\", byte, index)\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", test))]\nimpl error::Error for DecodeError {\n    fn description(&self) -> &str {\n        match *self {\n            DecodeError::InvalidByte(_, _) => \"invalid byte\",\n            DecodeError::InvalidLength => \"invalid length\",\n            DecodeError::InvalidLastSymbol(_, _) => \"invalid last symbol\",\n        }\n    }\n\n    fn cause(&self) -> Option<&dyn error::Error> {\n        None\n    }\n}\n\n///Decode from string reference as octets.\n///Returns a Result containing a Vec<u8>.\n///Convenience `decode_config(input, base64::STANDARD);`.\n///\n///# Example\n///\n///```rust\n///extern crate base64;\n///\n///fn main() {\n///    let bytes = base64::decode(\"aGVsbG8gd29ybGQ=\").unwrap();\n///    println!(\"{:?}\", bytes);\n///}\n///```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub fn decode<T: AsRef<[u8]>>(input: T) -> Result<Vec<u8>, DecodeError> {\n    decode_config(input, STANDARD)\n}\n\n///Decode from string reference as octets.\n///Returns a Result containing a Vec<u8>.\n///\n///# Example\n///\n///```rust\n///extern crate base64;\n///\n///fn main() {\n///    let bytes = base64::decode_config(\"aGVsbG8gd29ybGR+Cg==\", base64::STANDARD).unwrap();\n///    println!(\"{:?}\", bytes);\n///\n///    let bytes_url = base64::decode_config(\"aGVsbG8gaW50ZXJuZXR-Cg==\", base64::URL_SAFE).unwrap();\n///    println!(\"{:?}\", bytes_url);\n///}\n///```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub fn decode_config<T: AsRef<[u8]>>(input: T, config: Config) -> Result<Vec<u8>, DecodeError> {\n    let mut buffer = Vec::<u8>::with_capacity(input.as_ref().len() * 4 / 3);\n\n    decode_config_buf(input, config, &mut buffer).map(|_| buffer)\n}\n\n///Decode from string reference as octets.\n///Writes into the supplied buffer to avoid allocation.\n///Returns a Result containing an empty tuple, aka ().\n///\n///# Example\n///\n///```rust\n///extern crate base64;\n///\n///fn main() {\n///    let mut buffer = Vec::<u8>::new();\n///    base64::decode_config_buf(\"aGVsbG8gd29ybGR+Cg==\", base64::STANDARD, &mut buffer).unwrap();\n///    println!(\"{:?}\", buffer);\n///\n///    buffer.clear();\n///\n///    base64::decode_config_buf(\"aGVsbG8gaW50ZXJuZXR-Cg==\", base64::URL_SAFE, &mut buffer)\n///        .unwrap();\n///    println!(\"{:?}\", buffer);\n///}\n///```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub fn decode_config_buf<T: AsRef<[u8]>>(\n    input: T,\n    config: Config,\n    buffer: &mut Vec<u8>,\n) -> Result<(), DecodeError> {\n    let input_bytes = input.as_ref();\n\n    let starting_output_len = buffer.len();\n\n    let num_chunks = num_chunks(input_bytes);\n    let decoded_len_estimate = num_chunks\n        .checked_mul(DECODED_CHUNK_LEN)\n        .and_then(|p| p.checked_add(starting_output_len))\n        .expect(\"Overflow when calculating output buffer length\");\n    buffer.resize(decoded_len_estimate, 0);\n\n    let bytes_written;\n    {\n        let buffer_slice = &mut buffer.as_mut_slice()[starting_output_len..];\n        bytes_written = decode_helper(input_bytes, num_chunks, config, buffer_slice)?;\n    }\n\n    buffer.truncate(starting_output_len + bytes_written);\n\n    Ok(())\n}\n\n/// Decode the input into the provided output slice.\n///\n/// This will not write any bytes past exactly what is decoded (no stray garbage bytes at the end).\n///\n/// If you don't know ahead of time what the decoded length should be, size your buffer with a\n/// conservative estimate for the decoded length of an input: 3 bytes of output for every 4 bytes of\n/// input, rounded up, or in other words `(input_len + 3) / 4 * 3`.\n///\n/// If the slice is not large enough, this will panic.\npub fn decode_config_slice<T: AsRef<[u8]>>(\n    input: T,\n    config: Config,\n    output: &mut [u8],\n) -> Result<usize, DecodeError> {\n    let input_bytes = input.as_ref();\n\n    decode_helper(input_bytes, num_chunks(input_bytes), config, output)\n}\n\n/// Return the number of input chunks (including a possibly partial final chunk) in the input\nfn num_chunks(input: &[u8]) -> usize {\n    input\n        .len()\n        .checked_add(INPUT_CHUNK_LEN - 1)\n        .expect(\"Overflow when calculating number of chunks in input\")\n        / INPUT_CHUNK_LEN\n}\n\n/// Helper to avoid duplicating num_chunks calculation, which is costly on short inputs.\n/// Returns the number of bytes written, or an error.\n// We're on the fragile edge of compiler heuristics here. If this is not inlined, slow. If this is\n// inlined(always), a different slow. plain ol' inline makes the benchmarks happiest at the moment,\n// but this is fragile and the best setting changes with only minor code modifications.\n#[inline]\nfn decode_helper(\n    input: &[u8],\n    num_chunks: usize,\n    config: Config,\n    output: &mut [u8],\n) -> Result<usize, DecodeError> {\n    let char_set = config.char_set;\n    let decode_table = char_set.decode_table();\n\n    let remainder_len = input.len() % INPUT_CHUNK_LEN;\n\n    // Because the fast decode loop writes in groups of 8 bytes (unrolled to\n    // CHUNKS_PER_FAST_LOOP_BLOCK times 8 bytes, where possible) and outputs 8 bytes at a time (of\n    // which only 6 are valid data), we need to be sure that we stop using the fast decode loop\n    // soon enough that there will always be 2 more bytes of valid data written after that loop.\n    let trailing_bytes_to_skip = match remainder_len {\n        // if input is a multiple of the chunk size, ignore the last chunk as it may have padding,\n        // and the fast decode logic cannot handle padding\n        0 => INPUT_CHUNK_LEN,\n        // 1 and 5 trailing bytes are illegal: can't decode 6 bits of input into a byte\n        1 | 5 => {\n            // trailing whitespace is so common that it's worth it to check the last byte to\n            // possibly return a better error message\n            if let Some(b) = input.last() {\n                if *b != PAD_BYTE && decode_table[*b as usize] == tables::INVALID_VALUE {\n                    return Err(DecodeError::InvalidByte(input.len() - 1, *b));\n                }\n            }\n\n            return Err(DecodeError::InvalidLength);\n        }\n        // This will decode to one output byte, which isn't enough to overwrite the 2 extra bytes\n        // written by the fast decode loop. So, we have to ignore both these 2 bytes and the\n        // previous chunk.\n        2 => INPUT_CHUNK_LEN + 2,\n        // If this is 3 unpadded chars, then it would actually decode to 2 bytes. However, if this\n        // is an erroneous 2 chars + 1 pad char that would decode to 1 byte, then it should fail\n        // with an error, not panic from going past the bounds of the output slice, so we let it\n        // use stage 3 + 4.\n        3 => INPUT_CHUNK_LEN + 3,\n        // This can also decode to one output byte because it may be 2 input chars + 2 padding\n        // chars, which would decode to 1 byte.\n        4 => INPUT_CHUNK_LEN + 4,\n        // Everything else is a legal decode len (given that we don't require padding), and will\n        // decode to at least 2 bytes of output.\n        _ => remainder_len,\n    };\n\n    // rounded up to include partial chunks\n    let mut remaining_chunks = num_chunks;\n\n    let mut input_index = 0;\n    let mut output_index = 0;\n\n    {\n        let length_of_fast_decode_chunks = input.len().saturating_sub(trailing_bytes_to_skip);\n\n        // Fast loop, stage 1\n        // manual unroll to CHUNKS_PER_FAST_LOOP_BLOCK of u64s to amortize slice bounds checks\n        if let Some(max_start_index) = length_of_fast_decode_chunks.checked_sub(INPUT_BLOCK_LEN) {\n            while input_index <= max_start_index {\n                let input_slice = &input[input_index..(input_index + INPUT_BLOCK_LEN)];\n                let output_slice = &mut output[output_index..(output_index + DECODED_BLOCK_LEN)];\n\n                decode_chunk(\n                    &input_slice[0..],\n                    input_index,\n                    decode_table,\n                    &mut output_slice[0..],\n                )?;\n                decode_chunk(\n                    &input_slice[8..],\n                    input_index + 8,\n                    decode_table,\n                    &mut output_slice[6..],\n                )?;\n                decode_chunk(\n                    &input_slice[16..],\n                    input_index + 16,\n                    decode_table,\n                    &mut output_slice[12..],\n                )?;\n                decode_chunk(\n                    &input_slice[24..],\n                    input_index + 24,\n                    decode_table,\n                    &mut output_slice[18..],\n                )?;\n\n                input_index += INPUT_BLOCK_LEN;\n                output_index += DECODED_BLOCK_LEN - DECODED_CHUNK_SUFFIX;\n                remaining_chunks -= CHUNKS_PER_FAST_LOOP_BLOCK;\n            }\n        }\n\n        // Fast loop, stage 2 (aka still pretty fast loop)\n        // 8 bytes at a time for whatever we didn't do in stage 1.\n        if let Some(max_start_index) = length_of_fast_decode_chunks.checked_sub(INPUT_CHUNK_LEN) {\n            while input_index < max_start_index {\n                decode_chunk(\n                    &input[input_index..(input_index + INPUT_CHUNK_LEN)],\n                    input_index,\n                    decode_table,\n                    &mut output\n                        [output_index..(output_index + DECODED_CHUNK_LEN + DECODED_CHUNK_SUFFIX)],\n                )?;\n\n                output_index += DECODED_CHUNK_LEN;\n                input_index += INPUT_CHUNK_LEN;\n                remaining_chunks -= 1;\n            }\n        }\n    }\n\n    // Stage 3\n    // If input length was such that a chunk had to be deferred until after the fast loop\n    // because decoding it would have produced 2 trailing bytes that wouldn't then be\n    // overwritten, we decode that chunk here. This way is slower but doesn't write the 2\n    // trailing bytes.\n    // However, we still need to avoid the last chunk (partial or complete) because it could\n    // have padding, so we always do 1 fewer to avoid the last chunk.\n    for _ in 1..remaining_chunks {\n        decode_chunk_precise(\n            &input[input_index..],\n            input_index,\n            decode_table,\n            &mut output[output_index..(output_index + DECODED_CHUNK_LEN)],\n        )?;\n\n        input_index += INPUT_CHUNK_LEN;\n        output_index += DECODED_CHUNK_LEN;\n    }\n\n    // always have one more (possibly partial) block of 8 input\n    debug_assert!(input.len() - input_index > 1 || input.is_empty());\n    debug_assert!(input.len() - input_index <= 8);\n\n    // Stage 4\n    // Finally, decode any leftovers that aren't a complete input block of 8 bytes.\n    // Use a u64 as a stack-resident 8 byte buffer.\n    let mut leftover_bits: u64 = 0;\n    let mut morsels_in_leftover = 0;\n    let mut padding_bytes = 0;\n    let mut first_padding_index: usize = 0;\n    let mut last_symbol = 0_u8;\n    let start_of_leftovers = input_index;\n    for (i, b) in input[start_of_leftovers..].iter().enumerate() {\n        // '=' padding\n        if *b == PAD_BYTE {\n            // There can be bad padding in a few ways:\n            // 1 - Padding with non-padding characters after it\n            // 2 - Padding after zero or one non-padding characters before it\n            //     in the current quad.\n            // 3 - More than two characters of padding. If 3 or 4 padding chars\n            //     are in the same quad, that implies it will be caught by #2.\n            //     If it spreads from one quad to another, it will be caught by\n            //     #2 in the second quad.\n\n            if i % 4 < 2 {\n                // Check for case #2.\n                let bad_padding_index = start_of_leftovers\n                    + if padding_bytes > 0 {\n                        // If we've already seen padding, report the first padding index.\n                        // This is to be consistent with the faster logic above: it will report an\n                        // error on the first padding character (since it doesn't expect to see\n                        // anything but actual encoded data).\n                        first_padding_index\n                    } else {\n                        // haven't seen padding before, just use where we are now\n                        i\n                    };\n                return Err(DecodeError::InvalidByte(bad_padding_index, *b));\n            }\n\n            if padding_bytes == 0 {\n                first_padding_index = i;\n            }\n\n            padding_bytes += 1;\n            continue;\n        }\n\n        // Check for case #1.\n        // To make '=' handling consistent with the main loop, don't allow\n        // non-suffix '=' in trailing chunk either. Report error as first\n        // erroneous padding.\n        if padding_bytes > 0 {\n            return Err(DecodeError::InvalidByte(\n                start_of_leftovers + first_padding_index,\n                PAD_BYTE,\n            ));\n        }\n        last_symbol = *b;\n\n        // can use up to 8 * 6 = 48 bits of the u64, if last chunk has no padding.\n        // To minimize shifts, pack the leftovers from left to right.\n        let shift = 64 - (morsels_in_leftover + 1) * 6;\n        // tables are all 256 elements, lookup with a u8 index always succeeds\n        let morsel = decode_table[*b as usize];\n        if morsel == tables::INVALID_VALUE {\n            return Err(DecodeError::InvalidByte(start_of_leftovers + i, *b));\n        }\n\n        leftover_bits |= (morsel as u64) << shift;\n        morsels_in_leftover += 1;\n    }\n\n    let leftover_bits_ready_to_append = match morsels_in_leftover {\n        0 => 0,\n        2 => 8,\n        3 => 16,\n        4 => 24,\n        6 => 32,\n        7 => 40,\n        8 => 48,\n        _ => unreachable!(\n            \"Impossible: must only have 0 to 8 input bytes in last chunk, with no invalid lengths\"\n        ),\n    };\n\n    // if there are bits set outside the bits we care about, last symbol encodes trailing bits that\n    // will not be included in the output\n    let mask = !0 >> leftover_bits_ready_to_append;\n    if !config.decode_allow_trailing_bits && (leftover_bits & mask) != 0 {\n        // last morsel is at `morsels_in_leftover` - 1\n        return Err(DecodeError::InvalidLastSymbol(\n            start_of_leftovers + morsels_in_leftover - 1,\n            last_symbol,\n        ));\n    }\n\n    let mut leftover_bits_appended_to_buf = 0;\n    while leftover_bits_appended_to_buf < leftover_bits_ready_to_append {\n        // `as` simply truncates the higher bits, which is what we want here\n        let selected_bits = (leftover_bits >> (56 - leftover_bits_appended_to_buf)) as u8;\n        output[output_index] = selected_bits;\n        output_index += 1;\n\n        leftover_bits_appended_to_buf += 8;\n    }\n\n    Ok(output_index)\n}\n\n#[inline]\nfn write_u64(output: &mut [u8], value: u64) {\n    output[..8].copy_from_slice(&value.to_be_bytes());\n}\n\n/// Decode 8 bytes of input into 6 bytes of output. 8 bytes of output will be written, but only the\n/// first 6 of those contain meaningful data.\n///\n/// `input` is the bytes to decode, of which the first 8 bytes will be processed.\n/// `index_at_start_of_input` is the offset in the overall input (used for reporting errors\n/// accurately)\n/// `decode_table` is the lookup table for the particular base64 alphabet.\n/// `output` will have its first 8 bytes overwritten, of which only the first 6 are valid decoded\n/// data.\n// yes, really inline (worth 30-50% speedup)\n#[inline(always)]\nfn decode_chunk(\n    input: &[u8],\n    index_at_start_of_input: usize,\n    decode_table: &[u8; 256],\n    output: &mut [u8],\n) -> Result<(), DecodeError> {\n    let mut accum: u64;\n\n    let morsel = decode_table[input[0] as usize];\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(index_at_start_of_input, input[0]));\n    }\n    accum = (morsel as u64) << 58;\n\n    let morsel = decode_table[input[1] as usize];\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 1,\n            input[1],\n        ));\n    }\n    accum |= (morsel as u64) << 52;\n\n    let morsel = decode_table[input[2] as usize];\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 2,\n            input[2],\n        ));\n    }\n    accum |= (morsel as u64) << 46;\n\n    let morsel = decode_table[input[3] as usize];\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 3,\n            input[3],\n        ));\n    }\n    accum |= (morsel as u64) << 40;\n\n    let morsel = decode_table[input[4] as usize];\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 4,\n            input[4],\n        ));\n    }\n    accum |= (morsel as u64) << 34;\n\n    let morsel = decode_table[input[5] as usize];\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 5,\n            input[5],\n        ));\n    }\n    accum |= (morsel as u64) << 28;\n\n    let morsel = decode_table[input[6] as usize];\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 6,\n            input[6],\n        ));\n    }\n    accum |= (morsel as u64) << 22;\n\n    let morsel = decode_table[input[7] as usize];\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 7,\n            input[7],\n        ));\n    }\n    accum |= (morsel as u64) << 16;\n\n    write_u64(output, accum);\n\n    Ok(())\n}\n\n/// Decode an 8-byte chunk, but only write the 6 bytes actually decoded instead of including 2\n/// trailing garbage bytes.\n#[inline]\nfn decode_chunk_precise(\n    input: &[u8],\n    index_at_start_of_input: usize,\n    decode_table: &[u8; 256],\n    output: &mut [u8],\n) -> Result<(), DecodeError> {\n    let mut tmp_buf = [0_u8; 8];\n\n    decode_chunk(\n        input,\n        index_at_start_of_input,\n        decode_table,\n        &mut tmp_buf[..],\n    )?;\n\n    output[0..6].copy_from_slice(&tmp_buf[0..6]);\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        encode::encode_config_buf,\n        encode::encode_config_slice,\n        tests::{assert_encode_sanity, random_config},\n    };\n\n    use rand::{\n        distributions::{Distribution, Uniform},\n        FromEntropy, Rng,\n    };\n\n    #[test]\n    fn decode_chunk_precise_writes_only_6_bytes() {\n        let input = b\"Zm9vYmFy\"; // \"foobar\"\n        let mut output = [0_u8, 1, 2, 3, 4, 5, 6, 7];\n        decode_chunk_precise(&input[..], 0, tables::STANDARD_DECODE, &mut output).unwrap();\n        assert_eq!(&vec![b'f', b'o', b'o', b'b', b'a', b'r', 6, 7], &output);\n    }\n\n    #[test]\n    fn decode_chunk_writes_8_bytes() {\n        let input = b\"Zm9vYmFy\"; // \"foobar\"\n        let mut output = [0_u8, 1, 2, 3, 4, 5, 6, 7];\n        decode_chunk(&input[..], 0, tables::STANDARD_DECODE, &mut output).unwrap();\n        assert_eq!(&vec![b'f', b'o', b'o', b'b', b'a', b'r', 0, 0], &output);\n    }\n\n    #[test]\n    fn decode_into_nonempty_vec_doesnt_clobber_existing_prefix() {\n        let mut orig_data = Vec::new();\n        let mut encoded_data = String::new();\n        let mut decoded_with_prefix = Vec::new();\n        let mut decoded_without_prefix = Vec::new();\n        let mut prefix = Vec::new();\n\n        let prefix_len_range = Uniform::new(0, 1000);\n        let input_len_range = Uniform::new(0, 1000);\n\n        let mut rng = rand::rngs::SmallRng::from_entropy();\n\n        for _ in 0..10_000 {\n            orig_data.clear();\n            encoded_data.clear();\n            decoded_with_prefix.clear();\n            decoded_without_prefix.clear();\n            prefix.clear();\n\n            let input_len = input_len_range.sample(&mut rng);\n\n            for _ in 0..input_len {\n                orig_data.push(rng.gen());\n            }\n\n            let config = random_config(&mut rng);\n            encode_config_buf(&orig_data, config, &mut encoded_data);\n            assert_encode_sanity(&encoded_data, config, input_len);\n\n            let prefix_len = prefix_len_range.sample(&mut rng);\n\n            // fill the buf with a prefix\n            for _ in 0..prefix_len {\n                prefix.push(rng.gen());\n            }\n\n            decoded_with_prefix.resize(prefix_len, 0);\n            decoded_with_prefix.copy_from_slice(&prefix);\n\n            // decode into the non-empty buf\n            decode_config_buf(&encoded_data, config, &mut decoded_with_prefix).unwrap();\n            // also decode into the empty buf\n            decode_config_buf(&encoded_data, config, &mut decoded_without_prefix).unwrap();\n\n            assert_eq!(\n                prefix_len + decoded_without_prefix.len(),\n                decoded_with_prefix.len()\n            );\n            assert_eq!(orig_data, decoded_without_prefix);\n\n            // append plain decode onto prefix\n            prefix.append(&mut decoded_without_prefix);\n\n            assert_eq!(prefix, decoded_with_prefix);\n        }\n    }\n\n    #[test]\n    fn decode_into_slice_doesnt_clobber_existing_prefix_or_suffix() {\n        let mut orig_data = Vec::new();\n        let mut encoded_data = String::new();\n        let mut decode_buf = Vec::new();\n        let mut decode_buf_copy: Vec<u8> = Vec::new();\n\n        let input_len_range = Uniform::new(0, 1000);\n\n        let mut rng = rand::rngs::SmallRng::from_entropy();\n\n        for _ in 0..10_000 {\n            orig_data.clear();\n            encoded_data.clear();\n            decode_buf.clear();\n            decode_buf_copy.clear();\n\n            let input_len = input_len_range.sample(&mut rng);\n\n            for _ in 0..input_len {\n                orig_data.push(rng.gen());\n            }\n\n            let config = random_config(&mut rng);\n            encode_config_buf(&orig_data, config, &mut encoded_data);\n            assert_encode_sanity(&encoded_data, config, input_len);\n\n            // fill the buffer with random garbage, long enough to have some room before and after\n            for _ in 0..5000 {\n                decode_buf.push(rng.gen());\n            }\n\n            // keep a copy for later comparison\n            decode_buf_copy.extend(decode_buf.iter());\n\n            let offset = 1000;\n\n            // decode into the non-empty buf\n            let decode_bytes_written =\n                decode_config_slice(&encoded_data, config, &mut decode_buf[offset..]).unwrap();\n\n            assert_eq!(orig_data.len(), decode_bytes_written);\n            assert_eq!(\n                orig_data,\n                &decode_buf[offset..(offset + decode_bytes_written)]\n            );\n            assert_eq!(&decode_buf_copy[0..offset], &decode_buf[0..offset]);\n            assert_eq!(\n                &decode_buf_copy[offset + decode_bytes_written..],\n                &decode_buf[offset + decode_bytes_written..]\n            );\n        }\n    }\n\n    #[test]\n    fn decode_into_slice_fits_in_precisely_sized_slice() {\n        let mut orig_data = Vec::new();\n        let mut encoded_data = String::new();\n        let mut decode_buf = Vec::new();\n\n        let input_len_range = Uniform::new(0, 1000);\n\n        let mut rng = rand::rngs::SmallRng::from_entropy();\n\n        for _ in 0..10_000 {\n            orig_data.clear();\n            encoded_data.clear();\n            decode_buf.clear();\n\n            let input_len = input_len_range.sample(&mut rng);\n\n            for _ in 0..input_len {\n                orig_data.push(rng.gen());\n            }\n\n            let config = random_config(&mut rng);\n            encode_config_buf(&orig_data, config, &mut encoded_data);\n            assert_encode_sanity(&encoded_data, config, input_len);\n\n            decode_buf.resize(input_len, 0);\n\n            // decode into the non-empty buf\n            let decode_bytes_written =\n                decode_config_slice(&encoded_data, config, &mut decode_buf[..]).unwrap();\n\n            assert_eq!(orig_data.len(), decode_bytes_written);\n            assert_eq!(orig_data, decode_buf);\n        }\n    }\n\n    #[test]\n    fn detect_invalid_last_symbol_two_bytes() {\n        let decode =\n            |input, forgiving| decode_config(input, STANDARD.decode_allow_trailing_bits(forgiving));\n\n        // example from https://github.com/marshallpierce/rust-base64/issues/75\n        assert!(decode(\"iYU=\", false).is_ok());\n        // trailing 01\n        assert_eq!(\n            Err(DecodeError::InvalidLastSymbol(2, b'V')),\n            decode(\"iYV=\", false)\n        );\n        assert_eq!(Ok(vec![137, 133]), decode(\"iYV=\", true));\n        // trailing 10\n        assert_eq!(\n            Err(DecodeError::InvalidLastSymbol(2, b'W')),\n            decode(\"iYW=\", false)\n        );\n        assert_eq!(Ok(vec![137, 133]), decode(\"iYV=\", true));\n        // trailing 11\n        assert_eq!(\n            Err(DecodeError::InvalidLastSymbol(2, b'X')),\n            decode(\"iYX=\", false)\n        );\n        assert_eq!(Ok(vec![137, 133]), decode(\"iYV=\", true));\n\n        // also works when there are 2 quads in the last block\n        assert_eq!(\n            Err(DecodeError::InvalidLastSymbol(6, b'X')),\n            decode(\"AAAAiYX=\", false)\n        );\n        assert_eq!(Ok(vec![0, 0, 0, 137, 133]), decode(\"AAAAiYX=\", true));\n    }\n\n    #[test]\n    fn detect_invalid_last_symbol_one_byte() {\n        // 0xFF -> \"/w==\", so all letters > w, 0-9, and '+', '/' should get InvalidLastSymbol\n\n        assert!(decode(\"/w==\").is_ok());\n        // trailing 01\n        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'x')), decode(\"/x==\"));\n        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'z')), decode(\"/z==\"));\n        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'0')), decode(\"/0==\"));\n        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'9')), decode(\"/9==\"));\n        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'+')), decode(\"/+==\"));\n        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'/')), decode(\"//==\"));\n\n        // also works when there are 2 quads in the last block\n        assert_eq!(\n            Err(DecodeError::InvalidLastSymbol(5, b'x')),\n            decode(\"AAAA/x==\")\n        );\n    }\n\n    #[test]\n    fn detect_invalid_last_symbol_every_possible_three_symbols() {\n        let mut base64_to_bytes = ::std::collections::HashMap::new();\n\n        let mut bytes = [0_u8; 2];\n        for b1 in 0_u16..256 {\n            bytes[0] = b1 as u8;\n            for b2 in 0_u16..256 {\n                bytes[1] = b2 as u8;\n                let mut b64 = vec![0_u8; 4];\n                assert_eq!(4, encode_config_slice(&bytes, STANDARD, &mut b64[..]));\n                let mut v = ::std::vec::Vec::with_capacity(2);\n                v.extend_from_slice(&bytes[..]);\n\n                assert!(base64_to_bytes.insert(b64, v).is_none());\n            }\n        }\n\n        // every possible combination of symbols must either decode to 2 bytes or get InvalidLastSymbol\n\n        let mut symbols = [0_u8; 4];\n        for &s1 in STANDARD.char_set.encode_table().iter() {\n            symbols[0] = s1;\n            for &s2 in STANDARD.char_set.encode_table().iter() {\n                symbols[1] = s2;\n                for &s3 in STANDARD.char_set.encode_table().iter() {\n                    symbols[2] = s3;\n                    symbols[3] = PAD_BYTE;\n\n                    match base64_to_bytes.get(&symbols[..]) {\n                        Some(bytes) => {\n                            assert_eq!(Ok(bytes.to_vec()), decode_config(&symbols, STANDARD))\n                        }\n                        None => assert_eq!(\n                            Err(DecodeError::InvalidLastSymbol(2, s3)),\n                            decode_config(&symbols[..], STANDARD)\n                        ),\n                    }\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn detect_invalid_last_symbol_every_possible_two_symbols() {\n        let mut base64_to_bytes = ::std::collections::HashMap::new();\n\n        for b in 0_u16..256 {\n            let mut b64 = vec![0_u8; 4];\n            assert_eq!(4, encode_config_slice(&[b as u8], STANDARD, &mut b64[..]));\n            let mut v = ::std::vec::Vec::with_capacity(1);\n            v.push(b as u8);\n\n            assert!(base64_to_bytes.insert(b64, v).is_none());\n        }\n\n        // every possible combination of symbols must either decode to 1 byte or get InvalidLastSymbol\n\n        let mut symbols = [0_u8; 4];\n        for &s1 in STANDARD.char_set.encode_table().iter() {\n            symbols[0] = s1;\n            for &s2 in STANDARD.char_set.encode_table().iter() {\n                symbols[1] = s2;\n                symbols[2] = PAD_BYTE;\n                symbols[3] = PAD_BYTE;\n\n                match base64_to_bytes.get(&symbols[..]) {\n                    Some(bytes) => {\n                        assert_eq!(Ok(bytes.to_vec()), decode_config(&symbols, STANDARD))\n                    }\n                    None => assert_eq!(\n                        Err(DecodeError::InvalidLastSymbol(1, s2)),\n                        decode_config(&symbols[..], STANDARD)\n                    ),\n                }\n            }\n        }\n    }\n}\n", "//! # Configs\n//!\n//! There isn't just one type of Base64; that would be too simple. You need to choose a character\n//! set (standard, URL-safe, etc) and padding suffix (yes/no).\n//! The `Config` struct encapsulates this info. There are some common configs included: `STANDARD`,\n//! `URL_SAFE`, etc. You can also make your own `Config` if needed.\n//!\n//! The functions that don't have `config` in the name (e.g. `encode()` and `decode()`) use the\n//! `STANDARD` config .\n//!\n//! The functions that write to a slice (the ones that end in `_slice`) are generally the fastest\n//! because they don't need to resize anything. If it fits in your workflow and you care about\n//! performance, keep using the same buffer (growing as need be) and use the `_slice` methods for\n//! the best performance.\n//!\n//! # Encoding\n//!\n//! Several different encoding functions are available to you depending on your desire for\n//! convenience vs performance.\n//!\n//! | Function                | Output                       | Allocates                      |\n//! | ----------------------- | ---------------------------- | ------------------------------ |\n//! | `encode`                | Returns a new `String`       | Always                         |\n//! | `encode_config`         | Returns a new `String`       | Always                         |\n//! | `encode_config_buf`     | Appends to provided `String` | Only if `String` needs to grow |\n//! | `encode_config_slice`   | Writes to provided `&[u8]`   | Never                          |\n//!\n//! All of the encoding functions that take a `Config` will pad as per the config.\n//!\n//! # Decoding\n//!\n//! Just as for encoding, there are different decoding functions available.\n//!\n//! | Function                | Output                        | Allocates                      |\n//! | ----------------------- | ----------------------------- | ------------------------------ |\n//! | `decode`                | Returns a new `Vec<u8>`       | Always                         |\n//! | `decode_config`         | Returns a new `Vec<u8>`       | Always                         |\n//! | `decode_config_buf`     | Appends to provided `Vec<u8>` | Only if `Vec` needs to grow    |\n//! | `decode_config_slice`   | Writes to provided `&[u8]`    | Never                          |\n//!\n//! Unlike encoding, where all possible input is valid, decoding can fail (see `DecodeError`).\n//!\n//! Input can be invalid because it has invalid characters or invalid padding. (No padding at all is\n//! valid, but excess padding is not.) Whitespace in the input is invalid.\n//!\n//! # `Read` and `Write`\n//!\n//! To map a `Read` of b64 bytes to the decoded bytes, wrap a reader (file, network socket, etc)\n//! with `base64::read::DecoderReader`. To write raw bytes and have them b64 encoded on the fly,\n//! wrap a writer with `base64::write::EncoderWriter`. There is some performance overhead (15% or\n//! so) because of the necessary buffer shuffling -- still fast enough that almost nobody cares.\n//! Also, these implementations do not heap allocate.\n//!\n//! # Panics\n//!\n//! If length calculations result in overflowing `usize`, a panic will result.\n//!\n//! The `_slice` flavors of encode or decode will panic if the provided output slice is too small,\n\n#![cfg_attr(feature = \"cargo-clippy\", allow(clippy::cast_lossless))]\n#![deny(\n    missing_docs,\n    trivial_casts,\n    trivial_numeric_casts,\n    unused_extern_crates,\n    unused_import_braces,\n    unused_results,\n    variant_size_differences,\n    warnings\n)]\n#![forbid(unsafe_code)]\n#![cfg_attr(not(any(feature = \"std\", test)), no_std)]\n\n#[cfg(all(feature = \"alloc\", not(any(feature = \"std\", test))))]\nextern crate alloc;\n#[cfg(any(feature = \"std\", test))]\nextern crate std as alloc;\n\nmod chunked_encoder;\npub mod display;\n#[cfg(any(feature = \"std\", test))]\npub mod read;\nmod tables;\n#[cfg(any(feature = \"std\", test))]\npub mod write;\n\nmod encode;\npub use crate::encode::encode_config_slice;\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub use crate::encode::{encode, encode_config, encode_config_buf};\n\nmod decode;\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub use crate::decode::{decode, decode_config, decode_config_buf};\npub use crate::decode::{decode_config_slice, DecodeError};\n\n#[cfg(test)]\nmod tests;\n\n/// Available encoding character sets\n#[derive(Clone, Copy, Debug)]\npub enum CharacterSet {\n    /// The standard character set (uses `+` and `/`).\n    ///\n    /// See [RFC 3548](https://tools.ietf.org/html/rfc3548#section-3).\n    Standard,\n    /// The URL safe character set (uses `-` and `_`).\n    ///\n    /// See [RFC 3548](https://tools.ietf.org/html/rfc3548#section-4).\n    UrlSafe,\n    /// The `crypt(3)` character set (uses `./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`).\n    ///\n    /// Not standardized, but folk wisdom on the net asserts that this alphabet is what crypt uses.\n    Crypt,\n    /// The bcrypt character set (uses `./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789`).\n    Bcrypt,\n    /// The character set used in IMAP-modified UTF-7 (uses `+` and `,`).\n    ///\n    /// See [RFC 3501](https://tools.ietf.org/html/rfc3501#section-5.1.3)\n    ImapMutf7,\n    /// The character set used in BinHex 4.0 files.\n    ///\n    /// See [BinHex 4.0 Definition](http://files.stairways.com/other/binhex-40-specs-info.txt)\n    BinHex,\n}\n\nimpl CharacterSet {\n    fn encode_table(self) -> &'static [u8; 64] {\n        match self {\n            CharacterSet::Standard => tables::STANDARD_ENCODE,\n            CharacterSet::UrlSafe => tables::URL_SAFE_ENCODE,\n            CharacterSet::Crypt => tables::CRYPT_ENCODE,\n            CharacterSet::Bcrypt => tables::BCRYPT_ENCODE,\n            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_ENCODE,\n            CharacterSet::BinHex => tables::BINHEX_ENCODE,\n        }\n    }\n\n    fn decode_table(self) -> &'static [u8; 256] {\n        match self {\n            CharacterSet::Standard => tables::STANDARD_DECODE,\n            CharacterSet::UrlSafe => tables::URL_SAFE_DECODE,\n            CharacterSet::Crypt => tables::CRYPT_DECODE,\n            CharacterSet::Bcrypt => tables::BCRYPT_DECODE,\n            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_DECODE,\n            CharacterSet::BinHex => tables::BINHEX_DECODE,\n        }\n    }\n}\n\n/// Contains configuration parameters for base64 encoding\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    /// Character set to use\n    char_set: CharacterSet,\n    /// True to pad output with `=` characters\n    pad: bool,\n    /// True to ignore excess nonzero bits in the last few symbols, otherwise an error is returned.\n    decode_allow_trailing_bits: bool,\n}\n\nimpl Config {\n    /// Create a new `Config`.\n    pub const fn new(char_set: CharacterSet, pad: bool) -> Config {\n        Config {\n            char_set,\n            pad,\n            decode_allow_trailing_bits: false,\n        }\n    }\n\n    /// Sets whether to pad output with `=` characters.\n    pub const fn pad(self, pad: bool) -> Config {\n        Config { pad, ..self }\n    }\n\n    /// Sets whether to emit errors for nonzero trailing bits.\n    ///\n    /// This is useful when implementing\n    /// [forgiving-base64 decode](https://infra.spec.whatwg.org/#forgiving-base64-decode).\n    pub const fn decode_allow_trailing_bits(self, allow: bool) -> Config {\n        Config {\n            decode_allow_trailing_bits: allow,\n            ..self\n        }\n    }\n}\n\n/// Standard character set with padding.\npub const STANDARD: Config = Config {\n    char_set: CharacterSet::Standard,\n    pad: true,\n    decode_allow_trailing_bits: false,\n};\n\n/// Standard character set without padding.\npub const STANDARD_NO_PAD: Config = Config {\n    char_set: CharacterSet::Standard,\n    pad: false,\n    decode_allow_trailing_bits: false,\n};\n\n/// URL-safe character set with padding\npub const URL_SAFE: Config = Config {\n    char_set: CharacterSet::UrlSafe,\n    pad: true,\n    decode_allow_trailing_bits: false,\n};\n\n/// URL-safe character set without padding\npub const URL_SAFE_NO_PAD: Config = Config {\n    char_set: CharacterSet::UrlSafe,\n    pad: false,\n    decode_allow_trailing_bits: false,\n};\n\n/// As per `crypt(3)` requirements\npub const CRYPT: Config = Config {\n    char_set: CharacterSet::Crypt,\n    pad: false,\n    decode_allow_trailing_bits: false,\n};\n\n/// Bcrypt character set\npub const BCRYPT: Config = Config {\n    char_set: CharacterSet::Bcrypt,\n    pad: false,\n    decode_allow_trailing_bits: false,\n};\n\n/// IMAP modified UTF-7 requirements\npub const IMAP_MUTF7: Config = Config {\n    char_set: CharacterSet::ImapMutf7,\n    pad: false,\n    decode_allow_trailing_bits: false,\n};\n\n/// BinHex character set\npub const BINHEX: Config = Config {\n    char_set: CharacterSet::BinHex,\n    pad: false,\n    decode_allow_trailing_bits: false,\n};\n\nconst PAD_BYTE: u8 = b'=';\n", "pub const INVALID_VALUE: u8 = 255;\n#[rustfmt::skip]\npub const STANDARD_ENCODE: &[u8; 64] = &[\n    65, // input 0 (0x0) => 'A' (0x41)\n    66, // input 1 (0x1) => 'B' (0x42)\n    67, // input 2 (0x2) => 'C' (0x43)\n    68, // input 3 (0x3) => 'D' (0x44)\n    69, // input 4 (0x4) => 'E' (0x45)\n    70, // input 5 (0x5) => 'F' (0x46)\n    71, // input 6 (0x6) => 'G' (0x47)\n    72, // input 7 (0x7) => 'H' (0x48)\n    73, // input 8 (0x8) => 'I' (0x49)\n    74, // input 9 (0x9) => 'J' (0x4A)\n    75, // input 10 (0xA) => 'K' (0x4B)\n    76, // input 11 (0xB) => 'L' (0x4C)\n    77, // input 12 (0xC) => 'M' (0x4D)\n    78, // input 13 (0xD) => 'N' (0x4E)\n    79, // input 14 (0xE) => 'O' (0x4F)\n    80, // input 15 (0xF) => 'P' (0x50)\n    81, // input 16 (0x10) => 'Q' (0x51)\n    82, // input 17 (0x11) => 'R' (0x52)\n    83, // input 18 (0x12) => 'S' (0x53)\n    84, // input 19 (0x13) => 'T' (0x54)\n    85, // input 20 (0x14) => 'U' (0x55)\n    86, // input 21 (0x15) => 'V' (0x56)\n    87, // input 22 (0x16) => 'W' (0x57)\n    88, // input 23 (0x17) => 'X' (0x58)\n    89, // input 24 (0x18) => 'Y' (0x59)\n    90, // input 25 (0x19) => 'Z' (0x5A)\n    97, // input 26 (0x1A) => 'a' (0x61)\n    98, // input 27 (0x1B) => 'b' (0x62)\n    99, // input 28 (0x1C) => 'c' (0x63)\n    100, // input 29 (0x1D) => 'd' (0x64)\n    101, // input 30 (0x1E) => 'e' (0x65)\n    102, // input 31 (0x1F) => 'f' (0x66)\n    103, // input 32 (0x20) => 'g' (0x67)\n    104, // input 33 (0x21) => 'h' (0x68)\n    105, // input 34 (0x22) => 'i' (0x69)\n    106, // input 35 (0x23) => 'j' (0x6A)\n    107, // input 36 (0x24) => 'k' (0x6B)\n    108, // input 37 (0x25) => 'l' (0x6C)\n    109, // input 38 (0x26) => 'm' (0x6D)\n    110, // input 39 (0x27) => 'n' (0x6E)\n    111, // input 40 (0x28) => 'o' (0x6F)\n    112, // input 41 (0x29) => 'p' (0x70)\n    113, // input 42 (0x2A) => 'q' (0x71)\n    114, // input 43 (0x2B) => 'r' (0x72)\n    115, // input 44 (0x2C) => 's' (0x73)\n    116, // input 45 (0x2D) => 't' (0x74)\n    117, // input 46 (0x2E) => 'u' (0x75)\n    118, // input 47 (0x2F) => 'v' (0x76)\n    119, // input 48 (0x30) => 'w' (0x77)\n    120, // input 49 (0x31) => 'x' (0x78)\n    121, // input 50 (0x32) => 'y' (0x79)\n    122, // input 51 (0x33) => 'z' (0x7A)\n    48, // input 52 (0x34) => '0' (0x30)\n    49, // input 53 (0x35) => '1' (0x31)\n    50, // input 54 (0x36) => '2' (0x32)\n    51, // input 55 (0x37) => '3' (0x33)\n    52, // input 56 (0x38) => '4' (0x34)\n    53, // input 57 (0x39) => '5' (0x35)\n    54, // input 58 (0x3A) => '6' (0x36)\n    55, // input 59 (0x3B) => '7' (0x37)\n    56, // input 60 (0x3C) => '8' (0x38)\n    57, // input 61 (0x3D) => '9' (0x39)\n    43, // input 62 (0x3E) => '+' (0x2B)\n    47, // input 63 (0x3F) => '/' (0x2F)\n];\n#[rustfmt::skip]\npub const STANDARD_DECODE: &[u8; 256] = &[\n    INVALID_VALUE, // input 0 (0x0)\n    INVALID_VALUE, // input 1 (0x1)\n    INVALID_VALUE, // input 2 (0x2)\n    INVALID_VALUE, // input 3 (0x3)\n    INVALID_VALUE, // input 4 (0x4)\n    INVALID_VALUE, // input 5 (0x5)\n    INVALID_VALUE, // input 6 (0x6)\n    INVALID_VALUE, // input 7 (0x7)\n    INVALID_VALUE, // input 8 (0x8)\n    INVALID_VALUE, // input 9 (0x9)\n    INVALID_VALUE, // input 10 (0xA)\n    INVALID_VALUE, // input 11 (0xB)\n    INVALID_VALUE, // input 12 (0xC)\n    INVALID_VALUE, // input 13 (0xD)\n    INVALID_VALUE, // input 14 (0xE)\n    INVALID_VALUE, // input 15 (0xF)\n    INVALID_VALUE, // input 16 (0x10)\n    INVALID_VALUE, // input 17 (0x11)\n    INVALID_VALUE, // input 18 (0x12)\n    INVALID_VALUE, // input 19 (0x13)\n    INVALID_VALUE, // input 20 (0x14)\n    INVALID_VALUE, // input 21 (0x15)\n    INVALID_VALUE, // input 22 (0x16)\n    INVALID_VALUE, // input 23 (0x17)\n    INVALID_VALUE, // input 24 (0x18)\n    INVALID_VALUE, // input 25 (0x19)\n    INVALID_VALUE, // input 26 (0x1A)\n    INVALID_VALUE, // input 27 (0x1B)\n    INVALID_VALUE, // input 28 (0x1C)\n    INVALID_VALUE, // input 29 (0x1D)\n    INVALID_VALUE, // input 30 (0x1E)\n    INVALID_VALUE, // input 31 (0x1F)\n    INVALID_VALUE, // input 32 (0x20)\n    INVALID_VALUE, // input 33 (0x21)\n    INVALID_VALUE, // input 34 (0x22)\n    INVALID_VALUE, // input 35 (0x23)\n    INVALID_VALUE, // input 36 (0x24)\n    INVALID_VALUE, // input 37 (0x25)\n    INVALID_VALUE, // input 38 (0x26)\n    INVALID_VALUE, // input 39 (0x27)\n    INVALID_VALUE, // input 40 (0x28)\n    INVALID_VALUE, // input 41 (0x29)\n    INVALID_VALUE, // input 42 (0x2A)\n    62, // input 43 (0x2B char '+') => 62 (0x3E)\n    INVALID_VALUE, // input 44 (0x2C)\n    INVALID_VALUE, // input 45 (0x2D)\n    INVALID_VALUE, // input 46 (0x2E)\n    63, // input 47 (0x2F char '/') => 63 (0x3F)\n    52, // input 48 (0x30 char '0') => 52 (0x34)\n    53, // input 49 (0x31 char '1') => 53 (0x35)\n    54, // input 50 (0x32 char '2') => 54 (0x36)\n    55, // input 51 (0x33 char '3') => 55 (0x37)\n    56, // input 52 (0x34 char '4') => 56 (0x38)\n    57, // input 53 (0x35 char '5') => 57 (0x39)\n    58, // input 54 (0x36 char '6') => 58 (0x3A)\n    59, // input 55 (0x37 char '7') => 59 (0x3B)\n    60, // input 56 (0x38 char '8') => 60 (0x3C)\n    61, // input 57 (0x39 char '9') => 61 (0x3D)\n    INVALID_VALUE, // input 58 (0x3A)\n    INVALID_VALUE, // input 59 (0x3B)\n    INVALID_VALUE, // input 60 (0x3C)\n    INVALID_VALUE, // input 61 (0x3D)\n    INVALID_VALUE, // input 62 (0x3E)\n    INVALID_VALUE, // input 63 (0x3F)\n    INVALID_VALUE, // input 64 (0x40)\n    0, // input 65 (0x41 char 'A') => 0 (0x0)\n    1, // input 66 (0x42 char 'B') => 1 (0x1)\n    2, // input 67 (0x43 char 'C') => 2 (0x2)\n    3, // input 68 (0x44 char 'D') => 3 (0x3)\n    4, // input 69 (0x45 char 'E') => 4 (0x4)\n    5, // input 70 (0x46 char 'F') => 5 (0x5)\n    6, // input 71 (0x47 char 'G') => 6 (0x6)\n    7, // input 72 (0x48 char 'H') => 7 (0x7)\n    8, // input 73 (0x49 char 'I') => 8 (0x8)\n    9, // input 74 (0x4A char 'J') => 9 (0x9)\n    10, // input 75 (0x4B char 'K') => 10 (0xA)\n    11, // input 76 (0x4C char 'L') => 11 (0xB)\n    12, // input 77 (0x4D char 'M') => 12 (0xC)\n    13, // input 78 (0x4E char 'N') => 13 (0xD)\n    14, // input 79 (0x4F char 'O') => 14 (0xE)\n    15, // input 80 (0x50 char 'P') => 15 (0xF)\n    16, // input 81 (0x51 char 'Q') => 16 (0x10)\n    17, // input 82 (0x52 char 'R') => 17 (0x11)\n    18, // input 83 (0x53 char 'S') => 18 (0x12)\n    19, // input 84 (0x54 char 'T') => 19 (0x13)\n    20, // input 85 (0x55 char 'U') => 20 (0x14)\n    21, // input 86 (0x56 char 'V') => 21 (0x15)\n    22, // input 87 (0x57 char 'W') => 22 (0x16)\n    23, // input 88 (0x58 char 'X') => 23 (0x17)\n    24, // input 89 (0x59 char 'Y') => 24 (0x18)\n    25, // input 90 (0x5A char 'Z') => 25 (0x19)\n    INVALID_VALUE, // input 91 (0x5B)\n    INVALID_VALUE, // input 92 (0x5C)\n    INVALID_VALUE, // input 93 (0x5D)\n    INVALID_VALUE, // input 94 (0x5E)\n    INVALID_VALUE, // input 95 (0x5F)\n    INVALID_VALUE, // input 96 (0x60)\n    26, // input 97 (0x61 char 'a') => 26 (0x1A)\n    27, // input 98 (0x62 char 'b') => 27 (0x1B)\n    28, // input 99 (0x63 char 'c') => 28 (0x1C)\n    29, // input 100 (0x64 char 'd') => 29 (0x1D)\n    30, // input 101 (0x65 char 'e') => 30 (0x1E)\n    31, // input 102 (0x66 char 'f') => 31 (0x1F)\n    32, // input 103 (0x67 char 'g') => 32 (0x20)\n    33, // input 104 (0x68 char 'h') => 33 (0x21)\n    34, // input 105 (0x69 char 'i') => 34 (0x22)\n    35, // input 106 (0x6A char 'j') => 35 (0x23)\n    36, // input 107 (0x6B char 'k') => 36 (0x24)\n    37, // input 108 (0x6C char 'l') => 37 (0x25)\n    38, // input 109 (0x6D char 'm') => 38 (0x26)\n    39, // input 110 (0x6E char 'n') => 39 (0x27)\n    40, // input 111 (0x6F char 'o') => 40 (0x28)\n    41, // input 112 (0x70 char 'p') => 41 (0x29)\n    42, // input 113 (0x71 char 'q') => 42 (0x2A)\n    43, // input 114 (0x72 char 'r') => 43 (0x2B)\n    44, // input 115 (0x73 char 's') => 44 (0x2C)\n    45, // input 116 (0x74 char 't') => 45 (0x2D)\n    46, // input 117 (0x75 char 'u') => 46 (0x2E)\n    47, // input 118 (0x76 char 'v') => 47 (0x2F)\n    48, // input 119 (0x77 char 'w') => 48 (0x30)\n    49, // input 120 (0x78 char 'x') => 49 (0x31)\n    50, // input 121 (0x79 char 'y') => 50 (0x32)\n    51, // input 122 (0x7A char 'z') => 51 (0x33)\n    INVALID_VALUE, // input 123 (0x7B)\n    INVALID_VALUE, // input 124 (0x7C)\n    INVALID_VALUE, // input 125 (0x7D)\n    INVALID_VALUE, // input 126 (0x7E)\n    INVALID_VALUE, // input 127 (0x7F)\n    INVALID_VALUE, // input 128 (0x80)\n    INVALID_VALUE, // input 129 (0x81)\n    INVALID_VALUE, // input 130 (0x82)\n    INVALID_VALUE, // input 131 (0x83)\n    INVALID_VALUE, // input 132 (0x84)\n    INVALID_VALUE, // input 133 (0x85)\n    INVALID_VALUE, // input 134 (0x86)\n    INVALID_VALUE, // input 135 (0x87)\n    INVALID_VALUE, // input 136 (0x88)\n    INVALID_VALUE, // input 137 (0x89)\n    INVALID_VALUE, // input 138 (0x8A)\n    INVALID_VALUE, // input 139 (0x8B)\n    INVALID_VALUE, // input 140 (0x8C)\n    INVALID_VALUE, // input 141 (0x8D)\n    INVALID_VALUE, // input 142 (0x8E)\n    INVALID_VALUE, // input 143 (0x8F)\n    INVALID_VALUE, // input 144 (0x90)\n    INVALID_VALUE, // input 145 (0x91)\n    INVALID_VALUE, // input 146 (0x92)\n    INVALID_VALUE, // input 147 (0x93)\n    INVALID_VALUE, // input 148 (0x94)\n    INVALID_VALUE, // input 149 (0x95)\n    INVALID_VALUE, // input 150 (0x96)\n    INVALID_VALUE, // input 151 (0x97)\n    INVALID_VALUE, // input 152 (0x98)\n    INVALID_VALUE, // input 153 (0x99)\n    INVALID_VALUE, // input 154 (0x9A)\n    INVALID_VALUE, // input 155 (0x9B)\n    INVALID_VALUE, // input 156 (0x9C)\n    INVALID_VALUE, // input 157 (0x9D)\n    INVALID_VALUE, // input 158 (0x9E)\n    INVALID_VALUE, // input 159 (0x9F)\n    INVALID_VALUE, // input 160 (0xA0)\n    INVALID_VALUE, // input 161 (0xA1)\n    INVALID_VALUE, // input 162 (0xA2)\n    INVALID_VALUE, // input 163 (0xA3)\n    INVALID_VALUE, // input 164 (0xA4)\n    INVALID_VALUE, // input 165 (0xA5)\n    INVALID_VALUE, // input 166 (0xA6)\n    INVALID_VALUE, // input 167 (0xA7)\n    INVALID_VALUE, // input 168 (0xA8)\n    INVALID_VALUE, // input 169 (0xA9)\n    INVALID_VALUE, // input 170 (0xAA)\n    INVALID_VALUE, // input 171 (0xAB)\n    INVALID_VALUE, // input 172 (0xAC)\n    INVALID_VALUE, // input 173 (0xAD)\n    INVALID_VALUE, // input 174 (0xAE)\n    INVALID_VALUE, // input 175 (0xAF)\n    INVALID_VALUE, // input 176 (0xB0)\n    INVALID_VALUE, // input 177 (0xB1)\n    INVALID_VALUE, // input 178 (0xB2)\n    INVALID_VALUE, // input 179 (0xB3)\n    INVALID_VALUE, // input 180 (0xB4)\n    INVALID_VALUE, // input 181 (0xB5)\n    INVALID_VALUE, // input 182 (0xB6)\n    INVALID_VALUE, // input 183 (0xB7)\n    INVALID_VALUE, // input 184 (0xB8)\n    INVALID_VALUE, // input 185 (0xB9)\n    INVALID_VALUE, // input 186 (0xBA)\n    INVALID_VALUE, // input 187 (0xBB)\n    INVALID_VALUE, // input 188 (0xBC)\n    INVALID_VALUE, // input 189 (0xBD)\n    INVALID_VALUE, // input 190 (0xBE)\n    INVALID_VALUE, // input 191 (0xBF)\n    INVALID_VALUE, // input 192 (0xC0)\n    INVALID_VALUE, // input 193 (0xC1)\n    INVALID_VALUE, // input 194 (0xC2)\n    INVALID_VALUE, // input 195 (0xC3)\n    INVALID_VALUE, // input 196 (0xC4)\n    INVALID_VALUE, // input 197 (0xC5)\n    INVALID_VALUE, // input 198 (0xC6)\n    INVALID_VALUE, // input 199 (0xC7)\n    INVALID_VALUE, // input 200 (0xC8)\n    INVALID_VALUE, // input 201 (0xC9)\n    INVALID_VALUE, // input 202 (0xCA)\n    INVALID_VALUE, // input 203 (0xCB)\n    INVALID_VALUE, // input 204 (0xCC)\n    INVALID_VALUE, // input 205 (0xCD)\n    INVALID_VALUE, // input 206 (0xCE)\n    INVALID_VALUE, // input 207 (0xCF)\n    INVALID_VALUE, // input 208 (0xD0)\n    INVALID_VALUE, // input 209 (0xD1)\n    INVALID_VALUE, // input 210 (0xD2)\n    INVALID_VALUE, // input 211 (0xD3)\n    INVALID_VALUE, // input 212 (0xD4)\n    INVALID_VALUE, // input 213 (0xD5)\n    INVALID_VALUE, // input 214 (0xD6)\n    INVALID_VALUE, // input 215 (0xD7)\n    INVALID_VALUE, // input 216 (0xD8)\n    INVALID_VALUE, // input 217 (0xD9)\n    INVALID_VALUE, // input 218 (0xDA)\n    INVALID_VALUE, // input 219 (0xDB)\n    INVALID_VALUE, // input 220 (0xDC)\n    INVALID_VALUE, // input 221 (0xDD)\n    INVALID_VALUE, // input 222 (0xDE)\n    INVALID_VALUE, // input 223 (0xDF)\n    INVALID_VALUE, // input 224 (0xE0)\n    INVALID_VALUE, // input 225 (0xE1)\n    INVALID_VALUE, // input 226 (0xE2)\n    INVALID_VALUE, // input 227 (0xE3)\n    INVALID_VALUE, // input 228 (0xE4)\n    INVALID_VALUE, // input 229 (0xE5)\n    INVALID_VALUE, // input 230 (0xE6)\n    INVALID_VALUE, // input 231 (0xE7)\n    INVALID_VALUE, // input 232 (0xE8)\n    INVALID_VALUE, // input 233 (0xE9)\n    INVALID_VALUE, // input 234 (0xEA)\n    INVALID_VALUE, // input 235 (0xEB)\n    INVALID_VALUE, // input 236 (0xEC)\n    INVALID_VALUE, // input 237 (0xED)\n    INVALID_VALUE, // input 238 (0xEE)\n    INVALID_VALUE, // input 239 (0xEF)\n    INVALID_VALUE, // input 240 (0xF0)\n    INVALID_VALUE, // input 241 (0xF1)\n    INVALID_VALUE, // input 242 (0xF2)\n    INVALID_VALUE, // input 243 (0xF3)\n    INVALID_VALUE, // input 244 (0xF4)\n    INVALID_VALUE, // input 245 (0xF5)\n    INVALID_VALUE, // input 246 (0xF6)\n    INVALID_VALUE, // input 247 (0xF7)\n    INVALID_VALUE, // input 248 (0xF8)\n    INVALID_VALUE, // input 249 (0xF9)\n    INVALID_VALUE, // input 250 (0xFA)\n    INVALID_VALUE, // input 251 (0xFB)\n    INVALID_VALUE, // input 252 (0xFC)\n    INVALID_VALUE, // input 253 (0xFD)\n    INVALID_VALUE, // input 254 (0xFE)\n    INVALID_VALUE, // input 255 (0xFF)\n];\n#[rustfmt::skip]\npub const URL_SAFE_ENCODE: &[u8; 64] = &[\n    65, // input 0 (0x0) => 'A' (0x41)\n    66, // input 1 (0x1) => 'B' (0x42)\n    67, // input 2 (0x2) => 'C' (0x43)\n    68, // input 3 (0x3) => 'D' (0x44)\n    69, // input 4 (0x4) => 'E' (0x45)\n    70, // input 5 (0x5) => 'F' (0x46)\n    71, // input 6 (0x6) => 'G' (0x47)\n    72, // input 7 (0x7) => 'H' (0x48)\n    73, // input 8 (0x8) => 'I' (0x49)\n    74, // input 9 (0x9) => 'J' (0x4A)\n    75, // input 10 (0xA) => 'K' (0x4B)\n    76, // input 11 (0xB) => 'L' (0x4C)\n    77, // input 12 (0xC) => 'M' (0x4D)\n    78, // input 13 (0xD) => 'N' (0x4E)\n    79, // input 14 (0xE) => 'O' (0x4F)\n    80, // input 15 (0xF) => 'P' (0x50)\n    81, // input 16 (0x10) => 'Q' (0x51)\n    82, // input 17 (0x11) => 'R' (0x52)\n    83, // input 18 (0x12) => 'S' (0x53)\n    84, // input 19 (0x13) => 'T' (0x54)\n    85, // input 20 (0x14) => 'U' (0x55)\n    86, // input 21 (0x15) => 'V' (0x56)\n    87, // input 22 (0x16) => 'W' (0x57)\n    88, // input 23 (0x17) => 'X' (0x58)\n    89, // input 24 (0x18) => 'Y' (0x59)\n    90, // input 25 (0x19) => 'Z' (0x5A)\n    97, // input 26 (0x1A) => 'a' (0x61)\n    98, // input 27 (0x1B) => 'b' (0x62)\n    99, // input 28 (0x1C) => 'c' (0x63)\n    100, // input 29 (0x1D) => 'd' (0x64)\n    101, // input 30 (0x1E) => 'e' (0x65)\n    102, // input 31 (0x1F) => 'f' (0x66)\n    103, // input 32 (0x20) => 'g' (0x67)\n    104, // input 33 (0x21) => 'h' (0x68)\n    105, // input 34 (0x22) => 'i' (0x69)\n    106, // input 35 (0x23) => 'j' (0x6A)\n    107, // input 36 (0x24) => 'k' (0x6B)\n    108, // input 37 (0x25) => 'l' (0x6C)\n    109, // input 38 (0x26) => 'm' (0x6D)\n    110, // input 39 (0x27) => 'n' (0x6E)\n    111, // input 40 (0x28) => 'o' (0x6F)\n    112, // input 41 (0x29) => 'p' (0x70)\n    113, // input 42 (0x2A) => 'q' (0x71)\n    114, // input 43 (0x2B) => 'r' (0x72)\n    115, // input 44 (0x2C) => 's' (0x73)\n    116, // input 45 (0x2D) => 't' (0x74)\n    117, // input 46 (0x2E) => 'u' (0x75)\n    118, // input 47 (0x2F) => 'v' (0x76)\n    119, // input 48 (0x30) => 'w' (0x77)\n    120, // input 49 (0x31) => 'x' (0x78)\n    121, // input 50 (0x32) => 'y' (0x79)\n    122, // input 51 (0x33) => 'z' (0x7A)\n    48, // input 52 (0x34) => '0' (0x30)\n    49, // input 53 (0x35) => '1' (0x31)\n    50, // input 54 (0x36) => '2' (0x32)\n    51, // input 55 (0x37) => '3' (0x33)\n    52, // input 56 (0x38) => '4' (0x34)\n    53, // input 57 (0x39) => '5' (0x35)\n    54, // input 58 (0x3A) => '6' (0x36)\n    55, // input 59 (0x3B) => '7' (0x37)\n    56, // input 60 (0x3C) => '8' (0x38)\n    57, // input 61 (0x3D) => '9' (0x39)\n    45, // input 62 (0x3E) => '-' (0x2D)\n    95, // input 63 (0x3F) => '_' (0x5F)\n];\n#[rustfmt::skip]\npub const URL_SAFE_DECODE: &[u8; 256] = &[\n    INVALID_VALUE, // input 0 (0x0)\n    INVALID_VALUE, // input 1 (0x1)\n    INVALID_VALUE, // input 2 (0x2)\n    INVALID_VALUE, // input 3 (0x3)\n    INVALID_VALUE, // input 4 (0x4)\n    INVALID_VALUE, // input 5 (0x5)\n    INVALID_VALUE, // input 6 (0x6)\n    INVALID_VALUE, // input 7 (0x7)\n    INVALID_VALUE, // input 8 (0x8)\n    INVALID_VALUE, // input 9 (0x9)\n    INVALID_VALUE, // input 10 (0xA)\n    INVALID_VALUE, // input 11 (0xB)\n    INVALID_VALUE, // input 12 (0xC)\n    INVALID_VALUE, // input 13 (0xD)\n    INVALID_VALUE, // input 14 (0xE)\n    INVALID_VALUE, // input 15 (0xF)\n    INVALID_VALUE, // input 16 (0x10)\n    INVALID_VALUE, // input 17 (0x11)\n    INVALID_VALUE, // input 18 (0x12)\n    INVALID_VALUE, // input 19 (0x13)\n    INVALID_VALUE, // input 20 (0x14)\n    INVALID_VALUE, // input 21 (0x15)\n    INVALID_VALUE, // input 22 (0x16)\n    INVALID_VALUE, // input 23 (0x17)\n    INVALID_VALUE, // input 24 (0x18)\n    INVALID_VALUE, // input 25 (0x19)\n    INVALID_VALUE, // input 26 (0x1A)\n    INVALID_VALUE, // input 27 (0x1B)\n    INVALID_VALUE, // input 28 (0x1C)\n    INVALID_VALUE, // input 29 (0x1D)\n    INVALID_VALUE, // input 30 (0x1E)\n    INVALID_VALUE, // input 31 (0x1F)\n    INVALID_VALUE, // input 32 (0x20)\n    INVALID_VALUE, // input 33 (0x21)\n    INVALID_VALUE, // input 34 (0x22)\n    INVALID_VALUE, // input 35 (0x23)\n    INVALID_VALUE, // input 36 (0x24)\n    INVALID_VALUE, // input 37 (0x25)\n    INVALID_VALUE, // input 38 (0x26)\n    INVALID_VALUE, // input 39 (0x27)\n    INVALID_VALUE, // input 40 (0x28)\n    INVALID_VALUE, // input 41 (0x29)\n    INVALID_VALUE, // input 42 (0x2A)\n    INVALID_VALUE, // input 43 (0x2B)\n    INVALID_VALUE, // input 44 (0x2C)\n    62, // input 45 (0x2D char '-') => 62 (0x3E)\n    INVALID_VALUE, // input 46 (0x2E)\n    INVALID_VALUE, // input 47 (0x2F)\n    52, // input 48 (0x30 char '0') => 52 (0x34)\n    53, // input 49 (0x31 char '1') => 53 (0x35)\n    54, // input 50 (0x32 char '2') => 54 (0x36)\n    55, // input 51 (0x33 char '3') => 55 (0x37)\n    56, // input 52 (0x34 char '4') => 56 (0x38)\n    57, // input 53 (0x35 char '5') => 57 (0x39)\n    58, // input 54 (0x36 char '6') => 58 (0x3A)\n    59, // input 55 (0x37 char '7') => 59 (0x3B)\n    60, // input 56 (0x38 char '8') => 60 (0x3C)\n    61, // input 57 (0x39 char '9') => 61 (0x3D)\n    INVALID_VALUE, // input 58 (0x3A)\n    INVALID_VALUE, // input 59 (0x3B)\n    INVALID_VALUE, // input 60 (0x3C)\n    INVALID_VALUE, // input 61 (0x3D)\n    INVALID_VALUE, // input 62 (0x3E)\n    INVALID_VALUE, // input 63 (0x3F)\n    INVALID_VALUE, // input 64 (0x40)\n    0, // input 65 (0x41 char 'A') => 0 (0x0)\n    1, // input 66 (0x42 char 'B') => 1 (0x1)\n    2, // input 67 (0x43 char 'C') => 2 (0x2)\n    3, // input 68 (0x44 char 'D') => 3 (0x3)\n    4, // input 69 (0x45 char 'E') => 4 (0x4)\n    5, // input 70 (0x46 char 'F') => 5 (0x5)\n    6, // input 71 (0x47 char 'G') => 6 (0x6)\n    7, // input 72 (0x48 char 'H') => 7 (0x7)\n    8, // input 73 (0x49 char 'I') => 8 (0x8)\n    9, // input 74 (0x4A char 'J') => 9 (0x9)\n    10, // input 75 (0x4B char 'K') => 10 (0xA)\n    11, // input 76 (0x4C char 'L') => 11 (0xB)\n    12, // input 77 (0x4D char 'M') => 12 (0xC)\n    13, // input 78 (0x4E char 'N') => 13 (0xD)\n    14, // input 79 (0x4F char 'O') => 14 (0xE)\n    15, // input 80 (0x50 char 'P') => 15 (0xF)\n    16, // input 81 (0x51 char 'Q') => 16 (0x10)\n    17, // input 82 (0x52 char 'R') => 17 (0x11)\n    18, // input 83 (0x53 char 'S') => 18 (0x12)\n    19, // input 84 (0x54 char 'T') => 19 (0x13)\n    20, // input 85 (0x55 char 'U') => 20 (0x14)\n    21, // input 86 (0x56 char 'V') => 21 (0x15)\n    22, // input 87 (0x57 char 'W') => 22 (0x16)\n    23, // input 88 (0x58 char 'X') => 23 (0x17)\n    24, // input 89 (0x59 char 'Y') => 24 (0x18)\n    25, // input 90 (0x5A char 'Z') => 25 (0x19)\n    INVALID_VALUE, // input 91 (0x5B)\n    INVALID_VALUE, // input 92 (0x5C)\n    INVALID_VALUE, // input 93 (0x5D)\n    INVALID_VALUE, // input 94 (0x5E)\n    63, // input 95 (0x5F char '_') => 63 (0x3F)\n    INVALID_VALUE, // input 96 (0x60)\n    26, // input 97 (0x61 char 'a') => 26 (0x1A)\n    27, // input 98 (0x62 char 'b') => 27 (0x1B)\n    28, // input 99 (0x63 char 'c') => 28 (0x1C)\n    29, // input 100 (0x64 char 'd') => 29 (0x1D)\n    30, // input 101 (0x65 char 'e') => 30 (0x1E)\n    31, // input 102 (0x66 char 'f') => 31 (0x1F)\n    32, // input 103 (0x67 char 'g') => 32 (0x20)\n    33, // input 104 (0x68 char 'h') => 33 (0x21)\n    34, // input 105 (0x69 char 'i') => 34 (0x22)\n    35, // input 106 (0x6A char 'j') => 35 (0x23)\n    36, // input 107 (0x6B char 'k') => 36 (0x24)\n    37, // input 108 (0x6C char 'l') => 37 (0x25)\n    38, // input 109 (0x6D char 'm') => 38 (0x26)\n    39, // input 110 (0x6E char 'n') => 39 (0x27)\n    40, // input 111 (0x6F char 'o') => 40 (0x28)\n    41, // input 112 (0x70 char 'p') => 41 (0x29)\n    42, // input 113 (0x71 char 'q') => 42 (0x2A)\n    43, // input 114 (0x72 char 'r') => 43 (0x2B)\n    44, // input 115 (0x73 char 's') => 44 (0x2C)\n    45, // input 116 (0x74 char 't') => 45 (0x2D)\n    46, // input 117 (0x75 char 'u') => 46 (0x2E)\n    47, // input 118 (0x76 char 'v') => 47 (0x2F)\n    48, // input 119 (0x77 char 'w') => 48 (0x30)\n    49, // input 120 (0x78 char 'x') => 49 (0x31)\n    50, // input 121 (0x79 char 'y') => 50 (0x32)\n    51, // input 122 (0x7A char 'z') => 51 (0x33)\n    INVALID_VALUE, // input 123 (0x7B)\n    INVALID_VALUE, // input 124 (0x7C)\n    INVALID_VALUE, // input 125 (0x7D)\n    INVALID_VALUE, // input 126 (0x7E)\n    INVALID_VALUE, // input 127 (0x7F)\n    INVALID_VALUE, // input 128 (0x80)\n    INVALID_VALUE, // input 129 (0x81)\n    INVALID_VALUE, // input 130 (0x82)\n    INVALID_VALUE, // input 131 (0x83)\n    INVALID_VALUE, // input 132 (0x84)\n    INVALID_VALUE, // input 133 (0x85)\n    INVALID_VALUE, // input 134 (0x86)\n    INVALID_VALUE, // input 135 (0x87)\n    INVALID_VALUE, // input 136 (0x88)\n    INVALID_VALUE, // input 137 (0x89)\n    INVALID_VALUE, // input 138 (0x8A)\n    INVALID_VALUE, // input 139 (0x8B)\n    INVALID_VALUE, // input 140 (0x8C)\n    INVALID_VALUE, // input 141 (0x8D)\n    INVALID_VALUE, // input 142 (0x8E)\n    INVALID_VALUE, // input 143 (0x8F)\n    INVALID_VALUE, // input 144 (0x90)\n    INVALID_VALUE, // input 145 (0x91)\n    INVALID_VALUE, // input 146 (0x92)\n    INVALID_VALUE, // input 147 (0x93)\n    INVALID_VALUE, // input 148 (0x94)\n    INVALID_VALUE, // input 149 (0x95)\n    INVALID_VALUE, // input 150 (0x96)\n    INVALID_VALUE, // input 151 (0x97)\n    INVALID_VALUE, // input 152 (0x98)\n    INVALID_VALUE, // input 153 (0x99)\n    INVALID_VALUE, // input 154 (0x9A)\n    INVALID_VALUE, // input 155 (0x9B)\n    INVALID_VALUE, // input 156 (0x9C)\n    INVALID_VALUE, // input 157 (0x9D)\n    INVALID_VALUE, // input 158 (0x9E)\n    INVALID_VALUE, // input 159 (0x9F)\n    INVALID_VALUE, // input 160 (0xA0)\n    INVALID_VALUE, // input 161 (0xA1)\n    INVALID_VALUE, // input 162 (0xA2)\n    INVALID_VALUE, // input 163 (0xA3)\n    INVALID_VALUE, // input 164 (0xA4)\n    INVALID_VALUE, // input 165 (0xA5)\n    INVALID_VALUE, // input 166 (0xA6)\n    INVALID_VALUE, // input 167 (0xA7)\n    INVALID_VALUE, // input 168 (0xA8)\n    INVALID_VALUE, // input 169 (0xA9)\n    INVALID_VALUE, // input 170 (0xAA)\n    INVALID_VALUE, // input 171 (0xAB)\n    INVALID_VALUE, // input 172 (0xAC)\n    INVALID_VALUE, // input 173 (0xAD)\n    INVALID_VALUE, // input 174 (0xAE)\n    INVALID_VALUE, // input 175 (0xAF)\n    INVALID_VALUE, // input 176 (0xB0)\n    INVALID_VALUE, // input 177 (0xB1)\n    INVALID_VALUE, // input 178 (0xB2)\n    INVALID_VALUE, // input 179 (0xB3)\n    INVALID_VALUE, // input 180 (0xB4)\n    INVALID_VALUE, // input 181 (0xB5)\n    INVALID_VALUE, // input 182 (0xB6)\n    INVALID_VALUE, // input 183 (0xB7)\n    INVALID_VALUE, // input 184 (0xB8)\n    INVALID_VALUE, // input 185 (0xB9)\n    INVALID_VALUE, // input 186 (0xBA)\n    INVALID_VALUE, // input 187 (0xBB)\n    INVALID_VALUE, // input 188 (0xBC)\n    INVALID_VALUE, // input 189 (0xBD)\n    INVALID_VALUE, // input 190 (0xBE)\n    INVALID_VALUE, // input 191 (0xBF)\n    INVALID_VALUE, // input 192 (0xC0)\n    INVALID_VALUE, // input 193 (0xC1)\n    INVALID_VALUE, // input 194 (0xC2)\n    INVALID_VALUE, // input 195 (0xC3)\n    INVALID_VALUE, // input 196 (0xC4)\n    INVALID_VALUE, // input 197 (0xC5)\n    INVALID_VALUE, // input 198 (0xC6)\n    INVALID_VALUE, // input 199 (0xC7)\n    INVALID_VALUE, // input 200 (0xC8)\n    INVALID_VALUE, // input 201 (0xC9)\n    INVALID_VALUE, // input 202 (0xCA)\n    INVALID_VALUE, // input 203 (0xCB)\n    INVALID_VALUE, // input 204 (0xCC)\n    INVALID_VALUE, // input 205 (0xCD)\n    INVALID_VALUE, // input 206 (0xCE)\n    INVALID_VALUE, // input 207 (0xCF)\n    INVALID_VALUE, // input 208 (0xD0)\n    INVALID_VALUE, // input 209 (0xD1)\n    INVALID_VALUE, // input 210 (0xD2)\n    INVALID_VALUE, // input 211 (0xD3)\n    INVALID_VALUE, // input 212 (0xD4)\n    INVALID_VALUE, // input 213 (0xD5)\n    INVALID_VALUE, // input 214 (0xD6)\n    INVALID_VALUE, // input 215 (0xD7)\n    INVALID_VALUE, // input 216 (0xD8)\n    INVALID_VALUE, // input 217 (0xD9)\n    INVALID_VALUE, // input 218 (0xDA)\n    INVALID_VALUE, // input 219 (0xDB)\n    INVALID_VALUE, // input 220 (0xDC)\n    INVALID_VALUE, // input 221 (0xDD)\n    INVALID_VALUE, // input 222 (0xDE)\n    INVALID_VALUE, // input 223 (0xDF)\n    INVALID_VALUE, // input 224 (0xE0)\n    INVALID_VALUE, // input 225 (0xE1)\n    INVALID_VALUE, // input 226 (0xE2)\n    INVALID_VALUE, // input 227 (0xE3)\n    INVALID_VALUE, // input 228 (0xE4)\n    INVALID_VALUE, // input 229 (0xE5)\n    INVALID_VALUE, // input 230 (0xE6)\n    INVALID_VALUE, // input 231 (0xE7)\n    INVALID_VALUE, // input 232 (0xE8)\n    INVALID_VALUE, // input 233 (0xE9)\n    INVALID_VALUE, // input 234 (0xEA)\n    INVALID_VALUE, // input 235 (0xEB)\n    INVALID_VALUE, // input 236 (0xEC)\n    INVALID_VALUE, // input 237 (0xED)\n    INVALID_VALUE, // input 238 (0xEE)\n    INVALID_VALUE, // input 239 (0xEF)\n    INVALID_VALUE, // input 240 (0xF0)\n    INVALID_VALUE, // input 241 (0xF1)\n    INVALID_VALUE, // input 242 (0xF2)\n    INVALID_VALUE, // input 243 (0xF3)\n    INVALID_VALUE, // input 244 (0xF4)\n    INVALID_VALUE, // input 245 (0xF5)\n    INVALID_VALUE, // input 246 (0xF6)\n    INVALID_VALUE, // input 247 (0xF7)\n    INVALID_VALUE, // input 248 (0xF8)\n    INVALID_VALUE, // input 249 (0xF9)\n    INVALID_VALUE, // input 250 (0xFA)\n    INVALID_VALUE, // input 251 (0xFB)\n    INVALID_VALUE, // input 252 (0xFC)\n    INVALID_VALUE, // input 253 (0xFD)\n    INVALID_VALUE, // input 254 (0xFE)\n    INVALID_VALUE, // input 255 (0xFF)\n];\n#[rustfmt::skip]\npub const CRYPT_ENCODE: &[u8; 64] = &[\n    46, // input 0 (0x0) => '.' (0x2E)\n    47, // input 1 (0x1) => '/' (0x2F)\n    48, // input 2 (0x2) => '0' (0x30)\n    49, // input 3 (0x3) => '1' (0x31)\n    50, // input 4 (0x4) => '2' (0x32)\n    51, // input 5 (0x5) => '3' (0x33)\n    52, // input 6 (0x6) => '4' (0x34)\n    53, // input 7 (0x7) => '5' (0x35)\n    54, // input 8 (0x8) => '6' (0x36)\n    55, // input 9 (0x9) => '7' (0x37)\n    56, // input 10 (0xA) => '8' (0x38)\n    57, // input 11 (0xB) => '9' (0x39)\n    65, // input 12 (0xC) => 'A' (0x41)\n    66, // input 13 (0xD) => 'B' (0x42)\n    67, // input 14 (0xE) => 'C' (0x43)\n    68, // input 15 (0xF) => 'D' (0x44)\n    69, // input 16 (0x10) => 'E' (0x45)\n    70, // input 17 (0x11) => 'F' (0x46)\n    71, // input 18 (0x12) => 'G' (0x47)\n    72, // input 19 (0x13) => 'H' (0x48)\n    73, // input 20 (0x14) => 'I' (0x49)\n    74, // input 21 (0x15) => 'J' (0x4A)\n    75, // input 22 (0x16) => 'K' (0x4B)\n    76, // input 23 (0x17) => 'L' (0x4C)\n    77, // input 24 (0x18) => 'M' (0x4D)\n    78, // input 25 (0x19) => 'N' (0x4E)\n    79, // input 26 (0x1A) => 'O' (0x4F)\n    80, // input 27 (0x1B) => 'P' (0x50)\n    81, // input 28 (0x1C) => 'Q' (0x51)\n    82, // input 29 (0x1D) => 'R' (0x52)\n    83, // input 30 (0x1E) => 'S' (0x53)\n    84, // input 31 (0x1F) => 'T' (0x54)\n    85, // input 32 (0x20) => 'U' (0x55)\n    86, // input 33 (0x21) => 'V' (0x56)\n    87, // input 34 (0x22) => 'W' (0x57)\n    88, // input 35 (0x23) => 'X' (0x58)\n    89, // input 36 (0x24) => 'Y' (0x59)\n    90, // input 37 (0x25) => 'Z' (0x5A)\n    97, // input 38 (0x26) => 'a' (0x61)\n    98, // input 39 (0x27) => 'b' (0x62)\n    99, // input 40 (0x28) => 'c' (0x63)\n    100, // input 41 (0x29) => 'd' (0x64)\n    101, // input 42 (0x2A) => 'e' (0x65)\n    102, // input 43 (0x2B) => 'f' (0x66)\n    103, // input 44 (0x2C) => 'g' (0x67)\n    104, // input 45 (0x2D) => 'h' (0x68)\n    105, // input 46 (0x2E) => 'i' (0x69)\n    106, // input 47 (0x2F) => 'j' (0x6A)\n    107, // input 48 (0x30) => 'k' (0x6B)\n    108, // input 49 (0x31) => 'l' (0x6C)\n    109, // input 50 (0x32) => 'm' (0x6D)\n    110, // input 51 (0x33) => 'n' (0x6E)\n    111, // input 52 (0x34) => 'o' (0x6F)\n    112, // input 53 (0x35) => 'p' (0x70)\n    113, // input 54 (0x36) => 'q' (0x71)\n    114, // input 55 (0x37) => 'r' (0x72)\n    115, // input 56 (0x38) => 's' (0x73)\n    116, // input 57 (0x39) => 't' (0x74)\n    117, // input 58 (0x3A) => 'u' (0x75)\n    118, // input 59 (0x3B) => 'v' (0x76)\n    119, // input 60 (0x3C) => 'w' (0x77)\n    120, // input 61 (0x3D) => 'x' (0x78)\n    121, // input 62 (0x3E) => 'y' (0x79)\n    122, // input 63 (0x3F) => 'z' (0x7A)\n];\n#[rustfmt::skip]\npub const CRYPT_DECODE: &[u8; 256] = &[\n    INVALID_VALUE, // input 0 (0x0)\n    INVALID_VALUE, // input 1 (0x1)\n    INVALID_VALUE, // input 2 (0x2)\n    INVALID_VALUE, // input 3 (0x3)\n    INVALID_VALUE, // input 4 (0x4)\n    INVALID_VALUE, // input 5 (0x5)\n    INVALID_VALUE, // input 6 (0x6)\n    INVALID_VALUE, // input 7 (0x7)\n    INVALID_VALUE, // input 8 (0x8)\n    INVALID_VALUE, // input 9 (0x9)\n    INVALID_VALUE, // input 10 (0xA)\n    INVALID_VALUE, // input 11 (0xB)\n    INVALID_VALUE, // input 12 (0xC)\n    INVALID_VALUE, // input 13 (0xD)\n    INVALID_VALUE, // input 14 (0xE)\n    INVALID_VALUE, // input 15 (0xF)\n    INVALID_VALUE, // input 16 (0x10)\n    INVALID_VALUE, // input 17 (0x11)\n    INVALID_VALUE, // input 18 (0x12)\n    INVALID_VALUE, // input 19 (0x13)\n    INVALID_VALUE, // input 20 (0x14)\n    INVALID_VALUE, // input 21 (0x15)\n    INVALID_VALUE, // input 22 (0x16)\n    INVALID_VALUE, // input 23 (0x17)\n    INVALID_VALUE, // input 24 (0x18)\n    INVALID_VALUE, // input 25 (0x19)\n    INVALID_VALUE, // input 26 (0x1A)\n    INVALID_VALUE, // input 27 (0x1B)\n    INVALID_VALUE, // input 28 (0x1C)\n    INVALID_VALUE, // input 29 (0x1D)\n    INVALID_VALUE, // input 30 (0x1E)\n    INVALID_VALUE, // input 31 (0x1F)\n    INVALID_VALUE, // input 32 (0x20)\n    INVALID_VALUE, // input 33 (0x21)\n    INVALID_VALUE, // input 34 (0x22)\n    INVALID_VALUE, // input 35 (0x23)\n    INVALID_VALUE, // input 36 (0x24)\n    INVALID_VALUE, // input 37 (0x25)\n    INVALID_VALUE, // input 38 (0x26)\n    INVALID_VALUE, // input 39 (0x27)\n    INVALID_VALUE, // input 40 (0x28)\n    INVALID_VALUE, // input 41 (0x29)\n    INVALID_VALUE, // input 42 (0x2A)\n    INVALID_VALUE, // input 43 (0x2B)\n    INVALID_VALUE, // input 44 (0x2C)\n    INVALID_VALUE, // input 45 (0x2D)\n    0, // input 46 (0x2E char '.') => 0 (0x0)\n    1, // input 47 (0x2F char '/') => 1 (0x1)\n    2, // input 48 (0x30 char '0') => 2 (0x2)\n    3, // input 49 (0x31 char '1') => 3 (0x3)\n    4, // input 50 (0x32 char '2') => 4 (0x4)\n    5, // input 51 (0x33 char '3') => 5 (0x5)\n    6, // input 52 (0x34 char '4') => 6 (0x6)\n    7, // input 53 (0x35 char '5') => 7 (0x7)\n    8, // input 54 (0x36 char '6') => 8 (0x8)\n    9, // input 55 (0x37 char '7') => 9 (0x9)\n    10, // input 56 (0x38 char '8') => 10 (0xA)\n    11, // input 57 (0x39 char '9') => 11 (0xB)\n    INVALID_VALUE, // input 58 (0x3A)\n    INVALID_VALUE, // input 59 (0x3B)\n    INVALID_VALUE, // input 60 (0x3C)\n    INVALID_VALUE, // input 61 (0x3D)\n    INVALID_VALUE, // input 62 (0x3E)\n    INVALID_VALUE, // input 63 (0x3F)\n    INVALID_VALUE, // input 64 (0x40)\n    12, // input 65 (0x41 char 'A') => 12 (0xC)\n    13, // input 66 (0x42 char 'B') => 13 (0xD)\n    14, // input 67 (0x43 char 'C') => 14 (0xE)\n    15, // input 68 (0x44 char 'D') => 15 (0xF)\n    16, // input 69 (0x45 char 'E') => 16 (0x10)\n    17, // input 70 (0x46 char 'F') => 17 (0x11)\n    18, // input 71 (0x47 char 'G') => 18 (0x12)\n    19, // input 72 (0x48 char 'H') => 19 (0x13)\n    20, // input 73 (0x49 char 'I') => 20 (0x14)\n    21, // input 74 (0x4A char 'J') => 21 (0x15)\n    22, // input 75 (0x4B char 'K') => 22 (0x16)\n    23, // input 76 (0x4C char 'L') => 23 (0x17)\n    24, // input 77 (0x4D char 'M') => 24 (0x18)\n    25, // input 78 (0x4E char 'N') => 25 (0x19)\n    26, // input 79 (0x4F char 'O') => 26 (0x1A)\n    27, // input 80 (0x50 char 'P') => 27 (0x1B)\n    28, // input 81 (0x51 char 'Q') => 28 (0x1C)\n    29, // input 82 (0x52 char 'R') => 29 (0x1D)\n    30, // input 83 (0x53 char 'S') => 30 (0x1E)\n    31, // input 84 (0x54 char 'T') => 31 (0x1F)\n    32, // input 85 (0x55 char 'U') => 32 (0x20)\n    33, // input 86 (0x56 char 'V') => 33 (0x21)\n    34, // input 87 (0x57 char 'W') => 34 (0x22)\n    35, // input 88 (0x58 char 'X') => 35 (0x23)\n    36, // input 89 (0x59 char 'Y') => 36 (0x24)\n    37, // input 90 (0x5A char 'Z') => 37 (0x25)\n    INVALID_VALUE, // input 91 (0x5B)\n    INVALID_VALUE, // input 92 (0x5C)\n    INVALID_VALUE, // input 93 (0x5D)\n    INVALID_VALUE, // input 94 (0x5E)\n    INVALID_VALUE, // input 95 (0x5F)\n    INVALID_VALUE, // input 96 (0x60)\n    38, // input 97 (0x61 char 'a') => 38 (0x26)\n    39, // input 98 (0x62 char 'b') => 39 (0x27)\n    40, // input 99 (0x63 char 'c') => 40 (0x28)\n    41, // input 100 (0x64 char 'd') => 41 (0x29)\n    42, // input 101 (0x65 char 'e') => 42 (0x2A)\n    43, // input 102 (0x66 char 'f') => 43 (0x2B)\n    44, // input 103 (0x67 char 'g') => 44 (0x2C)\n    45, // input 104 (0x68 char 'h') => 45 (0x2D)\n    46, // input 105 (0x69 char 'i') => 46 (0x2E)\n    47, // input 106 (0x6A char 'j') => 47 (0x2F)\n    48, // input 107 (0x6B char 'k') => 48 (0x30)\n    49, // input 108 (0x6C char 'l') => 49 (0x31)\n    50, // input 109 (0x6D char 'm') => 50 (0x32)\n    51, // input 110 (0x6E char 'n') => 51 (0x33)\n    52, // input 111 (0x6F char 'o') => 52 (0x34)\n    53, // input 112 (0x70 char 'p') => 53 (0x35)\n    54, // input 113 (0x71 char 'q') => 54 (0x36)\n    55, // input 114 (0x72 char 'r') => 55 (0x37)\n    56, // input 115 (0x73 char 's') => 56 (0x38)\n    57, // input 116 (0x74 char 't') => 57 (0x39)\n    58, // input 117 (0x75 char 'u') => 58 (0x3A)\n    59, // input 118 (0x76 char 'v') => 59 (0x3B)\n    60, // input 119 (0x77 char 'w') => 60 (0x3C)\n    61, // input 120 (0x78 char 'x') => 61 (0x3D)\n    62, // input 121 (0x79 char 'y') => 62 (0x3E)\n    63, // input 122 (0x7A char 'z') => 63 (0x3F)\n    INVALID_VALUE, // input 123 (0x7B)\n    INVALID_VALUE, // input 124 (0x7C)\n    INVALID_VALUE, // input 125 (0x7D)\n    INVALID_VALUE, // input 126 (0x7E)\n    INVALID_VALUE, // input 127 (0x7F)\n    INVALID_VALUE, // input 128 (0x80)\n    INVALID_VALUE, // input 129 (0x81)\n    INVALID_VALUE, // input 130 (0x82)\n    INVALID_VALUE, // input 131 (0x83)\n    INVALID_VALUE, // input 132 (0x84)\n    INVALID_VALUE, // input 133 (0x85)\n    INVALID_VALUE, // input 134 (0x86)\n    INVALID_VALUE, // input 135 (0x87)\n    INVALID_VALUE, // input 136 (0x88)\n    INVALID_VALUE, // input 137 (0x89)\n    INVALID_VALUE, // input 138 (0x8A)\n    INVALID_VALUE, // input 139 (0x8B)\n    INVALID_VALUE, // input 140 (0x8C)\n    INVALID_VALUE, // input 141 (0x8D)\n    INVALID_VALUE, // input 142 (0x8E)\n    INVALID_VALUE, // input 143 (0x8F)\n    INVALID_VALUE, // input 144 (0x90)\n    INVALID_VALUE, // input 145 (0x91)\n    INVALID_VALUE, // input 146 (0x92)\n    INVALID_VALUE, // input 147 (0x93)\n    INVALID_VALUE, // input 148 (0x94)\n    INVALID_VALUE, // input 149 (0x95)\n    INVALID_VALUE, // input 150 (0x96)\n    INVALID_VALUE, // input 151 (0x97)\n    INVALID_VALUE, // input 152 (0x98)\n    INVALID_VALUE, // input 153 (0x99)\n    INVALID_VALUE, // input 154 (0x9A)\n    INVALID_VALUE, // input 155 (0x9B)\n    INVALID_VALUE, // input 156 (0x9C)\n    INVALID_VALUE, // input 157 (0x9D)\n    INVALID_VALUE, // input 158 (0x9E)\n    INVALID_VALUE, // input 159 (0x9F)\n    INVALID_VALUE, // input 160 (0xA0)\n    INVALID_VALUE, // input 161 (0xA1)\n    INVALID_VALUE, // input 162 (0xA2)\n    INVALID_VALUE, // input 163 (0xA3)\n    INVALID_VALUE, // input 164 (0xA4)\n    INVALID_VALUE, // input 165 (0xA5)\n    INVALID_VALUE, // input 166 (0xA6)\n    INVALID_VALUE, // input 167 (0xA7)\n    INVALID_VALUE, // input 168 (0xA8)\n    INVALID_VALUE, // input 169 (0xA9)\n    INVALID_VALUE, // input 170 (0xAA)\n    INVALID_VALUE, // input 171 (0xAB)\n    INVALID_VALUE, // input 172 (0xAC)\n    INVALID_VALUE, // input 173 (0xAD)\n    INVALID_VALUE, // input 174 (0xAE)\n    INVALID_VALUE, // input 175 (0xAF)\n    INVALID_VALUE, // input 176 (0xB0)\n    INVALID_VALUE, // input 177 (0xB1)\n    INVALID_VALUE, // input 178 (0xB2)\n    INVALID_VALUE, // input 179 (0xB3)\n    INVALID_VALUE, // input 180 (0xB4)\n    INVALID_VALUE, // input 181 (0xB5)\n    INVALID_VALUE, // input 182 (0xB6)\n    INVALID_VALUE, // input 183 (0xB7)\n    INVALID_VALUE, // input 184 (0xB8)\n    INVALID_VALUE, // input 185 (0xB9)\n    INVALID_VALUE, // input 186 (0xBA)\n    INVALID_VALUE, // input 187 (0xBB)\n    INVALID_VALUE, // input 188 (0xBC)\n    INVALID_VALUE, // input 189 (0xBD)\n    INVALID_VALUE, // input 190 (0xBE)\n    INVALID_VALUE, // input 191 (0xBF)\n    INVALID_VALUE, // input 192 (0xC0)\n    INVALID_VALUE, // input 193 (0xC1)\n    INVALID_VALUE, // input 194 (0xC2)\n    INVALID_VALUE, // input 195 (0xC3)\n    INVALID_VALUE, // input 196 (0xC4)\n    INVALID_VALUE, // input 197 (0xC5)\n    INVALID_VALUE, // input 198 (0xC6)\n    INVALID_VALUE, // input 199 (0xC7)\n    INVALID_VALUE, // input 200 (0xC8)\n    INVALID_VALUE, // input 201 (0xC9)\n    INVALID_VALUE, // input 202 (0xCA)\n    INVALID_VALUE, // input 203 (0xCB)\n    INVALID_VALUE, // input 204 (0xCC)\n    INVALID_VALUE, // input 205 (0xCD)\n    INVALID_VALUE, // input 206 (0xCE)\n    INVALID_VALUE, // input 207 (0xCF)\n    INVALID_VALUE, // input 208 (0xD0)\n    INVALID_VALUE, // input 209 (0xD1)\n    INVALID_VALUE, // input 210 (0xD2)\n    INVALID_VALUE, // input 211 (0xD3)\n    INVALID_VALUE, // input 212 (0xD4)\n    INVALID_VALUE, // input 213 (0xD5)\n    INVALID_VALUE, // input 214 (0xD6)\n    INVALID_VALUE, // input 215 (0xD7)\n    INVALID_VALUE, // input 216 (0xD8)\n    INVALID_VALUE, // input 217 (0xD9)\n    INVALID_VALUE, // input 218 (0xDA)\n    INVALID_VALUE, // input 219 (0xDB)\n    INVALID_VALUE, // input 220 (0xDC)\n    INVALID_VALUE, // input 221 (0xDD)\n    INVALID_VALUE, // input 222 (0xDE)\n    INVALID_VALUE, // input 223 (0xDF)\n    INVALID_VALUE, // input 224 (0xE0)\n    INVALID_VALUE, // input 225 (0xE1)\n    INVALID_VALUE, // input 226 (0xE2)\n    INVALID_VALUE, // input 227 (0xE3)\n    INVALID_VALUE, // input 228 (0xE4)\n    INVALID_VALUE, // input 229 (0xE5)\n    INVALID_VALUE, // input 230 (0xE6)\n    INVALID_VALUE, // input 231 (0xE7)\n    INVALID_VALUE, // input 232 (0xE8)\n    INVALID_VALUE, // input 233 (0xE9)\n    INVALID_VALUE, // input 234 (0xEA)\n    INVALID_VALUE, // input 235 (0xEB)\n    INVALID_VALUE, // input 236 (0xEC)\n    INVALID_VALUE, // input 237 (0xED)\n    INVALID_VALUE, // input 238 (0xEE)\n    INVALID_VALUE, // input 239 (0xEF)\n    INVALID_VALUE, // input 240 (0xF0)\n    INVALID_VALUE, // input 241 (0xF1)\n    INVALID_VALUE, // input 242 (0xF2)\n    INVALID_VALUE, // input 243 (0xF3)\n    INVALID_VALUE, // input 244 (0xF4)\n    INVALID_VALUE, // input 245 (0xF5)\n    INVALID_VALUE, // input 246 (0xF6)\n    INVALID_VALUE, // input 247 (0xF7)\n    INVALID_VALUE, // input 248 (0xF8)\n    INVALID_VALUE, // input 249 (0xF9)\n    INVALID_VALUE, // input 250 (0xFA)\n    INVALID_VALUE, // input 251 (0xFB)\n    INVALID_VALUE, // input 252 (0xFC)\n    INVALID_VALUE, // input 253 (0xFD)\n    INVALID_VALUE, // input 254 (0xFE)\n    INVALID_VALUE, // input 255 (0xFF)\n];\n#[rustfmt::skip]\npub const BCRYPT_ENCODE: &[u8; 64] = &[\n    46, // input 0 (0x0) => '.' (0x2E)\n    47, // input 1 (0x1) => '/' (0x2F)\n    65, // input 2 (0x2) => 'A' (0x41)\n    66, // input 3 (0x3) => 'B' (0x42)\n    67, // input 4 (0x4) => 'C' (0x43)\n    68, // input 5 (0x5) => 'D' (0x44)\n    69, // input 6 (0x6) => 'E' (0x45)\n    70, // input 7 (0x7) => 'F' (0x46)\n    71, // input 8 (0x8) => 'G' (0x47)\n    72, // input 9 (0x9) => 'H' (0x48)\n    73, // input 10 (0xA) => 'I' (0x49)\n    74, // input 11 (0xB) => 'J' (0x4A)\n    75, // input 12 (0xC) => 'K' (0x4B)\n    76, // input 13 (0xD) => 'L' (0x4C)\n    77, // input 14 (0xE) => 'M' (0x4D)\n    78, // input 15 (0xF) => 'N' (0x4E)\n    79, // input 16 (0x10) => 'O' (0x4F)\n    80, // input 17 (0x11) => 'P' (0x50)\n    81, // input 18 (0x12) => 'Q' (0x51)\n    82, // input 19 (0x13) => 'R' (0x52)\n    83, // input 20 (0x14) => 'S' (0x53)\n    84, // input 21 (0x15) => 'T' (0x54)\n    85, // input 22 (0x16) => 'U' (0x55)\n    86, // input 23 (0x17) => 'V' (0x56)\n    87, // input 24 (0x18) => 'W' (0x57)\n    88, // input 25 (0x19) => 'X' (0x58)\n    89, // input 26 (0x1A) => 'Y' (0x59)\n    90, // input 27 (0x1B) => 'Z' (0x5A)\n    97, // input 28 (0x1C) => 'a' (0x61)\n    98, // input 29 (0x1D) => 'b' (0x62)\n    99, // input 30 (0x1E) => 'c' (0x63)\n    100, // input 31 (0x1F) => 'd' (0x64)\n    101, // input 32 (0x20) => 'e' (0x65)\n    102, // input 33 (0x21) => 'f' (0x66)\n    103, // input 34 (0x22) => 'g' (0x67)\n    104, // input 35 (0x23) => 'h' (0x68)\n    105, // input 36 (0x24) => 'i' (0x69)\n    106, // input 37 (0x25) => 'j' (0x6A)\n    107, // input 38 (0x26) => 'k' (0x6B)\n    108, // input 39 (0x27) => 'l' (0x6C)\n    109, // input 40 (0x28) => 'm' (0x6D)\n    110, // input 41 (0x29) => 'n' (0x6E)\n    111, // input 42 (0x2A) => 'o' (0x6F)\n    112, // input 43 (0x2B) => 'p' (0x70)\n    113, // input 44 (0x2C) => 'q' (0x71)\n    114, // input 45 (0x2D) => 'r' (0x72)\n    115, // input 46 (0x2E) => 's' (0x73)\n    116, // input 47 (0x2F) => 't' (0x74)\n    117, // input 48 (0x30) => 'u' (0x75)\n    118, // input 49 (0x31) => 'v' (0x76)\n    119, // input 50 (0x32) => 'w' (0x77)\n    120, // input 51 (0x33) => 'x' (0x78)\n    121, // input 52 (0x34) => 'y' (0x79)\n    122, // input 53 (0x35) => 'z' (0x7A)\n    48, // input 54 (0x36) => '0' (0x30)\n    49, // input 55 (0x37) => '1' (0x31)\n    50, // input 56 (0x38) => '2' (0x32)\n    51, // input 57 (0x39) => '3' (0x33)\n    52, // input 58 (0x3A) => '4' (0x34)\n    53, // input 59 (0x3B) => '5' (0x35)\n    54, // input 60 (0x3C) => '6' (0x36)\n    55, // input 61 (0x3D) => '7' (0x37)\n    56, // input 62 (0x3E) => '8' (0x38)\n    57, // input 63 (0x3F) => '9' (0x39)\n];\n#[rustfmt::skip]\npub const BCRYPT_DECODE: &[u8; 256] = &[\n    INVALID_VALUE, // input 0 (0x0)\n    INVALID_VALUE, // input 1 (0x1)\n    INVALID_VALUE, // input 2 (0x2)\n    INVALID_VALUE, // input 3 (0x3)\n    INVALID_VALUE, // input 4 (0x4)\n    INVALID_VALUE, // input 5 (0x5)\n    INVALID_VALUE, // input 6 (0x6)\n    INVALID_VALUE, // input 7 (0x7)\n    INVALID_VALUE, // input 8 (0x8)\n    INVALID_VALUE, // input 9 (0x9)\n    INVALID_VALUE, // input 10 (0xA)\n    INVALID_VALUE, // input 11 (0xB)\n    INVALID_VALUE, // input 12 (0xC)\n    INVALID_VALUE, // input 13 (0xD)\n    INVALID_VALUE, // input 14 (0xE)\n    INVALID_VALUE, // input 15 (0xF)\n    INVALID_VALUE, // input 16 (0x10)\n    INVALID_VALUE, // input 17 (0x11)\n    INVALID_VALUE, // input 18 (0x12)\n    INVALID_VALUE, // input 19 (0x13)\n    INVALID_VALUE, // input 20 (0x14)\n    INVALID_VALUE, // input 21 (0x15)\n    INVALID_VALUE, // input 22 (0x16)\n    INVALID_VALUE, // input 23 (0x17)\n    INVALID_VALUE, // input 24 (0x18)\n    INVALID_VALUE, // input 25 (0x19)\n    INVALID_VALUE, // input 26 (0x1A)\n    INVALID_VALUE, // input 27 (0x1B)\n    INVALID_VALUE, // input 28 (0x1C)\n    INVALID_VALUE, // input 29 (0x1D)\n    INVALID_VALUE, // input 30 (0x1E)\n    INVALID_VALUE, // input 31 (0x1F)\n    INVALID_VALUE, // input 32 (0x20)\n    INVALID_VALUE, // input 33 (0x21)\n    INVALID_VALUE, // input 34 (0x22)\n    INVALID_VALUE, // input 35 (0x23)\n    INVALID_VALUE, // input 36 (0x24)\n    INVALID_VALUE, // input 37 (0x25)\n    INVALID_VALUE, // input 38 (0x26)\n    INVALID_VALUE, // input 39 (0x27)\n    INVALID_VALUE, // input 40 (0x28)\n    INVALID_VALUE, // input 41 (0x29)\n    INVALID_VALUE, // input 42 (0x2A)\n    INVALID_VALUE, // input 43 (0x2B)\n    INVALID_VALUE, // input 44 (0x2C)\n    INVALID_VALUE, // input 45 (0x2D)\n    0, // input 46 (0x2E char '.') => 0 (0x0)\n    1, // input 47 (0x2F char '/') => 1 (0x1)\n    54, // input 48 (0x30 char '0') => 54 (0x36)\n    55, // input 49 (0x31 char '1') => 55 (0x37)\n    56, // input 50 (0x32 char '2') => 56 (0x38)\n    57, // input 51 (0x33 char '3') => 57 (0x39)\n    58, // input 52 (0x34 char '4') => 58 (0x3A)\n    59, // input 53 (0x35 char '5') => 59 (0x3B)\n    60, // input 54 (0x36 char '6') => 60 (0x3C)\n    61, // input 55 (0x37 char '7') => 61 (0x3D)\n    62, // input 56 (0x38 char '8') => 62 (0x3E)\n    63, // input 57 (0x39 char '9') => 63 (0x3F)\n    INVALID_VALUE, // input 58 (0x3A)\n    INVALID_VALUE, // input 59 (0x3B)\n    INVALID_VALUE, // input 60 (0x3C)\n    INVALID_VALUE, // input 61 (0x3D)\n    INVALID_VALUE, // input 62 (0x3E)\n    INVALID_VALUE, // input 63 (0x3F)\n    INVALID_VALUE, // input 64 (0x40)\n    2, // input 65 (0x41 char 'A') => 2 (0x2)\n    3, // input 66 (0x42 char 'B') => 3 (0x3)\n    4, // input 67 (0x43 char 'C') => 4 (0x4)\n    5, // input 68 (0x44 char 'D') => 5 (0x5)\n    6, // input 69 (0x45 char 'E') => 6 (0x6)\n    7, // input 70 (0x46 char 'F') => 7 (0x7)\n    8, // input 71 (0x47 char 'G') => 8 (0x8)\n    9, // input 72 (0x48 char 'H') => 9 (0x9)\n    10, // input 73 (0x49 char 'I') => 10 (0xA)\n    11, // input 74 (0x4A char 'J') => 11 (0xB)\n    12, // input 75 (0x4B char 'K') => 12 (0xC)\n    13, // input 76 (0x4C char 'L') => 13 (0xD)\n    14, // input 77 (0x4D char 'M') => 14 (0xE)\n    15, // input 78 (0x4E char 'N') => 15 (0xF)\n    16, // input 79 (0x4F char 'O') => 16 (0x10)\n    17, // input 80 (0x50 char 'P') => 17 (0x11)\n    18, // input 81 (0x51 char 'Q') => 18 (0x12)\n    19, // input 82 (0x52 char 'R') => 19 (0x13)\n    20, // input 83 (0x53 char 'S') => 20 (0x14)\n    21, // input 84 (0x54 char 'T') => 21 (0x15)\n    22, // input 85 (0x55 char 'U') => 22 (0x16)\n    23, // input 86 (0x56 char 'V') => 23 (0x17)\n    24, // input 87 (0x57 char 'W') => 24 (0x18)\n    25, // input 88 (0x58 char 'X') => 25 (0x19)\n    26, // input 89 (0x59 char 'Y') => 26 (0x1A)\n    27, // input 90 (0x5A char 'Z') => 27 (0x1B)\n    INVALID_VALUE, // input 91 (0x5B)\n    INVALID_VALUE, // input 92 (0x5C)\n    INVALID_VALUE, // input 93 (0x5D)\n    INVALID_VALUE, // input 94 (0x5E)\n    INVALID_VALUE, // input 95 (0x5F)\n    INVALID_VALUE, // input 96 (0x60)\n    28, // input 97 (0x61 char 'a') => 28 (0x1C)\n    29, // input 98 (0x62 char 'b') => 29 (0x1D)\n    30, // input 99 (0x63 char 'c') => 30 (0x1E)\n    31, // input 100 (0x64 char 'd') => 31 (0x1F)\n    32, // input 101 (0x65 char 'e') => 32 (0x20)\n    33, // input 102 (0x66 char 'f') => 33 (0x21)\n    34, // input 103 (0x67 char 'g') => 34 (0x22)\n    35, // input 104 (0x68 char 'h') => 35 (0x23)\n    36, // input 105 (0x69 char 'i') => 36 (0x24)\n    37, // input 106 (0x6A char 'j') => 37 (0x25)\n    38, // input 107 (0x6B char 'k') => 38 (0x26)\n    39, // input 108 (0x6C char 'l') => 39 (0x27)\n    40, // input 109 (0x6D char 'm') => 40 (0x28)\n    41, // input 110 (0x6E char 'n') => 41 (0x29)\n    42, // input 111 (0x6F char 'o') => 42 (0x2A)\n    43, // input 112 (0x70 char 'p') => 43 (0x2B)\n    44, // input 113 (0x71 char 'q') => 44 (0x2C)\n    45, // input 114 (0x72 char 'r') => 45 (0x2D)\n    46, // input 115 (0x73 char 's') => 46 (0x2E)\n    47, // input 116 (0x74 char 't') => 47 (0x2F)\n    48, // input 117 (0x75 char 'u') => 48 (0x30)\n    49, // input 118 (0x76 char 'v') => 49 (0x31)\n    50, // input 119 (0x77 char 'w') => 50 (0x32)\n    51, // input 120 (0x78 char 'x') => 51 (0x33)\n    52, // input 121 (0x79 char 'y') => 52 (0x34)\n    53, // input 122 (0x7A char 'z') => 53 (0x35)\n    INVALID_VALUE, // input 123 (0x7B)\n    INVALID_VALUE, // input 124 (0x7C)\n    INVALID_VALUE, // input 125 (0x7D)\n    INVALID_VALUE, // input 126 (0x7E)\n    INVALID_VALUE, // input 127 (0x7F)\n    INVALID_VALUE, // input 128 (0x80)\n    INVALID_VALUE, // input 129 (0x81)\n    INVALID_VALUE, // input 130 (0x82)\n    INVALID_VALUE, // input 131 (0x83)\n    INVALID_VALUE, // input 132 (0x84)\n    INVALID_VALUE, // input 133 (0x85)\n    INVALID_VALUE, // input 134 (0x86)\n    INVALID_VALUE, // input 135 (0x87)\n    INVALID_VALUE, // input 136 (0x88)\n    INVALID_VALUE, // input 137 (0x89)\n    INVALID_VALUE, // input 138 (0x8A)\n    INVALID_VALUE, // input 139 (0x8B)\n    INVALID_VALUE, // input 140 (0x8C)\n    INVALID_VALUE, // input 141 (0x8D)\n    INVALID_VALUE, // input 142 (0x8E)\n    INVALID_VALUE, // input 143 (0x8F)\n    INVALID_VALUE, // input 144 (0x90)\n    INVALID_VALUE, // input 145 (0x91)\n    INVALID_VALUE, // input 146 (0x92)\n    INVALID_VALUE, // input 147 (0x93)\n    INVALID_VALUE, // input 148 (0x94)\n    INVALID_VALUE, // input 149 (0x95)\n    INVALID_VALUE, // input 150 (0x96)\n    INVALID_VALUE, // input 151 (0x97)\n    INVALID_VALUE, // input 152 (0x98)\n    INVALID_VALUE, // input 153 (0x99)\n    INVALID_VALUE, // input 154 (0x9A)\n    INVALID_VALUE, // input 155 (0x9B)\n    INVALID_VALUE, // input 156 (0x9C)\n    INVALID_VALUE, // input 157 (0x9D)\n    INVALID_VALUE, // input 158 (0x9E)\n    INVALID_VALUE, // input 159 (0x9F)\n    INVALID_VALUE, // input 160 (0xA0)\n    INVALID_VALUE, // input 161 (0xA1)\n    INVALID_VALUE, // input 162 (0xA2)\n    INVALID_VALUE, // input 163 (0xA3)\n    INVALID_VALUE, // input 164 (0xA4)\n    INVALID_VALUE, // input 165 (0xA5)\n    INVALID_VALUE, // input 166 (0xA6)\n    INVALID_VALUE, // input 167 (0xA7)\n    INVALID_VALUE, // input 168 (0xA8)\n    INVALID_VALUE, // input 169 (0xA9)\n    INVALID_VALUE, // input 170 (0xAA)\n    INVALID_VALUE, // input 171 (0xAB)\n    INVALID_VALUE, // input 172 (0xAC)\n    INVALID_VALUE, // input 173 (0xAD)\n    INVALID_VALUE, // input 174 (0xAE)\n    INVALID_VALUE, // input 175 (0xAF)\n    INVALID_VALUE, // input 176 (0xB0)\n    INVALID_VALUE, // input 177 (0xB1)\n    INVALID_VALUE, // input 178 (0xB2)\n    INVALID_VALUE, // input 179 (0xB3)\n    INVALID_VALUE, // input 180 (0xB4)\n    INVALID_VALUE, // input 181 (0xB5)\n    INVALID_VALUE, // input 182 (0xB6)\n    INVALID_VALUE, // input 183 (0xB7)\n    INVALID_VALUE, // input 184 (0xB8)\n    INVALID_VALUE, // input 185 (0xB9)\n    INVALID_VALUE, // input 186 (0xBA)\n    INVALID_VALUE, // input 187 (0xBB)\n    INVALID_VALUE, // input 188 (0xBC)\n    INVALID_VALUE, // input 189 (0xBD)\n    INVALID_VALUE, // input 190 (0xBE)\n    INVALID_VALUE, // input 191 (0xBF)\n    INVALID_VALUE, // input 192 (0xC0)\n    INVALID_VALUE, // input 193 (0xC1)\n    INVALID_VALUE, // input 194 (0xC2)\n    INVALID_VALUE, // input 195 (0xC3)\n    INVALID_VALUE, // input 196 (0xC4)\n    INVALID_VALUE, // input 197 (0xC5)\n    INVALID_VALUE, // input 198 (0xC6)\n    INVALID_VALUE, // input 199 (0xC7)\n    INVALID_VALUE, // input 200 (0xC8)\n    INVALID_VALUE, // input 201 (0xC9)\n    INVALID_VALUE, // input 202 (0xCA)\n    INVALID_VALUE, // input 203 (0xCB)\n    INVALID_VALUE, // input 204 (0xCC)\n    INVALID_VALUE, // input 205 (0xCD)\n    INVALID_VALUE, // input 206 (0xCE)\n    INVALID_VALUE, // input 207 (0xCF)\n    INVALID_VALUE, // input 208 (0xD0)\n    INVALID_VALUE, // input 209 (0xD1)\n    INVALID_VALUE, // input 210 (0xD2)\n    INVALID_VALUE, // input 211 (0xD3)\n    INVALID_VALUE, // input 212 (0xD4)\n    INVALID_VALUE, // input 213 (0xD5)\n    INVALID_VALUE, // input 214 (0xD6)\n    INVALID_VALUE, // input 215 (0xD7)\n    INVALID_VALUE, // input 216 (0xD8)\n    INVALID_VALUE, // input 217 (0xD9)\n    INVALID_VALUE, // input 218 (0xDA)\n    INVALID_VALUE, // input 219 (0xDB)\n    INVALID_VALUE, // input 220 (0xDC)\n    INVALID_VALUE, // input 221 (0xDD)\n    INVALID_VALUE, // input 222 (0xDE)\n    INVALID_VALUE, // input 223 (0xDF)\n    INVALID_VALUE, // input 224 (0xE0)\n    INVALID_VALUE, // input 225 (0xE1)\n    INVALID_VALUE, // input 226 (0xE2)\n    INVALID_VALUE, // input 227 (0xE3)\n    INVALID_VALUE, // input 228 (0xE4)\n    INVALID_VALUE, // input 229 (0xE5)\n    INVALID_VALUE, // input 230 (0xE6)\n    INVALID_VALUE, // input 231 (0xE7)\n    INVALID_VALUE, // input 232 (0xE8)\n    INVALID_VALUE, // input 233 (0xE9)\n    INVALID_VALUE, // input 234 (0xEA)\n    INVALID_VALUE, // input 235 (0xEB)\n    INVALID_VALUE, // input 236 (0xEC)\n    INVALID_VALUE, // input 237 (0xED)\n    INVALID_VALUE, // input 238 (0xEE)\n    INVALID_VALUE, // input 239 (0xEF)\n    INVALID_VALUE, // input 240 (0xF0)\n    INVALID_VALUE, // input 241 (0xF1)\n    INVALID_VALUE, // input 242 (0xF2)\n    INVALID_VALUE, // input 243 (0xF3)\n    INVALID_VALUE, // input 244 (0xF4)\n    INVALID_VALUE, // input 245 (0xF5)\n    INVALID_VALUE, // input 246 (0xF6)\n    INVALID_VALUE, // input 247 (0xF7)\n    INVALID_VALUE, // input 248 (0xF8)\n    INVALID_VALUE, // input 249 (0xF9)\n    INVALID_VALUE, // input 250 (0xFA)\n    INVALID_VALUE, // input 251 (0xFB)\n    INVALID_VALUE, // input 252 (0xFC)\n    INVALID_VALUE, // input 253 (0xFD)\n    INVALID_VALUE, // input 254 (0xFE)\n    INVALID_VALUE, // input 255 (0xFF)\n];\n#[rustfmt::skip]\npub const IMAP_MUTF7_ENCODE: &[u8; 64] = &[\n    65, // input 0 (0x0) => 'A' (0x41)\n    66, // input 1 (0x1) => 'B' (0x42)\n    67, // input 2 (0x2) => 'C' (0x43)\n    68, // input 3 (0x3) => 'D' (0x44)\n    69, // input 4 (0x4) => 'E' (0x45)\n    70, // input 5 (0x5) => 'F' (0x46)\n    71, // input 6 (0x6) => 'G' (0x47)\n    72, // input 7 (0x7) => 'H' (0x48)\n    73, // input 8 (0x8) => 'I' (0x49)\n    74, // input 9 (0x9) => 'J' (0x4A)\n    75, // input 10 (0xA) => 'K' (0x4B)\n    76, // input 11 (0xB) => 'L' (0x4C)\n    77, // input 12 (0xC) => 'M' (0x4D)\n    78, // input 13 (0xD) => 'N' (0x4E)\n    79, // input 14 (0xE) => 'O' (0x4F)\n    80, // input 15 (0xF) => 'P' (0x50)\n    81, // input 16 (0x10) => 'Q' (0x51)\n    82, // input 17 (0x11) => 'R' (0x52)\n    83, // input 18 (0x12) => 'S' (0x53)\n    84, // input 19 (0x13) => 'T' (0x54)\n    85, // input 20 (0x14) => 'U' (0x55)\n    86, // input 21 (0x15) => 'V' (0x56)\n    87, // input 22 (0x16) => 'W' (0x57)\n    88, // input 23 (0x17) => 'X' (0x58)\n    89, // input 24 (0x18) => 'Y' (0x59)\n    90, // input 25 (0x19) => 'Z' (0x5A)\n    97, // input 26 (0x1A) => 'a' (0x61)\n    98, // input 27 (0x1B) => 'b' (0x62)\n    99, // input 28 (0x1C) => 'c' (0x63)\n    100, // input 29 (0x1D) => 'd' (0x64)\n    101, // input 30 (0x1E) => 'e' (0x65)\n    102, // input 31 (0x1F) => 'f' (0x66)\n    103, // input 32 (0x20) => 'g' (0x67)\n    104, // input 33 (0x21) => 'h' (0x68)\n    105, // input 34 (0x22) => 'i' (0x69)\n    106, // input 35 (0x23) => 'j' (0x6A)\n    107, // input 36 (0x24) => 'k' (0x6B)\n    108, // input 37 (0x25) => 'l' (0x6C)\n    109, // input 38 (0x26) => 'm' (0x6D)\n    110, // input 39 (0x27) => 'n' (0x6E)\n    111, // input 40 (0x28) => 'o' (0x6F)\n    112, // input 41 (0x29) => 'p' (0x70)\n    113, // input 42 (0x2A) => 'q' (0x71)\n    114, // input 43 (0x2B) => 'r' (0x72)\n    115, // input 44 (0x2C) => 's' (0x73)\n    116, // input 45 (0x2D) => 't' (0x74)\n    117, // input 46 (0x2E) => 'u' (0x75)\n    118, // input 47 (0x2F) => 'v' (0x76)\n    119, // input 48 (0x30) => 'w' (0x77)\n    120, // input 49 (0x31) => 'x' (0x78)\n    121, // input 50 (0x32) => 'y' (0x79)\n    122, // input 51 (0x33) => 'z' (0x7A)\n    48, // input 52 (0x34) => '0' (0x30)\n    49, // input 53 (0x35) => '1' (0x31)\n    50, // input 54 (0x36) => '2' (0x32)\n    51, // input 55 (0x37) => '3' (0x33)\n    52, // input 56 (0x38) => '4' (0x34)\n    53, // input 57 (0x39) => '5' (0x35)\n    54, // input 58 (0x3A) => '6' (0x36)\n    55, // input 59 (0x3B) => '7' (0x37)\n    56, // input 60 (0x3C) => '8' (0x38)\n    57, // input 61 (0x3D) => '9' (0x39)\n    43, // input 62 (0x3E) => '+' (0x2B)\n    44, // input 63 (0x3F) => ',' (0x2C)\n];\n#[rustfmt::skip]\npub const IMAP_MUTF7_DECODE: &[u8; 256] = &[\n    INVALID_VALUE, // input 0 (0x0)\n    INVALID_VALUE, // input 1 (0x1)\n    INVALID_VALUE, // input 2 (0x2)\n    INVALID_VALUE, // input 3 (0x3)\n    INVALID_VALUE, // input 4 (0x4)\n    INVALID_VALUE, // input 5 (0x5)\n    INVALID_VALUE, // input 6 (0x6)\n    INVALID_VALUE, // input 7 (0x7)\n    INVALID_VALUE, // input 8 (0x8)\n    INVALID_VALUE, // input 9 (0x9)\n    INVALID_VALUE, // input 10 (0xA)\n    INVALID_VALUE, // input 11 (0xB)\n    INVALID_VALUE, // input 12 (0xC)\n    INVALID_VALUE, // input 13 (0xD)\n    INVALID_VALUE, // input 14 (0xE)\n    INVALID_VALUE, // input 15 (0xF)\n    INVALID_VALUE, // input 16 (0x10)\n    INVALID_VALUE, // input 17 (0x11)\n    INVALID_VALUE, // input 18 (0x12)\n    INVALID_VALUE, // input 19 (0x13)\n    INVALID_VALUE, // input 20 (0x14)\n    INVALID_VALUE, // input 21 (0x15)\n    INVALID_VALUE, // input 22 (0x16)\n    INVALID_VALUE, // input 23 (0x17)\n    INVALID_VALUE, // input 24 (0x18)\n    INVALID_VALUE, // input 25 (0x19)\n    INVALID_VALUE, // input 26 (0x1A)\n    INVALID_VALUE, // input 27 (0x1B)\n    INVALID_VALUE, // input 28 (0x1C)\n    INVALID_VALUE, // input 29 (0x1D)\n    INVALID_VALUE, // input 30 (0x1E)\n    INVALID_VALUE, // input 31 (0x1F)\n    INVALID_VALUE, // input 32 (0x20)\n    INVALID_VALUE, // input 33 (0x21)\n    INVALID_VALUE, // input 34 (0x22)\n    INVALID_VALUE, // input 35 (0x23)\n    INVALID_VALUE, // input 36 (0x24)\n    INVALID_VALUE, // input 37 (0x25)\n    INVALID_VALUE, // input 38 (0x26)\n    INVALID_VALUE, // input 39 (0x27)\n    INVALID_VALUE, // input 40 (0x28)\n    INVALID_VALUE, // input 41 (0x29)\n    INVALID_VALUE, // input 42 (0x2A)\n    62, // input 43 (0x2B char '+') => 62 (0x3E)\n    63, // input 44 (0x2C char ',') => 63 (0x3F)\n    INVALID_VALUE, // input 45 (0x2D)\n    INVALID_VALUE, // input 46 (0x2E)\n    INVALID_VALUE, // input 47 (0x2F)\n    52, // input 48 (0x30 char '0') => 52 (0x34)\n    53, // input 49 (0x31 char '1') => 53 (0x35)\n    54, // input 50 (0x32 char '2') => 54 (0x36)\n    55, // input 51 (0x33 char '3') => 55 (0x37)\n    56, // input 52 (0x34 char '4') => 56 (0x38)\n    57, // input 53 (0x35 char '5') => 57 (0x39)\n    58, // input 54 (0x36 char '6') => 58 (0x3A)\n    59, // input 55 (0x37 char '7') => 59 (0x3B)\n    60, // input 56 (0x38 char '8') => 60 (0x3C)\n    61, // input 57 (0x39 char '9') => 61 (0x3D)\n    INVALID_VALUE, // input 58 (0x3A)\n    INVALID_VALUE, // input 59 (0x3B)\n    INVALID_VALUE, // input 60 (0x3C)\n    INVALID_VALUE, // input 61 (0x3D)\n    INVALID_VALUE, // input 62 (0x3E)\n    INVALID_VALUE, // input 63 (0x3F)\n    INVALID_VALUE, // input 64 (0x40)\n    0, // input 65 (0x41 char 'A') => 0 (0x0)\n    1, // input 66 (0x42 char 'B') => 1 (0x1)\n    2, // input 67 (0x43 char 'C') => 2 (0x2)\n    3, // input 68 (0x44 char 'D') => 3 (0x3)\n    4, // input 69 (0x45 char 'E') => 4 (0x4)\n    5, // input 70 (0x46 char 'F') => 5 (0x5)\n    6, // input 71 (0x47 char 'G') => 6 (0x6)\n    7, // input 72 (0x48 char 'H') => 7 (0x7)\n    8, // input 73 (0x49 char 'I') => 8 (0x8)\n    9, // input 74 (0x4A char 'J') => 9 (0x9)\n    10, // input 75 (0x4B char 'K') => 10 (0xA)\n    11, // input 76 (0x4C char 'L') => 11 (0xB)\n    12, // input 77 (0x4D char 'M') => 12 (0xC)\n    13, // input 78 (0x4E char 'N') => 13 (0xD)\n    14, // input 79 (0x4F char 'O') => 14 (0xE)\n    15, // input 80 (0x50 char 'P') => 15 (0xF)\n    16, // input 81 (0x51 char 'Q') => 16 (0x10)\n    17, // input 82 (0x52 char 'R') => 17 (0x11)\n    18, // input 83 (0x53 char 'S') => 18 (0x12)\n    19, // input 84 (0x54 char 'T') => 19 (0x13)\n    20, // input 85 (0x55 char 'U') => 20 (0x14)\n    21, // input 86 (0x56 char 'V') => 21 (0x15)\n    22, // input 87 (0x57 char 'W') => 22 (0x16)\n    23, // input 88 (0x58 char 'X') => 23 (0x17)\n    24, // input 89 (0x59 char 'Y') => 24 (0x18)\n    25, // input 90 (0x5A char 'Z') => 25 (0x19)\n    INVALID_VALUE, // input 91 (0x5B)\n    INVALID_VALUE, // input 92 (0x5C)\n    INVALID_VALUE, // input 93 (0x5D)\n    INVALID_VALUE, // input 94 (0x5E)\n    INVALID_VALUE, // input 95 (0x5F)\n    INVALID_VALUE, // input 96 (0x60)\n    26, // input 97 (0x61 char 'a') => 26 (0x1A)\n    27, // input 98 (0x62 char 'b') => 27 (0x1B)\n    28, // input 99 (0x63 char 'c') => 28 (0x1C)\n    29, // input 100 (0x64 char 'd') => 29 (0x1D)\n    30, // input 101 (0x65 char 'e') => 30 (0x1E)\n    31, // input 102 (0x66 char 'f') => 31 (0x1F)\n    32, // input 103 (0x67 char 'g') => 32 (0x20)\n    33, // input 104 (0x68 char 'h') => 33 (0x21)\n    34, // input 105 (0x69 char 'i') => 34 (0x22)\n    35, // input 106 (0x6A char 'j') => 35 (0x23)\n    36, // input 107 (0x6B char 'k') => 36 (0x24)\n    37, // input 108 (0x6C char 'l') => 37 (0x25)\n    38, // input 109 (0x6D char 'm') => 38 (0x26)\n    39, // input 110 (0x6E char 'n') => 39 (0x27)\n    40, // input 111 (0x6F char 'o') => 40 (0x28)\n    41, // input 112 (0x70 char 'p') => 41 (0x29)\n    42, // input 113 (0x71 char 'q') => 42 (0x2A)\n    43, // input 114 (0x72 char 'r') => 43 (0x2B)\n    44, // input 115 (0x73 char 's') => 44 (0x2C)\n    45, // input 116 (0x74 char 't') => 45 (0x2D)\n    46, // input 117 (0x75 char 'u') => 46 (0x2E)\n    47, // input 118 (0x76 char 'v') => 47 (0x2F)\n    48, // input 119 (0x77 char 'w') => 48 (0x30)\n    49, // input 120 (0x78 char 'x') => 49 (0x31)\n    50, // input 121 (0x79 char 'y') => 50 (0x32)\n    51, // input 122 (0x7A char 'z') => 51 (0x33)\n    INVALID_VALUE, // input 123 (0x7B)\n    INVALID_VALUE, // input 124 (0x7C)\n    INVALID_VALUE, // input 125 (0x7D)\n    INVALID_VALUE, // input 126 (0x7E)\n    INVALID_VALUE, // input 127 (0x7F)\n    INVALID_VALUE, // input 128 (0x80)\n    INVALID_VALUE, // input 129 (0x81)\n    INVALID_VALUE, // input 130 (0x82)\n    INVALID_VALUE, // input 131 (0x83)\n    INVALID_VALUE, // input 132 (0x84)\n    INVALID_VALUE, // input 133 (0x85)\n    INVALID_VALUE, // input 134 (0x86)\n    INVALID_VALUE, // input 135 (0x87)\n    INVALID_VALUE, // input 136 (0x88)\n    INVALID_VALUE, // input 137 (0x89)\n    INVALID_VALUE, // input 138 (0x8A)\n    INVALID_VALUE, // input 139 (0x8B)\n    INVALID_VALUE, // input 140 (0x8C)\n    INVALID_VALUE, // input 141 (0x8D)\n    INVALID_VALUE, // input 142 (0x8E)\n    INVALID_VALUE, // input 143 (0x8F)\n    INVALID_VALUE, // input 144 (0x90)\n    INVALID_VALUE, // input 145 (0x91)\n    INVALID_VALUE, // input 146 (0x92)\n    INVALID_VALUE, // input 147 (0x93)\n    INVALID_VALUE, // input 148 (0x94)\n    INVALID_VALUE, // input 149 (0x95)\n    INVALID_VALUE, // input 150 (0x96)\n    INVALID_VALUE, // input 151 (0x97)\n    INVALID_VALUE, // input 152 (0x98)\n    INVALID_VALUE, // input 153 (0x99)\n    INVALID_VALUE, // input 154 (0x9A)\n    INVALID_VALUE, // input 155 (0x9B)\n    INVALID_VALUE, // input 156 (0x9C)\n    INVALID_VALUE, // input 157 (0x9D)\n    INVALID_VALUE, // input 158 (0x9E)\n    INVALID_VALUE, // input 159 (0x9F)\n    INVALID_VALUE, // input 160 (0xA0)\n    INVALID_VALUE, // input 161 (0xA1)\n    INVALID_VALUE, // input 162 (0xA2)\n    INVALID_VALUE, // input 163 (0xA3)\n    INVALID_VALUE, // input 164 (0xA4)\n    INVALID_VALUE, // input 165 (0xA5)\n    INVALID_VALUE, // input 166 (0xA6)\n    INVALID_VALUE, // input 167 (0xA7)\n    INVALID_VALUE, // input 168 (0xA8)\n    INVALID_VALUE, // input 169 (0xA9)\n    INVALID_VALUE, // input 170 (0xAA)\n    INVALID_VALUE, // input 171 (0xAB)\n    INVALID_VALUE, // input 172 (0xAC)\n    INVALID_VALUE, // input 173 (0xAD)\n    INVALID_VALUE, // input 174 (0xAE)\n    INVALID_VALUE, // input 175 (0xAF)\n    INVALID_VALUE, // input 176 (0xB0)\n    INVALID_VALUE, // input 177 (0xB1)\n    INVALID_VALUE, // input 178 (0xB2)\n    INVALID_VALUE, // input 179 (0xB3)\n    INVALID_VALUE, // input 180 (0xB4)\n    INVALID_VALUE, // input 181 (0xB5)\n    INVALID_VALUE, // input 182 (0xB6)\n    INVALID_VALUE, // input 183 (0xB7)\n    INVALID_VALUE, // input 184 (0xB8)\n    INVALID_VALUE, // input 185 (0xB9)\n    INVALID_VALUE, // input 186 (0xBA)\n    INVALID_VALUE, // input 187 (0xBB)\n    INVALID_VALUE, // input 188 (0xBC)\n    INVALID_VALUE, // input 189 (0xBD)\n    INVALID_VALUE, // input 190 (0xBE)\n    INVALID_VALUE, // input 191 (0xBF)\n    INVALID_VALUE, // input 192 (0xC0)\n    INVALID_VALUE, // input 193 (0xC1)\n    INVALID_VALUE, // input 194 (0xC2)\n    INVALID_VALUE, // input 195 (0xC3)\n    INVALID_VALUE, // input 196 (0xC4)\n    INVALID_VALUE, // input 197 (0xC5)\n    INVALID_VALUE, // input 198 (0xC6)\n    INVALID_VALUE, // input 199 (0xC7)\n    INVALID_VALUE, // input 200 (0xC8)\n    INVALID_VALUE, // input 201 (0xC9)\n    INVALID_VALUE, // input 202 (0xCA)\n    INVALID_VALUE, // input 203 (0xCB)\n    INVALID_VALUE, // input 204 (0xCC)\n    INVALID_VALUE, // input 205 (0xCD)\n    INVALID_VALUE, // input 206 (0xCE)\n    INVALID_VALUE, // input 207 (0xCF)\n    INVALID_VALUE, // input 208 (0xD0)\n    INVALID_VALUE, // input 209 (0xD1)\n    INVALID_VALUE, // input 210 (0xD2)\n    INVALID_VALUE, // input 211 (0xD3)\n    INVALID_VALUE, // input 212 (0xD4)\n    INVALID_VALUE, // input 213 (0xD5)\n    INVALID_VALUE, // input 214 (0xD6)\n    INVALID_VALUE, // input 215 (0xD7)\n    INVALID_VALUE, // input 216 (0xD8)\n    INVALID_VALUE, // input 217 (0xD9)\n    INVALID_VALUE, // input 218 (0xDA)\n    INVALID_VALUE, // input 219 (0xDB)\n    INVALID_VALUE, // input 220 (0xDC)\n    INVALID_VALUE, // input 221 (0xDD)\n    INVALID_VALUE, // input 222 (0xDE)\n    INVALID_VALUE, // input 223 (0xDF)\n    INVALID_VALUE, // input 224 (0xE0)\n    INVALID_VALUE, // input 225 (0xE1)\n    INVALID_VALUE, // input 226 (0xE2)\n    INVALID_VALUE, // input 227 (0xE3)\n    INVALID_VALUE, // input 228 (0xE4)\n    INVALID_VALUE, // input 229 (0xE5)\n    INVALID_VALUE, // input 230 (0xE6)\n    INVALID_VALUE, // input 231 (0xE7)\n    INVALID_VALUE, // input 232 (0xE8)\n    INVALID_VALUE, // input 233 (0xE9)\n    INVALID_VALUE, // input 234 (0xEA)\n    INVALID_VALUE, // input 235 (0xEB)\n    INVALID_VALUE, // input 236 (0xEC)\n    INVALID_VALUE, // input 237 (0xED)\n    INVALID_VALUE, // input 238 (0xEE)\n    INVALID_VALUE, // input 239 (0xEF)\n    INVALID_VALUE, // input 240 (0xF0)\n    INVALID_VALUE, // input 241 (0xF1)\n    INVALID_VALUE, // input 242 (0xF2)\n    INVALID_VALUE, // input 243 (0xF3)\n    INVALID_VALUE, // input 244 (0xF4)\n    INVALID_VALUE, // input 245 (0xF5)\n    INVALID_VALUE, // input 246 (0xF6)\n    INVALID_VALUE, // input 247 (0xF7)\n    INVALID_VALUE, // input 248 (0xF8)\n    INVALID_VALUE, // input 249 (0xF9)\n    INVALID_VALUE, // input 250 (0xFA)\n    INVALID_VALUE, // input 251 (0xFB)\n    INVALID_VALUE, // input 252 (0xFC)\n    INVALID_VALUE, // input 253 (0xFD)\n    INVALID_VALUE, // input 254 (0xFE)\n    INVALID_VALUE, // input 255 (0xFF)\n];\n#[rustfmt::skip]\npub const BINHEX_ENCODE: &[u8; 64] = &[\n    33, // input 0 (0x0) => '!' (0x21)\n    34, // input 1 (0x1) => '\"' (0x22)\n    35, // input 2 (0x2) => '#' (0x23)\n    36, // input 3 (0x3) => '$' (0x24)\n    37, // input 4 (0x4) => '%' (0x25)\n    38, // input 5 (0x5) => '&' (0x26)\n    39, // input 6 (0x6) => ''' (0x27)\n    40, // input 7 (0x7) => '(' (0x28)\n    41, // input 8 (0x8) => ')' (0x29)\n    42, // input 9 (0x9) => '*' (0x2A)\n    43, // input 10 (0xA) => '+' (0x2B)\n    44, // input 11 (0xB) => ',' (0x2C)\n    45, // input 12 (0xC) => '-' (0x2D)\n    48, // input 13 (0xD) => '0' (0x30)\n    49, // input 14 (0xE) => '1' (0x31)\n    50, // input 15 (0xF) => '2' (0x32)\n    51, // input 16 (0x10) => '3' (0x33)\n    52, // input 17 (0x11) => '4' (0x34)\n    53, // input 18 (0x12) => '5' (0x35)\n    54, // input 19 (0x13) => '6' (0x36)\n    55, // input 20 (0x14) => '7' (0x37)\n    56, // input 21 (0x15) => '8' (0x38)\n    57, // input 22 (0x16) => '9' (0x39)\n    64, // input 23 (0x17) => '@' (0x40)\n    65, // input 24 (0x18) => 'A' (0x41)\n    66, // input 25 (0x19) => 'B' (0x42)\n    67, // input 26 (0x1A) => 'C' (0x43)\n    68, // input 27 (0x1B) => 'D' (0x44)\n    69, // input 28 (0x1C) => 'E' (0x45)\n    70, // input 29 (0x1D) => 'F' (0x46)\n    71, // input 30 (0x1E) => 'G' (0x47)\n    72, // input 31 (0x1F) => 'H' (0x48)\n    73, // input 32 (0x20) => 'I' (0x49)\n    74, // input 33 (0x21) => 'J' (0x4A)\n    75, // input 34 (0x22) => 'K' (0x4B)\n    76, // input 35 (0x23) => 'L' (0x4C)\n    77, // input 36 (0x24) => 'M' (0x4D)\n    78, // input 37 (0x25) => 'N' (0x4E)\n    80, // input 38 (0x26) => 'P' (0x50)\n    81, // input 39 (0x27) => 'Q' (0x51)\n    82, // input 40 (0x28) => 'R' (0x52)\n    83, // input 41 (0x29) => 'S' (0x53)\n    84, // input 42 (0x2A) => 'T' (0x54)\n    85, // input 43 (0x2B) => 'U' (0x55)\n    86, // input 44 (0x2C) => 'V' (0x56)\n    88, // input 45 (0x2D) => 'X' (0x58)\n    89, // input 46 (0x2E) => 'Y' (0x59)\n    90, // input 47 (0x2F) => 'Z' (0x5A)\n    91, // input 48 (0x30) => '[' (0x5B)\n    96, // input 49 (0x31) => '`' (0x60)\n    97, // input 50 (0x32) => 'a' (0x61)\n    98, // input 51 (0x33) => 'b' (0x62)\n    99, // input 52 (0x34) => 'c' (0x63)\n    100, // input 53 (0x35) => 'd' (0x64)\n    101, // input 54 (0x36) => 'e' (0x65)\n    104, // input 55 (0x37) => 'h' (0x68)\n    105, // input 56 (0x38) => 'i' (0x69)\n    106, // input 57 (0x39) => 'j' (0x6A)\n    107, // input 58 (0x3A) => 'k' (0x6B)\n    108, // input 59 (0x3B) => 'l' (0x6C)\n    109, // input 60 (0x3C) => 'm' (0x6D)\n    112, // input 61 (0x3D) => 'p' (0x70)\n    113, // input 62 (0x3E) => 'q' (0x71)\n    114, // input 63 (0x3F) => 'r' (0x72)\n];\n#[rustfmt::skip]\npub const BINHEX_DECODE: &[u8; 256] = &[\n    INVALID_VALUE, // input 0 (0x0)\n    INVALID_VALUE, // input 1 (0x1)\n    INVALID_VALUE, // input 2 (0x2)\n    INVALID_VALUE, // input 3 (0x3)\n    INVALID_VALUE, // input 4 (0x4)\n    INVALID_VALUE, // input 5 (0x5)\n    INVALID_VALUE, // input 6 (0x6)\n    INVALID_VALUE, // input 7 (0x7)\n    INVALID_VALUE, // input 8 (0x8)\n    INVALID_VALUE, // input 9 (0x9)\n    INVALID_VALUE, // input 10 (0xA)\n    INVALID_VALUE, // input 11 (0xB)\n    INVALID_VALUE, // input 12 (0xC)\n    INVALID_VALUE, // input 13 (0xD)\n    INVALID_VALUE, // input 14 (0xE)\n    INVALID_VALUE, // input 15 (0xF)\n    INVALID_VALUE, // input 16 (0x10)\n    INVALID_VALUE, // input 17 (0x11)\n    INVALID_VALUE, // input 18 (0x12)\n    INVALID_VALUE, // input 19 (0x13)\n    INVALID_VALUE, // input 20 (0x14)\n    INVALID_VALUE, // input 21 (0x15)\n    INVALID_VALUE, // input 22 (0x16)\n    INVALID_VALUE, // input 23 (0x17)\n    INVALID_VALUE, // input 24 (0x18)\n    INVALID_VALUE, // input 25 (0x19)\n    INVALID_VALUE, // input 26 (0x1A)\n    INVALID_VALUE, // input 27 (0x1B)\n    INVALID_VALUE, // input 28 (0x1C)\n    INVALID_VALUE, // input 29 (0x1D)\n    INVALID_VALUE, // input 30 (0x1E)\n    INVALID_VALUE, // input 31 (0x1F)\n    INVALID_VALUE, // input 32 (0x20)\n    0, // input 33 (0x21 char '!') => 0 (0x0)\n    1, // input 34 (0x22 char '\"') => 1 (0x1)\n    2, // input 35 (0x23 char '#') => 2 (0x2)\n    3, // input 36 (0x24 char '$') => 3 (0x3)\n    4, // input 37 (0x25 char '%') => 4 (0x4)\n    5, // input 38 (0x26 char '&') => 5 (0x5)\n    6, // input 39 (0x27 char ''') => 6 (0x6)\n    7, // input 40 (0x28 char '(') => 7 (0x7)\n    8, // input 41 (0x29 char ')') => 8 (0x8)\n    9, // input 42 (0x2A char '*') => 9 (0x9)\n    10, // input 43 (0x2B char '+') => 10 (0xA)\n    11, // input 44 (0x2C char ',') => 11 (0xB)\n    12, // input 45 (0x2D char '-') => 12 (0xC)\n    INVALID_VALUE, // input 46 (0x2E)\n    INVALID_VALUE, // input 47 (0x2F)\n    13, // input 48 (0x30 char '0') => 13 (0xD)\n    14, // input 49 (0x31 char '1') => 14 (0xE)\n    15, // input 50 (0x32 char '2') => 15 (0xF)\n    16, // input 51 (0x33 char '3') => 16 (0x10)\n    17, // input 52 (0x34 char '4') => 17 (0x11)\n    18, // input 53 (0x35 char '5') => 18 (0x12)\n    19, // input 54 (0x36 char '6') => 19 (0x13)\n    20, // input 55 (0x37 char '7') => 20 (0x14)\n    21, // input 56 (0x38 char '8') => 21 (0x15)\n    22, // input 57 (0x39 char '9') => 22 (0x16)\n    INVALID_VALUE, // input 58 (0x3A)\n    INVALID_VALUE, // input 59 (0x3B)\n    INVALID_VALUE, // input 60 (0x3C)\n    INVALID_VALUE, // input 61 (0x3D)\n    INVALID_VALUE, // input 62 (0x3E)\n    INVALID_VALUE, // input 63 (0x3F)\n    23, // input 64 (0x40 char '@') => 23 (0x17)\n    24, // input 65 (0x41 char 'A') => 24 (0x18)\n    25, // input 66 (0x42 char 'B') => 25 (0x19)\n    26, // input 67 (0x43 char 'C') => 26 (0x1A)\n    27, // input 68 (0x44 char 'D') => 27 (0x1B)\n    28, // input 69 (0x45 char 'E') => 28 (0x1C)\n    29, // input 70 (0x46 char 'F') => 29 (0x1D)\n    30, // input 71 (0x47 char 'G') => 30 (0x1E)\n    31, // input 72 (0x48 char 'H') => 31 (0x1F)\n    32, // input 73 (0x49 char 'I') => 32 (0x20)\n    33, // input 74 (0x4A char 'J') => 33 (0x21)\n    34, // input 75 (0x4B char 'K') => 34 (0x22)\n    35, // input 76 (0x4C char 'L') => 35 (0x23)\n    36, // input 77 (0x4D char 'M') => 36 (0x24)\n    37, // input 78 (0x4E char 'N') => 37 (0x25)\n    INVALID_VALUE, // input 79 (0x4F)\n    38, // input 80 (0x50 char 'P') => 38 (0x26)\n    39, // input 81 (0x51 char 'Q') => 39 (0x27)\n    40, // input 82 (0x52 char 'R') => 40 (0x28)\n    41, // input 83 (0x53 char 'S') => 41 (0x29)\n    42, // input 84 (0x54 char 'T') => 42 (0x2A)\n    43, // input 85 (0x55 char 'U') => 43 (0x2B)\n    44, // input 86 (0x56 char 'V') => 44 (0x2C)\n    INVALID_VALUE, // input 87 (0x57)\n    45, // input 88 (0x58 char 'X') => 45 (0x2D)\n    46, // input 89 (0x59 char 'Y') => 46 (0x2E)\n    47, // input 90 (0x5A char 'Z') => 47 (0x2F)\n    48, // input 91 (0x5B char '[') => 48 (0x30)\n    INVALID_VALUE, // input 92 (0x5C)\n    INVALID_VALUE, // input 93 (0x5D)\n    INVALID_VALUE, // input 94 (0x5E)\n    INVALID_VALUE, // input 95 (0x5F)\n    49, // input 96 (0x60 char '`') => 49 (0x31)\n    50, // input 97 (0x61 char 'a') => 50 (0x32)\n    51, // input 98 (0x62 char 'b') => 51 (0x33)\n    52, // input 99 (0x63 char 'c') => 52 (0x34)\n    53, // input 100 (0x64 char 'd') => 53 (0x35)\n    54, // input 101 (0x65 char 'e') => 54 (0x36)\n    INVALID_VALUE, // input 102 (0x66)\n    INVALID_VALUE, // input 103 (0x67)\n    55, // input 104 (0x68 char 'h') => 55 (0x37)\n    56, // input 105 (0x69 char 'i') => 56 (0x38)\n    57, // input 106 (0x6A char 'j') => 57 (0x39)\n    58, // input 107 (0x6B char 'k') => 58 (0x3A)\n    59, // input 108 (0x6C char 'l') => 59 (0x3B)\n    60, // input 109 (0x6D char 'm') => 60 (0x3C)\n    INVALID_VALUE, // input 110 (0x6E)\n    INVALID_VALUE, // input 111 (0x6F)\n    61, // input 112 (0x70 char 'p') => 61 (0x3D)\n    62, // input 113 (0x71 char 'q') => 62 (0x3E)\n    63, // input 114 (0x72 char 'r') => 63 (0x3F)\n    INVALID_VALUE, // input 115 (0x73)\n    INVALID_VALUE, // input 116 (0x74)\n    INVALID_VALUE, // input 117 (0x75)\n    INVALID_VALUE, // input 118 (0x76)\n    INVALID_VALUE, // input 119 (0x77)\n    INVALID_VALUE, // input 120 (0x78)\n    INVALID_VALUE, // input 121 (0x79)\n    INVALID_VALUE, // input 122 (0x7A)\n    INVALID_VALUE, // input 123 (0x7B)\n    INVALID_VALUE, // input 124 (0x7C)\n    INVALID_VALUE, // input 125 (0x7D)\n    INVALID_VALUE, // input 126 (0x7E)\n    INVALID_VALUE, // input 127 (0x7F)\n    INVALID_VALUE, // input 128 (0x80)\n    INVALID_VALUE, // input 129 (0x81)\n    INVALID_VALUE, // input 130 (0x82)\n    INVALID_VALUE, // input 131 (0x83)\n    INVALID_VALUE, // input 132 (0x84)\n    INVALID_VALUE, // input 133 (0x85)\n    INVALID_VALUE, // input 134 (0x86)\n    INVALID_VALUE, // input 135 (0x87)\n    INVALID_VALUE, // input 136 (0x88)\n    INVALID_VALUE, // input 137 (0x89)\n    INVALID_VALUE, // input 138 (0x8A)\n    INVALID_VALUE, // input 139 (0x8B)\n    INVALID_VALUE, // input 140 (0x8C)\n    INVALID_VALUE, // input 141 (0x8D)\n    INVALID_VALUE, // input 142 (0x8E)\n    INVALID_VALUE, // input 143 (0x8F)\n    INVALID_VALUE, // input 144 (0x90)\n    INVALID_VALUE, // input 145 (0x91)\n    INVALID_VALUE, // input 146 (0x92)\n    INVALID_VALUE, // input 147 (0x93)\n    INVALID_VALUE, // input 148 (0x94)\n    INVALID_VALUE, // input 149 (0x95)\n    INVALID_VALUE, // input 150 (0x96)\n    INVALID_VALUE, // input 151 (0x97)\n    INVALID_VALUE, // input 152 (0x98)\n    INVALID_VALUE, // input 153 (0x99)\n    INVALID_VALUE, // input 154 (0x9A)\n    INVALID_VALUE, // input 155 (0x9B)\n    INVALID_VALUE, // input 156 (0x9C)\n    INVALID_VALUE, // input 157 (0x9D)\n    INVALID_VALUE, // input 158 (0x9E)\n    INVALID_VALUE, // input 159 (0x9F)\n    INVALID_VALUE, // input 160 (0xA0)\n    INVALID_VALUE, // input 161 (0xA1)\n    INVALID_VALUE, // input 162 (0xA2)\n    INVALID_VALUE, // input 163 (0xA3)\n    INVALID_VALUE, // input 164 (0xA4)\n    INVALID_VALUE, // input 165 (0xA5)\n    INVALID_VALUE, // input 166 (0xA6)\n    INVALID_VALUE, // input 167 (0xA7)\n    INVALID_VALUE, // input 168 (0xA8)\n    INVALID_VALUE, // input 169 (0xA9)\n    INVALID_VALUE, // input 170 (0xAA)\n    INVALID_VALUE, // input 171 (0xAB)\n    INVALID_VALUE, // input 172 (0xAC)\n    INVALID_VALUE, // input 173 (0xAD)\n    INVALID_VALUE, // input 174 (0xAE)\n    INVALID_VALUE, // input 175 (0xAF)\n    INVALID_VALUE, // input 176 (0xB0)\n    INVALID_VALUE, // input 177 (0xB1)\n    INVALID_VALUE, // input 178 (0xB2)\n    INVALID_VALUE, // input 179 (0xB3)\n    INVALID_VALUE, // input 180 (0xB4)\n    INVALID_VALUE, // input 181 (0xB5)\n    INVALID_VALUE, // input 182 (0xB6)\n    INVALID_VALUE, // input 183 (0xB7)\n    INVALID_VALUE, // input 184 (0xB8)\n    INVALID_VALUE, // input 185 (0xB9)\n    INVALID_VALUE, // input 186 (0xBA)\n    INVALID_VALUE, // input 187 (0xBB)\n    INVALID_VALUE, // input 188 (0xBC)\n    INVALID_VALUE, // input 189 (0xBD)\n    INVALID_VALUE, // input 190 (0xBE)\n    INVALID_VALUE, // input 191 (0xBF)\n    INVALID_VALUE, // input 192 (0xC0)\n    INVALID_VALUE, // input 193 (0xC1)\n    INVALID_VALUE, // input 194 (0xC2)\n    INVALID_VALUE, // input 195 (0xC3)\n    INVALID_VALUE, // input 196 (0xC4)\n    INVALID_VALUE, // input 197 (0xC5)\n    INVALID_VALUE, // input 198 (0xC6)\n    INVALID_VALUE, // input 199 (0xC7)\n    INVALID_VALUE, // input 200 (0xC8)\n    INVALID_VALUE, // input 201 (0xC9)\n    INVALID_VALUE, // input 202 (0xCA)\n    INVALID_VALUE, // input 203 (0xCB)\n    INVALID_VALUE, // input 204 (0xCC)\n    INVALID_VALUE, // input 205 (0xCD)\n    INVALID_VALUE, // input 206 (0xCE)\n    INVALID_VALUE, // input 207 (0xCF)\n    INVALID_VALUE, // input 208 (0xD0)\n    INVALID_VALUE, // input 209 (0xD1)\n    INVALID_VALUE, // input 210 (0xD2)\n    INVALID_VALUE, // input 211 (0xD3)\n    INVALID_VALUE, // input 212 (0xD4)\n    INVALID_VALUE, // input 213 (0xD5)\n    INVALID_VALUE, // input 214 (0xD6)\n    INVALID_VALUE, // input 215 (0xD7)\n    INVALID_VALUE, // input 216 (0xD8)\n    INVALID_VALUE, // input 217 (0xD9)\n    INVALID_VALUE, // input 218 (0xDA)\n    INVALID_VALUE, // input 219 (0xDB)\n    INVALID_VALUE, // input 220 (0xDC)\n    INVALID_VALUE, // input 221 (0xDD)\n    INVALID_VALUE, // input 222 (0xDE)\n    INVALID_VALUE, // input 223 (0xDF)\n    INVALID_VALUE, // input 224 (0xE0)\n    INVALID_VALUE, // input 225 (0xE1)\n    INVALID_VALUE, // input 226 (0xE2)\n    INVALID_VALUE, // input 227 (0xE3)\n    INVALID_VALUE, // input 228 (0xE4)\n    INVALID_VALUE, // input 229 (0xE5)\n    INVALID_VALUE, // input 230 (0xE6)\n    INVALID_VALUE, // input 231 (0xE7)\n    INVALID_VALUE, // input 232 (0xE8)\n    INVALID_VALUE, // input 233 (0xE9)\n    INVALID_VALUE, // input 234 (0xEA)\n    INVALID_VALUE, // input 235 (0xEB)\n    INVALID_VALUE, // input 236 (0xEC)\n    INVALID_VALUE, // input 237 (0xED)\n    INVALID_VALUE, // input 238 (0xEE)\n    INVALID_VALUE, // input 239 (0xEF)\n    INVALID_VALUE, // input 240 (0xF0)\n    INVALID_VALUE, // input 241 (0xF1)\n    INVALID_VALUE, // input 242 (0xF2)\n    INVALID_VALUE, // input 243 (0xF3)\n    INVALID_VALUE, // input 244 (0xF4)\n    INVALID_VALUE, // input 245 (0xF5)\n    INVALID_VALUE, // input 246 (0xF6)\n    INVALID_VALUE, // input 247 (0xF7)\n    INVALID_VALUE, // input 248 (0xF8)\n    INVALID_VALUE, // input 249 (0xF9)\n    INVALID_VALUE, // input 250 (0xFA)\n    INVALID_VALUE, // input 251 (0xFB)\n    INVALID_VALUE, // input 252 (0xFC)\n    INVALID_VALUE, // input 253 (0xFD)\n    INVALID_VALUE, // input 254 (0xFE)\n    INVALID_VALUE, // input 255 (0xFF)\n];\n"], "fixing_code": ["[package]\nname = \"base64\"\nversion = \"0.13.0\"\nauthors = [\"Alice Maz <alice@alicemaz.com>\", \"Marshall Pierce <marshall@mpierce.org>\"]\ndescription = \"encodes and decodes base64 as bytes or utf8\"\nrepository = \"https://github.com/marshallpierce/rust-base64\"\ndocumentation = \"https://docs.rs/base64\"\nreadme = \"README.md\"\nkeywords = [\"base64\", \"utf8\", \"encode\", \"decode\", \"no_std\"]\ncategories = [\"encoding\"]\nlicense = \"MIT/Apache-2.0\"\nedition = \"2018\"\n\n[[bench]]\nname = \"benchmarks\"\nharness = false\n\n[dev-dependencies]\n# 0.3.3 requires rust 1.36.0 for stable copied()\ncriterion = \"=0.3.2\"\nrand = \"0.6.1\"\nstructopt = \"0.3\"\n\n[features]\ndefault = [\"std\"]\nalloc = []\nstd = []\nslow_but_safe = []\n\n[profile.bench]\n# Useful for better disassembly when using `perf record` and `perf annotate`\ndebug = true\n", "use crate::{tables, Config, PAD_BYTE};\n\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\nuse crate::STANDARD;\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\nuse alloc::vec::Vec;\nuse core::fmt;\n#[cfg(any(feature = \"std\", test))]\nuse std::error;\n\n// decode logic operates on chunks of 8 input bytes without padding\nconst INPUT_CHUNK_LEN: usize = 8;\nconst DECODED_CHUNK_LEN: usize = 6;\n// we read a u64 and write a u64, but a u64 of input only yields 6 bytes of output, so the last\n// 2 bytes of any output u64 should not be counted as written to (but must be available in a\n// slice).\nconst DECODED_CHUNK_SUFFIX: usize = 2;\n\n// how many u64's of input to handle at a time\nconst CHUNKS_PER_FAST_LOOP_BLOCK: usize = 4;\nconst INPUT_BLOCK_LEN: usize = CHUNKS_PER_FAST_LOOP_BLOCK * INPUT_CHUNK_LEN;\n// includes the trailing 2 bytes for the final u64 write\nconst DECODED_BLOCK_LEN: usize =\n    CHUNKS_PER_FAST_LOOP_BLOCK * DECODED_CHUNK_LEN + DECODED_CHUNK_SUFFIX;\n\n/// Errors that can occur while decoding.\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum DecodeError {\n    /// An invalid byte was found in the input. The offset and offending byte are provided.\n    InvalidByte(usize, u8),\n    /// The length of the input is invalid.\n    /// A typical cause of this is stray trailing whitespace or other separator bytes.\n    /// In the case where excess trailing bytes have produced an invalid length *and* the last byte\n    /// is also an invalid base64 symbol (as would be the case for whitespace, etc), `InvalidByte`\n    /// will be emitted instead of `InvalidLength` to make the issue easier to debug.\n    InvalidLength,\n    /// The last non-padding input symbol's encoded 6 bits have nonzero bits that will be discarded.\n    /// This is indicative of corrupted or truncated Base64.\n    /// Unlike InvalidByte, which reports symbols that aren't in the alphabet, this error is for\n    /// symbols that are in the alphabet but represent nonsensical encodings.\n    InvalidLastSymbol(usize, u8),\n}\n\nimpl fmt::Display for DecodeError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            DecodeError::InvalidByte(index, byte) => {\n                write!(f, \"Invalid byte {}, offset {}.\", byte, index)\n            }\n            DecodeError::InvalidLength => write!(f, \"Encoded text cannot have a 6-bit remainder.\"),\n            DecodeError::InvalidLastSymbol(index, byte) => {\n                write!(f, \"Invalid last symbol {}, offset {}.\", byte, index)\n            }\n        }\n    }\n}\n\n#[cfg(any(feature = \"std\", test))]\nimpl error::Error for DecodeError {\n    fn description(&self) -> &str {\n        match *self {\n            DecodeError::InvalidByte(_, _) => \"invalid byte\",\n            DecodeError::InvalidLength => \"invalid length\",\n            DecodeError::InvalidLastSymbol(_, _) => \"invalid last symbol\",\n        }\n    }\n\n    fn cause(&self) -> Option<&dyn error::Error> {\n        None\n    }\n}\n\n///Decode from string reference as octets.\n///Returns a Result containing a Vec<u8>.\n///Convenience `decode_config(input, base64::STANDARD);`.\n///\n///# Example\n///\n///```rust\n///extern crate base64;\n///\n///fn main() {\n///    let bytes = base64::decode(\"aGVsbG8gd29ybGQ=\").unwrap();\n///    println!(\"{:?}\", bytes);\n///}\n///```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub fn decode<T: AsRef<[u8]>>(input: T) -> Result<Vec<u8>, DecodeError> {\n    decode_config(input, STANDARD)\n}\n\n///Decode from string reference as octets.\n///Returns a Result containing a Vec<u8>.\n///\n///# Example\n///\n///```rust\n///extern crate base64;\n///\n///fn main() {\n///    let bytes = base64::decode_config(\"aGVsbG8gd29ybGR+Cg==\", base64::STANDARD).unwrap();\n///    println!(\"{:?}\", bytes);\n///\n///    let bytes_url = base64::decode_config(\"aGVsbG8gaW50ZXJuZXR-Cg==\", base64::URL_SAFE).unwrap();\n///    println!(\"{:?}\", bytes_url);\n///}\n///```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub fn decode_config<T: AsRef<[u8]>>(input: T, config: Config) -> Result<Vec<u8>, DecodeError> {\n    let mut buffer = Vec::<u8>::with_capacity(input.as_ref().len() * 4 / 3);\n\n    decode_config_buf(input, config, &mut buffer).map(|_| buffer)\n}\n\n///Decode from string reference as octets.\n///Writes into the supplied buffer to avoid allocation.\n///Returns a Result containing an empty tuple, aka ().\n///\n///# Example\n///\n///```rust\n///extern crate base64;\n///\n///fn main() {\n///    let mut buffer = Vec::<u8>::new();\n///    base64::decode_config_buf(\"aGVsbG8gd29ybGR+Cg==\", base64::STANDARD, &mut buffer).unwrap();\n///    println!(\"{:?}\", buffer);\n///\n///    buffer.clear();\n///\n///    base64::decode_config_buf(\"aGVsbG8gaW50ZXJuZXR-Cg==\", base64::URL_SAFE, &mut buffer)\n///        .unwrap();\n///    println!(\"{:?}\", buffer);\n///}\n///```\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub fn decode_config_buf<T: AsRef<[u8]>>(\n    input: T,\n    config: Config,\n    buffer: &mut Vec<u8>,\n) -> Result<(), DecodeError> {\n    let input_bytes = input.as_ref();\n\n    let starting_output_len = buffer.len();\n\n    let num_chunks = num_chunks(input_bytes);\n    let decoded_len_estimate = num_chunks\n        .checked_mul(DECODED_CHUNK_LEN)\n        .and_then(|p| p.checked_add(starting_output_len))\n        .expect(\"Overflow when calculating output buffer length\");\n    buffer.resize(decoded_len_estimate, 0);\n\n    let bytes_written;\n    {\n        let buffer_slice = &mut buffer.as_mut_slice()[starting_output_len..];\n        bytes_written = decode_helper(input_bytes, num_chunks, config, buffer_slice)?;\n    }\n\n    buffer.truncate(starting_output_len + bytes_written);\n\n    Ok(())\n}\n\n/// Decode the input into the provided output slice.\n///\n/// This will not write any bytes past exactly what is decoded (no stray garbage bytes at the end).\n///\n/// If you don't know ahead of time what the decoded length should be, size your buffer with a\n/// conservative estimate for the decoded length of an input: 3 bytes of output for every 4 bytes of\n/// input, rounded up, or in other words `(input_len + 3) / 4 * 3`.\n///\n/// If the slice is not large enough, this will panic.\npub fn decode_config_slice<T: AsRef<[u8]>>(\n    input: T,\n    config: Config,\n    output: &mut [u8],\n) -> Result<usize, DecodeError> {\n    let input_bytes = input.as_ref();\n\n    decode_helper(input_bytes, num_chunks(input_bytes), config, output)\n}\n\n/// Return the number of input chunks (including a possibly partial final chunk) in the input\nfn num_chunks(input: &[u8]) -> usize {\n    input\n        .len()\n        .checked_add(INPUT_CHUNK_LEN - 1)\n        .expect(\"Overflow when calculating number of chunks in input\")\n        / INPUT_CHUNK_LEN\n}\n\n/// Helper to avoid duplicating num_chunks calculation, which is costly on short inputs.\n/// Returns the number of bytes written, or an error.\n// We're on the fragile edge of compiler heuristics here. If this is not inlined, slow. If this is\n// inlined(always), a different slow. plain ol' inline makes the benchmarks happiest at the moment,\n// but this is fragile and the best setting changes with only minor code modifications.\n#[inline]\nfn decode_helper(\n    input: &[u8],\n    num_chunks: usize,\n    config: Config,\n    output: &mut [u8],\n) -> Result<usize, DecodeError> {\n    let char_set = config.char_set;\n    let decode_table = char_set.decode_table();\n\n    let remainder_len = input.len() % INPUT_CHUNK_LEN;\n\n    // Because the fast decode loop writes in groups of 8 bytes (unrolled to\n    // CHUNKS_PER_FAST_LOOP_BLOCK times 8 bytes, where possible) and outputs 8 bytes at a time (of\n    // which only 6 are valid data), we need to be sure that we stop using the fast decode loop\n    // soon enough that there will always be 2 more bytes of valid data written after that loop.\n    let trailing_bytes_to_skip = match remainder_len {\n        // if input is a multiple of the chunk size, ignore the last chunk as it may have padding,\n        // and the fast decode logic cannot handle padding\n        0 => INPUT_CHUNK_LEN,\n        // 1 and 5 trailing bytes are illegal: can't decode 6 bits of input into a byte\n        1 | 5 => {\n            // trailing whitespace is so common that it's worth it to check the last byte to\n            // possibly return a better error message\n            if let Some(b) = input.last() {\n                if *b != PAD_BYTE && decode_table[*b as usize] == tables::INVALID_VALUE {\n                    return Err(DecodeError::InvalidByte(input.len() - 1, *b));\n                }\n            }\n\n            return Err(DecodeError::InvalidLength);\n        }\n        // This will decode to one output byte, which isn't enough to overwrite the 2 extra bytes\n        // written by the fast decode loop. So, we have to ignore both these 2 bytes and the\n        // previous chunk.\n        2 => INPUT_CHUNK_LEN + 2,\n        // If this is 3 unpadded chars, then it would actually decode to 2 bytes. However, if this\n        // is an erroneous 2 chars + 1 pad char that would decode to 1 byte, then it should fail\n        // with an error, not panic from going past the bounds of the output slice, so we let it\n        // use stage 3 + 4.\n        3 => INPUT_CHUNK_LEN + 3,\n        // This can also decode to one output byte because it may be 2 input chars + 2 padding\n        // chars, which would decode to 1 byte.\n        4 => INPUT_CHUNK_LEN + 4,\n        // Everything else is a legal decode len (given that we don't require padding), and will\n        // decode to at least 2 bytes of output.\n        _ => remainder_len,\n    };\n\n    // rounded up to include partial chunks\n    let mut remaining_chunks = num_chunks;\n\n    let mut input_index = 0;\n    let mut output_index = 0;\n\n    {\n        let length_of_fast_decode_chunks = input.len().saturating_sub(trailing_bytes_to_skip);\n\n        // Fast loop, stage 1\n        // manual unroll to CHUNKS_PER_FAST_LOOP_BLOCK of u64s to amortize slice bounds checks\n        if let Some(max_start_index) = length_of_fast_decode_chunks.checked_sub(INPUT_BLOCK_LEN) {\n            while input_index <= max_start_index {\n                let input_slice = &input[input_index..(input_index + INPUT_BLOCK_LEN)];\n                let output_slice = &mut output[output_index..(output_index + DECODED_BLOCK_LEN)];\n\n                decode_chunk(\n                    &input_slice[0..],\n                    input_index,\n                    decode_table,\n                    &mut output_slice[0..],\n                )?;\n                decode_chunk(\n                    &input_slice[8..],\n                    input_index + 8,\n                    decode_table,\n                    &mut output_slice[6..],\n                )?;\n                decode_chunk(\n                    &input_slice[16..],\n                    input_index + 16,\n                    decode_table,\n                    &mut output_slice[12..],\n                )?;\n                decode_chunk(\n                    &input_slice[24..],\n                    input_index + 24,\n                    decode_table,\n                    &mut output_slice[18..],\n                )?;\n\n                input_index += INPUT_BLOCK_LEN;\n                output_index += DECODED_BLOCK_LEN - DECODED_CHUNK_SUFFIX;\n                remaining_chunks -= CHUNKS_PER_FAST_LOOP_BLOCK;\n            }\n        }\n\n        // Fast loop, stage 2 (aka still pretty fast loop)\n        // 8 bytes at a time for whatever we didn't do in stage 1.\n        if let Some(max_start_index) = length_of_fast_decode_chunks.checked_sub(INPUT_CHUNK_LEN) {\n            while input_index < max_start_index {\n                decode_chunk(\n                    &input[input_index..(input_index + INPUT_CHUNK_LEN)],\n                    input_index,\n                    decode_table,\n                    &mut output\n                        [output_index..(output_index + DECODED_CHUNK_LEN + DECODED_CHUNK_SUFFIX)],\n                )?;\n\n                output_index += DECODED_CHUNK_LEN;\n                input_index += INPUT_CHUNK_LEN;\n                remaining_chunks -= 1;\n            }\n        }\n    }\n\n    // Stage 3\n    // If input length was such that a chunk had to be deferred until after the fast loop\n    // because decoding it would have produced 2 trailing bytes that wouldn't then be\n    // overwritten, we decode that chunk here. This way is slower but doesn't write the 2\n    // trailing bytes.\n    // However, we still need to avoid the last chunk (partial or complete) because it could\n    // have padding, so we always do 1 fewer to avoid the last chunk.\n    for _ in 1..remaining_chunks {\n        decode_chunk_precise(\n            &input[input_index..],\n            input_index,\n            decode_table,\n            &mut output[output_index..(output_index + DECODED_CHUNK_LEN)],\n        )?;\n\n        input_index += INPUT_CHUNK_LEN;\n        output_index += DECODED_CHUNK_LEN;\n    }\n\n    // always have one more (possibly partial) block of 8 input\n    debug_assert!(input.len() - input_index > 1 || input.is_empty());\n    debug_assert!(input.len() - input_index <= 8);\n\n    // Stage 4\n    // Finally, decode any leftovers that aren't a complete input block of 8 bytes.\n    // Use a u64 as a stack-resident 8 byte buffer.\n    let mut leftover_bits: u64 = 0;\n    let mut morsels_in_leftover = 0;\n    let mut padding_bytes = 0;\n    let mut first_padding_index: usize = 0;\n    let mut last_symbol = 0_u8;\n    let start_of_leftovers = input_index;\n    for (i, b) in input[start_of_leftovers..].iter().enumerate() {\n        // '=' padding\n        if *b == PAD_BYTE {\n            // There can be bad padding in a few ways:\n            // 1 - Padding with non-padding characters after it\n            // 2 - Padding after zero or one non-padding characters before it\n            //     in the current quad.\n            // 3 - More than two characters of padding. If 3 or 4 padding chars\n            //     are in the same quad, that implies it will be caught by #2.\n            //     If it spreads from one quad to another, it will be caught by\n            //     #2 in the second quad.\n\n            if i % 4 < 2 {\n                // Check for case #2.\n                let bad_padding_index = start_of_leftovers\n                    + if padding_bytes > 0 {\n                        // If we've already seen padding, report the first padding index.\n                        // This is to be consistent with the faster logic above: it will report an\n                        // error on the first padding character (since it doesn't expect to see\n                        // anything but actual encoded data).\n                        first_padding_index\n                    } else {\n                        // haven't seen padding before, just use where we are now\n                        i\n                    };\n                return Err(DecodeError::InvalidByte(bad_padding_index, *b));\n            }\n\n            if padding_bytes == 0 {\n                first_padding_index = i;\n            }\n\n            padding_bytes += 1;\n            continue;\n        }\n\n        // Check for case #1.\n        // To make '=' handling consistent with the main loop, don't allow\n        // non-suffix '=' in trailing chunk either. Report error as first\n        // erroneous padding.\n        if padding_bytes > 0 {\n            return Err(DecodeError::InvalidByte(\n                start_of_leftovers + first_padding_index,\n                PAD_BYTE,\n            ));\n        }\n        last_symbol = *b;\n\n        // can use up to 8 * 6 = 48 bits of the u64, if last chunk has no padding.\n        // To minimize shifts, pack the leftovers from left to right.\n        let shift = 64 - (morsels_in_leftover + 1) * 6;\n        // tables are all 256 elements, lookup with a u8 index always succeeds\n        let morsel = decode_table[*b as usize];\n        if morsel == tables::INVALID_VALUE {\n            return Err(DecodeError::InvalidByte(start_of_leftovers + i, *b));\n        }\n\n        leftover_bits |= (morsel as u64) << shift;\n        morsels_in_leftover += 1;\n    }\n\n    let leftover_bits_ready_to_append = match morsels_in_leftover {\n        0 => 0,\n        2 => 8,\n        3 => 16,\n        4 => 24,\n        6 => 32,\n        7 => 40,\n        8 => 48,\n        _ => unreachable!(\n            \"Impossible: must only have 0 to 8 input bytes in last chunk, with no invalid lengths\"\n        ),\n    };\n\n    // if there are bits set outside the bits we care about, last symbol encodes trailing bits that\n    // will not be included in the output\n    let mask = !0 >> leftover_bits_ready_to_append;\n    if !config.decode_allow_trailing_bits && (leftover_bits & mask) != 0 {\n        // last morsel is at `morsels_in_leftover` - 1\n        return Err(DecodeError::InvalidLastSymbol(\n            start_of_leftovers + morsels_in_leftover - 1,\n            last_symbol,\n        ));\n    }\n\n    let mut leftover_bits_appended_to_buf = 0;\n    while leftover_bits_appended_to_buf < leftover_bits_ready_to_append {\n        // `as` simply truncates the higher bits, which is what we want here\n        let selected_bits = (leftover_bits >> (56 - leftover_bits_appended_to_buf)) as u8;\n        output[output_index] = selected_bits;\n        output_index += 1;\n\n        leftover_bits_appended_to_buf += 8;\n    }\n\n    Ok(output_index)\n}\n\n#[inline]\nfn write_u64(output: &mut [u8], value: u64) {\n    output[..8].copy_from_slice(&value.to_be_bytes());\n}\n\n#[cfg(feature = \"slow_but_safe\")]\nfn decode_aligned(b64ch: u8, decode_table: &[u8; 256]) -> u8 {\n    let mut result: u8 = 0x00;\n    let mut mask: u8;\n    let idx: [u8;2] = [ b64ch % 64, b64ch % 64 + 64];\n    for i in 0..2  {\n        mask = 0xFF ^ (((idx[i] == b64ch) as i8 - 1) as u8);\n        result = result | (decode_table[idx[i] as usize] & mask);\n    }\n    result\n}\n\n/// Decode 8 bytes of input into 6 bytes of output. 8 bytes of output will be written, but only the\n/// first 6 of those contain meaningful data.\n///\n/// `input` is the bytes to decode, of which the first 8 bytes will be processed.\n/// `index_at_start_of_input` is the offset in the overall input (used for reporting errors\n/// accurately)\n/// `decode_table` is the lookup table for the particular base64 alphabet.\n/// `output` will have its first 8 bytes overwritten, of which only the first 6 are valid decoded\n/// data.\n// yes, really inline (worth 30-50% speedup)\n#[inline(always)]\nfn decode_chunk(\n    input: &[u8],\n    index_at_start_of_input: usize,\n    decode_table: &[u8; 256],\n    output: &mut [u8],\n) -> Result<(), DecodeError> {\n    let mut accum: u64;\n\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[0] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[0], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(index_at_start_of_input, input[0]));\n    }\n    accum = (morsel as u64) << 58;\n\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[1] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[1], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 1,\n            input[1],\n        ));\n    }\n    accum |= (morsel as u64) << 52;\n\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[2] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[2], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 2,\n            input[2],\n        ));\n    }\n    accum |= (morsel as u64) << 46;\n\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[3] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[3], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 3,\n            input[3],\n        ));\n    }\n    accum |= (morsel as u64) << 40;\n\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[4] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[4], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 4,\n            input[4],\n        ));\n    }\n    accum |= (morsel as u64) << 34;\n\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[5] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[5], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 5,\n            input[5],\n        ));\n    }\n    accum |= (morsel as u64) << 28;\n\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[6] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[6], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 6,\n            input[6],\n        ));\n    }\n    accum |= (morsel as u64) << 22;\n\n    #[cfg(not(feature = \"slow_but_safe\"))]\n    let morsel = decode_table[input[7] as usize];\n    #[cfg(feature = \"slow_but_safe\")]\n    let morsel = decode_aligned(input[7], decode_table);\n    if morsel == tables::INVALID_VALUE {\n        return Err(DecodeError::InvalidByte(\n            index_at_start_of_input + 7,\n            input[7],\n        ));\n    }\n    accum |= (morsel as u64) << 16;\n\n    write_u64(output, accum);\n\n    Ok(())\n}\n\n/// Decode an 8-byte chunk, but only write the 6 bytes actually decoded instead of including 2\n/// trailing garbage bytes.\n#[inline]\nfn decode_chunk_precise(\n    input: &[u8],\n    index_at_start_of_input: usize,\n    decode_table: &[u8; 256],\n    output: &mut [u8],\n) -> Result<(), DecodeError> {\n    let mut tmp_buf = [0_u8; 8];\n\n    decode_chunk(\n        input,\n        index_at_start_of_input,\n        decode_table,\n        &mut tmp_buf[..],\n    )?;\n\n    output[0..6].copy_from_slice(&tmp_buf[0..6]);\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{\n        encode::encode_config_buf,\n        encode::encode_config_slice,\n        tests::{assert_encode_sanity, random_config},\n    };\n\n    use rand::{\n        distributions::{Distribution, Uniform},\n        FromEntropy, Rng,\n    };\n\n    #[test]\n    fn decode_chunk_precise_writes_only_6_bytes() {\n        let input = b\"Zm9vYmFy\"; // \"foobar\"\n        let mut output = [0_u8, 1, 2, 3, 4, 5, 6, 7];\n        decode_chunk_precise(&input[..], 0, tables::STANDARD_DECODE, &mut output).unwrap();\n        assert_eq!(&vec![b'f', b'o', b'o', b'b', b'a', b'r', 6, 7], &output);\n    }\n\n    #[test]\n    fn decode_chunk_writes_8_bytes() {\n        let input = b\"Zm9vYmFy\"; // \"foobar\"\n        let mut output = [0_u8, 1, 2, 3, 4, 5, 6, 7];\n        decode_chunk(&input[..], 0, tables::STANDARD_DECODE, &mut output).unwrap();\n        assert_eq!(&vec![b'f', b'o', b'o', b'b', b'a', b'r', 0, 0], &output);\n    }\n\n    #[test]\n    fn decode_into_nonempty_vec_doesnt_clobber_existing_prefix() {\n        let mut orig_data = Vec::new();\n        let mut encoded_data = String::new();\n        let mut decoded_with_prefix = Vec::new();\n        let mut decoded_without_prefix = Vec::new();\n        let mut prefix = Vec::new();\n\n        let prefix_len_range = Uniform::new(0, 1000);\n        let input_len_range = Uniform::new(0, 1000);\n\n        let mut rng = rand::rngs::SmallRng::from_entropy();\n\n        for _ in 0..10_000 {\n            orig_data.clear();\n            encoded_data.clear();\n            decoded_with_prefix.clear();\n            decoded_without_prefix.clear();\n            prefix.clear();\n\n            let input_len = input_len_range.sample(&mut rng);\n\n            for _ in 0..input_len {\n                orig_data.push(rng.gen());\n            }\n\n            let config = random_config(&mut rng);\n            encode_config_buf(&orig_data, config, &mut encoded_data);\n            assert_encode_sanity(&encoded_data, config, input_len);\n\n            let prefix_len = prefix_len_range.sample(&mut rng);\n\n            // fill the buf with a prefix\n            for _ in 0..prefix_len {\n                prefix.push(rng.gen());\n            }\n\n            decoded_with_prefix.resize(prefix_len, 0);\n            decoded_with_prefix.copy_from_slice(&prefix);\n\n            // decode into the non-empty buf\n            decode_config_buf(&encoded_data, config, &mut decoded_with_prefix).unwrap();\n            // also decode into the empty buf\n            decode_config_buf(&encoded_data, config, &mut decoded_without_prefix).unwrap();\n\n            assert_eq!(\n                prefix_len + decoded_without_prefix.len(),\n                decoded_with_prefix.len()\n            );\n            assert_eq!(orig_data, decoded_without_prefix);\n\n            // append plain decode onto prefix\n            prefix.append(&mut decoded_without_prefix);\n\n            assert_eq!(prefix, decoded_with_prefix);\n        }\n    }\n\n    #[test]\n    fn decode_into_slice_doesnt_clobber_existing_prefix_or_suffix() {\n        let mut orig_data = Vec::new();\n        let mut encoded_data = String::new();\n        let mut decode_buf = Vec::new();\n        let mut decode_buf_copy: Vec<u8> = Vec::new();\n\n        let input_len_range = Uniform::new(0, 1000);\n\n        let mut rng = rand::rngs::SmallRng::from_entropy();\n\n        for _ in 0..10_000 {\n            orig_data.clear();\n            encoded_data.clear();\n            decode_buf.clear();\n            decode_buf_copy.clear();\n\n            let input_len = input_len_range.sample(&mut rng);\n\n            for _ in 0..input_len {\n                orig_data.push(rng.gen());\n            }\n\n            let config = random_config(&mut rng);\n            encode_config_buf(&orig_data, config, &mut encoded_data);\n            assert_encode_sanity(&encoded_data, config, input_len);\n\n            // fill the buffer with random garbage, long enough to have some room before and after\n            for _ in 0..5000 {\n                decode_buf.push(rng.gen());\n            }\n\n            // keep a copy for later comparison\n            decode_buf_copy.extend(decode_buf.iter());\n\n            let offset = 1000;\n\n            // decode into the non-empty buf\n            let decode_bytes_written =\n                decode_config_slice(&encoded_data, config, &mut decode_buf[offset..]).unwrap();\n\n            assert_eq!(orig_data.len(), decode_bytes_written);\n            assert_eq!(\n                orig_data,\n                &decode_buf[offset..(offset + decode_bytes_written)]\n            );\n            assert_eq!(&decode_buf_copy[0..offset], &decode_buf[0..offset]);\n            assert_eq!(\n                &decode_buf_copy[offset + decode_bytes_written..],\n                &decode_buf[offset + decode_bytes_written..]\n            );\n        }\n    }\n\n    #[test]\n    fn decode_into_slice_fits_in_precisely_sized_slice() {\n        let mut orig_data = Vec::new();\n        let mut encoded_data = String::new();\n        let mut decode_buf = Vec::new();\n\n        let input_len_range = Uniform::new(0, 1000);\n\n        let mut rng = rand::rngs::SmallRng::from_entropy();\n\n        for _ in 0..10_000 {\n            orig_data.clear();\n            encoded_data.clear();\n            decode_buf.clear();\n\n            let input_len = input_len_range.sample(&mut rng);\n\n            for _ in 0..input_len {\n                orig_data.push(rng.gen());\n            }\n\n            let config = random_config(&mut rng);\n            encode_config_buf(&orig_data, config, &mut encoded_data);\n            assert_encode_sanity(&encoded_data, config, input_len);\n\n            decode_buf.resize(input_len, 0);\n\n            // decode into the non-empty buf\n            let decode_bytes_written =\n                decode_config_slice(&encoded_data, config, &mut decode_buf[..]).unwrap();\n\n            assert_eq!(orig_data.len(), decode_bytes_written);\n            assert_eq!(orig_data, decode_buf);\n        }\n    }\n\n    #[test]\n    fn detect_invalid_last_symbol_two_bytes() {\n        let decode =\n            |input, forgiving| decode_config(input, STANDARD.decode_allow_trailing_bits(forgiving));\n\n        // example from https://github.com/marshallpierce/rust-base64/issues/75\n        assert!(decode(\"iYU=\", false).is_ok());\n        // trailing 01\n        assert_eq!(\n            Err(DecodeError::InvalidLastSymbol(2, b'V')),\n            decode(\"iYV=\", false)\n        );\n        assert_eq!(Ok(vec![137, 133]), decode(\"iYV=\", true));\n        // trailing 10\n        assert_eq!(\n            Err(DecodeError::InvalidLastSymbol(2, b'W')),\n            decode(\"iYW=\", false)\n        );\n        assert_eq!(Ok(vec![137, 133]), decode(\"iYV=\", true));\n        // trailing 11\n        assert_eq!(\n            Err(DecodeError::InvalidLastSymbol(2, b'X')),\n            decode(\"iYX=\", false)\n        );\n        assert_eq!(Ok(vec![137, 133]), decode(\"iYV=\", true));\n\n        // also works when there are 2 quads in the last block\n        assert_eq!(\n            Err(DecodeError::InvalidLastSymbol(6, b'X')),\n            decode(\"AAAAiYX=\", false)\n        );\n        assert_eq!(Ok(vec![0, 0, 0, 137, 133]), decode(\"AAAAiYX=\", true));\n    }\n\n    #[test]\n    fn detect_invalid_last_symbol_one_byte() {\n        // 0xFF -> \"/w==\", so all letters > w, 0-9, and '+', '/' should get InvalidLastSymbol\n\n        assert!(decode(\"/w==\").is_ok());\n        // trailing 01\n        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'x')), decode(\"/x==\"));\n        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'z')), decode(\"/z==\"));\n        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'0')), decode(\"/0==\"));\n        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'9')), decode(\"/9==\"));\n        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'+')), decode(\"/+==\"));\n        assert_eq!(Err(DecodeError::InvalidLastSymbol(1, b'/')), decode(\"//==\"));\n\n        // also works when there are 2 quads in the last block\n        assert_eq!(\n            Err(DecodeError::InvalidLastSymbol(5, b'x')),\n            decode(\"AAAA/x==\")\n        );\n    }\n\n    #[test]\n    fn detect_invalid_last_symbol_every_possible_three_symbols() {\n        let mut base64_to_bytes = ::std::collections::HashMap::new();\n\n        let mut bytes = [0_u8; 2];\n        for b1 in 0_u16..256 {\n            bytes[0] = b1 as u8;\n            for b2 in 0_u16..256 {\n                bytes[1] = b2 as u8;\n                let mut b64 = vec![0_u8; 4];\n                assert_eq!(4, encode_config_slice(&bytes, STANDARD, &mut b64[..]));\n                let mut v = ::std::vec::Vec::with_capacity(2);\n                v.extend_from_slice(&bytes[..]);\n\n                assert!(base64_to_bytes.insert(b64, v).is_none());\n            }\n        }\n\n        // every possible combination of symbols must either decode to 2 bytes or get InvalidLastSymbol\n\n        let mut symbols = [0_u8; 4];\n        for &s1 in STANDARD.char_set.encode_table().iter() {\n            symbols[0] = s1;\n            for &s2 in STANDARD.char_set.encode_table().iter() {\n                symbols[1] = s2;\n                for &s3 in STANDARD.char_set.encode_table().iter() {\n                    symbols[2] = s3;\n                    symbols[3] = PAD_BYTE;\n\n                    match base64_to_bytes.get(&symbols[..]) {\n                        Some(bytes) => {\n                            assert_eq!(Ok(bytes.to_vec()), decode_config(&symbols, STANDARD))\n                        }\n                        None => assert_eq!(\n                            Err(DecodeError::InvalidLastSymbol(2, s3)),\n                            decode_config(&symbols[..], STANDARD)\n                        ),\n                    }\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn detect_invalid_last_symbol_every_possible_two_symbols() {\n        let mut base64_to_bytes = ::std::collections::HashMap::new();\n\n        for b in 0_u16..256 {\n            let mut b64 = vec![0_u8; 4];\n            assert_eq!(4, encode_config_slice(&[b as u8], STANDARD, &mut b64[..]));\n            let mut v = ::std::vec::Vec::with_capacity(1);\n            v.push(b as u8);\n\n            assert!(base64_to_bytes.insert(b64, v).is_none());\n        }\n\n        // every possible combination of symbols must either decode to 1 byte or get InvalidLastSymbol\n\n        let mut symbols = [0_u8; 4];\n        for &s1 in STANDARD.char_set.encode_table().iter() {\n            symbols[0] = s1;\n            for &s2 in STANDARD.char_set.encode_table().iter() {\n                symbols[1] = s2;\n                symbols[2] = PAD_BYTE;\n                symbols[3] = PAD_BYTE;\n\n                match base64_to_bytes.get(&symbols[..]) {\n                    Some(bytes) => {\n                        assert_eq!(Ok(bytes.to_vec()), decode_config(&symbols, STANDARD))\n                    }\n                    None => assert_eq!(\n                        Err(DecodeError::InvalidLastSymbol(1, s2)),\n                        decode_config(&symbols[..], STANDARD)\n                    ),\n                }\n            }\n        }\n    }\n}\n", "//! # Configs\n//!\n//! There isn't just one type of Base64; that would be too simple. You need to choose a character\n//! set (standard, URL-safe, etc) and padding suffix (yes/no).\n//! The `Config` struct encapsulates this info. There are some common configs included: `STANDARD`,\n//! `URL_SAFE`, etc. You can also make your own `Config` if needed.\n//!\n//! The functions that don't have `config` in the name (e.g. `encode()` and `decode()`) use the\n//! `STANDARD` config .\n//!\n//! The functions that write to a slice (the ones that end in `_slice`) are generally the fastest\n//! because they don't need to resize anything. If it fits in your workflow and you care about\n//! performance, keep using the same buffer (growing as need be) and use the `_slice` methods for\n//! the best performance.\n//!\n//! # Encoding\n//!\n//! Several different encoding functions are available to you depending on your desire for\n//! convenience vs performance.\n//!\n//! | Function                | Output                       | Allocates                      |\n//! | ----------------------- | ---------------------------- | ------------------------------ |\n//! | `encode`                | Returns a new `String`       | Always                         |\n//! | `encode_config`         | Returns a new `String`       | Always                         |\n//! | `encode_config_buf`     | Appends to provided `String` | Only if `String` needs to grow |\n//! | `encode_config_slice`   | Writes to provided `&[u8]`   | Never                          |\n//!\n//! All of the encoding functions that take a `Config` will pad as per the config.\n//!\n//! # Decoding\n//!\n//! Just as for encoding, there are different decoding functions available.\n//!\n//! | Function                | Output                        | Allocates                      |\n//! | ----------------------- | ----------------------------- | ------------------------------ |\n//! | `decode`                | Returns a new `Vec<u8>`       | Always                         |\n//! | `decode_config`         | Returns a new `Vec<u8>`       | Always                         |\n//! | `decode_config_buf`     | Appends to provided `Vec<u8>` | Only if `Vec` needs to grow    |\n//! | `decode_config_slice`   | Writes to provided `&[u8]`    | Never                          |\n//!\n//! Unlike encoding, where all possible input is valid, decoding can fail (see `DecodeError`).\n//!\n//! Input can be invalid because it has invalid characters or invalid padding. (No padding at all is\n//! valid, but excess padding is not.) Whitespace in the input is invalid.\n//!\n//! # `Read` and `Write`\n//!\n//! To map a `Read` of b64 bytes to the decoded bytes, wrap a reader (file, network socket, etc)\n//! with `base64::read::DecoderReader`. To write raw bytes and have them b64 encoded on the fly,\n//! wrap a writer with `base64::write::EncoderWriter`. There is some performance overhead (15% or\n//! so) because of the necessary buffer shuffling -- still fast enough that almost nobody cares.\n//! Also, these implementations do not heap allocate.\n//!\n//! # Panics\n//!\n//! If length calculations result in overflowing `usize`, a panic will result.\n//!\n//! The `_slice` flavors of encode or decode will panic if the provided output slice is too small,\n\n#![cfg_attr(feature = \"cargo-clippy\", allow(clippy::cast_lossless))]\n#![deny(\n    missing_docs,\n    trivial_casts,\n    trivial_numeric_casts,\n    unused_extern_crates,\n    unused_import_braces,\n    unused_results,\n    variant_size_differences,\n    warnings\n)]\n#![forbid(unsafe_code)]\n#![cfg_attr(not(any(feature = \"std\", test)), no_std)]\n\n#[cfg(all(feature = \"alloc\", not(any(feature = \"std\", test))))]\nextern crate alloc;\n#[cfg(any(feature = \"std\", test))]\nextern crate std as alloc;\n\nmod chunked_encoder;\npub mod display;\n#[cfg(any(feature = \"std\", test))]\npub mod read;\nmod tables;\n#[cfg(any(feature = \"std\", test))]\npub mod write;\n\nmod encode;\npub use crate::encode::encode_config_slice;\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub use crate::encode::{encode, encode_config, encode_config_buf};\n\nmod decode;\n#[cfg(any(feature = \"alloc\", feature = \"std\", test))]\npub use crate::decode::{decode, decode_config, decode_config_buf};\npub use crate::decode::{decode_config_slice, DecodeError};\n\n#[cfg(test)]\nmod tests;\n\n/// Available encoding character sets\n#[derive(Clone, Copy, Debug)]\npub enum CharacterSet {\n    /// The standard character set (uses `+` and `/`).\n    ///\n    /// See [RFC 3548](https://tools.ietf.org/html/rfc3548#section-3).\n    Standard,\n    /// The URL safe character set (uses `-` and `_`).\n    ///\n    /// See [RFC 3548](https://tools.ietf.org/html/rfc3548#section-4).\n    UrlSafe,\n    /// The `crypt(3)` character set (uses `./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`).\n    ///\n    /// Not standardized, but folk wisdom on the net asserts that this alphabet is what crypt uses.\n    Crypt,\n    /// The bcrypt character set (uses `./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789`).\n    Bcrypt,\n    /// The character set used in IMAP-modified UTF-7 (uses `+` and `,`).\n    ///\n    /// See [RFC 3501](https://tools.ietf.org/html/rfc3501#section-5.1.3)\n    ImapMutf7,\n    /// The character set used in BinHex 4.0 files.\n    ///\n    /// See [BinHex 4.0 Definition](http://files.stairways.com/other/binhex-40-specs-info.txt)\n    BinHex,\n}\n\nimpl CharacterSet {\n    fn encode_table(self) -> &'static [u8; 64] {\n        match self {\n            CharacterSet::Standard => tables::STANDARD_ENCODE,\n            CharacterSet::UrlSafe => tables::URL_SAFE_ENCODE,\n            CharacterSet::Crypt => tables::CRYPT_ENCODE,\n            CharacterSet::Bcrypt => tables::BCRYPT_ENCODE,\n            CharacterSet::ImapMutf7 => tables::IMAP_MUTF7_ENCODE,\n            CharacterSet::BinHex => tables::BINHEX_ENCODE,\n        }\n    }\n\n    fn decode_table(self) -> &'static [u8; 256] {\n        match self {\n            CharacterSet::Standard => &tables::STANDARD_DECODE_HOLDER.data,\n            CharacterSet::UrlSafe => &tables::URL_SAFE_DECODE_HOLDER.data,\n            CharacterSet::Crypt => &tables::CRYPT_DECODE_HOLDER.data,\n            CharacterSet::Bcrypt => &tables::BCRYPT_DECODE_HOLDER.data,\n            CharacterSet::ImapMutf7 => &tables::IMAP_MUTF7_DECODE_HOLDER.data,\n            CharacterSet::BinHex => &tables::BINHEX_DECODE_HOLDER.data,\n        }\n    }\n}\n\n/// Contains configuration parameters for base64 encoding\n#[derive(Clone, Copy, Debug)]\npub struct Config {\n    /// Character set to use\n    char_set: CharacterSet,\n    /// True to pad output with `=` characters\n    pad: bool,\n    /// True to ignore excess nonzero bits in the last few symbols, otherwise an error is returned.\n    decode_allow_trailing_bits: bool,\n}\n\nimpl Config {\n    /// Create a new `Config`.\n    pub const fn new(char_set: CharacterSet, pad: bool) -> Config {\n        Config {\n            char_set,\n            pad,\n            decode_allow_trailing_bits: false,\n        }\n    }\n\n    /// Sets whether to pad output with `=` characters.\n    pub const fn pad(self, pad: bool) -> Config {\n        Config { pad, ..self }\n    }\n\n    /// Sets whether to emit errors for nonzero trailing bits.\n    ///\n    /// This is useful when implementing\n    /// [forgiving-base64 decode](https://infra.spec.whatwg.org/#forgiving-base64-decode).\n    pub const fn decode_allow_trailing_bits(self, allow: bool) -> Config {\n        Config {\n            decode_allow_trailing_bits: allow,\n            ..self\n        }\n    }\n}\n\n/// Standard character set with padding.\npub const STANDARD: Config = Config {\n    char_set: CharacterSet::Standard,\n    pad: true,\n    decode_allow_trailing_bits: false,\n};\n\n/// Standard character set without padding.\npub const STANDARD_NO_PAD: Config = Config {\n    char_set: CharacterSet::Standard,\n    pad: false,\n    decode_allow_trailing_bits: false,\n};\n\n/// URL-safe character set with padding\npub const URL_SAFE: Config = Config {\n    char_set: CharacterSet::UrlSafe,\n    pad: true,\n    decode_allow_trailing_bits: false,\n};\n\n/// URL-safe character set without padding\npub const URL_SAFE_NO_PAD: Config = Config {\n    char_set: CharacterSet::UrlSafe,\n    pad: false,\n    decode_allow_trailing_bits: false,\n};\n\n/// As per `crypt(3)` requirements\npub const CRYPT: Config = Config {\n    char_set: CharacterSet::Crypt,\n    pad: false,\n    decode_allow_trailing_bits: false,\n};\n\n/// Bcrypt character set\npub const BCRYPT: Config = Config {\n    char_set: CharacterSet::Bcrypt,\n    pad: false,\n    decode_allow_trailing_bits: false,\n};\n\n/// IMAP modified UTF-7 requirements\npub const IMAP_MUTF7: Config = Config {\n    char_set: CharacterSet::ImapMutf7,\n    pad: false,\n    decode_allow_trailing_bits: false,\n};\n\n/// BinHex character set\npub const BINHEX: Config = Config {\n    char_set: CharacterSet::BinHex,\n    pad: false,\n    decode_allow_trailing_bits: false,\n};\n\nconst PAD_BYTE: u8 = b'=';\n", "//#[repr(align(64))]\n//pub struct StructStandardEncode { pub data: [u8; 64] }\n#[repr(align(64))]\npub struct StructStandardDecode { pub data: [u8; 256] }\n//#[repr(align(64))]\n//pub struct StructUrlSafeEncode { pub data: [u8; 64] }\n#[repr(align(64))]\npub struct StructUrlSafeDecode { pub data: [u8; 256] }\n//#[repr(align(64))]\n//pub struct StructCryptEncode { pub data: [u8; 64] }\n#[repr(align(64))]\npub struct StructCryptDecode { pub data: [u8; 256] }\n//#[repr(align(64))]\n//pub struct StructBcryptEncode { pub data: [u8; 64] }\n#[repr(align(64))]\npub struct StructBcryptDecode { pub data: [u8; 256] }\n//#[repr(align(64))]\n//pub struct StructImapMutf7Encode { pub data: [u8; 64] }\n#[repr(align(64))]\npub struct StructImapMutf7Decode { pub data: [u8; 256] }\n//#[repr(align(64))]\n//pub struct StructBinhexEncode { pub data: [u8; 64] }\n#[repr(align(64))]\npub struct StructBinhexDecode { pub data: [u8; 256] }\n\npub const STANDARD_DECODE_HOLDER: StructStandardDecode = StructStandardDecode { data: *STANDARD_DECODE };\npub const URL_SAFE_DECODE_HOLDER: StructUrlSafeDecode = StructUrlSafeDecode { data: *URL_SAFE_DECODE };\npub const CRYPT_DECODE_HOLDER: StructCryptDecode = StructCryptDecode { data: *CRYPT_DECODE };\npub const BCRYPT_DECODE_HOLDER: StructBcryptDecode = StructBcryptDecode { data: *BCRYPT_DECODE };\npub const IMAP_MUTF7_DECODE_HOLDER: StructImapMutf7Decode = StructImapMutf7Decode { data: *IMAP_MUTF7_DECODE };\npub const BINHEX_DECODE_HOLDER: StructBinhexDecode = StructBinhexDecode { data: *BINHEX_DECODE };\n\npub const INVALID_VALUE: u8 = 255;\n#[rustfmt::skip]\npub const STANDARD_ENCODE: &[u8; 64] = &[\n    65, // input 0 (0x0) => 'A' (0x41)\n    66, // input 1 (0x1) => 'B' (0x42)\n    67, // input 2 (0x2) => 'C' (0x43)\n    68, // input 3 (0x3) => 'D' (0x44)\n    69, // input 4 (0x4) => 'E' (0x45)\n    70, // input 5 (0x5) => 'F' (0x46)\n    71, // input 6 (0x6) => 'G' (0x47)\n    72, // input 7 (0x7) => 'H' (0x48)\n    73, // input 8 (0x8) => 'I' (0x49)\n    74, // input 9 (0x9) => 'J' (0x4A)\n    75, // input 10 (0xA) => 'K' (0x4B)\n    76, // input 11 (0xB) => 'L' (0x4C)\n    77, // input 12 (0xC) => 'M' (0x4D)\n    78, // input 13 (0xD) => 'N' (0x4E)\n    79, // input 14 (0xE) => 'O' (0x4F)\n    80, // input 15 (0xF) => 'P' (0x50)\n    81, // input 16 (0x10) => 'Q' (0x51)\n    82, // input 17 (0x11) => 'R' (0x52)\n    83, // input 18 (0x12) => 'S' (0x53)\n    84, // input 19 (0x13) => 'T' (0x54)\n    85, // input 20 (0x14) => 'U' (0x55)\n    86, // input 21 (0x15) => 'V' (0x56)\n    87, // input 22 (0x16) => 'W' (0x57)\n    88, // input 23 (0x17) => 'X' (0x58)\n    89, // input 24 (0x18) => 'Y' (0x59)\n    90, // input 25 (0x19) => 'Z' (0x5A)\n    97, // input 26 (0x1A) => 'a' (0x61)\n    98, // input 27 (0x1B) => 'b' (0x62)\n    99, // input 28 (0x1C) => 'c' (0x63)\n    100, // input 29 (0x1D) => 'd' (0x64)\n    101, // input 30 (0x1E) => 'e' (0x65)\n    102, // input 31 (0x1F) => 'f' (0x66)\n    103, // input 32 (0x20) => 'g' (0x67)\n    104, // input 33 (0x21) => 'h' (0x68)\n    105, // input 34 (0x22) => 'i' (0x69)\n    106, // input 35 (0x23) => 'j' (0x6A)\n    107, // input 36 (0x24) => 'k' (0x6B)\n    108, // input 37 (0x25) => 'l' (0x6C)\n    109, // input 38 (0x26) => 'm' (0x6D)\n    110, // input 39 (0x27) => 'n' (0x6E)\n    111, // input 40 (0x28) => 'o' (0x6F)\n    112, // input 41 (0x29) => 'p' (0x70)\n    113, // input 42 (0x2A) => 'q' (0x71)\n    114, // input 43 (0x2B) => 'r' (0x72)\n    115, // input 44 (0x2C) => 's' (0x73)\n    116, // input 45 (0x2D) => 't' (0x74)\n    117, // input 46 (0x2E) => 'u' (0x75)\n    118, // input 47 (0x2F) => 'v' (0x76)\n    119, // input 48 (0x30) => 'w' (0x77)\n    120, // input 49 (0x31) => 'x' (0x78)\n    121, // input 50 (0x32) => 'y' (0x79)\n    122, // input 51 (0x33) => 'z' (0x7A)\n    48, // input 52 (0x34) => '0' (0x30)\n    49, // input 53 (0x35) => '1' (0x31)\n    50, // input 54 (0x36) => '2' (0x32)\n    51, // input 55 (0x37) => '3' (0x33)\n    52, // input 56 (0x38) => '4' (0x34)\n    53, // input 57 (0x39) => '5' (0x35)\n    54, // input 58 (0x3A) => '6' (0x36)\n    55, // input 59 (0x3B) => '7' (0x37)\n    56, // input 60 (0x3C) => '8' (0x38)\n    57, // input 61 (0x3D) => '9' (0x39)\n    43, // input 62 (0x3E) => '+' (0x2B)\n    47, // input 63 (0x3F) => '/' (0x2F)\n];\n#[rustfmt::skip]\npub const STANDARD_DECODE: &[u8; 256] = &[\n    INVALID_VALUE, // input 0 (0x0)\n    INVALID_VALUE, // input 1 (0x1)\n    INVALID_VALUE, // input 2 (0x2)\n    INVALID_VALUE, // input 3 (0x3)\n    INVALID_VALUE, // input 4 (0x4)\n    INVALID_VALUE, // input 5 (0x5)\n    INVALID_VALUE, // input 6 (0x6)\n    INVALID_VALUE, // input 7 (0x7)\n    INVALID_VALUE, // input 8 (0x8)\n    INVALID_VALUE, // input 9 (0x9)\n    INVALID_VALUE, // input 10 (0xA)\n    INVALID_VALUE, // input 11 (0xB)\n    INVALID_VALUE, // input 12 (0xC)\n    INVALID_VALUE, // input 13 (0xD)\n    INVALID_VALUE, // input 14 (0xE)\n    INVALID_VALUE, // input 15 (0xF)\n    INVALID_VALUE, // input 16 (0x10)\n    INVALID_VALUE, // input 17 (0x11)\n    INVALID_VALUE, // input 18 (0x12)\n    INVALID_VALUE, // input 19 (0x13)\n    INVALID_VALUE, // input 20 (0x14)\n    INVALID_VALUE, // input 21 (0x15)\n    INVALID_VALUE, // input 22 (0x16)\n    INVALID_VALUE, // input 23 (0x17)\n    INVALID_VALUE, // input 24 (0x18)\n    INVALID_VALUE, // input 25 (0x19)\n    INVALID_VALUE, // input 26 (0x1A)\n    INVALID_VALUE, // input 27 (0x1B)\n    INVALID_VALUE, // input 28 (0x1C)\n    INVALID_VALUE, // input 29 (0x1D)\n    INVALID_VALUE, // input 30 (0x1E)\n    INVALID_VALUE, // input 31 (0x1F)\n    INVALID_VALUE, // input 32 (0x20)\n    INVALID_VALUE, // input 33 (0x21)\n    INVALID_VALUE, // input 34 (0x22)\n    INVALID_VALUE, // input 35 (0x23)\n    INVALID_VALUE, // input 36 (0x24)\n    INVALID_VALUE, // input 37 (0x25)\n    INVALID_VALUE, // input 38 (0x26)\n    INVALID_VALUE, // input 39 (0x27)\n    INVALID_VALUE, // input 40 (0x28)\n    INVALID_VALUE, // input 41 (0x29)\n    INVALID_VALUE, // input 42 (0x2A)\n    62, // input 43 (0x2B char '+') => 62 (0x3E)\n    INVALID_VALUE, // input 44 (0x2C)\n    INVALID_VALUE, // input 45 (0x2D)\n    INVALID_VALUE, // input 46 (0x2E)\n    63, // input 47 (0x2F char '/') => 63 (0x3F)\n    52, // input 48 (0x30 char '0') => 52 (0x34)\n    53, // input 49 (0x31 char '1') => 53 (0x35)\n    54, // input 50 (0x32 char '2') => 54 (0x36)\n    55, // input 51 (0x33 char '3') => 55 (0x37)\n    56, // input 52 (0x34 char '4') => 56 (0x38)\n    57, // input 53 (0x35 char '5') => 57 (0x39)\n    58, // input 54 (0x36 char '6') => 58 (0x3A)\n    59, // input 55 (0x37 char '7') => 59 (0x3B)\n    60, // input 56 (0x38 char '8') => 60 (0x3C)\n    61, // input 57 (0x39 char '9') => 61 (0x3D)\n    INVALID_VALUE, // input 58 (0x3A)\n    INVALID_VALUE, // input 59 (0x3B)\n    INVALID_VALUE, // input 60 (0x3C)\n    INVALID_VALUE, // input 61 (0x3D)\n    INVALID_VALUE, // input 62 (0x3E)\n    INVALID_VALUE, // input 63 (0x3F)\n    INVALID_VALUE, // input 64 (0x40)\n    0, // input 65 (0x41 char 'A') => 0 (0x0)\n    1, // input 66 (0x42 char 'B') => 1 (0x1)\n    2, // input 67 (0x43 char 'C') => 2 (0x2)\n    3, // input 68 (0x44 char 'D') => 3 (0x3)\n    4, // input 69 (0x45 char 'E') => 4 (0x4)\n    5, // input 70 (0x46 char 'F') => 5 (0x5)\n    6, // input 71 (0x47 char 'G') => 6 (0x6)\n    7, // input 72 (0x48 char 'H') => 7 (0x7)\n    8, // input 73 (0x49 char 'I') => 8 (0x8)\n    9, // input 74 (0x4A char 'J') => 9 (0x9)\n    10, // input 75 (0x4B char 'K') => 10 (0xA)\n    11, // input 76 (0x4C char 'L') => 11 (0xB)\n    12, // input 77 (0x4D char 'M') => 12 (0xC)\n    13, // input 78 (0x4E char 'N') => 13 (0xD)\n    14, // input 79 (0x4F char 'O') => 14 (0xE)\n    15, // input 80 (0x50 char 'P') => 15 (0xF)\n    16, // input 81 (0x51 char 'Q') => 16 (0x10)\n    17, // input 82 (0x52 char 'R') => 17 (0x11)\n    18, // input 83 (0x53 char 'S') => 18 (0x12)\n    19, // input 84 (0x54 char 'T') => 19 (0x13)\n    20, // input 85 (0x55 char 'U') => 20 (0x14)\n    21, // input 86 (0x56 char 'V') => 21 (0x15)\n    22, // input 87 (0x57 char 'W') => 22 (0x16)\n    23, // input 88 (0x58 char 'X') => 23 (0x17)\n    24, // input 89 (0x59 char 'Y') => 24 (0x18)\n    25, // input 90 (0x5A char 'Z') => 25 (0x19)\n    INVALID_VALUE, // input 91 (0x5B)\n    INVALID_VALUE, // input 92 (0x5C)\n    INVALID_VALUE, // input 93 (0x5D)\n    INVALID_VALUE, // input 94 (0x5E)\n    INVALID_VALUE, // input 95 (0x5F)\n    INVALID_VALUE, // input 96 (0x60)\n    26, // input 97 (0x61 char 'a') => 26 (0x1A)\n    27, // input 98 (0x62 char 'b') => 27 (0x1B)\n    28, // input 99 (0x63 char 'c') => 28 (0x1C)\n    29, // input 100 (0x64 char 'd') => 29 (0x1D)\n    30, // input 101 (0x65 char 'e') => 30 (0x1E)\n    31, // input 102 (0x66 char 'f') => 31 (0x1F)\n    32, // input 103 (0x67 char 'g') => 32 (0x20)\n    33, // input 104 (0x68 char 'h') => 33 (0x21)\n    34, // input 105 (0x69 char 'i') => 34 (0x22)\n    35, // input 106 (0x6A char 'j') => 35 (0x23)\n    36, // input 107 (0x6B char 'k') => 36 (0x24)\n    37, // input 108 (0x6C char 'l') => 37 (0x25)\n    38, // input 109 (0x6D char 'm') => 38 (0x26)\n    39, // input 110 (0x6E char 'n') => 39 (0x27)\n    40, // input 111 (0x6F char 'o') => 40 (0x28)\n    41, // input 112 (0x70 char 'p') => 41 (0x29)\n    42, // input 113 (0x71 char 'q') => 42 (0x2A)\n    43, // input 114 (0x72 char 'r') => 43 (0x2B)\n    44, // input 115 (0x73 char 's') => 44 (0x2C)\n    45, // input 116 (0x74 char 't') => 45 (0x2D)\n    46, // input 117 (0x75 char 'u') => 46 (0x2E)\n    47, // input 118 (0x76 char 'v') => 47 (0x2F)\n    48, // input 119 (0x77 char 'w') => 48 (0x30)\n    49, // input 120 (0x78 char 'x') => 49 (0x31)\n    50, // input 121 (0x79 char 'y') => 50 (0x32)\n    51, // input 122 (0x7A char 'z') => 51 (0x33)\n    INVALID_VALUE, // input 123 (0x7B)\n    INVALID_VALUE, // input 124 (0x7C)\n    INVALID_VALUE, // input 125 (0x7D)\n    INVALID_VALUE, // input 126 (0x7E)\n    INVALID_VALUE, // input 127 (0x7F)\n    INVALID_VALUE, // input 128 (0x80)\n    INVALID_VALUE, // input 129 (0x81)\n    INVALID_VALUE, // input 130 (0x82)\n    INVALID_VALUE, // input 131 (0x83)\n    INVALID_VALUE, // input 132 (0x84)\n    INVALID_VALUE, // input 133 (0x85)\n    INVALID_VALUE, // input 134 (0x86)\n    INVALID_VALUE, // input 135 (0x87)\n    INVALID_VALUE, // input 136 (0x88)\n    INVALID_VALUE, // input 137 (0x89)\n    INVALID_VALUE, // input 138 (0x8A)\n    INVALID_VALUE, // input 139 (0x8B)\n    INVALID_VALUE, // input 140 (0x8C)\n    INVALID_VALUE, // input 141 (0x8D)\n    INVALID_VALUE, // input 142 (0x8E)\n    INVALID_VALUE, // input 143 (0x8F)\n    INVALID_VALUE, // input 144 (0x90)\n    INVALID_VALUE, // input 145 (0x91)\n    INVALID_VALUE, // input 146 (0x92)\n    INVALID_VALUE, // input 147 (0x93)\n    INVALID_VALUE, // input 148 (0x94)\n    INVALID_VALUE, // input 149 (0x95)\n    INVALID_VALUE, // input 150 (0x96)\n    INVALID_VALUE, // input 151 (0x97)\n    INVALID_VALUE, // input 152 (0x98)\n    INVALID_VALUE, // input 153 (0x99)\n    INVALID_VALUE, // input 154 (0x9A)\n    INVALID_VALUE, // input 155 (0x9B)\n    INVALID_VALUE, // input 156 (0x9C)\n    INVALID_VALUE, // input 157 (0x9D)\n    INVALID_VALUE, // input 158 (0x9E)\n    INVALID_VALUE, // input 159 (0x9F)\n    INVALID_VALUE, // input 160 (0xA0)\n    INVALID_VALUE, // input 161 (0xA1)\n    INVALID_VALUE, // input 162 (0xA2)\n    INVALID_VALUE, // input 163 (0xA3)\n    INVALID_VALUE, // input 164 (0xA4)\n    INVALID_VALUE, // input 165 (0xA5)\n    INVALID_VALUE, // input 166 (0xA6)\n    INVALID_VALUE, // input 167 (0xA7)\n    INVALID_VALUE, // input 168 (0xA8)\n    INVALID_VALUE, // input 169 (0xA9)\n    INVALID_VALUE, // input 170 (0xAA)\n    INVALID_VALUE, // input 171 (0xAB)\n    INVALID_VALUE, // input 172 (0xAC)\n    INVALID_VALUE, // input 173 (0xAD)\n    INVALID_VALUE, // input 174 (0xAE)\n    INVALID_VALUE, // input 175 (0xAF)\n    INVALID_VALUE, // input 176 (0xB0)\n    INVALID_VALUE, // input 177 (0xB1)\n    INVALID_VALUE, // input 178 (0xB2)\n    INVALID_VALUE, // input 179 (0xB3)\n    INVALID_VALUE, // input 180 (0xB4)\n    INVALID_VALUE, // input 181 (0xB5)\n    INVALID_VALUE, // input 182 (0xB6)\n    INVALID_VALUE, // input 183 (0xB7)\n    INVALID_VALUE, // input 184 (0xB8)\n    INVALID_VALUE, // input 185 (0xB9)\n    INVALID_VALUE, // input 186 (0xBA)\n    INVALID_VALUE, // input 187 (0xBB)\n    INVALID_VALUE, // input 188 (0xBC)\n    INVALID_VALUE, // input 189 (0xBD)\n    INVALID_VALUE, // input 190 (0xBE)\n    INVALID_VALUE, // input 191 (0xBF)\n    INVALID_VALUE, // input 192 (0xC0)\n    INVALID_VALUE, // input 193 (0xC1)\n    INVALID_VALUE, // input 194 (0xC2)\n    INVALID_VALUE, // input 195 (0xC3)\n    INVALID_VALUE, // input 196 (0xC4)\n    INVALID_VALUE, // input 197 (0xC5)\n    INVALID_VALUE, // input 198 (0xC6)\n    INVALID_VALUE, // input 199 (0xC7)\n    INVALID_VALUE, // input 200 (0xC8)\n    INVALID_VALUE, // input 201 (0xC9)\n    INVALID_VALUE, // input 202 (0xCA)\n    INVALID_VALUE, // input 203 (0xCB)\n    INVALID_VALUE, // input 204 (0xCC)\n    INVALID_VALUE, // input 205 (0xCD)\n    INVALID_VALUE, // input 206 (0xCE)\n    INVALID_VALUE, // input 207 (0xCF)\n    INVALID_VALUE, // input 208 (0xD0)\n    INVALID_VALUE, // input 209 (0xD1)\n    INVALID_VALUE, // input 210 (0xD2)\n    INVALID_VALUE, // input 211 (0xD3)\n    INVALID_VALUE, // input 212 (0xD4)\n    INVALID_VALUE, // input 213 (0xD5)\n    INVALID_VALUE, // input 214 (0xD6)\n    INVALID_VALUE, // input 215 (0xD7)\n    INVALID_VALUE, // input 216 (0xD8)\n    INVALID_VALUE, // input 217 (0xD9)\n    INVALID_VALUE, // input 218 (0xDA)\n    INVALID_VALUE, // input 219 (0xDB)\n    INVALID_VALUE, // input 220 (0xDC)\n    INVALID_VALUE, // input 221 (0xDD)\n    INVALID_VALUE, // input 222 (0xDE)\n    INVALID_VALUE, // input 223 (0xDF)\n    INVALID_VALUE, // input 224 (0xE0)\n    INVALID_VALUE, // input 225 (0xE1)\n    INVALID_VALUE, // input 226 (0xE2)\n    INVALID_VALUE, // input 227 (0xE3)\n    INVALID_VALUE, // input 228 (0xE4)\n    INVALID_VALUE, // input 229 (0xE5)\n    INVALID_VALUE, // input 230 (0xE6)\n    INVALID_VALUE, // input 231 (0xE7)\n    INVALID_VALUE, // input 232 (0xE8)\n    INVALID_VALUE, // input 233 (0xE9)\n    INVALID_VALUE, // input 234 (0xEA)\n    INVALID_VALUE, // input 235 (0xEB)\n    INVALID_VALUE, // input 236 (0xEC)\n    INVALID_VALUE, // input 237 (0xED)\n    INVALID_VALUE, // input 238 (0xEE)\n    INVALID_VALUE, // input 239 (0xEF)\n    INVALID_VALUE, // input 240 (0xF0)\n    INVALID_VALUE, // input 241 (0xF1)\n    INVALID_VALUE, // input 242 (0xF2)\n    INVALID_VALUE, // input 243 (0xF3)\n    INVALID_VALUE, // input 244 (0xF4)\n    INVALID_VALUE, // input 245 (0xF5)\n    INVALID_VALUE, // input 246 (0xF6)\n    INVALID_VALUE, // input 247 (0xF7)\n    INVALID_VALUE, // input 248 (0xF8)\n    INVALID_VALUE, // input 249 (0xF9)\n    INVALID_VALUE, // input 250 (0xFA)\n    INVALID_VALUE, // input 251 (0xFB)\n    INVALID_VALUE, // input 252 (0xFC)\n    INVALID_VALUE, // input 253 (0xFD)\n    INVALID_VALUE, // input 254 (0xFE)\n    INVALID_VALUE, // input 255 (0xFF)\n];\n#[rustfmt::skip]\npub const URL_SAFE_ENCODE: &[u8; 64] = &[\n    65, // input 0 (0x0) => 'A' (0x41)\n    66, // input 1 (0x1) => 'B' (0x42)\n    67, // input 2 (0x2) => 'C' (0x43)\n    68, // input 3 (0x3) => 'D' (0x44)\n    69, // input 4 (0x4) => 'E' (0x45)\n    70, // input 5 (0x5) => 'F' (0x46)\n    71, // input 6 (0x6) => 'G' (0x47)\n    72, // input 7 (0x7) => 'H' (0x48)\n    73, // input 8 (0x8) => 'I' (0x49)\n    74, // input 9 (0x9) => 'J' (0x4A)\n    75, // input 10 (0xA) => 'K' (0x4B)\n    76, // input 11 (0xB) => 'L' (0x4C)\n    77, // input 12 (0xC) => 'M' (0x4D)\n    78, // input 13 (0xD) => 'N' (0x4E)\n    79, // input 14 (0xE) => 'O' (0x4F)\n    80, // input 15 (0xF) => 'P' (0x50)\n    81, // input 16 (0x10) => 'Q' (0x51)\n    82, // input 17 (0x11) => 'R' (0x52)\n    83, // input 18 (0x12) => 'S' (0x53)\n    84, // input 19 (0x13) => 'T' (0x54)\n    85, // input 20 (0x14) => 'U' (0x55)\n    86, // input 21 (0x15) => 'V' (0x56)\n    87, // input 22 (0x16) => 'W' (0x57)\n    88, // input 23 (0x17) => 'X' (0x58)\n    89, // input 24 (0x18) => 'Y' (0x59)\n    90, // input 25 (0x19) => 'Z' (0x5A)\n    97, // input 26 (0x1A) => 'a' (0x61)\n    98, // input 27 (0x1B) => 'b' (0x62)\n    99, // input 28 (0x1C) => 'c' (0x63)\n    100, // input 29 (0x1D) => 'd' (0x64)\n    101, // input 30 (0x1E) => 'e' (0x65)\n    102, // input 31 (0x1F) => 'f' (0x66)\n    103, // input 32 (0x20) => 'g' (0x67)\n    104, // input 33 (0x21) => 'h' (0x68)\n    105, // input 34 (0x22) => 'i' (0x69)\n    106, // input 35 (0x23) => 'j' (0x6A)\n    107, // input 36 (0x24) => 'k' (0x6B)\n    108, // input 37 (0x25) => 'l' (0x6C)\n    109, // input 38 (0x26) => 'm' (0x6D)\n    110, // input 39 (0x27) => 'n' (0x6E)\n    111, // input 40 (0x28) => 'o' (0x6F)\n    112, // input 41 (0x29) => 'p' (0x70)\n    113, // input 42 (0x2A) => 'q' (0x71)\n    114, // input 43 (0x2B) => 'r' (0x72)\n    115, // input 44 (0x2C) => 's' (0x73)\n    116, // input 45 (0x2D) => 't' (0x74)\n    117, // input 46 (0x2E) => 'u' (0x75)\n    118, // input 47 (0x2F) => 'v' (0x76)\n    119, // input 48 (0x30) => 'w' (0x77)\n    120, // input 49 (0x31) => 'x' (0x78)\n    121, // input 50 (0x32) => 'y' (0x79)\n    122, // input 51 (0x33) => 'z' (0x7A)\n    48, // input 52 (0x34) => '0' (0x30)\n    49, // input 53 (0x35) => '1' (0x31)\n    50, // input 54 (0x36) => '2' (0x32)\n    51, // input 55 (0x37) => '3' (0x33)\n    52, // input 56 (0x38) => '4' (0x34)\n    53, // input 57 (0x39) => '5' (0x35)\n    54, // input 58 (0x3A) => '6' (0x36)\n    55, // input 59 (0x3B) => '7' (0x37)\n    56, // input 60 (0x3C) => '8' (0x38)\n    57, // input 61 (0x3D) => '9' (0x39)\n    45, // input 62 (0x3E) => '-' (0x2D)\n    95, // input 63 (0x3F) => '_' (0x5F)\n];\n#[rustfmt::skip]\npub const URL_SAFE_DECODE: &[u8; 256] = &[\n    INVALID_VALUE, // input 0 (0x0)\n    INVALID_VALUE, // input 1 (0x1)\n    INVALID_VALUE, // input 2 (0x2)\n    INVALID_VALUE, // input 3 (0x3)\n    INVALID_VALUE, // input 4 (0x4)\n    INVALID_VALUE, // input 5 (0x5)\n    INVALID_VALUE, // input 6 (0x6)\n    INVALID_VALUE, // input 7 (0x7)\n    INVALID_VALUE, // input 8 (0x8)\n    INVALID_VALUE, // input 9 (0x9)\n    INVALID_VALUE, // input 10 (0xA)\n    INVALID_VALUE, // input 11 (0xB)\n    INVALID_VALUE, // input 12 (0xC)\n    INVALID_VALUE, // input 13 (0xD)\n    INVALID_VALUE, // input 14 (0xE)\n    INVALID_VALUE, // input 15 (0xF)\n    INVALID_VALUE, // input 16 (0x10)\n    INVALID_VALUE, // input 17 (0x11)\n    INVALID_VALUE, // input 18 (0x12)\n    INVALID_VALUE, // input 19 (0x13)\n    INVALID_VALUE, // input 20 (0x14)\n    INVALID_VALUE, // input 21 (0x15)\n    INVALID_VALUE, // input 22 (0x16)\n    INVALID_VALUE, // input 23 (0x17)\n    INVALID_VALUE, // input 24 (0x18)\n    INVALID_VALUE, // input 25 (0x19)\n    INVALID_VALUE, // input 26 (0x1A)\n    INVALID_VALUE, // input 27 (0x1B)\n    INVALID_VALUE, // input 28 (0x1C)\n    INVALID_VALUE, // input 29 (0x1D)\n    INVALID_VALUE, // input 30 (0x1E)\n    INVALID_VALUE, // input 31 (0x1F)\n    INVALID_VALUE, // input 32 (0x20)\n    INVALID_VALUE, // input 33 (0x21)\n    INVALID_VALUE, // input 34 (0x22)\n    INVALID_VALUE, // input 35 (0x23)\n    INVALID_VALUE, // input 36 (0x24)\n    INVALID_VALUE, // input 37 (0x25)\n    INVALID_VALUE, // input 38 (0x26)\n    INVALID_VALUE, // input 39 (0x27)\n    INVALID_VALUE, // input 40 (0x28)\n    INVALID_VALUE, // input 41 (0x29)\n    INVALID_VALUE, // input 42 (0x2A)\n    INVALID_VALUE, // input 43 (0x2B)\n    INVALID_VALUE, // input 44 (0x2C)\n    62, // input 45 (0x2D char '-') => 62 (0x3E)\n    INVALID_VALUE, // input 46 (0x2E)\n    INVALID_VALUE, // input 47 (0x2F)\n    52, // input 48 (0x30 char '0') => 52 (0x34)\n    53, // input 49 (0x31 char '1') => 53 (0x35)\n    54, // input 50 (0x32 char '2') => 54 (0x36)\n    55, // input 51 (0x33 char '3') => 55 (0x37)\n    56, // input 52 (0x34 char '4') => 56 (0x38)\n    57, // input 53 (0x35 char '5') => 57 (0x39)\n    58, // input 54 (0x36 char '6') => 58 (0x3A)\n    59, // input 55 (0x37 char '7') => 59 (0x3B)\n    60, // input 56 (0x38 char '8') => 60 (0x3C)\n    61, // input 57 (0x39 char '9') => 61 (0x3D)\n    INVALID_VALUE, // input 58 (0x3A)\n    INVALID_VALUE, // input 59 (0x3B)\n    INVALID_VALUE, // input 60 (0x3C)\n    INVALID_VALUE, // input 61 (0x3D)\n    INVALID_VALUE, // input 62 (0x3E)\n    INVALID_VALUE, // input 63 (0x3F)\n    INVALID_VALUE, // input 64 (0x40)\n    0, // input 65 (0x41 char 'A') => 0 (0x0)\n    1, // input 66 (0x42 char 'B') => 1 (0x1)\n    2, // input 67 (0x43 char 'C') => 2 (0x2)\n    3, // input 68 (0x44 char 'D') => 3 (0x3)\n    4, // input 69 (0x45 char 'E') => 4 (0x4)\n    5, // input 70 (0x46 char 'F') => 5 (0x5)\n    6, // input 71 (0x47 char 'G') => 6 (0x6)\n    7, // input 72 (0x48 char 'H') => 7 (0x7)\n    8, // input 73 (0x49 char 'I') => 8 (0x8)\n    9, // input 74 (0x4A char 'J') => 9 (0x9)\n    10, // input 75 (0x4B char 'K') => 10 (0xA)\n    11, // input 76 (0x4C char 'L') => 11 (0xB)\n    12, // input 77 (0x4D char 'M') => 12 (0xC)\n    13, // input 78 (0x4E char 'N') => 13 (0xD)\n    14, // input 79 (0x4F char 'O') => 14 (0xE)\n    15, // input 80 (0x50 char 'P') => 15 (0xF)\n    16, // input 81 (0x51 char 'Q') => 16 (0x10)\n    17, // input 82 (0x52 char 'R') => 17 (0x11)\n    18, // input 83 (0x53 char 'S') => 18 (0x12)\n    19, // input 84 (0x54 char 'T') => 19 (0x13)\n    20, // input 85 (0x55 char 'U') => 20 (0x14)\n    21, // input 86 (0x56 char 'V') => 21 (0x15)\n    22, // input 87 (0x57 char 'W') => 22 (0x16)\n    23, // input 88 (0x58 char 'X') => 23 (0x17)\n    24, // input 89 (0x59 char 'Y') => 24 (0x18)\n    25, // input 90 (0x5A char 'Z') => 25 (0x19)\n    INVALID_VALUE, // input 91 (0x5B)\n    INVALID_VALUE, // input 92 (0x5C)\n    INVALID_VALUE, // input 93 (0x5D)\n    INVALID_VALUE, // input 94 (0x5E)\n    63, // input 95 (0x5F char '_') => 63 (0x3F)\n    INVALID_VALUE, // input 96 (0x60)\n    26, // input 97 (0x61 char 'a') => 26 (0x1A)\n    27, // input 98 (0x62 char 'b') => 27 (0x1B)\n    28, // input 99 (0x63 char 'c') => 28 (0x1C)\n    29, // input 100 (0x64 char 'd') => 29 (0x1D)\n    30, // input 101 (0x65 char 'e') => 30 (0x1E)\n    31, // input 102 (0x66 char 'f') => 31 (0x1F)\n    32, // input 103 (0x67 char 'g') => 32 (0x20)\n    33, // input 104 (0x68 char 'h') => 33 (0x21)\n    34, // input 105 (0x69 char 'i') => 34 (0x22)\n    35, // input 106 (0x6A char 'j') => 35 (0x23)\n    36, // input 107 (0x6B char 'k') => 36 (0x24)\n    37, // input 108 (0x6C char 'l') => 37 (0x25)\n    38, // input 109 (0x6D char 'm') => 38 (0x26)\n    39, // input 110 (0x6E char 'n') => 39 (0x27)\n    40, // input 111 (0x6F char 'o') => 40 (0x28)\n    41, // input 112 (0x70 char 'p') => 41 (0x29)\n    42, // input 113 (0x71 char 'q') => 42 (0x2A)\n    43, // input 114 (0x72 char 'r') => 43 (0x2B)\n    44, // input 115 (0x73 char 's') => 44 (0x2C)\n    45, // input 116 (0x74 char 't') => 45 (0x2D)\n    46, // input 117 (0x75 char 'u') => 46 (0x2E)\n    47, // input 118 (0x76 char 'v') => 47 (0x2F)\n    48, // input 119 (0x77 char 'w') => 48 (0x30)\n    49, // input 120 (0x78 char 'x') => 49 (0x31)\n    50, // input 121 (0x79 char 'y') => 50 (0x32)\n    51, // input 122 (0x7A char 'z') => 51 (0x33)\n    INVALID_VALUE, // input 123 (0x7B)\n    INVALID_VALUE, // input 124 (0x7C)\n    INVALID_VALUE, // input 125 (0x7D)\n    INVALID_VALUE, // input 126 (0x7E)\n    INVALID_VALUE, // input 127 (0x7F)\n    INVALID_VALUE, // input 128 (0x80)\n    INVALID_VALUE, // input 129 (0x81)\n    INVALID_VALUE, // input 130 (0x82)\n    INVALID_VALUE, // input 131 (0x83)\n    INVALID_VALUE, // input 132 (0x84)\n    INVALID_VALUE, // input 133 (0x85)\n    INVALID_VALUE, // input 134 (0x86)\n    INVALID_VALUE, // input 135 (0x87)\n    INVALID_VALUE, // input 136 (0x88)\n    INVALID_VALUE, // input 137 (0x89)\n    INVALID_VALUE, // input 138 (0x8A)\n    INVALID_VALUE, // input 139 (0x8B)\n    INVALID_VALUE, // input 140 (0x8C)\n    INVALID_VALUE, // input 141 (0x8D)\n    INVALID_VALUE, // input 142 (0x8E)\n    INVALID_VALUE, // input 143 (0x8F)\n    INVALID_VALUE, // input 144 (0x90)\n    INVALID_VALUE, // input 145 (0x91)\n    INVALID_VALUE, // input 146 (0x92)\n    INVALID_VALUE, // input 147 (0x93)\n    INVALID_VALUE, // input 148 (0x94)\n    INVALID_VALUE, // input 149 (0x95)\n    INVALID_VALUE, // input 150 (0x96)\n    INVALID_VALUE, // input 151 (0x97)\n    INVALID_VALUE, // input 152 (0x98)\n    INVALID_VALUE, // input 153 (0x99)\n    INVALID_VALUE, // input 154 (0x9A)\n    INVALID_VALUE, // input 155 (0x9B)\n    INVALID_VALUE, // input 156 (0x9C)\n    INVALID_VALUE, // input 157 (0x9D)\n    INVALID_VALUE, // input 158 (0x9E)\n    INVALID_VALUE, // input 159 (0x9F)\n    INVALID_VALUE, // input 160 (0xA0)\n    INVALID_VALUE, // input 161 (0xA1)\n    INVALID_VALUE, // input 162 (0xA2)\n    INVALID_VALUE, // input 163 (0xA3)\n    INVALID_VALUE, // input 164 (0xA4)\n    INVALID_VALUE, // input 165 (0xA5)\n    INVALID_VALUE, // input 166 (0xA6)\n    INVALID_VALUE, // input 167 (0xA7)\n    INVALID_VALUE, // input 168 (0xA8)\n    INVALID_VALUE, // input 169 (0xA9)\n    INVALID_VALUE, // input 170 (0xAA)\n    INVALID_VALUE, // input 171 (0xAB)\n    INVALID_VALUE, // input 172 (0xAC)\n    INVALID_VALUE, // input 173 (0xAD)\n    INVALID_VALUE, // input 174 (0xAE)\n    INVALID_VALUE, // input 175 (0xAF)\n    INVALID_VALUE, // input 176 (0xB0)\n    INVALID_VALUE, // input 177 (0xB1)\n    INVALID_VALUE, // input 178 (0xB2)\n    INVALID_VALUE, // input 179 (0xB3)\n    INVALID_VALUE, // input 180 (0xB4)\n    INVALID_VALUE, // input 181 (0xB5)\n    INVALID_VALUE, // input 182 (0xB6)\n    INVALID_VALUE, // input 183 (0xB7)\n    INVALID_VALUE, // input 184 (0xB8)\n    INVALID_VALUE, // input 185 (0xB9)\n    INVALID_VALUE, // input 186 (0xBA)\n    INVALID_VALUE, // input 187 (0xBB)\n    INVALID_VALUE, // input 188 (0xBC)\n    INVALID_VALUE, // input 189 (0xBD)\n    INVALID_VALUE, // input 190 (0xBE)\n    INVALID_VALUE, // input 191 (0xBF)\n    INVALID_VALUE, // input 192 (0xC0)\n    INVALID_VALUE, // input 193 (0xC1)\n    INVALID_VALUE, // input 194 (0xC2)\n    INVALID_VALUE, // input 195 (0xC3)\n    INVALID_VALUE, // input 196 (0xC4)\n    INVALID_VALUE, // input 197 (0xC5)\n    INVALID_VALUE, // input 198 (0xC6)\n    INVALID_VALUE, // input 199 (0xC7)\n    INVALID_VALUE, // input 200 (0xC8)\n    INVALID_VALUE, // input 201 (0xC9)\n    INVALID_VALUE, // input 202 (0xCA)\n    INVALID_VALUE, // input 203 (0xCB)\n    INVALID_VALUE, // input 204 (0xCC)\n    INVALID_VALUE, // input 205 (0xCD)\n    INVALID_VALUE, // input 206 (0xCE)\n    INVALID_VALUE, // input 207 (0xCF)\n    INVALID_VALUE, // input 208 (0xD0)\n    INVALID_VALUE, // input 209 (0xD1)\n    INVALID_VALUE, // input 210 (0xD2)\n    INVALID_VALUE, // input 211 (0xD3)\n    INVALID_VALUE, // input 212 (0xD4)\n    INVALID_VALUE, // input 213 (0xD5)\n    INVALID_VALUE, // input 214 (0xD6)\n    INVALID_VALUE, // input 215 (0xD7)\n    INVALID_VALUE, // input 216 (0xD8)\n    INVALID_VALUE, // input 217 (0xD9)\n    INVALID_VALUE, // input 218 (0xDA)\n    INVALID_VALUE, // input 219 (0xDB)\n    INVALID_VALUE, // input 220 (0xDC)\n    INVALID_VALUE, // input 221 (0xDD)\n    INVALID_VALUE, // input 222 (0xDE)\n    INVALID_VALUE, // input 223 (0xDF)\n    INVALID_VALUE, // input 224 (0xE0)\n    INVALID_VALUE, // input 225 (0xE1)\n    INVALID_VALUE, // input 226 (0xE2)\n    INVALID_VALUE, // input 227 (0xE3)\n    INVALID_VALUE, // input 228 (0xE4)\n    INVALID_VALUE, // input 229 (0xE5)\n    INVALID_VALUE, // input 230 (0xE6)\n    INVALID_VALUE, // input 231 (0xE7)\n    INVALID_VALUE, // input 232 (0xE8)\n    INVALID_VALUE, // input 233 (0xE9)\n    INVALID_VALUE, // input 234 (0xEA)\n    INVALID_VALUE, // input 235 (0xEB)\n    INVALID_VALUE, // input 236 (0xEC)\n    INVALID_VALUE, // input 237 (0xED)\n    INVALID_VALUE, // input 238 (0xEE)\n    INVALID_VALUE, // input 239 (0xEF)\n    INVALID_VALUE, // input 240 (0xF0)\n    INVALID_VALUE, // input 241 (0xF1)\n    INVALID_VALUE, // input 242 (0xF2)\n    INVALID_VALUE, // input 243 (0xF3)\n    INVALID_VALUE, // input 244 (0xF4)\n    INVALID_VALUE, // input 245 (0xF5)\n    INVALID_VALUE, // input 246 (0xF6)\n    INVALID_VALUE, // input 247 (0xF7)\n    INVALID_VALUE, // input 248 (0xF8)\n    INVALID_VALUE, // input 249 (0xF9)\n    INVALID_VALUE, // input 250 (0xFA)\n    INVALID_VALUE, // input 251 (0xFB)\n    INVALID_VALUE, // input 252 (0xFC)\n    INVALID_VALUE, // input 253 (0xFD)\n    INVALID_VALUE, // input 254 (0xFE)\n    INVALID_VALUE, // input 255 (0xFF)\n];\n#[rustfmt::skip]\npub const CRYPT_ENCODE: &[u8; 64] = &[\n    46, // input 0 (0x0) => '.' (0x2E)\n    47, // input 1 (0x1) => '/' (0x2F)\n    48, // input 2 (0x2) => '0' (0x30)\n    49, // input 3 (0x3) => '1' (0x31)\n    50, // input 4 (0x4) => '2' (0x32)\n    51, // input 5 (0x5) => '3' (0x33)\n    52, // input 6 (0x6) => '4' (0x34)\n    53, // input 7 (0x7) => '5' (0x35)\n    54, // input 8 (0x8) => '6' (0x36)\n    55, // input 9 (0x9) => '7' (0x37)\n    56, // input 10 (0xA) => '8' (0x38)\n    57, // input 11 (0xB) => '9' (0x39)\n    65, // input 12 (0xC) => 'A' (0x41)\n    66, // input 13 (0xD) => 'B' (0x42)\n    67, // input 14 (0xE) => 'C' (0x43)\n    68, // input 15 (0xF) => 'D' (0x44)\n    69, // input 16 (0x10) => 'E' (0x45)\n    70, // input 17 (0x11) => 'F' (0x46)\n    71, // input 18 (0x12) => 'G' (0x47)\n    72, // input 19 (0x13) => 'H' (0x48)\n    73, // input 20 (0x14) => 'I' (0x49)\n    74, // input 21 (0x15) => 'J' (0x4A)\n    75, // input 22 (0x16) => 'K' (0x4B)\n    76, // input 23 (0x17) => 'L' (0x4C)\n    77, // input 24 (0x18) => 'M' (0x4D)\n    78, // input 25 (0x19) => 'N' (0x4E)\n    79, // input 26 (0x1A) => 'O' (0x4F)\n    80, // input 27 (0x1B) => 'P' (0x50)\n    81, // input 28 (0x1C) => 'Q' (0x51)\n    82, // input 29 (0x1D) => 'R' (0x52)\n    83, // input 30 (0x1E) => 'S' (0x53)\n    84, // input 31 (0x1F) => 'T' (0x54)\n    85, // input 32 (0x20) => 'U' (0x55)\n    86, // input 33 (0x21) => 'V' (0x56)\n    87, // input 34 (0x22) => 'W' (0x57)\n    88, // input 35 (0x23) => 'X' (0x58)\n    89, // input 36 (0x24) => 'Y' (0x59)\n    90, // input 37 (0x25) => 'Z' (0x5A)\n    97, // input 38 (0x26) => 'a' (0x61)\n    98, // input 39 (0x27) => 'b' (0x62)\n    99, // input 40 (0x28) => 'c' (0x63)\n    100, // input 41 (0x29) => 'd' (0x64)\n    101, // input 42 (0x2A) => 'e' (0x65)\n    102, // input 43 (0x2B) => 'f' (0x66)\n    103, // input 44 (0x2C) => 'g' (0x67)\n    104, // input 45 (0x2D) => 'h' (0x68)\n    105, // input 46 (0x2E) => 'i' (0x69)\n    106, // input 47 (0x2F) => 'j' (0x6A)\n    107, // input 48 (0x30) => 'k' (0x6B)\n    108, // input 49 (0x31) => 'l' (0x6C)\n    109, // input 50 (0x32) => 'm' (0x6D)\n    110, // input 51 (0x33) => 'n' (0x6E)\n    111, // input 52 (0x34) => 'o' (0x6F)\n    112, // input 53 (0x35) => 'p' (0x70)\n    113, // input 54 (0x36) => 'q' (0x71)\n    114, // input 55 (0x37) => 'r' (0x72)\n    115, // input 56 (0x38) => 's' (0x73)\n    116, // input 57 (0x39) => 't' (0x74)\n    117, // input 58 (0x3A) => 'u' (0x75)\n    118, // input 59 (0x3B) => 'v' (0x76)\n    119, // input 60 (0x3C) => 'w' (0x77)\n    120, // input 61 (0x3D) => 'x' (0x78)\n    121, // input 62 (0x3E) => 'y' (0x79)\n    122, // input 63 (0x3F) => 'z' (0x7A)\n];\n#[rustfmt::skip]\npub const CRYPT_DECODE: &[u8; 256] = &[\n    INVALID_VALUE, // input 0 (0x0)\n    INVALID_VALUE, // input 1 (0x1)\n    INVALID_VALUE, // input 2 (0x2)\n    INVALID_VALUE, // input 3 (0x3)\n    INVALID_VALUE, // input 4 (0x4)\n    INVALID_VALUE, // input 5 (0x5)\n    INVALID_VALUE, // input 6 (0x6)\n    INVALID_VALUE, // input 7 (0x7)\n    INVALID_VALUE, // input 8 (0x8)\n    INVALID_VALUE, // input 9 (0x9)\n    INVALID_VALUE, // input 10 (0xA)\n    INVALID_VALUE, // input 11 (0xB)\n    INVALID_VALUE, // input 12 (0xC)\n    INVALID_VALUE, // input 13 (0xD)\n    INVALID_VALUE, // input 14 (0xE)\n    INVALID_VALUE, // input 15 (0xF)\n    INVALID_VALUE, // input 16 (0x10)\n    INVALID_VALUE, // input 17 (0x11)\n    INVALID_VALUE, // input 18 (0x12)\n    INVALID_VALUE, // input 19 (0x13)\n    INVALID_VALUE, // input 20 (0x14)\n    INVALID_VALUE, // input 21 (0x15)\n    INVALID_VALUE, // input 22 (0x16)\n    INVALID_VALUE, // input 23 (0x17)\n    INVALID_VALUE, // input 24 (0x18)\n    INVALID_VALUE, // input 25 (0x19)\n    INVALID_VALUE, // input 26 (0x1A)\n    INVALID_VALUE, // input 27 (0x1B)\n    INVALID_VALUE, // input 28 (0x1C)\n    INVALID_VALUE, // input 29 (0x1D)\n    INVALID_VALUE, // input 30 (0x1E)\n    INVALID_VALUE, // input 31 (0x1F)\n    INVALID_VALUE, // input 32 (0x20)\n    INVALID_VALUE, // input 33 (0x21)\n    INVALID_VALUE, // input 34 (0x22)\n    INVALID_VALUE, // input 35 (0x23)\n    INVALID_VALUE, // input 36 (0x24)\n    INVALID_VALUE, // input 37 (0x25)\n    INVALID_VALUE, // input 38 (0x26)\n    INVALID_VALUE, // input 39 (0x27)\n    INVALID_VALUE, // input 40 (0x28)\n    INVALID_VALUE, // input 41 (0x29)\n    INVALID_VALUE, // input 42 (0x2A)\n    INVALID_VALUE, // input 43 (0x2B)\n    INVALID_VALUE, // input 44 (0x2C)\n    INVALID_VALUE, // input 45 (0x2D)\n    0, // input 46 (0x2E char '.') => 0 (0x0)\n    1, // input 47 (0x2F char '/') => 1 (0x1)\n    2, // input 48 (0x30 char '0') => 2 (0x2)\n    3, // input 49 (0x31 char '1') => 3 (0x3)\n    4, // input 50 (0x32 char '2') => 4 (0x4)\n    5, // input 51 (0x33 char '3') => 5 (0x5)\n    6, // input 52 (0x34 char '4') => 6 (0x6)\n    7, // input 53 (0x35 char '5') => 7 (0x7)\n    8, // input 54 (0x36 char '6') => 8 (0x8)\n    9, // input 55 (0x37 char '7') => 9 (0x9)\n    10, // input 56 (0x38 char '8') => 10 (0xA)\n    11, // input 57 (0x39 char '9') => 11 (0xB)\n    INVALID_VALUE, // input 58 (0x3A)\n    INVALID_VALUE, // input 59 (0x3B)\n    INVALID_VALUE, // input 60 (0x3C)\n    INVALID_VALUE, // input 61 (0x3D)\n    INVALID_VALUE, // input 62 (0x3E)\n    INVALID_VALUE, // input 63 (0x3F)\n    INVALID_VALUE, // input 64 (0x40)\n    12, // input 65 (0x41 char 'A') => 12 (0xC)\n    13, // input 66 (0x42 char 'B') => 13 (0xD)\n    14, // input 67 (0x43 char 'C') => 14 (0xE)\n    15, // input 68 (0x44 char 'D') => 15 (0xF)\n    16, // input 69 (0x45 char 'E') => 16 (0x10)\n    17, // input 70 (0x46 char 'F') => 17 (0x11)\n    18, // input 71 (0x47 char 'G') => 18 (0x12)\n    19, // input 72 (0x48 char 'H') => 19 (0x13)\n    20, // input 73 (0x49 char 'I') => 20 (0x14)\n    21, // input 74 (0x4A char 'J') => 21 (0x15)\n    22, // input 75 (0x4B char 'K') => 22 (0x16)\n    23, // input 76 (0x4C char 'L') => 23 (0x17)\n    24, // input 77 (0x4D char 'M') => 24 (0x18)\n    25, // input 78 (0x4E char 'N') => 25 (0x19)\n    26, // input 79 (0x4F char 'O') => 26 (0x1A)\n    27, // input 80 (0x50 char 'P') => 27 (0x1B)\n    28, // input 81 (0x51 char 'Q') => 28 (0x1C)\n    29, // input 82 (0x52 char 'R') => 29 (0x1D)\n    30, // input 83 (0x53 char 'S') => 30 (0x1E)\n    31, // input 84 (0x54 char 'T') => 31 (0x1F)\n    32, // input 85 (0x55 char 'U') => 32 (0x20)\n    33, // input 86 (0x56 char 'V') => 33 (0x21)\n    34, // input 87 (0x57 char 'W') => 34 (0x22)\n    35, // input 88 (0x58 char 'X') => 35 (0x23)\n    36, // input 89 (0x59 char 'Y') => 36 (0x24)\n    37, // input 90 (0x5A char 'Z') => 37 (0x25)\n    INVALID_VALUE, // input 91 (0x5B)\n    INVALID_VALUE, // input 92 (0x5C)\n    INVALID_VALUE, // input 93 (0x5D)\n    INVALID_VALUE, // input 94 (0x5E)\n    INVALID_VALUE, // input 95 (0x5F)\n    INVALID_VALUE, // input 96 (0x60)\n    38, // input 97 (0x61 char 'a') => 38 (0x26)\n    39, // input 98 (0x62 char 'b') => 39 (0x27)\n    40, // input 99 (0x63 char 'c') => 40 (0x28)\n    41, // input 100 (0x64 char 'd') => 41 (0x29)\n    42, // input 101 (0x65 char 'e') => 42 (0x2A)\n    43, // input 102 (0x66 char 'f') => 43 (0x2B)\n    44, // input 103 (0x67 char 'g') => 44 (0x2C)\n    45, // input 104 (0x68 char 'h') => 45 (0x2D)\n    46, // input 105 (0x69 char 'i') => 46 (0x2E)\n    47, // input 106 (0x6A char 'j') => 47 (0x2F)\n    48, // input 107 (0x6B char 'k') => 48 (0x30)\n    49, // input 108 (0x6C char 'l') => 49 (0x31)\n    50, // input 109 (0x6D char 'm') => 50 (0x32)\n    51, // input 110 (0x6E char 'n') => 51 (0x33)\n    52, // input 111 (0x6F char 'o') => 52 (0x34)\n    53, // input 112 (0x70 char 'p') => 53 (0x35)\n    54, // input 113 (0x71 char 'q') => 54 (0x36)\n    55, // input 114 (0x72 char 'r') => 55 (0x37)\n    56, // input 115 (0x73 char 's') => 56 (0x38)\n    57, // input 116 (0x74 char 't') => 57 (0x39)\n    58, // input 117 (0x75 char 'u') => 58 (0x3A)\n    59, // input 118 (0x76 char 'v') => 59 (0x3B)\n    60, // input 119 (0x77 char 'w') => 60 (0x3C)\n    61, // input 120 (0x78 char 'x') => 61 (0x3D)\n    62, // input 121 (0x79 char 'y') => 62 (0x3E)\n    63, // input 122 (0x7A char 'z') => 63 (0x3F)\n    INVALID_VALUE, // input 123 (0x7B)\n    INVALID_VALUE, // input 124 (0x7C)\n    INVALID_VALUE, // input 125 (0x7D)\n    INVALID_VALUE, // input 126 (0x7E)\n    INVALID_VALUE, // input 127 (0x7F)\n    INVALID_VALUE, // input 128 (0x80)\n    INVALID_VALUE, // input 129 (0x81)\n    INVALID_VALUE, // input 130 (0x82)\n    INVALID_VALUE, // input 131 (0x83)\n    INVALID_VALUE, // input 132 (0x84)\n    INVALID_VALUE, // input 133 (0x85)\n    INVALID_VALUE, // input 134 (0x86)\n    INVALID_VALUE, // input 135 (0x87)\n    INVALID_VALUE, // input 136 (0x88)\n    INVALID_VALUE, // input 137 (0x89)\n    INVALID_VALUE, // input 138 (0x8A)\n    INVALID_VALUE, // input 139 (0x8B)\n    INVALID_VALUE, // input 140 (0x8C)\n    INVALID_VALUE, // input 141 (0x8D)\n    INVALID_VALUE, // input 142 (0x8E)\n    INVALID_VALUE, // input 143 (0x8F)\n    INVALID_VALUE, // input 144 (0x90)\n    INVALID_VALUE, // input 145 (0x91)\n    INVALID_VALUE, // input 146 (0x92)\n    INVALID_VALUE, // input 147 (0x93)\n    INVALID_VALUE, // input 148 (0x94)\n    INVALID_VALUE, // input 149 (0x95)\n    INVALID_VALUE, // input 150 (0x96)\n    INVALID_VALUE, // input 151 (0x97)\n    INVALID_VALUE, // input 152 (0x98)\n    INVALID_VALUE, // input 153 (0x99)\n    INVALID_VALUE, // input 154 (0x9A)\n    INVALID_VALUE, // input 155 (0x9B)\n    INVALID_VALUE, // input 156 (0x9C)\n    INVALID_VALUE, // input 157 (0x9D)\n    INVALID_VALUE, // input 158 (0x9E)\n    INVALID_VALUE, // input 159 (0x9F)\n    INVALID_VALUE, // input 160 (0xA0)\n    INVALID_VALUE, // input 161 (0xA1)\n    INVALID_VALUE, // input 162 (0xA2)\n    INVALID_VALUE, // input 163 (0xA3)\n    INVALID_VALUE, // input 164 (0xA4)\n    INVALID_VALUE, // input 165 (0xA5)\n    INVALID_VALUE, // input 166 (0xA6)\n    INVALID_VALUE, // input 167 (0xA7)\n    INVALID_VALUE, // input 168 (0xA8)\n    INVALID_VALUE, // input 169 (0xA9)\n    INVALID_VALUE, // input 170 (0xAA)\n    INVALID_VALUE, // input 171 (0xAB)\n    INVALID_VALUE, // input 172 (0xAC)\n    INVALID_VALUE, // input 173 (0xAD)\n    INVALID_VALUE, // input 174 (0xAE)\n    INVALID_VALUE, // input 175 (0xAF)\n    INVALID_VALUE, // input 176 (0xB0)\n    INVALID_VALUE, // input 177 (0xB1)\n    INVALID_VALUE, // input 178 (0xB2)\n    INVALID_VALUE, // input 179 (0xB3)\n    INVALID_VALUE, // input 180 (0xB4)\n    INVALID_VALUE, // input 181 (0xB5)\n    INVALID_VALUE, // input 182 (0xB6)\n    INVALID_VALUE, // input 183 (0xB7)\n    INVALID_VALUE, // input 184 (0xB8)\n    INVALID_VALUE, // input 185 (0xB9)\n    INVALID_VALUE, // input 186 (0xBA)\n    INVALID_VALUE, // input 187 (0xBB)\n    INVALID_VALUE, // input 188 (0xBC)\n    INVALID_VALUE, // input 189 (0xBD)\n    INVALID_VALUE, // input 190 (0xBE)\n    INVALID_VALUE, // input 191 (0xBF)\n    INVALID_VALUE, // input 192 (0xC0)\n    INVALID_VALUE, // input 193 (0xC1)\n    INVALID_VALUE, // input 194 (0xC2)\n    INVALID_VALUE, // input 195 (0xC3)\n    INVALID_VALUE, // input 196 (0xC4)\n    INVALID_VALUE, // input 197 (0xC5)\n    INVALID_VALUE, // input 198 (0xC6)\n    INVALID_VALUE, // input 199 (0xC7)\n    INVALID_VALUE, // input 200 (0xC8)\n    INVALID_VALUE, // input 201 (0xC9)\n    INVALID_VALUE, // input 202 (0xCA)\n    INVALID_VALUE, // input 203 (0xCB)\n    INVALID_VALUE, // input 204 (0xCC)\n    INVALID_VALUE, // input 205 (0xCD)\n    INVALID_VALUE, // input 206 (0xCE)\n    INVALID_VALUE, // input 207 (0xCF)\n    INVALID_VALUE, // input 208 (0xD0)\n    INVALID_VALUE, // input 209 (0xD1)\n    INVALID_VALUE, // input 210 (0xD2)\n    INVALID_VALUE, // input 211 (0xD3)\n    INVALID_VALUE, // input 212 (0xD4)\n    INVALID_VALUE, // input 213 (0xD5)\n    INVALID_VALUE, // input 214 (0xD6)\n    INVALID_VALUE, // input 215 (0xD7)\n    INVALID_VALUE, // input 216 (0xD8)\n    INVALID_VALUE, // input 217 (0xD9)\n    INVALID_VALUE, // input 218 (0xDA)\n    INVALID_VALUE, // input 219 (0xDB)\n    INVALID_VALUE, // input 220 (0xDC)\n    INVALID_VALUE, // input 221 (0xDD)\n    INVALID_VALUE, // input 222 (0xDE)\n    INVALID_VALUE, // input 223 (0xDF)\n    INVALID_VALUE, // input 224 (0xE0)\n    INVALID_VALUE, // input 225 (0xE1)\n    INVALID_VALUE, // input 226 (0xE2)\n    INVALID_VALUE, // input 227 (0xE3)\n    INVALID_VALUE, // input 228 (0xE4)\n    INVALID_VALUE, // input 229 (0xE5)\n    INVALID_VALUE, // input 230 (0xE6)\n    INVALID_VALUE, // input 231 (0xE7)\n    INVALID_VALUE, // input 232 (0xE8)\n    INVALID_VALUE, // input 233 (0xE9)\n    INVALID_VALUE, // input 234 (0xEA)\n    INVALID_VALUE, // input 235 (0xEB)\n    INVALID_VALUE, // input 236 (0xEC)\n    INVALID_VALUE, // input 237 (0xED)\n    INVALID_VALUE, // input 238 (0xEE)\n    INVALID_VALUE, // input 239 (0xEF)\n    INVALID_VALUE, // input 240 (0xF0)\n    INVALID_VALUE, // input 241 (0xF1)\n    INVALID_VALUE, // input 242 (0xF2)\n    INVALID_VALUE, // input 243 (0xF3)\n    INVALID_VALUE, // input 244 (0xF4)\n    INVALID_VALUE, // input 245 (0xF5)\n    INVALID_VALUE, // input 246 (0xF6)\n    INVALID_VALUE, // input 247 (0xF7)\n    INVALID_VALUE, // input 248 (0xF8)\n    INVALID_VALUE, // input 249 (0xF9)\n    INVALID_VALUE, // input 250 (0xFA)\n    INVALID_VALUE, // input 251 (0xFB)\n    INVALID_VALUE, // input 252 (0xFC)\n    INVALID_VALUE, // input 253 (0xFD)\n    INVALID_VALUE, // input 254 (0xFE)\n    INVALID_VALUE, // input 255 (0xFF)\n];\n#[rustfmt::skip]\npub const BCRYPT_ENCODE: &[u8; 64] = &[\n    46, // input 0 (0x0) => '.' (0x2E)\n    47, // input 1 (0x1) => '/' (0x2F)\n    65, // input 2 (0x2) => 'A' (0x41)\n    66, // input 3 (0x3) => 'B' (0x42)\n    67, // input 4 (0x4) => 'C' (0x43)\n    68, // input 5 (0x5) => 'D' (0x44)\n    69, // input 6 (0x6) => 'E' (0x45)\n    70, // input 7 (0x7) => 'F' (0x46)\n    71, // input 8 (0x8) => 'G' (0x47)\n    72, // input 9 (0x9) => 'H' (0x48)\n    73, // input 10 (0xA) => 'I' (0x49)\n    74, // input 11 (0xB) => 'J' (0x4A)\n    75, // input 12 (0xC) => 'K' (0x4B)\n    76, // input 13 (0xD) => 'L' (0x4C)\n    77, // input 14 (0xE) => 'M' (0x4D)\n    78, // input 15 (0xF) => 'N' (0x4E)\n    79, // input 16 (0x10) => 'O' (0x4F)\n    80, // input 17 (0x11) => 'P' (0x50)\n    81, // input 18 (0x12) => 'Q' (0x51)\n    82, // input 19 (0x13) => 'R' (0x52)\n    83, // input 20 (0x14) => 'S' (0x53)\n    84, // input 21 (0x15) => 'T' (0x54)\n    85, // input 22 (0x16) => 'U' (0x55)\n    86, // input 23 (0x17) => 'V' (0x56)\n    87, // input 24 (0x18) => 'W' (0x57)\n    88, // input 25 (0x19) => 'X' (0x58)\n    89, // input 26 (0x1A) => 'Y' (0x59)\n    90, // input 27 (0x1B) => 'Z' (0x5A)\n    97, // input 28 (0x1C) => 'a' (0x61)\n    98, // input 29 (0x1D) => 'b' (0x62)\n    99, // input 30 (0x1E) => 'c' (0x63)\n    100, // input 31 (0x1F) => 'd' (0x64)\n    101, // input 32 (0x20) => 'e' (0x65)\n    102, // input 33 (0x21) => 'f' (0x66)\n    103, // input 34 (0x22) => 'g' (0x67)\n    104, // input 35 (0x23) => 'h' (0x68)\n    105, // input 36 (0x24) => 'i' (0x69)\n    106, // input 37 (0x25) => 'j' (0x6A)\n    107, // input 38 (0x26) => 'k' (0x6B)\n    108, // input 39 (0x27) => 'l' (0x6C)\n    109, // input 40 (0x28) => 'm' (0x6D)\n    110, // input 41 (0x29) => 'n' (0x6E)\n    111, // input 42 (0x2A) => 'o' (0x6F)\n    112, // input 43 (0x2B) => 'p' (0x70)\n    113, // input 44 (0x2C) => 'q' (0x71)\n    114, // input 45 (0x2D) => 'r' (0x72)\n    115, // input 46 (0x2E) => 's' (0x73)\n    116, // input 47 (0x2F) => 't' (0x74)\n    117, // input 48 (0x30) => 'u' (0x75)\n    118, // input 49 (0x31) => 'v' (0x76)\n    119, // input 50 (0x32) => 'w' (0x77)\n    120, // input 51 (0x33) => 'x' (0x78)\n    121, // input 52 (0x34) => 'y' (0x79)\n    122, // input 53 (0x35) => 'z' (0x7A)\n    48, // input 54 (0x36) => '0' (0x30)\n    49, // input 55 (0x37) => '1' (0x31)\n    50, // input 56 (0x38) => '2' (0x32)\n    51, // input 57 (0x39) => '3' (0x33)\n    52, // input 58 (0x3A) => '4' (0x34)\n    53, // input 59 (0x3B) => '5' (0x35)\n    54, // input 60 (0x3C) => '6' (0x36)\n    55, // input 61 (0x3D) => '7' (0x37)\n    56, // input 62 (0x3E) => '8' (0x38)\n    57, // input 63 (0x3F) => '9' (0x39)\n];\n#[rustfmt::skip]\npub const BCRYPT_DECODE: &[u8; 256] = &[\n    INVALID_VALUE, // input 0 (0x0)\n    INVALID_VALUE, // input 1 (0x1)\n    INVALID_VALUE, // input 2 (0x2)\n    INVALID_VALUE, // input 3 (0x3)\n    INVALID_VALUE, // input 4 (0x4)\n    INVALID_VALUE, // input 5 (0x5)\n    INVALID_VALUE, // input 6 (0x6)\n    INVALID_VALUE, // input 7 (0x7)\n    INVALID_VALUE, // input 8 (0x8)\n    INVALID_VALUE, // input 9 (0x9)\n    INVALID_VALUE, // input 10 (0xA)\n    INVALID_VALUE, // input 11 (0xB)\n    INVALID_VALUE, // input 12 (0xC)\n    INVALID_VALUE, // input 13 (0xD)\n    INVALID_VALUE, // input 14 (0xE)\n    INVALID_VALUE, // input 15 (0xF)\n    INVALID_VALUE, // input 16 (0x10)\n    INVALID_VALUE, // input 17 (0x11)\n    INVALID_VALUE, // input 18 (0x12)\n    INVALID_VALUE, // input 19 (0x13)\n    INVALID_VALUE, // input 20 (0x14)\n    INVALID_VALUE, // input 21 (0x15)\n    INVALID_VALUE, // input 22 (0x16)\n    INVALID_VALUE, // input 23 (0x17)\n    INVALID_VALUE, // input 24 (0x18)\n    INVALID_VALUE, // input 25 (0x19)\n    INVALID_VALUE, // input 26 (0x1A)\n    INVALID_VALUE, // input 27 (0x1B)\n    INVALID_VALUE, // input 28 (0x1C)\n    INVALID_VALUE, // input 29 (0x1D)\n    INVALID_VALUE, // input 30 (0x1E)\n    INVALID_VALUE, // input 31 (0x1F)\n    INVALID_VALUE, // input 32 (0x20)\n    INVALID_VALUE, // input 33 (0x21)\n    INVALID_VALUE, // input 34 (0x22)\n    INVALID_VALUE, // input 35 (0x23)\n    INVALID_VALUE, // input 36 (0x24)\n    INVALID_VALUE, // input 37 (0x25)\n    INVALID_VALUE, // input 38 (0x26)\n    INVALID_VALUE, // input 39 (0x27)\n    INVALID_VALUE, // input 40 (0x28)\n    INVALID_VALUE, // input 41 (0x29)\n    INVALID_VALUE, // input 42 (0x2A)\n    INVALID_VALUE, // input 43 (0x2B)\n    INVALID_VALUE, // input 44 (0x2C)\n    INVALID_VALUE, // input 45 (0x2D)\n    0, // input 46 (0x2E char '.') => 0 (0x0)\n    1, // input 47 (0x2F char '/') => 1 (0x1)\n    54, // input 48 (0x30 char '0') => 54 (0x36)\n    55, // input 49 (0x31 char '1') => 55 (0x37)\n    56, // input 50 (0x32 char '2') => 56 (0x38)\n    57, // input 51 (0x33 char '3') => 57 (0x39)\n    58, // input 52 (0x34 char '4') => 58 (0x3A)\n    59, // input 53 (0x35 char '5') => 59 (0x3B)\n    60, // input 54 (0x36 char '6') => 60 (0x3C)\n    61, // input 55 (0x37 char '7') => 61 (0x3D)\n    62, // input 56 (0x38 char '8') => 62 (0x3E)\n    63, // input 57 (0x39 char '9') => 63 (0x3F)\n    INVALID_VALUE, // input 58 (0x3A)\n    INVALID_VALUE, // input 59 (0x3B)\n    INVALID_VALUE, // input 60 (0x3C)\n    INVALID_VALUE, // input 61 (0x3D)\n    INVALID_VALUE, // input 62 (0x3E)\n    INVALID_VALUE, // input 63 (0x3F)\n    INVALID_VALUE, // input 64 (0x40)\n    2, // input 65 (0x41 char 'A') => 2 (0x2)\n    3, // input 66 (0x42 char 'B') => 3 (0x3)\n    4, // input 67 (0x43 char 'C') => 4 (0x4)\n    5, // input 68 (0x44 char 'D') => 5 (0x5)\n    6, // input 69 (0x45 char 'E') => 6 (0x6)\n    7, // input 70 (0x46 char 'F') => 7 (0x7)\n    8, // input 71 (0x47 char 'G') => 8 (0x8)\n    9, // input 72 (0x48 char 'H') => 9 (0x9)\n    10, // input 73 (0x49 char 'I') => 10 (0xA)\n    11, // input 74 (0x4A char 'J') => 11 (0xB)\n    12, // input 75 (0x4B char 'K') => 12 (0xC)\n    13, // input 76 (0x4C char 'L') => 13 (0xD)\n    14, // input 77 (0x4D char 'M') => 14 (0xE)\n    15, // input 78 (0x4E char 'N') => 15 (0xF)\n    16, // input 79 (0x4F char 'O') => 16 (0x10)\n    17, // input 80 (0x50 char 'P') => 17 (0x11)\n    18, // input 81 (0x51 char 'Q') => 18 (0x12)\n    19, // input 82 (0x52 char 'R') => 19 (0x13)\n    20, // input 83 (0x53 char 'S') => 20 (0x14)\n    21, // input 84 (0x54 char 'T') => 21 (0x15)\n    22, // input 85 (0x55 char 'U') => 22 (0x16)\n    23, // input 86 (0x56 char 'V') => 23 (0x17)\n    24, // input 87 (0x57 char 'W') => 24 (0x18)\n    25, // input 88 (0x58 char 'X') => 25 (0x19)\n    26, // input 89 (0x59 char 'Y') => 26 (0x1A)\n    27, // input 90 (0x5A char 'Z') => 27 (0x1B)\n    INVALID_VALUE, // input 91 (0x5B)\n    INVALID_VALUE, // input 92 (0x5C)\n    INVALID_VALUE, // input 93 (0x5D)\n    INVALID_VALUE, // input 94 (0x5E)\n    INVALID_VALUE, // input 95 (0x5F)\n    INVALID_VALUE, // input 96 (0x60)\n    28, // input 97 (0x61 char 'a') => 28 (0x1C)\n    29, // input 98 (0x62 char 'b') => 29 (0x1D)\n    30, // input 99 (0x63 char 'c') => 30 (0x1E)\n    31, // input 100 (0x64 char 'd') => 31 (0x1F)\n    32, // input 101 (0x65 char 'e') => 32 (0x20)\n    33, // input 102 (0x66 char 'f') => 33 (0x21)\n    34, // input 103 (0x67 char 'g') => 34 (0x22)\n    35, // input 104 (0x68 char 'h') => 35 (0x23)\n    36, // input 105 (0x69 char 'i') => 36 (0x24)\n    37, // input 106 (0x6A char 'j') => 37 (0x25)\n    38, // input 107 (0x6B char 'k') => 38 (0x26)\n    39, // input 108 (0x6C char 'l') => 39 (0x27)\n    40, // input 109 (0x6D char 'm') => 40 (0x28)\n    41, // input 110 (0x6E char 'n') => 41 (0x29)\n    42, // input 111 (0x6F char 'o') => 42 (0x2A)\n    43, // input 112 (0x70 char 'p') => 43 (0x2B)\n    44, // input 113 (0x71 char 'q') => 44 (0x2C)\n    45, // input 114 (0x72 char 'r') => 45 (0x2D)\n    46, // input 115 (0x73 char 's') => 46 (0x2E)\n    47, // input 116 (0x74 char 't') => 47 (0x2F)\n    48, // input 117 (0x75 char 'u') => 48 (0x30)\n    49, // input 118 (0x76 char 'v') => 49 (0x31)\n    50, // input 119 (0x77 char 'w') => 50 (0x32)\n    51, // input 120 (0x78 char 'x') => 51 (0x33)\n    52, // input 121 (0x79 char 'y') => 52 (0x34)\n    53, // input 122 (0x7A char 'z') => 53 (0x35)\n    INVALID_VALUE, // input 123 (0x7B)\n    INVALID_VALUE, // input 124 (0x7C)\n    INVALID_VALUE, // input 125 (0x7D)\n    INVALID_VALUE, // input 126 (0x7E)\n    INVALID_VALUE, // input 127 (0x7F)\n    INVALID_VALUE, // input 128 (0x80)\n    INVALID_VALUE, // input 129 (0x81)\n    INVALID_VALUE, // input 130 (0x82)\n    INVALID_VALUE, // input 131 (0x83)\n    INVALID_VALUE, // input 132 (0x84)\n    INVALID_VALUE, // input 133 (0x85)\n    INVALID_VALUE, // input 134 (0x86)\n    INVALID_VALUE, // input 135 (0x87)\n    INVALID_VALUE, // input 136 (0x88)\n    INVALID_VALUE, // input 137 (0x89)\n    INVALID_VALUE, // input 138 (0x8A)\n    INVALID_VALUE, // input 139 (0x8B)\n    INVALID_VALUE, // input 140 (0x8C)\n    INVALID_VALUE, // input 141 (0x8D)\n    INVALID_VALUE, // input 142 (0x8E)\n    INVALID_VALUE, // input 143 (0x8F)\n    INVALID_VALUE, // input 144 (0x90)\n    INVALID_VALUE, // input 145 (0x91)\n    INVALID_VALUE, // input 146 (0x92)\n    INVALID_VALUE, // input 147 (0x93)\n    INVALID_VALUE, // input 148 (0x94)\n    INVALID_VALUE, // input 149 (0x95)\n    INVALID_VALUE, // input 150 (0x96)\n    INVALID_VALUE, // input 151 (0x97)\n    INVALID_VALUE, // input 152 (0x98)\n    INVALID_VALUE, // input 153 (0x99)\n    INVALID_VALUE, // input 154 (0x9A)\n    INVALID_VALUE, // input 155 (0x9B)\n    INVALID_VALUE, // input 156 (0x9C)\n    INVALID_VALUE, // input 157 (0x9D)\n    INVALID_VALUE, // input 158 (0x9E)\n    INVALID_VALUE, // input 159 (0x9F)\n    INVALID_VALUE, // input 160 (0xA0)\n    INVALID_VALUE, // input 161 (0xA1)\n    INVALID_VALUE, // input 162 (0xA2)\n    INVALID_VALUE, // input 163 (0xA3)\n    INVALID_VALUE, // input 164 (0xA4)\n    INVALID_VALUE, // input 165 (0xA5)\n    INVALID_VALUE, // input 166 (0xA6)\n    INVALID_VALUE, // input 167 (0xA7)\n    INVALID_VALUE, // input 168 (0xA8)\n    INVALID_VALUE, // input 169 (0xA9)\n    INVALID_VALUE, // input 170 (0xAA)\n    INVALID_VALUE, // input 171 (0xAB)\n    INVALID_VALUE, // input 172 (0xAC)\n    INVALID_VALUE, // input 173 (0xAD)\n    INVALID_VALUE, // input 174 (0xAE)\n    INVALID_VALUE, // input 175 (0xAF)\n    INVALID_VALUE, // input 176 (0xB0)\n    INVALID_VALUE, // input 177 (0xB1)\n    INVALID_VALUE, // input 178 (0xB2)\n    INVALID_VALUE, // input 179 (0xB3)\n    INVALID_VALUE, // input 180 (0xB4)\n    INVALID_VALUE, // input 181 (0xB5)\n    INVALID_VALUE, // input 182 (0xB6)\n    INVALID_VALUE, // input 183 (0xB7)\n    INVALID_VALUE, // input 184 (0xB8)\n    INVALID_VALUE, // input 185 (0xB9)\n    INVALID_VALUE, // input 186 (0xBA)\n    INVALID_VALUE, // input 187 (0xBB)\n    INVALID_VALUE, // input 188 (0xBC)\n    INVALID_VALUE, // input 189 (0xBD)\n    INVALID_VALUE, // input 190 (0xBE)\n    INVALID_VALUE, // input 191 (0xBF)\n    INVALID_VALUE, // input 192 (0xC0)\n    INVALID_VALUE, // input 193 (0xC1)\n    INVALID_VALUE, // input 194 (0xC2)\n    INVALID_VALUE, // input 195 (0xC3)\n    INVALID_VALUE, // input 196 (0xC4)\n    INVALID_VALUE, // input 197 (0xC5)\n    INVALID_VALUE, // input 198 (0xC6)\n    INVALID_VALUE, // input 199 (0xC7)\n    INVALID_VALUE, // input 200 (0xC8)\n    INVALID_VALUE, // input 201 (0xC9)\n    INVALID_VALUE, // input 202 (0xCA)\n    INVALID_VALUE, // input 203 (0xCB)\n    INVALID_VALUE, // input 204 (0xCC)\n    INVALID_VALUE, // input 205 (0xCD)\n    INVALID_VALUE, // input 206 (0xCE)\n    INVALID_VALUE, // input 207 (0xCF)\n    INVALID_VALUE, // input 208 (0xD0)\n    INVALID_VALUE, // input 209 (0xD1)\n    INVALID_VALUE, // input 210 (0xD2)\n    INVALID_VALUE, // input 211 (0xD3)\n    INVALID_VALUE, // input 212 (0xD4)\n    INVALID_VALUE, // input 213 (0xD5)\n    INVALID_VALUE, // input 214 (0xD6)\n    INVALID_VALUE, // input 215 (0xD7)\n    INVALID_VALUE, // input 216 (0xD8)\n    INVALID_VALUE, // input 217 (0xD9)\n    INVALID_VALUE, // input 218 (0xDA)\n    INVALID_VALUE, // input 219 (0xDB)\n    INVALID_VALUE, // input 220 (0xDC)\n    INVALID_VALUE, // input 221 (0xDD)\n    INVALID_VALUE, // input 222 (0xDE)\n    INVALID_VALUE, // input 223 (0xDF)\n    INVALID_VALUE, // input 224 (0xE0)\n    INVALID_VALUE, // input 225 (0xE1)\n    INVALID_VALUE, // input 226 (0xE2)\n    INVALID_VALUE, // input 227 (0xE3)\n    INVALID_VALUE, // input 228 (0xE4)\n    INVALID_VALUE, // input 229 (0xE5)\n    INVALID_VALUE, // input 230 (0xE6)\n    INVALID_VALUE, // input 231 (0xE7)\n    INVALID_VALUE, // input 232 (0xE8)\n    INVALID_VALUE, // input 233 (0xE9)\n    INVALID_VALUE, // input 234 (0xEA)\n    INVALID_VALUE, // input 235 (0xEB)\n    INVALID_VALUE, // input 236 (0xEC)\n    INVALID_VALUE, // input 237 (0xED)\n    INVALID_VALUE, // input 238 (0xEE)\n    INVALID_VALUE, // input 239 (0xEF)\n    INVALID_VALUE, // input 240 (0xF0)\n    INVALID_VALUE, // input 241 (0xF1)\n    INVALID_VALUE, // input 242 (0xF2)\n    INVALID_VALUE, // input 243 (0xF3)\n    INVALID_VALUE, // input 244 (0xF4)\n    INVALID_VALUE, // input 245 (0xF5)\n    INVALID_VALUE, // input 246 (0xF6)\n    INVALID_VALUE, // input 247 (0xF7)\n    INVALID_VALUE, // input 248 (0xF8)\n    INVALID_VALUE, // input 249 (0xF9)\n    INVALID_VALUE, // input 250 (0xFA)\n    INVALID_VALUE, // input 251 (0xFB)\n    INVALID_VALUE, // input 252 (0xFC)\n    INVALID_VALUE, // input 253 (0xFD)\n    INVALID_VALUE, // input 254 (0xFE)\n    INVALID_VALUE, // input 255 (0xFF)\n];\n#[rustfmt::skip]\npub const IMAP_MUTF7_ENCODE: &[u8; 64] = &[\n    65, // input 0 (0x0) => 'A' (0x41)\n    66, // input 1 (0x1) => 'B' (0x42)\n    67, // input 2 (0x2) => 'C' (0x43)\n    68, // input 3 (0x3) => 'D' (0x44)\n    69, // input 4 (0x4) => 'E' (0x45)\n    70, // input 5 (0x5) => 'F' (0x46)\n    71, // input 6 (0x6) => 'G' (0x47)\n    72, // input 7 (0x7) => 'H' (0x48)\n    73, // input 8 (0x8) => 'I' (0x49)\n    74, // input 9 (0x9) => 'J' (0x4A)\n    75, // input 10 (0xA) => 'K' (0x4B)\n    76, // input 11 (0xB) => 'L' (0x4C)\n    77, // input 12 (0xC) => 'M' (0x4D)\n    78, // input 13 (0xD) => 'N' (0x4E)\n    79, // input 14 (0xE) => 'O' (0x4F)\n    80, // input 15 (0xF) => 'P' (0x50)\n    81, // input 16 (0x10) => 'Q' (0x51)\n    82, // input 17 (0x11) => 'R' (0x52)\n    83, // input 18 (0x12) => 'S' (0x53)\n    84, // input 19 (0x13) => 'T' (0x54)\n    85, // input 20 (0x14) => 'U' (0x55)\n    86, // input 21 (0x15) => 'V' (0x56)\n    87, // input 22 (0x16) => 'W' (0x57)\n    88, // input 23 (0x17) => 'X' (0x58)\n    89, // input 24 (0x18) => 'Y' (0x59)\n    90, // input 25 (0x19) => 'Z' (0x5A)\n    97, // input 26 (0x1A) => 'a' (0x61)\n    98, // input 27 (0x1B) => 'b' (0x62)\n    99, // input 28 (0x1C) => 'c' (0x63)\n    100, // input 29 (0x1D) => 'd' (0x64)\n    101, // input 30 (0x1E) => 'e' (0x65)\n    102, // input 31 (0x1F) => 'f' (0x66)\n    103, // input 32 (0x20) => 'g' (0x67)\n    104, // input 33 (0x21) => 'h' (0x68)\n    105, // input 34 (0x22) => 'i' (0x69)\n    106, // input 35 (0x23) => 'j' (0x6A)\n    107, // input 36 (0x24) => 'k' (0x6B)\n    108, // input 37 (0x25) => 'l' (0x6C)\n    109, // input 38 (0x26) => 'm' (0x6D)\n    110, // input 39 (0x27) => 'n' (0x6E)\n    111, // input 40 (0x28) => 'o' (0x6F)\n    112, // input 41 (0x29) => 'p' (0x70)\n    113, // input 42 (0x2A) => 'q' (0x71)\n    114, // input 43 (0x2B) => 'r' (0x72)\n    115, // input 44 (0x2C) => 's' (0x73)\n    116, // input 45 (0x2D) => 't' (0x74)\n    117, // input 46 (0x2E) => 'u' (0x75)\n    118, // input 47 (0x2F) => 'v' (0x76)\n    119, // input 48 (0x30) => 'w' (0x77)\n    120, // input 49 (0x31) => 'x' (0x78)\n    121, // input 50 (0x32) => 'y' (0x79)\n    122, // input 51 (0x33) => 'z' (0x7A)\n    48, // input 52 (0x34) => '0' (0x30)\n    49, // input 53 (0x35) => '1' (0x31)\n    50, // input 54 (0x36) => '2' (0x32)\n    51, // input 55 (0x37) => '3' (0x33)\n    52, // input 56 (0x38) => '4' (0x34)\n    53, // input 57 (0x39) => '5' (0x35)\n    54, // input 58 (0x3A) => '6' (0x36)\n    55, // input 59 (0x3B) => '7' (0x37)\n    56, // input 60 (0x3C) => '8' (0x38)\n    57, // input 61 (0x3D) => '9' (0x39)\n    43, // input 62 (0x3E) => '+' (0x2B)\n    44, // input 63 (0x3F) => ',' (0x2C)\n];\n#[rustfmt::skip]\npub const IMAP_MUTF7_DECODE: &[u8; 256] = &[\n    INVALID_VALUE, // input 0 (0x0)\n    INVALID_VALUE, // input 1 (0x1)\n    INVALID_VALUE, // input 2 (0x2)\n    INVALID_VALUE, // input 3 (0x3)\n    INVALID_VALUE, // input 4 (0x4)\n    INVALID_VALUE, // input 5 (0x5)\n    INVALID_VALUE, // input 6 (0x6)\n    INVALID_VALUE, // input 7 (0x7)\n    INVALID_VALUE, // input 8 (0x8)\n    INVALID_VALUE, // input 9 (0x9)\n    INVALID_VALUE, // input 10 (0xA)\n    INVALID_VALUE, // input 11 (0xB)\n    INVALID_VALUE, // input 12 (0xC)\n    INVALID_VALUE, // input 13 (0xD)\n    INVALID_VALUE, // input 14 (0xE)\n    INVALID_VALUE, // input 15 (0xF)\n    INVALID_VALUE, // input 16 (0x10)\n    INVALID_VALUE, // input 17 (0x11)\n    INVALID_VALUE, // input 18 (0x12)\n    INVALID_VALUE, // input 19 (0x13)\n    INVALID_VALUE, // input 20 (0x14)\n    INVALID_VALUE, // input 21 (0x15)\n    INVALID_VALUE, // input 22 (0x16)\n    INVALID_VALUE, // input 23 (0x17)\n    INVALID_VALUE, // input 24 (0x18)\n    INVALID_VALUE, // input 25 (0x19)\n    INVALID_VALUE, // input 26 (0x1A)\n    INVALID_VALUE, // input 27 (0x1B)\n    INVALID_VALUE, // input 28 (0x1C)\n    INVALID_VALUE, // input 29 (0x1D)\n    INVALID_VALUE, // input 30 (0x1E)\n    INVALID_VALUE, // input 31 (0x1F)\n    INVALID_VALUE, // input 32 (0x20)\n    INVALID_VALUE, // input 33 (0x21)\n    INVALID_VALUE, // input 34 (0x22)\n    INVALID_VALUE, // input 35 (0x23)\n    INVALID_VALUE, // input 36 (0x24)\n    INVALID_VALUE, // input 37 (0x25)\n    INVALID_VALUE, // input 38 (0x26)\n    INVALID_VALUE, // input 39 (0x27)\n    INVALID_VALUE, // input 40 (0x28)\n    INVALID_VALUE, // input 41 (0x29)\n    INVALID_VALUE, // input 42 (0x2A)\n    62, // input 43 (0x2B char '+') => 62 (0x3E)\n    63, // input 44 (0x2C char ',') => 63 (0x3F)\n    INVALID_VALUE, // input 45 (0x2D)\n    INVALID_VALUE, // input 46 (0x2E)\n    INVALID_VALUE, // input 47 (0x2F)\n    52, // input 48 (0x30 char '0') => 52 (0x34)\n    53, // input 49 (0x31 char '1') => 53 (0x35)\n    54, // input 50 (0x32 char '2') => 54 (0x36)\n    55, // input 51 (0x33 char '3') => 55 (0x37)\n    56, // input 52 (0x34 char '4') => 56 (0x38)\n    57, // input 53 (0x35 char '5') => 57 (0x39)\n    58, // input 54 (0x36 char '6') => 58 (0x3A)\n    59, // input 55 (0x37 char '7') => 59 (0x3B)\n    60, // input 56 (0x38 char '8') => 60 (0x3C)\n    61, // input 57 (0x39 char '9') => 61 (0x3D)\n    INVALID_VALUE, // input 58 (0x3A)\n    INVALID_VALUE, // input 59 (0x3B)\n    INVALID_VALUE, // input 60 (0x3C)\n    INVALID_VALUE, // input 61 (0x3D)\n    INVALID_VALUE, // input 62 (0x3E)\n    INVALID_VALUE, // input 63 (0x3F)\n    INVALID_VALUE, // input 64 (0x40)\n    0, // input 65 (0x41 char 'A') => 0 (0x0)\n    1, // input 66 (0x42 char 'B') => 1 (0x1)\n    2, // input 67 (0x43 char 'C') => 2 (0x2)\n    3, // input 68 (0x44 char 'D') => 3 (0x3)\n    4, // input 69 (0x45 char 'E') => 4 (0x4)\n    5, // input 70 (0x46 char 'F') => 5 (0x5)\n    6, // input 71 (0x47 char 'G') => 6 (0x6)\n    7, // input 72 (0x48 char 'H') => 7 (0x7)\n    8, // input 73 (0x49 char 'I') => 8 (0x8)\n    9, // input 74 (0x4A char 'J') => 9 (0x9)\n    10, // input 75 (0x4B char 'K') => 10 (0xA)\n    11, // input 76 (0x4C char 'L') => 11 (0xB)\n    12, // input 77 (0x4D char 'M') => 12 (0xC)\n    13, // input 78 (0x4E char 'N') => 13 (0xD)\n    14, // input 79 (0x4F char 'O') => 14 (0xE)\n    15, // input 80 (0x50 char 'P') => 15 (0xF)\n    16, // input 81 (0x51 char 'Q') => 16 (0x10)\n    17, // input 82 (0x52 char 'R') => 17 (0x11)\n    18, // input 83 (0x53 char 'S') => 18 (0x12)\n    19, // input 84 (0x54 char 'T') => 19 (0x13)\n    20, // input 85 (0x55 char 'U') => 20 (0x14)\n    21, // input 86 (0x56 char 'V') => 21 (0x15)\n    22, // input 87 (0x57 char 'W') => 22 (0x16)\n    23, // input 88 (0x58 char 'X') => 23 (0x17)\n    24, // input 89 (0x59 char 'Y') => 24 (0x18)\n    25, // input 90 (0x5A char 'Z') => 25 (0x19)\n    INVALID_VALUE, // input 91 (0x5B)\n    INVALID_VALUE, // input 92 (0x5C)\n    INVALID_VALUE, // input 93 (0x5D)\n    INVALID_VALUE, // input 94 (0x5E)\n    INVALID_VALUE, // input 95 (0x5F)\n    INVALID_VALUE, // input 96 (0x60)\n    26, // input 97 (0x61 char 'a') => 26 (0x1A)\n    27, // input 98 (0x62 char 'b') => 27 (0x1B)\n    28, // input 99 (0x63 char 'c') => 28 (0x1C)\n    29, // input 100 (0x64 char 'd') => 29 (0x1D)\n    30, // input 101 (0x65 char 'e') => 30 (0x1E)\n    31, // input 102 (0x66 char 'f') => 31 (0x1F)\n    32, // input 103 (0x67 char 'g') => 32 (0x20)\n    33, // input 104 (0x68 char 'h') => 33 (0x21)\n    34, // input 105 (0x69 char 'i') => 34 (0x22)\n    35, // input 106 (0x6A char 'j') => 35 (0x23)\n    36, // input 107 (0x6B char 'k') => 36 (0x24)\n    37, // input 108 (0x6C char 'l') => 37 (0x25)\n    38, // input 109 (0x6D char 'm') => 38 (0x26)\n    39, // input 110 (0x6E char 'n') => 39 (0x27)\n    40, // input 111 (0x6F char 'o') => 40 (0x28)\n    41, // input 112 (0x70 char 'p') => 41 (0x29)\n    42, // input 113 (0x71 char 'q') => 42 (0x2A)\n    43, // input 114 (0x72 char 'r') => 43 (0x2B)\n    44, // input 115 (0x73 char 's') => 44 (0x2C)\n    45, // input 116 (0x74 char 't') => 45 (0x2D)\n    46, // input 117 (0x75 char 'u') => 46 (0x2E)\n    47, // input 118 (0x76 char 'v') => 47 (0x2F)\n    48, // input 119 (0x77 char 'w') => 48 (0x30)\n    49, // input 120 (0x78 char 'x') => 49 (0x31)\n    50, // input 121 (0x79 char 'y') => 50 (0x32)\n    51, // input 122 (0x7A char 'z') => 51 (0x33)\n    INVALID_VALUE, // input 123 (0x7B)\n    INVALID_VALUE, // input 124 (0x7C)\n    INVALID_VALUE, // input 125 (0x7D)\n    INVALID_VALUE, // input 126 (0x7E)\n    INVALID_VALUE, // input 127 (0x7F)\n    INVALID_VALUE, // input 128 (0x80)\n    INVALID_VALUE, // input 129 (0x81)\n    INVALID_VALUE, // input 130 (0x82)\n    INVALID_VALUE, // input 131 (0x83)\n    INVALID_VALUE, // input 132 (0x84)\n    INVALID_VALUE, // input 133 (0x85)\n    INVALID_VALUE, // input 134 (0x86)\n    INVALID_VALUE, // input 135 (0x87)\n    INVALID_VALUE, // input 136 (0x88)\n    INVALID_VALUE, // input 137 (0x89)\n    INVALID_VALUE, // input 138 (0x8A)\n    INVALID_VALUE, // input 139 (0x8B)\n    INVALID_VALUE, // input 140 (0x8C)\n    INVALID_VALUE, // input 141 (0x8D)\n    INVALID_VALUE, // input 142 (0x8E)\n    INVALID_VALUE, // input 143 (0x8F)\n    INVALID_VALUE, // input 144 (0x90)\n    INVALID_VALUE, // input 145 (0x91)\n    INVALID_VALUE, // input 146 (0x92)\n    INVALID_VALUE, // input 147 (0x93)\n    INVALID_VALUE, // input 148 (0x94)\n    INVALID_VALUE, // input 149 (0x95)\n    INVALID_VALUE, // input 150 (0x96)\n    INVALID_VALUE, // input 151 (0x97)\n    INVALID_VALUE, // input 152 (0x98)\n    INVALID_VALUE, // input 153 (0x99)\n    INVALID_VALUE, // input 154 (0x9A)\n    INVALID_VALUE, // input 155 (0x9B)\n    INVALID_VALUE, // input 156 (0x9C)\n    INVALID_VALUE, // input 157 (0x9D)\n    INVALID_VALUE, // input 158 (0x9E)\n    INVALID_VALUE, // input 159 (0x9F)\n    INVALID_VALUE, // input 160 (0xA0)\n    INVALID_VALUE, // input 161 (0xA1)\n    INVALID_VALUE, // input 162 (0xA2)\n    INVALID_VALUE, // input 163 (0xA3)\n    INVALID_VALUE, // input 164 (0xA4)\n    INVALID_VALUE, // input 165 (0xA5)\n    INVALID_VALUE, // input 166 (0xA6)\n    INVALID_VALUE, // input 167 (0xA7)\n    INVALID_VALUE, // input 168 (0xA8)\n    INVALID_VALUE, // input 169 (0xA9)\n    INVALID_VALUE, // input 170 (0xAA)\n    INVALID_VALUE, // input 171 (0xAB)\n    INVALID_VALUE, // input 172 (0xAC)\n    INVALID_VALUE, // input 173 (0xAD)\n    INVALID_VALUE, // input 174 (0xAE)\n    INVALID_VALUE, // input 175 (0xAF)\n    INVALID_VALUE, // input 176 (0xB0)\n    INVALID_VALUE, // input 177 (0xB1)\n    INVALID_VALUE, // input 178 (0xB2)\n    INVALID_VALUE, // input 179 (0xB3)\n    INVALID_VALUE, // input 180 (0xB4)\n    INVALID_VALUE, // input 181 (0xB5)\n    INVALID_VALUE, // input 182 (0xB6)\n    INVALID_VALUE, // input 183 (0xB7)\n    INVALID_VALUE, // input 184 (0xB8)\n    INVALID_VALUE, // input 185 (0xB9)\n    INVALID_VALUE, // input 186 (0xBA)\n    INVALID_VALUE, // input 187 (0xBB)\n    INVALID_VALUE, // input 188 (0xBC)\n    INVALID_VALUE, // input 189 (0xBD)\n    INVALID_VALUE, // input 190 (0xBE)\n    INVALID_VALUE, // input 191 (0xBF)\n    INVALID_VALUE, // input 192 (0xC0)\n    INVALID_VALUE, // input 193 (0xC1)\n    INVALID_VALUE, // input 194 (0xC2)\n    INVALID_VALUE, // input 195 (0xC3)\n    INVALID_VALUE, // input 196 (0xC4)\n    INVALID_VALUE, // input 197 (0xC5)\n    INVALID_VALUE, // input 198 (0xC6)\n    INVALID_VALUE, // input 199 (0xC7)\n    INVALID_VALUE, // input 200 (0xC8)\n    INVALID_VALUE, // input 201 (0xC9)\n    INVALID_VALUE, // input 202 (0xCA)\n    INVALID_VALUE, // input 203 (0xCB)\n    INVALID_VALUE, // input 204 (0xCC)\n    INVALID_VALUE, // input 205 (0xCD)\n    INVALID_VALUE, // input 206 (0xCE)\n    INVALID_VALUE, // input 207 (0xCF)\n    INVALID_VALUE, // input 208 (0xD0)\n    INVALID_VALUE, // input 209 (0xD1)\n    INVALID_VALUE, // input 210 (0xD2)\n    INVALID_VALUE, // input 211 (0xD3)\n    INVALID_VALUE, // input 212 (0xD4)\n    INVALID_VALUE, // input 213 (0xD5)\n    INVALID_VALUE, // input 214 (0xD6)\n    INVALID_VALUE, // input 215 (0xD7)\n    INVALID_VALUE, // input 216 (0xD8)\n    INVALID_VALUE, // input 217 (0xD9)\n    INVALID_VALUE, // input 218 (0xDA)\n    INVALID_VALUE, // input 219 (0xDB)\n    INVALID_VALUE, // input 220 (0xDC)\n    INVALID_VALUE, // input 221 (0xDD)\n    INVALID_VALUE, // input 222 (0xDE)\n    INVALID_VALUE, // input 223 (0xDF)\n    INVALID_VALUE, // input 224 (0xE0)\n    INVALID_VALUE, // input 225 (0xE1)\n    INVALID_VALUE, // input 226 (0xE2)\n    INVALID_VALUE, // input 227 (0xE3)\n    INVALID_VALUE, // input 228 (0xE4)\n    INVALID_VALUE, // input 229 (0xE5)\n    INVALID_VALUE, // input 230 (0xE6)\n    INVALID_VALUE, // input 231 (0xE7)\n    INVALID_VALUE, // input 232 (0xE8)\n    INVALID_VALUE, // input 233 (0xE9)\n    INVALID_VALUE, // input 234 (0xEA)\n    INVALID_VALUE, // input 235 (0xEB)\n    INVALID_VALUE, // input 236 (0xEC)\n    INVALID_VALUE, // input 237 (0xED)\n    INVALID_VALUE, // input 238 (0xEE)\n    INVALID_VALUE, // input 239 (0xEF)\n    INVALID_VALUE, // input 240 (0xF0)\n    INVALID_VALUE, // input 241 (0xF1)\n    INVALID_VALUE, // input 242 (0xF2)\n    INVALID_VALUE, // input 243 (0xF3)\n    INVALID_VALUE, // input 244 (0xF4)\n    INVALID_VALUE, // input 245 (0xF5)\n    INVALID_VALUE, // input 246 (0xF6)\n    INVALID_VALUE, // input 247 (0xF7)\n    INVALID_VALUE, // input 248 (0xF8)\n    INVALID_VALUE, // input 249 (0xF9)\n    INVALID_VALUE, // input 250 (0xFA)\n    INVALID_VALUE, // input 251 (0xFB)\n    INVALID_VALUE, // input 252 (0xFC)\n    INVALID_VALUE, // input 253 (0xFD)\n    INVALID_VALUE, // input 254 (0xFE)\n    INVALID_VALUE, // input 255 (0xFF)\n];\n#[rustfmt::skip]\npub const BINHEX_ENCODE: &[u8; 64] = &[\n    33, // input 0 (0x0) => '!' (0x21)\n    34, // input 1 (0x1) => '\"' (0x22)\n    35, // input 2 (0x2) => '#' (0x23)\n    36, // input 3 (0x3) => '$' (0x24)\n    37, // input 4 (0x4) => '%' (0x25)\n    38, // input 5 (0x5) => '&' (0x26)\n    39, // input 6 (0x6) => ''' (0x27)\n    40, // input 7 (0x7) => '(' (0x28)\n    41, // input 8 (0x8) => ')' (0x29)\n    42, // input 9 (0x9) => '*' (0x2A)\n    43, // input 10 (0xA) => '+' (0x2B)\n    44, // input 11 (0xB) => ',' (0x2C)\n    45, // input 12 (0xC) => '-' (0x2D)\n    48, // input 13 (0xD) => '0' (0x30)\n    49, // input 14 (0xE) => '1' (0x31)\n    50, // input 15 (0xF) => '2' (0x32)\n    51, // input 16 (0x10) => '3' (0x33)\n    52, // input 17 (0x11) => '4' (0x34)\n    53, // input 18 (0x12) => '5' (0x35)\n    54, // input 19 (0x13) => '6' (0x36)\n    55, // input 20 (0x14) => '7' (0x37)\n    56, // input 21 (0x15) => '8' (0x38)\n    57, // input 22 (0x16) => '9' (0x39)\n    64, // input 23 (0x17) => '@' (0x40)\n    65, // input 24 (0x18) => 'A' (0x41)\n    66, // input 25 (0x19) => 'B' (0x42)\n    67, // input 26 (0x1A) => 'C' (0x43)\n    68, // input 27 (0x1B) => 'D' (0x44)\n    69, // input 28 (0x1C) => 'E' (0x45)\n    70, // input 29 (0x1D) => 'F' (0x46)\n    71, // input 30 (0x1E) => 'G' (0x47)\n    72, // input 31 (0x1F) => 'H' (0x48)\n    73, // input 32 (0x20) => 'I' (0x49)\n    74, // input 33 (0x21) => 'J' (0x4A)\n    75, // input 34 (0x22) => 'K' (0x4B)\n    76, // input 35 (0x23) => 'L' (0x4C)\n    77, // input 36 (0x24) => 'M' (0x4D)\n    78, // input 37 (0x25) => 'N' (0x4E)\n    80, // input 38 (0x26) => 'P' (0x50)\n    81, // input 39 (0x27) => 'Q' (0x51)\n    82, // input 40 (0x28) => 'R' (0x52)\n    83, // input 41 (0x29) => 'S' (0x53)\n    84, // input 42 (0x2A) => 'T' (0x54)\n    85, // input 43 (0x2B) => 'U' (0x55)\n    86, // input 44 (0x2C) => 'V' (0x56)\n    88, // input 45 (0x2D) => 'X' (0x58)\n    89, // input 46 (0x2E) => 'Y' (0x59)\n    90, // input 47 (0x2F) => 'Z' (0x5A)\n    91, // input 48 (0x30) => '[' (0x5B)\n    96, // input 49 (0x31) => '`' (0x60)\n    97, // input 50 (0x32) => 'a' (0x61)\n    98, // input 51 (0x33) => 'b' (0x62)\n    99, // input 52 (0x34) => 'c' (0x63)\n    100, // input 53 (0x35) => 'd' (0x64)\n    101, // input 54 (0x36) => 'e' (0x65)\n    104, // input 55 (0x37) => 'h' (0x68)\n    105, // input 56 (0x38) => 'i' (0x69)\n    106, // input 57 (0x39) => 'j' (0x6A)\n    107, // input 58 (0x3A) => 'k' (0x6B)\n    108, // input 59 (0x3B) => 'l' (0x6C)\n    109, // input 60 (0x3C) => 'm' (0x6D)\n    112, // input 61 (0x3D) => 'p' (0x70)\n    113, // input 62 (0x3E) => 'q' (0x71)\n    114, // input 63 (0x3F) => 'r' (0x72)\n];\n#[rustfmt::skip]\npub const BINHEX_DECODE: &[u8; 256] = &[\n    INVALID_VALUE, // input 0 (0x0)\n    INVALID_VALUE, // input 1 (0x1)\n    INVALID_VALUE, // input 2 (0x2)\n    INVALID_VALUE, // input 3 (0x3)\n    INVALID_VALUE, // input 4 (0x4)\n    INVALID_VALUE, // input 5 (0x5)\n    INVALID_VALUE, // input 6 (0x6)\n    INVALID_VALUE, // input 7 (0x7)\n    INVALID_VALUE, // input 8 (0x8)\n    INVALID_VALUE, // input 9 (0x9)\n    INVALID_VALUE, // input 10 (0xA)\n    INVALID_VALUE, // input 11 (0xB)\n    INVALID_VALUE, // input 12 (0xC)\n    INVALID_VALUE, // input 13 (0xD)\n    INVALID_VALUE, // input 14 (0xE)\n    INVALID_VALUE, // input 15 (0xF)\n    INVALID_VALUE, // input 16 (0x10)\n    INVALID_VALUE, // input 17 (0x11)\n    INVALID_VALUE, // input 18 (0x12)\n    INVALID_VALUE, // input 19 (0x13)\n    INVALID_VALUE, // input 20 (0x14)\n    INVALID_VALUE, // input 21 (0x15)\n    INVALID_VALUE, // input 22 (0x16)\n    INVALID_VALUE, // input 23 (0x17)\n    INVALID_VALUE, // input 24 (0x18)\n    INVALID_VALUE, // input 25 (0x19)\n    INVALID_VALUE, // input 26 (0x1A)\n    INVALID_VALUE, // input 27 (0x1B)\n    INVALID_VALUE, // input 28 (0x1C)\n    INVALID_VALUE, // input 29 (0x1D)\n    INVALID_VALUE, // input 30 (0x1E)\n    INVALID_VALUE, // input 31 (0x1F)\n    INVALID_VALUE, // input 32 (0x20)\n    0, // input 33 (0x21 char '!') => 0 (0x0)\n    1, // input 34 (0x22 char '\"') => 1 (0x1)\n    2, // input 35 (0x23 char '#') => 2 (0x2)\n    3, // input 36 (0x24 char '$') => 3 (0x3)\n    4, // input 37 (0x25 char '%') => 4 (0x4)\n    5, // input 38 (0x26 char '&') => 5 (0x5)\n    6, // input 39 (0x27 char ''') => 6 (0x6)\n    7, // input 40 (0x28 char '(') => 7 (0x7)\n    8, // input 41 (0x29 char ')') => 8 (0x8)\n    9, // input 42 (0x2A char '*') => 9 (0x9)\n    10, // input 43 (0x2B char '+') => 10 (0xA)\n    11, // input 44 (0x2C char ',') => 11 (0xB)\n    12, // input 45 (0x2D char '-') => 12 (0xC)\n    INVALID_VALUE, // input 46 (0x2E)\n    INVALID_VALUE, // input 47 (0x2F)\n    13, // input 48 (0x30 char '0') => 13 (0xD)\n    14, // input 49 (0x31 char '1') => 14 (0xE)\n    15, // input 50 (0x32 char '2') => 15 (0xF)\n    16, // input 51 (0x33 char '3') => 16 (0x10)\n    17, // input 52 (0x34 char '4') => 17 (0x11)\n    18, // input 53 (0x35 char '5') => 18 (0x12)\n    19, // input 54 (0x36 char '6') => 19 (0x13)\n    20, // input 55 (0x37 char '7') => 20 (0x14)\n    21, // input 56 (0x38 char '8') => 21 (0x15)\n    22, // input 57 (0x39 char '9') => 22 (0x16)\n    INVALID_VALUE, // input 58 (0x3A)\n    INVALID_VALUE, // input 59 (0x3B)\n    INVALID_VALUE, // input 60 (0x3C)\n    INVALID_VALUE, // input 61 (0x3D)\n    INVALID_VALUE, // input 62 (0x3E)\n    INVALID_VALUE, // input 63 (0x3F)\n    23, // input 64 (0x40 char '@') => 23 (0x17)\n    24, // input 65 (0x41 char 'A') => 24 (0x18)\n    25, // input 66 (0x42 char 'B') => 25 (0x19)\n    26, // input 67 (0x43 char 'C') => 26 (0x1A)\n    27, // input 68 (0x44 char 'D') => 27 (0x1B)\n    28, // input 69 (0x45 char 'E') => 28 (0x1C)\n    29, // input 70 (0x46 char 'F') => 29 (0x1D)\n    30, // input 71 (0x47 char 'G') => 30 (0x1E)\n    31, // input 72 (0x48 char 'H') => 31 (0x1F)\n    32, // input 73 (0x49 char 'I') => 32 (0x20)\n    33, // input 74 (0x4A char 'J') => 33 (0x21)\n    34, // input 75 (0x4B char 'K') => 34 (0x22)\n    35, // input 76 (0x4C char 'L') => 35 (0x23)\n    36, // input 77 (0x4D char 'M') => 36 (0x24)\n    37, // input 78 (0x4E char 'N') => 37 (0x25)\n    INVALID_VALUE, // input 79 (0x4F)\n    38, // input 80 (0x50 char 'P') => 38 (0x26)\n    39, // input 81 (0x51 char 'Q') => 39 (0x27)\n    40, // input 82 (0x52 char 'R') => 40 (0x28)\n    41, // input 83 (0x53 char 'S') => 41 (0x29)\n    42, // input 84 (0x54 char 'T') => 42 (0x2A)\n    43, // input 85 (0x55 char 'U') => 43 (0x2B)\n    44, // input 86 (0x56 char 'V') => 44 (0x2C)\n    INVALID_VALUE, // input 87 (0x57)\n    45, // input 88 (0x58 char 'X') => 45 (0x2D)\n    46, // input 89 (0x59 char 'Y') => 46 (0x2E)\n    47, // input 90 (0x5A char 'Z') => 47 (0x2F)\n    48, // input 91 (0x5B char '[') => 48 (0x30)\n    INVALID_VALUE, // input 92 (0x5C)\n    INVALID_VALUE, // input 93 (0x5D)\n    INVALID_VALUE, // input 94 (0x5E)\n    INVALID_VALUE, // input 95 (0x5F)\n    49, // input 96 (0x60 char '`') => 49 (0x31)\n    50, // input 97 (0x61 char 'a') => 50 (0x32)\n    51, // input 98 (0x62 char 'b') => 51 (0x33)\n    52, // input 99 (0x63 char 'c') => 52 (0x34)\n    53, // input 100 (0x64 char 'd') => 53 (0x35)\n    54, // input 101 (0x65 char 'e') => 54 (0x36)\n    INVALID_VALUE, // input 102 (0x66)\n    INVALID_VALUE, // input 103 (0x67)\n    55, // input 104 (0x68 char 'h') => 55 (0x37)\n    56, // input 105 (0x69 char 'i') => 56 (0x38)\n    57, // input 106 (0x6A char 'j') => 57 (0x39)\n    58, // input 107 (0x6B char 'k') => 58 (0x3A)\n    59, // input 108 (0x6C char 'l') => 59 (0x3B)\n    60, // input 109 (0x6D char 'm') => 60 (0x3C)\n    INVALID_VALUE, // input 110 (0x6E)\n    INVALID_VALUE, // input 111 (0x6F)\n    61, // input 112 (0x70 char 'p') => 61 (0x3D)\n    62, // input 113 (0x71 char 'q') => 62 (0x3E)\n    63, // input 114 (0x72 char 'r') => 63 (0x3F)\n    INVALID_VALUE, // input 115 (0x73)\n    INVALID_VALUE, // input 116 (0x74)\n    INVALID_VALUE, // input 117 (0x75)\n    INVALID_VALUE, // input 118 (0x76)\n    INVALID_VALUE, // input 119 (0x77)\n    INVALID_VALUE, // input 120 (0x78)\n    INVALID_VALUE, // input 121 (0x79)\n    INVALID_VALUE, // input 122 (0x7A)\n    INVALID_VALUE, // input 123 (0x7B)\n    INVALID_VALUE, // input 124 (0x7C)\n    INVALID_VALUE, // input 125 (0x7D)\n    INVALID_VALUE, // input 126 (0x7E)\n    INVALID_VALUE, // input 127 (0x7F)\n    INVALID_VALUE, // input 128 (0x80)\n    INVALID_VALUE, // input 129 (0x81)\n    INVALID_VALUE, // input 130 (0x82)\n    INVALID_VALUE, // input 131 (0x83)\n    INVALID_VALUE, // input 132 (0x84)\n    INVALID_VALUE, // input 133 (0x85)\n    INVALID_VALUE, // input 134 (0x86)\n    INVALID_VALUE, // input 135 (0x87)\n    INVALID_VALUE, // input 136 (0x88)\n    INVALID_VALUE, // input 137 (0x89)\n    INVALID_VALUE, // input 138 (0x8A)\n    INVALID_VALUE, // input 139 (0x8B)\n    INVALID_VALUE, // input 140 (0x8C)\n    INVALID_VALUE, // input 141 (0x8D)\n    INVALID_VALUE, // input 142 (0x8E)\n    INVALID_VALUE, // input 143 (0x8F)\n    INVALID_VALUE, // input 144 (0x90)\n    INVALID_VALUE, // input 145 (0x91)\n    INVALID_VALUE, // input 146 (0x92)\n    INVALID_VALUE, // input 147 (0x93)\n    INVALID_VALUE, // input 148 (0x94)\n    INVALID_VALUE, // input 149 (0x95)\n    INVALID_VALUE, // input 150 (0x96)\n    INVALID_VALUE, // input 151 (0x97)\n    INVALID_VALUE, // input 152 (0x98)\n    INVALID_VALUE, // input 153 (0x99)\n    INVALID_VALUE, // input 154 (0x9A)\n    INVALID_VALUE, // input 155 (0x9B)\n    INVALID_VALUE, // input 156 (0x9C)\n    INVALID_VALUE, // input 157 (0x9D)\n    INVALID_VALUE, // input 158 (0x9E)\n    INVALID_VALUE, // input 159 (0x9F)\n    INVALID_VALUE, // input 160 (0xA0)\n    INVALID_VALUE, // input 161 (0xA1)\n    INVALID_VALUE, // input 162 (0xA2)\n    INVALID_VALUE, // input 163 (0xA3)\n    INVALID_VALUE, // input 164 (0xA4)\n    INVALID_VALUE, // input 165 (0xA5)\n    INVALID_VALUE, // input 166 (0xA6)\n    INVALID_VALUE, // input 167 (0xA7)\n    INVALID_VALUE, // input 168 (0xA8)\n    INVALID_VALUE, // input 169 (0xA9)\n    INVALID_VALUE, // input 170 (0xAA)\n    INVALID_VALUE, // input 171 (0xAB)\n    INVALID_VALUE, // input 172 (0xAC)\n    INVALID_VALUE, // input 173 (0xAD)\n    INVALID_VALUE, // input 174 (0xAE)\n    INVALID_VALUE, // input 175 (0xAF)\n    INVALID_VALUE, // input 176 (0xB0)\n    INVALID_VALUE, // input 177 (0xB1)\n    INVALID_VALUE, // input 178 (0xB2)\n    INVALID_VALUE, // input 179 (0xB3)\n    INVALID_VALUE, // input 180 (0xB4)\n    INVALID_VALUE, // input 181 (0xB5)\n    INVALID_VALUE, // input 182 (0xB6)\n    INVALID_VALUE, // input 183 (0xB7)\n    INVALID_VALUE, // input 184 (0xB8)\n    INVALID_VALUE, // input 185 (0xB9)\n    INVALID_VALUE, // input 186 (0xBA)\n    INVALID_VALUE, // input 187 (0xBB)\n    INVALID_VALUE, // input 188 (0xBC)\n    INVALID_VALUE, // input 189 (0xBD)\n    INVALID_VALUE, // input 190 (0xBE)\n    INVALID_VALUE, // input 191 (0xBF)\n    INVALID_VALUE, // input 192 (0xC0)\n    INVALID_VALUE, // input 193 (0xC1)\n    INVALID_VALUE, // input 194 (0xC2)\n    INVALID_VALUE, // input 195 (0xC3)\n    INVALID_VALUE, // input 196 (0xC4)\n    INVALID_VALUE, // input 197 (0xC5)\n    INVALID_VALUE, // input 198 (0xC6)\n    INVALID_VALUE, // input 199 (0xC7)\n    INVALID_VALUE, // input 200 (0xC8)\n    INVALID_VALUE, // input 201 (0xC9)\n    INVALID_VALUE, // input 202 (0xCA)\n    INVALID_VALUE, // input 203 (0xCB)\n    INVALID_VALUE, // input 204 (0xCC)\n    INVALID_VALUE, // input 205 (0xCD)\n    INVALID_VALUE, // input 206 (0xCE)\n    INVALID_VALUE, // input 207 (0xCF)\n    INVALID_VALUE, // input 208 (0xD0)\n    INVALID_VALUE, // input 209 (0xD1)\n    INVALID_VALUE, // input 210 (0xD2)\n    INVALID_VALUE, // input 211 (0xD3)\n    INVALID_VALUE, // input 212 (0xD4)\n    INVALID_VALUE, // input 213 (0xD5)\n    INVALID_VALUE, // input 214 (0xD6)\n    INVALID_VALUE, // input 215 (0xD7)\n    INVALID_VALUE, // input 216 (0xD8)\n    INVALID_VALUE, // input 217 (0xD9)\n    INVALID_VALUE, // input 218 (0xDA)\n    INVALID_VALUE, // input 219 (0xDB)\n    INVALID_VALUE, // input 220 (0xDC)\n    INVALID_VALUE, // input 221 (0xDD)\n    INVALID_VALUE, // input 222 (0xDE)\n    INVALID_VALUE, // input 223 (0xDF)\n    INVALID_VALUE, // input 224 (0xE0)\n    INVALID_VALUE, // input 225 (0xE1)\n    INVALID_VALUE, // input 226 (0xE2)\n    INVALID_VALUE, // input 227 (0xE3)\n    INVALID_VALUE, // input 228 (0xE4)\n    INVALID_VALUE, // input 229 (0xE5)\n    INVALID_VALUE, // input 230 (0xE6)\n    INVALID_VALUE, // input 231 (0xE7)\n    INVALID_VALUE, // input 232 (0xE8)\n    INVALID_VALUE, // input 233 (0xE9)\n    INVALID_VALUE, // input 234 (0xEA)\n    INVALID_VALUE, // input 235 (0xEB)\n    INVALID_VALUE, // input 236 (0xEC)\n    INVALID_VALUE, // input 237 (0xED)\n    INVALID_VALUE, // input 238 (0xEE)\n    INVALID_VALUE, // input 239 (0xEF)\n    INVALID_VALUE, // input 240 (0xF0)\n    INVALID_VALUE, // input 241 (0xF1)\n    INVALID_VALUE, // input 242 (0xF2)\n    INVALID_VALUE, // input 243 (0xF3)\n    INVALID_VALUE, // input 244 (0xF4)\n    INVALID_VALUE, // input 245 (0xF5)\n    INVALID_VALUE, // input 246 (0xF6)\n    INVALID_VALUE, // input 247 (0xF7)\n    INVALID_VALUE, // input 248 (0xF8)\n    INVALID_VALUE, // input 249 (0xF9)\n    INVALID_VALUE, // input 250 (0xFA)\n    INVALID_VALUE, // input 251 (0xFB)\n    INVALID_VALUE, // input 252 (0xFC)\n    INVALID_VALUE, // input 253 (0xFD)\n    INVALID_VALUE, // input 254 (0xFE)\n    INVALID_VALUE, // input 255 (0xFF)\n];\n\n#[test]\nfn alignment_check() {\n    let p: *const u8 = STANDARD_DECODE_HOLDER.data.as_ptr();\n    assert_eq!((p as u64) % 64, 0);\n    let p: *const u8 = URL_SAFE_DECODE_HOLDER.data.as_ptr();\n    assert_eq!((p as u64) % 64, 0);\n    let p: *const u8 = CRYPT_DECODE_HOLDER.data.as_ptr();\n    assert_eq!((p as u64) % 64, 0);\n    let p: *const u8 = BCRYPT_DECODE_HOLDER.data.as_ptr();\n    assert_eq!((p as u64) % 64, 0);\n    let p: *const u8 = IMAP_MUTF7_DECODE_HOLDER.data.as_ptr();\n    assert_eq!((p as u64) % 64, 0);\n    let p: *const u8 = BINHEX_DECODE_HOLDER.data.as_ptr();\n    assert_eq!((p as u64) % 64, 0);\n}\n"], "filenames": ["Cargo.toml", "src/decode.rs", "src/lib.rs", "src/tables.rs"], "buggy_code_start_loc": [27, 446, 141, 0], "buggy_code_end_loc": [27, 526, 147, 1957], "fixing_code_start_loc": [28, 447, 141, 1], "fixing_code_end_loc": [29, 563, 147, 2006], "type": "CWE-203", "message": "In Apache Teaclave Rust SGX SDK 1.1.3, a side-channel vulnerability in base64 PEM file decoding allows system-level (administrator) attackers to obtain information about secret RSA keys via a controlled-channel and side-channel attack on software running in isolated environments that can be single stepped, especially Intel SGX.", "other": {"cve": {"id": "CVE-2021-24117", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-14T14:15:08.810", "lastModified": "2022-05-13T17:36:58.683", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Apache Teaclave Rust SGX SDK 1.1.3, a side-channel vulnerability in base64 PEM file decoding allows system-level (administrator) attackers to obtain information about secret RSA keys via a controlled-channel and side-channel attack on software running in isolated environments that can be single stepped, especially Intel SGX."}, {"lang": "es", "value": "En Apache Teaclave Rust SGX SDK versi\u00f3n 1.1.3, una vulnerabilidad de canal lateral en la decodificaci\u00f3n de archivos PEM base64, permite a atacantes a nivel de sistema (administrador) obtener informaci\u00f3n sobre claves RSA secretas por medio de un ataque de canal controlado y de canal lateral en software ejecut\u00e1ndose entornos aislados que pueden ser de un solo paso, especialmente Intel SGX"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:teaclave_sgx_sdk:1.1.3:*:*:*:*:rust:*:*", "matchCriteriaId": "9F4F7C7A-759B-410D-BD62-A7691A5034CB"}]}]}], "references": [{"url": "https://docs.rs/crate/sgx_tstd/1.1.1", "source": "cve@mitre.org", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://github.com/UzL-ITS/util-lookup/blob/main/cve-vulnerability-publication.md", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dingelish/rust-base64/commit/a554b7ae880553db6dde8a387101a093911d5b2a", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dingelish/rust-base64/commit/a554b7ae880553db6dde8a387101a093911d5b2a"}}