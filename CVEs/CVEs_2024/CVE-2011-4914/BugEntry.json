{"buggy_code": ["/*\n *\tDeclarations of Rose type objects.\n *\n *\tJonathan Naylor G4KLX\t25/8/96\n */\n\n#ifndef _ROSE_H\n#define _ROSE_H \n\n#include <linux/rose.h>\n#include <net/sock.h>\n\n#define\tROSE_ADDR_LEN\t\t\t5\n\n#define\tROSE_MIN_LEN\t\t\t3\n\n#define\tROSE_GFI\t\t\t0x10\n#define\tROSE_Q_BIT\t\t\t0x80\n#define\tROSE_D_BIT\t\t\t0x40\n#define\tROSE_M_BIT\t\t\t0x10\n\n#define\tROSE_CALL_REQUEST\t\t0x0B\n#define\tROSE_CALL_ACCEPTED\t\t0x0F\n#define\tROSE_CLEAR_REQUEST\t\t0x13\n#define\tROSE_CLEAR_CONFIRMATION\t\t0x17\n#define\tROSE_DATA\t\t\t0x00\n#define\tROSE_INTERRUPT\t\t\t0x23\n#define\tROSE_INTERRUPT_CONFIRMATION\t0x27\n#define\tROSE_RR\t\t\t\t0x01\n#define\tROSE_RNR\t\t\t0x05\n#define\tROSE_REJ\t\t\t0x09\n#define\tROSE_RESET_REQUEST\t\t0x1B\n#define\tROSE_RESET_CONFIRMATION\t\t0x1F\n#define\tROSE_REGISTRATION_REQUEST\t0xF3\n#define\tROSE_REGISTRATION_CONFIRMATION\t0xF7\n#define\tROSE_RESTART_REQUEST\t\t0xFB\n#define\tROSE_RESTART_CONFIRMATION\t0xFF\n#define\tROSE_DIAGNOSTIC\t\t\t0xF1\n#define\tROSE_ILLEGAL\t\t\t0xFD\n\n/* Define Link State constants. */\n\nenum {\n\tROSE_STATE_0,\t\t\t/* Ready */\n\tROSE_STATE_1,\t\t\t/* Awaiting Call Accepted */\n\tROSE_STATE_2,\t\t\t/* Awaiting Clear Confirmation */\n\tROSE_STATE_3,\t\t\t/* Data Transfer */\n\tROSE_STATE_4,\t\t\t/* Awaiting Reset Confirmation */\n\tROSE_STATE_5\t\t\t/* Deferred Call Acceptance */\n};\n\n#define ROSE_DEFAULT_T0\t\t\t180000\t\t/* Default T10 T20 value */\n#define ROSE_DEFAULT_T1\t\t\t200000\t\t/* Default T11 T21 value */\n#define ROSE_DEFAULT_T2\t\t\t180000\t\t/* Default T12 T22 value */\n#define\tROSE_DEFAULT_T3\t\t\t180000\t\t/* Default T13 T23 value */\n#define\tROSE_DEFAULT_HB\t\t\t5000\t\t/* Default Holdback value */\n#define\tROSE_DEFAULT_IDLE\t\t0\t\t/* No Activity Timeout - none */\n#define\tROSE_DEFAULT_ROUTING\t\t1\t\t/* Default routing flag */\n#define\tROSE_DEFAULT_FAIL_TIMEOUT\t120000\t\t/* Time until link considered usable */\n#define\tROSE_DEFAULT_MAXVC\t\t50\t\t/* Maximum number of VCs per neighbour */\n#define\tROSE_DEFAULT_WINDOW_SIZE\t7\t\t/* Default window size */\n\n#define ROSE_MODULUS \t\t\t8\n#define\tROSE_MAX_PACKET_SIZE\t\t251\t\t/* Maximum packet size */\n\n#define\tROSE_COND_ACK_PENDING\t\t0x01\n#define\tROSE_COND_PEER_RX_BUSY\t\t0x02\n#define\tROSE_COND_OWN_RX_BUSY\t\t0x04\n\n#define\tFAC_NATIONAL\t\t\t0x00\n#define\tFAC_CCITT\t\t\t0x0F\n\n#define\tFAC_NATIONAL_RAND\t\t0x7F\n#define\tFAC_NATIONAL_FLAGS\t\t0x3F\n#define\tFAC_NATIONAL_DEST_DIGI\t\t0xE9\n#define\tFAC_NATIONAL_SRC_DIGI\t\t0xEB\n#define\tFAC_NATIONAL_FAIL_CALL\t\t0xED\n#define\tFAC_NATIONAL_FAIL_ADD\t\t0xEE\n#define\tFAC_NATIONAL_DIGIS\t\t\t0xEF\n\n#define\tFAC_CCITT_DEST_NSAP\t\t0xC9\n#define\tFAC_CCITT_SRC_NSAP\t\t0xCB\n\nstruct rose_neigh {\n\tstruct rose_neigh\t*next;\n\tax25_address\t\tcallsign;\n\tax25_digi\t\t*digipeat;\n\tax25_cb\t\t\t*ax25;\n\tstruct net_device\t\t*dev;\n\tunsigned short\t\tcount;\n\tunsigned short\t\tuse;\n\tunsigned int\t\tnumber;\n\tchar\t\t\trestarted;\n\tchar\t\t\tdce_mode;\n\tchar\t\t\tloopback;\n\tstruct sk_buff_head\tqueue;\n\tstruct timer_list\tt0timer;\n\tstruct timer_list\tftimer;\n};\n\nstruct rose_node {\n\tstruct rose_node\t*next;\n\trose_address\t\taddress;\n\tunsigned short\t\tmask;\n\tunsigned char\t\tcount;\n\tchar\t\t\tloopback;\n\tstruct rose_neigh\t*neighbour[3];\n};\n\nstruct rose_route {\n\tstruct rose_route\t*next;\n\tunsigned int\t\tlci1, lci2;\n\trose_address\t\tsrc_addr, dest_addr;\n\tax25_address\t\tsrc_call, dest_call;\n\tstruct rose_neigh \t*neigh1, *neigh2;\n\tunsigned int\t\trand;\n};\n\nstruct rose_sock {\n\tstruct sock\t\tsock;\n\trose_address\t\tsource_addr,   dest_addr;\n\tax25_address\t\tsource_call,   dest_call;\n\tunsigned char\t\tsource_ndigis, dest_ndigis;\n\tax25_address\t\tsource_digis[ROSE_MAX_DIGIS];\n\tax25_address\t\tdest_digis[ROSE_MAX_DIGIS];\n\tstruct rose_neigh\t*neighbour;\n\tstruct net_device\t\t*device;\n\tunsigned int\t\tlci, rand;\n\tunsigned char\t\tstate, condition, qbitincl, defer;\n\tunsigned char\t\tcause, diagnostic;\n\tunsigned short\t\tvs, vr, va, vl;\n\tunsigned long\t\tt1, t2, t3, hb, idle;\n#ifdef M_BIT\n\tunsigned short\t\tfraglen;\n\tstruct sk_buff_head\tfrag_queue;\n#endif\n\tstruct sk_buff_head\tack_queue;\n\tstruct rose_facilities_struct facilities;\n\tstruct timer_list\ttimer;\n\tstruct timer_list\tidletimer;\n};\n\n#define rose_sk(sk) ((struct rose_sock *)(sk))\n\n/* af_rose.c */\nextern ax25_address rose_callsign;\nextern int  sysctl_rose_restart_request_timeout;\nextern int  sysctl_rose_call_request_timeout;\nextern int  sysctl_rose_reset_request_timeout;\nextern int  sysctl_rose_clear_request_timeout;\nextern int  sysctl_rose_no_activity_timeout;\nextern int  sysctl_rose_ack_hold_back_timeout;\nextern int  sysctl_rose_routing_control;\nextern int  sysctl_rose_link_fail_timeout;\nextern int  sysctl_rose_maximum_vcs;\nextern int  sysctl_rose_window_size;\nextern int  rosecmp(rose_address *, rose_address *);\nextern int  rosecmpm(rose_address *, rose_address *, unsigned short);\nextern char *rose2asc(char *buf, const rose_address *);\nextern struct sock *rose_find_socket(unsigned int, struct rose_neigh *);\nextern void rose_kill_by_neigh(struct rose_neigh *);\nextern unsigned int rose_new_lci(struct rose_neigh *);\nextern int  rose_rx_call_request(struct sk_buff *, struct net_device *, struct rose_neigh *, unsigned int);\nextern void rose_destroy_socket(struct sock *);\n\n/* rose_dev.c */\nextern void  rose_setup(struct net_device *);\n\n/* rose_in.c */\nextern int  rose_process_rx_frame(struct sock *, struct sk_buff *);\n\n/* rose_link.c */\nextern void rose_start_ftimer(struct rose_neigh *);\nextern void rose_stop_ftimer(struct rose_neigh *);\nextern void rose_stop_t0timer(struct rose_neigh *);\nextern int  rose_ftimer_running(struct rose_neigh *);\nextern void rose_link_rx_restart(struct sk_buff *, struct rose_neigh *, unsigned short);\nextern void rose_transmit_clear_request(struct rose_neigh *, unsigned int, unsigned char, unsigned char);\nextern void rose_transmit_link(struct sk_buff *, struct rose_neigh *);\n\n/* rose_loopback.c */\nextern void rose_loopback_init(void);\nextern void rose_loopback_clear(void);\nextern int  rose_loopback_queue(struct sk_buff *, struct rose_neigh *);\n\n/* rose_out.c */\nextern void rose_kick(struct sock *);\nextern void rose_enquiry_response(struct sock *);\n\n/* rose_route.c */\nextern struct rose_neigh *rose_loopback_neigh;\nextern const struct file_operations rose_neigh_fops;\nextern const struct file_operations rose_nodes_fops;\nextern const struct file_operations rose_routes_fops;\n\nextern void rose_add_loopback_neigh(void);\nextern int __must_check rose_add_loopback_node(rose_address *);\nextern void rose_del_loopback_node(rose_address *);\nextern void rose_rt_device_down(struct net_device *);\nextern void rose_link_device_down(struct net_device *);\nextern struct net_device *rose_dev_first(void);\nextern struct net_device *rose_dev_get(rose_address *);\nextern struct rose_route *rose_route_free_lci(unsigned int, struct rose_neigh *);\nextern struct rose_neigh *rose_get_neigh(rose_address *, unsigned char *, unsigned char *, int);\nextern int  rose_rt_ioctl(unsigned int, void __user *);\nextern void rose_link_failed(ax25_cb *, int);\nextern int  rose_route_frame(struct sk_buff *, ax25_cb *);\nextern void rose_rt_free(void);\n\n/* rose_subr.c */\nextern void rose_clear_queues(struct sock *);\nextern void rose_frames_acked(struct sock *, unsigned short);\nextern void rose_requeue_frames(struct sock *);\nextern int  rose_validate_nr(struct sock *, unsigned short);\nextern void rose_write_internal(struct sock *, int);\nextern int  rose_decode(struct sk_buff *, int *, int *, int *, int *, int *);\nextern int  rose_parse_facilities(unsigned char *, struct rose_facilities_struct *);\nextern void rose_disconnect(struct sock *, int, int, int);\n\n/* rose_timer.c */\nextern void rose_start_heartbeat(struct sock *);\nextern void rose_start_t1timer(struct sock *);\nextern void rose_start_t2timer(struct sock *);\nextern void rose_start_t3timer(struct sock *);\nextern void rose_start_hbtimer(struct sock *);\nextern void rose_start_idletimer(struct sock *);\nextern void rose_stop_heartbeat(struct sock *);\nextern void rose_stop_timer(struct sock *);\nextern void rose_stop_idletimer(struct sock *);\n\n/* sysctl_net_rose.c */\nextern void rose_register_sysctl(void);\nextern void rose_unregister_sysctl(void);\n\n#endif\n", "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Copyright (C) Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n * Copyright (C) Alan Cox GW4PTS (alan@lxorguk.ukuu.org.uk)\n * Copyright (C) Terry Dawson VK2KTJ (terry@animats.net)\n * Copyright (C) Tomi Manninen OH2BNS (oh2bns@sral.fi)\n */\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/stat.h>\n#include <net/net_namespace.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <asm/system.h>\n#include <asm/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <net/rose.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <net/tcp_states.h>\n#include <net/ip.h>\n#include <net/arp.h>\n\nstatic int rose_ndevs = 10;\n\nint sysctl_rose_restart_request_timeout = ROSE_DEFAULT_T0;\nint sysctl_rose_call_request_timeout    = ROSE_DEFAULT_T1;\nint sysctl_rose_reset_request_timeout   = ROSE_DEFAULT_T2;\nint sysctl_rose_clear_request_timeout   = ROSE_DEFAULT_T3;\nint sysctl_rose_no_activity_timeout     = ROSE_DEFAULT_IDLE;\nint sysctl_rose_ack_hold_back_timeout   = ROSE_DEFAULT_HB;\nint sysctl_rose_routing_control         = ROSE_DEFAULT_ROUTING;\nint sysctl_rose_link_fail_timeout       = ROSE_DEFAULT_FAIL_TIMEOUT;\nint sysctl_rose_maximum_vcs             = ROSE_DEFAULT_MAXVC;\nint sysctl_rose_window_size             = ROSE_DEFAULT_WINDOW_SIZE;\n\nstatic HLIST_HEAD(rose_list);\nstatic DEFINE_SPINLOCK(rose_list_lock);\n\nstatic const struct proto_ops rose_proto_ops;\n\nax25_address rose_callsign;\n\n/*\n * ROSE network devices are virtual network devices encapsulating ROSE\n * frames into AX.25 which will be sent through an AX.25 device, so form a\n * special \"super class\" of normal net devices; split their locks off into a\n * separate class since they always nest.\n */\nstatic struct lock_class_key rose_netdev_xmit_lock_key;\nstatic struct lock_class_key rose_netdev_addr_lock_key;\n\nstatic void rose_set_lockdep_one(struct net_device *dev,\n\t\t\t\t struct netdev_queue *txq,\n\t\t\t\t void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock, &rose_netdev_xmit_lock_key);\n}\n\nstatic void rose_set_lockdep_key(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock, &rose_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, rose_set_lockdep_one, NULL);\n}\n\n/*\n *\tConvert a ROSE address into text.\n */\nchar *rose2asc(char *buf, const rose_address *addr)\n{\n\tif (addr->rose_addr[0] == 0x00 && addr->rose_addr[1] == 0x00 &&\n\t    addr->rose_addr[2] == 0x00 && addr->rose_addr[3] == 0x00 &&\n\t    addr->rose_addr[4] == 0x00) {\n\t\tstrcpy(buf, \"*\");\n\t} else {\n\t\tsprintf(buf, \"%02X%02X%02X%02X%02X\", addr->rose_addr[0] & 0xFF,\n\t\t\t\t\t\taddr->rose_addr[1] & 0xFF,\n\t\t\t\t\t\taddr->rose_addr[2] & 0xFF,\n\t\t\t\t\t\taddr->rose_addr[3] & 0xFF,\n\t\t\t\t\t\taddr->rose_addr[4] & 0xFF);\n\t}\n\n\treturn buf;\n}\n\n/*\n *\tCompare two ROSE addresses, 0 == equal.\n */\nint rosecmp(rose_address *addr1, rose_address *addr2)\n{\n\tint i;\n\n\tfor (i = 0; i < 5; i++)\n\t\tif (addr1->rose_addr[i] != addr2->rose_addr[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n/*\n *\tCompare two ROSE addresses for only mask digits, 0 == equal.\n */\nint rosecmpm(rose_address *addr1, rose_address *addr2, unsigned short mask)\n{\n\tunsigned int i, j;\n\n\tif (mask > 10)\n\t\treturn 1;\n\n\tfor (i = 0; i < mask; i++) {\n\t\tj = i / 2;\n\n\t\tif ((i % 2) != 0) {\n\t\t\tif ((addr1->rose_addr[j] & 0x0F) != (addr2->rose_addr[j] & 0x0F))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif ((addr1->rose_addr[j] & 0xF0) != (addr2->rose_addr[j] & 0xF0))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n *\tSocket removal during an interrupt is now safe.\n */\nstatic void rose_remove_socket(struct sock *sk)\n{\n\tspin_lock_bh(&rose_list_lock);\n\tsk_del_node_init(sk);\n\tspin_unlock_bh(&rose_list_lock);\n}\n\n/*\n *\tKill all bound sockets on a broken link layer connection to a\n *\tparticular neighbour.\n */\nvoid rose_kill_by_neigh(struct rose_neigh *neigh)\n{\n\tstruct sock *s;\n\tstruct hlist_node *node;\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_for_each(s, node, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (rose->neighbour == neigh) {\n\t\t\trose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);\n\t\t\trose->neighbour->use--;\n\t\t\trose->neighbour = NULL;\n\t\t}\n\t}\n\tspin_unlock_bh(&rose_list_lock);\n}\n\n/*\n *\tKill all bound sockets on a dropped device.\n */\nstatic void rose_kill_by_device(struct net_device *dev)\n{\n\tstruct sock *s;\n\tstruct hlist_node *node;\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_for_each(s, node, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (rose->device == dev) {\n\t\t\trose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);\n\t\t\trose->neighbour->use--;\n\t\t\trose->device = NULL;\n\t\t}\n\t}\n\tspin_unlock_bh(&rose_list_lock);\n}\n\n/*\n *\tHandle device status changes.\n */\nstatic int rose_device_event(struct notifier_block *this, unsigned long event,\n\tvoid *ptr)\n{\n\tstruct net_device *dev = (struct net_device *)ptr;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (dev->type) {\n\tcase ARPHRD_ROSE:\n\t\trose_kill_by_device(dev);\n\t\tbreak;\n\tcase ARPHRD_AX25:\n\t\trose_link_device_down(dev);\n\t\trose_rt_device_down(dev);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n/*\n *\tAdd a socket to the bound sockets list.\n */\nstatic void rose_insert_socket(struct sock *sk)\n{\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_add_node(sk, &rose_list);\n\tspin_unlock_bh(&rose_list_lock);\n}\n\n/*\n *\tFind a socket that wants to accept the Call Request we just\n *\treceived.\n */\nstatic struct sock *rose_find_listener(rose_address *addr, ax25_address *call)\n{\n\tstruct sock *s;\n\tstruct hlist_node *node;\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_for_each(s, node, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (!rosecmp(&rose->source_addr, addr) &&\n\t\t    !ax25cmp(&rose->source_call, call) &&\n\t\t    !rose->source_ndigis && s->sk_state == TCP_LISTEN)\n\t\t\tgoto found;\n\t}\n\n\tsk_for_each(s, node, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (!rosecmp(&rose->source_addr, addr) &&\n\t\t    !ax25cmp(&rose->source_call, &null_ax25_address) &&\n\t\t    s->sk_state == TCP_LISTEN)\n\t\t\tgoto found;\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&rose_list_lock);\n\treturn s;\n}\n\n/*\n *\tFind a connected ROSE socket given my LCI and device.\n */\nstruct sock *rose_find_socket(unsigned int lci, struct rose_neigh *neigh)\n{\n\tstruct sock *s;\n\tstruct hlist_node *node;\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_for_each(s, node, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (rose->lci == lci && rose->neighbour == neigh)\n\t\t\tgoto found;\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&rose_list_lock);\n\treturn s;\n}\n\n/*\n *\tFind a unique LCI for a given device.\n */\nunsigned int rose_new_lci(struct rose_neigh *neigh)\n{\n\tint lci;\n\n\tif (neigh->dce_mode) {\n\t\tfor (lci = 1; lci <= sysctl_rose_maximum_vcs; lci++)\n\t\t\tif (rose_find_socket(lci, neigh) == NULL && rose_route_free_lci(lci, neigh) == NULL)\n\t\t\t\treturn lci;\n\t} else {\n\t\tfor (lci = sysctl_rose_maximum_vcs; lci > 0; lci--)\n\t\t\tif (rose_find_socket(lci, neigh) == NULL && rose_route_free_lci(lci, neigh) == NULL)\n\t\t\t\treturn lci;\n\t}\n\n\treturn 0;\n}\n\n/*\n *\tDeferred destroy.\n */\nvoid rose_destroy_socket(struct sock *);\n\n/*\n *\tHandler for deferred kills.\n */\nstatic void rose_destroy_timer(unsigned long data)\n{\n\trose_destroy_socket((struct sock *)data);\n}\n\n/*\n *\tThis is called from user mode and the timers. Thus it protects itself\n *\tagainst interrupt users but doesn't worry about being called during\n *\twork.  Once it is removed from the queue no interrupt or bottom half\n *\twill touch it and we are (fairly 8-) ) safe.\n */\nvoid rose_destroy_socket(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\trose_remove_socket(sk);\n\trose_stop_heartbeat(sk);\n\trose_stop_idletimer(sk);\n\trose_stop_timer(sk);\n\n\trose_clear_queues(sk);\t\t/* Flush the queues */\n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (skb->sk != sk) {\t/* A pending connection */\n\t\t\t/* Queue the unaccepted socket for death */\n\t\t\tsock_set_flag(skb->sk, SOCK_DEAD);\n\t\t\trose_start_heartbeat(skb->sk);\n\t\t\trose_sk(skb->sk)->state = ROSE_STATE_0;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\tif (sk_has_allocations(sk)) {\n\t\t/* Defer: outstanding buffers */\n\t\tsetup_timer(&sk->sk_timer, rose_destroy_timer,\n\t\t\t\t(unsigned long)sk);\n\t\tsk->sk_timer.expires  = jiffies + 10 * HZ;\n\t\tadd_timer(&sk->sk_timer);\n\t} else\n\t\tsock_put(sk);\n}\n\n/*\n *\tHandling for system calls applied via the various interfaces to a\n *\tROSE socket object.\n */\n\nstatic int rose_setsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint opt;\n\n\tif (level != SOL_ROSE)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(opt, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase ROSE_DEFER:\n\t\trose->defer = opt ? 1 : 0;\n\t\treturn 0;\n\n\tcase ROSE_T1:\n\t\tif (opt < 1)\n\t\t\treturn -EINVAL;\n\t\trose->t1 = opt * HZ;\n\t\treturn 0;\n\n\tcase ROSE_T2:\n\t\tif (opt < 1)\n\t\t\treturn -EINVAL;\n\t\trose->t2 = opt * HZ;\n\t\treturn 0;\n\n\tcase ROSE_T3:\n\t\tif (opt < 1)\n\t\t\treturn -EINVAL;\n\t\trose->t3 = opt * HZ;\n\t\treturn 0;\n\n\tcase ROSE_HOLDBACK:\n\t\tif (opt < 1)\n\t\t\treturn -EINVAL;\n\t\trose->hb = opt * HZ;\n\t\treturn 0;\n\n\tcase ROSE_IDLE:\n\t\tif (opt < 0)\n\t\t\treturn -EINVAL;\n\t\trose->idle = opt * 60 * HZ;\n\t\treturn 0;\n\n\tcase ROSE_QBITINCL:\n\t\trose->qbitincl = opt ? 1 : 0;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\nstatic int rose_getsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint val = 0;\n\tint len;\n\n\tif (level != SOL_ROSE)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase ROSE_DEFER:\n\t\tval = rose->defer;\n\t\tbreak;\n\n\tcase ROSE_T1:\n\t\tval = rose->t1 / HZ;\n\t\tbreak;\n\n\tcase ROSE_T2:\n\t\tval = rose->t2 / HZ;\n\t\tbreak;\n\n\tcase ROSE_T3:\n\t\tval = rose->t3 / HZ;\n\t\tbreak;\n\n\tcase ROSE_HOLDBACK:\n\t\tval = rose->hb / HZ;\n\t\tbreak;\n\n\tcase ROSE_IDLE:\n\t\tval = rose->idle / (60 * HZ);\n\t\tbreak;\n\n\tcase ROSE_QBITINCL:\n\t\tval = rose->qbitincl;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn copy_to_user(optval, &val, len) ? -EFAULT : 0;\n}\n\nstatic int rose_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tstruct rose_sock *rose = rose_sk(sk);\n\n\t\trose->dest_ndigis = 0;\n\t\tmemset(&rose->dest_addr, 0, ROSE_ADDR_LEN);\n\t\tmemset(&rose->dest_call, 0, AX25_ADDR_LEN);\n\t\tmemset(rose->dest_digis, 0, AX25_ADDR_LEN * ROSE_MAX_DIGIS);\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct proto rose_proto = {\n\t.name\t  = \"ROSE\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct rose_sock),\n};\n\nstatic int rose_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tstruct rose_sock *rose;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tif (sock->type != SOCK_SEQPACKET || protocol != 0)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\trose = rose_sk(sk);\n\n\tsock_init_data(sock, sk);\n\n\tskb_queue_head_init(&rose->ack_queue);\n#ifdef M_BIT\n\tskb_queue_head_init(&rose->frag_queue);\n\trose->fraglen    = 0;\n#endif\n\n\tsock->ops    = &rose_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tinit_timer(&rose->timer);\n\tinit_timer(&rose->idletimer);\n\n\trose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);\n\trose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);\n\trose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);\n\trose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);\n\trose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);\n\n\trose->state = ROSE_STATE_0;\n\n\treturn 0;\n}\n\nstatic struct sock *rose_make_new(struct sock *osk)\n{\n\tstruct sock *sk;\n\tstruct rose_sock *rose, *orose;\n\n\tif (osk->sk_type != SOCK_SEQPACKET)\n\t\treturn NULL;\n\n\tsk = sk_alloc(sock_net(osk), PF_ROSE, GFP_ATOMIC, &rose_proto);\n\tif (sk == NULL)\n\t\treturn NULL;\n\n\trose = rose_sk(sk);\n\n\tsock_init_data(NULL, sk);\n\n\tskb_queue_head_init(&rose->ack_queue);\n#ifdef M_BIT\n\tskb_queue_head_init(&rose->frag_queue);\n\trose->fraglen  = 0;\n#endif\n\n\tsk->sk_type     = osk->sk_type;\n\tsk->sk_priority = osk->sk_priority;\n\tsk->sk_protocol = osk->sk_protocol;\n\tsk->sk_rcvbuf   = osk->sk_rcvbuf;\n\tsk->sk_sndbuf   = osk->sk_sndbuf;\n\tsk->sk_state    = TCP_ESTABLISHED;\n\tsock_copy_flags(sk, osk);\n\n\tinit_timer(&rose->timer);\n\tinit_timer(&rose->idletimer);\n\n\torose\t\t= rose_sk(osk);\n\trose->t1\t= orose->t1;\n\trose->t2\t= orose->t2;\n\trose->t3\t= orose->t3;\n\trose->hb\t= orose->hb;\n\trose->idle\t= orose->idle;\n\trose->defer\t= orose->defer;\n\trose->device\t= orose->device;\n\trose->qbitincl\t= orose->qbitincl;\n\n\treturn sk;\n}\n\nstatic int rose_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose;\n\n\tif (sk == NULL) return 0;\n\n\tsock_hold(sk);\n\tsock_orphan(sk);\n\tlock_sock(sk);\n\trose = rose_sk(sk);\n\n\tswitch (rose->state) {\n\tcase ROSE_STATE_0:\n\t\trelease_sock(sk);\n\t\trose_disconnect(sk, 0, -1, -1);\n\t\tlock_sock(sk);\n\t\trose_destroy_socket(sk);\n\t\tbreak;\n\n\tcase ROSE_STATE_2:\n\t\trose->neighbour->use--;\n\t\trelease_sock(sk);\n\t\trose_disconnect(sk, 0, -1, -1);\n\t\tlock_sock(sk);\n\t\trose_destroy_socket(sk);\n\t\tbreak;\n\n\tcase ROSE_STATE_1:\n\tcase ROSE_STATE_3:\n\tcase ROSE_STATE_4:\n\tcase ROSE_STATE_5:\n\t\trose_clear_queues(sk);\n\t\trose_stop_idletimer(sk);\n\t\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\t\trose_start_t3timer(sk);\n\t\trose->state  = ROSE_STATE_2;\n\t\tsk->sk_state    = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int rose_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;\n\tstruct net_device *dev;\n\tax25_address *source;\n\tax25_uid_assoc *user;\n\tint n;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\n\tif (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))\n\t\treturn -EINVAL;\n\n\tif (addr->srose_family != AF_ROSE)\n\t\treturn -EINVAL;\n\n\tif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\n\t\treturn -EINVAL;\n\n\tif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tif ((dev = rose_dev_get(&addr->srose_addr)) == NULL) {\n\t\tSOCK_DEBUG(sk, \"ROSE: bind failed: invalid address\\n\");\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tsource = &addr->srose_call;\n\n\tuser = ax25_findbyuid(current_euid());\n\tif (user) {\n\t\trose->source_call = user->call;\n\t\tax25_uid_put(user);\n\t} else {\n\t\tif (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE))\n\t\t\treturn -EACCES;\n\t\trose->source_call   = *source;\n\t}\n\n\trose->source_addr   = addr->srose_addr;\n\trose->device        = dev;\n\trose->source_ndigis = addr->srose_ndigis;\n\n\tif (addr_len == sizeof(struct full_sockaddr_rose)) {\n\t\tstruct full_sockaddr_rose *full_addr = (struct full_sockaddr_rose *)uaddr;\n\t\tfor (n = 0 ; n < addr->srose_ndigis ; n++)\n\t\t\trose->source_digis[n] = full_addr->srose_digis[n];\n\t} else {\n\t\tif (rose->source_ndigis == 1) {\n\t\t\trose->source_digis[0] = addr->srose_digi;\n\t\t}\n\t}\n\n\trose_insert_socket(sk);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tSOCK_DEBUG(sk, \"ROSE: socket is bound\\n\");\n\treturn 0;\n}\n\nstatic int rose_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;\n\tunsigned char cause, diagnostic;\n\tstruct net_device *dev;\n\tax25_uid_assoc *user;\n\tint n, err = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))\n\t\treturn -EINVAL;\n\n\tif (addr->srose_family != AF_ROSE)\n\t\treturn -EINVAL;\n\n\tif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\n\t\treturn -EINVAL;\n\n\tif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\t/* Source + Destination digis should not exceed ROSE_MAX_DIGIS */\n\tif ((rose->source_ndigis + addr->srose_ndigis) > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\t/* Connect completed during a ERESTARTSYS event */\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = -ECONNREFUSED;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\t/* No reconnect on a seqpacket socket */\n\t\terr = -EISCONN;\n\t\tgoto out_release;\n\t}\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trose->neighbour = rose_get_neigh(&addr->srose_addr, &cause,\n\t\t\t\t\t &diagnostic, 0);\n\tif (!rose->neighbour) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out_release;\n\t}\n\n\trose->lci = rose_new_lci(rose->neighbour);\n\tif (!rose->lci) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out_release;\n\t}\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\t/* Must bind first - autobinding in this may or may not work */\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\t\tif ((dev = rose_dev_first()) == NULL) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tuser = ax25_findbyuid(current_euid());\n\t\tif (!user) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tmemcpy(&rose->source_addr, dev->dev_addr, ROSE_ADDR_LEN);\n\t\trose->source_call = user->call;\n\t\trose->device      = dev;\n\t\tax25_uid_put(user);\n\n\t\trose_insert_socket(sk);\t\t/* Finish the bind */\n\t}\n\trose->dest_addr   = addr->srose_addr;\n\trose->dest_call   = addr->srose_call;\n\trose->rand        = ((long)rose & 0xFFFF) + rose->lci;\n\trose->dest_ndigis = addr->srose_ndigis;\n\n\tif (addr_len == sizeof(struct full_sockaddr_rose)) {\n\t\tstruct full_sockaddr_rose *full_addr = (struct full_sockaddr_rose *)uaddr;\n\t\tfor (n = 0 ; n < addr->srose_ndigis ; n++)\n\t\t\trose->dest_digis[n] = full_addr->srose_digis[n];\n\t} else {\n\t\tif (rose->dest_ndigis == 1) {\n\t\t\trose->dest_digis[0] = addr->srose_digi;\n\t\t}\n\t}\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state     = TCP_SYN_SENT;\n\n\trose->state = ROSE_STATE_1;\n\n\trose->neighbour->use++;\n\n\trose_write_internal(sk, ROSE_CALL_REQUEST);\n\trose_start_heartbeat(sk);\n\trose_start_t1timer(sk);\n\n\t/* Now the loop */\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\n\t\terr = -EINPROGRESS;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * A Connect Ack with Choke or timeout or failed routing will go to\n\t * closed.\n\t */\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\t\tbreak;\n\t\t\tif (!signal_pending(current)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tschedule();\n\t\t\t\tlock_sock(sk);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = sock_error(sk);\t/* Always set at this point */\n\t\tgoto out_release;\n\t}\n\n\tsock->state = SS_CONNECTED;\n\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int rose_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *newsk;\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk;\n\tint err = 0;\n\n\tif ((sk = sock->sk) == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t *\tThe write queue this time is holding sockets ready to use\n\t *\thooked into the SABM we saved\n\t */\n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tbreak;\n\n\t\tif (flags & O_NONBLOCK) {\n\t\t\terr = -EWOULDBLOCK;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\trelease_sock(sk);\n\t\t\tschedule();\n\t\t\tlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\tif (err)\n\t\tgoto out_release;\n\n\tnewsk = skb->sk;\n\tsock_graft(newsk, newsock);\n\n\t/* Now attach up the new socket */\n\tskb->sk = NULL;\n\tkfree_skb(skb);\n\tsk->sk_ack_backlog--;\n\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\n\tmemset(srose, 0, sizeof(*srose));\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}\n\nint rose_rx_call_request(struct sk_buff *skb, struct net_device *dev, struct rose_neigh *neigh, unsigned int lci)\n{\n\tstruct sock *sk;\n\tstruct sock *make;\n\tstruct rose_sock *make_rose;\n\tstruct rose_facilities_struct facilities;\n\tint n, len;\n\n\tskb->sk = NULL;\t\t/* Initially we don't know who it's for */\n\n\t/*\n\t *\tskb->data points to the rose frame start\n\t */\n\tmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\n\n\tlen  = (((skb->data[3] >> 4) & 0x0F) + 1) >> 1;\n\tlen += (((skb->data[3] >> 0) & 0x0F) + 1) >> 1;\n\tif (!rose_parse_facilities(skb->data + len + 4, &facilities)) {\n\t\trose_transmit_clear_request(neigh, lci, ROSE_INVALID_FACILITY, 76);\n\t\treturn 0;\n\t}\n\n\tsk = rose_find_listener(&facilities.source_addr, &facilities.source_call);\n\n\t/*\n\t * We can't accept the Call Request.\n\t */\n\tif (sk == NULL || sk_acceptq_is_full(sk) ||\n\t    (make = rose_make_new(sk)) == NULL) {\n\t\trose_transmit_clear_request(neigh, lci, ROSE_NETWORK_CONGESTION, 120);\n\t\treturn 0;\n\t}\n\n\tskb->sk     = make;\n\tmake->sk_state = TCP_ESTABLISHED;\n\tmake_rose = rose_sk(make);\n\n\tmake_rose->lci           = lci;\n\tmake_rose->dest_addr     = facilities.dest_addr;\n\tmake_rose->dest_call     = facilities.dest_call;\n\tmake_rose->dest_ndigis   = facilities.dest_ndigis;\n\tfor (n = 0 ; n < facilities.dest_ndigis ; n++)\n\t\tmake_rose->dest_digis[n] = facilities.dest_digis[n];\n\tmake_rose->source_addr   = facilities.source_addr;\n\tmake_rose->source_call   = facilities.source_call;\n\tmake_rose->source_ndigis = facilities.source_ndigis;\n\tfor (n = 0 ; n < facilities.source_ndigis ; n++)\n\t\tmake_rose->source_digis[n]= facilities.source_digis[n];\n\tmake_rose->neighbour     = neigh;\n\tmake_rose->device        = dev;\n\tmake_rose->facilities    = facilities;\n\n\tmake_rose->neighbour->use++;\n\n\tif (rose_sk(sk)->defer) {\n\t\tmake_rose->state = ROSE_STATE_5;\n\t} else {\n\t\trose_write_internal(make, ROSE_CALL_ACCEPTED);\n\t\tmake_rose->state = ROSE_STATE_3;\n\t\trose_start_idletimer(make);\n\t}\n\n\tmake_rose->condition = 0x00;\n\tmake_rose->vs        = 0;\n\tmake_rose->va        = 0;\n\tmake_rose->vr        = 0;\n\tmake_rose->vl        = 0;\n\tsk->sk_ack_backlog++;\n\n\trose_insert_socket(make);\n\n\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\trose_start_heartbeat(make);\n\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk, skb->len);\n\n\treturn 1;\n}\n\nstatic int rose_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *usrose = (struct sockaddr_rose *)msg->msg_name;\n\tint err;\n\tstruct full_sockaddr_rose srose;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint n, size, qbit = 0;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\treturn -EPIPE;\n\t}\n\n\tif (rose->neighbour == NULL || rose->device == NULL)\n\t\treturn -ENETUNREACH;\n\n\tif (usrose != NULL) {\n\t\tif (msg->msg_namelen != sizeof(struct sockaddr_rose) && msg->msg_namelen != sizeof(struct full_sockaddr_rose))\n\t\t\treturn -EINVAL;\n\t\tmemset(&srose, 0, sizeof(struct full_sockaddr_rose));\n\t\tmemcpy(&srose, usrose, msg->msg_namelen);\n\t\tif (rosecmp(&rose->dest_addr, &srose.srose_addr) != 0 ||\n\t\t    ax25cmp(&rose->dest_call, &srose.srose_call) != 0)\n\t\t\treturn -EISCONN;\n\t\tif (srose.srose_ndigis != rose->dest_ndigis)\n\t\t\treturn -EISCONN;\n\t\tif (srose.srose_ndigis == rose->dest_ndigis) {\n\t\t\tfor (n = 0 ; n < srose.srose_ndigis ; n++)\n\t\t\t\tif (ax25cmp(&rose->dest_digis[n],\n\t\t\t\t\t    &srose.srose_digis[n]))\n\t\t\t\t\treturn -EISCONN;\n\t\t}\n\t\tif (srose.srose_family != AF_ROSE)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsrose.srose_family = AF_ROSE;\n\t\tsrose.srose_addr   = rose->dest_addr;\n\t\tsrose.srose_call   = rose->dest_call;\n\t\tsrose.srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\tsrose.srose_digis[n] = rose->dest_digis[n];\n\t}\n\n\tSOCK_DEBUG(sk, \"ROSE: sendto: Addresses built.\\n\");\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"ROSE: sendto: building packet.\\n\");\n\t/* Sanity check the packet size */\n\tif (len > 65535)\n\t\treturn -EMSGSIZE;\n\n\tsize = len + AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN;\n\n\tif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)\n\t\treturn err;\n\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN);\n\n\t/*\n\t *\tPut the data on the end\n\t */\n\tSOCK_DEBUG(sk, \"ROSE: Appending user data\\n\");\n\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, len);\n\n\terr = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\t/*\n\t *\tIf the Q BIT Include socket option is in force, the first\n\t *\tbyte of the user data is the logical value of the Q Bit.\n\t */\n\tif (rose->qbitincl) {\n\t\tqbit = skb->data[0];\n\t\tskb_pull(skb, 1);\n\t}\n\n\t/*\n\t *\tPush down the ROSE header\n\t */\n\tasmptr = skb_push(skb, ROSE_MIN_LEN);\n\n\tSOCK_DEBUG(sk, \"ROSE: Building Network Header.\\n\");\n\n\t/* Build a ROSE Network header */\n\tasmptr[0] = ((rose->lci >> 8) & 0x0F) | ROSE_GFI;\n\tasmptr[1] = (rose->lci >> 0) & 0xFF;\n\tasmptr[2] = ROSE_DATA;\n\n\tif (qbit)\n\t\tasmptr[0] |= ROSE_Q_BIT;\n\n\tSOCK_DEBUG(sk, \"ROSE: Built header.\\n\");\n\n\tSOCK_DEBUG(sk, \"ROSE: Transmitting buffer\\n\");\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOTCONN;\n\t}\n\n#ifdef M_BIT\n#define ROSE_PACLEN (256-ROSE_MIN_LEN)\n\tif (skb->len - ROSE_MIN_LEN > ROSE_PACLEN) {\n\t\tunsigned char header[ROSE_MIN_LEN];\n\t\tstruct sk_buff *skbn;\n\t\tint frontlen;\n\t\tint lg;\n\n\t\t/* Save a copy of the Header */\n\t\tskb_copy_from_linear_data(skb, header, ROSE_MIN_LEN);\n\t\tskb_pull(skb, ROSE_MIN_LEN);\n\n\t\tfrontlen = skb_headroom(skb);\n\n\t\twhile (skb->len > 0) {\n\t\t\tif ((skbn = sock_alloc_send_skb(sk, frontlen + ROSE_PACLEN, 0, &err)) == NULL) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tskbn->sk   = sk;\n\t\t\tskbn->free = 1;\n\t\t\tskbn->arp  = 1;\n\n\t\t\tskb_reserve(skbn, frontlen);\n\n\t\t\tlg = (ROSE_PACLEN > skb->len) ? skb->len : ROSE_PACLEN;\n\n\t\t\t/* Copy the user data */\n\t\t\tskb_copy_from_linear_data(skb, skb_put(skbn, lg), lg);\n\t\t\tskb_pull(skb, lg);\n\n\t\t\t/* Duplicate the Header */\n\t\t\tskb_push(skbn, ROSE_MIN_LEN);\n\t\t\tskb_copy_to_linear_data(skbn, header, ROSE_MIN_LEN);\n\n\t\t\tif (skb->len > 0)\n\t\t\t\tskbn->data[2] |= M_BIT;\n\n\t\t\tskb_queue_tail(&sk->sk_write_queue, skbn); /* Throw it on the queue */\n\t\t}\n\n\t\tskb->free = 1;\n\t\tkfree_skb(skb);\n\t} else {\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\t\t/* Throw it on the queue */\n\t}\n#else\n\tskb_queue_tail(&sk->sk_write_queue, skb);\t/* Shove it onto the queue */\n#endif\n\n\trose_kick(sk);\n\n\treturn len;\n}\n\n\nstatic int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;\n\tsize_t copied;\n\tunsigned char *asmptr;\n\tstruct sk_buff *skb;\n\tint n, er, qbit;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\n\t/* Now we can treat all alike */\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)\n\t\treturn er;\n\n\tqbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\n\tskb_pull(skb, ROSE_MIN_LEN);\n\n\tif (rose->qbitincl) {\n\t\tasmptr  = skb_push(skb, 1);\n\t\t*asmptr = qbit;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tif (srose != NULL) {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tif (msg->msg_namelen >= sizeof(struct full_sockaddr_rose)) {\n\t\t\tstruct full_sockaddr_rose *full_srose = (struct full_sockaddr_rose *)msg->msg_name;\n\t\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\t\tfull_srose->srose_digis[n] = rose->dest_digis[n];\n\t\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_rose);\n\t\t} else {\n\t\t\tif (rose->dest_ndigis >= 1) {\n\t\t\t\tsrose->srose_ndigis = 1;\n\t\t\t\tsrose->srose_digi = rose->dest_digis[0];\n\t\t\t}\n\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_rose);\n\t\t}\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn copied;\n}\n\n\nstatic int rose_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount;\n\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\treturn put_user(amount, (unsigned int __user *) argp);\n\t}\n\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0L;\n\t\t/* These two are safe on a single CPU system as only user tasks fiddle here */\n\t\tif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\n\t\t\tamount = skb->len;\n\t\treturn put_user(amount, (unsigned int __user *) argp);\n\t}\n\n\tcase SIOCGSTAMP:\n\t\treturn sock_get_timestamp(sk, (struct timeval __user *) argp);\n\n\tcase SIOCGSTAMPNS:\n\t\treturn sock_get_timestampns(sk, (struct timespec __user *) argp);\n\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\t\treturn -EINVAL;\n\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\tcase SIOCRSCLRRT:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn rose_rt_ioctl(cmd, argp);\n\n\tcase SIOCRSGCAUSE: {\n\t\tstruct rose_cause_struct rose_cause;\n\t\trose_cause.cause      = rose->cause;\n\t\trose_cause.diagnostic = rose->diagnostic;\n\t\treturn copy_to_user(argp, &rose_cause, sizeof(struct rose_cause_struct)) ? -EFAULT : 0;\n\t}\n\n\tcase SIOCRSSCAUSE: {\n\t\tstruct rose_cause_struct rose_cause;\n\t\tif (copy_from_user(&rose_cause, argp, sizeof(struct rose_cause_struct)))\n\t\t\treturn -EFAULT;\n\t\trose->cause      = rose_cause.cause;\n\t\trose->diagnostic = rose_cause.diagnostic;\n\t\treturn 0;\n\t}\n\n\tcase SIOCRSSL2CALL:\n\t\tif (!capable(CAP_NET_ADMIN)) return -EPERM;\n\t\tif (ax25cmp(&rose_callsign, &null_ax25_address) != 0)\n\t\t\tax25_listen_release(&rose_callsign, NULL);\n\t\tif (copy_from_user(&rose_callsign, argp, sizeof(ax25_address)))\n\t\t\treturn -EFAULT;\n\t\tif (ax25cmp(&rose_callsign, &null_ax25_address) != 0)\n\t\t\treturn ax25_listen_register(&rose_callsign, NULL);\n\n\t\treturn 0;\n\n\tcase SIOCRSGL2CALL:\n\t\treturn copy_to_user(argp, &rose_callsign, sizeof(ax25_address)) ? -EFAULT : 0;\n\n\tcase SIOCRSACCEPT:\n\t\tif (rose->state == ROSE_STATE_5) {\n\t\t\trose_write_internal(sk, ROSE_CALL_ACCEPTED);\n\t\t\trose_start_idletimer(sk);\n\t\t\trose->condition = 0x00;\n\t\t\trose->vs        = 0;\n\t\t\trose->va        = 0;\n\t\t\trose->vr        = 0;\n\t\t\trose->vl        = 0;\n\t\t\trose->state     = ROSE_STATE_3;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void *rose_info_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rose_list_lock)\n{\n\tspin_lock_bh(&rose_list_lock);\n\treturn seq_hlist_start_head(&rose_list, *pos);\n}\n\nstatic void *rose_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &rose_list, pos);\n}\n\nstatic void rose_info_stop(struct seq_file *seq, void *v)\n\t__releases(rose_list_lock)\n{\n\tspin_unlock_bh(&rose_list_lock);\n}\n\nstatic int rose_info_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11], rsbuf[11];\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"dest_addr  dest_call src_addr   src_call  dev   lci neigh st vs vr va   t  t1  t2  t3  hb    idle Snd-Q Rcv-Q inode\\n\");\n\n\telse {\n\t\tstruct sock *s = sk_entry(v);\n\t\tstruct rose_sock *rose = rose_sk(s);\n\t\tconst char *devname, *callsign;\n\t\tconst struct net_device *dev = rose->device;\n\n\t\tif (!dev)\n\t\t\tdevname = \"???\";\n\t\telse\n\t\t\tdevname = dev->name;\n\n\t\tseq_printf(seq, \"%-10s %-9s \",\n\t\t\t   rose2asc(rsbuf, &rose->dest_addr),\n\t\t\t   ax2asc(buf, &rose->dest_call));\n\n\t\tif (ax25cmp(&rose->source_call, &null_ax25_address) == 0)\n\t\t\tcallsign = \"??????-?\";\n\t\telse\n\t\t\tcallsign = ax2asc(buf, &rose->source_call);\n\n\t\tseq_printf(seq,\n\t\t\t   \"%-10s %-9s %-5s %3.3X %05d  %d  %d  %d  %d %3lu %3lu %3lu %3lu %3lu %3lu/%03lu %5d %5d %ld\\n\",\n\t\t\trose2asc(rsbuf, &rose->source_addr),\n\t\t\tcallsign,\n\t\t\tdevname,\n\t\t\trose->lci & 0x0FFF,\n\t\t\t(rose->neighbour) ? rose->neighbour->number : 0,\n\t\t\trose->state,\n\t\t\trose->vs,\n\t\t\trose->vr,\n\t\t\trose->va,\n\t\t\tax25_display_timer(&rose->timer) / HZ,\n\t\t\trose->t1 / HZ,\n\t\t\trose->t2 / HZ,\n\t\t\trose->t3 / HZ,\n\t\t\trose->hb / HZ,\n\t\t\tax25_display_timer(&rose->idletimer) / (60 * HZ),\n\t\t\trose->idle / (60 * HZ),\n\t\t\tsk_wmem_alloc_get(s),\n\t\t\tsk_rmem_alloc_get(s),\n\t\t\ts->sk_socket ? SOCK_INODE(s->sk_socket)->i_ino : 0L);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct seq_operations rose_info_seqops = {\n\t.start = rose_info_start,\n\t.next = rose_info_next,\n\t.stop = rose_info_stop,\n\t.show = rose_info_show,\n};\n\nstatic int rose_info_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &rose_info_seqops);\n}\n\nstatic const struct file_operations rose_info_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rose_info_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n#endif\t/* CONFIG_PROC_FS */\n\nstatic const struct net_proto_family rose_family_ops = {\n\t.family\t\t=\tPF_ROSE,\n\t.create\t\t=\trose_create,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic const struct proto_ops rose_proto_ops = {\n\t.family\t\t=\tPF_ROSE,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.release\t=\trose_release,\n\t.bind\t\t=\trose_bind,\n\t.connect\t=\trose_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.accept\t\t=\trose_accept,\n\t.getname\t=\trose_getname,\n\t.poll\t\t=\tdatagram_poll,\n\t.ioctl\t\t=\trose_ioctl,\n\t.listen\t\t=\trose_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.setsockopt\t=\trose_setsockopt,\n\t.getsockopt\t=\trose_getsockopt,\n\t.sendmsg\t=\trose_sendmsg,\n\t.recvmsg\t=\trose_recvmsg,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.sendpage\t=\tsock_no_sendpage,\n};\n\nstatic struct notifier_block rose_dev_notifier = {\n\t.notifier_call\t=\trose_device_event,\n};\n\nstatic struct net_device **dev_rose;\n\nstatic struct ax25_protocol rose_pid = {\n\t.pid\t= AX25_P_ROSE,\n\t.func\t= rose_route_frame\n};\n\nstatic struct ax25_linkfail rose_linkfail_notifier = {\n\t.func\t= rose_link_failed\n};\n\nstatic int __init rose_proto_init(void)\n{\n\tint i;\n\tint rc;\n\n\tif (rose_ndevs > 0x7FFFFFFF/sizeof(struct net_device *)) {\n\t\tprintk(KERN_ERR \"ROSE: rose_proto_init - rose_ndevs parameter to large\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = proto_register(&rose_proto, 0);\n\tif (rc != 0)\n\t\tgoto out;\n\n\trose_callsign = null_ax25_address;\n\n\tdev_rose = kzalloc(rose_ndevs * sizeof(struct net_device *), GFP_KERNEL);\n\tif (dev_rose == NULL) {\n\t\tprintk(KERN_ERR \"ROSE: rose_proto_init - unable to allocate device structure\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_proto_unregister;\n\t}\n\n\tfor (i = 0; i < rose_ndevs; i++) {\n\t\tstruct net_device *dev;\n\t\tchar name[IFNAMSIZ];\n\n\t\tsprintf(name, \"rose%d\", i);\n\t\tdev = alloc_netdev(0, name, rose_setup);\n\t\tif (!dev) {\n\t\t\tprintk(KERN_ERR \"ROSE: rose_proto_init - unable to allocate memory\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\trc = register_netdev(dev);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"ROSE: netdevice registration failed\\n\");\n\t\t\tfree_netdev(dev);\n\t\t\tgoto fail;\n\t\t}\n\t\trose_set_lockdep_key(dev);\n\t\tdev_rose[i] = dev;\n\t}\n\n\tsock_register(&rose_family_ops);\n\tregister_netdevice_notifier(&rose_dev_notifier);\n\n\tax25_register_pid(&rose_pid);\n\tax25_linkfail_register(&rose_linkfail_notifier);\n\n#ifdef CONFIG_SYSCTL\n\trose_register_sysctl();\n#endif\n\trose_loopback_init();\n\n\trose_add_loopback_neigh();\n\n\tproc_net_fops_create(&init_net, \"rose\", S_IRUGO, &rose_info_fops);\n\tproc_net_fops_create(&init_net, \"rose_neigh\", S_IRUGO, &rose_neigh_fops);\n\tproc_net_fops_create(&init_net, \"rose_nodes\", S_IRUGO, &rose_nodes_fops);\n\tproc_net_fops_create(&init_net, \"rose_routes\", S_IRUGO, &rose_routes_fops);\nout:\n\treturn rc;\nfail:\n\twhile (--i >= 0) {\n\t\tunregister_netdev(dev_rose[i]);\n\t\tfree_netdev(dev_rose[i]);\n\t}\n\tkfree(dev_rose);\nout_proto_unregister:\n\tproto_unregister(&rose_proto);\n\tgoto out;\n}\nmodule_init(rose_proto_init);\n\nmodule_param(rose_ndevs, int, 0);\nMODULE_PARM_DESC(rose_ndevs, \"number of ROSE devices\");\n\nMODULE_AUTHOR(\"Jonathan Naylor G4KLX <g4klx@g4klx.demon.co.uk>\");\nMODULE_DESCRIPTION(\"The amateur radio ROSE network layer protocol\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_ROSE);\n\nstatic void __exit rose_exit(void)\n{\n\tint i;\n\n\tproc_net_remove(&init_net, \"rose\");\n\tproc_net_remove(&init_net, \"rose_neigh\");\n\tproc_net_remove(&init_net, \"rose_nodes\");\n\tproc_net_remove(&init_net, \"rose_routes\");\n\trose_loopback_clear();\n\n\trose_rt_free();\n\n\tax25_protocol_release(AX25_P_ROSE);\n\tax25_linkfail_release(&rose_linkfail_notifier);\n\n\tif (ax25cmp(&rose_callsign, &null_ax25_address) != 0)\n\t\tax25_listen_release(&rose_callsign, NULL);\n\n#ifdef CONFIG_SYSCTL\n\trose_unregister_sysctl();\n#endif\n\tunregister_netdevice_notifier(&rose_dev_notifier);\n\n\tsock_unregister(PF_ROSE);\n\n\tfor (i = 0; i < rose_ndevs; i++) {\n\t\tstruct net_device *dev = dev_rose[i];\n\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tfree_netdev(dev);\n\t\t}\n\t}\n\n\tkfree(dev_rose);\n\tproto_unregister(&rose_proto);\n}\n\nmodule_exit(rose_exit);\n", "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Copyright (C) Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n */\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/timer.h>\n#include <net/ax25.h>\n#include <linux/skbuff.h>\n#include <net/rose.h>\n#include <linux/init.h>\n\nstatic struct sk_buff_head loopback_queue;\nstatic struct timer_list loopback_timer;\n\nstatic void rose_set_loopback_timer(void);\n\nvoid rose_loopback_init(void)\n{\n\tskb_queue_head_init(&loopback_queue);\n\n\tinit_timer(&loopback_timer);\n}\n\nstatic int rose_loopback_running(void)\n{\n\treturn timer_pending(&loopback_timer);\n}\n\nint rose_loopback_queue(struct sk_buff *skb, struct rose_neigh *neigh)\n{\n\tstruct sk_buff *skbn;\n\n\tskbn = skb_clone(skb, GFP_ATOMIC);\n\n\tkfree_skb(skb);\n\n\tif (skbn != NULL) {\n\t\tskb_queue_tail(&loopback_queue, skbn);\n\n\t\tif (!rose_loopback_running())\n\t\t\trose_set_loopback_timer();\n\t}\n\n\treturn 1;\n}\n\nstatic void rose_loopback_timer(unsigned long);\n\nstatic void rose_set_loopback_timer(void)\n{\n\tdel_timer(&loopback_timer);\n\n\tloopback_timer.data     = 0;\n\tloopback_timer.function = &rose_loopback_timer;\n\tloopback_timer.expires  = jiffies + 10;\n\n\tadd_timer(&loopback_timer);\n}\n\nstatic void rose_loopback_timer(unsigned long param)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\trose_address *dest;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci_i, lci_o;\n\n\twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n\t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\t\tframetype = skb->data[2];\n\t\tdest      = (rose_address *)(skb->data + 4);\n\t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n\n\t\tskb_reset_transport_header(skb);\n\n\t\tsk = rose_find_socket(lci_o, rose_loopback_neigh);\n\t\tif (sk) {\n\t\t\tif (rose_process_rx_frame(sk, skb) == 0)\n\t\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tif ((dev = rose_dev_get(dest)) != NULL) {\n\t\t\t\tif (rose_rx_call_request(skb, dev, rose_loopback_neigh, lci_o) == 0)\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}\n\nvoid __exit rose_loopback_clear(void)\n{\n\tstruct sk_buff *skb;\n\n\tdel_timer(&loopback_timer);\n\n\twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n\t\tskb->sk = NULL;\n\t\tkfree_skb(skb);\n\t}\n}\n", "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Copyright (C) Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n * Copyright (C) Terry Dawson VK2KTJ (terry@animats.net)\n */\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <net/arp.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <asm/system.h>\n#include <asm/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\t/* For TIOCINQ/OUTQ */\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/netfilter.h>\n#include <linux/init.h>\n#include <net/rose.h>\n#include <linux/seq_file.h>\n\nstatic unsigned int rose_neigh_no = 1;\n\nstatic struct rose_node  *rose_node_list;\nstatic DEFINE_SPINLOCK(rose_node_list_lock);\nstatic struct rose_neigh *rose_neigh_list;\nstatic DEFINE_SPINLOCK(rose_neigh_list_lock);\nstatic struct rose_route *rose_route_list;\nstatic DEFINE_SPINLOCK(rose_route_list_lock);\n\nstruct rose_neigh *rose_loopback_neigh;\n\n/*\n *\tAdd a new route to a node, and in the process add the node and the\n *\tneighbour if it is new.\n */\nstatic int __must_check rose_add_node(struct rose_route_struct *rose_route,\n\tstruct net_device *dev)\n{\n\tstruct rose_node  *rose_node, *rose_tmpn, *rose_tmpp;\n\tstruct rose_neigh *rose_neigh;\n\tint i, res = 0;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tspin_lock_bh(&rose_neigh_list_lock);\n\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == rose_route->mask) &&\n\t\t    (rosecmpm(&rose_route->address, &rose_node->address,\n\t\t\t      rose_route->mask) == 0))\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\n\tif (rose_node != NULL && rose_node->loopback) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (ax25cmp(&rose_route->neighbour,\n\t\t\t    &rose_neigh->callsign) == 0 &&\n\t\t    rose_neigh->dev == dev)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh == NULL) {\n\t\trose_neigh = kmalloc(sizeof(*rose_neigh), GFP_ATOMIC);\n\t\tif (rose_neigh == NULL) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\trose_neigh->callsign  = rose_route->neighbour;\n\t\trose_neigh->digipeat  = NULL;\n\t\trose_neigh->ax25      = NULL;\n\t\trose_neigh->dev       = dev;\n\t\trose_neigh->count     = 0;\n\t\trose_neigh->use       = 0;\n\t\trose_neigh->dce_mode  = 0;\n\t\trose_neigh->loopback  = 0;\n\t\trose_neigh->number    = rose_neigh_no++;\n\t\trose_neigh->restarted = 0;\n\n\t\tskb_queue_head_init(&rose_neigh->queue);\n\n\t\tinit_timer(&rose_neigh->ftimer);\n\t\tinit_timer(&rose_neigh->t0timer);\n\n\t\tif (rose_route->ndigis != 0) {\n\t\t\trose_neigh->digipeat =\n\t\t\t\tkmalloc(sizeof(ax25_digi), GFP_ATOMIC);\n\t\t\tif (rose_neigh->digipeat == NULL) {\n\t\t\t\tkfree(rose_neigh);\n\t\t\t\tres = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trose_neigh->digipeat->ndigi      = rose_route->ndigis;\n\t\t\trose_neigh->digipeat->lastrepeat = -1;\n\n\t\t\tfor (i = 0; i < rose_route->ndigis; i++) {\n\t\t\t\trose_neigh->digipeat->calls[i]    =\n\t\t\t\t\trose_route->digipeaters[i];\n\t\t\t\trose_neigh->digipeat->repeated[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\trose_neigh->next = rose_neigh_list;\n\t\trose_neigh_list  = rose_neigh;\n\t}\n\n\t/*\n\t * This is a new node to be inserted into the list. Find where it needs\n\t * to be inserted into the list, and insert it. We want to be sure\n\t * to order the list in descending order of mask size to ensure that\n\t * later when we are searching this list the first match will be the\n\t * best match.\n\t */\n\tif (rose_node == NULL) {\n\t\trose_tmpn = rose_node_list;\n\t\trose_tmpp = NULL;\n\n\t\twhile (rose_tmpn != NULL) {\n\t\t\tif (rose_tmpn->mask > rose_route->mask) {\n\t\t\t\trose_tmpp = rose_tmpn;\n\t\t\t\trose_tmpn = rose_tmpn->next;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* create new node */\n\t\trose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC);\n\t\tif (rose_node == NULL) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\trose_node->address      = rose_route->address;\n\t\trose_node->mask         = rose_route->mask;\n\t\trose_node->count        = 1;\n\t\trose_node->loopback     = 0;\n\t\trose_node->neighbour[0] = rose_neigh;\n\n\t\tif (rose_tmpn == NULL) {\n\t\t\tif (rose_tmpp == NULL) {\t/* Empty list */\n\t\t\t\trose_node_list  = rose_node;\n\t\t\t\trose_node->next = NULL;\n\t\t\t} else {\n\t\t\t\trose_tmpp->next = rose_node;\n\t\t\t\trose_node->next = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (rose_tmpp == NULL) {\t/* 1st node */\n\t\t\t\trose_node->next = rose_node_list;\n\t\t\t\trose_node_list  = rose_node;\n\t\t\t} else {\n\t\t\t\trose_tmpp->next = rose_node;\n\t\t\t\trose_node->next = rose_tmpn;\n\t\t\t}\n\t\t}\n\t\trose_neigh->count++;\n\n\t\tgoto out;\n\t}\n\n\t/* We have space, slot it in */\n\tif (rose_node->count < 3) {\n\t\trose_node->neighbour[rose_node->count] = rose_neigh;\n\t\trose_node->count++;\n\t\trose_neigh->count++;\n\t}\n\nout:\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\tspin_unlock_bh(&rose_node_list_lock);\n\n\treturn res;\n}\n\n/*\n * Caller is holding rose_node_list_lock.\n */\nstatic void rose_remove_node(struct rose_node *rose_node)\n{\n\tstruct rose_node *s;\n\n\tif ((s = rose_node_list) == rose_node) {\n\t\trose_node_list = rose_node->next;\n\t\tkfree(rose_node);\n\t\treturn;\n\t}\n\n\twhile (s != NULL && s->next != NULL) {\n\t\tif (s->next == rose_node) {\n\t\t\ts->next = rose_node->next;\n\t\t\tkfree(rose_node);\n\t\t\treturn;\n\t\t}\n\n\t\ts = s->next;\n\t}\n}\n\n/*\n * Caller is holding rose_neigh_list_lock.\n */\nstatic void rose_remove_neigh(struct rose_neigh *rose_neigh)\n{\n\tstruct rose_neigh *s;\n\n\trose_stop_ftimer(rose_neigh);\n\trose_stop_t0timer(rose_neigh);\n\n\tskb_queue_purge(&rose_neigh->queue);\n\n\tif ((s = rose_neigh_list) == rose_neigh) {\n\t\trose_neigh_list = rose_neigh->next;\n\t\tif (rose_neigh->ax25)\n\t\t\tax25_cb_put(rose_neigh->ax25);\n\t\tkfree(rose_neigh->digipeat);\n\t\tkfree(rose_neigh);\n\t\treturn;\n\t}\n\n\twhile (s != NULL && s->next != NULL) {\n\t\tif (s->next == rose_neigh) {\n\t\t\ts->next = rose_neigh->next;\n\t\t\tif (rose_neigh->ax25)\n\t\t\t\tax25_cb_put(rose_neigh->ax25);\n\t\t\tkfree(rose_neigh->digipeat);\n\t\t\tkfree(rose_neigh);\n\t\t\treturn;\n\t\t}\n\n\t\ts = s->next;\n\t}\n}\n\n/*\n * Caller is holding rose_route_list_lock.\n */\nstatic void rose_remove_route(struct rose_route *rose_route)\n{\n\tstruct rose_route *s;\n\n\tif (rose_route->neigh1 != NULL)\n\t\trose_route->neigh1->use--;\n\n\tif (rose_route->neigh2 != NULL)\n\t\trose_route->neigh2->use--;\n\n\tif ((s = rose_route_list) == rose_route) {\n\t\trose_route_list = rose_route->next;\n\t\tkfree(rose_route);\n\t\treturn;\n\t}\n\n\twhile (s != NULL && s->next != NULL) {\n\t\tif (s->next == rose_route) {\n\t\t\ts->next = rose_route->next;\n\t\t\tkfree(rose_route);\n\t\t\treturn;\n\t\t}\n\n\t\ts = s->next;\n\t}\n}\n\n/*\n *\t\"Delete\" a node. Strictly speaking remove a route to a node. The node\n *\tis only deleted if no routes are left to it.\n */\nstatic int rose_del_node(struct rose_route_struct *rose_route,\n\tstruct net_device *dev)\n{\n\tstruct rose_node  *rose_node;\n\tstruct rose_neigh *rose_neigh;\n\tint i, err = 0;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tspin_lock_bh(&rose_neigh_list_lock);\n\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == rose_route->mask) &&\n\t\t    (rosecmpm(&rose_route->address, &rose_node->address,\n\t\t\t      rose_route->mask) == 0))\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\n\tif (rose_node == NULL || rose_node->loopback) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (ax25cmp(&rose_route->neighbour,\n\t\t\t    &rose_neigh->callsign) == 0 &&\n\t\t    rose_neigh->dev == dev)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh == NULL) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < rose_node->count; i++) {\n\t\tif (rose_node->neighbour[i] == rose_neigh) {\n\t\t\trose_neigh->count--;\n\n\t\t\tif (rose_neigh->count == 0 && rose_neigh->use == 0)\n\t\t\t\trose_remove_neigh(rose_neigh);\n\n\t\t\trose_node->count--;\n\n\t\t\tif (rose_node->count == 0) {\n\t\t\t\trose_remove_node(rose_node);\n\t\t\t} else {\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\trose_node->neighbour[0] =\n\t\t\t\t\t\trose_node->neighbour[1];\n\t\t\t\tcase 1:\n\t\t\t\t\trose_node->neighbour[1] =\n\t\t\t\t\t\trose_node->neighbour[2];\n\t\t\t\tcase 2:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = -EINVAL;\n\nout:\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\tspin_unlock_bh(&rose_node_list_lock);\n\n\treturn err;\n}\n\n/*\n *\tAdd the loopback neighbour.\n */\nvoid rose_add_loopback_neigh(void)\n{\n\tstruct rose_neigh *sn;\n\n\trose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);\n\tif (!rose_loopback_neigh)\n\t\treturn;\n\tsn = rose_loopback_neigh;\n\n\tsn->callsign  = null_ax25_address;\n\tsn->digipeat  = NULL;\n\tsn->ax25      = NULL;\n\tsn->dev       = NULL;\n\tsn->count     = 0;\n\tsn->use       = 0;\n\tsn->dce_mode  = 1;\n\tsn->loopback  = 1;\n\tsn->number    = rose_neigh_no++;\n\tsn->restarted = 1;\n\n\tskb_queue_head_init(&sn->queue);\n\n\tinit_timer(&sn->ftimer);\n\tinit_timer(&sn->t0timer);\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\tsn->next = rose_neigh_list;\n\trose_neigh_list           = sn;\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}\n\n/*\n *\tAdd a loopback node.\n */\nint rose_add_loopback_node(rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\tint err = 0;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t     (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t     rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\n\tif (rose_node != NULL)\n\t\tgoto out;\n\n\tif ((rose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC)) == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trose_node->address      = *address;\n\trose_node->mask         = 10;\n\trose_node->count        = 1;\n\trose_node->loopback     = 1;\n\trose_node->neighbour[0] = rose_loopback_neigh;\n\n\t/* Insert at the head of list. Address is always mask=10 */\n\trose_node->next = rose_node_list;\n\trose_node_list  = rose_node;\n\n\trose_loopback_neigh->count++;\n\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n\n\treturn err;\n}\n\n/*\n *\tDelete a loopback node.\n */\nvoid rose_del_loopback_node(rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t    (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t    rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\n\tif (rose_node == NULL)\n\t\tgoto out;\n\n\trose_remove_node(rose_node);\n\n\trose_loopback_neigh->count--;\n\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n}\n\n/*\n *\tA device has been removed. Remove its routes and neighbours.\n */\nvoid rose_rt_device_down(struct net_device *dev)\n{\n\tstruct rose_neigh *s, *rose_neigh;\n\tstruct rose_node  *t, *rose_node;\n\tint i;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tspin_lock_bh(&rose_neigh_list_lock);\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\ts          = rose_neigh;\n\t\trose_neigh = rose_neigh->next;\n\n\t\tif (s->dev != dev)\n\t\t\tcontinue;\n\n\t\trose_node = rose_node_list;\n\n\t\twhile (rose_node != NULL) {\n\t\t\tt         = rose_node;\n\t\t\trose_node = rose_node->next;\n\n\t\t\tfor (i = 0; i < t->count; i++) {\n\t\t\t\tif (t->neighbour[i] != s)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tt->count--;\n\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tt->neighbour[0] = t->neighbour[1];\n\t\t\t\tcase 1:\n\t\t\t\t\tt->neighbour[1] = t->neighbour[2];\n\t\t\t\tcase 2:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t->count <= 0)\n\t\t\t\trose_remove_node(t);\n\t\t}\n\n\t\trose_remove_neigh(s);\n\t}\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\tspin_unlock_bh(&rose_node_list_lock);\n}\n\n#if 0 /* Currently unused */\n/*\n *\tA device has been removed. Remove its links.\n */\nvoid rose_route_device_down(struct net_device *dev)\n{\n\tstruct rose_route *s, *rose_route;\n\n\tspin_lock_bh(&rose_route_list_lock);\n\trose_route = rose_route_list;\n\twhile (rose_route != NULL) {\n\t\ts          = rose_route;\n\t\trose_route = rose_route->next;\n\n\t\tif (s->neigh1->dev == dev || s->neigh2->dev == dev)\n\t\t\trose_remove_route(s);\n\t}\n\tspin_unlock_bh(&rose_route_list_lock);\n}\n#endif\n\n/*\n *\tClear all nodes and neighbours out, except for neighbours with\n *\tactive connections going through them.\n *  Do not clear loopback neighbour and nodes.\n */\nstatic int rose_clear_routes(void)\n{\n\tstruct rose_neigh *s, *rose_neigh;\n\tstruct rose_node  *t, *rose_node;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tspin_lock_bh(&rose_neigh_list_lock);\n\n\trose_neigh = rose_neigh_list;\n\trose_node  = rose_node_list;\n\n\twhile (rose_node != NULL) {\n\t\tt         = rose_node;\n\t\trose_node = rose_node->next;\n\t\tif (!t->loopback)\n\t\t\trose_remove_node(t);\n\t}\n\n\twhile (rose_neigh != NULL) {\n\t\ts          = rose_neigh;\n\t\trose_neigh = rose_neigh->next;\n\n\t\tif (s->use == 0 && !s->loopback) {\n\t\t\ts->count = 0;\n\t\t\trose_remove_neigh(s);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\tspin_unlock_bh(&rose_node_list_lock);\n\n\treturn 0;\n}\n\n/*\n *\tCheck that the device given is a valid AX.25 interface that is \"up\".\n * \tcalled whith RTNL\n */\nstatic struct net_device *rose_ax25_dev_find(char *devname)\n{\n\tstruct net_device *dev;\n\n\tif ((dev = __dev_get_by_name(&init_net, devname)) == NULL)\n\t\treturn NULL;\n\n\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_AX25)\n\t\treturn dev;\n\n\treturn NULL;\n}\n\n/*\n *\tFind the first active ROSE device, usually \"rose0\".\n */\nstruct net_device *rose_dev_first(void)\n{\n\tstruct net_device *dev, *first = NULL;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, dev) {\n\t\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE)\n\t\t\tif (first == NULL || strncmp(dev->name, first->name, 3) < 0)\n\t\t\t\tfirst = dev;\n\t}\n\trcu_read_unlock();\n\n\treturn first;\n}\n\n/*\n *\tFind the ROSE device for the given address.\n */\nstruct net_device *rose_dev_get(rose_address *addr)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, dev) {\n\t\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE && rosecmp(addr, (rose_address *)dev->dev_addr) == 0) {\n\t\t\tdev_hold(dev);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdev = NULL;\nout:\n\trcu_read_unlock();\n\treturn dev;\n}\n\nstatic int rose_dev_exists(rose_address *addr)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, dev) {\n\t\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE && rosecmp(addr, (rose_address *)dev->dev_addr) == 0)\n\t\t\tgoto out;\n\t}\n\tdev = NULL;\nout:\n\trcu_read_unlock();\n\treturn dev != NULL;\n}\n\n\n\n\nstruct rose_route *rose_route_free_lci(unsigned int lci, struct rose_neigh *neigh)\n{\n\tstruct rose_route *rose_route;\n\n\tfor (rose_route = rose_route_list; rose_route != NULL; rose_route = rose_route->next)\n\t\tif ((rose_route->neigh1 == neigh && rose_route->lci1 == lci) ||\n\t\t    (rose_route->neigh2 == neigh && rose_route->lci2 == lci))\n\t\t\treturn rose_route;\n\n\treturn NULL;\n}\n\n/*\n *\tFind a neighbour or a route given a ROSE address.\n */\nstruct rose_neigh *rose_get_neigh(rose_address *addr, unsigned char *cause,\n\tunsigned char *diagnostic, int route_frame)\n{\n\tstruct rose_neigh *res = NULL;\n\tstruct rose_node *node;\n\tint failed = 0;\n\tint i;\n\n\tif (!route_frame) spin_lock_bh(&rose_node_list_lock);\n\tfor (node = rose_node_list; node != NULL; node = node->next) {\n\t\tif (rosecmpm(addr, &node->address, node->mask) == 0) {\n\t\t\tfor (i = 0; i < node->count; i++) {\n\t\t\t\tif (node->neighbour[i]->restarted) {\n\t\t\t\t\tres = node->neighbour[i];\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!route_frame) { /* connect request */\n\t\tfor (node = rose_node_list; node != NULL; node = node->next) {\n\t\t\tif (rosecmpm(addr, &node->address, node->mask) == 0) {\n\t\t\t\tfor (i = 0; i < node->count; i++) {\n\t\t\t\t\tif (!rose_ftimer_running(node->neighbour[i])) {\n\t\t\t\t\t\tres = node->neighbour[i];\n\t\t\t\t\t\tfailed = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tfailed = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (failed) {\n\t\t*cause      = ROSE_OUT_OF_ORDER;\n\t\t*diagnostic = 0;\n\t} else {\n\t\t*cause      = ROSE_NOT_OBTAINABLE;\n\t\t*diagnostic = 0;\n\t}\n\nout:\n\tif (!route_frame) spin_unlock_bh(&rose_node_list_lock);\n\treturn res;\n}\n\n/*\n *\tHandle the ioctls that control the routing functions.\n */\nint rose_rt_ioctl(unsigned int cmd, void __user *arg)\n{\n\tstruct rose_route_struct rose_route;\n\tstruct net_device *dev;\n\tint err;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\t\tif (copy_from_user(&rose_route, arg, sizeof(struct rose_route_struct)))\n\t\t\treturn -EFAULT;\n\t\tif ((dev = rose_ax25_dev_find(rose_route.device)) == NULL)\n\t\t\treturn -EINVAL;\n\t\tif (rose_dev_exists(&rose_route.address)) /* Can't add routes to ourself */\n\t\t\treturn -EINVAL;\n\t\tif (rose_route.mask > 10) /* Mask can't be more than 10 digits */\n\t\t\treturn -EINVAL;\n\t\tif (rose_route.ndigis > AX25_MAX_DIGIS)\n\t\t\treturn -EINVAL;\n\t\terr = rose_add_node(&rose_route, dev);\n\t\treturn err;\n\n\tcase SIOCDELRT:\n\t\tif (copy_from_user(&rose_route, arg, sizeof(struct rose_route_struct)))\n\t\t\treturn -EFAULT;\n\t\tif ((dev = rose_ax25_dev_find(rose_route.device)) == NULL)\n\t\t\treturn -EINVAL;\n\t\terr = rose_del_node(&rose_route, dev);\n\t\treturn err;\n\n\tcase SIOCRSCLRRT:\n\t\treturn rose_clear_routes();\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void rose_del_route_by_neigh(struct rose_neigh *rose_neigh)\n{\n\tstruct rose_route *rose_route, *s;\n\n\trose_neigh->restarted = 0;\n\n\trose_stop_t0timer(rose_neigh);\n\trose_start_ftimer(rose_neigh);\n\n\tskb_queue_purge(&rose_neigh->queue);\n\n\tspin_lock_bh(&rose_route_list_lock);\n\n\trose_route = rose_route_list;\n\n\twhile (rose_route != NULL) {\n\t\tif ((rose_route->neigh1 == rose_neigh && rose_route->neigh2 == rose_neigh) ||\n\t\t    (rose_route->neigh1 == rose_neigh && rose_route->neigh2 == NULL)       ||\n\t\t    (rose_route->neigh2 == rose_neigh && rose_route->neigh1 == NULL)) {\n\t\t\ts = rose_route->next;\n\t\t\trose_remove_route(rose_route);\n\t\t\trose_route = s;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rose_route->neigh1 == rose_neigh) {\n\t\t\trose_route->neigh1->use--;\n\t\t\trose_route->neigh1 = NULL;\n\t\t\trose_transmit_clear_request(rose_route->neigh2, rose_route->lci2, ROSE_OUT_OF_ORDER, 0);\n\t\t}\n\n\t\tif (rose_route->neigh2 == rose_neigh) {\n\t\t\trose_route->neigh2->use--;\n\t\t\trose_route->neigh2 = NULL;\n\t\t\trose_transmit_clear_request(rose_route->neigh1, rose_route->lci1, ROSE_OUT_OF_ORDER, 0);\n\t\t}\n\n\t\trose_route = rose_route->next;\n\t}\n\tspin_unlock_bh(&rose_route_list_lock);\n}\n\n/*\n * \tA level 2 link has timed out, therefore it appears to be a poor link,\n *\tthen don't use that neighbour until it is reset. Blow away all through\n *\troutes and connections using this route.\n */\nvoid rose_link_failed(ax25_cb *ax25, int reason)\n{\n\tstruct rose_neigh *rose_neigh;\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (rose_neigh->ax25 == ax25)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh != NULL) {\n\t\trose_neigh->ax25 = NULL;\n\t\tax25_cb_put(ax25);\n\n\t\trose_del_route_by_neigh(rose_neigh);\n\t\trose_kill_by_neigh(rose_neigh);\n\t}\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}\n\n/*\n * \tA device has been \"downed\" remove its link status. Blow away all\n *\tthrough routes and connections that use this device.\n */\nvoid rose_link_device_down(struct net_device *dev)\n{\n\tstruct rose_neigh *rose_neigh;\n\n\tfor (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next) {\n\t\tif (rose_neigh->dev == dev) {\n\t\t\trose_del_route_by_neigh(rose_neigh);\n\t\t\trose_kill_by_neigh(rose_neigh);\n\t\t}\n\t}\n}\n\n/*\n *\tRoute a frame to an appropriate AX.25 connection.\n */\nint rose_route_frame(struct sk_buff *skb, ax25_cb *ax25)\n{\n\tstruct rose_neigh *rose_neigh, *new_neigh;\n\tstruct rose_route *rose_route;\n\tstruct rose_facilities_struct facilities;\n\trose_address *src_addr, *dest_addr;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci, new_lci;\n\tunsigned char cause, diagnostic;\n\tstruct net_device *dev;\n\tint len, res = 0;\n\tchar buf[11];\n\n#if 0\n\tif (call_in_firewall(PF_ROSE, skb->dev, skb->data, NULL, &skb) != FW_ACCEPT)\n\t\treturn res;\n#endif\n\n\tframetype = skb->data[2];\n\tlci = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\tsrc_addr  = (rose_address *)(skb->data + 9);\n\tdest_addr = (rose_address *)(skb->data + 4);\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\tspin_lock_bh(&rose_route_list_lock);\n\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (ax25cmp(&ax25->dest_addr, &rose_neigh->callsign) == 0 &&\n\t\t    ax25->ax25_dev->dev == rose_neigh->dev)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh == NULL) {\n\t\tprintk(\"rose_route : unknown neighbour or device %s\\n\",\n\t\t       ax2asc(buf, &ax25->dest_addr));\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tObviously the link is working, halt the ftimer.\n\t */\n\trose_stop_ftimer(rose_neigh);\n\n\t/*\n\t *\tLCI of zero is always for us, and its always a restart\n\t * \tframe.\n\t */\n\tif (lci == 0) {\n\t\trose_link_rx_restart(skb, rose_neigh, frametype);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tFind an existing socket.\n\t */\n\tif ((sk = rose_find_socket(lci, rose_neigh)) != NULL) {\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tstruct rose_sock *rose = rose_sk(sk);\n\n\t\t\t/* Remove an existing unused socket */\n\t\t\trose_clear_queues(sk);\n\t\t\trose->cause\t = ROSE_NETWORK_CONGESTION;\n\t\t\trose->diagnostic = 0;\n\t\t\trose->neighbour->use--;\n\t\t\trose->neighbour\t = NULL;\n\t\t\trose->lci\t = 0;\n\t\t\trose->state\t = ROSE_STATE_0;\n\t\t\tsk->sk_state\t = TCP_CLOSE;\n\t\t\tsk->sk_err\t = 0;\n\t\t\tsk->sk_shutdown\t |= SEND_SHUTDOWN;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\tsock_set_flag(sk, SOCK_DEAD);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tskb_reset_transport_header(skb);\n\t\t\tres = rose_process_rx_frame(sk, skb);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tIs is a Call Request and is it for us ?\n\t */\n\tif (frametype == ROSE_CALL_REQUEST)\n\t\tif ((dev = rose_dev_get(dest_addr)) != NULL) {\n\t\t\tres = rose_rx_call_request(skb, dev, rose_neigh, lci);\n\t\t\tdev_put(dev);\n\t\t\tgoto out;\n\t\t}\n\n\tif (!sysctl_rose_routing_control) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NOT_OBTAINABLE, 0);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tRoute it to the next in line if we have an entry for it.\n\t */\n\trose_route = rose_route_list;\n\twhile (rose_route != NULL) {\n\t\tif (rose_route->lci1 == lci &&\n\t\t    rose_route->neigh1 == rose_neigh) {\n\t\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\t\t/* F6FBB - Remove an existing unused route */\n\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tbreak;\n\t\t\t} else if (rose_route->neigh2 != NULL) {\n\t\t\t\tskb->data[0] &= 0xF0;\n\t\t\t\tskb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;\n\t\t\t\tskb->data[1]  = (rose_route->lci2 >> 0) & 0xFF;\n\t\t\t\trose_transmit_link(skb, rose_route->neigh2);\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tres = 1;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (rose_route->lci2 == lci &&\n\t\t    rose_route->neigh2 == rose_neigh) {\n\t\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\t\t/* F6FBB - Remove an existing unused route */\n\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tbreak;\n\t\t\t} else if (rose_route->neigh1 != NULL) {\n\t\t\t\tskb->data[0] &= 0xF0;\n\t\t\t\tskb->data[0] |= (rose_route->lci1 >> 8) & 0x0F;\n\t\t\t\tskb->data[1]  = (rose_route->lci1 >> 0) & 0xFF;\n\t\t\t\trose_transmit_link(skb, rose_route->neigh1);\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tres = 1;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trose_route = rose_route->next;\n\t}\n\n\t/*\n\t *\tWe know that:\n\t *\t1. The frame isn't for us,\n\t *\t2. It isn't \"owned\" by any existing route.\n\t */\n\tif (frametype != ROSE_CALL_REQUEST) {\t/* XXX */\n\t\tres = 0;\n\t\tgoto out;\n\t}\n\n\tlen  = (((skb->data[3] >> 4) & 0x0F) + 1) >> 1;\n\tlen += (((skb->data[3] >> 0) & 0x0F) + 1) >> 1;\n\n\tmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\n\n\tif (!rose_parse_facilities(skb->data + len + 4, &facilities)) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_INVALID_FACILITY, 76);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tCheck for routing loops.\n\t */\n\trose_route = rose_route_list;\n\twhile (rose_route != NULL) {\n\t\tif (rose_route->rand == facilities.rand &&\n\t\t    rosecmp(src_addr, &rose_route->src_addr) == 0 &&\n\t\t    ax25cmp(&facilities.dest_call, &rose_route->src_call) == 0 &&\n\t\t    ax25cmp(&facilities.source_call, &rose_route->dest_call) == 0) {\n\t\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NOT_OBTAINABLE, 120);\n\t\t\tgoto out;\n\t\t}\n\t\trose_route = rose_route->next;\n\t}\n\n\tif ((new_neigh = rose_get_neigh(dest_addr, &cause, &diagnostic, 1)) == NULL) {\n\t\trose_transmit_clear_request(rose_neigh, lci, cause, diagnostic);\n\t\tgoto out;\n\t}\n\n\tif ((new_lci = rose_new_lci(new_neigh)) == 0) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NETWORK_CONGESTION, 71);\n\t\tgoto out;\n\t}\n\n\tif ((rose_route = kmalloc(sizeof(*rose_route), GFP_ATOMIC)) == NULL) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NETWORK_CONGESTION, 120);\n\t\tgoto out;\n\t}\n\n\trose_route->lci1      = lci;\n\trose_route->src_addr  = *src_addr;\n\trose_route->dest_addr = *dest_addr;\n\trose_route->src_call  = facilities.dest_call;\n\trose_route->dest_call = facilities.source_call;\n\trose_route->rand      = facilities.rand;\n\trose_route->neigh1    = rose_neigh;\n\trose_route->lci2      = new_lci;\n\trose_route->neigh2    = new_neigh;\n\n\trose_route->neigh1->use++;\n\trose_route->neigh2->use++;\n\n\trose_route->next = rose_route_list;\n\trose_route_list  = rose_route;\n\n\tskb->data[0] &= 0xF0;\n\tskb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;\n\tskb->data[1]  = (rose_route->lci2 >> 0) & 0xFF;\n\n\trose_transmit_link(skb, rose_route->neigh2);\n\tres = 1;\n\nout:\n\tspin_unlock_bh(&rose_route_list_lock);\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\n\treturn res;\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *rose_node_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rose_node_list_lock)\n{\n\tstruct rose_node *rose_node;\n\tint i = 1;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (rose_node = rose_node_list; rose_node && i < *pos;\n\t     rose_node = rose_node->next, ++i);\n\n\treturn (i == *pos) ? rose_node : NULL;\n}\n\nstatic void *rose_node_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\n\treturn (v == SEQ_START_TOKEN) ? rose_node_list\n\t\t: ((struct rose_node *)v)->next;\n}\n\nstatic void rose_node_stop(struct seq_file *seq, void *v)\n\t__releases(rose_node_list_lock)\n{\n\tspin_unlock_bh(&rose_node_list_lock);\n}\n\nstatic int rose_node_show(struct seq_file *seq, void *v)\n{\n\tchar rsbuf[11];\n\tint i;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"address    mask n neigh neigh neigh\\n\");\n\telse {\n\t\tconst struct rose_node *rose_node = v;\n\t\t/* if (rose_node->loopback) {\n\t\t\tseq_printf(seq, \"%-10s %04d 1 loopback\\n\",\n\t\t\t\t   rose2asc(rsbuf, &rose_node->address),\n\t\t\t\t   rose_node->mask);\n\t\t} else { */\n\t\t\tseq_printf(seq, \"%-10s %04d %d\",\n\t\t\t\t   rose2asc(rsbuf, &rose_node->address),\n\t\t\t\t   rose_node->mask,\n\t\t\t\t   rose_node->count);\n\n\t\t\tfor (i = 0; i < rose_node->count; i++)\n\t\t\t\tseq_printf(seq, \" %05d\",\n\t\t\t\t\trose_node->neighbour[i]->number);\n\n\t\t\tseq_puts(seq, \"\\n\");\n\t\t/* } */\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations rose_node_seqops = {\n\t.start = rose_node_start,\n\t.next = rose_node_next,\n\t.stop = rose_node_stop,\n\t.show = rose_node_show,\n};\n\nstatic int rose_nodes_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &rose_node_seqops);\n}\n\nconst struct file_operations rose_nodes_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rose_nodes_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic void *rose_neigh_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rose_neigh_list_lock)\n{\n\tstruct rose_neigh *rose_neigh;\n\tint i = 1;\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (rose_neigh = rose_neigh_list; rose_neigh && i < *pos;\n\t     rose_neigh = rose_neigh->next, ++i);\n\n\treturn (i == *pos) ? rose_neigh : NULL;\n}\n\nstatic void *rose_neigh_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\n\treturn (v == SEQ_START_TOKEN) ? rose_neigh_list\n\t\t: ((struct rose_neigh *)v)->next;\n}\n\nstatic void rose_neigh_stop(struct seq_file *seq, void *v)\n\t__releases(rose_neigh_list_lock)\n{\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}\n\nstatic int rose_neigh_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11];\n\tint i;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"addr  callsign  dev  count use mode restart  t0  tf digipeaters\\n\");\n\telse {\n\t\tstruct rose_neigh *rose_neigh = v;\n\n\t\t/* if (!rose_neigh->loopback) { */\n\t\tseq_printf(seq, \"%05d %-9s %-4s   %3d %3d  %3s     %3s %3lu %3lu\",\n\t\t\t   rose_neigh->number,\n\t\t\t   (rose_neigh->loopback) ? \"RSLOOP-0\" : ax2asc(buf, &rose_neigh->callsign),\n\t\t\t   rose_neigh->dev ? rose_neigh->dev->name : \"???\",\n\t\t\t   rose_neigh->count,\n\t\t\t   rose_neigh->use,\n\t\t\t   (rose_neigh->dce_mode) ? \"DCE\" : \"DTE\",\n\t\t\t   (rose_neigh->restarted) ? \"yes\" : \"no\",\n\t\t\t   ax25_display_timer(&rose_neigh->t0timer) / HZ,\n\t\t\t   ax25_display_timer(&rose_neigh->ftimer)  / HZ);\n\n\t\tif (rose_neigh->digipeat != NULL) {\n\t\t\tfor (i = 0; i < rose_neigh->digipeat->ndigi; i++)\n\t\t\t\tseq_printf(seq, \" %s\", ax2asc(buf, &rose_neigh->digipeat->calls[i]));\n\t\t}\n\n\t\tseq_puts(seq, \"\\n\");\n\t}\n\treturn 0;\n}\n\n\nstatic const struct seq_operations rose_neigh_seqops = {\n\t.start = rose_neigh_start,\n\t.next = rose_neigh_next,\n\t.stop = rose_neigh_stop,\n\t.show = rose_neigh_show,\n};\n\nstatic int rose_neigh_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &rose_neigh_seqops);\n}\n\nconst struct file_operations rose_neigh_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rose_neigh_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\n\nstatic void *rose_route_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rose_route_list_lock)\n{\n\tstruct rose_route *rose_route;\n\tint i = 1;\n\n\tspin_lock_bh(&rose_route_list_lock);\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (rose_route = rose_route_list; rose_route && i < *pos;\n\t     rose_route = rose_route->next, ++i);\n\n\treturn (i == *pos) ? rose_route : NULL;\n}\n\nstatic void *rose_route_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\n\treturn (v == SEQ_START_TOKEN) ? rose_route_list\n\t\t: ((struct rose_route *)v)->next;\n}\n\nstatic void rose_route_stop(struct seq_file *seq, void *v)\n\t__releases(rose_route_list_lock)\n{\n\tspin_unlock_bh(&rose_route_list_lock);\n}\n\nstatic int rose_route_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11], rsbuf[11];\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"lci  address     callsign   neigh  <-> lci  address     callsign   neigh\\n\");\n\telse {\n\t\tstruct rose_route *rose_route = v;\n\n\t\tif (rose_route->neigh1)\n\t\t\tseq_printf(seq,\n\t\t\t\t   \"%3.3X  %-10s  %-9s  %05d      \",\n\t\t\t\t   rose_route->lci1,\n\t\t\t\t   rose2asc(rsbuf, &rose_route->src_addr),\n\t\t\t\t   ax2asc(buf, &rose_route->src_call),\n\t\t\t\t   rose_route->neigh1->number);\n\t\telse\n\t\t\tseq_puts(seq,\n\t\t\t\t \"000  *           *          00000      \");\n\n\t\tif (rose_route->neigh2)\n\t\t\tseq_printf(seq,\n\t\t\t\t   \"%3.3X  %-10s  %-9s  %05d\\n\",\n\t\t\t\t   rose_route->lci2,\n\t\t\t\t   rose2asc(rsbuf, &rose_route->dest_addr),\n\t\t\t\t   ax2asc(buf, &rose_route->dest_call),\n\t\t\t\t   rose_route->neigh2->number);\n\t\t else\n\t\t\t seq_puts(seq,\n\t\t\t\t  \"000  *           *          00000\\n\");\n\t\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations rose_route_seqops = {\n\t.start = rose_route_start,\n\t.next = rose_route_next,\n\t.stop = rose_route_stop,\n\t.show = rose_route_show,\n};\n\nstatic int rose_route_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &rose_route_seqops);\n}\n\nconst struct file_operations rose_routes_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rose_route_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\n#endif /* CONFIG_PROC_FS */\n\n/*\n *\tRelease all memory associated with ROSE routing structures.\n */\nvoid __exit rose_rt_free(void)\n{\n\tstruct rose_neigh *s, *rose_neigh = rose_neigh_list;\n\tstruct rose_node  *t, *rose_node  = rose_node_list;\n\tstruct rose_route *u, *rose_route = rose_route_list;\n\n\twhile (rose_neigh != NULL) {\n\t\ts          = rose_neigh;\n\t\trose_neigh = rose_neigh->next;\n\n\t\trose_remove_neigh(s);\n\t}\n\n\twhile (rose_node != NULL) {\n\t\tt         = rose_node;\n\t\trose_node = rose_node->next;\n\n\t\trose_remove_node(t);\n\t}\n\n\twhile (rose_route != NULL) {\n\t\tu          = rose_route;\n\t\trose_route = rose_route->next;\n\n\t\trose_remove_route(u);\n\t}\n}\n", "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Copyright (C) Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n */\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <asm/system.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/rose.h>\n\nstatic int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose);\n\n/*\n *\tThis routine purges all of the queues of frames.\n */\nvoid rose_clear_queues(struct sock *sk)\n{\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&rose_sk(sk)->ack_queue);\n}\n\n/*\n * This routine purges the input queue of those frames that have been\n * acknowledged. This replaces the boxes labelled \"V(a) <- N(r)\" on the\n * SDL diagram.\n */\nvoid rose_frames_acked(struct sock *sk, unsigned short nr)\n{\n\tstruct sk_buff *skb;\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\t/*\n\t * Remove all the ack-ed frames from the ack queue.\n\t */\n\tif (rose->va != nr) {\n\t\twhile (skb_peek(&rose->ack_queue) != NULL && rose->va != nr) {\n\t\t\tskb = skb_dequeue(&rose->ack_queue);\n\t\t\tkfree_skb(skb);\n\t\t\trose->va = (rose->va + 1) % ROSE_MODULUS;\n\t\t}\n\t}\n}\n\nvoid rose_requeue_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\n\t/*\n\t * Requeue all the un-ack-ed frames on the output queue to be picked\n\t * up by rose_kick. This arrangement handles the possibility of an\n\t * empty output queue.\n\t */\n\twhile ((skb = skb_dequeue(&rose_sk(sk)->ack_queue)) != NULL) {\n\t\tif (skb_prev == NULL)\n\t\t\tskb_queue_head(&sk->sk_write_queue, skb);\n\t\telse\n\t\t\tskb_append(skb_prev, skb, &sk->sk_write_queue);\n\t\tskb_prev = skb;\n\t}\n}\n\n/*\n *\tValidate that the value of nr is between va and vs. Return true or\n *\tfalse for testing.\n */\nint rose_validate_nr(struct sock *sk, unsigned short nr)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tunsigned short vc = rose->va;\n\n\twhile (vc != rose->vs) {\n\t\tif (nr == vc) return 1;\n\t\tvc = (vc + 1) % ROSE_MODULUS;\n\t}\n\n\treturn nr == rose->vs;\n}\n\n/*\n *  This routine is called when the packet layer internally generates a\n *  control frame.\n */\nvoid rose_write_internal(struct sock *sk, int frametype)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned char  *dptr;\n\tunsigned char  lci1, lci2;\n\tchar buffer[100];\n\tint len, faclen = 0;\n\n\tlen = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1;\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_REQUEST:\n\t\tlen   += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN;\n\t\tfaclen = rose_create_facilities(buffer, rose);\n\t\tlen   += faclen;\n\t\tbreak;\n\tcase ROSE_CALL_ACCEPTED:\n\tcase ROSE_CLEAR_REQUEST:\n\tcase ROSE_RESET_REQUEST:\n\t\tlen   += 2;\n\t\tbreak;\n\t}\n\n\tif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\t/*\n\t *\tSpace for AX.25 header and PID.\n\t */\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1);\n\n\tdptr = skb_put(skb, skb_tailroom(skb));\n\n\tlci1 = (rose->lci >> 8) & 0x0F;\n\tlci2 = (rose->lci >> 0) & 0xFF;\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = 0xAA;\n\t\tmemcpy(dptr, &rose->dest_addr,  ROSE_ADDR_LEN);\n\t\tdptr   += ROSE_ADDR_LEN;\n\t\tmemcpy(dptr, &rose->source_addr, ROSE_ADDR_LEN);\n\t\tdptr   += ROSE_ADDR_LEN;\n\t\tmemcpy(dptr, buffer, faclen);\n\t\tdptr   += faclen;\n\t\tbreak;\n\n\tcase ROSE_CALL_ACCEPTED:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = 0x00;\t\t/* Address length */\n\t\t*dptr++ = 0;\t\t/* Facilities length */\n\t\tbreak;\n\n\tcase ROSE_CLEAR_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = rose->cause;\n\t\t*dptr++ = rose->diagnostic;\n\t\tbreak;\n\n\tcase ROSE_RESET_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = ROSE_DTE_ORIGINATED;\n\t\t*dptr++ = 0;\n\t\tbreak;\n\n\tcase ROSE_RR:\n\tcase ROSE_RNR:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr   = frametype;\n\t\t*dptr++ |= (rose->vr << 5) & 0xE0;\n\t\tbreak;\n\n\tcase ROSE_CLEAR_CONFIRMATION:\n\tcase ROSE_RESET_CONFIRMATION:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++  = frametype;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"ROSE: rose_write_internal - invalid frametype %02X\\n\", frametype);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\trose_transmit_link(skb, rose->neighbour);\n}\n\nint rose_decode(struct sk_buff *skb, int *ns, int *nr, int *q, int *d, int *m)\n{\n\tunsigned char *frame;\n\n\tframe = skb->data;\n\n\t*ns = *nr = *q = *d = *m = 0;\n\n\tswitch (frame[2]) {\n\tcase ROSE_CALL_REQUEST:\n\tcase ROSE_CALL_ACCEPTED:\n\tcase ROSE_CLEAR_REQUEST:\n\tcase ROSE_CLEAR_CONFIRMATION:\n\tcase ROSE_RESET_REQUEST:\n\tcase ROSE_RESET_CONFIRMATION:\n\t\treturn frame[2];\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((frame[2] & 0x1F) == ROSE_RR  ||\n\t    (frame[2] & 0x1F) == ROSE_RNR) {\n\t\t*nr = (frame[2] >> 5) & 0x07;\n\t\treturn frame[2] & 0x1F;\n\t}\n\n\tif ((frame[2] & 0x01) == ROSE_DATA) {\n\t\t*q  = (frame[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\t\t*d  = (frame[0] & ROSE_D_BIT) == ROSE_D_BIT;\n\t\t*m  = (frame[2] & ROSE_M_BIT) == ROSE_M_BIT;\n\t\t*nr = (frame[2] >> 5) & 0x07;\n\t\t*ns = (frame[2] >> 1) & 0x07;\n\t\treturn ROSE_DATA;\n\t}\n\n\treturn ROSE_ILLEGAL;\n}\n\nstatic int rose_parse_national(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char *pt;\n\tunsigned char l, lg, n = 0;\n\tint fac_national_digis_received = 0;\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tif (*p == FAC_NATIONAL_RAND)\n\t\t\t\tfacilities->rand = ((p[1] << 8) & 0xFF00) + ((p[2] << 0) & 0x00FF);\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tl = p[1];\n\t\t\tif (*p == FAC_NATIONAL_DEST_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tmemcpy(&facilities->source_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->source_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_SRC_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tmemcpy(&facilities->dest_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->dest_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_CALL) {\n\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT) {\n\t\t\t\t\t\tif (facilities->dest_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (facilities->source_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n\nstatic int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tl = p[1];\n\n\t\t\t/* Prevent overflows*/\n\t\t\tif (l < 10 || l > 20)\n\t\t\t\treturn -1;\n\n\t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n\t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n\nint rose_parse_facilities(unsigned char *p,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\n\tfacilities_len = *p++;\n\n\tif (facilities_len == 0)\n\t\treturn 0;\n\n\twhile (facilities_len > 0) {\n\t\tif (*p == 0x00) {\n\t\t\tfacilities_len--;\n\t\t\tp++;\n\n\t\t\tswitch (*p) {\n\t\t\tcase FAC_NATIONAL:\t\t/* National */\n\t\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n\t\t\t\tif (len < 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tfacilities_len -= len + 1;\n\t\t\t\tp += len + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase FAC_CCITT:\t\t/* CCITT */\n\t\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n\t\t\t\tif (len < 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tfacilities_len -= len + 1;\n\t\t\t\tp += len + 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\t\tfacilities_len--;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\t/* Error in facilities format */\n\t}\n\n\treturn 1;\n}\n\nstatic int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose)\n{\n\tunsigned char *p = buffer + 1;\n\tchar *callsign;\n\tchar buf[11];\n\tint len, nb;\n\n\t/* National Facilities */\n\tif (rose->rand != 0 || rose->source_ndigis == 1 || rose->dest_ndigis == 1) {\n\t\t*p++ = 0x00;\n\t\t*p++ = FAC_NATIONAL;\n\n\t\tif (rose->rand != 0) {\n\t\t\t*p++ = FAC_NATIONAL_RAND;\n\t\t\t*p++ = (rose->rand >> 8) & 0xFF;\n\t\t\t*p++ = (rose->rand >> 0) & 0xFF;\n\t\t}\n\n\t\t/* Sent before older facilities */\n\t\tif ((rose->source_ndigis > 0) || (rose->dest_ndigis > 0)) {\n\t\t\tint maxdigi = 0;\n\t\t\t*p++ = FAC_NATIONAL_DIGIS;\n\t\t\t*p++ = AX25_ADDR_LEN * (rose->source_ndigis + rose->dest_ndigis);\n\t\t\tfor (nb = 0 ; nb < rose->source_ndigis ; nb++) {\n\t\t\t\tif (++maxdigi >= ROSE_MAX_DIGIS)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(p, &rose->source_digis[nb], AX25_ADDR_LEN);\n\t\t\t\tp[6] |= AX25_HBIT;\n\t\t\t\tp += AX25_ADDR_LEN;\n\t\t\t}\n\t\t\tfor (nb = 0 ; nb < rose->dest_ndigis ; nb++) {\n\t\t\t\tif (++maxdigi >= ROSE_MAX_DIGIS)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(p, &rose->dest_digis[nb], AX25_ADDR_LEN);\n\t\t\t\tp[6] &= ~AX25_HBIT;\n\t\t\t\tp += AX25_ADDR_LEN;\n\t\t\t}\n\t\t}\n\n\t\t/* For compatibility */\n\t\tif (rose->source_ndigis > 0) {\n\t\t\t*p++ = FAC_NATIONAL_SRC_DIGI;\n\t\t\t*p++ = AX25_ADDR_LEN;\n\t\t\tmemcpy(p, &rose->source_digis[0], AX25_ADDR_LEN);\n\t\t\tp   += AX25_ADDR_LEN;\n\t\t}\n\n\t\t/* For compatibility */\n\t\tif (rose->dest_ndigis > 0) {\n\t\t\t*p++ = FAC_NATIONAL_DEST_DIGI;\n\t\t\t*p++ = AX25_ADDR_LEN;\n\t\t\tmemcpy(p, &rose->dest_digis[0], AX25_ADDR_LEN);\n\t\t\tp   += AX25_ADDR_LEN;\n\t\t}\n\t}\n\n\t*p++ = 0x00;\n\t*p++ = FAC_CCITT;\n\n\t*p++ = FAC_CCITT_DEST_NSAP;\n\n\tcallsign = ax2asc(buf, &rose->dest_call);\n\n\t*p++ = strlen(callsign) + 10;\n\t*p++ = (strlen(callsign) + 9) * 2;\t\t/* ??? */\n\n\t*p++ = 0x47; *p++ = 0x00; *p++ = 0x11;\n\t*p++ = ROSE_ADDR_LEN * 2;\n\tmemcpy(p, &rose->dest_addr, ROSE_ADDR_LEN);\n\tp   += ROSE_ADDR_LEN;\n\n\tmemcpy(p, callsign, strlen(callsign));\n\tp   += strlen(callsign);\n\n\t*p++ = FAC_CCITT_SRC_NSAP;\n\n\tcallsign = ax2asc(buf, &rose->source_call);\n\n\t*p++ = strlen(callsign) + 10;\n\t*p++ = (strlen(callsign) + 9) * 2;\t\t/* ??? */\n\n\t*p++ = 0x47; *p++ = 0x00; *p++ = 0x11;\n\t*p++ = ROSE_ADDR_LEN * 2;\n\tmemcpy(p, &rose->source_addr, ROSE_ADDR_LEN);\n\tp   += ROSE_ADDR_LEN;\n\n\tmemcpy(p, callsign, strlen(callsign));\n\tp   += strlen(callsign);\n\n\tlen       = p - buffer;\n\tbuffer[0] = len - 1;\n\n\treturn len;\n}\n\nvoid rose_disconnect(struct sock *sk, int reason, int cause, int diagnostic)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\trose_stop_timer(sk);\n\trose_stop_idletimer(sk);\n\n\trose_clear_queues(sk);\n\n\trose->lci   = 0;\n\trose->state = ROSE_STATE_0;\n\n\tif (cause != -1)\n\t\trose->cause = cause;\n\n\tif (diagnostic != -1)\n\t\trose->diagnostic = diagnostic;\n\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = reason;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n}\n"], "fixing_code": ["/*\n *\tDeclarations of Rose type objects.\n *\n *\tJonathan Naylor G4KLX\t25/8/96\n */\n\n#ifndef _ROSE_H\n#define _ROSE_H \n\n#include <linux/rose.h>\n#include <net/sock.h>\n\n#define\tROSE_ADDR_LEN\t\t\t5\n\n#define\tROSE_MIN_LEN\t\t\t3\n\n#define\tROSE_CALL_REQ_ADDR_LEN_OFF\t3\n#define\tROSE_CALL_REQ_ADDR_LEN_VAL\t0xAA\t/* each address is 10 digits */\n#define\tROSE_CALL_REQ_DEST_ADDR_OFF\t4\n#define\tROSE_CALL_REQ_SRC_ADDR_OFF\t9\n#define\tROSE_CALL_REQ_FACILITIES_OFF\t14\n\n#define\tROSE_GFI\t\t\t0x10\n#define\tROSE_Q_BIT\t\t\t0x80\n#define\tROSE_D_BIT\t\t\t0x40\n#define\tROSE_M_BIT\t\t\t0x10\n\n#define\tROSE_CALL_REQUEST\t\t0x0B\n#define\tROSE_CALL_ACCEPTED\t\t0x0F\n#define\tROSE_CLEAR_REQUEST\t\t0x13\n#define\tROSE_CLEAR_CONFIRMATION\t\t0x17\n#define\tROSE_DATA\t\t\t0x00\n#define\tROSE_INTERRUPT\t\t\t0x23\n#define\tROSE_INTERRUPT_CONFIRMATION\t0x27\n#define\tROSE_RR\t\t\t\t0x01\n#define\tROSE_RNR\t\t\t0x05\n#define\tROSE_REJ\t\t\t0x09\n#define\tROSE_RESET_REQUEST\t\t0x1B\n#define\tROSE_RESET_CONFIRMATION\t\t0x1F\n#define\tROSE_REGISTRATION_REQUEST\t0xF3\n#define\tROSE_REGISTRATION_CONFIRMATION\t0xF7\n#define\tROSE_RESTART_REQUEST\t\t0xFB\n#define\tROSE_RESTART_CONFIRMATION\t0xFF\n#define\tROSE_DIAGNOSTIC\t\t\t0xF1\n#define\tROSE_ILLEGAL\t\t\t0xFD\n\n/* Define Link State constants. */\n\nenum {\n\tROSE_STATE_0,\t\t\t/* Ready */\n\tROSE_STATE_1,\t\t\t/* Awaiting Call Accepted */\n\tROSE_STATE_2,\t\t\t/* Awaiting Clear Confirmation */\n\tROSE_STATE_3,\t\t\t/* Data Transfer */\n\tROSE_STATE_4,\t\t\t/* Awaiting Reset Confirmation */\n\tROSE_STATE_5\t\t\t/* Deferred Call Acceptance */\n};\n\n#define ROSE_DEFAULT_T0\t\t\t180000\t\t/* Default T10 T20 value */\n#define ROSE_DEFAULT_T1\t\t\t200000\t\t/* Default T11 T21 value */\n#define ROSE_DEFAULT_T2\t\t\t180000\t\t/* Default T12 T22 value */\n#define\tROSE_DEFAULT_T3\t\t\t180000\t\t/* Default T13 T23 value */\n#define\tROSE_DEFAULT_HB\t\t\t5000\t\t/* Default Holdback value */\n#define\tROSE_DEFAULT_IDLE\t\t0\t\t/* No Activity Timeout - none */\n#define\tROSE_DEFAULT_ROUTING\t\t1\t\t/* Default routing flag */\n#define\tROSE_DEFAULT_FAIL_TIMEOUT\t120000\t\t/* Time until link considered usable */\n#define\tROSE_DEFAULT_MAXVC\t\t50\t\t/* Maximum number of VCs per neighbour */\n#define\tROSE_DEFAULT_WINDOW_SIZE\t7\t\t/* Default window size */\n\n#define ROSE_MODULUS \t\t\t8\n#define\tROSE_MAX_PACKET_SIZE\t\t251\t\t/* Maximum packet size */\n\n#define\tROSE_COND_ACK_PENDING\t\t0x01\n#define\tROSE_COND_PEER_RX_BUSY\t\t0x02\n#define\tROSE_COND_OWN_RX_BUSY\t\t0x04\n\n#define\tFAC_NATIONAL\t\t\t0x00\n#define\tFAC_CCITT\t\t\t0x0F\n\n#define\tFAC_NATIONAL_RAND\t\t0x7F\n#define\tFAC_NATIONAL_FLAGS\t\t0x3F\n#define\tFAC_NATIONAL_DEST_DIGI\t\t0xE9\n#define\tFAC_NATIONAL_SRC_DIGI\t\t0xEB\n#define\tFAC_NATIONAL_FAIL_CALL\t\t0xED\n#define\tFAC_NATIONAL_FAIL_ADD\t\t0xEE\n#define\tFAC_NATIONAL_DIGIS\t\t\t0xEF\n\n#define\tFAC_CCITT_DEST_NSAP\t\t0xC9\n#define\tFAC_CCITT_SRC_NSAP\t\t0xCB\n\nstruct rose_neigh {\n\tstruct rose_neigh\t*next;\n\tax25_address\t\tcallsign;\n\tax25_digi\t\t*digipeat;\n\tax25_cb\t\t\t*ax25;\n\tstruct net_device\t\t*dev;\n\tunsigned short\t\tcount;\n\tunsigned short\t\tuse;\n\tunsigned int\t\tnumber;\n\tchar\t\t\trestarted;\n\tchar\t\t\tdce_mode;\n\tchar\t\t\tloopback;\n\tstruct sk_buff_head\tqueue;\n\tstruct timer_list\tt0timer;\n\tstruct timer_list\tftimer;\n};\n\nstruct rose_node {\n\tstruct rose_node\t*next;\n\trose_address\t\taddress;\n\tunsigned short\t\tmask;\n\tunsigned char\t\tcount;\n\tchar\t\t\tloopback;\n\tstruct rose_neigh\t*neighbour[3];\n};\n\nstruct rose_route {\n\tstruct rose_route\t*next;\n\tunsigned int\t\tlci1, lci2;\n\trose_address\t\tsrc_addr, dest_addr;\n\tax25_address\t\tsrc_call, dest_call;\n\tstruct rose_neigh \t*neigh1, *neigh2;\n\tunsigned int\t\trand;\n};\n\nstruct rose_sock {\n\tstruct sock\t\tsock;\n\trose_address\t\tsource_addr,   dest_addr;\n\tax25_address\t\tsource_call,   dest_call;\n\tunsigned char\t\tsource_ndigis, dest_ndigis;\n\tax25_address\t\tsource_digis[ROSE_MAX_DIGIS];\n\tax25_address\t\tdest_digis[ROSE_MAX_DIGIS];\n\tstruct rose_neigh\t*neighbour;\n\tstruct net_device\t\t*device;\n\tunsigned int\t\tlci, rand;\n\tunsigned char\t\tstate, condition, qbitincl, defer;\n\tunsigned char\t\tcause, diagnostic;\n\tunsigned short\t\tvs, vr, va, vl;\n\tunsigned long\t\tt1, t2, t3, hb, idle;\n#ifdef M_BIT\n\tunsigned short\t\tfraglen;\n\tstruct sk_buff_head\tfrag_queue;\n#endif\n\tstruct sk_buff_head\tack_queue;\n\tstruct rose_facilities_struct facilities;\n\tstruct timer_list\ttimer;\n\tstruct timer_list\tidletimer;\n};\n\n#define rose_sk(sk) ((struct rose_sock *)(sk))\n\n/* af_rose.c */\nextern ax25_address rose_callsign;\nextern int  sysctl_rose_restart_request_timeout;\nextern int  sysctl_rose_call_request_timeout;\nextern int  sysctl_rose_reset_request_timeout;\nextern int  sysctl_rose_clear_request_timeout;\nextern int  sysctl_rose_no_activity_timeout;\nextern int  sysctl_rose_ack_hold_back_timeout;\nextern int  sysctl_rose_routing_control;\nextern int  sysctl_rose_link_fail_timeout;\nextern int  sysctl_rose_maximum_vcs;\nextern int  sysctl_rose_window_size;\nextern int  rosecmp(rose_address *, rose_address *);\nextern int  rosecmpm(rose_address *, rose_address *, unsigned short);\nextern char *rose2asc(char *buf, const rose_address *);\nextern struct sock *rose_find_socket(unsigned int, struct rose_neigh *);\nextern void rose_kill_by_neigh(struct rose_neigh *);\nextern unsigned int rose_new_lci(struct rose_neigh *);\nextern int  rose_rx_call_request(struct sk_buff *, struct net_device *, struct rose_neigh *, unsigned int);\nextern void rose_destroy_socket(struct sock *);\n\n/* rose_dev.c */\nextern void  rose_setup(struct net_device *);\n\n/* rose_in.c */\nextern int  rose_process_rx_frame(struct sock *, struct sk_buff *);\n\n/* rose_link.c */\nextern void rose_start_ftimer(struct rose_neigh *);\nextern void rose_stop_ftimer(struct rose_neigh *);\nextern void rose_stop_t0timer(struct rose_neigh *);\nextern int  rose_ftimer_running(struct rose_neigh *);\nextern void rose_link_rx_restart(struct sk_buff *, struct rose_neigh *, unsigned short);\nextern void rose_transmit_clear_request(struct rose_neigh *, unsigned int, unsigned char, unsigned char);\nextern void rose_transmit_link(struct sk_buff *, struct rose_neigh *);\n\n/* rose_loopback.c */\nextern void rose_loopback_init(void);\nextern void rose_loopback_clear(void);\nextern int  rose_loopback_queue(struct sk_buff *, struct rose_neigh *);\n\n/* rose_out.c */\nextern void rose_kick(struct sock *);\nextern void rose_enquiry_response(struct sock *);\n\n/* rose_route.c */\nextern struct rose_neigh *rose_loopback_neigh;\nextern const struct file_operations rose_neigh_fops;\nextern const struct file_operations rose_nodes_fops;\nextern const struct file_operations rose_routes_fops;\n\nextern void rose_add_loopback_neigh(void);\nextern int __must_check rose_add_loopback_node(rose_address *);\nextern void rose_del_loopback_node(rose_address *);\nextern void rose_rt_device_down(struct net_device *);\nextern void rose_link_device_down(struct net_device *);\nextern struct net_device *rose_dev_first(void);\nextern struct net_device *rose_dev_get(rose_address *);\nextern struct rose_route *rose_route_free_lci(unsigned int, struct rose_neigh *);\nextern struct rose_neigh *rose_get_neigh(rose_address *, unsigned char *, unsigned char *, int);\nextern int  rose_rt_ioctl(unsigned int, void __user *);\nextern void rose_link_failed(ax25_cb *, int);\nextern int  rose_route_frame(struct sk_buff *, ax25_cb *);\nextern void rose_rt_free(void);\n\n/* rose_subr.c */\nextern void rose_clear_queues(struct sock *);\nextern void rose_frames_acked(struct sock *, unsigned short);\nextern void rose_requeue_frames(struct sock *);\nextern int  rose_validate_nr(struct sock *, unsigned short);\nextern void rose_write_internal(struct sock *, int);\nextern int  rose_decode(struct sk_buff *, int *, int *, int *, int *, int *);\nextern int  rose_parse_facilities(unsigned char *, unsigned int, struct rose_facilities_struct *);\nextern void rose_disconnect(struct sock *, int, int, int);\n\n/* rose_timer.c */\nextern void rose_start_heartbeat(struct sock *);\nextern void rose_start_t1timer(struct sock *);\nextern void rose_start_t2timer(struct sock *);\nextern void rose_start_t3timer(struct sock *);\nextern void rose_start_hbtimer(struct sock *);\nextern void rose_start_idletimer(struct sock *);\nextern void rose_stop_heartbeat(struct sock *);\nextern void rose_stop_timer(struct sock *);\nextern void rose_stop_idletimer(struct sock *);\n\n/* sysctl_net_rose.c */\nextern void rose_register_sysctl(void);\nextern void rose_unregister_sysctl(void);\n\n#endif\n", "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Copyright (C) Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n * Copyright (C) Alan Cox GW4PTS (alan@lxorguk.ukuu.org.uk)\n * Copyright (C) Terry Dawson VK2KTJ (terry@animats.net)\n * Copyright (C) Tomi Manninen OH2BNS (oh2bns@sral.fi)\n */\n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/stat.h>\n#include <net/net_namespace.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <asm/system.h>\n#include <asm/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <net/rose.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <net/tcp_states.h>\n#include <net/ip.h>\n#include <net/arp.h>\n\nstatic int rose_ndevs = 10;\n\nint sysctl_rose_restart_request_timeout = ROSE_DEFAULT_T0;\nint sysctl_rose_call_request_timeout    = ROSE_DEFAULT_T1;\nint sysctl_rose_reset_request_timeout   = ROSE_DEFAULT_T2;\nint sysctl_rose_clear_request_timeout   = ROSE_DEFAULT_T3;\nint sysctl_rose_no_activity_timeout     = ROSE_DEFAULT_IDLE;\nint sysctl_rose_ack_hold_back_timeout   = ROSE_DEFAULT_HB;\nint sysctl_rose_routing_control         = ROSE_DEFAULT_ROUTING;\nint sysctl_rose_link_fail_timeout       = ROSE_DEFAULT_FAIL_TIMEOUT;\nint sysctl_rose_maximum_vcs             = ROSE_DEFAULT_MAXVC;\nint sysctl_rose_window_size             = ROSE_DEFAULT_WINDOW_SIZE;\n\nstatic HLIST_HEAD(rose_list);\nstatic DEFINE_SPINLOCK(rose_list_lock);\n\nstatic const struct proto_ops rose_proto_ops;\n\nax25_address rose_callsign;\n\n/*\n * ROSE network devices are virtual network devices encapsulating ROSE\n * frames into AX.25 which will be sent through an AX.25 device, so form a\n * special \"super class\" of normal net devices; split their locks off into a\n * separate class since they always nest.\n */\nstatic struct lock_class_key rose_netdev_xmit_lock_key;\nstatic struct lock_class_key rose_netdev_addr_lock_key;\n\nstatic void rose_set_lockdep_one(struct net_device *dev,\n\t\t\t\t struct netdev_queue *txq,\n\t\t\t\t void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock, &rose_netdev_xmit_lock_key);\n}\n\nstatic void rose_set_lockdep_key(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock, &rose_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, rose_set_lockdep_one, NULL);\n}\n\n/*\n *\tConvert a ROSE address into text.\n */\nchar *rose2asc(char *buf, const rose_address *addr)\n{\n\tif (addr->rose_addr[0] == 0x00 && addr->rose_addr[1] == 0x00 &&\n\t    addr->rose_addr[2] == 0x00 && addr->rose_addr[3] == 0x00 &&\n\t    addr->rose_addr[4] == 0x00) {\n\t\tstrcpy(buf, \"*\");\n\t} else {\n\t\tsprintf(buf, \"%02X%02X%02X%02X%02X\", addr->rose_addr[0] & 0xFF,\n\t\t\t\t\t\taddr->rose_addr[1] & 0xFF,\n\t\t\t\t\t\taddr->rose_addr[2] & 0xFF,\n\t\t\t\t\t\taddr->rose_addr[3] & 0xFF,\n\t\t\t\t\t\taddr->rose_addr[4] & 0xFF);\n\t}\n\n\treturn buf;\n}\n\n/*\n *\tCompare two ROSE addresses, 0 == equal.\n */\nint rosecmp(rose_address *addr1, rose_address *addr2)\n{\n\tint i;\n\n\tfor (i = 0; i < 5; i++)\n\t\tif (addr1->rose_addr[i] != addr2->rose_addr[i])\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n/*\n *\tCompare two ROSE addresses for only mask digits, 0 == equal.\n */\nint rosecmpm(rose_address *addr1, rose_address *addr2, unsigned short mask)\n{\n\tunsigned int i, j;\n\n\tif (mask > 10)\n\t\treturn 1;\n\n\tfor (i = 0; i < mask; i++) {\n\t\tj = i / 2;\n\n\t\tif ((i % 2) != 0) {\n\t\t\tif ((addr1->rose_addr[j] & 0x0F) != (addr2->rose_addr[j] & 0x0F))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif ((addr1->rose_addr[j] & 0xF0) != (addr2->rose_addr[j] & 0xF0))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n *\tSocket removal during an interrupt is now safe.\n */\nstatic void rose_remove_socket(struct sock *sk)\n{\n\tspin_lock_bh(&rose_list_lock);\n\tsk_del_node_init(sk);\n\tspin_unlock_bh(&rose_list_lock);\n}\n\n/*\n *\tKill all bound sockets on a broken link layer connection to a\n *\tparticular neighbour.\n */\nvoid rose_kill_by_neigh(struct rose_neigh *neigh)\n{\n\tstruct sock *s;\n\tstruct hlist_node *node;\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_for_each(s, node, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (rose->neighbour == neigh) {\n\t\t\trose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);\n\t\t\trose->neighbour->use--;\n\t\t\trose->neighbour = NULL;\n\t\t}\n\t}\n\tspin_unlock_bh(&rose_list_lock);\n}\n\n/*\n *\tKill all bound sockets on a dropped device.\n */\nstatic void rose_kill_by_device(struct net_device *dev)\n{\n\tstruct sock *s;\n\tstruct hlist_node *node;\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_for_each(s, node, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (rose->device == dev) {\n\t\t\trose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);\n\t\t\trose->neighbour->use--;\n\t\t\trose->device = NULL;\n\t\t}\n\t}\n\tspin_unlock_bh(&rose_list_lock);\n}\n\n/*\n *\tHandle device status changes.\n */\nstatic int rose_device_event(struct notifier_block *this, unsigned long event,\n\tvoid *ptr)\n{\n\tstruct net_device *dev = (struct net_device *)ptr;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (event != NETDEV_DOWN)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (dev->type) {\n\tcase ARPHRD_ROSE:\n\t\trose_kill_by_device(dev);\n\t\tbreak;\n\tcase ARPHRD_AX25:\n\t\trose_link_device_down(dev);\n\t\trose_rt_device_down(dev);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n/*\n *\tAdd a socket to the bound sockets list.\n */\nstatic void rose_insert_socket(struct sock *sk)\n{\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_add_node(sk, &rose_list);\n\tspin_unlock_bh(&rose_list_lock);\n}\n\n/*\n *\tFind a socket that wants to accept the Call Request we just\n *\treceived.\n */\nstatic struct sock *rose_find_listener(rose_address *addr, ax25_address *call)\n{\n\tstruct sock *s;\n\tstruct hlist_node *node;\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_for_each(s, node, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (!rosecmp(&rose->source_addr, addr) &&\n\t\t    !ax25cmp(&rose->source_call, call) &&\n\t\t    !rose->source_ndigis && s->sk_state == TCP_LISTEN)\n\t\t\tgoto found;\n\t}\n\n\tsk_for_each(s, node, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (!rosecmp(&rose->source_addr, addr) &&\n\t\t    !ax25cmp(&rose->source_call, &null_ax25_address) &&\n\t\t    s->sk_state == TCP_LISTEN)\n\t\t\tgoto found;\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&rose_list_lock);\n\treturn s;\n}\n\n/*\n *\tFind a connected ROSE socket given my LCI and device.\n */\nstruct sock *rose_find_socket(unsigned int lci, struct rose_neigh *neigh)\n{\n\tstruct sock *s;\n\tstruct hlist_node *node;\n\n\tspin_lock_bh(&rose_list_lock);\n\tsk_for_each(s, node, &rose_list) {\n\t\tstruct rose_sock *rose = rose_sk(s);\n\n\t\tif (rose->lci == lci && rose->neighbour == neigh)\n\t\t\tgoto found;\n\t}\n\ts = NULL;\nfound:\n\tspin_unlock_bh(&rose_list_lock);\n\treturn s;\n}\n\n/*\n *\tFind a unique LCI for a given device.\n */\nunsigned int rose_new_lci(struct rose_neigh *neigh)\n{\n\tint lci;\n\n\tif (neigh->dce_mode) {\n\t\tfor (lci = 1; lci <= sysctl_rose_maximum_vcs; lci++)\n\t\t\tif (rose_find_socket(lci, neigh) == NULL && rose_route_free_lci(lci, neigh) == NULL)\n\t\t\t\treturn lci;\n\t} else {\n\t\tfor (lci = sysctl_rose_maximum_vcs; lci > 0; lci--)\n\t\t\tif (rose_find_socket(lci, neigh) == NULL && rose_route_free_lci(lci, neigh) == NULL)\n\t\t\t\treturn lci;\n\t}\n\n\treturn 0;\n}\n\n/*\n *\tDeferred destroy.\n */\nvoid rose_destroy_socket(struct sock *);\n\n/*\n *\tHandler for deferred kills.\n */\nstatic void rose_destroy_timer(unsigned long data)\n{\n\trose_destroy_socket((struct sock *)data);\n}\n\n/*\n *\tThis is called from user mode and the timers. Thus it protects itself\n *\tagainst interrupt users but doesn't worry about being called during\n *\twork.  Once it is removed from the queue no interrupt or bottom half\n *\twill touch it and we are (fairly 8-) ) safe.\n */\nvoid rose_destroy_socket(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\n\trose_remove_socket(sk);\n\trose_stop_heartbeat(sk);\n\trose_stop_idletimer(sk);\n\trose_stop_timer(sk);\n\n\trose_clear_queues(sk);\t\t/* Flush the queues */\n\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (skb->sk != sk) {\t/* A pending connection */\n\t\t\t/* Queue the unaccepted socket for death */\n\t\t\tsock_set_flag(skb->sk, SOCK_DEAD);\n\t\t\trose_start_heartbeat(skb->sk);\n\t\t\trose_sk(skb->sk)->state = ROSE_STATE_0;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\tif (sk_has_allocations(sk)) {\n\t\t/* Defer: outstanding buffers */\n\t\tsetup_timer(&sk->sk_timer, rose_destroy_timer,\n\t\t\t\t(unsigned long)sk);\n\t\tsk->sk_timer.expires  = jiffies + 10 * HZ;\n\t\tadd_timer(&sk->sk_timer);\n\t} else\n\t\tsock_put(sk);\n}\n\n/*\n *\tHandling for system calls applied via the various interfaces to a\n *\tROSE socket object.\n */\n\nstatic int rose_setsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint opt;\n\n\tif (level != SOL_ROSE)\n\t\treturn -ENOPROTOOPT;\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\n\tif (get_user(opt, (int __user *)optval))\n\t\treturn -EFAULT;\n\n\tswitch (optname) {\n\tcase ROSE_DEFER:\n\t\trose->defer = opt ? 1 : 0;\n\t\treturn 0;\n\n\tcase ROSE_T1:\n\t\tif (opt < 1)\n\t\t\treturn -EINVAL;\n\t\trose->t1 = opt * HZ;\n\t\treturn 0;\n\n\tcase ROSE_T2:\n\t\tif (opt < 1)\n\t\t\treturn -EINVAL;\n\t\trose->t2 = opt * HZ;\n\t\treturn 0;\n\n\tcase ROSE_T3:\n\t\tif (opt < 1)\n\t\t\treturn -EINVAL;\n\t\trose->t3 = opt * HZ;\n\t\treturn 0;\n\n\tcase ROSE_HOLDBACK:\n\t\tif (opt < 1)\n\t\t\treturn -EINVAL;\n\t\trose->hb = opt * HZ;\n\t\treturn 0;\n\n\tcase ROSE_IDLE:\n\t\tif (opt < 0)\n\t\t\treturn -EINVAL;\n\t\trose->idle = opt * 60 * HZ;\n\t\treturn 0;\n\n\tcase ROSE_QBITINCL:\n\t\trose->qbitincl = opt ? 1 : 0;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n}\n\nstatic int rose_getsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint val = 0;\n\tint len;\n\n\tif (level != SOL_ROSE)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase ROSE_DEFER:\n\t\tval = rose->defer;\n\t\tbreak;\n\n\tcase ROSE_T1:\n\t\tval = rose->t1 / HZ;\n\t\tbreak;\n\n\tcase ROSE_T2:\n\t\tval = rose->t2 / HZ;\n\t\tbreak;\n\n\tcase ROSE_T3:\n\t\tval = rose->t3 / HZ;\n\t\tbreak;\n\n\tcase ROSE_HOLDBACK:\n\t\tval = rose->hb / HZ;\n\t\tbreak;\n\n\tcase ROSE_IDLE:\n\t\tval = rose->idle / (60 * HZ);\n\t\tbreak;\n\n\tcase ROSE_QBITINCL:\n\t\tval = rose->qbitincl;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn copy_to_user(optval, &val, len) ? -EFAULT : 0;\n}\n\nstatic int rose_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tstruct rose_sock *rose = rose_sk(sk);\n\n\t\trose->dest_ndigis = 0;\n\t\tmemset(&rose->dest_addr, 0, ROSE_ADDR_LEN);\n\t\tmemset(&rose->dest_call, 0, AX25_ADDR_LEN);\n\t\tmemset(rose->dest_digis, 0, AX25_ADDR_LEN * ROSE_MAX_DIGIS);\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct proto rose_proto = {\n\t.name\t  = \"ROSE\",\n\t.owner\t  = THIS_MODULE,\n\t.obj_size = sizeof(struct rose_sock),\n};\n\nstatic int rose_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tstruct rose_sock *rose;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tif (sock->type != SOCK_SEQPACKET || protocol != 0)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ROSE, GFP_ATOMIC, &rose_proto);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\trose = rose_sk(sk);\n\n\tsock_init_data(sock, sk);\n\n\tskb_queue_head_init(&rose->ack_queue);\n#ifdef M_BIT\n\tskb_queue_head_init(&rose->frag_queue);\n\trose->fraglen    = 0;\n#endif\n\n\tsock->ops    = &rose_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tinit_timer(&rose->timer);\n\tinit_timer(&rose->idletimer);\n\n\trose->t1   = msecs_to_jiffies(sysctl_rose_call_request_timeout);\n\trose->t2   = msecs_to_jiffies(sysctl_rose_reset_request_timeout);\n\trose->t3   = msecs_to_jiffies(sysctl_rose_clear_request_timeout);\n\trose->hb   = msecs_to_jiffies(sysctl_rose_ack_hold_back_timeout);\n\trose->idle = msecs_to_jiffies(sysctl_rose_no_activity_timeout);\n\n\trose->state = ROSE_STATE_0;\n\n\treturn 0;\n}\n\nstatic struct sock *rose_make_new(struct sock *osk)\n{\n\tstruct sock *sk;\n\tstruct rose_sock *rose, *orose;\n\n\tif (osk->sk_type != SOCK_SEQPACKET)\n\t\treturn NULL;\n\n\tsk = sk_alloc(sock_net(osk), PF_ROSE, GFP_ATOMIC, &rose_proto);\n\tif (sk == NULL)\n\t\treturn NULL;\n\n\trose = rose_sk(sk);\n\n\tsock_init_data(NULL, sk);\n\n\tskb_queue_head_init(&rose->ack_queue);\n#ifdef M_BIT\n\tskb_queue_head_init(&rose->frag_queue);\n\trose->fraglen  = 0;\n#endif\n\n\tsk->sk_type     = osk->sk_type;\n\tsk->sk_priority = osk->sk_priority;\n\tsk->sk_protocol = osk->sk_protocol;\n\tsk->sk_rcvbuf   = osk->sk_rcvbuf;\n\tsk->sk_sndbuf   = osk->sk_sndbuf;\n\tsk->sk_state    = TCP_ESTABLISHED;\n\tsock_copy_flags(sk, osk);\n\n\tinit_timer(&rose->timer);\n\tinit_timer(&rose->idletimer);\n\n\torose\t\t= rose_sk(osk);\n\trose->t1\t= orose->t1;\n\trose->t2\t= orose->t2;\n\trose->t3\t= orose->t3;\n\trose->hb\t= orose->hb;\n\trose->idle\t= orose->idle;\n\trose->defer\t= orose->defer;\n\trose->device\t= orose->device;\n\trose->qbitincl\t= orose->qbitincl;\n\n\treturn sk;\n}\n\nstatic int rose_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose;\n\n\tif (sk == NULL) return 0;\n\n\tsock_hold(sk);\n\tsock_orphan(sk);\n\tlock_sock(sk);\n\trose = rose_sk(sk);\n\n\tswitch (rose->state) {\n\tcase ROSE_STATE_0:\n\t\trelease_sock(sk);\n\t\trose_disconnect(sk, 0, -1, -1);\n\t\tlock_sock(sk);\n\t\trose_destroy_socket(sk);\n\t\tbreak;\n\n\tcase ROSE_STATE_2:\n\t\trose->neighbour->use--;\n\t\trelease_sock(sk);\n\t\trose_disconnect(sk, 0, -1, -1);\n\t\tlock_sock(sk);\n\t\trose_destroy_socket(sk);\n\t\tbreak;\n\n\tcase ROSE_STATE_1:\n\tcase ROSE_STATE_3:\n\tcase ROSE_STATE_4:\n\tcase ROSE_STATE_5:\n\t\trose_clear_queues(sk);\n\t\trose_stop_idletimer(sk);\n\t\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\t\trose_start_t3timer(sk);\n\t\trose->state  = ROSE_STATE_2;\n\t\tsk->sk_state    = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}\n\nstatic int rose_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;\n\tstruct net_device *dev;\n\tax25_address *source;\n\tax25_uid_assoc *user;\n\tint n;\n\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\n\tif (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))\n\t\treturn -EINVAL;\n\n\tif (addr->srose_family != AF_ROSE)\n\t\treturn -EINVAL;\n\n\tif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\n\t\treturn -EINVAL;\n\n\tif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tif ((dev = rose_dev_get(&addr->srose_addr)) == NULL) {\n\t\tSOCK_DEBUG(sk, \"ROSE: bind failed: invalid address\\n\");\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tsource = &addr->srose_call;\n\n\tuser = ax25_findbyuid(current_euid());\n\tif (user) {\n\t\trose->source_call = user->call;\n\t\tax25_uid_put(user);\n\t} else {\n\t\tif (ax25_uid_policy && !capable(CAP_NET_BIND_SERVICE))\n\t\t\treturn -EACCES;\n\t\trose->source_call   = *source;\n\t}\n\n\trose->source_addr   = addr->srose_addr;\n\trose->device        = dev;\n\trose->source_ndigis = addr->srose_ndigis;\n\n\tif (addr_len == sizeof(struct full_sockaddr_rose)) {\n\t\tstruct full_sockaddr_rose *full_addr = (struct full_sockaddr_rose *)uaddr;\n\t\tfor (n = 0 ; n < addr->srose_ndigis ; n++)\n\t\t\trose->source_digis[n] = full_addr->srose_digis[n];\n\t} else {\n\t\tif (rose->source_ndigis == 1) {\n\t\t\trose->source_digis[0] = addr->srose_digi;\n\t\t}\n\t}\n\n\trose_insert_socket(sk);\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tSOCK_DEBUG(sk, \"ROSE: socket is bound\\n\");\n\treturn 0;\n}\n\nstatic int rose_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *addr = (struct sockaddr_rose *)uaddr;\n\tunsigned char cause, diagnostic;\n\tstruct net_device *dev;\n\tax25_uid_assoc *user;\n\tint n, err = 0;\n\n\tif (addr_len != sizeof(struct sockaddr_rose) && addr_len != sizeof(struct full_sockaddr_rose))\n\t\treturn -EINVAL;\n\n\tif (addr->srose_family != AF_ROSE)\n\t\treturn -EINVAL;\n\n\tif (addr_len == sizeof(struct sockaddr_rose) && addr->srose_ndigis > 1)\n\t\treturn -EINVAL;\n\n\tif ((unsigned int) addr->srose_ndigis > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\t/* Source + Destination digis should not exceed ROSE_MAX_DIGIS */\n\tif ((rose->source_ndigis + addr->srose_ndigis) > ROSE_MAX_DIGIS)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == TCP_ESTABLISHED && sock->state == SS_CONNECTING) {\n\t\t/* Connect completed during a ERESTARTSYS event */\n\t\tsock->state = SS_CONNECTED;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_CLOSE && sock->state == SS_CONNECTING) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = -ECONNREFUSED;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state == TCP_ESTABLISHED) {\n\t\t/* No reconnect on a seqpacket socket */\n\t\terr = -EISCONN;\n\t\tgoto out_release;\n\t}\n\n\tsk->sk_state   = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trose->neighbour = rose_get_neigh(&addr->srose_addr, &cause,\n\t\t\t\t\t &diagnostic, 0);\n\tif (!rose->neighbour) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out_release;\n\t}\n\n\trose->lci = rose_new_lci(rose->neighbour);\n\tif (!rose->lci) {\n\t\terr = -ENETUNREACH;\n\t\tgoto out_release;\n\t}\n\n\tif (sock_flag(sk, SOCK_ZAPPED)) {\t/* Must bind first - autobinding in this may or may not work */\n\t\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\t\tif ((dev = rose_dev_first()) == NULL) {\n\t\t\terr = -ENETUNREACH;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tuser = ax25_findbyuid(current_euid());\n\t\tif (!user) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tmemcpy(&rose->source_addr, dev->dev_addr, ROSE_ADDR_LEN);\n\t\trose->source_call = user->call;\n\t\trose->device      = dev;\n\t\tax25_uid_put(user);\n\n\t\trose_insert_socket(sk);\t\t/* Finish the bind */\n\t}\n\trose->dest_addr   = addr->srose_addr;\n\trose->dest_call   = addr->srose_call;\n\trose->rand        = ((long)rose & 0xFFFF) + rose->lci;\n\trose->dest_ndigis = addr->srose_ndigis;\n\n\tif (addr_len == sizeof(struct full_sockaddr_rose)) {\n\t\tstruct full_sockaddr_rose *full_addr = (struct full_sockaddr_rose *)uaddr;\n\t\tfor (n = 0 ; n < addr->srose_ndigis ; n++)\n\t\t\trose->dest_digis[n] = full_addr->srose_digis[n];\n\t} else {\n\t\tif (rose->dest_ndigis == 1) {\n\t\t\trose->dest_digis[0] = addr->srose_digi;\n\t\t}\n\t}\n\n\t/* Move to connecting socket, start sending Connect Requests */\n\tsock->state   = SS_CONNECTING;\n\tsk->sk_state     = TCP_SYN_SENT;\n\n\trose->state = ROSE_STATE_1;\n\n\trose->neighbour->use++;\n\n\trose_write_internal(sk, ROSE_CALL_REQUEST);\n\trose_start_heartbeat(sk);\n\trose_start_t1timer(sk);\n\n\t/* Now the loop */\n\tif (sk->sk_state != TCP_ESTABLISHED && (flags & O_NONBLOCK)) {\n\t\terr = -EINPROGRESS;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t * A Connect Ack with Choke or timeout or failed routing will go to\n\t * closed.\n\t */\n\tif (sk->sk_state == TCP_SYN_SENT) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tfor (;;) {\n\t\t\tprepare_to_wait(sk_sleep(sk), &wait,\n\t\t\t\t\tTASK_INTERRUPTIBLE);\n\t\t\tif (sk->sk_state != TCP_SYN_SENT)\n\t\t\t\tbreak;\n\t\t\tif (!signal_pending(current)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\tschedule();\n\t\t\t\tlock_sock(sk);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tfinish_wait(sk_sleep(sk), &wait);\n\n\t\tif (err)\n\t\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tsock->state = SS_UNCONNECTED;\n\t\terr = sock_error(sk);\t/* Always set at this point */\n\t\tgoto out_release;\n\t}\n\n\tsock->state = SS_CONNECTED;\n\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int rose_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sk_buff *skb;\n\tstruct sock *newsk;\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk;\n\tint err = 0;\n\n\tif ((sk = sock->sk) == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_release;\n\t}\n\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\terr = -EINVAL;\n\t\tgoto out_release;\n\t}\n\n\t/*\n\t *\tThe write queue this time is holding sockets ready to use\n\t *\thooked into the SABM we saved\n\t */\n\tfor (;;) {\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\n\t\tskb = skb_dequeue(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tbreak;\n\n\t\tif (flags & O_NONBLOCK) {\n\t\t\terr = -EWOULDBLOCK;\n\t\t\tbreak;\n\t\t}\n\t\tif (!signal_pending(current)) {\n\t\t\trelease_sock(sk);\n\t\t\tschedule();\n\t\t\tlock_sock(sk);\n\t\t\tcontinue;\n\t\t}\n\t\terr = -ERESTARTSYS;\n\t\tbreak;\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\tif (err)\n\t\tgoto out_release;\n\n\tnewsk = skb->sk;\n\tsock_graft(newsk, newsock);\n\n\t/* Now attach up the new socket */\n\tskb->sk = NULL;\n\tkfree_skb(skb);\n\tsk->sk_ack_backlog--;\n\nout_release:\n\trelease_sock(sk);\n\n\treturn err;\n}\n\nstatic int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\n\tmemset(srose, 0, sizeof(*srose));\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}\n\nint rose_rx_call_request(struct sk_buff *skb, struct net_device *dev, struct rose_neigh *neigh, unsigned int lci)\n{\n\tstruct sock *sk;\n\tstruct sock *make;\n\tstruct rose_sock *make_rose;\n\tstruct rose_facilities_struct facilities;\n\tint n;\n\n\tskb->sk = NULL;\t\t/* Initially we don't know who it's for */\n\n\t/*\n\t *\tskb->data points to the rose frame start\n\t */\n\tmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\n\n\tif (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,\n\t\t\t\t   skb->len - ROSE_CALL_REQ_FACILITIES_OFF,\n\t\t\t\t   &facilities)) {\n\t\trose_transmit_clear_request(neigh, lci, ROSE_INVALID_FACILITY, 76);\n\t\treturn 0;\n\t}\n\n\tsk = rose_find_listener(&facilities.source_addr, &facilities.source_call);\n\n\t/*\n\t * We can't accept the Call Request.\n\t */\n\tif (sk == NULL || sk_acceptq_is_full(sk) ||\n\t    (make = rose_make_new(sk)) == NULL) {\n\t\trose_transmit_clear_request(neigh, lci, ROSE_NETWORK_CONGESTION, 120);\n\t\treturn 0;\n\t}\n\n\tskb->sk     = make;\n\tmake->sk_state = TCP_ESTABLISHED;\n\tmake_rose = rose_sk(make);\n\n\tmake_rose->lci           = lci;\n\tmake_rose->dest_addr     = facilities.dest_addr;\n\tmake_rose->dest_call     = facilities.dest_call;\n\tmake_rose->dest_ndigis   = facilities.dest_ndigis;\n\tfor (n = 0 ; n < facilities.dest_ndigis ; n++)\n\t\tmake_rose->dest_digis[n] = facilities.dest_digis[n];\n\tmake_rose->source_addr   = facilities.source_addr;\n\tmake_rose->source_call   = facilities.source_call;\n\tmake_rose->source_ndigis = facilities.source_ndigis;\n\tfor (n = 0 ; n < facilities.source_ndigis ; n++)\n\t\tmake_rose->source_digis[n]= facilities.source_digis[n];\n\tmake_rose->neighbour     = neigh;\n\tmake_rose->device        = dev;\n\tmake_rose->facilities    = facilities;\n\n\tmake_rose->neighbour->use++;\n\n\tif (rose_sk(sk)->defer) {\n\t\tmake_rose->state = ROSE_STATE_5;\n\t} else {\n\t\trose_write_internal(make, ROSE_CALL_ACCEPTED);\n\t\tmake_rose->state = ROSE_STATE_3;\n\t\trose_start_idletimer(make);\n\t}\n\n\tmake_rose->condition = 0x00;\n\tmake_rose->vs        = 0;\n\tmake_rose->va        = 0;\n\tmake_rose->vr        = 0;\n\tmake_rose->vl        = 0;\n\tsk->sk_ack_backlog++;\n\n\trose_insert_socket(make);\n\n\tskb_queue_head(&sk->sk_receive_queue, skb);\n\n\trose_start_heartbeat(make);\n\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_data_ready(sk, skb->len);\n\n\treturn 1;\n}\n\nstatic int rose_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *usrose = (struct sockaddr_rose *)msg->msg_name;\n\tint err;\n\tstruct full_sockaddr_rose srose;\n\tstruct sk_buff *skb;\n\tunsigned char *asmptr;\n\tint n, size, qbit = 0;\n\n\tif (msg->msg_flags & ~(MSG_DONTWAIT|MSG_EOR|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN) {\n\t\tsend_sig(SIGPIPE, current, 0);\n\t\treturn -EPIPE;\n\t}\n\n\tif (rose->neighbour == NULL || rose->device == NULL)\n\t\treturn -ENETUNREACH;\n\n\tif (usrose != NULL) {\n\t\tif (msg->msg_namelen != sizeof(struct sockaddr_rose) && msg->msg_namelen != sizeof(struct full_sockaddr_rose))\n\t\t\treturn -EINVAL;\n\t\tmemset(&srose, 0, sizeof(struct full_sockaddr_rose));\n\t\tmemcpy(&srose, usrose, msg->msg_namelen);\n\t\tif (rosecmp(&rose->dest_addr, &srose.srose_addr) != 0 ||\n\t\t    ax25cmp(&rose->dest_call, &srose.srose_call) != 0)\n\t\t\treturn -EISCONN;\n\t\tif (srose.srose_ndigis != rose->dest_ndigis)\n\t\t\treturn -EISCONN;\n\t\tif (srose.srose_ndigis == rose->dest_ndigis) {\n\t\t\tfor (n = 0 ; n < srose.srose_ndigis ; n++)\n\t\t\t\tif (ax25cmp(&rose->dest_digis[n],\n\t\t\t\t\t    &srose.srose_digis[n]))\n\t\t\t\t\treturn -EISCONN;\n\t\t}\n\t\tif (srose.srose_family != AF_ROSE)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\n\t\tsrose.srose_family = AF_ROSE;\n\t\tsrose.srose_addr   = rose->dest_addr;\n\t\tsrose.srose_call   = rose->dest_call;\n\t\tsrose.srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\tsrose.srose_digis[n] = rose->dest_digis[n];\n\t}\n\n\tSOCK_DEBUG(sk, \"ROSE: sendto: Addresses built.\\n\");\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"ROSE: sendto: building packet.\\n\");\n\t/* Sanity check the packet size */\n\tif (len > 65535)\n\t\treturn -EMSGSIZE;\n\n\tsize = len + AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN;\n\n\tif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)\n\t\treturn err;\n\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN);\n\n\t/*\n\t *\tPut the data on the end\n\t */\n\tSOCK_DEBUG(sk, \"ROSE: Appending user data\\n\");\n\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, len);\n\n\terr = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\t/*\n\t *\tIf the Q BIT Include socket option is in force, the first\n\t *\tbyte of the user data is the logical value of the Q Bit.\n\t */\n\tif (rose->qbitincl) {\n\t\tqbit = skb->data[0];\n\t\tskb_pull(skb, 1);\n\t}\n\n\t/*\n\t *\tPush down the ROSE header\n\t */\n\tasmptr = skb_push(skb, ROSE_MIN_LEN);\n\n\tSOCK_DEBUG(sk, \"ROSE: Building Network Header.\\n\");\n\n\t/* Build a ROSE Network header */\n\tasmptr[0] = ((rose->lci >> 8) & 0x0F) | ROSE_GFI;\n\tasmptr[1] = (rose->lci >> 0) & 0xFF;\n\tasmptr[2] = ROSE_DATA;\n\n\tif (qbit)\n\t\tasmptr[0] |= ROSE_Q_BIT;\n\n\tSOCK_DEBUG(sk, \"ROSE: Built header.\\n\");\n\n\tSOCK_DEBUG(sk, \"ROSE: Transmitting buffer\\n\");\n\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOTCONN;\n\t}\n\n#ifdef M_BIT\n#define ROSE_PACLEN (256-ROSE_MIN_LEN)\n\tif (skb->len - ROSE_MIN_LEN > ROSE_PACLEN) {\n\t\tunsigned char header[ROSE_MIN_LEN];\n\t\tstruct sk_buff *skbn;\n\t\tint frontlen;\n\t\tint lg;\n\n\t\t/* Save a copy of the Header */\n\t\tskb_copy_from_linear_data(skb, header, ROSE_MIN_LEN);\n\t\tskb_pull(skb, ROSE_MIN_LEN);\n\n\t\tfrontlen = skb_headroom(skb);\n\n\t\twhile (skb->len > 0) {\n\t\t\tif ((skbn = sock_alloc_send_skb(sk, frontlen + ROSE_PACLEN, 0, &err)) == NULL) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tskbn->sk   = sk;\n\t\t\tskbn->free = 1;\n\t\t\tskbn->arp  = 1;\n\n\t\t\tskb_reserve(skbn, frontlen);\n\n\t\t\tlg = (ROSE_PACLEN > skb->len) ? skb->len : ROSE_PACLEN;\n\n\t\t\t/* Copy the user data */\n\t\t\tskb_copy_from_linear_data(skb, skb_put(skbn, lg), lg);\n\t\t\tskb_pull(skb, lg);\n\n\t\t\t/* Duplicate the Header */\n\t\t\tskb_push(skbn, ROSE_MIN_LEN);\n\t\t\tskb_copy_to_linear_data(skbn, header, ROSE_MIN_LEN);\n\n\t\t\tif (skb->len > 0)\n\t\t\t\tskbn->data[2] |= M_BIT;\n\n\t\t\tskb_queue_tail(&sk->sk_write_queue, skbn); /* Throw it on the queue */\n\t\t}\n\n\t\tskb->free = 1;\n\t\tkfree_skb(skb);\n\t} else {\n\t\tskb_queue_tail(&sk->sk_write_queue, skb);\t\t/* Throw it on the queue */\n\t}\n#else\n\tskb_queue_tail(&sk->sk_write_queue, skb);\t/* Shove it onto the queue */\n#endif\n\n\trose_kick(sk);\n\n\treturn len;\n}\n\n\nstatic int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;\n\tsize_t copied;\n\tunsigned char *asmptr;\n\tstruct sk_buff *skb;\n\tint n, er, qbit;\n\n\t/*\n\t * This works for seqpacket too. The receiver has ordered the queue for\n\t * us! We do one quick check first though\n\t */\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\n\t/* Now we can treat all alike */\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)\n\t\treturn er;\n\n\tqbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\n\tskb_pull(skb, ROSE_MIN_LEN);\n\n\tif (rose->qbitincl) {\n\t\tasmptr  = skb_push(skb, 1);\n\t\t*asmptr = qbit;\n\t}\n\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tif (srose != NULL) {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tif (msg->msg_namelen >= sizeof(struct full_sockaddr_rose)) {\n\t\t\tstruct full_sockaddr_rose *full_srose = (struct full_sockaddr_rose *)msg->msg_name;\n\t\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\t\tfull_srose->srose_digis[n] = rose->dest_digis[n];\n\t\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_rose);\n\t\t} else {\n\t\t\tif (rose->dest_ndigis >= 1) {\n\t\t\t\tsrose->srose_ndigis = 1;\n\t\t\t\tsrose->srose_digi = rose->dest_digis[0];\n\t\t\t}\n\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_rose);\n\t\t}\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn copied;\n}\n\n\nstatic int rose_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount;\n\n\t\tamount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\treturn put_user(amount, (unsigned int __user *) argp);\n\t}\n\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0L;\n\t\t/* These two are safe on a single CPU system as only user tasks fiddle here */\n\t\tif ((skb = skb_peek(&sk->sk_receive_queue)) != NULL)\n\t\t\tamount = skb->len;\n\t\treturn put_user(amount, (unsigned int __user *) argp);\n\t}\n\n\tcase SIOCGSTAMP:\n\t\treturn sock_get_timestamp(sk, (struct timeval __user *) argp);\n\n\tcase SIOCGSTAMPNS:\n\t\treturn sock_get_timestampns(sk, (struct timespec __user *) argp);\n\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\t\treturn -EINVAL;\n\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\tcase SIOCRSCLRRT:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn rose_rt_ioctl(cmd, argp);\n\n\tcase SIOCRSGCAUSE: {\n\t\tstruct rose_cause_struct rose_cause;\n\t\trose_cause.cause      = rose->cause;\n\t\trose_cause.diagnostic = rose->diagnostic;\n\t\treturn copy_to_user(argp, &rose_cause, sizeof(struct rose_cause_struct)) ? -EFAULT : 0;\n\t}\n\n\tcase SIOCRSSCAUSE: {\n\t\tstruct rose_cause_struct rose_cause;\n\t\tif (copy_from_user(&rose_cause, argp, sizeof(struct rose_cause_struct)))\n\t\t\treturn -EFAULT;\n\t\trose->cause      = rose_cause.cause;\n\t\trose->diagnostic = rose_cause.diagnostic;\n\t\treturn 0;\n\t}\n\n\tcase SIOCRSSL2CALL:\n\t\tif (!capable(CAP_NET_ADMIN)) return -EPERM;\n\t\tif (ax25cmp(&rose_callsign, &null_ax25_address) != 0)\n\t\t\tax25_listen_release(&rose_callsign, NULL);\n\t\tif (copy_from_user(&rose_callsign, argp, sizeof(ax25_address)))\n\t\t\treturn -EFAULT;\n\t\tif (ax25cmp(&rose_callsign, &null_ax25_address) != 0)\n\t\t\treturn ax25_listen_register(&rose_callsign, NULL);\n\n\t\treturn 0;\n\n\tcase SIOCRSGL2CALL:\n\t\treturn copy_to_user(argp, &rose_callsign, sizeof(ax25_address)) ? -EFAULT : 0;\n\n\tcase SIOCRSACCEPT:\n\t\tif (rose->state == ROSE_STATE_5) {\n\t\t\trose_write_internal(sk, ROSE_CALL_ACCEPTED);\n\t\t\trose_start_idletimer(sk);\n\t\t\trose->condition = 0x00;\n\t\t\trose->vs        = 0;\n\t\t\trose->va        = 0;\n\t\t\trose->vr        = 0;\n\t\t\trose->vl        = 0;\n\t\t\trose->state     = ROSE_STATE_3;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PROC_FS\nstatic void *rose_info_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rose_list_lock)\n{\n\tspin_lock_bh(&rose_list_lock);\n\treturn seq_hlist_start_head(&rose_list, *pos);\n}\n\nstatic void *rose_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_hlist_next(v, &rose_list, pos);\n}\n\nstatic void rose_info_stop(struct seq_file *seq, void *v)\n\t__releases(rose_list_lock)\n{\n\tspin_unlock_bh(&rose_list_lock);\n}\n\nstatic int rose_info_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11], rsbuf[11];\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"dest_addr  dest_call src_addr   src_call  dev   lci neigh st vs vr va   t  t1  t2  t3  hb    idle Snd-Q Rcv-Q inode\\n\");\n\n\telse {\n\t\tstruct sock *s = sk_entry(v);\n\t\tstruct rose_sock *rose = rose_sk(s);\n\t\tconst char *devname, *callsign;\n\t\tconst struct net_device *dev = rose->device;\n\n\t\tif (!dev)\n\t\t\tdevname = \"???\";\n\t\telse\n\t\t\tdevname = dev->name;\n\n\t\tseq_printf(seq, \"%-10s %-9s \",\n\t\t\t   rose2asc(rsbuf, &rose->dest_addr),\n\t\t\t   ax2asc(buf, &rose->dest_call));\n\n\t\tif (ax25cmp(&rose->source_call, &null_ax25_address) == 0)\n\t\t\tcallsign = \"??????-?\";\n\t\telse\n\t\t\tcallsign = ax2asc(buf, &rose->source_call);\n\n\t\tseq_printf(seq,\n\t\t\t   \"%-10s %-9s %-5s %3.3X %05d  %d  %d  %d  %d %3lu %3lu %3lu %3lu %3lu %3lu/%03lu %5d %5d %ld\\n\",\n\t\t\trose2asc(rsbuf, &rose->source_addr),\n\t\t\tcallsign,\n\t\t\tdevname,\n\t\t\trose->lci & 0x0FFF,\n\t\t\t(rose->neighbour) ? rose->neighbour->number : 0,\n\t\t\trose->state,\n\t\t\trose->vs,\n\t\t\trose->vr,\n\t\t\trose->va,\n\t\t\tax25_display_timer(&rose->timer) / HZ,\n\t\t\trose->t1 / HZ,\n\t\t\trose->t2 / HZ,\n\t\t\trose->t3 / HZ,\n\t\t\trose->hb / HZ,\n\t\t\tax25_display_timer(&rose->idletimer) / (60 * HZ),\n\t\t\trose->idle / (60 * HZ),\n\t\t\tsk_wmem_alloc_get(s),\n\t\t\tsk_rmem_alloc_get(s),\n\t\t\ts->sk_socket ? SOCK_INODE(s->sk_socket)->i_ino : 0L);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct seq_operations rose_info_seqops = {\n\t.start = rose_info_start,\n\t.next = rose_info_next,\n\t.stop = rose_info_stop,\n\t.show = rose_info_show,\n};\n\nstatic int rose_info_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &rose_info_seqops);\n}\n\nstatic const struct file_operations rose_info_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rose_info_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n#endif\t/* CONFIG_PROC_FS */\n\nstatic const struct net_proto_family rose_family_ops = {\n\t.family\t\t=\tPF_ROSE,\n\t.create\t\t=\trose_create,\n\t.owner\t\t=\tTHIS_MODULE,\n};\n\nstatic const struct proto_ops rose_proto_ops = {\n\t.family\t\t=\tPF_ROSE,\n\t.owner\t\t=\tTHIS_MODULE,\n\t.release\t=\trose_release,\n\t.bind\t\t=\trose_bind,\n\t.connect\t=\trose_connect,\n\t.socketpair\t=\tsock_no_socketpair,\n\t.accept\t\t=\trose_accept,\n\t.getname\t=\trose_getname,\n\t.poll\t\t=\tdatagram_poll,\n\t.ioctl\t\t=\trose_ioctl,\n\t.listen\t\t=\trose_listen,\n\t.shutdown\t=\tsock_no_shutdown,\n\t.setsockopt\t=\trose_setsockopt,\n\t.getsockopt\t=\trose_getsockopt,\n\t.sendmsg\t=\trose_sendmsg,\n\t.recvmsg\t=\trose_recvmsg,\n\t.mmap\t\t=\tsock_no_mmap,\n\t.sendpage\t=\tsock_no_sendpage,\n};\n\nstatic struct notifier_block rose_dev_notifier = {\n\t.notifier_call\t=\trose_device_event,\n};\n\nstatic struct net_device **dev_rose;\n\nstatic struct ax25_protocol rose_pid = {\n\t.pid\t= AX25_P_ROSE,\n\t.func\t= rose_route_frame\n};\n\nstatic struct ax25_linkfail rose_linkfail_notifier = {\n\t.func\t= rose_link_failed\n};\n\nstatic int __init rose_proto_init(void)\n{\n\tint i;\n\tint rc;\n\n\tif (rose_ndevs > 0x7FFFFFFF/sizeof(struct net_device *)) {\n\t\tprintk(KERN_ERR \"ROSE: rose_proto_init - rose_ndevs parameter to large\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = proto_register(&rose_proto, 0);\n\tif (rc != 0)\n\t\tgoto out;\n\n\trose_callsign = null_ax25_address;\n\n\tdev_rose = kzalloc(rose_ndevs * sizeof(struct net_device *), GFP_KERNEL);\n\tif (dev_rose == NULL) {\n\t\tprintk(KERN_ERR \"ROSE: rose_proto_init - unable to allocate device structure\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_proto_unregister;\n\t}\n\n\tfor (i = 0; i < rose_ndevs; i++) {\n\t\tstruct net_device *dev;\n\t\tchar name[IFNAMSIZ];\n\n\t\tsprintf(name, \"rose%d\", i);\n\t\tdev = alloc_netdev(0, name, rose_setup);\n\t\tif (!dev) {\n\t\t\tprintk(KERN_ERR \"ROSE: rose_proto_init - unable to allocate memory\\n\");\n\t\t\trc = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\trc = register_netdev(dev);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"ROSE: netdevice registration failed\\n\");\n\t\t\tfree_netdev(dev);\n\t\t\tgoto fail;\n\t\t}\n\t\trose_set_lockdep_key(dev);\n\t\tdev_rose[i] = dev;\n\t}\n\n\tsock_register(&rose_family_ops);\n\tregister_netdevice_notifier(&rose_dev_notifier);\n\n\tax25_register_pid(&rose_pid);\n\tax25_linkfail_register(&rose_linkfail_notifier);\n\n#ifdef CONFIG_SYSCTL\n\trose_register_sysctl();\n#endif\n\trose_loopback_init();\n\n\trose_add_loopback_neigh();\n\n\tproc_net_fops_create(&init_net, \"rose\", S_IRUGO, &rose_info_fops);\n\tproc_net_fops_create(&init_net, \"rose_neigh\", S_IRUGO, &rose_neigh_fops);\n\tproc_net_fops_create(&init_net, \"rose_nodes\", S_IRUGO, &rose_nodes_fops);\n\tproc_net_fops_create(&init_net, \"rose_routes\", S_IRUGO, &rose_routes_fops);\nout:\n\treturn rc;\nfail:\n\twhile (--i >= 0) {\n\t\tunregister_netdev(dev_rose[i]);\n\t\tfree_netdev(dev_rose[i]);\n\t}\n\tkfree(dev_rose);\nout_proto_unregister:\n\tproto_unregister(&rose_proto);\n\tgoto out;\n}\nmodule_init(rose_proto_init);\n\nmodule_param(rose_ndevs, int, 0);\nMODULE_PARM_DESC(rose_ndevs, \"number of ROSE devices\");\n\nMODULE_AUTHOR(\"Jonathan Naylor G4KLX <g4klx@g4klx.demon.co.uk>\");\nMODULE_DESCRIPTION(\"The amateur radio ROSE network layer protocol\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NETPROTO(PF_ROSE);\n\nstatic void __exit rose_exit(void)\n{\n\tint i;\n\n\tproc_net_remove(&init_net, \"rose\");\n\tproc_net_remove(&init_net, \"rose_neigh\");\n\tproc_net_remove(&init_net, \"rose_nodes\");\n\tproc_net_remove(&init_net, \"rose_routes\");\n\trose_loopback_clear();\n\n\trose_rt_free();\n\n\tax25_protocol_release(AX25_P_ROSE);\n\tax25_linkfail_release(&rose_linkfail_notifier);\n\n\tif (ax25cmp(&rose_callsign, &null_ax25_address) != 0)\n\t\tax25_listen_release(&rose_callsign, NULL);\n\n#ifdef CONFIG_SYSCTL\n\trose_unregister_sysctl();\n#endif\n\tunregister_netdevice_notifier(&rose_dev_notifier);\n\n\tsock_unregister(PF_ROSE);\n\n\tfor (i = 0; i < rose_ndevs; i++) {\n\t\tstruct net_device *dev = dev_rose[i];\n\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tfree_netdev(dev);\n\t\t}\n\t}\n\n\tkfree(dev_rose);\n\tproto_unregister(&rose_proto);\n}\n\nmodule_exit(rose_exit);\n", "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Copyright (C) Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n */\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/timer.h>\n#include <net/ax25.h>\n#include <linux/skbuff.h>\n#include <net/rose.h>\n#include <linux/init.h>\n\nstatic struct sk_buff_head loopback_queue;\nstatic struct timer_list loopback_timer;\n\nstatic void rose_set_loopback_timer(void);\n\nvoid rose_loopback_init(void)\n{\n\tskb_queue_head_init(&loopback_queue);\n\n\tinit_timer(&loopback_timer);\n}\n\nstatic int rose_loopback_running(void)\n{\n\treturn timer_pending(&loopback_timer);\n}\n\nint rose_loopback_queue(struct sk_buff *skb, struct rose_neigh *neigh)\n{\n\tstruct sk_buff *skbn;\n\n\tskbn = skb_clone(skb, GFP_ATOMIC);\n\n\tkfree_skb(skb);\n\n\tif (skbn != NULL) {\n\t\tskb_queue_tail(&loopback_queue, skbn);\n\n\t\tif (!rose_loopback_running())\n\t\t\trose_set_loopback_timer();\n\t}\n\n\treturn 1;\n}\n\nstatic void rose_loopback_timer(unsigned long);\n\nstatic void rose_set_loopback_timer(void)\n{\n\tdel_timer(&loopback_timer);\n\n\tloopback_timer.data     = 0;\n\tloopback_timer.function = &rose_loopback_timer;\n\tloopback_timer.expires  = jiffies + 10;\n\n\tadd_timer(&loopback_timer);\n}\n\nstatic void rose_loopback_timer(unsigned long param)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\trose_address *dest;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci_i, lci_o;\n\n\twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n\t\tif (skb->len < ROSE_MIN_LEN) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\t\tframetype = skb->data[2];\n\t\tif (frametype == ROSE_CALL_REQUEST &&\n\t\t    (skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\n\t\t     skb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\n\t\t     ROSE_CALL_REQ_ADDR_LEN_VAL)) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tdest      = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\n\t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n\n\t\tskb_reset_transport_header(skb);\n\n\t\tsk = rose_find_socket(lci_o, rose_loopback_neigh);\n\t\tif (sk) {\n\t\t\tif (rose_process_rx_frame(sk, skb) == 0)\n\t\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tif ((dev = rose_dev_get(dest)) != NULL) {\n\t\t\t\tif (rose_rx_call_request(skb, dev, rose_loopback_neigh, lci_o) == 0)\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}\n\nvoid __exit rose_loopback_clear(void)\n{\n\tstruct sk_buff *skb;\n\n\tdel_timer(&loopback_timer);\n\n\twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n\t\tskb->sk = NULL;\n\t\tkfree_skb(skb);\n\t}\n}\n", "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Copyright (C) Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n * Copyright (C) Terry Dawson VK2KTJ (terry@animats.net)\n */\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <net/arp.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <asm/system.h>\n#include <asm/uaccess.h>\n#include <linux/fcntl.h>\n#include <linux/termios.h>\t/* For TIOCINQ/OUTQ */\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/netfilter.h>\n#include <linux/init.h>\n#include <net/rose.h>\n#include <linux/seq_file.h>\n\nstatic unsigned int rose_neigh_no = 1;\n\nstatic struct rose_node  *rose_node_list;\nstatic DEFINE_SPINLOCK(rose_node_list_lock);\nstatic struct rose_neigh *rose_neigh_list;\nstatic DEFINE_SPINLOCK(rose_neigh_list_lock);\nstatic struct rose_route *rose_route_list;\nstatic DEFINE_SPINLOCK(rose_route_list_lock);\n\nstruct rose_neigh *rose_loopback_neigh;\n\n/*\n *\tAdd a new route to a node, and in the process add the node and the\n *\tneighbour if it is new.\n */\nstatic int __must_check rose_add_node(struct rose_route_struct *rose_route,\n\tstruct net_device *dev)\n{\n\tstruct rose_node  *rose_node, *rose_tmpn, *rose_tmpp;\n\tstruct rose_neigh *rose_neigh;\n\tint i, res = 0;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tspin_lock_bh(&rose_neigh_list_lock);\n\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == rose_route->mask) &&\n\t\t    (rosecmpm(&rose_route->address, &rose_node->address,\n\t\t\t      rose_route->mask) == 0))\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\n\tif (rose_node != NULL && rose_node->loopback) {\n\t\tres = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (ax25cmp(&rose_route->neighbour,\n\t\t\t    &rose_neigh->callsign) == 0 &&\n\t\t    rose_neigh->dev == dev)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh == NULL) {\n\t\trose_neigh = kmalloc(sizeof(*rose_neigh), GFP_ATOMIC);\n\t\tif (rose_neigh == NULL) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\trose_neigh->callsign  = rose_route->neighbour;\n\t\trose_neigh->digipeat  = NULL;\n\t\trose_neigh->ax25      = NULL;\n\t\trose_neigh->dev       = dev;\n\t\trose_neigh->count     = 0;\n\t\trose_neigh->use       = 0;\n\t\trose_neigh->dce_mode  = 0;\n\t\trose_neigh->loopback  = 0;\n\t\trose_neigh->number    = rose_neigh_no++;\n\t\trose_neigh->restarted = 0;\n\n\t\tskb_queue_head_init(&rose_neigh->queue);\n\n\t\tinit_timer(&rose_neigh->ftimer);\n\t\tinit_timer(&rose_neigh->t0timer);\n\n\t\tif (rose_route->ndigis != 0) {\n\t\t\trose_neigh->digipeat =\n\t\t\t\tkmalloc(sizeof(ax25_digi), GFP_ATOMIC);\n\t\t\tif (rose_neigh->digipeat == NULL) {\n\t\t\t\tkfree(rose_neigh);\n\t\t\t\tres = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trose_neigh->digipeat->ndigi      = rose_route->ndigis;\n\t\t\trose_neigh->digipeat->lastrepeat = -1;\n\n\t\t\tfor (i = 0; i < rose_route->ndigis; i++) {\n\t\t\t\trose_neigh->digipeat->calls[i]    =\n\t\t\t\t\trose_route->digipeaters[i];\n\t\t\t\trose_neigh->digipeat->repeated[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\trose_neigh->next = rose_neigh_list;\n\t\trose_neigh_list  = rose_neigh;\n\t}\n\n\t/*\n\t * This is a new node to be inserted into the list. Find where it needs\n\t * to be inserted into the list, and insert it. We want to be sure\n\t * to order the list in descending order of mask size to ensure that\n\t * later when we are searching this list the first match will be the\n\t * best match.\n\t */\n\tif (rose_node == NULL) {\n\t\trose_tmpn = rose_node_list;\n\t\trose_tmpp = NULL;\n\n\t\twhile (rose_tmpn != NULL) {\n\t\t\tif (rose_tmpn->mask > rose_route->mask) {\n\t\t\t\trose_tmpp = rose_tmpn;\n\t\t\t\trose_tmpn = rose_tmpn->next;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* create new node */\n\t\trose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC);\n\t\tif (rose_node == NULL) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\trose_node->address      = rose_route->address;\n\t\trose_node->mask         = rose_route->mask;\n\t\trose_node->count        = 1;\n\t\trose_node->loopback     = 0;\n\t\trose_node->neighbour[0] = rose_neigh;\n\n\t\tif (rose_tmpn == NULL) {\n\t\t\tif (rose_tmpp == NULL) {\t/* Empty list */\n\t\t\t\trose_node_list  = rose_node;\n\t\t\t\trose_node->next = NULL;\n\t\t\t} else {\n\t\t\t\trose_tmpp->next = rose_node;\n\t\t\t\trose_node->next = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (rose_tmpp == NULL) {\t/* 1st node */\n\t\t\t\trose_node->next = rose_node_list;\n\t\t\t\trose_node_list  = rose_node;\n\t\t\t} else {\n\t\t\t\trose_tmpp->next = rose_node;\n\t\t\t\trose_node->next = rose_tmpn;\n\t\t\t}\n\t\t}\n\t\trose_neigh->count++;\n\n\t\tgoto out;\n\t}\n\n\t/* We have space, slot it in */\n\tif (rose_node->count < 3) {\n\t\trose_node->neighbour[rose_node->count] = rose_neigh;\n\t\trose_node->count++;\n\t\trose_neigh->count++;\n\t}\n\nout:\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\tspin_unlock_bh(&rose_node_list_lock);\n\n\treturn res;\n}\n\n/*\n * Caller is holding rose_node_list_lock.\n */\nstatic void rose_remove_node(struct rose_node *rose_node)\n{\n\tstruct rose_node *s;\n\n\tif ((s = rose_node_list) == rose_node) {\n\t\trose_node_list = rose_node->next;\n\t\tkfree(rose_node);\n\t\treturn;\n\t}\n\n\twhile (s != NULL && s->next != NULL) {\n\t\tif (s->next == rose_node) {\n\t\t\ts->next = rose_node->next;\n\t\t\tkfree(rose_node);\n\t\t\treturn;\n\t\t}\n\n\t\ts = s->next;\n\t}\n}\n\n/*\n * Caller is holding rose_neigh_list_lock.\n */\nstatic void rose_remove_neigh(struct rose_neigh *rose_neigh)\n{\n\tstruct rose_neigh *s;\n\n\trose_stop_ftimer(rose_neigh);\n\trose_stop_t0timer(rose_neigh);\n\n\tskb_queue_purge(&rose_neigh->queue);\n\n\tif ((s = rose_neigh_list) == rose_neigh) {\n\t\trose_neigh_list = rose_neigh->next;\n\t\tif (rose_neigh->ax25)\n\t\t\tax25_cb_put(rose_neigh->ax25);\n\t\tkfree(rose_neigh->digipeat);\n\t\tkfree(rose_neigh);\n\t\treturn;\n\t}\n\n\twhile (s != NULL && s->next != NULL) {\n\t\tif (s->next == rose_neigh) {\n\t\t\ts->next = rose_neigh->next;\n\t\t\tif (rose_neigh->ax25)\n\t\t\t\tax25_cb_put(rose_neigh->ax25);\n\t\t\tkfree(rose_neigh->digipeat);\n\t\t\tkfree(rose_neigh);\n\t\t\treturn;\n\t\t}\n\n\t\ts = s->next;\n\t}\n}\n\n/*\n * Caller is holding rose_route_list_lock.\n */\nstatic void rose_remove_route(struct rose_route *rose_route)\n{\n\tstruct rose_route *s;\n\n\tif (rose_route->neigh1 != NULL)\n\t\trose_route->neigh1->use--;\n\n\tif (rose_route->neigh2 != NULL)\n\t\trose_route->neigh2->use--;\n\n\tif ((s = rose_route_list) == rose_route) {\n\t\trose_route_list = rose_route->next;\n\t\tkfree(rose_route);\n\t\treturn;\n\t}\n\n\twhile (s != NULL && s->next != NULL) {\n\t\tif (s->next == rose_route) {\n\t\t\ts->next = rose_route->next;\n\t\t\tkfree(rose_route);\n\t\t\treturn;\n\t\t}\n\n\t\ts = s->next;\n\t}\n}\n\n/*\n *\t\"Delete\" a node. Strictly speaking remove a route to a node. The node\n *\tis only deleted if no routes are left to it.\n */\nstatic int rose_del_node(struct rose_route_struct *rose_route,\n\tstruct net_device *dev)\n{\n\tstruct rose_node  *rose_node;\n\tstruct rose_neigh *rose_neigh;\n\tint i, err = 0;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tspin_lock_bh(&rose_neigh_list_lock);\n\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == rose_route->mask) &&\n\t\t    (rosecmpm(&rose_route->address, &rose_node->address,\n\t\t\t      rose_route->mask) == 0))\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\n\tif (rose_node == NULL || rose_node->loopback) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (ax25cmp(&rose_route->neighbour,\n\t\t\t    &rose_neigh->callsign) == 0 &&\n\t\t    rose_neigh->dev == dev)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh == NULL) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < rose_node->count; i++) {\n\t\tif (rose_node->neighbour[i] == rose_neigh) {\n\t\t\trose_neigh->count--;\n\n\t\t\tif (rose_neigh->count == 0 && rose_neigh->use == 0)\n\t\t\t\trose_remove_neigh(rose_neigh);\n\n\t\t\trose_node->count--;\n\n\t\t\tif (rose_node->count == 0) {\n\t\t\t\trose_remove_node(rose_node);\n\t\t\t} else {\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\trose_node->neighbour[0] =\n\t\t\t\t\t\trose_node->neighbour[1];\n\t\t\t\tcase 1:\n\t\t\t\t\trose_node->neighbour[1] =\n\t\t\t\t\t\trose_node->neighbour[2];\n\t\t\t\tcase 2:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = -EINVAL;\n\nout:\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\tspin_unlock_bh(&rose_node_list_lock);\n\n\treturn err;\n}\n\n/*\n *\tAdd the loopback neighbour.\n */\nvoid rose_add_loopback_neigh(void)\n{\n\tstruct rose_neigh *sn;\n\n\trose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);\n\tif (!rose_loopback_neigh)\n\t\treturn;\n\tsn = rose_loopback_neigh;\n\n\tsn->callsign  = null_ax25_address;\n\tsn->digipeat  = NULL;\n\tsn->ax25      = NULL;\n\tsn->dev       = NULL;\n\tsn->count     = 0;\n\tsn->use       = 0;\n\tsn->dce_mode  = 1;\n\tsn->loopback  = 1;\n\tsn->number    = rose_neigh_no++;\n\tsn->restarted = 1;\n\n\tskb_queue_head_init(&sn->queue);\n\n\tinit_timer(&sn->ftimer);\n\tinit_timer(&sn->t0timer);\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\tsn->next = rose_neigh_list;\n\trose_neigh_list           = sn;\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}\n\n/*\n *\tAdd a loopback node.\n */\nint rose_add_loopback_node(rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\tint err = 0;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t     (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t     rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\n\tif (rose_node != NULL)\n\t\tgoto out;\n\n\tif ((rose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC)) == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trose_node->address      = *address;\n\trose_node->mask         = 10;\n\trose_node->count        = 1;\n\trose_node->loopback     = 1;\n\trose_node->neighbour[0] = rose_loopback_neigh;\n\n\t/* Insert at the head of list. Address is always mask=10 */\n\trose_node->next = rose_node_list;\n\trose_node_list  = rose_node;\n\n\trose_loopback_neigh->count++;\n\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n\n\treturn err;\n}\n\n/*\n *\tDelete a loopback node.\n */\nvoid rose_del_loopback_node(rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t    (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t    rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\n\tif (rose_node == NULL)\n\t\tgoto out;\n\n\trose_remove_node(rose_node);\n\n\trose_loopback_neigh->count--;\n\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n}\n\n/*\n *\tA device has been removed. Remove its routes and neighbours.\n */\nvoid rose_rt_device_down(struct net_device *dev)\n{\n\tstruct rose_neigh *s, *rose_neigh;\n\tstruct rose_node  *t, *rose_node;\n\tint i;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tspin_lock_bh(&rose_neigh_list_lock);\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\ts          = rose_neigh;\n\t\trose_neigh = rose_neigh->next;\n\n\t\tif (s->dev != dev)\n\t\t\tcontinue;\n\n\t\trose_node = rose_node_list;\n\n\t\twhile (rose_node != NULL) {\n\t\t\tt         = rose_node;\n\t\t\trose_node = rose_node->next;\n\n\t\t\tfor (i = 0; i < t->count; i++) {\n\t\t\t\tif (t->neighbour[i] != s)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tt->count--;\n\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tt->neighbour[0] = t->neighbour[1];\n\t\t\t\tcase 1:\n\t\t\t\t\tt->neighbour[1] = t->neighbour[2];\n\t\t\t\tcase 2:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (t->count <= 0)\n\t\t\t\trose_remove_node(t);\n\t\t}\n\n\t\trose_remove_neigh(s);\n\t}\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\tspin_unlock_bh(&rose_node_list_lock);\n}\n\n#if 0 /* Currently unused */\n/*\n *\tA device has been removed. Remove its links.\n */\nvoid rose_route_device_down(struct net_device *dev)\n{\n\tstruct rose_route *s, *rose_route;\n\n\tspin_lock_bh(&rose_route_list_lock);\n\trose_route = rose_route_list;\n\twhile (rose_route != NULL) {\n\t\ts          = rose_route;\n\t\trose_route = rose_route->next;\n\n\t\tif (s->neigh1->dev == dev || s->neigh2->dev == dev)\n\t\t\trose_remove_route(s);\n\t}\n\tspin_unlock_bh(&rose_route_list_lock);\n}\n#endif\n\n/*\n *\tClear all nodes and neighbours out, except for neighbours with\n *\tactive connections going through them.\n *  Do not clear loopback neighbour and nodes.\n */\nstatic int rose_clear_routes(void)\n{\n\tstruct rose_neigh *s, *rose_neigh;\n\tstruct rose_node  *t, *rose_node;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tspin_lock_bh(&rose_neigh_list_lock);\n\n\trose_neigh = rose_neigh_list;\n\trose_node  = rose_node_list;\n\n\twhile (rose_node != NULL) {\n\t\tt         = rose_node;\n\t\trose_node = rose_node->next;\n\t\tif (!t->loopback)\n\t\t\trose_remove_node(t);\n\t}\n\n\twhile (rose_neigh != NULL) {\n\t\ts          = rose_neigh;\n\t\trose_neigh = rose_neigh->next;\n\n\t\tif (s->use == 0 && !s->loopback) {\n\t\t\ts->count = 0;\n\t\t\trose_remove_neigh(s);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\tspin_unlock_bh(&rose_node_list_lock);\n\n\treturn 0;\n}\n\n/*\n *\tCheck that the device given is a valid AX.25 interface that is \"up\".\n * \tcalled whith RTNL\n */\nstatic struct net_device *rose_ax25_dev_find(char *devname)\n{\n\tstruct net_device *dev;\n\n\tif ((dev = __dev_get_by_name(&init_net, devname)) == NULL)\n\t\treturn NULL;\n\n\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_AX25)\n\t\treturn dev;\n\n\treturn NULL;\n}\n\n/*\n *\tFind the first active ROSE device, usually \"rose0\".\n */\nstruct net_device *rose_dev_first(void)\n{\n\tstruct net_device *dev, *first = NULL;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, dev) {\n\t\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE)\n\t\t\tif (first == NULL || strncmp(dev->name, first->name, 3) < 0)\n\t\t\t\tfirst = dev;\n\t}\n\trcu_read_unlock();\n\n\treturn first;\n}\n\n/*\n *\tFind the ROSE device for the given address.\n */\nstruct net_device *rose_dev_get(rose_address *addr)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, dev) {\n\t\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE && rosecmp(addr, (rose_address *)dev->dev_addr) == 0) {\n\t\t\tdev_hold(dev);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdev = NULL;\nout:\n\trcu_read_unlock();\n\treturn dev;\n}\n\nstatic int rose_dev_exists(rose_address *addr)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, dev) {\n\t\tif ((dev->flags & IFF_UP) && dev->type == ARPHRD_ROSE && rosecmp(addr, (rose_address *)dev->dev_addr) == 0)\n\t\t\tgoto out;\n\t}\n\tdev = NULL;\nout:\n\trcu_read_unlock();\n\treturn dev != NULL;\n}\n\n\n\n\nstruct rose_route *rose_route_free_lci(unsigned int lci, struct rose_neigh *neigh)\n{\n\tstruct rose_route *rose_route;\n\n\tfor (rose_route = rose_route_list; rose_route != NULL; rose_route = rose_route->next)\n\t\tif ((rose_route->neigh1 == neigh && rose_route->lci1 == lci) ||\n\t\t    (rose_route->neigh2 == neigh && rose_route->lci2 == lci))\n\t\t\treturn rose_route;\n\n\treturn NULL;\n}\n\n/*\n *\tFind a neighbour or a route given a ROSE address.\n */\nstruct rose_neigh *rose_get_neigh(rose_address *addr, unsigned char *cause,\n\tunsigned char *diagnostic, int route_frame)\n{\n\tstruct rose_neigh *res = NULL;\n\tstruct rose_node *node;\n\tint failed = 0;\n\tint i;\n\n\tif (!route_frame) spin_lock_bh(&rose_node_list_lock);\n\tfor (node = rose_node_list; node != NULL; node = node->next) {\n\t\tif (rosecmpm(addr, &node->address, node->mask) == 0) {\n\t\t\tfor (i = 0; i < node->count; i++) {\n\t\t\t\tif (node->neighbour[i]->restarted) {\n\t\t\t\t\tres = node->neighbour[i];\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!route_frame) { /* connect request */\n\t\tfor (node = rose_node_list; node != NULL; node = node->next) {\n\t\t\tif (rosecmpm(addr, &node->address, node->mask) == 0) {\n\t\t\t\tfor (i = 0; i < node->count; i++) {\n\t\t\t\t\tif (!rose_ftimer_running(node->neighbour[i])) {\n\t\t\t\t\t\tres = node->neighbour[i];\n\t\t\t\t\t\tfailed = 0;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tfailed = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (failed) {\n\t\t*cause      = ROSE_OUT_OF_ORDER;\n\t\t*diagnostic = 0;\n\t} else {\n\t\t*cause      = ROSE_NOT_OBTAINABLE;\n\t\t*diagnostic = 0;\n\t}\n\nout:\n\tif (!route_frame) spin_unlock_bh(&rose_node_list_lock);\n\treturn res;\n}\n\n/*\n *\tHandle the ioctls that control the routing functions.\n */\nint rose_rt_ioctl(unsigned int cmd, void __user *arg)\n{\n\tstruct rose_route_struct rose_route;\n\tstruct net_device *dev;\n\tint err;\n\n\tswitch (cmd) {\n\tcase SIOCADDRT:\n\t\tif (copy_from_user(&rose_route, arg, sizeof(struct rose_route_struct)))\n\t\t\treturn -EFAULT;\n\t\tif ((dev = rose_ax25_dev_find(rose_route.device)) == NULL)\n\t\t\treturn -EINVAL;\n\t\tif (rose_dev_exists(&rose_route.address)) /* Can't add routes to ourself */\n\t\t\treturn -EINVAL;\n\t\tif (rose_route.mask > 10) /* Mask can't be more than 10 digits */\n\t\t\treturn -EINVAL;\n\t\tif (rose_route.ndigis > AX25_MAX_DIGIS)\n\t\t\treturn -EINVAL;\n\t\terr = rose_add_node(&rose_route, dev);\n\t\treturn err;\n\n\tcase SIOCDELRT:\n\t\tif (copy_from_user(&rose_route, arg, sizeof(struct rose_route_struct)))\n\t\t\treturn -EFAULT;\n\t\tif ((dev = rose_ax25_dev_find(rose_route.device)) == NULL)\n\t\t\treturn -EINVAL;\n\t\terr = rose_del_node(&rose_route, dev);\n\t\treturn err;\n\n\tcase SIOCRSCLRRT:\n\t\treturn rose_clear_routes();\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void rose_del_route_by_neigh(struct rose_neigh *rose_neigh)\n{\n\tstruct rose_route *rose_route, *s;\n\n\trose_neigh->restarted = 0;\n\n\trose_stop_t0timer(rose_neigh);\n\trose_start_ftimer(rose_neigh);\n\n\tskb_queue_purge(&rose_neigh->queue);\n\n\tspin_lock_bh(&rose_route_list_lock);\n\n\trose_route = rose_route_list;\n\n\twhile (rose_route != NULL) {\n\t\tif ((rose_route->neigh1 == rose_neigh && rose_route->neigh2 == rose_neigh) ||\n\t\t    (rose_route->neigh1 == rose_neigh && rose_route->neigh2 == NULL)       ||\n\t\t    (rose_route->neigh2 == rose_neigh && rose_route->neigh1 == NULL)) {\n\t\t\ts = rose_route->next;\n\t\t\trose_remove_route(rose_route);\n\t\t\trose_route = s;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rose_route->neigh1 == rose_neigh) {\n\t\t\trose_route->neigh1->use--;\n\t\t\trose_route->neigh1 = NULL;\n\t\t\trose_transmit_clear_request(rose_route->neigh2, rose_route->lci2, ROSE_OUT_OF_ORDER, 0);\n\t\t}\n\n\t\tif (rose_route->neigh2 == rose_neigh) {\n\t\t\trose_route->neigh2->use--;\n\t\t\trose_route->neigh2 = NULL;\n\t\t\trose_transmit_clear_request(rose_route->neigh1, rose_route->lci1, ROSE_OUT_OF_ORDER, 0);\n\t\t}\n\n\t\trose_route = rose_route->next;\n\t}\n\tspin_unlock_bh(&rose_route_list_lock);\n}\n\n/*\n * \tA level 2 link has timed out, therefore it appears to be a poor link,\n *\tthen don't use that neighbour until it is reset. Blow away all through\n *\troutes and connections using this route.\n */\nvoid rose_link_failed(ax25_cb *ax25, int reason)\n{\n\tstruct rose_neigh *rose_neigh;\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (rose_neigh->ax25 == ax25)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh != NULL) {\n\t\trose_neigh->ax25 = NULL;\n\t\tax25_cb_put(ax25);\n\n\t\trose_del_route_by_neigh(rose_neigh);\n\t\trose_kill_by_neigh(rose_neigh);\n\t}\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}\n\n/*\n * \tA device has been \"downed\" remove its link status. Blow away all\n *\tthrough routes and connections that use this device.\n */\nvoid rose_link_device_down(struct net_device *dev)\n{\n\tstruct rose_neigh *rose_neigh;\n\n\tfor (rose_neigh = rose_neigh_list; rose_neigh != NULL; rose_neigh = rose_neigh->next) {\n\t\tif (rose_neigh->dev == dev) {\n\t\t\trose_del_route_by_neigh(rose_neigh);\n\t\t\trose_kill_by_neigh(rose_neigh);\n\t\t}\n\t}\n}\n\n/*\n *\tRoute a frame to an appropriate AX.25 connection.\n */\nint rose_route_frame(struct sk_buff *skb, ax25_cb *ax25)\n{\n\tstruct rose_neigh *rose_neigh, *new_neigh;\n\tstruct rose_route *rose_route;\n\tstruct rose_facilities_struct facilities;\n\trose_address *src_addr, *dest_addr;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci, new_lci;\n\tunsigned char cause, diagnostic;\n\tstruct net_device *dev;\n\tint res = 0;\n\tchar buf[11];\n\n#if 0\n\tif (call_in_firewall(PF_ROSE, skb->dev, skb->data, NULL, &skb) != FW_ACCEPT)\n\t\treturn res;\n#endif\n\n\tif (skb->len < ROSE_MIN_LEN)\n\t\treturn res;\n\tframetype = skb->data[2];\n\tlci = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\tif (frametype == ROSE_CALL_REQUEST &&\n\t    (skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\n\t     skb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\n\t     ROSE_CALL_REQ_ADDR_LEN_VAL))\n\t\treturn res;\n\tsrc_addr  = (rose_address *)(skb->data + ROSE_CALL_REQ_SRC_ADDR_OFF);\n\tdest_addr = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\tspin_lock_bh(&rose_route_list_lock);\n\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (ax25cmp(&ax25->dest_addr, &rose_neigh->callsign) == 0 &&\n\t\t    ax25->ax25_dev->dev == rose_neigh->dev)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\n\tif (rose_neigh == NULL) {\n\t\tprintk(\"rose_route : unknown neighbour or device %s\\n\",\n\t\t       ax2asc(buf, &ax25->dest_addr));\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tObviously the link is working, halt the ftimer.\n\t */\n\trose_stop_ftimer(rose_neigh);\n\n\t/*\n\t *\tLCI of zero is always for us, and its always a restart\n\t * \tframe.\n\t */\n\tif (lci == 0) {\n\t\trose_link_rx_restart(skb, rose_neigh, frametype);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tFind an existing socket.\n\t */\n\tif ((sk = rose_find_socket(lci, rose_neigh)) != NULL) {\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tstruct rose_sock *rose = rose_sk(sk);\n\n\t\t\t/* Remove an existing unused socket */\n\t\t\trose_clear_queues(sk);\n\t\t\trose->cause\t = ROSE_NETWORK_CONGESTION;\n\t\t\trose->diagnostic = 0;\n\t\t\trose->neighbour->use--;\n\t\t\trose->neighbour\t = NULL;\n\t\t\trose->lci\t = 0;\n\t\t\trose->state\t = ROSE_STATE_0;\n\t\t\tsk->sk_state\t = TCP_CLOSE;\n\t\t\tsk->sk_err\t = 0;\n\t\t\tsk->sk_shutdown\t |= SEND_SHUTDOWN;\n\t\t\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\t\t\tsk->sk_state_change(sk);\n\t\t\t\tsock_set_flag(sk, SOCK_DEAD);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tskb_reset_transport_header(skb);\n\t\t\tres = rose_process_rx_frame(sk, skb);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t *\tIs is a Call Request and is it for us ?\n\t */\n\tif (frametype == ROSE_CALL_REQUEST)\n\t\tif ((dev = rose_dev_get(dest_addr)) != NULL) {\n\t\t\tres = rose_rx_call_request(skb, dev, rose_neigh, lci);\n\t\t\tdev_put(dev);\n\t\t\tgoto out;\n\t\t}\n\n\tif (!sysctl_rose_routing_control) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NOT_OBTAINABLE, 0);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tRoute it to the next in line if we have an entry for it.\n\t */\n\trose_route = rose_route_list;\n\twhile (rose_route != NULL) {\n\t\tif (rose_route->lci1 == lci &&\n\t\t    rose_route->neigh1 == rose_neigh) {\n\t\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\t\t/* F6FBB - Remove an existing unused route */\n\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tbreak;\n\t\t\t} else if (rose_route->neigh2 != NULL) {\n\t\t\t\tskb->data[0] &= 0xF0;\n\t\t\t\tskb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;\n\t\t\t\tskb->data[1]  = (rose_route->lci2 >> 0) & 0xFF;\n\t\t\t\trose_transmit_link(skb, rose_route->neigh2);\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tres = 1;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (rose_route->lci2 == lci &&\n\t\t    rose_route->neigh2 == rose_neigh) {\n\t\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\t\t/* F6FBB - Remove an existing unused route */\n\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tbreak;\n\t\t\t} else if (rose_route->neigh1 != NULL) {\n\t\t\t\tskb->data[0] &= 0xF0;\n\t\t\t\tskb->data[0] |= (rose_route->lci1 >> 8) & 0x0F;\n\t\t\t\tskb->data[1]  = (rose_route->lci1 >> 0) & 0xFF;\n\t\t\t\trose_transmit_link(skb, rose_route->neigh1);\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tres = 1;\n\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tif (frametype == ROSE_CLEAR_CONFIRMATION)\n\t\t\t\t\trose_remove_route(rose_route);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\trose_route = rose_route->next;\n\t}\n\n\t/*\n\t *\tWe know that:\n\t *\t1. The frame isn't for us,\n\t *\t2. It isn't \"owned\" by any existing route.\n\t */\n\tif (frametype != ROSE_CALL_REQUEST) {\t/* XXX */\n\t\tres = 0;\n\t\tgoto out;\n\t}\n\n\tmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\n\n\tif (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,\n\t\t\t\t   skb->len - ROSE_CALL_REQ_FACILITIES_OFF,\n\t\t\t\t   &facilities)) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_INVALID_FACILITY, 76);\n\t\tgoto out;\n\t}\n\n\t/*\n\t *\tCheck for routing loops.\n\t */\n\trose_route = rose_route_list;\n\twhile (rose_route != NULL) {\n\t\tif (rose_route->rand == facilities.rand &&\n\t\t    rosecmp(src_addr, &rose_route->src_addr) == 0 &&\n\t\t    ax25cmp(&facilities.dest_call, &rose_route->src_call) == 0 &&\n\t\t    ax25cmp(&facilities.source_call, &rose_route->dest_call) == 0) {\n\t\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NOT_OBTAINABLE, 120);\n\t\t\tgoto out;\n\t\t}\n\t\trose_route = rose_route->next;\n\t}\n\n\tif ((new_neigh = rose_get_neigh(dest_addr, &cause, &diagnostic, 1)) == NULL) {\n\t\trose_transmit_clear_request(rose_neigh, lci, cause, diagnostic);\n\t\tgoto out;\n\t}\n\n\tif ((new_lci = rose_new_lci(new_neigh)) == 0) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NETWORK_CONGESTION, 71);\n\t\tgoto out;\n\t}\n\n\tif ((rose_route = kmalloc(sizeof(*rose_route), GFP_ATOMIC)) == NULL) {\n\t\trose_transmit_clear_request(rose_neigh, lci, ROSE_NETWORK_CONGESTION, 120);\n\t\tgoto out;\n\t}\n\n\trose_route->lci1      = lci;\n\trose_route->src_addr  = *src_addr;\n\trose_route->dest_addr = *dest_addr;\n\trose_route->src_call  = facilities.dest_call;\n\trose_route->dest_call = facilities.source_call;\n\trose_route->rand      = facilities.rand;\n\trose_route->neigh1    = rose_neigh;\n\trose_route->lci2      = new_lci;\n\trose_route->neigh2    = new_neigh;\n\n\trose_route->neigh1->use++;\n\trose_route->neigh2->use++;\n\n\trose_route->next = rose_route_list;\n\trose_route_list  = rose_route;\n\n\tskb->data[0] &= 0xF0;\n\tskb->data[0] |= (rose_route->lci2 >> 8) & 0x0F;\n\tskb->data[1]  = (rose_route->lci2 >> 0) & 0xFF;\n\n\trose_transmit_link(skb, rose_route->neigh2);\n\tres = 1;\n\nout:\n\tspin_unlock_bh(&rose_route_list_lock);\n\tspin_unlock_bh(&rose_neigh_list_lock);\n\n\treturn res;\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *rose_node_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rose_node_list_lock)\n{\n\tstruct rose_node *rose_node;\n\tint i = 1;\n\n\tspin_lock_bh(&rose_node_list_lock);\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (rose_node = rose_node_list; rose_node && i < *pos;\n\t     rose_node = rose_node->next, ++i);\n\n\treturn (i == *pos) ? rose_node : NULL;\n}\n\nstatic void *rose_node_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\n\treturn (v == SEQ_START_TOKEN) ? rose_node_list\n\t\t: ((struct rose_node *)v)->next;\n}\n\nstatic void rose_node_stop(struct seq_file *seq, void *v)\n\t__releases(rose_node_list_lock)\n{\n\tspin_unlock_bh(&rose_node_list_lock);\n}\n\nstatic int rose_node_show(struct seq_file *seq, void *v)\n{\n\tchar rsbuf[11];\n\tint i;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \"address    mask n neigh neigh neigh\\n\");\n\telse {\n\t\tconst struct rose_node *rose_node = v;\n\t\t/* if (rose_node->loopback) {\n\t\t\tseq_printf(seq, \"%-10s %04d 1 loopback\\n\",\n\t\t\t\t   rose2asc(rsbuf, &rose_node->address),\n\t\t\t\t   rose_node->mask);\n\t\t} else { */\n\t\t\tseq_printf(seq, \"%-10s %04d %d\",\n\t\t\t\t   rose2asc(rsbuf, &rose_node->address),\n\t\t\t\t   rose_node->mask,\n\t\t\t\t   rose_node->count);\n\n\t\t\tfor (i = 0; i < rose_node->count; i++)\n\t\t\t\tseq_printf(seq, \" %05d\",\n\t\t\t\t\trose_node->neighbour[i]->number);\n\n\t\t\tseq_puts(seq, \"\\n\");\n\t\t/* } */\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations rose_node_seqops = {\n\t.start = rose_node_start,\n\t.next = rose_node_next,\n\t.stop = rose_node_stop,\n\t.show = rose_node_show,\n};\n\nstatic int rose_nodes_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &rose_node_seqops);\n}\n\nconst struct file_operations rose_nodes_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rose_nodes_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic void *rose_neigh_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rose_neigh_list_lock)\n{\n\tstruct rose_neigh *rose_neigh;\n\tint i = 1;\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (rose_neigh = rose_neigh_list; rose_neigh && i < *pos;\n\t     rose_neigh = rose_neigh->next, ++i);\n\n\treturn (i == *pos) ? rose_neigh : NULL;\n}\n\nstatic void *rose_neigh_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\n\treturn (v == SEQ_START_TOKEN) ? rose_neigh_list\n\t\t: ((struct rose_neigh *)v)->next;\n}\n\nstatic void rose_neigh_stop(struct seq_file *seq, void *v)\n\t__releases(rose_neigh_list_lock)\n{\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}\n\nstatic int rose_neigh_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11];\n\tint i;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"addr  callsign  dev  count use mode restart  t0  tf digipeaters\\n\");\n\telse {\n\t\tstruct rose_neigh *rose_neigh = v;\n\n\t\t/* if (!rose_neigh->loopback) { */\n\t\tseq_printf(seq, \"%05d %-9s %-4s   %3d %3d  %3s     %3s %3lu %3lu\",\n\t\t\t   rose_neigh->number,\n\t\t\t   (rose_neigh->loopback) ? \"RSLOOP-0\" : ax2asc(buf, &rose_neigh->callsign),\n\t\t\t   rose_neigh->dev ? rose_neigh->dev->name : \"???\",\n\t\t\t   rose_neigh->count,\n\t\t\t   rose_neigh->use,\n\t\t\t   (rose_neigh->dce_mode) ? \"DCE\" : \"DTE\",\n\t\t\t   (rose_neigh->restarted) ? \"yes\" : \"no\",\n\t\t\t   ax25_display_timer(&rose_neigh->t0timer) / HZ,\n\t\t\t   ax25_display_timer(&rose_neigh->ftimer)  / HZ);\n\n\t\tif (rose_neigh->digipeat != NULL) {\n\t\t\tfor (i = 0; i < rose_neigh->digipeat->ndigi; i++)\n\t\t\t\tseq_printf(seq, \" %s\", ax2asc(buf, &rose_neigh->digipeat->calls[i]));\n\t\t}\n\n\t\tseq_puts(seq, \"\\n\");\n\t}\n\treturn 0;\n}\n\n\nstatic const struct seq_operations rose_neigh_seqops = {\n\t.start = rose_neigh_start,\n\t.next = rose_neigh_next,\n\t.stop = rose_neigh_stop,\n\t.show = rose_neigh_show,\n};\n\nstatic int rose_neigh_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &rose_neigh_seqops);\n}\n\nconst struct file_operations rose_neigh_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rose_neigh_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\n\nstatic void *rose_route_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rose_route_list_lock)\n{\n\tstruct rose_route *rose_route;\n\tint i = 1;\n\n\tspin_lock_bh(&rose_route_list_lock);\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\n\tfor (rose_route = rose_route_list; rose_route && i < *pos;\n\t     rose_route = rose_route->next, ++i);\n\n\treturn (i == *pos) ? rose_route : NULL;\n}\n\nstatic void *rose_route_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\n\treturn (v == SEQ_START_TOKEN) ? rose_route_list\n\t\t: ((struct rose_route *)v)->next;\n}\n\nstatic void rose_route_stop(struct seq_file *seq, void *v)\n\t__releases(rose_route_list_lock)\n{\n\tspin_unlock_bh(&rose_route_list_lock);\n}\n\nstatic int rose_route_show(struct seq_file *seq, void *v)\n{\n\tchar buf[11], rsbuf[11];\n\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"lci  address     callsign   neigh  <-> lci  address     callsign   neigh\\n\");\n\telse {\n\t\tstruct rose_route *rose_route = v;\n\n\t\tif (rose_route->neigh1)\n\t\t\tseq_printf(seq,\n\t\t\t\t   \"%3.3X  %-10s  %-9s  %05d      \",\n\t\t\t\t   rose_route->lci1,\n\t\t\t\t   rose2asc(rsbuf, &rose_route->src_addr),\n\t\t\t\t   ax2asc(buf, &rose_route->src_call),\n\t\t\t\t   rose_route->neigh1->number);\n\t\telse\n\t\t\tseq_puts(seq,\n\t\t\t\t \"000  *           *          00000      \");\n\n\t\tif (rose_route->neigh2)\n\t\t\tseq_printf(seq,\n\t\t\t\t   \"%3.3X  %-10s  %-9s  %05d\\n\",\n\t\t\t\t   rose_route->lci2,\n\t\t\t\t   rose2asc(rsbuf, &rose_route->dest_addr),\n\t\t\t\t   ax2asc(buf, &rose_route->dest_call),\n\t\t\t\t   rose_route->neigh2->number);\n\t\t else\n\t\t\t seq_puts(seq,\n\t\t\t\t  \"000  *           *          00000\\n\");\n\t\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations rose_route_seqops = {\n\t.start = rose_route_start,\n\t.next = rose_route_next,\n\t.stop = rose_route_stop,\n\t.show = rose_route_show,\n};\n\nstatic int rose_route_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &rose_route_seqops);\n}\n\nconst struct file_operations rose_routes_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rose_route_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\n#endif /* CONFIG_PROC_FS */\n\n/*\n *\tRelease all memory associated with ROSE routing structures.\n */\nvoid __exit rose_rt_free(void)\n{\n\tstruct rose_neigh *s, *rose_neigh = rose_neigh_list;\n\tstruct rose_node  *t, *rose_node  = rose_node_list;\n\tstruct rose_route *u, *rose_route = rose_route_list;\n\n\twhile (rose_neigh != NULL) {\n\t\ts          = rose_neigh;\n\t\trose_neigh = rose_neigh->next;\n\n\t\trose_remove_neigh(s);\n\t}\n\n\twhile (rose_node != NULL) {\n\t\tt         = rose_node;\n\t\trose_node = rose_node->next;\n\n\t\trose_remove_node(t);\n\t}\n\n\twhile (rose_route != NULL) {\n\t\tu          = rose_route;\n\t\trose_route = rose_route->next;\n\n\t\trose_remove_route(u);\n\t}\n}\n", "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Copyright (C) Jonathan Naylor G4KLX (g4klx@g4klx.demon.co.uk)\n */\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/sockios.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <net/tcp_states.h>\n#include <asm/system.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <net/rose.h>\n\nstatic int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose);\n\n/*\n *\tThis routine purges all of the queues of frames.\n */\nvoid rose_clear_queues(struct sock *sk)\n{\n\tskb_queue_purge(&sk->sk_write_queue);\n\tskb_queue_purge(&rose_sk(sk)->ack_queue);\n}\n\n/*\n * This routine purges the input queue of those frames that have been\n * acknowledged. This replaces the boxes labelled \"V(a) <- N(r)\" on the\n * SDL diagram.\n */\nvoid rose_frames_acked(struct sock *sk, unsigned short nr)\n{\n\tstruct sk_buff *skb;\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\t/*\n\t * Remove all the ack-ed frames from the ack queue.\n\t */\n\tif (rose->va != nr) {\n\t\twhile (skb_peek(&rose->ack_queue) != NULL && rose->va != nr) {\n\t\t\tskb = skb_dequeue(&rose->ack_queue);\n\t\t\tkfree_skb(skb);\n\t\t\trose->va = (rose->va + 1) % ROSE_MODULUS;\n\t\t}\n\t}\n}\n\nvoid rose_requeue_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\n\t/*\n\t * Requeue all the un-ack-ed frames on the output queue to be picked\n\t * up by rose_kick. This arrangement handles the possibility of an\n\t * empty output queue.\n\t */\n\twhile ((skb = skb_dequeue(&rose_sk(sk)->ack_queue)) != NULL) {\n\t\tif (skb_prev == NULL)\n\t\t\tskb_queue_head(&sk->sk_write_queue, skb);\n\t\telse\n\t\t\tskb_append(skb_prev, skb, &sk->sk_write_queue);\n\t\tskb_prev = skb;\n\t}\n}\n\n/*\n *\tValidate that the value of nr is between va and vs. Return true or\n *\tfalse for testing.\n */\nint rose_validate_nr(struct sock *sk, unsigned short nr)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tunsigned short vc = rose->va;\n\n\twhile (vc != rose->vs) {\n\t\tif (nr == vc) return 1;\n\t\tvc = (vc + 1) % ROSE_MODULUS;\n\t}\n\n\treturn nr == rose->vs;\n}\n\n/*\n *  This routine is called when the packet layer internally generates a\n *  control frame.\n */\nvoid rose_write_internal(struct sock *sk, int frametype)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sk_buff *skb;\n\tunsigned char  *dptr;\n\tunsigned char  lci1, lci2;\n\tchar buffer[100];\n\tint len, faclen = 0;\n\n\tlen = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1;\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_REQUEST:\n\t\tlen   += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN;\n\t\tfaclen = rose_create_facilities(buffer, rose);\n\t\tlen   += faclen;\n\t\tbreak;\n\tcase ROSE_CALL_ACCEPTED:\n\tcase ROSE_CLEAR_REQUEST:\n\tcase ROSE_RESET_REQUEST:\n\t\tlen   += 2;\n\t\tbreak;\n\t}\n\n\tif ((skb = alloc_skb(len, GFP_ATOMIC)) == NULL)\n\t\treturn;\n\n\t/*\n\t *\tSpace for AX.25 header and PID.\n\t */\n\tskb_reserve(skb, AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1);\n\n\tdptr = skb_put(skb, skb_tailroom(skb));\n\n\tlci1 = (rose->lci >> 8) & 0x0F;\n\tlci2 = (rose->lci >> 0) & 0xFF;\n\n\tswitch (frametype) {\n\tcase ROSE_CALL_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = ROSE_CALL_REQ_ADDR_LEN_VAL;\n\t\tmemcpy(dptr, &rose->dest_addr,  ROSE_ADDR_LEN);\n\t\tdptr   += ROSE_ADDR_LEN;\n\t\tmemcpy(dptr, &rose->source_addr, ROSE_ADDR_LEN);\n\t\tdptr   += ROSE_ADDR_LEN;\n\t\tmemcpy(dptr, buffer, faclen);\n\t\tdptr   += faclen;\n\t\tbreak;\n\n\tcase ROSE_CALL_ACCEPTED:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = 0x00;\t\t/* Address length */\n\t\t*dptr++ = 0;\t\t/* Facilities length */\n\t\tbreak;\n\n\tcase ROSE_CLEAR_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = rose->cause;\n\t\t*dptr++ = rose->diagnostic;\n\t\tbreak;\n\n\tcase ROSE_RESET_REQUEST:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++ = frametype;\n\t\t*dptr++ = ROSE_DTE_ORIGINATED;\n\t\t*dptr++ = 0;\n\t\tbreak;\n\n\tcase ROSE_RR:\n\tcase ROSE_RNR:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr   = frametype;\n\t\t*dptr++ |= (rose->vr << 5) & 0xE0;\n\t\tbreak;\n\n\tcase ROSE_CLEAR_CONFIRMATION:\n\tcase ROSE_RESET_CONFIRMATION:\n\t\t*dptr++ = ROSE_GFI | lci1;\n\t\t*dptr++ = lci2;\n\t\t*dptr++  = frametype;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"ROSE: rose_write_internal - invalid frametype %02X\\n\", frametype);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\trose_transmit_link(skb, rose->neighbour);\n}\n\nint rose_decode(struct sk_buff *skb, int *ns, int *nr, int *q, int *d, int *m)\n{\n\tunsigned char *frame;\n\n\tframe = skb->data;\n\n\t*ns = *nr = *q = *d = *m = 0;\n\n\tswitch (frame[2]) {\n\tcase ROSE_CALL_REQUEST:\n\tcase ROSE_CALL_ACCEPTED:\n\tcase ROSE_CLEAR_REQUEST:\n\tcase ROSE_CLEAR_CONFIRMATION:\n\tcase ROSE_RESET_REQUEST:\n\tcase ROSE_RESET_CONFIRMATION:\n\t\treturn frame[2];\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((frame[2] & 0x1F) == ROSE_RR  ||\n\t    (frame[2] & 0x1F) == ROSE_RNR) {\n\t\t*nr = (frame[2] >> 5) & 0x07;\n\t\treturn frame[2] & 0x1F;\n\t}\n\n\tif ((frame[2] & 0x01) == ROSE_DATA) {\n\t\t*q  = (frame[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\t\t*d  = (frame[0] & ROSE_D_BIT) == ROSE_D_BIT;\n\t\t*m  = (frame[2] & ROSE_M_BIT) == ROSE_M_BIT;\n\t\t*nr = (frame[2] >> 5) & 0x07;\n\t\t*ns = (frame[2] >> 1) & 0x07;\n\t\treturn ROSE_DATA;\n\t}\n\n\treturn ROSE_ILLEGAL;\n}\n\nstatic int rose_parse_national(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char *pt;\n\tunsigned char l, lg, n = 0;\n\tint fac_national_digis_received = 0;\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tif (len < 3)\n\t\t\t\treturn -1;\n\t\t\tif (*p == FAC_NATIONAL_RAND)\n\t\t\t\tfacilities->rand = ((p[1] << 8) & 0xFF00) + ((p[2] << 0) & 0x00FF);\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tif (len < 4)\n\t\t\t\treturn -1;\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tl = p[1];\n\t\t\tif (len < 2 + l)\n\t\t\t\treturn -1;\n\t\t\tif (*p == FAC_NATIONAL_DEST_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tif (l < AX25_ADDR_LEN)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tmemcpy(&facilities->source_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->source_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_SRC_DIGI) {\n\t\t\t\tif (!fac_national_digis_received) {\n\t\t\t\t\tif (l < AX25_ADDR_LEN)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tmemcpy(&facilities->dest_digis[0], p + 2, AX25_ADDR_LEN);\n\t\t\t\t\tfacilities->dest_ndigis = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_CALL) {\n\t\t\t\tif (l < AX25_ADDR_LEN)\n\t\t\t\t\treturn -1;\n\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tif (l < 1 + ROSE_ADDR_LEN)\n\t\t\t\t\treturn -1;\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tif (l % AX25_ADDR_LEN)\n\t\t\t\t\treturn -1;\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT) {\n\t\t\t\t\t\tif (facilities->dest_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (facilities->source_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n\nstatic int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\n\t\tcase 0x40:\n\t\t\tif (len < 3)\n\t\t\t\treturn -1;\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\n\t\tcase 0x80:\n\t\t\tif (len < 4)\n\t\t\t\treturn -1;\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\n\t\tcase 0xC0:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tl = p[1];\n\n\t\t\t/* Prevent overflows*/\n\t\t\tif (l < 10 || l > 20)\n\t\t\t\treturn -1;\n\n\t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n\t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;\n}\n\nint rose_parse_facilities(unsigned char *p, unsigned packet_len,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\n\tfacilities_len = *p++;\n\n\tif (facilities_len == 0 || (unsigned)facilities_len > packet_len)\n\t\treturn 0;\n\n\twhile (facilities_len >= 3 && *p == 0x00) {\n\t\tfacilities_len--;\n\t\tp++;\n\n\t\tswitch (*p) {\n\t\tcase FAC_NATIONAL:\t\t/* National */\n\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\n\t\tcase FAC_CCITT:\t\t/* CCITT */\n\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\tlen = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (len < 0)\n\t\t\treturn 0;\n\t\tif (WARN_ON(len >= facilities_len))\n\t\t\treturn 0;\n\t\tfacilities_len -= len + 1;\n\t\tp += len + 1;\n\t}\n\n\treturn facilities_len == 0;\n}\n\nstatic int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose)\n{\n\tunsigned char *p = buffer + 1;\n\tchar *callsign;\n\tchar buf[11];\n\tint len, nb;\n\n\t/* National Facilities */\n\tif (rose->rand != 0 || rose->source_ndigis == 1 || rose->dest_ndigis == 1) {\n\t\t*p++ = 0x00;\n\t\t*p++ = FAC_NATIONAL;\n\n\t\tif (rose->rand != 0) {\n\t\t\t*p++ = FAC_NATIONAL_RAND;\n\t\t\t*p++ = (rose->rand >> 8) & 0xFF;\n\t\t\t*p++ = (rose->rand >> 0) & 0xFF;\n\t\t}\n\n\t\t/* Sent before older facilities */\n\t\tif ((rose->source_ndigis > 0) || (rose->dest_ndigis > 0)) {\n\t\t\tint maxdigi = 0;\n\t\t\t*p++ = FAC_NATIONAL_DIGIS;\n\t\t\t*p++ = AX25_ADDR_LEN * (rose->source_ndigis + rose->dest_ndigis);\n\t\t\tfor (nb = 0 ; nb < rose->source_ndigis ; nb++) {\n\t\t\t\tif (++maxdigi >= ROSE_MAX_DIGIS)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(p, &rose->source_digis[nb], AX25_ADDR_LEN);\n\t\t\t\tp[6] |= AX25_HBIT;\n\t\t\t\tp += AX25_ADDR_LEN;\n\t\t\t}\n\t\t\tfor (nb = 0 ; nb < rose->dest_ndigis ; nb++) {\n\t\t\t\tif (++maxdigi >= ROSE_MAX_DIGIS)\n\t\t\t\t\tbreak;\n\t\t\t\tmemcpy(p, &rose->dest_digis[nb], AX25_ADDR_LEN);\n\t\t\t\tp[6] &= ~AX25_HBIT;\n\t\t\t\tp += AX25_ADDR_LEN;\n\t\t\t}\n\t\t}\n\n\t\t/* For compatibility */\n\t\tif (rose->source_ndigis > 0) {\n\t\t\t*p++ = FAC_NATIONAL_SRC_DIGI;\n\t\t\t*p++ = AX25_ADDR_LEN;\n\t\t\tmemcpy(p, &rose->source_digis[0], AX25_ADDR_LEN);\n\t\t\tp   += AX25_ADDR_LEN;\n\t\t}\n\n\t\t/* For compatibility */\n\t\tif (rose->dest_ndigis > 0) {\n\t\t\t*p++ = FAC_NATIONAL_DEST_DIGI;\n\t\t\t*p++ = AX25_ADDR_LEN;\n\t\t\tmemcpy(p, &rose->dest_digis[0], AX25_ADDR_LEN);\n\t\t\tp   += AX25_ADDR_LEN;\n\t\t}\n\t}\n\n\t*p++ = 0x00;\n\t*p++ = FAC_CCITT;\n\n\t*p++ = FAC_CCITT_DEST_NSAP;\n\n\tcallsign = ax2asc(buf, &rose->dest_call);\n\n\t*p++ = strlen(callsign) + 10;\n\t*p++ = (strlen(callsign) + 9) * 2;\t\t/* ??? */\n\n\t*p++ = 0x47; *p++ = 0x00; *p++ = 0x11;\n\t*p++ = ROSE_ADDR_LEN * 2;\n\tmemcpy(p, &rose->dest_addr, ROSE_ADDR_LEN);\n\tp   += ROSE_ADDR_LEN;\n\n\tmemcpy(p, callsign, strlen(callsign));\n\tp   += strlen(callsign);\n\n\t*p++ = FAC_CCITT_SRC_NSAP;\n\n\tcallsign = ax2asc(buf, &rose->source_call);\n\n\t*p++ = strlen(callsign) + 10;\n\t*p++ = (strlen(callsign) + 9) * 2;\t\t/* ??? */\n\n\t*p++ = 0x47; *p++ = 0x00; *p++ = 0x11;\n\t*p++ = ROSE_ADDR_LEN * 2;\n\tmemcpy(p, &rose->source_addr, ROSE_ADDR_LEN);\n\tp   += ROSE_ADDR_LEN;\n\n\tmemcpy(p, callsign, strlen(callsign));\n\tp   += strlen(callsign);\n\n\tlen       = p - buffer;\n\tbuffer[0] = len - 1;\n\n\treturn len;\n}\n\nvoid rose_disconnect(struct sock *sk, int reason, int cause, int diagnostic)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\trose_stop_timer(sk);\n\trose_stop_idletimer(sk);\n\n\trose_clear_queues(sk);\n\n\trose->lci   = 0;\n\trose->state = ROSE_STATE_0;\n\n\tif (cause != -1)\n\t\trose->cause = cause;\n\n\tif (diagnostic != -1)\n\t\trose->diagnostic = diagnostic;\n\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = reason;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n}\n"], "filenames": ["include/net/rose.h", "net/rose/af_rose.c", "net/rose/rose_loopback.c", "net/rose/rose_route.c", "net/rose/rose_subr.c"], "buggy_code_start_loc": [15, 981, 75, 864, 145], "buggy_code_end_loc": [218, 993, 79, 1019, 411], "fixing_code_start_loc": [16, 981, 76, 864, 145], "fixing_code_end_loc": [224, 993, 90, 1025, 434], "type": "CWE-20", "message": "The ROSE protocol implementation in the Linux kernel before 2.6.39 does not verify that certain data-length values are consistent with the amount of data sent, which might allow remote attackers to obtain sensitive information from kernel memory or cause a denial of service (out-of-bounds read) via crafted data to a ROSE socket.", "other": {"cve": {"id": "CVE-2011-4914", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:02.457", "lastModified": "2023-02-13T00:22:19.087", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The ROSE protocol implementation in the Linux kernel before 2.6.39 does not verify that certain data-length values are consistent with the amount of data sent, which might allow remote attackers to obtain sensitive information from kernel memory or cause a denial of service (out-of-bounds read) via crafted data to a ROSE socket."}, {"lang": "es", "value": "La implementaci\u00f3n del protocolo ROSE en el kernel de Linux anteriores a v2.6.39 no verifica que algunos valores de la longitud de datos son consistentes con la cantidad de datos enviada, lo que podr\u00eda permitir a atacantes remotos a obtener informaci\u00f3n sensible de la memoria del kernel o provocar una denegaci\u00f3n de servicio (lectura fuera de los l\u00edmites) a trav\u00e9s de una cadena de datos manipulada sobre un socket ROSE.\r\n"}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.38.8", "matchCriteriaId": "57A0A2B0-3B9F-40C2-8C7A-CD9590B51315"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:*:*:*:*:*:*:*", "matchCriteriaId": "7462DB6D-E0A6-4DBB-8E21-66B875184FFC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc1:*:*:*:*:*:*", "matchCriteriaId": "2DDCB342-4F5F-4BF1-9624-882BBC57330D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc2:*:*:*:*:*:*", "matchCriteriaId": "C3AB4113-BF83-4587-8A85-0E4FECEE7D9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc3:*:*:*:*:*:*", "matchCriteriaId": "4B57F5AD-A697-4090-89B9-81BC12993A1A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc4:*:*:*:*:*:*", "matchCriteriaId": "CA141BCB-A705-4DF5-9EED-746B62C86111"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc5:*:*:*:*:*:*", "matchCriteriaId": "E9ECE134-58A3-4B9D-B9B3-F836C0EDD64C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc6:*:*:*:*:*:*", "matchCriteriaId": "56186720-6B4C-4D71-85C5-7EAC5C5D84A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc7:*:*:*:*:*:*", "matchCriteriaId": "9BBB4630-CBED-43B9-B203-BE65BBF011AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38:rc8:*:*:*:*:*:*", "matchCriteriaId": "FD375A78-63D7-441A-9FB0-7BC878AB4EDD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.1:*:*:*:*:*:*:*", "matchCriteriaId": "A5BEFFDD-02BB-4A05-8372-891DBDB9AC5A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.2:*:*:*:*:*:*:*", "matchCriteriaId": "766E193D-819C-42EA-8411-AE0013AC15FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.3:*:*:*:*:*:*:*", "matchCriteriaId": "3B39B6AF-6A83-48C2-BED2-79228F8513A6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.4:*:*:*:*:*:*:*", "matchCriteriaId": "CD8A68D1-DFE9-4ADB-9FB8-4D69AB4CAFF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.5:*:*:*:*:*:*:*", "matchCriteriaId": "0D6EF951-AF15-4C30-A3A5-3392AA61813C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.6:*:*:*:*:*:*:*", "matchCriteriaId": "15154FA0-65DC-4855-AC70-3ACF92313F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:2.6.38.7:*:*:*:*:*:*:*", "matchCriteriaId": "F4B3A9F4-A61F-4919-A173-3E459F0C5AF8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_server:10.0:sp4:*:*:ltss:*:*:*", "matchCriteriaId": "1D421F7F-A203-4868-846D-3A057610D399"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=e0bccd315db0c2f919e7fcf9cb60db21d9986f52", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/12/28/2", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=770777", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52"}}