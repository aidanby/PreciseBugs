{"buggy_code": ["## ---------------------------------------------------------------------------\n## See the NOTICE file distributed with this work for additional\n## information regarding copyright ownership.\n##\n## This is free software; you can redistribute it and/or modify it\n## under the terms of the GNU Lesser General Public License as\n## published by the Free Software Foundation; either version 2.1 of\n## the License, or (at your option) any later version.\n##\n## This software is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n## Lesser General Public License for more details.\n##\n## You should have received a copy of the GNU Lesser General Public\n## License along with this software; if not, write to the Free\n## Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n## 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n## ---------------------------------------------------------------------------\n#template('drawer_macros.vm')\n##\n## Display the drawer\n##\n<nav class=\"drawer-nav\" id=\"tmDrawer\">\n  <ul class=\"drawer-menu\">\n    ##\n    ## Drawer header (with elements concerning the current user: profile, login, logout, register, etc...)\n    ##\n    <li class=\"drawer-brand clearfix\">\n      <a href=\"$xwiki.getURL($xcontext.user, 'view')\">\n        #largeUserAvatar($xcontext.user)\n      </a>\n      <div class=\"brand-links\">\n        #if ($xcontext.user != 'XWiki.XWikiGuest')\n          <a href=\"$xwiki.getURL($xcontext.user, 'view')\" class=\"brand-user\" id=\"tmUser\">$!xwiki.getUserName($xcontext.user, false)</a>\n          <a href=\"$xwiki.getURL('XWiki.XWikiLogout', 'logout', \"xredirect=$escapetool.url($xwiki.relativeRequestURL)\")\" id=\"tmLogout\" rel=\"nofollow\">$services.icon.renderHTML('log-out') $escapetool.xml($services.localization.render('logout'))</a>\n        #else\n          <a href=\"$xwiki.getURL('XWiki.XWikiLogin', 'login', \"xredirect=$escapetool.url($xwiki.relativeRequestURL)&loginLink=1\")\" id=\"tmLogin\" rel=\"nofollow\">$services.icon.renderHTML('log-in') $escapetool.xml($services.localization.render('login'))</a>\n          #if ($xwiki.hasAccessLevel('register', 'XWiki.XWikiPreferences'))\n            <a href=\"$xwiki.getURL('XWiki.XWikiRegister', 'register', \"xredirect=$escapetool.url($xwiki.relativeRequestURL)\")\" id=\"tmRegister\" rel=\"nofollow\">$services.icon.renderHTML('log-in') $escapetool.xml($services.localization.render('register'))</a>\n          #end\n        #end\n        ##\n        ## UIX\n        ##\n        #displayDrawerUIX('org.xwiki.plaftorm.drawer.header')\n      </div>\n    </li>\n    ##\n    ## Display the content of the drawer\n    ##\n    #set ($drawerExtensions = $services.uix.getExtensions('org.xwiki.plaftorm.drawer', {'sortByParameter' : 'order'}))\n    ## Logs to debug problems when displaying UIXes.\n    #set ($discard = $services.logging.getLogger('drawer.vm').debug('Drawer UIXes: [{}]', $drawerExtensions))\n    ##\n    ## Local Category\n    ##\n    #drawerCategoryHeader($services.wiki.currentWikiDescriptor.prettyName)\n    ##\n    ## Display an \"Administer wiki\" item if the Administration App is not installed.\n    ## The role of the item is to help the user importing content.\n    ##\n    #if ($hasGlobalAdmin)\n      #set ($importaction = $!xwiki.getURL('XWiki.XWikiPreferences', 'import'))\n      #if (!$isAdminAppInstalled)\n        ## If the admin application is not installed, we add a link to import it.\n        ## Otherwise, we let the admin application adds the correct UIX to administrate the wiki.\n        #set ($importaction = $!xwiki.getURL('XWiki.XWikiPreferences', 'import'))\n        #drawerItem($importaction, 'wrench', $escapetool.xml($services.localization.render('core.menu.admin')), 'tmAdminWiki')\n        #drawerSeparator()\n      #end\n    #end\n    ##\n    ## UIX: Drawer items for the current wiki\n    ##\n    #displayTheseDrawerUIX($drawerExtensions, 'local')\n    ##\n    ## Global category\n    ##\n    #define ($globalPart)\n      ##\n      ## Languages\n      ##\n      #template('menus_language.vm')\n      ##\n      ## UIX: Drawer items for the global scope\n      ##\n      #displayTheseDrawerUIX($drawerExtensions, 'global')\n    #end\n    #if ($stringtool.isNotBlank($globalPart.toString()))\n      #drawerCategoryHeader($services.localization.render('core.drawer.global'))\n      $globalPart\n    #end\n  </ul>\n</nav>\n#**\n * Display the UI extensions.\n *\n * @param $name the name of the UI extension to display\n * @param $category the name of the category to filter on (by default, it fallbacks on \"local\")\n *#\n#macro(displayDrawerUIX $name $category)\n  #displayTheseDrawerUIX($services.uix.getExtensions($name, {'sortByParameter' : 'order'}), $category)\n#end\n#**\n * Display the UI extensions.\n *\n * @param $extensions a list of extensions to display\n * @param $category the name of the category to filter on (by default, it fallbacks on \"local\")\n *#\n#macro(displayTheseDrawerUIX $extensions $category)\n  #set ($canHaveMenuSeparator = false)\n  #if (\"$!category\" == '')\n    #set ($category = 'local')\n  #end\n  #foreach($uix in $extensions)\n    #set ($uixCategory = \"$!uix.parameters.category\")\n    #set ($hasAccessForDrawerUIX = $services.security.authorization.hasAccess('admin', $uix.authorReference, $services.wiki.currentWikiDescriptor.reference))\n    ## Logs to debug problems when displaying UIXes.\n    #set ($discard = $services.logging.getLogger('drawer.vm').debug('Drawer UIX [{}] - Reference: [{}]', $uix, $!uix.documentReference))\n    #set ($discard = $services.logging.getLogger('drawer.vm').debug('Drawer UIX [{}] - Author: [{}]', $uix, $!uix.authorReference))\n    #set ($discard = $services.logging.getLogger('drawer.vm').debug('Drawer UIX [{}] - Category: [{}] - UIX Category: [{}]', $uix, $category, $uixCategory))\n    #set ($discard = $services.logging.getLogger('drawer.vm').debug('Drawer UIX [{}] - Permission: [{}]', $uix, $hasAccessForDrawerUIX))\n    #if (($uixCategory == $category || $category == 'local' && $uixCategory == '') && $hasAccessForDrawerUIX)\n      #if (\"$!uix.getParameters().separator\" == 'true' && $canHaveMenuSeparator)\n        #drawerSeparator()\n        #set ($canHaveMenuSeparator = false)\n      #end\n      #set ($content = $services.rendering.render($uix.execute(), 'html/5.0'))\n      $content\n      #if (!$canHaveMenuSeparator && $stringtool.isNotBlank($content))\n        #set ($canHaveMenuSeparator = true)\n      #end\n    #end\n  #end\n#end\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.notifications.rest.internal;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.ws.rs.core.CacheControl;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.core.Response.Status;\n\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.notifications.CompositeEvent;\nimport org.xwiki.notifications.NotificationException;\nimport org.xwiki.notifications.notifiers.internal.DefaultNotificationCacheManager;\nimport org.xwiki.notifications.notifiers.rss.NotificationRSSManager;\nimport org.xwiki.notifications.rest.NotificationsResource;\nimport org.xwiki.notifications.rest.model.Notifications;\nimport org.xwiki.notifications.sources.NotificationParameters;\nimport org.xwiki.notifications.sources.ParametrizedNotificationManager;\nimport org.xwiki.notifications.sources.internal.DefaultNotificationParametersFactory;\nimport org.xwiki.notifications.sources.internal.DefaultNotificationParametersFactory.ParametersKey;\nimport org.xwiki.rest.XWikiResource;\n\nimport com.rometools.rome.io.SyndFeedOutput;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.web.XWikiRequest;\n\n/**\n * Default implementation of {@link NotificationsResource}.\n *\n * @version $Id$\n * @since 10.4RC1\n */\n@Component\n@Named(\"org.xwiki.notifications.rest.internal.DefaultNotificationsResource\")\npublic class DefaultNotificationsResource extends XWikiResource implements NotificationsResource\n{\n    private static final String TRUE = \"true\";\n\n    @Inject\n    private ParametrizedNotificationManager newNotificationManager;\n\n    @Inject\n    private DocumentReferenceResolver<String> documentReferenceResolver;\n\n    @Inject\n    private InternalNotificationsRenderer notificationsRenderer;\n\n    @Inject\n    private NotificationRSSManager notificationRSSManager;\n\n    @Inject\n    private DefaultNotificationCacheManager cacheManager;\n\n    @Inject\n    private NotificationEventExecutor executor;\n\n    @Inject\n    private DefaultNotificationParametersFactory notificationParametersFactory;\n\n    @Override\n    public Response getNotifications(String useUserPreferences, String userId, String untilDate,\n        boolean untilDateIncluded, String blackList, String pages, String spaces, String wikis, String users,\n        String maxCount, String displayOwnEvents, String displayMinorEvents, String displaySystemEvents,\n        String displayReadEvents, String displayReadStatus, String tags, String currentWiki, String async,\n        String asyncId) throws Exception\n    {\n        // Build the response\n        Response.ResponseBuilder response;\n        Object result = getCompositeEvents(useUserPreferences, userId, untilDate, untilDateIncluded, blackList, pages,\n            spaces, wikis, users, toMaxCount(maxCount, 21), displayOwnEvents, displayMinorEvents, displaySystemEvents,\n            displayReadEvents, tags, currentWiki, async, asyncId, false, false);\n\n        if (result instanceof String) {\n            response = Response.status(Status.ACCEPTED);\n            response.entity(Collections.singletonMap(\"asyncId\", result));\n        } else {\n            // Make sure URLs will be rendered like in any other display (by default REST API forces absolute URLs)\n            XWikiContext xcontext = getXWikiContext();\n            xcontext.setURLFactory(\n                xcontext.getWiki().getURLFactoryService().createURLFactory(XWikiContext.MODE_SERVLET, xcontext));\n\n            // Make sure to rendering the notifications in the right wiki\n            String currentOriginalWiki = xcontext.getOriginalWikiId();\n            try {\n                if (currentWiki != null) {\n                    xcontext.setOriginalWikiId(currentWiki);\n                }\n\n                Notifications notifications = new Notifications(this.notificationsRenderer\n                    .renderNotifications((List<CompositeEvent>) result, userId, TRUE.equals(displayReadStatus)));\n\n                response = Response.ok(notifications);\n            } finally {\n                xcontext.setOriginalWikiId(currentOriginalWiki);\n            }\n        }\n\n        // Add the \"cache control\" header.\n        CacheControl cacheControl = new CacheControl();\n        cacheControl.setNoCache(true);\n        response.cacheControl(cacheControl);\n\n        return response.build();\n    }\n\n    private int toMaxCount(String maxCount, int defaultMaxCount)\n    {\n        return NumberUtils.toInt(maxCount, defaultMaxCount);\n    }\n\n    private Object getCompositeEvents(String useUserPreferences, String userId, String untilDate,\n        boolean untilDateIncluded, String blackList, String pages, String spaces, String wikis, String users,\n        int maxCount, String displayOwnEvents, String displayMinorEvents, String displaySystemEvents,\n        String displayReadEvents, String tags, String currentWiki, String async, String asyncId, boolean onlyUnread,\n        boolean count) throws Exception\n    {\n        Object result = null;\n        NotificationParameters notificationParameters = getNotificationParameters(useUserPreferences, userId, untilDate,\n            untilDateIncluded, blackList, pages, spaces, wikis, users, maxCount, displayOwnEvents, displayMinorEvents,\n            displaySystemEvents, displayReadEvents, tags, currentWiki, onlyUnread);\n\n        // 1. Check current asynchronous execution\n        if (asyncId != null) {\n            result = this.executor.popAsync(asyncId);\n\n            if (result == null) {\n                // Another round\n                result = asyncId;\n            }\n        }\n\n        if (result == null) {\n            // 2. Generate the cache key\n            String cacheKey = this.cacheManager.createCacheKey(notificationParameters);\n\n            // 3. Search events\n            result = this.executor.submit(cacheKey,\n                () -> getCompositeEvents(notificationParameters),\n                Boolean.parseBoolean(async), count);\n        }\n\n        return result;\n    }\n\n    private List<CompositeEvent> getCompositeEvents(NotificationParameters notificationParameters)\n        throws NotificationException\n    {\n        return this.newNotificationManager.getEvents(notificationParameters);\n    }\n\n    @Override\n    public Response getNotificationsCount(String useUserPreferences, String userId, String pages, String spaces,\n        String wikis, String users, String maxCount, String displayOwnEvents, String displayMinorEvents,\n        String displaySystemEvents, String displayReadEvents, String displayReadStatus, String tags, String currentWiki,\n        String async, String asyncId) throws Exception\n    {\n        // Build the response\n        Response.ResponseBuilder response;\n        XWikiUser xWikiUser = getXWikiContext().getWiki().getAuthService().checkAuth(getXWikiContext());\n        if (xWikiUser == null) {\n            response = Response.status(Status.UNAUTHORIZED);\n        } else {\n            Object result = getCompositeEvents(useUserPreferences, userId, null, true, null, pages, spaces, wikis,\n                users, toMaxCount(maxCount, 21), displayOwnEvents, displayMinorEvents, displaySystemEvents,\n                displayReadEvents, tags, currentWiki, async, asyncId, true, true);\n\n            if (result instanceof String) {\n                response = Response.status(Status.ACCEPTED);\n                response.entity(Collections.singletonMap(\"asyncId\", result));\n            } else {\n                response = Response.ok(Collections.singletonMap(\"unread\", result));\n            }\n\n            // Add the \"cache control\" header.\n            CacheControl cacheControl = new CacheControl();\n            cacheControl.setNoCache(true);\n            response.cacheControl(cacheControl);\n        }\n        return response.build();\n    }\n\n    @Override\n    public String getNotificationsRSS(String useUserPreferences, String userId, String untilDate, String blackList,\n        String pages, String spaces, String wikis, String users, String maxCount, String displayOwnEvents,\n        String displayMinorEvents, String displaySystemEvents, String displayReadEvents, String displayReadStatus,\n        String tags, String currentWiki) throws Exception\n    {\n        // Build the response\n        XWikiUser xWikiUser = getXWikiContext().getWiki().getAuthService().checkAuth(getXWikiContext());\n        DocumentReference userIdDoc = this.documentReferenceResolver.resolve(userId);\n        if (xWikiUser == null || !userIdDoc.equals(xWikiUser.getUserReference())) {\n            getXWikiContext().getResponse().sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return null;\n        } else {\n            List<CompositeEvent> events =\n                (List<CompositeEvent>) getCompositeEvents(useUserPreferences, userId, untilDate, true, blackList, pages,\n                    spaces, wikis, users, toMaxCount(maxCount, 10), displayOwnEvents, displayMinorEvents,\n                    displaySystemEvents, displayReadEvents, tags, currentWiki, null, null, false, false);\n\n            SyndFeedOutput output = new SyndFeedOutput();\n            return output.outputString(notificationRSSManager.renderFeed(events));\n        }\n    }\n\n    @Override\n    public Response postNotifications() throws Exception\n    {\n        // We should seriously consider to stop using Restlet, because the @FormParam attribute does not work.\n        // See: https://github.com/restlet/restlet-framework-java/issues/1120\n        // That's why we need to use this workaround: manually getting the POST params in the request object.\n        XWikiRequest request = getXWikiContext().getRequest();\n        return getNotifications(request.get(\"useUserPreferences\"), request.get(\"userId\"), request.get(\"untilDate\"),\n            BooleanUtils.toBooleanObject(request.get(\"untilDateIncluded\")) != Boolean.FALSE, request.get(\"blackList\"),\n            request.get(\"pages\"), request.get(\"spaces\"), request.get(\"wikis\"), request.get(\"users\"),\n            request.get(\"count\"), request.get(\"displayOwnEvents\"), request.get(\"displayMinorEvents\"),\n            request.get(\"displaySystemEvents\"), request.get(\"displayReadEvents\"), request.get(\"displayReadStatus\"),\n            request.get(\"tags\"), request.get(\"currentWiki\"), request.get(\"async\"), request.get(\"asyncId\"));\n    }\n\n    private NotificationParameters getNotificationParameters(String useUserPreferences, String userId, String untilDate,\n        boolean untilDateIncluded, String blackList, String pages, String spaces, String wikis, String users,\n        int maxCount, String displayOwnEvents, String displayMinorEvents, String displaySystemEvents,\n        String displayReadEvents, String tags, String currentWiki, boolean onlyUnread) throws NotificationException\n    {\n        Map<ParametersKey, String> parametersMap = new HashMap<>();\n        parametersMap.put(ParametersKey.USE_USER_PREFERENCES, useUserPreferences);\n        parametersMap.put(ParametersKey.USER_ID, userId);\n        parametersMap.put(ParametersKey.UNTIL_DATE, untilDate);\n        parametersMap.put(ParametersKey.UNTIL_DATE_INCLUDED, String.valueOf(untilDateIncluded));\n        parametersMap.put(ParametersKey.BLACKLIST, blackList);\n        parametersMap.put(ParametersKey.PAGES, pages);\n        parametersMap.put(ParametersKey.SPACES, spaces);\n        parametersMap.put(ParametersKey.WIKIS, wikis);\n        parametersMap.put(ParametersKey.USERS, users);\n        parametersMap.put(ParametersKey.MAX_COUNT, String.valueOf(maxCount));\n        parametersMap.put(ParametersKey.DISPLAY_OWN_EVENTS, displayOwnEvents);\n        parametersMap.put(ParametersKey.DISPLAY_MINOR_EVENTS, displayMinorEvents);\n        parametersMap.put(ParametersKey.DISPLAY_SYSTEM_EVENTS, displaySystemEvents);\n        parametersMap.put(ParametersKey.DISPLAY_READ_EVENTS, displayReadEvents);\n        parametersMap.put(ParametersKey.TAGS, tags);\n        parametersMap.put(ParametersKey.CURRENT_WIKI, currentWiki);\n        parametersMap.put(ParametersKey.ONLY_UNREAD, String.valueOf(onlyUnread));\n\n        return this.notificationParametersFactory.createNotificationParameters(parametersMap);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.FileTime;\nimport java.text.DateFormatSymbols;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.Vector;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.zip.ZipOutputStream;\n\nimport javax.annotation.Priority;\nimport javax.inject.Provider;\nimport javax.mail.Message;\nimport javax.mail.Session;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport javax.naming.NamingException;\nimport javax.script.ScriptContext;\nimport javax.servlet.http.Cookie;\n\nimport org.apache.commons.httpclient.Credentials;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.URIException;\nimport org.apache.commons.httpclient.UsernamePasswordCredentials;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.util.URIUtil;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.hibernate.HibernateException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentCreatingEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentDeletingEvent;\nimport org.xwiki.bridge.event.DocumentRestoredEvent;\nimport org.xwiki.bridge.event.DocumentRestoringEvent;\nimport org.xwiki.bridge.event.DocumentRolledBackEvent;\nimport org.xwiki.bridge.event.DocumentRollingBackEvent;\nimport org.xwiki.bridge.event.DocumentUpdatedEvent;\nimport org.xwiki.bridge.event.DocumentUpdatingEvent;\nimport org.xwiki.bridge.event.DocumentVersionRangeDeletedEvent;\nimport org.xwiki.bridge.event.DocumentVersionRangeDeletingEvent;\nimport org.xwiki.bridge.event.WikiCopiedEvent;\nimport org.xwiki.bridge.event.WikiDeletedEvent;\nimport org.xwiki.cache.Cache;\nimport org.xwiki.classloader.ClassLoaderManager;\nimport org.xwiki.component.event.ComponentDescriptorAddedEvent;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.manager.NamespacedComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.container.servlet.HttpServletUtils;\nimport org.xwiki.context.Execution;\nimport org.xwiki.edit.EditConfiguration;\nimport org.xwiki.extension.job.internal.InstallJob;\nimport org.xwiki.extension.job.internal.UninstallJob;\nimport org.xwiki.job.Job;\nimport org.xwiki.job.JobException;\nimport org.xwiki.job.JobExecutor;\nimport org.xwiki.job.annotation.Serializable;\nimport org.xwiki.job.event.JobFinishedEvent;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.job.event.status.JobStatus.State;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.mail.MailListener;\nimport org.xwiki.mail.MailSender;\nimport org.xwiki.mail.MailSenderConfiguration;\nimport org.xwiki.mail.MailStatusResultSerializer;\nimport org.xwiki.mail.XWikiAuthenticator;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.AttachmentReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.PageReferenceResolver;\nimport org.xwiki.model.reference.RegexEntityReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.event.CancelableEvent;\nimport org.xwiki.observation.event.Event;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryFilter;\nimport org.xwiki.refactoring.ReferenceRenamer;\nimport org.xwiki.refactoring.batch.BatchOperationExecutor;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.Block.Axes;\nimport org.xwiki.rendering.block.MetaDataBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.MetadataBlockMatcher;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.renderer.BlockRenderer;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxContent;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.resource.ResourceReference;\nimport org.xwiki.resource.ResourceReferenceManager;\nimport org.xwiki.resource.ResourceReferenceResolver;\nimport org.xwiki.resource.ResourceType;\nimport org.xwiki.resource.ResourceTypeResolver;\nimport org.xwiki.resource.entity.EntityResourceReference;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.skin.Resource;\nimport org.xwiki.skin.Skin;\nimport org.xwiki.skin.SkinManager;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.url.ExtendedURL;\nimport org.xwiki.url.URLConfiguration;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserPropertiesResolver;\nimport org.xwiki.velocity.VelocityContextFactory;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.velocity.XWikiVelocityContext;\nimport org.xwiki.velocity.XWikiVelocityException;\nimport org.xwiki.wiki.descriptor.WikiDescriptor;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\nimport org.xwiki.wiki.manager.WikiManager;\nimport org.xwiki.wiki.manager.WikiManagerException;\nimport org.xwiki.xml.XMLUtils;\n\nimport com.xpn.xwiki.api.Api;\nimport com.xpn.xwiki.api.Document;\nimport com.xpn.xwiki.api.User;\nimport com.xpn.xwiki.criteria.api.XWikiCriteriaService;\nimport com.xpn.xwiki.doc.DeletedAttachment;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.MandatoryDocumentInitializer;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiAttachmentArchive;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocument.XWikiAttachmentToRemove;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.internal.WikiInitializerJob;\nimport com.xpn.xwiki.internal.WikiInitializerRequest;\nimport com.xpn.xwiki.internal.XWikiCfgConfigurationSource;\nimport com.xpn.xwiki.internal.XWikiConfigDelegate;\nimport com.xpn.xwiki.internal.XWikiInitializerJob;\nimport com.xpn.xwiki.internal.debug.DebugConfiguration;\nimport com.xpn.xwiki.internal.event.MandatoryDocumentsInitializedEvent;\nimport com.xpn.xwiki.internal.event.MandatoryDocumentsInitializingEvent;\nimport com.xpn.xwiki.internal.event.UserCreatingDocumentEvent;\nimport com.xpn.xwiki.internal.event.UserDeletingDocumentEvent;\nimport com.xpn.xwiki.internal.event.UserUpdatingDocumentEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyAddedEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyDeletedEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyUpdatedEvent;\nimport com.xpn.xwiki.internal.mandatory.XWikiPreferencesDocumentInitializer;\nimport com.xpn.xwiki.internal.render.OldRendering;\nimport com.xpn.xwiki.internal.render.groovy.ParseGroovyFromString;\nimport com.xpn.xwiki.internal.skin.InternalSkinConfiguration;\nimport com.xpn.xwiki.internal.skin.InternalSkinManager;\nimport com.xpn.xwiki.internal.skin.WikiSkin;\nimport com.xpn.xwiki.internal.skin.WikiSkinUtils;\nimport com.xpn.xwiki.internal.store.StoreConfiguration;\nimport com.xpn.xwiki.internal.store.hibernate.HibernateConfiguration;\nimport com.xpn.xwiki.internal.velocity.VelocityEvaluator;\nimport com.xpn.xwiki.job.JobRequestContext;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.PropertyInterface;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PasswordClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.meta.MetaClass;\nimport com.xpn.xwiki.plugin.XWikiPluginInterface;\nimport com.xpn.xwiki.plugin.XWikiPluginManager;\nimport com.xpn.xwiki.render.groovy.XWikiPageClassLoader;\nimport com.xpn.xwiki.stats.api.XWikiStatsService;\nimport com.xpn.xwiki.stats.impl.SearchEngineRule;\nimport com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl;\nimport com.xpn.xwiki.store.AttachmentRecycleBinStore;\nimport com.xpn.xwiki.store.AttachmentVersioningStore;\nimport com.xpn.xwiki.store.XWikiAttachmentStoreInterface;\nimport com.xpn.xwiki.store.XWikiCacheStoreInterface;\nimport com.xpn.xwiki.store.XWikiHibernateStore;\nimport com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.user.api.XWikiAuthService;\nimport com.xpn.xwiki.user.api.XWikiGroupService;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiRightServiceImpl;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.util.XWikiStubContextProvider;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiEngineContext;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiServletRequestStub;\nimport com.xpn.xwiki.web.XWikiURLFactory;\nimport com.xpn.xwiki.web.XWikiURLFactoryService;\nimport com.xpn.xwiki.web.XWikiURLFactoryServiceImpl;\n\n@Serializable(false)\npublic class XWiki implements EventListener\n{\n    /** Name of the default wiki. */\n    public static final String DEFAULT_MAIN_WIKI = \"xwiki\";\n\n    /** Name of the default home space. */\n    public static final String DEFAULT_HOME_SPACE = \"Main\";\n\n    /** Name of the default system space. */\n    public static final String SYSTEM_SPACE = \"XWiki\";\n\n    /**\n     * Name of the default system space as an EntityReference.\n     * \n     * @since 13.2RC1\n     */\n    public static final EntityReference SYSTEM_SPACE_REFERENCE = new EntityReference(\"XWiki\", EntityType.SPACE);\n\n    /** Name of the default space homepage. */\n    public static final String DEFAULT_SPACE_HOMEPAGE = \"WebHome\";\n\n    public static final String CKEY_SKIN = InternalSkinManager.CKEY_SKIN;\n\n    public static final String CKEY_BASESKIN = InternalSkinManager.CKEY_PARENTSKIN;\n\n    public static final String DEFAULT_SKIN = InternalSkinConfiguration.DEFAULT_SKIN;\n\n    /**\n     * Query parameters used to control the browser cache version of a resource.\n     */\n    public static final String CACHE_VERSION = \"cache-version\";\n\n    /** Logging helper object. */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);\n\n    /** Frequently used Document reference, the class which holds virtual wiki definitions. */\n    private static final DocumentReference VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE =\n        new DocumentReference(DEFAULT_MAIN_WIKI, SYSTEM_SPACE, \"XWikiServerClass\");\n\n    /** The default encoding, and the internally used encoding when dealing with byte representation of strings. */\n    public static final String DEFAULT_ENCODING = \"UTF-8\";\n\n    /** Represents no value (ie the default value will be used) in xproperties */\n    private static final String NO_VALUE = \"---\";\n\n    /**\n     * List of top level space names that can be used in the fake context document created when accessing a resource\n     * with the 'skin' action.\n     */\n    private static final List<String> SKIN_RESOURCE_SPACE_NAMES = Arrays.asList(\"skins\", \"resources\");\n\n    /** The main document storage. */\n    private XWikiStoreInterface store;\n\n    /** The attachment content storage. */\n    private XWikiAttachmentStoreInterface defaultAttachmentContentStore;\n\n    /** The attachment archive storage. */\n    private AttachmentVersioningStore defaultAttachmentArchiveStore;\n\n    /** Document versioning storage. */\n    private XWikiVersioningStoreInterface versioningStore;\n\n    /** Deleted documents storage. */\n    private XWikiRecycleBinStoreInterface recycleBinStore;\n\n    private AttachmentRecycleBinStore attachmentRecycleBinStore;\n\n    private XWikiPluginManager pluginManager;\n\n    private XWikiAuthService authService;\n\n    private XWikiRightService rightService;\n\n    private XWikiGroupService groupService;\n\n    private XWikiStatsService statsService;\n\n    private XWikiURLFactoryService urlFactoryService;\n\n    private XWikiCriteriaService criteriaService;\n\n    /** Lock object used for the lazy initialization of the authentication service. */\n    private final Object AUTH_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the authorization service. */\n    private final Object RIGHT_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the group management service. */\n    private final Object GROUP_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the statistics service. */\n    private final Object STATS_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the URL Factory service. */\n    private final Object URLFACTORY_SERVICE_LOCK = new Object();\n\n    private MetaClass metaclass;\n\n    private String version;\n\n    private XWikiEngineContext engine_context;\n\n    private String database;\n\n    private String fullNameSQL;\n\n    /**\n     * The list of initialized wikis.\n     */\n    private Map<String, WikiInitializerJob> initializedWikis = new ConcurrentHashMap<>();\n\n    private boolean isReadOnly = false;\n\n    /**\n     * @deprecated since 6.1M2, use {@link XWikiCfgConfigurationSource#CFG_ENV_NAME} instead\n     */\n    @Deprecated\n    public static final String CFG_ENV_NAME = XWikiCfgConfigurationSource.CFG_ENV_NAME;\n\n    public static final String MACROS_FILE = \"/templates/macros.txt\";\n\n    /**\n     * File containing XWiki's version, in the format: <version name>.<SVN revision number>.\n     */\n    private static final String VERSION_FILE = \"/WEB-INF/version.properties\";\n\n    /**\n     * Property containing the version value in the {@link #VERSION_FILE} file.\n     */\n    private static final String VERSION_FILE_PROPERTY = \"version\";\n\n    private static XWikiInitializerJob job;\n\n    /** Used to convert a proper Document Reference to string (standard form). */\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead.\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    private DocumentReferenceResolver<EntityReference> currentReferenceDocumentReferenceResolver;\n\n    private EntityReferenceResolver<String> currentMixedEntityReferenceResolver;\n\n    private EntityReferenceResolver<String> relativeEntityReferenceResolver;\n\n    private EntityReferenceSerializer<String> localStringEntityReferenceSerializer;\n\n    private ResourceReferenceManager resourceReferenceManager;\n\n    private JobExecutor jobExecutor;\n\n    private InternalSkinManager internalSkinManager;\n\n    private TemplateManager templateManager;\n\n    private RenderingContext renderingContext;\n\n    private VelocityEvaluator velocityEvaluator;\n\n    /**\n     * Whether backlinks are enabled or not (cached for performance).\n     *\n     * @since 3.2M2\n     */\n    private Boolean hasBacklinks;\n\n    private ConfigurationSource xwikicfg;\n\n    private ConfigurationSource wikiConfiguration;\n\n    private UserPropertiesResolver userPropertiesResolver;\n\n    private ConfigurationSource spaceConfiguration;\n\n    private EditConfiguration editConfiguration;\n\n    private URLConfiguration urlConfiguration;\n\n    private StoreConfiguration storeConfiguration;\n\n    private HibernateConfiguration hibernateConfiguration;\n\n    private ObservationManager observationManager;\n\n    private Provider<XWikiContext> xcontextProvider;\n\n    private ContextualLocalizationManager localization;\n\n    private Provider<OldRendering> oldRenderingProvider;\n\n    private ParseGroovyFromString parseGroovyFromString;\n\n    private JobProgressManager progress;\n\n    private Provider<DocumentReference> defaultDocumentReferenceProvider;\n\n    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;\n\n    private PageReferenceResolver<EntityReference> currentgetpageResolver;\n\n    private AttachmentReferenceResolver<EntityReference> currentAttachmentReferenceResolver;\n\n    private WikiSkinUtils wikiSkinUtils;\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private VelocityContextFactory velocityContextFactory;\n\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    private AsyncContext asyncContext;\n\n    private AuthorizationManager authorizationManager;\n\n    private ConfigurationSource getConfiguration()\n    {\n        if (this.xwikicfg == null) {\n            this.xwikicfg = Utils.getComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);\n        }\n\n        return this.xwikicfg;\n    }\n\n    private ConfigurationSource getWikiConfiguration()\n    {\n        if (this.wikiConfiguration == null) {\n            this.wikiConfiguration = Utils.getComponent(ConfigurationSource.class, \"wiki\");\n        }\n\n        return this.wikiConfiguration;\n    }\n\n    private ConfigurationSource getSpaceConfiguration()\n    {\n        if (this.spaceConfiguration == null) {\n            this.spaceConfiguration = Utils.getComponent(ConfigurationSource.class, \"space\");\n        }\n\n        return this.spaceConfiguration;\n    }\n\n    private UserPropertiesResolver getAllUserPropertiesResolver()\n    {\n        if (this.userPropertiesResolver == null) {\n            this.userPropertiesResolver = Utils.getComponent(UserPropertiesResolver.class, \"all\");\n        }\n\n        return this.userPropertiesResolver;\n    }\n\n    private EditConfiguration getEditConfiguration()\n    {\n        if (this.editConfiguration == null) {\n            this.editConfiguration = Utils.getComponent(EditConfiguration.class);\n        }\n\n        return this.editConfiguration;\n    }\n\n    private URLConfiguration getURLConfiguration()\n    {\n        if (this.urlConfiguration == null) {\n            this.urlConfiguration = Utils.getComponent(URLConfiguration.class);\n        }\n\n        return this.urlConfiguration;\n    }\n\n    private StoreConfiguration getStoreConfiguration()\n    {\n        if (this.storeConfiguration == null) {\n            this.storeConfiguration = Utils.getComponent(StoreConfiguration.class);\n        }\n\n        return this.storeConfiguration;\n    }\n\n    private HibernateConfiguration getHibernateConfiguration()\n    {\n        if (this.hibernateConfiguration == null) {\n            this.hibernateConfiguration = Utils.getComponent(HibernateConfiguration.class);\n        }\n\n        return this.hibernateConfiguration;\n    }\n\n    private InternalSkinManager getInternalSkinManager()\n    {\n        if (this.internalSkinManager == null) {\n            this.internalSkinManager = Utils.getComponent(InternalSkinManager.class);\n        }\n\n        return this.internalSkinManager;\n    }\n\n    private TemplateManager getTemplateManager()\n    {\n        if (this.templateManager == null) {\n            this.templateManager = Utils.getComponent(TemplateManager.class);\n        }\n\n        return this.templateManager;\n    }\n\n    private RenderingContext getRenderingContext()\n    {\n        if (this.renderingContext == null) {\n            this.renderingContext = Utils.getComponent(RenderingContext.class);\n        }\n\n        return this.renderingContext;\n    }\n\n    private MutableRenderingContext getMutableRenderingContext()\n    {\n        return getRenderingContext() instanceof MutableRenderingContext\n            ? (MutableRenderingContext) getRenderingContext() : null;\n    }\n\n    private VelocityEvaluator getVelocityEvaluator()\n    {\n        if (this.velocityEvaluator == null) {\n            this.velocityEvaluator = Utils.getComponent(VelocityEvaluator.class);\n        }\n\n        return this.velocityEvaluator;\n    }\n\n    private ObservationManager getObservationManager()\n    {\n        if (this.observationManager == null) {\n            this.observationManager = Utils.getComponent(ObservationManager.class);\n        }\n\n        return this.observationManager;\n    }\n\n    private XWikiContext getXWikiContext()\n    {\n        if (this.xcontextProvider == null) {\n            this.xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);\n        }\n\n        return this.xcontextProvider.get();\n    }\n\n    private ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    private OldRendering getOldRendering()\n    {\n        if (this.oldRenderingProvider == null) {\n            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);\n        }\n\n        return this.oldRenderingProvider.get();\n    }\n\n    private ParseGroovyFromString getParseGroovyFromString()\n    {\n        if (this.parseGroovyFromString == null) {\n            this.parseGroovyFromString = Utils.getComponent(ParseGroovyFromString.class);\n        }\n\n        return this.parseGroovyFromString;\n    }\n\n    private JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    private Provider<DocumentReference> getDefaultDocumentReferenceProvider()\n    {\n        if (this.defaultDocumentReferenceProvider == null) {\n            this.defaultDocumentReferenceProvider = Utils.getComponent(DocumentReference.TYPE_PROVIDER);\n        }\n\n        return this.defaultDocumentReferenceProvider;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentGetDocumentResolver()\n    {\n        if (this.currentgetdocumentResolver == null) {\n            this.currentgetdocumentResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");\n        }\n\n        return this.currentgetdocumentResolver;\n    }\n\n    private PageReferenceResolver<EntityReference> getCurrentGetPageResolver()\n    {\n        if (this.currentgetpageResolver == null) {\n            this.currentgetpageResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE, \"currentgetpage\");\n        }\n\n        return this.currentgetpageResolver;\n    }\n\n    private AttachmentReferenceResolver<EntityReference> getCurrentAttachmentResolver()\n    {\n        if (this.currentAttachmentReferenceResolver == null) {\n            this.currentAttachmentReferenceResolver =\n                Utils.getComponent(AttachmentReferenceResolver.TYPE_REFERENCE, \"current\");\n        }\n\n        return this.currentAttachmentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()\n    {\n        if (this.defaultEntityReferenceSerializer == null) {\n            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultEntityReferenceSerializer;\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()\n    {\n        if (this.currentReferenceDocumentReferenceResolver == null) {\n            this.currentReferenceDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n        }\n\n        return this.currentReferenceDocumentReferenceResolver;\n    }\n\n    private EntityReferenceResolver<String> getCurrentMixedEntityReferenceResolver()\n    {\n        if (this.currentMixedEntityReferenceResolver == null) {\n            this.currentMixedEntityReferenceResolver =\n                Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedEntityReferenceResolver;\n    }\n\n    private EntityReferenceResolver<String> getRelativeEntityReferenceResolver()\n    {\n        if (this.relativeEntityReferenceResolver == null) {\n            this.relativeEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");\n        }\n\n        return this.relativeEntityReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getLocalStringEntityReferenceSerializer()\n    {\n        if (this.localStringEntityReferenceSerializer == null) {\n            this.localStringEntityReferenceSerializer =\n                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n\n        return this.localStringEntityReferenceSerializer;\n    }\n\n    private ResourceReferenceManager getResourceReferenceManager()\n    {\n        if (this.resourceReferenceManager == null) {\n            this.resourceReferenceManager = Utils.getComponent(ResourceReferenceManager.class);\n        }\n\n        return this.resourceReferenceManager;\n    }\n\n    private JobExecutor getJobExecutor()\n    {\n        if (this.jobExecutor == null) {\n            this.jobExecutor = Utils.getComponent(JobExecutor.class);\n        }\n\n        return this.jobExecutor;\n    }\n\n    private DocumentReference getDefaultDocumentReference()\n    {\n        return getDefaultDocumentReferenceProvider().get();\n    }\n\n    private WikiSkinUtils getWikiSkinUtils()\n    {\n        if (this.wikiSkinUtils == null) {\n            this.wikiSkinUtils = Utils.getComponent(WikiSkinUtils.class);\n        }\n\n        return this.wikiSkinUtils;\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    private VelocityContextFactory getVelocityContextFactory()\n    {\n        if (this.velocityContextFactory == null) {\n            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);\n        }\n\n        return this.velocityContextFactory;\n    }\n\n    private WikiDescriptorManager getWikiDescriptorManager()\n    {\n        if (this.wikiDescriptorManager == null) {\n            this.wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n        }\n\n        return this.wikiDescriptorManager;\n    }\n\n    private AsyncContext getAsyncContext()\n    {\n        if (this.asyncContext == null) {\n            this.asyncContext = Utils.getComponent(AsyncContext.class);\n        }\n\n        return this.asyncContext;\n    }\n\n    private AuthorizationManager getAuthorizationManager()\n    {\n        if (this.authorizationManager == null) {\n            this.authorizationManager = Utils.getComponent(AuthorizationManager.class);\n        }\n\n        return this.authorizationManager;\n    }\n\n    private String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public static XWiki getMainXWiki(XWikiContext context) throws XWikiException\n    {\n        return getMainXWiki(true, context);\n    }\n\n    /**\n     * @param wait true if the method should way for {@link XWiki} instance to be initialized\n     * @param context see {@link XWikiContext}\n     */\n    public static XWiki getMainXWiki(boolean wait, XWikiContext context) throws XWikiException\n    {\n        String xwikiname = DEFAULT_MAIN_WIKI;\n\n        context.setMainXWiki(xwikiname);\n\n        XWiki xwiki;\n\n        try {\n            XWikiEngineContext econtext = context.getEngineContext();\n\n            xwiki = (XWiki) econtext.getAttribute(xwikiname);\n            if (xwiki == null) {\n                // Start XWiki initialization\n                synchronized (XWiki.class) {\n                    xwiki = (XWiki) econtext.getAttribute(xwikiname);\n                    if (xwiki == null && job == null) {\n                        job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);\n\n                        if (job.getStatus() == null) {\n                            // \"Pre-initialize\" XWikiStubContextProvider so that XWiki initializer can find one\n                            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class)\n                                .initialize(context);\n\n                            job.startAsync();\n                        }\n                    }\n                }\n\n                // Wait until XWiki is initialized\n                if (wait) {\n                    job.join();\n                    xwiki = (XWiki) econtext.getAttribute(xwikiname);\n                }\n            }\n\n            context.setWiki(xwiki);\n\n            return xwiki;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                \"Could not initialize main XWiki instance\", e);\n        }\n    }\n\n    public static boolean isInitializing(XWikiContext xcontext)\n    {\n        return Boolean.TRUE.equals(xcontext.getEngineContext().getAttribute(\"xwiki.init\"));\n    }\n\n    /**\n     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.\n     *\n     * @param context see {@link XWikiContext}\n     * @return an XWiki object configured for the wiki corresponding to the current request\n     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's an error in the\n     *             storage\n     */\n    public static XWiki getXWiki(XWikiContext context) throws XWikiException\n    {\n        return getXWiki(true, context);\n    }\n\n    /**\n     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.\n     * <p>\n     * Unless <code>wait</code> is false the method return right away null if XWiki is not yet initialized.\n     *\n     * @param wait wait until XWiki is initialized\n     * @param xcontext see {@link XWikiContext}\n     * @return an XWiki object configured for the wiki corresponding to the current request\n     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's an error in the\n     *             storage\n     */\n    public static XWiki getXWiki(boolean wait, XWikiContext xcontext) throws XWikiException\n    {\n        XWiki xwiki = getMainXWiki(wait, xcontext);\n\n        if (xwiki == null) {\n            return null;\n        }\n\n        // Extract Entity Resource from URL and put it in the Execution Context\n        EntityResourceReference entityResourceReference = initializeResourceFromURL(xcontext);\n\n        // If not an entity resource reference assume main wiki\n        if (entityResourceReference == null) {\n            return xwiki;\n        }\n\n        // Get the wiki id\n        String wikiId = entityResourceReference.getEntityReference().extractReference(EntityType.WIKI).getName();\n        if (wikiId.equals(xcontext.getMainXWiki())) {\n            // The main wiki was requested.\n            return xwiki;\n        }\n\n        // Check if the wiki exists by checking if a descriptor exists for the wiki id.\n        WikiDescriptorManager wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n        WikiDescriptor descriptor;\n        try {\n            descriptor = wikiDescriptorManager.getById(wikiId);\n        } catch (WikiManagerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_STORE_MISC,\n                String.format(\"Failed find wiki descriptor for wiki id [%s]\", wikiId), e);\n        }\n        if (descriptor == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_DOES_NOT_EXIST,\n                String.format(\"The wiki [%s] does not exist\", wikiId));\n        }\n\n        // Initialize wiki\n\n        xcontext.setWikiId(wikiId);\n        xcontext.setOriginalWikiId(wikiId);\n\n        if (!xwiki.initializeWiki(wikiId, wait, xcontext)) {\n            // The wiki is still initializing\n            return null;\n        }\n\n        return xwiki;\n    }\n\n    /**\n     * @param wikiId the identifier of the wiki\n     * @return the current {@link WikiInitializerJob} associated to the passed wiki or null if there is none\n     */\n    public Job getWikiInitializerJob(String wikiId)\n    {\n        return this.initializedWikis.get(wikiId);\n    }\n\n    /**\n     * Make sure the wiki is initializing or wait for it.\n     * \n     * @param wikiId the identifier of the wiki to initialize\n     * @param wait true if the method should return only when the wiki is fully initialized\n     * @return true if the wiki is fully initialized\n     * @param xcontext the XWiki context\n     * @throws XWikiException when the initialization failed\n     * @since 8.4RC1\n     */\n    public boolean initializeWiki(String wikiId, boolean wait, XWikiContext xcontext) throws XWikiException\n    {\n        Job wikiJob = this.initializedWikis.get(wikiId);\n\n        // Create and start the job if it does not exist\n        if (wikiJob == null) {\n            try {\n                wikiJob = initializeWiki(wikiId, xcontext);\n            } catch (JobException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Could not start [\" + wikiId + \"] wiki initialization\", e);\n            }\n        }\n\n        // Check if the job is done\n        if (wikiJob.getStatus().getState() == State.FINISHED) {\n            return true;\n        }\n\n        // Wait until the job is finished if asked to\n        if (wait) {\n            try {\n                wikiJob.join();\n            } catch (InterruptedException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Wiki [\" + wikiId + \"] initialization was interrupted unexpectedly\", e);\n            }\n\n            if (wikiJob.getStatus().getError() != null) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Wiki [\" + wikiId + \"] initialization failed\", wikiJob.getStatus().getError());\n            }\n\n            return true;\n        }\n\n        // Still initializing\n        return false;\n    }\n\n    private Job initializeWiki(String wikiId, XWikiContext xcontext) throws JobException\n    {\n        synchronized (this.initializedWikis) {\n            WikiInitializerJob wikiJob = this.initializedWikis.get(wikiId);\n\n            if (wikiJob == null) {\n                WikiInitializerRequest request = new WikiInitializerRequest(wikiId);\n\n                JobRequestContext.set(request, xcontext);\n\n                wikiJob = (WikiInitializerJob) getJobExecutor().execute(WikiInitializerJob.JOBTYPE, request);\n                this.initializedWikis.put(wikiId, wikiJob);\n            }\n\n            return wikiJob;\n        }\n    }\n\n    private static EntityResourceReference initializeResourceFromURL(XWikiContext context) throws XWikiException\n    {\n        // Extract the Entity Resource from the URL\n        // TODO: This code should be put in an ExecutionContextInitializer but we couldn't do yet since this code\n        // requires that the XWiki object be initialized first (the line above). Thus we'll be able to to move it only\n        // after the XWiki init is done also in an ExecutionContextInitializer (and with priorities).\n        @SuppressWarnings(\"deprecation\")\n        EntityResourceReference entityResourceReference;\n        URL url = context.getURL();\n        try {\n            ExtendedURL extendedURL = new ExtendedURL(url, context.getRequest().getContextPath());\n            ResourceTypeResolver<ExtendedURL> typeResolver =\n                Utils.getComponent(new DefaultParameterizedType(null, ResourceTypeResolver.class, ExtendedURL.class));\n            ResourceType type = typeResolver.resolve(extendedURL, Collections.<String, Object>emptyMap());\n            ResourceReferenceResolver<ExtendedURL> resourceResolver = Utils\n                .getComponent(new DefaultParameterizedType(null, ResourceReferenceResolver.class, ExtendedURL.class));\n            ResourceReference reference =\n                resourceResolver.resolve(extendedURL, type, Collections.<String, Object>emptyMap());\n            entityResourceReference =\n                reference instanceof EntityResourceReference ? (EntityResourceReference) reference : null;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION,\n                String.format(\"Failed to extract Entity Resource Reference from URL [%s]\", url), e);\n        }\n        Utils.getComponent(Execution.class).getContext().setProperty(ResourceReferenceManager.RESOURCE_CONTEXT_PROPERTY,\n            entityResourceReference);\n\n        return entityResourceReference;\n    }\n\n    public static URL getRequestURL(XWikiRequest request) throws XWikiException\n    {\n        return HttpServletUtils.getSourceURL(request);\n    }\n\n    public static Object callPrivateMethod(Object obj, String methodName)\n    {\n        return callPrivateMethod(obj, methodName, null, null);\n    }\n\n    public static Object callPrivateMethod(Object obj, String methodName, Class<?>[] classes, Object[] args)\n    {\n        try {\n            Method method = obj.getClass().getDeclaredMethod(methodName, classes);\n            method.setAccessible(true);\n            return method.invoke(obj, args);\n        } catch (IllegalAccessException e) {\n            LOGGER.error(\"Failed to call private method [{}]: [{}]\", methodName, e);\n\n            return null;\n        } catch (NoSuchMethodException e) {\n            return null;\n        } catch (InvocationTargetException e) {\n            LOGGER.error(\"Private method [{}] failed: [{}]\", methodName, e);\n\n            return null;\n        }\n    }\n\n    public static HttpClient getHttpClient(int timeout, String userAgent)\n    {\n        HttpClient client = new HttpClient();\n\n        if (timeout != 0) {\n            client.getParams().setSoTimeout(timeout);\n            client.getParams().setParameter(\"http.connection.timeout\", Integer.valueOf(timeout));\n        }\n\n        client.getParams().setParameter(\"http.useragent\", userAgent);\n\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if ((proxyHost != null) && (!proxyHost.equals(\"\"))) {\n            int port = 3128;\n            if ((proxyPort != null) && (!proxyPort.equals(\"\"))) {\n                port = Integer.parseInt(proxyPort);\n            }\n            client.getHostConfiguration().setProxy(proxyHost, port);\n        }\n\n        String proxyUser = System.getProperty(\"http.proxyUser\");\n        if ((proxyUser != null) && (!proxyUser.equals(\"\"))) {\n            String proxyPassword = System.getProperty(\"http.proxyPassword\");\n            Credentials defaultcreds = new UsernamePasswordCredentials(proxyUser, proxyPassword);\n            client.getState().setProxyCredentials(AuthScope.ANY, defaultcreds);\n        }\n\n        return client;\n    }\n\n    /**\n     * Using reflection, read the private value of the passed field name for the passed object.\n     *\n     * @param obj the java object on which to read the private field value\n     * @param fieldName the object member field for which to read the value\n     * @return the private value for the field\n     * @deprecated use {@link FieldUtils#readDeclaredField(Object, String, boolean)} instead\n     */\n    @Deprecated\n    public static Object getPrivateField(Object obj, String fieldName)\n    {\n        try {\n            Field field = obj.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n            return field.get(obj);\n        } catch (NoSuchFieldException e) {\n            return null;\n        } catch (IllegalAccessException e) {\n            LOGGER.error(\"Failed to get private field with name [{}]: [{}]\", fieldName, e);\n\n            return null;\n        } finally {\n        }\n    }\n\n    public static String getServerWikiPage(String servername)\n    {\n        return \"XWiki.XWikiServer\" + StringUtils.capitalize(servername);\n    }\n\n    /**\n     * @param content the content of the text area\n     * @param context see {@link XWikiContext}\n     */\n    public static String getTextArea(String content, XWikiContext context)\n    {\n        StringBuilder result = new StringBuilder();\n\n        // Forcing a new line after the <textarea> tag, as\n        // http://www.w3.org/TR/html4/appendix/notes.html#h-B.3.1 causes an empty line at the start\n        // of the document content to be trimmed.\n        result.append(\"<textarea name=\\\"content\\\" id=\\\"content\\\" rows=\\\"25\\\" cols=\\\"80\\\">\\n\");\n        result.append(XMLUtils.escape(content));\n        result.append(\"</textarea>\");\n\n        return result.toString();\n    }\n\n    /**\n     * This provide a way to create an XWiki object without initializing the whole XWiki (including plugins, storage,\n     * etc.).\n     * <p>\n     * Needed for tools or tests which need XWiki because it is used everywhere in the API.\n     */\n    public XWiki()\n    {\n        // Empty voluntarily\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public XWiki(XWikiContext context, XWikiEngineContext engineContext, boolean noupdate) throws XWikiException\n    {\n        initXWiki(context, engineContext, noupdate);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public XWiki(XWikiContext context) throws XWikiException\n    {\n        this(context, null, false);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public void initXWiki(XWikiContext context, XWikiEngineContext engineContext, boolean noupdate)\n        throws XWikiException\n    {\n        initXWiki(null, context, engineContext, noupdate);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param config the object holding the XWiki configuration read from {@code xwiki.cfg}\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     * @deprecated since 6.1M2, use {@link #initXWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public void initXWiki(XWikiConfig config, XWikiContext context, XWikiEngineContext engineContext, boolean noupdate)\n        throws XWikiException\n    {\n        getProgress().pushLevelProgress(4, this);\n\n        try {\n            getProgress().startStep(this);\n\n            setDatabase(context.getMainXWiki());\n\n            setEngineContext(engineContext);\n            context.setWiki(this);\n\n            // \"Pre-initialize\" XWikiStubContextProvider with a XWikiContext containing a XWiki instance as soon as\n            // possible\n            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class).initialize(context);\n\n            // Prepare the store\n            if (config != null) {\n                setConfig(config);\n            }\n\n            try {\n                initializeStores();\n            } catch (ComponentLookupException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                    \"Failed to initialize stores\", e);\n            }\n\n            setCriteriaService((XWikiCriteriaService) createClassFromConfig(\"xwiki.criteria.class\",\n                \"com.xpn.xwiki.criteria.impl.XWikiCriteriaServiceImpl\", context));\n\n            // \"Pre-initialize\" XWikiStubContextProvider so that rendering engine, plugins or listeners reacting to\n            // potential document changes can use it\n            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class).initialize(context);\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            // Make sure these classes exists\n            if (noupdate) {\n                getProgress().pushLevelProgress(2, this);\n\n                try {\n                    getProgress().startStep(this);\n\n                    initializeMandatoryDocuments(context);\n\n                    getProgress().startStep(this);\n\n                    getStatsService(context);\n                } finally {\n                    getProgress().popLevelProgress(this);\n                }\n            }\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            // Prepare the Plugin Engine\n            preparePlugins(context);\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            String ro = getConfiguration().getProperty(\"xwiki.readonly\", \"no\");\n            this.isReadOnly = (\"yes\".equalsIgnoreCase(ro) || \"true\".equalsIgnoreCase(ro) || \"1\".equalsIgnoreCase(ro));\n\n            getObservationManager().addListener(this);\n        } finally {\n            getProgress().popLevelProgress(this);\n        }\n    }\n\n    private void initializeStores() throws ComponentLookupException\n    {\n        XWikiStoreInterface mainStore = getStoreConfiguration().getXWikiStore();\n\n        // Check if we need to use the cache store..\n        if (getStoreConfiguration().isStoreCacheEnabled()) {\n            XWikiCacheStoreInterface cachestore =\n                (XWikiCacheStoreInterface) Utils.getComponent(XWikiStoreInterface.class, \"cache\");\n            cachestore.setStore(mainStore);\n            setStore(cachestore);\n        } else {\n            setStore(mainStore);\n        }\n\n        setDefaultAttachmentContentStore(getStoreConfiguration().getXWikiAttachmentStore());\n        setVersioningStore(getStoreConfiguration().getXWikiVersioningStore());\n        setDefaultAttachmentArchiveStore(getStoreConfiguration().getAttachmentVersioningStore());\n        setRecycleBinStore(getStoreConfiguration().getXWikiRecycleBinStore());\n        setAttachmentRecycleBinStore(getStoreConfiguration().getAttachmentRecycleBinStore());\n    }\n\n    /**\n     * Ensure that mandatory classes (ie classes XWiki needs to work properly) exist and create them if they don't\n     * exist.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public void initializeMandatoryDocuments(XWikiContext context)\n    {\n        if (context.get(\"initdone\") == null) {\n            @SuppressWarnings(\"deprecation\")\n            List<MandatoryDocumentInitializer> initializers =\n                Utils.getComponentList(MandatoryDocumentInitializer.class);\n\n            // Sort the initializers based on priority. Lower priority values are first.\n            Collections.sort(initializers, new Comparator<MandatoryDocumentInitializer>()\n            {\n                @Override\n                public int compare(MandatoryDocumentInitializer left, MandatoryDocumentInitializer right)\n                {\n                    Priority leftPriority = left.getClass().getAnnotation(Priority.class);\n                    int leftPriorityValue =\n                        leftPriority != null ? leftPriority.value() : MandatoryDocumentInitializer.DEFAULT_PRIORITY;\n\n                    Priority rightPriority = right.getClass().getAnnotation(Priority.class);\n                    int rightPriorityValue =\n                        rightPriority != null ? rightPriority.value() : MandatoryDocumentInitializer.DEFAULT_PRIORITY;\n\n                    // Compare the two.\n                    return leftPriorityValue - rightPriorityValue;\n                }\n            });\n\n            getObservationManager().notify(MandatoryDocumentsInitializingEvent.EVENT, null);\n\n            getProgress().pushLevelProgress(initializers.size(), this);\n\n            try {\n                for (MandatoryDocumentInitializer initializer : initializers) {\n                    getProgress().startStep(this);\n\n                    initializeMandatoryDocument(initializer, context);\n\n                    getProgress().endStep(this);\n                }\n            } finally {\n                getProgress().popLevelProgress(this);\n            }\n\n            getObservationManager().notify(MandatoryDocumentsInitializedEvent.EVENT, null);\n        }\n    }\n\n    private void initializeMandatoryDocument(String wiki, MandatoryDocumentInitializer initializer,\n        XWikiContext context)\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            context.setWikiId(wiki);\n\n            initializeMandatoryDocument(initializer, context);\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    private void initializeMandatoryDocument(MandatoryDocumentInitializer initializer, XWikiContext context)\n    {\n        try {\n            DocumentReference documentReference =\n                getCurrentReferenceDocumentReferenceResolver().resolve(initializer.getDocumentReference());\n\n            if (documentReference.getWikiReference().getName().equals(context.getWikiId())) {\n                XWikiDocument document = context.getWiki().getDocument(documentReference, context);\n\n                if (initializer.updateDocument(document)) {\n                    saveDocument(document,\n                        localizePlainOrKey(\"core.model.xclass.mandatoryUpdateProperty.versionSummary\"), context);\n                }\n            }\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to initialize mandatory document [{}]\", initializer.getDocumentReference(), e);\n        }\n    }\n\n    public XWikiStoreInterface getNotCacheStore()\n    {\n        XWikiStoreInterface store = getStore();\n        if (store instanceof XWikiCacheStoreInterface) {\n            store = ((XWikiCacheStoreInterface) store).getStore();\n        }\n        return store;\n    }\n\n    public XWikiHibernateStore getHibernateStore()\n    {\n        XWikiStoreInterface store = getStore();\n        if (store instanceof XWikiHibernateStore) {\n            return (XWikiHibernateStore) store;\n        } else if (store instanceof XWikiCacheStoreInterface) {\n            store = ((XWikiCacheStoreInterface) store).getStore();\n            if (store instanceof XWikiHibernateStore) {\n                return (XWikiHibernateStore) store;\n            } else {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, XWikiContext context) throws HibernateException, XWikiException\n    {\n        updateDatabase(wikiId, false, context);\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, boolean force, XWikiContext context)\n        throws HibernateException, XWikiException\n    {\n        updateDatabase(wikiId, force, true, context);\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param force if the update of the databse should be forced\n     * @param initDocuments if mandatory document and plugin should be initialized for passed wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, boolean force, boolean initDocuments, XWikiContext context)\n        throws HibernateException, XWikiException\n    {\n        initializeWiki(wikiId, true, context);\n    }\n\n    /**\n     * @return a cached list of all active virtual wikis (i.e. wikis who have been hit by a user request). To get a full\n     *         list of all virtual wikis database names use {@link WikiDescriptorManager#getAllIds()}.\n     * @deprecated\n     */\n    @Deprecated\n    public List<String> getVirtualWikiList()\n    {\n        return new ArrayList<>(this.initializedWikis.keySet());\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     * @return the full list of all wiki names of all defined wikis. The wiki names are computed from the names of\n     *         documents having a {@code XWiki.XWikiServerClass} object attached to them by removing the\n     *         {@code XWiki.XWikiServer} prefix and making it lower case. For example a page named\n     *         {@code XWiki.XWikiServerMyDatabase} would return {@code mydatabase} as the wiki name. This list will also\n     *         contain the main wiki.\n     *         <p>\n     *         Note: the wiki name is commonly also the name of the database where the wiki's data is stored. However,\n     *         if configured accordingly, the database can be diferent from the wiki name, like for example when setting\n     *         a wiki database prefix.\n     * @deprecated since 5.3, use {@link WikiDescriptorManager#getAllIds()} instead\n     */\n    @Deprecated\n    public List<String> getVirtualWikisDatabaseNames(XWikiContext context) throws XWikiException\n    {\n        WikiDescriptorManager descriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n\n        try {\n            return new ArrayList<String>(descriptorManager.getAllIds());\n        } catch (WikiManagerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to get the list of wikis\", e);\n        }\n    }\n\n    /**\n     * @return the cache containing the names of the wikis already initialized.\n     * @since 1.5M2.\n     * @deprecated\n     */\n    @Deprecated\n    public Cache<DocumentReference> getVirtualWikiCache()\n    {\n        return null;\n    }\n\n    /**\n     * Get the reference of the owner for the provider wiki.\n     *\n     * @param wikiName the technical name of the wiki\n     * @param context see {@link XWikiContext}\n     * @return the wiki owner or null if none is set\n     * @throws XWikiException failed to get wiki descriptor document\n     */\n    public String getWikiOwner(String wikiName, XWikiContext context) throws XWikiException\n    {\n        String wikiOwner;\n\n        String currentdatabase = context.getWikiId();\n        try {\n            context.setWikiId(context.getMainXWiki());\n\n            String serverwikipage = getServerWikiPage(wikiName);\n            XWikiDocument doc = getDocument(serverwikipage, context);\n\n            if (doc.isNew()) {\n                if (!context.isMainWiki(wikiName)) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_DOES_NOT_EXIST,\n                        \"The wiki \" + wikiName + \" does not exist\");\n                } else {\n                    wikiOwner = null;\n                }\n            } else {\n                wikiOwner = doc.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"owner\");\n                if (wikiOwner.indexOf(':') == -1) {\n                    wikiOwner = context.getMainXWiki() + \":\" + wikiOwner;\n                }\n            }\n        } finally {\n            context.setWikiId(currentdatabase);\n        }\n\n        return wikiOwner;\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    protected Object createClassFromConfig(String param, String defClass, XWikiContext context) throws XWikiException\n    {\n        String storeclass = getConfiguration().getProperty(param, defClass);\n        try {\n            Class<?>[] classes = new Class<?>[] { XWikiContext.class };\n            Object[] args = new Object[] { context };\n            Object result = Class.forName(storeclass).getConstructor(classes).newInstance(args);\n            return result;\n        } catch (Exception e) {\n            Throwable ecause = e;\n            if (e instanceof InvocationTargetException) {\n                ecause = ((InvocationTargetException) e).getTargetException();\n            }\n            Object[] args = { param, storeclass };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_CLASSINVOCATIONERROR, \"Cannot load class {1} from param {0}\", ecause,\n                args);\n        }\n    }\n\n    private void preparePlugins(XWikiContext context)\n    {\n        setPluginManager(new XWikiPluginManager(getXWikiPreference(\"plugins\", context), context));\n        String plugins = getConfiguration().getProperty(\"xwiki.plugins\", \"\");\n        if (!plugins.equals(\"\")) {\n            getPluginManager().addPlugins(StringUtils.split(plugins, \" ,\"), context);\n        }\n    }\n\n    /**\n     * @return the XWiki core version as specified in the {@link #VERSION_FILE} file\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String getVersion()\n    {\n        if (this.version == null) {\n            try {\n                InputStream is = getResourceAsStream(VERSION_FILE);\n                try {\n                    XWikiConfig properties = new XWikiConfig(is);\n                    this.version = properties.getProperty(VERSION_FILE_PROPERTY);\n                } finally {\n                    IOUtils.closeQuietly(is);\n                }\n            } catch (Exception e) {\n                // Failed to retrieve the version, log a warning and default to \"Unknown\"\n                LOGGER.warn(\"Failed to retrieve XWiki's version from [\" + VERSION_FILE + \"], using the [\"\n                    + VERSION_FILE_PROPERTY + \"] property.\", e);\n                this.version = \"Unknown version\";\n            }\n        }\n        return this.version;\n    }\n\n    public URL getResource(String s) throws MalformedURLException\n    {\n        return getEngineContext().getResource(s);\n    }\n\n    public InputStream getResourceAsStream(String s) throws MalformedURLException\n    {\n        InputStream is = getEngineContext().getResourceAsStream(s);\n        if (is == null) {\n            is = getEngineContext().getResourceAsStream(\"/\" + s);\n        }\n        return is;\n    }\n\n    public String getResourceContent(String name) throws IOException\n    {\n        if (getEngineContext() != null) {\n            try (InputStream is = getResourceAsStream(name)) {\n                if (is != null) {\n                    return IOUtils.toString(is, DEFAULT_ENCODING);\n                }\n            }\n        }\n        // Resources should always be encoded as UTF-8, to reduce the dependency on the system encoding\n        return FileUtils.readFileToString(new File(name), DEFAULT_ENCODING);\n    }\n\n    public Date getResourceLastModificationDate(String name)\n    {\n        try {\n            if (getEngineContext() != null) {\n                return Util.getFileLastModificationDate(getEngineContext().getRealPath(name));\n            }\n        } catch (Exception ex) {\n            // Probably a SecurityException or the file is not accessible (inside a war)\n            LOGGER.info(\"Failed to get file modification date: \" + ex.getMessage());\n        }\n        return new Date();\n    }\n\n    public byte[] getResourceContentAsBytes(String name) throws IOException\n    {\n        if (getEngineContext() != null) {\n            try (InputStream is = getResourceAsStream(name)) {\n                if (is != null) {\n                    return IOUtils.toByteArray(is);\n                }\n            } catch (Exception e) {\n            }\n        }\n        return FileUtils.readFileToByteArray(new File(name));\n    }\n\n    public boolean resourceExists(String name)\n    {\n        if (getEngineContext() != null) {\n            try {\n                if (getResource(name) != null) {\n                    return true;\n                }\n            } catch (IOException e) {\n            }\n        }\n        try {\n            File file = new File(name);\n            return file.exists();\n        } catch (Exception e) {\n            // Could be running under -security, which prevents calling file.exists().\n        }\n        return false;\n    }\n\n    public String getRealPath(String path)\n    {\n        return getEngineContext().getRealPath(path);\n    }\n\n    public String ParamAsRealPath(String key)\n    {\n        String param = getConfiguration().getProperty(key);\n        try {\n            return getRealPath(param);\n        } catch (Exception e) {\n            return param;\n        }\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public String ParamAsRealPath(String key, XWikiContext context)\n    {\n        return ParamAsRealPath(key);\n    }\n\n    public String ParamAsRealPathVerified(String param)\n    {\n        String path;\n        File fpath;\n\n        path = getConfiguration().getProperty(param);\n        if (path == null) {\n            return null;\n        }\n\n        fpath = new File(path);\n        if (fpath.exists()) {\n            return path;\n        }\n\n        path = getRealPath(path);\n        if (path == null) {\n            return null;\n        }\n\n        fpath = new File(path);\n        if (fpath.exists()) {\n            return path;\n        } else {\n        }\n        return null;\n    }\n\n    public XWikiStoreInterface getStore()\n    {\n        return this.store;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #getDefaultAttachmentContentStore()} instead\n     */\n    @Deprecated\n    public XWikiAttachmentStoreInterface getAttachmentStore()\n    {\n        return getDefaultAttachmentContentStore();\n    }\n\n    /**\n     * @return the store to use by default when saving a new attachment content\n     * @since 9.10RC1\n     */\n    public XWikiAttachmentStoreInterface getDefaultAttachmentContentStore()\n    {\n        return this.defaultAttachmentContentStore;\n    }\n\n    /**\n     * @return the store to use by default when saving a new attachment archive\n     * @since 9.10RC1\n     */\n    public AttachmentVersioningStore getDefaultAttachmentArchiveStore()\n    {\n        return this.defaultAttachmentArchiveStore;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #getDefaultAttachmentArchiveStore()} instead\n     */\n    @Deprecated\n    public AttachmentVersioningStore getAttachmentVersioningStore()\n    {\n        return getDefaultAttachmentArchiveStore();\n    }\n\n    public XWikiVersioningStoreInterface getVersioningStore()\n    {\n        return this.versioningStore;\n    }\n\n    public XWikiRecycleBinStoreInterface getRecycleBinStore()\n    {\n        return this.recycleBinStore;\n    }\n\n    public AttachmentRecycleBinStore getAttachmentRecycleBinStore()\n    {\n        return this.attachmentRecycleBinStore;\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, String comment,\n        XWikiContext context) throws XWikiException\n    {\n        checkSavingDocument(userReference, document, comment, false, context);\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        checkSavingDocument(userReference, document, \"\", false, context);\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param isMinorEdit true if the new version is a minor version\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, String comment,\n        boolean isMinorEdit, XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            // Switch to document wiki\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            // Make sure the document is ready to be saved\n            XWikiDocument originalDocument = prepareDocumentForSave(document, comment, isMinorEdit, context);\n\n            ObservationManager om = getObservationManager();\n\n            // Notify listeners about the document about to be created or updated\n\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n\n            if (om != null) {\n                CancelableEvent documentEvent;\n                if (originalDocument.isNew()) {\n                    documentEvent = new UserCreatingDocumentEvent(userReference, document.getDocumentReference());\n                } else {\n                    documentEvent = new UserUpdatingDocumentEvent(userReference, document.getDocumentReference());\n                }\n                om.notify(documentEvent, document, context);\n\n                // If the action has been canceled by the user then don't perform any save and throw an exception\n                if (documentEvent.isCanceled()) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        String.format(\"User [%s] has been denied the right to save the document [%s]. Reason: [%s]\",\n                            userReference, document.getDocumentReference(), documentEvent.getReason()));\n                }\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    private XWikiDocument prepareDocumentForSave(XWikiDocument document, String comment, boolean isMinorEdit,\n        XWikiContext context) throws XWikiException\n    {\n        // Set the store so we can use it for checking the max length.\n        if (document.getStore() == null) {\n            document.setStore(this.getStore());\n        }\n        String fullName = getLocalStringEntityReferenceSerializer().serialize(document.getDocumentReference());\n        // If it's a new doc we check its name length to avoid a nasty SQL error.\n        if (document.isNew() && fullName.length() > document.getLocalReferenceMaxLength()) {\n            java.lang.Object[] args = { fullName, document.getLocalReferenceMaxLength(), fullName.length() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG,\n                \"Cannot create document {0} because its full path is too long: only {1} characters are allowed and \"\n                    + \"current length is {2}.\",\n                null, args);\n        }\n\n        // Setting comment & minor edit before saving\n        document.setComment(StringUtils.defaultString(comment));\n        document.setMinorEdit(isMinorEdit);\n\n        // We need to save the original document since saveXWikiDoc() will reset it and we\n        // need that original document for the notification below.\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        // Make sure to always have an original document for listeners that need to compare with it.\n        // The only case where we have a null original document is supposedly when the document\n        // instance has been crafted and passed #saveDocument without using #getDocument\n        // (which is not a good practice)\n        // Also for document indicated as new make sure the previous document is accurate.\n        if (originalDocument == null || document.isNew()) {\n            XWikiDocument existing = getDocument(document.getDocumentReferenceWithLocale(), context);\n            // Switch the original document only if we actually find an existing document or if there is no original\n            // document in the first place\n            if (originalDocument == null || !existing.isNew()) {\n                originalDocument = existing;\n                document.setOriginalDocument(originalDocument);\n            }\n        }\n\n        return originalDocument;\n    }\n\n    /**\n     * @param doc the document to save\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        // If no comment is provided we should use an empty comment\n        saveDocument(doc, \"\", context);\n    }\n\n    /**\n     * @param doc the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument doc, String comment, XWikiContext context) throws XWikiException\n    {\n        saveDocument(doc, comment, false, context);\n    }\n\n    private void beforeSave(XWikiDocument document, XWikiContext context) throws XWikiException\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            CancelableEvent documentEvent;\n            if (document.getOriginalDocument().isNew()) {\n                documentEvent = new DocumentCreatingEvent(document.getDocumentReference());\n            } else {\n                documentEvent = new DocumentUpdatingEvent(document.getDocumentReference());\n            }\n            om.notify(documentEvent, document, context);\n\n            // If the action has been canceled by the user then don't perform any save and throw an exception\n            if (documentEvent.isCanceled()) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC,\n                    String.format(\"An Event Listener has cancelled the document save for [%s]. Reason: [%s]\",\n                        document.getDocumentReference(), documentEvent.getReason()));\n            }\n        }\n    }\n\n    private void afterSave(XWikiDocument document, XWikiContext context)\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            if (document.getOriginalDocument().isNew()) {\n                om.notify(new DocumentCreatedEvent(document.getDocumentReference()), document, context);\n            } else {\n                om.notify(new DocumentUpdatedEvent(document.getDocumentReference()), document, context);\n            }\n        }\n    }\n\n    /**\n     * Save the passed document in the store.\n     * <p>\n     * If document is not new and metadata and content dirty flags are false, the version/history won't be incremented\n     * (only the current state will be updated).\n     * <p>\n     * Since 11.1, if document#isNew() return true, any pre existing document will be backuped in the deleted documents\n     * store automatically and completely replaced.\n     * \n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param isMinorEdit true if the new version is a minor version\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument document, String comment, boolean isMinorEdit, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            // Switch to document wiki\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            // Make sure the document is ready to be saved\n            XWikiDocument originalDocument = prepareDocumentForSave(document, comment, isMinorEdit, context);\n\n            // Notify listeners about the document about to be created or updated\n\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            beforeSave(document, context);\n\n            // Delete existing document if we replace with a new one\n            if (document.isNew()) {\n                if (!originalDocument.isNew()) {\n                    // We don't want to notify about this delete since from outside world point of view it's an update\n                    // and not a delete+create\n                    deleteDocument(originalDocument, true, false, context);\n                }\n            } else {\n                // Put attachments to remove in recycle bin\n                if (hasAttachmentRecycleBin(context)) {\n                    for (XWikiAttachmentToRemove attachment : document.getAttachmentsToRemove()) {\n                        if (attachment.isToRecycleBin()\n                            // Only store the attachment to the trash bin if it's not broken\n                            && attachment.getAttachment().contentExists(context)) {\n                            // Make sure the attachment will be stored with its history\n                            attachment.getAttachment().loadArchive(context);\n                            getAttachmentRecycleBinStore().saveToRecycleBin(attachment.getAttachment(),\n                                context.getUser(), new Date(), context, true);\n                        }\n                    }\n                }\n            }\n\n            // Actually save the document.\n            getStore().saveXWikiDoc(document, context);\n\n            // Since the store#saveXWikiDoc resets originalDocument, we need to temporarily put it\n            // back to send notifications.\n            XWikiDocument newOriginal = document.getOriginalDocument();\n\n            try {\n                document.setOriginalDocument(originalDocument);\n\n                // Notify listeners about the document having been created or updated\n\n                // First the legacy notification mechanism\n\n                // Then the new observation module\n                // Note that for the moment the event being send is a bridge event, as we are still passing around\n                // an XWikiDocument as source and an XWikiContext as data.\n                // The old version is made available using doc.getOriginalDocument()\n                afterSave(document, context);\n            } catch (Exception ex) {\n                LOGGER.error(\"Failed to send document save notification for document [\"\n                    + getDefaultEntityReferenceSerializer().serialize(document.getDocumentReference()) + \"]\", ex);\n            } finally {\n                document.setOriginalDocument(newOriginal);\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Loads a XWikiDocument from the store.\n     * <p>\n     * Before 7.2M1 the reference is assumed to be a complete or incomplete document reference.\n     * <p>\n     * Since 7.2M1, the passed reference can be anything. If if a document child, the document reference will be\n     * extracted from it. If it's a document parent it will be completed with the necessary default references (for\n     * example if it's a space reference it will load the space home page).\n     *\n     * @param reference the reference of the document\n     * @param context see {@link XWikiContext}\n     * @since 5.0M1\n     */\n    public XWikiDocument getDocument(EntityReference reference, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument document;\n\n        if (reference.getType() == EntityType.PAGE || reference.getType().isAllowedAncestor(EntityType.PAGE)) {\n            document = getDocument(getCurrentGetPageResolver().resolve(reference), context);\n        } else {\n            document = getDocument(getCurrentGetDocumentResolver().resolve(reference), context);\n        }\n\n        return document;\n    }\n\n    /**\n     * Loads a XWikiDocument from the store.\n     *\n     * @param reference the reference of the document to be loaded\n     * @param type the type of the reference\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 10.6RC1\n     */\n    public XWikiDocument getDocument(String reference, EntityType type, XWikiContext xcontext) throws XWikiException\n    {\n        return getDocument(getRelativeEntityReferenceResolver().resolve(reference, type), xcontext);\n    }\n\n    /**\n     * @param doc the document\n     * @param context see {@link XWikiContext}\n     */\n    public XWikiDocument getDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(doc.getDocumentReference().getWikiReference().getName());\n\n            try {\n                // Indicate the the async context manipulated documents\n                getAsyncContext().useEntity(doc.getDocumentReferenceWithLocale());\n            } catch (Exception e) {\n                // If the AsyncContext component does not work then we are not in an asynchronous context anyway\n                LOGGER.debug(\"Failed to register the document in the asynchronous context\", e);\n            }\n\n            return getStore().loadXWikiDoc(doc, context);\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * @param reference the reference of the document to load\n     * @param revision the revision of the document to load\n     * @param context the XWiki context\n     * @return the document corresponding to the passed revision or a new XWikiDocument instance if none can be found\n     * @throws XWikiException when failing to load the document revision\n     * @since 9.4RC1\n     * @deprecated sine 9.10RC1, use {@link DocumentRevisionProvider#getRevision(DocumentReference, String)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(DocumentReference reference, String revision, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument revisionDocument = getDocumentRevisionProvider().getRevision(reference, revision);\n\n        if (revisionDocument == null && (revision.equals(\"1.1\") || revision.equals(\"1.0\"))) {\n            revisionDocument = new XWikiDocument(reference);\n        }\n\n        return revisionDocument;\n    }\n\n    /**\n     * @param document the reference document\n     * @param revision the revision of the document to load\n     * @param context the XWiki context\n     * @return the document corresponding to the passed revision or a new XWikiDocument instance if none can be found\n     * @throws XWikiException when failing to load the document revision\n     * @deprecated sine 9.10RC1, use {@link DocumentRevisionProvider#getRevision(XWikiDocument, String)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(XWikiDocument document, String revision, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument revisionDocument = getDocumentRevisionProvider().getRevision(document, revision);\n\n        if (revisionDocument == null && (revision.equals(\"1.1\") || revision.equals(\"1.0\"))) {\n            revisionDocument = new XWikiDocument(document.getDocumentReference());\n        }\n\n        return revisionDocument;\n    }\n\n    /**\n     * @param reference the reference of the document\n     * @param context see {@link XWikiContext}\n     * @since 2.2M1\n     */\n    public XWikiDocument getDocument(DocumentReference reference, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(\n            reference.getLocale() != null ? new DocumentReference(reference, (Locale) null) : reference,\n            reference.getLocale());\n\n        doc.setContentDirty(true);\n\n        return getDocument(doc, context);\n    }\n\n    /**\n     * @param reference the reference of the page\n     * @param context see {@link XWikiContext}\n     * @since 10.6RC1\n     */\n    public XWikiDocument getDocument(PageReference reference, XWikiContext context) throws XWikiException\n    {\n        DocumentReference documentReference = getCurrentReferenceDocumentReferenceResolver().resolve(reference);\n\n        XWikiDocument document = getDocument(documentReference, context);\n\n        if (document.isNew() && documentReference.getParent().getParent().getType() == EntityType.SPACE) {\n            // Try final page\n            XWikiDocument finalDocument = getDocument(new DocumentReference(documentReference.getParent().getName(),\n                documentReference.getParent().getParent(), documentReference.getParameters()), context);\n\n            if (!finalDocument.isNew()) {\n                document = finalDocument;\n            }\n        }\n\n        return document;\n    }\n\n    /**\n     * Find the document reference corresponding to the entity reference based on what exist in the database (page\n     * reference can means two different documents for example).\n     * \n     * @param reference the reference to resolve\n     * @param context the XWiki context\n     * @return the document reference\n     * @since 10.6RC1\n     */\n    public DocumentReference getDocumentReference(EntityReference reference, XWikiContext context)\n    {\n        DocumentReference documentReference = getCurrentGetDocumentResolver().resolve(reference);\n\n        // If the document has been found or it's top level space, return the reference\n        if (documentReference.getParent().getParent().getType() != EntityType.SPACE\n            || exists(documentReference, context)) {\n            return documentReference;\n        }\n\n        // Try final page\n        DocumentReference finalPageReference = new DocumentReference(documentReference.getParent().getName(),\n            documentReference.getParent().getParent(), documentReference.getParameters());\n\n        return exists(finalPageReference, context) ? finalPageReference : documentReference;\n    }\n\n    /**\n     * @param fullname the reference of the document as String\n     * @param context see {@link XWikiContext}\n     * @deprecated since 2.2M1 use {@link #getDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(String fullname, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setFullName(fullname, context);\n        return getDocument(doc, context);\n    }\n\n    /**\n     * @param spaces the reference of the space as String\n     * @param fullname the reference of the document as String\n     * @param context see {@link XWikiContext}\n     * @deprecated since 2.2M1 use {@link #getDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(String spaces, String fullname, XWikiContext context) throws XWikiException\n    {\n        int dotPosition = fullname.lastIndexOf('.');\n        if (dotPosition != -1) {\n            String spaceFromFullname = fullname.substring(0, dotPosition);\n            String name = fullname.substring(dotPosition + 1);\n            if (name.equals(\"\")) {\n                name = getDefaultPage(context);\n            }\n            return getDocument(spaceFromFullname + \".\" + name, context);\n        } else {\n            return getDocument(spaces + \".\" + fullname, context);\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocuments(String, String)\n     */\n    public XWikiDeletedDocument[] getDeletedDocuments(String fullname, String locale, XWikiContext context)\n        throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n            doc.setLanguage(locale);\n            return getRecycleBinStore().getAllDeletedDocuments(doc, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocuments(String)\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument[] getDeletedDocuments(String batchId, XWikiContext context) throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            return getRecycleBinStore().getAllDeletedDocuments(batchId, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocument(String, String, String)\n     * @deprecated since 9.4RC1. Use {@link #getDeletedDocument(long, XWikiContext)} instead.\n     */\n    @Deprecated\n    public XWikiDeletedDocument getDeletedDocument(String fullname, String locale, int index, XWikiContext context)\n        throws XWikiException\n    {\n        return getDeletedDocument(index, context);\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocument(String)\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument getDeletedDocument(long index, XWikiContext context) throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            return getRecycleBinStore().getDeletedDocument(index, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document. Note that this does not distinguish\n     * between different incarnations of a document name, and it does not require that the document still exists, it\n     * returns all the attachments that at the time of their deletion had a document with the specified name as their\n     * owner.\n     *\n     * @param docName the {@link XWikiDocument#getFullName() name} of the owner document\n     * @param context see {@link XWikiContext}\n     * @return A list with all the deleted attachments which belonged to the specified document. If no such attachments\n     *         are found in the trash, an empty list is returned.\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, XWikiContext context) throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName));\n            return getAttachmentRecycleBinStore().getAllDeletedAttachments(doc, context, true);\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document and had the specified name. Multiple\n     * versions can be returned since the same file can be uploaded and deleted several times, creating different\n     * instances in the trash. Note that this does not distinguish between different incarnations of a document name,\n     * and it does not require that the document still exists, it returns all the attachments that at the time of their\n     * deletion had a document with the specified name as their owner.\n     *\n     * @param docName the {@link DeletedAttachment#getDocName() name of the document} the attachment belonged to\n     * @param filename the {@link DeletedAttachment#getFilename() name} of the attachment to search for\n     * @param context see {@link XWikiContext}\n     * @return A list with all the deleted attachments which belonged to the specified document and had the specified\n     *         filename. If no such attachments are found in the trash, an empty list is returned.\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, String filename, XWikiContext context)\n        throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName));\n            XWikiAttachment attachment = new XWikiAttachment(doc, filename);\n            return getAttachmentRecycleBinStore().getAllDeletedAttachments(attachment, context, true);\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve a specific attachment from the trash.\n     *\n     * @param id the unique identifier of the entry in the trash\n     * @param context the XWiki context\n     * @return specified attachment from the trash, {@code null} if not found\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public DeletedAttachment getDeletedAttachment(String id, XWikiContext context) throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            return getAttachmentRecycleBinStore().getDeletedAttachment(NumberUtils.toLong(id), context, true);\n        }\n        return null;\n    }\n\n    public MetaClass getMetaclass()\n    {\n        if (this.metaclass == null) {\n            this.metaclass = MetaClass.getMetaClass();\n        }\n        return this.metaclass;\n    }\n\n    public void setMetaclass(MetaClass metaclass)\n    {\n        this.metaclass = metaclass;\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public List<String> getClassList(XWikiContext context) throws XWikiException\n    {\n        List<String> result = getStore().getClassList(context);\n        Collections.sort(result);\n        return result;\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, 0, 0, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param nb limit the number of results to return\n     * @param start the offset from which to start return results\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, int nb, int start, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, nb, start, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, Object[][] whereParams, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, 0, 0, whereParams, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param nb limit the number of results to return\n     * @param start the offset from which to start return results\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, int nb, int start, Object[][] whereParams, XWikiContext context)\n        throws XWikiException\n    {\n        return getStore().search(sql, nb, start, whereParams, context);\n    }\n\n    /**\n     * @param content the content to parse\n     * @param context see {@link XWikiContext}\n     * @deprecated Since 7.2M1. Use specific rendering/parsing options for the content type you want to parse/render.\n     */\n    @Deprecated\n    public String parseContent(String content, XWikiContext context)\n    {\n        return getOldRendering().parseContent(content, context);\n    }\n\n    /**\n     * @param template the name of the template\n     * @param context see {@link XWikiContext}\n     * @deprecated use {@link #evaluateTemplate(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String parseTemplate(String template, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            result = evaluateTemplate(template, context);\n        } catch (Exception e) {\n            LOGGER.debug(\"Exception while parsing template [{}] from /templates/\", template, e);\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate provided template content using velocity engine.\n     *\n     * @param template the template to evaluate\n     * @param context see {@link XWikiContext}\n     * @return the return of the velocity script\n     * @throws IOException failed to get the template content\n     * @since 2.2.2\n     * @deprecated since 7.0M1, use {@link TemplateManager#render(String)} instead\n     */\n    @Deprecated\n    public String evaluateTemplate(String template, XWikiContext context) throws IOException\n    {\n        try {\n            return getTemplateManager().render(template);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while evaluating velocity template [{}]\", template, e);\n\n            Object[] args = { template };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while evaluating velocity template {0}\",\n                e, args);\n\n            return Util.getHTMLExceptionMessage(xe, context);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param skinId the id of the skin from which to load the template\n     * @param context see {@link XWikiContext}\n     * @deprecated since 7.0M1, use {@link TemplateManager#renderFromSkin} instead\n     */\n    @Deprecated\n    public String parseTemplate(String template, String skinId, XWikiContext context)\n    {\n        MutableRenderingContext mutableRenderingContext = getMutableRenderingContext();\n\n        Syntax currentTargetSyntax = mutableRenderingContext.getTargetSyntax();\n        try {\n            // Force rendering with XHTML 1.0 syntax for retro-compatibility\n            mutableRenderingContext.setTargetSyntax(Syntax.XHTML_1_0);\n\n            Skin skin = getInternalSkinManager().getSkin(skinId);\n            return getTemplateManager().renderFromSkin(template, skin);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while evaluating velocity template [{}] skin [{}]\", template, skinId, e);\n\n            Object[] args = { template, skinId };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION,\n                \"Error while evaluating velocity template [{0}] from skin [{1}]\", e, args);\n\n            return Util.getHTMLExceptionMessage(xe, context);\n        } finally {\n            mutableRenderingContext.setTargetSyntax(currentTargetSyntax);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param skin the id of the skin from which to load the template\n     * @param context see {@link XWikiContext}\n     */\n    public String renderTemplate(String template, String skin, XWikiContext context)\n    {\n        try {\n            return getOldRendering().renderTemplate(template, skin, context);\n        } catch (Exception ex) {\n            LOGGER.error(\"Failed to render template [\" + template + \"] for skin [\" + skin + \"]\", ex);\n            return parseTemplate(template, skin, context);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param context see {@link XWikiContext}\n     */\n    public String renderTemplate(String template, XWikiContext context)\n    {\n        try {\n            return getOldRendering().renderTemplate(template, context);\n        } catch (Exception ex) {\n            LOGGER.error(\"Failed to render template [\" + template + \"]\", ex);\n            return parseTemplate(template, context);\n        }\n    }\n\n    /**\n     * @param iconName the standard name of an icon (it's not the name of the file on the filesystem, it's a generic\n     *            name, for example \"success\" for a success icon\n     * @param context see {@link XWikiContext}\n     * @return the URL to the icon resource\n     * @since 2.6M1\n     */\n    public String getIconURL(String iconName, XWikiContext context)\n    {\n        // TODO: Do a better mapping between generic icon name and physical resource name, especially to be independent\n        // of the underlying icon library. Right now we assume it's the Silk icon library.\n        return getSkinFile(\"icons/silk/\" + iconName + \".png\", context);\n    }\n\n    public String getSkinFile(String filename, XWikiContext context)\n    {\n        return getSkinFile(filename, false, context);\n    }\n\n    /**\n     * Build and return a skin file url based on the given parameters.\n     * \n     * @param filename the file name of the skin file wanted\n     * @param forceSkinAction if true force the usage of directory /skins/ in the URL\n     * @param context current context for the request\n     * @return a resource URL for the asked filename\n     */\n    public String getSkinFile(String filename, boolean forceSkinAction, XWikiContext context)\n    {\n        String skinFile = getSkinFile(filename, null, forceSkinAction, context);\n\n        if (skinFile == null) {\n            // Use the default base skin even if the URL could be invalid.\n            XWikiURLFactory urlf = context.getURLFactory();\n            URL url;\n            if (forceSkinAction) {\n                url = urlf.createSkinURL(filename, \"skins\", getDefaultBaseSkin(context), context);\n            } else {\n                url = urlf.createSkinURL(filename, getDefaultBaseSkin(context), context);\n            }\n            skinFile = urlf.getURL(url, context);\n        }\n\n        return skinFile;\n    }\n\n    private String getSkinFileInternal(String fileName, String skinId, boolean forceSkinAction, XWikiContext context)\n    {\n        try {\n            if (skinId != null) {\n                // Try only in the specified skin.\n                Skin skin = getInternalSkinManager().getSkin(skinId);\n                if (skin != null) {\n                    Resource<?> resource = skin.getLocalResource(fileName);\n                    if (resource != null) {\n                        return resource.getURL(forceSkinAction);\n                    }\n                }\n            } else {\n                // Try in the current skin.\n                Skin skin = getInternalSkinManager().getCurrentSkin(true);\n                if (skin != null) {\n                    Resource<?> resource = skin.getResource(fileName);\n                    if (resource != null) {\n                        return resource.getURL(forceSkinAction);\n                    }\n                } else {\n                    // Try in the current parent skin.\n                    Skin parentSkin = getInternalSkinManager().getCurrentParentSkin(true);\n                    if (parentSkin != null) {\n                        Resource<?> resource = parentSkin.getResource(fileName);\n                        if (resource != null) {\n                            return resource.getURL(forceSkinAction);\n                        }\n                    }\n                }\n            }\n\n            // Look for a resource file.\n            String resourceFilePath = \"/resources/\" + fileName;\n            XWikiURLFactory urlFactory = context.getURLFactory();\n            if (resourceExists(resourceFilePath)) {\n                URL url = urlFactory.createResourceURL(fileName, forceSkinAction, context,\n                    getResourceURLCacheParameters(resourceFilePath));\n                return urlFactory.getURL(url, context);\n            }\n        } catch (Exception e) {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Exception while getting skin file [{}] from skin [{}]\", fileName, skinId, e);\n            }\n        }\n\n        return null;\n    }\n\n    private Map<String, Object> getResourceURLCacheParameters(String resourceFilePath)\n    {\n        try {\n            URL resourceUrl = getResource(resourceFilePath);\n            return getResourceURLCacheParameters(resourceUrl);\n        } catch (MalformedURLException e) {\n            LOGGER.debug(\"Error while getting URL for resource path [{}]\", resourceFilePath, e);\n            return Collections.singletonMap(CACHE_VERSION, getVersion());\n        }\n    }\n\n    private Map<String, Object> getResourceURLCacheParameters(URL resourceUrl)\n    {\n        Map<String, Object> parameters = new LinkedHashMap<>();\n\n        if (getURLConfiguration().useResourceLastModificationDate()) {\n            try {\n                Path resourcePath = Paths.get(resourceUrl.toURI());\n                FileTime lastModifiedTime = Files.getLastModifiedTime(resourcePath);\n                parameters.put(CACHE_VERSION, String.valueOf(lastModifiedTime.toMillis()));\n            } catch (Exception e) {\n                LOGGER.debug(\"Error when trying to access properties of resource URL [{}]\", resourceUrl, e);\n                parameters.put(CACHE_VERSION, getVersion());\n            }\n        } else {\n            parameters.put(CACHE_VERSION, getVersion());\n        }\n\n        return parameters;\n    }\n\n    public String getSkinFile(String filename, String skin, XWikiContext context)\n    {\n        return getSkinFile(filename, skin, false, context);\n    }\n\n    public String getSkinFile(String fileName, String skinId, boolean forceSkinAction, XWikiContext context)\n    {\n        if (StringUtils.endsWithAny(fileName, \".js\", \".css\")) {\n            String extension = StringUtils.substringAfterLast(fileName, '.');\n            String shortFileName = StringUtils.substringBeforeLast(fileName, \".\");\n            if (StringUtils.endsWith(shortFileName, \".min\")) {\n                shortFileName = StringUtils.substringBeforeLast(shortFileName, \".\");\n            }\n            String fileNameSource = String.format(\"%s.%s\", shortFileName, extension);\n            String fileNameMinified = String.format(\"%s.min.%s\", shortFileName, extension);\n            DebugConfiguration debugConfig = Utils.getComponent(DebugConfiguration.class);\n            String[] fileNames = debugConfig.isMinify() ? new String[] {fileNameMinified, fileNameSource}\n                : new String[] {fileNameSource, fileNameMinified};\n            String skinFile = null;\n            for (String name : fileNames) {\n                skinFile = getSkinFileInternal(name, skinId, forceSkinAction, context);\n                if (skinFile != null) {\n                    break;\n                }\n            }\n            return skinFile;\n        } else {\n            return getSkinFileInternal(fileName, skinId, forceSkinAction, context);\n        }\n    }\n\n    /**\n     * @deprecated since 7.0M1, use {@link SkinManager#getCurrentSkin(boolean)} instead\n     */\n    @Deprecated\n    public String getSkin(XWikiContext context)\n    {\n        String skin;\n\n        try {\n            skin = getInternalSkinManager().getCurrentSkinId(true);\n        } catch (Exception e) {\n            LOGGER.debug(\"Exception while determining current skin\", e);\n            skin = getDefaultBaseSkin(context);\n        }\n\n        return skin;\n    }\n\n    public String getSkinPreference(String prefname, XWikiContext context)\n    {\n        return getSkinPreference(prefname, \"\", context);\n    }\n\n    public String getSkinPreference(String prefname, String defaultValue, XWikiContext context)\n    {\n        for (Skin skin = getInternalSkinManager().getCurrentSkin(true); skin != null; skin = skin.getParent()) {\n            if (skin instanceof WikiSkin) {\n                String value = getWikiSkinUtils().getSkinProperty(skin.getId(), prefname);\n\n                // TODO: remove the NO_VALUE test when XWIKI-10853 is fixed\n                if (!StringUtils.isEmpty(value) && !NO_VALUE.equals(value)) {\n                    return value;\n                }\n            }\n        }\n\n        return defaultValue;\n    }\n\n    /**\n     * @deprecated since 7.0M1, use {@link SkinManager#getDefaultParentSkin()} instead\n     */\n    @Deprecated\n    public String getDefaultBaseSkin(XWikiContext context)\n    {\n        return getInternalSkinManager().getDefaultParentSkinId();\n    }\n\n    /**\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    public String getBaseSkin(XWikiContext context)\n    {\n        return getBaseSkin(context, false);\n    }\n\n    /**\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    public String getBaseSkin(XWikiContext context, boolean fromRenderSkin)\n    {\n        String baseskin = \"\";\n        try {\n            return getInternalSkinManager().getCurrentParentSkinId(false);\n        } catch (Exception e) {\n            baseskin = getDefaultBaseSkin(context);\n\n            LOGGER.debug(\"Exception while determining base skin\", e);\n        }\n\n        return baseskin;\n    }\n\n    /**\n     * @param skin the name of the skin for which to return the base skin. For example : {@code XWiki.DefaultSkin}\n     * @param context see {@link XWikiContext}\n     * @return if found, the name of the base skin the asked skin inherits from. If not found, returns an empty string.\n     * @since 2.0.2\n     * @since 2.1M1\n     * @deprecated since 7.0M1, use {@link SkinManager#getCurrentSkin(boolean)} and {@link Skin#getParent()} instead\n     */\n    @Deprecated\n    public String getBaseSkin(String skin, XWikiContext context)\n    {\n        String baseSkin = getInternalSkinManager().getParentSkin(skin);\n\n        return baseSkin != null ? baseSkin : \"\";\n    }\n\n    public String getSpaceCopyright(XWikiContext context)\n    {\n        return getSpacePreference(\"webcopyright\", \"\", context);\n    }\n\n    public String getXWikiPreference(String prefname, XWikiContext context)\n    {\n        return getXWikiPreference(prefname, \"\", context);\n    }\n\n    /**\n     * Obtain a preference value for the wiki, looking up first in the XWiki.XWikiPreferences document, then fallbacking\n     * on a config parameter when the first lookup gives an empty string, then returning the default value if the config\n     * parameter returned itself an empty string.\n     *\n     * @param prefname the parameter to look for in the XWiki.XWikiPreferences object in the XWiki.XWikiPreferences\n     *            document of the wiki.\n     * @param fallbackParam the parameter in xwiki.cfg to fallback on, in case the XWiki.XWikiPreferences object gave no\n     *            result\n     * @param defaultValue the default value to fallback on, in case both XWiki.XWikiPreferences and the fallback\n     *            xwiki.cfg parameter gave no result\n     */\n    public String getXWikiPreference(String prefname, String fallbackParam, String defaultValue, XWikiContext context)\n    {\n        String result = getWikiConfiguration().getProperty(prefname, String.class);\n\n        if (StringUtils.isEmpty(result)) {\n            result = getConfiguration().getProperty(fallbackParam, defaultValue);\n        }\n\n        return result != null ? result : \"\";\n    }\n\n    /**\n     * Obtain a preference value for the wiki, looking up first in the XWiki.XWikiPreferences document, then fallbacking\n     * on a config parameter when the first lookup gives an empty string, then returning the default value if the config\n     * parameter returned itself an empty string.\n     *\n     * @param prefname the parameter to look for in the XWiki.XWikiPreferences object in the XWiki.XWikiPreferences\n     *            document of the wiki.\n     * @param wiki the wiki to get preference from\n     * @param fallbackParam the parameter in xwiki.cfg to fallback on, in case the XWiki.XWikiPreferences object gave no\n     *            result\n     * @param defaultValue the default value to fallback on, in case both XWiki.XWikiPreferences and the fallback\n     *            xwiki.cfg parameter gave no result\n     * @since 7.4M1\n     */\n    public String getXWikiPreference(String prefname, String wiki, String fallbackParam, String defaultValue,\n        XWikiContext xcontext)\n    {\n        String currentWiki = xcontext.getWikiId();\n\n        try {\n            xcontext.setWikiId(wiki);\n\n            return getXWikiPreference(prefname, fallbackParam, defaultValue, xcontext);\n        } finally {\n            xcontext.setWikiId(currentWiki);\n        }\n    }\n\n    public String getXWikiPreference(String prefname, String defaultValue, XWikiContext context)\n    {\n        return getXWikiPreference(prefname, \"\", defaultValue, context);\n    }\n\n    public String getSpacePreference(String preference, XWikiContext context)\n    {\n        return getSpacePreference(preference, \"\", context);\n    }\n\n    public String getSpacePreference(String preference, String defaultValue, XWikiContext context)\n    {\n        return getSpacePreference(preference, (SpaceReference) null, defaultValue, context);\n    }\n\n    /**\n     * @deprecated since 7.4M1, use {@link #getSpacePreference(String, SpaceReference, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String getSpacePreference(String preference, String space, String defaultValue, XWikiContext context)\n    {\n        return getSpacePreference(preference, new SpaceReference(space, context.getWikiReference()), defaultValue,\n            context);\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     * \n     * @param preferenceKey the name of the preference key\n     * @param spaceReference the reference of the space\n     * @param context see {@link XWikiContext}\n     * @return the value of the preference or empty String if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreference(String preferenceKey, SpaceReference spaceReference, XWikiContext context)\n    {\n        return getSpacePreference(preferenceKey, spaceReference, \"\", context);\n    }\n\n    /**\n     * Get the preference key for the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     * \n     * @param preferenceKey the name of the preference key\n     * @param spaceReference the reference of the space. If null and there's a current document then the current space\n     *                       is used. If null and there's no current document then fall back to the wiki preferences.\n     * @param defaultValue the value to return if the preference can't be found\n     * @param context see {@link XWikiContext}\n     * @return the value of the preference or <code>defaultValue</code> if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreference(String preferenceKey, SpaceReference spaceReference, String defaultValue,\n        XWikiContext context)\n    {\n        XWikiDocument currentDocument = context.getDoc();\n\n        try {\n            if (spaceReference != null) {\n                context.setDoc(new XWikiDocument(new DocumentReference(\"WebPreferences\", spaceReference)));\n            } else if (currentDocument != null) {\n                spaceReference = currentDocument.getDocumentReference().getLastSpaceReference();\n            }\n\n            String result = getSpaceConfiguration().getProperty(preferenceKey, String.class);\n\n            if (StringUtils.isEmpty(result)) {\n                if (spaceReference == null) {\n                    result = getXWikiPreference(preferenceKey, defaultValue, context);\n                } else if (spaceReference.getParent() instanceof SpaceReference) {\n                    result = getSpacePreference(preferenceKey, (SpaceReference) spaceReference.getParent(),\n                        defaultValue, context);\n                } else if (spaceReference.getParent() instanceof WikiReference) {\n                    result =\n                        getXWikiPreference(preferenceKey, spaceReference.getParent().getName(), defaultValue, context);\n                }\n            }\n\n            return result != null ? result : defaultValue;\n        } finally {\n            context.setDoc(currentDocument);\n        }\n    }\n\n    public String getUserPreference(String prefname, XWikiContext context)\n    {\n        String result =\n            getAllUserPropertiesResolver().resolve(CurrentUserReference.INSTANCE).getProperty(prefname, String.class);\n\n        return result != null ? result : \"\";\n    }\n\n    public String getUserPreferenceFromCookie(String prefname, XWikiContext context)\n    {\n        Cookie[] cookies = context.getRequest().getCookies();\n        if (cookies == null) {\n            return null;\n        }\n        for (Cookie cookie : cookies) {\n            String name = cookie.getName();\n            if (name.equals(prefname)) {\n                String value = cookie.getValue();\n                if (!value.trim().equals(\"\")) {\n                    return value;\n                } else {\n                    break;\n                }\n            }\n        }\n        return null;\n    }\n\n    public String getUserPreference(String prefname, boolean useCookie, XWikiContext context)\n    {\n        // First we look in the cookies\n        if (useCookie) {\n            String result = Util.normalizeLanguage(getUserPreferenceFromCookie(prefname, context));\n            if (result != null) {\n                return result;\n            }\n        }\n        return getUserPreference(prefname, context);\n    }\n\n    /**\n     * Set the locale in the given context.\n     * <p>\n     * If {@code forceSupported} is true, then the locale will be set only if it is in the {@see availableLocales}. Note\n     * that all the parent locales are checked.\n     *\n     * @param locale the locale to use\n     * @param context the context\n     * @param availableLocales the accepted locales. Used only if {@see forceSupported} is true\n     * @param forceSupported determine if the {@see locale} should be checked against the {@see availableLocales}\n     * @return the locale that has been set or null\n     */\n    private Locale setLocale(Locale locale, XWikiContext context, Set<Locale> availableLocales, boolean forceSupported)\n    {\n        while (locale != null) {\n            if (!forceSupported || availableLocales.contains(locale)) {\n                context.setLocale(locale);\n                break;\n            }\n            locale = LocaleUtils.getParentLocale(locale);\n        }\n\n        return locale;\n    }\n\n    /**\n     * The algorithm to find the locale to use is the following, in this order:\n     *\n     * <ul>\n     *   <li>Try to find the current locale in use from the XWiki contex</li>\n     *   <li>If the wiki is not multilingual use the wiki default locale ({@code default_language} xproperty in\n     *   {@code XWikiPreferences} xobject or English if not found)</li>\n     *   <li>If the wiki is multilingual<ul>\n     *     <li>Try to get the locale passed in the request (looking for a {@code language} query string parameter).\n     *     If the language value is {@code default} use the wiki default locale. If a parameter is found sets a\n     *     {@code language} cookie to remember the language in use.</li>\n     *     <li>Try to get the locale from the {@code language} cookie</li>\n     *     <li>If the default language is preferred ({@code xwiki.language.preferDefault} from {@code xwiki.cfg}\n     *     or {@code preferDefaultLanguage} property from the space preferences ({@code WebPreferences} xobject) or\n     *     wiki preferences ({@code XWikiPreferences} xobject})), and since the user didn't explicitly ask for a\n     *     language already, then use the wiki default locale.</li>\n     *     <li>Try to use the browser's {@code Accept-Language} header sent in HTTP request.<li>\n     *     <li>Fallback to the wiki default locale</li>\n     *   </ul></li>\n     * </ul>\n     *\n     * In addition the {code xwiki.language.forceSupported} configuration property is enabled by default and means that\n     * if at any step above the locale found is not in the list of supported locales, then the locale is not set and\n     * the algorithm moves to the next step.\n     *\n     * @return the locale to use\n     * @since 8.0M1\n     */\n    public Locale getLocalePreference(XWikiContext context)\n    {\n        Locale defaultLocale = this.getDefaultLocale(context);\n        Set<Locale> availableLocales = new HashSet<>(this.getAvailableLocales(context));\n        boolean forceSupported = getConfiguration().getProperty(\"xwiki.language.forceSupported\", \"1\").equals(\"1\");\n\n        // First we try to get the language from the XWiki Context. This is the current language\n        // being used.\n        Locale locale = context.getLocale();\n        if (locale != null) {\n            return locale;\n        }\n\n        // If the wiki is non multilingual then the language is the default language.\n        if (!isMultiLingual(context)) {\n            locale = defaultLocale;\n            context.setLocale(locale);\n            return locale;\n        }\n\n        // As the wiki is multilingual try to find the language to use from the request by looking\n        // for a language parameter. If the language value is \"default\" use the default language\n        // from the XWiki preferences settings. Otherwise set a cookie to remember the language\n        // in use.\n        try {\n            String language = Util.normalizeLanguage(context.getRequest().getParameter(\"language\"));\n            if (language != null) {\n                if (\"default\".equals(language)) {\n                    // forgetting language cookie\n                    Cookie cookie = new Cookie(\"language\", \"\");\n                    cookie.setMaxAge(0);\n                    cookie.setPath(\"/\");\n                    context.getResponse().addCookie(cookie);\n                    context.setLocale(defaultLocale);\n                    return defaultLocale;\n                } else {\n                    locale = setLocale(LocaleUtils.toLocale(language), context, availableLocales, forceSupported);\n                    if (LocaleUtils.isAvailableLocale(locale)) {\n                        // setting language cookie\n                        Cookie cookie = new Cookie(\"language\", context.getLocale().toString());\n                        cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                        cookie.setPath(\"/\");\n                        context.getResponse().addCookie(cookie);\n                        return locale;\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        // As no language parameter was passed in the request, try to get the language to use from a cookie.\n        try {\n            // First we get the language from the cookie\n            String language = Util.normalizeLanguage(getUserPreferenceFromCookie(\"language\", context));\n            if (StringUtils.isNotEmpty(language)) {\n                locale = setLocale(LocaleUtils.toLocale(language), context, availableLocales, forceSupported);\n                if (LocaleUtils.isAvailableLocale(locale)) {\n                    return locale;\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        // If the default language is preferred, and since the user didn't explicitly ask for a\n        // language already, then use the default wiki language.\n        if (getConfiguration().getProperty(\"xwiki.language.preferDefault\", \"0\").equals(\"1\")\n            || getSpacePreference(\"preferDefaultLanguage\", \"0\", context).equals(\"1\")) {\n            locale = defaultLocale;\n            context.setLocale(locale);\n            return locale;\n        }\n\n        // Then from the navigator language setting\n        if (context.getRequest() != null && context.getRequest().getLocales() != null) {\n            for (Locale acceptedLocale : Collections.list(context.getRequest().getLocales())) {\n                locale = setLocale(acceptedLocale, context, availableLocales, forceSupported);\n                if (LocaleUtils.isAvailableLocale(locale)) {\n                    return locale;\n                }\n            }\n            // If none of the languages requested by the client is acceptable, skip to next\n            // phase (use default language).\n        }\n\n        // Finally, use the default language from the global preferences.\n        context.setLocale(defaultLocale);\n        return defaultLocale;\n    }\n\n    /**\n     * First try to find the current locale in use from the XWiki context. If none is used and if the wiki is not\n     * multilingual use the default locale defined in the XWiki preferences. If the wiki is multilingual try to get the\n     * locale passed in the request. If none was passed try to get it from a cookie. If no locale cookie exists then use\n     * the user default locale and barring that use the browser's \"Accept-Language\" header sent in HTTP request. If none\n     * is defined use the default locale.\n     *\n     * @return the locale to use\n     * @deprecated since 8.0M1, use {@link #getLocalePreference(XWikiContext)} instead\n     */\n    @Deprecated\n    public String getLanguagePreference(XWikiContext context)\n    {\n        return getLocalePreference(context).toString();\n    }\n\n    /**\n     * Construct a list of language codes (ISO 639-1) from the Accept-Languages header. This method filters out some\n     * bugs in different browsers or containers, like returning '*' as a language (Jetty) or using '_' as a\n     * language--country delimiter (some versions of Opera).\n     *\n     * @param request The client request.\n     * @return A list of language codes, in the client preference order; might be empty if the header is not well\n     *         formed.\n     */\n    private List<String> getAcceptedLanguages(XWikiRequest request)\n    {\n        List<String> result = new ArrayList<String>();\n        Enumeration<Locale> e = request.getLocales();\n        while (e.hasMoreElements()) {\n            String language = e.nextElement().getLanguage().toLowerCase();\n            // All language codes should have 2 letters.\n            if (StringUtils.isAlpha(language)) {\n                result.add(language);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @deprecated since 5.1M2 use {@link #getDefaultLocale(XWikiContext)} instead\n     */\n    @Deprecated\n    public String getDefaultLanguage(XWikiContext xcontext)\n    {\n        return getDefaultLocale(xcontext).toString();\n    }\n\n    /**\n     * The default locale in the preferences.\n     *\n     * @param xcontext the XWiki context.\n     * @return the default locale\n     * @since 5.1M2\n     */\n    public Locale getDefaultLocale(XWikiContext xcontext)\n    {\n        // Find out what is the default language from the XWiki preferences settings.\n        String defaultLanguage = xcontext.getWiki().getXWikiPreference(\"default_language\", \"\", xcontext);\n\n        Locale defaultLocale;\n\n        if (StringUtils.isBlank(defaultLanguage)) {\n            defaultLocale = Locale.ENGLISH;\n        } else {\n            try {\n                defaultLocale = LocaleUtils.toLocale(Util.normalizeLanguage(defaultLanguage));\n            } catch (Exception e) {\n                LOGGER.warn(\"Invalid locale [{}] set as default locale in the preferences\", defaultLanguage);\n                defaultLocale = Locale.ENGLISH;\n            }\n        }\n\n        return defaultLocale;\n    }\n\n    /**\n     * Get the available locales according to the preferences.\n     *\n     * @param xcontext the XWiki context\n     * @return all the available locales\n     * @since 5.1M2\n     */\n    public List<Locale> getAvailableLocales(XWikiContext xcontext)\n    {\n        String[] languages = StringUtils.split(xcontext.getWiki().getXWikiPreference(\"languages\", xcontext), \", |\");\n\n        List<Locale> locales = new ArrayList<Locale>(languages.length);\n\n        for (String language : languages) {\n            if (StringUtils.isNotBlank(language)) {\n                try {\n                    locales.add(LocaleUtils.toLocale(language));\n                } catch (Exception e) {\n                    LOGGER.warn(\"Invalid locale [{}] listed as available in the preferences\", language);\n                }\n            }\n        }\n\n        // Add default language in case it's not listed as available (which is wrong but it happen)\n        Locale defaultocale = getDefaultLocale(xcontext);\n        if (!locales.contains(defaultocale)) {\n            locales.add(defaultocale);\n        }\n\n        return locales;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public Locale getDocLocalePreferenceNew(XWikiContext context)\n    {\n        String language = getDocLanguagePreferenceNew(context);\n\n        return LocaleUtils.toLocale(language);\n    }\n\n    /**\n     * @deprecated since 8.0M1, use {@link #getDocLocalePreferenceNew(XWikiContext)} instead\n     */\n    @Deprecated\n    // TODO: move implementation to #getDocLocalePreferenceNew\n    public String getDocLanguagePreferenceNew(XWikiContext context)\n    {\n        // Get context language\n        String contextLanguage = context.getLanguage();\n        // If the language exists in the context, it was previously set by another call\n        if (!StringUtils.isEmpty(contextLanguage)) {\n            return contextLanguage;\n        }\n\n        String language = \"\", requestLanguage = \"\", userPreferenceLanguage = \"\", navigatorLanguage = \"\",\n            cookieLanguage = \"\";\n        boolean setCookie = false;\n\n        if (!context.getWiki().isMultiLingual(context)) {\n            language = context.getWiki().getXWikiPreference(\"default_language\", \"\", context);\n            context.setLanguage(language);\n            return language;\n        }\n\n        // Get request language\n        try {\n            requestLanguage = Util.normalizeLanguage(context.getRequest().getParameter(\"language\"));\n        } catch (Exception ex) {\n        }\n\n        // Get user preference\n        try {\n            String user = context.getUser();\n            XWikiDocument userdoc = getDocument(user, context);\n            if (userdoc != null) {\n                userPreferenceLanguage = userdoc.getStringValue(\"XWiki.XWikiUsers\", \"default_language\");\n            }\n        } catch (XWikiException e) {\n        }\n\n        // Get navigator language setting\n        if (context.getRequest() != null) {\n            String accept = context.getRequest().getHeader(\"Accept-Language\");\n            if ((accept != null) && (!accept.equals(\"\"))) {\n                String[] alist = StringUtils.split(accept, \",;-\");\n                if ((alist != null) && !(alist.length == 0)) {\n                    context.setLanguage(alist[0]);\n                    navigatorLanguage = alist[0];\n                }\n            }\n        }\n\n        // Get language from cookie\n        try {\n            cookieLanguage = Util.normalizeLanguage(getUserPreferenceFromCookie(\"language\", context));\n        } catch (Exception e) {\n        }\n\n        // Determine which language to use\n        // First we get the language from the request\n        if (StringUtils.isNotEmpty(requestLanguage)) {\n            if (requestLanguage.equals(\"default\")) {\n                setCookie = true;\n            } else {\n                language = requestLanguage;\n                context.setLanguage(language);\n                Cookie cookie = new Cookie(\"language\", language);\n                cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                cookie.setPath(\"/\");\n                context.getResponse().addCookie(cookie);\n                return language;\n            }\n        }\n        // Next we get the language from the cookie\n        if (StringUtils.isNotEmpty(cookieLanguage)) {\n            language = cookieLanguage;\n        }\n        // Next from the default user preference\n        else if (StringUtils.isNotEmpty(userPreferenceLanguage)) {\n            language = userPreferenceLanguage;\n        }\n        // Then from the navigator language setting\n        else if (StringUtils.isNotEmpty(navigatorLanguage)) {\n            language = navigatorLanguage;\n        }\n        context.setLanguage(language);\n        if (setCookie) {\n            Cookie cookie = new Cookie(\"language\", language);\n            cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n            cookie.setPath(\"/\");\n            context.getResponse().addCookie(cookie);\n        }\n        return language;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public Locale getInterfaceLocalePreference(XWikiContext context)\n    {\n        String language = getInterfaceLanguagePreference(context);\n\n        return LocaleUtils.toLocale(language);\n    }\n\n    /**\n     * @deprecated since 8.0M1, use {@link #getInterfaceLocalePreference(XWikiContext)} instead\n     */\n    @Deprecated\n    // TODO: move implementation to #getInterfaceLocalePreference\n    public String getInterfaceLanguagePreference(XWikiContext context)\n    {\n        String language = \"\", requestLanguage = \"\", userPreferenceLanguage = \"\", navigatorLanguage = \"\",\n            cookieLanguage = \"\", contextLanguage = \"\";\n        boolean setCookie = false;\n\n        if (!context.getWiki().isMultiLingual(context)) {\n            language = Util.normalizeLanguage(context.getWiki().getXWikiPreference(\"default_language\", \"\", context));\n            context.setInterfaceLocale(LocaleUtils.toLocale(language));\n            return language;\n        }\n\n        // Get request language\n        try {\n            requestLanguage = Util.normalizeLanguage(context.getRequest().getParameter(\"interfacelanguage\"));\n        } catch (Exception ex) {\n        }\n\n        // Get context language\n        contextLanguage = context.getInterfaceLanguage();\n\n        // Get user preference\n        try {\n            String user = context.getUser();\n            XWikiDocument userdoc = null;\n            userdoc = getDocument(user, context);\n            if (userdoc != null) {\n                userPreferenceLanguage = userdoc.getStringValue(\"XWiki.XWikiUsers\", \"default_interface_language\");\n            }\n        } catch (XWikiException e) {\n        }\n\n        // Get navigator language setting\n        if (context.getRequest() != null) {\n            String accept = context.getRequest().getHeader(\"Accept-Language\");\n            if ((accept != null) && (!accept.equals(\"\"))) {\n                String[] alist = StringUtils.split(accept, \",;-\");\n                if ((alist != null) && !(alist.length == 0)) {\n                    context.setLanguage(alist[0]);\n                    navigatorLanguage = alist[0];\n                }\n            }\n        }\n\n        // Get language from cookie\n        try {\n            cookieLanguage = Util.normalizeLanguage(getUserPreferenceFromCookie(\"interfacelanguage\", context));\n        } catch (Exception e) {\n        }\n\n        // Determine which language to use\n        // First we get the language from the request\n        if ((requestLanguage != null) && (!requestLanguage.equals(\"\"))) {\n            if (requestLanguage.equals(\"default\")) {\n                setCookie = true;\n            } else {\n                language = requestLanguage;\n                context.setLanguage(language);\n                Cookie cookie = new Cookie(\"interfacelanguage\", language);\n                cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                cookie.setPath(\"/\");\n                context.getResponse().addCookie(cookie);\n                return language;\n            }\n        }\n        // Next we get the language from the context\n        if (!StringUtils.isEmpty(contextLanguage)) {\n            language = contextLanguage;\n        }\n        // Next we get the language from the cookie\n        else if (StringUtils.isNotEmpty(cookieLanguage)) {\n            language = cookieLanguage;\n        }\n        // Next from the default user preference\n        else if (StringUtils.isNotEmpty(userPreferenceLanguage)) {\n            language = userPreferenceLanguage;\n        }\n        // Then from the navigator language setting\n        else if (StringUtils.isNotEmpty(navigatorLanguage)) {\n            language = navigatorLanguage;\n        }\n        context.setLanguage(language);\n        if (setCookie) {\n            Cookie cookie = new Cookie(\"interfacelanguage\", language);\n            cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n            cookie.setPath(\"/\");\n            context.getResponse().addCookie(cookie);\n        }\n        return language;\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getXWikiPreference(preference, context));\n    }\n\n    public long getSpacePreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getSpacePreference(preference, context));\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toLong((getXWikiPreference(preference, context)), defaultValue);\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, String fallbackParameter, long defaultValue,\n        XWikiContext context)\n    {\n        return NumberUtils.toLong(getXWikiPreference(preference, fallbackParameter, \"\", context), defaultValue);\n    }\n\n    public long getSpacePreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toLong(getSpacePreference(preference, context), defaultValue);\n    }\n\n    public long getUserPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getUserPreference(preference, context));\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, XWikiContext context)\n    {\n        return Integer.parseInt(getXWikiPreference(preference, context));\n    }\n\n    public int getSpacePreferenceAsInt(String preference, XWikiContext context)\n    {\n        return Integer.parseInt(getSpacePreference(preference, context));\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toInt(getXWikiPreference(preference, context), defaultValue);\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, String fallbackParameter, int defaultValue,\n        XWikiContext context)\n    {\n        return NumberUtils.toInt(getXWikiPreference(preference, fallbackParameter, \"\", context), defaultValue);\n    }\n\n    public int getSpacePreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toInt(getSpacePreference(preference, context), defaultValue);\n    }\n\n    public int getUserPreferenceAsInt(String prefname, XWikiContext context)\n    {\n        return Integer.parseInt(getUserPreference(prefname, context));\n    }\n\n    public void flushCache(XWikiContext context)\n    {\n        // We need to flush the virtual wiki list\n        this.initializedWikis = new ConcurrentHashMap<>();\n\n        // We need to flush the group service cache\n        if (this.groupService != null) {\n            this.groupService.flushCache();\n        }\n\n        // If we use the Cache Store layer.. we need to flush it\n        XWikiStoreInterface store = getStore();\n        if ((store != null) && (store instanceof XWikiCacheStoreInterface)) {\n            ((XWikiCacheStoreInterface) getStore()).flushCache();\n        }\n        // Flush renderers.. Groovy renderer has a cache\n        getOldRendering().flushCache();\n        getParseGroovyFromString().flushCache();\n\n        XWikiPluginManager pmanager = getPluginManager();\n        if (pmanager != null) {\n            pmanager.flushCache(context);\n        }\n\n        // Make sure we call all classes flushCache function\n        try {\n            List<String> classes = getClassList(context);\n            for (int i = 0; i < classes.size(); i++) {\n                String className = classes.get(i);\n                try {\n                    getClass(className, context).flushCache();\n                } catch (Exception e) {\n                }\n            }\n        } catch (Exception e) {\n        }\n\n    }\n\n    public XWikiPluginManager getPluginManager()\n    {\n        return this.pluginManager;\n    }\n\n    public void setPluginManager(XWikiPluginManager pluginManager)\n    {\n        this.pluginManager = pluginManager;\n    }\n\n    public void setStore(XWikiStoreInterface store)\n    {\n        this.store = store;\n    }\n\n    /**\n     * @param attachmentContentStore the store to use by default when saving a new attachment content\n     * @since 9.10RC1\n     */\n    public void setDefaultAttachmentContentStore(XWikiAttachmentStoreInterface attachmentContentStore)\n    {\n        this.defaultAttachmentContentStore = attachmentContentStore;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #setDefaultAttachmentContentStore(XWikiAttachmentStoreInterface)} instead\n     */\n    @Deprecated\n    public void setAttachmentStore(XWikiAttachmentStoreInterface attachmentStore)\n    {\n        this.defaultAttachmentContentStore = attachmentStore;\n    }\n\n    /**\n     * @param attachmentArchiveStore the store to use by default when saving a new attachment archive\n     * @since 9.10RC1\n     */\n    public void setDefaultAttachmentArchiveStore(AttachmentVersioningStore attachmentArchiveStore)\n    {\n        this.defaultAttachmentArchiveStore = attachmentArchiveStore;\n    }\n\n    /**\n     * @deprecated since 9.10RC1, use {@link #setDefaultAttachmentArchiveStore(AttachmentVersioningStore)} instead\n     */\n    @Deprecated\n    public void setAttachmentVersioningStore(AttachmentVersioningStore attachmentArchiveStore)\n    {\n        setDefaultAttachmentArchiveStore(attachmentArchiveStore);\n    }\n\n    public void setVersioningStore(XWikiVersioningStoreInterface versioningStore)\n    {\n        this.versioningStore = versioningStore;\n    }\n\n    public void setRecycleBinStore(XWikiRecycleBinStoreInterface recycleBinStore)\n    {\n        this.recycleBinStore = recycleBinStore;\n    }\n\n    public void setAttachmentRecycleBinStore(AttachmentRecycleBinStore attachmentRecycleBinStore)\n    {\n        this.attachmentRecycleBinStore = attachmentRecycleBinStore;\n    }\n\n    public void setCriteriaService(XWikiCriteriaService criteriaService)\n    {\n        this.criteriaService = criteriaService;\n    }\n\n    public void setVersion(String version)\n    {\n        this.version = version;\n    }\n\n    /**\n     * Verify if the provided xclass page exists and that it contains all the required configuration properties to make\n     * the tag feature work properly. If some properties are missing they are created and saved in the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @param classReference the reference of the document containing the class\n     * @return the Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     */\n    private BaseClass getMandatoryClass(XWikiContext context, DocumentReference classReference) throws XWikiException\n    {\n        XWikiDocument document = getDocument(classReference, context);\n\n        if (context.get(\"initdone\") == null) {\n            @SuppressWarnings(\"deprecation\")\n            MandatoryDocumentInitializer initializer =\n                Utils.getComponent(MandatoryDocumentInitializer.class, document.getFullName());\n\n            if (initializer.updateDocument(document)) {\n                saveDocument(document, localizePlainOrKey(\"core.model.xclass.mandatoryUpdateProperty.versionSummary\"),\n                    context);\n            }\n        }\n\n        return document.getXClass();\n    }\n\n    /**\n     * Verify if the <code>XWiki.TagClass</code> page exists and that it contains all the required configuration\n     * properties to make the tag feature work properly. If some properties are missing they are created and saved in\n     * the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the TagClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getTagClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"TagClass\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.SheetClass</code> page exists and that it contains all the required configuration\n     * properties to make the sheet feature work properly. If some properties are missing they are created and saved in\n     * the database. SheetClass is used to a page as a sheet. When a page is tagged as a sheet and that page is included\n     * in another page using the include macro then editing it triggers automatic inline edition (for XWiki Syntax 2.0\n     * only - for XWiki Syntax 1.0 automatic inline edition is triggered using #includeForm).\n     *\n     * @param context see {@link XWikiContext}\n     * @return the SheetClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     * @deprecated since 3.1M2 edit mode class should be used for this purpose, not the sheet class\n     * @see #getEditModeClass(XWikiContext)\n     */\n    @Deprecated\n    public BaseClass getSheetClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"SheetClass\"));\n    }\n\n    /**\n     * Verify if the {@code XWiki.EditModeClass} page exists and that it contains all the required configuration\n     * properties to make the edit mode feature work properly. If some properties are missing they are created and saved\n     * in the database. EditModeClass is used to specify the default edit mode of a page. It can also be used to mark a\n     * page as a sheet. When a page is marked as a sheet and that page is included in another page using the include\n     * macro then editing it triggers automatic inline edition (for XWiki Syntax 2.0 only - for XWiki Syntax 1.0\n     * automatic inline edition is triggered using #includeForm). It replaces and enhances the SheetClass mechanism (see\n     * {@link #getSheetClass(XWikiContext)}).\n     *\n     * @param context see {@link XWikiContext}\n     * @return the EditModeClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     * @since 3.1M2\n     */\n    public BaseClass getEditModeClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(\n            new LocalDocumentReference(XWikiConstant.EDIT_MODE_CLASS), new WikiReference(context.getWikiId())));\n    }\n\n    /**\n     * Verify if the <code>XWiki.XWikiUsers</code> page exists and that it contains all the required configuration\n     * properties to make the user feature work properly. If some properties are missing they are created and saved in\n     * the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the XWikiUsers Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getUserClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiUsers\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.GlobalRedirect</code> page exists and that it contains all the required configuration\n     * properties to make the redirection feature work properly. If some properties are missing they are created and\n     * saved in the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the GlobalRedirect Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getRedirectClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"GlobalRedirect\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.XWikiPreferences</code> page exists and that it contains all the required configuration\n     * properties to make XWiki work properly. If some properties are missing they are created and saved in the\n     * database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the XWiki Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getPrefsClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, getPreferencesDocumentReference(context));\n    }\n\n    public BaseClass getGroupClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiGroups\"));\n    }\n\n    public BaseClass getRightsClass(String pagename, XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, pagename));\n    }\n\n    public BaseClass getRightsClass(XWikiContext context) throws XWikiException\n    {\n        return getRightsClass(\"XWikiRights\", context);\n    }\n\n    public BaseClass getGlobalRightsClass(XWikiContext context) throws XWikiException\n    {\n        return getRightsClass(\"XWikiGlobalRights\", context);\n    }\n\n    public BaseClass getCommentsClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiComments\"));\n    }\n\n    public BaseClass getSkinClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiSkins\"));\n    }\n\n    public int createUser(XWikiContext context) throws XWikiException\n    {\n        return createUser(false, \"edit\", context);\n    }\n\n    public int validateUser(boolean withConfirmEmail, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            // Get the user document\n            String username = convertUsername(request.getParameter(\"xwikiname\"), context);\n            if (username.indexOf('.') == -1) {\n                username = \"XWiki.\" + username;\n            }\n            XWikiDocument userDocument = getDocument(username, context);\n\n            // Get the stored validation key\n            BaseObject userObject = userDocument.getObject(\"XWiki.XWikiUsers\", 0);\n            String storedKey = userObject.getStringValue(\"validkey\");\n\n            // Get the validation key from the URL\n            String validationKey = request.getParameter(\"validkey\");\n            PropertyInterface validationKeyClass = getClass(\"XWiki.XWikiUsers\", context).get(\"validkey\");\n            if (validationKeyClass instanceof PasswordClass) {\n                validationKey = ((PasswordClass) validationKeyClass).getEquivalentPassword(storedKey, validationKey);\n            }\n\n            // Compare the two keys\n            if ((!storedKey.equals(\"\") && (storedKey.equals(validationKey)))) {\n                // Ensure to remove the validation key value, so it cannot be used afterwards to enable back\n                // a disabled user.\n                userObject.setStringValue(\"validkey\", \"\");\n                saveDocument(userDocument, context);\n\n                XWikiUser xWikiUser = new XWikiUser(userDocument.getDocumentReference());\n                xWikiUser.setDisabled(false, context);\n                xWikiUser.setEmailChecked(true, context);\n\n                if (withConfirmEmail) {\n                    String email = userObject.getStringValue(\"email\");\n                    String password = userObject.getStringValue(\"password\");\n                    sendValidationEmail(username, password, email, request.getParameter(\"validkey\"),\n                        \"confirmation_email_content\", context);\n                }\n\n                return 0;\n            } else {\n                return -1;\n            }\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_VALIDATE_USER,\n                \"Exception while validating user\", e, null);\n        }\n    }\n\n    public int createUser(boolean withValidation, String userRights, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            Map<String, String[]> map = Util.getObject(request, \"register\");\n\n            String content = \"\";\n            Syntax syntax = getDefaultDocumentSyntaxInternal();\n\n            // Read the values from the request.\n            String xwikiname = request.getParameter(\"xwikiname\");\n            String password2 = request.getParameter(\"register2_password\");\n            String password = (map.get(\"password\"))[0];\n            String email = (map.get(\"email\"))[0];\n            String template = request.getParameter(\"template\");\n            String parent = request.getParameter(\"parent\");\n            String validkey = null;\n\n            // Validate the values.\n            if (XWikiRightService.SUPERADMIN_USER.equalsIgnoreCase(xwikiname)) {\n                return -8;\n            }\n            try {\n                if (!context.getUtil().match(getConfiguration().getProperty(\"xwiki.validusername\", \"/^[a-zA-Z0-9_]+$/\"),\n                    xwikiname)) {\n                    return -4;\n                }\n            } catch (RuntimeException ex) {\n                LOGGER.warn(\"Invalid regular expression for xwiki.validusername\", ex);\n                if (!context.getUtil().match(\"/^[a-zA-Z0-9_]+$/\", xwikiname)) {\n                    return -4;\n                }\n            }\n\n            if ((!password.equals(password2))) {\n                // TODO: throw wrong password exception\n                return -2;\n            }\n\n            if ((template != null) && (!template.equals(\"\"))) {\n                XWikiDocument tdoc = getDocument(template, context);\n                if ((!tdoc.isNew())) {\n                    // FIXME: This ignores template objects, attachments, etc.\n                    content = tdoc.getContent();\n                    syntax = tdoc.getSyntax();\n                }\n            }\n\n            if ((parent == null) || (parent.equals(\"\"))) {\n                parent = \"XWiki.XWikiUsers\";\n            }\n\n            // Mark the user as active or waiting email validation.\n            if (withValidation) {\n                map.put(XWikiUser.ACTIVE_PROPERTY, new String[] { \"0\" });\n                map.put(XWikiUser.EMAIL_CHECKED_PROPERTY, new String[] { \"0\" });\n\n                validkey = generateValidationKey(16);\n                map.put(\"validkey\", new String[] { validkey });\n\n            } else {\n                // Mark user active\n                map.put(XWikiUser.ACTIVE_PROPERTY, new String[] { \"1\" });\n                map.put(XWikiUser.EMAIL_CHECKED_PROPERTY, new String[] { \"1\" });\n            }\n\n            // Create the user.\n            int result =\n                createUser(xwikiname, map, getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT),\n                    content, syntax, userRights, context);\n\n            // Send validation mail, if needed.\n            if ((result > 0) && (withValidation)) {\n                // Send the validation email\n                try {\n                    sendValidationEmail(xwikiname, password, email, validkey, \"validation_email_content\", context);\n                } catch (XWikiException e) {\n                    LOGGER.warn(\"User created. Failed to send the mail to the created user.\", e);\n                    return -11;\n                }\n\n            }\n\n            return result;\n        } catch (XWikiException e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw e;\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_CREATE_USER,\n                \"Exception while creating user\", e, null);\n        }\n    }\n\n    /**\n     * Method allows to create an empty user with no password (he won't be able to login) This method is usefull for\n     * authentication like LDAP or App Server trusted\n     *\n     * @param xwikiname\n     * @param userRights\n     * @param context see {@link XWikiContext}\n     * @return true if success\n     * @throws XWikiException\n     */\n    public boolean createEmptyUser(String xwikiname, String userRights, XWikiContext context) throws XWikiException\n    {\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"active\", \"1\");\n        map.put(\"first_name\", xwikiname);\n\n        if (createUser(xwikiname, map, userRights, context) == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void sendConfirmationEmail(String xwikiname, String password, String email, String message,\n        String contentfield, XWikiContext context) throws XWikiException\n    {\n        sendValidationEmail(xwikiname, password, email, \"message\", message, contentfield, context);\n    }\n\n    public void sendValidationEmail(String xwikiname, String password, String email, String validkey,\n        String contentfield, XWikiContext context) throws XWikiException\n    {\n        sendValidationEmail(xwikiname, password, email, \"validkey\", validkey, contentfield, context);\n    }\n\n    public void sendValidationEmail(String xwikiname, String password, String email, String addfieldname,\n        String addfieldvalue, String contentfield, XWikiContext context) throws XWikiException\n    {\n        MailSenderConfiguration configuration = Utils.getComponent(MailSenderConfiguration.class);\n\n        String sender;\n        String content;\n        try {\n            sender = configuration.getFromAddress();\n            if (StringUtils.isBlank(sender)) {\n                String server = context.getRequest().getServerName();\n                if (server.matches(\"\\\\[.*\\\\]|(\\\\d{1,3}+\\\\.){3}+\\\\d{1,3}+\")) {\n                    sender = \"noreply@domain.net\";\n                } else {\n                    sender = \"noreply@\" + server;\n                }\n            }\n            content = getXWikiPreference(contentfield, context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_CANNOT_GET_VALIDATION_CONFIG,\n                \"Exception while reading the validation email config\", e, null);\n\n        }\n\n        try {\n            VelocityContext vcontext = (VelocityContext) context.get(\"vcontext\");\n            vcontext.put(addfieldname, addfieldvalue);\n            vcontext.put(\"email\", email);\n            vcontext.put(\"password\", password);\n            vcontext.put(\"sender\", sender);\n            vcontext.put(\"xwikiname\", xwikiname);\n            content = parseContent(content, context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_CANNOT_PREPARE_VALIDATION_EMAIL,\n                \"Exception while preparing the validation email\", e, null);\n\n        }\n\n        // Let's now send the message\n        try {\n            Session session =\n                Session.getInstance(configuration.getAllProperties(), new XWikiAuthenticator(configuration));\n            InputStream is = new ByteArrayInputStream(content.getBytes());\n            MimeMessage message = new MimeMessage(session, is);\n            message.setFrom(new InternetAddress(sender));\n            message.setRecipients(Message.RecipientType.TO, email);\n            message.setHeader(\"X-MailType\", \"Account Validation\");\n            MailSender mailSender = Utils.getComponent(MailSender.class);\n            MailListener mailListener = Utils.getComponent(MailListener.class, \"database\");\n            mailSender.sendAsynchronously(Arrays.asList(message), session, mailListener);\n            mailListener.getMailStatusResult().waitTillProcessed(Long.MAX_VALUE);\n            String errorMessage = MailStatusResultSerializer.serializeErrors(mailListener.getMailStatusResult());\n            if (errorMessage != null) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                    XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL,\n                    String.format(\"Error while sending the validation email. %s\", errorMessage));\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL, \"Error while sending the validation email\", e);\n        }\n    }\n\n    public String generateRandomString(int size)\n    {\n        return RandomStringUtils.randomAlphanumeric(size);\n    }\n\n    public String generateValidationKey(int size)\n    {\n        return generateRandomString(size);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, XWikiContext context) throws XWikiException\n    {\n        return createUser(userName, map, \"edit\", context);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param userRights the right of the user on his own profile page\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, String userRights, XWikiContext context)\n        throws XWikiException\n    {\n        BaseClass userClass = getUserClass(context);\n\n        String content = \"\";\n        Syntax syntax = getDefaultDocumentSyntaxInternal();\n\n        return createUser(userName, map,\n            new EntityReference(userClass.getDocumentReference().getName(), EntityType.DOCUMENT), content, syntax,\n            userRights, context);\n    }\n\n    /**\n     * @deprecated since 2.4RC1 use\n     *             {@link #createUser(String, Map, EntityReference, String, Syntax, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public int createUser(String userName, Map<String, ?> map, String parent, String content, String syntaxId,\n        String userRights, XWikiContext context) throws XWikiException\n    {\n        Syntax syntax;\n\n        try {\n            syntax = Syntax.valueOf(syntaxId);\n        } catch (ParseException e) {\n            syntax = getDefaultDocumentSyntaxInternal();\n        }\n\n        return createUser(userName, map, getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT),\n            content, syntax, userRights, context);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param parentReference the parent of the user profile\n     * @param content the content of the user profile\n     * @param syntax the syntax of the provided content\n     * @param userRights the right of the user on his own profile page\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, EntityReference parentReference, String content,\n        Syntax syntax, String userRights, XWikiContext context) throws XWikiException\n    {\n        BaseClass userClass = getUserClass(context);\n\n        try {\n            // TODO: Verify existing user\n            XWikiDocument doc = getDocument(new DocumentReference(context.getWikiId(), \"XWiki\", userName), context);\n\n            if (!doc.isNew()) {\n                // TODO: throws Exception\n                return -3;\n            }\n\n            DocumentReference userClassReference = userClass.getDocumentReference();\n            BaseObject userObject =\n                doc.newXObject(userClassReference.removeParent(userClassReference.getWikiReference()), context);\n            userClass.fromMap(map, userObject);\n\n            doc.setParentReference(parentReference);\n            doc.setContent(content);\n            doc.setSyntax(syntax);\n\n            // Set the user itself as the creator of the document, so that she has the CREATOR right on her user page.\n            doc.setCreatorReference(doc.getDocumentReference());\n\n            // However, we use the context user for the author to see in the history who has really created the user\n            // (it may be an administrator).\n            if (context.getUserReference() != null) {\n                doc.setAuthorReference(context.getUserReference());\n            } else {\n                // Except if the current user is guest (which means the user registered herself)\n                doc.setAuthorReference(doc.getDocumentReference());\n            }\n\n            // The information from the user profile needs to be indexed using the proper locale. If multilingual is\n            // enabled then the user can choose the desired locale (from the list of supported locales) before\n            // registering. An administrator registering users can do the same. Otherwise, if there is only one locale\n            // supported then that langage will be used.\n            doc.setDefaultLocale(context.getLocale());\n\n            protectUserPage(doc.getFullName(), userRights, doc, context);\n\n            saveDocument(doc, localizePlainOrKey(\"core.comment.createdUser\"), context);\n\n            // Now let's add the user to XWiki.XWikiAllGroup\n            setUserDefaultGroup(doc.getFullName(), context);\n\n            return 1;\n        } catch (Exception e) {\n            Object[] args = { \"XWiki.\" + userName };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_CREATE,\n                \"Cannot create user {0}\", e, args);\n        }\n    }\n\n    /**\n     * @deprecated starting with XE 1.8.1 use\n     *             {@link #createUser(String, Map, String, String, String, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public int createUser(String xwikiname, Map<String, ?> map, String parent, String content, String userRights,\n        XWikiContext context) throws XWikiException\n    {\n        return createUser(xwikiname, map, parent, content, Syntax.XWIKI_1_0.toIdString(), userRights, context);\n    }\n\n    public void setUserDefaultGroup(String fullwikiname, XWikiContext context) throws XWikiException\n    {\n        String groupsPreference = isAllGroupImplicit() ? getConfiguration().getProperty(\"xwiki.users.initialGroups\")\n            : getConfiguration().getProperty(\"xwiki.users.initialGroups\", \"XWiki.XWikiAllGroup\");\n\n        if (groupsPreference != null) {\n            String[] groups = groupsPreference.split(\",\");\n            for (String groupName : groups) {\n                if (StringUtils.isNotBlank(groupName)) {\n                    addUserToGroup(fullwikiname, groupName.trim(), context);\n                }\n            }\n        }\n    }\n\n    protected void addUserToGroup(String userName, String groupName, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groupDoc = getDocument(groupName, context);\n\n        DocumentReference groupClassReference = getGroupClass(context).getDocumentReference();\n        BaseObject memberObject =\n            groupDoc.newXObject(groupClassReference.removeParent(groupClassReference.getWikiReference()), context);\n\n        memberObject.setStringValue(\"member\", userName);\n\n        this.saveDocument(groupDoc, localizePlainOrKey(\"core.comment.addedUserToGroup\"), context);\n    }\n\n    public void protectUserPage(String userName, String userRights, XWikiDocument doc, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference rightClassReference = getRightsClass(context).getDocumentReference();\n\n        EntityReference relativeRightClassReference =\n            rightClassReference.removeParent(rightClassReference.getWikiReference());\n\n        // Allow users to edit their own profiles\n        BaseObject newuserrightsobject = doc.newXObject(relativeRightClassReference, context);\n        newuserrightsobject.setLargeStringValue(\"users\", userName);\n        newuserrightsobject.setStringValue(\"levels\", userRights);\n        newuserrightsobject.setIntValue(\"allow\", 1);\n    }\n\n    public User getUser(XWikiContext context)\n    {\n        return getUser(context.getUserReference(), context);\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link #getUser(DocumentReference, XWikiContext)}.\n     */\n    @Deprecated\n    public User getUser(String username, XWikiContext context)\n    {\n        XWikiUser xwikiUser = new XWikiUser(username);\n        User user = new User(xwikiUser, context);\n        return user;\n    }\n\n    /**\n     * Retrieve a user from its document reference.\n     *\n     * @param userReference the reference of the user.\n     * @param context the current context.\n     * @return the user corresponding to that document reference.\n     * @since 11.8RC1\n     */\n    public User getUser(DocumentReference userReference, XWikiContext context)\n    {\n        XWikiUser xwikiUser = new XWikiUser(userReference);\n        User user = new User(xwikiUser, context);\n        return user;\n    }\n\n    /**\n     * Prepares the localized resources, according to the selected locale. Set context \"msg\" and locale.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public void prepareResources(XWikiContext context)\n    {\n        if (context.get(\"msg\") == null) {\n            Locale locale = getLocalePreference(context);\n            context.setLocale(locale);\n            if (context.getResponse() != null) {\n                context.getResponse().setLocale(locale);\n            }\n            XWikiMessageTool msg = new XWikiMessageTool(Utils.getComponent(ContextualLocalizationManager.class));\n            context.put(\"msg\", msg);\n        }\n    }\n\n    public XWikiUser checkAuth(XWikiContext context) throws XWikiException\n    {\n        return getAuthService().checkAuth(context);\n    }\n\n    public boolean checkAccess(String action, XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        // Handle the 'skin' action specially so that resources don`t require special (or even 'view') rights.\n        String firstSpaceName = doc.getDocumentReference().getSpaceReferences().get(0).getName();\n        if (action.equals(\"skin\") && SKIN_RESOURCE_SPACE_NAMES.contains(firstSpaceName)) {\n            // We still need to call checkAuth to set the proper user.\n            XWikiUser user = checkAuth(context);\n            if (user != null) {\n                context.setUser(user.getUser());\n            }\n\n            // Always allow.\n            return true;\n        }\n\n        return getRightService().checkAccess(action, doc, context);\n    }\n\n    public String include(String topic, boolean isForm, XWikiContext context) throws XWikiException\n    {\n        String database = null, incdatabase = null;\n        String prefixedTopic, localTopic;\n\n        // Save current documents in script context\n        Document currentAPIdoc = null, currentAPIcdoc = null, currentAPItdoc = null;\n        ScriptContextManager scritContextManager = Utils.getComponent(ScriptContextManager.class);\n        ScriptContext scontext = scritContextManager.getScriptContext();\n        String currentDocName = context.getWikiId() + \":\" + context.getDoc().getFullName();\n        if (scontext != null) {\n            currentAPIdoc = (Document) scontext.getAttribute(\"doc\");\n            currentAPIcdoc = (Document) scontext.getAttribute(\"cdoc\");\n            currentAPItdoc = (Document) scontext.getAttribute(\"tdoc\");\n        }\n\n        try {\n            int i0 = topic.indexOf(':');\n            if (i0 != -1) {\n                incdatabase = topic.substring(0, i0);\n                database = context.getWikiId();\n                context.setWikiId(incdatabase);\n                prefixedTopic = topic;\n                localTopic = topic.substring(i0 + 1);\n            } else {\n                prefixedTopic = context.getWikiId() + \":\" + topic;\n                localTopic = topic;\n            }\n\n            XWikiDocument doc = null;\n            try {\n                LOGGER.debug(\"Including Topic \" + topic);\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    Set<String> includedDocs = (Set<String>) context.get(\"included_docs\");\n                    if (includedDocs == null) {\n                        includedDocs = new HashSet<String>();\n                        context.put(\"included_docs\", includedDocs);\n                    }\n\n                    if (includedDocs.contains(prefixedTopic) || currentDocName.equals(prefixedTopic)) {\n                        LOGGER.warn(\"Error on too many recursive includes for topic \" + topic);\n                        return \"Cannot make recursive include\";\n                    }\n                    includedDocs.add(prefixedTopic);\n                } catch (Exception e) {\n                }\n\n                // Get document to include\n                DocumentReference targetDocumentReference =\n                    getCurrentMixedDocumentReferenceResolver().resolve(localTopic);\n                doc = getDocument(targetDocumentReference, context);\n\n                if (checkAccess(\"view\", doc, context) == false) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED, \"Access to this document is denied: \" + doc);\n                }\n            } catch (XWikiException e) {\n                LOGGER.warn(\"Exception Including Topic \" + topic, e);\n                return \"Topic \" + topic + \" does not exist\";\n            }\n\n            XWikiDocument contentdoc = doc.getTranslatedDocument(context);\n\n            String result;\n            if (isForm) {\n                // We do everything in the context of the including document\n                if (database != null) {\n                    context.setWikiId(database);\n                }\n\n                // Note: the Script macro in the new rendering checks for programming rights for the document in\n                // the xwiki context.\n                result = getRenderedContent(contentdoc, (XWikiDocument) context.get(\"doc\"), context);\n            } else {\n                // We stay in the included document context\n\n                // Since the Script macro checks for programming rights in the current document, we need to\n                // temporarily set the contentdoc as the current doc before rendering it.\n                XWikiDocument originalDoc = null;\n                try {\n                    originalDoc = context.getDoc();\n                    context.put(\"doc\", doc);\n                    result = getRenderedContent(contentdoc, doc, context);\n                } finally {\n                    context.put(\"doc\", originalDoc);\n                }\n            }\n            try {\n                @SuppressWarnings(\"unchecked\")\n                Set<String> includedDocs = (Set<String>) context.get(\"included_docs\");\n                if (includedDocs != null) {\n                    includedDocs.remove(prefixedTopic);\n                }\n            } catch (Exception e) {\n            }\n            return result;\n        } finally {\n            if (database != null) {\n                context.setWikiId(database);\n            }\n\n            if (currentAPIdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"doc\", currentAPIdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n            if (currentAPIcdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"cdoc\", currentAPIcdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n            if (currentAPItdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"tdoc\", currentAPItdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n        }\n    }\n\n    /**\n     * Render content from the passed included document, setting the correct security doc (sdoc) and including doc\n     * (idoc).\n     *\n     * @since 2.2M2\n     */\n    private String getRenderedContent(XWikiDocument includedDoc, XWikiDocument includingDoc, XWikiContext context)\n        throws XWikiException\n    {\n        String result;\n        XWikiDocument idoc = (XWikiDocument) context.get(\"idoc\");\n        XWikiDocument sdoc = (XWikiDocument) context.get(\"sdoc\");\n\n        context.put(\"idoc\", includingDoc);\n        context.put(\"sdoc\", includedDoc);\n        try {\n            result = includedDoc.getRenderedContent(Utils.getComponent(RenderingContext.class).getTargetSyntax(), false,\n                context);\n        } finally {\n            // Remove including doc or set the previous one\n            if (idoc == null) {\n                context.remove(\"idoc\");\n            } else {\n                context.put(\"idoc\", idoc);\n            }\n\n            // Remove security doc or set the previous one\n            if (sdoc == null) {\n                context.remove(\"sdoc\");\n            } else {\n                context.put(\"sdoc\", sdoc);\n            }\n        }\n\n        return result;\n    }\n\n    public void deleteDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        deleteDocument(doc, true, context);\n    }\n\n    public void deleteDocument(XWikiDocument doc, boolean totrash, XWikiContext context) throws XWikiException\n    {\n        deleteDocument(doc, totrash, true, context);\n    }\n\n    private XWikiDocument prepareDocumentDelete(XWikiDocument doc, XWikiContext context)\n    {\n        // The source document is a new empty XWikiDocument to follow\n        // DocumentUpdatedEvent policy: source document in new document and the old version is available using\n        // doc.getOriginalDocument()\n        XWikiDocument blankDoc = new XWikiDocument(doc.getDocumentReference());\n        // Again to follow general event policy, new document author is the user who modified the document\n        // (here the modification is delete)\n        blankDoc.setOriginalDocument(doc.getOriginalDocument());\n        blankDoc.setAuthorReference(context.getUserReference());\n        blankDoc.setContentAuthorReference(context.getUserReference());\n\n        return blankDoc;\n    }\n\n    private XWikiDocument beforeDelete(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument blankDoc = prepareDocumentDelete(doc, context);\n\n        ObservationManager om = getObservationManager();\n\n        // Inform notification mechanisms that a document is about to be deleted\n        // Note that for the moment the event being send is a bridge event, as we are still passing around\n        // an XWikiDocument as source and an XWikiContext as data.\n        if (om != null) {\n            CancelableEvent documentEvent = new DocumentDeletingEvent(doc.getDocumentReference());\n            om.notify(documentEvent, blankDoc, context);\n\n            // If the action has been canceled by the user then don't perform any deletion and throw an exception\n            if (documentEvent.isCanceled()) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_DOC,\n                    String.format(\"An Event Listener has cancelled the document deletion for [%s]. Reason: [%s]\",\n                        doc.getDocumentReference(), documentEvent.getReason()));\n            }\n        }\n\n        return blankDoc;\n    }\n\n    private void afterDelete(XWikiDocument blankDoc, XWikiContext context)\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            om.notify(new DocumentDeletedEvent(blankDoc.getDocumentReference()), blankDoc, context);\n        }\n    }\n\n    private void deleteDocument(XWikiDocument doc, boolean totrash, boolean notify, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = null;\n\n        currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(doc.getDocumentReference().getWikiReference().getName());\n\n            XWikiDocument blankDoc = null;\n\n            // Inform notification mechanisms that a document is about to be deleted\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            if (notify) {\n                blankDoc = beforeDelete(doc, context);\n            }\n\n            if (hasRecycleBin(context) && totrash) {\n                // Extract any existing batchId from the context.\n                String batchId = Utils.getComponent(BatchOperationExecutor.class).getCurrentBatchId();\n\n                // Save to recycle bin together with any determined batch ID.\n                getRecycleBinStore().saveToRecycleBin(doc, context.getUser(), new Date(), batchId, context, true);\n            }\n\n            getStore().deleteXWikiDoc(doc, context);\n\n            try {\n                // Inform notification mechanisms that a document has been deleted\n                // Note that for the moment the event being send is a bridge event, as we are still passing around\n                // an XWikiDocument as source and an XWikiContext as data.\n                if (notify) {\n                    afterDelete(blankDoc, context);\n                }\n            } catch (Exception ex) {\n                LOGGER.error(\"Failed to send document delete notifications for document [{}]\",\n                    doc.getDocumentReference(), ex);\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Check if the user is allowed to delete the document.\n     * \n     * @param userReference the user responsible for the delete\n     * @param document the document to delete\n     * @param context the XWiki context\n     * @throws XWikiException when failing to delete\n     * @since 11.6\n     * @since 10.11.10\n     */\n    public void checkDeletingDocument(DocumentReference userReference, XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = null;\n\n        currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            XWikiDocument blankDoc = prepareDocumentDelete(document, context);\n\n            ObservationManager om = getObservationManager();\n\n            // Inform notification mechanisms that a document is about to be deleted\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            if (om != null) {\n                CancelableEvent documentEvent =\n                    new UserDeletingDocumentEvent(userReference, document.getDocumentReference());\n                om.notify(documentEvent, blankDoc, context);\n\n                // If the action has been canceled by the user then don't perform any deletion and throw an exception\n                if (documentEvent.isCanceled()) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        String.format(\"User [%s] has been denied the right to delete the document [%s]. Reason: [%s]\",\n                            userReference, document.getDocumentReference(), documentEvent.getReason()));\n                }\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Delete a range of versions from a document history.\n     * \n     * @param document the document from which to delete versions\n     * @param version1 one end of the versions range to remove\n     * @param version2 the other end of the versions range to remove\n     * @param context the XWiki context\n     * @throws XWikiException\n     * @since 13.6RC1\n     */\n    @Unstable\n    public void deleteDocumentVersions(XWikiDocument document, String version1, String version2, XWikiContext context)\n        throws XWikiException\n    {\n        Version v1 = new Version(version1);\n        Version v2 = new Version(version2);\n\n        // Find the lower and upper bounds\n        Version upperBound = v1;\n        Version lowerBound = v2;\n        if (upperBound.compareVersions(lowerBound) < 0) {\n            Version tmp = upperBound;\n            upperBound = lowerBound;\n            lowerBound = tmp;\n        }\n\n        XWikiDocumentArchive archive = document.getDocumentArchive(context);\n\n        // Remove the versions\n        archive.removeVersions(upperBound, lowerBound, context);\n\n        // Is this the last remaining version? If so, then recycle the document.\n        if (archive.getLatestVersion() == null) {\n            // Wrap the work as a batch operation.\n            BatchOperationExecutor batchOperationExecutor = Utils.getComponent(BatchOperationExecutor.class);\n            batchOperationExecutor.execute(() -> {\n                if (document.getLocale().equals(Locale.ROOT)) {\n                    context.getWiki().deleteAllDocuments(document, context);\n                } else {\n                    // Only delete the translation\n                    context.getWiki().deleteDocument(document, context);\n                }\n            });\n        } else {\n            // Notify before versions delete\n            getObservationManager()\n                .notify(new DocumentVersionRangeDeletingEvent(document.getDocumentReferenceWithLocale(),\n                    lowerBound.toString(), upperBound.toString()), document, context);\n\n            // Update the archive\n            context.getWiki().getVersioningStore().saveXWikiDocArchive(archive, true, context);\n            document.setDocumentArchive(archive);\n\n            // There are still some versions left.\n            // If we delete the most recent (current) version, then rollback to latest undeleted version.\n            Version previousVersion = archive.getLatestVersion();\n            if (!document.getRCSVersion().equals(previousVersion)) {\n                context.getWiki().rollback(document, previousVersion.toString(), false, context);\n            }\n\n            // Notify after versions delete\n            getObservationManager()\n                .notify(new DocumentVersionRangeDeletedEvent(document.getDocumentReferenceWithLocale(),\n                    lowerBound.toString(), upperBound.toString()), document, context);\n        }\n    }\n\n    public String getDatabase()\n    {\n        return this.database;\n    }\n\n    public void setDatabase(String database)\n    {\n        this.database = database;\n    }\n\n    public void gc()\n    {\n        System.gc();\n    }\n\n    public long freeMemory()\n    {\n        return Runtime.getRuntime().freeMemory();\n    }\n\n    public long totalMemory()\n    {\n        return Runtime.getRuntime().totalMemory();\n    }\n\n    public long maxMemory()\n    {\n        return Runtime.getRuntime().maxMemory();\n    }\n\n    public String[] split(String str, String sep)\n    {\n        return StringUtils.split(str, sep);\n    }\n\n    /**\n     * @deprecated use {@link ExceptionUtils#getStackTrace(Throwable)} instead\n     */\n    @Deprecated\n    public String printStrackTrace(Throwable e)\n    {\n        StringWriter strwriter = new StringWriter();\n        PrintWriter writer = new PrintWriter(strwriter);\n        e.printStackTrace(writer);\n\n        return strwriter.toString();\n    }\n\n    /**\n     * API to rename a document to another document.\n     *\n     * @param sourceDocumentReference the source document to rename.\n     * @param targetDocumentReference the target reference to rename the document to.\n     * @param overwrite if {@code true} the target document reference will be overwritten if it exists\n     *                  (deleted to the recycle bin before the rename). If {@code false} and the target document exist\n     *                  the rename won't be performed.\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *                                  modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *                                 document reference\n     * @return {@code true} if the rename succeeded. {@code false} if there was any issue.\n     * @throws XWikiException if the document cannot be renamed properly.\n     * @since 12.5RC1\n     */\n    public boolean renameDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean overwrite, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences, XWikiContext context)\n        throws XWikiException\n    {\n        boolean result = false;\n\n        // if source and destination are same, no need to perform the rename.\n        if (!sourceDocumentReference.equals(targetDocumentReference)) {\n            XWikiDocument sourceDocument = this.getDocument(sourceDocumentReference, context);\n            XWikiDocument targetDocument = this.getDocument(targetDocumentReference, context);\n\n            ConfigurationSource xwikiproperties = Utils.getComponent(ConfigurationSource.class, \"xwikiproperties\");\n            boolean useAtomicRename = xwikiproperties.getProperty(\"refactoring.rename.useAtomicRename\", Boolean.TRUE);\n\n            // Proceed on the rename only if the source document exists and if either the targetDoc does not exist or\n            // the overwritten is accepted.\n            if (!sourceDocument.isNew() && (overwrite || targetDocument.isNew())) {\n                if (!useAtomicRename) {\n                    this.renameByCopyAndDelete(sourceDocument, targetDocumentReference, backlinkDocumentReferences,\n                        childDocumentReferences, context);\n                    result = true;\n                } else {\n                    // Ensure that the current context contains the wiki reference of the source document.\n                    WikiReference wikiReference = context.getWikiReference();\n                    context.setWikiReference(sourceDocumentReference.getWikiReference());\n\n                    try {\n                        // rename main document\n                        this.atomicRenameDocument(sourceDocument, targetDocumentReference, context);\n\n                        // handle translations\n                        List<Locale> translationLocales = sourceDocument.getTranslationLocales(context);\n                        for (Locale translationLocale : translationLocales) {\n                            DocumentReference translatedSourceReference =\n                                new DocumentReference(sourceDocumentReference, translationLocale);\n                            DocumentReference translatedTargetReference =\n                                new DocumentReference(targetDocumentReference, translationLocale);\n                            XWikiDocument translatedSourceDoc = this.getDocument(translatedSourceReference, context);\n                            this.atomicRenameDocument(translatedSourceDoc, translatedTargetReference, context);\n                        }\n                    } finally {\n                        context.setWikiReference(wikiReference);\n                    }\n\n                    // Step 4: For each child document, update its parent reference.\n                    // Step 5: For each backlink to rename, parse the backlink document and replace the links with\n                    // the new name.\n                    // Step 6: Refactor the relative links contained in the document to make sure they are relative\n                    // to the new document's location.\n                    this.updateLinksForRename(sourceDocument, targetDocumentReference, backlinkDocumentReferences,\n                        childDocumentReferences, context);\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private void atomicRenameDocument(XWikiDocument sourceDocument, DocumentReference targetDocumentReference,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 1: Simulate creating a document and deleting a document from listeners point of view\n        // FIXME: currently modifications made by listeners won't be applied\n        XWikiDocument futureTargetDocument = sourceDocument.cloneRename(targetDocumentReference, context);\n        futureTargetDocument.setOriginalDocument(new XWikiDocument(targetDocumentReference));\n        beforeSave(futureTargetDocument, context);\n        XWikiDocument deletedDocument = beforeDelete(sourceDocument, context);\n\n        // Step 2: Perform atomic rename in DB\n        this.getStore().renameXWikiDoc(sourceDocument, targetDocumentReference, context);\n\n        // Step 3: Simulate a created document and a deleted document from listeners point of view\n        afterDelete(deletedDocument, context);\n        afterSave(futureTargetDocument, context);\n    }\n\n    private void updateLinksForRename(XWikiDocument sourceDoc, DocumentReference newDocumentReference,\n        List<DocumentReference> backlinkDocumentReferences, List<DocumentReference> childDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 2: For each child document, update its parent reference.\n        if (childDocumentReferences != null) {\n            for (DocumentReference childDocumentReference : childDocumentReferences) {\n                XWikiDocument childDocument = getDocument(childDocumentReference, context);\n                String compactReference = getCompactEntityReferenceSerializer().serialize(newDocumentReference);\n                childDocument.setParent(compactReference);\n                String saveMessage = localizePlainOrKey(\"core.comment.renameParent\", compactReference);\n                childDocument.setAuthorReference(context.getUserReference());\n                saveDocument(childDocument, saveMessage, true, context);\n            }\n        }\n\n        // Step 3: For each backlink to rename, parse the backlink document and replace the links with the new name.\n        for (DocumentReference backlinkDocumentReference : backlinkDocumentReferences) {\n            XWikiDocument backlinkRootDocument = getDocument(backlinkDocumentReference, context);\n\n            // Update default locale instance\n            renameLinks(backlinkRootDocument, sourceDoc.getDocumentReference(), newDocumentReference, context);\n\n            // Update translations\n            for (Locale locale : backlinkRootDocument.getTranslationLocales(context)) {\n                XWikiDocument backlinkDocument = backlinkRootDocument.getTranslatedDocument(locale, context);\n\n                renameLinks(backlinkDocument, sourceDoc.getDocumentReference(), newDocumentReference, context);\n            }\n        }\n\n        // Get new document\n        XWikiDocument newDocument = getDocument(newDocumentReference, context);\n\n        // Step 4: Refactor the relative links contained in the document to make sure they are relative to the new\n        // document's location.\n        if (Utils.getContextComponentManager().hasComponent(BlockRenderer.class, sourceDoc.getSyntax().toIdString())) {\n            // Only support syntax for which a renderer is provided\n\n            ReferenceRenamer referenceRenamer = Utils.getComponent(ReferenceRenamer.class);\n\n            DocumentReference oldDocumentReference = sourceDoc.getDocumentReference();\n            XDOM newDocumentXDOM = newDocument.getXDOM();\n            boolean modified = referenceRenamer\n                .renameReferences(newDocumentXDOM, newDocumentReference, oldDocumentReference, newDocumentReference,\n                    false);\n\n            // Set the new content and save document if needed\n            if (modified) {\n                newDocument.setContent(newDocumentXDOM);\n                newDocument.setAuthorReference(context.getUserReference());\n                saveDocument(newDocument, context);\n            }\n        }\n    }\n\n    /**\n     * Perform a rename of document by copying the document and deleting the old one.\n     * This operation must be used only in case of document rename from one wiki to another, since it's not supported\n     * by the atomic store operation.\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *            document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 12.5\n     * @deprecated Old implementation of the rename by copy and delete. Since 12.5 the implementation using\n     * {@link XWikiStoreInterface#renameXWikiDoc(XWikiDocument, DocumentReference, XWikiContext)} should be preferred.\n     */\n    @Deprecated\n    public void renameByCopyAndDelete(XWikiDocument sourceDoc, DocumentReference newDocumentReference,\n        List<DocumentReference> backlinkDocumentReferences, List<DocumentReference> childDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 1: Copy the document and all its translations under a new document with the new reference.\n        copyDocument(sourceDoc.getDocumentReference(), newDocumentReference, false, context);\n\n        // Step 2: For each child document, update its parent reference.\n        // Step 3: For each backlink to rename, parse the backlink document and replace the links with the new name.\n        // Step 4: Refactor the relative links contained in the document to make sure they are relative to the new\n        // document's location.\n        updateLinksForRename(sourceDoc, newDocumentReference, backlinkDocumentReferences, childDocumentReferences,\n            context);\n\n        // Step 5: Delete the old document\n        deleteDocument(sourceDoc, context);\n\n        // Get new document\n        XWikiDocument newDocument = getDocument(newDocumentReference, context);\n\n        // Step 6: The current document needs to point to the renamed document as otherwise it's pointing to an\n        // invalid XWikiDocument object as it's been deleted...\n        sourceDoc.clone(newDocument);\n    }\n\n    /**\n     * Rename links in passed document and save it if needed.\n     */\n    private void renameLinks(XWikiDocument backlinkDocument, DocumentReference oldLink, DocumentReference newLink,\n        XWikiContext context) throws XWikiException\n    {\n        // FIXME: Duplicate code. See org.xwiki.refactoring.internal.DefaultLinkRefactoring#renameLinks in\n        // xwiki-platform-refactoring-default\n        getOldRendering().renameLinks(backlinkDocument, oldLink, newLink, context);\n\n        // Save if content changed\n        if (backlinkDocument.isContentDirty()) {\n            String saveMessage =\n                localizePlainOrKey(\"core.comment.renameLink\", getCompactEntityReferenceSerializer().serialize(newLink));\n            backlinkDocument.setAuthorReference(context.getUserReference());\n            context.getWiki().saveDocument(backlinkDocument, saveMessage, true, context);\n        }\n    }\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part if it matches the current\n     * wiki).\n     */\n    private static EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (compact form).\n     */\n    private static EntityReferenceSerializer<String> getCompactEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n    }\n\n    /**\n     * Used to resolve a ResourceReference into a proper Entity Reference using the current document to fill the blanks.\n     */\n    private static EntityReferenceResolver<org.xwiki.rendering.listener.reference.ResourceReference>\n        getResourceReferenceEntityReferenceResolver()\n    {\n        return Utils\n            .getComponent(new DefaultParameterizedType(null, EntityReferenceResolver.class,\n                org.xwiki.rendering.listener.reference.ResourceReference.class));\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, true, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean reset, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, reset, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean reset, boolean force, boolean resetCreationData, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, reset, force, resetCreationData,\n            context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, true, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, false, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, boolean force, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, force, false, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, boolean force, boolean resetCreationData, XWikiContext context)\n        throws XWikiException\n    {\n        String db = context.getWikiId();\n        String sourceWiki = sourceDocumentReference.getWikiReference().getName();\n        String targetWiki = targetDocumentReference.getWikiReference().getName();\n\n        String sourceStringReference = getDefaultEntityReferenceSerializer().serialize(sourceDocumentReference);\n\n        try {\n            context.setWikiId(sourceWiki);\n            XWikiDocument sdoc = getDocument(sourceDocumentReference, context);\n            if (!sdoc.isNew()) {\n                LOGGER.info(\"Copying document [{}] to [{}]\", sourceDocumentReference, targetDocumentReference);\n\n                // Let's switch to the other database to verify if the document already exists\n                context.setWikiId(targetWiki);\n                XWikiDocument previoustdoc = getDocument(targetDocumentReference, context);\n                // There is already an existing document\n                if (!previoustdoc.isNew()) {\n                    if (!force) {\n                        return false;\n                    }\n                }\n\n                // Let's switch back again to the original db\n                context.setWikiId(sourceWiki);\n\n                if (wikilocale == null) {\n                    XWikiDocument tdoc = sdoc.copyDocument(targetDocumentReference, context);\n\n                    // Make sure to replace the existing document if any\n                    tdoc.setNew(true);\n\n                    // forget past versions\n                    if (reset) {\n                        tdoc.setVersion(\"1.1\");\n                    }\n                    if (resetCreationData) {\n                        Date now = new Date();\n                        tdoc.setCreationDate(now);\n                        tdoc.setContentUpdateDate(now);\n                        tdoc.setDate(now);\n                        tdoc.setCreatorReference(context.getUserReference());\n                        tdoc.setAuthorReference(context.getUserReference());\n                    }\n\n                    // We don't want to trigger a new version otherwise the version number will be wrong.\n                    tdoc.setMetaDataDirty(false);\n                    tdoc.setContentDirty(false);\n\n                    saveDocument(tdoc, \"Copied from \" + sourceStringReference, context);\n\n                    if (!reset) {\n                        context.setWikiId(sourceWiki);\n                        XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                        context.setWikiId(targetWiki);\n                        txda = txda.clone(tdoc.getId(), context);\n                        getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                    } else {\n                        context.setWikiId(targetWiki);\n                        getVersioningStore().resetRCSArchive(tdoc, true, context);\n                    }\n\n                    // Now we need to copy the translations\n                    context.setWikiId(sourceWiki);\n                    List<String> tlist = sdoc.getTranslationList(context);\n                    for (String clanguage : tlist) {\n                        XWikiDocument stdoc = sdoc.getTranslatedDocument(clanguage, context);\n                        LOGGER.info(\"Copying document [{}], language [{}] to [{}]\", sourceWiki, clanguage,\n                            targetDocumentReference);\n\n                        context.setWikiId(targetWiki);\n                        XWikiDocument ttdoc = tdoc.getTranslatedDocument(clanguage, context);\n\n                        // There is already an existing document\n                        if (ttdoc != tdoc) {\n                            return false;\n                        }\n\n                        // Let's switch back again to the original db\n                        context.setWikiId(sourceWiki);\n\n                        ttdoc = stdoc.copyDocument(targetDocumentReference, context);\n\n                        // Make sure to replace the existing document if any\n                        ttdoc.setNew(true);\n\n                        // forget past versions\n                        if (reset) {\n                            ttdoc.setNew(true);\n                            ttdoc.setVersion(\"1.1\");\n                        }\n                        if (resetCreationData) {\n                            Date now = new Date();\n                            ttdoc.setCreationDate(now);\n                            ttdoc.setContentUpdateDate(now);\n                            ttdoc.setDate(now);\n                            ttdoc.setCreatorReference(context.getUserReference());\n                            ttdoc.setAuthorReference(context.getUserReference());\n                        }\n\n                        // we don't want to trigger a new version\n                        // otherwise the version number will be wrong\n                        tdoc.setMetaDataDirty(false);\n                        tdoc.setContentDirty(false);\n\n                        saveDocument(ttdoc, \"Copied from \" + sourceStringReference, context);\n\n                        if (!reset) {\n                            context.setWikiId(sourceWiki);\n                            XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                            context.setWikiId(targetWiki);\n                            txda = txda.clone(tdoc.getId(), context);\n                            getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                        } else {\n                            getVersioningStore().resetRCSArchive(tdoc, true, context);\n                        }\n                    }\n                } else {\n                    // We want only one language in the end\n                    XWikiDocument stdoc = sdoc.getTranslatedDocument(wikilocale, context);\n\n                    XWikiDocument tdoc = stdoc.copyDocument(targetDocumentReference, context);\n\n                    // Make sure to replace the existing document if any\n                    tdoc.setNew(true);\n\n                    // forget language\n                    tdoc.setDefaultLanguage(wikilocale);\n                    tdoc.setLanguage(\"\");\n                    // forget past versions\n                    if (reset) {\n                        tdoc.setVersion(\"1.1\");\n                    }\n                    if (resetCreationData) {\n                        Date now = new Date();\n                        tdoc.setCreationDate(now);\n                        tdoc.setContentUpdateDate(now);\n                        tdoc.setDate(now);\n                        tdoc.setCreatorReference(context.getUserReference());\n                        tdoc.setAuthorReference(context.getUserReference());\n                    }\n\n                    // we don't want to trigger a new version\n                    // otherwise the version number will be wrong\n                    tdoc.setMetaDataDirty(false);\n                    tdoc.setContentDirty(false);\n\n                    saveDocument(tdoc, \"Copied from \" + sourceStringReference, context);\n\n                    if (!reset) {\n                        context.setWikiId(sourceWiki);\n                        XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                        context.setWikiId(targetWiki);\n                        txda = txda.clone(tdoc.getId(), context);\n                        getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                    } else {\n                        getVersioningStore().resetRCSArchive(tdoc, true, context);\n                    }\n                }\n            }\n            return true;\n        } finally {\n            context.setWikiId(db);\n        }\n    }\n\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale,\n        XWikiContext context) throws XWikiException\n    {\n        return copySpaceBetweenWikis(space, sourceWiki, targetWiki, locale, false, context);\n    }\n\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale, boolean clean,\n        XWikiContext context) throws XWikiException\n    {\n        String db = context.getWikiId();\n        int nb = 0;\n        // Workaround for XWIKI-3915: Do not use XWikiStoreInterface#searchDocumentNames since currently it has the\n        // side effect of hidding hidden documents and no other workaround exists than directly using\n        // XWikiStoreInterface#search directly\n        String sql = \"select distinct doc.fullName from XWikiDocument as doc\";\n        List<String> parameters = new ArrayList<>();\n        if (space != null) {\n            parameters.add(space);\n            sql += \" where doc.space = ?\" + parameters.size();\n        }\n\n        if (clean) {\n            try {\n                context.setWikiId(targetWiki);\n                List<String> list = getStore().search(sql, 0, 0, parameters, context);\n\n                LOGGER.info(\"Deleting [{}] documents from wiki [{}]\", list.size(), targetWiki);\n\n                for (String docname : list) {\n                    XWikiDocument doc = getDocument(docname, context);\n                    deleteDocument(doc, context);\n                }\n            } finally {\n                context.setWikiId(db);\n            }\n        }\n\n        try {\n            context.setWikiId(sourceWiki);\n            List<String> list = getStore().search(sql, 0, 0, parameters, context);\n\n            LOGGER.info(\"Copying [{}] documents from wiki [{}] to wiki [{}]\", list.size(), sourceWiki, targetWiki);\n\n            WikiReference sourceWikiReference = new WikiReference(sourceWiki);\n            WikiReference targetWikiReference = new WikiReference(targetWiki);\n            for (String docname : list) {\n                DocumentReference sourceDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n                sourceDocumentReference = sourceDocumentReference\n                    .replaceParent(sourceDocumentReference.getWikiReference(), sourceWikiReference);\n                DocumentReference targetDocumentReference =\n                    sourceDocumentReference.replaceParent(sourceWikiReference, targetWikiReference);\n                copyDocument(sourceDocumentReference, targetDocumentReference, locale, context);\n                nb++;\n            }\n            return nb;\n        } finally {\n            context.setWikiId(db);\n        }\n    }\n\n    /**\n     * Copy an entire wiki to a target wiki.\n     * <p>\n     * It does not override document already existing in target wiki.\n     *\n     * @param sourceWiki the source wiki identifier\n     * @param targetWiki the target wiki identifier\n     * @param locale the locale to copy\n     * @param context see {@link XWikiContext}\n     * @return the number of copied documents\n     * @throws XWikiException failed to copy wiki\n     * @deprecated since 5.3, use {@link WikiManager#copy(String, String, String, boolean, boolean, boolean)} instead\n     */\n    @Deprecated\n    public int copyWiki(String sourceWiki, String targetWiki, String locale, XWikiContext context) throws XWikiException\n    {\n        return copyWiki(sourceWiki, targetWiki, locale, false, context);\n    }\n\n    /**\n     * Copy an entire wiki to a target wiki.\n     *\n     * @param sourceWiki the source wiki identifier\n     * @param targetWiki the target wiki identifier\n     * @param locale the locale to copy\n     * @param clean clean the target wiki before copying\n     * @param context see {@link XWikiContext}\n     * @return the number of copied documents\n     * @throws XWikiException failed to copy wiki\n     * @deprecated since 5.3, use {@link WikiManager#copy(String, String, String, boolean, boolean, boolean)} instead\n     */\n    @Deprecated\n    public int copyWiki(String sourceWiki, String targetWiki, String locale, boolean clean, XWikiContext context)\n        throws XWikiException\n    {\n        int documents = copySpaceBetweenWikis(null, sourceWiki, targetWiki, locale, clean, context);\n\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            om.notify(new WikiCopiedEvent(sourceWiki, targetWiki), sourceWiki, context);\n        }\n\n        return documents;\n    }\n\n    public String getEncoding()\n    {\n        return getConfiguration().getProperty(\"xwiki.encoding\", \"UTF-8\");\n    }\n\n    public URL getServerURL(String wikiId, XWikiContext xcontext) throws MalformedURLException\n    {\n        // In path based the base URL is the same for all wikis\n        if (!xcontext.isMainWiki(wikiId) && isPathBased()) {\n            return getServerURL(xcontext.getMainXWiki(), xcontext);\n        }\n\n        // If main wiki check the main wiki home page configuration\n        if (xcontext.isMainWiki(wikiId)) {\n            String homepage = getConfiguration().getProperty(\"xwiki.home\");\n            if (StringUtils.isNotEmpty(homepage)) {\n                try {\n                    return new URL(homepage);\n                } catch (MalformedURLException e) {\n                    LOGGER.warn(\"Invalid main wiki home page URL [{}] configured: {}\", homepage,\n                        ExceptionUtils.getRootCauseMessage(e));\n                }\n            }\n        }\n\n        if (wikiId != null) {\n            try {\n                WikiDescriptor wikiDescriptor = getWikiDescriptorManager().getById(wikiId);\n                if (wikiDescriptor != null) {\n                    String server = wikiDescriptor.getDefaultAlias();\n                    if (server != null) {\n                        String protocol = getWikiProtocol(wikiDescriptor);\n                        int port = getWikiPort(wikiDescriptor, xcontext);\n\n                        if (protocol == null && port == -1) {\n                            // If request is a \"real\" one keep using the same protocol/port (if asking for the same wiki)\n                            XWikiRequest request = xcontext.getRequest();\n                            if (request != null && wikiDescriptor.getId().equals(xcontext.getOriginalWikiId())\n                                && !isDaemon(request)) {\n                                URL sourceURL = HttpServletUtils.getSourceBaseURL(xcontext.getRequest());\n\n                                protocol = sourceURL.getProtocol();\n                                port = sourceURL.getPort();\n                            } else {\n                                // Default to HTTP\n                                protocol = \"http\";\n                            }\n                        }\n\n                        return new URL(protocol != null ? protocol : (port == 443 ? \"https\" : \"http\"), server, port,\n                            \"\");\n                    }\n                }\n            } catch (WikiManagerException e) {\n                LOGGER.error(\"Failed to get descriptor for wiki [{}]\", wikiId, e);\n            }\n        }\n\n        return null;\n    }\n\n    private boolean isDaemon(XWikiRequest request)\n    {\n        return request.getHttpServletRequest() instanceof XWikiServletRequestStub\n            && ((XWikiServletRequestStub) request.getHttpServletRequest()).isDaemon();\n    }\n\n    private String getWikiProtocol(WikiDescriptor wikiDescriptor)\n    {\n        // Try wiki descriptor\n        Boolean secure = wikiDescriptor.isSecure();\n        if (secure != null) {\n            return wikiDescriptor.isSecure() == Boolean.TRUE ? \"https\" : \"http\";\n        }\n\n        // Try configuration\n        String protocol = getConfiguration().getProperty(\"xwiki.url.protocol\");\n        if (protocol != null) {\n            return protocol;\n        }\n\n        // Try main wiki\n        try {\n            secure = getWikiDescriptorManager().getMainWikiDescriptor().isSecure();\n\n            if (secure != null) {\n                return secure ? \"https\" : \"http\";\n            }\n        } catch (WikiManagerException e) {\n            LOGGER.error(\"Failed to get main wiki descriptor\", e);\n        }\n\n        return null;\n    }\n\n    private int getWikiPort(WikiDescriptor wikiDescriptor, XWikiContext context)\n    {\n        // Try wiki descriptor\n        int port = wikiDescriptor.getPort();\n        if (port != -1) {\n            return port;\n        }\n\n        // Try main wiki\n        try {\n            port = getWikiDescriptorManager().getMainWikiDescriptor().getPort();\n\n            if (port != -1) {\n                return port;\n            }\n        } catch (WikiManagerException e) {\n            LOGGER.error(\"Failed to get main wiki descriptor\", e);\n        }\n\n        return -1;\n    }\n\n    public String getServletPath(String wikiName, XWikiContext context)\n    {\n        // unless we are in virtual wiki path mode we should return null\n        if (!context.isMainWiki(wikiName) && isPathBased()) {\n            try {\n                WikiDescriptor wikiDescriptor = getWikiDescriptorManager().getById(wikiName);\n                if (wikiDescriptor != null) {\n                    return \"wiki/\" + wikiDescriptor.getDefaultAlias() + \"/\";\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to get URL for provided wiki [\" + wikiName + \"]\", e);\n            }\n        }\n\n        String servletPath = getConfiguration().getProperty(\"xwiki.servletpath\", \"\");\n\n        if (context.getRequest() != null) {\n            if (StringUtils.isEmpty(servletPath)) {\n                String currentServletpath = context.getRequest().getServletPath();\n                if (currentServletpath != null && currentServletpath.startsWith(\"/bin\")) {\n                    servletPath = \"bin/\";\n                } else {\n                    servletPath = getConfiguration().getProperty(\"xwiki.defaultservletpath\", \"bin/\");\n                }\n            }\n        }\n\n        return servletPath;\n    }\n\n    public String getWebAppPath(XWikiContext context)\n    {\n        String contextPath = getConfiguration().getProperty(\"xwiki.webapppath\");\n        if (contextPath == null) {\n            // Try getting the context path by asking the request for it (if a request exists!) and if it doesn't\n            // work try extracting it from the context URL.\n            // TODO: Instead of trying to extract from the URL, save the context path at webapp init (using a\n            // ServlettContextListener for example).\n            XWikiRequest request = context.getRequest();\n            if (request != null) {\n                contextPath = request.getContextPath();\n            }\n            if (contextPath == null) {\n                // Extract the context by getting the first path segment\n                contextPath = StringUtils.substringBefore(StringUtils.stripStart(context.getURL().getPath(), \"/\"), \"/\");\n            }\n        }\n\n        // Remove any leading or trailing slashes\n        contextPath = StringUtils.strip(contextPath, \"/\");\n\n        // TODO We're using URL parts in a wrong way, since contextPath and servletPath are returned with a leading /,\n        // while we need a trailing /. This code ensure we always have CONTEXTNAME + \"/\".\n        return contextPath + \"/\";\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference entityReference, String action, String queryString, String anchor,\n        XWikiContext context)\n    {\n        // TODO: replace this API with a clean implementation of EntityResourceReferenceSerializer\n\n        // Handle attachment URL\n        if (EntityType.ATTACHMENT.equals(entityReference.getType())) {\n            // Get the full attachment reference\n            AttachmentReference attachmentReference = getCurrentAttachmentResolver().resolve(entityReference);\n            return getAttachmentURL(attachmentReference, action, queryString, context);\n        }\n\n        // For all other types, we return the URL of the default corresponding document.\n        DocumentReference documentReference = getDocumentReference(entityReference, context);\n        return getURL(documentReference, action, queryString, anchor, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference, String action, XWikiContext context)\n    {\n        return getURL(reference, action, null, null, context);\n    }\n\n    /**\n     * @since 7.2RC1\n     */\n    public String getURL(EntityReference reference, XWikiContext context)\n    {\n        String action = \"view\";\n        if (reference.getType() == EntityType.ATTACHMENT) {\n            action = \"download\";\n        }\n        return getURL(reference, action, context);\n    }\n\n    /**\n     * @since 2.2.1\n     */\n    public String getURL(DocumentReference documentReference, String action, String queryString, String anchor,\n        XWikiContext context)\n    {\n        // We need to serialize the space reference because the old createURL() API doesn't accept a DocumentReference.\n        String spaces = getLocalStringEntityReferenceSerializer().serialize(documentReference.getLastSpaceReference());\n\n        // Take into account the specified document locale.\n        Locale documentLocale = documentReference.getLocale();\n        String actualQueryString = queryString;\n        if (documentLocale != null && documentLocale != Locale.ROOT) {\n            String localeQueryString = \"language=\" + documentLocale;\n            if (StringUtils.isEmpty(queryString)) {\n                actualQueryString = localeQueryString;\n            } else {\n                // Note: if the locale is already specified on the given query string then it won't be overwriten\n                // because the first parameter value is taken into account.\n                actualQueryString += '&' + localeQueryString;\n            }\n        }\n\n        URL url = context.getURLFactory().createURL(spaces, documentReference.getName(), action, actualQueryString,\n            anchor, documentReference.getWikiReference().getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    /**\n     * @deprecated since 2.2.1 use {@link #getURL(DocumentReference, String, String, String, XWikiContext)}\n     */\n    @Deprecated\n    public String getURL(String fullname, String action, String queryString, String anchor, XWikiContext context)\n    {\n        return getURL(getCurrentMixedDocumentReferenceResolver().resolve(fullname), action, queryString, anchor,\n            context);\n    }\n\n    public String getURL(String fullname, String action, String querystring, XWikiContext context)\n    {\n        return getURL(fullname, action, querystring, null, context);\n    }\n\n    /**\n     * @since 2.3M2\n     */\n    public String getURL(DocumentReference reference, String action, XWikiContext context)\n    {\n        return getURL(reference, action, null, null, context);\n    }\n\n    /**\n     * @deprecated since 2.3M2 use {@link #getURL(DocumentReference, String, XWikiContext)}\n     */\n    @Deprecated\n    public String getURL(String fullname, String action, XWikiContext context)\n    {\n        return getURL(fullname, action, null, null, context);\n    }\n\n    public String getExternalURL(String fullname, String action, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, null, null,\n            doc.getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getExternalURL(String fullname, String action, String querystring, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, querystring, null,\n            doc.getDatabase(), context);\n        return url.toString();\n    }\n\n    /**\n     * Get the full URL of the given {@link DocumentReference}. This also includes the server name of the wiki.\n     *\n     * @param documentReference the document that should be resolved\n     * @param action the action of the URL\n     * @param querystring the URL parameters\n     * @param anchor the anchor of the document\n     * @param context the current XWikiContext\n     * @return the full URL of the given reference\n     * @since 9.6RC1\n     */\n    public String getExternalURL(DocumentReference documentReference, String action, String querystring, String anchor,\n        XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(\n            this.getLocalStringEntityReferenceSerializer().serialize(documentReference.getLastSpaceReference()),\n            documentReference.getName(), action, querystring, anchor, documentReference.getWikiReference().getName(),\n            context);\n        return url.toString();\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentURL(AttachmentReference attachmentReference, String action, String queryString,\n        XWikiContext context)\n    {\n        DocumentReference documentReference = attachmentReference.getDocumentReference();\n        SpaceReference spaceReference = documentReference.getLastSpaceReference();\n        WikiReference wikiReference = spaceReference.getWikiReference();\n\n        // We need to serialize the space reference because the old URLFactory has no method to create an Attachment URL\n        // from an AttachmentReference...\n        String serializedSpace = getLocalStringEntityReferenceSerializer().serialize(spaceReference);\n\n        URL url = context.getURLFactory().createAttachmentURL(attachmentReference.getName(), serializedSpace,\n            documentReference.getName(), action, queryString, wikiReference.getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentURL(AttachmentReference attachmentReference, String queryString, XWikiContext context)\n    {\n        return getAttachmentURL(attachmentReference, \"download\", queryString, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentRevisionURL(AttachmentReference attachmentReference, String revision, String queryString,\n        XWikiContext context)\n    {\n        DocumentReference documentReference = attachmentReference.getDocumentReference();\n        SpaceReference spaceReference = documentReference.getLastSpaceReference();\n        WikiReference wikiReference = spaceReference.getWikiReference();\n\n        // We need to serialize the space reference because the old URLFactory has no method to create an Attachment URL\n        // from an AttachmentReference...\n        String serializedSpace = getLocalStringEntityReferenceSerializer().serialize(spaceReference);\n\n        URL url = context.getURLFactory().createAttachmentRevisionURL(attachmentReference.getName(), serializedSpace,\n            documentReference.getName(), revision, queryString, wikiReference.getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getAttachmentURL(String fullname, String filename, XWikiContext context) throws XWikiException\n    {\n        return getAttachmentURL(fullname, filename, null, context);\n    }\n\n    /**\n     * @since 2.5RC1\n     */\n    public String getAttachmentURL(String fullname, String filename, String queryString, XWikiContext context)\n        throws XWikiException\n    {\n        AttachmentReference attachmentReference =\n            new AttachmentReference(filename, getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        return getAttachmentURL(attachmentReference, queryString, context);\n    }\n\n    // Usefull date functions\n\n    public int getTimeDelta(long time)\n    {\n        Date ctime = new Date();\n        return (int) (ctime.getTime() - time);\n    }\n\n    public boolean isMultiLingual(XWikiContext context)\n    {\n        return \"1\".equals(getXWikiPreference(\"multilingual\", \"0\", context));\n    }\n\n    public boolean isLDAP()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.ldap\"));\n    }\n\n    /**\n     * @return true if XWikiAllGroup group should be seen as virtual group containing all users, false to use it as any\n     *         other group\n     * @since 9.3RC1\n     */\n    public boolean isAllGroupImplicit()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.group.allgroupimplicit\"));\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link XWikiUser#isDisabled(XWikiContext)}.\n     */\n    @Deprecated\n    public int checkActive(XWikiContext context) throws XWikiException\n    {\n        return checkActive(context.getUser(), context);\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link XWikiUser#isDisabled(XWikiContext)}.\n     */\n    @Deprecated\n    public int checkActive(String user, XWikiContext context) throws XWikiException\n    {\n        XWikiUser xWikiUser = new XWikiUser(user);\n        return xWikiUser.isDisabled(context) ? 0 : 1;\n    }\n\n    /**\n     * @since 2.3M1\n     */\n    public DocumentReference getDocumentReference(XWikiRequest request, XWikiContext context)\n    {\n        DocumentReference reference;\n        if (context.getMode() == XWikiContext.MODE_PORTLET) {\n            if (request.getParameter(\"topic\") != null) {\n                reference = getCurrentMixedDocumentReferenceResolver().resolve(request.getParameter(\"topic\"));\n            } else {\n                // Point to this wiki's home page\n                reference = getDefaultDocumentReference().setWikiReference(new WikiReference(context.getWikiId()));\n            }\n        } else if (context.getMode() == XWikiContext.MODE_XMLRPC) {\n            reference = new DocumentReference(context.getWikiId(),\n                context.getDoc().getDocumentReference().getLastSpaceReference().getName(),\n                context.getDoc().getDocumentReference().getName());\n        } else {\n            ResourceReference resourceReference = getResourceReferenceManager().getResourceReference();\n            if (resourceReference instanceof EntityResourceReference) {\n                EntityResourceReference entityResource = (EntityResourceReference) resourceReference;\n                String action = entityResource.getAction().getActionName();\n                if ((request.getParameter(\"topic\") != null) && (action.equals(\"edit\") || action.equals(\"inline\"))) {\n                    reference = getCurrentMixedDocumentReferenceResolver().resolve(request.getParameter(\"topic\"));\n                } else {\n                    reference = new DocumentReference(\n                        entityResource.getEntityReference().extractReference(EntityType.DOCUMENT));\n                }\n            } else {\n                // TODO: Handle references not pointing to a document...\n                // Big problem we don't have an Entity URL!\n                throw new RuntimeException(\n                    String.format(\"Resource Reference [%s] isn't an Entity Resource Reference!\", resourceReference));\n            }\n        }\n\n        return reference;\n    }\n\n    /**\n     * Helper method, removes a predefined path segment (the context path or the servel path) from the start of the\n     * requested URI and returns the remainder. This method is needed because special characters in the path can be\n     * URL-encoded, depending on whether the request is forwarded through the request dispatcher or not, and also\n     * depending on the client (some browsers encode -, while some don't).\n     *\n     * @param path the path, as taken from the requested URI\n     * @param segment the segment to remove, as reported by the container\n     * @return the path with the specified segment trimmed from its start\n     */\n    public static String stripSegmentFromPath(String path, String segment)\n    {\n        if (!path.startsWith(segment)) {\n            // The context path probably contains special characters that are encoded in the URL\n            try {\n                segment = URIUtil.encodePath(segment);\n            } catch (URIException e) {\n                LOGGER.warn(\"Invalid path: [\" + segment + \"]\");\n            }\n        }\n        if (!path.startsWith(segment)) {\n            // Some clients also encode -, although it's allowed in the path\n            segment = segment.replaceAll(\"-\", \"%2D\");\n        }\n        if (!path.startsWith(segment)) {\n            // Can't find the context path in the URL (shouldn't happen), just skip to the next path segment\n            return path.substring(path.indexOf('/', 1));\n        }\n        return path.substring(segment.length());\n    }\n\n    public boolean prepareDocuments(XWikiRequest request, XWikiContext context, VelocityContext vcontext)\n        throws XWikiException\n    {\n        XWikiDocument doc;\n        context.getWiki().prepareResources(context);\n        DocumentReference reference = getDocumentReference(request, context);\n        if (context.getAction().equals(\"register\")) {\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n        } else {\n            try {\n                doc = getDocument(reference, context);\n            } catch (XWikiException e) {\n                doc = context.getDoc();\n                if (context.getAction().equals(\"delete\")) {\n                    if (doc == null) {\n                        setPhonyDocument(reference, context, vcontext);\n                        doc = context.getDoc();\n                    }\n                    if (!checkAccess(\"admin\", doc, context)) {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // the user is set after the access is checked.\n        boolean hasAccess = checkAccess(context.getAction(), doc, context);\n\n        XWikiUser user;\n        if (context.getUserReference() != null) {\n            user = new XWikiUser(context.getUserReference());\n        } else {\n            user = new XWikiUser(context.getUser());\n        }\n\n        // We need to check rights before we look for translations\n        // Otherwise we don't have the user language\n        if (!hasAccess) {\n            Object[] args = { doc.getFullName(), user.getUser() };\n            setPhonyDocument(reference, context, vcontext);\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access to document {0} has been denied to user {1}\", null, args);\n        // User is disabled: the mail address is marked as checked\n        } else if (user.isDisabled(context) && user.isEmailChecked(context)) {\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if (!((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\"))))) {\n                Object[] args = { user.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_DISABLED,\n                    \"User {0} account is disabled\", null, args);\n            }\n        // User actually needs to activate his mail address.\n        } else if (user.isDisabled(context) && !user.isEmailChecked(context)) {\n            boolean allow = false;\n            String action = context.getAction();\n            /*\n             * Allow inactive users to see skins, ressources, SSX, JSX and downloads they could have seen as guest. The\n             * rational behind this behaviour is that inactive users should be able to access the same UI that guests\n             * are used to see, including custom icons, panels, and so on...\n             */\n            if ((action.equals(\"skin\") && (doc.getSpace().equals(\"skins\") || doc.getSpace().equals(\"resources\")))\n                || ((action.equals(\"skin\") || action.equals(\"download\") || action.equals(\"ssx\") || action.equals(\"jsx\"))\n                    && getRightService().hasAccessLevel(\"view\", XWikiRightService.GUEST_USER_FULLNAME,\n                        doc.getPrefixedFullName(), context))\n                || ((action.equals(\"view\") && doc.getFullName().equals(\"XWiki.AccountValidation\")))) {\n                allow = true;\n            } else {\n                String allowed = getConfiguration().getProperty(\"xwiki.inactiveuser.allowedpages\", \"\");\n                if (context.getAction().equals(\"view\") && !allowed.equals(\"\")) {\n                    String[] allowedList = StringUtils.split(allowed, \" ,\");\n                    for (String element : allowedList) {\n                        if (element.equals(doc.getFullName())) {\n                            allow = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (!allow) {\n                Object[] args = { context.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_INACTIVE,\n                    \"User {0} account is inactive\", null, args);\n            }\n        }\n\n        if (!\"skin\".equals(context.getAction())\n            && !getAuthorizationManager().hasAccess(Right.VIEW, context.getUserReference(), reference)) {\n            // If for some reason (e.g., login action) the user has rights for the action but no view right on the\n            // document, do not load the document into the context.\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n            context.put(\"tdoc\", doc);\n            context.put(\"cdoc\", doc);\n        } else {\n            context.put(\"doc\", doc);\n            context.put(\"cdoc\", doc);\n            vcontext.put(\"doc\", doc.newDocument(context));\n            vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n            XWikiDocument tdoc;\n\n            // If the parameter language exists and is empty, it means we want to force loading the regular document\n            // not a translation. This should be handled later by doing a better separation between locale used in the UI\n            // and for loading the documents.\n            if (\"\".equals(context.getRequest().getParameter(\"language\"))) {\n                tdoc = doc;\n            } else {\n                tdoc = doc.getTranslatedDocument(context);\n            }\n\n            try {\n                String rev = (String) context.get(\"rev\");\n                if (StringUtils.isNotEmpty(rev)) {\n                    tdoc = getDocument(tdoc, rev, context);\n                }\n            } catch (Exception ex) {\n                // Invalid version, just use the most recent one\n            }\n            context.put(\"tdoc\", tdoc);\n            vcontext.put(\"tdoc\", tdoc.newDocument(context));\n        }\n\n        return true;\n    }\n\n    /**\n     * @since 8.3M1\n     */\n    public void setPhonyDocument(DocumentReference reference, XWikiContext context)\n    {\n        XWikiDocument doc = new XWikiDocument(reference);\n        doc.setElements(XWikiDocument.HAS_ATTACHMENTS | XWikiDocument.HAS_OBJECTS);\n        doc.setStore(getStore());\n        context.put(\"doc\", doc);\n    }\n\n    /**\n     * @since 2.3M1\n     * @deprecated since 8.3M1, use {@link #setPhonyDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public void setPhonyDocument(DocumentReference reference, XWikiContext context, VelocityContext vcontext)\n    {\n        setPhonyDocument(reference, context);\n\n        vcontext.put(\"doc\", context.getDoc().newDocument(context));\n        vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n        vcontext.put(\"tdoc\", vcontext.get(\"doc\"));\n    }\n\n    /**\n     * @deprecated since 2.3M1 use {@link #setPhonyDocument(DocumentReference, XWikiContext, VelocityContext)}\n     */\n    @Deprecated\n    public void setPhonyDocument(String docName, XWikiContext context, VelocityContext vcontext)\n    {\n        setPhonyDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName), context, vcontext);\n    }\n\n    public XWikiEngineContext getEngineContext()\n    {\n        return this.engine_context;\n    }\n\n    public void setEngineContext(XWikiEngineContext engine_context)\n    {\n        this.engine_context = engine_context;\n    }\n\n    public void setAuthService(XWikiAuthService authService)\n    {\n        this.authService = authService;\n    }\n\n    public void setRightService(XWikiRightService rightService)\n    {\n        this.rightService = rightService;\n    }\n\n    public XWikiGroupService getGroupService(XWikiContext context) throws XWikiException\n    {\n        synchronized (this.GROUP_SERVICE_LOCK) {\n            if (this.groupService == null) {\n                String groupClass = getConfiguration().getProperty(\"xwiki.authentication.groupclass\",\n                    \"com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl\");\n\n                try {\n                    this.groupService = (XWikiGroupService) Class.forName(groupClass).newInstance();\n                } catch (Exception e) {\n                    LOGGER.error(\"Failed to instantiate custom group service class: \" + e.getMessage(), e);\n                    this.groupService = new XWikiGroupServiceImpl();\n                }\n                this.groupService.init(this, context);\n            }\n\n            return this.groupService;\n        }\n    }\n\n    public void setGroupService(XWikiGroupService groupService)\n    {\n        this.groupService = groupService;\n    }\n\n    private Class<? extends XWikiAuthService> getAuthServiceClass() throws ClassNotFoundException\n    {\n        String authClass = getConfiguration().getProperty(\"xwiki.authentication.authclass\");\n        if (StringUtils.isEmpty(authClass)) {\n            if (isLDAP()) {\n                authClass = \"com.xpn.xwiki.user.impl.LDAP.XWikiLDAPAuthServiceImpl\";\n            } else {\n                authClass = \"com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl\";\n            }\n        }\n\n        // Get main wiki ClassLoader\n        ClassLoaderManager clManager = Utils.getComponent(ClassLoaderManager.class);\n        ClassLoader classloader = null;\n        if (clManager != null) {\n            classloader = clManager.getURLClassLoader(\"wiki:xwiki\", false);\n        }\n\n        // Get the class\n        if (classloader != null) {\n            return (Class<? extends XWikiAuthService>) Class.forName(authClass, true, classloader);\n        } else {\n            return (Class<? extends XWikiAuthService>) Class.forName(authClass);\n        }\n    }\n\n    public XWikiAuthService getAuthService()\n    {\n        synchronized (this.AUTH_SERVICE_LOCK) {\n            if (this.authService == null) {\n                LOGGER.info(\"Initializing AuthService...\");\n\n                try {\n                    Class<? extends XWikiAuthService> authClass = getAuthServiceClass();\n\n                    setAuthService(authClass);\n                } catch (Exception e) {\n                    LOGGER.warn(\"Failed to get the configured AuthService class, fallbacking on standard authenticator\",\n                        e);\n\n                    this.authService = new XWikiAuthServiceImpl();\n\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Initialized AuthService {} using 'new'.\", this.authService.getClass().getName());\n                    }\n                }\n            }\n\n            return this.authService;\n        }\n    }\n\n    private void setAuthService(Class<? extends XWikiAuthService> authClass)\n    {\n        try {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Using AuthClass {}\", authClass.getName());\n            }\n\n            this.authService = authClass.newInstance();\n\n            LOGGER.debug(\"Initialized AuthService using Reflection.\");\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to initialize the AuthService from class [{}], fallbacking on standard authenticator\",\n                authClass.getName(), e);\n\n            this.authService = new XWikiAuthServiceImpl();\n\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Initialized AuthService {} using 'new'.\", this.authService.getClass().getName());\n            }\n        }\n    }\n\n    private static final String DEFAULT_RIGHT_SERVICE_CLASS =\n        \"org.xwiki.security.authorization.internal.XWikiCachingRightService\";\n\n    public XWikiRightService getRightService()\n    {\n        synchronized (this.RIGHT_SERVICE_LOCK) {\n            if (this.rightService == null) {\n                LOGGER.info(\"Initializing RightService...\");\n\n                String rightsClass = getConfiguration().getProperty(\"xwiki.authentication.rightsclass\");\n                if (rightsClass != null && !rightsClass.equals(DEFAULT_RIGHT_SERVICE_CLASS)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.warn(\"Using custom Right Service [{}].\", rightsClass);\n                    }\n                } else {\n                    rightsClass = DEFAULT_RIGHT_SERVICE_CLASS;\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Using default Right Service [{}].\", rightsClass);\n                    }\n                }\n\n                try {\n                    this.rightService = (XWikiRightService) Class.forName(rightsClass).newInstance();\n                    LOGGER.debug(\"Initialized RightService using Reflection.\");\n                } catch (Exception e) {\n                    Exception lastException = e;\n\n                    if (!rightsClass.equals(DEFAULT_RIGHT_SERVICE_CLASS)) {\n                        LOGGER.warn(String.format(\n                            \"Failed to initialize custom RightService [%s]\"\n                                + \" by Reflection, using default implementation [%s].\",\n                            rightsClass, DEFAULT_RIGHT_SERVICE_CLASS), e);\n                        rightsClass = DEFAULT_RIGHT_SERVICE_CLASS;\n                        try {\n                            this.rightService = (XWikiRightService) Class.forName(rightsClass).newInstance();\n                            LOGGER.debug(\"Initialized default RightService using Reflection.\");\n                        } catch (Exception e1) {\n                            lastException = e1;\n                        }\n                    }\n\n                    if (this.rightService == null) {\n                        LOGGER.warn(String.format(\n                            \"Failed to initialize RightService [%s]\"\n                                + \" by Reflection, using OLD implementation [%s] with 'new'.\",\n                            rightsClass, XWikiRightServiceImpl.class.getCanonicalName()), lastException);\n\n                        this.rightService = new XWikiRightServiceImpl();\n\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Initialized old RightService implementation \"\n                                + this.rightService.getClass().getName() + \" using 'new'.\");\n                        }\n                    }\n                }\n            }\n            return this.rightService;\n        }\n    }\n\n    public XWikiStatsService getStatsService(XWikiContext context)\n    {\n        synchronized (this.STATS_SERVICE_LOCK) {\n            if (this.statsService == null) {\n                if (\"1\".equals(getConfiguration().getProperty(\"xwiki.stats\", \"1\"))) {\n                    String storeClass = getConfiguration().getProperty(\"xwiki.stats.class\",\n                        \"com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl\");\n                    try {\n                        this.statsService = (XWikiStatsService) Class.forName(storeClass).newInstance();\n                    } catch (Exception e) {\n                        LOGGER.error(e.getMessage(), e);\n\n                        this.statsService = new XWikiStatsServiceImpl();\n                    }\n\n                    this.statsService.init(context);\n                }\n            }\n\n            return this.statsService;\n        }\n    }\n\n    public XWikiURLFactoryService getURLFactoryService()\n    {\n        if (this.urlFactoryService == null) {\n            synchronized (this.URLFACTORY_SERVICE_LOCK) {\n                if (this.urlFactoryService == null) {\n                    LOGGER.info(\"Initializing URLFactory Service...\");\n\n                    XWikiURLFactoryService factoryService = null;\n\n                    String urlFactoryServiceClass = getConfiguration().getProperty(\"xwiki.urlfactory.serviceclass\");\n                    if (urlFactoryServiceClass != null) {\n                        try {\n                            if (LOGGER.isDebugEnabled()) {\n                                LOGGER.debug(\"Using custom URLFactory Service Class [\" + urlFactoryServiceClass + \"]\");\n                            }\n                            factoryService = (XWikiURLFactoryService) Class.forName(urlFactoryServiceClass)\n                                .getConstructor(new Class<?>[] { XWiki.class }).newInstance(new Object[] { this });\n                        } catch (Exception e) {\n                            factoryService = null;\n                            LOGGER.warn(\"Failed to initialize URLFactory Service [\" + urlFactoryServiceClass + \"]\", e);\n                        }\n                    }\n                    if (factoryService == null) {\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Using default URLFactory Service Class [\" + urlFactoryServiceClass + \"]\");\n                        }\n                        factoryService = new XWikiURLFactoryServiceImpl(this);\n                    }\n\n                    // Set the urlFactoryService object in one assignment to prevent threading\n                    // issues when checking for\n                    // null above.\n                    this.urlFactoryService = factoryService;\n                }\n            }\n        }\n\n        return this.urlFactoryService;\n    }\n\n    public XWikiCriteriaService getCriteriaService(XWikiContext context)\n    {\n        return this.criteriaService;\n    }\n\n    public ZipOutputStream getZipOutputStream(XWikiContext context) throws IOException\n    {\n        return new ZipOutputStream(context.getResponse().getOutputStream());\n    }\n\n    private Map<String, SearchEngineRule> getSearchEngineRules(XWikiContext context)\n    {\n        // We currently hardcode the rules\n        // We will put them in the preferences soon\n        Map<String, SearchEngineRule> map = new HashMap<String, SearchEngineRule>();\n        map.put(\"Google\", new SearchEngineRule(\"google.\", \"s/(^|.*&)q=(.*?)(&.*|$)/$2/\"));\n        map.put(\"MSN\", new SearchEngineRule(\"search.msn.\", \"s/(^|.*&)q=(.*?)(&.*|$)/$2/\"));\n        map.put(\"Yahoo\", new SearchEngineRule(\"search.yahoo.\", \"s/(^|.*&)p=(.*?)(&.*|$)/$2/\"));\n        map.put(\"Voila\", new SearchEngineRule(\"voila.fr\", \"s/(^|.*&)kw=(.*?)(&.*|$)/$2/\"));\n\n        return map;\n    }\n\n    public String getRefererText(String referer, XWikiContext context)\n    {\n        try {\n            URL url = new URL(referer);\n            Map<String, SearchEngineRule> searchengines = getSearchEngineRules(context);\n            if (searchengines != null) {\n                for (SearchEngineRule senginerule : searchengines.values()) {\n                    String host = url.getHost();\n                    int i1 = host.indexOf(senginerule.getHost());\n                    if (i1 != -1) {\n                        String query = context.getUtil().substitute(senginerule.getRegEx(), url.getQuery());\n                        if ((query != null) && (!query.equals(\"\"))) {\n                            // We return the query text instead of the full referer\n                            return host.substring(i1) + \":\" + query;\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        String result = referer.substring(referer.indexOf(\"://\") + 3);\n        if (result.endsWith(\"/\")) {\n            return result.substring(0, result.length() - 1);\n        } else {\n            return result;\n        }\n    }\n\n    public boolean isMySQL()\n    {\n        if (getHibernateStore() == null) {\n            return false;\n        }\n\n        Object dialect = getHibernateStore().getConfiguration().getProperties().get(\"dialect\");\n        return \"org.hibernate.dialect.MySQLDialect\".equals(dialect)\n            || \"net.sf.hibernate.dialect.MySQLDialect\".equals(dialect);\n    }\n\n    public String getFullNameSQL()\n    {\n        return getFullNameSQL(true);\n    }\n\n    public String getFullNameSQL(boolean newFullName)\n    {\n        if (newFullName) {\n            return \"doc.fullName\";\n        }\n\n        if (this.fullNameSQL == null) {\n            if (isMySQL()) {\n                this.fullNameSQL = \"CONCAT(doc.space,'.',doc.name)\";\n            } else {\n                this.fullNameSQL = \"doc.space||'.'||doc.name\";\n            }\n        }\n\n        return this.fullNameSQL;\n    }\n\n    public String getUserName(String user, XWikiContext context)\n    {\n        return getUserName(user, null, true, context);\n    }\n\n    public String getUserName(String user, String format, XWikiContext context)\n    {\n        return getUserName(user, format, true, context);\n    }\n\n    /**\n     * @return a formatted and pretty printed user name for displaying\n     */\n    public String getUserName(String user, String format, boolean link, XWikiContext context)\n    {\n        if (StringUtils.isBlank(user)) {\n            return localizePlainOrKey(\"core.users.unknownUser\");\n        }\n\n        DocumentReference userReference = getCurrentMixedDocumentReferenceResolver().resolve(user);\n\n        return getUserName(userReference, format, link, true, context);\n    }\n\n    /**\n     * Generate a display user name and return it.\n     *\n     * @param userReference\n     * @param format a Velocity scnippet used to format the user name\n     * @param link true if a full html link snippet should be returned\n     * @param escapeXML true if the returned name should be escaped (forced true if {@code link} is true)\n     * @param context see {@link XWikiContext}\n     * @return the display user name or a html snippet with the link to the passed user\n     * @since 6.4RC1\n     */\n    public String getUserName(DocumentReference userReference, String format, boolean link, boolean escapeXML,\n        XWikiContext context)\n    {\n        if (userReference == null) {\n            return localizePlainOrKey(\"core.users.unknownUser\");\n        }\n\n        XWikiDocument userdoc = null;\n        try {\n            userdoc = getDocument(userReference, context);\n            if (userdoc == null) {\n                return escapeXML ? XMLUtils.escape(userReference.getName()) : userReference.getName();\n            }\n\n            BaseObject userobj = userdoc.getObject(\"XWiki.XWikiUsers\");\n            if (userobj == null) {\n                return escapeXML ? XMLUtils.escape(userdoc.getDocumentReference().getName())\n                    : userdoc.getDocumentReference().getName();\n            }\n\n            String text;\n\n            if (format == null) {\n                text = userobj.getStringValue(\"first_name\");\n                String lastName = userobj.getStringValue(\"last_name\");\n                if (!text.isEmpty() && !lastName.isEmpty()) {\n                    text += ' ';\n                }\n                text += userobj.getStringValue(\"last_name\");\n                if (StringUtils.isBlank(text)) {\n                    text = userdoc.getDocumentReference().getName();\n                }\n            } else {\n                VelocityContext vcontext;\n                try {\n                    vcontext = getVelocityContextFactory().createContext();\n                } catch (XWikiVelocityException e) {\n                    LOGGER.error(\"Failed to create standard VelocityContext\", e);\n\n                    vcontext = new XWikiVelocityContext();\n                }\n\n                for (String propname : userobj.getPropertyList()) {\n                    vcontext.put(propname, userobj.getStringValue(propname));\n                }\n                text = evaluateVelocity(format,\n                    \"<username formatting code in \" + context.getDoc().getDocumentReference() + \">\", vcontext);\n            }\n\n            if (escapeXML || link) {\n                text = XMLUtils.escape(text.trim());\n            }\n\n            if (link) {\n                text = \"<span class=\\\"wikilink\\\"><a href=\\\"\" + userdoc.getURL(\"view\", context) + \"\\\">\" + text\n                    + \"</a></span>\";\n            }\n            return text;\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to display the user name of [{}]. Root cause is [{}]. Falling back on the user id.\",\n                userReference, ExceptionUtils.getRootCauseMessage(e));\n\n            return escapeXML ? XMLUtils.escape(userReference.getName()) : userReference.getName();\n        }\n    }\n\n    /**\n     * @param content the Velocity content to evaluate\n     * @param namespace the namespace under which to evaluate it (used for isolation)\n     * @param vcontext the Velocity context to use when evaluating. If {@code null}, then a new context will be created,\n     *            initialized and used.\n     * @return the evaluated content\n     * @since 7.2M1\n     */\n    public String evaluateVelocity(String content, String namespace, VelocityContext vcontext)\n    {\n        try {\n            return getVelocityEvaluator().evaluateVelocity(content, namespace, vcontext);\n        } catch (XWikiException xe) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}] with content:\\n[{}]\", namespace, content,\n                xe.getCause());\n            return Util.getHTMLExceptionMessage(xe, null);\n        }\n    }\n\n    /**\n     * @param content the Velocity content to evaluate\n     * @param name the namespace under which to evaluate it (used for isolation)\n     * @return the evaluated content\n     * @since 7.2M1\n     */\n    public String evaluateVelocity(String content, String name)\n    {\n        try {\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            VelocityContext velocityContext = velocityManager.getVelocityContext();\n            return evaluateVelocity(content, name, velocityContext);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}] with content:\\n[{}]\", name, content, e);\n            Object[] args = { name };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while parsing velocity page {0}\", e,\n                args);\n            return Util.getHTMLExceptionMessage(xe, null);\n        }\n    }\n\n    /**\n     * Generate and return an unescaped user display name.\n     *\n     * @param userReference the user reference\n     * @param context see {@link XWikiContext}\n     * @return the unescaped display user name\n     * @since 6.4RC1\n     */\n    public String getPlainUserName(DocumentReference userReference, XWikiContext context)\n    {\n        return getUserName(userReference, null, false, false, context);\n    }\n\n    public boolean hasCentralizedAuthentication(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"authentication_centralized\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.centralized\", \"0\"));\n    }\n\n    public String getLocalUserName(String user, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, null, true, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), null, true, context);\n        }\n    }\n\n    public String getLocalUserName(String user, String format, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, format, true, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), format, true, context);\n        }\n    }\n\n    public String getLocalUserName(String user, String format, boolean link, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, format, link, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), format, link, context);\n        }\n    }\n\n    public String formatDate(Date date, String format, XWikiContext context)\n    {\n        if (date == null) {\n            return \"\";\n        }\n        String xformat = format;\n        String defaultFormat = \"yyyy/MM/dd HH:mm\";\n\n        if (format == null) {\n            xformat = getXWikiPreference(\"dateformat\", defaultFormat, context);\n        }\n\n        try {\n            DateFormatSymbols formatSymbols = null;\n            try {\n                String language = getLanguagePreference(context);\n                formatSymbols = new DateFormatSymbols(new Locale(language));\n            } catch (Exception e2) {\n                String language = getXWikiPreference(\"default_language\", context);\n                if ((language != null) && (!language.equals(\"\"))) {\n                    formatSymbols = new DateFormatSymbols(new Locale(language));\n                }\n            }\n\n            SimpleDateFormat sdf;\n            if (formatSymbols != null) {\n                sdf = new SimpleDateFormat(xformat, formatSymbols);\n            } else {\n                sdf = new SimpleDateFormat(xformat);\n            }\n\n            try {\n                sdf.setTimeZone(TimeZone.getTimeZone(getUserTimeZone(context)));\n            } catch (Exception e) {\n            }\n\n            return sdf.format(date);\n        } catch (Exception e) {\n            LOGGER.info(\"Failed to format date [\" + date + \"] with pattern [\" + xformat + \"]: \" + e.getMessage());\n            if (format == null) {\n                if (xformat.equals(defaultFormat)) {\n                    return date.toString();\n                } else {\n                    return formatDate(date, defaultFormat, context);\n                }\n            } else {\n                return formatDate(date, null, context);\n            }\n        }\n    }\n\n    /*\n     * Allow to read user setting providing the user timezone All dates will be expressed with this timezone\n     */\n    public String getUserTimeZone(XWikiContext context)\n    {\n        String tz = getUserPreference(\"timezone\", context);\n        // We perform this verification ourselves since TimeZone#getTimeZone(String) with an invalid parameter returns\n        // GMT and not the system default.\n        if (!ArrayUtils.contains(TimeZone.getAvailableIDs(), tz)) {\n            String defaultTz = TimeZone.getDefault().getID();\n            return getConfiguration().getProperty(\"xwiki.timezone\", defaultTz);\n        } else {\n            return tz;\n        }\n    }\n\n    /**\n     * @deprecated since 2.2.1 use {@link #exists(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public boolean exists(String fullname, XWikiContext context)\n    {\n        return exists(getCurrentMixedDocumentReferenceResolver().resolve(fullname), context);\n    }\n\n    public boolean exists(DocumentReference documentReference, XWikiContext context)\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            XWikiDocument doc = new XWikiDocument(documentReference, documentReference.getLocale());\n\n            context.setWikiId(documentReference.getWikiReference().getName());\n\n            return getStore().exists(doc, context);\n        } catch (XWikiException e) {\n            return false;\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Returns whether a page exists or not.\n     * \n     * @param reference the reference of the page to check for its existence\n     * @return true if the page exists, false if not\n     * @since 13.3RC1\n     * @since 12.10.7\n     */\n    @Unstable\n    public boolean exists(PageReference reference, XWikiContext context)\n    {\n        // Try as space\n        DocumentReference documentReference = getCurrentReferenceDocumentReferenceResolver().resolve(reference);\n        if (exists(documentReference, context)) {\n            return true;\n        }\n\n        // Try as document\n        if (documentReference.getParent().getParent().getType() == EntityType.SPACE) {\n            return exists(new DocumentReference(documentReference.getParent().getName(),\n                documentReference.getParent().getParent(), documentReference.getParameters()), context);\n        }\n\n        return false;\n    }\n\n    public String getAdType(XWikiContext context)\n    {\n        String adtype = \"\";\n        XWikiDocument wikiServer = context.getWikiServer();\n        if (wikiServer != null) {\n            adtype = wikiServer.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"adtype\");\n        }\n\n        if (adtype.equals(\"\")) {\n            adtype = getConfiguration().getProperty(\"xwiki.ad.type\", \"\");\n        }\n\n        return adtype;\n    }\n\n    public String getAdClientId(XWikiContext context)\n    {\n        final String defaultadclientid = \"pub-2778691407285481\";\n        String adclientid = \"\";\n        XWikiDocument wikiServer = context.getWikiServer();\n        if (wikiServer != null) {\n            adclientid = wikiServer.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"adclientid\");\n        }\n\n        if (adclientid.equals(\"\")) {\n            adclientid = getConfiguration().getProperty(\"xwiki.ad.clientid\", \"\");\n        }\n\n        if (adclientid.equals(\"\")) {\n            adclientid = defaultadclientid;\n        }\n\n        return adclientid;\n    }\n\n    /**\n     * @deprecated\n     */\n    @Deprecated\n    public XWikiPluginInterface getPlugin(String name, XWikiContext context)\n    {\n        XWikiPluginManager plugins = getPluginManager();\n        Vector<String> pluginlist = plugins.getPlugins();\n        for (String pluginname : pluginlist) {\n            if (pluginname.equals(name)) {\n                return plugins.getPlugin(pluginname);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated\n     */\n    @Deprecated\n    public Api getPluginApi(String name, XWikiContext context)\n    {\n        XWikiPluginInterface plugin = getPlugin(name, context);\n        if (plugin != null) {\n            return plugin.getPluginApi(plugin, context);\n        }\n\n        return null;\n    }\n\n    public int getHttpTimeout(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.http.timeout\", 60000);\n    }\n\n    public String getHttpUserAgent(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.http.useragent\", \"XWikiBot/1.0\");\n    }\n\n    public String getURLContent(String surl, XWikiContext context) throws IOException\n    {\n        return getURLContent(surl, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public String getURLContent(String surl, int timeout, String userAgent) throws IOException\n    {\n        String content;\n        HttpClient client = getHttpClient(timeout, userAgent);\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            client.executeMethod(get);\n            content = get.getResponseBodyAsString();\n        } finally {\n            // Release any connection resources used by the method\n            get.releaseConnection();\n        }\n\n        return content;\n    }\n\n    public String getURLContent(String surl, String username, String password, XWikiContext context) throws IOException\n    {\n        return getURLContent(surl, username, password, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public String getURLContent(String surl, String username, String password, int timeout, String userAgent)\n        throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // pass our credentials to HttpClient, they will only be used for\n        // authenticating to servers with realm \"realm\", to authenticate agains\n        // an arbitrary realm change this to null.\n        client.getState().setCredentials(new AuthScope(null, -1, null),\n            new UsernamePasswordCredentials(username, password));\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // Tell the GET method to automatically handle authentication. The\n            // method will use any appropriate credentials to handle basic\n            // authentication requests. Setting this value to false will cause\n            // any request for authentication to return with a status of 401.\n            // It will then be up to the client to handle the authentication.\n            get.setDoAuthentication(true);\n\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBodyAsString();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    public byte[] getURLContentAsBytes(String surl, XWikiContext context) throws IOException\n    {\n        return getURLContentAsBytes(surl, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public byte[] getURLContentAsBytes(String surl, int timeout, String userAgent) throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBody();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    public byte[] getURLContentAsBytes(String surl, String username, String password, XWikiContext context)\n        throws IOException\n    {\n        return getURLContentAsBytes(surl, username, password, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public byte[] getURLContentAsBytes(String surl, String username, String password, int timeout, String userAgent)\n        throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // pass our credentials to HttpClient, they will only be used for\n        // authenticating to servers with realm \"realm\", to authenticate agains\n        // an arbitrary realm change this to null.\n        client.getState().setCredentials(new AuthScope(null, -1, null),\n            new UsernamePasswordCredentials(username, password));\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // Tell the GET method to automatically handle authentication. The\n            // method will use any appropriate credentials to handle basic\n            // authentication requests. Setting this value to false will cause\n            // any request for authentication to return with a status of 401.\n            // It will then be up to the client to handle the authentication.\n            get.setDoAuthentication(true);\n\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBody();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    /**\n     * API to list all spaces in the current wiki.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @return a list of string representing all non-hidden spaces (ie spaces that have non-hidden pages) for the\n     *         current wiki\n     * @throws XWikiException if something went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaces(XWikiContext context) throws XWikiException\n    {\n        try {\n            return getStore().getQueryManager().getNamedQuery(\"getSpaces\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\")).execute();\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    /**\n     * API to list all non-hidden documents in a space.\n     *\n     * @param spaceReference the local reference of the space for which to return all non-hidden documents\n     * @return the list of document names (in the format {@code Space.Page}) for non-hidden documents in the specified\n     *         space\n     * @throws XWikiException if the loading went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaceDocsName(String spaceReference, XWikiContext context) throws XWikiException\n    {\n        try {\n            return getStore().getQueryManager().getNamedQuery(\"getSpaceDocsName\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\"))\n                .bindValue(\"space\", spaceReference).execute();\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    public List<String> getIncludedMacros(String defaultSpace, String content, XWikiContext context)\n    {\n        List<String> list;\n\n        try {\n            String pattern = \"#includeMacros[ ]*\\\\([ ]*([\\\"'])(.*?)\\\\1[ ]*\\\\)\";\n            list = context.getUtil().getUniqueMatches(content, pattern, 2);\n            for (int i = 0; i < list.size(); i++) {\n                String name = list.get(i);\n                if (name.indexOf('.') == -1) {\n                    list.set(i, defaultSpace + \".\" + name);\n                }\n            }\n        } catch (Exception e) {\n            // This should never happen\n            LOGGER.error(\"Failed to extract #includeMacros targets from provided content [\" + content + \"]\", e);\n\n            list = Collections.emptyList();\n        }\n\n        return list;\n    }\n\n    /**\n     * accessor for the isReadOnly instance var.\n     *\n     * @see #isReadOnly\n     */\n    public boolean isReadOnly()\n    {\n        return this.isReadOnly;\n    }\n\n    public void setReadOnly(boolean readOnly)\n    {\n        this.isReadOnly = readOnly;\n    }\n\n    public void deleteAllDocuments(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        deleteAllDocuments(doc, true, context);\n    }\n\n    public void deleteAllDocuments(XWikiDocument doc, boolean toTrash, XWikiContext context) throws XWikiException\n    {\n        // Wrap the work as a batch operation.\n        BatchOperationExecutor batchOperationExecutor = Utils.getComponent(BatchOperationExecutor.class);\n        batchOperationExecutor.execute(() -> {\n            // Delete all translation documents\n            for (Locale locale : doc.getTranslationLocales(context)) {\n                XWikiDocument tdoc = doc.getTranslatedDocument(locale, context);\n                deleteDocument(tdoc, toTrash, context);\n            }\n\n            // Delete the default document\n            deleteDocument(doc, toTrash, context);\n        });\n    }\n\n    public void refreshLinks(XWikiContext context) throws XWikiException\n    {\n        try {\n            // refreshes all Links of each doc of the wiki\n            @SuppressWarnings(\"deprecation\")\n            List<String> docs = getStore().getQueryManager().getNamedQuery(\"getAllDocuments\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\")).execute();\n            for (int i = 0; i < docs.size(); i++) {\n                XWikiDocument myDoc = this.getDocument(docs.get(i), context);\n                myDoc.getStore().saveLinks(myDoc, context, true);\n            }\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    public boolean hasBacklinks(XWikiContext context)\n    {\n        if (this.hasBacklinks == null) {\n            this.hasBacklinks = \"1\".equals(getXWikiPreference(\"backlinks\", \"xwiki.backlinks\", \"0\", context));\n        }\n        return this.hasBacklinks;\n    }\n\n    public boolean hasTags(XWikiContext context)\n    {\n        return \"1\".equals(getXWikiPreference(\"tags\", \"xwiki.tags\", \"0\", context));\n    }\n\n    public boolean hasCustomMappings()\n    {\n        return getHibernateConfiguration().hasCustomMappings();\n    }\n\n    public boolean hasDynamicCustomMappings()\n    {\n        return getHibernateConfiguration().hasDynamicCustomMappings();\n    }\n\n    public String getDefaultSpace(XWikiContext context)\n    {\n        String defaultSpace = getXWikiPreference(\"defaultweb\", \"\", context);\n        if (StringUtils.isEmpty(defaultSpace)) {\n            return getConfiguration().getProperty(\"xwiki.defaultweb\", DEFAULT_HOME_SPACE);\n        }\n        return defaultSpace;\n    }\n\n    public boolean showViewAction(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"showviewaction\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        } else if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.showviewaction\", \"1\"));\n    }\n\n    public boolean useDefaultAction(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"usedefaultaction\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.usedefaultaction\", \"0\"));\n    }\n\n    public String getDefaultPage(XWikiContext context)\n    {\n        String defaultPage = getXWikiPreference(\"defaultpage\", \"\", context);\n        if (StringUtils.isEmpty(defaultPage)) {\n            return getConfiguration().getProperty(\"xwiki.defaultpage\", DEFAULT_SPACE_HOMEPAGE);\n        }\n        return defaultPage;\n    }\n\n    public boolean hasEditComment(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment\", \"0\"));\n    }\n\n    public boolean isEditCommentFieldHidden(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_hidden\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.hidden\", \"0\"));\n    }\n\n    public boolean isEditCommentSuggested(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_suggested\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.suggested\", \"0\"));\n    }\n\n    public boolean isEditCommentMandatory(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_mandatory\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.mandatory\", \"0\"));\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#hasMinorEdit()\n     */\n    public boolean hasMinorEdit(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"minoredit\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.minoredit\", \"1\"));\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#hasRecycleBin()\n     * @param context see {@link XWikiContext}\n     */\n    public boolean hasRecycleBin(XWikiContext context)\n    {\n        return getStoreConfiguration().isRecycleBinEnabled();\n    }\n\n    /**\n     * Indicates whether deleted attachments are stored in a recycle bin or not. This can be configured using the key\n     * <var>storage.attachment.recyclebin</var>.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public boolean hasAttachmentRecycleBin(XWikiContext context)\n    {\n        return getStoreConfiguration().isAttachmentRecycleBinEnabled();\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public BaseClass getXClass(DocumentReference documentReference, XWikiContext context) throws XWikiException\n    {\n        // Used to avoid recursive loading of documents if there are recursives usage of classes\n        BaseClass bclass = context.getBaseClass(documentReference);\n        if (bclass != null) {\n            return bclass;\n        }\n\n        return getDocument(documentReference, context).getXClass();\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #getXClass(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public BaseClass getClass(String fullName, XWikiContext context) throws XWikiException\n    {\n        DocumentReference reference = null;\n        if (StringUtils.isNotEmpty(fullName)) {\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);\n        }\n        return getXClass(reference, context);\n    }\n\n    public String getEditorPreference(XWikiContext context)\n    {\n        String defaultSyntaxContentEditor = getEditConfiguration().getDefaultEditor(SyntaxContent.class);\n\n        return defaultSyntaxContentEditor == null ? \"\" : defaultSyntaxContentEditor.toLowerCase();\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String. Note that Groovy scripts\n     * compilation is cached.\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public Object parseGroovyFromString(String script, XWikiContext xcontext) throws XWikiException\n    {\n        return getParseGroovyFromString().parseGroovyFromString(script, xcontext);\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String, using a classloader including all\n     * JAR files located in the passed page as attachments. Note that Groovy scripts compilation is cached\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public Object parseGroovyFromString(String script, String jarWikiPage, XWikiContext xcontext) throws XWikiException\n    {\n        XWikiPageClassLoader pcl = new XWikiPageClassLoader(jarWikiPage, xcontext);\n        Object prevParentClassLoader = xcontext.get(\"parentclassloader\");\n        try {\n            xcontext.put(\"parentclassloader\", pcl);\n\n            return parseGroovyFromString(script, xcontext);\n        } finally {\n            if (prevParentClassLoader == null) {\n                xcontext.remove(\"parentclassloader\");\n            } else {\n                xcontext.put(\"parentclassloader\", prevParentClassLoader);\n            }\n        }\n    }\n\n    public Object parseGroovyFromPage(String fullName, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groovyDocument = context.getWiki().getDocument(fullName, context);\n\n        Object sdoc = context.get(XWikiDocument.CKEY_SDOC);\n        context.put(XWikiDocument.CKEY_SDOC, groovyDocument);\n\n        try {\n            return parseGroovyFromString(groovyDocument.getContent(), context);\n        } finally {\n            context.put(XWikiDocument.CKEY_SDOC, sdoc);\n        }\n    }\n\n    public Object parseGroovyFromPage(String fullName, String jarWikiPage, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groovyDocument = context.getWiki().getDocument(fullName, context);\n\n        Object sdoc = context.get(XWikiDocument.CKEY_SDOC);\n        context.put(XWikiDocument.CKEY_SDOC, groovyDocument);\n\n        try {\n            return parseGroovyFromString(groovyDocument.getContent(), jarWikiPage, context);\n        } finally {\n            context.put(XWikiDocument.CKEY_SDOC, sdoc);\n        }\n    }\n\n    public String getMacroList(XWikiContext context)\n    {\n        String macrosmapping = \"\";\n        XWiki xwiki = context.getWiki();\n\n        try {\n            macrosmapping = getResourceContent(MACROS_FILE);\n        } catch (IOException e) {\n        }\n\n        macrosmapping += \"\\r\\n\" + xwiki.getXWikiPreference(\"macros_mapping\", \"\", context);\n\n        return macrosmapping;\n    }\n\n    // This functions adds an object from an new object creation form\n    public BaseObject getObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        Map<String, String[]> map = Util.getObject(context.getRequest(), className);\n        BaseClass bclass = context.getWiki().getClass(className, context);\n        BaseObject newobject = (BaseObject) bclass.fromMap(map, context);\n\n        return newobject;\n    }\n\n    public String getConvertingUserNameType(XWikiContext context)\n    {\n        if (StringUtils.isNotBlank(context.getWiki().getXWikiPreference(\"convertmail\", context))) {\n            return context.getWiki().getXWikiPreference(\"convertmail\", \"0\", context);\n        }\n\n        return getConfiguration().getProperty(\"xwiki.authentication.convertemail\", \"0\");\n    }\n\n    public String convertUsername(String username, XWikiContext context)\n    {\n        if (username == null) {\n            return null;\n        }\n\n        if (getConvertingUserNameType(context).equals(\"1\") && (username.indexOf('@') != -1)) {\n            String id = \"\" + username.hashCode();\n            id = id.replace(\"-\", \"\");\n            if (username.length() > 1) {\n                int i1 = username.indexOf('@');\n                id = \"\" + username.charAt(0) + username.substring(i1 + 1, i1 + 2)\n                    + username.charAt(username.length() - 1) + id;\n            }\n\n            return id;\n        } else if (getConvertingUserNameType(context).equals(\"2\")) {\n            return username.replaceAll(\"[\\\\.\\\\@]\", \"_\");\n        } else {\n            return username;\n        }\n    }\n\n    public boolean hasSectionEdit(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.section.edit\", 0) == 1;\n    }\n\n    /**\n     * @return The maximum section depth for which section editing is available. This can be customized through the\n     *         {@code xwiki.section.depth} configuration property. Defaults to 2 when not defined.\n     */\n    public long getSectionEditingDepth()\n    {\n        return getConfiguration().getProperty(\"xwiki.section.depth\", 2L);\n    }\n\n    public String getWysiwygToolbars(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.wysiwyg.toolbars\", \"\");\n    }\n\n    public String clearName(String name, XWikiContext context)\n    {\n        return clearName(name, true, true, context);\n    }\n\n    public String clearName(String name, boolean stripDots, boolean ascii, XWikiContext context)\n    {\n        String temp = name;\n        temp = temp.replaceAll(\n            \"[\\u00c0\\u00c1\\u00c2\\u00c3\\u00c4\\u00c5\\u0100\\u0102\\u0104\\u01cd\\u01de\\u01e0\\u01fa\\u0200\\u0202\\u0226]\", \"A\");\n        temp = temp.replaceAll(\n            \"[\\u00e0\\u00e1\\u00e2\\u00e3\\u00e4\\u00e5\\u0101\\u0103\\u0105\\u01ce\\u01df\\u01e1\\u01fb\\u0201\\u0203\\u0227]\", \"a\");\n        temp = temp.replaceAll(\"[\\u00c6\\u01e2\\u01fc]\", \"AE\");\n        temp = temp.replaceAll(\"[\\u00e6\\u01e3\\u01fd]\", \"ae\");\n        temp = temp.replaceAll(\"[\\u008c\\u0152]\", \"OE\");\n        temp = temp.replaceAll(\"[\\u009c\\u0153]\", \"oe\");\n        temp = temp.replaceAll(\"[\\u00c7\\u0106\\u0108\\u010a\\u010c]\", \"C\");\n        temp = temp.replaceAll(\"[\\u00e7\\u0107\\u0109\\u010b\\u010d]\", \"c\");\n        temp = temp.replaceAll(\"[\\u00d0\\u010e\\u0110]\", \"D\");\n        temp = temp.replaceAll(\"[\\u00f0\\u010f\\u0111]\", \"d\");\n        temp = temp.replaceAll(\"[\\u00c8\\u00c9\\u00ca\\u00cb\\u0112\\u0114\\u0116\\u0118\\u011a\\u0204\\u0206\\u0228]\", \"E\");\n        temp = temp.replaceAll(\"[\\u00e8\\u00e9\\u00ea\\u00eb\\u0113\\u0115\\u0117\\u0119\\u011b\\u01dd\\u0205\\u0207\\u0229]\", \"e\");\n        temp = temp.replaceAll(\"[\\u011c\\u011e\\u0120\\u0122\\u01e4\\u01e6\\u01f4]\", \"G\");\n        temp = temp.replaceAll(\"[\\u011d\\u011f\\u0121\\u0123\\u01e5\\u01e7\\u01f5]\", \"g\");\n        temp = temp.replaceAll(\"[\\u0124\\u0126\\u021e]\", \"H\");\n        temp = temp.replaceAll(\"[\\u0125\\u0127\\u021f]\", \"h\");\n        temp = temp.replaceAll(\"[\\u00cc\\u00cd\\u00ce\\u00cf\\u0128\\u012a\\u012c\\u012e\\u0130\\u01cf\\u0208\\u020a]\", \"I\");\n        temp = temp.replaceAll(\"[\\u00ec\\u00ed\\u00ee\\u00ef\\u0129\\u012b\\u012d\\u012f\\u0131\\u01d0\\u0209\\u020b]\", \"i\");\n        temp = temp.replaceAll(\"[\\u0132]\", \"IJ\");\n        temp = temp.replaceAll(\"[\\u0133]\", \"ij\");\n        temp = temp.replaceAll(\"[\\u0134]\", \"J\");\n        temp = temp.replaceAll(\"[\\u0135]\", \"j\");\n        temp = temp.replaceAll(\"[\\u0136\\u01e8]\", \"K\");\n        temp = temp.replaceAll(\"[\\u0137\\u0138\\u01e9]\", \"k\");\n        temp = temp.replaceAll(\"[\\u0139\\u013b\\u013d\\u013f\\u0141]\", \"L\");\n        temp = temp.replaceAll(\"[\\u013a\\u013c\\u013e\\u0140\\u0142\\u0234]\", \"l\");\n        temp = temp.replaceAll(\"[\\u00d1\\u0143\\u0145\\u0147\\u014a\\u01f8]\", \"N\");\n        temp = temp.replaceAll(\"[\\u00f1\\u0144\\u0146\\u0148\\u0149\\u014b\\u01f9\\u0235]\", \"n\");\n        temp = temp.replaceAll(\n            \"[\\u00d2\\u00d3\\u00d4\\u00d5\\u00d6\\u00d8\\u014c\\u014e\\u0150\\u01d1\\u01ea\\u01ec\\u01fe\\u020c\\u020e\\u022a\\u022c\"\n                + \"\\u022e\\u0230]\",\n            \"O\");\n        temp = temp.replaceAll(\n            \"[\\u00f2\\u00f3\\u00f4\\u00f5\\u00f6\\u00f8\\u014d\\u014f\\u0151\\u01d2\\u01eb\\u01ed\\u01ff\\u020d\\u020f\\u022b\\u022d\"\n                + \"\\u022f\\u0231]\",\n            \"o\");\n        temp = temp.replaceAll(\"[\\u0156\\u0158\\u0210\\u0212]\", \"R\");\n        temp = temp.replaceAll(\"[\\u0157\\u0159\\u0211\\u0213]\", \"r\");\n        temp = temp.replaceAll(\"[\\u015a\\u015c\\u015e\\u0160\\u0218]\", \"S\");\n        temp = temp.replaceAll(\"[\\u015b\\u015d\\u015f\\u0161\\u0219]\", \"s\");\n        temp = temp.replaceAll(\"[\\u00de\\u0162\\u0164\\u0166\\u021a]\", \"T\");\n        temp = temp.replaceAll(\"[\\u00fe\\u0163\\u0165\\u0167\\u021b\\u0236]\", \"t\");\n        temp = temp.replaceAll(\n            \"[\\u00d9\\u00da\\u00db\\u00dc\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u0214\\u0216]\",\n            \"U\");\n        temp = temp.replaceAll(\n            \"[\\u00f9\\u00fa\\u00fb\\u00fc\\u0169\\u016b\\u016d\\u016f\\u0171\\u0173\\u01d4\\u01d6\\u01d8\\u01da\\u01dc\\u0215\\u0217]\",\n            \"u\");\n        temp = temp.replaceAll(\"[\\u0174]\", \"W\");\n        temp = temp.replaceAll(\"[\\u0175]\", \"w\");\n        temp = temp.replaceAll(\"[\\u00dd\\u0176\\u0178\\u0232]\", \"Y\");\n        temp = temp.replaceAll(\"[\\u00fd\\u00ff\\u0177\\u0233]\", \"y\");\n        temp = temp.replaceAll(\"[\\u0179\\u017b\\u017d]\", \"Z\");\n        temp = temp.replaceAll(\"[\\u017a\\u017c\\u017e]\", \"z\");\n        temp = temp.replaceAll(\"[\\u00df]\", \"SS\");\n        temp = temp.replaceAll(\"[_':,;\\\\\\\\/]\", \" \");\n        name = temp;\n        name = name.replaceAll(\"\\\\s+\", \"\");\n        name = name.replaceAll(\"[\\\\(\\\\)]\", \" \");\n\n        if (stripDots) {\n            name = name.replaceAll(\"[\\\\.]\", \"\");\n        }\n\n        if (ascii) {\n            name = name.replaceAll(\"[^a-zA-Z0-9\\\\-_\\\\.]\", \"\");\n        }\n\n        if (name.length() > 250) {\n            name = name.substring(0, 250);\n        }\n\n        return name;\n\n    }\n\n    public String getUniquePageName(String space, XWikiContext context)\n    {\n        String pageName = generateRandomString(16);\n\n        return getUniquePageName(space, pageName, context);\n    }\n\n    public String getUniquePageName(String space, String name, XWikiContext context)\n    {\n        String pageName = clearName(name, context);\n        if (exists(space + \".\" + pageName, context)) {\n            int i = 0;\n            while (exists(space + \".\" + pageName + \"_\" + i, context)) {\n                i++;\n            }\n\n            return pageName + \"_\" + i;\n        }\n\n        return pageName;\n    }\n\n    public PropertyClass getPropertyClassFromName(String propPath, XWikiContext context)\n    {\n        int i1 = propPath.indexOf('_');\n        if (i1 == -1) {\n            return null;\n        } else {\n            String className = propPath.substring(0, i1);\n            String propName = propPath.substring(i1 + 1);\n            try {\n                return (PropertyClass) getDocument(className, context).getXClass().get(propName);\n            } catch (XWikiException e) {\n                return null;\n            }\n        }\n    }\n\n    public boolean validateDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        return doc.validate(context);\n    }\n\n    public String addTooltip(String html, String message, String params, XWikiContext context)\n    {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"<span class=\\\"tooltip_span\\\" onmouseover=\\\"\");\n        buffer.append(params);\n        buffer.append(\"; return escape('\");\n        buffer.append(message.replaceAll(\"'\", \"\\\\'\"));\n        buffer.append(\"');\\\">\");\n        buffer.append(html);\n        buffer.append(\"</span>\");\n\n        return buffer.toString();\n    }\n\n    public String addTooltipJS(XWikiContext context)\n    {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"<script src=\\\"\");\n        buffer.append(getSkinFile(\"ajax/wzToolTip.js\", context));\n        buffer.append(\"\\\"></script>\");\n        // buffer.append(\"<div id=\\\"dhtmltooltip\\\"></div>\");\n\n        return buffer.toString();\n    }\n\n    public String addTooltip(String html, String message, XWikiContext context)\n    {\n        return addTooltip(html, message, \"this.WIDTH='300'\", context);\n    }\n\n    public String addMandatory(XWikiContext context)\n    {\n        String star =\n            \"<span class=\\\"mandatoryParenthesis\\\">&nbsp;(</span><span class=\\\"mandatoryDot\\\">&lowast;</span><span class=\\\"mandatoryParenthesis\\\">)&nbsp;</span>\";\n        return context.getWiki().getXWikiPreference(\"mandatory_display\", star, context);\n    }\n\n    /**\n     * @since 2.3M1\n     */\n    public boolean hasVersioning(XWikiContext context)\n    {\n        return getStoreConfiguration().isVersioningEnabled();\n    }\n\n    public boolean hasAttachmentVersioning(XWikiContext context)\n    {\n        return getStoreConfiguration().isAttachmentVersioningEnabled();\n    }\n\n    public String getExternalAttachmentURL(String fullName, String filename, XWikiContext context)\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setFullName(fullName, context);\n\n        return doc.getExternalAttachmentURL(filename, \"download\", context);\n    }\n\n    public int getMaxRecursiveSpaceChecks(XWikiContext context)\n    {\n        int max = getXWikiPreferenceAsInt(\"rights_maxrecursivespacechecks\", -1, context);\n        if (max == -1) {\n            return getConfiguration().getProperty(\"xwiki.rights.maxrecursivespacechecks\", 0);\n        } else {\n            return max;\n        }\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param doc the document to restore\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 5.4RC1\n     */\n    public void restoreFromRecycleBin(final XWikiDocument doc, String comment, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = getRecycleBinStore().getAllDeletedDocuments(doc, context, true);\n        if (deletedDocuments != null && deletedDocuments.length > 0) {\n            long index = deletedDocuments[0].getId();\n            restoreFromRecycleBin(doc, index, comment, context);\n        }\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param doc the document to restore\n     * @param index the index of the document in the recycle bin\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 5.4RC1\n     * @deprecated since 9.4RC1. Use {@link #restoreFromRecycleBin(long, String, XWikiContext)} instead.\n     */\n    @Deprecated\n    public void restoreFromRecycleBin(final XWikiDocument doc, long index, String comment, XWikiContext context)\n        throws XWikiException\n    {\n        restoreFromRecycleBin(index, comment, context);\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param index the index of the document in the recycle bin\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 9.4RC1\n     */\n    public void restoreFromRecycleBin(long index, String comment, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument newdoc = getRecycleBinStore().restoreFromRecycleBin(index, context, true);\n\n        ObservationManager observation = getObservationManager();\n\n        if (observation != null) {\n            observation.notify(new DocumentRestoringEvent(newdoc.getDocumentReferenceWithLocale(), index), newdoc,\n                context);\n        }\n\n        saveDocument(newdoc, comment, context);\n        getRecycleBinStore().deleteFromRecycleBin(index, context, true);\n\n        if (observation != null) {\n            observation.notify(new DocumentRestoredEvent(newdoc.getDocumentReferenceWithLocale(), index), newdoc,\n                context);\n        }        \n    }\n\n    public XWikiDocument rollback(final XWikiDocument tdoc, String rev, XWikiContext context) throws XWikiException\n    {\n        return rollback(tdoc, rev, true, context);\n    }\n\n    private void restoreDeletedAttachment(XWikiAttachment rolledbackAttachment, XWikiContext context)\n        throws XWikiException\n    {\n        // Restore deleted attachments from the trash\n        if (getAttachmentRecycleBinStore() != null) {\n            // There might be multiple versions of the attachment in the trash, search for the right one\n            List<DeletedAttachment> deletedVariants =\n                getAttachmentRecycleBinStore().getAllDeletedAttachments(rolledbackAttachment, context, true);\n\n            DeletedAttachment correctVariant = null;\n            for (DeletedAttachment variant : deletedVariants) { // Reverse chronological order\n                if (variant.getDate().before(rolledbackAttachment.getDate())) {\n                    break;\n                }\n\n                correctVariant = variant;\n            }\n\n            if (correctVariant != null) {\n                XWikiAttachment restoredAttachment = correctVariant.restoreAttachment();\n\n                boolean updateArchive = false;\n\n                if (!restoredAttachment.getVersion().equals(rolledbackAttachment.getVersion())) {\n                    XWikiAttachment restoredAttachmentRevision =\n                        restoredAttachment.getAttachmentRevision(rolledbackAttachment.getVersion(), context);\n\n                    if (restoredAttachmentRevision != null) {\n                        // Update the archive since it won't be done by the store (it's a new attachment)\n                        // TODO: Remove from the archive the versions greater than the rollbacked one instead (they\n                        // would not be lost since they would still be in the recycle bin) ?\n                        rolledbackAttachment.setVersion(restoredAttachment.getVersion());\n                        updateArchive = true;\n\n                        restoredAttachment = restoredAttachmentRevision;\n                    }\n                }\n\n                rolledbackAttachment.apply(restoredAttachment);\n\n                // Restore the deleted archive\n                rolledbackAttachment\n                    .setAttachment_archive((XWikiAttachmentArchive) restoredAttachment.getAttachment_archive().clone());\n                rolledbackAttachment.getAttachment_archive().setAttachment(rolledbackAttachment);\n\n                if (updateArchive) {\n                    rolledbackAttachment.updateContentArchive(context);\n                }\n            } else {\n                // Not found in the trash, set an empty content to avoid errors\n                try {\n                    rolledbackAttachment.setContent(new ByteArrayInputStream(new byte[0]));\n                } catch (IOException e) {\n                    // The content we pass cannot fail\n                }\n            }\n        }\n    }\n\n    /**\n     * @param tdoc the document to rollback\n     * @param rev the revision to rollback to\n     * @param addRevision true if a new revision should be created\n     * @param xcontext the XWiki context\n     * @return the new document\n     * @throws XWikiException when failing to rollback the document\n     * @since 10.7RC1\n     * @since 9.11.8\n     */\n    public XWikiDocument rollback(final XWikiDocument tdoc, String rev, boolean addRevision, XWikiContext xcontext)\n        throws XWikiException\n    {\n        LOGGER.debug(\"Rolling back [{}] to version [{}]\", tdoc, rev);\n\n        // Clone the document before modifying to avoid concurrency issues\n        XWikiDocument document = tdoc.clone();\n\n        XWikiDocument rolledbackDoc = getDocumentRevisionProvider().getRevision(tdoc, rev);\n\n        // Restore attachments\n        if (\"1\".equals(getConfiguration().getProperty(\"xwiki.store.rollbackattachmentwithdocuments\", \"1\"))) {\n            LOGGER.debug(\"Checking attachments\");\n\n            for (XWikiAttachment rolledbackAttachment : rolledbackDoc.getAttachmentList()) {\n                String filename = rolledbackAttachment.getFilename();\n                XWikiAttachment attachment = document.getAttachment(filename);\n\n                if (attachment == null) {\n                    // The attachment has been deleted, search and restore it\n                    LOGGER.debug(\"Deleted attachment: [{}]\", filename);\n\n                    // Restore content and archive from the recycle bin\n                    restoreDeletedAttachment(rolledbackAttachment, xcontext);\n                } else {\n                    XWikiAttachment attachmentRevision =\n                        attachment.getAttachmentRevision(rolledbackAttachment.getVersion(), xcontext);\n\n                    // We compare the number of milliseconds instead of the date objects directly because Hibernate can\n                    // return java.sql.Timestamp for date fields and the JavaDoc says that Timestamp.equals(Object)\n                    // doesn't return true if the passed value is a java.util.Date object with the same number of\n                    // milliseconds because the nanoseconds component of the passed date is unknown.\n                    if (attachmentRevision == null\n                        || attachmentRevision.getDate().getTime() != rolledbackAttachment.getDate().getTime()) {\n                        // Recreated attachment\n                        LOGGER.debug(\"Recreated attachment: [{}]\", filename);\n\n                        // Mark current attachment for deletion to not loose it\n                        document.removeAttachment(attachment);\n\n                        // Search and restore previously deleted one\n                        // If the attachment trash is not available, don't lose the existing attachment\n                        if (getAttachmentRecycleBinStore() != null) {\n                            // Restore in the right version\n                            restoreDeletedAttachment(rolledbackAttachment, xcontext);\n                        }\n                    } else {\n                        // Restore content and archive from the recycle bin\n                        rolledbackAttachment.apply(attachmentRevision);\n                    }\n                }\n            }\n        }\n\n        document.apply(rolledbackDoc);\n\n        // Prepare the XWikiDocument before save\n        document.setAuthorReference(xcontext.getUserReference());\n        document.setContentAuthorReference(xcontext.getUserReference());\n\n        // Make sure the history is not modified if addRevision is disabled\n        String message;\n        if (!addRevision) {\n            document.setVersion(rev);\n            document.setMetaDataDirty(false);\n            document.setContentDirty(false);\n            message = document.getComment();\n        } else {\n            // Make sure to save a new version even if nothing changed\n            document.setMetaDataDirty(true);\n            message = localizePlainOrKey(\"core.comment.rollback\", rev);\n        }\n\n        ObservationManager om = getObservationManager();\n        if (om != null) {\n            // Notify listeners about the document that is going to be rolled back.\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            om.notify(new DocumentRollingBackEvent(document.getDocumentReference(), rev), document, xcontext);\n        }\n\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        saveDocument(document, message, xcontext);\n\n        // Since XWiki#saveDocument resets the original document, we need to temporarily put it back to send\n        // notifications.\n        XWikiDocument newOriginalDocument = document.getOriginalDocument();\n        document.setOriginalDocument(originalDocument);\n\n        try {\n            if (om != null) {\n                // Notify listeners about the document that was rolled back.\n                // Note that for the moment the event being send is a bridge event, as we are still passing around an\n                // XWikiDocument as source and an XWikiContext as data.\n                om.notify(new DocumentRolledBackEvent(document.getDocumentReference(), rev), document, xcontext);\n            }\n        } finally {\n            document.setOriginalDocument(newOriginalDocument);\n        }\n\n        return document;\n    }\n\n    /**\n     * @return the syntax id of the syntax to use when creating new documents\n     */\n    public String getDefaultDocumentSyntax()\n    {\n        // TODO: Fix this method to return a Syntax object instead of a String\n        return getDefaultDocumentSyntaxInternal().toIdString();\n    }\n\n    /**\n     * @return the syntax to use when creating new documents\n     */\n    private Syntax getDefaultDocumentSyntaxInternal()\n    {\n        return Utils.getComponent(CoreConfiguration.class).getDefaultDocumentSyntax();\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @param defaultSyntaxId the default value to return if no document can be found\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId(String defaultSyntaxId, XWikiContext context)\n    {\n        String syntaxId = getCurrentContentSyntaxIdInternal(context);\n\n        if (syntaxId == null) {\n            syntaxId = defaultSyntaxId;\n        }\n\n        return syntaxId;\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId(XWikiContext context)\n    {\n        String syntaxId = getCurrentContentSyntaxIdInternal(context);\n\n        if (syntaxId == null) {\n            throw new RuntimeException(\"Cannot get the current syntax since there's no current document set\");\n        }\n\n        return syntaxId;\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    private String getCurrentContentSyntaxIdInternal(XWikiContext context)\n    {\n        Syntax syntax = getCurrentContentSyntaxInternal(context);\n\n        return syntax != null ? syntax.toIdString() : null;\n    }\n\n    /**\n     * Get the syntax of the code currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax\n     */\n    private Syntax getCurrentContentSyntaxInternal(XWikiContext context)\n    {\n        Syntax syntax = null;\n\n        // Try to find the current syntax\n        if (getRenderingContext() != null) {\n            Block curentBlock = getRenderingContext().getCurrentBlock();\n\n            if (curentBlock != null) {\n                MetaDataBlock metaDataBlock =\n                    curentBlock.getFirstBlock(new MetadataBlockMatcher(MetaData.SYNTAX), Axes.ANCESTOR_OR_SELF);\n\n                if (metaDataBlock != null) {\n                    return (Syntax) metaDataBlock.getMetaData().getMetaData(MetaData.SYNTAX);\n                }\n            }\n        }\n\n        // Fallback on secure and current document in the context\n        if (context.get(\"sdoc\") != null) {\n            // The content document\n            syntax = ((XWikiDocument) context.get(\"sdoc\")).getSyntax();\n        } else if (context.getDoc() != null) {\n            // The context document\n            syntax = context.getDoc().getSyntax();\n        }\n\n        return syntax;\n    }\n\n    /**\n     * @return true if title handling should be using the compatibility mode or not. When the compatibility mode is\n     *         active, if the document's content first header (level 1 or level 2) matches the document's title the\n     *         first header is stripped.\n     */\n    public boolean isTitleInCompatibilityMode()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.title.compatibility\", \"0\"));\n    }\n\n    @Override\n    public void onEvent(Event event, Object source, Object data)\n    {\n        if (event instanceof JobFinishedEvent) {\n            // An extension just been initialized (after an install or upgrade for example)\n            onJobFinished((JobFinishedEvent) event);\n        } else if (event instanceof WikiDeletedEvent) {\n            // A wiki has been deleted\n            onWikiDeletedEvent((WikiDeletedEvent) event);\n        } else if (event instanceof ComponentDescriptorAddedEvent) {\n            // A new mandatory document initializer has been installed\n            onMandatoryDocumentInitializerAdded((ComponentDescriptorAddedEvent) event, (ComponentManager) source);\n        } else {\n            // Document modifications\n\n            XWikiDocument doc = (XWikiDocument) source;\n\n            if (event instanceof XObjectPropertyEvent) {\n                EntityReference reference = ((XObjectPropertyEvent) event).getReference();\n                String modifiedProperty = reference.getName();\n                if (\"backlinks\".equals(modifiedProperty)) {\n                    this.hasBacklinks = doc.getXObject((ObjectReference) reference.getParent()).getIntValue(\"backlinks\",\n                        getConfiguration().getProperty(\"xwiki.backlinks\", 0)) == 1;\n                }\n            }\n        }\n    }\n\n    private void onJobFinished(JobFinishedEvent event)\n    {\n        // Skip it if:\n        // * the authenticator was not yet initialized\n        // * we are using the standard authenticator\n        // * the event is not related to an install or uninstall job\n        if (this.authService == null || this.authService.getClass() == XWikiAuthServiceImpl.class\n            || (!event.getJobType().equals(InstallJob.JOBTYPE) && !event.getJobType().equals(UninstallJob.JOBTYPE))) {\n            return;\n        }\n\n        try {\n            // Get the class corresponding to the configuration\n            Class<? extends XWikiAuthService> authClass = getAuthServiceClass();\n\n            // If the class does not have the same reference anymore it means it's coming from a different classloader\n            // which generally imply that it's coming from an extension which has been reloaded or upgraded\n            // Both still need to have the same class name as otherwise it means the current class did not had anything\n            // to with with the standard configuration (some authenticators register themself)\n            if (this.authService.getClass() != authClass\n                && this.authService.getClass().getName().equals(authClass.getName())) {\n                setAuthService(authClass);\n            }\n        } catch (ClassNotFoundException e) {\n            LOGGER.warn(\"Failed to get the class of the configured authenticator ({}), keeping current authenticator.\",\n                ExceptionUtils.getRootCauseMessage(e));\n        }\n    }\n\n    private void onWikiDeletedEvent(WikiDeletedEvent event)\n    {\n        this.initializedWikis.remove(event.getWikiId());\n    }\n\n    private void onMandatoryDocumentInitializerAdded(ComponentDescriptorAddedEvent event,\n        ComponentManager componentManager)\n    {\n        String namespace;\n        if (componentManager instanceof NamespacedComponentManager) {\n            namespace = ((NamespacedComponentManager) componentManager).getNamespace();\n        } else {\n            namespace = null;\n        }\n\n        MandatoryDocumentInitializer initializer;\n        try {\n            initializer = componentManager.getInstance(MandatoryDocumentInitializer.class, event.getRoleHint());\n\n            XWikiContext context = getXWikiContext();\n            if (namespace == null) {\n                // Initialize in main wiki\n                initializeMandatoryDocument(context.getMainXWiki(), initializer, context);\n                // Initialize in already initialized sub wikis (will be initialized in others when they are initialized)\n                for (String wiki : this.initializedWikis.keySet()) {\n                    initializeMandatoryDocument(wiki, initializer, context);\n                }\n            } else if (namespace.startsWith(\"wiki:\")) {\n                // Initialize in the wiki where the extension is installed\n                initializeMandatoryDocument(namespace.substring(\"wiki:\".length()), initializer, context);\n            }\n        } catch (ComponentLookupException e) {\n            LOGGER.error(\"Failed to lookup mandatory document initializer\", e);\n        }\n    }\n\n    /**\n     * The reference to match properties \"plugins\" and \"backlinks\" of class XWiki.XWikiPreference on whatever wiki.\n     */\n    private static final RegexEntityReference XWIKIPREFERENCE_PROPERTY_REFERENCE =\n        XWikiPreferencesDocumentInitializer.OBJECT_REFERENCE;\n\n    private static final List<Event> LISTENER_EVENTS =\n        Arrays.<Event>asList(new XObjectPropertyAddedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE),\n            new XObjectPropertyDeletedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE),\n            new XObjectPropertyUpdatedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE), new WikiDeletedEvent(),\n            new ComponentDescriptorAddedEvent(MandatoryDocumentInitializer.class), new JobFinishedEvent());\n\n    @Override\n    public List<Event> getEvents()\n    {\n        return LISTENER_EVENTS;\n    }\n\n    @Override\n    public String getName()\n    {\n        return \"xwiki-core\";\n    }\n\n    /**\n     * Return the document reference to the wiki preferences.\n     *\n     * @param context see {@link XWikiContext}\n     * @since 4.3M2\n     */\n    private DocumentReference getPreferencesDocumentReference(XWikiContext context)\n    {\n        String database = context.getWikiId();\n        EntityReference spaceReference;\n        if (database != null) {\n            spaceReference = new EntityReference(SYSTEM_SPACE, EntityType.SPACE, new WikiReference(database));\n        } else {\n            spaceReference = getCurrentMixedEntityReferenceResolver().resolve(SYSTEM_SPACE, EntityType.SPACE);\n        }\n        return new DocumentReference(\"XWikiPreferences\", new SpaceReference(spaceReference));\n    }\n\n    /**\n     * Search attachments by passing HQL where clause values as parameters. You can specify properties of the \"attach\"\n     * (the attachment) or \"doc\" (the document it is attached to)\n     *\n     * @param parametrizedSqlClause The HQL where clause. For example {@code where doc.fullName\n     *        <> ?1 and (attach.author = ?2 or (attach.filename = ?3 and doc.space = ?4))}\n     * @param checkRight if true, only return attachments in documents which the \"current user\" has permission to view.\n     * @param nb The number of rows to return. If 0 then all rows are returned\n     * @param start The number of rows to skip at the beginning.\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @param context see {@link XWikiContext}\n     * @return A List of {@link XWikiAttachment} objects.\n     * @throws XWikiException in case of error while performing the query\n     * @see com.xpn.xwiki.store.XWikiStoreInterface#searchDocuments(String, int, int, java.util.List, XWikiContext)\n     * @since 5.0M2\n     * @deprecated since 9.7RC1, use the QueryManager instead along with the \"attachment\" query filter\n     */\n    @Deprecated\n    public List<XWikiAttachment> searchAttachments(String parametrizedSqlClause, boolean checkRight, int nb, int start,\n        List<?> parameterValues, XWikiContext context) throws XWikiException\n    {\n        parametrizedSqlClause = parametrizedSqlClause.trim().replaceFirst(\"^and \", \"\").replaceFirst(\"^where \", \"\");\n\n        // Get the attachment filenames and document fullNames\n        List<java.lang.Object[]> results = this.getStore().search(\n            \"select attach.filename, doc.fullName from XWikiAttachment attach, XWikiDocument doc where doc.id = attach.docId and \"\n                + parametrizedSqlClause,\n            nb, start, parameterValues, context);\n\n        HashMap<String, List<String>> filenamesByDocFullName = new HashMap<>();\n\n        // Put each attachment name with the document name it belongs to\n        for (int i = 0; i < results.size(); i++) {\n            String filename = (String) results.get(i)[0];\n            String docFullName = (String) results.get(i)[1];\n            if (!filenamesByDocFullName.containsKey(docFullName)) {\n                filenamesByDocFullName.put(docFullName, new ArrayList<String>());\n            }\n            filenamesByDocFullName.get(docFullName).add(filename);\n        }\n\n        List<XWikiAttachment> out = new ArrayList<>();\n\n        // Index through the document names, get relivent attachments\n        for (Map.Entry<String, List<String>> entry : filenamesByDocFullName.entrySet()) {\n            String fullName = entry.getKey();\n\n            XWikiDocument doc = getDocument(fullName, context);\n            if (checkRight) {\n                if (!context.getWiki().getRightService().hasAccessLevel(\"view\", context.getUser(), doc.getFullName(),\n                    context)) {\n                    continue;\n                }\n            }\n            List<String> returnedAttachmentNames = entry.getValue();\n            for (XWikiAttachment attach : doc.getAttachmentList()) {\n                if (returnedAttachmentNames.contains(attach.getFilename())) {\n                    out.add(attach);\n                }\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Count attachments returned by a given parameterized query\n     *\n     * @param parametrizedSqlClause Everything which would follow the \"WHERE\" in HQL\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @param context see {@link XWikiContext}\n     * @return int number of attachments found.\n     * @throws XWikiException in event of an exception querying the database\n     * @see #searchAttachments(String, boolean, int, int, java.util.List, XWikiContext)\n     * @since 5.0M2\n     */\n    public int countAttachments(String parametrizedSqlClause, List<?> parameterValues, XWikiContext context)\n        throws XWikiException\n    {\n        parametrizedSqlClause = parametrizedSqlClause.trim().replaceFirst(\"^and \", \"\").replaceFirst(\"^where \", \"\");\n\n        List l = getStore().search(\"select count(attach) from XWikiAttachment attach, XWikiDocument doc where \"\n            + \"attach.docId=doc.id and \" + parametrizedSqlClause, 0, 0, parameterValues, context);\n        return ((Number) l.get(0)).intValue();\n    }\n\n    // Deprecated\n\n    /**\n     * @deprecated since 6.1M2, use {@link XWikiCfgConfigurationSource#getConfigPath()} instead\n     */\n    @Deprecated\n    public static String getConfigPath() throws NamingException\n    {\n        return XWikiCfgConfigurationSource.getConfigPath();\n    }\n\n    /**\n     * @deprecated since 6.1M3, use {@link #XWiki(XWikiContext)} instead\n     */\n    @Deprecated\n    public XWiki(XWikiConfig config, XWikiContext context) throws XWikiException\n    {\n        this(config, context, null, false);\n    }\n\n    /**\n     * @deprecated since 6.1M3, use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(XWikiConfig config, XWikiContext context, XWikiEngineContext engine_context, boolean noupdate)\n        throws XWikiException\n    {\n        initXWiki(config, context, engine_context, noupdate);\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext)} instead\n     */\n    @Deprecated\n    public XWiki(String xwikicfgpath, XWikiContext context) throws XWikiException\n    {\n        this(xwikicfgpath, context, null, false);\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(String xwikicfgpath, XWikiContext context, XWikiEngineContext engine_context, boolean noupdate)\n        throws XWikiException\n    {\n        try {\n            initXWiki(new XWikiConfig(new FileInputStream(xwikicfgpath)), context, engine_context, noupdate);\n        } catch (FileNotFoundException e) {\n            Object[] args = { xwikicfgpath };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_CONFIG, XWikiException.ERROR_XWIKI_CONFIG_FILENOTFOUND,\n                \"Configuration file {0} not found\", e, args);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(InputStream is, XWikiContext context, XWikiEngineContext engine_context) throws XWikiException\n    {\n        initXWiki(new XWikiConfig(is), context, engine_context, true);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public XWikiConfig getConfig()\n    {\n        return new XWikiConfigDelegate(getConfiguration());\n    }\n\n    /**\n     * @deprecated since 6.1M2\n     */\n    @Deprecated\n    public void setConfig(XWikiConfig config)\n    {\n        ConfigurationSource configuration = getConfiguration();\n\n        if (configuration instanceof XWikiCfgConfigurationSource) {\n            ((XWikiCfgConfigurationSource) configuration).set(config);\n        }\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public String Param(String key)\n    {\n        return Param(key, null);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public String Param(String key, String default_value)\n    {\n        if (getConfiguration() != null) {\n            return getConfiguration().getProperty(key, default_value);\n        }\n\n        return default_value;\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public long ParamAsLong(String key)\n    {\n        return getConfiguration().getProperty(key, long.class);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public long ParamAsLong(String key, long default_value)\n    {\n        return getConfiguration().getProperty(key, default_value);\n    }\n\n    /**\n     * @return true if the wiki is in path based mode, fale otherwise\n     * @since 11.9RC1\n     */\n    public boolean isPathBased()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.virtual.usepath\", \"1\"));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport javax.inject.Provider;\n\nimport org.apache.commons.collections4.map.LRUMap;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.velocity.internal.VelocityExecutionContextInitializer;\n\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.validation.XWikiValidationStatus;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiEngineContext;\nimport com.xpn.xwiki.web.XWikiForm;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiResponse;\nimport com.xpn.xwiki.web.XWikiURLFactory;\n\n/**\n * Represents the execution environment for all the wiki pages. An instance of the <code>Context</code> class is\n * available as a predefined variable for scripting inside any wiki page. You can access it using <code>$xcontext</code>\n * in Velocity scripts or simply <code>xcontext</code> in Groovy ones. The <code>Context</code> class provides a means\n * of getting contextual information about the current request or configuring XWiki on the fly.\n *\n * @version $Id$\n */\npublic class XWikiContext extends Hashtable<Object, Object>\n{\n    /**\n     * Type instance for {@code Provider<XWikiContext>}.\n     *\n     * @since 5.0M1\n     */\n    public static final ParameterizedType TYPE_PROVIDER =\n        new DefaultParameterizedType(null, Provider.class, XWikiContext.class);\n\n    public static final int MODE_SERVLET = 0;\n\n    public static final int MODE_PORTLET = 1;\n\n    public static final int MODE_XMLRPC = 2;\n\n    public static final int MODE_ATOM = 3;\n\n    public static final int MODE_PDF = 4;\n\n    public static final int MODE_GWT = 5;\n\n    public static final int MODE_GWT_DEBUG = 6;\n\n    public static final String EXECUTIONCONTEXT_KEY = \"xwikicontext\";\n\n    /**\n     * @deprecated use {@link VelocityManager#getVelocityContext()} instead\n     */\n    @Deprecated\n    public static final String KEY_LEGACY_VELOCITYCONTEXT = \"vcontext\";\n\n    /** Logging helper object. */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(XWikiContext.class);\n\n    private static final String WIKI_KEY = \"wiki\";\n\n    private static final String ORIGINAL_WIKI_KEY = \"originalWiki\";\n\n    private static final String USER_KEY = \"user\";\n\n    private static final String USERREFERENCE_KEY = \"userreference\";\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead and for the wiki name for which\n     * the current wiki is used instead of the current document reference's wiki.\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    /**\n     * Used to convert a proper Document Reference to a string but without the wiki name.\n     */\n    private EntityReferenceSerializer<String> localEntityReferenceSerializer;\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part if it matches the current\n     * wiki).\n     */\n    private EntityReferenceSerializer<String> compactWikiEntityReferenceSerializer;\n\n    /** The Execution so that we can check if permissions were dropped there. */\n    private Execution execution;\n\n    private boolean finished = false;\n\n    private boolean responseSent = false;\n\n    private XWiki wiki;\n\n    private XWikiEngineContext engine_context;\n\n    private XWikiRequest request;\n\n    private XWikiResponse response;\n\n    private XWikiForm form;\n\n    private String action;\n\n    private String orig_wikiId;\n\n    private WikiReference wikiReference;\n\n    private DocumentReference userReference;\n\n    private Locale locale;\n\n    private static final String LANGUAGE_KEY = \"language\";\n\n    private Locale interfaceLocale;\n\n    private int mode;\n\n    private URL url;\n\n    private XWikiURLFactory URLFactory;\n\n    private int cacheDuration = 0;\n\n    private int classCacheSize = 20;\n\n    // Used to avoid recursive loading of documents if there are recursives usage of classes\n    // FIXME: why synchronized since a context is supposed to be tied to a thread ?\n    @SuppressWarnings(\"unchecked\")\n    private Map<DocumentReference, BaseClass> classCache = Collections.synchronizedMap(new LRUMap(this.classCacheSize));\n\n    // FIXME: why synchronized since a context is supposed to be tied to a thread ?\n    private List<String> displayedFields = Collections.synchronizedList(new ArrayList<String>());\n\n    public XWikiContext()\n    {\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getLocalEntityReferenceSerializer()\n    {\n        if (this.localEntityReferenceSerializer == null) {\n            this.localEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n\n        return this.localEntityReferenceSerializer;\n    }\n\n    private EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()\n    {\n        if (this.compactWikiEntityReferenceSerializer == null) {\n            this.compactWikiEntityReferenceSerializer =\n                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n        }\n\n        return this.compactWikiEntityReferenceSerializer;\n    }\n\n    private Execution getExecution()\n    {\n        if (this.execution == null) {\n            this.execution = Utils.getComponent(Execution.class);\n        }\n\n        return this.execution;\n    }\n\n    private ExecutionContext getExecutionContext()\n    {\n        if (getExecution() != null) {\n            return getExecution().getContext();\n        }\n\n        return null;\n    }\n\n    public XWiki getWiki()\n    {\n        return this.wiki;\n    }\n\n    public Util getUtil()\n    {\n        Util util = (Util) this.get(\"util\");\n        if (util == null) {\n            util = new Util();\n            this.put(\"util\", util);\n        }\n\n        return util;\n    }\n\n    public void setWiki(XWiki wiki)\n    {\n        this.wiki = wiki;\n    }\n\n    public XWikiEngineContext getEngineContext()\n    {\n        return this.engine_context;\n    }\n\n    public void setEngineContext(XWikiEngineContext engine_context)\n    {\n        this.engine_context = engine_context;\n    }\n\n    public XWikiRequest getRequest()\n    {\n        return this.request;\n    }\n\n    public void setRequest(XWikiRequest request)\n    {\n        this.request = request;\n    }\n\n    public String getAction()\n    {\n        return this.action;\n    }\n\n    public void setAction(String action)\n    {\n        this.action = action;\n    }\n\n    public XWikiResponse getResponse()\n    {\n        return this.response;\n    }\n\n    public void setResponse(XWikiResponse response)\n    {\n        this.response = response;\n    }\n\n    /**\n     * @deprecated since 6.1M1, use {@link #getWikiId()} instead\n     */\n    @Deprecated\n    public String getDatabase()\n    {\n        return getWikiId();\n    }\n\n    /**\n     * @return the id of the current wiki, or null if none is set\n     * @since 6.1M1\n     */\n    public String getWikiId()\n    {\n        return this.wikiReference != null ? this.wikiReference.getName() : null;\n    }\n\n    /**\n     * @return the reference of the current wiki or null if none is set\n     * @since 7.2M1\n     */\n    public WikiReference getWikiReference()\n    {\n        return this.wikiReference;\n    }\n\n    /**\n     * @param wikiId the current wiki id\n     * @deprecated since 6.1M1, use {@link #setWikiId(String)} instead\n     */\n    @Deprecated\n    public void setDatabase(String wikiId)\n    {\n        setWikiId(wikiId);\n    }\n\n    /**\n     * @param wikiId the current wiki id\n     * @since 6.1M1\n     */\n    public void setWikiId(String wikiId)\n    {\n        setWikiReference(wikiId != null ? new WikiReference(wikiId) : null);\n    }\n\n    /**\n     * @param wikiReference the current wiki reference\n     * @since 7.2M1\n     */\n    public void setWikiReference(WikiReference wikiReference)\n    {\n        this.wikiReference = wikiReference;\n\n        if (this.wikiReference == null) {\n            super.remove(WIKI_KEY);\n        } else {\n            super.put(WIKI_KEY, this.wikiReference.getName());\n\n            if (this.orig_wikiId == null) {\n                this.orig_wikiId = this.wikiReference.getName();\n                super.put(ORIGINAL_WIKI_KEY, this.wikiReference.getName());\n            }\n        }\n    }\n\n    @Override\n    public synchronized Object get(Object key)\n    {\n        Object value;\n\n        if (WIKI_KEY.equals(key)) {\n            value = getWikiId();\n        } else if (KEY_LEGACY_VELOCITYCONTEXT.equals(key)) {\n            ExecutionContext executionContext = getExecutionContext();\n            if (executionContext != null) {\n                value = executionContext.getProperty(VelocityExecutionContextInitializer.VELOCITY_CONTEXT_ID);\n            } else {\n                value = null;\n            }\n        } else {\n            value = super.get(key);\n        }\n\n        return value;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Make sure to keep wiki field and map synchronized.\n     * </p>\n     *\n     * @see java.util.Hashtable#put(java.lang.Object, java.lang.Object)\n     */\n    @Override\n    public synchronized Object put(Object key, Object value)\n    {\n        Object previous;\n\n        if (WIKI_KEY.equals(key)) {\n            previous = get(WIKI_KEY);\n            setWikiId((String) value);\n        } else if (KEY_LEGACY_VELOCITYCONTEXT.equals(key)) {\n            ExecutionContext executionContext = getExecutionContext();\n            if (executionContext != null) {\n                previous = executionContext.getProperty(VelocityExecutionContextInitializer.VELOCITY_CONTEXT_ID);\n                executionContext.setProperty(VelocityExecutionContextInitializer.VELOCITY_CONTEXT_ID, value);\n            } else {\n                previous = null;\n            }\n        } else {\n            if (value != null) {\n                previous = super.put(key, value);\n            } else {\n                previous = super.remove(key);\n            }\n        }\n\n        return previous;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Make sure to keep wiki field and map synchronized.\n     * </p>\n     *\n     * @see java.util.Hashtable#remove(java.lang.Object)\n     */\n    @Override\n    public synchronized Object remove(Object key)\n    {\n        Object previous;\n\n        if (WIKI_KEY.equals(key)) {\n            previous = get(WIKI_KEY);\n            setWikiId(null);\n        } else if (KEY_LEGACY_VELOCITYCONTEXT.equals(key)) {\n            ExecutionContext executionContext = getExecutionContext();\n            if (executionContext != null) {\n                previous = executionContext.getProperty(VelocityExecutionContextInitializer.VELOCITY_CONTEXT_ID);\n                executionContext.removeProperty(VelocityExecutionContextInitializer.VELOCITY_CONTEXT_ID);\n            } else {\n                previous = null;\n            }\n        } else {\n            previous = super.remove(key);\n        }\n\n        return previous;\n    }\n\n    /**\n     * Get the \"original\" wiki id. This will be the wiki id for the wiki which the user requested. If the wiki is\n     * switched to load some piece of data, this will remember what it should be switched back to.\n     *\n     * @return the wiki id originally requested by the user.\n     * @deprecated since 6.1M1, use {@link #getOriginalWikiId()} instead\n     */\n    @Deprecated\n    public String getOriginalDatabase()\n    {\n        return getOriginalWikiId();\n    }\n\n    /**\n     * Get the \"original\" wiki id. This will be the wiki id for the wiki which the user requested. If the wiki is\n     * switched to load some piece of data, this will remember what it should be switched back to.\n     *\n     * @return the wiki id originally requested by the user.\n     * @since 6.1M1\n     */\n    public String getOriginalWikiId()\n    {\n        return this.orig_wikiId;\n    }\n\n    /**\n     * @deprecated since 6.1M1, use {@link #setOriginalWikiId(String)} instead\n     */\n    @Deprecated\n    public void setOriginalDatabase(String wikiId)\n    {\n        setOriginalWikiId(wikiId);\n    }\n\n    /**\n     * Set the \"original\" wiki id. This will be the wiki id for the wiki which the user requested. If the wiki is\n     * switched to load some piece of data, this will remember what it should be switched back to.\n     *\n     * @param wikiId the wiki id originally requested by the user\n     * @since 6.1M1\n     */\n    public void setOriginalWikiId(String wikiId)\n    {\n        this.orig_wikiId = wikiId;\n        if (wikiId == null) {\n            remove(ORIGINAL_WIKI_KEY);\n        } else {\n            put(ORIGINAL_WIKI_KEY, wikiId);\n        }\n    }\n\n    /**\n     * @return true it's main wiki's context, false otherwise.\n     */\n    public boolean isMainWiki()\n    {\n        return isMainWiki(getWikiId());\n    }\n\n    /**\n     * @param wikiName the name of the wiki.\n     * @return true it's main wiki's context, false otherwise.\n     */\n    public boolean isMainWiki(String wikiName)\n    {\n        return StringUtils.equalsIgnoreCase(wikiName, getMainXWiki());\n    }\n\n    /**\n     * @return the current document handled in the context or {@code null}.\n     */\n    public XWikiDocument getDoc()\n    {\n        return (XWikiDocument) get(\"doc\");\n    }\n\n    public void setDoc(XWikiDocument doc)\n    {\n        if (doc == null) {\n            remove(\"doc\");\n        } else {\n            put(\"doc\", doc);\n        }\n    }\n\n    public DocumentReference getUserReference()\n    {\n        return this.userReference;\n    }\n\n    public void setUserReference(DocumentReference userReference)\n    {\n        if (userReference == null) {\n            this.userReference = null;\n            remove(USER_KEY);\n            remove(USERREFERENCE_KEY);\n        } else {\n            this.userReference = userReference;\n            boolean ismain = isMainWiki(this.userReference.getWikiReference().getName());\n            put(USER_KEY, new XWikiUser(getUser(), ismain));\n            put(USERREFERENCE_KEY, this.userReference);\n\n            // Log this since it's probably a mistake so that we find who is doing bad things\n            if (this.userReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n        }\n\n    }\n\n    private void setUserInternal(String user, boolean main)\n    {\n        if (user == null) {\n            setUserReference(null);\n        } else if (user.endsWith(XWikiRightService.GUEST_USER_FULLNAME) || user.equals(XWikiRightService.GUEST_USER)) {\n            setUserReference(null);\n            // retro-compatibilty hack: some code does not give the same meaning to null XWikiUser and XWikiUser\n            // containing guest user\n            put(USER_KEY, new XWikiUser(user, main));\n        } else {\n            setUserReference(resolveUserReference(user));\n        }\n    }\n\n    /**\n     * Make sure to use \"XWiki\" as default space when it's not provided in user name.\n     */\n    private DocumentReference resolveUserReference(String user)\n    {\n        return getCurrentMixedDocumentReferenceResolver().resolve(user,\n            new SpaceReference(\"XWiki\", new WikiReference(getWikiId() == null ? \"xwiki\" : getWikiId())));\n    }\n\n    /**\n     * @deprecated since 3.1M1 use {@link #setUserReference(DocumentReference)} instead\n     */\n    @Deprecated\n    public void setUser(String user)\n    {\n        setUserInternal(user, false);\n    }\n\n    /**\n     * @deprecated since 3.1M1 use {@link #getUserReference()} instead\n     */\n    @Deprecated\n    public String getUser()\n    {\n        if (this.userReference != null) {\n            if (getWikiId() == null) {\n                return getLocalEntityReferenceSerializer().serialize(this.userReference);\n            } else {\n                return getCompactWikiEntityReferenceSerializer().serialize(this.userReference,\n                    new WikiReference(getWikiId()));\n            }\n        } else {\n            return XWikiRightService.GUEST_USER_FULLNAME;\n        }\n    }\n\n    /**\n     * @deprecated since 3.1M1 use {@link #getUserReference()} instead\n     */\n    @Deprecated\n    public String getLocalUser()\n    {\n        if (this.userReference != null) {\n            return getLocalEntityReferenceSerializer().serialize(this.userReference);\n        } else {\n            return XWikiRightService.GUEST_USER_FULLNAME;\n        }\n    }\n\n    /**\n     * @deprecated since 3.1M1 use {@link #getUserReference()} instead\n     */\n    @Deprecated\n    public XWikiUser getXWikiUser()\n    {\n        if (this.userReference != null) {\n            boolean ismain = isMainWiki(this.userReference.getWikiReference().getName());\n            return new XWikiUser(getUser(), ismain);\n        }\n\n        return (XWikiUser) get(USER_KEY);\n    }\n\n    /**\n     * @deprecated since 4.3M1 use {@link #getLocale()} instead\n     */\n    @Deprecated\n    public String getLanguage()\n    {\n        return this.locale != null ? this.locale.toString() : null;\n    }\n\n    /**\n     * @deprecated since 4.3M1 use {@link #setLocale(Locale)} instead\n     */\n    @Deprecated\n    public void setLanguage(String language)\n    {\n        setLocale(LocaleUtils.toLocale(Util.normalizeLanguage(language)));\n\n    }\n\n    /**\n     * @return the current locale\n     * @since 4.3M1\n     */\n    public Locale getLocale()\n    {\n        return this.locale;\n    }\n\n    /**\n     * @param locale the current locale\n     * @since 4.3M1\n     */\n    public void setLocale(Locale locale)\n    {\n        this.locale = locale;\n\n        if (locale == null) {\n            remove(LANGUAGE_KEY);\n        } else {\n            put(LANGUAGE_KEY, locale.toString());\n        }\n    }\n\n    /**\n     * @deprecated since 6.0M1, use {@link #getInterfaceLocale()} instead\n     */\n    @Deprecated\n    public String getInterfaceLanguage()\n    {\n        return this.interfaceLocale != null ? this.interfaceLocale.toString() : null;\n    }\n\n    /**\n     * @return the {@link Locale} to use to display the user interface\n     * @since 6.0M1\n     */\n    public Locale getInterfaceLocale()\n    {\n        return this.interfaceLocale;\n    }\n\n    /**\n     * @param interfaceLocale the {@link Locale} to use to display the content\n     * @since 6.0M1\n     */\n    public void setInterfaceLocale(Locale interfaceLocale)\n    {\n        this.interfaceLocale = interfaceLocale;\n    }\n\n    public int getMode()\n    {\n        return this.mode;\n    }\n\n    public void setMode(int mode)\n    {\n        this.mode = mode;\n    }\n\n    public URL getURL()\n    {\n        return this.url;\n    }\n\n    public void setURL(URL url)\n    {\n        this.url = url;\n    }\n\n    public XWikiURLFactory getURLFactory()\n    {\n        return this.URLFactory;\n    }\n\n    public void setURLFactory(XWikiURLFactory URLFactory)\n    {\n        this.URLFactory = URLFactory;\n    }\n\n    public XWikiForm getForm()\n    {\n        return this.form;\n    }\n\n    public void setForm(XWikiForm form)\n    {\n        this.form = form;\n    }\n\n    /**\n     * Define if a response has been already sent or not.\n     * Note that contrary to {@link #isResponseSent()} this method will ensure that the template is executed even if the\n     * result of the execution is not sent. See {@link Utils#parseTemplate(String, boolean, XWikiContext)} for details.\n     * @return {@code true} if the response has been sent and no new reponse should be sent anymore.\n     */\n    public boolean isFinished()\n    {\n        return this.finished;\n    }\n\n    /**\n     * See {@link #isFinished()}.\n     * @param finished Set to {@code true} if the response has been sent.\n     */\n    public void setFinished(boolean finished)\n    {\n        this.finished = finished;\n    }\n\n    /**\n     * Define if a response has been already sent or not and if the template parsing should be done.\n     * Note that contrary to {@link #isFinished()} this method will always prevent the execution of the template.\n     * See {@link Utils#parseTemplate(String, boolean, XWikiContext)} for details.\n     * @return {@code true} if the response has been sent, no new reponse should be sent anymore\n     *          and the template should not be parsed.\n     * @since 13.3RC1\n     */\n    @Unstable\n    public boolean isResponseSent()\n    {\n        return this.responseSent;\n    }\n\n    /**\n     * See {@link #isResponseSent()}.\n     * @param responseSent Set to {@code true} if the response has been sent and the template should not be executed.\n     */\n    public void setResponseSent(boolean responseSent)\n    {\n        this.responseSent = responseSent;\n    }\n\n    public XWikiDocument getWikiServer()\n    {\n        String currentWiki = getWikiId();\n        try {\n            setWikiId(getMainXWiki());\n\n            return getWiki().getDocument(XWiki.getServerWikiPage(currentWiki), this);\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to get wiki descriptor for wiki [{}]\", currentWiki, e);\n        } finally {\n            setWikiId(currentWiki);\n        }\n\n        return null;\n    }\n\n    public int getCacheDuration()\n    {\n        return this.cacheDuration;\n    }\n\n    public void setCacheDuration(int cacheDuration)\n    {\n        this.cacheDuration = cacheDuration;\n    }\n\n    public String getMainXWiki()\n    {\n        return (String) get(\"mainxwiki\");\n    }\n\n    public void setMainXWiki(String str)\n    {\n        put(\"mainxwiki\", str);\n    }\n\n    // Used to avoid recursive loading of documents if there are recursives usage of classes\n    public void addBaseClass(BaseClass bclass)\n    {\n        this.classCache.put(bclass.getDocumentReference(), bclass);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    // Used to avoid recursive loading of documents if there are recursives usage of classes\n    public BaseClass getBaseClass(DocumentReference classReference)\n    {\n        return this.classCache.get(classReference);\n    }\n\n    /**\n     * @param classReference the reference of the class\n     * @since 9.0RC1\n     */\n    public void removeBaseClass(DocumentReference classReference)\n    {\n        this.classCache.remove(classReference);\n    }\n\n    /**\n     * Empty the class cache.\n     */\n    public void flushClassCache()\n    {\n        this.classCache.clear();\n    }\n\n    public void setLinksAction(String action)\n    {\n        put(\"links_action\", action);\n    }\n\n    public void unsetLinksAction()\n    {\n        remove(\"links_action\");\n    }\n\n    public String getLinksAction()\n    {\n        return (String) get(\"links_action\");\n    }\n\n    public void setLinksQueryString(String value)\n    {\n        put(\"links_qs\", value);\n    }\n\n    public void unsetLinksQueryString()\n    {\n        remove(\"links_qs\");\n    }\n\n    public String getLinksQueryString()\n    {\n        return (String) get(\"links_qs\");\n    }\n\n    /**\n     * @deprecated since 4.3M2 use {@link org.xwiki.localization.ContextualLocalizationManager} component instead\n     */\n    @Deprecated\n    public XWikiMessageTool getMessageTool()\n    {\n        XWikiMessageTool msg = ((XWikiMessageTool) get(\"msg\"));\n        if (msg == null) {\n            getWiki().prepareResources(this);\n            msg = ((XWikiMessageTool) get(\"msg\"));\n        }\n\n        return msg;\n    }\n\n    public XWikiValidationStatus getValidationStatus()\n    {\n        return (XWikiValidationStatus) get(\"validation_status\");\n    }\n\n    public void setValidationStatus(XWikiValidationStatus status)\n    {\n        put(\"validation_status\", status);\n    }\n\n    public void addDisplayedField(String fieldname)\n    {\n        this.displayedFields.add(fieldname);\n    }\n\n    public List<String> getDisplayedFields()\n    {\n        return this.displayedFields;\n    }\n\n    /**\n     * Returns the list of TextArea fields that use the WYSIWYG editor. This list is automatically built when displaying\n     * TextArea properties.\n     *\n     * @deprecated since 8.2RC1 when we started using the Edit Module to load the configured WYSIWYG editor\n     * @return a string containing a comma-separated list of TextArea field names for which the WYSIWYG editor should be\n     *         enabled\n     */\n    @Deprecated\n    public String getEditorWysiwyg()\n    {\n        return (String) get(\"editor_wysiwyg\");\n    }\n\n    /**\n     * Drop permissions for the remainder of the request cycle.\n     * <p>\n     * After this is called:\n     * <ul>\n     * <li>1. {@link com.xpn.xwiki.api.Api#hasProgrammingRights()} will always return false.</li>\n     * <li>2. {@link com.xpn.xwiki.api.XWiki#getDocumentAsAuthor(org.xwiki.model.reference.DocumentReference)},\n     * {@link com.xpn.xwiki.api.XWiki#getDocumentAsAuthor(String)}, {@link com.xpn.xwiki.api.Document#saveAsAuthor()},\n     * {@link com.xpn.xwiki.api.Document#saveAsAuthor(String)},\n     * {@link com.xpn.xwiki.api.Document#saveAsAuthor(String, boolean)}, and\n     * {@link com.xpn.xwiki.api.Document#deleteAsAuthor()} will perform all of their actions as if the document's\n     * content author was the guest user (XWiki.XWikiGuest).</li>\n     * </ul>\n     * <p>\n     * In effect, no code requiring \"programming right\" will run, and if the document content author (see:\n     * {@link com.xpn.xwiki.api.Document#getContentAuthor()}) is a user who has \"programming right\", there will be no\n     * way for code following this call to save another document as this user, blessing it too with programming right.\n     * <p>\n     * Once dropped, permissions cannot be regained for the duration of the request.\n     * <p>\n     * If you are interested in a more flexable sandboxing method which sandboxed code only for the remainder of the\n     * rendering cycle, consider using {@link com.xpn.xwiki.api.Document#dropPermissions()}.\n     *\n     * @since 3.0M3\n     */\n    public void dropPermissions()\n    {\n        this.put(XWikiConstant.DROPPED_PERMISSIONS, Boolean.TRUE);\n    }\n\n    /**\n     * @return true if {@link XWikiContext#dropPermissions()} has been called on this context, or if the\n     *         {@link XWikiConstant#DROPPED_PERMISSIONS} key has been set in the\n     *         {@link org.xwiki.context.ExecutionContext} for this thread. This is done by calling\n     *         {Document#dropPermissions()}\n     */\n    public boolean hasDroppedPermissions()\n    {\n        if (this.get(XWikiConstant.DROPPED_PERMISSIONS) != null) {\n            return true;\n        }\n\n        final Object dropped = getExecution().getContext().getProperty(XWikiConstant.DROPPED_PERMISSIONS);\n\n        if (!(dropped instanceof Integer)) {\n            return false;\n        }\n\n        return ((Integer) dropped) == System.identityHashCode(getExecution().getContext());\n    }\n\n    // Object\n\n    @Override\n    public synchronized XWikiContext clone()\n    {\n        XWikiContext context = (XWikiContext) super.clone();\n\n        // Make sure to have unique instances of the various caches\n        context.displayedFields = Collections.synchronizedList(new ArrayList<String>(this.displayedFields));\n        context.classCache = Collections.synchronizedMap(new LRUMap<DocumentReference, BaseClass>(this.classCacheSize));\n\n        return context;\n    }\n\n    /**\n     * There are several places where the XWiki context needs to be declared in the execution, so we add a common method\n     * here.\n     *\n     * @param executionContext The execution context.\n     */\n    public void declareInExecutionContext(ExecutionContext executionContext)\n    {\n        if (!executionContext.hasProperty(XWikiContext.EXECUTIONCONTEXT_KEY)) {\n            executionContext.newProperty(XWikiContext.EXECUTIONCONTEXT_KEY).initial(this).inherited().declare();\n        } else {\n            executionContext.setProperty(XWikiContext.EXECUTIONCONTEXT_KEY, this);\n        }\n    }\n\n    /**\n     * @return the reference of the user being used to check script and programming right (i.e. the author of the\n     *         current script)\n     * @since 8.3M2\n     */\n    public DocumentReference getAuthorReference()\n    {\n        XWikiDocument sdoc = (XWikiDocument) get(\"sdoc\");\n        if (sdoc == null) {\n            sdoc = getDoc();\n        }\n\n        return sdoc != null ? sdoc.getContentAuthorReference() : getUserReference();\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.api;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.job.Job;\nimport org.xwiki.job.event.status.JobStatus;\nimport org.xwiki.job.event.status.JobStatus.State;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.rendering.renderer.PrintRendererFactory;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.XWikiInitializerJob;\nimport com.xpn.xwiki.internal.XWikiInitializerJobStatus;\nimport com.xpn.xwiki.objects.meta.MetaClass;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.util.Programming;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiEngineContext;\nimport com.xpn.xwiki.web.XWikiURLFactory;\n\npublic class XWiki extends Api\n{\n    /** Logging helper object. */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);\n\n    /** The internal object wrapped by this API. */\n    private com.xpn.xwiki.XWiki xwiki;\n\n    /**\n     * @see #getStatsService()\n     */\n    private StatsService statsService;\n\n    /**\n     * @see #getCriteriaService()\n     */\n    private CriteriaService criteriaService;\n\n    /**\n     * @see com.xpn.xwiki.internal.model.reference.CurrentMixedStringDocumentReferenceResolver\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    /**\n     * @see org.xwiki.model.internal.reference.DefaultStringDocumentReferenceResolver\n     */\n    private DocumentReferenceResolver<String> defaultDocumentReferenceResolver;\n\n    /**\n     * The object used to serialize entity references into strings. We need it because we have script APIs that work\n     * with entity references but have to call older, often internal, methods that still use string references.\n     */\n    private EntityReferenceSerializer<String> defaultStringEntityReferenceSerializer;\n\n    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private ContextualAuthorizationManager contextualAuthorizationManager;\n\n    /**\n     * XWiki API Constructor\n     *\n     * @param xwiki XWiki Main Object to wrap\n     * @param context XWikiContext to wrap\n     */\n    public XWiki(com.xpn.xwiki.XWiki xwiki, XWikiContext context)\n    {\n        super(context);\n\n        this.xwiki = xwiki;\n        this.statsService = new StatsService(context);\n        this.criteriaService = new CriteriaService(context);\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentgetdocumentResolver()\n    {\n        if (this.currentgetdocumentResolver == null) {\n            this.currentgetdocumentResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");\n        }\n\n        return this.currentgetdocumentResolver;\n    }\n\n    private DocumentReferenceResolver<String> getDefaultDocumentReferenceResolver()\n    {\n        if (this.defaultDocumentReferenceResolver == null) {\n            this.defaultDocumentReferenceResolver = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING);\n        }\n\n        return this.defaultDocumentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getDefaultStringEntityReferenceSerializer()\n    {\n        if (this.defaultStringEntityReferenceSerializer == null) {\n            this.defaultStringEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultStringEntityReferenceSerializer;\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    /**\n     * Privileged API allowing to access the underlying main XWiki Object\n     *\n     * @return Privileged Main XWiki Object\n     */\n    @Programming\n    public com.xpn.xwiki.XWiki getXWiki()\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki;\n        }\n\n        return null;\n    }\n\n    /**\n     * @return the status of the job initializing {@link com.xpn.xwiki.XWiki} instance\n     * @since 6.1M1\n     */\n    public XWikiInitializerJobStatus getJobStatus()\n    {\n        XWikiInitializerJob job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);\n\n        return job != null ? job.getStatus() : null;\n    }\n\n    /**\n     * @return the status of the job initializing the instance or the current wiki\n     * @since 8.4RC1\n     */\n    public JobStatus getCurrentInitializerJobStatus()\n    {\n        // Get XWiki initializer job\n        JobStatus jobStatus = getJobStatus();\n\n        if (jobStatus == null) {\n            return null;\n        }\n\n        // The XWiki initialization is not done yet\n        if (jobStatus.getState() != State.FINISHED) {\n            return jobStatus;\n        }\n\n        // If XWiki initialization did not failed\n        if (this.xwiki != null) {\n            // Get current wiki initializer job\n            Job wikiJob = this.xwiki.getWikiInitializerJob(this.context.getWikiId());\n\n            jobStatus = wikiJob != null ? wikiJob.getStatus() : null;\n        }\n\n        return jobStatus;\n    }\n\n    /**\n     * @return XWiki's version in the format <code>(version).(SVN build number)</code>, or \"Unknown version\" if it\n     *         failed to be retrieved\n     */\n    public String getVersion()\n    {\n        return this.xwiki.getVersion();\n    }\n\n    /**\n     * API Allowing to access the current request URL being requested.\n     *\n     * @return the URL\n     * @throws XWikiException failed to create the URL\n     */\n    public String getRequestURL() throws XWikiException\n    {\n        return getXWikiContext().getURLFactory().getRequestURL(getXWikiContext()).toString();\n    }\n\n    /**\n     * API Allowing to access the current request URL being requested as a relative URL.\n     *\n     * @return the URL\n     * @throws XWikiException failed to create the URL\n     * @since 4.0M1\n     */\n    public String getRelativeRequestURL() throws XWikiException\n    {\n        XWikiURLFactory urlFactory = getXWikiContext().getURLFactory();\n\n        return urlFactory.getURL(urlFactory.getRequestURL(getXWikiContext()), getXWikiContext());\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked before sending back the document.\n     * <p>\n     * This is a helper for document reference but you can use {@link #getEntityDocument(String, EntityType)} for any\n     * other kind of reference.\n     *\n     * @param documentReference the reference of the document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @see #getEntityDocument(String, EntityType)\n     */\n    public Document getDocument(String documentReference) throws XWikiException\n    {\n        DocumentReference reference;\n\n        // We ignore the passed full name if it's null to be backward compatible with previous behaviors.\n        if (documentReference != null) {\n            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't\n            // specified in the passed string, rather than use the current document's page name.\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(documentReference);\n        } else {\n            reference = getDefaultDocumentReferenceResolver().resolve(\"\");\n        }\n\n        return getDocument(reference);\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked before sending back the document.\n     *\n     * @param reference the reference of the document to be loaded\n     * @param type the type of the reference\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 10.6RC1\n     */\n    public Document getEntityDocument(String reference, EntityType type) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(reference, type, getXWikiContext());\n        if (!getContextualAuthorizationManager().hasAccess(Right.VIEW, doc.getDocumentReference())) {\n            return null;\n        }\n\n        return doc.newDocument(getXWikiContext());\n    }\n\n    /**\n     * Loads a Document from the database. Rights are checked before sending back the document.\n     *\n     * @param reference the reference of the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 2.3M1\n     */\n    public Document getDocument(DocumentReference reference) throws XWikiException\n    {\n        try {\n            XWikiDocument doc = this.xwiki.getDocument(reference, getXWikiContext());\n            if (this.xwiki.getRightService().hasAccessLevel(\"view\", getXWikiContext().getUser(),\n                doc.getPrefixedFullName(), getXWikiContext()) == false) {\n                return null;\n            }\n\n            return doc.newDocument(getXWikiContext());\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to access document [{}]. Root reason: [{}]\", reference,\n                ExceptionUtils.getRootCauseMessage(ex));\n            return new Document(new XWikiDocument(reference), getXWikiContext());\n        }\n    }\n\n    /**\n     * Loads a Document from the store. Rights are checked before sending back the document.\n     * <p>\n     * The passed reference can be anything. If if a document child, the document reference will be extracted from it.\n     * If it's a document parent it will be completed with the necessary default references (for example if it's a space\n     * reference it will load the space home page).\n     *\n     * @param reference the reference close to the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 7.1M2\n     */\n    public Document getDocument(EntityReference reference) throws XWikiException\n    {\n        return getDocument(this.xwiki.getDocumentReference(reference, getXWikiContext()));\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked on the author (contentAuthor) of the document containing\n     * the currently executing script before sending back the loaded document.\n     *\n     * @param fullName the full name of the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 2.3M2\n     */\n    public Document getDocumentAsAuthor(String fullName) throws XWikiException\n    {\n        DocumentReference reference;\n\n        // We ignore the passed full name if it's null to match behavior of getDocument\n        if (fullName != null) {\n            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't\n            // specified in the passed string, rather than use the current document's page name.\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);\n        } else {\n            reference = getDefaultDocumentReferenceResolver().resolve(\"\");\n        }\n\n        return getDocumentAsAuthor(reference);\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked on the author (contentAuthor) of the document containing\n     * the currently executing script before sending back the loaded document.\n     *\n     * @param reference the reference of the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 2.3M2\n     */\n    public Document getDocumentAsAuthor(DocumentReference reference) throws XWikiException\n    {\n        if (!getAuthorizationManager().hasAccess(Right.VIEW, getEffectiveAuthorReference(), reference)) {\n            return null;\n        }\n\n        return this.xwiki.getDocument(reference, getXWikiContext()).newDocument(getXWikiContext());\n    }\n\n    /**\n     * @param fullname the {@link XWikiDocument#getFullName() name} of the document to search for.\n     * @param locale an optional {@link XWikiDocument#getLocale() locale} to filter results.\n     * @return A list with all the deleted versions of a document in the recycle bin.\n     * @throws XWikiException if any error\n     */\n    public List<DeletedDocument> getDeletedDocuments(String fullname, String locale) throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = this.xwiki.getDeletedDocuments(fullname, locale, this.context);\n        List<DeletedDocument> result = wrapDeletedDocuments(deletedDocuments);\n        return result;\n    }\n\n    /**\n     * @param batchId id of the operation that deleted multiple documents at the same time; useful when trying to revert\n     *            the operation\n     * @return a list of all document versions that were deleted in the same batch, as part of the same operation\n     * @throws XWikiException if any error\n     * @since 9.4RC1\n     */\n    public List<DeletedDocument> getDeletedDocuments(String batchId) throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = this.xwiki.getDeletedDocuments(batchId, this.context);\n        List<DeletedDocument> result = wrapDeletedDocuments(deletedDocuments);\n        return result;\n    }\n\n    private List<DeletedDocument> wrapDeletedDocuments(XWikiDeletedDocument[] deletedDocuments)\n    {\n        if (deletedDocuments == null || deletedDocuments.length == 0) {\n            return Collections.emptyList();\n        }\n\n        List<DeletedDocument> result = new ArrayList<>(deletedDocuments.length);\n        for (XWikiDeletedDocument deletedDocument : deletedDocuments) {\n            result.add(new DeletedDocument(deletedDocument, this.context));\n        }\n\n        return result;\n    }\n\n    /**\n     * @param fullname - {@link XWikiDocument#getFullName()}\n     * @param locale - {@link XWikiDocument#getLocale()}\n     * @param index - {@link XWikiDocument#getId()}\n     * @return the specified document from the recycle bin\n     * @throws XWikiException if any error\n     * @deprecated since 9.4RC1. Use {@link #getDeletedDocument(String)} instead.\n     */\n    @Deprecated\n    public DeletedDocument getDeletedDocument(String fullname, String locale, String index) throws XWikiException\n    {\n        return getDeletedDocument(index);\n    }\n\n    /**\n     * @return the specified document from the recycle bin\n     * @throws XWikiException if any error\n     * @since 9.4RC1\n     */\n    public DeletedDocument getDeletedDocument(String index) throws XWikiException\n    {\n        if (!NumberUtils.isDigits(index)) {\n            return null;\n        }\n\n        XWikiDeletedDocument dd = this.xwiki.getDeletedDocument(Long.parseLong(index), this.context);\n        if (dd == null) {\n            return null;\n        }\n\n        return new DeletedDocument(dd, this.context);\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document. Note that this does not distinguish\n     * between different incarnations of a document name, and it does not require that the document still exists, it\n     * returns all the attachments that at the time of their deletion had a document with the specified name as their\n     * owner.\n     *\n     * @param docName the {@link XWikiDocument#getFullName() name} of the owner document\n     * @return A list with all the deleted attachments which belonged to the specified document. If no such attachments\n     *         are found in the trash, an empty list is returned.\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName)\n    {\n        try {\n            List<com.xpn.xwiki.doc.DeletedAttachment> attachments =\n                this.xwiki.getDeletedAttachments(docName, this.context);\n            if (attachments == null || attachments.isEmpty()) {\n                attachments = Collections.emptyList();\n            }\n            List<DeletedAttachment> result = new ArrayList<DeletedAttachment>(attachments.size());\n            for (com.xpn.xwiki.doc.DeletedAttachment attachment : attachments) {\n                result.add(new DeletedAttachment(attachment, this.context));\n            }\n            return result;\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to retrieve deleted attachments\", ex);\n        }\n        return Collections.emptyList();\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document and had the specified name. Multiple\n     * versions can be returned since the same file can be uploaded and deleted several times, creating different\n     * instances in the trash. Note that this does not distinguish between different incarnations of a document name,\n     * and it does not require that the document still exists, it returns all the attachments that at the time of their\n     * deletion had a document with the specified name as their owner.\n     *\n     * @param docName the {@link DeletedAttachment#getDocName() name of the document} the attachment belonged to\n     * @param filename the {@link DeletedAttachment#getFilename() name} of the attachment to search for\n     * @return A list with all the deleted attachments which belonged to the specified document and had the specified\n     *         filename. If no such attachments are found in the trash, an empty list is returned.\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, String filename)\n    {\n        try {\n            List<com.xpn.xwiki.doc.DeletedAttachment> attachments =\n                this.xwiki.getDeletedAttachments(docName, filename, this.context);\n            if (attachments == null) {\n                attachments = Collections.emptyList();\n            }\n            List<DeletedAttachment> result = new ArrayList<DeletedAttachment>(attachments.size());\n            for (com.xpn.xwiki.doc.DeletedAttachment attachment : attachments) {\n                result.add(new DeletedAttachment(attachment, this.context));\n            }\n            return result;\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to retrieve deleted attachments\", ex);\n        }\n        return Collections.emptyList();\n    }\n\n    /**\n     * Retrieve a specific attachment from the trash.\n     *\n     * @param id the unique identifier of the entry in the trash\n     * @return specified attachment from the trash, {@code null} if not found\n     */\n    public DeletedAttachment getDeletedAttachment(String id)\n    {\n        try {\n            com.xpn.xwiki.doc.DeletedAttachment attachment = this.xwiki.getDeletedAttachment(id, this.context);\n            if (attachment != null) {\n                return new DeletedAttachment(attachment, this.context);\n            }\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to retrieve deleted attachment\", ex);\n        }\n        return null;\n    }\n\n    /**\n     * Returns whether a document exists or not\n     *\n     * @param fullname Fullname of the XWiki document to be loaded\n     * @return true if the document exists, false if not\n     * @throws XWikiException\n     */\n    public boolean exists(String fullname) throws XWikiException\n    {\n        return this.xwiki.exists(fullname, getXWikiContext());\n    }\n\n    /**\n     * Returns whether a document exists or not\n     *\n     * @param reference the reference of the document to check for its existence\n     * @return true if the document exists, false if not\n     * @since 2.3M2\n     */\n    public boolean exists(DocumentReference reference) throws XWikiException\n    {\n        return this.xwiki.exists(reference, getXWikiContext());\n    }\n\n    /**\n     * Returns whether a page exists or not.\n     *\n     * @param reference the reference of the page to check for its existence\n     * @return true if the page exists, false if not\n     * @since 13.3RC1\n     * @since 12.10.7\n     */\n    @Unstable\n    public boolean exists(PageReference reference)\n    {\n        return this.xwiki.exists(reference, getXWikiContext());\n    }\n\n    /**\n     * Verify the rights the current user has on a document. If the document requires rights and the user is not\n     * authenticated he will be redirected to the login page.\n     *\n     * @param docname fullname of the document\n     * @param right right to check (\"view\", \"edit\", \"admin\", \"delete\")\n     * @return true if it exists\n     */\n    public boolean checkAccess(String docname, String right)\n    {\n        try {\n            DocumentReference docReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n            XWikiDocument doc = getXWikiContext().getWiki().getDocument(docReference, this.context);\n            return getXWikiContext().getWiki().checkAccess(right, doc, getXWikiContext());\n        } catch (XWikiException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked before sending back the document.\n     *\n     * @param space Space to use in case no space is defined in the provided <code>fullname</code>\n     * @param fullname the full name or relative name of the document to load\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     */\n    public Document getDocument(String space, String fullname) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(space, fullname, getXWikiContext());\n        if (this.xwiki.getRightService().hasAccessLevel(\"view\", getXWikiContext().getUser(), doc.getFullName(),\n            getXWikiContext()) == false) {\n            return null;\n        }\n\n        return doc.newDocument(getXWikiContext());\n    }\n\n    /**\n     * Load a specific revision of a document\n     *\n     * @param doc Document for which to load a specific revision\n     * @param rev Revision number\n     * @return Specific revision of a document\n     * @throws XWikiException is never thrown\n     */\n    public Document getDocument(Document doc, String rev) throws XWikiException\n    {\n        if (doc == null || doc.getDoc() == null) {\n            return null;\n        }\n\n        if (!getContextualAuthorizationManager().hasAccess(Right.VIEW, doc.getDocumentReference())) {\n            // Finally we return null, otherwise showing search result is a real pain\n            return null;\n        }\n\n        return doc.getDocumentRevision(rev);\n    }\n\n    /**\n     * Load a specific revision of a document\n     *\n     * @param reference Document for which to load a specific revision\n     * @param revision Revision number\n     * @return Specific revision of a document\n     * @throws XWikiException is never thrown\n     * @since 9.4RC1\n     */\n    public Document getDocument(DocumentReference reference, String revision) throws XWikiException\n    {\n        try {\n            if (reference != null && getContextualAuthorizationManager().hasAccess(Right.VIEW, reference)) {\n                XWikiDocument documentRevision = getDocumentRevisionProvider().getRevision(reference, revision);\n\n                if (documentRevision != null) {\n                    return new Document(documentRevision, this.context);\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to access revision [{}] of document {}\", revision, reference, e);\n        }\n\n        return null;\n    }\n\n    /**\n     * Output content in the edit content textarea\n     *\n     * @param content content to output\n     * @return the textarea text content\n     */\n    public String getTextArea(String content)\n    {\n        return com.xpn.xwiki.XWiki.getTextArea(content, getXWikiContext());\n    }\n\n    /**\n     * Get the list of available classes in the wiki\n     *\n     * @return list of classes names\n     * @throws XWikiException\n     */\n    public List<String> getClassList() throws XWikiException\n    {\n        return this.xwiki.getClassList(getXWikiContext());\n    }\n\n    /**\n     * Get the global MetaClass object\n     *\n     * @return MetaClass object\n     */\n    public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }\n\n    /**\n     * API allowing to search for document names matching a query. Examples:\n     * <ul>\n     * <li>Query: <code>where doc.space='Main' order by doc.creationDate desc</code>. Result: All the documents in space\n     * 'Main' ordered by the creation date from the most recent</li>\n     * <li>Query: <code>where doc.name like '%sport%' order by doc.name asc</code>. Result: All the documents containing\n     * 'sport' in their name ordered by document name</li>\n     * <li>Query: <code>where doc.content like '%sport%' order by doc.author</code> Result: All the documents containing\n     * 'sport' in their content ordered by the author</li>\n     * <li>Query: <code>where doc.creator = 'XWiki.LudovicDubost' order by doc.creationDate\n     *       desc</code>. Result: All the documents with creator LudovicDubost ordered by the creation date from the\n     * most recent</li>\n     * <li>Query: <code>where doc.author = 'XWiki.LudovicDubost' order by doc.date desc</code>. Result: All the\n     * documents with last author LudovicDubost ordered by the last modification date from the most recent.</li>\n     * <li>Query: <code>,BaseObject as obj where doc.fullName=obj.name and\n     *       obj.className='XWiki.XWikiComments' order by doc.date desc</code>. Result: All the documents with at least\n     * one comment ordered by the last modification date from the most recent</li>\n     * <li>Query: <code>,BaseObject as obj, StringProperty as prop where\n     *       doc.fullName=obj.name and obj.className='XWiki.XWikiComments' and obj.id=prop.id.id\n     *       and prop.id.name='author' and prop.value='XWiki.LudovicDubost' order by doc.date\n     *       desc</code>. Result: All the documents with at least one comment from LudovicDubost ordered by the last\n     * modification date from the most recent</li>\n     * </ul>\n     *\n     * @param wheresql Query to be run (either starting with \", BaseObject as obj where..\" or by \"where ...\"\n     * @return List of document names matching (Main.Page1, Main.Page2)\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String wheresql) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(wheresql, getXWikiContext());\n    }\n\n    /**\n     * API allowing to search for document names matching a query return only a limited number of elements and skipping\n     * the first rows. The query part is the same as searchDocuments\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param nb return only 'nb' rows\n     * @param start skip the first 'start' rows\n     * @return List of document names matching\n     * @throws XWikiException\n     * @see List searchDocuments(String where sql)\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String wheresql, int nb, int start) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(wheresql, nb, start, getXWikiContext());\n    }\n\n    /**\n     * Privileged API allowing to search for document names matching a query return only a limited number of elements\n     * and skipping the first rows. The return values contain the list of columns specified in addition to the document\n     * space and name The query part is the same as searchDocuments\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param nb return only 'nb' rows\n     * @param start skip the first 'start' rows\n     * @param selectColumns List of columns to add to the result\n     * @return List of Object[] with the column values of the matching rows\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String wheresql, int nb, int start, String selectColumns) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.getStore().searchDocumentsNames(wheresql, nb, start, selectColumns, getXWikiContext());\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * API allowing to search for documents allowing to have mutliple entries per locale\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param distinctbylocale true to return multiple rows per locale\n     * @return List of Document object matching\n     * @throws XWikiException\n     */\n    public List<Document> searchDocuments(String wheresql, boolean distinctbylocale) throws XWikiException\n    {\n        return convert(this.xwiki.getStore().searchDocuments(wheresql, distinctbylocale, getXWikiContext()));\n    }\n\n    /**\n     * API allowing to search for documents allowing to have multiple entries per locale\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param distinctbylocale true to return multiple rows per locale\n     * @return List of Document object matching\n     * @param nb return only 'nb' rows\n     * @param start skip the first 'start' rows\n     * @throws XWikiException\n     */\n    public List<Document> searchDocuments(String wheresql, boolean distinctbylocale, int nb, int start)\n        throws XWikiException\n    {\n        return convert(this.xwiki.getStore().searchDocuments(wheresql, distinctbylocale, nb, start, getXWikiContext()));\n    }\n\n    /**\n     * Search documents by passing HQL where clause values as parameters. This allows generating a Named HQL query which\n     * will automatically encode the passed values (like escaping single quotes). This API is recommended to be used\n     * over the other similar methods where the values are passed inside the where clause and for which you'll need to\n     * do the encoding/escaping yourself before calling them.\n     * <p>\n     * Example\n     * </p>\n     *\n     * <pre>\n     * &lt;code&gt;\n     * #set($orphans = $xwiki.searchDocuments(&quot; where doc.fullName &lt;&gt; ?1 and (doc.parent = ?2 or &quot;\n     *     + &quot;(doc.parent = ?3 and doc.space = ?4))&quot;,\n     *     [&quot;${doc.fullName}as&quot;, ${doc.fullName}, ${doc.name}, ${doc.space}]))\n     * &lt;/code&gt;\n     * </pre>\n     *\n     * @param parameterizedWhereClause the HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param maxResults the number of rows to return. If 0 then all rows are returned\n     * @param startOffset the number of rows to skip. If 0 don't skip any row\n     * @param parameterValues the where clause values that replace the question marks (?1, ?2, etc.)\n     * @return a list of document names\n     * @throws XWikiException in case of error while performing the query\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, int maxResults, int startOffset,\n        List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, maxResults, startOffset,\n            parameterValues, getXWikiContext());\n    }\n\n    /**\n     * Same as {@link #searchDocuments(String, int, int, java.util.List)} but returns all rows.\n     *\n     * @see #searchDocuments(String, int, int, java.util.List)\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }\n\n    /**\n     * Search documents in the provided wiki by passing HQL where clause values as parameters. See\n     * {@link #searchDocuments(String, int, int, java.util.List)} for more details.\n     *\n     * @param wikiName the name of the wiki where to search.\n     * @param parameterizedWhereClause the HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param maxResults the number of rows to return. If 0 then all rows are returned\n     * @param startOffset the number of rows to skip. If 0 don't skip any row\n     * @param parameterValues the where clause values that replace the question marks (?)\n     * @return a list of document full names (Space.Name).\n     * @see #searchDocuments(String, int, int, java.util.List)\n     * @throws XWikiException in case of error while performing the query\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }\n\n    /**\n     * Search spaces by passing HQL where clause values as parameters. See\n     * {@link #searchDocuments(String, int, int, List)} for more about parameterized hql clauses.\n     *\n     * @param parametrizedSqlClause the HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param nb the number of rows to return. If 0 then all rows are returned\n     * @param start the number of rows to skip. If 0 don't skip any row\n     * @param parameterValues the where clause values that replace the question marks (?)\n     * @return a list of spaces names.\n     * @throws XWikiException in case of error while performing the query\n     */\n    public List<String> searchSpacesNames(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parametrizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }\n\n    /**\n     * Search attachments by passing HQL where clause values as parameters. See\n     * {@link #searchDocuments(String, int, int, List)} for more about parameterized hql clauses. You can specify\n     * properties of attach (the attachment) or doc (the document it is attached to)\n     *\n     * @param parametrizedSqlClause The HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param nb The number of rows to return. If 0 then all rows are returned\n     * @param start The number of rows to skip at the beginning.\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @return A List of {@link Attachment} objects.\n     * @throws XWikiException in case of error while performing the query\n     * @since 5.0M2\n     */\n    public List<Attachment> searchAttachments(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return convertAttachments(\n            this.xwiki.searchAttachments(parametrizedSqlClause, true, nb, start, parameterValues, this.context));\n    }\n\n    /**\n     * Count attachments returned by a given parameterized query\n     *\n     * @param parametrizedSqlClause Everything which would follow the \"WHERE\" in HQL see:\n     *            {@link #searchDocuments(String, int, int, List)}\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @return int number of attachments found.\n     * @throws XWikiException\n     * @see #searchAttachments(String, int, int, List)\n     * @since 5.0M2\n     */\n    public int countAttachments(String parametrizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.countAttachments(parametrizedSqlClause, parameterValues, this.context);\n    }\n\n    /**\n     * Function to wrap a list of XWikiDocument into Document objects\n     *\n     * @param docs list of XWikiDocument\n     * @return list of Document objects\n     */\n    public List<Document> wrapDocs(List<?> docs)\n    {\n        List<Document> result = new ArrayList<Document>();\n        if (docs != null) {\n            for (java.lang.Object obj : docs) {\n                try {\n                    if (obj instanceof XWikiDocument) {\n                        XWikiDocument doc = (XWikiDocument) obj;\n                        Document wrappedDoc = doc.newDocument(getXWikiContext());\n                        result.add(wrappedDoc);\n                    } else if (obj instanceof Document) {\n                        result.add((Document) obj);\n                    } else if (obj instanceof String) {\n                        Document doc = getDocument(obj.toString());\n                        if (doc != null) {\n                            result.add(doc);\n                        }\n                    }\n                } catch (XWikiException ex) {\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * API allowing to parse a text content to evaluate velocity scripts\n     *\n     * @param content\n     * @return evaluated content if the content contains velocity scripts\n     * @deprecated Since 7.2M1. Use specific rendering/parsing options for the content type you want to parse/render.\n     */\n    @Deprecated\n    public String parseContent(String content)\n    {\n        return this.xwiki.parseContent(content, getXWikiContext());\n    }\n\n    /**\n     * API to parse a velocity template provided by the current Skin The template is first looked in the skin active for\n     * the user, the space or the wiki. If the template does not exist in that skin, the template is looked up in the\n     * \"parent skin\" of the skin\n     *\n     * @param template Template name (\"view\", \"edit\", \"comment\")\n     * @return Evaluated content from the template\n     */\n    public String parseTemplate(String template)\n    {\n        return this.xwiki.parseTemplate(template, getXWikiContext());\n    }\n\n    /**\n     * API to render a velocity template provided by the current Skin The template is first looked in the skin active\n     * for the user, the space or the wiki. If the template does not exist in that skin, the template is looked up in\n     * the \"parent skin\" of the skin\n     *\n     * @param template Template name (\"view\", \"edit\", \"comment\")\n     * @return Evaluated content from the template\n     */\n    public String renderTemplate(String template)\n    {\n        return this.xwiki.renderTemplate(template, getXWikiContext());\n    }\n\n    /**\n     * Return the URL of the static file provided by the current skin The file is first looked in the skin active for\n     * the user, the space or the wiki. If the file does not exist in that skin, the file is looked up in the \"parent\n     * skin\" of the skin. The file can be a CSS file, an image file, a javascript file, etc.\n     *\n     * @param filename Filename to be looked up in the skin (logo.gif, style.css)\n     * @return URL to access this file\n     */\n    public String getSkinFile(String filename)\n    {\n        return this.xwiki.getSkinFile(filename, getXWikiContext());\n    }\n\n    /**\n     * Return the URL of the static file provided by the current skin The file is first looked in the skin active for\n     * the user, the space or the wiki. If the file does not exist in that skin, the file is looked up in the \"parent\n     * skin\" of the skin. The file can be a CSS file, an image file, a javascript file, etc.\n     *\n     * @param filename Filename to be looked up in the skin (logo.gif, style.css)\n     * @param forceSkinAction true to make sure that static files are retrieved through the skin action, to allow\n     *            parsing of velocity on CSS files\n     * @return URL to access this file\n     */\n    public String getSkinFile(String filename, boolean forceSkinAction)\n    {\n        return this.xwiki.getSkinFile(filename, forceSkinAction, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the current skin for this request and user The skin is first derived from the request \"skin\"\n     * parameter If this parameter does not exist, the user preference \"skin\" is looked up If this parameter does not\n     * exist or is empty, the space preference \"skin\" is looked up If this parameter does not exist or is empty, the\n     * XWiki preference \"skin\" is looked up If this parameter does not exist or is empty, the xwiki.cfg parameter\n     * xwiki.defaultskin is looked up If this parameter does not exist or is empty, the xwiki.cfg parameter\n     * xwiki.defaultbaseskin is looked up If this parameter does not exist or is empty, the skin is \"colibri\"\n     *\n     * @return The current skin for this request and user\n     */\n    public String getSkin()\n    {\n        return this.xwiki.getSkin(getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the current skin for this request and user. Each skin has a skin it is based on. If not the base\n     * skin is the xwiki.cfg parameter \"xwiki.defaultbaseskin\". If this parameter does not exist or is empty, the base\n     * skin is \"colibri\".\n     *\n     * @return The current baseskin for this request and user\n     */\n    public String getBaseSkin()\n    {\n        return this.xwiki.getBaseSkin(getXWikiContext());\n    }\n\n    /**\n     * API to access the copyright for this space. The copyright is read in the space preferences. If it does not exist\n     * or is empty it is read from the XWiki preferences.\n     *\n     * @return the text for the copyright\n     */\n    public String getSpaceCopyright()\n    {\n        return this.xwiki.getSpaceCopyright(getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getXWikiPreference(String preference)\n    {\n        return this.xwiki.getXWikiPreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale\n     */\n    public String getXWikiPreference(String preference, String defaultValue)\n    {\n        return this.xwiki.getXWikiPreference(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an Space Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale If no preference is found it will look in the XWiki\n     * Preferences\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getSpacePreference(String preference)\n    {\n        return this.xwiki.getSpacePreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access an Space Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale If no preference is found it will look in the XWiki\n     * Preferences\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale\n     */\n    public String getSpacePreference(String preference, String defaultValue)\n    {\n        return this.xwiki.getSpacePreference(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access a Skin Preference The skin object is the current user's skin\n     *\n     * @param preference Preference name\n     * @return The preference for the current skin\n     */\n    public String getSkinPreference(String preference)\n    {\n        return this.xwiki.getSkinPreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a Skin Preference The skin object is the current user's skin\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for the current skin\n     */\n    public String getSkinPreference(String preference, String defaultValue)\n    {\n        return this.xwiki.getSkinPreference(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     *\n     * @param preference Preference name\n     * @param space The space for which this preference is requested\n     * @return The preference for this wiki and the current locale\n     */\n    public String getSpacePreferenceFor(String preference, String space)\n    {\n        return getSpacePreferenceFor(preference, space, \"\");\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     *\n     * @param preference Preference name\n     * @param space The space for which this preference is requested\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public String getSpacePreferenceFor(String preference, String space, String defaultValue)\n    {\n        return this.xwiki.getSpacePreference(preference, space, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     * \n     * @param preference the name of the preference key\n     * @param spaceReference the reference of the space\n     * @return the value of the preference or empty String if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreferenceFor(String preference, SpaceReference spaceReference)\n    {\n        return this.xwiki.getSpacePreference(preference, spaceReference, getXWikiContext());\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     * \n     * @param preference the name of the preference key\n     * @param spaceReference the reference of the space\n     * @param defaultValue the value to return if the preference can't be found\n     * @return the value of the preference or <code>defaultValue</code> if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreferenceFor(String preference, SpaceReference spaceReference, String defaultValue)\n    {\n        return this.xwiki.getSpacePreference(preference, spaceReference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getXWikiPreferenceAsLong(String preference, long defaultValue)\n    {\n        return this.xwiki.getXWikiPreferenceAsLong(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getXWikiPreferenceAsLong(String preference)\n    {\n        return this.xwiki.getXWikiPreferenceAsLong(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a Space Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale If no preference is found it will\n     * look for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the prefenrece does not exist or is empty\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getSpacePreferenceAsLong(String preference, long defaultValue)\n    {\n        return this.xwiki.getSpacePreferenceAsLong(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access a Space Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale If no preference is found it will\n     * look for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getSpacePreferenceAsLong(String preference)\n    {\n        return this.xwiki.getSpacePreferenceAsLong(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as an int number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the prefenrece does not exist or is empty\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getXWikiPreferenceAsInt(String preference, int defaultValue)\n    {\n        return this.xwiki.getXWikiPreferenceAsInt(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as a int number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getXWikiPreferenceAsInt(String preference)\n    {\n        return this.xwiki.getXWikiPreferenceAsInt(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a space Preference as a int number There can be one preference object per locale This function will\n     * find the right preference object associated to the current active locale If no preference is found it will look\n     * for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the prefenrece does not exist or is empty\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getSpacePreferenceAsInt(String preference, int defaultValue)\n    {\n        return this.xwiki.getSpacePreferenceAsInt(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access a Space Preference as a int number There can be one preference object per locale This function will\n     * find the right preference object associated to the current active locale If no preference is found it will look\n     * for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getSpacePreferenceAsInt(String preference)\n    {\n        return this.xwiki.getSpacePreferenceAsInt(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a User Preference This function will look in the User profile for the preference If no preference\n     * is found it will look in the Space Preferences If no preference is found it will look in the XWiki Preferences\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getUserPreference(String preference)\n    {\n        return this.xwiki.getUserPreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a User Preference from cookie This function will look in the session cookie for the preference\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getUserPreferenceFromCookie(String preference)\n    {\n        return this.xwiki.getUserPreferenceFromCookie(preference, getXWikiContext());\n    }\n\n    /**\n     * Same as {@link #getLocalePreference()} but as a String.\n     *\n     * @return the locale to use\n     * @deprecated since 8.0M1, use {@link #getLocalePreference()} instead\n     */\n    @Deprecated\n    public String getLanguagePreference()\n    {\n        return this.xwiki.getLanguagePreference(getXWikiContext());\n    }\n\n    /**\n     * First try to find the current locale in use from the XWiki context. If none is used and if the wiki is not\n     * multilingual use the default locale defined in the XWiki preferences. If the wiki is multilingual try to get the\n     * locale passed in the request. If none was passed try to get it from a cookie. If no locale cookie exists then use\n     * the user default locale and barring that use the browser's \"Accept-Language\" header sent in HTTP request. If none\n     * is defined use the default locale.\n     *\n     * @return the locale to use\n     * @since 8.0M1\n     */\n    public Locale getLocalePreference()\n    {\n        return this.xwiki.getLocalePreference(getXWikiContext());\n    }\n\n    /**\n     * Same as {@link #getInterfaceLocalePreference()} but as a String.\n     *\n     * @return the document locale preference for the request\n     * @deprecated since 8.0M1, use {@link #getInterfaceLocalePreference()} instead\n     */\n    @Deprecated\n    public String getInterfaceLanguagePreference()\n    {\n        return this.xwiki.getInterfaceLanguagePreference(getXWikiContext());\n    }\n\n    /**\n     * API to access the interface locale preference for the request Order of evaluation is: locale of the wiki in\n     * mono-lingual mode locale request parameter locale in context locale user preference locale in cookie locale\n     * accepted by the navigator\n     *\n     * @return the document locale preference for the request\n     */\n    public Locale getInterfaceLocalePreference()\n    {\n        return this.xwiki.getInterfaceLocalePreference(getXWikiContext());\n    }\n\n    /**\n     * Get the available locales according to the preferences.\n     *\n     * @return the list of available locales\n     * @since 12.4RC1\n     */\n    public List<Locale> getAvailableLocales()\n    {\n        return this.xwiki.getAvailableLocales(getXWikiContext());\n    }\n\n    /**\n     * @return the list of all wiki names, including the main wiki, corresponding to the available wiki descriptors.\n     *         Example: the descriptor for the wiki <i>wikiname</i> is a document in the main wiki, named\n     *         <i>XWiki.XWikiServerWikiname</i>, containing an XWiki.XWikiServerClass object.\n     * @see com.xpn.xwiki.XWiki#getVirtualWikisDatabaseNames(XWikiContext)\n     */\n    public List<String> getWikiNames()\n    {\n        List<String> result = new ArrayList<String>();\n\n        try {\n            result = this.xwiki.getVirtualWikisDatabaseNames(getXWikiContext());\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to get the list of all wiki names\", e);\n        }\n\n        return result;\n    }\n\n    /**\n     * Convenience method to ask if the current XWiki instance contains subwikis (in addition to the main wiki)\n     *\n     * @return true if at least 1 subwiki exists; false otherwise\n     * @see #getWikiNames()\n     */\n    public boolean hasSubWikis()\n    {\n        return getWikiNames().size() > 1;\n    }\n\n    /**\n     * API to check is wiki is multi-lingual\n     *\n     * @return true for multi-lingual/false for mono-lingual\n     */\n    public boolean isMultiLingual()\n    {\n        return this.xwiki.isMultiLingual(getXWikiContext());\n    }\n\n    /**\n     * Privileged API to flush the cache of the Wiki installation This flushed the cache of all wikis, all plugins, all\n     * renderers\n     */\n    public void flushCache()\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.flushCache(getXWikiContext());\n        }\n    }\n\n    /**\n     * Privileged API to create a new user from the request This API is used by RegisterNewUser wiki page\n     *\n     * @return the integer status code\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-2: passwords are different or password is empty</li>\n     *         <li>-3: user already exists</li>\n     *         <li>-4: invalid username provided</li>\n     *         <li>-8: user already exists</li>\n     *         </ul>\n     * @throws XWikiException\n     */\n    public int createUser() throws XWikiException\n    {\n        return createUser(false, \"edit\");\n    }\n\n    /**\n     * Privileged API to create a new user from the request This API is used by RegisterNewUser wiki page This version\n     * sends a validation email to the user Configuration of validation email is in the XWiki Preferences\n     *\n     * @param withValidation true to send the validationemail\n     * @return the integer status code\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-2: passwords are different or password is empty</li>\n     *         <li>-3: user already exists</li>\n     *         <li>-4: invalid username provided</li>\n     *         <li>-8: user already exists</li>\n     *         </ul>\n     * @throws XWikiException\n     */\n    public int createUser(boolean withValidation) throws XWikiException\n    {\n        return createUser(withValidation, \"edit\");\n    }\n\n    /**\n     * Privileged API to create a new user from the request.\n     * <p>\n     * This API is used by the RegisterNewUser wiki page.\n     * <p>\n     * This version sends a validation email to the user. Configuration of validation email is in the XWiki Preferences.\n     *\n     * @param withValidation true to send the validation email\n     * @param userRights Rights to set for the user for it's own page(defaults to \"edit\")\n     * @return the integer status code\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-2: passwords are different or password is empty</li>\n     *         <li>-3: user already exists</li>\n     *         <li>-4: invalid username provided</li>\n     *         <li>-8: user already exists</li>\n     *         </ul>\n     * @throws XWikiException\n     */\n    public int createUser(boolean withValidation, String userRights) throws XWikiException\n    {\n        boolean registerRight;\n        try {\n            // So, what's the register right for? This says that if the creator of the page\n            // (Admin) has programming rights, anybody can register. Is this OK?\n            if (hasProgrammingRights()) {\n                registerRight = true;\n            } else {\n                registerRight = this.xwiki.getRightService().hasAccessLevel(\"register\", getXWikiContext().getUser(),\n                    \"XWiki.XWikiPreferences\", getXWikiContext());\n            }\n\n            if (registerRight) {\n                return this.xwiki.createUser(withValidation, userRights, getXWikiContext());\n            }\n\n            return -1;\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create user\", e);\n\n            return -10;\n        }\n\n    }\n\n    /**\n     * Privileged API to validate the return code given by a user in response to an email validation email The\n     * validation information are taken from the request object\n     *\n     * @param withConfirmEmail true to send a account confirmation email/false to not send it\n     * @return Success of Failure code (0 for success, -1 for missing programming rights, &gt; 0 for other errors\n     * @throws XWikiException\n     */\n    public int validateUser(boolean withConfirmEmail) throws XWikiException\n    {\n        return this.xwiki.validateUser(withConfirmEmail, getXWikiContext());\n    }\n\n    /**\n     * Privileged API to add a user to the XWiki.XWikiAllGroup\n     *\n     * @param fullwikiname user name to add\n     * @throws XWikiException\n     */\n    public void addToAllGroup(String fullwikiname) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.setUserDefaultGroup(fullwikiname, getXWikiContext());\n        }\n    }\n\n    /**\n     * Privileged API to send a confirmation email to a user\n     *\n     * @param xwikiname user to send the email to\n     * @param password password to put in the mail\n     * @param email email to send to\n     * @param add_message Additional message to send to the user\n     * @param contentfield Preference field to use as a mail template\n     * @throws XWikiException if the mail was not send successfully\n     */\n    public void sendConfirmationMail(String xwikiname, String password, String email, String add_message,\n        String contentfield) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.sendConfirmationEmail(xwikiname, password, email, add_message, contentfield, getXWikiContext());\n        }\n    }\n\n    /**\n     * Privileged API to send a confirmation email to a user\n     *\n     * @param xwikiname user to send the email to\n     * @param password password to put in the mail\n     * @param email email to send to\n     * @param contentfield Preference field to use as a mail template\n     * @throws XWikiException if the mail was not send successfully\n     */\n    public void sendConfirmationMail(String xwikiname, String password, String email, String contentfield)\n        throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.sendConfirmationEmail(xwikiname, password, email, \"\", contentfield, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to rename a document to another document.\n     * Note that the list of backlinks can be retrieved with {@link Document#getBackLinkedReferences()}\n     * and the list of children with {@link Document#getChildrenReferences()}.\n     *\n     * <strong>Warning:</strong> Be aware that this method never triggers any event related to the rename\n     * of the document. If you want the right events to be sent for the event, please use the dedicated Refactoring\n     * Module API (see\n     * {@link org.xwiki.refactoring.script.RequestFactory#createRenameRequest(EntityReference, EntityReference)}\n     * and {@link org.xwiki.refactoring.job.MoveRequest}).\n     *\n     * @param sourceDocumentReference the source document to rename.\n     * @param targetDocumentReference the target reference to rename the document to.\n     * @param overwrite if {@code true} the target document reference will be overwritten if it exists\n     *                  (deleted to the recycle bin before the rename). If {@code false} and the target document exist\n     *                  the rename won't be performed.\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *                                  modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *                                 document reference\n     * @return {@code true} if the rename succeeded. {@code false} if there was any issue.\n     * @throws XWikiException if the document cannot be renamed properly.\n     * @since 12.5RC1\n     */\n    public boolean renameDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean overwrite, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences) throws XWikiException\n    {\n        if (hasAccess(Right.DELETE, sourceDocumentReference)\n            && ((overwrite && hasAccess(Right.DELETE, targetDocumentReference))\n            || (!overwrite && hasAccess(Right.EDIT, targetDocumentReference)))) {\n            return this.xwiki.renameDocument(sourceDocumentReference, targetDocumentReference, overwrite,\n                backlinkDocumentReferences, childDocumentReferences, getXWikiContext());\n        }\n        return false;\n    }\n\n    /**\n     * API to copy a document to another document in the same wiki\n     *\n     * @param docname source document\n     * @param targetdocname target document\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname) throws XWikiException\n    {\n        return this.copyDocument(docname, targetdocname, null, null, null, false, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document in the same wiki\n     *\n     * @param docname source document\n     * @param targetdocname target document\n     * @param wikilocale locale to copy\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname, String wikilocale) throws XWikiException\n    {\n        return this.copyDocument(docname, targetdocname, null, null, wikilocale, false, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki\n     *\n     * @param docname source document\n     * @param sourceWiki source wiki\n     * @param targetWiki target wiki\n     * @param wikilocale locale to copy\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String sourceWiki, String targetWiki, String wikilocale)\n        throws XWikiException\n    {\n        return this.copyDocument(docname, docname, sourceWiki, targetWiki, wikilocale, true, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki additionally\n     * resetting the version\n     *\n     * @param docname source document\n     * @param sourceWiki source wiki\n     * @param targetWiki target wiki\n     * @param wikilocale locale to copy\n     * @param reset true to reset versions\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname, String sourceWiki, String targetWiki,\n        String wikilocale, boolean reset) throws XWikiException\n    {\n        return this.copyDocument(docname, targetdocname, sourceWiki, targetWiki, wikilocale, reset, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki additionally\n     * resetting the version and overwriting the previous document\n     *\n     * @param docname source document name\n     * @param targetdocname target document name\n     * @param sourceWiki source wiki\n     * @param targetWiki target wiki\n     * @param wikilocale locale to copy\n     * @param reset true to reset versions\n     * @param force true to overwrite the previous document\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname, String sourceWiki, String targetWiki,\n        String wikilocale, boolean reset, boolean force) throws XWikiException\n    {\n        DocumentReference sourceDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n        if (!StringUtils.isEmpty(sourceWiki)) {\n            sourceDocumentReference = sourceDocumentReference.replaceParent(sourceDocumentReference.getWikiReference(),\n                new WikiReference(sourceWiki));\n        }\n\n        DocumentReference targetDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(targetdocname);\n        if (!StringUtils.isEmpty(targetWiki)) {\n            targetDocumentReference = targetDocumentReference.replaceParent(targetDocumentReference.getWikiReference(),\n                new WikiReference(targetWiki));\n        }\n\n        return this.copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, force);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki additionally\n     * resetting the version and overwriting the previous document\n     *\n     * @param sourceDocumentReference the reference to the document to copy\n     * @param targetDocumentReference the reference to the document to create\n     * @param wikilocale locale to copy\n     * @param resetHistory {@code true} to reset versions\n     * @param overwrite {@code true} to overwrite the previous document\n     * @return {@code true} if the copy was sucessful\n     * @throws XWikiException if the document was not copied properly\n     * @since 3.0M3\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean resetHistory, boolean overwrite) throws XWikiException\n    {\n        // In order to copy the source document the user must have at least the right to view it.\n        if (hasAccessLevel(\"view\", getDefaultStringEntityReferenceSerializer().serialize(sourceDocumentReference))) {\n            String targetDocStringRef = getDefaultStringEntityReferenceSerializer().serialize(targetDocumentReference);\n            // To create the target document the user must have edit rights. If the target document exists and the user\n            // wants to overwrite it then he needs delete right.\n            // Note: We have to check if the target document exists before checking the delete right because delete\n            // right is denied if not explicitly specified.\n            if (hasAccessLevel(\"edit\", targetDocStringRef)\n                && (!overwrite || !exists(targetDocumentReference) || hasAccessLevel(\"delete\", targetDocStringRef))) {\n                // Reset creation data otherwise the required rights for page copy need to be reconsidered.\n                return this.xwiki.copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale,\n                    resetHistory, overwrite, true, getXWikiContext());\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Privileged API to copy a space to another wiki, optionally deleting all document of the target space\n     *\n     * @param space source Space\n     * @param sourceWiki source Wiki\n     * @param targetWiki target Wiki\n     * @param locale locale to copy\n     * @param clean true to delete all document of the target space\n     * @return number of copied documents\n     * @throws XWikiException if the space was not copied properly\n     */\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale, boolean clean)\n        throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.copySpaceBetweenWikis(space, sourceWiki, targetWiki, locale, clean, getXWikiContext());\n        }\n\n        return -1;\n    }\n\n    /**\n     * API to include a topic into another The topic is rendered fully in the context of itself\n     *\n     * @param topic page name of the topic to include\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeTopic(String topic) throws XWikiException\n    {\n        return includeTopic(topic, true);\n    }\n\n    /**\n     * API to execute a form in the context of an including topic The rendering is evaluated in the context of the\n     * including topic All velocity variables are the one of the including topic This api is usually called using\n     * #includeForm in a page, which modifies the behavior of \"Edit this page\" button to direct for Form mode (inline)\n     *\n     * @param topic page name of the form to execute\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeForm(String topic) throws XWikiException\n    {\n        return includeForm(topic, true);\n    }\n\n    /**\n     * API to include a topic into another, optionally surrounding the content with {pre}{/pre} to avoid future wiki\n     * rendering. The topic is rendered fully in the context of itself.\n     *\n     * @param topic page name of the topic to include\n     * @param pre true to add {pre} {/pre} (only if includer document is 1.0 syntax)\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeTopic(String topic, boolean pre) throws XWikiException\n    {\n        String result = this.xwiki.include(topic, false, getXWikiContext());\n\n        if (pre) {\n            String includerSyntax = this.xwiki.getCurrentContentSyntaxId(null, this.context);\n\n            if (includerSyntax != null && Syntax.XWIKI_1_0.toIdString().equals(includerSyntax)) {\n                result = \"{pre}\" + result + \"{/pre}\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * API to execute a form in the context of an including topic, optionnaly surrounding the content with {pre}{/pre}\n     * to avoid future wiki rendering The rendering is evaluated in the context of the including topic All velocity\n     * variables are the one of the including topic This api is usually called using #includeForm in a page, which\n     * modifies the behavior of \"Edit this page\" button to direct for Form mode (inline).\n     *\n     * @param topic page name of the form to execute\n     * @param pre true to add {pre} {/pre} (only if includer document is 1.0 syntax)\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeForm(String topic, boolean pre) throws XWikiException\n    {\n        String result = this.xwiki.include(topic, true, getXWikiContext());\n\n        if (pre) {\n            String includerSyntax = this.xwiki.getCurrentContentSyntaxId(null, this.context);\n\n            if (includerSyntax != null && Syntax.XWIKI_1_0.toIdString().equals(includerSyntax)) {\n                result = \"{pre}\" + result + \"{/pre}\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * API to check rights on the current document for the current user\n     *\n     * @param level right to check (view, edit, comment, delete)\n     * @return true if right is granted/false if not\n     */\n    public boolean hasAccessLevel(String level)\n    {\n        return hasAccessLevel(level, getXWikiContext().getUser(), getXWikiContext().getDoc().getFullName());\n    }\n\n    /**\n     * API to check rights on a document for a given user\n     *\n     * @param level right to check (view, edit, comment, delete)\n     * @param user user for which to check the right\n     * @param docname document on which to check the rights\n     * @return true if right is granted/false if not\n     */\n    public boolean hasAccessLevel(String level, String user, String docname)\n    {\n        try {\n            return this.xwiki.getRightService().hasAccessLevel(level, user, docname, getXWikiContext());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * API to list all spaces in the current wiki.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @return a list of string representing all non-hidden spaces (ie spaces that have non-hidden pages) for the\n     *         current wiki\n     * @throws XWikiException if something went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaces() throws XWikiException\n    {\n        return this.xwiki.getSpaces(getXWikiContext());\n    }\n\n    /**\n     * API to list all documents in a space.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @param spaceReference the local reference of the space for which to return all non-hidden documents\n     * @return the list of document names (in the format {@code Space.Page}) for non-hidden documents in the specified\n     *         space\n     * @throws XWikiException if the loading went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaceDocsName(String spaceReference) throws XWikiException\n    {\n        return this.xwiki.getSpaceDocsName(spaceReference, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the current encoding of the wiki engine The encoding is stored in xwiki.cfg Default encoding is\n     * ISO-8891-1\n     *\n     * @return encoding active in this wiki\n     */\n    public String getEncoding()\n    {\n        return this.xwiki.getEncoding();\n    }\n\n    /**\n     * API to retrieve the URL of an attached file in a Wiki Document The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment) It\n     * is important to always use the URL functions to generate URL and never hardcode URLs\n     *\n     * @param fullname page name which includes the attached file\n     * @param filename attached filename to create a link for\n     * @return a URL as a string pointing to the filename\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getAttachmentURL(String fullname, String filename) throws XWikiException\n    {\n        if (StringUtils.isAnyEmpty(fullname, filename)) {\n            return \"\";\n        }\n\n        return this.xwiki.getAttachmentURL(fullname, filename, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in view mode The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment) It\n     * is important to always use the URL functions to generate URL and never hardcode URLs\n     *\n     * @param fullname the name of the document for which to return the URL for\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, \"view\", getXWikiContext());\n    }\n\n    /**\n     * Retrieve the URL of an entity using the default mode/action for that entity type. The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..). The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. For compatibility with any target environment (and especially the\n     * portlet environment) it is important to always use the URL functions to generate URLs and never hardcode URLs.\n     *\n     * @param reference the reference to the entity for which to return the URL\n     * @return a URL as a string pointing to the specified entity, using the default mode/action for that entity type\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an entity in any mode, optionally adding a query string The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The query string will be modified to be added in the way the\n     * environment needs it. It is important to not add the query string parameter manually after a URL. Some\n     * environments will not accept this (like the Portlet environment).\n     *\n     * @param reference the reference to the entity for which to return the URL for\n     * @param action the mode in which to access the entity (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @return a URL as a string pointing to the entity\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference, String action, String querystring) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, action, querystring, null, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in view mode The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment) It\n     * is important to always use the URL functions to generate URL and never hardcode URLs\n     *\n     * @param reference the reference to the document for which to return the URL for\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 2.3M2\n     */\n    public String getURL(DocumentReference reference) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, \"view\", getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in any mode. The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..). The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment). It\n     * is important to always use the URL functions to generate URL and never hardcode URLs.\n     *\n     * @param fullname the page name which includes the attached file\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible.\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname, String action) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, action, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of a Wiki Document in any mode, optionally adding a query string The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The query string will be modified to be added in the way the\n     * environment needs it. It is important to not add the query string parameter manually after a URL. Some\n     * environments will not accept this (like the Portlet environment).\n     *\n     * @param fullname the page name which includes the attached file\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname, String action, String querystring) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, action, querystring, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of a Wiki Document in any mode, optionally adding a query string The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The query string will be modified to be added in the way the\n     * environment needs it. It is important to not add the query string parameter manually after a URL. Some\n     * environments will not accept this (like the Portlet environment).\n     *\n     * @param reference the reference to the document for which to return the URL for\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 3.0M3\n     */\n    public String getURL(DocumentReference reference, String action, String querystring) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, action, querystring, null, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in any mode, optionally adding an anchor. The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The anchor will be modified to be added in the way the environment\n     * needs it. It is important to not add the anchor parameter manually after a URL. Some environments will not accept\n     * this (like the Portlet environment).\n     *\n     * @param fullname the page name which includes the attached file\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @param anchor the anchor that points at a location within the passed document name\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname, String action, String querystring, String anchor) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, action, querystring, anchor, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a viewable referer text for a referer Referers are URL where users have clicked on a link to an\n     * XWiki page Search engine referer URLs are transformed to a nicer view (Google: search query string) For other URL\n     * the http:// part is stripped\n     *\n     * @param referer referer URL to transform\n     * @return A viewable string\n     */\n    public String getRefererText(String referer)\n    {\n        try {\n            return this.xwiki.getRefererText(referer, getXWikiContext());\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * API to retrieve a viewable referer text for a referer with a maximum length Referers are URL where users have\n     * clicked on a link to an XWiki page Search engine referer URLs are transformed to a nicer view (Google: search\n     * query string) For other URL the http:// part is stripped\n     *\n     * @param referer referer URL to transform\n     * @param length Maximum length. \"...\" is added to the end of the text\n     * @return A viewable string\n     */\n    public String getShortRefererText(String referer, int length)\n    {\n        try {\n            return this.xwiki.getRefererText(referer, getXWikiContext()).substring(0, length);\n        } catch (Exception e) {\n            return this.xwiki.getRefererText(referer, getXWikiContext());\n        }\n    }\n\n    /**\n     * Generate and return an unescaped user display name.\n     *\n     * @param userReference the user reference\n     * @return the unescaped display user name\n     * @since 6.4RC1\n     */\n    public String getPlainUserName(DocumentReference userReference)\n    {\n        return this.xwiki.getPlainUserName(userReference, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed for the first name and last name of the user. The link\n     * will link to the page on the wiki where the user is registered\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user)\n    {\n        return this.xwiki.getUserName(user, null, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed with a custom view. The link will link to the page on the\n     * wiki where the user is registered. The formating is done using the format parameter which can contain velocity\n     * scripting and access all properties of the User profile using variables ($first_name $last_name $email $city)\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user, String format)\n    {\n        return this.xwiki.getUserName(user, format, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed for the first name and last name of the user. The link\n     * will link to the page on the local wiki even if the user is registered on a different wiki.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), null, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, null, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed with a custom view. The link will link to the page on the\n     * local wiki even if the user is registered on a different wiki. The formating is done using the format parameter\n     * which can contain velocity scripting and access all properties of the User profile using variables ($first_name\n     * $last_name $email $city)\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user, String format)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), format, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, format, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to retrieve a text representing the user with the first name and last name of the user. With the link param\n     * set to false it will not link to the user page With the link param set to true, the link will link to the page on\n     * the wiki where the user was registered.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user, boolean link)\n    {\n        return this.xwiki.getUserName(user, null, link, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a text representing the user with a custom view With the link param set to false it will not link\n     * to the user page. With the link param set to true, the link will link to the page on the wiki where the user was\n     * registered. The formating is done using the format parameter which can contain velocity scripting and access all\n     * properties of the User profile using variables ($first_name $last_name $email $city)\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user, String format, boolean link)\n    {\n        return this.xwiki.getUserName(user, format, link, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a text representing the user with the first name and last name of the user. With the link param\n     * set to false it will not link to the user page. With the link param set to true, the link will link to the page\n     * on the local wiki even if the user is registered on a different wiki.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user, boolean link)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), null, link, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, null, link, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to retrieve a text representing the user with a custom view. The formating is done using the format parameter\n     * which can contain velocity scripting and access all properties of the User profile using variables ($first_name\n     * $last_name $email $city). With the link param set to false it will not link to the user page. With the link param\n     * set to true, the link will link to the page on the local wiki even if the user is registered on a different wiki.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user, String format, boolean link)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), format, link, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, format, link, getXWikiContext());\n        }\n    }\n\n    public User getUser()\n    {\n        return this.xwiki.getUser(getXWikiContext());\n    }\n\n    public User getUser(String username)\n    {\n        return this.xwiki.getUser(username, getXWikiContext());\n    }\n\n    /**\n     * Retrieve a user from its document reference.\n     *\n     * @param userReference the reference of the user.\n     * @return the user corresponding to the reference.\n     * @since 11.8RC1\n     */\n    public User getUser(DocumentReference userReference)\n    {\n        return this.xwiki.getUser(userReference, getXWikiContext());\n    }\n\n    /**\n     * API allowing to format a date according to the default Wiki setting The date format is provided in the\n     * 'dateformat' parameter of the XWiki Preferences\n     *\n     * @param date date object to format\n     * @return A string with the date formating from the default Wiki setting\n     */\n    public String formatDate(Date date)\n    {\n        return this.xwiki.formatDate(date, null, getXWikiContext());\n    }\n\n    /**\n     * API allowing to format a date according to a custom format The date format is from java.text.SimpleDateFormat\n     * Example: \"dd/MM/yyyy HH:mm:ss\" or \"d MMM yyyy\" If the format is invalid the default format will be used to show\n     * the date\n     *\n     * @param date date to format\n     * @param format format of the date to be used\n     * @return the formatted date\n     * @see java.text.SimpleDateFormat\n     */\n    public String formatDate(Date date, String format)\n    {\n        return this.xwiki.formatDate(date, format, getXWikiContext());\n    }\n\n    /*\n     * Allow to read user setting providing the user timezone All dates will be expressed with this timezone @return the\n     * timezone\n     */\n    public String getUserTimeZone()\n    {\n        return this.xwiki.getUserTimeZone(this.context);\n    }\n\n    /**\n     * Returns a plugin from the plugin API. Plugin Rights can be verified. Note that although this API is a duplicate\n     * of {@link #getPlugin(String)} it used to provide an easy access from Velocity to XWiki plugins. Indeed Velocity\n     * has a feature in that if a class has a get method, using the dot notation will automatically call the get method\n     * for the class. See http://velocity.apache.org/engine/releases/velocity-1.5/user-guide.html#propertylookuprules.\n     * This this allows the following constructs: <code>$xwiki.pluginName.somePluginMethod()</code>\n     *\n     * @param name Name of the plugin to retrieve (either short of full class name)\n     * @return a plugin object\n     */\n    public Api get(String name)\n    {\n        return getPlugin(name);\n    }\n\n    /**\n     * Returns a plugin from the plugin API. Plugin Rights can be verified.\n     *\n     * @param name Name of the plugin to retrieve (either short of full class name)\n     * @return a plugin object\n     */\n    public Api getPlugin(String name)\n    {\n        return this.xwiki != null ? this.xwiki.getPluginApi(name, getXWikiContext()) : null;\n    }\n\n    /**\n     * Returns the Advertisement system from the preferences\n     *\n     * @return \"google\" or \"none\"\n     */\n    public String getAdType()\n    {\n        return this.xwiki.getAdType(getXWikiContext());\n    }\n\n    /**\n     * Returns the Advertisement client ID from the preferences\n     *\n     * @return an Ad affiliate ID\n     */\n    public String getAdClientId()\n    {\n        return this.xwiki.getAdClientId(getXWikiContext());\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL protected using Basic Authentication\n     *\n     * @param surl url to retrieve\n     * @param username username for the basic authentication\n     * @param password password for the basic authentication\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl, String username, String password) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, username, password, this.context);\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to retrieve content from [\" + surl + \"]\", e);\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL\n     *\n     * @param surl url to retrieve\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, this.context);\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to retrieve content from [\" + surl + \"]\", e);\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL protected using Basic Authentication\n     *\n     * @param surl url to retrieve\n     * @param username username for the basic authentication\n     * @param password password for the basic authentication\n     * @param timeout manuel timeout in milliseconds\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl, String username, String password, int timeout) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, username, password, timeout,\n                this.xwiki.getHttpUserAgent(this.context));\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL\n     *\n     * @param surl url to retrieve\n     * @param timeout manuel timeout in milliseconds\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl, int timeout) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, timeout, this.xwiki.getHttpUserAgent(this.context));\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL protected using Basic Authentication as Bytes\n     *\n     * @param surl url to retrieve\n     * @param username username for the basic authentication\n     * @param password password for the basic authentication\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public byte[] getURLContentAsBytes(String surl, String username, String password) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return null;\n        }\n\n        try {\n            return this.xwiki.getURLContentAsBytes(surl, username, password, this.context);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL as Bytes\n     *\n     * @param surl url to retrieve\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public byte[] getURLContentAsBytes(String surl) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return null;\n        }\n\n        try {\n            return this.xwiki.getURLContentAsBytes(surl, this.context);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the list of Macros documents in the specified content\n     *\n     * @param defaultSpace Default space to use for relative path names\n     * @param content Content to parse\n     * @return ArrayList of document names\n     */\n    public List<String> getIncludedMacros(String defaultSpace, String content)\n    {\n        return this.xwiki.getIncludedMacros(defaultSpace, content, getXWikiContext());\n    }\n\n    /**\n     * returns true if xwiki.readonly is set in the configuration file\n     *\n     * @return the value of xwiki.isReadOnly()\n     * @see com.xpn.xwiki.XWiki\n     */\n    public boolean isReadOnly()\n    {\n        return this.xwiki.isReadOnly();\n    }\n\n    /**\n     * Privileged API to set/unset the readonly status of the Wiki After setting this to true no writing to the database\n     * will be performed All Edit buttons will be removed and save actions disabled This is used for maintenance\n     * purposes\n     *\n     * @param ro true to set read-only mode/false to unset\n     */\n    public void setReadOnly(boolean ro)\n    {\n        if (hasAdminRights()) {\n            this.xwiki.setReadOnly(ro);\n        }\n    }\n\n    /**\n     * Priviledge API to regenerate the links/backlinks table Normally links and backlinks are stored when a page is\n     * modified This function will regenerate all the backlinks This function can be long to run\n     *\n     * @throws XWikiException exception if the generation fails\n     */\n    public void refreshLinks() throws XWikiException\n    {\n        if (hasAdminRights()) {\n            this.xwiki.refreshLinks(getXWikiContext());\n        }\n    }\n\n    /**\n     * API to check if the backlinks feature is active Backlinks are activated in xwiki.cfg or in the XWiki Preferences\n     *\n     * @return true if the backlinks feature is active\n     * @throws XWikiException exception if the preference could not be retrieved\n     */\n    public boolean hasBacklinks() throws XWikiException\n    {\n        return this.xwiki.hasBacklinks(getXWikiContext());\n    }\n\n    /**\n     * API to check if the tags feature is active. Tags are activated in xwiki.cfg or in the XWiki Preferences\n     *\n     * @return true if the tags feature is active, false otherwise\n     * @throws XWikiException exception if the preference could not be retrieved\n     */\n    public boolean hasTags() throws XWikiException\n    {\n        return this.xwiki.hasTags(getXWikiContext());\n    }\n\n    /**\n     * API to check if the edit comment feature is active Edit comments are activated in xwiki.cfg or in the XWiki\n     * Preferences\n     *\n     * @return\n     */\n    public boolean hasEditComment()\n    {\n        return this.xwiki.hasEditComment(this.context);\n    }\n\n    /**\n     * API to check if the edit comment field is shown in the edit form Edit comments are activated in xwiki.cfg or in\n     * the XWiki Preferences\n     *\n     * @return\n     */\n    public boolean isEditCommentFieldHidden()\n    {\n        return this.xwiki.isEditCommentFieldHidden(this.context);\n    }\n\n    /**\n     * API to check if the edit comment is suggested (prompted once by Javascript if empty) Edit comments are activated\n     * in xwiki.cfg or in the XWiki Preferences\n     *\n     * @return\n     */\n    public boolean isEditCommentSuggested()\n    {\n        return this.xwiki.isEditCommentSuggested(this.context);\n    }\n\n    /**\n     * API to check if the edit comment is mandatory (prompted by Javascript if empty) Edit comments are activated in\n     * xwiki.cfg or in the XWiki Preferences\n     *\n     * @return\n     */\n    public boolean isEditCommentMandatory()\n    {\n        return this.xwiki.isEditCommentMandatory(this.context);\n    }\n\n    /**\n     * API to check if the minor edit feature is active minor edit is activated in xwiki.cfg or in the XWiki Preferences\n     */\n    public boolean hasMinorEdit()\n    {\n        return this.xwiki.hasMinorEdit(this.context);\n    }\n\n    /**\n     * API to check if the recycle bin feature is active recycle bin is activated in xwiki.cfg or in the XWiki\n     * Preferences\n     */\n    public boolean hasRecycleBin()\n    {\n        return this.xwiki.hasRecycleBin(this.context);\n    }\n\n    /**\n     * Retrieves the current editor preference for the request The preference is first looked up in the user preference\n     * and then in the space and wiki preference\n     *\n     * @return \"wysiwyg\" or \"text\"\n     */\n    public String getEditorPreference()\n    {\n        return this.xwiki.getEditorPreference(getXWikiContext());\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String. Note that Groovy scripts\n     * compilation is cached.\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public java.lang.Object parseGroovyFromString(String script) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.parseGroovyFromString(script, getXWikiContext());\n        }\n        return \"groovy_missingrights\";\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String, using a classloader including all\n     * JAR files located in the passed page as attachments. Note that Groovy scripts compilation is cached\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public java.lang.Object parseGroovyFromPage(String script, String jarWikiPage) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(script, getXWikiContext());\n        if (this.xwiki.getRightService().hasProgrammingRights(doc, getXWikiContext())) {\n            return this.xwiki.parseGroovyFromString(doc.getContent(), jarWikiPage, getXWikiContext());\n        }\n        return \"groovy_missingrights\";\n    }\n\n    /**\n     * Privileged API to retrieve an object instanciated from groovy code in a String Groovy scripts compilation is\n     * cached\n     *\n     * @param fullname // script containing a Groovy class definition (public class MyClass { ... })\n     * @return An object instanciating this class\n     * @throws XWikiException\n     */\n    public java.lang.Object parseGroovyFromPage(String fullname) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(fullname, getXWikiContext());\n        if (this.xwiki.getRightService().hasProgrammingRights(doc, getXWikiContext())) {\n            return this.xwiki.parseGroovyFromString(doc.getContent(), getXWikiContext());\n        }\n        return \"groovy_missingrights\";\n    }\n\n    /**\n     * API to get the macro list from the XWiki Preferences The macro list are the macros available from the Macro\n     * Mapping System\n     *\n     * @return String with each macro on each line\n     */\n    public String getMacroList()\n    {\n        return this.xwiki.getMacroList(getXWikiContext());\n    }\n\n    /**\n     * API to check if using which toolbars in Wysiwyg editor\n     *\n     * @return a string value\n     */\n    public String getWysiwygToolbars()\n    {\n        return this.xwiki.getWysiwygToolbars(getXWikiContext());\n    }\n\n    /**\n     * API to create an object from the request The parameters are the ones that are created from\n     * doc.display(\"field\",\"edit\") calls\n     *\n     * @param className XWiki Class Name to create the object from\n     * @return a BaseObject wrapped in an Object\n     * @throws XWikiException exception if the object could not be read\n     */\n    public com.xpn.xwiki.api.Object getObjectFromRequest(String className) throws XWikiException\n    {\n        return new com.xpn.xwiki.api.Object(this.xwiki.getObjectFromRequest(className, getXWikiContext()),\n            getXWikiContext());\n    }\n\n    /**\n     * API to create an empty document\n     *\n     * @return an XWikiDocument wrapped in a Document\n     */\n    public Document createDocument()\n    {\n        return new XWikiDocument().newDocument(getXWikiContext());\n    }\n\n    /**\n     * API to convert the username depending on the configuration The username can be converted from email to a valid\n     * XWiki page name hidding the email address The username can be then used to login and link to the right user page\n     *\n     * @param username username to use for login\n     * @return converted wiki page name for this username\n     */\n    public String convertUsername(String username)\n    {\n        return this.xwiki.convertUsername(username, getXWikiContext());\n    }\n\n    /**\n     * API to get the Property object from a class based on a property path A property path looks like\n     * XWiki.ArticleClass_fieldname\n     *\n     * @param propPath Property path\n     * @return a PropertyClass object from a BaseClass object\n     */\n    public com.xpn.xwiki.api.PropertyClass getPropertyClassFromName(String propPath)\n    {\n        return new PropertyClass(this.xwiki.getPropertyClassFromName(propPath, getXWikiContext()), getXWikiContext());\n    }\n\n    /**\n     * Generates a unique page name based on initial page name and already existing pages\n     *\n     * @param name\n     * @return a unique page name\n     */\n    public String getUniquePageName(String name)\n    {\n        return this.xwiki.getUniquePageName(name, getXWikiContext());\n    }\n\n    /**\n     * Generates a unique page name based on initial page name and already existing pages\n     *\n     * @param space\n     * @param name\n     * @return a unique page name\n     */\n    public String getUniquePageName(String space, String name)\n    {\n        return this.xwiki.getUniquePageName(space, name, getXWikiContext());\n    }\n\n    /**\n     * Inserts a tooltip using toolTip.js\n     *\n     * @param html HTML viewed\n     * @param message HTML Tooltip message\n     * @param params Parameters in Javascropt added to the tooltip config\n     * @return HTML with working tooltip\n     */\n    public String addTooltip(String html, String message, String params)\n    {\n        return this.xwiki.addTooltip(html, message, params, getXWikiContext());\n    }\n\n    /**\n     * Inserts a tooltip using toolTip.js\n     *\n     * @param html HTML viewed\n     * @param message HTML Tooltip message\n     * @return HTML with working tooltip\n     */\n    public String addTooltip(String html, String message)\n    {\n        return this.xwiki.addTooltip(html, message, getXWikiContext());\n    }\n\n    /**\n     * Inserts the tooltip Javascript\n     *\n     * @return\n     */\n    public String addTooltipJS()\n    {\n        return this.xwiki.addTooltipJS(getXWikiContext());\n    }\n\n    /*\n     * Inserts a Mandatory asterix\n     */\n    public String addMandatory()\n    {\n        return this.xwiki.addMandatory(getXWikiContext());\n    }\n\n    /**\n     * Get the XWiki Class object defined in the passed Document name.\n     * <p>\n     * Note: This method doesn't require any rights for accessing the passed Document (as opposed to the\n     * {@link com.xpn.xwiki.api.Document#getClass()} method which does require to get a Document object first. This is\n     * thus useful in cases where the calling code doesn't have the access right to the specified Document. It is safe\n     * because there are no sensitive data stored in a Class definition.\n     * </p>\n     *\n     * @param documentName the name of the document for which to get the Class object. For example\n     *            \"XWiki.XWikiPreferences\"\n     * @return the XWiki Class object defined in the passed Document name. If the passed Document name points to a\n     *         Document with no Class defined then an empty Class object is returned (i.e. a Class object with no\n     *         properties).\n     * @throws XWikiException if the passed document name doesn't point to a valid Document\n     */\n    public Class getClass(String documentName) throws XWikiException\n    {\n        // TODO: The implementation should be done in com.xpn.xwiki.XWiki as this class should\n        // delegate all implementations to that Class.\n        DocumentReference docReference = getCurrentMixedDocumentReferenceResolver().resolve(documentName);\n        return getClass(docReference);\n    }\n\n    /**\n     * Get the XWiki Class object defined in the passed Document name.\n     * <p>\n     * Note: This method doesn't require any rights for accessing the passed Document (as opposed to the\n     * {@link com.xpn.xwiki.api.Document#getClass()} method which does require to get a Document object first. This is\n     * thus useful in cases where the calling code doesn't have the access right to the specified Document. It is safe\n     * because there are no sensitive data stored in a Class definition.\n     * </p>\n     *\n     * @param docReference the reference of the document for which to get the Class object.\n     * @return the XWiki Class object defined in the passed Document reference. If the passed Document name points to a\n     *         Document with no Class defined then an empty Class object is returned (i.e. a Class object with no\n     *         properties).\n     * @throws XWikiException if the reference doesn't exist.\n     * @since 10.11.10\n     * @since 11.8RC1\n     * @since 11.3.4\n     */\n    public Class getClass(EntityReference docReference) throws XWikiException\n    {\n        return new Class(this.xwiki.getDocument(docReference, this.context).getXClass(), this.context);\n    }\n\n    /**\n     * Provides an absolute counter\n     *\n     * @param name Counter name\n     * @return String\n     */\n    public String getCounter(String name)\n    {\n        XWikiEngineContext econtext = this.context.getEngineContext();\n        Integer counter = (Integer) econtext.getAttribute(name);\n        if (counter == null) {\n            counter = 0;\n        }\n        counter = counter.intValue() + 1;\n        econtext.setAttribute(name, counter);\n\n        return counter.toString();\n    }\n\n    /**\n     * Check authentication from request and set according persitent login information If it fails user is unlogged\n     *\n     * @return null if failed, non null XWikiUser if sucess\n     * @throws XWikiException\n     */\n    public XWikiUser checkAuth() throws XWikiException\n    {\n        return this.context.getWiki().getAuthService().checkAuth(this.context);\n    }\n\n    /**\n     * Check authentication from username and password and set according persitent login information If it fails user is\n     * unlogged\n     *\n     * @param username username to check\n     * @param password password to check\n     * @param rememberme \"1\" if you want to remember the login accross navigator restart\n     * @return null if failed, non null XWikiUser if sucess\n     * @throws XWikiException\n     */\n    public XWikiUser checkAuth(String username, String password, String rememberme) throws XWikiException\n    {\n        return this.context.getWiki().getAuthService().checkAuth(username, password, rememberme, this.context);\n    }\n\n    /**\n     * Access statistics api\n     *\n     * @return a StatsService instance that can be used to retrieve different xwiki statistics\n     */\n    public StatsService getStatsService()\n    {\n        return this.statsService;\n    }\n\n    /**\n     * API to get the xwiki criteria service which allow to create various criteria : integer ranges, date periods, date\n     * intervals, etc.\n     *\n     * @return the xwiki criteria service\n     */\n    public CriteriaService getCriteriaService()\n    {\n        return this.criteriaService;\n    }\n\n    /**\n     * API to get the Servlet path for a given wiki. In mono wiki this is \"bin/\" or \"xwiki/\". In virtual mode and if\n     * {@code xwiki.virtual.usepath} is enabled in xwiki.cfg, it is \"wiki/wikiname/\".\n     *\n     * @param wikiName wiki for which to get the path\n     * @return The servlet path\n     */\n    public String getServletPath(String wikiName)\n    {\n        return this.xwiki.getServletPath(wikiName, this.context);\n    }\n\n    /**\n     * API to get the Servlet path for the current wiki. In mono wiki this is \"bin/\" or \"xwiki/\". In virtual mode and if\n     * {@code xwiki.virtual.usepath} is enabled in xwiki.cfg, it is \"wiki/wikiname/\".\n     *\n     * @return The servlet path\n     */\n    public String getServletPath()\n    {\n        return this.xwiki.getServletPath(this.context.getWikiId(), this.context);\n    }\n\n    /**\n     * API to get the webapp path for the current wiki. This usually is \"xwiki/\". It can be configured in xwiki.cfg with\n     * the config {@code xwiki.webapppath}.\n     *\n     * @return The servlet path\n     */\n    public String getWebAppPath()\n    {\n        return this.xwiki.getWebAppPath(this.context);\n    }\n\n    /**\n     * @return the syntax id of the syntax to use when creating new documents.\n     */\n    public String getDefaultDocumentSyntax()\n    {\n        return this.xwiki.getDefaultDocumentSyntax();\n    }\n\n    /**\n     * Find the corresponding available renderer syntax.\n     * <p>\n     * If <code>syntaxVersion</code> is null the last version of the available provided syntax type is returned.\n     *\n     * @param syntaxType the syntax type\n     * @param syntaxVersion the syntax version\n     * @return the available corresponding {@link Syntax}. Null if no available renderer can be found.\n     */\n    public Syntax getAvailableRendererSyntax(String syntaxType, String syntaxVersion)\n    {\n        Syntax syntax = null;\n\n        try {\n            List<PrintRendererFactory> factories =\n                Utils.getContextComponentManager().getInstanceList((Type) PrintRendererFactory.class);\n            for (PrintRendererFactory factory : factories) {\n                Syntax factorySyntax = factory.getSyntax();\n                if (syntaxVersion != null) {\n                    if (factorySyntax.getType().getId().equalsIgnoreCase(syntaxType)\n                        && factorySyntax.getVersion().equals(syntaxVersion)) {\n                        syntax = factorySyntax;\n                        break;\n                    }\n                } else {\n                    // TODO: improve version comparaison since it does not work when comparing 2.0 and 10.0 for example.\n                    // We\n                    // should have a Version which implements Comparable like we have SyntaxId in Syntax\n                    if (factorySyntax.getType().getId().equalsIgnoreCase(syntaxType)\n                        && (syntax == null || factorySyntax.getVersion().compareTo(syntax.getVersion()) > 0)) {\n                        syntax = factorySyntax;\n                    }\n                }\n            }\n        } catch (ComponentLookupException e) {\n            LOGGER.error(\"Failed to lookup available renderer syntaxes\", e);\n        }\n\n        return syntax;\n    }\n\n    /**\n     * @return true if section editing is enabled (can be configured through the {@code xwiki.section.edit}\n     *         configuration property. Defaults to 1 (=enabled) when not defined\n     */\n    public boolean hasSectionEdit()\n    {\n        return this.xwiki.hasSectionEdit(getXWikiContext());\n    }\n\n    /**\n     * @return the section depth for which section editing is available (can be configured through\n     *         {@code xwiki.section.depth} configuration property. Defaults to 2 when not defined\n     */\n    public long getSectionEditingDepth()\n    {\n        return this.xwiki.getSectionEditingDepth();\n    }\n\n    /**\n     * @return true if title handling should be using the compatibility mode or not. When the compatibility mode is\n     *         active, if the document's content first header (level 1 or level 2) matches the document's title the\n     *         first header is stripped.\n     */\n    public boolean isTitleInCompatibilityMode()\n    {\n        return this.xwiki.isTitleInCompatibilityMode();\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId()\n    {\n        return this.xwiki.getCurrentContentSyntaxId(getXWikiContext());\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.user.api;\n\nimport java.util.Collection;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.WikiReference;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.web.Utils;\n\npublic class XWikiUser\n{\n    /**\n     * Class used to store user properties.\n     */\n    private static final String USER_CLASS = \"XWiki.XWikiUsers\";\n\n    /**\n     * The name of the property that store the active status of the user.\n     * \n     * @since 11.8RC1\n     */\n    public static final String ACTIVE_PROPERTY = \"active\";\n\n    /**\n     * The name of the property that store the information if an email was checked for the user.\n     * \n     * @since 11.8RC1\n     */\n    public static final String EMAIL_CHECKED_PROPERTY = \"email_checked\";\n\n    /**\n     * @see com.xpn.xwiki.internal.model.reference.CurrentMixedStringDocumentReferenceResolver\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    private EntityReferenceSerializer<String> localEntityReferenceSerializer;\n\n    private ContextualLocalizationManager localization;\n\n    private Logger logger = LoggerFactory.getLogger(XWikiUser.class);\n\n    private String fullName;\n\n    private boolean fullNameNull;\n\n    private DocumentReference userReference;\n\n    private boolean userReferenceSet;\n\n    private boolean main;\n\n    /**\n     * Create a XWikiUser from its document reference and infer if the user is global or not based on the wiki part of\n     * this reference. See {@link #isMain()} for more information.\n     * \n     * @param userReference the document reference of the user.\n     * @since 11.6RC1\n     */\n    public XWikiUser(DocumentReference userReference)\n    {\n        this(userReference,\n            userReference == null || XWiki.DEFAULT_MAIN_WIKI.equals(userReference.getWikiReference().getName()));\n    }\n\n    /**\n     * Create a XWikiUser from its document reference and set the main flag. (see {@link #isMain()}).\n     * \n     * @param userReference the document reference of the user.\n     * @param main true if the user is global (i.e. registered in the main wiki)\n     * @since 11.6RC1\n     */\n    public XWikiUser(DocumentReference userReference, boolean main)\n    {\n        this.userReference = userReference;\n        this.userReferenceSet = true;\n\n        setMain(main);\n    }\n\n    /**\n     * Create a XWikiUser for the given user.\n     * \n     * @param user the full name of the user on the form {@code XWiki.Foo}.\n     * @deprecated since 11.6RC1 use {@link #XWikiUser(DocumentReference)}.\n     */\n    @Deprecated\n    public XWikiUser(String user)\n    {\n        this(user, false);\n    }\n\n    /**\n     * Create a XWikiUser for the given user.\n     * \n     * @param user the full name of the user on the form {@code XWiki.Foo}.\n     * @param main true if the user is global (i.e. registered in the main wiki)\n     * @deprecated since 11.6RC1 use {@link #XWikiUser(DocumentReference, boolean)}.\n     */\n    @Deprecated\n    public XWikiUser(String user, boolean main)\n    {\n        setUser(user);\n        setMain(main);\n    }\n\n    private void setUserReference(DocumentReference userReference)\n    {\n        this.userReference = userReference;\n        this.userReferenceSet = true;\n    }\n\n    private String toFullName(DocumentReference userReference)\n    {\n        if (userReference != null) {\n            return getLocalEntityReferenceSerializer().serialize(userReference);\n        } else {\n            return XWikiRightService.GUEST_USER_FULLNAME;\n        }\n    }\n\n    private DocumentReference fromFullName(String fullName)\n    {\n        DocumentReference reference = null;\n\n        if (fullName != null && !fullName.endsWith(XWikiRightService.GUEST_USER_FULLNAME)\n            && !fullName.equals(XWikiRightService.GUEST_USER)) {\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);\n        }\n\n        return reference;\n    }\n\n    /**\n     * @return user fullname\n     * @deprecated since 11.6RC1 use {@link #getFullName()}.\n     */\n    @Deprecated\n    public String getUser()\n    {\n        return getFullName();\n    }\n\n    /**\n     * @return the fullname of the user like {@code XWiki.Foo}.\n     */\n    public String getFullName()\n    {\n        if (this.fullName == null && !this.fullNameNull) {\n            this.fullName = toFullName(this.userReference);\n            this.fullNameNull = this.fullName == null;\n        }\n\n        return this.fullName;\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (currentMixedDocumentReferenceResolver == null) {\n            currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n        return currentMixedDocumentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getLocalEntityReferenceSerializer()\n    {\n        if (localEntityReferenceSerializer == null) {\n            localEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n        return localEntityReferenceSerializer;\n    }\n\n    private ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    private String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    public DocumentReference getUserReference()\n    {\n        if (!this.userReferenceSet) {\n            setUserReference(fromFullName(getUser()));\n        }\n\n        return this.userReference;\n    }\n\n    private DocumentReference getUserClassReference(WikiReference userDocWiki)\n    {\n        return getCurrentMixedDocumentReferenceResolver().resolve(userDocWiki.getName() + \":\" + USER_CLASS);\n    }\n\n    private boolean isGuest()\n    {\n        return XWikiRightService.isGuest(getUserReference());\n    }\n\n    private boolean isSuperAdmin()\n    {\n        return XWikiRightService.isSuperAdmin(getUserReference());\n    }\n\n    private XWikiDocument getUserDocument(XWikiContext context) throws XWikiException\n    {\n        return context.getWiki().getDocument(getUserReference(), context);\n    }\n\n    /**\n     * @param context used to retrieve the user document.\n     * @return true if the user is email have been checked before. This always returns true if the user is the guest or\n     *         superadmin user.\n     * @since 11.8RC1\n     */\n    public boolean isEmailChecked(XWikiContext context)\n    {\n        boolean isChecked;\n        // These users are necessarily active. Note that superadmin might be main-wiki-prefixed when in a subwiki.\n        if (isGuest() || isSuperAdmin()) {\n            isChecked = true;\n        } else {\n            try {\n                XWikiDocument userdoc = getUserDocument(context);\n                DocumentReference userClassReference =\n                    getUserClassReference(userdoc.getDocumentReference().getWikiReference());\n                // Default value of email_checked should be 1 (i.e. checked) if not set.\n                isChecked = userdoc.getIntValue(userClassReference, EMAIL_CHECKED_PROPERTY, 1) != 0;\n            } catch (XWikiException e) {\n                this.logger.error(\"Error while checking email_checked status of user [{}]\", getUser(), e);\n                isChecked = true;\n            }\n        }\n        return isChecked;\n    }\n\n    /**\n     * @param checked true if the email address was checked for the user. False if it wasn't checked.\n     * @param context used to retrieve the user document.\n     * @since 11.8RC1\n     */\n    public void setEmailChecked(boolean checked, XWikiContext context)\n    {\n        // We don't modify any information for guest and superadmin.\n        if (!isGuest() && !isSuperAdmin()) {\n            int checkedFlag = (checked) ? 1 : 0;\n            try {\n                XWikiDocument userdoc = getUserDocument(context);\n                userdoc.setIntValue(getUserClassReference(userdoc.getDocumentReference().getWikiReference()),\n                    EMAIL_CHECKED_PROPERTY, checkedFlag);\n                context.getWiki().saveDocument(userdoc, localizePlainOrKey(\n                    \"core.users.\" + (checked ? \"email_checked\" : \"email_unchecked\") + \".saveComment\"), context);\n            } catch (XWikiException e) {\n                this.logger.error(\"Error while setting email_checked status of user [{}]\", getUser(), e);\n            }\n        }\n    }\n\n    /**\n     * @param context used to retrieve the user document.\n     * @return true if the user is disabled (i.e. its active property is set to 0). This always returns false if the\n     *         user is the guest or superadmin user.\n     * @since 11.6RC1\n     */\n    public boolean isDisabled(XWikiContext context)\n    {\n        boolean disabled;\n        // These users are necessarily active. Note that superadmin might be main-wiki-prefixed when in a subwiki.\n        if (isGuest() || isSuperAdmin()) {\n            disabled = false;\n        } else {\n            try {\n                XWikiDocument userdoc = getUserDocument(context);\n                DocumentReference userClassReference =\n                    getUserClassReference(userdoc.getDocumentReference().getWikiReference());\n                // Default value of active should be 1 (i.e. active) if not set\n                disabled = userdoc.getIntValue(userClassReference, ACTIVE_PROPERTY, 1) == 0;\n            } catch (XWikiException e) {\n                this.logger.error(\"Error while checking active status of user [{}]\", getUser(), e);\n                disabled = false;\n            }\n        }\n        return disabled;\n    }\n\n    /**\n     * @param disable true if the user disabled the account. False to enable the account.\n     * @param context used to retrieve the user document.\n     * @since 11.6RC1\n     */\n    public void setDisabled(boolean disable, XWikiContext context)\n    {\n        // We don't modify any information for guest and superadmin.\n        if (!isGuest() && !isSuperAdmin()) {\n            int activeFlag = (disable) ? 0 : 1;\n            try {\n                XWikiDocument userdoc = getUserDocument(context);\n                userdoc.setIntValue(getUserClassReference(userdoc.getDocumentReference().getWikiReference()),\n                    ACTIVE_PROPERTY, activeFlag);\n                userdoc.setAuthorReference(context.getUserReference());\n                context.getWiki().saveDocument(userdoc,\n                    localizePlainOrKey(\"core.users.\" + (disable ? \"disable\" : \"enable\") + \".saveComment\"), context);\n            } catch (XWikiException e) {\n                this.logger.error(\"Error while setting active status of user [{}]\", getUser(), e);\n            }\n        }\n    }\n\n    /**\n     * @param context used to retrieve the user document.\n     * @return true if the user exists.\n     * @since 11.6RC1\n     */\n    public boolean exists(XWikiContext context)\n    {\n        boolean exists = false;\n        try {\n            XWikiDocument userdoc = getUserDocument(context);\n            exists = !userdoc.isNew();\n        } catch (XWikiException e) {\n            this.logger.error(\"Error while checking existing status of user [{}]\", getUser(), e);\n        }\n        return exists;\n    }\n\n    public void setUser(String user)\n    {\n        this.fullName = user;\n        this.fullNameNull = this.fullName == null;\n\n        this.userReference = null;\n        this.userReferenceSet = false;\n    }\n\n    /**\n     * Check if the user belongs to a group or not. This method only check direct membership (no recursive checking) in\n     * the current wiki.\n     *\n     * @param groupName The group to check.\n     * @param context The current {@link XWikiContext context}.\n     * @return {@code true} if the user does belong to the specified group, false otherwise or if an exception occurs.\n     * @throws XWikiException If an error occurs when checking the groups.\n     * @since 1.3\n     */\n    public boolean isUserInGroup(String groupName, XWikiContext context) throws XWikiException\n    {\n        if (!StringUtils.isEmpty(getUser())) {\n            XWikiGroupService groupService = context.getWiki().getGroupService(context);\n\n            DocumentReference groupReference = getCurrentMixedDocumentReferenceResolver().resolve(groupName);\n\n            Collection<DocumentReference> groups =\n                groupService.getAllGroupsReferencesForMember(getUserReference(), 0, 0, context);\n\n            if (groups.contains(groupReference)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * See if the user is global (i.e. registered in the main wiki) or local to a virtual wiki.\n     *\n     * @return {@code true} if the user is global, false otherwise or if an exception occurs.\n     */\n    public boolean isMain()\n    {\n        return this.main;\n    }\n\n    public void setMain(boolean main)\n    {\n        this.main = main;\n    }\n\n    @Override\n    public String toString()\n    {\n        return getUser();\n    }\n\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (super.equals(obj)) {\n            return true;\n        }\n\n        boolean equals;\n        if (obj instanceof XWikiUser) {\n            XWikiUser otherUser = (XWikiUser) obj;\n\n            equals = otherUser.main == this.main && Objects.equals(getUserReference(), otherUser.getUserReference());\n        } else {\n            equals = false;\n        }\n\n        return equals;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.security.authorization.internal;\n\nimport java.util.HashMap;\nimport java.util.List;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.security.internal.XWikiConstants;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * Legacy bridge aimed to replace the current RightService until the new API is used in all places.\n * @version $Id$\n * @since 4.0M2\n */\npublic class XWikiCachingRightService implements XWikiRightService\n{\n    /** Logger. */\n    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiCachingRightService.class);\n\n    /** The login action. */\n    private static final String DELETE_ACTION = \"delete\";\n\n    /** The delete action. */\n    private static final String LOGIN_ACTION = \"login\";\n\n    /**\n     * Map containing all known actions.\n     */\n    private static final ActionMap ACTION_MAP = new ActionMap();\n\n    static {\n        ACTION_MAP\n            .putAction(LOGIN_ACTION, Right.LOGIN)\n            .putAction(\"view\", Right.VIEW)\n            .putAction(DELETE_ACTION, Right.DELETE)\n            .putAction(\"distribution\", Right.VIEW)\n            .putAction(\"admin\", Right.ADMIN)\n            .putAction(\"programming\", Right.PROGRAM)\n            .putAction(\"edit\", Right.EDIT)\n            .putAction(\"register\", Right.REGISTER)\n            .putAction(\"logout\", Right.LOGIN)\n            .putAction(\"loginerror\", Right.LOGIN)\n            .putAction(\"loginsubmit\", Right.LOGIN)\n            .putAction(\"viewrev\", Right.VIEW)\n            .putAction(\"viewattachrev\", Right.VIEW)\n            .putAction(\"get\", Right.VIEW)\n            .putAction(\"downloadrev\", Right.VIEW)\n            .putAction(\"plain\", Right.VIEW)\n            .putAction(\"raw\", Right.VIEW)\n            .putAction(\"attach\", Right.VIEW)\n            .putAction(\"charting\", Right.VIEW)\n            .putAction(\"skin\", Right.VIEW)\n            .putAction(\"download\", Right.VIEW)\n            .putAction(\"dot\", Right.VIEW)\n            .putAction(\"svg\", Right.VIEW)\n            .putAction(\"pdf\", Right.VIEW)\n            // TODO: The \"undelete\" action is mapped to the right \"undelete\" in the legacy\n            // implementation.  We should check whether the \"undelete\" right is actually used or not and\n            // if we need to introduce it here as well for compatiblity reasons.\n            .putAction(\"undelete\", Right.EDIT)\n            .putAction(\"reset\", Right.DELETE)\n            .putAction(\"commentadd\", Right.COMMENT)\n            .putAction(\"commentsave\", Right.COMMENT)\n            .putAction(\"redirect\", Right.VIEW)\n            .putAction(\"export\", Right.VIEW)\n            .putAction(\"import\", Right.ADMIN)\n            .putAction(\"jsx\", Right.VIEW)\n            .putAction(\"ssx\", Right.VIEW)\n            .putAction(\"tex\", Right.VIEW)\n            .putAction(\"unknown\", Right.VIEW)\n            .putAction(\"save\", Right.EDIT)\n            .putAction(\"preview\", Right.EDIT)\n            .putAction(\"lock\", Right.EDIT)\n            .putAction(\"cancel\", Right.EDIT)\n            .putAction(\"delattachment\", Right.EDIT)\n            .putAction(\"inline\", Right.EDIT)\n            .putAction(\"propadd\", Right.EDIT)\n            .putAction(\"propupdate\", Right.EDIT)\n            .putAction(\"propdelete\", Right.EDIT)\n            .putAction(\"propdisable\", Right.EDIT)\n            .putAction(\"propenable\", Right.EDIT)\n            .putAction(\"objectadd\", Right.EDIT)\n            .putAction(\"objectremove\", Right.EDIT)\n            .putAction(\"objectsync\", Right.EDIT)\n            .putAction(\"rollback\", Right.EDIT)\n            .putAction(\"upload\", Right.EDIT)\n            .putAction(\"create\", Right.VIEW)\n            .putAction(\"deleteversions\", Right.ADMIN)\n            .putAction(\"deletespace\", Right.ADMIN)\n            .putAction(\"temp\", Right.VIEW)\n            .putAction(\"webjars\", Right.VIEW);\n    }\n\n    /** Resolver for document references. */\n    @SuppressWarnings(\"unchecked\")\n    private DocumentReferenceResolver<String> documentReferenceResolver\n        = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n\n    /** Resolver for user and group document references. */\n    @SuppressWarnings(\"unchecked\")\n    private DocumentReferenceResolver<String> userAndGroupReferenceResolver\n        = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"user\");\n\n    /** The rendering context to check PR for signed macro. */\n    private final RenderingContext renderingContext\n        = Utils.getComponent(RenderingContext.class);\n\n    /** The authorization manager used to really do the job. */\n    private final AuthorizationManager authorizationManager\n        = Utils.getComponent(AuthorizationManager.class);\n\n    /** The contextual authorization manager used to really do the job. */\n    private final ContextualAuthorizationManager contextualAuthorizationManager\n        = Utils.getComponent(ContextualAuthorizationManager.class);\n\n    /**\n     * Specialized map with a chainable put action to avoid exceeding code complexity during initialization.\n     */\n    private static class ActionMap extends HashMap<String, Right>\n    {\n        /** Serialization identifier for conformance to Serializable. */\n        private static final long serialVersionUID = 1;\n\n        /** Allow filling the map in the initializer without exceeding code complexity.\n         * @param action the action name\n         * @param right the corresponding right required\n         * @return this action map to allow code chaining\n         */\n        public ActionMap putAction(String action, Right right)\n        {\n            put(action, right);\n            return this;\n        }\n    }\n\n    /**\n     * Map an action represented by a string to a right.\n     * @param action String representation of action.\n     * @return right The corresponding Right instance, or\n     * {@code ILLEGAL}.\n     */\n    public static Right actionToRight(String action)\n    {\n        Right right = ACTION_MAP.get(action);\n        if (right == null) {\n            return Right.ILLEGAL;\n        }\n        return right;\n    }\n\n    /**\n     * @param username name as a string.\n     * @param wikiReference default wiki, if not explicitly specified in the username.\n     * @return A document reference that uniquely identifies the user.\n     */\n    private DocumentReference resolveUserName(String username, WikiReference wikiReference)\n    {\n        return userAndGroupReferenceResolver.resolve(username, wikiReference);\n    }\n\n    /**\n     * @param docname name of the document as string.\n     * @param wikiReference the default wiki where the document will be\n     * assumed do be located, unless explicitly specified in docname.\n     * @return the document reference.\n     */\n    private DocumentReference resolveDocumentName(String docname, WikiReference wikiReference)\n    {\n        return documentReferenceResolver.resolve(docname, wikiReference);\n    }\n\n    /**\n     * Show the login page, unless the wiki is configured otherwise.\n     * @param context the context\n     */\n    private void showLogin(XWikiContext context)\n    {\n        try {\n            if (context.getRequest() != null\n                /*\n                 * We must explicitly check the action from the context, as some templates that are\n                 * rendered may call checkAccess with different actions (which, strictly speaking is\n                 * incorrect, those templates should use hasAccessLevel).  In particular, 'menuview.vm'\n                 * will call checkAccess with action 'view', if the document 'XWiki.XWikiLogin' exists.\n                 */\n                && !LOGIN_ACTION.equals(context.getAction())\n                && !context.getWiki().Param(\"xwiki.hidelogin\", \"false\").equalsIgnoreCase(\"true\")) {\n                context.getWiki().getAuthService().showLogin(context);\n            }\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to show login page.\", e);\n        }\n    }\n\n    /**\n     * Ensure user authentication if needed.\n     *\n     * @param context Current XWikiContext\n     */\n    private void authenticateUser(XWikiContext context)\n    {\n        DocumentReference contextUserReference = context.getUserReference();\n        DocumentReference userReference = contextUserReference;\n\n        if (userReference == null && context.getMode() != XWikiContext.MODE_XMLRPC) {\n            try {\n                XWikiUser user = context.getWiki().checkAuth(context);\n                if (user != null) {\n                    userReference = resolveUserName(user.getUser(), new WikiReference(context.getWikiId()));\n                }\n            } catch (XWikiException e) {\n                LOGGER.error(\"Caught exception while authenticating user.\", e);\n            }\n        }\n\n        if (userReference != null && XWikiConstants.GUEST_USER.equals(userReference.getName())) {\n            // Public users (not logged in) should be passed as null in the new API. It may happen that badly\n            // design code, and poorly written API does not take care, so we prevent security issue here.\n            userReference = null;\n        }\n\n        if (userReference != contextUserReference\n            && (userReference == null || !userReference.equals(contextUserReference))) {\n            context.setUserReference(userReference);\n        }\n    }\n\n    @Override\n    public boolean checkAccess(String action, XWikiDocument doc, XWikiContext context)\n        throws XWikiException\n    {\n        Right right = actionToRight(action);\n        EntityReference entityReference = doc.getDocumentReference();\n\n        LOGGER.debug(\"checkAccess for action [{}] on entity [{}].\", right, entityReference);\n\n        authenticateUser(context);\n\n        if (contextualAuthorizationManager.hasAccess(right, entityReference)) {\n            return true;\n        }\n\n        // If the right has been denied, and we have guest user, redirect the user to login page\n        // unless the denied is on the login action, which could cause infinite redirection.\n        // FIXME: The hasAccessLevel is broken (do not allow document creator) on the delete action in the old\n        // implementation, so code that simply want to verify if a user can delete (but is not actually deleting)\n        // has to call checkAccess. This happen really often, and this why we should not redirect to login on failed\n        // delete, since it would prevent most user to do anything.\n        if (context.getUserReference() == null && !DELETE_ACTION.equals(action) && !LOGIN_ACTION.equals(action)) {\n            LOGGER.debug(\"Redirecting unauthenticated user to login, since it have been denied [{}] on [{}].\",\n                         right, entityReference);\n            showLogin(context);\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean hasAccessLevel(String rightName, String username, String docname, XWikiContext context)\n        throws XWikiException\n    {\n        WikiReference wikiReference = new WikiReference(context.getWikiId());\n        DocumentReference document = resolveDocumentName(docname, wikiReference);\n        LOGGER.debug(\"hasAccessLevel() resolved document named [{}] into reference [{}]\", docname, document);\n        DocumentReference user = resolveUserName(username, wikiReference);\n\n        if (user != null && XWikiConstants.GUEST_USER.equals(user.getName())) {\n            // Public users (not logged in) should be passed as null in the new API\n            user = null;\n        }\n\n        Right right = Right.toRight(rightName);\n\n        return authorizationManager.hasAccess(right, user, document);\n    }\n\n    @Override\n    public boolean hasProgrammingRights(XWikiContext context)\n    {\n        return contextualAuthorizationManager.hasAccess(Right.PROGRAM);\n    }\n\n    @Override\n    public boolean hasProgrammingRights(XWikiDocument doc, XWikiContext context)\n    {\n        DocumentReference user;\n        WikiReference wiki;\n\n        if (doc != null) {\n            user = doc.getContentAuthorReference();\n            wiki = doc.getDocumentReference().getWikiReference();\n        } else {\n            user = context.getUserReference();\n            wiki = new WikiReference(context.getWikiId());\n        }\n\n        if (user != null && XWikiConstants.GUEST_USER.equals(user.getName())) {\n            // Public users (not logged in) should be passed as null in the new API. It may happen that badly\n            // design code, and poorly written API does not take care, so we prevent security issue here.\n            user = null;\n        }\n\n        // This method as never check for external contextual aspect like rendering context restriction or dropping of\n        // permissions. So we do not use the contextual authorization manager to keep backward compatibility.\n        return authorizationManager.hasAccess(Right.PROGRAM, user, wiki);\n    }\n\n    @Override\n    public boolean hasAdminRights(XWikiContext context)\n    {\n        return contextualAuthorizationManager.hasAccess(Right.ADMIN);\n    }\n\n    @Override\n    public boolean hasWikiAdminRights(XWikiContext context)\n    {\n        return contextualAuthorizationManager.hasAccess(Right.ADMIN, new WikiReference(context.getWikiId()));\n    }\n\n    @Override\n    public List<String> listAllLevels(XWikiContext context)\n        throws XWikiException\n    {\n        return Right.getAllRightsAsString();\n    }\n}\n"], "fixing_code": ["## ---------------------------------------------------------------------------\n## See the NOTICE file distributed with this work for additional\n## information regarding copyright ownership.\n##\n## This is free software; you can redistribute it and/or modify it\n## under the terms of the GNU Lesser General Public License as\n## published by the Free Software Foundation; either version 2.1 of\n## the License, or (at your option) any later version.\n##\n## This software is distributed in the hope that it will be useful,\n## but WITHOUT ANY WARRANTY; without even the implied warranty of\n## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n## Lesser General Public License for more details.\n##\n## You should have received a copy of the GNU Lesser General Public\n## License along with this software; if not, write to the Free\n## Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n## 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n## ---------------------------------------------------------------------------\n#template('drawer_macros.vm')\n##\n## Display the drawer\n##\n<nav class=\"drawer-nav\" id=\"tmDrawer\">\n  <ul class=\"drawer-menu\">\n    ##\n    ## Drawer header (with elements concerning the current user: profile, login, logout, register, etc...)\n    ##\n    <li class=\"drawer-brand clearfix\">\n      <a href=\"$xwiki.getURL($xcontext.user, 'view')\">\n        #largeUserAvatar($xcontext.user)\n      </a>\n      <div class=\"brand-links\">\n        #define ($logoutLink)\n          <a href=\"$xwiki.getURL('XWiki.XWikiLogout', 'logout', \"xredirect=$escapetool.url($xwiki.relativeRequestURL)\")\" id=\"tmLogout\" rel=\"nofollow\">$services.icon.renderHTML('log-out') $escapetool.xml($services.localization.render('logout'))</a>\n        #end\n        #if ($xcontext.user != 'XWiki.XWikiGuest')\n          <a href=\"$xwiki.getURL($xcontext.user, 'view')\" class=\"brand-user\" id=\"tmUser\">$!xwiki.getUserName($xcontext.user, false)</a>\n          $logoutLink\n        #elseif($xcontext.user == 'XWiki.XWikiGuest' && $xcontext.inactiveUserReference)\n          <a href=\"$xwiki.getURL($xcontext.inactiveUserReference, 'view')\" class=\"brand-user\" id=\"tmUser\">$!xwiki.getUserName($xcontext.inactiveUserReference, false)</a>\n          $logoutLink\n        #else\n          <a href=\"$xwiki.getURL('XWiki.XWikiLogin', 'login', \"xredirect=$escapetool.url($xwiki.relativeRequestURL)&loginLink=1\")\" id=\"tmLogin\" rel=\"nofollow\">$services.icon.renderHTML('log-in') $escapetool.xml($services.localization.render('login'))</a>\n          #if ($xwiki.hasAccessLevel('register', 'XWiki.XWikiPreferences'))\n            <a href=\"$xwiki.getURL('XWiki.XWikiRegister', 'register', \"xredirect=$escapetool.url($xwiki.relativeRequestURL)\")\" id=\"tmRegister\" rel=\"nofollow\">$services.icon.renderHTML('log-in') $escapetool.xml($services.localization.render('register'))</a>\n          #end\n        #end\n        ##\n        ## UIX\n        ##\n        #displayDrawerUIX('org.xwiki.plaftorm.drawer.header')\n      </div>\n    </li>\n    ##\n    ## Display the content of the drawer\n    ##\n    #set ($drawerExtensions = $services.uix.getExtensions('org.xwiki.plaftorm.drawer', {'sortByParameter' : 'order'}))\n    ## Logs to debug problems when displaying UIXes.\n    #set ($discard = $services.logging.getLogger('drawer.vm').debug('Drawer UIXes: [{}]', $drawerExtensions))\n    ##\n    ## Local Category\n    ##\n    #drawerCategoryHeader($services.wiki.currentWikiDescriptor.prettyName)\n    ##\n    ## Display an \"Administer wiki\" item if the Administration App is not installed.\n    ## The role of the item is to help the user importing content.\n    ##\n    #if ($hasGlobalAdmin)\n      #set ($importaction = $!xwiki.getURL('XWiki.XWikiPreferences', 'import'))\n      #if (!$isAdminAppInstalled)\n        ## If the admin application is not installed, we add a link to import it.\n        ## Otherwise, we let the admin application adds the correct UIX to administrate the wiki.\n        #set ($importaction = $!xwiki.getURL('XWiki.XWikiPreferences', 'import'))\n        #drawerItem($importaction, 'wrench', $escapetool.xml($services.localization.render('core.menu.admin')), 'tmAdminWiki')\n        #drawerSeparator()\n      #end\n    #end\n    ##\n    ## UIX: Drawer items for the current wiki\n    ##\n    #displayTheseDrawerUIX($drawerExtensions, 'local')\n    ##\n    ## Global category\n    ##\n    #define ($globalPart)\n      ##\n      ## Languages\n      ##\n      #template('menus_language.vm')\n      ##\n      ## UIX: Drawer items for the global scope\n      ##\n      #displayTheseDrawerUIX($drawerExtensions, 'global')\n    #end\n    #if ($stringtool.isNotBlank($globalPart.toString()))\n      #drawerCategoryHeader($services.localization.render('core.drawer.global'))\n      $globalPart\n    #end\n  </ul>\n</nav>\n#**\n * Display the UI extensions.\n *\n * @param $name the name of the UI extension to display\n * @param $category the name of the category to filter on (by default, it fallbacks on \"local\")\n *#\n#macro(displayDrawerUIX $name $category)\n  #displayTheseDrawerUIX($services.uix.getExtensions($name, {'sortByParameter' : 'order'}), $category)\n#end\n#**\n * Display the UI extensions.\n *\n * @param $extensions a list of extensions to display\n * @param $category the name of the category to filter on (by default, it fallbacks on \"local\")\n *#\n#macro(displayTheseDrawerUIX $extensions $category)\n  #set ($canHaveMenuSeparator = false)\n  #if (\"$!category\" == '')\n    #set ($category = 'local')\n  #end\n  #foreach($uix in $extensions)\n    #set ($uixCategory = \"$!uix.parameters.category\")\n    #set ($hasAccessForDrawerUIX = $services.security.authorization.hasAccess('admin', $uix.authorReference, $services.wiki.currentWikiDescriptor.reference))\n    ## Logs to debug problems when displaying UIXes.\n    #set ($discard = $services.logging.getLogger('drawer.vm').debug('Drawer UIX [{}] - Reference: [{}]', $uix, $!uix.documentReference))\n    #set ($discard = $services.logging.getLogger('drawer.vm').debug('Drawer UIX [{}] - Author: [{}]', $uix, $!uix.authorReference))\n    #set ($discard = $services.logging.getLogger('drawer.vm').debug('Drawer UIX [{}] - Category: [{}] - UIX Category: [{}]', $uix, $category, $uixCategory))\n    #set ($discard = $services.logging.getLogger('drawer.vm').debug('Drawer UIX [{}] - Permission: [{}]', $uix, $hasAccessForDrawerUIX))\n    #if (($uixCategory == $category || $category == 'local' && $uixCategory == '') && $hasAccessForDrawerUIX)\n      #if (\"$!uix.getParameters().separator\" == 'true' && $canHaveMenuSeparator)\n        #drawerSeparator()\n        #set ($canHaveMenuSeparator = false)\n      #end\n      #set ($content = $services.rendering.render($uix.execute(), 'html/5.0'))\n      $content\n      #if (!$canHaveMenuSeparator && $stringtool.isNotBlank($content))\n        #set ($canHaveMenuSeparator = true)\n      #end\n    #end\n  #end\n#end\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.notifications.rest.internal;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.ws.rs.core.CacheControl;\nimport javax.ws.rs.core.Response;\nimport javax.ws.rs.core.Response.Status;\n\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.notifications.CompositeEvent;\nimport org.xwiki.notifications.NotificationException;\nimport org.xwiki.notifications.notifiers.internal.DefaultNotificationCacheManager;\nimport org.xwiki.notifications.notifiers.rss.NotificationRSSManager;\nimport org.xwiki.notifications.rest.NotificationsResource;\nimport org.xwiki.notifications.rest.model.Notifications;\nimport org.xwiki.notifications.sources.NotificationParameters;\nimport org.xwiki.notifications.sources.ParametrizedNotificationManager;\nimport org.xwiki.notifications.sources.internal.DefaultNotificationParametersFactory;\nimport org.xwiki.notifications.sources.internal.DefaultNotificationParametersFactory.ParametersKey;\nimport org.xwiki.rest.XWikiResource;\n\nimport com.rometools.rome.io.SyndFeedOutput;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.web.XWikiRequest;\n\n/**\n * Default implementation of {@link NotificationsResource}.\n *\n * @version $Id$\n * @since 10.4RC1\n */\n@Component\n@Named(\"org.xwiki.notifications.rest.internal.DefaultNotificationsResource\")\npublic class DefaultNotificationsResource extends XWikiResource implements NotificationsResource\n{\n    private static final String TRUE = \"true\";\n\n    @Inject\n    private ParametrizedNotificationManager newNotificationManager;\n\n    @Inject\n    private DocumentReferenceResolver<String> documentReferenceResolver;\n\n    @Inject\n    private InternalNotificationsRenderer notificationsRenderer;\n\n    @Inject\n    private NotificationRSSManager notificationRSSManager;\n\n    @Inject\n    private DefaultNotificationCacheManager cacheManager;\n\n    @Inject\n    private NotificationEventExecutor executor;\n\n    @Inject\n    private DefaultNotificationParametersFactory notificationParametersFactory;\n\n    @Override\n    public Response getNotifications(String useUserPreferences, String userId, String untilDate,\n        boolean untilDateIncluded, String blackList, String pages, String spaces, String wikis, String users,\n        String maxCount, String displayOwnEvents, String displayMinorEvents, String displaySystemEvents,\n        String displayReadEvents, String displayReadStatus, String tags, String currentWiki, String async,\n        String asyncId) throws Exception\n    {\n        // Build the response\n        Response.ResponseBuilder response;\n        Object result = getCompositeEvents(useUserPreferences, userId, untilDate, untilDateIncluded, blackList, pages,\n            spaces, wikis, users, toMaxCount(maxCount, 21), displayOwnEvents, displayMinorEvents, displaySystemEvents,\n            displayReadEvents, tags, currentWiki, async, asyncId, false, false);\n\n        if (result instanceof String) {\n            response = Response.status(Status.ACCEPTED);\n            response.entity(Collections.singletonMap(\"asyncId\", result));\n        } else {\n            // Make sure URLs will be rendered like in any other display (by default REST API forces absolute URLs)\n            XWikiContext xcontext = getXWikiContext();\n            xcontext.setURLFactory(\n                xcontext.getWiki().getURLFactoryService().createURLFactory(XWikiContext.MODE_SERVLET, xcontext));\n\n            // Make sure to rendering the notifications in the right wiki\n            String currentOriginalWiki = xcontext.getOriginalWikiId();\n            try {\n                if (currentWiki != null) {\n                    xcontext.setOriginalWikiId(currentWiki);\n                }\n\n                Notifications notifications = new Notifications(this.notificationsRenderer\n                    .renderNotifications((List<CompositeEvent>) result, userId, TRUE.equals(displayReadStatus)));\n\n                response = Response.ok(notifications);\n            } finally {\n                xcontext.setOriginalWikiId(currentOriginalWiki);\n            }\n        }\n\n        // Add the \"cache control\" header.\n        CacheControl cacheControl = new CacheControl();\n        cacheControl.setNoCache(true);\n        response.cacheControl(cacheControl);\n\n        return response.build();\n    }\n\n    private int toMaxCount(String maxCount, int defaultMaxCount)\n    {\n        return NumberUtils.toInt(maxCount, defaultMaxCount);\n    }\n\n    private Object getCompositeEvents(String useUserPreferences, String userId, String untilDate,\n        boolean untilDateIncluded, String blackList, String pages, String spaces, String wikis, String users,\n        int maxCount, String displayOwnEvents, String displayMinorEvents, String displaySystemEvents,\n        String displayReadEvents, String tags, String currentWiki, String async, String asyncId, boolean onlyUnread,\n        boolean count) throws Exception\n    {\n        Object result = null;\n        NotificationParameters notificationParameters = getNotificationParameters(useUserPreferences, userId, untilDate,\n            untilDateIncluded, blackList, pages, spaces, wikis, users, maxCount, displayOwnEvents, displayMinorEvents,\n            displaySystemEvents, displayReadEvents, tags, currentWiki, onlyUnread);\n\n        // 1. Check current asynchronous execution\n        if (asyncId != null) {\n            result = this.executor.popAsync(asyncId);\n\n            if (result == null) {\n                // Another round\n                result = asyncId;\n            }\n        }\n\n        if (result == null) {\n            // 2. Generate the cache key\n            String cacheKey = this.cacheManager.createCacheKey(notificationParameters);\n\n            // 3. Search events\n            result = this.executor.submit(cacheKey,\n                () -> getCompositeEvents(notificationParameters),\n                Boolean.parseBoolean(async), count);\n        }\n\n        return result;\n    }\n\n    private List<CompositeEvent> getCompositeEvents(NotificationParameters notificationParameters)\n        throws NotificationException\n    {\n        return this.newNotificationManager.getEvents(notificationParameters);\n    }\n\n    @Override\n    public Response getNotificationsCount(String useUserPreferences, String userId, String pages, String spaces,\n        String wikis, String users, String maxCount, String displayOwnEvents, String displayMinorEvents,\n        String displaySystemEvents, String displayReadEvents, String displayReadStatus, String tags, String currentWiki,\n        String async, String asyncId) throws Exception\n    {\n        // Build the response\n        Response.ResponseBuilder response;\n        XWikiUser xWikiUser = getXWikiContext().getWiki().checkAuth(getXWikiContext());\n        if (xWikiUser == null) {\n            response = Response.status(Status.UNAUTHORIZED);\n        } else {\n            Object result = getCompositeEvents(useUserPreferences, userId, null, true, null, pages, spaces, wikis,\n                users, toMaxCount(maxCount, 21), displayOwnEvents, displayMinorEvents, displaySystemEvents,\n                displayReadEvents, tags, currentWiki, async, asyncId, true, true);\n\n            if (result instanceof String) {\n                response = Response.status(Status.ACCEPTED);\n                response.entity(Collections.singletonMap(\"asyncId\", result));\n            } else {\n                response = Response.ok(Collections.singletonMap(\"unread\", result));\n            }\n\n            // Add the \"cache control\" header.\n            CacheControl cacheControl = new CacheControl();\n            cacheControl.setNoCache(true);\n            response.cacheControl(cacheControl);\n        }\n        return response.build();\n    }\n\n    @Override\n    public String getNotificationsRSS(String useUserPreferences, String userId, String untilDate, String blackList,\n        String pages, String spaces, String wikis, String users, String maxCount, String displayOwnEvents,\n        String displayMinorEvents, String displaySystemEvents, String displayReadEvents, String displayReadStatus,\n        String tags, String currentWiki) throws Exception\n    {\n        // Build the response\n        XWikiUser xWikiUser = getXWikiContext().getWiki().checkAuth(getXWikiContext());\n        DocumentReference userIdDoc = this.documentReferenceResolver.resolve(userId);\n        if (xWikiUser == null || !userIdDoc.equals(xWikiUser.getUserReference())) {\n            getXWikiContext().getResponse().sendError(HttpServletResponse.SC_UNAUTHORIZED);\n            return null;\n        } else {\n            List<CompositeEvent> events =\n                (List<CompositeEvent>) getCompositeEvents(useUserPreferences, userId, untilDate, true, blackList, pages,\n                    spaces, wikis, users, toMaxCount(maxCount, 10), displayOwnEvents, displayMinorEvents,\n                    displaySystemEvents, displayReadEvents, tags, currentWiki, null, null, false, false);\n\n            SyndFeedOutput output = new SyndFeedOutput();\n            return output.outputString(notificationRSSManager.renderFeed(events));\n        }\n    }\n\n    @Override\n    public Response postNotifications() throws Exception\n    {\n        // We should seriously consider to stop using Restlet, because the @FormParam attribute does not work.\n        // See: https://github.com/restlet/restlet-framework-java/issues/1120\n        // That's why we need to use this workaround: manually getting the POST params in the request object.\n        XWikiRequest request = getXWikiContext().getRequest();\n        return getNotifications(request.get(\"useUserPreferences\"), request.get(\"userId\"), request.get(\"untilDate\"),\n            BooleanUtils.toBooleanObject(request.get(\"untilDateIncluded\")) != Boolean.FALSE, request.get(\"blackList\"),\n            request.get(\"pages\"), request.get(\"spaces\"), request.get(\"wikis\"), request.get(\"users\"),\n            request.get(\"count\"), request.get(\"displayOwnEvents\"), request.get(\"displayMinorEvents\"),\n            request.get(\"displaySystemEvents\"), request.get(\"displayReadEvents\"), request.get(\"displayReadStatus\"),\n            request.get(\"tags\"), request.get(\"currentWiki\"), request.get(\"async\"), request.get(\"asyncId\"));\n    }\n\n    private NotificationParameters getNotificationParameters(String useUserPreferences, String userId, String untilDate,\n        boolean untilDateIncluded, String blackList, String pages, String spaces, String wikis, String users,\n        int maxCount, String displayOwnEvents, String displayMinorEvents, String displaySystemEvents,\n        String displayReadEvents, String tags, String currentWiki, boolean onlyUnread) throws NotificationException\n    {\n        Map<ParametersKey, String> parametersMap = new HashMap<>();\n        parametersMap.put(ParametersKey.USE_USER_PREFERENCES, useUserPreferences);\n        parametersMap.put(ParametersKey.USER_ID, userId);\n        parametersMap.put(ParametersKey.UNTIL_DATE, untilDate);\n        parametersMap.put(ParametersKey.UNTIL_DATE_INCLUDED, String.valueOf(untilDateIncluded));\n        parametersMap.put(ParametersKey.BLACKLIST, blackList);\n        parametersMap.put(ParametersKey.PAGES, pages);\n        parametersMap.put(ParametersKey.SPACES, spaces);\n        parametersMap.put(ParametersKey.WIKIS, wikis);\n        parametersMap.put(ParametersKey.USERS, users);\n        parametersMap.put(ParametersKey.MAX_COUNT, String.valueOf(maxCount));\n        parametersMap.put(ParametersKey.DISPLAY_OWN_EVENTS, displayOwnEvents);\n        parametersMap.put(ParametersKey.DISPLAY_MINOR_EVENTS, displayMinorEvents);\n        parametersMap.put(ParametersKey.DISPLAY_SYSTEM_EVENTS, displaySystemEvents);\n        parametersMap.put(ParametersKey.DISPLAY_READ_EVENTS, displayReadEvents);\n        parametersMap.put(ParametersKey.TAGS, tags);\n        parametersMap.put(ParametersKey.CURRENT_WIKI, currentWiki);\n        parametersMap.put(ParametersKey.ONLY_UNREAD, String.valueOf(onlyUnread));\n\n        return this.notificationParametersFactory.createNotificationParameters(parametersMap);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.FileTime;\nimport java.text.DateFormatSymbols;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.Vector;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.zip.ZipOutputStream;\n\nimport javax.annotation.Priority;\nimport javax.inject.Provider;\nimport javax.mail.Message;\nimport javax.mail.Session;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport javax.naming.NamingException;\nimport javax.script.ScriptContext;\nimport javax.servlet.http.Cookie;\n\nimport org.apache.commons.httpclient.Credentials;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.URIException;\nimport org.apache.commons.httpclient.UsernamePasswordCredentials;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.util.URIUtil;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.apache.commons.lang3.reflect.FieldUtils;\nimport org.apache.velocity.VelocityContext;\nimport org.hibernate.HibernateException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.suigeneris.jrcs.rcs.Version;\nimport org.xwiki.bridge.event.DocumentCreatedEvent;\nimport org.xwiki.bridge.event.DocumentCreatingEvent;\nimport org.xwiki.bridge.event.DocumentDeletedEvent;\nimport org.xwiki.bridge.event.DocumentDeletingEvent;\nimport org.xwiki.bridge.event.DocumentRestoredEvent;\nimport org.xwiki.bridge.event.DocumentRestoringEvent;\nimport org.xwiki.bridge.event.DocumentRolledBackEvent;\nimport org.xwiki.bridge.event.DocumentRollingBackEvent;\nimport org.xwiki.bridge.event.DocumentUpdatedEvent;\nimport org.xwiki.bridge.event.DocumentUpdatingEvent;\nimport org.xwiki.bridge.event.DocumentVersionRangeDeletedEvent;\nimport org.xwiki.bridge.event.DocumentVersionRangeDeletingEvent;\nimport org.xwiki.bridge.event.WikiCopiedEvent;\nimport org.xwiki.bridge.event.WikiDeletedEvent;\nimport org.xwiki.cache.Cache;\nimport org.xwiki.classloader.ClassLoaderManager;\nimport org.xwiki.component.event.ComponentDescriptorAddedEvent;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.manager.NamespacedComponentManager;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.container.servlet.HttpServletUtils;\nimport org.xwiki.context.Execution;\nimport org.xwiki.edit.EditConfiguration;\nimport org.xwiki.extension.job.internal.InstallJob;\nimport org.xwiki.extension.job.internal.UninstallJob;\nimport org.xwiki.job.Job;\nimport org.xwiki.job.JobException;\nimport org.xwiki.job.JobExecutor;\nimport org.xwiki.job.annotation.Serializable;\nimport org.xwiki.job.event.JobFinishedEvent;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.job.event.status.JobStatus.State;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.mail.MailListener;\nimport org.xwiki.mail.MailSender;\nimport org.xwiki.mail.MailSenderConfiguration;\nimport org.xwiki.mail.MailStatusResultSerializer;\nimport org.xwiki.mail.XWikiAuthenticator;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.AttachmentReferenceResolver;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.ObjectReference;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.PageReferenceResolver;\nimport org.xwiki.model.reference.RegexEntityReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.observation.EventListener;\nimport org.xwiki.observation.ObservationManager;\nimport org.xwiki.observation.event.CancelableEvent;\nimport org.xwiki.observation.event.Event;\nimport org.xwiki.query.QueryException;\nimport org.xwiki.query.QueryFilter;\nimport org.xwiki.refactoring.ReferenceRenamer;\nimport org.xwiki.refactoring.batch.BatchOperationExecutor;\nimport org.xwiki.rendering.async.AsyncContext;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.Block.Axes;\nimport org.xwiki.rendering.block.MetaDataBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.block.match.MetadataBlockMatcher;\nimport org.xwiki.rendering.internal.transformation.MutableRenderingContext;\nimport org.xwiki.rendering.listener.MetaData;\nimport org.xwiki.rendering.parser.ParseException;\nimport org.xwiki.rendering.renderer.BlockRenderer;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.syntax.SyntaxContent;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.resource.ResourceReference;\nimport org.xwiki.resource.ResourceReferenceManager;\nimport org.xwiki.resource.ResourceReferenceResolver;\nimport org.xwiki.resource.ResourceType;\nimport org.xwiki.resource.ResourceTypeResolver;\nimport org.xwiki.resource.entity.EntityResourceReference;\nimport org.xwiki.script.ScriptContextManager;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.skin.Resource;\nimport org.xwiki.skin.Skin;\nimport org.xwiki.skin.SkinManager;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.template.TemplateManager;\nimport org.xwiki.url.ExtendedURL;\nimport org.xwiki.url.URLConfiguration;\nimport org.xwiki.user.CurrentUserReference;\nimport org.xwiki.user.UserPropertiesResolver;\nimport org.xwiki.velocity.VelocityContextFactory;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.velocity.XWikiVelocityContext;\nimport org.xwiki.velocity.XWikiVelocityException;\nimport org.xwiki.wiki.descriptor.WikiDescriptor;\nimport org.xwiki.wiki.descriptor.WikiDescriptorManager;\nimport org.xwiki.wiki.manager.WikiManager;\nimport org.xwiki.wiki.manager.WikiManagerException;\nimport org.xwiki.xml.XMLUtils;\n\nimport com.xpn.xwiki.api.Api;\nimport com.xpn.xwiki.api.Document;\nimport com.xpn.xwiki.api.User;\nimport com.xpn.xwiki.criteria.api.XWikiCriteriaService;\nimport com.xpn.xwiki.doc.DeletedAttachment;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.MandatoryDocumentInitializer;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiAttachmentArchive;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.doc.XWikiDocument.XWikiAttachmentToRemove;\nimport com.xpn.xwiki.doc.XWikiDocumentArchive;\nimport com.xpn.xwiki.internal.WikiInitializerJob;\nimport com.xpn.xwiki.internal.WikiInitializerRequest;\nimport com.xpn.xwiki.internal.XWikiCfgConfigurationSource;\nimport com.xpn.xwiki.internal.XWikiConfigDelegate;\nimport com.xpn.xwiki.internal.XWikiInitializerJob;\nimport com.xpn.xwiki.internal.debug.DebugConfiguration;\nimport com.xpn.xwiki.internal.event.MandatoryDocumentsInitializedEvent;\nimport com.xpn.xwiki.internal.event.MandatoryDocumentsInitializingEvent;\nimport com.xpn.xwiki.internal.event.UserCreatingDocumentEvent;\nimport com.xpn.xwiki.internal.event.UserDeletingDocumentEvent;\nimport com.xpn.xwiki.internal.event.UserUpdatingDocumentEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyAddedEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyDeletedEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyEvent;\nimport com.xpn.xwiki.internal.event.XObjectPropertyUpdatedEvent;\nimport com.xpn.xwiki.internal.mandatory.XWikiPreferencesDocumentInitializer;\nimport com.xpn.xwiki.internal.render.OldRendering;\nimport com.xpn.xwiki.internal.render.groovy.ParseGroovyFromString;\nimport com.xpn.xwiki.internal.skin.InternalSkinConfiguration;\nimport com.xpn.xwiki.internal.skin.InternalSkinManager;\nimport com.xpn.xwiki.internal.skin.WikiSkin;\nimport com.xpn.xwiki.internal.skin.WikiSkinUtils;\nimport com.xpn.xwiki.internal.store.StoreConfiguration;\nimport com.xpn.xwiki.internal.store.hibernate.HibernateConfiguration;\nimport com.xpn.xwiki.internal.velocity.VelocityEvaluator;\nimport com.xpn.xwiki.job.JobRequestContext;\nimport com.xpn.xwiki.objects.BaseObject;\nimport com.xpn.xwiki.objects.PropertyInterface;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.objects.classes.PasswordClass;\nimport com.xpn.xwiki.objects.classes.PropertyClass;\nimport com.xpn.xwiki.objects.meta.MetaClass;\nimport com.xpn.xwiki.plugin.XWikiPluginInterface;\nimport com.xpn.xwiki.plugin.XWikiPluginManager;\nimport com.xpn.xwiki.render.groovy.XWikiPageClassLoader;\nimport com.xpn.xwiki.stats.api.XWikiStatsService;\nimport com.xpn.xwiki.stats.impl.SearchEngineRule;\nimport com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl;\nimport com.xpn.xwiki.store.AttachmentRecycleBinStore;\nimport com.xpn.xwiki.store.AttachmentVersioningStore;\nimport com.xpn.xwiki.store.XWikiAttachmentStoreInterface;\nimport com.xpn.xwiki.store.XWikiCacheStoreInterface;\nimport com.xpn.xwiki.store.XWikiHibernateStore;\nimport com.xpn.xwiki.store.XWikiRecycleBinStoreInterface;\nimport com.xpn.xwiki.store.XWikiStoreInterface;\nimport com.xpn.xwiki.store.XWikiVersioningStoreInterface;\nimport com.xpn.xwiki.user.api.XWikiAuthService;\nimport com.xpn.xwiki.user.api.XWikiGroupService;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl;\nimport com.xpn.xwiki.user.impl.xwiki.XWikiRightServiceImpl;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.util.XWikiStubContextProvider;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiEngineContext;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiServletRequestStub;\nimport com.xpn.xwiki.web.XWikiURLFactory;\nimport com.xpn.xwiki.web.XWikiURLFactoryService;\nimport com.xpn.xwiki.web.XWikiURLFactoryServiceImpl;\n\n@Serializable(false)\npublic class XWiki implements EventListener\n{\n    /** Name of the default wiki. */\n    public static final String DEFAULT_MAIN_WIKI = \"xwiki\";\n\n    /** Name of the default home space. */\n    public static final String DEFAULT_HOME_SPACE = \"Main\";\n\n    /** Name of the default system space. */\n    public static final String SYSTEM_SPACE = \"XWiki\";\n\n    /**\n     * Name of the default system space as an EntityReference.\n     * \n     * @since 13.2RC1\n     */\n    public static final EntityReference SYSTEM_SPACE_REFERENCE = new EntityReference(\"XWiki\", EntityType.SPACE);\n\n    /** Name of the default space homepage. */\n    public static final String DEFAULT_SPACE_HOMEPAGE = \"WebHome\";\n\n    public static final String CKEY_SKIN = InternalSkinManager.CKEY_SKIN;\n\n    public static final String CKEY_BASESKIN = InternalSkinManager.CKEY_PARENTSKIN;\n\n    public static final String DEFAULT_SKIN = InternalSkinConfiguration.DEFAULT_SKIN;\n\n    /**\n     * Query parameters used to control the browser cache version of a resource.\n     */\n    public static final String CACHE_VERSION = \"cache-version\";\n\n    /** Logging helper object. */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);\n\n    /** Frequently used Document reference, the class which holds virtual wiki definitions. */\n    private static final DocumentReference VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE =\n        new DocumentReference(DEFAULT_MAIN_WIKI, SYSTEM_SPACE, \"XWikiServerClass\");\n\n    /** The default encoding, and the internally used encoding when dealing with byte representation of strings. */\n    public static final String DEFAULT_ENCODING = \"UTF-8\";\n\n    /** Represents no value (ie the default value will be used) in xproperties */\n    private static final String NO_VALUE = \"---\";\n\n    /**\n     * List of top level space names that can be used in the fake context document created when accessing a resource\n     * with the 'skin' action.\n     */\n    private static final List<String> SKIN_RESOURCE_SPACE_NAMES = Arrays.asList(\"skins\", \"resources\");\n\n    /** The main document storage. */\n    private XWikiStoreInterface store;\n\n    /** The attachment content storage. */\n    private XWikiAttachmentStoreInterface defaultAttachmentContentStore;\n\n    /** The attachment archive storage. */\n    private AttachmentVersioningStore defaultAttachmentArchiveStore;\n\n    /** Document versioning storage. */\n    private XWikiVersioningStoreInterface versioningStore;\n\n    /** Deleted documents storage. */\n    private XWikiRecycleBinStoreInterface recycleBinStore;\n\n    private AttachmentRecycleBinStore attachmentRecycleBinStore;\n\n    private XWikiPluginManager pluginManager;\n\n    private XWikiAuthService authService;\n\n    private XWikiRightService rightService;\n\n    private XWikiGroupService groupService;\n\n    private XWikiStatsService statsService;\n\n    private XWikiURLFactoryService urlFactoryService;\n\n    private XWikiCriteriaService criteriaService;\n\n    /** Lock object used for the lazy initialization of the authentication service. */\n    private final Object AUTH_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the authorization service. */\n    private final Object RIGHT_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the group management service. */\n    private final Object GROUP_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the statistics service. */\n    private final Object STATS_SERVICE_LOCK = new Object();\n\n    /** Lock object used for the lazy initialization of the URL Factory service. */\n    private final Object URLFACTORY_SERVICE_LOCK = new Object();\n\n    private MetaClass metaclass;\n\n    private String version;\n\n    private XWikiEngineContext engine_context;\n\n    private String database;\n\n    private String fullNameSQL;\n\n    /**\n     * The list of initialized wikis.\n     */\n    private Map<String, WikiInitializerJob> initializedWikis = new ConcurrentHashMap<>();\n\n    private boolean isReadOnly = false;\n\n    /**\n     * @deprecated since 6.1M2, use {@link XWikiCfgConfigurationSource#CFG_ENV_NAME} instead\n     */\n    @Deprecated\n    public static final String CFG_ENV_NAME = XWikiCfgConfigurationSource.CFG_ENV_NAME;\n\n    public static final String MACROS_FILE = \"/templates/macros.txt\";\n\n    /**\n     * File containing XWiki's version, in the format: <version name>.<SVN revision number>.\n     */\n    private static final String VERSION_FILE = \"/WEB-INF/version.properties\";\n\n    /**\n     * Property containing the version value in the {@link #VERSION_FILE} file.\n     */\n    private static final String VERSION_FILE_PROPERTY = \"version\";\n\n    private static XWikiInitializerJob job;\n\n    /** Used to convert a proper Document Reference to string (standard form). */\n    private EntityReferenceSerializer<String> defaultEntityReferenceSerializer;\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead.\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    private DocumentReferenceResolver<EntityReference> currentReferenceDocumentReferenceResolver;\n\n    private EntityReferenceResolver<String> currentMixedEntityReferenceResolver;\n\n    private EntityReferenceResolver<String> relativeEntityReferenceResolver;\n\n    private EntityReferenceSerializer<String> localStringEntityReferenceSerializer;\n\n    private ResourceReferenceManager resourceReferenceManager;\n\n    private JobExecutor jobExecutor;\n\n    private InternalSkinManager internalSkinManager;\n\n    private TemplateManager templateManager;\n\n    private RenderingContext renderingContext;\n\n    private VelocityEvaluator velocityEvaluator;\n\n    /**\n     * Whether backlinks are enabled or not (cached for performance).\n     *\n     * @since 3.2M2\n     */\n    private Boolean hasBacklinks;\n\n    private ConfigurationSource xwikicfg;\n\n    private ConfigurationSource wikiConfiguration;\n\n    private UserPropertiesResolver userPropertiesResolver;\n\n    private ConfigurationSource spaceConfiguration;\n\n    private EditConfiguration editConfiguration;\n\n    private URLConfiguration urlConfiguration;\n\n    private StoreConfiguration storeConfiguration;\n\n    private HibernateConfiguration hibernateConfiguration;\n\n    private ObservationManager observationManager;\n\n    private Provider<XWikiContext> xcontextProvider;\n\n    private ContextualLocalizationManager localization;\n\n    private Provider<OldRendering> oldRenderingProvider;\n\n    private ParseGroovyFromString parseGroovyFromString;\n\n    private JobProgressManager progress;\n\n    private Provider<DocumentReference> defaultDocumentReferenceProvider;\n\n    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;\n\n    private PageReferenceResolver<EntityReference> currentgetpageResolver;\n\n    private AttachmentReferenceResolver<EntityReference> currentAttachmentReferenceResolver;\n\n    private WikiSkinUtils wikiSkinUtils;\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private VelocityContextFactory velocityContextFactory;\n\n    private WikiDescriptorManager wikiDescriptorManager;\n\n    private AsyncContext asyncContext;\n\n    private AuthorizationManager authorizationManager;\n\n    private ConfigurationSource getConfiguration()\n    {\n        if (this.xwikicfg == null) {\n            this.xwikicfg = Utils.getComponent(ConfigurationSource.class, XWikiCfgConfigurationSource.ROLEHINT);\n        }\n\n        return this.xwikicfg;\n    }\n\n    private ConfigurationSource getWikiConfiguration()\n    {\n        if (this.wikiConfiguration == null) {\n            this.wikiConfiguration = Utils.getComponent(ConfigurationSource.class, \"wiki\");\n        }\n\n        return this.wikiConfiguration;\n    }\n\n    private ConfigurationSource getSpaceConfiguration()\n    {\n        if (this.spaceConfiguration == null) {\n            this.spaceConfiguration = Utils.getComponent(ConfigurationSource.class, \"space\");\n        }\n\n        return this.spaceConfiguration;\n    }\n\n    private UserPropertiesResolver getAllUserPropertiesResolver()\n    {\n        if (this.userPropertiesResolver == null) {\n            this.userPropertiesResolver = Utils.getComponent(UserPropertiesResolver.class, \"all\");\n        }\n\n        return this.userPropertiesResolver;\n    }\n\n    private EditConfiguration getEditConfiguration()\n    {\n        if (this.editConfiguration == null) {\n            this.editConfiguration = Utils.getComponent(EditConfiguration.class);\n        }\n\n        return this.editConfiguration;\n    }\n\n    private URLConfiguration getURLConfiguration()\n    {\n        if (this.urlConfiguration == null) {\n            this.urlConfiguration = Utils.getComponent(URLConfiguration.class);\n        }\n\n        return this.urlConfiguration;\n    }\n\n    private StoreConfiguration getStoreConfiguration()\n    {\n        if (this.storeConfiguration == null) {\n            this.storeConfiguration = Utils.getComponent(StoreConfiguration.class);\n        }\n\n        return this.storeConfiguration;\n    }\n\n    private HibernateConfiguration getHibernateConfiguration()\n    {\n        if (this.hibernateConfiguration == null) {\n            this.hibernateConfiguration = Utils.getComponent(HibernateConfiguration.class);\n        }\n\n        return this.hibernateConfiguration;\n    }\n\n    private InternalSkinManager getInternalSkinManager()\n    {\n        if (this.internalSkinManager == null) {\n            this.internalSkinManager = Utils.getComponent(InternalSkinManager.class);\n        }\n\n        return this.internalSkinManager;\n    }\n\n    private TemplateManager getTemplateManager()\n    {\n        if (this.templateManager == null) {\n            this.templateManager = Utils.getComponent(TemplateManager.class);\n        }\n\n        return this.templateManager;\n    }\n\n    private RenderingContext getRenderingContext()\n    {\n        if (this.renderingContext == null) {\n            this.renderingContext = Utils.getComponent(RenderingContext.class);\n        }\n\n        return this.renderingContext;\n    }\n\n    private MutableRenderingContext getMutableRenderingContext()\n    {\n        return getRenderingContext() instanceof MutableRenderingContext\n            ? (MutableRenderingContext) getRenderingContext() : null;\n    }\n\n    private VelocityEvaluator getVelocityEvaluator()\n    {\n        if (this.velocityEvaluator == null) {\n            this.velocityEvaluator = Utils.getComponent(VelocityEvaluator.class);\n        }\n\n        return this.velocityEvaluator;\n    }\n\n    private ObservationManager getObservationManager()\n    {\n        if (this.observationManager == null) {\n            this.observationManager = Utils.getComponent(ObservationManager.class);\n        }\n\n        return this.observationManager;\n    }\n\n    private XWikiContext getXWikiContext()\n    {\n        if (this.xcontextProvider == null) {\n            this.xcontextProvider = Utils.getComponent(XWikiContext.TYPE_PROVIDER);\n        }\n\n        return this.xcontextProvider.get();\n    }\n\n    private ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    private OldRendering getOldRendering()\n    {\n        if (this.oldRenderingProvider == null) {\n            this.oldRenderingProvider = Utils.getComponent(OldRendering.TYPE_PROVIDER);\n        }\n\n        return this.oldRenderingProvider.get();\n    }\n\n    private ParseGroovyFromString getParseGroovyFromString()\n    {\n        if (this.parseGroovyFromString == null) {\n            this.parseGroovyFromString = Utils.getComponent(ParseGroovyFromString.class);\n        }\n\n        return this.parseGroovyFromString;\n    }\n\n    private JobProgressManager getProgress()\n    {\n        if (this.progress == null) {\n            this.progress = Utils.getComponent(JobProgressManager.class);\n        }\n\n        return this.progress;\n    }\n\n    private Provider<DocumentReference> getDefaultDocumentReferenceProvider()\n    {\n        if (this.defaultDocumentReferenceProvider == null) {\n            this.defaultDocumentReferenceProvider = Utils.getComponent(DocumentReference.TYPE_PROVIDER);\n        }\n\n        return this.defaultDocumentReferenceProvider;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentGetDocumentResolver()\n    {\n        if (this.currentgetdocumentResolver == null) {\n            this.currentgetdocumentResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");\n        }\n\n        return this.currentgetdocumentResolver;\n    }\n\n    private PageReferenceResolver<EntityReference> getCurrentGetPageResolver()\n    {\n        if (this.currentgetpageResolver == null) {\n            this.currentgetpageResolver = Utils.getComponent(PageReferenceResolver.TYPE_REFERENCE, \"currentgetpage\");\n        }\n\n        return this.currentgetpageResolver;\n    }\n\n    private AttachmentReferenceResolver<EntityReference> getCurrentAttachmentResolver()\n    {\n        if (this.currentAttachmentReferenceResolver == null) {\n            this.currentAttachmentReferenceResolver =\n                Utils.getComponent(AttachmentReferenceResolver.TYPE_REFERENCE, \"current\");\n        }\n\n        return this.currentAttachmentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getDefaultEntityReferenceSerializer()\n    {\n        if (this.defaultEntityReferenceSerializer == null) {\n            this.defaultEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultEntityReferenceSerializer;\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentReferenceDocumentReferenceResolver()\n    {\n        if (this.currentReferenceDocumentReferenceResolver == null) {\n            this.currentReferenceDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"current\");\n        }\n\n        return this.currentReferenceDocumentReferenceResolver;\n    }\n\n    private EntityReferenceResolver<String> getCurrentMixedEntityReferenceResolver()\n    {\n        if (this.currentMixedEntityReferenceResolver == null) {\n            this.currentMixedEntityReferenceResolver =\n                Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedEntityReferenceResolver;\n    }\n\n    private EntityReferenceResolver<String> getRelativeEntityReferenceResolver()\n    {\n        if (this.relativeEntityReferenceResolver == null) {\n            this.relativeEntityReferenceResolver = Utils.getComponent(EntityReferenceResolver.TYPE_STRING, \"relative\");\n        }\n\n        return this.relativeEntityReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getLocalStringEntityReferenceSerializer()\n    {\n        if (this.localStringEntityReferenceSerializer == null) {\n            this.localStringEntityReferenceSerializer =\n                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n\n        return this.localStringEntityReferenceSerializer;\n    }\n\n    private ResourceReferenceManager getResourceReferenceManager()\n    {\n        if (this.resourceReferenceManager == null) {\n            this.resourceReferenceManager = Utils.getComponent(ResourceReferenceManager.class);\n        }\n\n        return this.resourceReferenceManager;\n    }\n\n    private JobExecutor getJobExecutor()\n    {\n        if (this.jobExecutor == null) {\n            this.jobExecutor = Utils.getComponent(JobExecutor.class);\n        }\n\n        return this.jobExecutor;\n    }\n\n    private DocumentReference getDefaultDocumentReference()\n    {\n        return getDefaultDocumentReferenceProvider().get();\n    }\n\n    private WikiSkinUtils getWikiSkinUtils()\n    {\n        if (this.wikiSkinUtils == null) {\n            this.wikiSkinUtils = Utils.getComponent(WikiSkinUtils.class);\n        }\n\n        return this.wikiSkinUtils;\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    private VelocityContextFactory getVelocityContextFactory()\n    {\n        if (this.velocityContextFactory == null) {\n            this.velocityContextFactory = Utils.getComponent(VelocityContextFactory.class);\n        }\n\n        return this.velocityContextFactory;\n    }\n\n    private WikiDescriptorManager getWikiDescriptorManager()\n    {\n        if (this.wikiDescriptorManager == null) {\n            this.wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n        }\n\n        return this.wikiDescriptorManager;\n    }\n\n    private AsyncContext getAsyncContext()\n    {\n        if (this.asyncContext == null) {\n            this.asyncContext = Utils.getComponent(AsyncContext.class);\n        }\n\n        return this.asyncContext;\n    }\n\n    private AuthorizationManager getAuthorizationManager()\n    {\n        if (this.authorizationManager == null) {\n            this.authorizationManager = Utils.getComponent(AuthorizationManager.class);\n        }\n\n        return this.authorizationManager;\n    }\n\n    private String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public static XWiki getMainXWiki(XWikiContext context) throws XWikiException\n    {\n        return getMainXWiki(true, context);\n    }\n\n    /**\n     * @param wait true if the method should way for {@link XWiki} instance to be initialized\n     * @param context see {@link XWikiContext}\n     */\n    public static XWiki getMainXWiki(boolean wait, XWikiContext context) throws XWikiException\n    {\n        String xwikiname = DEFAULT_MAIN_WIKI;\n\n        context.setMainXWiki(xwikiname);\n\n        XWiki xwiki;\n\n        try {\n            XWikiEngineContext econtext = context.getEngineContext();\n\n            xwiki = (XWiki) econtext.getAttribute(xwikiname);\n            if (xwiki == null) {\n                // Start XWiki initialization\n                synchronized (XWiki.class) {\n                    xwiki = (XWiki) econtext.getAttribute(xwikiname);\n                    if (xwiki == null && job == null) {\n                        job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);\n\n                        if (job.getStatus() == null) {\n                            // \"Pre-initialize\" XWikiStubContextProvider so that XWiki initializer can find one\n                            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class)\n                                .initialize(context);\n\n                            job.startAsync();\n                        }\n                    }\n                }\n\n                // Wait until XWiki is initialized\n                if (wait) {\n                    job.join();\n                    xwiki = (XWiki) econtext.getAttribute(xwikiname);\n                }\n            }\n\n            context.setWiki(xwiki);\n\n            return xwiki;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                \"Could not initialize main XWiki instance\", e);\n        }\n    }\n\n    public static boolean isInitializing(XWikiContext xcontext)\n    {\n        return Boolean.TRUE.equals(xcontext.getEngineContext().getAttribute(\"xwiki.init\"));\n    }\n\n    /**\n     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.\n     *\n     * @param context see {@link XWikiContext}\n     * @return an XWiki object configured for the wiki corresponding to the current request\n     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's an error in the\n     *             storage\n     */\n    public static XWiki getXWiki(XWikiContext context) throws XWikiException\n    {\n        return getXWiki(true, context);\n    }\n\n    /**\n     * Return the XWiki object (as in \"the Wiki API\") corresponding to the requested wiki.\n     * <p>\n     * Unless <code>wait</code> is false the method return right away null if XWiki is not yet initialized.\n     *\n     * @param wait wait until XWiki is initialized\n     * @param xcontext see {@link XWikiContext}\n     * @return an XWiki object configured for the wiki corresponding to the current request\n     * @throws XWikiException if the requested URL does not correspond to a real wiki, or if there's an error in the\n     *             storage\n     */\n    public static XWiki getXWiki(boolean wait, XWikiContext xcontext) throws XWikiException\n    {\n        XWiki xwiki = getMainXWiki(wait, xcontext);\n\n        if (xwiki == null) {\n            return null;\n        }\n\n        // Extract Entity Resource from URL and put it in the Execution Context\n        EntityResourceReference entityResourceReference = initializeResourceFromURL(xcontext);\n\n        // If not an entity resource reference assume main wiki\n        if (entityResourceReference == null) {\n            return xwiki;\n        }\n\n        // Get the wiki id\n        String wikiId = entityResourceReference.getEntityReference().extractReference(EntityType.WIKI).getName();\n        if (wikiId.equals(xcontext.getMainXWiki())) {\n            // The main wiki was requested.\n            return xwiki;\n        }\n\n        // Check if the wiki exists by checking if a descriptor exists for the wiki id.\n        WikiDescriptorManager wikiDescriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n        WikiDescriptor descriptor;\n        try {\n            descriptor = wikiDescriptorManager.getById(wikiId);\n        } catch (WikiManagerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_STORE_MISC,\n                String.format(\"Failed find wiki descriptor for wiki id [%s]\", wikiId), e);\n        }\n        if (descriptor == null) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_DOES_NOT_EXIST,\n                String.format(\"The wiki [%s] does not exist\", wikiId));\n        }\n\n        // Initialize wiki\n\n        xcontext.setWikiId(wikiId);\n        xcontext.setOriginalWikiId(wikiId);\n\n        if (!xwiki.initializeWiki(wikiId, wait, xcontext)) {\n            // The wiki is still initializing\n            return null;\n        }\n\n        return xwiki;\n    }\n\n    /**\n     * @param wikiId the identifier of the wiki\n     * @return the current {@link WikiInitializerJob} associated to the passed wiki or null if there is none\n     */\n    public Job getWikiInitializerJob(String wikiId)\n    {\n        return this.initializedWikis.get(wikiId);\n    }\n\n    /**\n     * Make sure the wiki is initializing or wait for it.\n     * \n     * @param wikiId the identifier of the wiki to initialize\n     * @param wait true if the method should return only when the wiki is fully initialized\n     * @return true if the wiki is fully initialized\n     * @param xcontext the XWiki context\n     * @throws XWikiException when the initialization failed\n     * @since 8.4RC1\n     */\n    public boolean initializeWiki(String wikiId, boolean wait, XWikiContext xcontext) throws XWikiException\n    {\n        Job wikiJob = this.initializedWikis.get(wikiId);\n\n        // Create and start the job if it does not exist\n        if (wikiJob == null) {\n            try {\n                wikiJob = initializeWiki(wikiId, xcontext);\n            } catch (JobException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Could not start [\" + wikiId + \"] wiki initialization\", e);\n            }\n        }\n\n        // Check if the job is done\n        if (wikiJob.getStatus().getState() == State.FINISHED) {\n            return true;\n        }\n\n        // Wait until the job is finished if asked to\n        if (wait) {\n            try {\n                wikiJob.join();\n            } catch (InterruptedException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Wiki [\" + wikiId + \"] initialization was interrupted unexpectedly\", e);\n            }\n\n            if (wikiJob.getStatus().getError() != null) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_INIT_FAILED,\n                    \"Wiki [\" + wikiId + \"] initialization failed\", wikiJob.getStatus().getError());\n            }\n\n            return true;\n        }\n\n        // Still initializing\n        return false;\n    }\n\n    private Job initializeWiki(String wikiId, XWikiContext xcontext) throws JobException\n    {\n        synchronized (this.initializedWikis) {\n            WikiInitializerJob wikiJob = this.initializedWikis.get(wikiId);\n\n            if (wikiJob == null) {\n                WikiInitializerRequest request = new WikiInitializerRequest(wikiId);\n\n                JobRequestContext.set(request, xcontext);\n\n                wikiJob = (WikiInitializerJob) getJobExecutor().execute(WikiInitializerJob.JOBTYPE, request);\n                this.initializedWikis.put(wikiId, wikiJob);\n            }\n\n            return wikiJob;\n        }\n    }\n\n    private static EntityResourceReference initializeResourceFromURL(XWikiContext context) throws XWikiException\n    {\n        // Extract the Entity Resource from the URL\n        // TODO: This code should be put in an ExecutionContextInitializer but we couldn't do yet since this code\n        // requires that the XWiki object be initialized first (the line above). Thus we'll be able to to move it only\n        // after the XWiki init is done also in an ExecutionContextInitializer (and with priorities).\n        @SuppressWarnings(\"deprecation\")\n        EntityResourceReference entityResourceReference;\n        URL url = context.getURL();\n        try {\n            ExtendedURL extendedURL = new ExtendedURL(url, context.getRequest().getContextPath());\n            ResourceTypeResolver<ExtendedURL> typeResolver =\n                Utils.getComponent(new DefaultParameterizedType(null, ResourceTypeResolver.class, ExtendedURL.class));\n            ResourceType type = typeResolver.resolve(extendedURL, Collections.<String, Object>emptyMap());\n            ResourceReferenceResolver<ExtendedURL> resourceResolver = Utils\n                .getComponent(new DefaultParameterizedType(null, ResourceReferenceResolver.class, ExtendedURL.class));\n            ResourceReference reference =\n                resourceResolver.resolve(extendedURL, type, Collections.<String, Object>emptyMap());\n            entityResourceReference =\n                reference instanceof EntityResourceReference ? (EntityResourceReference) reference : null;\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_APP_URL_EXCEPTION,\n                String.format(\"Failed to extract Entity Resource Reference from URL [%s]\", url), e);\n        }\n        Utils.getComponent(Execution.class).getContext().setProperty(ResourceReferenceManager.RESOURCE_CONTEXT_PROPERTY,\n            entityResourceReference);\n\n        return entityResourceReference;\n    }\n\n    public static URL getRequestURL(XWikiRequest request) throws XWikiException\n    {\n        return HttpServletUtils.getSourceURL(request);\n    }\n\n    public static Object callPrivateMethod(Object obj, String methodName)\n    {\n        return callPrivateMethod(obj, methodName, null, null);\n    }\n\n    public static Object callPrivateMethod(Object obj, String methodName, Class<?>[] classes, Object[] args)\n    {\n        try {\n            Method method = obj.getClass().getDeclaredMethod(methodName, classes);\n            method.setAccessible(true);\n            return method.invoke(obj, args);\n        } catch (IllegalAccessException e) {\n            LOGGER.error(\"Failed to call private method [{}]: [{}]\", methodName, e);\n\n            return null;\n        } catch (NoSuchMethodException e) {\n            return null;\n        } catch (InvocationTargetException e) {\n            LOGGER.error(\"Private method [{}] failed: [{}]\", methodName, e);\n\n            return null;\n        }\n    }\n\n    public static HttpClient getHttpClient(int timeout, String userAgent)\n    {\n        HttpClient client = new HttpClient();\n\n        if (timeout != 0) {\n            client.getParams().setSoTimeout(timeout);\n            client.getParams().setParameter(\"http.connection.timeout\", Integer.valueOf(timeout));\n        }\n\n        client.getParams().setParameter(\"http.useragent\", userAgent);\n\n        String proxyHost = System.getProperty(\"http.proxyHost\");\n        String proxyPort = System.getProperty(\"http.proxyPort\");\n        if ((proxyHost != null) && (!proxyHost.equals(\"\"))) {\n            int port = 3128;\n            if ((proxyPort != null) && (!proxyPort.equals(\"\"))) {\n                port = Integer.parseInt(proxyPort);\n            }\n            client.getHostConfiguration().setProxy(proxyHost, port);\n        }\n\n        String proxyUser = System.getProperty(\"http.proxyUser\");\n        if ((proxyUser != null) && (!proxyUser.equals(\"\"))) {\n            String proxyPassword = System.getProperty(\"http.proxyPassword\");\n            Credentials defaultcreds = new UsernamePasswordCredentials(proxyUser, proxyPassword);\n            client.getState().setProxyCredentials(AuthScope.ANY, defaultcreds);\n        }\n\n        return client;\n    }\n\n    /**\n     * Using reflection, read the private value of the passed field name for the passed object.\n     *\n     * @param obj the java object on which to read the private field value\n     * @param fieldName the object member field for which to read the value\n     * @return the private value for the field\n     * @deprecated use {@link FieldUtils#readDeclaredField(Object, String, boolean)} instead\n     */\n    @Deprecated\n    public static Object getPrivateField(Object obj, String fieldName)\n    {\n        try {\n            Field field = obj.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n            return field.get(obj);\n        } catch (NoSuchFieldException e) {\n            return null;\n        } catch (IllegalAccessException e) {\n            LOGGER.error(\"Failed to get private field with name [{}]: [{}]\", fieldName, e);\n\n            return null;\n        } finally {\n        }\n    }\n\n    public static String getServerWikiPage(String servername)\n    {\n        return \"XWiki.XWikiServer\" + StringUtils.capitalize(servername);\n    }\n\n    /**\n     * @param content the content of the text area\n     * @param context see {@link XWikiContext}\n     */\n    public static String getTextArea(String content, XWikiContext context)\n    {\n        StringBuilder result = new StringBuilder();\n\n        // Forcing a new line after the <textarea> tag, as\n        // http://www.w3.org/TR/html4/appendix/notes.html#h-B.3.1 causes an empty line at the start\n        // of the document content to be trimmed.\n        result.append(\"<textarea name=\\\"content\\\" id=\\\"content\\\" rows=\\\"25\\\" cols=\\\"80\\\">\\n\");\n        result.append(XMLUtils.escape(content));\n        result.append(\"</textarea>\");\n\n        return result.toString();\n    }\n\n    /**\n     * This provide a way to create an XWiki object without initializing the whole XWiki (including plugins, storage,\n     * etc.).\n     * <p>\n     * Needed for tools or tests which need XWiki because it is used everywhere in the API.\n     */\n    public XWiki()\n    {\n        // Empty voluntarily\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public XWiki(XWikiContext context, XWikiEngineContext engineContext, boolean noupdate) throws XWikiException\n    {\n        initXWiki(context, engineContext, noupdate);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public XWiki(XWikiContext context) throws XWikiException\n    {\n        this(context, null, false);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     */\n    public void initXWiki(XWikiContext context, XWikiEngineContext engineContext, boolean noupdate)\n        throws XWikiException\n    {\n        initXWiki(null, context, engineContext, noupdate);\n    }\n\n    /**\n     * Initialize all xwiki subsystems.\n     *\n     * @param config the object holding the XWiki configuration read from {@code xwiki.cfg}\n     * @param context see {@link XWikiContext}\n     * @param engineContext the XWiki object wrapping the {@link javax.servlet.ServletContext} and which allows to set\n     *            data that live on as long as the XWiki webapp is not stopped in the Servlet Container\n     * @param noupdate true if the whole initialization should be done (create mandatory xlcasses, initialize stats\n     *            service), i.e. if this is not an update, and false otherwise\n     * @throws XWikiException if an error happened during initialization (failure to initialize some cache for example)\n     * @deprecated since 6.1M2, use {@link #initXWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public void initXWiki(XWikiConfig config, XWikiContext context, XWikiEngineContext engineContext, boolean noupdate)\n        throws XWikiException\n    {\n        getProgress().pushLevelProgress(4, this);\n\n        try {\n            getProgress().startStep(this);\n\n            setDatabase(context.getMainXWiki());\n\n            setEngineContext(engineContext);\n            context.setWiki(this);\n\n            // \"Pre-initialize\" XWikiStubContextProvider with a XWikiContext containing a XWiki instance as soon as\n            // possible\n            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class).initialize(context);\n\n            // Prepare the store\n            if (config != null) {\n                setConfig(config);\n            }\n\n            try {\n                initializeStores();\n            } catch (ComponentLookupException e) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE, XWikiException.ERROR_XWIKI_UNKNOWN,\n                    \"Failed to initialize stores\", e);\n            }\n\n            setCriteriaService((XWikiCriteriaService) createClassFromConfig(\"xwiki.criteria.class\",\n                \"com.xpn.xwiki.criteria.impl.XWikiCriteriaServiceImpl\", context));\n\n            // \"Pre-initialize\" XWikiStubContextProvider so that rendering engine, plugins or listeners reacting to\n            // potential document changes can use it\n            Utils.<XWikiStubContextProvider>getComponent(XWikiStubContextProvider.class).initialize(context);\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            // Make sure these classes exists\n            if (noupdate) {\n                getProgress().pushLevelProgress(2, this);\n\n                try {\n                    getProgress().startStep(this);\n\n                    initializeMandatoryDocuments(context);\n\n                    getProgress().startStep(this);\n\n                    getStatsService(context);\n                } finally {\n                    getProgress().popLevelProgress(this);\n                }\n            }\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            // Prepare the Plugin Engine\n            preparePlugins(context);\n\n            getProgress().endStep(this);\n\n            getProgress().startStep(this);\n\n            String ro = getConfiguration().getProperty(\"xwiki.readonly\", \"no\");\n            this.isReadOnly = (\"yes\".equalsIgnoreCase(ro) || \"true\".equalsIgnoreCase(ro) || \"1\".equalsIgnoreCase(ro));\n\n            getObservationManager().addListener(this);\n        } finally {\n            getProgress().popLevelProgress(this);\n        }\n    }\n\n    private void initializeStores() throws ComponentLookupException\n    {\n        XWikiStoreInterface mainStore = getStoreConfiguration().getXWikiStore();\n\n        // Check if we need to use the cache store..\n        if (getStoreConfiguration().isStoreCacheEnabled()) {\n            XWikiCacheStoreInterface cachestore =\n                (XWikiCacheStoreInterface) Utils.getComponent(XWikiStoreInterface.class, \"cache\");\n            cachestore.setStore(mainStore);\n            setStore(cachestore);\n        } else {\n            setStore(mainStore);\n        }\n\n        setDefaultAttachmentContentStore(getStoreConfiguration().getXWikiAttachmentStore());\n        setVersioningStore(getStoreConfiguration().getXWikiVersioningStore());\n        setDefaultAttachmentArchiveStore(getStoreConfiguration().getAttachmentVersioningStore());\n        setRecycleBinStore(getStoreConfiguration().getXWikiRecycleBinStore());\n        setAttachmentRecycleBinStore(getStoreConfiguration().getAttachmentRecycleBinStore());\n    }\n\n    /**\n     * Ensure that mandatory classes (ie classes XWiki needs to work properly) exist and create them if they don't\n     * exist.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public void initializeMandatoryDocuments(XWikiContext context)\n    {\n        if (context.get(\"initdone\") == null) {\n            @SuppressWarnings(\"deprecation\")\n            List<MandatoryDocumentInitializer> initializers =\n                Utils.getComponentList(MandatoryDocumentInitializer.class);\n\n            // Sort the initializers based on priority. Lower priority values are first.\n            Collections.sort(initializers, new Comparator<MandatoryDocumentInitializer>()\n            {\n                @Override\n                public int compare(MandatoryDocumentInitializer left, MandatoryDocumentInitializer right)\n                {\n                    Priority leftPriority = left.getClass().getAnnotation(Priority.class);\n                    int leftPriorityValue =\n                        leftPriority != null ? leftPriority.value() : MandatoryDocumentInitializer.DEFAULT_PRIORITY;\n\n                    Priority rightPriority = right.getClass().getAnnotation(Priority.class);\n                    int rightPriorityValue =\n                        rightPriority != null ? rightPriority.value() : MandatoryDocumentInitializer.DEFAULT_PRIORITY;\n\n                    // Compare the two.\n                    return leftPriorityValue - rightPriorityValue;\n                }\n            });\n\n            getObservationManager().notify(MandatoryDocumentsInitializingEvent.EVENT, null);\n\n            getProgress().pushLevelProgress(initializers.size(), this);\n\n            try {\n                for (MandatoryDocumentInitializer initializer : initializers) {\n                    getProgress().startStep(this);\n\n                    initializeMandatoryDocument(initializer, context);\n\n                    getProgress().endStep(this);\n                }\n            } finally {\n                getProgress().popLevelProgress(this);\n            }\n\n            getObservationManager().notify(MandatoryDocumentsInitializedEvent.EVENT, null);\n        }\n    }\n\n    private void initializeMandatoryDocument(String wiki, MandatoryDocumentInitializer initializer,\n        XWikiContext context)\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            context.setWikiId(wiki);\n\n            initializeMandatoryDocument(initializer, context);\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    private void initializeMandatoryDocument(MandatoryDocumentInitializer initializer, XWikiContext context)\n    {\n        try {\n            DocumentReference documentReference =\n                getCurrentReferenceDocumentReferenceResolver().resolve(initializer.getDocumentReference());\n\n            if (documentReference.getWikiReference().getName().equals(context.getWikiId())) {\n                XWikiDocument document = context.getWiki().getDocument(documentReference, context);\n\n                if (initializer.updateDocument(document)) {\n                    saveDocument(document,\n                        localizePlainOrKey(\"core.model.xclass.mandatoryUpdateProperty.versionSummary\"), context);\n                }\n            }\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to initialize mandatory document [{}]\", initializer.getDocumentReference(), e);\n        }\n    }\n\n    public XWikiStoreInterface getNotCacheStore()\n    {\n        XWikiStoreInterface store = getStore();\n        if (store instanceof XWikiCacheStoreInterface) {\n            store = ((XWikiCacheStoreInterface) store).getStore();\n        }\n        return store;\n    }\n\n    public XWikiHibernateStore getHibernateStore()\n    {\n        XWikiStoreInterface store = getStore();\n        if (store instanceof XWikiHibernateStore) {\n            return (XWikiHibernateStore) store;\n        } else if (store instanceof XWikiCacheStoreInterface) {\n            store = ((XWikiCacheStoreInterface) store).getStore();\n            if (store instanceof XWikiHibernateStore) {\n                return (XWikiHibernateStore) store;\n            } else {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, XWikiContext context) throws HibernateException, XWikiException\n    {\n        updateDatabase(wikiId, false, context);\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, boolean force, XWikiContext context)\n        throws HibernateException, XWikiException\n    {\n        updateDatabase(wikiId, force, true, context);\n    }\n\n    /**\n     * @param wikiId the id of the wiki\n     * @param force if the update of the databse should be forced\n     * @param initDocuments if mandatory document and plugin should be initialized for passed wiki\n     * @param context see {@link XWikiContext}\n     * @deprecated since 8.4RC1, use {@link #initializeWiki(String, boolean, XWikiContext)} instead\n     */\n    @Deprecated\n    public void updateDatabase(String wikiId, boolean force, boolean initDocuments, XWikiContext context)\n        throws HibernateException, XWikiException\n    {\n        initializeWiki(wikiId, true, context);\n    }\n\n    /**\n     * @return a cached list of all active virtual wikis (i.e. wikis who have been hit by a user request). To get a full\n     *         list of all virtual wikis database names use {@link WikiDescriptorManager#getAllIds()}.\n     * @deprecated\n     */\n    @Deprecated\n    public List<String> getVirtualWikiList()\n    {\n        return new ArrayList<>(this.initializedWikis.keySet());\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     * @return the full list of all wiki names of all defined wikis. The wiki names are computed from the names of\n     *         documents having a {@code XWiki.XWikiServerClass} object attached to them by removing the\n     *         {@code XWiki.XWikiServer} prefix and making it lower case. For example a page named\n     *         {@code XWiki.XWikiServerMyDatabase} would return {@code mydatabase} as the wiki name. This list will also\n     *         contain the main wiki.\n     *         <p>\n     *         Note: the wiki name is commonly also the name of the database where the wiki's data is stored. However,\n     *         if configured accordingly, the database can be diferent from the wiki name, like for example when setting\n     *         a wiki database prefix.\n     * @deprecated since 5.3, use {@link WikiDescriptorManager#getAllIds()} instead\n     */\n    @Deprecated\n    public List<String> getVirtualWikisDatabaseNames(XWikiContext context) throws XWikiException\n    {\n        WikiDescriptorManager descriptorManager = Utils.getComponent(WikiDescriptorManager.class);\n\n        try {\n            return new ArrayList<String>(descriptorManager.getAllIds());\n        } catch (WikiManagerException e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_UNKNOWN,\n                \"Failed to get the list of wikis\", e);\n        }\n    }\n\n    /**\n     * @return the cache containing the names of the wikis already initialized.\n     * @since 1.5M2.\n     * @deprecated\n     */\n    @Deprecated\n    public Cache<DocumentReference> getVirtualWikiCache()\n    {\n        return null;\n    }\n\n    /**\n     * Get the reference of the owner for the provider wiki.\n     *\n     * @param wikiName the technical name of the wiki\n     * @param context see {@link XWikiContext}\n     * @return the wiki owner or null if none is set\n     * @throws XWikiException failed to get wiki descriptor document\n     */\n    public String getWikiOwner(String wikiName, XWikiContext context) throws XWikiException\n    {\n        String wikiOwner;\n\n        String currentdatabase = context.getWikiId();\n        try {\n            context.setWikiId(context.getMainXWiki());\n\n            String serverwikipage = getServerWikiPage(wikiName);\n            XWikiDocument doc = getDocument(serverwikipage, context);\n\n            if (doc.isNew()) {\n                if (!context.isMainWiki(wikiName)) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI, XWikiException.ERROR_XWIKI_DOES_NOT_EXIST,\n                        \"The wiki \" + wikiName + \" does not exist\");\n                } else {\n                    wikiOwner = null;\n                }\n            } else {\n                wikiOwner = doc.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"owner\");\n                if (wikiOwner.indexOf(':') == -1) {\n                    wikiOwner = context.getMainXWiki() + \":\" + wikiOwner;\n                }\n            }\n        } finally {\n            context.setWikiId(currentdatabase);\n        }\n\n        return wikiOwner;\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    protected Object createClassFromConfig(String param, String defClass, XWikiContext context) throws XWikiException\n    {\n        String storeclass = getConfiguration().getProperty(param, defClass);\n        try {\n            Class<?>[] classes = new Class<?>[] { XWikiContext.class };\n            Object[] args = new Object[] { context };\n            Object result = Class.forName(storeclass).getConstructor(classes).newInstance(args);\n            return result;\n        } catch (Exception e) {\n            Throwable ecause = e;\n            if (e instanceof InvocationTargetException) {\n                ecause = ((InvocationTargetException) e).getTargetException();\n            }\n            Object[] args = { param, storeclass };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_STORE_CLASSINVOCATIONERROR, \"Cannot load class {1} from param {0}\", ecause,\n                args);\n        }\n    }\n\n    private void preparePlugins(XWikiContext context)\n    {\n        setPluginManager(new XWikiPluginManager(getXWikiPreference(\"plugins\", context), context));\n        String plugins = getConfiguration().getProperty(\"xwiki.plugins\", \"\");\n        if (!plugins.equals(\"\")) {\n            getPluginManager().addPlugins(StringUtils.split(plugins, \" ,\"), context);\n        }\n    }\n\n    /**\n     * @return the XWiki core version as specified in the {@link #VERSION_FILE} file\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String getVersion()\n    {\n        if (this.version == null) {\n            try {\n                InputStream is = getResourceAsStream(VERSION_FILE);\n                try {\n                    XWikiConfig properties = new XWikiConfig(is);\n                    this.version = properties.getProperty(VERSION_FILE_PROPERTY);\n                } finally {\n                    IOUtils.closeQuietly(is);\n                }\n            } catch (Exception e) {\n                // Failed to retrieve the version, log a warning and default to \"Unknown\"\n                LOGGER.warn(\"Failed to retrieve XWiki's version from [\" + VERSION_FILE + \"], using the [\"\n                    + VERSION_FILE_PROPERTY + \"] property.\", e);\n                this.version = \"Unknown version\";\n            }\n        }\n        return this.version;\n    }\n\n    public URL getResource(String s) throws MalformedURLException\n    {\n        return getEngineContext().getResource(s);\n    }\n\n    public InputStream getResourceAsStream(String s) throws MalformedURLException\n    {\n        InputStream is = getEngineContext().getResourceAsStream(s);\n        if (is == null) {\n            is = getEngineContext().getResourceAsStream(\"/\" + s);\n        }\n        return is;\n    }\n\n    public String getResourceContent(String name) throws IOException\n    {\n        if (getEngineContext() != null) {\n            try (InputStream is = getResourceAsStream(name)) {\n                if (is != null) {\n                    return IOUtils.toString(is, DEFAULT_ENCODING);\n                }\n            }\n        }\n        // Resources should always be encoded as UTF-8, to reduce the dependency on the system encoding\n        return FileUtils.readFileToString(new File(name), DEFAULT_ENCODING);\n    }\n\n    public Date getResourceLastModificationDate(String name)\n    {\n        try {\n            if (getEngineContext() != null) {\n                return Util.getFileLastModificationDate(getEngineContext().getRealPath(name));\n            }\n        } catch (Exception ex) {\n            // Probably a SecurityException or the file is not accessible (inside a war)\n            LOGGER.info(\"Failed to get file modification date: \" + ex.getMessage());\n        }\n        return new Date();\n    }\n\n    public byte[] getResourceContentAsBytes(String name) throws IOException\n    {\n        if (getEngineContext() != null) {\n            try (InputStream is = getResourceAsStream(name)) {\n                if (is != null) {\n                    return IOUtils.toByteArray(is);\n                }\n            } catch (Exception e) {\n            }\n        }\n        return FileUtils.readFileToByteArray(new File(name));\n    }\n\n    public boolean resourceExists(String name)\n    {\n        if (getEngineContext() != null) {\n            try {\n                if (getResource(name) != null) {\n                    return true;\n                }\n            } catch (IOException e) {\n            }\n        }\n        try {\n            File file = new File(name);\n            return file.exists();\n        } catch (Exception e) {\n            // Could be running under -security, which prevents calling file.exists().\n        }\n        return false;\n    }\n\n    public String getRealPath(String path)\n    {\n        return getEngineContext().getRealPath(path);\n    }\n\n    public String ParamAsRealPath(String key)\n    {\n        String param = getConfiguration().getProperty(key);\n        try {\n            return getRealPath(param);\n        } catch (Exception e) {\n            return param;\n        }\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public String ParamAsRealPath(String key, XWikiContext context)\n    {\n        return ParamAsRealPath(key);\n    }\n\n    public String ParamAsRealPathVerified(String param)\n    {\n        String path;\n        File fpath;\n\n        path = getConfiguration().getProperty(param);\n        if (path == null) {\n            return null;\n        }\n\n        fpath = new File(path);\n        if (fpath.exists()) {\n            return path;\n        }\n\n        path = getRealPath(path);\n        if (path == null) {\n            return null;\n        }\n\n        fpath = new File(path);\n        if (fpath.exists()) {\n            return path;\n        } else {\n        }\n        return null;\n    }\n\n    public XWikiStoreInterface getStore()\n    {\n        return this.store;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #getDefaultAttachmentContentStore()} instead\n     */\n    @Deprecated\n    public XWikiAttachmentStoreInterface getAttachmentStore()\n    {\n        return getDefaultAttachmentContentStore();\n    }\n\n    /**\n     * @return the store to use by default when saving a new attachment content\n     * @since 9.10RC1\n     */\n    public XWikiAttachmentStoreInterface getDefaultAttachmentContentStore()\n    {\n        return this.defaultAttachmentContentStore;\n    }\n\n    /**\n     * @return the store to use by default when saving a new attachment archive\n     * @since 9.10RC1\n     */\n    public AttachmentVersioningStore getDefaultAttachmentArchiveStore()\n    {\n        return this.defaultAttachmentArchiveStore;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #getDefaultAttachmentArchiveStore()} instead\n     */\n    @Deprecated\n    public AttachmentVersioningStore getAttachmentVersioningStore()\n    {\n        return getDefaultAttachmentArchiveStore();\n    }\n\n    public XWikiVersioningStoreInterface getVersioningStore()\n    {\n        return this.versioningStore;\n    }\n\n    public XWikiRecycleBinStoreInterface getRecycleBinStore()\n    {\n        return this.recycleBinStore;\n    }\n\n    public AttachmentRecycleBinStore getAttachmentRecycleBinStore()\n    {\n        return this.attachmentRecycleBinStore;\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, String comment,\n        XWikiContext context) throws XWikiException\n    {\n        checkSavingDocument(userReference, document, comment, false, context);\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        checkSavingDocument(userReference, document, \"\", false, context);\n    }\n\n    /**\n     * Check if the user is allowed to save the document.\n     * \n     * @param userReference the user responsible for the changes\n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param isMinorEdit true if the new version is a minor version\n     * @param context see {@link XWikiContext}\n     * @since 10.11.10\n     * @since 11.6\n     */\n    public void checkSavingDocument(DocumentReference userReference, XWikiDocument document, String comment,\n        boolean isMinorEdit, XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            // Switch to document wiki\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            // Make sure the document is ready to be saved\n            XWikiDocument originalDocument = prepareDocumentForSave(document, comment, isMinorEdit, context);\n\n            ObservationManager om = getObservationManager();\n\n            // Notify listeners about the document about to be created or updated\n\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n\n            if (om != null) {\n                CancelableEvent documentEvent;\n                if (originalDocument.isNew()) {\n                    documentEvent = new UserCreatingDocumentEvent(userReference, document.getDocumentReference());\n                } else {\n                    documentEvent = new UserUpdatingDocumentEvent(userReference, document.getDocumentReference());\n                }\n                om.notify(documentEvent, document, context);\n\n                // If the action has been canceled by the user then don't perform any save and throw an exception\n                if (documentEvent.isCanceled()) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        String.format(\"User [%s] has been denied the right to save the document [%s]. Reason: [%s]\",\n                            userReference, document.getDocumentReference(), documentEvent.getReason()));\n                }\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    private XWikiDocument prepareDocumentForSave(XWikiDocument document, String comment, boolean isMinorEdit,\n        XWikiContext context) throws XWikiException\n    {\n        // Set the store so we can use it for checking the max length.\n        if (document.getStore() == null) {\n            document.setStore(this.getStore());\n        }\n        String fullName = getLocalStringEntityReferenceSerializer().serialize(document.getDocumentReference());\n        // If it's a new doc we check its name length to avoid a nasty SQL error.\n        if (document.isNew() && fullName.length() > document.getLocalReferenceMaxLength()) {\n            java.lang.Object[] args = { fullName, document.getLocalReferenceMaxLength(), fullName.length() };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                XWikiException.ERROR_XWIKI_APP_DOCUMENT_PATH_TOO_LONG,\n                \"Cannot create document {0} because its full path is too long: only {1} characters are allowed and \"\n                    + \"current length is {2}.\",\n                null, args);\n        }\n\n        // Setting comment & minor edit before saving\n        document.setComment(StringUtils.defaultString(comment));\n        document.setMinorEdit(isMinorEdit);\n\n        // We need to save the original document since saveXWikiDoc() will reset it and we\n        // need that original document for the notification below.\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        // Make sure to always have an original document for listeners that need to compare with it.\n        // The only case where we have a null original document is supposedly when the document\n        // instance has been crafted and passed #saveDocument without using #getDocument\n        // (which is not a good practice)\n        // Also for document indicated as new make sure the previous document is accurate.\n        if (originalDocument == null || document.isNew()) {\n            XWikiDocument existing = getDocument(document.getDocumentReferenceWithLocale(), context);\n            // Switch the original document only if we actually find an existing document or if there is no original\n            // document in the first place\n            if (originalDocument == null || !existing.isNew()) {\n                originalDocument = existing;\n                document.setOriginalDocument(originalDocument);\n            }\n        }\n\n        return originalDocument;\n    }\n\n    /**\n     * @param doc the document to save\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        // If no comment is provided we should use an empty comment\n        saveDocument(doc, \"\", context);\n    }\n\n    /**\n     * @param doc the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument doc, String comment, XWikiContext context) throws XWikiException\n    {\n        saveDocument(doc, comment, false, context);\n    }\n\n    private void beforeSave(XWikiDocument document, XWikiContext context) throws XWikiException\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            CancelableEvent documentEvent;\n            if (document.getOriginalDocument().isNew()) {\n                documentEvent = new DocumentCreatingEvent(document.getDocumentReference());\n            } else {\n                documentEvent = new DocumentUpdatingEvent(document.getDocumentReference());\n            }\n            om.notify(documentEvent, document, context);\n\n            // If the action has been canceled by the user then don't perform any save and throw an exception\n            if (documentEvent.isCanceled()) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_SAVING_DOC,\n                    String.format(\"An Event Listener has cancelled the document save for [%s]. Reason: [%s]\",\n                        document.getDocumentReference(), documentEvent.getReason()));\n            }\n        }\n    }\n\n    private void afterSave(XWikiDocument document, XWikiContext context)\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            if (document.getOriginalDocument().isNew()) {\n                om.notify(new DocumentCreatedEvent(document.getDocumentReference()), document, context);\n            } else {\n                om.notify(new DocumentUpdatedEvent(document.getDocumentReference()), document, context);\n            }\n        }\n    }\n\n    /**\n     * Save the passed document in the store.\n     * <p>\n     * If document is not new and metadata and content dirty flags are false, the version/history won't be incremented\n     * (only the current state will be updated).\n     * <p>\n     * Since 11.1, if document#isNew() return true, any pre existing document will be backuped in the deleted documents\n     * store automatically and completely replaced.\n     * \n     * @param document the document to save\n     * @param comment the comment to associated to the new version of the saved document\n     * @param isMinorEdit true if the new version is a minor version\n     * @param context see {@link XWikiContext}\n     */\n    public void saveDocument(XWikiDocument document, String comment, boolean isMinorEdit, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            // Switch to document wiki\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            // Make sure the document is ready to be saved\n            XWikiDocument originalDocument = prepareDocumentForSave(document, comment, isMinorEdit, context);\n\n            // Notify listeners about the document about to be created or updated\n\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            beforeSave(document, context);\n\n            // Delete existing document if we replace with a new one\n            if (document.isNew()) {\n                if (!originalDocument.isNew()) {\n                    // We don't want to notify about this delete since from outside world point of view it's an update\n                    // and not a delete+create\n                    deleteDocument(originalDocument, true, false, context);\n                }\n            } else {\n                // Put attachments to remove in recycle bin\n                if (hasAttachmentRecycleBin(context)) {\n                    for (XWikiAttachmentToRemove attachment : document.getAttachmentsToRemove()) {\n                        if (attachment.isToRecycleBin()\n                            // Only store the attachment to the trash bin if it's not broken\n                            && attachment.getAttachment().contentExists(context)) {\n                            // Make sure the attachment will be stored with its history\n                            attachment.getAttachment().loadArchive(context);\n                            getAttachmentRecycleBinStore().saveToRecycleBin(attachment.getAttachment(),\n                                context.getUser(), new Date(), context, true);\n                        }\n                    }\n                }\n            }\n\n            // Actually save the document.\n            getStore().saveXWikiDoc(document, context);\n\n            // Since the store#saveXWikiDoc resets originalDocument, we need to temporarily put it\n            // back to send notifications.\n            XWikiDocument newOriginal = document.getOriginalDocument();\n\n            try {\n                document.setOriginalDocument(originalDocument);\n\n                // Notify listeners about the document having been created or updated\n\n                // First the legacy notification mechanism\n\n                // Then the new observation module\n                // Note that for the moment the event being send is a bridge event, as we are still passing around\n                // an XWikiDocument as source and an XWikiContext as data.\n                // The old version is made available using doc.getOriginalDocument()\n                afterSave(document, context);\n            } catch (Exception ex) {\n                LOGGER.error(\"Failed to send document save notification for document [\"\n                    + getDefaultEntityReferenceSerializer().serialize(document.getDocumentReference()) + \"]\", ex);\n            } finally {\n                document.setOriginalDocument(newOriginal);\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Loads a XWikiDocument from the store.\n     * <p>\n     * Before 7.2M1 the reference is assumed to be a complete or incomplete document reference.\n     * <p>\n     * Since 7.2M1, the passed reference can be anything. If if a document child, the document reference will be\n     * extracted from it. If it's a document parent it will be completed with the necessary default references (for\n     * example if it's a space reference it will load the space home page).\n     *\n     * @param reference the reference of the document\n     * @param context see {@link XWikiContext}\n     * @since 5.0M1\n     */\n    public XWikiDocument getDocument(EntityReference reference, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument document;\n\n        if (reference.getType() == EntityType.PAGE || reference.getType().isAllowedAncestor(EntityType.PAGE)) {\n            document = getDocument(getCurrentGetPageResolver().resolve(reference), context);\n        } else {\n            document = getDocument(getCurrentGetDocumentResolver().resolve(reference), context);\n        }\n\n        return document;\n    }\n\n    /**\n     * Loads a XWikiDocument from the store.\n     *\n     * @param reference the reference of the document to be loaded\n     * @param type the type of the reference\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 10.6RC1\n     */\n    public XWikiDocument getDocument(String reference, EntityType type, XWikiContext xcontext) throws XWikiException\n    {\n        return getDocument(getRelativeEntityReferenceResolver().resolve(reference, type), xcontext);\n    }\n\n    /**\n     * @param doc the document\n     * @param context see {@link XWikiContext}\n     */\n    public XWikiDocument getDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        String currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(doc.getDocumentReference().getWikiReference().getName());\n\n            try {\n                // Indicate the the async context manipulated documents\n                getAsyncContext().useEntity(doc.getDocumentReferenceWithLocale());\n            } catch (Exception e) {\n                // If the AsyncContext component does not work then we are not in an asynchronous context anyway\n                LOGGER.debug(\"Failed to register the document in the asynchronous context\", e);\n            }\n\n            return getStore().loadXWikiDoc(doc, context);\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * @param reference the reference of the document to load\n     * @param revision the revision of the document to load\n     * @param context the XWiki context\n     * @return the document corresponding to the passed revision or a new XWikiDocument instance if none can be found\n     * @throws XWikiException when failing to load the document revision\n     * @since 9.4RC1\n     * @deprecated sine 9.10RC1, use {@link DocumentRevisionProvider#getRevision(DocumentReference, String)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(DocumentReference reference, String revision, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument revisionDocument = getDocumentRevisionProvider().getRevision(reference, revision);\n\n        if (revisionDocument == null && (revision.equals(\"1.1\") || revision.equals(\"1.0\"))) {\n            revisionDocument = new XWikiDocument(reference);\n        }\n\n        return revisionDocument;\n    }\n\n    /**\n     * @param document the reference document\n     * @param revision the revision of the document to load\n     * @param context the XWiki context\n     * @return the document corresponding to the passed revision or a new XWikiDocument instance if none can be found\n     * @throws XWikiException when failing to load the document revision\n     * @deprecated sine 9.10RC1, use {@link DocumentRevisionProvider#getRevision(XWikiDocument, String)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(XWikiDocument document, String revision, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument revisionDocument = getDocumentRevisionProvider().getRevision(document, revision);\n\n        if (revisionDocument == null && (revision.equals(\"1.1\") || revision.equals(\"1.0\"))) {\n            revisionDocument = new XWikiDocument(document.getDocumentReference());\n        }\n\n        return revisionDocument;\n    }\n\n    /**\n     * @param reference the reference of the document\n     * @param context see {@link XWikiContext}\n     * @since 2.2M1\n     */\n    public XWikiDocument getDocument(DocumentReference reference, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(\n            reference.getLocale() != null ? new DocumentReference(reference, (Locale) null) : reference,\n            reference.getLocale());\n\n        doc.setContentDirty(true);\n\n        return getDocument(doc, context);\n    }\n\n    /**\n     * @param reference the reference of the page\n     * @param context see {@link XWikiContext}\n     * @since 10.6RC1\n     */\n    public XWikiDocument getDocument(PageReference reference, XWikiContext context) throws XWikiException\n    {\n        DocumentReference documentReference = getCurrentReferenceDocumentReferenceResolver().resolve(reference);\n\n        XWikiDocument document = getDocument(documentReference, context);\n\n        if (document.isNew() && documentReference.getParent().getParent().getType() == EntityType.SPACE) {\n            // Try final page\n            XWikiDocument finalDocument = getDocument(new DocumentReference(documentReference.getParent().getName(),\n                documentReference.getParent().getParent(), documentReference.getParameters()), context);\n\n            if (!finalDocument.isNew()) {\n                document = finalDocument;\n            }\n        }\n\n        return document;\n    }\n\n    /**\n     * Find the document reference corresponding to the entity reference based on what exist in the database (page\n     * reference can means two different documents for example).\n     * \n     * @param reference the reference to resolve\n     * @param context the XWiki context\n     * @return the document reference\n     * @since 10.6RC1\n     */\n    public DocumentReference getDocumentReference(EntityReference reference, XWikiContext context)\n    {\n        DocumentReference documentReference = getCurrentGetDocumentResolver().resolve(reference);\n\n        // If the document has been found or it's top level space, return the reference\n        if (documentReference.getParent().getParent().getType() != EntityType.SPACE\n            || exists(documentReference, context)) {\n            return documentReference;\n        }\n\n        // Try final page\n        DocumentReference finalPageReference = new DocumentReference(documentReference.getParent().getName(),\n            documentReference.getParent().getParent(), documentReference.getParameters());\n\n        return exists(finalPageReference, context) ? finalPageReference : documentReference;\n    }\n\n    /**\n     * @param fullname the reference of the document as String\n     * @param context see {@link XWikiContext}\n     * @deprecated since 2.2M1 use {@link #getDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(String fullname, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setFullName(fullname, context);\n        return getDocument(doc, context);\n    }\n\n    /**\n     * @param spaces the reference of the space as String\n     * @param fullname the reference of the document as String\n     * @param context see {@link XWikiContext}\n     * @deprecated since 2.2M1 use {@link #getDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public XWikiDocument getDocument(String spaces, String fullname, XWikiContext context) throws XWikiException\n    {\n        int dotPosition = fullname.lastIndexOf('.');\n        if (dotPosition != -1) {\n            String spaceFromFullname = fullname.substring(0, dotPosition);\n            String name = fullname.substring(dotPosition + 1);\n            if (name.equals(\"\")) {\n                name = getDefaultPage(context);\n            }\n            return getDocument(spaceFromFullname + \".\" + name, context);\n        } else {\n            return getDocument(spaces + \".\" + fullname, context);\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocuments(String, String)\n     */\n    public XWikiDeletedDocument[] getDeletedDocuments(String fullname, String locale, XWikiContext context)\n        throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n            doc.setLanguage(locale);\n            return getRecycleBinStore().getAllDeletedDocuments(doc, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocuments(String)\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument[] getDeletedDocuments(String batchId, XWikiContext context) throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            return getRecycleBinStore().getAllDeletedDocuments(batchId, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocument(String, String, String)\n     * @deprecated since 9.4RC1. Use {@link #getDeletedDocument(long, XWikiContext)} instead.\n     */\n    @Deprecated\n    public XWikiDeletedDocument getDeletedDocument(String fullname, String locale, int index, XWikiContext context)\n        throws XWikiException\n    {\n        return getDeletedDocument(index, context);\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#getDeletedDocument(String)\n     * @since 9.4RC1\n     */\n    public XWikiDeletedDocument getDeletedDocument(long index, XWikiContext context) throws XWikiException\n    {\n        if (hasRecycleBin(context)) {\n            return getRecycleBinStore().getDeletedDocument(index, context, true);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document. Note that this does not distinguish\n     * between different incarnations of a document name, and it does not require that the document still exists, it\n     * returns all the attachments that at the time of their deletion had a document with the specified name as their\n     * owner.\n     *\n     * @param docName the {@link XWikiDocument#getFullName() name} of the owner document\n     * @param context see {@link XWikiContext}\n     * @return A list with all the deleted attachments which belonged to the specified document. If no such attachments\n     *         are found in the trash, an empty list is returned.\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, XWikiContext context) throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName));\n            return getAttachmentRecycleBinStore().getAllDeletedAttachments(doc, context, true);\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document and had the specified name. Multiple\n     * versions can be returned since the same file can be uploaded and deleted several times, creating different\n     * instances in the trash. Note that this does not distinguish between different incarnations of a document name,\n     * and it does not require that the document still exists, it returns all the attachments that at the time of their\n     * deletion had a document with the specified name as their owner.\n     *\n     * @param docName the {@link DeletedAttachment#getDocName() name of the document} the attachment belonged to\n     * @param filename the {@link DeletedAttachment#getFilename() name} of the attachment to search for\n     * @param context see {@link XWikiContext}\n     * @return A list with all the deleted attachments which belonged to the specified document and had the specified\n     *         filename. If no such attachments are found in the trash, an empty list is returned.\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, String filename, XWikiContext context)\n        throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName));\n            XWikiAttachment attachment = new XWikiAttachment(doc, filename);\n            return getAttachmentRecycleBinStore().getAllDeletedAttachments(attachment, context, true);\n        }\n        return null;\n    }\n\n    /**\n     * Retrieve a specific attachment from the trash.\n     *\n     * @param id the unique identifier of the entry in the trash\n     * @param context the XWiki context\n     * @return specified attachment from the trash, {@code null} if not found\n     * @throws XWikiException if an error occurs while loading the attachments\n     */\n    public DeletedAttachment getDeletedAttachment(String id, XWikiContext context) throws XWikiException\n    {\n        if (hasAttachmentRecycleBin(context)) {\n            return getAttachmentRecycleBinStore().getDeletedAttachment(NumberUtils.toLong(id), context, true);\n        }\n        return null;\n    }\n\n    public MetaClass getMetaclass()\n    {\n        if (this.metaclass == null) {\n            this.metaclass = MetaClass.getMetaClass();\n        }\n        return this.metaclass;\n    }\n\n    public void setMetaclass(MetaClass metaclass)\n    {\n        this.metaclass = metaclass;\n    }\n\n    /**\n     * @param context see {@link XWikiContext}\n     */\n    public List<String> getClassList(XWikiContext context) throws XWikiException\n    {\n        List<String> result = getStore().getClassList(context);\n        Collections.sort(result);\n        return result;\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, 0, 0, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param nb limit the number of results to return\n     * @param start the offset from which to start return results\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, int nb, int start, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, nb, start, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, Object[][] whereParams, XWikiContext context) throws XWikiException\n    {\n        return getStore().search(sql, 0, 0, whereParams, context);\n    }\n\n    /**\n     * @param sql the sql query to execute\n     * @param nb limit the number of results to return\n     * @param start the offset from which to start return results\n     * @param context see {@link XWikiContext}\n     */\n    public <T> List<T> search(String sql, int nb, int start, Object[][] whereParams, XWikiContext context)\n        throws XWikiException\n    {\n        return getStore().search(sql, nb, start, whereParams, context);\n    }\n\n    /**\n     * @param content the content to parse\n     * @param context see {@link XWikiContext}\n     * @deprecated Since 7.2M1. Use specific rendering/parsing options for the content type you want to parse/render.\n     */\n    @Deprecated\n    public String parseContent(String content, XWikiContext context)\n    {\n        return getOldRendering().parseContent(content, context);\n    }\n\n    /**\n     * @param template the name of the template\n     * @param context see {@link XWikiContext}\n     * @deprecated use {@link #evaluateTemplate(String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String parseTemplate(String template, XWikiContext context)\n    {\n        String result = \"\";\n\n        try {\n            result = evaluateTemplate(template, context);\n        } catch (Exception e) {\n            LOGGER.debug(\"Exception while parsing template [{}] from /templates/\", template, e);\n        }\n\n        return result;\n    }\n\n    /**\n     * Evaluate provided template content using velocity engine.\n     *\n     * @param template the template to evaluate\n     * @param context see {@link XWikiContext}\n     * @return the return of the velocity script\n     * @throws IOException failed to get the template content\n     * @since 2.2.2\n     * @deprecated since 7.0M1, use {@link TemplateManager#render(String)} instead\n     */\n    @Deprecated\n    public String evaluateTemplate(String template, XWikiContext context) throws IOException\n    {\n        try {\n            return getTemplateManager().render(template);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while evaluating velocity template [{}]\", template, e);\n\n            Object[] args = { template };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while evaluating velocity template {0}\",\n                e, args);\n\n            return Util.getHTMLExceptionMessage(xe, context);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param skinId the id of the skin from which to load the template\n     * @param context see {@link XWikiContext}\n     * @deprecated since 7.0M1, use {@link TemplateManager#renderFromSkin} instead\n     */\n    @Deprecated\n    public String parseTemplate(String template, String skinId, XWikiContext context)\n    {\n        MutableRenderingContext mutableRenderingContext = getMutableRenderingContext();\n\n        Syntax currentTargetSyntax = mutableRenderingContext.getTargetSyntax();\n        try {\n            // Force rendering with XHTML 1.0 syntax for retro-compatibility\n            mutableRenderingContext.setTargetSyntax(Syntax.XHTML_1_0);\n\n            Skin skin = getInternalSkinManager().getSkin(skinId);\n            return getTemplateManager().renderFromSkin(template, skin);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while evaluating velocity template [{}] skin [{}]\", template, skinId, e);\n\n            Object[] args = { template, skinId };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION,\n                \"Error while evaluating velocity template [{0}] from skin [{1}]\", e, args);\n\n            return Util.getHTMLExceptionMessage(xe, context);\n        } finally {\n            mutableRenderingContext.setTargetSyntax(currentTargetSyntax);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param skin the id of the skin from which to load the template\n     * @param context see {@link XWikiContext}\n     */\n    public String renderTemplate(String template, String skin, XWikiContext context)\n    {\n        try {\n            return getOldRendering().renderTemplate(template, skin, context);\n        } catch (Exception ex) {\n            LOGGER.error(\"Failed to render template [\" + template + \"] for skin [\" + skin + \"]\", ex);\n            return parseTemplate(template, skin, context);\n        }\n    }\n\n    /**\n     * @param template the name of the template\n     * @param context see {@link XWikiContext}\n     */\n    public String renderTemplate(String template, XWikiContext context)\n    {\n        try {\n            return getOldRendering().renderTemplate(template, context);\n        } catch (Exception ex) {\n            LOGGER.error(\"Failed to render template [\" + template + \"]\", ex);\n            return parseTemplate(template, context);\n        }\n    }\n\n    /**\n     * @param iconName the standard name of an icon (it's not the name of the file on the filesystem, it's a generic\n     *            name, for example \"success\" for a success icon\n     * @param context see {@link XWikiContext}\n     * @return the URL to the icon resource\n     * @since 2.6M1\n     */\n    public String getIconURL(String iconName, XWikiContext context)\n    {\n        // TODO: Do a better mapping between generic icon name and physical resource name, especially to be independent\n        // of the underlying icon library. Right now we assume it's the Silk icon library.\n        return getSkinFile(\"icons/silk/\" + iconName + \".png\", context);\n    }\n\n    public String getSkinFile(String filename, XWikiContext context)\n    {\n        return getSkinFile(filename, false, context);\n    }\n\n    /**\n     * Build and return a skin file url based on the given parameters.\n     * \n     * @param filename the file name of the skin file wanted\n     * @param forceSkinAction if true force the usage of directory /skins/ in the URL\n     * @param context current context for the request\n     * @return a resource URL for the asked filename\n     */\n    public String getSkinFile(String filename, boolean forceSkinAction, XWikiContext context)\n    {\n        String skinFile = getSkinFile(filename, null, forceSkinAction, context);\n\n        if (skinFile == null) {\n            // Use the default base skin even if the URL could be invalid.\n            XWikiURLFactory urlf = context.getURLFactory();\n            URL url;\n            if (forceSkinAction) {\n                url = urlf.createSkinURL(filename, \"skins\", getDefaultBaseSkin(context), context);\n            } else {\n                url = urlf.createSkinURL(filename, getDefaultBaseSkin(context), context);\n            }\n            skinFile = urlf.getURL(url, context);\n        }\n\n        return skinFile;\n    }\n\n    private String getSkinFileInternal(String fileName, String skinId, boolean forceSkinAction, XWikiContext context)\n    {\n        try {\n            if (skinId != null) {\n                // Try only in the specified skin.\n                Skin skin = getInternalSkinManager().getSkin(skinId);\n                if (skin != null) {\n                    Resource<?> resource = skin.getLocalResource(fileName);\n                    if (resource != null) {\n                        return resource.getURL(forceSkinAction);\n                    }\n                }\n            } else {\n                // Try in the current skin.\n                Skin skin = getInternalSkinManager().getCurrentSkin(true);\n                if (skin != null) {\n                    Resource<?> resource = skin.getResource(fileName);\n                    if (resource != null) {\n                        return resource.getURL(forceSkinAction);\n                    }\n                } else {\n                    // Try in the current parent skin.\n                    Skin parentSkin = getInternalSkinManager().getCurrentParentSkin(true);\n                    if (parentSkin != null) {\n                        Resource<?> resource = parentSkin.getResource(fileName);\n                        if (resource != null) {\n                            return resource.getURL(forceSkinAction);\n                        }\n                    }\n                }\n            }\n\n            // Look for a resource file.\n            String resourceFilePath = \"/resources/\" + fileName;\n            XWikiURLFactory urlFactory = context.getURLFactory();\n            if (resourceExists(resourceFilePath)) {\n                URL url = urlFactory.createResourceURL(fileName, forceSkinAction, context,\n                    getResourceURLCacheParameters(resourceFilePath));\n                return urlFactory.getURL(url, context);\n            }\n        } catch (Exception e) {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Exception while getting skin file [{}] from skin [{}]\", fileName, skinId, e);\n            }\n        }\n\n        return null;\n    }\n\n    private Map<String, Object> getResourceURLCacheParameters(String resourceFilePath)\n    {\n        try {\n            URL resourceUrl = getResource(resourceFilePath);\n            return getResourceURLCacheParameters(resourceUrl);\n        } catch (MalformedURLException e) {\n            LOGGER.debug(\"Error while getting URL for resource path [{}]\", resourceFilePath, e);\n            return Collections.singletonMap(CACHE_VERSION, getVersion());\n        }\n    }\n\n    private Map<String, Object> getResourceURLCacheParameters(URL resourceUrl)\n    {\n        Map<String, Object> parameters = new LinkedHashMap<>();\n\n        if (getURLConfiguration().useResourceLastModificationDate()) {\n            try {\n                Path resourcePath = Paths.get(resourceUrl.toURI());\n                FileTime lastModifiedTime = Files.getLastModifiedTime(resourcePath);\n                parameters.put(CACHE_VERSION, String.valueOf(lastModifiedTime.toMillis()));\n            } catch (Exception e) {\n                LOGGER.debug(\"Error when trying to access properties of resource URL [{}]\", resourceUrl, e);\n                parameters.put(CACHE_VERSION, getVersion());\n            }\n        } else {\n            parameters.put(CACHE_VERSION, getVersion());\n        }\n\n        return parameters;\n    }\n\n    public String getSkinFile(String filename, String skin, XWikiContext context)\n    {\n        return getSkinFile(filename, skin, false, context);\n    }\n\n    public String getSkinFile(String fileName, String skinId, boolean forceSkinAction, XWikiContext context)\n    {\n        if (StringUtils.endsWithAny(fileName, \".js\", \".css\")) {\n            String extension = StringUtils.substringAfterLast(fileName, '.');\n            String shortFileName = StringUtils.substringBeforeLast(fileName, \".\");\n            if (StringUtils.endsWith(shortFileName, \".min\")) {\n                shortFileName = StringUtils.substringBeforeLast(shortFileName, \".\");\n            }\n            String fileNameSource = String.format(\"%s.%s\", shortFileName, extension);\n            String fileNameMinified = String.format(\"%s.min.%s\", shortFileName, extension);\n            DebugConfiguration debugConfig = Utils.getComponent(DebugConfiguration.class);\n            String[] fileNames = debugConfig.isMinify() ? new String[] {fileNameMinified, fileNameSource}\n                : new String[] {fileNameSource, fileNameMinified};\n            String skinFile = null;\n            for (String name : fileNames) {\n                skinFile = getSkinFileInternal(name, skinId, forceSkinAction, context);\n                if (skinFile != null) {\n                    break;\n                }\n            }\n            return skinFile;\n        } else {\n            return getSkinFileInternal(fileName, skinId, forceSkinAction, context);\n        }\n    }\n\n    /**\n     * @deprecated since 7.0M1, use {@link SkinManager#getCurrentSkin(boolean)} instead\n     */\n    @Deprecated\n    public String getSkin(XWikiContext context)\n    {\n        String skin;\n\n        try {\n            skin = getInternalSkinManager().getCurrentSkinId(true);\n        } catch (Exception e) {\n            LOGGER.debug(\"Exception while determining current skin\", e);\n            skin = getDefaultBaseSkin(context);\n        }\n\n        return skin;\n    }\n\n    public String getSkinPreference(String prefname, XWikiContext context)\n    {\n        return getSkinPreference(prefname, \"\", context);\n    }\n\n    public String getSkinPreference(String prefname, String defaultValue, XWikiContext context)\n    {\n        for (Skin skin = getInternalSkinManager().getCurrentSkin(true); skin != null; skin = skin.getParent()) {\n            if (skin instanceof WikiSkin) {\n                String value = getWikiSkinUtils().getSkinProperty(skin.getId(), prefname);\n\n                // TODO: remove the NO_VALUE test when XWIKI-10853 is fixed\n                if (!StringUtils.isEmpty(value) && !NO_VALUE.equals(value)) {\n                    return value;\n                }\n            }\n        }\n\n        return defaultValue;\n    }\n\n    /**\n     * @deprecated since 7.0M1, use {@link SkinManager#getDefaultParentSkin()} instead\n     */\n    @Deprecated\n    public String getDefaultBaseSkin(XWikiContext context)\n    {\n        return getInternalSkinManager().getDefaultParentSkinId();\n    }\n\n    /**\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    public String getBaseSkin(XWikiContext context)\n    {\n        return getBaseSkin(context, false);\n    }\n\n    /**\n     * @deprecated since 7.0M1\n     */\n    @Deprecated\n    public String getBaseSkin(XWikiContext context, boolean fromRenderSkin)\n    {\n        String baseskin = \"\";\n        try {\n            return getInternalSkinManager().getCurrentParentSkinId(false);\n        } catch (Exception e) {\n            baseskin = getDefaultBaseSkin(context);\n\n            LOGGER.debug(\"Exception while determining base skin\", e);\n        }\n\n        return baseskin;\n    }\n\n    /**\n     * @param skin the name of the skin for which to return the base skin. For example : {@code XWiki.DefaultSkin}\n     * @param context see {@link XWikiContext}\n     * @return if found, the name of the base skin the asked skin inherits from. If not found, returns an empty string.\n     * @since 2.0.2\n     * @since 2.1M1\n     * @deprecated since 7.0M1, use {@link SkinManager#getCurrentSkin(boolean)} and {@link Skin#getParent()} instead\n     */\n    @Deprecated\n    public String getBaseSkin(String skin, XWikiContext context)\n    {\n        String baseSkin = getInternalSkinManager().getParentSkin(skin);\n\n        return baseSkin != null ? baseSkin : \"\";\n    }\n\n    public String getSpaceCopyright(XWikiContext context)\n    {\n        return getSpacePreference(\"webcopyright\", \"\", context);\n    }\n\n    public String getXWikiPreference(String prefname, XWikiContext context)\n    {\n        return getXWikiPreference(prefname, \"\", context);\n    }\n\n    /**\n     * Obtain a preference value for the wiki, looking up first in the XWiki.XWikiPreferences document, then fallbacking\n     * on a config parameter when the first lookup gives an empty string, then returning the default value if the config\n     * parameter returned itself an empty string.\n     *\n     * @param prefname the parameter to look for in the XWiki.XWikiPreferences object in the XWiki.XWikiPreferences\n     *            document of the wiki.\n     * @param fallbackParam the parameter in xwiki.cfg to fallback on, in case the XWiki.XWikiPreferences object gave no\n     *            result\n     * @param defaultValue the default value to fallback on, in case both XWiki.XWikiPreferences and the fallback\n     *            xwiki.cfg parameter gave no result\n     */\n    public String getXWikiPreference(String prefname, String fallbackParam, String defaultValue, XWikiContext context)\n    {\n        String result = getWikiConfiguration().getProperty(prefname, String.class);\n\n        if (StringUtils.isEmpty(result)) {\n            result = getConfiguration().getProperty(fallbackParam, defaultValue);\n        }\n\n        return result != null ? result : \"\";\n    }\n\n    /**\n     * Obtain a preference value for the wiki, looking up first in the XWiki.XWikiPreferences document, then fallbacking\n     * on a config parameter when the first lookup gives an empty string, then returning the default value if the config\n     * parameter returned itself an empty string.\n     *\n     * @param prefname the parameter to look for in the XWiki.XWikiPreferences object in the XWiki.XWikiPreferences\n     *            document of the wiki.\n     * @param wiki the wiki to get preference from\n     * @param fallbackParam the parameter in xwiki.cfg to fallback on, in case the XWiki.XWikiPreferences object gave no\n     *            result\n     * @param defaultValue the default value to fallback on, in case both XWiki.XWikiPreferences and the fallback\n     *            xwiki.cfg parameter gave no result\n     * @since 7.4M1\n     */\n    public String getXWikiPreference(String prefname, String wiki, String fallbackParam, String defaultValue,\n        XWikiContext xcontext)\n    {\n        String currentWiki = xcontext.getWikiId();\n\n        try {\n            xcontext.setWikiId(wiki);\n\n            return getXWikiPreference(prefname, fallbackParam, defaultValue, xcontext);\n        } finally {\n            xcontext.setWikiId(currentWiki);\n        }\n    }\n\n    public String getXWikiPreference(String prefname, String defaultValue, XWikiContext context)\n    {\n        return getXWikiPreference(prefname, \"\", defaultValue, context);\n    }\n\n    public String getSpacePreference(String preference, XWikiContext context)\n    {\n        return getSpacePreference(preference, \"\", context);\n    }\n\n    public String getSpacePreference(String preference, String defaultValue, XWikiContext context)\n    {\n        return getSpacePreference(preference, (SpaceReference) null, defaultValue, context);\n    }\n\n    /**\n     * @deprecated since 7.4M1, use {@link #getSpacePreference(String, SpaceReference, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public String getSpacePreference(String preference, String space, String defaultValue, XWikiContext context)\n    {\n        return getSpacePreference(preference, new SpaceReference(space, context.getWikiReference()), defaultValue,\n            context);\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     * \n     * @param preferenceKey the name of the preference key\n     * @param spaceReference the reference of the space\n     * @param context see {@link XWikiContext}\n     * @return the value of the preference or empty String if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreference(String preferenceKey, SpaceReference spaceReference, XWikiContext context)\n    {\n        return getSpacePreference(preferenceKey, spaceReference, \"\", context);\n    }\n\n    /**\n     * Get the preference key for the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     * \n     * @param preferenceKey the name of the preference key\n     * @param spaceReference the reference of the space. If null and there's a current document then the current space\n     *                       is used. If null and there's no current document then fall back to the wiki preferences.\n     * @param defaultValue the value to return if the preference can't be found\n     * @param context see {@link XWikiContext}\n     * @return the value of the preference or <code>defaultValue</code> if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreference(String preferenceKey, SpaceReference spaceReference, String defaultValue,\n        XWikiContext context)\n    {\n        XWikiDocument currentDocument = context.getDoc();\n\n        try {\n            if (spaceReference != null) {\n                context.setDoc(new XWikiDocument(new DocumentReference(\"WebPreferences\", spaceReference)));\n            } else if (currentDocument != null) {\n                spaceReference = currentDocument.getDocumentReference().getLastSpaceReference();\n            }\n\n            String result = getSpaceConfiguration().getProperty(preferenceKey, String.class);\n\n            if (StringUtils.isEmpty(result)) {\n                if (spaceReference == null) {\n                    result = getXWikiPreference(preferenceKey, defaultValue, context);\n                } else if (spaceReference.getParent() instanceof SpaceReference) {\n                    result = getSpacePreference(preferenceKey, (SpaceReference) spaceReference.getParent(),\n                        defaultValue, context);\n                } else if (spaceReference.getParent() instanceof WikiReference) {\n                    result =\n                        getXWikiPreference(preferenceKey, spaceReference.getParent().getName(), defaultValue, context);\n                }\n            }\n\n            return result != null ? result : defaultValue;\n        } finally {\n            context.setDoc(currentDocument);\n        }\n    }\n\n    public String getUserPreference(String prefname, XWikiContext context)\n    {\n        String result =\n            getAllUserPropertiesResolver().resolve(CurrentUserReference.INSTANCE).getProperty(prefname, String.class);\n\n        return result != null ? result : \"\";\n    }\n\n    public String getUserPreferenceFromCookie(String prefname, XWikiContext context)\n    {\n        Cookie[] cookies = context.getRequest().getCookies();\n        if (cookies == null) {\n            return null;\n        }\n        for (Cookie cookie : cookies) {\n            String name = cookie.getName();\n            if (name.equals(prefname)) {\n                String value = cookie.getValue();\n                if (!value.trim().equals(\"\")) {\n                    return value;\n                } else {\n                    break;\n                }\n            }\n        }\n        return null;\n    }\n\n    public String getUserPreference(String prefname, boolean useCookie, XWikiContext context)\n    {\n        // First we look in the cookies\n        if (useCookie) {\n            String result = Util.normalizeLanguage(getUserPreferenceFromCookie(prefname, context));\n            if (result != null) {\n                return result;\n            }\n        }\n        return getUserPreference(prefname, context);\n    }\n\n    /**\n     * Set the locale in the given context.\n     * <p>\n     * If {@code forceSupported} is true, then the locale will be set only if it is in the {@see availableLocales}. Note\n     * that all the parent locales are checked.\n     *\n     * @param locale the locale to use\n     * @param context the context\n     * @param availableLocales the accepted locales. Used only if {@see forceSupported} is true\n     * @param forceSupported determine if the {@see locale} should be checked against the {@see availableLocales}\n     * @return the locale that has been set or null\n     */\n    private Locale setLocale(Locale locale, XWikiContext context, Set<Locale> availableLocales, boolean forceSupported)\n    {\n        while (locale != null) {\n            if (!forceSupported || availableLocales.contains(locale)) {\n                context.setLocale(locale);\n                break;\n            }\n            locale = LocaleUtils.getParentLocale(locale);\n        }\n\n        return locale;\n    }\n\n    /**\n     * The algorithm to find the locale to use is the following, in this order:\n     *\n     * <ul>\n     *   <li>Try to find the current locale in use from the XWiki contex</li>\n     *   <li>If the wiki is not multilingual use the wiki default locale ({@code default_language} xproperty in\n     *   {@code XWikiPreferences} xobject or English if not found)</li>\n     *   <li>If the wiki is multilingual<ul>\n     *     <li>Try to get the locale passed in the request (looking for a {@code language} query string parameter).\n     *     If the language value is {@code default} use the wiki default locale. If a parameter is found sets a\n     *     {@code language} cookie to remember the language in use.</li>\n     *     <li>Try to get the locale from the {@code language} cookie</li>\n     *     <li>If the default language is preferred ({@code xwiki.language.preferDefault} from {@code xwiki.cfg}\n     *     or {@code preferDefaultLanguage} property from the space preferences ({@code WebPreferences} xobject) or\n     *     wiki preferences ({@code XWikiPreferences} xobject})), and since the user didn't explicitly ask for a\n     *     language already, then use the wiki default locale.</li>\n     *     <li>Try to use the browser's {@code Accept-Language} header sent in HTTP request.<li>\n     *     <li>Fallback to the wiki default locale</li>\n     *   </ul></li>\n     * </ul>\n     *\n     * In addition the {code xwiki.language.forceSupported} configuration property is enabled by default and means that\n     * if at any step above the locale found is not in the list of supported locales, then the locale is not set and\n     * the algorithm moves to the next step.\n     *\n     * @return the locale to use\n     * @since 8.0M1\n     */\n    public Locale getLocalePreference(XWikiContext context)\n    {\n        Locale defaultLocale = this.getDefaultLocale(context);\n        Set<Locale> availableLocales = new HashSet<>(this.getAvailableLocales(context));\n        boolean forceSupported = getConfiguration().getProperty(\"xwiki.language.forceSupported\", \"1\").equals(\"1\");\n\n        // First we try to get the language from the XWiki Context. This is the current language\n        // being used.\n        Locale locale = context.getLocale();\n        if (locale != null) {\n            return locale;\n        }\n\n        // If the wiki is non multilingual then the language is the default language.\n        if (!isMultiLingual(context)) {\n            locale = defaultLocale;\n            context.setLocale(locale);\n            return locale;\n        }\n\n        // As the wiki is multilingual try to find the language to use from the request by looking\n        // for a language parameter. If the language value is \"default\" use the default language\n        // from the XWiki preferences settings. Otherwise set a cookie to remember the language\n        // in use.\n        try {\n            String language = Util.normalizeLanguage(context.getRequest().getParameter(\"language\"));\n            if (language != null) {\n                if (\"default\".equals(language)) {\n                    // forgetting language cookie\n                    Cookie cookie = new Cookie(\"language\", \"\");\n                    cookie.setMaxAge(0);\n                    cookie.setPath(\"/\");\n                    context.getResponse().addCookie(cookie);\n                    context.setLocale(defaultLocale);\n                    return defaultLocale;\n                } else {\n                    locale = setLocale(LocaleUtils.toLocale(language), context, availableLocales, forceSupported);\n                    if (LocaleUtils.isAvailableLocale(locale)) {\n                        // setting language cookie\n                        Cookie cookie = new Cookie(\"language\", context.getLocale().toString());\n                        cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                        cookie.setPath(\"/\");\n                        context.getResponse().addCookie(cookie);\n                        return locale;\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        // As no language parameter was passed in the request, try to get the language to use from a cookie.\n        try {\n            // First we get the language from the cookie\n            String language = Util.normalizeLanguage(getUserPreferenceFromCookie(\"language\", context));\n            if (StringUtils.isNotEmpty(language)) {\n                locale = setLocale(LocaleUtils.toLocale(language), context, availableLocales, forceSupported);\n                if (LocaleUtils.isAvailableLocale(locale)) {\n                    return locale;\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        // If the default language is preferred, and since the user didn't explicitly ask for a\n        // language already, then use the default wiki language.\n        if (getConfiguration().getProperty(\"xwiki.language.preferDefault\", \"0\").equals(\"1\")\n            || getSpacePreference(\"preferDefaultLanguage\", \"0\", context).equals(\"1\")) {\n            locale = defaultLocale;\n            context.setLocale(locale);\n            return locale;\n        }\n\n        // Then from the navigator language setting\n        if (context.getRequest() != null && context.getRequest().getLocales() != null) {\n            for (Locale acceptedLocale : Collections.list(context.getRequest().getLocales())) {\n                locale = setLocale(acceptedLocale, context, availableLocales, forceSupported);\n                if (LocaleUtils.isAvailableLocale(locale)) {\n                    return locale;\n                }\n            }\n            // If none of the languages requested by the client is acceptable, skip to next\n            // phase (use default language).\n        }\n\n        // Finally, use the default language from the global preferences.\n        context.setLocale(defaultLocale);\n        return defaultLocale;\n    }\n\n    /**\n     * First try to find the current locale in use from the XWiki context. If none is used and if the wiki is not\n     * multilingual use the default locale defined in the XWiki preferences. If the wiki is multilingual try to get the\n     * locale passed in the request. If none was passed try to get it from a cookie. If no locale cookie exists then use\n     * the user default locale and barring that use the browser's \"Accept-Language\" header sent in HTTP request. If none\n     * is defined use the default locale.\n     *\n     * @return the locale to use\n     * @deprecated since 8.0M1, use {@link #getLocalePreference(XWikiContext)} instead\n     */\n    @Deprecated\n    public String getLanguagePreference(XWikiContext context)\n    {\n        return getLocalePreference(context).toString();\n    }\n\n    /**\n     * Construct a list of language codes (ISO 639-1) from the Accept-Languages header. This method filters out some\n     * bugs in different browsers or containers, like returning '*' as a language (Jetty) or using '_' as a\n     * language--country delimiter (some versions of Opera).\n     *\n     * @param request The client request.\n     * @return A list of language codes, in the client preference order; might be empty if the header is not well\n     *         formed.\n     */\n    private List<String> getAcceptedLanguages(XWikiRequest request)\n    {\n        List<String> result = new ArrayList<String>();\n        Enumeration<Locale> e = request.getLocales();\n        while (e.hasMoreElements()) {\n            String language = e.nextElement().getLanguage().toLowerCase();\n            // All language codes should have 2 letters.\n            if (StringUtils.isAlpha(language)) {\n                result.add(language);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @deprecated since 5.1M2 use {@link #getDefaultLocale(XWikiContext)} instead\n     */\n    @Deprecated\n    public String getDefaultLanguage(XWikiContext xcontext)\n    {\n        return getDefaultLocale(xcontext).toString();\n    }\n\n    /**\n     * The default locale in the preferences.\n     *\n     * @param xcontext the XWiki context.\n     * @return the default locale\n     * @since 5.1M2\n     */\n    public Locale getDefaultLocale(XWikiContext xcontext)\n    {\n        // Find out what is the default language from the XWiki preferences settings.\n        String defaultLanguage = xcontext.getWiki().getXWikiPreference(\"default_language\", \"\", xcontext);\n\n        Locale defaultLocale;\n\n        if (StringUtils.isBlank(defaultLanguage)) {\n            defaultLocale = Locale.ENGLISH;\n        } else {\n            try {\n                defaultLocale = LocaleUtils.toLocale(Util.normalizeLanguage(defaultLanguage));\n            } catch (Exception e) {\n                LOGGER.warn(\"Invalid locale [{}] set as default locale in the preferences\", defaultLanguage);\n                defaultLocale = Locale.ENGLISH;\n            }\n        }\n\n        return defaultLocale;\n    }\n\n    /**\n     * Get the available locales according to the preferences.\n     *\n     * @param xcontext the XWiki context\n     * @return all the available locales\n     * @since 5.1M2\n     */\n    public List<Locale> getAvailableLocales(XWikiContext xcontext)\n    {\n        String[] languages = StringUtils.split(xcontext.getWiki().getXWikiPreference(\"languages\", xcontext), \", |\");\n\n        List<Locale> locales = new ArrayList<Locale>(languages.length);\n\n        for (String language : languages) {\n            if (StringUtils.isNotBlank(language)) {\n                try {\n                    locales.add(LocaleUtils.toLocale(language));\n                } catch (Exception e) {\n                    LOGGER.warn(\"Invalid locale [{}] listed as available in the preferences\", language);\n                }\n            }\n        }\n\n        // Add default language in case it's not listed as available (which is wrong but it happen)\n        Locale defaultocale = getDefaultLocale(xcontext);\n        if (!locales.contains(defaultocale)) {\n            locales.add(defaultocale);\n        }\n\n        return locales;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public Locale getDocLocalePreferenceNew(XWikiContext context)\n    {\n        String language = getDocLanguagePreferenceNew(context);\n\n        return LocaleUtils.toLocale(language);\n    }\n\n    /**\n     * @deprecated since 8.0M1, use {@link #getDocLocalePreferenceNew(XWikiContext)} instead\n     */\n    @Deprecated\n    // TODO: move implementation to #getDocLocalePreferenceNew\n    public String getDocLanguagePreferenceNew(XWikiContext context)\n    {\n        // Get context language\n        String contextLanguage = context.getLanguage();\n        // If the language exists in the context, it was previously set by another call\n        if (!StringUtils.isEmpty(contextLanguage)) {\n            return contextLanguage;\n        }\n\n        String language = \"\", requestLanguage = \"\", userPreferenceLanguage = \"\", navigatorLanguage = \"\",\n            cookieLanguage = \"\";\n        boolean setCookie = false;\n\n        if (!context.getWiki().isMultiLingual(context)) {\n            language = context.getWiki().getXWikiPreference(\"default_language\", \"\", context);\n            context.setLanguage(language);\n            return language;\n        }\n\n        // Get request language\n        try {\n            requestLanguage = Util.normalizeLanguage(context.getRequest().getParameter(\"language\"));\n        } catch (Exception ex) {\n        }\n\n        // Get user preference\n        try {\n            String user = context.getUser();\n            XWikiDocument userdoc = getDocument(user, context);\n            if (userdoc != null) {\n                userPreferenceLanguage = userdoc.getStringValue(\"XWiki.XWikiUsers\", \"default_language\");\n            }\n        } catch (XWikiException e) {\n        }\n\n        // Get navigator language setting\n        if (context.getRequest() != null) {\n            String accept = context.getRequest().getHeader(\"Accept-Language\");\n            if ((accept != null) && (!accept.equals(\"\"))) {\n                String[] alist = StringUtils.split(accept, \",;-\");\n                if ((alist != null) && !(alist.length == 0)) {\n                    context.setLanguage(alist[0]);\n                    navigatorLanguage = alist[0];\n                }\n            }\n        }\n\n        // Get language from cookie\n        try {\n            cookieLanguage = Util.normalizeLanguage(getUserPreferenceFromCookie(\"language\", context));\n        } catch (Exception e) {\n        }\n\n        // Determine which language to use\n        // First we get the language from the request\n        if (StringUtils.isNotEmpty(requestLanguage)) {\n            if (requestLanguage.equals(\"default\")) {\n                setCookie = true;\n            } else {\n                language = requestLanguage;\n                context.setLanguage(language);\n                Cookie cookie = new Cookie(\"language\", language);\n                cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                cookie.setPath(\"/\");\n                context.getResponse().addCookie(cookie);\n                return language;\n            }\n        }\n        // Next we get the language from the cookie\n        if (StringUtils.isNotEmpty(cookieLanguage)) {\n            language = cookieLanguage;\n        }\n        // Next from the default user preference\n        else if (StringUtils.isNotEmpty(userPreferenceLanguage)) {\n            language = userPreferenceLanguage;\n        }\n        // Then from the navigator language setting\n        else if (StringUtils.isNotEmpty(navigatorLanguage)) {\n            language = navigatorLanguage;\n        }\n        context.setLanguage(language);\n        if (setCookie) {\n            Cookie cookie = new Cookie(\"language\", language);\n            cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n            cookie.setPath(\"/\");\n            context.getResponse().addCookie(cookie);\n        }\n        return language;\n    }\n\n    /**\n     * @since 8.0M1\n     */\n    public Locale getInterfaceLocalePreference(XWikiContext context)\n    {\n        String language = getInterfaceLanguagePreference(context);\n\n        return LocaleUtils.toLocale(language);\n    }\n\n    /**\n     * @deprecated since 8.0M1, use {@link #getInterfaceLocalePreference(XWikiContext)} instead\n     */\n    @Deprecated\n    // TODO: move implementation to #getInterfaceLocalePreference\n    public String getInterfaceLanguagePreference(XWikiContext context)\n    {\n        String language = \"\", requestLanguage = \"\", userPreferenceLanguage = \"\", navigatorLanguage = \"\",\n            cookieLanguage = \"\", contextLanguage = \"\";\n        boolean setCookie = false;\n\n        if (!context.getWiki().isMultiLingual(context)) {\n            language = Util.normalizeLanguage(context.getWiki().getXWikiPreference(\"default_language\", \"\", context));\n            context.setInterfaceLocale(LocaleUtils.toLocale(language));\n            return language;\n        }\n\n        // Get request language\n        try {\n            requestLanguage = Util.normalizeLanguage(context.getRequest().getParameter(\"interfacelanguage\"));\n        } catch (Exception ex) {\n        }\n\n        // Get context language\n        contextLanguage = context.getInterfaceLanguage();\n\n        // Get user preference\n        try {\n            String user = context.getUser();\n            XWikiDocument userdoc = null;\n            userdoc = getDocument(user, context);\n            if (userdoc != null) {\n                userPreferenceLanguage = userdoc.getStringValue(\"XWiki.XWikiUsers\", \"default_interface_language\");\n            }\n        } catch (XWikiException e) {\n        }\n\n        // Get navigator language setting\n        if (context.getRequest() != null) {\n            String accept = context.getRequest().getHeader(\"Accept-Language\");\n            if ((accept != null) && (!accept.equals(\"\"))) {\n                String[] alist = StringUtils.split(accept, \",;-\");\n                if ((alist != null) && !(alist.length == 0)) {\n                    context.setLanguage(alist[0]);\n                    navigatorLanguage = alist[0];\n                }\n            }\n        }\n\n        // Get language from cookie\n        try {\n            cookieLanguage = Util.normalizeLanguage(getUserPreferenceFromCookie(\"interfacelanguage\", context));\n        } catch (Exception e) {\n        }\n\n        // Determine which language to use\n        // First we get the language from the request\n        if ((requestLanguage != null) && (!requestLanguage.equals(\"\"))) {\n            if (requestLanguage.equals(\"default\")) {\n                setCookie = true;\n            } else {\n                language = requestLanguage;\n                context.setLanguage(language);\n                Cookie cookie = new Cookie(\"interfacelanguage\", language);\n                cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n                cookie.setPath(\"/\");\n                context.getResponse().addCookie(cookie);\n                return language;\n            }\n        }\n        // Next we get the language from the context\n        if (!StringUtils.isEmpty(contextLanguage)) {\n            language = contextLanguage;\n        }\n        // Next we get the language from the cookie\n        else if (StringUtils.isNotEmpty(cookieLanguage)) {\n            language = cookieLanguage;\n        }\n        // Next from the default user preference\n        else if (StringUtils.isNotEmpty(userPreferenceLanguage)) {\n            language = userPreferenceLanguage;\n        }\n        // Then from the navigator language setting\n        else if (StringUtils.isNotEmpty(navigatorLanguage)) {\n            language = navigatorLanguage;\n        }\n        context.setLanguage(language);\n        if (setCookie) {\n            Cookie cookie = new Cookie(\"interfacelanguage\", language);\n            cookie.setMaxAge(60 * 60 * 24 * 365 * 10);\n            cookie.setPath(\"/\");\n            context.getResponse().addCookie(cookie);\n        }\n        return language;\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getXWikiPreference(preference, context));\n    }\n\n    public long getSpacePreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getSpacePreference(preference, context));\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toLong((getXWikiPreference(preference, context)), defaultValue);\n    }\n\n    public long getXWikiPreferenceAsLong(String preference, String fallbackParameter, long defaultValue,\n        XWikiContext context)\n    {\n        return NumberUtils.toLong(getXWikiPreference(preference, fallbackParameter, \"\", context), defaultValue);\n    }\n\n    public long getSpacePreferenceAsLong(String preference, long defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toLong(getSpacePreference(preference, context), defaultValue);\n    }\n\n    public long getUserPreferenceAsLong(String preference, XWikiContext context)\n    {\n        return Long.parseLong(getUserPreference(preference, context));\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, XWikiContext context)\n    {\n        return Integer.parseInt(getXWikiPreference(preference, context));\n    }\n\n    public int getSpacePreferenceAsInt(String preference, XWikiContext context)\n    {\n        return Integer.parseInt(getSpacePreference(preference, context));\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toInt(getXWikiPreference(preference, context), defaultValue);\n    }\n\n    public int getXWikiPreferenceAsInt(String preference, String fallbackParameter, int defaultValue,\n        XWikiContext context)\n    {\n        return NumberUtils.toInt(getXWikiPreference(preference, fallbackParameter, \"\", context), defaultValue);\n    }\n\n    public int getSpacePreferenceAsInt(String preference, int defaultValue, XWikiContext context)\n    {\n        return NumberUtils.toInt(getSpacePreference(preference, context), defaultValue);\n    }\n\n    public int getUserPreferenceAsInt(String prefname, XWikiContext context)\n    {\n        return Integer.parseInt(getUserPreference(prefname, context));\n    }\n\n    public void flushCache(XWikiContext context)\n    {\n        // We need to flush the virtual wiki list\n        this.initializedWikis = new ConcurrentHashMap<>();\n\n        // We need to flush the group service cache\n        if (this.groupService != null) {\n            this.groupService.flushCache();\n        }\n\n        // If we use the Cache Store layer.. we need to flush it\n        XWikiStoreInterface store = getStore();\n        if ((store != null) && (store instanceof XWikiCacheStoreInterface)) {\n            ((XWikiCacheStoreInterface) getStore()).flushCache();\n        }\n        // Flush renderers.. Groovy renderer has a cache\n        getOldRendering().flushCache();\n        getParseGroovyFromString().flushCache();\n\n        XWikiPluginManager pmanager = getPluginManager();\n        if (pmanager != null) {\n            pmanager.flushCache(context);\n        }\n\n        // Make sure we call all classes flushCache function\n        try {\n            List<String> classes = getClassList(context);\n            for (int i = 0; i < classes.size(); i++) {\n                String className = classes.get(i);\n                try {\n                    getClass(className, context).flushCache();\n                } catch (Exception e) {\n                }\n            }\n        } catch (Exception e) {\n        }\n\n    }\n\n    public XWikiPluginManager getPluginManager()\n    {\n        return this.pluginManager;\n    }\n\n    public void setPluginManager(XWikiPluginManager pluginManager)\n    {\n        this.pluginManager = pluginManager;\n    }\n\n    public void setStore(XWikiStoreInterface store)\n    {\n        this.store = store;\n    }\n\n    /**\n     * @param attachmentContentStore the store to use by default when saving a new attachment content\n     * @since 9.10RC1\n     */\n    public void setDefaultAttachmentContentStore(XWikiAttachmentStoreInterface attachmentContentStore)\n    {\n        this.defaultAttachmentContentStore = attachmentContentStore;\n    }\n\n    /**\n     * @deprecated since 9.9RC1, use {@link #setDefaultAttachmentContentStore(XWikiAttachmentStoreInterface)} instead\n     */\n    @Deprecated\n    public void setAttachmentStore(XWikiAttachmentStoreInterface attachmentStore)\n    {\n        this.defaultAttachmentContentStore = attachmentStore;\n    }\n\n    /**\n     * @param attachmentArchiveStore the store to use by default when saving a new attachment archive\n     * @since 9.10RC1\n     */\n    public void setDefaultAttachmentArchiveStore(AttachmentVersioningStore attachmentArchiveStore)\n    {\n        this.defaultAttachmentArchiveStore = attachmentArchiveStore;\n    }\n\n    /**\n     * @deprecated since 9.10RC1, use {@link #setDefaultAttachmentArchiveStore(AttachmentVersioningStore)} instead\n     */\n    @Deprecated\n    public void setAttachmentVersioningStore(AttachmentVersioningStore attachmentArchiveStore)\n    {\n        setDefaultAttachmentArchiveStore(attachmentArchiveStore);\n    }\n\n    public void setVersioningStore(XWikiVersioningStoreInterface versioningStore)\n    {\n        this.versioningStore = versioningStore;\n    }\n\n    public void setRecycleBinStore(XWikiRecycleBinStoreInterface recycleBinStore)\n    {\n        this.recycleBinStore = recycleBinStore;\n    }\n\n    public void setAttachmentRecycleBinStore(AttachmentRecycleBinStore attachmentRecycleBinStore)\n    {\n        this.attachmentRecycleBinStore = attachmentRecycleBinStore;\n    }\n\n    public void setCriteriaService(XWikiCriteriaService criteriaService)\n    {\n        this.criteriaService = criteriaService;\n    }\n\n    public void setVersion(String version)\n    {\n        this.version = version;\n    }\n\n    /**\n     * Verify if the provided xclass page exists and that it contains all the required configuration properties to make\n     * the tag feature work properly. If some properties are missing they are created and saved in the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @param classReference the reference of the document containing the class\n     * @return the Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     */\n    private BaseClass getMandatoryClass(XWikiContext context, DocumentReference classReference) throws XWikiException\n    {\n        XWikiDocument document = getDocument(classReference, context);\n\n        if (context.get(\"initdone\") == null) {\n            @SuppressWarnings(\"deprecation\")\n            MandatoryDocumentInitializer initializer =\n                Utils.getComponent(MandatoryDocumentInitializer.class, document.getFullName());\n\n            if (initializer.updateDocument(document)) {\n                saveDocument(document, localizePlainOrKey(\"core.model.xclass.mandatoryUpdateProperty.versionSummary\"),\n                    context);\n            }\n        }\n\n        return document.getXClass();\n    }\n\n    /**\n     * Verify if the <code>XWiki.TagClass</code> page exists and that it contains all the required configuration\n     * properties to make the tag feature work properly. If some properties are missing they are created and saved in\n     * the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the TagClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getTagClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"TagClass\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.SheetClass</code> page exists and that it contains all the required configuration\n     * properties to make the sheet feature work properly. If some properties are missing they are created and saved in\n     * the database. SheetClass is used to a page as a sheet. When a page is tagged as a sheet and that page is included\n     * in another page using the include macro then editing it triggers automatic inline edition (for XWiki Syntax 2.0\n     * only - for XWiki Syntax 1.0 automatic inline edition is triggered using #includeForm).\n     *\n     * @param context see {@link XWikiContext}\n     * @return the SheetClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     * @deprecated since 3.1M2 edit mode class should be used for this purpose, not the sheet class\n     * @see #getEditModeClass(XWikiContext)\n     */\n    @Deprecated\n    public BaseClass getSheetClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"SheetClass\"));\n    }\n\n    /**\n     * Verify if the {@code XWiki.EditModeClass} page exists and that it contains all the required configuration\n     * properties to make the edit mode feature work properly. If some properties are missing they are created and saved\n     * in the database. EditModeClass is used to specify the default edit mode of a page. It can also be used to mark a\n     * page as a sheet. When a page is marked as a sheet and that page is included in another page using the include\n     * macro then editing it triggers automatic inline edition (for XWiki Syntax 2.0 only - for XWiki Syntax 1.0\n     * automatic inline edition is triggered using #includeForm). It replaces and enhances the SheetClass mechanism (see\n     * {@link #getSheetClass(XWikiContext)}).\n     *\n     * @param context see {@link XWikiContext}\n     * @return the EditModeClass Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the database\n     * @since 3.1M2\n     */\n    public BaseClass getEditModeClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(\n            new LocalDocumentReference(XWikiConstant.EDIT_MODE_CLASS), new WikiReference(context.getWikiId())));\n    }\n\n    /**\n     * Verify if the <code>XWiki.XWikiUsers</code> page exists and that it contains all the required configuration\n     * properties to make the user feature work properly. If some properties are missing they are created and saved in\n     * the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the XWikiUsers Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getUserClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiUsers\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.GlobalRedirect</code> page exists and that it contains all the required configuration\n     * properties to make the redirection feature work properly. If some properties are missing they are created and\n     * saved in the database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the GlobalRedirect Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getRedirectClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"GlobalRedirect\"));\n    }\n\n    /**\n     * Verify if the <code>XWiki.XWikiPreferences</code> page exists and that it contains all the required configuration\n     * properties to make XWiki work properly. If some properties are missing they are created and saved in the\n     * database.\n     *\n     * @param context see {@link XWikiContext}\n     * @return the XWiki Base Class object containing the properties\n     * @throws XWikiException if an error happens during the save to the datavase\n     */\n    public BaseClass getPrefsClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, getPreferencesDocumentReference(context));\n    }\n\n    public BaseClass getGroupClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiGroups\"));\n    }\n\n    public BaseClass getRightsClass(String pagename, XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, pagename));\n    }\n\n    public BaseClass getRightsClass(XWikiContext context) throws XWikiException\n    {\n        return getRightsClass(\"XWikiRights\", context);\n    }\n\n    public BaseClass getGlobalRightsClass(XWikiContext context) throws XWikiException\n    {\n        return getRightsClass(\"XWikiGlobalRights\", context);\n    }\n\n    public BaseClass getCommentsClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiComments\"));\n    }\n\n    public BaseClass getSkinClass(XWikiContext context) throws XWikiException\n    {\n        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, \"XWikiSkins\"));\n    }\n\n    public int createUser(XWikiContext context) throws XWikiException\n    {\n        return createUser(false, \"edit\", context);\n    }\n\n    public int validateUser(boolean withConfirmEmail, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            // Get the user document\n            String username = convertUsername(request.getParameter(\"xwikiname\"), context);\n            if (username.indexOf('.') == -1) {\n                username = \"XWiki.\" + username;\n            }\n            XWikiDocument userDocument = getDocument(username, context);\n\n            // Get the stored validation key\n            BaseObject userObject = userDocument.getObject(\"XWiki.XWikiUsers\", 0);\n            String storedKey = userObject.getStringValue(\"validkey\");\n\n            // Get the validation key from the URL\n            String validationKey = request.getParameter(\"validkey\");\n            PropertyInterface validationKeyClass = getClass(\"XWiki.XWikiUsers\", context).get(\"validkey\");\n            if (validationKeyClass instanceof PasswordClass) {\n                validationKey = ((PasswordClass) validationKeyClass).getEquivalentPassword(storedKey, validationKey);\n            }\n\n            // Compare the two keys\n            if ((!storedKey.equals(\"\") && (storedKey.equals(validationKey)))) {\n                // Ensure to remove the validation key value, so it cannot be used afterwards to enable back\n                // a disabled user.\n                userObject.setStringValue(\"validkey\", \"\");\n                saveDocument(userDocument, context);\n\n                XWikiUser xWikiUser = new XWikiUser(userDocument.getDocumentReference());\n                xWikiUser.setDisabled(false, context);\n                xWikiUser.setEmailChecked(true, context);\n\n                if (withConfirmEmail) {\n                    String email = userObject.getStringValue(\"email\");\n                    String password = userObject.getStringValue(\"password\");\n                    sendValidationEmail(username, password, email, request.getParameter(\"validkey\"),\n                        \"confirmation_email_content\", context);\n                }\n\n                return 0;\n            } else {\n                return -1;\n            }\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_VALIDATE_USER,\n                \"Exception while validating user\", e, null);\n        }\n    }\n\n    public int createUser(boolean withValidation, String userRights, XWikiContext context) throws XWikiException\n    {\n        try {\n            XWikiRequest request = context.getRequest();\n            Map<String, String[]> map = Util.getObject(request, \"register\");\n\n            String content = \"\";\n            Syntax syntax = getDefaultDocumentSyntaxInternal();\n\n            // Read the values from the request.\n            String xwikiname = request.getParameter(\"xwikiname\");\n            String password2 = request.getParameter(\"register2_password\");\n            String password = (map.get(\"password\"))[0];\n            String email = (map.get(\"email\"))[0];\n            String template = request.getParameter(\"template\");\n            String parent = request.getParameter(\"parent\");\n            String validkey = null;\n\n            // Validate the values.\n            if (XWikiRightService.SUPERADMIN_USER.equalsIgnoreCase(xwikiname)) {\n                return -8;\n            }\n            try {\n                if (!context.getUtil().match(getConfiguration().getProperty(\"xwiki.validusername\", \"/^[a-zA-Z0-9_]+$/\"),\n                    xwikiname)) {\n                    return -4;\n                }\n            } catch (RuntimeException ex) {\n                LOGGER.warn(\"Invalid regular expression for xwiki.validusername\", ex);\n                if (!context.getUtil().match(\"/^[a-zA-Z0-9_]+$/\", xwikiname)) {\n                    return -4;\n                }\n            }\n\n            if ((!password.equals(password2))) {\n                // TODO: throw wrong password exception\n                return -2;\n            }\n\n            if ((template != null) && (!template.equals(\"\"))) {\n                XWikiDocument tdoc = getDocument(template, context);\n                if ((!tdoc.isNew())) {\n                    // FIXME: This ignores template objects, attachments, etc.\n                    content = tdoc.getContent();\n                    syntax = tdoc.getSyntax();\n                }\n            }\n\n            if ((parent == null) || (parent.equals(\"\"))) {\n                parent = \"XWiki.XWikiUsers\";\n            }\n\n            // Mark the user as active or waiting email validation.\n            if (withValidation) {\n                map.put(XWikiUser.ACTIVE_PROPERTY, new String[] { \"0\" });\n                map.put(XWikiUser.EMAIL_CHECKED_PROPERTY, new String[] { \"0\" });\n\n                validkey = generateValidationKey(16);\n                map.put(\"validkey\", new String[] { validkey });\n\n            } else {\n                // Mark user active\n                map.put(XWikiUser.ACTIVE_PROPERTY, new String[] { \"1\" });\n                map.put(XWikiUser.EMAIL_CHECKED_PROPERTY, new String[] { \"1\" });\n            }\n\n            // Create the user.\n            int result =\n                createUser(xwikiname, map, getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT),\n                    content, syntax, userRights, context);\n\n            // Send validation mail, if needed.\n            if ((result > 0) && (withValidation)) {\n                // Send the validation email\n                try {\n                    sendValidationEmail(xwikiname, password, email, validkey, \"validation_email_content\", context);\n                } catch (XWikiException e) {\n                    LOGGER.warn(\"User created. Failed to send the mail to the created user.\", e);\n                    return -11;\n                }\n\n            }\n\n            return result;\n        } catch (XWikiException e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw e;\n        } catch (Exception e) {\n            LOGGER.error(e.getMessage(), e);\n\n            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_CREATE_USER,\n                \"Exception while creating user\", e, null);\n        }\n    }\n\n    /**\n     * Method allows to create an empty user with no password (he won't be able to login) This method is usefull for\n     * authentication like LDAP or App Server trusted\n     *\n     * @param xwikiname\n     * @param userRights\n     * @param context see {@link XWikiContext}\n     * @return true if success\n     * @throws XWikiException\n     */\n    public boolean createEmptyUser(String xwikiname, String userRights, XWikiContext context) throws XWikiException\n    {\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"active\", \"1\");\n        map.put(\"first_name\", xwikiname);\n\n        if (createUser(xwikiname, map, userRights, context) == 1) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public void sendConfirmationEmail(String xwikiname, String password, String email, String message,\n        String contentfield, XWikiContext context) throws XWikiException\n    {\n        sendValidationEmail(xwikiname, password, email, \"message\", message, contentfield, context);\n    }\n\n    public void sendValidationEmail(String xwikiname, String password, String email, String validkey,\n        String contentfield, XWikiContext context) throws XWikiException\n    {\n        sendValidationEmail(xwikiname, password, email, \"validkey\", validkey, contentfield, context);\n    }\n\n    public void sendValidationEmail(String xwikiname, String password, String email, String addfieldname,\n        String addfieldvalue, String contentfield, XWikiContext context) throws XWikiException\n    {\n        MailSenderConfiguration configuration = Utils.getComponent(MailSenderConfiguration.class);\n\n        String sender;\n        String content;\n        try {\n            sender = configuration.getFromAddress();\n            if (StringUtils.isBlank(sender)) {\n                String server = context.getRequest().getServerName();\n                if (server.matches(\"\\\\[.*\\\\]|(\\\\d{1,3}+\\\\.){3}+\\\\d{1,3}+\")) {\n                    sender = \"noreply@domain.net\";\n                } else {\n                    sender = \"noreply@\" + server;\n                }\n            }\n            content = getXWikiPreference(contentfield, context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_CANNOT_GET_VALIDATION_CONFIG,\n                \"Exception while reading the validation email config\", e, null);\n\n        }\n\n        try {\n            VelocityContext vcontext = (VelocityContext) context.get(\"vcontext\");\n            vcontext.put(addfieldname, addfieldvalue);\n            vcontext.put(\"email\", email);\n            vcontext.put(\"password\", password);\n            vcontext.put(\"sender\", sender);\n            vcontext.put(\"xwikiname\", xwikiname);\n            content = parseContent(content, context);\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_CANNOT_PREPARE_VALIDATION_EMAIL,\n                \"Exception while preparing the validation email\", e, null);\n\n        }\n\n        // Let's now send the message\n        try {\n            Session session =\n                Session.getInstance(configuration.getAllProperties(), new XWikiAuthenticator(configuration));\n            InputStream is = new ByteArrayInputStream(content.getBytes());\n            MimeMessage message = new MimeMessage(session, is);\n            message.setFrom(new InternetAddress(sender));\n            message.setRecipients(Message.RecipientType.TO, email);\n            message.setHeader(\"X-MailType\", \"Account Validation\");\n            MailSender mailSender = Utils.getComponent(MailSender.class);\n            MailListener mailListener = Utils.getComponent(MailListener.class, \"database\");\n            mailSender.sendAsynchronously(Arrays.asList(message), session, mailListener);\n            mailListener.getMailStatusResult().waitTillProcessed(Long.MAX_VALUE);\n            String errorMessage = MailStatusResultSerializer.serializeErrors(mailListener.getMailStatusResult());\n            if (errorMessage != null) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                    XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL,\n                    String.format(\"Error while sending the validation email. %s\", errorMessage));\n            }\n        } catch (Exception e) {\n            throw new XWikiException(XWikiException.MODULE_XWIKI_EMAIL,\n                XWikiException.ERROR_XWIKI_EMAIL_ERROR_SENDING_EMAIL, \"Error while sending the validation email\", e);\n        }\n    }\n\n    public String generateRandomString(int size)\n    {\n        return RandomStringUtils.randomAlphanumeric(size);\n    }\n\n    public String generateValidationKey(int size)\n    {\n        return generateRandomString(size);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, XWikiContext context) throws XWikiException\n    {\n        return createUser(userName, map, \"edit\", context);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param userRights the right of the user on his own profile page\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, String userRights, XWikiContext context)\n        throws XWikiException\n    {\n        BaseClass userClass = getUserClass(context);\n\n        String content = \"\";\n        Syntax syntax = getDefaultDocumentSyntaxInternal();\n\n        return createUser(userName, map,\n            new EntityReference(userClass.getDocumentReference().getName(), EntityType.DOCUMENT), content, syntax,\n            userRights, context);\n    }\n\n    /**\n     * @deprecated since 2.4RC1 use\n     *             {@link #createUser(String, Map, EntityReference, String, Syntax, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public int createUser(String userName, Map<String, ?> map, String parent, String content, String syntaxId,\n        String userRights, XWikiContext context) throws XWikiException\n    {\n        Syntax syntax;\n\n        try {\n            syntax = Syntax.valueOf(syntaxId);\n        } catch (ParseException e) {\n            syntax = getDefaultDocumentSyntaxInternal();\n        }\n\n        return createUser(userName, map, getRelativeEntityReferenceResolver().resolve(parent, EntityType.DOCUMENT),\n            content, syntax, userRights, context);\n    }\n\n    /**\n     * Create a new user.\n     *\n     * @param userName the name of the user (without the space)\n     * @param map extra datas to add to user profile object\n     * @param parentReference the parent of the user profile\n     * @param content the content of the user profile\n     * @param syntax the syntax of the provided content\n     * @param userRights the right of the user on his own profile page\n     * @param context see {@link XWikiContext}\n     * @return\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-3: user already exists</li>\n     *         </ul>\n     * @throws XWikiException failed to create the new user\n     */\n    public int createUser(String userName, Map<String, ?> map, EntityReference parentReference, String content,\n        Syntax syntax, String userRights, XWikiContext context) throws XWikiException\n    {\n        BaseClass userClass = getUserClass(context);\n\n        try {\n            // TODO: Verify existing user\n            XWikiDocument doc = getDocument(new DocumentReference(context.getWikiId(), \"XWiki\", userName), context);\n\n            if (!doc.isNew()) {\n                // TODO: throws Exception\n                return -3;\n            }\n\n            DocumentReference userClassReference = userClass.getDocumentReference();\n            BaseObject userObject =\n                doc.newXObject(userClassReference.removeParent(userClassReference.getWikiReference()), context);\n            userClass.fromMap(map, userObject);\n\n            doc.setParentReference(parentReference);\n            doc.setContent(content);\n            doc.setSyntax(syntax);\n\n            // Set the user itself as the creator of the document, so that she has the CREATOR right on her user page.\n            doc.setCreatorReference(doc.getDocumentReference());\n\n            // However, we use the context user for the author to see in the history who has really created the user\n            // (it may be an administrator).\n            if (context.getUserReference() != null) {\n                doc.setAuthorReference(context.getUserReference());\n            } else {\n                // Except if the current user is guest (which means the user registered herself)\n                doc.setAuthorReference(doc.getDocumentReference());\n            }\n\n            // The information from the user profile needs to be indexed using the proper locale. If multilingual is\n            // enabled then the user can choose the desired locale (from the list of supported locales) before\n            // registering. An administrator registering users can do the same. Otherwise, if there is only one locale\n            // supported then that langage will be used.\n            doc.setDefaultLocale(context.getLocale());\n\n            protectUserPage(doc.getFullName(), userRights, doc, context);\n\n            saveDocument(doc, localizePlainOrKey(\"core.comment.createdUser\"), context);\n\n            // Now let's add the user to XWiki.XWikiAllGroup\n            setUserDefaultGroup(doc.getFullName(), context);\n\n            return 1;\n        } catch (Exception e) {\n            Object[] args = { \"XWiki.\" + userName };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_CREATE,\n                \"Cannot create user {0}\", e, args);\n        }\n    }\n\n    /**\n     * @deprecated starting with XE 1.8.1 use\n     *             {@link #createUser(String, Map, String, String, String, String, XWikiContext)} instead\n     */\n    @Deprecated\n    public int createUser(String xwikiname, Map<String, ?> map, String parent, String content, String userRights,\n        XWikiContext context) throws XWikiException\n    {\n        return createUser(xwikiname, map, parent, content, Syntax.XWIKI_1_0.toIdString(), userRights, context);\n    }\n\n    public void setUserDefaultGroup(String fullwikiname, XWikiContext context) throws XWikiException\n    {\n        String groupsPreference = isAllGroupImplicit() ? getConfiguration().getProperty(\"xwiki.users.initialGroups\")\n            : getConfiguration().getProperty(\"xwiki.users.initialGroups\", \"XWiki.XWikiAllGroup\");\n\n        if (groupsPreference != null) {\n            String[] groups = groupsPreference.split(\",\");\n            for (String groupName : groups) {\n                if (StringUtils.isNotBlank(groupName)) {\n                    addUserToGroup(fullwikiname, groupName.trim(), context);\n                }\n            }\n        }\n    }\n\n    protected void addUserToGroup(String userName, String groupName, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groupDoc = getDocument(groupName, context);\n\n        DocumentReference groupClassReference = getGroupClass(context).getDocumentReference();\n        BaseObject memberObject =\n            groupDoc.newXObject(groupClassReference.removeParent(groupClassReference.getWikiReference()), context);\n\n        memberObject.setStringValue(\"member\", userName);\n\n        this.saveDocument(groupDoc, localizePlainOrKey(\"core.comment.addedUserToGroup\"), context);\n    }\n\n    public void protectUserPage(String userName, String userRights, XWikiDocument doc, XWikiContext context)\n        throws XWikiException\n    {\n        DocumentReference rightClassReference = getRightsClass(context).getDocumentReference();\n\n        EntityReference relativeRightClassReference =\n            rightClassReference.removeParent(rightClassReference.getWikiReference());\n\n        // Allow users to edit their own profiles\n        BaseObject newuserrightsobject = doc.newXObject(relativeRightClassReference, context);\n        newuserrightsobject.setLargeStringValue(\"users\", userName);\n        newuserrightsobject.setStringValue(\"levels\", userRights);\n        newuserrightsobject.setIntValue(\"allow\", 1);\n    }\n\n    public User getUser(XWikiContext context)\n    {\n        return getUser(context.getUserReference(), context);\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link #getUser(DocumentReference, XWikiContext)}.\n     */\n    @Deprecated\n    public User getUser(String username, XWikiContext context)\n    {\n        XWikiUser xwikiUser = new XWikiUser(username);\n        User user = new User(xwikiUser, context);\n        return user;\n    }\n\n    /**\n     * Retrieve a user from its document reference.\n     *\n     * @param userReference the reference of the user.\n     * @param context the current context.\n     * @return the user corresponding to that document reference.\n     * @since 11.8RC1\n     */\n    public User getUser(DocumentReference userReference, XWikiContext context)\n    {\n        XWikiUser xwikiUser = new XWikiUser(userReference);\n        User user = new User(xwikiUser, context);\n        return user;\n    }\n\n    /**\n     * Prepares the localized resources, according to the selected locale. Set context \"msg\" and locale.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public void prepareResources(XWikiContext context)\n    {\n        if (context.get(\"msg\") == null) {\n            Locale locale = getLocalePreference(context);\n            context.setLocale(locale);\n            if (context.getResponse() != null) {\n                context.getResponse().setLocale(locale);\n            }\n            XWikiMessageTool msg = new XWikiMessageTool(Utils.getComponent(ContextualLocalizationManager.class));\n            context.put(\"msg\", msg);\n        }\n    }\n\n    /**\n     * Authenticate the user from the context and check if the user is disabled or not.\n     * If the user is disabled, the method returns {@code null} but set the reference of the authenticated user in the\n     * context with the {@link XWikiContext#INACTIVE_USER_REFERENCE} property.\n     *\n     * @param context the context used to authenticate the user.\n     * @return an {@link XWikiUser} if the user is authenticated and enabled, else {@code null}.\n     * @throws XWikiException in case of problem when dealing with the authentication.\n     */\n    public XWikiUser checkAuth(XWikiContext context) throws XWikiException\n    {\n        XWikiUser user = getAuthService().checkAuth(context);\n        if (user != null && user.isDisabled(context)) {\n            context.put(XWikiContext.INACTIVE_USER_REFERENCE, user.getUserReference());\n            user = null;\n        }\n        return user;\n    }\n\n    public boolean checkAccess(String action, XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        // Handle the 'skin' action specially so that resources don`t require special (or even 'view') rights.\n        String firstSpaceName = doc.getDocumentReference().getSpaceReferences().get(0).getName();\n        if (action.equals(\"skin\") && SKIN_RESOURCE_SPACE_NAMES.contains(firstSpaceName)) {\n            // We still need to call checkAuth to set the proper user.\n            XWikiUser user = checkAuth(context);\n            if (user != null) {\n                context.setUser(user.getUser());\n            }\n\n            // Always allow.\n            return true;\n        }\n\n        return getRightService().checkAccess(action, doc, context);\n    }\n\n    public String include(String topic, boolean isForm, XWikiContext context) throws XWikiException\n    {\n        String database = null, incdatabase = null;\n        String prefixedTopic, localTopic;\n\n        // Save current documents in script context\n        Document currentAPIdoc = null, currentAPIcdoc = null, currentAPItdoc = null;\n        ScriptContextManager scritContextManager = Utils.getComponent(ScriptContextManager.class);\n        ScriptContext scontext = scritContextManager.getScriptContext();\n        String currentDocName = context.getWikiId() + \":\" + context.getDoc().getFullName();\n        if (scontext != null) {\n            currentAPIdoc = (Document) scontext.getAttribute(\"doc\");\n            currentAPIcdoc = (Document) scontext.getAttribute(\"cdoc\");\n            currentAPItdoc = (Document) scontext.getAttribute(\"tdoc\");\n        }\n\n        try {\n            int i0 = topic.indexOf(':');\n            if (i0 != -1) {\n                incdatabase = topic.substring(0, i0);\n                database = context.getWikiId();\n                context.setWikiId(incdatabase);\n                prefixedTopic = topic;\n                localTopic = topic.substring(i0 + 1);\n            } else {\n                prefixedTopic = context.getWikiId() + \":\" + topic;\n                localTopic = topic;\n            }\n\n            XWikiDocument doc = null;\n            try {\n                LOGGER.debug(\"Including Topic \" + topic);\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    Set<String> includedDocs = (Set<String>) context.get(\"included_docs\");\n                    if (includedDocs == null) {\n                        includedDocs = new HashSet<String>();\n                        context.put(\"included_docs\", includedDocs);\n                    }\n\n                    if (includedDocs.contains(prefixedTopic) || currentDocName.equals(prefixedTopic)) {\n                        LOGGER.warn(\"Error on too many recursive includes for topic \" + topic);\n                        return \"Cannot make recursive include\";\n                    }\n                    includedDocs.add(prefixedTopic);\n                } catch (Exception e) {\n                }\n\n                // Get document to include\n                DocumentReference targetDocumentReference =\n                    getCurrentMixedDocumentReferenceResolver().resolve(localTopic);\n                doc = getDocument(targetDocumentReference, context);\n\n                if (checkAccess(\"view\", doc, context) == false) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED, \"Access to this document is denied: \" + doc);\n                }\n            } catch (XWikiException e) {\n                LOGGER.warn(\"Exception Including Topic \" + topic, e);\n                return \"Topic \" + topic + \" does not exist\";\n            }\n\n            XWikiDocument contentdoc = doc.getTranslatedDocument(context);\n\n            String result;\n            if (isForm) {\n                // We do everything in the context of the including document\n                if (database != null) {\n                    context.setWikiId(database);\n                }\n\n                // Note: the Script macro in the new rendering checks for programming rights for the document in\n                // the xwiki context.\n                result = getRenderedContent(contentdoc, (XWikiDocument) context.get(\"doc\"), context);\n            } else {\n                // We stay in the included document context\n\n                // Since the Script macro checks for programming rights in the current document, we need to\n                // temporarily set the contentdoc as the current doc before rendering it.\n                XWikiDocument originalDoc = null;\n                try {\n                    originalDoc = context.getDoc();\n                    context.put(\"doc\", doc);\n                    result = getRenderedContent(contentdoc, doc, context);\n                } finally {\n                    context.put(\"doc\", originalDoc);\n                }\n            }\n            try {\n                @SuppressWarnings(\"unchecked\")\n                Set<String> includedDocs = (Set<String>) context.get(\"included_docs\");\n                if (includedDocs != null) {\n                    includedDocs.remove(prefixedTopic);\n                }\n            } catch (Exception e) {\n            }\n            return result;\n        } finally {\n            if (database != null) {\n                context.setWikiId(database);\n            }\n\n            if (currentAPIdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"doc\", currentAPIdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n            if (currentAPIcdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"cdoc\", currentAPIcdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n            if (currentAPItdoc != null) {\n                if (scontext != null) {\n                    scontext.setAttribute(\"tdoc\", currentAPItdoc, ScriptContext.ENGINE_SCOPE);\n                }\n            }\n        }\n    }\n\n    /**\n     * Render content from the passed included document, setting the correct security doc (sdoc) and including doc\n     * (idoc).\n     *\n     * @since 2.2M2\n     */\n    private String getRenderedContent(XWikiDocument includedDoc, XWikiDocument includingDoc, XWikiContext context)\n        throws XWikiException\n    {\n        String result;\n        XWikiDocument idoc = (XWikiDocument) context.get(\"idoc\");\n        XWikiDocument sdoc = (XWikiDocument) context.get(\"sdoc\");\n\n        context.put(\"idoc\", includingDoc);\n        context.put(\"sdoc\", includedDoc);\n        try {\n            result = includedDoc.getRenderedContent(Utils.getComponent(RenderingContext.class).getTargetSyntax(), false,\n                context);\n        } finally {\n            // Remove including doc or set the previous one\n            if (idoc == null) {\n                context.remove(\"idoc\");\n            } else {\n                context.put(\"idoc\", idoc);\n            }\n\n            // Remove security doc or set the previous one\n            if (sdoc == null) {\n                context.remove(\"sdoc\");\n            } else {\n                context.put(\"sdoc\", sdoc);\n            }\n        }\n\n        return result;\n    }\n\n    public void deleteDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        deleteDocument(doc, true, context);\n    }\n\n    public void deleteDocument(XWikiDocument doc, boolean totrash, XWikiContext context) throws XWikiException\n    {\n        deleteDocument(doc, totrash, true, context);\n    }\n\n    private XWikiDocument prepareDocumentDelete(XWikiDocument doc, XWikiContext context)\n    {\n        // The source document is a new empty XWikiDocument to follow\n        // DocumentUpdatedEvent policy: source document in new document and the old version is available using\n        // doc.getOriginalDocument()\n        XWikiDocument blankDoc = new XWikiDocument(doc.getDocumentReference());\n        // Again to follow general event policy, new document author is the user who modified the document\n        // (here the modification is delete)\n        blankDoc.setOriginalDocument(doc.getOriginalDocument());\n        blankDoc.setAuthorReference(context.getUserReference());\n        blankDoc.setContentAuthorReference(context.getUserReference());\n\n        return blankDoc;\n    }\n\n    private XWikiDocument beforeDelete(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument blankDoc = prepareDocumentDelete(doc, context);\n\n        ObservationManager om = getObservationManager();\n\n        // Inform notification mechanisms that a document is about to be deleted\n        // Note that for the moment the event being send is a bridge event, as we are still passing around\n        // an XWikiDocument as source and an XWikiContext as data.\n        if (om != null) {\n            CancelableEvent documentEvent = new DocumentDeletingEvent(doc.getDocumentReference());\n            om.notify(documentEvent, blankDoc, context);\n\n            // If the action has been canceled by the user then don't perform any deletion and throw an exception\n            if (documentEvent.isCanceled()) {\n                throw new XWikiException(XWikiException.MODULE_XWIKI_STORE,\n                    XWikiException.ERROR_XWIKI_STORE_HIBERNATE_DELETING_DOC,\n                    String.format(\"An Event Listener has cancelled the document deletion for [%s]. Reason: [%s]\",\n                        doc.getDocumentReference(), documentEvent.getReason()));\n            }\n        }\n\n        return blankDoc;\n    }\n\n    private void afterDelete(XWikiDocument blankDoc, XWikiContext context)\n    {\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            om.notify(new DocumentDeletedEvent(blankDoc.getDocumentReference()), blankDoc, context);\n        }\n    }\n\n    private void deleteDocument(XWikiDocument doc, boolean totrash, boolean notify, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = null;\n\n        currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(doc.getDocumentReference().getWikiReference().getName());\n\n            XWikiDocument blankDoc = null;\n\n            // Inform notification mechanisms that a document is about to be deleted\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            if (notify) {\n                blankDoc = beforeDelete(doc, context);\n            }\n\n            if (hasRecycleBin(context) && totrash) {\n                // Extract any existing batchId from the context.\n                String batchId = Utils.getComponent(BatchOperationExecutor.class).getCurrentBatchId();\n\n                // Save to recycle bin together with any determined batch ID.\n                getRecycleBinStore().saveToRecycleBin(doc, context.getUser(), new Date(), batchId, context, true);\n            }\n\n            getStore().deleteXWikiDoc(doc, context);\n\n            try {\n                // Inform notification mechanisms that a document has been deleted\n                // Note that for the moment the event being send is a bridge event, as we are still passing around\n                // an XWikiDocument as source and an XWikiContext as data.\n                if (notify) {\n                    afterDelete(blankDoc, context);\n                }\n            } catch (Exception ex) {\n                LOGGER.error(\"Failed to send document delete notifications for document [{}]\",\n                    doc.getDocumentReference(), ex);\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Check if the user is allowed to delete the document.\n     * \n     * @param userReference the user responsible for the delete\n     * @param document the document to delete\n     * @param context the XWiki context\n     * @throws XWikiException when failing to delete\n     * @since 11.6\n     * @since 10.11.10\n     */\n    public void checkDeletingDocument(DocumentReference userReference, XWikiDocument document, XWikiContext context)\n        throws XWikiException\n    {\n        String currentWiki = null;\n\n        currentWiki = context.getWikiId();\n        try {\n            context.setWikiId(document.getDocumentReference().getWikiReference().getName());\n\n            XWikiDocument blankDoc = prepareDocumentDelete(document, context);\n\n            ObservationManager om = getObservationManager();\n\n            // Inform notification mechanisms that a document is about to be deleted\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            if (om != null) {\n                CancelableEvent documentEvent =\n                    new UserDeletingDocumentEvent(userReference, document.getDocumentReference());\n                om.notify(documentEvent, blankDoc, context);\n\n                // If the action has been canceled by the user then don't perform any deletion and throw an exception\n                if (documentEvent.isCanceled()) {\n                    throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS,\n                        XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                        String.format(\"User [%s] has been denied the right to delete the document [%s]. Reason: [%s]\",\n                            userReference, document.getDocumentReference(), documentEvent.getReason()));\n                }\n            }\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Delete a range of versions from a document history.\n     * \n     * @param document the document from which to delete versions\n     * @param version1 one end of the versions range to remove\n     * @param version2 the other end of the versions range to remove\n     * @param context the XWiki context\n     * @throws XWikiException\n     * @since 13.6RC1\n     */\n    @Unstable\n    public void deleteDocumentVersions(XWikiDocument document, String version1, String version2, XWikiContext context)\n        throws XWikiException\n    {\n        Version v1 = new Version(version1);\n        Version v2 = new Version(version2);\n\n        // Find the lower and upper bounds\n        Version upperBound = v1;\n        Version lowerBound = v2;\n        if (upperBound.compareVersions(lowerBound) < 0) {\n            Version tmp = upperBound;\n            upperBound = lowerBound;\n            lowerBound = tmp;\n        }\n\n        XWikiDocumentArchive archive = document.getDocumentArchive(context);\n\n        // Remove the versions\n        archive.removeVersions(upperBound, lowerBound, context);\n\n        // Is this the last remaining version? If so, then recycle the document.\n        if (archive.getLatestVersion() == null) {\n            // Wrap the work as a batch operation.\n            BatchOperationExecutor batchOperationExecutor = Utils.getComponent(BatchOperationExecutor.class);\n            batchOperationExecutor.execute(() -> {\n                if (document.getLocale().equals(Locale.ROOT)) {\n                    context.getWiki().deleteAllDocuments(document, context);\n                } else {\n                    // Only delete the translation\n                    context.getWiki().deleteDocument(document, context);\n                }\n            });\n        } else {\n            // Notify before versions delete\n            getObservationManager()\n                .notify(new DocumentVersionRangeDeletingEvent(document.getDocumentReferenceWithLocale(),\n                    lowerBound.toString(), upperBound.toString()), document, context);\n\n            // Update the archive\n            context.getWiki().getVersioningStore().saveXWikiDocArchive(archive, true, context);\n            document.setDocumentArchive(archive);\n\n            // There are still some versions left.\n            // If we delete the most recent (current) version, then rollback to latest undeleted version.\n            Version previousVersion = archive.getLatestVersion();\n            if (!document.getRCSVersion().equals(previousVersion)) {\n                context.getWiki().rollback(document, previousVersion.toString(), false, context);\n            }\n\n            // Notify after versions delete\n            getObservationManager()\n                .notify(new DocumentVersionRangeDeletedEvent(document.getDocumentReferenceWithLocale(),\n                    lowerBound.toString(), upperBound.toString()), document, context);\n        }\n    }\n\n    public String getDatabase()\n    {\n        return this.database;\n    }\n\n    public void setDatabase(String database)\n    {\n        this.database = database;\n    }\n\n    public void gc()\n    {\n        System.gc();\n    }\n\n    public long freeMemory()\n    {\n        return Runtime.getRuntime().freeMemory();\n    }\n\n    public long totalMemory()\n    {\n        return Runtime.getRuntime().totalMemory();\n    }\n\n    public long maxMemory()\n    {\n        return Runtime.getRuntime().maxMemory();\n    }\n\n    public String[] split(String str, String sep)\n    {\n        return StringUtils.split(str, sep);\n    }\n\n    /**\n     * @deprecated use {@link ExceptionUtils#getStackTrace(Throwable)} instead\n     */\n    @Deprecated\n    public String printStrackTrace(Throwable e)\n    {\n        StringWriter strwriter = new StringWriter();\n        PrintWriter writer = new PrintWriter(strwriter);\n        e.printStackTrace(writer);\n\n        return strwriter.toString();\n    }\n\n    /**\n     * API to rename a document to another document.\n     *\n     * @param sourceDocumentReference the source document to rename.\n     * @param targetDocumentReference the target reference to rename the document to.\n     * @param overwrite if {@code true} the target document reference will be overwritten if it exists\n     *                  (deleted to the recycle bin before the rename). If {@code false} and the target document exist\n     *                  the rename won't be performed.\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *                                  modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *                                 document reference\n     * @return {@code true} if the rename succeeded. {@code false} if there was any issue.\n     * @throws XWikiException if the document cannot be renamed properly.\n     * @since 12.5RC1\n     */\n    public boolean renameDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean overwrite, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences, XWikiContext context)\n        throws XWikiException\n    {\n        boolean result = false;\n\n        // if source and destination are same, no need to perform the rename.\n        if (!sourceDocumentReference.equals(targetDocumentReference)) {\n            XWikiDocument sourceDocument = this.getDocument(sourceDocumentReference, context);\n            XWikiDocument targetDocument = this.getDocument(targetDocumentReference, context);\n\n            ConfigurationSource xwikiproperties = Utils.getComponent(ConfigurationSource.class, \"xwikiproperties\");\n            boolean useAtomicRename = xwikiproperties.getProperty(\"refactoring.rename.useAtomicRename\", Boolean.TRUE);\n\n            // Proceed on the rename only if the source document exists and if either the targetDoc does not exist or\n            // the overwritten is accepted.\n            if (!sourceDocument.isNew() && (overwrite || targetDocument.isNew())) {\n                if (!useAtomicRename) {\n                    this.renameByCopyAndDelete(sourceDocument, targetDocumentReference, backlinkDocumentReferences,\n                        childDocumentReferences, context);\n                    result = true;\n                } else {\n                    // Ensure that the current context contains the wiki reference of the source document.\n                    WikiReference wikiReference = context.getWikiReference();\n                    context.setWikiReference(sourceDocumentReference.getWikiReference());\n\n                    try {\n                        // rename main document\n                        this.atomicRenameDocument(sourceDocument, targetDocumentReference, context);\n\n                        // handle translations\n                        List<Locale> translationLocales = sourceDocument.getTranslationLocales(context);\n                        for (Locale translationLocale : translationLocales) {\n                            DocumentReference translatedSourceReference =\n                                new DocumentReference(sourceDocumentReference, translationLocale);\n                            DocumentReference translatedTargetReference =\n                                new DocumentReference(targetDocumentReference, translationLocale);\n                            XWikiDocument translatedSourceDoc = this.getDocument(translatedSourceReference, context);\n                            this.atomicRenameDocument(translatedSourceDoc, translatedTargetReference, context);\n                        }\n                    } finally {\n                        context.setWikiReference(wikiReference);\n                    }\n\n                    // Step 4: For each child document, update its parent reference.\n                    // Step 5: For each backlink to rename, parse the backlink document and replace the links with\n                    // the new name.\n                    // Step 6: Refactor the relative links contained in the document to make sure they are relative\n                    // to the new document's location.\n                    this.updateLinksForRename(sourceDocument, targetDocumentReference, backlinkDocumentReferences,\n                        childDocumentReferences, context);\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private void atomicRenameDocument(XWikiDocument sourceDocument, DocumentReference targetDocumentReference,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 1: Simulate creating a document and deleting a document from listeners point of view\n        // FIXME: currently modifications made by listeners won't be applied\n        XWikiDocument futureTargetDocument = sourceDocument.cloneRename(targetDocumentReference, context);\n        futureTargetDocument.setOriginalDocument(new XWikiDocument(targetDocumentReference));\n        beforeSave(futureTargetDocument, context);\n        XWikiDocument deletedDocument = beforeDelete(sourceDocument, context);\n\n        // Step 2: Perform atomic rename in DB\n        this.getStore().renameXWikiDoc(sourceDocument, targetDocumentReference, context);\n\n        // Step 3: Simulate a created document and a deleted document from listeners point of view\n        afterDelete(deletedDocument, context);\n        afterSave(futureTargetDocument, context);\n    }\n\n    private void updateLinksForRename(XWikiDocument sourceDoc, DocumentReference newDocumentReference,\n        List<DocumentReference> backlinkDocumentReferences, List<DocumentReference> childDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 2: For each child document, update its parent reference.\n        if (childDocumentReferences != null) {\n            for (DocumentReference childDocumentReference : childDocumentReferences) {\n                XWikiDocument childDocument = getDocument(childDocumentReference, context);\n                String compactReference = getCompactEntityReferenceSerializer().serialize(newDocumentReference);\n                childDocument.setParent(compactReference);\n                String saveMessage = localizePlainOrKey(\"core.comment.renameParent\", compactReference);\n                childDocument.setAuthorReference(context.getUserReference());\n                saveDocument(childDocument, saveMessage, true, context);\n            }\n        }\n\n        // Step 3: For each backlink to rename, parse the backlink document and replace the links with the new name.\n        for (DocumentReference backlinkDocumentReference : backlinkDocumentReferences) {\n            XWikiDocument backlinkRootDocument = getDocument(backlinkDocumentReference, context);\n\n            // Update default locale instance\n            renameLinks(backlinkRootDocument, sourceDoc.getDocumentReference(), newDocumentReference, context);\n\n            // Update translations\n            for (Locale locale : backlinkRootDocument.getTranslationLocales(context)) {\n                XWikiDocument backlinkDocument = backlinkRootDocument.getTranslatedDocument(locale, context);\n\n                renameLinks(backlinkDocument, sourceDoc.getDocumentReference(), newDocumentReference, context);\n            }\n        }\n\n        // Get new document\n        XWikiDocument newDocument = getDocument(newDocumentReference, context);\n\n        // Step 4: Refactor the relative links contained in the document to make sure they are relative to the new\n        // document's location.\n        if (Utils.getContextComponentManager().hasComponent(BlockRenderer.class, sourceDoc.getSyntax().toIdString())) {\n            // Only support syntax for which a renderer is provided\n\n            ReferenceRenamer referenceRenamer = Utils.getComponent(ReferenceRenamer.class);\n\n            DocumentReference oldDocumentReference = sourceDoc.getDocumentReference();\n            XDOM newDocumentXDOM = newDocument.getXDOM();\n            boolean modified = referenceRenamer\n                .renameReferences(newDocumentXDOM, newDocumentReference, oldDocumentReference, newDocumentReference,\n                    false);\n\n            // Set the new content and save document if needed\n            if (modified) {\n                newDocument.setContent(newDocumentXDOM);\n                newDocument.setAuthorReference(context.getUserReference());\n                saveDocument(newDocument, context);\n            }\n        }\n    }\n\n    /**\n     * Perform a rename of document by copying the document and deleting the old one.\n     * This operation must be used only in case of document rename from one wiki to another, since it's not supported\n     * by the atomic store operation.\n     *\n     * @param newDocumentReference the new document reference\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *            modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *            document reference\n     * @param context the ubiquitous XWiki Context\n     * @throws XWikiException in case of an error\n     * @since 12.5\n     * @deprecated Old implementation of the rename by copy and delete. Since 12.5 the implementation using\n     * {@link XWikiStoreInterface#renameXWikiDoc(XWikiDocument, DocumentReference, XWikiContext)} should be preferred.\n     */\n    @Deprecated\n    public void renameByCopyAndDelete(XWikiDocument sourceDoc, DocumentReference newDocumentReference,\n        List<DocumentReference> backlinkDocumentReferences, List<DocumentReference> childDocumentReferences,\n        XWikiContext context) throws XWikiException\n    {\n        // Step 1: Copy the document and all its translations under a new document with the new reference.\n        copyDocument(sourceDoc.getDocumentReference(), newDocumentReference, false, context);\n\n        // Step 2: For each child document, update its parent reference.\n        // Step 3: For each backlink to rename, parse the backlink document and replace the links with the new name.\n        // Step 4: Refactor the relative links contained in the document to make sure they are relative to the new\n        // document's location.\n        updateLinksForRename(sourceDoc, newDocumentReference, backlinkDocumentReferences, childDocumentReferences,\n            context);\n\n        // Step 5: Delete the old document\n        deleteDocument(sourceDoc, context);\n\n        // Get new document\n        XWikiDocument newDocument = getDocument(newDocumentReference, context);\n\n        // Step 6: The current document needs to point to the renamed document as otherwise it's pointing to an\n        // invalid XWikiDocument object as it's been deleted...\n        sourceDoc.clone(newDocument);\n    }\n\n    /**\n     * Rename links in passed document and save it if needed.\n     */\n    private void renameLinks(XWikiDocument backlinkDocument, DocumentReference oldLink, DocumentReference newLink,\n        XWikiContext context) throws XWikiException\n    {\n        // FIXME: Duplicate code. See org.xwiki.refactoring.internal.DefaultLinkRefactoring#renameLinks in\n        // xwiki-platform-refactoring-default\n        getOldRendering().renameLinks(backlinkDocument, oldLink, newLink, context);\n\n        // Save if content changed\n        if (backlinkDocument.isContentDirty()) {\n            String saveMessage =\n                localizePlainOrKey(\"core.comment.renameLink\", getCompactEntityReferenceSerializer().serialize(newLink));\n            backlinkDocument.setAuthorReference(context.getUserReference());\n            context.getWiki().saveDocument(backlinkDocument, saveMessage, true, context);\n        }\n    }\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part if it matches the current\n     * wiki).\n     */\n    private static EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n    }\n\n    /**\n     * Used to convert a proper Document Reference to string (compact form).\n     */\n    private static EntityReferenceSerializer<String> getCompactEntityReferenceSerializer()\n    {\n        return Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compact\");\n    }\n\n    /**\n     * Used to resolve a ResourceReference into a proper Entity Reference using the current document to fill the blanks.\n     */\n    private static EntityReferenceResolver<org.xwiki.rendering.listener.reference.ResourceReference>\n        getResourceReferenceEntityReferenceResolver()\n    {\n        return Utils\n            .getComponent(new DefaultParameterizedType(null, EntityReferenceResolver.class,\n                org.xwiki.rendering.listener.reference.ResourceReference.class));\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, true, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean reset, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, reset, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean reset, boolean force, boolean resetCreationData, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, null, reset, force, resetCreationData,\n            context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, true, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, false, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, boolean force, XWikiContext context) throws XWikiException\n    {\n        return copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, force, false, context);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean reset, boolean force, boolean resetCreationData, XWikiContext context)\n        throws XWikiException\n    {\n        String db = context.getWikiId();\n        String sourceWiki = sourceDocumentReference.getWikiReference().getName();\n        String targetWiki = targetDocumentReference.getWikiReference().getName();\n\n        String sourceStringReference = getDefaultEntityReferenceSerializer().serialize(sourceDocumentReference);\n\n        try {\n            context.setWikiId(sourceWiki);\n            XWikiDocument sdoc = getDocument(sourceDocumentReference, context);\n            if (!sdoc.isNew()) {\n                LOGGER.info(\"Copying document [{}] to [{}]\", sourceDocumentReference, targetDocumentReference);\n\n                // Let's switch to the other database to verify if the document already exists\n                context.setWikiId(targetWiki);\n                XWikiDocument previoustdoc = getDocument(targetDocumentReference, context);\n                // There is already an existing document\n                if (!previoustdoc.isNew()) {\n                    if (!force) {\n                        return false;\n                    }\n                }\n\n                // Let's switch back again to the original db\n                context.setWikiId(sourceWiki);\n\n                if (wikilocale == null) {\n                    XWikiDocument tdoc = sdoc.copyDocument(targetDocumentReference, context);\n\n                    // Make sure to replace the existing document if any\n                    tdoc.setNew(true);\n\n                    // forget past versions\n                    if (reset) {\n                        tdoc.setVersion(\"1.1\");\n                    }\n                    if (resetCreationData) {\n                        Date now = new Date();\n                        tdoc.setCreationDate(now);\n                        tdoc.setContentUpdateDate(now);\n                        tdoc.setDate(now);\n                        tdoc.setCreatorReference(context.getUserReference());\n                        tdoc.setAuthorReference(context.getUserReference());\n                    }\n\n                    // We don't want to trigger a new version otherwise the version number will be wrong.\n                    tdoc.setMetaDataDirty(false);\n                    tdoc.setContentDirty(false);\n\n                    saveDocument(tdoc, \"Copied from \" + sourceStringReference, context);\n\n                    if (!reset) {\n                        context.setWikiId(sourceWiki);\n                        XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                        context.setWikiId(targetWiki);\n                        txda = txda.clone(tdoc.getId(), context);\n                        getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                    } else {\n                        context.setWikiId(targetWiki);\n                        getVersioningStore().resetRCSArchive(tdoc, true, context);\n                    }\n\n                    // Now we need to copy the translations\n                    context.setWikiId(sourceWiki);\n                    List<String> tlist = sdoc.getTranslationList(context);\n                    for (String clanguage : tlist) {\n                        XWikiDocument stdoc = sdoc.getTranslatedDocument(clanguage, context);\n                        LOGGER.info(\"Copying document [{}], language [{}] to [{}]\", sourceWiki, clanguage,\n                            targetDocumentReference);\n\n                        context.setWikiId(targetWiki);\n                        XWikiDocument ttdoc = tdoc.getTranslatedDocument(clanguage, context);\n\n                        // There is already an existing document\n                        if (ttdoc != tdoc) {\n                            return false;\n                        }\n\n                        // Let's switch back again to the original db\n                        context.setWikiId(sourceWiki);\n\n                        ttdoc = stdoc.copyDocument(targetDocumentReference, context);\n\n                        // Make sure to replace the existing document if any\n                        ttdoc.setNew(true);\n\n                        // forget past versions\n                        if (reset) {\n                            ttdoc.setNew(true);\n                            ttdoc.setVersion(\"1.1\");\n                        }\n                        if (resetCreationData) {\n                            Date now = new Date();\n                            ttdoc.setCreationDate(now);\n                            ttdoc.setContentUpdateDate(now);\n                            ttdoc.setDate(now);\n                            ttdoc.setCreatorReference(context.getUserReference());\n                            ttdoc.setAuthorReference(context.getUserReference());\n                        }\n\n                        // we don't want to trigger a new version\n                        // otherwise the version number will be wrong\n                        tdoc.setMetaDataDirty(false);\n                        tdoc.setContentDirty(false);\n\n                        saveDocument(ttdoc, \"Copied from \" + sourceStringReference, context);\n\n                        if (!reset) {\n                            context.setWikiId(sourceWiki);\n                            XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                            context.setWikiId(targetWiki);\n                            txda = txda.clone(tdoc.getId(), context);\n                            getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                        } else {\n                            getVersioningStore().resetRCSArchive(tdoc, true, context);\n                        }\n                    }\n                } else {\n                    // We want only one language in the end\n                    XWikiDocument stdoc = sdoc.getTranslatedDocument(wikilocale, context);\n\n                    XWikiDocument tdoc = stdoc.copyDocument(targetDocumentReference, context);\n\n                    // Make sure to replace the existing document if any\n                    tdoc.setNew(true);\n\n                    // forget language\n                    tdoc.setDefaultLanguage(wikilocale);\n                    tdoc.setLanguage(\"\");\n                    // forget past versions\n                    if (reset) {\n                        tdoc.setVersion(\"1.1\");\n                    }\n                    if (resetCreationData) {\n                        Date now = new Date();\n                        tdoc.setCreationDate(now);\n                        tdoc.setContentUpdateDate(now);\n                        tdoc.setDate(now);\n                        tdoc.setCreatorReference(context.getUserReference());\n                        tdoc.setAuthorReference(context.getUserReference());\n                    }\n\n                    // we don't want to trigger a new version\n                    // otherwise the version number will be wrong\n                    tdoc.setMetaDataDirty(false);\n                    tdoc.setContentDirty(false);\n\n                    saveDocument(tdoc, \"Copied from \" + sourceStringReference, context);\n\n                    if (!reset) {\n                        context.setWikiId(sourceWiki);\n                        XWikiDocumentArchive txda = getVersioningStore().getXWikiDocumentArchive(sdoc, context);\n                        context.setWikiId(targetWiki);\n                        txda = txda.clone(tdoc.getId(), context);\n                        getVersioningStore().saveXWikiDocArchive(txda, true, context);\n                    } else {\n                        getVersioningStore().resetRCSArchive(tdoc, true, context);\n                    }\n                }\n            }\n            return true;\n        } finally {\n            context.setWikiId(db);\n        }\n    }\n\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale,\n        XWikiContext context) throws XWikiException\n    {\n        return copySpaceBetweenWikis(space, sourceWiki, targetWiki, locale, false, context);\n    }\n\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale, boolean clean,\n        XWikiContext context) throws XWikiException\n    {\n        String db = context.getWikiId();\n        int nb = 0;\n        // Workaround for XWIKI-3915: Do not use XWikiStoreInterface#searchDocumentNames since currently it has the\n        // side effect of hidding hidden documents and no other workaround exists than directly using\n        // XWikiStoreInterface#search directly\n        String sql = \"select distinct doc.fullName from XWikiDocument as doc\";\n        List<String> parameters = new ArrayList<>();\n        if (space != null) {\n            parameters.add(space);\n            sql += \" where doc.space = ?\" + parameters.size();\n        }\n\n        if (clean) {\n            try {\n                context.setWikiId(targetWiki);\n                List<String> list = getStore().search(sql, 0, 0, parameters, context);\n\n                LOGGER.info(\"Deleting [{}] documents from wiki [{}]\", list.size(), targetWiki);\n\n                for (String docname : list) {\n                    XWikiDocument doc = getDocument(docname, context);\n                    deleteDocument(doc, context);\n                }\n            } finally {\n                context.setWikiId(db);\n            }\n        }\n\n        try {\n            context.setWikiId(sourceWiki);\n            List<String> list = getStore().search(sql, 0, 0, parameters, context);\n\n            LOGGER.info(\"Copying [{}] documents from wiki [{}] to wiki [{}]\", list.size(), sourceWiki, targetWiki);\n\n            WikiReference sourceWikiReference = new WikiReference(sourceWiki);\n            WikiReference targetWikiReference = new WikiReference(targetWiki);\n            for (String docname : list) {\n                DocumentReference sourceDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n                sourceDocumentReference = sourceDocumentReference\n                    .replaceParent(sourceDocumentReference.getWikiReference(), sourceWikiReference);\n                DocumentReference targetDocumentReference =\n                    sourceDocumentReference.replaceParent(sourceWikiReference, targetWikiReference);\n                copyDocument(sourceDocumentReference, targetDocumentReference, locale, context);\n                nb++;\n            }\n            return nb;\n        } finally {\n            context.setWikiId(db);\n        }\n    }\n\n    /**\n     * Copy an entire wiki to a target wiki.\n     * <p>\n     * It does not override document already existing in target wiki.\n     *\n     * @param sourceWiki the source wiki identifier\n     * @param targetWiki the target wiki identifier\n     * @param locale the locale to copy\n     * @param context see {@link XWikiContext}\n     * @return the number of copied documents\n     * @throws XWikiException failed to copy wiki\n     * @deprecated since 5.3, use {@link WikiManager#copy(String, String, String, boolean, boolean, boolean)} instead\n     */\n    @Deprecated\n    public int copyWiki(String sourceWiki, String targetWiki, String locale, XWikiContext context) throws XWikiException\n    {\n        return copyWiki(sourceWiki, targetWiki, locale, false, context);\n    }\n\n    /**\n     * Copy an entire wiki to a target wiki.\n     *\n     * @param sourceWiki the source wiki identifier\n     * @param targetWiki the target wiki identifier\n     * @param locale the locale to copy\n     * @param clean clean the target wiki before copying\n     * @param context see {@link XWikiContext}\n     * @return the number of copied documents\n     * @throws XWikiException failed to copy wiki\n     * @deprecated since 5.3, use {@link WikiManager#copy(String, String, String, boolean, boolean, boolean)} instead\n     */\n    @Deprecated\n    public int copyWiki(String sourceWiki, String targetWiki, String locale, boolean clean, XWikiContext context)\n        throws XWikiException\n    {\n        int documents = copySpaceBetweenWikis(null, sourceWiki, targetWiki, locale, clean, context);\n\n        ObservationManager om = getObservationManager();\n\n        if (om != null) {\n            om.notify(new WikiCopiedEvent(sourceWiki, targetWiki), sourceWiki, context);\n        }\n\n        return documents;\n    }\n\n    public String getEncoding()\n    {\n        return getConfiguration().getProperty(\"xwiki.encoding\", \"UTF-8\");\n    }\n\n    public URL getServerURL(String wikiId, XWikiContext xcontext) throws MalformedURLException\n    {\n        // In path based the base URL is the same for all wikis\n        if (!xcontext.isMainWiki(wikiId) && isPathBased()) {\n            return getServerURL(xcontext.getMainXWiki(), xcontext);\n        }\n\n        // If main wiki check the main wiki home page configuration\n        if (xcontext.isMainWiki(wikiId)) {\n            String homepage = getConfiguration().getProperty(\"xwiki.home\");\n            if (StringUtils.isNotEmpty(homepage)) {\n                try {\n                    return new URL(homepage);\n                } catch (MalformedURLException e) {\n                    LOGGER.warn(\"Invalid main wiki home page URL [{}] configured: {}\", homepage,\n                        ExceptionUtils.getRootCauseMessage(e));\n                }\n            }\n        }\n\n        if (wikiId != null) {\n            try {\n                WikiDescriptor wikiDescriptor = getWikiDescriptorManager().getById(wikiId);\n                if (wikiDescriptor != null) {\n                    String server = wikiDescriptor.getDefaultAlias();\n                    if (server != null) {\n                        String protocol = getWikiProtocol(wikiDescriptor);\n                        int port = getWikiPort(wikiDescriptor, xcontext);\n\n                        if (protocol == null && port == -1) {\n                            // If request is a \"real\" one keep using the same protocol/port (if asking for the same wiki)\n                            XWikiRequest request = xcontext.getRequest();\n                            if (request != null && wikiDescriptor.getId().equals(xcontext.getOriginalWikiId())\n                                && !isDaemon(request)) {\n                                URL sourceURL = HttpServletUtils.getSourceBaseURL(xcontext.getRequest());\n\n                                protocol = sourceURL.getProtocol();\n                                port = sourceURL.getPort();\n                            } else {\n                                // Default to HTTP\n                                protocol = \"http\";\n                            }\n                        }\n\n                        return new URL(protocol != null ? protocol : (port == 443 ? \"https\" : \"http\"), server, port,\n                            \"\");\n                    }\n                }\n            } catch (WikiManagerException e) {\n                LOGGER.error(\"Failed to get descriptor for wiki [{}]\", wikiId, e);\n            }\n        }\n\n        return null;\n    }\n\n    private boolean isDaemon(XWikiRequest request)\n    {\n        return request.getHttpServletRequest() instanceof XWikiServletRequestStub\n            && ((XWikiServletRequestStub) request.getHttpServletRequest()).isDaemon();\n    }\n\n    private String getWikiProtocol(WikiDescriptor wikiDescriptor)\n    {\n        // Try wiki descriptor\n        Boolean secure = wikiDescriptor.isSecure();\n        if (secure != null) {\n            return wikiDescriptor.isSecure() == Boolean.TRUE ? \"https\" : \"http\";\n        }\n\n        // Try configuration\n        String protocol = getConfiguration().getProperty(\"xwiki.url.protocol\");\n        if (protocol != null) {\n            return protocol;\n        }\n\n        // Try main wiki\n        try {\n            secure = getWikiDescriptorManager().getMainWikiDescriptor().isSecure();\n\n            if (secure != null) {\n                return secure ? \"https\" : \"http\";\n            }\n        } catch (WikiManagerException e) {\n            LOGGER.error(\"Failed to get main wiki descriptor\", e);\n        }\n\n        return null;\n    }\n\n    private int getWikiPort(WikiDescriptor wikiDescriptor, XWikiContext context)\n    {\n        // Try wiki descriptor\n        int port = wikiDescriptor.getPort();\n        if (port != -1) {\n            return port;\n        }\n\n        // Try main wiki\n        try {\n            port = getWikiDescriptorManager().getMainWikiDescriptor().getPort();\n\n            if (port != -1) {\n                return port;\n            }\n        } catch (WikiManagerException e) {\n            LOGGER.error(\"Failed to get main wiki descriptor\", e);\n        }\n\n        return -1;\n    }\n\n    public String getServletPath(String wikiName, XWikiContext context)\n    {\n        // unless we are in virtual wiki path mode we should return null\n        if (!context.isMainWiki(wikiName) && isPathBased()) {\n            try {\n                WikiDescriptor wikiDescriptor = getWikiDescriptorManager().getById(wikiName);\n                if (wikiDescriptor != null) {\n                    return \"wiki/\" + wikiDescriptor.getDefaultAlias() + \"/\";\n                }\n            } catch (Exception e) {\n                LOGGER.error(\"Failed to get URL for provided wiki [\" + wikiName + \"]\", e);\n            }\n        }\n\n        String servletPath = getConfiguration().getProperty(\"xwiki.servletpath\", \"\");\n\n        if (context.getRequest() != null) {\n            if (StringUtils.isEmpty(servletPath)) {\n                String currentServletpath = context.getRequest().getServletPath();\n                if (currentServletpath != null && currentServletpath.startsWith(\"/bin\")) {\n                    servletPath = \"bin/\";\n                } else {\n                    servletPath = getConfiguration().getProperty(\"xwiki.defaultservletpath\", \"bin/\");\n                }\n            }\n        }\n\n        return servletPath;\n    }\n\n    public String getWebAppPath(XWikiContext context)\n    {\n        String contextPath = getConfiguration().getProperty(\"xwiki.webapppath\");\n        if (contextPath == null) {\n            // Try getting the context path by asking the request for it (if a request exists!) and if it doesn't\n            // work try extracting it from the context URL.\n            // TODO: Instead of trying to extract from the URL, save the context path at webapp init (using a\n            // ServlettContextListener for example).\n            XWikiRequest request = context.getRequest();\n            if (request != null) {\n                contextPath = request.getContextPath();\n            }\n            if (contextPath == null) {\n                // Extract the context by getting the first path segment\n                contextPath = StringUtils.substringBefore(StringUtils.stripStart(context.getURL().getPath(), \"/\"), \"/\");\n            }\n        }\n\n        // Remove any leading or trailing slashes\n        contextPath = StringUtils.strip(contextPath, \"/\");\n\n        // TODO We're using URL parts in a wrong way, since contextPath and servletPath are returned with a leading /,\n        // while we need a trailing /. This code ensure we always have CONTEXTNAME + \"/\".\n        return contextPath + \"/\";\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference entityReference, String action, String queryString, String anchor,\n        XWikiContext context)\n    {\n        // TODO: replace this API with a clean implementation of EntityResourceReferenceSerializer\n\n        // Handle attachment URL\n        if (EntityType.ATTACHMENT.equals(entityReference.getType())) {\n            // Get the full attachment reference\n            AttachmentReference attachmentReference = getCurrentAttachmentResolver().resolve(entityReference);\n            return getAttachmentURL(attachmentReference, action, queryString, context);\n        }\n\n        // For all other types, we return the URL of the default corresponding document.\n        DocumentReference documentReference = getDocumentReference(entityReference, context);\n        return getURL(documentReference, action, queryString, anchor, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference, String action, XWikiContext context)\n    {\n        return getURL(reference, action, null, null, context);\n    }\n\n    /**\n     * @since 7.2RC1\n     */\n    public String getURL(EntityReference reference, XWikiContext context)\n    {\n        String action = \"view\";\n        if (reference.getType() == EntityType.ATTACHMENT) {\n            action = \"download\";\n        }\n        return getURL(reference, action, context);\n    }\n\n    /**\n     * @since 2.2.1\n     */\n    public String getURL(DocumentReference documentReference, String action, String queryString, String anchor,\n        XWikiContext context)\n    {\n        // We need to serialize the space reference because the old createURL() API doesn't accept a DocumentReference.\n        String spaces = getLocalStringEntityReferenceSerializer().serialize(documentReference.getLastSpaceReference());\n\n        // Take into account the specified document locale.\n        Locale documentLocale = documentReference.getLocale();\n        String actualQueryString = queryString;\n        if (documentLocale != null && documentLocale != Locale.ROOT) {\n            String localeQueryString = \"language=\" + documentLocale;\n            if (StringUtils.isEmpty(queryString)) {\n                actualQueryString = localeQueryString;\n            } else {\n                // Note: if the locale is already specified on the given query string then it won't be overwriten\n                // because the first parameter value is taken into account.\n                actualQueryString += '&' + localeQueryString;\n            }\n        }\n\n        URL url = context.getURLFactory().createURL(spaces, documentReference.getName(), action, actualQueryString,\n            anchor, documentReference.getWikiReference().getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    /**\n     * @deprecated since 2.2.1 use {@link #getURL(DocumentReference, String, String, String, XWikiContext)}\n     */\n    @Deprecated\n    public String getURL(String fullname, String action, String queryString, String anchor, XWikiContext context)\n    {\n        return getURL(getCurrentMixedDocumentReferenceResolver().resolve(fullname), action, queryString, anchor,\n            context);\n    }\n\n    public String getURL(String fullname, String action, String querystring, XWikiContext context)\n    {\n        return getURL(fullname, action, querystring, null, context);\n    }\n\n    /**\n     * @since 2.3M2\n     */\n    public String getURL(DocumentReference reference, String action, XWikiContext context)\n    {\n        return getURL(reference, action, null, null, context);\n    }\n\n    /**\n     * @deprecated since 2.3M2 use {@link #getURL(DocumentReference, String, XWikiContext)}\n     */\n    @Deprecated\n    public String getURL(String fullname, String action, XWikiContext context)\n    {\n        return getURL(fullname, action, null, null, context);\n    }\n\n    public String getExternalURL(String fullname, String action, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, null, null,\n            doc.getDatabase(), context);\n        return url.toString();\n    }\n\n    public String getExternalURL(String fullname, String action, String querystring, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, querystring, null,\n            doc.getDatabase(), context);\n        return url.toString();\n    }\n\n    /**\n     * Get the full URL of the given {@link DocumentReference}. This also includes the server name of the wiki.\n     *\n     * @param documentReference the document that should be resolved\n     * @param action the action of the URL\n     * @param querystring the URL parameters\n     * @param anchor the anchor of the document\n     * @param context the current XWikiContext\n     * @return the full URL of the given reference\n     * @since 9.6RC1\n     */\n    public String getExternalURL(DocumentReference documentReference, String action, String querystring, String anchor,\n        XWikiContext context)\n    {\n        URL url = context.getURLFactory().createExternalURL(\n            this.getLocalStringEntityReferenceSerializer().serialize(documentReference.getLastSpaceReference()),\n            documentReference.getName(), action, querystring, anchor, documentReference.getWikiReference().getName(),\n            context);\n        return url.toString();\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentURL(AttachmentReference attachmentReference, String action, String queryString,\n        XWikiContext context)\n    {\n        DocumentReference documentReference = attachmentReference.getDocumentReference();\n        SpaceReference spaceReference = documentReference.getLastSpaceReference();\n        WikiReference wikiReference = spaceReference.getWikiReference();\n\n        // We need to serialize the space reference because the old URLFactory has no method to create an Attachment URL\n        // from an AttachmentReference...\n        String serializedSpace = getLocalStringEntityReferenceSerializer().serialize(spaceReference);\n\n        URL url = context.getURLFactory().createAttachmentURL(attachmentReference.getName(), serializedSpace,\n            documentReference.getName(), action, queryString, wikiReference.getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentURL(AttachmentReference attachmentReference, String queryString, XWikiContext context)\n    {\n        return getAttachmentURL(attachmentReference, \"download\", queryString, context);\n    }\n\n    /**\n     * @since 7.2M1\n     */\n    public String getAttachmentRevisionURL(AttachmentReference attachmentReference, String revision, String queryString,\n        XWikiContext context)\n    {\n        DocumentReference documentReference = attachmentReference.getDocumentReference();\n        SpaceReference spaceReference = documentReference.getLastSpaceReference();\n        WikiReference wikiReference = spaceReference.getWikiReference();\n\n        // We need to serialize the space reference because the old URLFactory has no method to create an Attachment URL\n        // from an AttachmentReference...\n        String serializedSpace = getLocalStringEntityReferenceSerializer().serialize(spaceReference);\n\n        URL url = context.getURLFactory().createAttachmentRevisionURL(attachmentReference.getName(), serializedSpace,\n            documentReference.getName(), revision, queryString, wikiReference.getName(), context);\n\n        return context.getURLFactory().getURL(url, context);\n    }\n\n    public String getAttachmentURL(String fullname, String filename, XWikiContext context) throws XWikiException\n    {\n        return getAttachmentURL(fullname, filename, null, context);\n    }\n\n    /**\n     * @since 2.5RC1\n     */\n    public String getAttachmentURL(String fullname, String filename, String queryString, XWikiContext context)\n        throws XWikiException\n    {\n        AttachmentReference attachmentReference =\n            new AttachmentReference(filename, getCurrentMixedDocumentReferenceResolver().resolve(fullname));\n\n        return getAttachmentURL(attachmentReference, queryString, context);\n    }\n\n    // Usefull date functions\n\n    public int getTimeDelta(long time)\n    {\n        Date ctime = new Date();\n        return (int) (ctime.getTime() - time);\n    }\n\n    public boolean isMultiLingual(XWikiContext context)\n    {\n        return \"1\".equals(getXWikiPreference(\"multilingual\", \"0\", context));\n    }\n\n    public boolean isLDAP()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.ldap\"));\n    }\n\n    /**\n     * @return true if XWikiAllGroup group should be seen as virtual group containing all users, false to use it as any\n     *         other group\n     * @since 9.3RC1\n     */\n    public boolean isAllGroupImplicit()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.group.allgroupimplicit\"));\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link XWikiUser#isDisabled(XWikiContext)}.\n     */\n    @Deprecated\n    public int checkActive(XWikiContext context) throws XWikiException\n    {\n        return checkActive(context.getUser(), context);\n    }\n\n    /**\n     * @deprecated since 11.8RC1 prefer using {@link XWikiUser#isDisabled(XWikiContext)}.\n     */\n    @Deprecated\n    public int checkActive(String user, XWikiContext context) throws XWikiException\n    {\n        XWikiUser xWikiUser = new XWikiUser(user);\n        return xWikiUser.isDisabled(context) ? 0 : 1;\n    }\n\n    /**\n     * @since 2.3M1\n     */\n    public DocumentReference getDocumentReference(XWikiRequest request, XWikiContext context)\n    {\n        DocumentReference reference;\n        if (context.getMode() == XWikiContext.MODE_PORTLET) {\n            if (request.getParameter(\"topic\") != null) {\n                reference = getCurrentMixedDocumentReferenceResolver().resolve(request.getParameter(\"topic\"));\n            } else {\n                // Point to this wiki's home page\n                reference = getDefaultDocumentReference().setWikiReference(new WikiReference(context.getWikiId()));\n            }\n        } else if (context.getMode() == XWikiContext.MODE_XMLRPC) {\n            reference = new DocumentReference(context.getWikiId(),\n                context.getDoc().getDocumentReference().getLastSpaceReference().getName(),\n                context.getDoc().getDocumentReference().getName());\n        } else {\n            ResourceReference resourceReference = getResourceReferenceManager().getResourceReference();\n            if (resourceReference instanceof EntityResourceReference) {\n                EntityResourceReference entityResource = (EntityResourceReference) resourceReference;\n                String action = entityResource.getAction().getActionName();\n                if ((request.getParameter(\"topic\") != null) && (action.equals(\"edit\") || action.equals(\"inline\"))) {\n                    reference = getCurrentMixedDocumentReferenceResolver().resolve(request.getParameter(\"topic\"));\n                } else {\n                    reference = new DocumentReference(\n                        entityResource.getEntityReference().extractReference(EntityType.DOCUMENT));\n                }\n            } else {\n                // TODO: Handle references not pointing to a document...\n                // Big problem we don't have an Entity URL!\n                throw new RuntimeException(\n                    String.format(\"Resource Reference [%s] isn't an Entity Resource Reference!\", resourceReference));\n            }\n        }\n\n        return reference;\n    }\n\n    /**\n     * Helper method, removes a predefined path segment (the context path or the servel path) from the start of the\n     * requested URI and returns the remainder. This method is needed because special characters in the path can be\n     * URL-encoded, depending on whether the request is forwarded through the request dispatcher or not, and also\n     * depending on the client (some browsers encode -, while some don't).\n     *\n     * @param path the path, as taken from the requested URI\n     * @param segment the segment to remove, as reported by the container\n     * @return the path with the specified segment trimmed from its start\n     */\n    public static String stripSegmentFromPath(String path, String segment)\n    {\n        if (!path.startsWith(segment)) {\n            // The context path probably contains special characters that are encoded in the URL\n            try {\n                segment = URIUtil.encodePath(segment);\n            } catch (URIException e) {\n                LOGGER.warn(\"Invalid path: [\" + segment + \"]\");\n            }\n        }\n        if (!path.startsWith(segment)) {\n            // Some clients also encode -, although it's allowed in the path\n            segment = segment.replaceAll(\"-\", \"%2D\");\n        }\n        if (!path.startsWith(segment)) {\n            // Can't find the context path in the URL (shouldn't happen), just skip to the next path segment\n            return path.substring(path.indexOf('/', 1));\n        }\n        return path.substring(segment.length());\n    }\n\n    public boolean prepareDocuments(XWikiRequest request, XWikiContext context, VelocityContext vcontext)\n        throws XWikiException\n    {\n        XWikiDocument doc;\n        context.getWiki().prepareResources(context);\n        DocumentReference reference = getDocumentReference(request, context);\n        if (context.getAction().equals(\"register\")) {\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n        } else {\n            try {\n                doc = getDocument(reference, context);\n            } catch (XWikiException e) {\n                doc = context.getDoc();\n                if (context.getAction().equals(\"delete\")) {\n                    if (doc == null) {\n                        setPhonyDocument(reference, context, vcontext);\n                        doc = context.getDoc();\n                    }\n                    if (!checkAccess(\"admin\", doc, context)) {\n                        throw e;\n                    }\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // the user is set after the access is checked.\n        boolean hasAccess = checkAccess(context.getAction(), doc, context);\n\n        XWikiUser user;\n        XWikiUser inactiveUser = null;\n        if (context.getUserReference() == null && context.get(XWikiContext.INACTIVE_USER_REFERENCE) != null) {\n            inactiveUser = new XWikiUser((DocumentReference) context.get(XWikiContext.INACTIVE_USER_REFERENCE));\n        }\n        if (context.getUserReference() != null) {\n            user = new XWikiUser(context.getUserReference());\n        } else {\n            user = new XWikiUser(context.getUser());\n        }\n\n        if (inactiveUser != null && context.getAction().equals(\"view\")) {\n            this.handleInactiveUserViewAction(inactiveUser, context, reference, vcontext);\n        }\n        // We need to check rights before we look for translations\n        // Otherwise we don't have the user language\n        else if (!hasAccess) {\n            Object[] args = { doc.getFullName(), user.getUser() };\n            setPhonyDocument(reference, context, vcontext);\n            throw new XWikiException(XWikiException.MODULE_XWIKI_ACCESS, XWikiException.ERROR_XWIKI_ACCESS_DENIED,\n                \"Access to document {0} has been denied to user {1}\", null, args);\n        }\n\n        if (!\"skin\".equals(context.getAction())\n            && !getAuthorizationManager().hasAccess(Right.VIEW, context.getUserReference(), reference)) {\n            // If for some reason (e.g., login action) the user has rights for the action but no view right on the\n            // document, do not load the document into the context.\n            setPhonyDocument(reference, context, vcontext);\n            doc = context.getDoc();\n            context.put(\"tdoc\", doc);\n            context.put(\"cdoc\", doc);\n        } else {\n            context.put(\"doc\", doc);\n            context.put(\"cdoc\", doc);\n            vcontext.put(\"doc\", doc.newDocument(context));\n            vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n            XWikiDocument tdoc;\n\n            // If the parameter language exists and is empty, it means we want to force loading the regular document\n            // not a translation. This should be handled later by doing a better separation between locale used in the UI\n            // and for loading the documents.\n            if (\"\".equals(context.getRequest().getParameter(\"language\"))) {\n                tdoc = doc;\n            } else {\n                tdoc = doc.getTranslatedDocument(context);\n            }\n\n            try {\n                String rev = (String) context.get(\"rev\");\n                if (StringUtils.isNotEmpty(rev)) {\n                    tdoc = getDocument(tdoc, rev, context);\n                }\n            } catch (Exception ex) {\n                // Invalid version, just use the most recent one\n            }\n            context.put(\"tdoc\", tdoc);\n            vcontext.put(\"tdoc\", tdoc.newDocument(context));\n        }\n\n        return true;\n    }\n\n    private void handleInactiveUserViewAction(XWikiUser inactiveUser, XWikiContext context, DocumentReference reference,\n        VelocityContext vcontext) throws XWikiException\n    {\n        if (inactiveUser.isEmailChecked(context)) {\n            Object[] args = { inactiveUser.getUser() };\n            setPhonyDocument(reference, context, vcontext);\n            throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_DISABLED,\n                \"User {0} account is disabled\", null, args);\n        } else if (!reference.getLocalDocumentReference().equals(XWikiUser.ACCOUNT_VALIDATION_DOCUMENT_REFERENCE)) {\n            String allowed = getConfiguration().getProperty(\"xwiki.inactiveuser.allowedpages\", \"\");\n            boolean allow = false;\n            if (!StringUtils.isEmpty(allowed)) {\n                XWikiDocument doc = this.getDocument(reference, context);\n                String[] allowedList = StringUtils.split(allowed, \" ,\");\n                for (String element : allowedList) {\n                    if (element.equals(doc.getFullName())) {\n                        allow = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!allow) {\n                Object[] args = { inactiveUser.getUser() };\n                setPhonyDocument(reference, context, vcontext);\n                throw new XWikiException(XWikiException.MODULE_XWIKI_USER, XWikiException.ERROR_XWIKI_USER_INACTIVE,\n                    \"User {0} account is inactive\", null, args);\n            }\n        }\n    }\n\n    /**\n     * @since 8.3M1\n     */\n    public void setPhonyDocument(DocumentReference reference, XWikiContext context)\n    {\n        XWikiDocument doc = new XWikiDocument(reference);\n        doc.setElements(XWikiDocument.HAS_ATTACHMENTS | XWikiDocument.HAS_OBJECTS);\n        doc.setStore(getStore());\n        context.put(\"doc\", doc);\n    }\n\n    /**\n     * @since 2.3M1\n     * @deprecated since 8.3M1, use {@link #setPhonyDocument(DocumentReference, XWikiContext)} instead\n     */\n    @Deprecated\n    public void setPhonyDocument(DocumentReference reference, XWikiContext context, VelocityContext vcontext)\n    {\n        setPhonyDocument(reference, context);\n\n        vcontext.put(\"doc\", context.getDoc().newDocument(context));\n        vcontext.put(\"cdoc\", vcontext.get(\"doc\"));\n        vcontext.put(\"tdoc\", vcontext.get(\"doc\"));\n    }\n\n    /**\n     * @deprecated since 2.3M1 use {@link #setPhonyDocument(DocumentReference, XWikiContext, VelocityContext)}\n     */\n    @Deprecated\n    public void setPhonyDocument(String docName, XWikiContext context, VelocityContext vcontext)\n    {\n        setPhonyDocument(getCurrentMixedDocumentReferenceResolver().resolve(docName), context, vcontext);\n    }\n\n    public XWikiEngineContext getEngineContext()\n    {\n        return this.engine_context;\n    }\n\n    public void setEngineContext(XWikiEngineContext engine_context)\n    {\n        this.engine_context = engine_context;\n    }\n\n    public void setAuthService(XWikiAuthService authService)\n    {\n        this.authService = authService;\n    }\n\n    public void setRightService(XWikiRightService rightService)\n    {\n        this.rightService = rightService;\n    }\n\n    public XWikiGroupService getGroupService(XWikiContext context) throws XWikiException\n    {\n        synchronized (this.GROUP_SERVICE_LOCK) {\n            if (this.groupService == null) {\n                String groupClass = getConfiguration().getProperty(\"xwiki.authentication.groupclass\",\n                    \"com.xpn.xwiki.user.impl.xwiki.XWikiGroupServiceImpl\");\n\n                try {\n                    this.groupService = (XWikiGroupService) Class.forName(groupClass).newInstance();\n                } catch (Exception e) {\n                    LOGGER.error(\"Failed to instantiate custom group service class: \" + e.getMessage(), e);\n                    this.groupService = new XWikiGroupServiceImpl();\n                }\n                this.groupService.init(this, context);\n            }\n\n            return this.groupService;\n        }\n    }\n\n    public void setGroupService(XWikiGroupService groupService)\n    {\n        this.groupService = groupService;\n    }\n\n    private Class<? extends XWikiAuthService> getAuthServiceClass() throws ClassNotFoundException\n    {\n        String authClass = getConfiguration().getProperty(\"xwiki.authentication.authclass\");\n        if (StringUtils.isEmpty(authClass)) {\n            if (isLDAP()) {\n                authClass = \"com.xpn.xwiki.user.impl.LDAP.XWikiLDAPAuthServiceImpl\";\n            } else {\n                authClass = \"com.xpn.xwiki.user.impl.xwiki.XWikiAuthServiceImpl\";\n            }\n        }\n\n        // Get main wiki ClassLoader\n        ClassLoaderManager clManager = Utils.getComponent(ClassLoaderManager.class);\n        ClassLoader classloader = null;\n        if (clManager != null) {\n            classloader = clManager.getURLClassLoader(\"wiki:xwiki\", false);\n        }\n\n        // Get the class\n        if (classloader != null) {\n            return (Class<? extends XWikiAuthService>) Class.forName(authClass, true, classloader);\n        } else {\n            return (Class<? extends XWikiAuthService>) Class.forName(authClass);\n        }\n    }\n\n    public XWikiAuthService getAuthService()\n    {\n        synchronized (this.AUTH_SERVICE_LOCK) {\n            if (this.authService == null) {\n                LOGGER.info(\"Initializing AuthService...\");\n\n                try {\n                    Class<? extends XWikiAuthService> authClass = getAuthServiceClass();\n\n                    setAuthService(authClass);\n                } catch (Exception e) {\n                    LOGGER.warn(\"Failed to get the configured AuthService class, fallbacking on standard authenticator\",\n                        e);\n\n                    this.authService = new XWikiAuthServiceImpl();\n\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Initialized AuthService {} using 'new'.\", this.authService.getClass().getName());\n                    }\n                }\n            }\n\n            return this.authService;\n        }\n    }\n\n    private void setAuthService(Class<? extends XWikiAuthService> authClass)\n    {\n        try {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Using AuthClass {}\", authClass.getName());\n            }\n\n            this.authService = authClass.newInstance();\n\n            LOGGER.debug(\"Initialized AuthService using Reflection.\");\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to initialize the AuthService from class [{}], fallbacking on standard authenticator\",\n                authClass.getName(), e);\n\n            this.authService = new XWikiAuthServiceImpl();\n\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Initialized AuthService {} using 'new'.\", this.authService.getClass().getName());\n            }\n        }\n    }\n\n    private static final String DEFAULT_RIGHT_SERVICE_CLASS =\n        \"org.xwiki.security.authorization.internal.XWikiCachingRightService\";\n\n    public XWikiRightService getRightService()\n    {\n        synchronized (this.RIGHT_SERVICE_LOCK) {\n            if (this.rightService == null) {\n                LOGGER.info(\"Initializing RightService...\");\n\n                String rightsClass = getConfiguration().getProperty(\"xwiki.authentication.rightsclass\");\n                if (rightsClass != null && !rightsClass.equals(DEFAULT_RIGHT_SERVICE_CLASS)) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.warn(\"Using custom Right Service [{}].\", rightsClass);\n                    }\n                } else {\n                    rightsClass = DEFAULT_RIGHT_SERVICE_CLASS;\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"Using default Right Service [{}].\", rightsClass);\n                    }\n                }\n\n                try {\n                    this.rightService = (XWikiRightService) Class.forName(rightsClass).newInstance();\n                    LOGGER.debug(\"Initialized RightService using Reflection.\");\n                } catch (Exception e) {\n                    Exception lastException = e;\n\n                    if (!rightsClass.equals(DEFAULT_RIGHT_SERVICE_CLASS)) {\n                        LOGGER.warn(String.format(\n                            \"Failed to initialize custom RightService [%s]\"\n                                + \" by Reflection, using default implementation [%s].\",\n                            rightsClass, DEFAULT_RIGHT_SERVICE_CLASS), e);\n                        rightsClass = DEFAULT_RIGHT_SERVICE_CLASS;\n                        try {\n                            this.rightService = (XWikiRightService) Class.forName(rightsClass).newInstance();\n                            LOGGER.debug(\"Initialized default RightService using Reflection.\");\n                        } catch (Exception e1) {\n                            lastException = e1;\n                        }\n                    }\n\n                    if (this.rightService == null) {\n                        LOGGER.warn(String.format(\n                            \"Failed to initialize RightService [%s]\"\n                                + \" by Reflection, using OLD implementation [%s] with 'new'.\",\n                            rightsClass, XWikiRightServiceImpl.class.getCanonicalName()), lastException);\n\n                        this.rightService = new XWikiRightServiceImpl();\n\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Initialized old RightService implementation \"\n                                + this.rightService.getClass().getName() + \" using 'new'.\");\n                        }\n                    }\n                }\n            }\n            return this.rightService;\n        }\n    }\n\n    public XWikiStatsService getStatsService(XWikiContext context)\n    {\n        synchronized (this.STATS_SERVICE_LOCK) {\n            if (this.statsService == null) {\n                if (\"1\".equals(getConfiguration().getProperty(\"xwiki.stats\", \"1\"))) {\n                    String storeClass = getConfiguration().getProperty(\"xwiki.stats.class\",\n                        \"com.xpn.xwiki.stats.impl.XWikiStatsServiceImpl\");\n                    try {\n                        this.statsService = (XWikiStatsService) Class.forName(storeClass).newInstance();\n                    } catch (Exception e) {\n                        LOGGER.error(e.getMessage(), e);\n\n                        this.statsService = new XWikiStatsServiceImpl();\n                    }\n\n                    this.statsService.init(context);\n                }\n            }\n\n            return this.statsService;\n        }\n    }\n\n    public XWikiURLFactoryService getURLFactoryService()\n    {\n        if (this.urlFactoryService == null) {\n            synchronized (this.URLFACTORY_SERVICE_LOCK) {\n                if (this.urlFactoryService == null) {\n                    LOGGER.info(\"Initializing URLFactory Service...\");\n\n                    XWikiURLFactoryService factoryService = null;\n\n                    String urlFactoryServiceClass = getConfiguration().getProperty(\"xwiki.urlfactory.serviceclass\");\n                    if (urlFactoryServiceClass != null) {\n                        try {\n                            if (LOGGER.isDebugEnabled()) {\n                                LOGGER.debug(\"Using custom URLFactory Service Class [\" + urlFactoryServiceClass + \"]\");\n                            }\n                            factoryService = (XWikiURLFactoryService) Class.forName(urlFactoryServiceClass)\n                                .getConstructor(new Class<?>[] { XWiki.class }).newInstance(new Object[] { this });\n                        } catch (Exception e) {\n                            factoryService = null;\n                            LOGGER.warn(\"Failed to initialize URLFactory Service [\" + urlFactoryServiceClass + \"]\", e);\n                        }\n                    }\n                    if (factoryService == null) {\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"Using default URLFactory Service Class [\" + urlFactoryServiceClass + \"]\");\n                        }\n                        factoryService = new XWikiURLFactoryServiceImpl(this);\n                    }\n\n                    // Set the urlFactoryService object in one assignment to prevent threading\n                    // issues when checking for\n                    // null above.\n                    this.urlFactoryService = factoryService;\n                }\n            }\n        }\n\n        return this.urlFactoryService;\n    }\n\n    public XWikiCriteriaService getCriteriaService(XWikiContext context)\n    {\n        return this.criteriaService;\n    }\n\n    public ZipOutputStream getZipOutputStream(XWikiContext context) throws IOException\n    {\n        return new ZipOutputStream(context.getResponse().getOutputStream());\n    }\n\n    private Map<String, SearchEngineRule> getSearchEngineRules(XWikiContext context)\n    {\n        // We currently hardcode the rules\n        // We will put them in the preferences soon\n        Map<String, SearchEngineRule> map = new HashMap<String, SearchEngineRule>();\n        map.put(\"Google\", new SearchEngineRule(\"google.\", \"s/(^|.*&)q=(.*?)(&.*|$)/$2/\"));\n        map.put(\"MSN\", new SearchEngineRule(\"search.msn.\", \"s/(^|.*&)q=(.*?)(&.*|$)/$2/\"));\n        map.put(\"Yahoo\", new SearchEngineRule(\"search.yahoo.\", \"s/(^|.*&)p=(.*?)(&.*|$)/$2/\"));\n        map.put(\"Voila\", new SearchEngineRule(\"voila.fr\", \"s/(^|.*&)kw=(.*?)(&.*|$)/$2/\"));\n\n        return map;\n    }\n\n    public String getRefererText(String referer, XWikiContext context)\n    {\n        try {\n            URL url = new URL(referer);\n            Map<String, SearchEngineRule> searchengines = getSearchEngineRules(context);\n            if (searchengines != null) {\n                for (SearchEngineRule senginerule : searchengines.values()) {\n                    String host = url.getHost();\n                    int i1 = host.indexOf(senginerule.getHost());\n                    if (i1 != -1) {\n                        String query = context.getUtil().substitute(senginerule.getRegEx(), url.getQuery());\n                        if ((query != null) && (!query.equals(\"\"))) {\n                            // We return the query text instead of the full referer\n                            return host.substring(i1) + \":\" + query;\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n        }\n\n        String result = referer.substring(referer.indexOf(\"://\") + 3);\n        if (result.endsWith(\"/\")) {\n            return result.substring(0, result.length() - 1);\n        } else {\n            return result;\n        }\n    }\n\n    public boolean isMySQL()\n    {\n        if (getHibernateStore() == null) {\n            return false;\n        }\n\n        Object dialect = getHibernateStore().getConfiguration().getProperties().get(\"dialect\");\n        return \"org.hibernate.dialect.MySQLDialect\".equals(dialect)\n            || \"net.sf.hibernate.dialect.MySQLDialect\".equals(dialect);\n    }\n\n    public String getFullNameSQL()\n    {\n        return getFullNameSQL(true);\n    }\n\n    public String getFullNameSQL(boolean newFullName)\n    {\n        if (newFullName) {\n            return \"doc.fullName\";\n        }\n\n        if (this.fullNameSQL == null) {\n            if (isMySQL()) {\n                this.fullNameSQL = \"CONCAT(doc.space,'.',doc.name)\";\n            } else {\n                this.fullNameSQL = \"doc.space||'.'||doc.name\";\n            }\n        }\n\n        return this.fullNameSQL;\n    }\n\n    public String getUserName(String user, XWikiContext context)\n    {\n        return getUserName(user, null, true, context);\n    }\n\n    public String getUserName(String user, String format, XWikiContext context)\n    {\n        return getUserName(user, format, true, context);\n    }\n\n    /**\n     * @return a formatted and pretty printed user name for displaying\n     */\n    public String getUserName(String user, String format, boolean link, XWikiContext context)\n    {\n        if (StringUtils.isBlank(user)) {\n            return localizePlainOrKey(\"core.users.unknownUser\");\n        }\n\n        DocumentReference userReference = getCurrentMixedDocumentReferenceResolver().resolve(user);\n\n        return getUserName(userReference, format, link, true, context);\n    }\n\n    /**\n     * Generate a display user name and return it.\n     *\n     * @param userReference\n     * @param format a Velocity scnippet used to format the user name\n     * @param link true if a full html link snippet should be returned\n     * @param escapeXML true if the returned name should be escaped (forced true if {@code link} is true)\n     * @param context see {@link XWikiContext}\n     * @return the display user name or a html snippet with the link to the passed user\n     * @since 6.4RC1\n     */\n    public String getUserName(DocumentReference userReference, String format, boolean link, boolean escapeXML,\n        XWikiContext context)\n    {\n        if (userReference == null) {\n            return localizePlainOrKey(\"core.users.unknownUser\");\n        }\n\n        XWikiDocument userdoc = null;\n        try {\n            userdoc = getDocument(userReference, context);\n            if (userdoc == null) {\n                return escapeXML ? XMLUtils.escape(userReference.getName()) : userReference.getName();\n            }\n\n            BaseObject userobj = userdoc.getObject(\"XWiki.XWikiUsers\");\n            if (userobj == null) {\n                return escapeXML ? XMLUtils.escape(userdoc.getDocumentReference().getName())\n                    : userdoc.getDocumentReference().getName();\n            }\n\n            String text;\n\n            if (format == null) {\n                text = userobj.getStringValue(\"first_name\");\n                String lastName = userobj.getStringValue(\"last_name\");\n                if (!text.isEmpty() && !lastName.isEmpty()) {\n                    text += ' ';\n                }\n                text += userobj.getStringValue(\"last_name\");\n                if (StringUtils.isBlank(text)) {\n                    text = userdoc.getDocumentReference().getName();\n                }\n            } else {\n                VelocityContext vcontext;\n                try {\n                    vcontext = getVelocityContextFactory().createContext();\n                } catch (XWikiVelocityException e) {\n                    LOGGER.error(\"Failed to create standard VelocityContext\", e);\n\n                    vcontext = new XWikiVelocityContext();\n                }\n\n                for (String propname : userobj.getPropertyList()) {\n                    vcontext.put(propname, userobj.getStringValue(propname));\n                }\n                text = evaluateVelocity(format,\n                    \"<username formatting code in \" + context.getDoc().getDocumentReference() + \">\", vcontext);\n            }\n\n            if (escapeXML || link) {\n                text = XMLUtils.escape(text.trim());\n            }\n\n            if (link) {\n                text = \"<span class=\\\"wikilink\\\"><a href=\\\"\" + userdoc.getURL(\"view\", context) + \"\\\">\" + text\n                    + \"</a></span>\";\n            }\n            return text;\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to display the user name of [{}]. Root cause is [{}]. Falling back on the user id.\",\n                userReference, ExceptionUtils.getRootCauseMessage(e));\n\n            return escapeXML ? XMLUtils.escape(userReference.getName()) : userReference.getName();\n        }\n    }\n\n    /**\n     * @param content the Velocity content to evaluate\n     * @param namespace the namespace under which to evaluate it (used for isolation)\n     * @param vcontext the Velocity context to use when evaluating. If {@code null}, then a new context will be created,\n     *            initialized and used.\n     * @return the evaluated content\n     * @since 7.2M1\n     */\n    public String evaluateVelocity(String content, String namespace, VelocityContext vcontext)\n    {\n        try {\n            return getVelocityEvaluator().evaluateVelocity(content, namespace, vcontext);\n        } catch (XWikiException xe) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}] with content:\\n[{}]\", namespace, content,\n                xe.getCause());\n            return Util.getHTMLExceptionMessage(xe, null);\n        }\n    }\n\n    /**\n     * @param content the Velocity content to evaluate\n     * @param name the namespace under which to evaluate it (used for isolation)\n     * @return the evaluated content\n     * @since 7.2M1\n     */\n    public String evaluateVelocity(String content, String name)\n    {\n        try {\n            VelocityManager velocityManager = Utils.getComponent(VelocityManager.class);\n            VelocityContext velocityContext = velocityManager.getVelocityContext();\n            return evaluateVelocity(content, name, velocityContext);\n        } catch (Exception e) {\n            LOGGER.error(\"Error while parsing velocity template namespace [{}] with content:\\n[{}]\", name, content, e);\n            Object[] args = { name };\n            XWikiException xe = new XWikiException(XWikiException.MODULE_XWIKI_RENDERING,\n                XWikiException.ERROR_XWIKI_RENDERING_VELOCITY_EXCEPTION, \"Error while parsing velocity page {0}\", e,\n                args);\n            return Util.getHTMLExceptionMessage(xe, null);\n        }\n    }\n\n    /**\n     * Generate and return an unescaped user display name.\n     *\n     * @param userReference the user reference\n     * @param context see {@link XWikiContext}\n     * @return the unescaped display user name\n     * @since 6.4RC1\n     */\n    public String getPlainUserName(DocumentReference userReference, XWikiContext context)\n    {\n        return getUserName(userReference, null, false, false, context);\n    }\n\n    public boolean hasCentralizedAuthentication(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"authentication_centralized\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.authentication.centralized\", \"0\"));\n    }\n\n    public String getLocalUserName(String user, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, null, true, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), null, true, context);\n        }\n    }\n\n    public String getLocalUserName(String user, String format, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, format, true, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), format, true, context);\n        }\n    }\n\n    public String getLocalUserName(String user, String format, boolean link, XWikiContext context)\n    {\n        if (hasCentralizedAuthentication(context)) {\n            return getUserName(user, format, link, context);\n        } else {\n            return getUserName(user.substring(user.indexOf(':') + 1), format, link, context);\n        }\n    }\n\n    public String formatDate(Date date, String format, XWikiContext context)\n    {\n        if (date == null) {\n            return \"\";\n        }\n        String xformat = format;\n        String defaultFormat = \"yyyy/MM/dd HH:mm\";\n\n        if (format == null) {\n            xformat = getXWikiPreference(\"dateformat\", defaultFormat, context);\n        }\n\n        try {\n            DateFormatSymbols formatSymbols = null;\n            try {\n                String language = getLanguagePreference(context);\n                formatSymbols = new DateFormatSymbols(new Locale(language));\n            } catch (Exception e2) {\n                String language = getXWikiPreference(\"default_language\", context);\n                if ((language != null) && (!language.equals(\"\"))) {\n                    formatSymbols = new DateFormatSymbols(new Locale(language));\n                }\n            }\n\n            SimpleDateFormat sdf;\n            if (formatSymbols != null) {\n                sdf = new SimpleDateFormat(xformat, formatSymbols);\n            } else {\n                sdf = new SimpleDateFormat(xformat);\n            }\n\n            try {\n                sdf.setTimeZone(TimeZone.getTimeZone(getUserTimeZone(context)));\n            } catch (Exception e) {\n            }\n\n            return sdf.format(date);\n        } catch (Exception e) {\n            LOGGER.info(\"Failed to format date [\" + date + \"] with pattern [\" + xformat + \"]: \" + e.getMessage());\n            if (format == null) {\n                if (xformat.equals(defaultFormat)) {\n                    return date.toString();\n                } else {\n                    return formatDate(date, defaultFormat, context);\n                }\n            } else {\n                return formatDate(date, null, context);\n            }\n        }\n    }\n\n    /*\n     * Allow to read user setting providing the user timezone All dates will be expressed with this timezone\n     */\n    public String getUserTimeZone(XWikiContext context)\n    {\n        String tz = getUserPreference(\"timezone\", context);\n        // We perform this verification ourselves since TimeZone#getTimeZone(String) with an invalid parameter returns\n        // GMT and not the system default.\n        if (!ArrayUtils.contains(TimeZone.getAvailableIDs(), tz)) {\n            String defaultTz = TimeZone.getDefault().getID();\n            return getConfiguration().getProperty(\"xwiki.timezone\", defaultTz);\n        } else {\n            return tz;\n        }\n    }\n\n    /**\n     * @deprecated since 2.2.1 use {@link #exists(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public boolean exists(String fullname, XWikiContext context)\n    {\n        return exists(getCurrentMixedDocumentReferenceResolver().resolve(fullname), context);\n    }\n\n    public boolean exists(DocumentReference documentReference, XWikiContext context)\n    {\n        String currentWiki = context.getWikiId();\n\n        try {\n            XWikiDocument doc = new XWikiDocument(documentReference, documentReference.getLocale());\n\n            context.setWikiId(documentReference.getWikiReference().getName());\n\n            return getStore().exists(doc, context);\n        } catch (XWikiException e) {\n            return false;\n        } finally {\n            context.setWikiId(currentWiki);\n        }\n    }\n\n    /**\n     * Returns whether a page exists or not.\n     * \n     * @param reference the reference of the page to check for its existence\n     * @return true if the page exists, false if not\n     * @since 13.3RC1\n     * @since 12.10.7\n     */\n    @Unstable\n    public boolean exists(PageReference reference, XWikiContext context)\n    {\n        // Try as space\n        DocumentReference documentReference = getCurrentReferenceDocumentReferenceResolver().resolve(reference);\n        if (exists(documentReference, context)) {\n            return true;\n        }\n\n        // Try as document\n        if (documentReference.getParent().getParent().getType() == EntityType.SPACE) {\n            return exists(new DocumentReference(documentReference.getParent().getName(),\n                documentReference.getParent().getParent(), documentReference.getParameters()), context);\n        }\n\n        return false;\n    }\n\n    public String getAdType(XWikiContext context)\n    {\n        String adtype = \"\";\n        XWikiDocument wikiServer = context.getWikiServer();\n        if (wikiServer != null) {\n            adtype = wikiServer.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"adtype\");\n        }\n\n        if (adtype.equals(\"\")) {\n            adtype = getConfiguration().getProperty(\"xwiki.ad.type\", \"\");\n        }\n\n        return adtype;\n    }\n\n    public String getAdClientId(XWikiContext context)\n    {\n        final String defaultadclientid = \"pub-2778691407285481\";\n        String adclientid = \"\";\n        XWikiDocument wikiServer = context.getWikiServer();\n        if (wikiServer != null) {\n            adclientid = wikiServer.getStringValue(VIRTUAL_WIKI_DEFINITION_CLASS_REFERENCE, \"adclientid\");\n        }\n\n        if (adclientid.equals(\"\")) {\n            adclientid = getConfiguration().getProperty(\"xwiki.ad.clientid\", \"\");\n        }\n\n        if (adclientid.equals(\"\")) {\n            adclientid = defaultadclientid;\n        }\n\n        return adclientid;\n    }\n\n    /**\n     * @deprecated\n     */\n    @Deprecated\n    public XWikiPluginInterface getPlugin(String name, XWikiContext context)\n    {\n        XWikiPluginManager plugins = getPluginManager();\n        Vector<String> pluginlist = plugins.getPlugins();\n        for (String pluginname : pluginlist) {\n            if (pluginname.equals(name)) {\n                return plugins.getPlugin(pluginname);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @deprecated\n     */\n    @Deprecated\n    public Api getPluginApi(String name, XWikiContext context)\n    {\n        XWikiPluginInterface plugin = getPlugin(name, context);\n        if (plugin != null) {\n            return plugin.getPluginApi(plugin, context);\n        }\n\n        return null;\n    }\n\n    public int getHttpTimeout(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.http.timeout\", 60000);\n    }\n\n    public String getHttpUserAgent(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.http.useragent\", \"XWikiBot/1.0\");\n    }\n\n    public String getURLContent(String surl, XWikiContext context) throws IOException\n    {\n        return getURLContent(surl, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public String getURLContent(String surl, int timeout, String userAgent) throws IOException\n    {\n        String content;\n        HttpClient client = getHttpClient(timeout, userAgent);\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            client.executeMethod(get);\n            content = get.getResponseBodyAsString();\n        } finally {\n            // Release any connection resources used by the method\n            get.releaseConnection();\n        }\n\n        return content;\n    }\n\n    public String getURLContent(String surl, String username, String password, XWikiContext context) throws IOException\n    {\n        return getURLContent(surl, username, password, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public String getURLContent(String surl, String username, String password, int timeout, String userAgent)\n        throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // pass our credentials to HttpClient, they will only be used for\n        // authenticating to servers with realm \"realm\", to authenticate agains\n        // an arbitrary realm change this to null.\n        client.getState().setCredentials(new AuthScope(null, -1, null),\n            new UsernamePasswordCredentials(username, password));\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // Tell the GET method to automatically handle authentication. The\n            // method will use any appropriate credentials to handle basic\n            // authentication requests. Setting this value to false will cause\n            // any request for authentication to return with a status of 401.\n            // It will then be up to the client to handle the authentication.\n            get.setDoAuthentication(true);\n\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBodyAsString();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    public byte[] getURLContentAsBytes(String surl, XWikiContext context) throws IOException\n    {\n        return getURLContentAsBytes(surl, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public byte[] getURLContentAsBytes(String surl, int timeout, String userAgent) throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBody();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    public byte[] getURLContentAsBytes(String surl, String username, String password, XWikiContext context)\n        throws IOException\n    {\n        return getURLContentAsBytes(surl, username, password, getHttpTimeout(context), getHttpUserAgent(context));\n    }\n\n    public byte[] getURLContentAsBytes(String surl, String username, String password, int timeout, String userAgent)\n        throws IOException\n    {\n        HttpClient client = getHttpClient(timeout, userAgent);\n\n        // pass our credentials to HttpClient, they will only be used for\n        // authenticating to servers with realm \"realm\", to authenticate agains\n        // an arbitrary realm change this to null.\n        client.getState().setCredentials(new AuthScope(null, -1, null),\n            new UsernamePasswordCredentials(username, password));\n\n        // create a GET method that reads a file over HTTPS, we're assuming\n        // that this file requires basic authentication using the realm above.\n        GetMethod get = new GetMethod(surl);\n\n        try {\n            // Tell the GET method to automatically handle authentication. The\n            // method will use any appropriate credentials to handle basic\n            // authentication requests. Setting this value to false will cause\n            // any request for authentication to return with a status of 401.\n            // It will then be up to the client to handle the authentication.\n            get.setDoAuthentication(true);\n\n            // execute the GET\n            client.executeMethod(get);\n\n            // print the status and response\n            return get.getResponseBody();\n        } finally {\n            // release any connection resources used by the method\n            get.releaseConnection();\n        }\n    }\n\n    /**\n     * API to list all spaces in the current wiki.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @return a list of string representing all non-hidden spaces (ie spaces that have non-hidden pages) for the\n     *         current wiki\n     * @throws XWikiException if something went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaces(XWikiContext context) throws XWikiException\n    {\n        try {\n            return getStore().getQueryManager().getNamedQuery(\"getSpaces\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\")).execute();\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    /**\n     * API to list all non-hidden documents in a space.\n     *\n     * @param spaceReference the local reference of the space for which to return all non-hidden documents\n     * @return the list of document names (in the format {@code Space.Page}) for non-hidden documents in the specified\n     *         space\n     * @throws XWikiException if the loading went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaceDocsName(String spaceReference, XWikiContext context) throws XWikiException\n    {\n        try {\n            return getStore().getQueryManager().getNamedQuery(\"getSpaceDocsName\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\"))\n                .bindValue(\"space\", spaceReference).execute();\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    public List<String> getIncludedMacros(String defaultSpace, String content, XWikiContext context)\n    {\n        List<String> list;\n\n        try {\n            String pattern = \"#includeMacros[ ]*\\\\([ ]*([\\\"'])(.*?)\\\\1[ ]*\\\\)\";\n            list = context.getUtil().getUniqueMatches(content, pattern, 2);\n            for (int i = 0; i < list.size(); i++) {\n                String name = list.get(i);\n                if (name.indexOf('.') == -1) {\n                    list.set(i, defaultSpace + \".\" + name);\n                }\n            }\n        } catch (Exception e) {\n            // This should never happen\n            LOGGER.error(\"Failed to extract #includeMacros targets from provided content [\" + content + \"]\", e);\n\n            list = Collections.emptyList();\n        }\n\n        return list;\n    }\n\n    /**\n     * accessor for the isReadOnly instance var.\n     *\n     * @see #isReadOnly\n     */\n    public boolean isReadOnly()\n    {\n        return this.isReadOnly;\n    }\n\n    public void setReadOnly(boolean readOnly)\n    {\n        this.isReadOnly = readOnly;\n    }\n\n    public void deleteAllDocuments(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        deleteAllDocuments(doc, true, context);\n    }\n\n    public void deleteAllDocuments(XWikiDocument doc, boolean toTrash, XWikiContext context) throws XWikiException\n    {\n        // Wrap the work as a batch operation.\n        BatchOperationExecutor batchOperationExecutor = Utils.getComponent(BatchOperationExecutor.class);\n        batchOperationExecutor.execute(() -> {\n            // Delete all translation documents\n            for (Locale locale : doc.getTranslationLocales(context)) {\n                XWikiDocument tdoc = doc.getTranslatedDocument(locale, context);\n                deleteDocument(tdoc, toTrash, context);\n            }\n\n            // Delete the default document\n            deleteDocument(doc, toTrash, context);\n        });\n    }\n\n    public void refreshLinks(XWikiContext context) throws XWikiException\n    {\n        try {\n            // refreshes all Links of each doc of the wiki\n            @SuppressWarnings(\"deprecation\")\n            List<String> docs = getStore().getQueryManager().getNamedQuery(\"getAllDocuments\")\n                .addFilter(Utils.<QueryFilter>getComponent(QueryFilter.class, \"hidden\")).execute();\n            for (int i = 0; i < docs.size(); i++) {\n                XWikiDocument myDoc = this.getDocument(docs.get(i), context);\n                myDoc.getStore().saveLinks(myDoc, context, true);\n            }\n        } catch (QueryException ex) {\n            throw new XWikiException(0, 0, ex.getMessage(), ex);\n        }\n    }\n\n    public boolean hasBacklinks(XWikiContext context)\n    {\n        if (this.hasBacklinks == null) {\n            this.hasBacklinks = \"1\".equals(getXWikiPreference(\"backlinks\", \"xwiki.backlinks\", \"0\", context));\n        }\n        return this.hasBacklinks;\n    }\n\n    public boolean hasTags(XWikiContext context)\n    {\n        return \"1\".equals(getXWikiPreference(\"tags\", \"xwiki.tags\", \"0\", context));\n    }\n\n    public boolean hasCustomMappings()\n    {\n        return getHibernateConfiguration().hasCustomMappings();\n    }\n\n    public boolean hasDynamicCustomMappings()\n    {\n        return getHibernateConfiguration().hasDynamicCustomMappings();\n    }\n\n    public String getDefaultSpace(XWikiContext context)\n    {\n        String defaultSpace = getXWikiPreference(\"defaultweb\", \"\", context);\n        if (StringUtils.isEmpty(defaultSpace)) {\n            return getConfiguration().getProperty(\"xwiki.defaultweb\", DEFAULT_HOME_SPACE);\n        }\n        return defaultSpace;\n    }\n\n    public boolean showViewAction(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"showviewaction\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        } else if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.showviewaction\", \"1\"));\n    }\n\n    public boolean useDefaultAction(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"usedefaultaction\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.usedefaultaction\", \"0\"));\n    }\n\n    public String getDefaultPage(XWikiContext context)\n    {\n        String defaultPage = getXWikiPreference(\"defaultpage\", \"\", context);\n        if (StringUtils.isEmpty(defaultPage)) {\n            return getConfiguration().getProperty(\"xwiki.defaultpage\", DEFAULT_SPACE_HOMEPAGE);\n        }\n        return defaultPage;\n    }\n\n    public boolean hasEditComment(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment\", \"0\"));\n    }\n\n    public boolean isEditCommentFieldHidden(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_hidden\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.hidden\", \"0\"));\n    }\n\n    public boolean isEditCommentSuggested(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_suggested\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.suggested\", \"0\"));\n    }\n\n    public boolean isEditCommentMandatory(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"editcomment_mandatory\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.editcomment.mandatory\", \"0\"));\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#hasMinorEdit()\n     */\n    public boolean hasMinorEdit(XWikiContext context)\n    {\n        String bl = getXWikiPreference(\"minoredit\", \"\", context);\n        if (\"1\".equals(bl)) {\n            return true;\n        }\n\n        if (\"0\".equals(bl)) {\n            return false;\n        }\n\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.minoredit\", \"1\"));\n    }\n\n    /**\n     * @see com.xpn.xwiki.api.XWiki#hasRecycleBin()\n     * @param context see {@link XWikiContext}\n     */\n    public boolean hasRecycleBin(XWikiContext context)\n    {\n        return getStoreConfiguration().isRecycleBinEnabled();\n    }\n\n    /**\n     * Indicates whether deleted attachments are stored in a recycle bin or not. This can be configured using the key\n     * <var>storage.attachment.recyclebin</var>.\n     *\n     * @param context see {@link XWikiContext}\n     */\n    public boolean hasAttachmentRecycleBin(XWikiContext context)\n    {\n        return getStoreConfiguration().isAttachmentRecycleBinEnabled();\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    public BaseClass getXClass(DocumentReference documentReference, XWikiContext context) throws XWikiException\n    {\n        // Used to avoid recursive loading of documents if there are recursives usage of classes\n        BaseClass bclass = context.getBaseClass(documentReference);\n        if (bclass != null) {\n            return bclass;\n        }\n\n        return getDocument(documentReference, context).getXClass();\n    }\n\n    /**\n     * @deprecated since 2.2M2 use {@link #getXClass(DocumentReference, XWikiContext)}\n     */\n    @Deprecated\n    public BaseClass getClass(String fullName, XWikiContext context) throws XWikiException\n    {\n        DocumentReference reference = null;\n        if (StringUtils.isNotEmpty(fullName)) {\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);\n        }\n        return getXClass(reference, context);\n    }\n\n    public String getEditorPreference(XWikiContext context)\n    {\n        String defaultSyntaxContentEditor = getEditConfiguration().getDefaultEditor(SyntaxContent.class);\n\n        return defaultSyntaxContentEditor == null ? \"\" : defaultSyntaxContentEditor.toLowerCase();\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String. Note that Groovy scripts\n     * compilation is cached.\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public Object parseGroovyFromString(String script, XWikiContext xcontext) throws XWikiException\n    {\n        return getParseGroovyFromString().parseGroovyFromString(script, xcontext);\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String, using a classloader including all\n     * JAR files located in the passed page as attachments. Note that Groovy scripts compilation is cached\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public Object parseGroovyFromString(String script, String jarWikiPage, XWikiContext xcontext) throws XWikiException\n    {\n        XWikiPageClassLoader pcl = new XWikiPageClassLoader(jarWikiPage, xcontext);\n        Object prevParentClassLoader = xcontext.get(\"parentclassloader\");\n        try {\n            xcontext.put(\"parentclassloader\", pcl);\n\n            return parseGroovyFromString(script, xcontext);\n        } finally {\n            if (prevParentClassLoader == null) {\n                xcontext.remove(\"parentclassloader\");\n            } else {\n                xcontext.put(\"parentclassloader\", prevParentClassLoader);\n            }\n        }\n    }\n\n    public Object parseGroovyFromPage(String fullName, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groovyDocument = context.getWiki().getDocument(fullName, context);\n\n        Object sdoc = context.get(XWikiDocument.CKEY_SDOC);\n        context.put(XWikiDocument.CKEY_SDOC, groovyDocument);\n\n        try {\n            return parseGroovyFromString(groovyDocument.getContent(), context);\n        } finally {\n            context.put(XWikiDocument.CKEY_SDOC, sdoc);\n        }\n    }\n\n    public Object parseGroovyFromPage(String fullName, String jarWikiPage, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument groovyDocument = context.getWiki().getDocument(fullName, context);\n\n        Object sdoc = context.get(XWikiDocument.CKEY_SDOC);\n        context.put(XWikiDocument.CKEY_SDOC, groovyDocument);\n\n        try {\n            return parseGroovyFromString(groovyDocument.getContent(), jarWikiPage, context);\n        } finally {\n            context.put(XWikiDocument.CKEY_SDOC, sdoc);\n        }\n    }\n\n    public String getMacroList(XWikiContext context)\n    {\n        String macrosmapping = \"\";\n        XWiki xwiki = context.getWiki();\n\n        try {\n            macrosmapping = getResourceContent(MACROS_FILE);\n        } catch (IOException e) {\n        }\n\n        macrosmapping += \"\\r\\n\" + xwiki.getXWikiPreference(\"macros_mapping\", \"\", context);\n\n        return macrosmapping;\n    }\n\n    // This functions adds an object from an new object creation form\n    public BaseObject getObjectFromRequest(String className, XWikiContext context) throws XWikiException\n    {\n        Map<String, String[]> map = Util.getObject(context.getRequest(), className);\n        BaseClass bclass = context.getWiki().getClass(className, context);\n        BaseObject newobject = (BaseObject) bclass.fromMap(map, context);\n\n        return newobject;\n    }\n\n    public String getConvertingUserNameType(XWikiContext context)\n    {\n        if (StringUtils.isNotBlank(context.getWiki().getXWikiPreference(\"convertmail\", context))) {\n            return context.getWiki().getXWikiPreference(\"convertmail\", \"0\", context);\n        }\n\n        return getConfiguration().getProperty(\"xwiki.authentication.convertemail\", \"0\");\n    }\n\n    public String convertUsername(String username, XWikiContext context)\n    {\n        if (username == null) {\n            return null;\n        }\n\n        if (getConvertingUserNameType(context).equals(\"1\") && (username.indexOf('@') != -1)) {\n            String id = \"\" + username.hashCode();\n            id = id.replace(\"-\", \"\");\n            if (username.length() > 1) {\n                int i1 = username.indexOf('@');\n                id = \"\" + username.charAt(0) + username.substring(i1 + 1, i1 + 2)\n                    + username.charAt(username.length() - 1) + id;\n            }\n\n            return id;\n        } else if (getConvertingUserNameType(context).equals(\"2\")) {\n            return username.replaceAll(\"[\\\\.\\\\@]\", \"_\");\n        } else {\n            return username;\n        }\n    }\n\n    public boolean hasSectionEdit(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.section.edit\", 0) == 1;\n    }\n\n    /**\n     * @return The maximum section depth for which section editing is available. This can be customized through the\n     *         {@code xwiki.section.depth} configuration property. Defaults to 2 when not defined.\n     */\n    public long getSectionEditingDepth()\n    {\n        return getConfiguration().getProperty(\"xwiki.section.depth\", 2L);\n    }\n\n    public String getWysiwygToolbars(XWikiContext context)\n    {\n        return getConfiguration().getProperty(\"xwiki.wysiwyg.toolbars\", \"\");\n    }\n\n    public String clearName(String name, XWikiContext context)\n    {\n        return clearName(name, true, true, context);\n    }\n\n    public String clearName(String name, boolean stripDots, boolean ascii, XWikiContext context)\n    {\n        String temp = name;\n        temp = temp.replaceAll(\n            \"[\\u00c0\\u00c1\\u00c2\\u00c3\\u00c4\\u00c5\\u0100\\u0102\\u0104\\u01cd\\u01de\\u01e0\\u01fa\\u0200\\u0202\\u0226]\", \"A\");\n        temp = temp.replaceAll(\n            \"[\\u00e0\\u00e1\\u00e2\\u00e3\\u00e4\\u00e5\\u0101\\u0103\\u0105\\u01ce\\u01df\\u01e1\\u01fb\\u0201\\u0203\\u0227]\", \"a\");\n        temp = temp.replaceAll(\"[\\u00c6\\u01e2\\u01fc]\", \"AE\");\n        temp = temp.replaceAll(\"[\\u00e6\\u01e3\\u01fd]\", \"ae\");\n        temp = temp.replaceAll(\"[\\u008c\\u0152]\", \"OE\");\n        temp = temp.replaceAll(\"[\\u009c\\u0153]\", \"oe\");\n        temp = temp.replaceAll(\"[\\u00c7\\u0106\\u0108\\u010a\\u010c]\", \"C\");\n        temp = temp.replaceAll(\"[\\u00e7\\u0107\\u0109\\u010b\\u010d]\", \"c\");\n        temp = temp.replaceAll(\"[\\u00d0\\u010e\\u0110]\", \"D\");\n        temp = temp.replaceAll(\"[\\u00f0\\u010f\\u0111]\", \"d\");\n        temp = temp.replaceAll(\"[\\u00c8\\u00c9\\u00ca\\u00cb\\u0112\\u0114\\u0116\\u0118\\u011a\\u0204\\u0206\\u0228]\", \"E\");\n        temp = temp.replaceAll(\"[\\u00e8\\u00e9\\u00ea\\u00eb\\u0113\\u0115\\u0117\\u0119\\u011b\\u01dd\\u0205\\u0207\\u0229]\", \"e\");\n        temp = temp.replaceAll(\"[\\u011c\\u011e\\u0120\\u0122\\u01e4\\u01e6\\u01f4]\", \"G\");\n        temp = temp.replaceAll(\"[\\u011d\\u011f\\u0121\\u0123\\u01e5\\u01e7\\u01f5]\", \"g\");\n        temp = temp.replaceAll(\"[\\u0124\\u0126\\u021e]\", \"H\");\n        temp = temp.replaceAll(\"[\\u0125\\u0127\\u021f]\", \"h\");\n        temp = temp.replaceAll(\"[\\u00cc\\u00cd\\u00ce\\u00cf\\u0128\\u012a\\u012c\\u012e\\u0130\\u01cf\\u0208\\u020a]\", \"I\");\n        temp = temp.replaceAll(\"[\\u00ec\\u00ed\\u00ee\\u00ef\\u0129\\u012b\\u012d\\u012f\\u0131\\u01d0\\u0209\\u020b]\", \"i\");\n        temp = temp.replaceAll(\"[\\u0132]\", \"IJ\");\n        temp = temp.replaceAll(\"[\\u0133]\", \"ij\");\n        temp = temp.replaceAll(\"[\\u0134]\", \"J\");\n        temp = temp.replaceAll(\"[\\u0135]\", \"j\");\n        temp = temp.replaceAll(\"[\\u0136\\u01e8]\", \"K\");\n        temp = temp.replaceAll(\"[\\u0137\\u0138\\u01e9]\", \"k\");\n        temp = temp.replaceAll(\"[\\u0139\\u013b\\u013d\\u013f\\u0141]\", \"L\");\n        temp = temp.replaceAll(\"[\\u013a\\u013c\\u013e\\u0140\\u0142\\u0234]\", \"l\");\n        temp = temp.replaceAll(\"[\\u00d1\\u0143\\u0145\\u0147\\u014a\\u01f8]\", \"N\");\n        temp = temp.replaceAll(\"[\\u00f1\\u0144\\u0146\\u0148\\u0149\\u014b\\u01f9\\u0235]\", \"n\");\n        temp = temp.replaceAll(\n            \"[\\u00d2\\u00d3\\u00d4\\u00d5\\u00d6\\u00d8\\u014c\\u014e\\u0150\\u01d1\\u01ea\\u01ec\\u01fe\\u020c\\u020e\\u022a\\u022c\"\n                + \"\\u022e\\u0230]\",\n            \"O\");\n        temp = temp.replaceAll(\n            \"[\\u00f2\\u00f3\\u00f4\\u00f5\\u00f6\\u00f8\\u014d\\u014f\\u0151\\u01d2\\u01eb\\u01ed\\u01ff\\u020d\\u020f\\u022b\\u022d\"\n                + \"\\u022f\\u0231]\",\n            \"o\");\n        temp = temp.replaceAll(\"[\\u0156\\u0158\\u0210\\u0212]\", \"R\");\n        temp = temp.replaceAll(\"[\\u0157\\u0159\\u0211\\u0213]\", \"r\");\n        temp = temp.replaceAll(\"[\\u015a\\u015c\\u015e\\u0160\\u0218]\", \"S\");\n        temp = temp.replaceAll(\"[\\u015b\\u015d\\u015f\\u0161\\u0219]\", \"s\");\n        temp = temp.replaceAll(\"[\\u00de\\u0162\\u0164\\u0166\\u021a]\", \"T\");\n        temp = temp.replaceAll(\"[\\u00fe\\u0163\\u0165\\u0167\\u021b\\u0236]\", \"t\");\n        temp = temp.replaceAll(\n            \"[\\u00d9\\u00da\\u00db\\u00dc\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u0214\\u0216]\",\n            \"U\");\n        temp = temp.replaceAll(\n            \"[\\u00f9\\u00fa\\u00fb\\u00fc\\u0169\\u016b\\u016d\\u016f\\u0171\\u0173\\u01d4\\u01d6\\u01d8\\u01da\\u01dc\\u0215\\u0217]\",\n            \"u\");\n        temp = temp.replaceAll(\"[\\u0174]\", \"W\");\n        temp = temp.replaceAll(\"[\\u0175]\", \"w\");\n        temp = temp.replaceAll(\"[\\u00dd\\u0176\\u0178\\u0232]\", \"Y\");\n        temp = temp.replaceAll(\"[\\u00fd\\u00ff\\u0177\\u0233]\", \"y\");\n        temp = temp.replaceAll(\"[\\u0179\\u017b\\u017d]\", \"Z\");\n        temp = temp.replaceAll(\"[\\u017a\\u017c\\u017e]\", \"z\");\n        temp = temp.replaceAll(\"[\\u00df]\", \"SS\");\n        temp = temp.replaceAll(\"[_':,;\\\\\\\\/]\", \" \");\n        name = temp;\n        name = name.replaceAll(\"\\\\s+\", \"\");\n        name = name.replaceAll(\"[\\\\(\\\\)]\", \" \");\n\n        if (stripDots) {\n            name = name.replaceAll(\"[\\\\.]\", \"\");\n        }\n\n        if (ascii) {\n            name = name.replaceAll(\"[^a-zA-Z0-9\\\\-_\\\\.]\", \"\");\n        }\n\n        if (name.length() > 250) {\n            name = name.substring(0, 250);\n        }\n\n        return name;\n\n    }\n\n    public String getUniquePageName(String space, XWikiContext context)\n    {\n        String pageName = generateRandomString(16);\n\n        return getUniquePageName(space, pageName, context);\n    }\n\n    public String getUniquePageName(String space, String name, XWikiContext context)\n    {\n        String pageName = clearName(name, context);\n        if (exists(space + \".\" + pageName, context)) {\n            int i = 0;\n            while (exists(space + \".\" + pageName + \"_\" + i, context)) {\n                i++;\n            }\n\n            return pageName + \"_\" + i;\n        }\n\n        return pageName;\n    }\n\n    public PropertyClass getPropertyClassFromName(String propPath, XWikiContext context)\n    {\n        int i1 = propPath.indexOf('_');\n        if (i1 == -1) {\n            return null;\n        } else {\n            String className = propPath.substring(0, i1);\n            String propName = propPath.substring(i1 + 1);\n            try {\n                return (PropertyClass) getDocument(className, context).getXClass().get(propName);\n            } catch (XWikiException e) {\n                return null;\n            }\n        }\n    }\n\n    public boolean validateDocument(XWikiDocument doc, XWikiContext context) throws XWikiException\n    {\n        return doc.validate(context);\n    }\n\n    public String addTooltip(String html, String message, String params, XWikiContext context)\n    {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"<span class=\\\"tooltip_span\\\" onmouseover=\\\"\");\n        buffer.append(params);\n        buffer.append(\"; return escape('\");\n        buffer.append(message.replaceAll(\"'\", \"\\\\'\"));\n        buffer.append(\"');\\\">\");\n        buffer.append(html);\n        buffer.append(\"</span>\");\n\n        return buffer.toString();\n    }\n\n    public String addTooltipJS(XWikiContext context)\n    {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"<script src=\\\"\");\n        buffer.append(getSkinFile(\"ajax/wzToolTip.js\", context));\n        buffer.append(\"\\\"></script>\");\n        // buffer.append(\"<div id=\\\"dhtmltooltip\\\"></div>\");\n\n        return buffer.toString();\n    }\n\n    public String addTooltip(String html, String message, XWikiContext context)\n    {\n        return addTooltip(html, message, \"this.WIDTH='300'\", context);\n    }\n\n    public String addMandatory(XWikiContext context)\n    {\n        String star =\n            \"<span class=\\\"mandatoryParenthesis\\\">&nbsp;(</span><span class=\\\"mandatoryDot\\\">&lowast;</span><span class=\\\"mandatoryParenthesis\\\">)&nbsp;</span>\";\n        return context.getWiki().getXWikiPreference(\"mandatory_display\", star, context);\n    }\n\n    /**\n     * @since 2.3M1\n     */\n    public boolean hasVersioning(XWikiContext context)\n    {\n        return getStoreConfiguration().isVersioningEnabled();\n    }\n\n    public boolean hasAttachmentVersioning(XWikiContext context)\n    {\n        return getStoreConfiguration().isAttachmentVersioningEnabled();\n    }\n\n    public String getExternalAttachmentURL(String fullName, String filename, XWikiContext context)\n    {\n        XWikiDocument doc = new XWikiDocument();\n        doc.setFullName(fullName, context);\n\n        return doc.getExternalAttachmentURL(filename, \"download\", context);\n    }\n\n    public int getMaxRecursiveSpaceChecks(XWikiContext context)\n    {\n        int max = getXWikiPreferenceAsInt(\"rights_maxrecursivespacechecks\", -1, context);\n        if (max == -1) {\n            return getConfiguration().getProperty(\"xwiki.rights.maxrecursivespacechecks\", 0);\n        } else {\n            return max;\n        }\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param doc the document to restore\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 5.4RC1\n     */\n    public void restoreFromRecycleBin(final XWikiDocument doc, String comment, XWikiContext context)\n        throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = getRecycleBinStore().getAllDeletedDocuments(doc, context, true);\n        if (deletedDocuments != null && deletedDocuments.length > 0) {\n            long index = deletedDocuments[0].getId();\n            restoreFromRecycleBin(doc, index, comment, context);\n        }\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param doc the document to restore\n     * @param index the index of the document in the recycle bin\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 5.4RC1\n     * @deprecated since 9.4RC1. Use {@link #restoreFromRecycleBin(long, String, XWikiContext)} instead.\n     */\n    @Deprecated\n    public void restoreFromRecycleBin(final XWikiDocument doc, long index, String comment, XWikiContext context)\n        throws XWikiException\n    {\n        restoreFromRecycleBin(index, comment, context);\n    }\n\n    /**\n     * Restore a document with passed index from recycle bin.\n     *\n     * @param index the index of the document in the recycle bin\n     * @param comment the comment to use when saving the document\n     * @param context see {@link XWikiContext}\n     * @throws XWikiException when failing to restore document\n     * @since 9.4RC1\n     */\n    public void restoreFromRecycleBin(long index, String comment, XWikiContext context) throws XWikiException\n    {\n        XWikiDocument newdoc = getRecycleBinStore().restoreFromRecycleBin(index, context, true);\n\n        ObservationManager observation = getObservationManager();\n\n        if (observation != null) {\n            observation.notify(new DocumentRestoringEvent(newdoc.getDocumentReferenceWithLocale(), index), newdoc,\n                context);\n        }\n\n        saveDocument(newdoc, comment, context);\n        getRecycleBinStore().deleteFromRecycleBin(index, context, true);\n\n        if (observation != null) {\n            observation.notify(new DocumentRestoredEvent(newdoc.getDocumentReferenceWithLocale(), index), newdoc,\n                context);\n        }        \n    }\n\n    public XWikiDocument rollback(final XWikiDocument tdoc, String rev, XWikiContext context) throws XWikiException\n    {\n        return rollback(tdoc, rev, true, context);\n    }\n\n    private void restoreDeletedAttachment(XWikiAttachment rolledbackAttachment, XWikiContext context)\n        throws XWikiException\n    {\n        // Restore deleted attachments from the trash\n        if (getAttachmentRecycleBinStore() != null) {\n            // There might be multiple versions of the attachment in the trash, search for the right one\n            List<DeletedAttachment> deletedVariants =\n                getAttachmentRecycleBinStore().getAllDeletedAttachments(rolledbackAttachment, context, true);\n\n            DeletedAttachment correctVariant = null;\n            for (DeletedAttachment variant : deletedVariants) { // Reverse chronological order\n                if (variant.getDate().before(rolledbackAttachment.getDate())) {\n                    break;\n                }\n\n                correctVariant = variant;\n            }\n\n            if (correctVariant != null) {\n                XWikiAttachment restoredAttachment = correctVariant.restoreAttachment();\n\n                boolean updateArchive = false;\n\n                if (!restoredAttachment.getVersion().equals(rolledbackAttachment.getVersion())) {\n                    XWikiAttachment restoredAttachmentRevision =\n                        restoredAttachment.getAttachmentRevision(rolledbackAttachment.getVersion(), context);\n\n                    if (restoredAttachmentRevision != null) {\n                        // Update the archive since it won't be done by the store (it's a new attachment)\n                        // TODO: Remove from the archive the versions greater than the rollbacked one instead (they\n                        // would not be lost since they would still be in the recycle bin) ?\n                        rolledbackAttachment.setVersion(restoredAttachment.getVersion());\n                        updateArchive = true;\n\n                        restoredAttachment = restoredAttachmentRevision;\n                    }\n                }\n\n                rolledbackAttachment.apply(restoredAttachment);\n\n                // Restore the deleted archive\n                rolledbackAttachment\n                    .setAttachment_archive((XWikiAttachmentArchive) restoredAttachment.getAttachment_archive().clone());\n                rolledbackAttachment.getAttachment_archive().setAttachment(rolledbackAttachment);\n\n                if (updateArchive) {\n                    rolledbackAttachment.updateContentArchive(context);\n                }\n            } else {\n                // Not found in the trash, set an empty content to avoid errors\n                try {\n                    rolledbackAttachment.setContent(new ByteArrayInputStream(new byte[0]));\n                } catch (IOException e) {\n                    // The content we pass cannot fail\n                }\n            }\n        }\n    }\n\n    /**\n     * @param tdoc the document to rollback\n     * @param rev the revision to rollback to\n     * @param addRevision true if a new revision should be created\n     * @param xcontext the XWiki context\n     * @return the new document\n     * @throws XWikiException when failing to rollback the document\n     * @since 10.7RC1\n     * @since 9.11.8\n     */\n    public XWikiDocument rollback(final XWikiDocument tdoc, String rev, boolean addRevision, XWikiContext xcontext)\n        throws XWikiException\n    {\n        LOGGER.debug(\"Rolling back [{}] to version [{}]\", tdoc, rev);\n\n        // Clone the document before modifying to avoid concurrency issues\n        XWikiDocument document = tdoc.clone();\n\n        XWikiDocument rolledbackDoc = getDocumentRevisionProvider().getRevision(tdoc, rev);\n\n        // Restore attachments\n        if (\"1\".equals(getConfiguration().getProperty(\"xwiki.store.rollbackattachmentwithdocuments\", \"1\"))) {\n            LOGGER.debug(\"Checking attachments\");\n\n            for (XWikiAttachment rolledbackAttachment : rolledbackDoc.getAttachmentList()) {\n                String filename = rolledbackAttachment.getFilename();\n                XWikiAttachment attachment = document.getAttachment(filename);\n\n                if (attachment == null) {\n                    // The attachment has been deleted, search and restore it\n                    LOGGER.debug(\"Deleted attachment: [{}]\", filename);\n\n                    // Restore content and archive from the recycle bin\n                    restoreDeletedAttachment(rolledbackAttachment, xcontext);\n                } else {\n                    XWikiAttachment attachmentRevision =\n                        attachment.getAttachmentRevision(rolledbackAttachment.getVersion(), xcontext);\n\n                    // We compare the number of milliseconds instead of the date objects directly because Hibernate can\n                    // return java.sql.Timestamp for date fields and the JavaDoc says that Timestamp.equals(Object)\n                    // doesn't return true if the passed value is a java.util.Date object with the same number of\n                    // milliseconds because the nanoseconds component of the passed date is unknown.\n                    if (attachmentRevision == null\n                        || attachmentRevision.getDate().getTime() != rolledbackAttachment.getDate().getTime()) {\n                        // Recreated attachment\n                        LOGGER.debug(\"Recreated attachment: [{}]\", filename);\n\n                        // Mark current attachment for deletion to not loose it\n                        document.removeAttachment(attachment);\n\n                        // Search and restore previously deleted one\n                        // If the attachment trash is not available, don't lose the existing attachment\n                        if (getAttachmentRecycleBinStore() != null) {\n                            // Restore in the right version\n                            restoreDeletedAttachment(rolledbackAttachment, xcontext);\n                        }\n                    } else {\n                        // Restore content and archive from the recycle bin\n                        rolledbackAttachment.apply(attachmentRevision);\n                    }\n                }\n            }\n        }\n\n        document.apply(rolledbackDoc);\n\n        // Prepare the XWikiDocument before save\n        document.setAuthorReference(xcontext.getUserReference());\n        document.setContentAuthorReference(xcontext.getUserReference());\n\n        // Make sure the history is not modified if addRevision is disabled\n        String message;\n        if (!addRevision) {\n            document.setVersion(rev);\n            document.setMetaDataDirty(false);\n            document.setContentDirty(false);\n            message = document.getComment();\n        } else {\n            // Make sure to save a new version even if nothing changed\n            document.setMetaDataDirty(true);\n            message = localizePlainOrKey(\"core.comment.rollback\", rev);\n        }\n\n        ObservationManager om = getObservationManager();\n        if (om != null) {\n            // Notify listeners about the document that is going to be rolled back.\n            // Note that for the moment the event being send is a bridge event, as we are still passing around\n            // an XWikiDocument as source and an XWikiContext as data.\n            om.notify(new DocumentRollingBackEvent(document.getDocumentReference(), rev), document, xcontext);\n        }\n\n        XWikiDocument originalDocument = document.getOriginalDocument();\n\n        saveDocument(document, message, xcontext);\n\n        // Since XWiki#saveDocument resets the original document, we need to temporarily put it back to send\n        // notifications.\n        XWikiDocument newOriginalDocument = document.getOriginalDocument();\n        document.setOriginalDocument(originalDocument);\n\n        try {\n            if (om != null) {\n                // Notify listeners about the document that was rolled back.\n                // Note that for the moment the event being send is a bridge event, as we are still passing around an\n                // XWikiDocument as source and an XWikiContext as data.\n                om.notify(new DocumentRolledBackEvent(document.getDocumentReference(), rev), document, xcontext);\n            }\n        } finally {\n            document.setOriginalDocument(newOriginalDocument);\n        }\n\n        return document;\n    }\n\n    /**\n     * @return the syntax id of the syntax to use when creating new documents\n     */\n    public String getDefaultDocumentSyntax()\n    {\n        // TODO: Fix this method to return a Syntax object instead of a String\n        return getDefaultDocumentSyntaxInternal().toIdString();\n    }\n\n    /**\n     * @return the syntax to use when creating new documents\n     */\n    private Syntax getDefaultDocumentSyntaxInternal()\n    {\n        return Utils.getComponent(CoreConfiguration.class).getDefaultDocumentSyntax();\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @param defaultSyntaxId the default value to return if no document can be found\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId(String defaultSyntaxId, XWikiContext context)\n    {\n        String syntaxId = getCurrentContentSyntaxIdInternal(context);\n\n        if (syntaxId == null) {\n            syntaxId = defaultSyntaxId;\n        }\n\n        return syntaxId;\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId(XWikiContext context)\n    {\n        String syntaxId = getCurrentContentSyntaxIdInternal(context);\n\n        if (syntaxId == null) {\n            throw new RuntimeException(\"Cannot get the current syntax since there's no current document set\");\n        }\n\n        return syntaxId;\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    private String getCurrentContentSyntaxIdInternal(XWikiContext context)\n    {\n        Syntax syntax = getCurrentContentSyntaxInternal(context);\n\n        return syntax != null ? syntax.toIdString() : null;\n    }\n\n    /**\n     * Get the syntax of the code currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax\n     */\n    private Syntax getCurrentContentSyntaxInternal(XWikiContext context)\n    {\n        Syntax syntax = null;\n\n        // Try to find the current syntax\n        if (getRenderingContext() != null) {\n            Block curentBlock = getRenderingContext().getCurrentBlock();\n\n            if (curentBlock != null) {\n                MetaDataBlock metaDataBlock =\n                    curentBlock.getFirstBlock(new MetadataBlockMatcher(MetaData.SYNTAX), Axes.ANCESTOR_OR_SELF);\n\n                if (metaDataBlock != null) {\n                    return (Syntax) metaDataBlock.getMetaData().getMetaData(MetaData.SYNTAX);\n                }\n            }\n        }\n\n        // Fallback on secure and current document in the context\n        if (context.get(\"sdoc\") != null) {\n            // The content document\n            syntax = ((XWikiDocument) context.get(\"sdoc\")).getSyntax();\n        } else if (context.getDoc() != null) {\n            // The context document\n            syntax = context.getDoc().getSyntax();\n        }\n\n        return syntax;\n    }\n\n    /**\n     * @return true if title handling should be using the compatibility mode or not. When the compatibility mode is\n     *         active, if the document's content first header (level 1 or level 2) matches the document's title the\n     *         first header is stripped.\n     */\n    public boolean isTitleInCompatibilityMode()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.title.compatibility\", \"0\"));\n    }\n\n    @Override\n    public void onEvent(Event event, Object source, Object data)\n    {\n        if (event instanceof JobFinishedEvent) {\n            // An extension just been initialized (after an install or upgrade for example)\n            onJobFinished((JobFinishedEvent) event);\n        } else if (event instanceof WikiDeletedEvent) {\n            // A wiki has been deleted\n            onWikiDeletedEvent((WikiDeletedEvent) event);\n        } else if (event instanceof ComponentDescriptorAddedEvent) {\n            // A new mandatory document initializer has been installed\n            onMandatoryDocumentInitializerAdded((ComponentDescriptorAddedEvent) event, (ComponentManager) source);\n        } else {\n            // Document modifications\n\n            XWikiDocument doc = (XWikiDocument) source;\n\n            if (event instanceof XObjectPropertyEvent) {\n                EntityReference reference = ((XObjectPropertyEvent) event).getReference();\n                String modifiedProperty = reference.getName();\n                if (\"backlinks\".equals(modifiedProperty)) {\n                    this.hasBacklinks = doc.getXObject((ObjectReference) reference.getParent()).getIntValue(\"backlinks\",\n                        getConfiguration().getProperty(\"xwiki.backlinks\", 0)) == 1;\n                }\n            }\n        }\n    }\n\n    private void onJobFinished(JobFinishedEvent event)\n    {\n        // Skip it if:\n        // * the authenticator was not yet initialized\n        // * we are using the standard authenticator\n        // * the event is not related to an install or uninstall job\n        if (this.authService == null || this.authService.getClass() == XWikiAuthServiceImpl.class\n            || (!event.getJobType().equals(InstallJob.JOBTYPE) && !event.getJobType().equals(UninstallJob.JOBTYPE))) {\n            return;\n        }\n\n        try {\n            // Get the class corresponding to the configuration\n            Class<? extends XWikiAuthService> authClass = getAuthServiceClass();\n\n            // If the class does not have the same reference anymore it means it's coming from a different classloader\n            // which generally imply that it's coming from an extension which has been reloaded or upgraded\n            // Both still need to have the same class name as otherwise it means the current class did not had anything\n            // to with with the standard configuration (some authenticators register themself)\n            if (this.authService.getClass() != authClass\n                && this.authService.getClass().getName().equals(authClass.getName())) {\n                setAuthService(authClass);\n            }\n        } catch (ClassNotFoundException e) {\n            LOGGER.warn(\"Failed to get the class of the configured authenticator ({}), keeping current authenticator.\",\n                ExceptionUtils.getRootCauseMessage(e));\n        }\n    }\n\n    private void onWikiDeletedEvent(WikiDeletedEvent event)\n    {\n        this.initializedWikis.remove(event.getWikiId());\n    }\n\n    private void onMandatoryDocumentInitializerAdded(ComponentDescriptorAddedEvent event,\n        ComponentManager componentManager)\n    {\n        String namespace;\n        if (componentManager instanceof NamespacedComponentManager) {\n            namespace = ((NamespacedComponentManager) componentManager).getNamespace();\n        } else {\n            namespace = null;\n        }\n\n        MandatoryDocumentInitializer initializer;\n        try {\n            initializer = componentManager.getInstance(MandatoryDocumentInitializer.class, event.getRoleHint());\n\n            XWikiContext context = getXWikiContext();\n            if (namespace == null) {\n                // Initialize in main wiki\n                initializeMandatoryDocument(context.getMainXWiki(), initializer, context);\n                // Initialize in already initialized sub wikis (will be initialized in others when they are initialized)\n                for (String wiki : this.initializedWikis.keySet()) {\n                    initializeMandatoryDocument(wiki, initializer, context);\n                }\n            } else if (namespace.startsWith(\"wiki:\")) {\n                // Initialize in the wiki where the extension is installed\n                initializeMandatoryDocument(namespace.substring(\"wiki:\".length()), initializer, context);\n            }\n        } catch (ComponentLookupException e) {\n            LOGGER.error(\"Failed to lookup mandatory document initializer\", e);\n        }\n    }\n\n    /**\n     * The reference to match properties \"plugins\" and \"backlinks\" of class XWiki.XWikiPreference on whatever wiki.\n     */\n    private static final RegexEntityReference XWIKIPREFERENCE_PROPERTY_REFERENCE =\n        XWikiPreferencesDocumentInitializer.OBJECT_REFERENCE;\n\n    private static final List<Event> LISTENER_EVENTS =\n        Arrays.<Event>asList(new XObjectPropertyAddedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE),\n            new XObjectPropertyDeletedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE),\n            new XObjectPropertyUpdatedEvent(XWIKIPREFERENCE_PROPERTY_REFERENCE), new WikiDeletedEvent(),\n            new ComponentDescriptorAddedEvent(MandatoryDocumentInitializer.class), new JobFinishedEvent());\n\n    @Override\n    public List<Event> getEvents()\n    {\n        return LISTENER_EVENTS;\n    }\n\n    @Override\n    public String getName()\n    {\n        return \"xwiki-core\";\n    }\n\n    /**\n     * Return the document reference to the wiki preferences.\n     *\n     * @param context see {@link XWikiContext}\n     * @since 4.3M2\n     */\n    private DocumentReference getPreferencesDocumentReference(XWikiContext context)\n    {\n        String database = context.getWikiId();\n        EntityReference spaceReference;\n        if (database != null) {\n            spaceReference = new EntityReference(SYSTEM_SPACE, EntityType.SPACE, new WikiReference(database));\n        } else {\n            spaceReference = getCurrentMixedEntityReferenceResolver().resolve(SYSTEM_SPACE, EntityType.SPACE);\n        }\n        return new DocumentReference(\"XWikiPreferences\", new SpaceReference(spaceReference));\n    }\n\n    /**\n     * Search attachments by passing HQL where clause values as parameters. You can specify properties of the \"attach\"\n     * (the attachment) or \"doc\" (the document it is attached to)\n     *\n     * @param parametrizedSqlClause The HQL where clause. For example {@code where doc.fullName\n     *        <> ?1 and (attach.author = ?2 or (attach.filename = ?3 and doc.space = ?4))}\n     * @param checkRight if true, only return attachments in documents which the \"current user\" has permission to view.\n     * @param nb The number of rows to return. If 0 then all rows are returned\n     * @param start The number of rows to skip at the beginning.\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @param context see {@link XWikiContext}\n     * @return A List of {@link XWikiAttachment} objects.\n     * @throws XWikiException in case of error while performing the query\n     * @see com.xpn.xwiki.store.XWikiStoreInterface#searchDocuments(String, int, int, java.util.List, XWikiContext)\n     * @since 5.0M2\n     * @deprecated since 9.7RC1, use the QueryManager instead along with the \"attachment\" query filter\n     */\n    @Deprecated\n    public List<XWikiAttachment> searchAttachments(String parametrizedSqlClause, boolean checkRight, int nb, int start,\n        List<?> parameterValues, XWikiContext context) throws XWikiException\n    {\n        parametrizedSqlClause = parametrizedSqlClause.trim().replaceFirst(\"^and \", \"\").replaceFirst(\"^where \", \"\");\n\n        // Get the attachment filenames and document fullNames\n        List<java.lang.Object[]> results = this.getStore().search(\n            \"select attach.filename, doc.fullName from XWikiAttachment attach, XWikiDocument doc where doc.id = attach.docId and \"\n                + parametrizedSqlClause,\n            nb, start, parameterValues, context);\n\n        HashMap<String, List<String>> filenamesByDocFullName = new HashMap<>();\n\n        // Put each attachment name with the document name it belongs to\n        for (int i = 0; i < results.size(); i++) {\n            String filename = (String) results.get(i)[0];\n            String docFullName = (String) results.get(i)[1];\n            if (!filenamesByDocFullName.containsKey(docFullName)) {\n                filenamesByDocFullName.put(docFullName, new ArrayList<String>());\n            }\n            filenamesByDocFullName.get(docFullName).add(filename);\n        }\n\n        List<XWikiAttachment> out = new ArrayList<>();\n\n        // Index through the document names, get relivent attachments\n        for (Map.Entry<String, List<String>> entry : filenamesByDocFullName.entrySet()) {\n            String fullName = entry.getKey();\n\n            XWikiDocument doc = getDocument(fullName, context);\n            if (checkRight) {\n                if (!context.getWiki().getRightService().hasAccessLevel(\"view\", context.getUser(), doc.getFullName(),\n                    context)) {\n                    continue;\n                }\n            }\n            List<String> returnedAttachmentNames = entry.getValue();\n            for (XWikiAttachment attach : doc.getAttachmentList()) {\n                if (returnedAttachmentNames.contains(attach.getFilename())) {\n                    out.add(attach);\n                }\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Count attachments returned by a given parameterized query\n     *\n     * @param parametrizedSqlClause Everything which would follow the \"WHERE\" in HQL\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @param context see {@link XWikiContext}\n     * @return int number of attachments found.\n     * @throws XWikiException in event of an exception querying the database\n     * @see #searchAttachments(String, boolean, int, int, java.util.List, XWikiContext)\n     * @since 5.0M2\n     */\n    public int countAttachments(String parametrizedSqlClause, List<?> parameterValues, XWikiContext context)\n        throws XWikiException\n    {\n        parametrizedSqlClause = parametrizedSqlClause.trim().replaceFirst(\"^and \", \"\").replaceFirst(\"^where \", \"\");\n\n        List l = getStore().search(\"select count(attach) from XWikiAttachment attach, XWikiDocument doc where \"\n            + \"attach.docId=doc.id and \" + parametrizedSqlClause, 0, 0, parameterValues, context);\n        return ((Number) l.get(0)).intValue();\n    }\n\n    // Deprecated\n\n    /**\n     * @deprecated since 6.1M2, use {@link XWikiCfgConfigurationSource#getConfigPath()} instead\n     */\n    @Deprecated\n    public static String getConfigPath() throws NamingException\n    {\n        return XWikiCfgConfigurationSource.getConfigPath();\n    }\n\n    /**\n     * @deprecated since 6.1M3, use {@link #XWiki(XWikiContext)} instead\n     */\n    @Deprecated\n    public XWiki(XWikiConfig config, XWikiContext context) throws XWikiException\n    {\n        this(config, context, null, false);\n    }\n\n    /**\n     * @deprecated since 6.1M3, use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(XWikiConfig config, XWikiContext context, XWikiEngineContext engine_context, boolean noupdate)\n        throws XWikiException\n    {\n        initXWiki(config, context, engine_context, noupdate);\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext)} instead\n     */\n    @Deprecated\n    public XWiki(String xwikicfgpath, XWikiContext context) throws XWikiException\n    {\n        this(xwikicfgpath, context, null, false);\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(String xwikicfgpath, XWikiContext context, XWikiEngineContext engine_context, boolean noupdate)\n        throws XWikiException\n    {\n        try {\n            initXWiki(new XWikiConfig(new FileInputStream(xwikicfgpath)), context, engine_context, noupdate);\n        } catch (FileNotFoundException e) {\n            Object[] args = { xwikicfgpath };\n            throw new XWikiException(XWikiException.MODULE_XWIKI_CONFIG, XWikiException.ERROR_XWIKI_CONFIG_FILENOTFOUND,\n                \"Configuration file {0} not found\", e, args);\n        }\n    }\n\n    /**\n     * @deprecated use {@link #XWiki(XWikiContext, XWikiEngineContext, boolean)} instead\n     */\n    @Deprecated\n    public XWiki(InputStream is, XWikiContext context, XWikiEngineContext engine_context) throws XWikiException\n    {\n        initXWiki(new XWikiConfig(is), context, engine_context, true);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public XWikiConfig getConfig()\n    {\n        return new XWikiConfigDelegate(getConfiguration());\n    }\n\n    /**\n     * @deprecated since 6.1M2\n     */\n    @Deprecated\n    public void setConfig(XWikiConfig config)\n    {\n        ConfigurationSource configuration = getConfiguration();\n\n        if (configuration instanceof XWikiCfgConfigurationSource) {\n            ((XWikiCfgConfigurationSource) configuration).set(config);\n        }\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public String Param(String key)\n    {\n        return Param(key, null);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public String Param(String key, String default_value)\n    {\n        if (getConfiguration() != null) {\n            return getConfiguration().getProperty(key, default_value);\n        }\n\n        return default_value;\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public long ParamAsLong(String key)\n    {\n        return getConfiguration().getProperty(key, long.class);\n    }\n\n    /**\n     * @deprecated since 6.1M2, use {@link ConfigurationSource} component with hint <code>xwikicfg</code> instead\n     */\n    @Deprecated\n    public long ParamAsLong(String key, long default_value)\n    {\n        return getConfiguration().getProperty(key, default_value);\n    }\n\n    /**\n     * @return true if the wiki is in path based mode, fale otherwise\n     * @since 11.9RC1\n     */\n    public boolean isPathBased()\n    {\n        return \"1\".equals(getConfiguration().getProperty(\"xwiki.virtual.usepath\", \"1\"));\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport javax.inject.Provider;\n\nimport org.apache.commons.collections4.map.LRUMap;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.util.DefaultParameterizedType;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.localization.LocaleUtils;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.stability.Unstable;\nimport org.xwiki.velocity.VelocityManager;\nimport org.xwiki.velocity.internal.VelocityExecutionContextInitializer;\n\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.classes.BaseClass;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.util.Util;\nimport com.xpn.xwiki.validation.XWikiValidationStatus;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiEngineContext;\nimport com.xpn.xwiki.web.XWikiForm;\nimport com.xpn.xwiki.web.XWikiMessageTool;\nimport com.xpn.xwiki.web.XWikiRequest;\nimport com.xpn.xwiki.web.XWikiResponse;\nimport com.xpn.xwiki.web.XWikiURLFactory;\n\n/**\n * Represents the execution environment for all the wiki pages. An instance of the <code>Context</code> class is\n * available as a predefined variable for scripting inside any wiki page. You can access it using <code>$xcontext</code>\n * in Velocity scripts or simply <code>xcontext</code> in Groovy ones. The <code>Context</code> class provides a means\n * of getting contextual information about the current request or configuring XWiki on the fly.\n *\n * @version $Id$\n */\npublic class XWikiContext extends Hashtable<Object, Object>\n{\n    /**\n     * Type instance for {@code Provider<XWikiContext>}.\n     *\n     * @since 5.0M1\n     */\n    public static final ParameterizedType TYPE_PROVIDER =\n        new DefaultParameterizedType(null, Provider.class, XWikiContext.class);\n\n    public static final int MODE_SERVLET = 0;\n\n    public static final int MODE_PORTLET = 1;\n\n    public static final int MODE_XMLRPC = 2;\n\n    public static final int MODE_ATOM = 3;\n\n    public static final int MODE_PDF = 4;\n\n    public static final int MODE_GWT = 5;\n\n    public static final int MODE_GWT_DEBUG = 6;\n\n    public static final String EXECUTIONCONTEXT_KEY = \"xwikicontext\";\n\n    /**\n     * @deprecated use {@link VelocityManager#getVelocityContext()} instead\n     */\n    @Deprecated\n    public static final String KEY_LEGACY_VELOCITYCONTEXT = \"vcontext\";\n\n    /**\n     * The reference of a logged-in inactive user: in such case the context user reference is guest, so we store\n     * the actual logged-in user with that key.\n     *\n     * @since 14.3RC1\n     * @since 13.10.5\n     */\n    @Unstable\n    public static final String INACTIVE_USER_REFERENCE = \"inactiveUserReference\";\n\n    /** Logging helper object. */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(XWikiContext.class);\n\n    private static final String WIKI_KEY = \"wiki\";\n\n    private static final String ORIGINAL_WIKI_KEY = \"originalWiki\";\n\n    private static final String USER_KEY = \"user\";\n\n    private static final String USERREFERENCE_KEY = \"userreference\";\n\n    /**\n     * Used to resolve a string into a proper Document Reference using the current document's reference to fill the\n     * blanks, except for the page name for which the default page name is used instead and for the wiki name for which\n     * the current wiki is used instead of the current document reference's wiki.\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    /**\n     * Used to convert a proper Document Reference to a string but without the wiki name.\n     */\n    private EntityReferenceSerializer<String> localEntityReferenceSerializer;\n\n    /**\n     * Used to convert a Document Reference to string (compact form without the wiki part if it matches the current\n     * wiki).\n     */\n    private EntityReferenceSerializer<String> compactWikiEntityReferenceSerializer;\n\n    /** The Execution so that we can check if permissions were dropped there. */\n    private Execution execution;\n\n    private boolean finished = false;\n\n    private boolean responseSent = false;\n\n    private XWiki wiki;\n\n    private XWikiEngineContext engine_context;\n\n    private XWikiRequest request;\n\n    private XWikiResponse response;\n\n    private XWikiForm form;\n\n    private String action;\n\n    private String orig_wikiId;\n\n    private WikiReference wikiReference;\n\n    private DocumentReference userReference;\n\n    private Locale locale;\n\n    private static final String LANGUAGE_KEY = \"language\";\n\n    private Locale interfaceLocale;\n\n    private int mode;\n\n    private URL url;\n\n    private XWikiURLFactory URLFactory;\n\n    private int cacheDuration = 0;\n\n    private int classCacheSize = 20;\n\n    // Used to avoid recursive loading of documents if there are recursives usage of classes\n    // FIXME: why synchronized since a context is supposed to be tied to a thread ?\n    @SuppressWarnings(\"unchecked\")\n    private Map<DocumentReference, BaseClass> classCache = Collections.synchronizedMap(new LRUMap(this.classCacheSize));\n\n    // FIXME: why synchronized since a context is supposed to be tied to a thread ?\n    private List<String> displayedFields = Collections.synchronizedList(new ArrayList<String>());\n\n    public XWikiContext()\n    {\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getLocalEntityReferenceSerializer()\n    {\n        if (this.localEntityReferenceSerializer == null) {\n            this.localEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n\n        return this.localEntityReferenceSerializer;\n    }\n\n    private EntityReferenceSerializer<String> getCompactWikiEntityReferenceSerializer()\n    {\n        if (this.compactWikiEntityReferenceSerializer == null) {\n            this.compactWikiEntityReferenceSerializer =\n                Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"compactwiki\");\n        }\n\n        return this.compactWikiEntityReferenceSerializer;\n    }\n\n    private Execution getExecution()\n    {\n        if (this.execution == null) {\n            this.execution = Utils.getComponent(Execution.class);\n        }\n\n        return this.execution;\n    }\n\n    private ExecutionContext getExecutionContext()\n    {\n        if (getExecution() != null) {\n            return getExecution().getContext();\n        }\n\n        return null;\n    }\n\n    public XWiki getWiki()\n    {\n        return this.wiki;\n    }\n\n    public Util getUtil()\n    {\n        Util util = (Util) this.get(\"util\");\n        if (util == null) {\n            util = new Util();\n            this.put(\"util\", util);\n        }\n\n        return util;\n    }\n\n    public void setWiki(XWiki wiki)\n    {\n        this.wiki = wiki;\n    }\n\n    public XWikiEngineContext getEngineContext()\n    {\n        return this.engine_context;\n    }\n\n    public void setEngineContext(XWikiEngineContext engine_context)\n    {\n        this.engine_context = engine_context;\n    }\n\n    public XWikiRequest getRequest()\n    {\n        return this.request;\n    }\n\n    public void setRequest(XWikiRequest request)\n    {\n        this.request = request;\n    }\n\n    public String getAction()\n    {\n        return this.action;\n    }\n\n    public void setAction(String action)\n    {\n        this.action = action;\n    }\n\n    public XWikiResponse getResponse()\n    {\n        return this.response;\n    }\n\n    public void setResponse(XWikiResponse response)\n    {\n        this.response = response;\n    }\n\n    /**\n     * @deprecated since 6.1M1, use {@link #getWikiId()} instead\n     */\n    @Deprecated\n    public String getDatabase()\n    {\n        return getWikiId();\n    }\n\n    /**\n     * @return the id of the current wiki, or null if none is set\n     * @since 6.1M1\n     */\n    public String getWikiId()\n    {\n        return this.wikiReference != null ? this.wikiReference.getName() : null;\n    }\n\n    /**\n     * @return the reference of the current wiki or null if none is set\n     * @since 7.2M1\n     */\n    public WikiReference getWikiReference()\n    {\n        return this.wikiReference;\n    }\n\n    /**\n     * @param wikiId the current wiki id\n     * @deprecated since 6.1M1, use {@link #setWikiId(String)} instead\n     */\n    @Deprecated\n    public void setDatabase(String wikiId)\n    {\n        setWikiId(wikiId);\n    }\n\n    /**\n     * @param wikiId the current wiki id\n     * @since 6.1M1\n     */\n    public void setWikiId(String wikiId)\n    {\n        setWikiReference(wikiId != null ? new WikiReference(wikiId) : null);\n    }\n\n    /**\n     * @param wikiReference the current wiki reference\n     * @since 7.2M1\n     */\n    public void setWikiReference(WikiReference wikiReference)\n    {\n        this.wikiReference = wikiReference;\n\n        if (this.wikiReference == null) {\n            super.remove(WIKI_KEY);\n        } else {\n            super.put(WIKI_KEY, this.wikiReference.getName());\n\n            if (this.orig_wikiId == null) {\n                this.orig_wikiId = this.wikiReference.getName();\n                super.put(ORIGINAL_WIKI_KEY, this.wikiReference.getName());\n            }\n        }\n    }\n\n    @Override\n    public synchronized Object get(Object key)\n    {\n        Object value;\n\n        if (WIKI_KEY.equals(key)) {\n            value = getWikiId();\n        } else if (KEY_LEGACY_VELOCITYCONTEXT.equals(key)) {\n            ExecutionContext executionContext = getExecutionContext();\n            if (executionContext != null) {\n                value = executionContext.getProperty(VelocityExecutionContextInitializer.VELOCITY_CONTEXT_ID);\n            } else {\n                value = null;\n            }\n        } else {\n            value = super.get(key);\n        }\n\n        return value;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Make sure to keep wiki field and map synchronized.\n     * </p>\n     *\n     * @see java.util.Hashtable#put(java.lang.Object, java.lang.Object)\n     */\n    @Override\n    public synchronized Object put(Object key, Object value)\n    {\n        Object previous;\n\n        if (WIKI_KEY.equals(key)) {\n            previous = get(WIKI_KEY);\n            setWikiId((String) value);\n        } else if (KEY_LEGACY_VELOCITYCONTEXT.equals(key)) {\n            ExecutionContext executionContext = getExecutionContext();\n            if (executionContext != null) {\n                previous = executionContext.getProperty(VelocityExecutionContextInitializer.VELOCITY_CONTEXT_ID);\n                executionContext.setProperty(VelocityExecutionContextInitializer.VELOCITY_CONTEXT_ID, value);\n            } else {\n                previous = null;\n            }\n        } else {\n            if (value != null) {\n                previous = super.put(key, value);\n            } else {\n                previous = super.remove(key);\n            }\n        }\n\n        return previous;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * Make sure to keep wiki field and map synchronized.\n     * </p>\n     *\n     * @see java.util.Hashtable#remove(java.lang.Object)\n     */\n    @Override\n    public synchronized Object remove(Object key)\n    {\n        Object previous;\n\n        if (WIKI_KEY.equals(key)) {\n            previous = get(WIKI_KEY);\n            setWikiId(null);\n        } else if (KEY_LEGACY_VELOCITYCONTEXT.equals(key)) {\n            ExecutionContext executionContext = getExecutionContext();\n            if (executionContext != null) {\n                previous = executionContext.getProperty(VelocityExecutionContextInitializer.VELOCITY_CONTEXT_ID);\n                executionContext.removeProperty(VelocityExecutionContextInitializer.VELOCITY_CONTEXT_ID);\n            } else {\n                previous = null;\n            }\n        } else {\n            previous = super.remove(key);\n        }\n\n        return previous;\n    }\n\n    /**\n     * Get the \"original\" wiki id. This will be the wiki id for the wiki which the user requested. If the wiki is\n     * switched to load some piece of data, this will remember what it should be switched back to.\n     *\n     * @return the wiki id originally requested by the user.\n     * @deprecated since 6.1M1, use {@link #getOriginalWikiId()} instead\n     */\n    @Deprecated\n    public String getOriginalDatabase()\n    {\n        return getOriginalWikiId();\n    }\n\n    /**\n     * Get the \"original\" wiki id. This will be the wiki id for the wiki which the user requested. If the wiki is\n     * switched to load some piece of data, this will remember what it should be switched back to.\n     *\n     * @return the wiki id originally requested by the user.\n     * @since 6.1M1\n     */\n    public String getOriginalWikiId()\n    {\n        return this.orig_wikiId;\n    }\n\n    /**\n     * @deprecated since 6.1M1, use {@link #setOriginalWikiId(String)} instead\n     */\n    @Deprecated\n    public void setOriginalDatabase(String wikiId)\n    {\n        setOriginalWikiId(wikiId);\n    }\n\n    /**\n     * Set the \"original\" wiki id. This will be the wiki id for the wiki which the user requested. If the wiki is\n     * switched to load some piece of data, this will remember what it should be switched back to.\n     *\n     * @param wikiId the wiki id originally requested by the user\n     * @since 6.1M1\n     */\n    public void setOriginalWikiId(String wikiId)\n    {\n        this.orig_wikiId = wikiId;\n        if (wikiId == null) {\n            remove(ORIGINAL_WIKI_KEY);\n        } else {\n            put(ORIGINAL_WIKI_KEY, wikiId);\n        }\n    }\n\n    /**\n     * @return true it's main wiki's context, false otherwise.\n     */\n    public boolean isMainWiki()\n    {\n        return isMainWiki(getWikiId());\n    }\n\n    /**\n     * @param wikiName the name of the wiki.\n     * @return true it's main wiki's context, false otherwise.\n     */\n    public boolean isMainWiki(String wikiName)\n    {\n        return StringUtils.equalsIgnoreCase(wikiName, getMainXWiki());\n    }\n\n    /**\n     * @return the current document handled in the context or {@code null}.\n     */\n    public XWikiDocument getDoc()\n    {\n        return (XWikiDocument) get(\"doc\");\n    }\n\n    public void setDoc(XWikiDocument doc)\n    {\n        if (doc == null) {\n            remove(\"doc\");\n        } else {\n            put(\"doc\", doc);\n        }\n    }\n\n    public DocumentReference getUserReference()\n    {\n        return this.userReference;\n    }\n\n    public void setUserReference(DocumentReference userReference)\n    {\n        if (userReference == null) {\n            this.userReference = null;\n            remove(USER_KEY);\n            remove(USERREFERENCE_KEY);\n        } else {\n            this.userReference = userReference;\n            boolean ismain = isMainWiki(this.userReference.getWikiReference().getName());\n            put(USER_KEY, new XWikiUser(getUser(), ismain));\n            put(USERREFERENCE_KEY, this.userReference);\n\n            // Log this since it's probably a mistake so that we find who is doing bad things\n            if (this.userReference.getName().equals(XWikiRightService.GUEST_USER)) {\n                LOGGER.warn(\"A reference to XWikiGuest user has been set instead of null. This is probably a mistake.\",\n                    new Exception(\"See stack trace\"));\n            }\n        }\n\n    }\n\n    private void setUserInternal(String user, boolean main)\n    {\n        if (user == null) {\n            setUserReference(null);\n        } else if (user.endsWith(XWikiRightService.GUEST_USER_FULLNAME) || user.equals(XWikiRightService.GUEST_USER)) {\n            setUserReference(null);\n            // retro-compatibilty hack: some code does not give the same meaning to null XWikiUser and XWikiUser\n            // containing guest user\n            put(USER_KEY, new XWikiUser(user, main));\n        } else {\n            setUserReference(resolveUserReference(user));\n        }\n    }\n\n    /**\n     * Make sure to use \"XWiki\" as default space when it's not provided in user name.\n     */\n    private DocumentReference resolveUserReference(String user)\n    {\n        return getCurrentMixedDocumentReferenceResolver().resolve(user,\n            new SpaceReference(\"XWiki\", new WikiReference(getWikiId() == null ? \"xwiki\" : getWikiId())));\n    }\n\n    /**\n     * @deprecated since 3.1M1 use {@link #setUserReference(DocumentReference)} instead\n     */\n    @Deprecated\n    public void setUser(String user)\n    {\n        setUserInternal(user, false);\n    }\n\n    /**\n     * @deprecated since 3.1M1 use {@link #getUserReference()} instead\n     */\n    @Deprecated\n    public String getUser()\n    {\n        if (this.userReference != null) {\n            if (getWikiId() == null) {\n                return getLocalEntityReferenceSerializer().serialize(this.userReference);\n            } else {\n                return getCompactWikiEntityReferenceSerializer().serialize(this.userReference,\n                    new WikiReference(getWikiId()));\n            }\n        } else {\n            return XWikiRightService.GUEST_USER_FULLNAME;\n        }\n    }\n\n    /**\n     * @deprecated since 3.1M1 use {@link #getUserReference()} instead\n     */\n    @Deprecated\n    public String getLocalUser()\n    {\n        if (this.userReference != null) {\n            return getLocalEntityReferenceSerializer().serialize(this.userReference);\n        } else {\n            return XWikiRightService.GUEST_USER_FULLNAME;\n        }\n    }\n\n    /**\n     * @deprecated since 3.1M1 use {@link #getUserReference()} instead\n     */\n    @Deprecated\n    public XWikiUser getXWikiUser()\n    {\n        if (this.userReference != null) {\n            boolean ismain = isMainWiki(this.userReference.getWikiReference().getName());\n            return new XWikiUser(getUser(), ismain);\n        }\n\n        return (XWikiUser) get(USER_KEY);\n    }\n\n    /**\n     * @deprecated since 4.3M1 use {@link #getLocale()} instead\n     */\n    @Deprecated\n    public String getLanguage()\n    {\n        return this.locale != null ? this.locale.toString() : null;\n    }\n\n    /**\n     * @deprecated since 4.3M1 use {@link #setLocale(Locale)} instead\n     */\n    @Deprecated\n    public void setLanguage(String language)\n    {\n        setLocale(LocaleUtils.toLocale(Util.normalizeLanguage(language)));\n\n    }\n\n    /**\n     * @return the current locale\n     * @since 4.3M1\n     */\n    public Locale getLocale()\n    {\n        return this.locale;\n    }\n\n    /**\n     * @param locale the current locale\n     * @since 4.3M1\n     */\n    public void setLocale(Locale locale)\n    {\n        this.locale = locale;\n\n        if (locale == null) {\n            remove(LANGUAGE_KEY);\n        } else {\n            put(LANGUAGE_KEY, locale.toString());\n        }\n    }\n\n    /**\n     * @deprecated since 6.0M1, use {@link #getInterfaceLocale()} instead\n     */\n    @Deprecated\n    public String getInterfaceLanguage()\n    {\n        return this.interfaceLocale != null ? this.interfaceLocale.toString() : null;\n    }\n\n    /**\n     * @return the {@link Locale} to use to display the user interface\n     * @since 6.0M1\n     */\n    public Locale getInterfaceLocale()\n    {\n        return this.interfaceLocale;\n    }\n\n    /**\n     * @param interfaceLocale the {@link Locale} to use to display the content\n     * @since 6.0M1\n     */\n    public void setInterfaceLocale(Locale interfaceLocale)\n    {\n        this.interfaceLocale = interfaceLocale;\n    }\n\n    public int getMode()\n    {\n        return this.mode;\n    }\n\n    public void setMode(int mode)\n    {\n        this.mode = mode;\n    }\n\n    public URL getURL()\n    {\n        return this.url;\n    }\n\n    public void setURL(URL url)\n    {\n        this.url = url;\n    }\n\n    public XWikiURLFactory getURLFactory()\n    {\n        return this.URLFactory;\n    }\n\n    public void setURLFactory(XWikiURLFactory URLFactory)\n    {\n        this.URLFactory = URLFactory;\n    }\n\n    public XWikiForm getForm()\n    {\n        return this.form;\n    }\n\n    public void setForm(XWikiForm form)\n    {\n        this.form = form;\n    }\n\n    /**\n     * Define if a response has been already sent or not.\n     * Note that contrary to {@link #isResponseSent()} this method will ensure that the template is executed even if the\n     * result of the execution is not sent. See {@link Utils#parseTemplate(String, boolean, XWikiContext)} for details.\n     * @return {@code true} if the response has been sent and no new reponse should be sent anymore.\n     */\n    public boolean isFinished()\n    {\n        return this.finished;\n    }\n\n    /**\n     * See {@link #isFinished()}.\n     * @param finished Set to {@code true} if the response has been sent.\n     */\n    public void setFinished(boolean finished)\n    {\n        this.finished = finished;\n    }\n\n    /**\n     * Define if a response has been already sent or not and if the template parsing should be done.\n     * Note that contrary to {@link #isFinished()} this method will always prevent the execution of the template.\n     * See {@link Utils#parseTemplate(String, boolean, XWikiContext)} for details.\n     * @return {@code true} if the response has been sent, no new reponse should be sent anymore\n     *          and the template should not be parsed.\n     * @since 13.3RC1\n     */\n    @Unstable\n    public boolean isResponseSent()\n    {\n        return this.responseSent;\n    }\n\n    /**\n     * See {@link #isResponseSent()}.\n     * @param responseSent Set to {@code true} if the response has been sent and the template should not be executed.\n     */\n    public void setResponseSent(boolean responseSent)\n    {\n        this.responseSent = responseSent;\n    }\n\n    public XWikiDocument getWikiServer()\n    {\n        String currentWiki = getWikiId();\n        try {\n            setWikiId(getMainXWiki());\n\n            return getWiki().getDocument(XWiki.getServerWikiPage(currentWiki), this);\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to get wiki descriptor for wiki [{}]\", currentWiki, e);\n        } finally {\n            setWikiId(currentWiki);\n        }\n\n        return null;\n    }\n\n    public int getCacheDuration()\n    {\n        return this.cacheDuration;\n    }\n\n    public void setCacheDuration(int cacheDuration)\n    {\n        this.cacheDuration = cacheDuration;\n    }\n\n    public String getMainXWiki()\n    {\n        return (String) get(\"mainxwiki\");\n    }\n\n    public void setMainXWiki(String str)\n    {\n        put(\"mainxwiki\", str);\n    }\n\n    // Used to avoid recursive loading of documents if there are recursives usage of classes\n    public void addBaseClass(BaseClass bclass)\n    {\n        this.classCache.put(bclass.getDocumentReference(), bclass);\n    }\n\n    /**\n     * @since 2.2M2\n     */\n    // Used to avoid recursive loading of documents if there are recursives usage of classes\n    public BaseClass getBaseClass(DocumentReference classReference)\n    {\n        return this.classCache.get(classReference);\n    }\n\n    /**\n     * @param classReference the reference of the class\n     * @since 9.0RC1\n     */\n    public void removeBaseClass(DocumentReference classReference)\n    {\n        this.classCache.remove(classReference);\n    }\n\n    /**\n     * Empty the class cache.\n     */\n    public void flushClassCache()\n    {\n        this.classCache.clear();\n    }\n\n    public void setLinksAction(String action)\n    {\n        put(\"links_action\", action);\n    }\n\n    public void unsetLinksAction()\n    {\n        remove(\"links_action\");\n    }\n\n    public String getLinksAction()\n    {\n        return (String) get(\"links_action\");\n    }\n\n    public void setLinksQueryString(String value)\n    {\n        put(\"links_qs\", value);\n    }\n\n    public void unsetLinksQueryString()\n    {\n        remove(\"links_qs\");\n    }\n\n    public String getLinksQueryString()\n    {\n        return (String) get(\"links_qs\");\n    }\n\n    /**\n     * @deprecated since 4.3M2 use {@link org.xwiki.localization.ContextualLocalizationManager} component instead\n     */\n    @Deprecated\n    public XWikiMessageTool getMessageTool()\n    {\n        XWikiMessageTool msg = ((XWikiMessageTool) get(\"msg\"));\n        if (msg == null) {\n            getWiki().prepareResources(this);\n            msg = ((XWikiMessageTool) get(\"msg\"));\n        }\n\n        return msg;\n    }\n\n    public XWikiValidationStatus getValidationStatus()\n    {\n        return (XWikiValidationStatus) get(\"validation_status\");\n    }\n\n    public void setValidationStatus(XWikiValidationStatus status)\n    {\n        put(\"validation_status\", status);\n    }\n\n    public void addDisplayedField(String fieldname)\n    {\n        this.displayedFields.add(fieldname);\n    }\n\n    public List<String> getDisplayedFields()\n    {\n        return this.displayedFields;\n    }\n\n    /**\n     * Returns the list of TextArea fields that use the WYSIWYG editor. This list is automatically built when displaying\n     * TextArea properties.\n     *\n     * @deprecated since 8.2RC1 when we started using the Edit Module to load the configured WYSIWYG editor\n     * @return a string containing a comma-separated list of TextArea field names for which the WYSIWYG editor should be\n     *         enabled\n     */\n    @Deprecated\n    public String getEditorWysiwyg()\n    {\n        return (String) get(\"editor_wysiwyg\");\n    }\n\n    /**\n     * Drop permissions for the remainder of the request cycle.\n     * <p>\n     * After this is called:\n     * <ul>\n     * <li>1. {@link com.xpn.xwiki.api.Api#hasProgrammingRights()} will always return false.</li>\n     * <li>2. {@link com.xpn.xwiki.api.XWiki#getDocumentAsAuthor(org.xwiki.model.reference.DocumentReference)},\n     * {@link com.xpn.xwiki.api.XWiki#getDocumentAsAuthor(String)}, {@link com.xpn.xwiki.api.Document#saveAsAuthor()},\n     * {@link com.xpn.xwiki.api.Document#saveAsAuthor(String)},\n     * {@link com.xpn.xwiki.api.Document#saveAsAuthor(String, boolean)}, and\n     * {@link com.xpn.xwiki.api.Document#deleteAsAuthor()} will perform all of their actions as if the document's\n     * content author was the guest user (XWiki.XWikiGuest).</li>\n     * </ul>\n     * <p>\n     * In effect, no code requiring \"programming right\" will run, and if the document content author (see:\n     * {@link com.xpn.xwiki.api.Document#getContentAuthor()}) is a user who has \"programming right\", there will be no\n     * way for code following this call to save another document as this user, blessing it too with programming right.\n     * <p>\n     * Once dropped, permissions cannot be regained for the duration of the request.\n     * <p>\n     * If you are interested in a more flexable sandboxing method which sandboxed code only for the remainder of the\n     * rendering cycle, consider using {@link com.xpn.xwiki.api.Document#dropPermissions()}.\n     *\n     * @since 3.0M3\n     */\n    public void dropPermissions()\n    {\n        this.put(XWikiConstant.DROPPED_PERMISSIONS, Boolean.TRUE);\n    }\n\n    /**\n     * @return true if {@link XWikiContext#dropPermissions()} has been called on this context, or if the\n     *         {@link XWikiConstant#DROPPED_PERMISSIONS} key has been set in the\n     *         {@link org.xwiki.context.ExecutionContext} for this thread. This is done by calling\n     *         {Document#dropPermissions()}\n     */\n    public boolean hasDroppedPermissions()\n    {\n        if (this.get(XWikiConstant.DROPPED_PERMISSIONS) != null) {\n            return true;\n        }\n\n        final Object dropped = getExecution().getContext().getProperty(XWikiConstant.DROPPED_PERMISSIONS);\n\n        if (!(dropped instanceof Integer)) {\n            return false;\n        }\n\n        return ((Integer) dropped) == System.identityHashCode(getExecution().getContext());\n    }\n\n    // Object\n\n    @Override\n    public synchronized XWikiContext clone()\n    {\n        XWikiContext context = (XWikiContext) super.clone();\n\n        // Make sure to have unique instances of the various caches\n        context.displayedFields = Collections.synchronizedList(new ArrayList<String>(this.displayedFields));\n        context.classCache = Collections.synchronizedMap(new LRUMap<DocumentReference, BaseClass>(this.classCacheSize));\n\n        return context;\n    }\n\n    /**\n     * There are several places where the XWiki context needs to be declared in the execution, so we add a common method\n     * here.\n     *\n     * @param executionContext The execution context.\n     */\n    public void declareInExecutionContext(ExecutionContext executionContext)\n    {\n        if (!executionContext.hasProperty(XWikiContext.EXECUTIONCONTEXT_KEY)) {\n            executionContext.newProperty(XWikiContext.EXECUTIONCONTEXT_KEY).initial(this).inherited().declare();\n        } else {\n            executionContext.setProperty(XWikiContext.EXECUTIONCONTEXT_KEY, this);\n        }\n    }\n\n    /**\n     * @return the reference of the user being used to check script and programming right (i.e. the author of the\n     *         current script)\n     * @since 8.3M2\n     */\n    public DocumentReference getAuthorReference()\n    {\n        XWikiDocument sdoc = (XWikiDocument) get(\"sdoc\");\n        if (sdoc == null) {\n            sdoc = getDoc();\n        }\n\n        return sdoc != null ? sdoc.getContentAuthorReference() : getUserReference();\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.api;\n\nimport java.io.IOException;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.exception.ExceptionUtils;\nimport org.apache.commons.lang3.math.NumberUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.job.Job;\nimport org.xwiki.job.event.status.JobStatus;\nimport org.xwiki.job.event.status.JobStatus.State;\nimport org.xwiki.model.EntityType;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.PageReference;\nimport org.xwiki.model.reference.SpaceReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.rendering.renderer.PrintRendererFactory;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.stability.Unstable;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.DocumentRevisionProvider;\nimport com.xpn.xwiki.doc.XWikiDeletedDocument;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.XWikiInitializerJob;\nimport com.xpn.xwiki.internal.XWikiInitializerJobStatus;\nimport com.xpn.xwiki.objects.meta.MetaClass;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.util.Programming;\nimport com.xpn.xwiki.web.Utils;\nimport com.xpn.xwiki.web.XWikiEngineContext;\nimport com.xpn.xwiki.web.XWikiURLFactory;\n\npublic class XWiki extends Api\n{\n    /** Logging helper object. */\n    protected static final Logger LOGGER = LoggerFactory.getLogger(XWiki.class);\n\n    /** The internal object wrapped by this API. */\n    private com.xpn.xwiki.XWiki xwiki;\n\n    /**\n     * @see #getStatsService()\n     */\n    private StatsService statsService;\n\n    /**\n     * @see #getCriteriaService()\n     */\n    private CriteriaService criteriaService;\n\n    /**\n     * @see com.xpn.xwiki.internal.model.reference.CurrentMixedStringDocumentReferenceResolver\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    /**\n     * @see org.xwiki.model.internal.reference.DefaultStringDocumentReferenceResolver\n     */\n    private DocumentReferenceResolver<String> defaultDocumentReferenceResolver;\n\n    /**\n     * The object used to serialize entity references into strings. We need it because we have script APIs that work\n     * with entity references but have to call older, often internal, methods that still use string references.\n     */\n    private EntityReferenceSerializer<String> defaultStringEntityReferenceSerializer;\n\n    private DocumentReferenceResolver<EntityReference> currentgetdocumentResolver;\n\n    private DocumentRevisionProvider documentRevisionProvider;\n\n    private ContextualAuthorizationManager contextualAuthorizationManager;\n\n    /**\n     * XWiki API Constructor\n     *\n     * @param xwiki XWiki Main Object to wrap\n     * @param context XWikiContext to wrap\n     */\n    public XWiki(com.xpn.xwiki.XWiki xwiki, XWikiContext context)\n    {\n        super(context);\n\n        this.xwiki = xwiki;\n        this.statsService = new StatsService(context);\n        this.criteriaService = new CriteriaService(context);\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (this.currentMixedDocumentReferenceResolver == null) {\n            this.currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n\n        return this.currentMixedDocumentReferenceResolver;\n    }\n\n    private DocumentReferenceResolver<EntityReference> getCurrentgetdocumentResolver()\n    {\n        if (this.currentgetdocumentResolver == null) {\n            this.currentgetdocumentResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_REFERENCE, \"currentgetdocument\");\n        }\n\n        return this.currentgetdocumentResolver;\n    }\n\n    private DocumentReferenceResolver<String> getDefaultDocumentReferenceResolver()\n    {\n        if (this.defaultDocumentReferenceResolver == null) {\n            this.defaultDocumentReferenceResolver = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING);\n        }\n\n        return this.defaultDocumentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getDefaultStringEntityReferenceSerializer()\n    {\n        if (this.defaultStringEntityReferenceSerializer == null) {\n            this.defaultStringEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING);\n        }\n\n        return this.defaultStringEntityReferenceSerializer;\n    }\n\n    private DocumentRevisionProvider getDocumentRevisionProvider()\n    {\n        if (this.documentRevisionProvider == null) {\n            this.documentRevisionProvider = Utils.getComponent(DocumentRevisionProvider.class);\n        }\n\n        return this.documentRevisionProvider;\n    }\n\n    /**\n     * Privileged API allowing to access the underlying main XWiki Object\n     *\n     * @return Privileged Main XWiki Object\n     */\n    @Programming\n    public com.xpn.xwiki.XWiki getXWiki()\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki;\n        }\n\n        return null;\n    }\n\n    /**\n     * @return the status of the job initializing {@link com.xpn.xwiki.XWiki} instance\n     * @since 6.1M1\n     */\n    public XWikiInitializerJobStatus getJobStatus()\n    {\n        XWikiInitializerJob job = Utils.getComponent((Type) Job.class, XWikiInitializerJob.JOBTYPE);\n\n        return job != null ? job.getStatus() : null;\n    }\n\n    /**\n     * @return the status of the job initializing the instance or the current wiki\n     * @since 8.4RC1\n     */\n    public JobStatus getCurrentInitializerJobStatus()\n    {\n        // Get XWiki initializer job\n        JobStatus jobStatus = getJobStatus();\n\n        if (jobStatus == null) {\n            return null;\n        }\n\n        // The XWiki initialization is not done yet\n        if (jobStatus.getState() != State.FINISHED) {\n            return jobStatus;\n        }\n\n        // If XWiki initialization did not failed\n        if (this.xwiki != null) {\n            // Get current wiki initializer job\n            Job wikiJob = this.xwiki.getWikiInitializerJob(this.context.getWikiId());\n\n            jobStatus = wikiJob != null ? wikiJob.getStatus() : null;\n        }\n\n        return jobStatus;\n    }\n\n    /**\n     * @return XWiki's version in the format <code>(version).(SVN build number)</code>, or \"Unknown version\" if it\n     *         failed to be retrieved\n     */\n    public String getVersion()\n    {\n        return this.xwiki.getVersion();\n    }\n\n    /**\n     * API Allowing to access the current request URL being requested.\n     *\n     * @return the URL\n     * @throws XWikiException failed to create the URL\n     */\n    public String getRequestURL() throws XWikiException\n    {\n        return getXWikiContext().getURLFactory().getRequestURL(getXWikiContext()).toString();\n    }\n\n    /**\n     * API Allowing to access the current request URL being requested as a relative URL.\n     *\n     * @return the URL\n     * @throws XWikiException failed to create the URL\n     * @since 4.0M1\n     */\n    public String getRelativeRequestURL() throws XWikiException\n    {\n        XWikiURLFactory urlFactory = getXWikiContext().getURLFactory();\n\n        return urlFactory.getURL(urlFactory.getRequestURL(getXWikiContext()), getXWikiContext());\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked before sending back the document.\n     * <p>\n     * This is a helper for document reference but you can use {@link #getEntityDocument(String, EntityType)} for any\n     * other kind of reference.\n     *\n     * @param documentReference the reference of the document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @see #getEntityDocument(String, EntityType)\n     */\n    public Document getDocument(String documentReference) throws XWikiException\n    {\n        DocumentReference reference;\n\n        // We ignore the passed full name if it's null to be backward compatible with previous behaviors.\n        if (documentReference != null) {\n            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't\n            // specified in the passed string, rather than use the current document's page name.\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(documentReference);\n        } else {\n            reference = getDefaultDocumentReferenceResolver().resolve(\"\");\n        }\n\n        return getDocument(reference);\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked before sending back the document.\n     *\n     * @param reference the reference of the document to be loaded\n     * @param type the type of the reference\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 10.6RC1\n     */\n    public Document getEntityDocument(String reference, EntityType type) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(reference, type, getXWikiContext());\n        if (!getContextualAuthorizationManager().hasAccess(Right.VIEW, doc.getDocumentReference())) {\n            return null;\n        }\n\n        return doc.newDocument(getXWikiContext());\n    }\n\n    /**\n     * Loads a Document from the database. Rights are checked before sending back the document.\n     *\n     * @param reference the reference of the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 2.3M1\n     */\n    public Document getDocument(DocumentReference reference) throws XWikiException\n    {\n        try {\n            XWikiDocument doc = this.xwiki.getDocument(reference, getXWikiContext());\n            if (this.xwiki.getRightService().hasAccessLevel(\"view\", getXWikiContext().getUser(),\n                doc.getPrefixedFullName(), getXWikiContext()) == false) {\n                return null;\n            }\n\n            return doc.newDocument(getXWikiContext());\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to access document [{}]. Root reason: [{}]\", reference,\n                ExceptionUtils.getRootCauseMessage(ex));\n            return new Document(new XWikiDocument(reference), getXWikiContext());\n        }\n    }\n\n    /**\n     * Loads a Document from the store. Rights are checked before sending back the document.\n     * <p>\n     * The passed reference can be anything. If if a document child, the document reference will be extracted from it.\n     * If it's a document parent it will be completed with the necessary default references (for example if it's a space\n     * reference it will load the space home page).\n     *\n     * @param reference the reference close to the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 7.1M2\n     */\n    public Document getDocument(EntityReference reference) throws XWikiException\n    {\n        return getDocument(this.xwiki.getDocumentReference(reference, getXWikiContext()));\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked on the author (contentAuthor) of the document containing\n     * the currently executing script before sending back the loaded document.\n     *\n     * @param fullName the full name of the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 2.3M2\n     */\n    public Document getDocumentAsAuthor(String fullName) throws XWikiException\n    {\n        DocumentReference reference;\n\n        // We ignore the passed full name if it's null to match behavior of getDocument\n        if (fullName != null) {\n            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't\n            // specified in the passed string, rather than use the current document's page name.\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);\n        } else {\n            reference = getDefaultDocumentReferenceResolver().resolve(\"\");\n        }\n\n        return getDocumentAsAuthor(reference);\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked on the author (contentAuthor) of the document containing\n     * the currently executing script before sending back the loaded document.\n     *\n     * @param reference the reference of the XWiki document to be loaded\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     * @since 2.3M2\n     */\n    public Document getDocumentAsAuthor(DocumentReference reference) throws XWikiException\n    {\n        if (!getAuthorizationManager().hasAccess(Right.VIEW, getEffectiveAuthorReference(), reference)) {\n            return null;\n        }\n\n        return this.xwiki.getDocument(reference, getXWikiContext()).newDocument(getXWikiContext());\n    }\n\n    /**\n     * @param fullname the {@link XWikiDocument#getFullName() name} of the document to search for.\n     * @param locale an optional {@link XWikiDocument#getLocale() locale} to filter results.\n     * @return A list with all the deleted versions of a document in the recycle bin.\n     * @throws XWikiException if any error\n     */\n    public List<DeletedDocument> getDeletedDocuments(String fullname, String locale) throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = this.xwiki.getDeletedDocuments(fullname, locale, this.context);\n        List<DeletedDocument> result = wrapDeletedDocuments(deletedDocuments);\n        return result;\n    }\n\n    /**\n     * @param batchId id of the operation that deleted multiple documents at the same time; useful when trying to revert\n     *            the operation\n     * @return a list of all document versions that were deleted in the same batch, as part of the same operation\n     * @throws XWikiException if any error\n     * @since 9.4RC1\n     */\n    public List<DeletedDocument> getDeletedDocuments(String batchId) throws XWikiException\n    {\n        XWikiDeletedDocument[] deletedDocuments = this.xwiki.getDeletedDocuments(batchId, this.context);\n        List<DeletedDocument> result = wrapDeletedDocuments(deletedDocuments);\n        return result;\n    }\n\n    private List<DeletedDocument> wrapDeletedDocuments(XWikiDeletedDocument[] deletedDocuments)\n    {\n        if (deletedDocuments == null || deletedDocuments.length == 0) {\n            return Collections.emptyList();\n        }\n\n        List<DeletedDocument> result = new ArrayList<>(deletedDocuments.length);\n        for (XWikiDeletedDocument deletedDocument : deletedDocuments) {\n            result.add(new DeletedDocument(deletedDocument, this.context));\n        }\n\n        return result;\n    }\n\n    /**\n     * @param fullname - {@link XWikiDocument#getFullName()}\n     * @param locale - {@link XWikiDocument#getLocale()}\n     * @param index - {@link XWikiDocument#getId()}\n     * @return the specified document from the recycle bin\n     * @throws XWikiException if any error\n     * @deprecated since 9.4RC1. Use {@link #getDeletedDocument(String)} instead.\n     */\n    @Deprecated\n    public DeletedDocument getDeletedDocument(String fullname, String locale, String index) throws XWikiException\n    {\n        return getDeletedDocument(index);\n    }\n\n    /**\n     * @return the specified document from the recycle bin\n     * @throws XWikiException if any error\n     * @since 9.4RC1\n     */\n    public DeletedDocument getDeletedDocument(String index) throws XWikiException\n    {\n        if (!NumberUtils.isDigits(index)) {\n            return null;\n        }\n\n        XWikiDeletedDocument dd = this.xwiki.getDeletedDocument(Long.parseLong(index), this.context);\n        if (dd == null) {\n            return null;\n        }\n\n        return new DeletedDocument(dd, this.context);\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document. Note that this does not distinguish\n     * between different incarnations of a document name, and it does not require that the document still exists, it\n     * returns all the attachments that at the time of their deletion had a document with the specified name as their\n     * owner.\n     *\n     * @param docName the {@link XWikiDocument#getFullName() name} of the owner document\n     * @return A list with all the deleted attachments which belonged to the specified document. If no such attachments\n     *         are found in the trash, an empty list is returned.\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName)\n    {\n        try {\n            List<com.xpn.xwiki.doc.DeletedAttachment> attachments =\n                this.xwiki.getDeletedAttachments(docName, this.context);\n            if (attachments == null || attachments.isEmpty()) {\n                attachments = Collections.emptyList();\n            }\n            List<DeletedAttachment> result = new ArrayList<DeletedAttachment>(attachments.size());\n            for (com.xpn.xwiki.doc.DeletedAttachment attachment : attachments) {\n                result.add(new DeletedAttachment(attachment, this.context));\n            }\n            return result;\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to retrieve deleted attachments\", ex);\n        }\n        return Collections.emptyList();\n    }\n\n    /**\n     * Retrieve all the deleted attachments that belonged to a certain document and had the specified name. Multiple\n     * versions can be returned since the same file can be uploaded and deleted several times, creating different\n     * instances in the trash. Note that this does not distinguish between different incarnations of a document name,\n     * and it does not require that the document still exists, it returns all the attachments that at the time of their\n     * deletion had a document with the specified name as their owner.\n     *\n     * @param docName the {@link DeletedAttachment#getDocName() name of the document} the attachment belonged to\n     * @param filename the {@link DeletedAttachment#getFilename() name} of the attachment to search for\n     * @return A list with all the deleted attachments which belonged to the specified document and had the specified\n     *         filename. If no such attachments are found in the trash, an empty list is returned.\n     */\n    public List<DeletedAttachment> getDeletedAttachments(String docName, String filename)\n    {\n        try {\n            List<com.xpn.xwiki.doc.DeletedAttachment> attachments =\n                this.xwiki.getDeletedAttachments(docName, filename, this.context);\n            if (attachments == null) {\n                attachments = Collections.emptyList();\n            }\n            List<DeletedAttachment> result = new ArrayList<DeletedAttachment>(attachments.size());\n            for (com.xpn.xwiki.doc.DeletedAttachment attachment : attachments) {\n                result.add(new DeletedAttachment(attachment, this.context));\n            }\n            return result;\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to retrieve deleted attachments\", ex);\n        }\n        return Collections.emptyList();\n    }\n\n    /**\n     * Retrieve a specific attachment from the trash.\n     *\n     * @param id the unique identifier of the entry in the trash\n     * @return specified attachment from the trash, {@code null} if not found\n     */\n    public DeletedAttachment getDeletedAttachment(String id)\n    {\n        try {\n            com.xpn.xwiki.doc.DeletedAttachment attachment = this.xwiki.getDeletedAttachment(id, this.context);\n            if (attachment != null) {\n                return new DeletedAttachment(attachment, this.context);\n            }\n        } catch (Exception ex) {\n            LOGGER.warn(\"Failed to retrieve deleted attachment\", ex);\n        }\n        return null;\n    }\n\n    /**\n     * Returns whether a document exists or not\n     *\n     * @param fullname Fullname of the XWiki document to be loaded\n     * @return true if the document exists, false if not\n     * @throws XWikiException\n     */\n    public boolean exists(String fullname) throws XWikiException\n    {\n        return this.xwiki.exists(fullname, getXWikiContext());\n    }\n\n    /**\n     * Returns whether a document exists or not\n     *\n     * @param reference the reference of the document to check for its existence\n     * @return true if the document exists, false if not\n     * @since 2.3M2\n     */\n    public boolean exists(DocumentReference reference) throws XWikiException\n    {\n        return this.xwiki.exists(reference, getXWikiContext());\n    }\n\n    /**\n     * Returns whether a page exists or not.\n     *\n     * @param reference the reference of the page to check for its existence\n     * @return true if the page exists, false if not\n     * @since 13.3RC1\n     * @since 12.10.7\n     */\n    @Unstable\n    public boolean exists(PageReference reference)\n    {\n        return this.xwiki.exists(reference, getXWikiContext());\n    }\n\n    /**\n     * Verify the rights the current user has on a document. If the document requires rights and the user is not\n     * authenticated he will be redirected to the login page.\n     *\n     * @param docname fullname of the document\n     * @param right right to check (\"view\", \"edit\", \"admin\", \"delete\")\n     * @return true if it exists\n     */\n    public boolean checkAccess(String docname, String right)\n    {\n        try {\n            DocumentReference docReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n            XWikiDocument doc = getXWikiContext().getWiki().getDocument(docReference, this.context);\n            return getXWikiContext().getWiki().checkAccess(right, doc, getXWikiContext());\n        } catch (XWikiException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Loads an Document from the database. Rights are checked before sending back the document.\n     *\n     * @param space Space to use in case no space is defined in the provided <code>fullname</code>\n     * @param fullname the full name or relative name of the document to load\n     * @return a Document object (if the document couldn't be found a new one is created in memory - but not saved, you\n     *         can check whether it's a new document or not by using {@link com.xpn.xwiki.api.Document#isNew()}\n     * @throws XWikiException\n     */\n    public Document getDocument(String space, String fullname) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(space, fullname, getXWikiContext());\n        if (this.xwiki.getRightService().hasAccessLevel(\"view\", getXWikiContext().getUser(), doc.getFullName(),\n            getXWikiContext()) == false) {\n            return null;\n        }\n\n        return doc.newDocument(getXWikiContext());\n    }\n\n    /**\n     * Load a specific revision of a document\n     *\n     * @param doc Document for which to load a specific revision\n     * @param rev Revision number\n     * @return Specific revision of a document\n     * @throws XWikiException is never thrown\n     */\n    public Document getDocument(Document doc, String rev) throws XWikiException\n    {\n        if (doc == null || doc.getDoc() == null) {\n            return null;\n        }\n\n        if (!getContextualAuthorizationManager().hasAccess(Right.VIEW, doc.getDocumentReference())) {\n            // Finally we return null, otherwise showing search result is a real pain\n            return null;\n        }\n\n        return doc.getDocumentRevision(rev);\n    }\n\n    /**\n     * Load a specific revision of a document\n     *\n     * @param reference Document for which to load a specific revision\n     * @param revision Revision number\n     * @return Specific revision of a document\n     * @throws XWikiException is never thrown\n     * @since 9.4RC1\n     */\n    public Document getDocument(DocumentReference reference, String revision) throws XWikiException\n    {\n        try {\n            if (reference != null && getContextualAuthorizationManager().hasAccess(Right.VIEW, reference)) {\n                XWikiDocument documentRevision = getDocumentRevisionProvider().getRevision(reference, revision);\n\n                if (documentRevision != null) {\n                    return new Document(documentRevision, this.context);\n                }\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to access revision [{}] of document {}\", revision, reference, e);\n        }\n\n        return null;\n    }\n\n    /**\n     * Output content in the edit content textarea\n     *\n     * @param content content to output\n     * @return the textarea text content\n     */\n    public String getTextArea(String content)\n    {\n        return com.xpn.xwiki.XWiki.getTextArea(content, getXWikiContext());\n    }\n\n    /**\n     * Get the list of available classes in the wiki\n     *\n     * @return list of classes names\n     * @throws XWikiException\n     */\n    public List<String> getClassList() throws XWikiException\n    {\n        return this.xwiki.getClassList(getXWikiContext());\n    }\n\n    /**\n     * Get the global MetaClass object\n     *\n     * @return MetaClass object\n     */\n    public MetaClass getMetaclass()\n    {\n        return this.xwiki.getMetaclass();\n    }\n\n    /**\n     * API allowing to search for document names matching a query. Examples:\n     * <ul>\n     * <li>Query: <code>where doc.space='Main' order by doc.creationDate desc</code>. Result: All the documents in space\n     * 'Main' ordered by the creation date from the most recent</li>\n     * <li>Query: <code>where doc.name like '%sport%' order by doc.name asc</code>. Result: All the documents containing\n     * 'sport' in their name ordered by document name</li>\n     * <li>Query: <code>where doc.content like '%sport%' order by doc.author</code> Result: All the documents containing\n     * 'sport' in their content ordered by the author</li>\n     * <li>Query: <code>where doc.creator = 'XWiki.LudovicDubost' order by doc.creationDate\n     *       desc</code>. Result: All the documents with creator LudovicDubost ordered by the creation date from the\n     * most recent</li>\n     * <li>Query: <code>where doc.author = 'XWiki.LudovicDubost' order by doc.date desc</code>. Result: All the\n     * documents with last author LudovicDubost ordered by the last modification date from the most recent.</li>\n     * <li>Query: <code>,BaseObject as obj where doc.fullName=obj.name and\n     *       obj.className='XWiki.XWikiComments' order by doc.date desc</code>. Result: All the documents with at least\n     * one comment ordered by the last modification date from the most recent</li>\n     * <li>Query: <code>,BaseObject as obj, StringProperty as prop where\n     *       doc.fullName=obj.name and obj.className='XWiki.XWikiComments' and obj.id=prop.id.id\n     *       and prop.id.name='author' and prop.value='XWiki.LudovicDubost' order by doc.date\n     *       desc</code>. Result: All the documents with at least one comment from LudovicDubost ordered by the last\n     * modification date from the most recent</li>\n     * </ul>\n     *\n     * @param wheresql Query to be run (either starting with \", BaseObject as obj where..\" or by \"where ...\"\n     * @return List of document names matching (Main.Page1, Main.Page2)\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String wheresql) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(wheresql, getXWikiContext());\n    }\n\n    /**\n     * API allowing to search for document names matching a query return only a limited number of elements and skipping\n     * the first rows. The query part is the same as searchDocuments\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param nb return only 'nb' rows\n     * @param start skip the first 'start' rows\n     * @return List of document names matching\n     * @throws XWikiException\n     * @see List searchDocuments(String where sql)\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String wheresql, int nb, int start) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(wheresql, nb, start, getXWikiContext());\n    }\n\n    /**\n     * Privileged API allowing to search for document names matching a query return only a limited number of elements\n     * and skipping the first rows. The return values contain the list of columns specified in addition to the document\n     * space and name The query part is the same as searchDocuments\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param nb return only 'nb' rows\n     * @param start skip the first 'start' rows\n     * @param selectColumns List of columns to add to the result\n     * @return List of Object[] with the column values of the matching rows\n     * @throws XWikiException\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String wheresql, int nb, int start, String selectColumns) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.getStore().searchDocumentsNames(wheresql, nb, start, selectColumns, getXWikiContext());\n        }\n\n        return Collections.emptyList();\n    }\n\n    /**\n     * API allowing to search for documents allowing to have mutliple entries per locale\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param distinctbylocale true to return multiple rows per locale\n     * @return List of Document object matching\n     * @throws XWikiException\n     */\n    public List<Document> searchDocuments(String wheresql, boolean distinctbylocale) throws XWikiException\n    {\n        return convert(this.xwiki.getStore().searchDocuments(wheresql, distinctbylocale, getXWikiContext()));\n    }\n\n    /**\n     * API allowing to search for documents allowing to have multiple entries per locale\n     *\n     * @param wheresql query to use similar to searchDocuments(wheresql)\n     * @param distinctbylocale true to return multiple rows per locale\n     * @return List of Document object matching\n     * @param nb return only 'nb' rows\n     * @param start skip the first 'start' rows\n     * @throws XWikiException\n     */\n    public List<Document> searchDocuments(String wheresql, boolean distinctbylocale, int nb, int start)\n        throws XWikiException\n    {\n        return convert(this.xwiki.getStore().searchDocuments(wheresql, distinctbylocale, nb, start, getXWikiContext()));\n    }\n\n    /**\n     * Search documents by passing HQL where clause values as parameters. This allows generating a Named HQL query which\n     * will automatically encode the passed values (like escaping single quotes). This API is recommended to be used\n     * over the other similar methods where the values are passed inside the where clause and for which you'll need to\n     * do the encoding/escaping yourself before calling them.\n     * <p>\n     * Example\n     * </p>\n     *\n     * <pre>\n     * &lt;code&gt;\n     * #set($orphans = $xwiki.searchDocuments(&quot; where doc.fullName &lt;&gt; ?1 and (doc.parent = ?2 or &quot;\n     *     + &quot;(doc.parent = ?3 and doc.space = ?4))&quot;,\n     *     [&quot;${doc.fullName}as&quot;, ${doc.fullName}, ${doc.name}, ${doc.space}]))\n     * &lt;/code&gt;\n     * </pre>\n     *\n     * @param parameterizedWhereClause the HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param maxResults the number of rows to return. If 0 then all rows are returned\n     * @param startOffset the number of rows to skip. If 0 don't skip any row\n     * @param parameterValues the where clause values that replace the question marks (?1, ?2, etc.)\n     * @return a list of document names\n     * @throws XWikiException in case of error while performing the query\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, int maxResults, int startOffset,\n        List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, maxResults, startOffset,\n            parameterValues, getXWikiContext());\n    }\n\n    /**\n     * Same as {@link #searchDocuments(String, int, int, java.util.List)} but returns all rows.\n     *\n     * @see #searchDocuments(String, int, int, java.util.List)\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocuments(String parameterizedWhereClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.getStore().searchDocumentsNames(parameterizedWhereClause, parameterValues, getXWikiContext());\n    }\n\n    /**\n     * Search documents in the provided wiki by passing HQL where clause values as parameters. See\n     * {@link #searchDocuments(String, int, int, java.util.List)} for more details.\n     *\n     * @param wikiName the name of the wiki where to search.\n     * @param parameterizedWhereClause the HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param maxResults the number of rows to return. If 0 then all rows are returned\n     * @param startOffset the number of rows to skip. If 0 don't skip any row\n     * @param parameterValues the where clause values that replace the question marks (?)\n     * @return a list of document full names (Space.Name).\n     * @see #searchDocuments(String, int, int, java.util.List)\n     * @throws XWikiException in case of error while performing the query\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> searchDocumentsNames(String wikiName, String parameterizedWhereClause, int maxResults,\n        int startOffset, List<?> parameterValues) throws XWikiException\n    {\n        String database = this.context.getWikiId();\n\n        try {\n            this.context.setWikiId(wikiName);\n\n            return searchDocuments(parameterizedWhereClause, maxResults, startOffset, parameterValues);\n        } finally {\n            this.context.setWikiId(database);\n        }\n    }\n\n    /**\n     * Search spaces by passing HQL where clause values as parameters. See\n     * {@link #searchDocuments(String, int, int, List)} for more about parameterized hql clauses.\n     *\n     * @param parametrizedSqlClause the HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param nb the number of rows to return. If 0 then all rows are returned\n     * @param start the number of rows to skip. If 0 don't skip any row\n     * @param parameterValues the where clause values that replace the question marks (?)\n     * @return a list of spaces names.\n     * @throws XWikiException in case of error while performing the query\n     */\n    public List<String> searchSpacesNames(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return this.xwiki.getStore().search(\"select distinct doc.space from XWikiDocument doc \" + parametrizedSqlClause,\n            nb, start, parameterValues, this.context);\n    }\n\n    /**\n     * Search attachments by passing HQL where clause values as parameters. See\n     * {@link #searchDocuments(String, int, int, List)} for more about parameterized hql clauses. You can specify\n     * properties of attach (the attachment) or doc (the document it is attached to)\n     *\n     * @param parametrizedSqlClause The HQL where clause. For example\n     *            {@code where doc.fullName <> ?1 and (doc.parent = ?2 or (doc.parent = ?3 and doc.space = ?4))}\n     * @param nb The number of rows to return. If 0 then all rows are returned\n     * @param start The number of rows to skip at the beginning.\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @return A List of {@link Attachment} objects.\n     * @throws XWikiException in case of error while performing the query\n     * @since 5.0M2\n     */\n    public List<Attachment> searchAttachments(String parametrizedSqlClause, int nb, int start, List<?> parameterValues)\n        throws XWikiException\n    {\n        return convertAttachments(\n            this.xwiki.searchAttachments(parametrizedSqlClause, true, nb, start, parameterValues, this.context));\n    }\n\n    /**\n     * Count attachments returned by a given parameterized query\n     *\n     * @param parametrizedSqlClause Everything which would follow the \"WHERE\" in HQL see:\n     *            {@link #searchDocuments(String, int, int, List)}\n     * @param parameterValues A {@link java.util.List} of the where clause values that replace the question marks (?)\n     * @return int number of attachments found.\n     * @throws XWikiException\n     * @see #searchAttachments(String, int, int, List)\n     * @since 5.0M2\n     */\n    public int countAttachments(String parametrizedSqlClause, List<?> parameterValues) throws XWikiException\n    {\n        return this.xwiki.countAttachments(parametrizedSqlClause, parameterValues, this.context);\n    }\n\n    /**\n     * Function to wrap a list of XWikiDocument into Document objects\n     *\n     * @param docs list of XWikiDocument\n     * @return list of Document objects\n     */\n    public List<Document> wrapDocs(List<?> docs)\n    {\n        List<Document> result = new ArrayList<Document>();\n        if (docs != null) {\n            for (java.lang.Object obj : docs) {\n                try {\n                    if (obj instanceof XWikiDocument) {\n                        XWikiDocument doc = (XWikiDocument) obj;\n                        Document wrappedDoc = doc.newDocument(getXWikiContext());\n                        result.add(wrappedDoc);\n                    } else if (obj instanceof Document) {\n                        result.add((Document) obj);\n                    } else if (obj instanceof String) {\n                        Document doc = getDocument(obj.toString());\n                        if (doc != null) {\n                            result.add(doc);\n                        }\n                    }\n                } catch (XWikiException ex) {\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * API allowing to parse a text content to evaluate velocity scripts\n     *\n     * @param content\n     * @return evaluated content if the content contains velocity scripts\n     * @deprecated Since 7.2M1. Use specific rendering/parsing options for the content type you want to parse/render.\n     */\n    @Deprecated\n    public String parseContent(String content)\n    {\n        return this.xwiki.parseContent(content, getXWikiContext());\n    }\n\n    /**\n     * API to parse a velocity template provided by the current Skin The template is first looked in the skin active for\n     * the user, the space or the wiki. If the template does not exist in that skin, the template is looked up in the\n     * \"parent skin\" of the skin\n     *\n     * @param template Template name (\"view\", \"edit\", \"comment\")\n     * @return Evaluated content from the template\n     */\n    public String parseTemplate(String template)\n    {\n        return this.xwiki.parseTemplate(template, getXWikiContext());\n    }\n\n    /**\n     * API to render a velocity template provided by the current Skin The template is first looked in the skin active\n     * for the user, the space or the wiki. If the template does not exist in that skin, the template is looked up in\n     * the \"parent skin\" of the skin\n     *\n     * @param template Template name (\"view\", \"edit\", \"comment\")\n     * @return Evaluated content from the template\n     */\n    public String renderTemplate(String template)\n    {\n        return this.xwiki.renderTemplate(template, getXWikiContext());\n    }\n\n    /**\n     * Return the URL of the static file provided by the current skin The file is first looked in the skin active for\n     * the user, the space or the wiki. If the file does not exist in that skin, the file is looked up in the \"parent\n     * skin\" of the skin. The file can be a CSS file, an image file, a javascript file, etc.\n     *\n     * @param filename Filename to be looked up in the skin (logo.gif, style.css)\n     * @return URL to access this file\n     */\n    public String getSkinFile(String filename)\n    {\n        return this.xwiki.getSkinFile(filename, getXWikiContext());\n    }\n\n    /**\n     * Return the URL of the static file provided by the current skin The file is first looked in the skin active for\n     * the user, the space or the wiki. If the file does not exist in that skin, the file is looked up in the \"parent\n     * skin\" of the skin. The file can be a CSS file, an image file, a javascript file, etc.\n     *\n     * @param filename Filename to be looked up in the skin (logo.gif, style.css)\n     * @param forceSkinAction true to make sure that static files are retrieved through the skin action, to allow\n     *            parsing of velocity on CSS files\n     * @return URL to access this file\n     */\n    public String getSkinFile(String filename, boolean forceSkinAction)\n    {\n        return this.xwiki.getSkinFile(filename, forceSkinAction, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the current skin for this request and user The skin is first derived from the request \"skin\"\n     * parameter If this parameter does not exist, the user preference \"skin\" is looked up If this parameter does not\n     * exist or is empty, the space preference \"skin\" is looked up If this parameter does not exist or is empty, the\n     * XWiki preference \"skin\" is looked up If this parameter does not exist or is empty, the xwiki.cfg parameter\n     * xwiki.defaultskin is looked up If this parameter does not exist or is empty, the xwiki.cfg parameter\n     * xwiki.defaultbaseskin is looked up If this parameter does not exist or is empty, the skin is \"colibri\"\n     *\n     * @return The current skin for this request and user\n     */\n    public String getSkin()\n    {\n        return this.xwiki.getSkin(getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the current skin for this request and user. Each skin has a skin it is based on. If not the base\n     * skin is the xwiki.cfg parameter \"xwiki.defaultbaseskin\". If this parameter does not exist or is empty, the base\n     * skin is \"colibri\".\n     *\n     * @return The current baseskin for this request and user\n     */\n    public String getBaseSkin()\n    {\n        return this.xwiki.getBaseSkin(getXWikiContext());\n    }\n\n    /**\n     * API to access the copyright for this space. The copyright is read in the space preferences. If it does not exist\n     * or is empty it is read from the XWiki preferences.\n     *\n     * @return the text for the copyright\n     */\n    public String getSpaceCopyright()\n    {\n        return this.xwiki.getSpaceCopyright(getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getXWikiPreference(String preference)\n    {\n        return this.xwiki.getXWikiPreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale\n     */\n    public String getXWikiPreference(String preference, String defaultValue)\n    {\n        return this.xwiki.getXWikiPreference(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an Space Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale If no preference is found it will look in the XWiki\n     * Preferences\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getSpacePreference(String preference)\n    {\n        return this.xwiki.getSpacePreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access an Space Preference There can be one preference object per locale This function will find the right\n     * preference object associated to the current active locale If no preference is found it will look in the XWiki\n     * Preferences\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale\n     */\n    public String getSpacePreference(String preference, String defaultValue)\n    {\n        return this.xwiki.getSpacePreference(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access a Skin Preference The skin object is the current user's skin\n     *\n     * @param preference Preference name\n     * @return The preference for the current skin\n     */\n    public String getSkinPreference(String preference)\n    {\n        return this.xwiki.getSkinPreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a Skin Preference The skin object is the current user's skin\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for the current skin\n     */\n    public String getSkinPreference(String preference, String defaultValue)\n    {\n        return this.xwiki.getSkinPreference(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     *\n     * @param preference Preference name\n     * @param space The space for which this preference is requested\n     * @return The preference for this wiki and the current locale\n     */\n    public String getSpacePreferenceFor(String preference, String space)\n    {\n        return getSpacePreferenceFor(preference, space, \"\");\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     *\n     * @param preference Preference name\n     * @param space The space for which this preference is requested\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public String getSpacePreferenceFor(String preference, String space, String defaultValue)\n    {\n        return this.xwiki.getSpacePreference(preference, space, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then empty String is returned.\n     * \n     * @param preference the name of the preference key\n     * @param spaceReference the reference of the space\n     * @return the value of the preference or empty String if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreferenceFor(String preference, SpaceReference spaceReference)\n    {\n        return this.xwiki.getSpacePreference(preference, spaceReference, getXWikiContext());\n    }\n\n    /**\n     * Get the reference of the space and fallback on parent space or wiki in case nothing is found.\n     * <p>\n     * If the property is not set on any level then <code>defaultValue</code> is returned.\n     * \n     * @param preference the name of the preference key\n     * @param spaceReference the reference of the space\n     * @param defaultValue the value to return if the preference can't be found\n     * @return the value of the preference or <code>defaultValue</code> if it could not be found\n     * @since 7.4M1\n     */\n    public String getSpacePreferenceFor(String preference, SpaceReference spaceReference, String defaultValue)\n    {\n        return this.xwiki.getSpacePreference(preference, spaceReference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the preference does not exist or is empty\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getXWikiPreferenceAsLong(String preference, long defaultValue)\n    {\n        return this.xwiki.getXWikiPreferenceAsLong(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getXWikiPreferenceAsLong(String preference)\n    {\n        return this.xwiki.getXWikiPreferenceAsLong(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a Space Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale If no preference is found it will\n     * look for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the prefenrece does not exist or is empty\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getSpacePreferenceAsLong(String preference, long defaultValue)\n    {\n        return this.xwiki.getSpacePreferenceAsLong(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access a Space Preference as a long number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale If no preference is found it will\n     * look for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in long format\n     */\n    public long getSpacePreferenceAsLong(String preference)\n    {\n        return this.xwiki.getSpacePreferenceAsLong(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as an int number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the prefenrece does not exist or is empty\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getXWikiPreferenceAsInt(String preference, int defaultValue)\n    {\n        return this.xwiki.getXWikiPreferenceAsInt(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access an XWiki Preference as a int number There can be one preference object per locale This function\n     * will find the right preference object associated to the current active locale\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getXWikiPreferenceAsInt(String preference)\n    {\n        return this.xwiki.getXWikiPreferenceAsInt(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a space Preference as a int number There can be one preference object per locale This function will\n     * find the right preference object associated to the current active locale If no preference is found it will look\n     * for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @param defaultValue default value to return if the prefenrece does not exist or is empty\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getSpacePreferenceAsInt(String preference, int defaultValue)\n    {\n        return this.xwiki.getSpacePreferenceAsInt(preference, defaultValue, getXWikiContext());\n    }\n\n    /**\n     * API to access a Space Preference as a int number There can be one preference object per locale This function will\n     * find the right preference object associated to the current active locale If no preference is found it will look\n     * for the XWiki Preference\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale in int format\n     */\n    public int getSpacePreferenceAsInt(String preference)\n    {\n        return this.xwiki.getSpacePreferenceAsInt(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a User Preference This function will look in the User profile for the preference If no preference\n     * is found it will look in the Space Preferences If no preference is found it will look in the XWiki Preferences\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getUserPreference(String preference)\n    {\n        return this.xwiki.getUserPreference(preference, getXWikiContext());\n    }\n\n    /**\n     * API to access a User Preference from cookie This function will look in the session cookie for the preference\n     *\n     * @param preference Preference name\n     * @return The preference for this wiki and the current locale\n     */\n    public String getUserPreferenceFromCookie(String preference)\n    {\n        return this.xwiki.getUserPreferenceFromCookie(preference, getXWikiContext());\n    }\n\n    /**\n     * Same as {@link #getLocalePreference()} but as a String.\n     *\n     * @return the locale to use\n     * @deprecated since 8.0M1, use {@link #getLocalePreference()} instead\n     */\n    @Deprecated\n    public String getLanguagePreference()\n    {\n        return this.xwiki.getLanguagePreference(getXWikiContext());\n    }\n\n    /**\n     * First try to find the current locale in use from the XWiki context. If none is used and if the wiki is not\n     * multilingual use the default locale defined in the XWiki preferences. If the wiki is multilingual try to get the\n     * locale passed in the request. If none was passed try to get it from a cookie. If no locale cookie exists then use\n     * the user default locale and barring that use the browser's \"Accept-Language\" header sent in HTTP request. If none\n     * is defined use the default locale.\n     *\n     * @return the locale to use\n     * @since 8.0M1\n     */\n    public Locale getLocalePreference()\n    {\n        return this.xwiki.getLocalePreference(getXWikiContext());\n    }\n\n    /**\n     * Same as {@link #getInterfaceLocalePreference()} but as a String.\n     *\n     * @return the document locale preference for the request\n     * @deprecated since 8.0M1, use {@link #getInterfaceLocalePreference()} instead\n     */\n    @Deprecated\n    public String getInterfaceLanguagePreference()\n    {\n        return this.xwiki.getInterfaceLanguagePreference(getXWikiContext());\n    }\n\n    /**\n     * API to access the interface locale preference for the request Order of evaluation is: locale of the wiki in\n     * mono-lingual mode locale request parameter locale in context locale user preference locale in cookie locale\n     * accepted by the navigator\n     *\n     * @return the document locale preference for the request\n     */\n    public Locale getInterfaceLocalePreference()\n    {\n        return this.xwiki.getInterfaceLocalePreference(getXWikiContext());\n    }\n\n    /**\n     * Get the available locales according to the preferences.\n     *\n     * @return the list of available locales\n     * @since 12.4RC1\n     */\n    public List<Locale> getAvailableLocales()\n    {\n        return this.xwiki.getAvailableLocales(getXWikiContext());\n    }\n\n    /**\n     * @return the list of all wiki names, including the main wiki, corresponding to the available wiki descriptors.\n     *         Example: the descriptor for the wiki <i>wikiname</i> is a document in the main wiki, named\n     *         <i>XWiki.XWikiServerWikiname</i>, containing an XWiki.XWikiServerClass object.\n     * @see com.xpn.xwiki.XWiki#getVirtualWikisDatabaseNames(XWikiContext)\n     */\n    public List<String> getWikiNames()\n    {\n        List<String> result = new ArrayList<String>();\n\n        try {\n            result = this.xwiki.getVirtualWikisDatabaseNames(getXWikiContext());\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to get the list of all wiki names\", e);\n        }\n\n        return result;\n    }\n\n    /**\n     * Convenience method to ask if the current XWiki instance contains subwikis (in addition to the main wiki)\n     *\n     * @return true if at least 1 subwiki exists; false otherwise\n     * @see #getWikiNames()\n     */\n    public boolean hasSubWikis()\n    {\n        return getWikiNames().size() > 1;\n    }\n\n    /**\n     * API to check is wiki is multi-lingual\n     *\n     * @return true for multi-lingual/false for mono-lingual\n     */\n    public boolean isMultiLingual()\n    {\n        return this.xwiki.isMultiLingual(getXWikiContext());\n    }\n\n    /**\n     * Privileged API to flush the cache of the Wiki installation This flushed the cache of all wikis, all plugins, all\n     * renderers\n     */\n    public void flushCache()\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.flushCache(getXWikiContext());\n        }\n    }\n\n    /**\n     * Privileged API to create a new user from the request This API is used by RegisterNewUser wiki page\n     *\n     * @return the integer status code\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-2: passwords are different or password is empty</li>\n     *         <li>-3: user already exists</li>\n     *         <li>-4: invalid username provided</li>\n     *         <li>-8: user already exists</li>\n     *         </ul>\n     * @throws XWikiException\n     */\n    public int createUser() throws XWikiException\n    {\n        return createUser(false, \"edit\");\n    }\n\n    /**\n     * Privileged API to create a new user from the request This API is used by RegisterNewUser wiki page This version\n     * sends a validation email to the user Configuration of validation email is in the XWiki Preferences\n     *\n     * @param withValidation true to send the validationemail\n     * @return the integer status code\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-2: passwords are different or password is empty</li>\n     *         <li>-3: user already exists</li>\n     *         <li>-4: invalid username provided</li>\n     *         <li>-8: user already exists</li>\n     *         </ul>\n     * @throws XWikiException\n     */\n    public int createUser(boolean withValidation) throws XWikiException\n    {\n        return createUser(withValidation, \"edit\");\n    }\n\n    /**\n     * Privileged API to create a new user from the request.\n     * <p>\n     * This API is used by the RegisterNewUser wiki page.\n     * <p>\n     * This version sends a validation email to the user. Configuration of validation email is in the XWiki Preferences.\n     *\n     * @param withValidation true to send the validation email\n     * @param userRights Rights to set for the user for it's own page(defaults to \"edit\")\n     * @return the integer status code\n     *         <ul>\n     *         <li>1: ok</li>\n     *         <li>-2: passwords are different or password is empty</li>\n     *         <li>-3: user already exists</li>\n     *         <li>-4: invalid username provided</li>\n     *         <li>-8: user already exists</li>\n     *         </ul>\n     * @throws XWikiException\n     */\n    public int createUser(boolean withValidation, String userRights) throws XWikiException\n    {\n        boolean registerRight;\n        try {\n            // So, what's the register right for? This says that if the creator of the page\n            // (Admin) has programming rights, anybody can register. Is this OK?\n            if (hasProgrammingRights()) {\n                registerRight = true;\n            } else {\n                registerRight = this.xwiki.getRightService().hasAccessLevel(\"register\", getXWikiContext().getUser(),\n                    \"XWiki.XWikiPreferences\", getXWikiContext());\n            }\n\n            if (registerRight) {\n                return this.xwiki.createUser(withValidation, userRights, getXWikiContext());\n            }\n\n            return -1;\n        } catch (Exception e) {\n            LOGGER.error(\"Failed to create user\", e);\n\n            return -10;\n        }\n\n    }\n\n    /**\n     * Privileged API to validate the return code given by a user in response to an email validation email The\n     * validation information are taken from the request object\n     *\n     * @param withConfirmEmail true to send a account confirmation email/false to not send it\n     * @return Success of Failure code (0 for success, -1 for missing programming rights, &gt; 0 for other errors\n     * @throws XWikiException\n     */\n    public int validateUser(boolean withConfirmEmail) throws XWikiException\n    {\n        return this.xwiki.validateUser(withConfirmEmail, getXWikiContext());\n    }\n\n    /**\n     * Privileged API to add a user to the XWiki.XWikiAllGroup\n     *\n     * @param fullwikiname user name to add\n     * @throws XWikiException\n     */\n    public void addToAllGroup(String fullwikiname) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.setUserDefaultGroup(fullwikiname, getXWikiContext());\n        }\n    }\n\n    /**\n     * Privileged API to send a confirmation email to a user\n     *\n     * @param xwikiname user to send the email to\n     * @param password password to put in the mail\n     * @param email email to send to\n     * @param add_message Additional message to send to the user\n     * @param contentfield Preference field to use as a mail template\n     * @throws XWikiException if the mail was not send successfully\n     */\n    public void sendConfirmationMail(String xwikiname, String password, String email, String add_message,\n        String contentfield) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.sendConfirmationEmail(xwikiname, password, email, add_message, contentfield, getXWikiContext());\n        }\n    }\n\n    /**\n     * Privileged API to send a confirmation email to a user\n     *\n     * @param xwikiname user to send the email to\n     * @param password password to put in the mail\n     * @param email email to send to\n     * @param contentfield Preference field to use as a mail template\n     * @throws XWikiException if the mail was not send successfully\n     */\n    public void sendConfirmationMail(String xwikiname, String password, String email, String contentfield)\n        throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            this.xwiki.sendConfirmationEmail(xwikiname, password, email, \"\", contentfield, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to rename a document to another document.\n     * Note that the list of backlinks can be retrieved with {@link Document#getBackLinkedReferences()}\n     * and the list of children with {@link Document#getChildrenReferences()}.\n     *\n     * <strong>Warning:</strong> Be aware that this method never triggers any event related to the rename\n     * of the document. If you want the right events to be sent for the event, please use the dedicated Refactoring\n     * Module API (see\n     * {@link org.xwiki.refactoring.script.RequestFactory#createRenameRequest(EntityReference, EntityReference)}\n     * and {@link org.xwiki.refactoring.job.MoveRequest}).\n     *\n     * @param sourceDocumentReference the source document to rename.\n     * @param targetDocumentReference the target reference to rename the document to.\n     * @param overwrite if {@code true} the target document reference will be overwritten if it exists\n     *                  (deleted to the recycle bin before the rename). If {@code false} and the target document exist\n     *                  the rename won't be performed.\n     * @param backlinkDocumentReferences the list of references of documents to parse and for which links will be\n     *                                  modified to point to the new document reference\n     * @param childDocumentReferences the list of references of document whose parent field will be set to the new\n     *                                 document reference\n     * @return {@code true} if the rename succeeded. {@code false} if there was any issue.\n     * @throws XWikiException if the document cannot be renamed properly.\n     * @since 12.5RC1\n     */\n    public boolean renameDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        boolean overwrite, List<DocumentReference> backlinkDocumentReferences,\n        List<DocumentReference> childDocumentReferences) throws XWikiException\n    {\n        if (hasAccess(Right.DELETE, sourceDocumentReference)\n            && ((overwrite && hasAccess(Right.DELETE, targetDocumentReference))\n            || (!overwrite && hasAccess(Right.EDIT, targetDocumentReference)))) {\n            return this.xwiki.renameDocument(sourceDocumentReference, targetDocumentReference, overwrite,\n                backlinkDocumentReferences, childDocumentReferences, getXWikiContext());\n        }\n        return false;\n    }\n\n    /**\n     * API to copy a document to another document in the same wiki\n     *\n     * @param docname source document\n     * @param targetdocname target document\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname) throws XWikiException\n    {\n        return this.copyDocument(docname, targetdocname, null, null, null, false, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document in the same wiki\n     *\n     * @param docname source document\n     * @param targetdocname target document\n     * @param wikilocale locale to copy\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname, String wikilocale) throws XWikiException\n    {\n        return this.copyDocument(docname, targetdocname, null, null, wikilocale, false, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki\n     *\n     * @param docname source document\n     * @param sourceWiki source wiki\n     * @param targetWiki target wiki\n     * @param wikilocale locale to copy\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String sourceWiki, String targetWiki, String wikilocale)\n        throws XWikiException\n    {\n        return this.copyDocument(docname, docname, sourceWiki, targetWiki, wikilocale, true, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki additionally\n     * resetting the version\n     *\n     * @param docname source document\n     * @param sourceWiki source wiki\n     * @param targetWiki target wiki\n     * @param wikilocale locale to copy\n     * @param reset true to reset versions\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname, String sourceWiki, String targetWiki,\n        String wikilocale, boolean reset) throws XWikiException\n    {\n        return this.copyDocument(docname, targetdocname, sourceWiki, targetWiki, wikilocale, reset, false);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki additionally\n     * resetting the version and overwriting the previous document\n     *\n     * @param docname source document name\n     * @param targetdocname target document name\n     * @param sourceWiki source wiki\n     * @param targetWiki target wiki\n     * @param wikilocale locale to copy\n     * @param reset true to reset versions\n     * @param force true to overwrite the previous document\n     * @return true if the copy was sucessfull\n     * @throws XWikiException if the document was not copied properly\n     */\n    public boolean copyDocument(String docname, String targetdocname, String sourceWiki, String targetWiki,\n        String wikilocale, boolean reset, boolean force) throws XWikiException\n    {\n        DocumentReference sourceDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(docname);\n        if (!StringUtils.isEmpty(sourceWiki)) {\n            sourceDocumentReference = sourceDocumentReference.replaceParent(sourceDocumentReference.getWikiReference(),\n                new WikiReference(sourceWiki));\n        }\n\n        DocumentReference targetDocumentReference = getCurrentMixedDocumentReferenceResolver().resolve(targetdocname);\n        if (!StringUtils.isEmpty(targetWiki)) {\n            targetDocumentReference = targetDocumentReference.replaceParent(targetDocumentReference.getWikiReference(),\n                new WikiReference(targetWiki));\n        }\n\n        return this.copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale, reset, force);\n    }\n\n    /**\n     * API to copy a translation of a document to another document of the same name in another wiki additionally\n     * resetting the version and overwriting the previous document\n     *\n     * @param sourceDocumentReference the reference to the document to copy\n     * @param targetDocumentReference the reference to the document to create\n     * @param wikilocale locale to copy\n     * @param resetHistory {@code true} to reset versions\n     * @param overwrite {@code true} to overwrite the previous document\n     * @return {@code true} if the copy was sucessful\n     * @throws XWikiException if the document was not copied properly\n     * @since 3.0M3\n     */\n    public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,\n        String wikilocale, boolean resetHistory, boolean overwrite) throws XWikiException\n    {\n        // In order to copy the source document the user must have at least the right to view it.\n        if (hasAccessLevel(\"view\", getDefaultStringEntityReferenceSerializer().serialize(sourceDocumentReference))) {\n            String targetDocStringRef = getDefaultStringEntityReferenceSerializer().serialize(targetDocumentReference);\n            // To create the target document the user must have edit rights. If the target document exists and the user\n            // wants to overwrite it then he needs delete right.\n            // Note: We have to check if the target document exists before checking the delete right because delete\n            // right is denied if not explicitly specified.\n            if (hasAccessLevel(\"edit\", targetDocStringRef)\n                && (!overwrite || !exists(targetDocumentReference) || hasAccessLevel(\"delete\", targetDocStringRef))) {\n                // Reset creation data otherwise the required rights for page copy need to be reconsidered.\n                return this.xwiki.copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale,\n                    resetHistory, overwrite, true, getXWikiContext());\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Privileged API to copy a space to another wiki, optionally deleting all document of the target space\n     *\n     * @param space source Space\n     * @param sourceWiki source Wiki\n     * @param targetWiki target Wiki\n     * @param locale locale to copy\n     * @param clean true to delete all document of the target space\n     * @return number of copied documents\n     * @throws XWikiException if the space was not copied properly\n     */\n    public int copySpaceBetweenWikis(String space, String sourceWiki, String targetWiki, String locale, boolean clean)\n        throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.copySpaceBetweenWikis(space, sourceWiki, targetWiki, locale, clean, getXWikiContext());\n        }\n\n        return -1;\n    }\n\n    /**\n     * API to include a topic into another The topic is rendered fully in the context of itself\n     *\n     * @param topic page name of the topic to include\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeTopic(String topic) throws XWikiException\n    {\n        return includeTopic(topic, true);\n    }\n\n    /**\n     * API to execute a form in the context of an including topic The rendering is evaluated in the context of the\n     * including topic All velocity variables are the one of the including topic This api is usually called using\n     * #includeForm in a page, which modifies the behavior of \"Edit this page\" button to direct for Form mode (inline)\n     *\n     * @param topic page name of the form to execute\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeForm(String topic) throws XWikiException\n    {\n        return includeForm(topic, true);\n    }\n\n    /**\n     * API to include a topic into another, optionally surrounding the content with {pre}{/pre} to avoid future wiki\n     * rendering. The topic is rendered fully in the context of itself.\n     *\n     * @param topic page name of the topic to include\n     * @param pre true to add {pre} {/pre} (only if includer document is 1.0 syntax)\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeTopic(String topic, boolean pre) throws XWikiException\n    {\n        String result = this.xwiki.include(topic, false, getXWikiContext());\n\n        if (pre) {\n            String includerSyntax = this.xwiki.getCurrentContentSyntaxId(null, this.context);\n\n            if (includerSyntax != null && Syntax.XWIKI_1_0.toIdString().equals(includerSyntax)) {\n                result = \"{pre}\" + result + \"{/pre}\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * API to execute a form in the context of an including topic, optionnaly surrounding the content with {pre}{/pre}\n     * to avoid future wiki rendering The rendering is evaluated in the context of the including topic All velocity\n     * variables are the one of the including topic This api is usually called using #includeForm in a page, which\n     * modifies the behavior of \"Edit this page\" button to direct for Form mode (inline).\n     *\n     * @param topic page name of the form to execute\n     * @param pre true to add {pre} {/pre} (only if includer document is 1.0 syntax)\n     * @return the content of the included page\n     * @throws XWikiException if the include failed\n     */\n    public String includeForm(String topic, boolean pre) throws XWikiException\n    {\n        String result = this.xwiki.include(topic, true, getXWikiContext());\n\n        if (pre) {\n            String includerSyntax = this.xwiki.getCurrentContentSyntaxId(null, this.context);\n\n            if (includerSyntax != null && Syntax.XWIKI_1_0.toIdString().equals(includerSyntax)) {\n                result = \"{pre}\" + result + \"{/pre}\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * API to check rights on the current document for the current user\n     *\n     * @param level right to check (view, edit, comment, delete)\n     * @return true if right is granted/false if not\n     */\n    public boolean hasAccessLevel(String level)\n    {\n        return hasAccessLevel(level, getXWikiContext().getUser(), getXWikiContext().getDoc().getFullName());\n    }\n\n    /**\n     * API to check rights on a document for a given user\n     *\n     * @param level right to check (view, edit, comment, delete)\n     * @param user user for which to check the right\n     * @param docname document on which to check the rights\n     * @return true if right is granted/false if not\n     */\n    public boolean hasAccessLevel(String level, String user, String docname)\n    {\n        try {\n            return this.xwiki.getRightService().hasAccessLevel(level, user, docname, getXWikiContext());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * API to list all spaces in the current wiki.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @return a list of string representing all non-hidden spaces (ie spaces that have non-hidden pages) for the\n     *         current wiki\n     * @throws XWikiException if something went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaces() throws XWikiException\n    {\n        return this.xwiki.getSpaces(getXWikiContext());\n    }\n\n    /**\n     * API to list all documents in a space.\n     * <p>\n     * Hidden spaces are filtered unless current user enabled them.\n     *\n     * @param spaceReference the local reference of the space for which to return all non-hidden documents\n     * @return the list of document names (in the format {@code Space.Page}) for non-hidden documents in the specified\n     *         space\n     * @throws XWikiException if the loading went wrong\n     * @deprecated use query service instead\n     */\n    @Deprecated\n    public List<String> getSpaceDocsName(String spaceReference) throws XWikiException\n    {\n        return this.xwiki.getSpaceDocsName(spaceReference, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the current encoding of the wiki engine The encoding is stored in xwiki.cfg Default encoding is\n     * ISO-8891-1\n     *\n     * @return encoding active in this wiki\n     */\n    public String getEncoding()\n    {\n        return this.xwiki.getEncoding();\n    }\n\n    /**\n     * API to retrieve the URL of an attached file in a Wiki Document The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment) It\n     * is important to always use the URL functions to generate URL and never hardcode URLs\n     *\n     * @param fullname page name which includes the attached file\n     * @param filename attached filename to create a link for\n     * @return a URL as a string pointing to the filename\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getAttachmentURL(String fullname, String filename) throws XWikiException\n    {\n        if (StringUtils.isAnyEmpty(fullname, filename)) {\n            return \"\";\n        }\n\n        return this.xwiki.getAttachmentURL(fullname, filename, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in view mode The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment) It\n     * is important to always use the URL functions to generate URL and never hardcode URLs\n     *\n     * @param fullname the name of the document for which to return the URL for\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, \"view\", getXWikiContext());\n    }\n\n    /**\n     * Retrieve the URL of an entity using the default mode/action for that entity type. The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..). The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. For compatibility with any target environment (and especially the\n     * portlet environment) it is important to always use the URL functions to generate URLs and never hardcode URLs.\n     *\n     * @param reference the reference to the entity for which to return the URL\n     * @return a URL as a string pointing to the specified entity, using the default mode/action for that entity type\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an entity in any mode, optionally adding a query string The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The query string will be modified to be added in the way the\n     * environment needs it. It is important to not add the query string parameter manually after a URL. Some\n     * environments will not accept this (like the Portlet environment).\n     *\n     * @param reference the reference to the entity for which to return the URL for\n     * @param action the mode in which to access the entity (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @return a URL as a string pointing to the entity\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 7.2M1\n     */\n    public String getURL(EntityReference reference, String action, String querystring) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, action, querystring, null, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in view mode The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment) It\n     * is important to always use the URL functions to generate URL and never hardcode URLs\n     *\n     * @param reference the reference to the document for which to return the URL for\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 2.3M2\n     */\n    public String getURL(DocumentReference reference) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, \"view\", getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in any mode. The URL is generated differently depending on the\n     * environment (Servlet, Portlet, PDF, etc..). The URL generation can be modified by implementing a new\n     * XWikiURLFactory object For compatibility with any target environment (and especially the portlet environment). It\n     * is important to always use the URL functions to generate URL and never hardcode URLs.\n     *\n     * @param fullname the page name which includes the attached file\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible.\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname, String action) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, action, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of a Wiki Document in any mode, optionally adding a query string The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The query string will be modified to be added in the way the\n     * environment needs it. It is important to not add the query string parameter manually after a URL. Some\n     * environments will not accept this (like the Portlet environment).\n     *\n     * @param fullname the page name which includes the attached file\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname, String action, String querystring) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, action, querystring, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of a Wiki Document in any mode, optionally adding a query string The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The query string will be modified to be added in the way the\n     * environment needs it. It is important to not add the query string parameter manually after a URL. Some\n     * environments will not accept this (like the Portlet environment).\n     *\n     * @param reference the reference to the document for which to return the URL for\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     * @since 3.0M3\n     */\n    public String getURL(DocumentReference reference, String action, String querystring) throws XWikiException\n    {\n        return this.xwiki.getURL(reference, action, querystring, null, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve the URL of an a Wiki Document in any mode, optionally adding an anchor. The URL is generated\n     * differently depending on the environment (Servlet, Portlet, PDF, etc..) The URL generation can be modified by\n     * implementing a new XWikiURLFactory object. The anchor will be modified to be added in the way the environment\n     * needs it. It is important to not add the anchor parameter manually after a URL. Some environments will not accept\n     * this (like the Portlet environment).\n     *\n     * @param fullname the page name which includes the attached file\n     * @param action the mode in which to access the document (view/edit/save/..). Any valid XWiki action is possible\n     * @param querystring the Query String to provide in the usual mode ({@code name1=value1&name2=value=2}) including\n     *            encoding\n     * @param anchor the anchor that points at a location within the passed document name\n     * @return a URL as a string pointing to the wiki document in view mode\n     * @throws XWikiException if the URL could not be generated properly\n     */\n    public String getURL(String fullname, String action, String querystring, String anchor) throws XWikiException\n    {\n        return this.xwiki.getURL(fullname, action, querystring, anchor, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a viewable referer text for a referer Referers are URL where users have clicked on a link to an\n     * XWiki page Search engine referer URLs are transformed to a nicer view (Google: search query string) For other URL\n     * the http:// part is stripped\n     *\n     * @param referer referer URL to transform\n     * @return A viewable string\n     */\n    public String getRefererText(String referer)\n    {\n        try {\n            return this.xwiki.getRefererText(referer, getXWikiContext());\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * API to retrieve a viewable referer text for a referer with a maximum length Referers are URL where users have\n     * clicked on a link to an XWiki page Search engine referer URLs are transformed to a nicer view (Google: search\n     * query string) For other URL the http:// part is stripped\n     *\n     * @param referer referer URL to transform\n     * @param length Maximum length. \"...\" is added to the end of the text\n     * @return A viewable string\n     */\n    public String getShortRefererText(String referer, int length)\n    {\n        try {\n            return this.xwiki.getRefererText(referer, getXWikiContext()).substring(0, length);\n        } catch (Exception e) {\n            return this.xwiki.getRefererText(referer, getXWikiContext());\n        }\n    }\n\n    /**\n     * Generate and return an unescaped user display name.\n     *\n     * @param userReference the user reference\n     * @return the unescaped display user name\n     * @since 6.4RC1\n     */\n    public String getPlainUserName(DocumentReference userReference)\n    {\n        return this.xwiki.getPlainUserName(userReference, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed for the first name and last name of the user. The link\n     * will link to the page on the wiki where the user is registered\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user)\n    {\n        return this.xwiki.getUserName(user, null, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed with a custom view. The link will link to the page on the\n     * wiki where the user is registered. The formating is done using the format parameter which can contain velocity\n     * scripting and access all properties of the User profile using variables ($first_name $last_name $email $city)\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user, String format)\n    {\n        return this.xwiki.getUserName(user, format, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed for the first name and last name of the user. The link\n     * will link to the page on the local wiki even if the user is registered on a different wiki.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), null, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, null, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to retrieve a link to the User Name page displayed with a custom view. The link will link to the page on the\n     * local wiki even if the user is registered on a different wiki. The formating is done using the format parameter\n     * which can contain velocity scripting and access all properties of the User profile using variables ($first_name\n     * $last_name $email $city)\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user, String format)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), format, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, format, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to retrieve a text representing the user with the first name and last name of the user. With the link param\n     * set to false it will not link to the user page With the link param set to true, the link will link to the page on\n     * the wiki where the user was registered.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user, boolean link)\n    {\n        return this.xwiki.getUserName(user, null, link, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a text representing the user with a custom view With the link param set to false it will not link\n     * to the user page. With the link param set to true, the link will link to the page on the wiki where the user was\n     * registered. The formating is done using the format parameter which can contain velocity scripting and access all\n     * properties of the User profile using variables ($first_name $last_name $email $city)\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getUserName(String user, String format, boolean link)\n    {\n        return this.xwiki.getUserName(user, format, link, getXWikiContext());\n    }\n\n    /**\n     * API to retrieve a text representing the user with the first name and last name of the user. With the link param\n     * set to false it will not link to the user page. With the link param set to true, the link will link to the page\n     * on the local wiki even if the user is registered on a different wiki.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user, boolean link)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), null, link, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, null, link, getXWikiContext());\n        }\n    }\n\n    /**\n     * API to retrieve a text representing the user with a custom view. The formating is done using the format parameter\n     * which can contain velocity scripting and access all properties of the User profile using variables ($first_name\n     * $last_name $email $city). With the link param set to false it will not link to the user page. With the link param\n     * set to true, the link will link to the page on the local wiki even if the user is registered on a different wiki.\n     *\n     * @param user Fully qualified username as retrieved from $xcontext.user (XWiki.LudovicDubost)\n     * @param format formatting to be used (\"$first_name $last_name\", \"$first_name\")\n     * @param link false to not add an HTML link to the user profile\n     * @return The first name and last name fields surrounded with a link to the user page\n     */\n    public String getLocalUserName(String user, String format, boolean link)\n    {\n        try {\n            return this.xwiki.getUserName(user.substring(user.indexOf(\":\") + 1), format, link, getXWikiContext());\n        } catch (Exception e) {\n            return this.xwiki.getUserName(user, format, link, getXWikiContext());\n        }\n    }\n\n    public User getUser()\n    {\n        return this.xwiki.getUser(getXWikiContext());\n    }\n\n    public User getUser(String username)\n    {\n        return this.xwiki.getUser(username, getXWikiContext());\n    }\n\n    /**\n     * Retrieve a user from its document reference.\n     *\n     * @param userReference the reference of the user.\n     * @return the user corresponding to the reference.\n     * @since 11.8RC1\n     */\n    public User getUser(DocumentReference userReference)\n    {\n        return this.xwiki.getUser(userReference, getXWikiContext());\n    }\n\n    /**\n     * API allowing to format a date according to the default Wiki setting The date format is provided in the\n     * 'dateformat' parameter of the XWiki Preferences\n     *\n     * @param date date object to format\n     * @return A string with the date formating from the default Wiki setting\n     */\n    public String formatDate(Date date)\n    {\n        return this.xwiki.formatDate(date, null, getXWikiContext());\n    }\n\n    /**\n     * API allowing to format a date according to a custom format The date format is from java.text.SimpleDateFormat\n     * Example: \"dd/MM/yyyy HH:mm:ss\" or \"d MMM yyyy\" If the format is invalid the default format will be used to show\n     * the date\n     *\n     * @param date date to format\n     * @param format format of the date to be used\n     * @return the formatted date\n     * @see java.text.SimpleDateFormat\n     */\n    public String formatDate(Date date, String format)\n    {\n        return this.xwiki.formatDate(date, format, getXWikiContext());\n    }\n\n    /*\n     * Allow to read user setting providing the user timezone All dates will be expressed with this timezone @return the\n     * timezone\n     */\n    public String getUserTimeZone()\n    {\n        return this.xwiki.getUserTimeZone(this.context);\n    }\n\n    /**\n     * Returns a plugin from the plugin API. Plugin Rights can be verified. Note that although this API is a duplicate\n     * of {@link #getPlugin(String)} it used to provide an easy access from Velocity to XWiki plugins. Indeed Velocity\n     * has a feature in that if a class has a get method, using the dot notation will automatically call the get method\n     * for the class. See http://velocity.apache.org/engine/releases/velocity-1.5/user-guide.html#propertylookuprules.\n     * This this allows the following constructs: <code>$xwiki.pluginName.somePluginMethod()</code>\n     *\n     * @param name Name of the plugin to retrieve (either short of full class name)\n     * @return a plugin object\n     */\n    public Api get(String name)\n    {\n        return getPlugin(name);\n    }\n\n    /**\n     * Returns a plugin from the plugin API. Plugin Rights can be verified.\n     *\n     * @param name Name of the plugin to retrieve (either short of full class name)\n     * @return a plugin object\n     */\n    public Api getPlugin(String name)\n    {\n        return this.xwiki != null ? this.xwiki.getPluginApi(name, getXWikiContext()) : null;\n    }\n\n    /**\n     * Returns the Advertisement system from the preferences\n     *\n     * @return \"google\" or \"none\"\n     */\n    public String getAdType()\n    {\n        return this.xwiki.getAdType(getXWikiContext());\n    }\n\n    /**\n     * Returns the Advertisement client ID from the preferences\n     *\n     * @return an Ad affiliate ID\n     */\n    public String getAdClientId()\n    {\n        return this.xwiki.getAdClientId(getXWikiContext());\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL protected using Basic Authentication\n     *\n     * @param surl url to retrieve\n     * @param username username for the basic authentication\n     * @param password password for the basic authentication\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl, String username, String password) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, username, password, this.context);\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to retrieve content from [\" + surl + \"]\", e);\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL\n     *\n     * @param surl url to retrieve\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, this.context);\n        } catch (Exception e) {\n            LOGGER.warn(\"Failed to retrieve content from [\" + surl + \"]\", e);\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL protected using Basic Authentication\n     *\n     * @param surl url to retrieve\n     * @param username username for the basic authentication\n     * @param password password for the basic authentication\n     * @param timeout manuel timeout in milliseconds\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl, String username, String password, int timeout) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, username, password, timeout,\n                this.xwiki.getHttpUserAgent(this.context));\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL\n     *\n     * @param surl url to retrieve\n     * @param timeout manuel timeout in milliseconds\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public String getURLContent(String surl, int timeout) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return \"\";\n        }\n\n        try {\n            return this.xwiki.getURLContent(surl, timeout, this.xwiki.getHttpUserAgent(this.context));\n        } catch (Exception e) {\n            return \"\";\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL protected using Basic Authentication as Bytes\n     *\n     * @param surl url to retrieve\n     * @param username username for the basic authentication\n     * @param password password for the basic authentication\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public byte[] getURLContentAsBytes(String surl, String username, String password) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return null;\n        }\n\n        try {\n            return this.xwiki.getURLContentAsBytes(surl, username, password, this.context);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the content of an HTTP/HTTPS URL as Bytes\n     *\n     * @param surl url to retrieve\n     * @return Content of the specified URL\n     * @throws IOException\n     */\n    @Programming\n    public byte[] getURLContentAsBytes(String surl) throws IOException\n    {\n        if (!hasProgrammingRights()) {\n            return null;\n        }\n\n        try {\n            return this.xwiki.getURLContentAsBytes(surl, this.context);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the list of Macros documents in the specified content\n     *\n     * @param defaultSpace Default space to use for relative path names\n     * @param content Content to parse\n     * @return ArrayList of document names\n     */\n    public List<String> getIncludedMacros(String defaultSpace, String content)\n    {\n        return this.xwiki.getIncludedMacros(defaultSpace, content, getXWikiContext());\n    }\n\n    /**\n     * returns true if xwiki.readonly is set in the configuration file\n     *\n     * @return the value of xwiki.isReadOnly()\n     * @see com.xpn.xwiki.XWiki\n     */\n    public boolean isReadOnly()\n    {\n        return this.xwiki.isReadOnly();\n    }\n\n    /**\n     * Privileged API to set/unset the readonly status of the Wiki After setting this to true no writing to the database\n     * will be performed All Edit buttons will be removed and save actions disabled This is used for maintenance\n     * purposes\n     *\n     * @param ro true to set read-only mode/false to unset\n     */\n    public void setReadOnly(boolean ro)\n    {\n        if (hasAdminRights()) {\n            this.xwiki.setReadOnly(ro);\n        }\n    }\n\n    /**\n     * Priviledge API to regenerate the links/backlinks table Normally links and backlinks are stored when a page is\n     * modified This function will regenerate all the backlinks This function can be long to run\n     *\n     * @throws XWikiException exception if the generation fails\n     */\n    public void refreshLinks() throws XWikiException\n    {\n        if (hasAdminRights()) {\n            this.xwiki.refreshLinks(getXWikiContext());\n        }\n    }\n\n    /**\n     * API to check if the backlinks feature is active Backlinks are activated in xwiki.cfg or in the XWiki Preferences\n     *\n     * @return true if the backlinks feature is active\n     * @throws XWikiException exception if the preference could not be retrieved\n     */\n    public boolean hasBacklinks() throws XWikiException\n    {\n        return this.xwiki.hasBacklinks(getXWikiContext());\n    }\n\n    /**\n     * API to check if the tags feature is active. Tags are activated in xwiki.cfg or in the XWiki Preferences\n     *\n     * @return true if the tags feature is active, false otherwise\n     * @throws XWikiException exception if the preference could not be retrieved\n     */\n    public boolean hasTags() throws XWikiException\n    {\n        return this.xwiki.hasTags(getXWikiContext());\n    }\n\n    /**\n     * API to check if the edit comment feature is active Edit comments are activated in xwiki.cfg or in the XWiki\n     * Preferences\n     *\n     * @return\n     */\n    public boolean hasEditComment()\n    {\n        return this.xwiki.hasEditComment(this.context);\n    }\n\n    /**\n     * API to check if the edit comment field is shown in the edit form Edit comments are activated in xwiki.cfg or in\n     * the XWiki Preferences\n     *\n     * @return\n     */\n    public boolean isEditCommentFieldHidden()\n    {\n        return this.xwiki.isEditCommentFieldHidden(this.context);\n    }\n\n    /**\n     * API to check if the edit comment is suggested (prompted once by Javascript if empty) Edit comments are activated\n     * in xwiki.cfg or in the XWiki Preferences\n     *\n     * @return\n     */\n    public boolean isEditCommentSuggested()\n    {\n        return this.xwiki.isEditCommentSuggested(this.context);\n    }\n\n    /**\n     * API to check if the edit comment is mandatory (prompted by Javascript if empty) Edit comments are activated in\n     * xwiki.cfg or in the XWiki Preferences\n     *\n     * @return\n     */\n    public boolean isEditCommentMandatory()\n    {\n        return this.xwiki.isEditCommentMandatory(this.context);\n    }\n\n    /**\n     * API to check if the minor edit feature is active minor edit is activated in xwiki.cfg or in the XWiki Preferences\n     */\n    public boolean hasMinorEdit()\n    {\n        return this.xwiki.hasMinorEdit(this.context);\n    }\n\n    /**\n     * API to check if the recycle bin feature is active recycle bin is activated in xwiki.cfg or in the XWiki\n     * Preferences\n     */\n    public boolean hasRecycleBin()\n    {\n        return this.xwiki.hasRecycleBin(this.context);\n    }\n\n    /**\n     * Retrieves the current editor preference for the request The preference is first looked up in the user preference\n     * and then in the space and wiki preference\n     *\n     * @return \"wysiwyg\" or \"text\"\n     */\n    public String getEditorPreference()\n    {\n        return this.xwiki.getEditorPreference(getXWikiContext());\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String. Note that Groovy scripts\n     * compilation is cached.\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public java.lang.Object parseGroovyFromString(String script) throws XWikiException\n    {\n        if (hasProgrammingRights()) {\n            return this.xwiki.parseGroovyFromString(script, getXWikiContext());\n        }\n        return \"groovy_missingrights\";\n    }\n\n    /**\n     * Privileged API to retrieve an object instantiated from groovy code in a String, using a classloader including all\n     * JAR files located in the passed page as attachments. Note that Groovy scripts compilation is cached\n     *\n     * @param script the Groovy class definition string (public class MyClass { ... })\n     * @return An object instantiating this class\n     * @throws XWikiException\n     */\n    public java.lang.Object parseGroovyFromPage(String script, String jarWikiPage) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(script, getXWikiContext());\n        if (this.xwiki.getRightService().hasProgrammingRights(doc, getXWikiContext())) {\n            return this.xwiki.parseGroovyFromString(doc.getContent(), jarWikiPage, getXWikiContext());\n        }\n        return \"groovy_missingrights\";\n    }\n\n    /**\n     * Privileged API to retrieve an object instanciated from groovy code in a String Groovy scripts compilation is\n     * cached\n     *\n     * @param fullname // script containing a Groovy class definition (public class MyClass { ... })\n     * @return An object instanciating this class\n     * @throws XWikiException\n     */\n    public java.lang.Object parseGroovyFromPage(String fullname) throws XWikiException\n    {\n        XWikiDocument doc = this.xwiki.getDocument(fullname, getXWikiContext());\n        if (this.xwiki.getRightService().hasProgrammingRights(doc, getXWikiContext())) {\n            return this.xwiki.parseGroovyFromString(doc.getContent(), getXWikiContext());\n        }\n        return \"groovy_missingrights\";\n    }\n\n    /**\n     * API to get the macro list from the XWiki Preferences The macro list are the macros available from the Macro\n     * Mapping System\n     *\n     * @return String with each macro on each line\n     */\n    public String getMacroList()\n    {\n        return this.xwiki.getMacroList(getXWikiContext());\n    }\n\n    /**\n     * API to check if using which toolbars in Wysiwyg editor\n     *\n     * @return a string value\n     */\n    public String getWysiwygToolbars()\n    {\n        return this.xwiki.getWysiwygToolbars(getXWikiContext());\n    }\n\n    /**\n     * API to create an object from the request The parameters are the ones that are created from\n     * doc.display(\"field\",\"edit\") calls\n     *\n     * @param className XWiki Class Name to create the object from\n     * @return a BaseObject wrapped in an Object\n     * @throws XWikiException exception if the object could not be read\n     */\n    public com.xpn.xwiki.api.Object getObjectFromRequest(String className) throws XWikiException\n    {\n        return new com.xpn.xwiki.api.Object(this.xwiki.getObjectFromRequest(className, getXWikiContext()),\n            getXWikiContext());\n    }\n\n    /**\n     * API to create an empty document\n     *\n     * @return an XWikiDocument wrapped in a Document\n     */\n    public Document createDocument()\n    {\n        return new XWikiDocument().newDocument(getXWikiContext());\n    }\n\n    /**\n     * API to convert the username depending on the configuration The username can be converted from email to a valid\n     * XWiki page name hidding the email address The username can be then used to login and link to the right user page\n     *\n     * @param username username to use for login\n     * @return converted wiki page name for this username\n     */\n    public String convertUsername(String username)\n    {\n        return this.xwiki.convertUsername(username, getXWikiContext());\n    }\n\n    /**\n     * API to get the Property object from a class based on a property path A property path looks like\n     * XWiki.ArticleClass_fieldname\n     *\n     * @param propPath Property path\n     * @return a PropertyClass object from a BaseClass object\n     */\n    public com.xpn.xwiki.api.PropertyClass getPropertyClassFromName(String propPath)\n    {\n        return new PropertyClass(this.xwiki.getPropertyClassFromName(propPath, getXWikiContext()), getXWikiContext());\n    }\n\n    /**\n     * Generates a unique page name based on initial page name and already existing pages\n     *\n     * @param name\n     * @return a unique page name\n     */\n    public String getUniquePageName(String name)\n    {\n        return this.xwiki.getUniquePageName(name, getXWikiContext());\n    }\n\n    /**\n     * Generates a unique page name based on initial page name and already existing pages\n     *\n     * @param space\n     * @param name\n     * @return a unique page name\n     */\n    public String getUniquePageName(String space, String name)\n    {\n        return this.xwiki.getUniquePageName(space, name, getXWikiContext());\n    }\n\n    /**\n     * Inserts a tooltip using toolTip.js\n     *\n     * @param html HTML viewed\n     * @param message HTML Tooltip message\n     * @param params Parameters in Javascropt added to the tooltip config\n     * @return HTML with working tooltip\n     */\n    public String addTooltip(String html, String message, String params)\n    {\n        return this.xwiki.addTooltip(html, message, params, getXWikiContext());\n    }\n\n    /**\n     * Inserts a tooltip using toolTip.js\n     *\n     * @param html HTML viewed\n     * @param message HTML Tooltip message\n     * @return HTML with working tooltip\n     */\n    public String addTooltip(String html, String message)\n    {\n        return this.xwiki.addTooltip(html, message, getXWikiContext());\n    }\n\n    /**\n     * Inserts the tooltip Javascript\n     *\n     * @return\n     */\n    public String addTooltipJS()\n    {\n        return this.xwiki.addTooltipJS(getXWikiContext());\n    }\n\n    /*\n     * Inserts a Mandatory asterix\n     */\n    public String addMandatory()\n    {\n        return this.xwiki.addMandatory(getXWikiContext());\n    }\n\n    /**\n     * Get the XWiki Class object defined in the passed Document name.\n     * <p>\n     * Note: This method doesn't require any rights for accessing the passed Document (as opposed to the\n     * {@link com.xpn.xwiki.api.Document#getClass()} method which does require to get a Document object first. This is\n     * thus useful in cases where the calling code doesn't have the access right to the specified Document. It is safe\n     * because there are no sensitive data stored in a Class definition.\n     * </p>\n     *\n     * @param documentName the name of the document for which to get the Class object. For example\n     *            \"XWiki.XWikiPreferences\"\n     * @return the XWiki Class object defined in the passed Document name. If the passed Document name points to a\n     *         Document with no Class defined then an empty Class object is returned (i.e. a Class object with no\n     *         properties).\n     * @throws XWikiException if the passed document name doesn't point to a valid Document\n     */\n    public Class getClass(String documentName) throws XWikiException\n    {\n        // TODO: The implementation should be done in com.xpn.xwiki.XWiki as this class should\n        // delegate all implementations to that Class.\n        DocumentReference docReference = getCurrentMixedDocumentReferenceResolver().resolve(documentName);\n        return getClass(docReference);\n    }\n\n    /**\n     * Get the XWiki Class object defined in the passed Document name.\n     * <p>\n     * Note: This method doesn't require any rights for accessing the passed Document (as opposed to the\n     * {@link com.xpn.xwiki.api.Document#getClass()} method which does require to get a Document object first. This is\n     * thus useful in cases where the calling code doesn't have the access right to the specified Document. It is safe\n     * because there are no sensitive data stored in a Class definition.\n     * </p>\n     *\n     * @param docReference the reference of the document for which to get the Class object.\n     * @return the XWiki Class object defined in the passed Document reference. If the passed Document name points to a\n     *         Document with no Class defined then an empty Class object is returned (i.e. a Class object with no\n     *         properties).\n     * @throws XWikiException if the reference doesn't exist.\n     * @since 10.11.10\n     * @since 11.8RC1\n     * @since 11.3.4\n     */\n    public Class getClass(EntityReference docReference) throws XWikiException\n    {\n        return new Class(this.xwiki.getDocument(docReference, this.context).getXClass(), this.context);\n    }\n\n    /**\n     * Provides an absolute counter\n     *\n     * @param name Counter name\n     * @return String\n     */\n    public String getCounter(String name)\n    {\n        XWikiEngineContext econtext = this.context.getEngineContext();\n        Integer counter = (Integer) econtext.getAttribute(name);\n        if (counter == null) {\n            counter = 0;\n        }\n        counter = counter.intValue() + 1;\n        econtext.setAttribute(name, counter);\n\n        return counter.toString();\n    }\n\n    /**\n     * Check authentication from request and set according persitent login information If it fails user is unlogged\n     *\n     * @return null if failed, non null XWikiUser if sucess\n     * @throws XWikiException\n     */\n    public XWikiUser checkAuth() throws XWikiException\n    {\n        return this.context.getWiki().checkAuth(this.context);\n    }\n\n    /**\n     * Check authentication from username and password and set according persitent login information If it fails user is\n     * unlogged\n     *\n     * @param username username to check\n     * @param password password to check\n     * @param rememberme \"1\" if you want to remember the login accross navigator restart\n     * @return null if failed, non null XWikiUser if sucess\n     * @throws XWikiException\n     */\n    public XWikiUser checkAuth(String username, String password, String rememberme) throws XWikiException\n    {\n        XWikiUser user =\n            this.context.getWiki().getAuthService().checkAuth(username, password, rememberme, this.context);\n        if (user.isDisabled(this.context)) {\n            this.context.put(XWikiContext.INACTIVE_USER_REFERENCE, user.getUserReference());\n            user = null;\n        }\n        return user;\n    }\n\n    /**\n     * Access statistics api\n     *\n     * @return a StatsService instance that can be used to retrieve different xwiki statistics\n     */\n    public StatsService getStatsService()\n    {\n        return this.statsService;\n    }\n\n    /**\n     * API to get the xwiki criteria service which allow to create various criteria : integer ranges, date periods, date\n     * intervals, etc.\n     *\n     * @return the xwiki criteria service\n     */\n    public CriteriaService getCriteriaService()\n    {\n        return this.criteriaService;\n    }\n\n    /**\n     * API to get the Servlet path for a given wiki. In mono wiki this is \"bin/\" or \"xwiki/\". In virtual mode and if\n     * {@code xwiki.virtual.usepath} is enabled in xwiki.cfg, it is \"wiki/wikiname/\".\n     *\n     * @param wikiName wiki for which to get the path\n     * @return The servlet path\n     */\n    public String getServletPath(String wikiName)\n    {\n        return this.xwiki.getServletPath(wikiName, this.context);\n    }\n\n    /**\n     * API to get the Servlet path for the current wiki. In mono wiki this is \"bin/\" or \"xwiki/\". In virtual mode and if\n     * {@code xwiki.virtual.usepath} is enabled in xwiki.cfg, it is \"wiki/wikiname/\".\n     *\n     * @return The servlet path\n     */\n    public String getServletPath()\n    {\n        return this.xwiki.getServletPath(this.context.getWikiId(), this.context);\n    }\n\n    /**\n     * API to get the webapp path for the current wiki. This usually is \"xwiki/\". It can be configured in xwiki.cfg with\n     * the config {@code xwiki.webapppath}.\n     *\n     * @return The servlet path\n     */\n    public String getWebAppPath()\n    {\n        return this.xwiki.getWebAppPath(this.context);\n    }\n\n    /**\n     * @return the syntax id of the syntax to use when creating new documents.\n     */\n    public String getDefaultDocumentSyntax()\n    {\n        return this.xwiki.getDefaultDocumentSyntax();\n    }\n\n    /**\n     * Find the corresponding available renderer syntax.\n     * <p>\n     * If <code>syntaxVersion</code> is null the last version of the available provided syntax type is returned.\n     *\n     * @param syntaxType the syntax type\n     * @param syntaxVersion the syntax version\n     * @return the available corresponding {@link Syntax}. Null if no available renderer can be found.\n     */\n    public Syntax getAvailableRendererSyntax(String syntaxType, String syntaxVersion)\n    {\n        Syntax syntax = null;\n\n        try {\n            List<PrintRendererFactory> factories =\n                Utils.getContextComponentManager().getInstanceList((Type) PrintRendererFactory.class);\n            for (PrintRendererFactory factory : factories) {\n                Syntax factorySyntax = factory.getSyntax();\n                if (syntaxVersion != null) {\n                    if (factorySyntax.getType().getId().equalsIgnoreCase(syntaxType)\n                        && factorySyntax.getVersion().equals(syntaxVersion)) {\n                        syntax = factorySyntax;\n                        break;\n                    }\n                } else {\n                    // TODO: improve version comparaison since it does not work when comparing 2.0 and 10.0 for example.\n                    // We\n                    // should have a Version which implements Comparable like we have SyntaxId in Syntax\n                    if (factorySyntax.getType().getId().equalsIgnoreCase(syntaxType)\n                        && (syntax == null || factorySyntax.getVersion().compareTo(syntax.getVersion()) > 0)) {\n                        syntax = factorySyntax;\n                    }\n                }\n            }\n        } catch (ComponentLookupException e) {\n            LOGGER.error(\"Failed to lookup available renderer syntaxes\", e);\n        }\n\n        return syntax;\n    }\n\n    /**\n     * @return true if section editing is enabled (can be configured through the {@code xwiki.section.edit}\n     *         configuration property. Defaults to 1 (=enabled) when not defined\n     */\n    public boolean hasSectionEdit()\n    {\n        return this.xwiki.hasSectionEdit(getXWikiContext());\n    }\n\n    /**\n     * @return the section depth for which section editing is available (can be configured through\n     *         {@code xwiki.section.depth} configuration property. Defaults to 2 when not defined\n     */\n    public long getSectionEditingDepth()\n    {\n        return this.xwiki.getSectionEditingDepth();\n    }\n\n    /**\n     * @return true if title handling should be using the compatibility mode or not. When the compatibility mode is\n     *         active, if the document's content first header (level 1 or level 2) matches the document's title the\n     *         first header is stripped.\n     */\n    public boolean isTitleInCompatibilityMode()\n    {\n        return this.xwiki.isTitleInCompatibilityMode();\n    }\n\n    /**\n     * Get the syntax of the content currently being executed.\n     * <p>\n     * The document currently being executed is not the same than the actual content syntax since the executed code\n     * might come from an included page or some macro that change the context syntax. The same logic used inside\n     * rendering macros is used (see {@link org.xwiki.rendering.macro.MacroContentParser}).\n     * <p>\n     * If the current document can't be found, the method assume that the executed document is the context document\n     * (it's generally the case when a document is directly rendered with\n     * {@link XWikiDocument#getRenderedContent(XWikiContext)} for example).\n     *\n     * @return the syntax identifier\n     */\n    public String getCurrentContentSyntaxId()\n    {\n        return this.xwiki.getCurrentContentSyntaxId(getXWikiContext());\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.user.api;\n\nimport java.util.Collection;\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.model.reference.LocalDocumentReference;\nimport org.xwiki.model.reference.WikiReference;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.web.Utils;\n\npublic class XWikiUser\n{\n    /**\n     * Class used to store user properties.\n     */\n    private static final String USER_CLASS = \"XWiki.XWikiUsers\";\n\n    /**\n     * The name of the property that store the active status of the user.\n     * \n     * @since 11.8RC1\n     */\n    public static final String ACTIVE_PROPERTY = \"active\";\n\n    /**\n     * The name of the property that store the information if an email was checked for the user.\n     * \n     * @since 11.8RC1\n     */\n    public static final String EMAIL_CHECKED_PROPERTY = \"email_checked\";\n\n    public static final LocalDocumentReference ACCOUNT_VALIDATION_DOCUMENT_REFERENCE =\n        new LocalDocumentReference(XWiki.SYSTEM_SPACE, \"AccountValidation\");\n\n    /**\n     * @see com.xpn.xwiki.internal.model.reference.CurrentMixedStringDocumentReferenceResolver\n     */\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    private EntityReferenceSerializer<String> localEntityReferenceSerializer;\n\n    private ContextualLocalizationManager localization;\n\n    private Logger logger = LoggerFactory.getLogger(XWikiUser.class);\n\n    private String fullName;\n\n    private boolean fullNameNull;\n\n    private DocumentReference userReference;\n\n    private boolean userReferenceSet;\n\n    private boolean main;\n\n    /**\n     * Create a XWikiUser from its document reference and infer if the user is global or not based on the wiki part of\n     * this reference. See {@link #isMain()} for more information.\n     * \n     * @param userReference the document reference of the user.\n     * @since 11.6RC1\n     */\n    public XWikiUser(DocumentReference userReference)\n    {\n        this(userReference,\n            userReference == null || XWiki.DEFAULT_MAIN_WIKI.equals(userReference.getWikiReference().getName()));\n    }\n\n    /**\n     * Create a XWikiUser from its document reference and set the main flag. (see {@link #isMain()}).\n     * \n     * @param userReference the document reference of the user.\n     * @param main true if the user is global (i.e. registered in the main wiki)\n     * @since 11.6RC1\n     */\n    public XWikiUser(DocumentReference userReference, boolean main)\n    {\n        this.userReference = userReference;\n        this.userReferenceSet = true;\n\n        setMain(main);\n    }\n\n    /**\n     * Create a XWikiUser for the given user.\n     * \n     * @param user the full name of the user on the form {@code XWiki.Foo}.\n     * @deprecated since 11.6RC1 use {@link #XWikiUser(DocumentReference)}.\n     */\n    @Deprecated\n    public XWikiUser(String user)\n    {\n        this(user, false);\n    }\n\n    /**\n     * Create a XWikiUser for the given user.\n     * \n     * @param user the full name of the user on the form {@code XWiki.Foo}.\n     * @param main true if the user is global (i.e. registered in the main wiki)\n     * @deprecated since 11.6RC1 use {@link #XWikiUser(DocumentReference, boolean)}.\n     */\n    @Deprecated\n    public XWikiUser(String user, boolean main)\n    {\n        setUser(user);\n        setMain(main);\n    }\n\n    private void setUserReference(DocumentReference userReference)\n    {\n        this.userReference = userReference;\n        this.userReferenceSet = true;\n    }\n\n    private String toFullName(DocumentReference userReference)\n    {\n        if (userReference != null) {\n            return getLocalEntityReferenceSerializer().serialize(userReference);\n        } else {\n            return XWikiRightService.GUEST_USER_FULLNAME;\n        }\n    }\n\n    private DocumentReference fromFullName(String fullName)\n    {\n        DocumentReference reference = null;\n\n        if (fullName != null && !fullName.endsWith(XWikiRightService.GUEST_USER_FULLNAME)\n            && !fullName.equals(XWikiRightService.GUEST_USER)) {\n            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);\n        }\n\n        return reference;\n    }\n\n    /**\n     * @return user fullname\n     * @deprecated since 11.6RC1 use {@link #getFullName()}.\n     */\n    @Deprecated\n    public String getUser()\n    {\n        return getFullName();\n    }\n\n    /**\n     * @return the fullname of the user like {@code XWiki.Foo}.\n     */\n    public String getFullName()\n    {\n        if (this.fullName == null && !this.fullNameNull) {\n            this.fullName = toFullName(this.userReference);\n            this.fullNameNull = this.fullName == null;\n        }\n\n        return this.fullName;\n    }\n\n    private DocumentReferenceResolver<String> getCurrentMixedDocumentReferenceResolver()\n    {\n        if (currentMixedDocumentReferenceResolver == null) {\n            currentMixedDocumentReferenceResolver =\n                Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n        }\n        return currentMixedDocumentReferenceResolver;\n    }\n\n    private EntityReferenceSerializer<String> getLocalEntityReferenceSerializer()\n    {\n        if (localEntityReferenceSerializer == null) {\n            localEntityReferenceSerializer = Utils.getComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        }\n        return localEntityReferenceSerializer;\n    }\n\n    private ContextualLocalizationManager getLocalization()\n    {\n        if (this.localization == null) {\n            this.localization = Utils.getComponent(ContextualLocalizationManager.class);\n        }\n\n        return this.localization;\n    }\n\n    private String localizePlainOrKey(String key, Object... parameters)\n    {\n        return StringUtils.defaultString(getLocalization().getTranslationPlain(key, parameters), key);\n    }\n\n    public DocumentReference getUserReference()\n    {\n        if (!this.userReferenceSet) {\n            setUserReference(fromFullName(getUser()));\n        }\n\n        return this.userReference;\n    }\n\n    private DocumentReference getUserClassReference(WikiReference userDocWiki)\n    {\n        return getCurrentMixedDocumentReferenceResolver().resolve(userDocWiki.getName() + \":\" + USER_CLASS);\n    }\n\n    private boolean isGuest()\n    {\n        return XWikiRightService.isGuest(getUserReference());\n    }\n\n    private boolean isSuperAdmin()\n    {\n        return XWikiRightService.isSuperAdmin(getUserReference());\n    }\n\n    private XWikiDocument getUserDocument(XWikiContext context) throws XWikiException\n    {\n        return context.getWiki().getDocument(getUserReference(), context);\n    }\n\n    /**\n     * @param context used to retrieve the user document.\n     * @return true if the user is email have been checked before. This always returns true if the user is the guest or\n     *         superadmin user.\n     * @since 11.8RC1\n     */\n    public boolean isEmailChecked(XWikiContext context)\n    {\n        boolean isChecked;\n        // These users are necessarily active. Note that superadmin might be main-wiki-prefixed when in a subwiki.\n        if (isGuest() || isSuperAdmin()) {\n            isChecked = true;\n        } else {\n            try {\n                XWikiDocument userdoc = getUserDocument(context);\n                DocumentReference userClassReference =\n                    getUserClassReference(userdoc.getDocumentReference().getWikiReference());\n                // Default value of email_checked should be 1 (i.e. checked) if not set.\n                isChecked = userdoc.getIntValue(userClassReference, EMAIL_CHECKED_PROPERTY, 1) != 0;\n            } catch (XWikiException e) {\n                this.logger.error(\"Error while checking email_checked status of user [{}]\", getUser(), e);\n                isChecked = true;\n            }\n        }\n        return isChecked;\n    }\n\n    /**\n     * @param checked true if the email address was checked for the user. False if it wasn't checked.\n     * @param context used to retrieve the user document.\n     * @since 11.8RC1\n     */\n    public void setEmailChecked(boolean checked, XWikiContext context)\n    {\n        // We don't modify any information for guest and superadmin.\n        if (!isGuest() && !isSuperAdmin()) {\n            int checkedFlag = (checked) ? 1 : 0;\n            try {\n                XWikiDocument userdoc = getUserDocument(context);\n                userdoc.setIntValue(getUserClassReference(userdoc.getDocumentReference().getWikiReference()),\n                    EMAIL_CHECKED_PROPERTY, checkedFlag);\n                context.getWiki().saveDocument(userdoc, localizePlainOrKey(\n                    \"core.users.\" + (checked ? \"email_checked\" : \"email_unchecked\") + \".saveComment\"), context);\n            } catch (XWikiException e) {\n                this.logger.error(\"Error while setting email_checked status of user [{}]\", getUser(), e);\n            }\n        }\n    }\n\n    /**\n     * @param context used to retrieve the user document.\n     * @return true if the user is disabled (i.e. its active property is set to 0). This always returns false if the\n     *         user is the guest or superadmin user.\n     * @since 11.6RC1\n     */\n    public boolean isDisabled(XWikiContext context)\n    {\n        boolean disabled;\n        // These users are necessarily active. Note that superadmin might be main-wiki-prefixed when in a subwiki.\n        if (isGuest() || isSuperAdmin()) {\n            disabled = false;\n        } else {\n            try {\n                XWikiDocument userdoc = getUserDocument(context);\n                DocumentReference userClassReference =\n                    getUserClassReference(userdoc.getDocumentReference().getWikiReference());\n                // Default value of active should be 1 (i.e. active) if not set\n                disabled = userdoc.getIntValue(userClassReference, ACTIVE_PROPERTY, 1) == 0;\n            } catch (XWikiException e) {\n                this.logger.error(\"Error while checking active status of user [{}]\", getUser(), e);\n                disabled = false;\n            }\n        }\n        return disabled;\n    }\n\n    /**\n     * @param disable true if the user disabled the account. False to enable the account.\n     * @param context used to retrieve the user document.\n     * @since 11.6RC1\n     */\n    public void setDisabled(boolean disable, XWikiContext context)\n    {\n        // We don't modify any information for guest and superadmin.\n        if (!isGuest() && !isSuperAdmin()) {\n            int activeFlag = (disable) ? 0 : 1;\n            try {\n                XWikiDocument userdoc = getUserDocument(context);\n                userdoc.setIntValue(getUserClassReference(userdoc.getDocumentReference().getWikiReference()),\n                    ACTIVE_PROPERTY, activeFlag);\n                userdoc.setAuthorReference(context.getUserReference());\n                context.getWiki().saveDocument(userdoc,\n                    localizePlainOrKey(\"core.users.\" + (disable ? \"disable\" : \"enable\") + \".saveComment\"), context);\n            } catch (XWikiException e) {\n                this.logger.error(\"Error while setting active status of user [{}]\", getUser(), e);\n            }\n        }\n    }\n\n    /**\n     * @param context used to retrieve the user document.\n     * @return true if the user exists.\n     * @since 11.6RC1\n     */\n    public boolean exists(XWikiContext context)\n    {\n        boolean exists = false;\n        try {\n            XWikiDocument userdoc = getUserDocument(context);\n            exists = !userdoc.isNew();\n        } catch (XWikiException e) {\n            this.logger.error(\"Error while checking existing status of user [{}]\", getUser(), e);\n        }\n        return exists;\n    }\n\n    public void setUser(String user)\n    {\n        this.fullName = user;\n        this.fullNameNull = this.fullName == null;\n\n        this.userReference = null;\n        this.userReferenceSet = false;\n    }\n\n    /**\n     * Check if the user belongs to a group or not. This method only check direct membership (no recursive checking) in\n     * the current wiki.\n     *\n     * @param groupName The group to check.\n     * @param context The current {@link XWikiContext context}.\n     * @return {@code true} if the user does belong to the specified group, false otherwise or if an exception occurs.\n     * @throws XWikiException If an error occurs when checking the groups.\n     * @since 1.3\n     */\n    public boolean isUserInGroup(String groupName, XWikiContext context) throws XWikiException\n    {\n        if (!StringUtils.isEmpty(getUser())) {\n            XWikiGroupService groupService = context.getWiki().getGroupService(context);\n\n            DocumentReference groupReference = getCurrentMixedDocumentReferenceResolver().resolve(groupName);\n\n            Collection<DocumentReference> groups =\n                groupService.getAllGroupsReferencesForMember(getUserReference(), 0, 0, context);\n\n            if (groups.contains(groupReference)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * See if the user is global (i.e. registered in the main wiki) or local to a virtual wiki.\n     *\n     * @return {@code true} if the user is global, false otherwise or if an exception occurs.\n     */\n    public boolean isMain()\n    {\n        return this.main;\n    }\n\n    public void setMain(boolean main)\n    {\n        this.main = main;\n    }\n\n    @Override\n    public String toString()\n    {\n        return getUser();\n    }\n\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (super.equals(obj)) {\n            return true;\n        }\n\n        boolean equals;\n        if (obj instanceof XWikiUser) {\n            XWikiUser otherUser = (XWikiUser) obj;\n\n            equals = otherUser.main == this.main && Objects.equals(getUserReference(), otherUser.getUserReference());\n        } else {\n            equals = false;\n        }\n\n        return equals;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.security.authorization.internal;\n\nimport java.util.HashMap;\nimport java.util.List;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.WikiReference;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.security.internal.XWikiConstants;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.user.api.XWikiRightService;\nimport com.xpn.xwiki.user.api.XWikiUser;\nimport com.xpn.xwiki.web.Utils;\n\n/**\n * Legacy bridge aimed to replace the current RightService until the new API is used in all places.\n * @version $Id$\n * @since 4.0M2\n */\npublic class XWikiCachingRightService implements XWikiRightService\n{\n    /** Logger. */\n    private static final Logger LOGGER = LoggerFactory.getLogger(XWikiCachingRightService.class);\n\n    /** The login action. */\n    private static final String DELETE_ACTION = \"delete\";\n\n    /** The delete action. */\n    private static final String LOGIN_ACTION = \"login\";\n\n    /**\n     * Map containing all known actions.\n     */\n    private static final ActionMap ACTION_MAP = new ActionMap();\n\n    static {\n        ACTION_MAP\n            .putAction(LOGIN_ACTION, Right.LOGIN)\n            .putAction(\"view\", Right.VIEW)\n            .putAction(DELETE_ACTION, Right.DELETE)\n            .putAction(\"distribution\", Right.VIEW)\n            .putAction(\"admin\", Right.ADMIN)\n            .putAction(\"programming\", Right.PROGRAM)\n            .putAction(\"edit\", Right.EDIT)\n            .putAction(\"register\", Right.REGISTER)\n            .putAction(\"logout\", Right.LOGIN)\n            .putAction(\"loginerror\", Right.LOGIN)\n            .putAction(\"loginsubmit\", Right.LOGIN)\n            .putAction(\"viewrev\", Right.VIEW)\n            .putAction(\"viewattachrev\", Right.VIEW)\n            .putAction(\"get\", Right.VIEW)\n            .putAction(\"downloadrev\", Right.VIEW)\n            .putAction(\"plain\", Right.VIEW)\n            .putAction(\"raw\", Right.VIEW)\n            .putAction(\"attach\", Right.VIEW)\n            .putAction(\"charting\", Right.VIEW)\n            .putAction(\"skin\", Right.VIEW)\n            .putAction(\"download\", Right.VIEW)\n            .putAction(\"dot\", Right.VIEW)\n            .putAction(\"svg\", Right.VIEW)\n            .putAction(\"pdf\", Right.VIEW)\n            // TODO: The \"undelete\" action is mapped to the right \"undelete\" in the legacy\n            // implementation.  We should check whether the \"undelete\" right is actually used or not and\n            // if we need to introduce it here as well for compatiblity reasons.\n            .putAction(\"undelete\", Right.EDIT)\n            .putAction(\"reset\", Right.DELETE)\n            .putAction(\"commentadd\", Right.COMMENT)\n            .putAction(\"commentsave\", Right.COMMENT)\n            .putAction(\"redirect\", Right.VIEW)\n            .putAction(\"export\", Right.VIEW)\n            .putAction(\"import\", Right.ADMIN)\n            .putAction(\"jsx\", Right.VIEW)\n            .putAction(\"ssx\", Right.VIEW)\n            .putAction(\"tex\", Right.VIEW)\n            .putAction(\"unknown\", Right.VIEW)\n            .putAction(\"save\", Right.EDIT)\n            .putAction(\"preview\", Right.EDIT)\n            .putAction(\"lock\", Right.EDIT)\n            .putAction(\"cancel\", Right.EDIT)\n            .putAction(\"delattachment\", Right.EDIT)\n            .putAction(\"inline\", Right.EDIT)\n            .putAction(\"propadd\", Right.EDIT)\n            .putAction(\"propupdate\", Right.EDIT)\n            .putAction(\"propdelete\", Right.EDIT)\n            .putAction(\"propdisable\", Right.EDIT)\n            .putAction(\"propenable\", Right.EDIT)\n            .putAction(\"objectadd\", Right.EDIT)\n            .putAction(\"objectremove\", Right.EDIT)\n            .putAction(\"objectsync\", Right.EDIT)\n            .putAction(\"rollback\", Right.EDIT)\n            .putAction(\"upload\", Right.EDIT)\n            .putAction(\"create\", Right.VIEW)\n            .putAction(\"deleteversions\", Right.ADMIN)\n            .putAction(\"deletespace\", Right.ADMIN)\n            .putAction(\"temp\", Right.VIEW)\n            .putAction(\"webjars\", Right.VIEW);\n    }\n\n    /** Resolver for document references. */\n    @SuppressWarnings(\"unchecked\")\n    private DocumentReferenceResolver<String> documentReferenceResolver\n        = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n\n    /** Resolver for user and group document references. */\n    @SuppressWarnings(\"unchecked\")\n    private DocumentReferenceResolver<String> userAndGroupReferenceResolver\n        = Utils.getComponent(DocumentReferenceResolver.TYPE_STRING, \"user\");\n\n    /** The rendering context to check PR for signed macro. */\n    private final RenderingContext renderingContext\n        = Utils.getComponent(RenderingContext.class);\n\n    /** The authorization manager used to really do the job. */\n    private final AuthorizationManager authorizationManager\n        = Utils.getComponent(AuthorizationManager.class);\n\n    /** The contextual authorization manager used to really do the job. */\n    private final ContextualAuthorizationManager contextualAuthorizationManager\n        = Utils.getComponent(ContextualAuthorizationManager.class);\n\n    /**\n     * Specialized map with a chainable put action to avoid exceeding code complexity during initialization.\n     */\n    private static class ActionMap extends HashMap<String, Right>\n    {\n        /** Serialization identifier for conformance to Serializable. */\n        private static final long serialVersionUID = 1;\n\n        /** Allow filling the map in the initializer without exceeding code complexity.\n         * @param action the action name\n         * @param right the corresponding right required\n         * @return this action map to allow code chaining\n         */\n        public ActionMap putAction(String action, Right right)\n        {\n            put(action, right);\n            return this;\n        }\n    }\n\n    /**\n     * Map an action represented by a string to a right.\n     * @param action String representation of action.\n     * @return right The corresponding Right instance, or\n     * {@code ILLEGAL}.\n     */\n    public static Right actionToRight(String action)\n    {\n        Right right = ACTION_MAP.get(action);\n        if (right == null) {\n            return Right.ILLEGAL;\n        }\n        return right;\n    }\n\n    /**\n     * @param username name as a string.\n     * @param wikiReference default wiki, if not explicitly specified in the username.\n     * @return A document reference that uniquely identifies the user.\n     */\n    private DocumentReference resolveUserName(String username, WikiReference wikiReference)\n    {\n        return userAndGroupReferenceResolver.resolve(username, wikiReference);\n    }\n\n    /**\n     * @param docname name of the document as string.\n     * @param wikiReference the default wiki where the document will be\n     * assumed do be located, unless explicitly specified in docname.\n     * @return the document reference.\n     */\n    private DocumentReference resolveDocumentName(String docname, WikiReference wikiReference)\n    {\n        return documentReferenceResolver.resolve(docname, wikiReference);\n    }\n\n    /**\n     * Show the login page, unless the wiki is configured otherwise.\n     * @param context the context\n     */\n    private void showLogin(XWikiContext context)\n    {\n        try {\n            if (context.getRequest() != null\n                /*\n                 * We must explicitly check the action from the context, as some templates that are\n                 * rendered may call checkAccess with different actions (which, strictly speaking is\n                 * incorrect, those templates should use hasAccessLevel).  In particular, 'menuview.vm'\n                 * will call checkAccess with action 'view', if the document 'XWiki.XWikiLogin' exists.\n                 */\n                && !LOGIN_ACTION.equals(context.getAction())\n                && !context.getWiki().Param(\"xwiki.hidelogin\", \"false\").equalsIgnoreCase(\"true\")) {\n                context.getWiki().getAuthService().showLogin(context);\n            }\n        } catch (XWikiException e) {\n            LOGGER.error(\"Failed to show login page.\", e);\n        }\n    }\n\n    /**\n     * Ensure user authentication if needed.\n     *\n     * @param context Current XWikiContext\n     */\n    private void authenticateUser(XWikiContext context)\n    {\n        DocumentReference contextUserReference = context.getUserReference();\n        DocumentReference userReference = contextUserReference;\n\n        if (userReference == null && context.getMode() != XWikiContext.MODE_XMLRPC) {\n            try {\n                XWikiUser user = context.getWiki().checkAuth(context);\n                if (user != null) {\n                    userReference = resolveUserName(user.getUser(), new WikiReference(context.getWikiId()));\n                }\n            } catch (XWikiException e) {\n                LOGGER.error(\"Caught exception while authenticating user.\", e);\n            }\n        }\n\n        if (userReference != null && XWikiConstants.GUEST_USER.equals(userReference.getName())) {\n            // Public users (not logged in) should be passed as null in the new API. It may happen that badly\n            // design code, and poorly written API does not take care, so we prevent security issue here.\n            userReference = null;\n        }\n\n        if (userReference != contextUserReference\n            && (userReference == null || !userReference.equals(contextUserReference))) {\n            context.setUserReference(userReference);\n        }\n    }\n\n    @Override\n    public boolean checkAccess(String action, XWikiDocument doc, XWikiContext context)\n        throws XWikiException\n    {\n        Right right = actionToRight(action);\n        EntityReference entityReference = doc.getDocumentReference();\n\n        LOGGER.debug(\"checkAccess for action [{}] on entity [{}].\", right, entityReference);\n\n        authenticateUser(context);\n\n        if (contextualAuthorizationManager.hasAccess(right, entityReference)) {\n            return true;\n        }\n\n        // If the right has been denied, and we have guest user, redirect the user to login page\n        // unless the denied is on the login action, which could cause infinite redirection.\n        // FIXME: The hasAccessLevel is broken (do not allow document creator) on the delete action in the old\n        // implementation, so code that simply want to verify if a user can delete (but is not actually deleting)\n        // has to call checkAccess. This happen really often, and this why we should not redirect to login on failed\n        // delete, since it would prevent most user to do anything.\n        // Also we don't show the login if an inactive user logged in.\n        if (context.getUserReference() == null && !DELETE_ACTION.equals(action) && !LOGIN_ACTION.equals(action)\n            && context.get(XWikiContext.INACTIVE_USER_REFERENCE) == null) {\n            LOGGER.debug(\"Redirecting unauthenticated user to login, since it have been denied [{}] on [{}].\",\n                         right, entityReference);\n            showLogin(context);\n        }\n\n        return false;\n    }\n\n    @Override\n    public boolean hasAccessLevel(String rightName, String username, String docname, XWikiContext context)\n        throws XWikiException\n    {\n        WikiReference wikiReference = new WikiReference(context.getWikiId());\n        DocumentReference document = resolveDocumentName(docname, wikiReference);\n        LOGGER.debug(\"hasAccessLevel() resolved document named [{}] into reference [{}]\", docname, document);\n        DocumentReference user = resolveUserName(username, wikiReference);\n\n        if (user != null && XWikiConstants.GUEST_USER.equals(user.getName())) {\n            // Public users (not logged in) should be passed as null in the new API\n            user = null;\n        }\n\n        Right right = Right.toRight(rightName);\n\n        return authorizationManager.hasAccess(right, user, document);\n    }\n\n    @Override\n    public boolean hasProgrammingRights(XWikiContext context)\n    {\n        return contextualAuthorizationManager.hasAccess(Right.PROGRAM);\n    }\n\n    @Override\n    public boolean hasProgrammingRights(XWikiDocument doc, XWikiContext context)\n    {\n        DocumentReference user;\n        WikiReference wiki;\n\n        if (doc != null) {\n            user = doc.getContentAuthorReference();\n            wiki = doc.getDocumentReference().getWikiReference();\n        } else {\n            user = context.getUserReference();\n            wiki = new WikiReference(context.getWikiId());\n        }\n\n        if (user != null && XWikiConstants.GUEST_USER.equals(user.getName())) {\n            // Public users (not logged in) should be passed as null in the new API. It may happen that badly\n            // design code, and poorly written API does not take care, so we prevent security issue here.\n            user = null;\n        }\n\n        // This method as never check for external contextual aspect like rendering context restriction or dropping of\n        // permissions. So we do not use the contextual authorization manager to keep backward compatibility.\n        return authorizationManager.hasAccess(Right.PROGRAM, user, wiki);\n    }\n\n    @Override\n    public boolean hasAdminRights(XWikiContext context)\n    {\n        return contextualAuthorizationManager.hasAccess(Right.ADMIN);\n    }\n\n    @Override\n    public boolean hasWikiAdminRights(XWikiContext context)\n    {\n        return contextualAuthorizationManager.hasAccess(Right.ADMIN, new WikiReference(context.getWikiId()));\n    }\n\n    @Override\n    public List<String> listAllLevels(XWikiContext context)\n        throws XWikiException\n    {\n        return Right.getAllRightsAsString();\n    }\n}\n"], "filenames": ["xwiki-platform-core/xwiki-platform-flamingo/xwiki-platform-flamingo-skin/xwiki-platform-flamingo-skin-resources/src/main/resources/flamingo/drawer.vm", "xwiki-platform-core/xwiki-platform-notifications/xwiki-platform-notifications-rest/src/main/java/org/xwiki/notifications/rest/internal/DefaultNotificationsResource.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/XWiki.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/XWikiContext.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/api/XWiki.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/user/api/XWikiUser.java", "xwiki-platform-core/xwiki-platform-security/xwiki-platform-security-authorization/xwiki-platform-security-authorization-bridge/src/main/java/org/xwiki/security/authorization/internal/XWikiCachingRightService.java"], "buggy_code_start_loc": [33, 188, 4324, 102, 2913, 31, 283], "buggy_code_end_loc": [37, 219, 5969, 102, 2929, 59, 284], "fixing_code_start_loc": [34, 188, 4325, 103, 2913, 32, 283], "fixing_code_end_loc": [43, 219, 5971, 113, 2935, 64, 286], "type": "NVD-CWE-Other", "message": "XWiki Platform Old Core is a core package for XWiki Platform, a generic wiki platform. Prior to versions 13.1.0.5 and 14.3-rc-1, some resources are missing a check for inactive (not yet activated or disabled) users in XWiki, including the REST service. This means a disabled user can enable themselves using a REST call. On the same way some resources handler created by extensions are not protected by default, so an inactive user could perform actions for such extensions. This issue has existed since at least version 1.1 of XWiki for instance configured with the email activation required for new users. Now it's more critical for versions 11.3-rc-1 and later since the maintainers provided the capability to disable user without deleting them and encouraged using that feature. XWiki 14.3-rc-1 and XWiki 13.10.5 contain a patch. There is no workaround for this other than upgrading XWiki.", "other": {"cve": {"id": "CVE-2022-36090", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-08T15:15:07.793", "lastModified": "2022-09-13T18:20:53.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform Old Core is a core package for XWiki Platform, a generic wiki platform. Prior to versions 13.1.0.5 and 14.3-rc-1, some resources are missing a check for inactive (not yet activated or disabled) users in XWiki, including the REST service. This means a disabled user can enable themselves using a REST call. On the same way some resources handler created by extensions are not protected by default, so an inactive user could perform actions for such extensions. This issue has existed since at least version 1.1 of XWiki for instance configured with the email activation required for new users. Now it's more critical for versions 11.3-rc-1 and later since the maintainers provided the capability to disable user without deleting them and encouraged using that feature. XWiki 14.3-rc-1 and XWiki 13.10.5 contain a patch. There is no workaround for this other than upgrading XWiki."}, {"lang": "es", "value": "XWiki Platform Old Core es un paquete central para XWiki Platform, una plataforma wiki gen\u00e9rica. En versiones anteriores a 13.1.0.5 y 14.3-rc-1, a algunos recursos les falta una comprobaci\u00f3n de usuarios inactivos (a\u00fan no activados o deshabilitados) en XWiki, incluido el servicio REST.&#xa0;Esto significa que un usuario deshabilitado puede habilitarse mediante una llamada REST.&#xa0;Del mismo modo, algunos controladores de recursos creados por extensiones no est\u00e1n protegidos por defecto, por lo que un usuario inactivo podr\u00eda llevar a cabo acciones para dichas extensiones.&#xa0;Este problema ha existido desde al menos la versi\u00f3n 1.1 de XWiki, por ejemplo, configurada con la activaci\u00f3n de correo electr\u00f3nico requerida para nuevos usuarios.&#xa0;Ahora es m\u00e1s cr\u00edtico para las versiones 11.3-rc-1 y posteriores, ya que los mantenedores proporcionaron la capacidad de deshabilitar a usuarios sin eliminarlos y alentaron a usar esa funci\u00f3n.&#xa0;XWiki 14.3-rc-1 y XWiki 13.10.5 contienen un parche"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1", "versionEndExcluding": "13.10.5", "matchCriteriaId": "011C9A04-2CCF-4C9D-B877-69F2AFE230C3"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/e074d226d9b2b96a0a1ba4349d1b73a802842986", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-jgc8-gvcx-9vfx", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-19559", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/e074d226d9b2b96a0a1ba4349d1b73a802842986"}}