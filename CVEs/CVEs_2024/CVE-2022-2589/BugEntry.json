{"buggy_code": ["<script lang=\"ts\">\n  import { extent } from \"d3-array\";\n  import { axisBottom, axisLeft } from \"d3-axis\";\n  import { quadtree } from \"d3-quadtree\";\n  import { scalePoint, scaleUtc } from \"d3-scale\";\n\n  import { day } from \"../format\";\n\n  import Axis from \"./Axis.svelte\";\n  import { scatterplotScale } from \"./helpers\";\n  import type { ScatterPlotDatum } from \"./scatterplot\";\n  import type { TooltipFindNode } from \"./tooltip\";\n  import { positionedTooltip } from \"./tooltip\";\n\n  export let data: ScatterPlotDatum[];\n  export let width: number;\n\n  const today = new Date();\n  const margin = {\n    top: 10,\n    right: 10,\n    bottom: 30,\n    left: 70,\n  };\n  const height = 250;\n  $: innerWidth = width - margin.left - margin.right;\n  $: innerHeight = height - margin.top - margin.bottom;\n\n  // Scales\n  $: dateExtent = extent(data, (d) => d.date);\n  $: x = scaleUtc()\n    .domain(dateExtent[0] ? dateExtent : [0, 1])\n    .range([0, innerWidth]);\n  $: y = scalePoint()\n    .padding(1)\n    .domain(data.map((d) => d.type))\n    .range([innerHeight, 0]);\n\n  // Axes\n  $: xAxis = axisBottom(x).tickSizeOuter(0);\n  $: yAxis = axisLeft(y)\n    .tickPadding(6)\n    .tickSize(-innerWidth)\n    .tickFormat((d) => d);\n\n  /** Quadtree for hover. */\n  $: quad = quadtree(\n    data,\n    (d) => x(d.date),\n    (d) => y(d.type) ?? 0\n  );\n\n  function tooltipText(d: ScatterPlotDatum) {\n    return `${d.description}<em>${day(d.date)}</em>`;\n  }\n\n  const tooltipFindNode: TooltipFindNode = (xPos, yPos) => {\n    const d = quad.find(xPos, yPos);\n    return d && [x(d.date), y(d.type) ?? 0, tooltipText(d)];\n  };\n</script>\n\n<svg {width} {height}>\n  <g\n    use:positionedTooltip={tooltipFindNode}\n    transform={`translate(${margin.left},${margin.top})`}\n  >\n    <Axis x axis={xAxis} {innerHeight} />\n    <Axis y axis={yAxis} />\n    <g>\n      {#each data as dot}\n        <circle\n          r=\"5\"\n          fill={scatterplotScale(dot.type)}\n          cx={x(dot.date)}\n          cy={y(dot.type)}\n          class:desaturate={dot.date > today}\n        />\n      {/each}\n    </g>\n  </g>\n</svg>\n\n<style>\n  svg > g {\n    pointer-events: all;\n  }\n\n  .desaturate {\n    filter: saturate(50%);\n  }\n</style>\n", "<script lang=\"ts\">\n  import { treemap } from \"d3-hierarchy\";\n  import type { HierarchyRectangularNode } from \"d3-hierarchy\";\n\n  import { ctx, formatPercentage } from \"../format\";\n  import { urlForAccount } from \"../helpers\";\n  import router from \"../router\";\n\n  import { treemapScale } from \"./helpers\";\n  import type {\n    AccountHierarchyDatum,\n    AccountHierarchyNode,\n  } from \"./hierarchy\";\n  import { followingTooltip } from \"./tooltip\";\n\n  export let data: AccountHierarchyNode;\n  export let width: number;\n  export let currency: string;\n\n  $: height = Math.min(width / 2.5, 400);\n\n  const tree = treemap<AccountHierarchyDatum>().paddingInner(2).round(true);\n  $: root = tree.size([width, height])(data);\n  $: leaves = root.leaves().filter((d) => d.value);\n\n  function fill(d: AccountHierarchyNode) {\n    const node = d.data.dummy && d.parent ? d.parent : d;\n    if (node.depth === 1 || !node.parent) {\n      return $treemapScale(node.data.account);\n    }\n    return $treemapScale(node.parent.data.account);\n  }\n\n  function tooltipText(d: AccountHierarchyNode) {\n    const val = d.value ?? 0;\n    const rootValue = root.value || 1;\n\n    return `${$ctx.amount(val, currency)} (${formatPercentage(\n      val / rootValue\n    )})<em>${d.data.account}</em>`;\n  }\n\n  function setVisibility(\n    node: SVGTextElement,\n    param: HierarchyRectangularNode<AccountHierarchyDatum>\n  ) {\n    function update(d: HierarchyRectangularNode<AccountHierarchyDatum>) {\n      const length = node.getComputedTextLength();\n      node.style.visibility =\n        d.x1 - d.x0 > length + 4 && d.y1 - d.y0 > 14 ? \"visible\" : \"hidden\";\n    }\n    update(param);\n    return { update };\n  }\n</script>\n\n<svg {width} {height}>\n  {#each leaves as d}\n    <g\n      transform={`translate(${d.x0},${d.y0})`}\n      use:followingTooltip={() => tooltipText(d)}\n    >\n      <rect fill={fill(d)} width={d.x1 - d.x0} height={d.y1 - d.y0} />\n      <text\n        use:setVisibility={d}\n        on:click={() => router.navigate(urlForAccount(d.data.account))}\n        dy=\".5em\"\n        x={(d.x1 - d.x0) / 2}\n        y={(d.y1 - d.y0) / 2}\n        text-anchor=\"middle\"\n      >\n        {d.data.account.split(\":\").pop() || \"\"}\n      </text>\n    </g>\n  {/each}\n</svg>\n\n<style>\n  svg {\n    shape-rendering: crispedges;\n  }\n\n  text {\n    cursor: pointer;\n  }\n</style>\n", "import type { Series } from \"d3-shape\";\nimport { stack, stackOffsetDiverging } from \"d3-shape\";\n\nimport type { FormatterContext } from \"../format\";\nimport { ok } from \"../lib/result\";\nimport type { Result } from \"../lib/result\";\nimport { array, date, number, object, record } from \"../lib/validation\";\n\nimport type { ChartContext } from \"./context\";\n\nexport interface BarChartDatumValue {\n  currency: string;\n  value: number;\n  budget: number;\n}\n\n/** The data for the bars of one interval. */\nexport interface BarChartDatum {\n  /** The label of this interval. */\n  label: string;\n  /** The date of this interval. */\n  date: Date;\n  /** One value for each (operating) currency. */\n  values: BarChartDatumValue[];\n  /** The balances of the child accounts. */\n  account_balances: Record<string, Record<string, number>>;\n}\n\nexport interface BarChart {\n  type: \"barchart\";\n  data: {\n    /** All accounts that occur as some child account. */\n    accounts: string[];\n    /** The data for the (single) bars for all the intervals in this chart. */\n    bar_groups: BarChartDatum[];\n    /** For each currency, the stacks (one series per account) */\n    stacks: [currency: string, stacks: Series<BarChartDatum, string>[]][];\n    /** Whether this chart contains any stacks (or is just a single account). */\n    hasStackedData: boolean;\n  };\n  tooltipText: (c: FormatterContext, d: BarChartDatum, e: string) => string;\n}\n\nconst bar_validator = array(\n  object({\n    date,\n    budgets: record(number),\n    balance: record(number),\n    account_balances: record(record(number)),\n  })\n);\n\n/**\n * Try to parse a bar chart.\n */\nexport function bar(\n  json: unknown,\n  { currencies, dateFormat }: ChartContext\n): Result<BarChart, string> {\n  const res = bar_validator(json);\n  if (!res.success) {\n    return res;\n  }\n  const parsedData = res.value;\n  const bar_groups = parsedData.map((interval) => ({\n    values: currencies.map((currency) => ({\n      currency,\n      value: interval.balance[currency] ?? 0,\n      budget: interval.budgets[currency] ?? 0,\n    })),\n    date: interval.date,\n    label: dateFormat(interval.date),\n    account_balances: interval.account_balances,\n  }));\n  const accounts = Array.from(\n    new Set(parsedData.map((d) => [...Object.keys(d.account_balances)]).flat(2))\n  ).sort();\n  const hasStackedData = accounts.length > 1;\n\n  const stacks = currencies.map(\n    (currency): [string, Series<BarChartDatum, string>[]] => [\n      currency,\n      stack<BarChartDatum>()\n        .keys(accounts)\n        .value((obj, key) => obj.account_balances[key]?.[currency] ?? 0)\n        .offset(stackOffsetDiverging)(bar_groups),\n    ]\n  );\n\n  return ok({\n    type: \"barchart\" as const,\n    data: { accounts, bar_groups, stacks, hasStackedData },\n    tooltipText: (c, d, e) => {\n      let text = \"\";\n      if (e === \"\") {\n        d.values.forEach((a) => {\n          text += c.amount(a.value, a.currency);\n          if (a.budget) {\n            text += ` / ${c.amount(a.budget, a.currency)}`;\n          }\n          text += \"<br>\";\n        });\n      } else {\n        text += `<em>${e}</em>`;\n        d.values.forEach((a) => {\n          const value = d.account_balances[e]?.[a.currency] ?? 0;\n          text += `${c.amount(value, a.currency)}<br>`;\n        });\n      }\n      text += `<em>${d.label}</em>`;\n      return text;\n    },\n  });\n}\n", "import type { Readable } from \"svelte/store\";\nimport { derived } from \"svelte/store\";\n\nimport { currentDateFormat } from \"../format\";\nimport { conversion, operating_currency } from \"../stores\";\n\nexport type ChartContext = {\n  currencies: string[];\n  dateFormat: (date: Date) => string;\n};\n\n/**\n * The list of operating currencies, adding in the current conversion currency.\n */\nconst operatingCurrenciesWithConversion = derived(\n  [operating_currency, conversion],\n  ([operating_currency_val, conversion_val]) => {\n    if (\n      !conversion_val ||\n      [\"at_cost\", \"at_value\", \"units\"].includes(conversion_val) ||\n      operating_currency_val.includes(conversion_val)\n    ) {\n      return operating_currency_val;\n    }\n    return [...operating_currency_val, conversion_val];\n  }\n);\n\nexport const chartContext: Readable<ChartContext> = derived(\n  [operatingCurrenciesWithConversion, currentDateFormat],\n  ([currencies_val, dateFormat]) => ({ currencies: currencies_val, dateFormat })\n);\n", "import type { FormatterContext } from \"../format\";\nimport { day } from \"../format\";\nimport { ok } from \"../lib/result\";\nimport type { Result } from \"../lib/result\";\nimport {\n  array,\n  date,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from \"../lib/validation\";\n\nexport interface LineChartDatum {\n  name: string;\n  date: Date;\n  value: number;\n}\n\nexport type LineChartData = {\n  name: string;\n  values: LineChartDatum[];\n};\n\nexport interface LineChart {\n  type: \"linechart\";\n  data: LineChartData[];\n  tooltipText: (c: FormatterContext, d: LineChartDatum) => string;\n}\n\nconst balances_validator = array(object({ date, balance: record(number) }));\n\nexport function balances(json: unknown): Result<LineChart, string> {\n  const res = balances_validator(json);\n  if (!res.success) {\n    return res;\n  }\n  const parsedData = res.value;\n  const groups = new Map<string, LineChartDatum[]>();\n  for (const { date: date_, balance } of parsedData) {\n    Object.entries(balance).forEach(([currency, value]) => {\n      const group = groups.get(currency);\n      const datum = { date: date_, value, name: currency };\n      if (group) {\n        group.push(datum);\n      } else {\n        groups.set(currency, [datum]);\n      }\n    });\n  }\n  const data = [...groups.entries()].map(([name, values]) => ({\n    name,\n    values,\n  }));\n\n  return ok({\n    type: \"linechart\" as const,\n    data,\n    tooltipText: (c, d) =>\n      `${c.amount(d.value, d.name)}<em>${day(d.date)}</em>`,\n  });\n}\n\nconst commodities_validator = object({\n  quote: string,\n  base: string,\n  prices: array(tuple([date, number])),\n});\n\nexport function commodities(\n  json: unknown,\n  _ctx: unknown,\n  label: string\n): Result<LineChart, string> {\n  const res = commodities_validator(json);\n  if (!res.success) {\n    return res;\n  }\n  const { base, quote, prices } = res.value;\n  const values = prices.map((d) => ({ name: label, date: d[0], value: d[1] }));\n  return ok({\n    type: \"linechart\" as const,\n    data: [{ name: label, values }],\n    tooltipText(c, d) {\n      return `1 ${base} = ${c.amount(d.value, quote)}<em>${day(d.date)}</em>`;\n    },\n  });\n}\n", "import { pointer } from \"d3-selection\";\n\n/** The tooltip div, lazily created. */\nconst tooltip = (() => {\n  let value: HTMLDivElement | null = null;\n  return () => {\n    if (value === null) {\n      value = document.createElement(\"div\");\n      value.className = \"tooltip\";\n      document.body.appendChild(value);\n    }\n    return value;\n  };\n})();\n\n/** Hide the tooltip. */\nconst hide = (): void => {\n  const t = tooltip();\n  t.style.opacity = \"0\";\n};\n\n/**\n * Svelte action to have the given element act on mouse to show a tooltip.\n *\n * The tooltip will be positioned at the cursor and is given a tooltip getter\n * per <g> element.\n */\nexport function followingTooltip(\n  node: SVGElement,\n  text: () => string\n): { destroy: () => void; update: (t: () => string) => void } {\n  let getter = text;\n  /** Event listener to have the tooltip follow the mouse. */\n  function followMouse(event: MouseEvent): void {\n    const t = tooltip();\n    t.style.opacity = \"1\";\n    t.style.left = `${event.pageX}px`;\n    t.style.top = `${event.pageY - 15}px`;\n  }\n  node.addEventListener(\"mouseenter\", () => {\n    const t = tooltip();\n    t.innerHTML = getter();\n  });\n  node.addEventListener(\"mousemove\", followMouse);\n  node.addEventListener(\"mouseleave\", hide);\n\n  return {\n    destroy: hide,\n    update(t: () => string): void {\n      getter = t;\n    },\n  };\n}\n\n/** A function to find the closest node and the content to show in the tooltip. */\nexport type TooltipFindNode = (\n  x: number,\n  y: number\n) => [number, number, string] | undefined;\n\n/**\n * Svelte action to have the given <g> element act on mouse to show a tooltip.\n *\n * The parameter to the tooltip is a function that takes a position (relative\n * to the container) as input and should return the position of the tooltip,\n * i.e., the found node, again relative to the container and the desired\n * content of the tooltip.\n */\nexport function positionedTooltip(\n  node: SVGGElement,\n  find: TooltipFindNode\n): { destroy: () => void } {\n  function mousemove(event: MouseEvent): void {\n    const [xPointer, yPointer] = pointer(event);\n    const res = find(xPointer, yPointer);\n    const matrix = node.getScreenCTM();\n    if (res && matrix) {\n      const [x, y, content] = res;\n      const t = tooltip();\n      t.style.opacity = \"1\";\n      t.innerHTML = content;\n      t.style.left = `${window.scrollX + x + matrix.e}px`;\n      t.style.top = `${window.scrollY + y + matrix.f - 15}px`;\n    } else {\n      hide();\n    }\n  }\n  node.addEventListener(\"mousemove\", mousemove);\n  node.addEventListener(\"mouseleave\", hide);\n\n  return {\n    destroy: hide,\n  };\n}\n", "/**\n * Add a tooltip showing the keyboard shortcut over the target element.\n * @param target - The target element to show the tooltip on.\n * @returns A function to remove event handler.\n */\nfunction showTooltip(target: HTMLElement): () => void {\n  const tooltip = document.createElement(\"div\");\n  const isHidden = target.classList.contains(\"hidden\");\n  if (isHidden) {\n    target.classList.remove(\"hidden\");\n  }\n  tooltip.className = \"keyboard-tooltip\";\n  tooltip.innerHTML = target.getAttribute(\"data-key\") || \"\";\n  document.body.appendChild(tooltip);\n  const parentCoords = target.getBoundingClientRect();\n  // Padded 10px to the left if there is space or centered otherwise\n  const left =\n    parentCoords.left +\n    Math.min((target.offsetWidth - tooltip.offsetWidth) / 2, 10);\n  const top =\n    parentCoords.top + (target.offsetHeight - tooltip.offsetHeight) / 2;\n  tooltip.style.left = `${left}px`;\n  tooltip.style.top = `${top + window.pageYOffset}px`;\n  return (): void => {\n    tooltip.remove();\n    if (isHidden) {\n      target.classList.add(\"hidden\");\n    }\n  };\n}\n\n/**\n * Show all keyboard shortcut tooltips.\n */\nfunction showTooltips(): () => void {\n  const removes: (() => void)[] = [];\n  document.querySelectorAll(\"[data-key]\").forEach((el) => {\n    if (el instanceof HTMLElement) {\n      removes.push(showTooltip(el));\n    }\n  });\n  return (): void => {\n    removes.forEach((r) => r());\n  };\n}\n\n/**\n * Ignore events originating from editable elements.\n * @param element - The element to check.\n * @returns true if the element is one of input/select/textarea or a\n *          contentEditable element.\n */\nfunction isEditableElement(element: EventTarget | null): boolean {\n  return (\n    element instanceof HTMLElement &&\n    (element instanceof HTMLInputElement ||\n      element instanceof HTMLSelectElement ||\n      element instanceof HTMLTextAreaElement ||\n      element.isContentEditable)\n  );\n}\n\n/** A handler function or an element to click. */\ntype KeyboardShortcutAction = ((event: KeyboardEvent) => void) | HTMLElement;\nconst keyboardShortcuts = new Map<string, KeyboardShortcutAction>();\n// The last typed character to check for sequences of two keys.\nlet lastChar = \"\";\n\n/**\n * Handle a `keydown` event on the document.\n *\n * Dispatch to the relevant handler.\n */\nfunction keydown(event: KeyboardEvent): void {\n  if (isEditableElement(event.target)) {\n    // ignore events in editable elements.\n    return;\n  }\n  let eventKey = event.key;\n  if (event.metaKey) {\n    eventKey = `Meta+${eventKey}`;\n  }\n  if (event.altKey) {\n    eventKey = `Alt+${eventKey}`;\n  }\n  if (event.ctrlKey) {\n    eventKey = `Control+${eventKey}`;\n  }\n  const lastTwoKeys = `${lastChar} ${eventKey}`;\n  const handler =\n    keyboardShortcuts.get(lastTwoKeys) ?? keyboardShortcuts.get(eventKey);\n  if (handler) {\n    if (handler instanceof HTMLInputElement) {\n      event.preventDefault();\n      handler.focus();\n    } else if (handler instanceof HTMLElement) {\n      handler.click();\n    } else {\n      handler(event);\n    }\n  }\n  if (event.key !== \"Alt\" && event.key !== \"Control\" && event.key !== \"Shift\") {\n    lastChar = eventKey;\n  }\n}\n\ndocument.addEventListener(\"keydown\", keydown);\n\n/** A type to specify a platform-dependent keyboard shortcut. */\nexport type KeySpec = string | { key: string; mac: string };\n\nconst currentPlatform: \"mac\" | \"key\" =\n  typeof navigator !== \"undefined\" && /Mac/.test(navigator.platform)\n    ? \"mac\"\n    : \"key\";\n\nexport const modKey = currentPlatform === \"mac\" ? \"Cmd\" : \"Ctrl\";\n\n/**\n * Get the keyboard key specifier string for the current platform.\n * @param keySpec - The key spec.\n */\nexport function getKeySpecKey(keySpec: KeySpec): string {\n  if (typeof keySpec === \"string\") {\n    return keySpec;\n  }\n  return currentPlatform === \"mac\" ? keySpec.mac : keySpec.key;\n}\n\n/**\n * Bind an event handler to a key.\n * @param key - The key to bind.\n * @param handler - The callback to run on key press.\n * @returns A function to unbind the keyboard handler.\n */\nexport function bindKey(\n  keySpec: KeySpec,\n  handler: KeyboardShortcutAction\n): () => void {\n  const key = getKeySpecKey(keySpec);\n  const sequence = key.split(\" \");\n  if (sequence.length > 2) {\n    // eslint-disable-next-line no-console\n    console.error(\"Only key sequences of length <=2 are supported: \", key);\n  }\n  if (keyboardShortcuts.has(key)) {\n    // eslint-disable-next-line no-console\n    console.warn(\"Duplicate keyboard shortcut: \", key, handler);\n  }\n  keyboardShortcuts.set(key, handler);\n  return (): void => {\n    keyboardShortcuts.delete(key);\n  };\n}\n\n/**\n * A svelte action to attach a global keyboard shortcut.\n *\n * This will attach a listener for the given key (or key sequence of length 2).\n * This listener will focus the given node if it is an <input> element and\n * trigger a click on it otherwise.\n */\nexport function keyboardShortcut(\n  node: HTMLElement,\n  key?: string\n): { destroy?: () => void } {\n  if (!key) {\n    return {};\n  }\n  node.setAttribute(\"data-key\", key);\n  const destroy = bindKey(key, node);\n\n  return { destroy };\n}\n\n/**\n * Register keyboard shortcuts for all newly added elements with a\n * `data-keyboard-shortcut` attribute.\n */\nexport function initCurrentKeyboardShortcuts(): void {\n  // clean up\n  for (const [key, action] of keyboardShortcuts.entries()) {\n    if (action instanceof HTMLElement && !document.contains(action)) {\n      keyboardShortcuts.delete(key);\n    }\n  }\n  document.querySelectorAll(\"[data-keyboard-shortcut]\").forEach((element) => {\n    const key = element.getAttribute(\"data-keyboard-shortcut\");\n    if (key && element instanceof HTMLElement) {\n      element.removeAttribute(\"data-keyboard-shortcut\");\n      element.setAttribute(\"data-key\", key);\n      bindKey(key, element);\n    }\n  });\n}\n\n/**\n * Register the keys to show/hide the tooltips\n */\nexport function initGlobalKeyboardShortcuts(): void {\n  bindKey(\"?\", () => {\n    const hide = showTooltips();\n    const once = () => {\n      hide();\n      document.removeEventListener(\"mousedown\", once);\n      document.removeEventListener(\"keydown\", once);\n    };\n    document.addEventListener(\"mousedown\", once);\n    document.addEventListener(\"keydown\", once);\n  });\n}\n", "/**\n * This script updates the links and error count in the sidebar as well as\n * toggling the sidebar on mobile.\n */\n\nimport { errorCount } from \"../stores\";\n\nexport function updateSidebar(): void {\n  document.querySelectorAll(\"aside a\").forEach((el) => {\n    el.classList.remove(\"selected\");\n    const href = el.getAttribute(\"href\");\n    if (\n      !el.hasAttribute(\"data-remote\") &&\n      href?.includes(window.location.pathname) &&\n      !el.matches(\".submenu a\")\n    ) {\n      el.classList.add(\"selected\");\n    }\n  });\n}\n\nexport function initSidebar(): void {\n  const errorCountEl = document.getElementById(\"error-count\");\n  if (errorCountEl instanceof HTMLLIElement) {\n    errorCount.subscribe((errorCount_val) => {\n      errorCountEl.classList.toggle(\"hidden\", errorCount_val === 0);\n      const span = errorCountEl.querySelector(\"span\");\n      if (span) {\n        span.innerHTML = `${errorCount_val}`;\n      }\n    });\n  }\n\n  const asideButton = document.getElementById(\"aside-button\");\n  if (asideButton instanceof HTMLButtonElement) {\n    asideButton.addEventListener(\"click\", () => {\n      document.querySelector(\"aside\")?.classList.toggle(\"active\");\n      asideButton.classList.toggle(\"active\");\n    });\n  }\n}\n"], "fixing_code": ["<script lang=\"ts\">\n  import { extent } from \"d3-array\";\n  import { axisBottom, axisLeft } from \"d3-axis\";\n  import { quadtree } from \"d3-quadtree\";\n  import { scalePoint, scaleUtc } from \"d3-scale\";\n\n  import { day } from \"../format\";\n\n  import Axis from \"./Axis.svelte\";\n  import { scatterplotScale } from \"./helpers\";\n  import type { ScatterPlotDatum } from \"./scatterplot\";\n  import type { TooltipFindNode } from \"./tooltip\";\n  import { domHelpers, positionedTooltip } from \"./tooltip\";\n\n  export let data: ScatterPlotDatum[];\n  export let width: number;\n\n  const today = new Date();\n  const margin = {\n    top: 10,\n    right: 10,\n    bottom: 30,\n    left: 70,\n  };\n  const height = 250;\n  $: innerWidth = width - margin.left - margin.right;\n  $: innerHeight = height - margin.top - margin.bottom;\n\n  // Scales\n  $: dateExtent = extent(data, (d) => d.date);\n  $: x = scaleUtc()\n    .domain(dateExtent[0] ? dateExtent : [0, 1])\n    .range([0, innerWidth]);\n  $: y = scalePoint()\n    .padding(1)\n    .domain(data.map((d) => d.type))\n    .range([innerHeight, 0]);\n\n  // Axes\n  $: xAxis = axisBottom(x).tickSizeOuter(0);\n  $: yAxis = axisLeft(y)\n    .tickPadding(6)\n    .tickSize(-innerWidth)\n    .tickFormat((d) => d);\n\n  /** Quadtree for hover. */\n  $: quad = quadtree(\n    data,\n    (d) => x(d.date),\n    (d) => y(d.type) ?? 0\n  );\n\n  function tooltipText(d: ScatterPlotDatum) {\n    return [domHelpers.t(d.description), domHelpers.em(day(d.date))];\n  }\n\n  const tooltipFindNode: TooltipFindNode = (xPos, yPos) => {\n    const d = quad.find(xPos, yPos);\n    return d && [x(d.date), y(d.type) ?? 0, tooltipText(d)];\n  };\n</script>\n\n<svg {width} {height}>\n  <g\n    use:positionedTooltip={tooltipFindNode}\n    transform={`translate(${margin.left},${margin.top})`}\n  >\n    <Axis x axis={xAxis} {innerHeight} />\n    <Axis y axis={yAxis} />\n    <g>\n      {#each data as dot}\n        <circle\n          r=\"5\"\n          fill={scatterplotScale(dot.type)}\n          cx={x(dot.date)}\n          cy={y(dot.type)}\n          class:desaturate={dot.date > today}\n        />\n      {/each}\n    </g>\n  </g>\n</svg>\n\n<style>\n  svg > g {\n    pointer-events: all;\n  }\n\n  .desaturate {\n    filter: saturate(50%);\n  }\n</style>\n", "<script lang=\"ts\">\n  import { treemap } from \"d3-hierarchy\";\n  import type { HierarchyRectangularNode } from \"d3-hierarchy\";\n\n  import { ctx, formatPercentage } from \"../format\";\n  import { urlForAccount } from \"../helpers\";\n  import router from \"../router\";\n\n  import { treemapScale } from \"./helpers\";\n  import type {\n    AccountHierarchyDatum,\n    AccountHierarchyNode,\n  } from \"./hierarchy\";\n  import { domHelpers, followingTooltip } from \"./tooltip\";\n\n  export let data: AccountHierarchyNode;\n  export let width: number;\n  export let currency: string;\n\n  $: height = Math.min(width / 2.5, 400);\n\n  const tree = treemap<AccountHierarchyDatum>().paddingInner(2).round(true);\n  $: root = tree.size([width, height])(data);\n  $: leaves = root.leaves().filter((d) => d.value);\n\n  function fill(d: AccountHierarchyNode) {\n    const node = d.data.dummy && d.parent ? d.parent : d;\n    if (node.depth === 1 || !node.parent) {\n      return $treemapScale(node.data.account);\n    }\n    return $treemapScale(node.parent.data.account);\n  }\n\n  function tooltipText(d: AccountHierarchyNode) {\n    const val = d.value ?? 0;\n    const rootValue = root.value || 1;\n\n    return [\n      domHelpers.t(\n        `${$ctx.amount(val, currency)} (${formatPercentage(val / rootValue)})`\n      ),\n      domHelpers.em(d.data.account),\n    ];\n  }\n\n  function setVisibility(\n    node: SVGTextElement,\n    param: HierarchyRectangularNode<AccountHierarchyDatum>\n  ) {\n    function update(d: HierarchyRectangularNode<AccountHierarchyDatum>) {\n      const length = node.getComputedTextLength();\n      node.style.visibility =\n        d.x1 - d.x0 > length + 4 && d.y1 - d.y0 > 14 ? \"visible\" : \"hidden\";\n    }\n    update(param);\n    return { update };\n  }\n</script>\n\n<svg {width} {height}>\n  {#each leaves as d}\n    <g\n      transform={`translate(${d.x0},${d.y0})`}\n      use:followingTooltip={() => tooltipText(d)}\n    >\n      <rect fill={fill(d)} width={d.x1 - d.x0} height={d.y1 - d.y0} />\n      <text\n        use:setVisibility={d}\n        on:click={() => router.navigate(urlForAccount(d.data.account))}\n        dy=\".5em\"\n        x={(d.x1 - d.x0) / 2}\n        y={(d.y1 - d.y0) / 2}\n        text-anchor=\"middle\"\n      >\n        {d.data.account.split(\":\").pop() || \"\"}\n      </text>\n    </g>\n  {/each}\n</svg>\n\n<style>\n  svg {\n    shape-rendering: crispedges;\n  }\n\n  text {\n    cursor: pointer;\n  }\n</style>\n", "import type { Series } from \"d3-shape\";\nimport { stack, stackOffsetDiverging } from \"d3-shape\";\n\nimport type { FormatterContext } from \"../format\";\nimport { ok } from \"../lib/result\";\nimport type { Result } from \"../lib/result\";\nimport { array, date, number, object, record } from \"../lib/validation\";\n\nimport type { ChartContext } from \"./context\";\nimport type { TooltipContent } from \"./tooltip\";\nimport { domHelpers } from \"./tooltip\";\n\nexport interface BarChartDatumValue {\n  currency: string;\n  value: number;\n  budget: number;\n}\n\n/** The data for the bars of one interval. */\nexport interface BarChartDatum {\n  /** The label of this interval. */\n  label: string;\n  /** The date of this interval. */\n  date: Date;\n  /** One value for each (operating) currency. */\n  values: BarChartDatumValue[];\n  /** The balances of the child accounts. */\n  account_balances: Record<string, Record<string, number>>;\n}\n\nexport interface BarChart {\n  type: \"barchart\";\n  data: {\n    /** All accounts that occur as some child account. */\n    accounts: string[];\n    /** The data for the (single) bars for all the intervals in this chart. */\n    bar_groups: BarChartDatum[];\n    /** For each currency, the stacks (one series per account) */\n    stacks: [currency: string, stacks: Series<BarChartDatum, string>[]][];\n    /** Whether this chart contains any stacks (or is just a single account). */\n    hasStackedData: boolean;\n  };\n  tooltipText: (\n    c: FormatterContext,\n    d: BarChartDatum,\n    e: string\n  ) => TooltipContent;\n}\n\nconst bar_validator = array(\n  object({\n    date,\n    budgets: record(number),\n    balance: record(number),\n    account_balances: record(record(number)),\n  })\n);\n\n/**\n * Try to parse a bar chart.\n */\nexport function bar(\n  json: unknown,\n  { currencies, dateFormat }: ChartContext\n): Result<BarChart, string> {\n  const res = bar_validator(json);\n  if (!res.success) {\n    return res;\n  }\n  const parsedData = res.value;\n  const bar_groups = parsedData.map((interval) => ({\n    values: currencies.map((currency) => ({\n      currency,\n      value: interval.balance[currency] ?? 0,\n      budget: interval.budgets[currency] ?? 0,\n    })),\n    date: interval.date,\n    label: dateFormat(interval.date),\n    account_balances: interval.account_balances,\n  }));\n  const accounts = Array.from(\n    new Set(parsedData.map((d) => [...Object.keys(d.account_balances)]).flat(2))\n  ).sort();\n  const hasStackedData = accounts.length > 1;\n\n  const stacks = currencies.map(\n    (currency): [string, Series<BarChartDatum, string>[]] => [\n      currency,\n      stack<BarChartDatum>()\n        .keys(accounts)\n        .value((obj, key) => obj.account_balances[key]?.[currency] ?? 0)\n        .offset(stackOffsetDiverging)(bar_groups),\n    ]\n  );\n\n  return ok({\n    type: \"barchart\" as const,\n    data: { accounts, bar_groups, stacks, hasStackedData },\n    tooltipText: (c, d, e) => {\n      const content: TooltipContent = [];\n      if (e === \"\") {\n        d.values.forEach((a) => {\n          content.push(\n            domHelpers.t(\n              a.budget\n                ? `${c.amount(a.value, a.currency)} / ${c.amount(\n                    a.budget,\n                    a.currency\n                  )}`\n                : c.amount(a.value, a.currency)\n            )\n          );\n          content.push(domHelpers.br());\n        });\n      } else {\n        content.push(domHelpers.em(e));\n        d.values.forEach((a) => {\n          const value = d.account_balances[e]?.[a.currency] ?? 0;\n          content.push(domHelpers.t(`${c.amount(value, a.currency)}`));\n          content.push(domHelpers.br());\n        });\n      }\n      content.push(domHelpers.em(d.label));\n      return content;\n    },\n  });\n}\n", "import type { Readable } from \"svelte/store\";\nimport { derived } from \"svelte/store\";\n\nimport { currentDateFormat } from \"../format\";\nimport { conversion, currencies, operating_currency } from \"../stores\";\n\nexport type ChartContext = {\n  currencies: string[];\n  dateFormat: (date: Date) => string;\n};\n\n/**\n * The list of operating currencies, adding in the current conversion currency.\n */\nconst operatingCurrenciesWithConversion = derived(\n  [operating_currency, currencies, conversion],\n  ([operating_currency_val, currencies_val, conversion_val]) =>\n    currencies_val.includes(conversion_val) &&\n    !operating_currency_val.includes(conversion_val)\n      ? [...operating_currency_val, conversion_val]\n      : operating_currency_val\n);\n\nexport const chartContext: Readable<ChartContext> = derived(\n  [operatingCurrenciesWithConversion, currentDateFormat],\n  ([currencies_val, dateFormat]) => ({ currencies: currencies_val, dateFormat })\n);\n", "import type { FormatterContext } from \"../format\";\nimport { day } from \"../format\";\nimport { ok } from \"../lib/result\";\nimport type { Result } from \"../lib/result\";\nimport {\n  array,\n  date,\n  number,\n  object,\n  record,\n  string,\n  tuple,\n} from \"../lib/validation\";\n\nimport type { TooltipContent } from \"./tooltip\";\nimport { domHelpers } from \"./tooltip\";\n\nexport interface LineChartDatum {\n  name: string;\n  date: Date;\n  value: number;\n}\n\nexport type LineChartData = {\n  name: string;\n  values: LineChartDatum[];\n};\n\nexport interface LineChart {\n  type: \"linechart\";\n  data: LineChartData[];\n  tooltipText: (c: FormatterContext, d: LineChartDatum) => TooltipContent;\n}\n\nconst balances_validator = array(object({ date, balance: record(number) }));\n\nexport function balances(json: unknown): Result<LineChart, string> {\n  const res = balances_validator(json);\n  if (!res.success) {\n    return res;\n  }\n  const parsedData = res.value;\n  const groups = new Map<string, LineChartDatum[]>();\n  for (const { date: date_, balance } of parsedData) {\n    Object.entries(balance).forEach(([currency, value]) => {\n      const group = groups.get(currency);\n      const datum = { date: date_, value, name: currency };\n      if (group) {\n        group.push(datum);\n      } else {\n        groups.set(currency, [datum]);\n      }\n    });\n  }\n  const data = [...groups.entries()].map(([name, values]) => ({\n    name,\n    values,\n  }));\n\n  return ok({\n    type: \"linechart\" as const,\n    data,\n    tooltipText: (c, d) => [\n      domHelpers.t(c.amount(d.value, d.name)),\n      domHelpers.em(day(d.date)),\n    ],\n  });\n}\n\nconst commodities_validator = object({\n  quote: string,\n  base: string,\n  prices: array(tuple([date, number])),\n});\n\nexport function commodities(\n  json: unknown,\n  _ctx: unknown,\n  label: string\n): Result<LineChart, string> {\n  const res = commodities_validator(json);\n  if (!res.success) {\n    return res;\n  }\n  const { base, quote, prices } = res.value;\n  const values = prices.map((d) => ({ name: label, date: d[0], value: d[1] }));\n  return ok({\n    type: \"linechart\" as const,\n    data: [{ name: label, values }],\n    tooltipText: (c, d) => [\n      domHelpers.t(`1 ${base} = ${c.amount(d.value, quote)}`),\n      domHelpers.em(day(d.date)),\n    ],\n  });\n}\n", "import { pointer } from \"d3-selection\";\n\n/** The tooltip div, lazily created. */\nconst tooltip = (() => {\n  let value: HTMLDivElement | null = null;\n  return () => {\n    if (value === null) {\n      value = document.createElement(\"div\");\n      value.className = \"tooltip\";\n      document.body.appendChild(value);\n    }\n    return value;\n  };\n})();\n\n/** Hide the tooltip. */\nconst hide = (): void => {\n  const t = tooltip();\n  t.style.opacity = \"0\";\n};\n\n/** Some small utilities to create tooltip contents. */\nexport const domHelpers = {\n  br: () => document.createElement(\"br\"),\n  em: (content: string) => {\n    const em = document.createElement(\"em\");\n    em.textContent = content;\n    return em;\n  },\n  t: (text: string) => document.createTextNode(text),\n};\n\nexport type TooltipContent = (HTMLElement | Text)[];\n\n/**\n * Svelte action to have the given element act on mouse to show a tooltip.\n *\n * The tooltip will be positioned at the cursor and is given a tooltip getter\n * per <g> element.\n */\nexport function followingTooltip(\n  node: SVGElement,\n  text: () => TooltipContent\n): { destroy: () => void; update: (t: () => TooltipContent) => void } {\n  let getter = text;\n  /** Event listener to have the tooltip follow the mouse. */\n  function followMouse(event: MouseEvent): void {\n    const t = tooltip();\n    t.style.opacity = \"1\";\n    t.style.left = `${event.pageX}px`;\n    t.style.top = `${event.pageY - 15}px`;\n  }\n  node.addEventListener(\"mouseenter\", () => {\n    const t = tooltip();\n    t.replaceChildren(...getter());\n  });\n  node.addEventListener(\"mousemove\", followMouse);\n  node.addEventListener(\"mouseleave\", hide);\n\n  return {\n    destroy: hide,\n    update(t: () => TooltipContent): void {\n      getter = t;\n    },\n  };\n}\n\n/** A function to find the closest node and the content to show in the tooltip. */\nexport type TooltipFindNode = (\n  x: number,\n  y: number\n) => [number, number, TooltipContent] | undefined;\n\n/**\n * Svelte action to have the given <g> element act on mouse to show a tooltip.\n *\n * The parameter to the tooltip is a function that takes a position (relative\n * to the container) as input and should return the position of the tooltip,\n * i.e., the found node, again relative to the container and the desired\n * content of the tooltip.\n */\nexport function positionedTooltip(\n  node: SVGGElement,\n  find: TooltipFindNode\n): { destroy: () => void } {\n  function mousemove(event: MouseEvent): void {\n    const [xPointer, yPointer] = pointer(event);\n    const res = find(xPointer, yPointer);\n    const matrix = node.getScreenCTM();\n    if (res && matrix) {\n      const [x, y, content] = res;\n      const t = tooltip();\n      t.style.opacity = \"1\";\n      t.replaceChildren(...content);\n      t.style.left = `${window.scrollX + x + matrix.e}px`;\n      t.style.top = `${window.scrollY + y + matrix.f - 15}px`;\n    } else {\n      hide();\n    }\n  }\n  node.addEventListener(\"mousemove\", mousemove);\n  node.addEventListener(\"mouseleave\", hide);\n\n  return {\n    destroy: hide,\n  };\n}\n", "/**\n * Add a tooltip showing the keyboard shortcut over the target element.\n * @param target - The target element to show the tooltip on.\n * @returns A function to remove event handler.\n */\nfunction showTooltip(target: HTMLElement): () => void {\n  const tooltip = document.createElement(\"div\");\n  const isHidden = target.classList.contains(\"hidden\");\n  if (isHidden) {\n    target.classList.remove(\"hidden\");\n  }\n  tooltip.className = \"keyboard-tooltip\";\n  tooltip.textContent = target.getAttribute(\"data-key\") ?? \"\";\n  document.body.appendChild(tooltip);\n  const parentCoords = target.getBoundingClientRect();\n  // Padded 10px to the left if there is space or centered otherwise\n  const left =\n    parentCoords.left +\n    Math.min((target.offsetWidth - tooltip.offsetWidth) / 2, 10);\n  const top =\n    parentCoords.top + (target.offsetHeight - tooltip.offsetHeight) / 2;\n  tooltip.style.left = `${left}px`;\n  tooltip.style.top = `${top + window.pageYOffset}px`;\n  return (): void => {\n    tooltip.remove();\n    if (isHidden) {\n      target.classList.add(\"hidden\");\n    }\n  };\n}\n\n/**\n * Show all keyboard shortcut tooltips.\n */\nfunction showTooltips(): () => void {\n  const removes: (() => void)[] = [];\n  document.querySelectorAll(\"[data-key]\").forEach((el) => {\n    if (el instanceof HTMLElement) {\n      removes.push(showTooltip(el));\n    }\n  });\n  return (): void => {\n    removes.forEach((r) => r());\n  };\n}\n\n/**\n * Ignore events originating from editable elements.\n * @param element - The element to check.\n * @returns true if the element is one of input/select/textarea or a\n *          contentEditable element.\n */\nfunction isEditableElement(element: EventTarget | null): boolean {\n  return (\n    element instanceof HTMLElement &&\n    (element instanceof HTMLInputElement ||\n      element instanceof HTMLSelectElement ||\n      element instanceof HTMLTextAreaElement ||\n      element.isContentEditable)\n  );\n}\n\n/** A handler function or an element to click. */\ntype KeyboardShortcutAction = ((event: KeyboardEvent) => void) | HTMLElement;\nconst keyboardShortcuts = new Map<string, KeyboardShortcutAction>();\n// The last typed character to check for sequences of two keys.\nlet lastChar = \"\";\n\n/**\n * Handle a `keydown` event on the document.\n *\n * Dispatch to the relevant handler.\n */\nfunction keydown(event: KeyboardEvent): void {\n  if (isEditableElement(event.target)) {\n    // ignore events in editable elements.\n    return;\n  }\n  let eventKey = event.key;\n  if (event.metaKey) {\n    eventKey = `Meta+${eventKey}`;\n  }\n  if (event.altKey) {\n    eventKey = `Alt+${eventKey}`;\n  }\n  if (event.ctrlKey) {\n    eventKey = `Control+${eventKey}`;\n  }\n  const lastTwoKeys = `${lastChar} ${eventKey}`;\n  const handler =\n    keyboardShortcuts.get(lastTwoKeys) ?? keyboardShortcuts.get(eventKey);\n  if (handler) {\n    if (handler instanceof HTMLInputElement) {\n      event.preventDefault();\n      handler.focus();\n    } else if (handler instanceof HTMLElement) {\n      handler.click();\n    } else {\n      handler(event);\n    }\n  }\n  if (event.key !== \"Alt\" && event.key !== \"Control\" && event.key !== \"Shift\") {\n    lastChar = eventKey;\n  }\n}\n\ndocument.addEventListener(\"keydown\", keydown);\n\n/** A type to specify a platform-dependent keyboard shortcut. */\nexport type KeySpec = string | { key: string; mac: string };\n\nconst currentPlatform: \"mac\" | \"key\" =\n  typeof navigator !== \"undefined\" && /Mac/.test(navigator.platform)\n    ? \"mac\"\n    : \"key\";\n\nexport const modKey = currentPlatform === \"mac\" ? \"Cmd\" : \"Ctrl\";\n\n/**\n * Get the keyboard key specifier string for the current platform.\n * @param keySpec - The key spec.\n */\nexport function getKeySpecKey(keySpec: KeySpec): string {\n  if (typeof keySpec === \"string\") {\n    return keySpec;\n  }\n  return currentPlatform === \"mac\" ? keySpec.mac : keySpec.key;\n}\n\n/**\n * Bind an event handler to a key.\n * @param key - The key to bind.\n * @param handler - The callback to run on key press.\n * @returns A function to unbind the keyboard handler.\n */\nexport function bindKey(\n  keySpec: KeySpec,\n  handler: KeyboardShortcutAction\n): () => void {\n  const key = getKeySpecKey(keySpec);\n  const sequence = key.split(\" \");\n  if (sequence.length > 2) {\n    // eslint-disable-next-line no-console\n    console.error(\"Only key sequences of length <=2 are supported: \", key);\n  }\n  if (keyboardShortcuts.has(key)) {\n    // eslint-disable-next-line no-console\n    console.warn(\"Duplicate keyboard shortcut: \", key, handler);\n  }\n  keyboardShortcuts.set(key, handler);\n  return (): void => {\n    keyboardShortcuts.delete(key);\n  };\n}\n\n/**\n * A svelte action to attach a global keyboard shortcut.\n *\n * This will attach a listener for the given key (or key sequence of length 2).\n * This listener will focus the given node if it is an <input> element and\n * trigger a click on it otherwise.\n */\nexport function keyboardShortcut(\n  node: HTMLElement,\n  key?: string\n): { destroy?: () => void } {\n  if (!key) {\n    return {};\n  }\n  node.setAttribute(\"data-key\", key);\n  const destroy = bindKey(key, node);\n\n  return { destroy };\n}\n\n/**\n * Register keyboard shortcuts for all newly added elements with a\n * `data-keyboard-shortcut` attribute.\n */\nexport function initCurrentKeyboardShortcuts(): void {\n  // clean up\n  for (const [key, action] of keyboardShortcuts.entries()) {\n    if (action instanceof HTMLElement && !document.contains(action)) {\n      keyboardShortcuts.delete(key);\n    }\n  }\n  document.querySelectorAll(\"[data-keyboard-shortcut]\").forEach((element) => {\n    const key = element.getAttribute(\"data-keyboard-shortcut\");\n    if (key && element instanceof HTMLElement) {\n      element.removeAttribute(\"data-keyboard-shortcut\");\n      element.setAttribute(\"data-key\", key);\n      bindKey(key, element);\n    }\n  });\n}\n\n/**\n * Register the keys to show/hide the tooltips\n */\nexport function initGlobalKeyboardShortcuts(): void {\n  bindKey(\"?\", () => {\n    const hide = showTooltips();\n    const once = () => {\n      hide();\n      document.removeEventListener(\"mousedown\", once);\n      document.removeEventListener(\"keydown\", once);\n    };\n    document.addEventListener(\"mousedown\", once);\n    document.addEventListener(\"keydown\", once);\n  });\n}\n", "/**\n * This script updates the links and error count in the sidebar as well as\n * toggling the sidebar on mobile.\n */\n\nimport { errorCount } from \"../stores\";\n\nexport function updateSidebar(): void {\n  document.querySelectorAll(\"aside a\").forEach((el) => {\n    el.classList.remove(\"selected\");\n    const href = el.getAttribute(\"href\");\n    if (\n      !el.hasAttribute(\"data-remote\") &&\n      href?.includes(window.location.pathname) &&\n      !el.matches(\".submenu a\")\n    ) {\n      el.classList.add(\"selected\");\n    }\n  });\n}\n\nexport function initSidebar(): void {\n  const errorCountEl = document.getElementById(\"error-count\");\n  if (errorCountEl instanceof HTMLLIElement) {\n    errorCount.subscribe((errorCount_val) => {\n      errorCountEl.classList.toggle(\"hidden\", errorCount_val === 0);\n      const span = errorCountEl.querySelector(\"span\");\n      if (span) {\n        span.textContent = `${errorCount_val}`;\n      }\n    });\n  }\n\n  const asideButton = document.getElementById(\"aside-button\");\n  if (asideButton instanceof HTMLButtonElement) {\n    asideButton.addEventListener(\"click\", () => {\n      document.querySelector(\"aside\")?.classList.toggle(\"active\");\n      asideButton.classList.toggle(\"active\");\n    });\n  }\n}\n"], "filenames": ["frontend/src/charts/ScatterPlot.svelte", "frontend/src/charts/Treemap.svelte", "frontend/src/charts/bar.ts", "frontend/src/charts/context.ts", "frontend/src/charts/line.ts", "frontend/src/charts/tooltip.ts", "frontend/src/keyboard-shortcuts.ts", "frontend/src/sidebar/index.ts"], "buggy_code_start_loc": [13, 14, 9, 5, 13, 21, 13, 29], "buggy_code_end_loc": [55, 41, 112, 27, 88, 82, 14, 30], "fixing_code_start_loc": [13, 14, 10, 5, 14, 22, 13, 29], "fixing_code_end_loc": [55, 44, 125, 22, 94, 95, 14, 30], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Reflected in GitHub repository beancount/fava prior to 1.22.3.", "other": {"cve": {"id": "CVE-2022-2589", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-01T15:15:09.583", "lastModified": "2022-08-04T23:29:01.717", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Reflected in GitHub repository beancount/fava prior to 1.22.3."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-site Scripting (XSS) - Reflejado en el repositorio de GitHub beancount/fava versiones anteriores a 1.22.3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:C/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 4.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fava_project:fava:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.22.3", "matchCriteriaId": "BB511EAA-25BF-4D11-B407-12E34592352E"}]}]}], "references": [{"url": "https://github.com/beancount/fava/commit/68bbb6e39319deb35ab9f18d0b6aa9fa70472539", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8705800d-cf2f-433d-9c3e-dbef6a3f7e08", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/beancount/fava/commit/68bbb6e39319deb35ab9f18d0b6aa9fa70472539"}}