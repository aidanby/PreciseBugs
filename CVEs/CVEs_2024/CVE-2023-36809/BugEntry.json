{"buggy_code": ["# -*- coding: utf-8 -*-\n\nfrom django.conf import settings\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.db import models\nfrom django.urls import reverse\nfrom tree_queries.models import TreeNode\nfrom uuslug import slugify\n\nfrom tcms.core.history import KiwiHistoricalRecords\nfrom tcms.core.models.base import UrlMixin\nfrom tcms.management.models import Version\nfrom tcms.testcases.models import TestCasePlan\n\n\nclass PlanType(models.Model, UrlMixin):\n    name = models.CharField(max_length=64, unique=True)\n    description = models.TextField(blank=True, null=True)\n\n    def __str__(self):\n        return self.name\n\n    class Meta:\n        ordering = [\"name\"]\n\n\nclass TestPlan(TreeNode, UrlMixin):\n    \"\"\"A plan within the TCMS\"\"\"\n\n    history = KiwiHistoricalRecords()\n\n    name = models.CharField(max_length=255, db_index=True)\n    text = models.TextField(blank=True)\n    create_date = models.DateTimeField(auto_now_add=True)\n    is_active = models.BooleanField(default=True, db_index=True)\n    extra_link = models.CharField(max_length=1024, default=None, blank=True, null=True)\n\n    product_version = models.ForeignKey(\n        Version, related_name=\"plans\", on_delete=models.CASCADE\n    )\n    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)\n    product = models.ForeignKey(\n        \"management.Product\", related_name=\"plan\", on_delete=models.CASCADE\n    )\n    type = models.ForeignKey(PlanType, on_delete=models.CASCADE)\n    tag = models.ManyToManyField(\n        \"management.Tag\", through=\"testplans.TestPlanTag\", related_name=\"plan\"\n    )\n\n    def __str__(self):\n        return self.name\n\n    def add_case(self, case, sortkey=None):\n        if sortkey is None:\n            lastcase = self.testcaseplan_set.order_by(\"-sortkey\").first()\n            if lastcase and lastcase.sortkey is not None:\n                sortkey = lastcase.sortkey + 10\n            else:\n                sortkey = 0\n\n        return TestCasePlan.objects.get_or_create(\n            plan=self, case=case, defaults={\"sortkey\": sortkey}\n        )[0]\n\n    def add_tag(self, tag):\n        return TestPlanTag.objects.get_or_create(plan=self, tag=tag)\n\n    def remove_tag(self, tag):\n        TestPlanTag.objects.filter(plan=self, tag=tag).delete()\n\n    def delete_case(self, case):\n        TestCasePlan.objects.filter(case=case.pk, plan=self.pk).delete()\n\n    def _get_absolute_url(self):\n        return reverse(\"test_plan_url\", args=[self.pk, slugify(self.name)])\n\n    def get_absolute_url(self):\n        return self._get_absolute_url()\n\n    def get_full_url(self):\n        return super().get_full_url().rstrip(\"/\")\n\n    def _get_email_conf(self):\n        try:\n            # note: this is the reverse_name of a 1-to-1 field\n            return self.email_settings  # pylint: disable=no-member\n        except ObjectDoesNotExist:\n            return TestPlanEmailSettings.objects.create(plan=self)\n\n    emailing = property(_get_email_conf)\n\n    def make_cloned_name(self):\n        \"\"\"Make default name of cloned plan\"\"\"\n        return f\"Copy of {self.name}\"\n\n    def clone(  # pylint: disable=too-many-arguments\n        self,\n        name=None,\n        product=None,\n        version=None,\n        new_author=None,\n        set_parent=False,\n        copy_testcases=False,\n        **_kwargs,\n    ):\n        \"\"\"Clone this plan\n\n        :param name: New name of cloned plan. If not passed, make_cloned_name is called\n            to generate a default one.\n        :type name: str\n        :param product: Product of cloned plan. If not passed, original plan's product is used.\n        :type product: :class:`tcms.management.models.Product`\n        :param version: Product version of cloned plan. If not passed use from source plan.\n        :type version: :class:`tcms.management.models.Version`\n        :param new_author: New author of cloned plan. If not passed, original plan's\n            author is used.\n        :type new_author: settings.AUTH_USER_MODEL\n        :param set_parent: Whether to set original plan as parent of cloned plan.\n            Default is False.\n        :type set_parent: bool\n        :param copy_testcases: Whether to copy cases to cloned plan instead of just\n            linking them. Default is False.\n        :type copy_testcases: bool\n        :param \\\\**_kwargs: Unused catch-all variable container for any extra input\n            which may be present\n        :return: cloned plan\n        :rtype: :class:`tcms.testplans.models.TestPlan`\n        \"\"\"\n        tp_dest = TestPlan.objects.create(\n            name=name or self.make_cloned_name(),\n            product=product or self.product,\n            author=new_author or self.author,\n            type=self.type,\n            product_version=version or self.product_version,\n            create_date=self.create_date,\n            is_active=self.is_active,\n            extra_link=self.extra_link,\n            parent=self if set_parent else None,\n            text=self.text,\n        )\n\n        # Copy the plan tags\n        for tp_tag_src in self.tag.all():\n            tp_dest.add_tag(tag=tp_tag_src)\n\n        # include TCs inside cloned TP\n        qs = self.cases.all().annotate(sortkey=models.F(\"testcaseplan__sortkey\"))\n        for tc_src in qs:\n            # this parameter should really be named clone_testcases b/c if set\n            # it clones the source TC and then adds it to the new TP\n            if copy_testcases:\n                tc_src.clone(new_author, [tp_dest])\n            else:\n                # otherwise just link the existing TC to the new TP\n                tp_dest.add_case(tc_src, sortkey=tc_src.sortkey)\n\n        return tp_dest\n\n    def tree_as_list(self):\n        \"\"\"\n        Returns the entire tree family as a list of TestPlan\n        object with additional fields from tree_queries!\n        \"\"\"\n        plan = TestPlan.objects.with_tree_fields().get(pk=self.pk)\n\n        tree_root = plan.ancestors(include_self=True).first()\n        result = tree_root.descendants(include_self=True)\n\n        return result\n\n    def tree_view_html(self):\n        \"\"\"\n        Returns nested tree structure represented as Patterfly TreeView!\n        Relies on the fact that tree nodes are returned in DFS\n        order!\n        \"\"\"\n        tree_nodes = self.tree_as_list()\n\n        # TP is not part of a tree\n        if len(tree_nodes) == 1:\n            return \"\"\n\n        result = \"\"\n        previous_depth = -1\n\n        for test_plan in tree_nodes:\n            # close tags for previously rendered node before rendering current one\n            if test_plan.tree_depth == previous_depth:\n                result += \"\"\"\n                    </div><!-- end-subtree -->\n                </div> <!-- end-node -->\"\"\"\n\n            # indent\n            if test_plan.tree_depth > previous_depth:\n                previous_depth = test_plan.tree_depth\n\n            # outdent\n            did_outdent = False\n            while test_plan.tree_depth < previous_depth:\n                result += \"\"\"\n                    </div><!-- end-subtree -->\n                </div> <!-- end-node -->\"\"\"\n                previous_depth -= 1\n                did_outdent = True\n\n            if did_outdent:\n                result += \"\"\"\n                    </div><!-- end-subtree -->\n                </div> <!-- end-node -->\"\"\"\n\n            # render the current node\n            active_class = \"\"\n            if test_plan.pk == self.pk:\n                active_class = \"active\"\n\n            result += f\"\"\"\n                <!-- begin-node -->\n                <div class=\"list-group-item {active_class}\" style=\"border: none\">\n                    <div class=\"list-group-item-header\" style=\"padding:0\">\n                        <div class=\"list-view-pf-main-info\"\n                             style=\"padding-top:0; padding-bottom:0\">\n                            <div class=\"list-view-pf-left\"\n                                 style=\"margin-left:3px; padding-right:10px\">\n                                <span class=\"fa fa-angle-right\"></span>\n                            </div>\n\n                            <div class=\"list-view-pf-body\">\n                                <div class=\"list-view-pf-description\">\n                                    <div class=\"list-group-item-text\">\n                                        <a href=\"{test_plan.get_absolute_url()}\">\n                                            TP-{test_plan.pk}: {test_plan.name}\n                                        </a>\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                    </div> <!-- /header -->\n\n                    <!-- begin-subtree -->\n                    <div class=\"list-group-item-container container-fluid\" style=\"border: none\">\n            \"\"\"\n\n        # close after the last elements in the for loop\n        while previous_depth >= 0:\n            result += \"\"\"\n                    </div><!-- end-subtree -->\n                </div> <!-- end-node -->\"\"\"\n            previous_depth -= 1\n\n        # HTML sanity check\n        begin_node = result.count(\"<!-- begin-node -->\")\n        end_node = result.count(\"<!-- end-node -->\")\n\n        begin_subtree = result.count(\"<!-- begin-subtree -->\")\n        end_subtree = result.count(\"<!-- end-subtree -->\")\n\n        # tese will make sure that we catch errors in production\n        if begin_node != end_node:\n            raise RuntimeError(\"Begin/End count for tree-view nodes don't match\")\n\n        if begin_subtree != end_subtree:\n            raise RuntimeError(\"Begin/End count for tree-view subtrees don't match\")\n\n        return f\"\"\"\n            <div id=\"test-plan-family-tree\"\n                 class=\"list-group tree-list-view-pf\"\n                 style=\"margin-top:0\">\n                {result}\n            </div>\n        \"\"\"\n\n\nclass TestPlanTag(models.Model):\n    tag = models.ForeignKey(\"management.Tag\", on_delete=models.CASCADE)\n    plan = models.ForeignKey(TestPlan, on_delete=models.CASCADE)\n\n\nclass TestPlanEmailSettings(models.Model):\n    plan = models.OneToOneField(\n        TestPlan, related_name=\"email_settings\", on_delete=models.CASCADE\n    )\n    auto_to_plan_author = models.BooleanField(default=True)\n    auto_to_case_owner = models.BooleanField(default=True)\n    auto_to_case_default_tester = models.BooleanField(default=True)\n    notify_on_plan_update = models.BooleanField(default=True)\n    notify_on_case_update = models.BooleanField(default=True)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\nfrom django.conf import settings\nfrom django.core.exceptions import ObjectDoesNotExist\nfrom django.db import models\nfrom django.urls import reverse\nfrom tree_queries.models import TreeNode\nfrom uuslug import slugify\n\nfrom tcms.core.history import KiwiHistoricalRecords\nfrom tcms.core.models.base import UrlMixin\nfrom tcms.core.templatetags.extra_filters import bleach_input\nfrom tcms.management.models import Version\nfrom tcms.testcases.models import TestCasePlan\n\n\nclass PlanType(models.Model, UrlMixin):\n    name = models.CharField(max_length=64, unique=True)\n    description = models.TextField(blank=True, null=True)\n\n    def __str__(self):\n        return self.name\n\n    class Meta:\n        ordering = [\"name\"]\n\n\nclass TestPlan(TreeNode, UrlMixin):\n    \"\"\"A plan within the TCMS\"\"\"\n\n    history = KiwiHistoricalRecords()\n\n    name = models.CharField(max_length=255, db_index=True)\n    text = models.TextField(blank=True)\n    create_date = models.DateTimeField(auto_now_add=True)\n    is_active = models.BooleanField(default=True, db_index=True)\n    extra_link = models.CharField(max_length=1024, default=None, blank=True, null=True)\n\n    product_version = models.ForeignKey(\n        Version, related_name=\"plans\", on_delete=models.CASCADE\n    )\n    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)\n    product = models.ForeignKey(\n        \"management.Product\", related_name=\"plan\", on_delete=models.CASCADE\n    )\n    type = models.ForeignKey(PlanType, on_delete=models.CASCADE)\n    tag = models.ManyToManyField(\n        \"management.Tag\", through=\"testplans.TestPlanTag\", related_name=\"plan\"\n    )\n\n    def __str__(self):\n        return self.name\n\n    def add_case(self, case, sortkey=None):\n        if sortkey is None:\n            lastcase = self.testcaseplan_set.order_by(\"-sortkey\").first()\n            if lastcase and lastcase.sortkey is not None:\n                sortkey = lastcase.sortkey + 10\n            else:\n                sortkey = 0\n\n        return TestCasePlan.objects.get_or_create(\n            plan=self, case=case, defaults={\"sortkey\": sortkey}\n        )[0]\n\n    def add_tag(self, tag):\n        return TestPlanTag.objects.get_or_create(plan=self, tag=tag)\n\n    def remove_tag(self, tag):\n        TestPlanTag.objects.filter(plan=self, tag=tag).delete()\n\n    def delete_case(self, case):\n        TestCasePlan.objects.filter(case=case.pk, plan=self.pk).delete()\n\n    def _get_absolute_url(self):\n        return reverse(\"test_plan_url\", args=[self.pk, slugify(self.name)])\n\n    def get_absolute_url(self):\n        return self._get_absolute_url()\n\n    def get_full_url(self):\n        return super().get_full_url().rstrip(\"/\")\n\n    def _get_email_conf(self):\n        try:\n            # note: this is the reverse_name of a 1-to-1 field\n            return self.email_settings  # pylint: disable=no-member\n        except ObjectDoesNotExist:\n            return TestPlanEmailSettings.objects.create(plan=self)\n\n    emailing = property(_get_email_conf)\n\n    def make_cloned_name(self):\n        \"\"\"Make default name of cloned plan\"\"\"\n        return f\"Copy of {self.name}\"\n\n    def clone(  # pylint: disable=too-many-arguments\n        self,\n        name=None,\n        product=None,\n        version=None,\n        new_author=None,\n        set_parent=False,\n        copy_testcases=False,\n        **_kwargs,\n    ):\n        \"\"\"Clone this plan\n\n        :param name: New name of cloned plan. If not passed, make_cloned_name is called\n            to generate a default one.\n        :type name: str\n        :param product: Product of cloned plan. If not passed, original plan's product is used.\n        :type product: :class:`tcms.management.models.Product`\n        :param version: Product version of cloned plan. If not passed use from source plan.\n        :type version: :class:`tcms.management.models.Version`\n        :param new_author: New author of cloned plan. If not passed, original plan's\n            author is used.\n        :type new_author: settings.AUTH_USER_MODEL\n        :param set_parent: Whether to set original plan as parent of cloned plan.\n            Default is False.\n        :type set_parent: bool\n        :param copy_testcases: Whether to copy cases to cloned plan instead of just\n            linking them. Default is False.\n        :type copy_testcases: bool\n        :param \\\\**_kwargs: Unused catch-all variable container for any extra input\n            which may be present\n        :return: cloned plan\n        :rtype: :class:`tcms.testplans.models.TestPlan`\n        \"\"\"\n        tp_dest = TestPlan.objects.create(\n            name=name or self.make_cloned_name(),\n            product=product or self.product,\n            author=new_author or self.author,\n            type=self.type,\n            product_version=version or self.product_version,\n            create_date=self.create_date,\n            is_active=self.is_active,\n            extra_link=self.extra_link,\n            parent=self if set_parent else None,\n            text=self.text,\n        )\n\n        # Copy the plan tags\n        for tp_tag_src in self.tag.all():\n            tp_dest.add_tag(tag=tp_tag_src)\n\n        # include TCs inside cloned TP\n        qs = self.cases.all().annotate(sortkey=models.F(\"testcaseplan__sortkey\"))\n        for tc_src in qs:\n            # this parameter should really be named clone_testcases b/c if set\n            # it clones the source TC and then adds it to the new TP\n            if copy_testcases:\n                tc_src.clone(new_author, [tp_dest])\n            else:\n                # otherwise just link the existing TC to the new TP\n                tp_dest.add_case(tc_src, sortkey=tc_src.sortkey)\n\n        return tp_dest\n\n    def tree_as_list(self):\n        \"\"\"\n        Returns the entire tree family as a list of TestPlan\n        object with additional fields from tree_queries!\n        \"\"\"\n        plan = TestPlan.objects.with_tree_fields().get(pk=self.pk)\n\n        tree_root = plan.ancestors(include_self=True).first()\n        result = tree_root.descendants(include_self=True)\n\n        return result\n\n    def tree_view_html(self):\n        \"\"\"\n        Returns nested tree structure represented as Patterfly TreeView!\n        Relies on the fact that tree nodes are returned in DFS\n        order!\n        \"\"\"\n        tree_nodes = self.tree_as_list()\n\n        # TP is not part of a tree\n        if len(tree_nodes) == 1:\n            return \"\"\n\n        result = \"\"\n        previous_depth = -1\n\n        for test_plan in tree_nodes:\n            # close tags for previously rendered node before rendering current one\n            if test_plan.tree_depth == previous_depth:\n                result += \"\"\"\n                    </div><!-- end-subtree -->\n                </div> <!-- end-node -->\"\"\"\n\n            # indent\n            if test_plan.tree_depth > previous_depth:\n                previous_depth = test_plan.tree_depth\n\n            # outdent\n            did_outdent = False\n            while test_plan.tree_depth < previous_depth:\n                result += \"\"\"\n                    </div><!-- end-subtree -->\n                </div> <!-- end-node -->\"\"\"\n                previous_depth -= 1\n                did_outdent = True\n\n            if did_outdent:\n                result += \"\"\"\n                    </div><!-- end-subtree -->\n                </div> <!-- end-node -->\"\"\"\n\n            # render the current node\n            active_class = \"\"\n            if test_plan.pk == self.pk:\n                active_class = \"active\"\n\n            plan_name = bleach_input(test_plan.name)\n            result += f\"\"\"\n                <!-- begin-node -->\n                <div class=\"list-group-item {active_class}\" style=\"border: none\">\n                    <div class=\"list-group-item-header\" style=\"padding:0\">\n                        <div class=\"list-view-pf-main-info\"\n                             style=\"padding-top:0; padding-bottom:0\">\n                            <div class=\"list-view-pf-left\"\n                                 style=\"margin-left:3px; padding-right:10px\">\n                                <span class=\"fa fa-angle-right\"></span>\n                            </div>\n\n                            <div class=\"list-view-pf-body\">\n                                <div class=\"list-view-pf-description\">\n                                    <div class=\"list-group-item-text\">\n                                        <a href=\"{test_plan.get_absolute_url()}\">\n                                            TP-{test_plan.pk}: {plan_name}\n                                        </a>\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                    </div> <!-- /header -->\n\n                    <!-- begin-subtree -->\n                    <div class=\"list-group-item-container container-fluid\" style=\"border: none\">\n            \"\"\"\n\n        # close after the last elements in the for loop\n        while previous_depth >= 0:\n            result += \"\"\"\n                    </div><!-- end-subtree -->\n                </div> <!-- end-node -->\"\"\"\n            previous_depth -= 1\n\n        # HTML sanity check\n        begin_node = result.count(\"<!-- begin-node -->\")\n        end_node = result.count(\"<!-- end-node -->\")\n\n        begin_subtree = result.count(\"<!-- begin-subtree -->\")\n        end_subtree = result.count(\"<!-- end-subtree -->\")\n\n        # tese will make sure that we catch errors in production\n        if begin_node != end_node:\n            raise RuntimeError(\"Begin/End count for tree-view nodes don't match\")\n\n        if begin_subtree != end_subtree:\n            raise RuntimeError(\"Begin/End count for tree-view subtrees don't match\")\n\n        return f\"\"\"\n            <div id=\"test-plan-family-tree\"\n                 class=\"list-group tree-list-view-pf\"\n                 style=\"margin-top:0\">\n                {result}\n            </div>\n        \"\"\"\n\n\nclass TestPlanTag(models.Model):\n    tag = models.ForeignKey(\"management.Tag\", on_delete=models.CASCADE)\n    plan = models.ForeignKey(TestPlan, on_delete=models.CASCADE)\n\n\nclass TestPlanEmailSettings(models.Model):\n    plan = models.OneToOneField(\n        TestPlan, related_name=\"email_settings\", on_delete=models.CASCADE\n    )\n    auto_to_plan_author = models.BooleanField(default=True)\n    auto_to_case_owner = models.BooleanField(default=True)\n    auto_to_case_default_tester = models.BooleanField(default=True)\n    notify_on_plan_update = models.BooleanField(default=True)\n    notify_on_case_update = models.BooleanField(default=True)\n"], "filenames": ["tcms/testplans/models.py"], "buggy_code_start_loc": [11], "buggy_code_end_loc": [232], "fixing_code_start_loc": [12], "fixing_code_end_loc": [234], "type": "CWE-79", "message": "Kiwi TCMS, an open source test management system allows users to upload attachments to test plans, test cases, etc. Versions of Kiwi TCMS prior to 12.5 had introduced changes which were meant to serve all uploaded files as plain text in order to prevent browsers from executing potentially dangerous files when such files are accessed directly. The previous Nginx configuration was incorrect allowing certain browsers like Firefox to ignore the `Content-Type: text/plain` header on some occasions thus allowing potentially dangerous scripts to be executed. Additionally, file upload validators and parts of the HTML rendering code had been found to require additional sanitation and improvements. Version 12.5 fixes this vulnerability with updated Nginx content type configuration, improved file upload validation code to prevent more potentially dangerous uploads, and Sanitization of test plan names used in the `tree_view_html()` function.", "other": {"cve": {"id": "CVE-2023-36809", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-05T22:15:09.670", "lastModified": "2023-07-12T17:38:32.513", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Kiwi TCMS, an open source test management system allows users to upload attachments to test plans, test cases, etc. Versions of Kiwi TCMS prior to 12.5 had introduced changes which were meant to serve all uploaded files as plain text in order to prevent browsers from executing potentially dangerous files when such files are accessed directly. The previous Nginx configuration was incorrect allowing certain browsers like Firefox to ignore the `Content-Type: text/plain` header on some occasions thus allowing potentially dangerous scripts to be executed. Additionally, file upload validators and parts of the HTML rendering code had been found to require additional sanitation and improvements. Version 12.5 fixes this vulnerability with updated Nginx content type configuration, improved file upload validation code to prevent more potentially dangerous uploads, and Sanitization of test plan names used in the `tree_view_html()` function."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-434"}, {"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kiwitcms:kiwi_tcms:*:*:*:*:*:*:*:*", "versionEndExcluding": "12.5", "matchCriteriaId": "A36039AD-D01B-4F13-96F0-A6A4E1D32482"}]}]}], "references": [{"url": "https://github.com/kiwitcms/Kiwi/security/advisories/GHSA-jpgw-2r9m-8qfw", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://huntr.dev/bounties/511489dd-ba38-4806-9029-b28ab2830aa8/", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/c6eeb346-fa99-4d41-bc40-b68f8d689223/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://kiwitcms.org/blog/kiwi-tcms-team/2023/07/04/kiwi-tcms-125/", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://www.github.com/kiwitcms/kiwi/commit/195ea53eaaf360c19227c864cc0fe58910032c3c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://www.github.com/kiwitcms/kiwi/commit/ffb00450be52fe11a82a2507632c2328cae4ec9d", "source": "security-advisories@github.com", "tags": ["Patch"]}]}, "github_commit_url": "https://www.github.com/kiwitcms/kiwi/commit/195ea53eaaf360c19227c864cc0fe58910032c3c"}}