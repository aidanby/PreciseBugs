{"buggy_code": ["/*\n * Copyright (c) 2010-2011 Atheros Communications Inc.\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"htc.h\"\n\nstatic int htc_issue_send(struct htc_target *target, struct sk_buff* skb,\n\t\t\t  u16 len, u8 flags, u8 epid)\n\n{\n\tstruct htc_frame_hdr *hdr;\n\tstruct htc_endpoint *endpoint = &target->endpoint[epid];\n\tint status;\n\n\thdr = skb_push(skb, sizeof(struct htc_frame_hdr));\n\thdr->endpoint_id = epid;\n\thdr->flags = flags;\n\thdr->payload_len = cpu_to_be16(len);\n\n\tstatus = target->hif->send(target->hif_dev, endpoint->ul_pipeid, skb);\n\n\treturn status;\n}\n\nstatic struct htc_endpoint *get_next_avail_ep(struct htc_endpoint *endpoint)\n{\n\tenum htc_endpoint_id avail_epid;\n\n\tfor (avail_epid = (ENDPOINT_MAX - 1); avail_epid > ENDPOINT0; avail_epid--)\n\t\tif (endpoint[avail_epid].service_id == 0)\n\t\t\treturn &endpoint[avail_epid];\n\treturn NULL;\n}\n\nstatic u8 service_to_ulpipe(u16 service_id)\n{\n\tswitch (service_id) {\n\tcase WMI_CONTROL_SVC:\n\t\treturn 4;\n\tcase WMI_BEACON_SVC:\n\tcase WMI_CAB_SVC:\n\tcase WMI_UAPSD_SVC:\n\tcase WMI_MGMT_SVC:\n\tcase WMI_DATA_VO_SVC:\n\tcase WMI_DATA_VI_SVC:\n\tcase WMI_DATA_BE_SVC:\n\tcase WMI_DATA_BK_SVC:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u8 service_to_dlpipe(u16 service_id)\n{\n\tswitch (service_id) {\n\tcase WMI_CONTROL_SVC:\n\t\treturn 3;\n\tcase WMI_BEACON_SVC:\n\tcase WMI_CAB_SVC:\n\tcase WMI_UAPSD_SVC:\n\tcase WMI_MGMT_SVC:\n\tcase WMI_DATA_VO_SVC:\n\tcase WMI_DATA_VI_SVC:\n\tcase WMI_DATA_BE_SVC:\n\tcase WMI_DATA_BK_SVC:\n\t\treturn 2;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void htc_process_target_rdy(struct htc_target *target,\n\t\t\t\t   void *buf)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_ready_msg *htc_ready_msg = (struct htc_ready_msg *) buf;\n\n\ttarget->credit_size = be16_to_cpu(htc_ready_msg->credit_size);\n\n\tendpoint = &target->endpoint[ENDPOINT0];\n\tendpoint->service_id = HTC_CTRL_RSVD_SVC;\n\tendpoint->max_msglen = HTC_MAX_CONTROL_MESSAGE_LENGTH;\n\tatomic_inc(&target->tgt_ready);\n\tcomplete(&target->target_wait);\n}\n\nstatic void htc_process_conn_rsp(struct htc_target *target,\n\t\t\t\t struct htc_frame_hdr *htc_hdr)\n{\n\tstruct htc_conn_svc_rspmsg *svc_rspmsg;\n\tstruct htc_endpoint *endpoint, *tmp_endpoint = NULL;\n\tu16 service_id;\n\tu16 max_msglen;\n\tenum htc_endpoint_id epid, tepid;\n\n\tsvc_rspmsg = (struct htc_conn_svc_rspmsg *)\n\t\t((void *) htc_hdr + sizeof(struct htc_frame_hdr));\n\n\tif (svc_rspmsg->status == HTC_SERVICE_SUCCESS) {\n\t\tepid = svc_rspmsg->endpoint_id;\n\t\tservice_id = be16_to_cpu(svc_rspmsg->service_id);\n\t\tmax_msglen = be16_to_cpu(svc_rspmsg->max_msg_len);\n\t\tendpoint = &target->endpoint[epid];\n\n\t\tfor (tepid = (ENDPOINT_MAX - 1); tepid > ENDPOINT0; tepid--) {\n\t\t\ttmp_endpoint = &target->endpoint[tepid];\n\t\t\tif (tmp_endpoint->service_id == service_id) {\n\t\t\t\ttmp_endpoint->service_id = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (tepid == ENDPOINT0)\n\t\t\treturn;\n\n\t\tendpoint->service_id = service_id;\n\t\tendpoint->max_txqdepth = tmp_endpoint->max_txqdepth;\n\t\tendpoint->ep_callbacks = tmp_endpoint->ep_callbacks;\n\t\tendpoint->ul_pipeid = tmp_endpoint->ul_pipeid;\n\t\tendpoint->dl_pipeid = tmp_endpoint->dl_pipeid;\n\t\tendpoint->max_msglen = max_msglen;\n\t\ttarget->conn_rsp_epid = epid;\n\t\tcomplete(&target->cmd_wait);\n\t} else {\n\t\ttarget->conn_rsp_epid = ENDPOINT_UNUSED;\n\t}\n}\n\nstatic int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC start timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\n/* HTC APIs */\n\nint htc_init(struct htc_target *target)\n{\n\tint ret;\n\n\tret = htc_config_pipe_credits(target);\n\tif (ret)\n\t\treturn ret;\n\n\treturn htc_setup_complete(target);\n}\n\nint htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\t/* Find an available endpoint */\n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"Endpoint is not available for service %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"Failed to allocate buf to send\"\n\t\t\t\"service connect req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nint htc_send(struct htc_target *target, struct sk_buff *skb)\n{\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\treturn htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);\n}\n\nint htc_send_epid(struct htc_target *target, struct sk_buff *skb,\n\t\t  enum htc_endpoint_id epid)\n{\n\treturn htc_issue_send(target, skb, skb->len, 0, epid);\n}\n\nvoid htc_stop(struct htc_target *target)\n{\n\ttarget->hif->stop(target->hif_dev);\n}\n\nvoid htc_start(struct htc_target *target)\n{\n\ttarget->hif->start(target->hif_dev);\n}\n\nvoid htc_sta_drain(struct htc_target *target, u8 idx)\n{\n\ttarget->hif->sta_drain(target->hif_dev, idx);\n}\n\nvoid ath9k_htc_txcompletion_cb(struct htc_target *htc_handle,\n\t\t\t       struct sk_buff *skb, bool txok)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_frame_hdr *htc_hdr = NULL;\n\n\tif (htc_handle->htc_flags & HTC_OP_CONFIG_PIPE_CREDITS) {\n\t\tcomplete(&htc_handle->cmd_wait);\n\t\thtc_handle->htc_flags &= ~HTC_OP_CONFIG_PIPE_CREDITS;\n\t\tgoto ret;\n\t}\n\n\tif (htc_handle->htc_flags & HTC_OP_START_WAIT) {\n\t\tcomplete(&htc_handle->cmd_wait);\n\t\thtc_handle->htc_flags &= ~HTC_OP_START_WAIT;\n\t\tgoto ret;\n\t}\n\n\tif (skb) {\n\t\thtc_hdr = (struct htc_frame_hdr *) skb->data;\n\t\tendpoint = &htc_handle->endpoint[htc_hdr->endpoint_id];\n\t\tskb_pull(skb, sizeof(struct htc_frame_hdr));\n\n\t\tif (endpoint->ep_callbacks.tx) {\n\t\t\tendpoint->ep_callbacks.tx(endpoint->ep_callbacks.priv,\n\t\t\t\t\t\t  skb, htc_hdr->endpoint_id,\n\t\t\t\t\t\t  txok);\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\treturn;\nret:\n\tkfree_skb(skb);\n}\n\nstatic void ath9k_htc_fw_panic_report(struct htc_target *htc_handle,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tuint32_t *pattern = (uint32_t *)skb->data;\n\n\tswitch (*pattern) {\n\tcase 0x33221199:\n\t\t{\n\t\tstruct htc_panic_bad_vaddr *htc_panic;\n\t\thtc_panic = (struct htc_panic_bad_vaddr *) skb->data;\n\t\tdev_err(htc_handle->dev, \"ath: firmware panic! \"\n\t\t\t\"exccause: 0x%08x; pc: 0x%08x; badvaddr: 0x%08x.\\n\",\n\t\t\thtc_panic->exccause, htc_panic->pc,\n\t\t\thtc_panic->badvaddr);\n\t\tbreak;\n\t\t}\n\tcase 0x33221299:\n\t\t{\n\t\tstruct htc_panic_bad_epid *htc_panic;\n\t\thtc_panic = (struct htc_panic_bad_epid *) skb->data;\n\t\tdev_err(htc_handle->dev, \"ath: firmware panic! \"\n\t\t\t\"bad epid: 0x%08x\\n\", htc_panic->epid);\n\t\tbreak;\n\t\t}\n\tdefault:\n\t\tdev_err(htc_handle->dev, \"ath: unknown panic pattern!\\n\");\n\t\tbreak;\n\t}\n}\n\n/*\n * HTC Messages are handled directly here and the obtained SKB\n * is freed.\n *\n * Service messages (Data, WMI) passed to the corresponding\n * endpoint RX handlers, which have to free the SKB.\n */\nvoid ath9k_htc_rx_msg(struct htc_target *htc_handle,\n\t\t      struct sk_buff *skb, u32 len, u8 pipe_id)\n{\n\tstruct htc_frame_hdr *htc_hdr;\n\tenum htc_endpoint_id epid;\n\tstruct htc_endpoint *endpoint;\n\t__be16 *msg_id;\n\n\tif (!htc_handle || !skb)\n\t\treturn;\n\n\thtc_hdr = (struct htc_frame_hdr *) skb->data;\n\tepid = htc_hdr->endpoint_id;\n\n\tif (epid == 0x99) {\n\t\tath9k_htc_fw_panic_report(htc_handle, skb);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (epid < 0 || epid >= ENDPOINT_MAX) {\n\t\tif (pipe_id != USB_REG_IN_PIPE)\n\t\t\tdev_kfree_skb_any(skb);\n\t\telse\n\t\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (epid == ENDPOINT0) {\n\n\t\t/* Handle trailer */\n\t\tif (htc_hdr->flags & HTC_FLAGS_RECV_TRAILER) {\n\t\t\tif (be32_to_cpu(*(__be32 *) skb->data) == 0x00C60000)\n\t\t\t\t/* Move past the Watchdog pattern */\n\t\t\t\thtc_hdr = (struct htc_frame_hdr *)(skb->data + 4);\n\t\t}\n\n\t\t/* Get the message ID */\n\t\tmsg_id = (__be16 *) ((void *) htc_hdr +\n\t\t\t\t     sizeof(struct htc_frame_hdr));\n\n\t\t/* Now process HTC messages */\n\t\tswitch (be16_to_cpu(*msg_id)) {\n\t\tcase HTC_MSG_READY_ID:\n\t\t\thtc_process_target_rdy(htc_handle, htc_hdr);\n\t\t\tbreak;\n\t\tcase HTC_MSG_CONNECT_SERVICE_RESPONSE_ID:\n\t\t\thtc_process_conn_rsp(htc_handle, htc_hdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree_skb(skb);\n\n\t} else {\n\t\tif (htc_hdr->flags & HTC_FLAGS_RECV_TRAILER)\n\t\t\tskb_trim(skb, len - htc_hdr->control[0]);\n\n\t\tskb_pull(skb, sizeof(struct htc_frame_hdr));\n\n\t\tendpoint = &htc_handle->endpoint[epid];\n\t\tif (endpoint->ep_callbacks.rx)\n\t\t\tendpoint->ep_callbacks.rx(endpoint->ep_callbacks.priv,\n\t\t\t\t\t\t  skb, epid);\n\t}\n}\n\nstruct htc_target *ath9k_htc_hw_alloc(void *hif_handle,\n\t\t\t\t      struct ath9k_htc_hif *hif,\n\t\t\t\t      struct device *dev)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_target *target;\n\n\ttarget = kzalloc(sizeof(struct htc_target), GFP_KERNEL);\n\tif (!target)\n\t\treturn NULL;\n\n\tinit_completion(&target->target_wait);\n\tinit_completion(&target->cmd_wait);\n\n\ttarget->hif = hif;\n\ttarget->hif_dev = hif_handle;\n\ttarget->dev = dev;\n\n\t/* Assign control endpoint pipe IDs */\n\tendpoint = &target->endpoint[ENDPOINT0];\n\tendpoint->ul_pipeid = hif->control_ul_pipe;\n\tendpoint->dl_pipeid = hif->control_dl_pipe;\n\n\tatomic_set(&target->tgt_ready, 0);\n\n\treturn target;\n}\n\nvoid ath9k_htc_hw_free(struct htc_target *htc)\n{\n\tkfree(htc);\n}\n\nint ath9k_htc_hw_init(struct htc_target *target,\n\t\t      struct device *dev, u16 devid,\n\t\t      char *product, u32 drv_info)\n{\n\tif (ath9k_htc_probe_device(target, dev, devid, product, drv_info)) {\n\t\tpr_err(\"Failed to initialize the device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nvoid ath9k_htc_hw_deinit(struct htc_target *target, bool hot_unplug)\n{\n\tif (target)\n\t\tath9k_htc_disconnect_device(target, hot_unplug);\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2010-2011 Atheros Communications Inc.\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"htc.h\"\n\nstatic int htc_issue_send(struct htc_target *target, struct sk_buff* skb,\n\t\t\t  u16 len, u8 flags, u8 epid)\n\n{\n\tstruct htc_frame_hdr *hdr;\n\tstruct htc_endpoint *endpoint = &target->endpoint[epid];\n\tint status;\n\n\thdr = skb_push(skb, sizeof(struct htc_frame_hdr));\n\thdr->endpoint_id = epid;\n\thdr->flags = flags;\n\thdr->payload_len = cpu_to_be16(len);\n\n\tstatus = target->hif->send(target->hif_dev, endpoint->ul_pipeid, skb);\n\n\treturn status;\n}\n\nstatic struct htc_endpoint *get_next_avail_ep(struct htc_endpoint *endpoint)\n{\n\tenum htc_endpoint_id avail_epid;\n\n\tfor (avail_epid = (ENDPOINT_MAX - 1); avail_epid > ENDPOINT0; avail_epid--)\n\t\tif (endpoint[avail_epid].service_id == 0)\n\t\t\treturn &endpoint[avail_epid];\n\treturn NULL;\n}\n\nstatic u8 service_to_ulpipe(u16 service_id)\n{\n\tswitch (service_id) {\n\tcase WMI_CONTROL_SVC:\n\t\treturn 4;\n\tcase WMI_BEACON_SVC:\n\tcase WMI_CAB_SVC:\n\tcase WMI_UAPSD_SVC:\n\tcase WMI_MGMT_SVC:\n\tcase WMI_DATA_VO_SVC:\n\tcase WMI_DATA_VI_SVC:\n\tcase WMI_DATA_BE_SVC:\n\tcase WMI_DATA_BK_SVC:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u8 service_to_dlpipe(u16 service_id)\n{\n\tswitch (service_id) {\n\tcase WMI_CONTROL_SVC:\n\t\treturn 3;\n\tcase WMI_BEACON_SVC:\n\tcase WMI_CAB_SVC:\n\tcase WMI_UAPSD_SVC:\n\tcase WMI_MGMT_SVC:\n\tcase WMI_DATA_VO_SVC:\n\tcase WMI_DATA_VI_SVC:\n\tcase WMI_DATA_BE_SVC:\n\tcase WMI_DATA_BK_SVC:\n\t\treturn 2;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void htc_process_target_rdy(struct htc_target *target,\n\t\t\t\t   void *buf)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_ready_msg *htc_ready_msg = (struct htc_ready_msg *) buf;\n\n\ttarget->credit_size = be16_to_cpu(htc_ready_msg->credit_size);\n\n\tendpoint = &target->endpoint[ENDPOINT0];\n\tendpoint->service_id = HTC_CTRL_RSVD_SVC;\n\tendpoint->max_msglen = HTC_MAX_CONTROL_MESSAGE_LENGTH;\n\tatomic_inc(&target->tgt_ready);\n\tcomplete(&target->target_wait);\n}\n\nstatic void htc_process_conn_rsp(struct htc_target *target,\n\t\t\t\t struct htc_frame_hdr *htc_hdr)\n{\n\tstruct htc_conn_svc_rspmsg *svc_rspmsg;\n\tstruct htc_endpoint *endpoint, *tmp_endpoint = NULL;\n\tu16 service_id;\n\tu16 max_msglen;\n\tenum htc_endpoint_id epid, tepid;\n\n\tsvc_rspmsg = (struct htc_conn_svc_rspmsg *)\n\t\t((void *) htc_hdr + sizeof(struct htc_frame_hdr));\n\n\tif (svc_rspmsg->status == HTC_SERVICE_SUCCESS) {\n\t\tepid = svc_rspmsg->endpoint_id;\n\t\tservice_id = be16_to_cpu(svc_rspmsg->service_id);\n\t\tmax_msglen = be16_to_cpu(svc_rspmsg->max_msg_len);\n\t\tendpoint = &target->endpoint[epid];\n\n\t\tfor (tepid = (ENDPOINT_MAX - 1); tepid > ENDPOINT0; tepid--) {\n\t\t\ttmp_endpoint = &target->endpoint[tepid];\n\t\t\tif (tmp_endpoint->service_id == service_id) {\n\t\t\t\ttmp_endpoint->service_id = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (tepid == ENDPOINT0)\n\t\t\treturn;\n\n\t\tendpoint->service_id = service_id;\n\t\tendpoint->max_txqdepth = tmp_endpoint->max_txqdepth;\n\t\tendpoint->ep_callbacks = tmp_endpoint->ep_callbacks;\n\t\tendpoint->ul_pipeid = tmp_endpoint->ul_pipeid;\n\t\tendpoint->dl_pipeid = tmp_endpoint->dl_pipeid;\n\t\tendpoint->max_msglen = max_msglen;\n\t\ttarget->conn_rsp_epid = epid;\n\t\tcomplete(&target->cmd_wait);\n\t} else {\n\t\ttarget->conn_rsp_epid = ENDPOINT_UNUSED;\n\t}\n}\n\nstatic int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\nstatic int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC start timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}\n\n/* HTC APIs */\n\nint htc_init(struct htc_target *target)\n{\n\tint ret;\n\n\tret = htc_config_pipe_credits(target);\n\tif (ret)\n\t\treturn ret;\n\n\treturn htc_setup_complete(target);\n}\n\nint htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\t/* Find an available endpoint */\n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"Endpoint is not available for service %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"Failed to allocate buf to send\"\n\t\t\t\"service connect req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nint htc_send(struct htc_target *target, struct sk_buff *skb)\n{\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\treturn htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);\n}\n\nint htc_send_epid(struct htc_target *target, struct sk_buff *skb,\n\t\t  enum htc_endpoint_id epid)\n{\n\treturn htc_issue_send(target, skb, skb->len, 0, epid);\n}\n\nvoid htc_stop(struct htc_target *target)\n{\n\ttarget->hif->stop(target->hif_dev);\n}\n\nvoid htc_start(struct htc_target *target)\n{\n\ttarget->hif->start(target->hif_dev);\n}\n\nvoid htc_sta_drain(struct htc_target *target, u8 idx)\n{\n\ttarget->hif->sta_drain(target->hif_dev, idx);\n}\n\nvoid ath9k_htc_txcompletion_cb(struct htc_target *htc_handle,\n\t\t\t       struct sk_buff *skb, bool txok)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_frame_hdr *htc_hdr = NULL;\n\n\tif (htc_handle->htc_flags & HTC_OP_CONFIG_PIPE_CREDITS) {\n\t\tcomplete(&htc_handle->cmd_wait);\n\t\thtc_handle->htc_flags &= ~HTC_OP_CONFIG_PIPE_CREDITS;\n\t\tgoto ret;\n\t}\n\n\tif (htc_handle->htc_flags & HTC_OP_START_WAIT) {\n\t\tcomplete(&htc_handle->cmd_wait);\n\t\thtc_handle->htc_flags &= ~HTC_OP_START_WAIT;\n\t\tgoto ret;\n\t}\n\n\tif (skb) {\n\t\thtc_hdr = (struct htc_frame_hdr *) skb->data;\n\t\tendpoint = &htc_handle->endpoint[htc_hdr->endpoint_id];\n\t\tskb_pull(skb, sizeof(struct htc_frame_hdr));\n\n\t\tif (endpoint->ep_callbacks.tx) {\n\t\t\tendpoint->ep_callbacks.tx(endpoint->ep_callbacks.priv,\n\t\t\t\t\t\t  skb, htc_hdr->endpoint_id,\n\t\t\t\t\t\t  txok);\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\treturn;\nret:\n\tkfree_skb(skb);\n}\n\nstatic void ath9k_htc_fw_panic_report(struct htc_target *htc_handle,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tuint32_t *pattern = (uint32_t *)skb->data;\n\n\tswitch (*pattern) {\n\tcase 0x33221199:\n\t\t{\n\t\tstruct htc_panic_bad_vaddr *htc_panic;\n\t\thtc_panic = (struct htc_panic_bad_vaddr *) skb->data;\n\t\tdev_err(htc_handle->dev, \"ath: firmware panic! \"\n\t\t\t\"exccause: 0x%08x; pc: 0x%08x; badvaddr: 0x%08x.\\n\",\n\t\t\thtc_panic->exccause, htc_panic->pc,\n\t\t\thtc_panic->badvaddr);\n\t\tbreak;\n\t\t}\n\tcase 0x33221299:\n\t\t{\n\t\tstruct htc_panic_bad_epid *htc_panic;\n\t\thtc_panic = (struct htc_panic_bad_epid *) skb->data;\n\t\tdev_err(htc_handle->dev, \"ath: firmware panic! \"\n\t\t\t\"bad epid: 0x%08x\\n\", htc_panic->epid);\n\t\tbreak;\n\t\t}\n\tdefault:\n\t\tdev_err(htc_handle->dev, \"ath: unknown panic pattern!\\n\");\n\t\tbreak;\n\t}\n}\n\n/*\n * HTC Messages are handled directly here and the obtained SKB\n * is freed.\n *\n * Service messages (Data, WMI) passed to the corresponding\n * endpoint RX handlers, which have to free the SKB.\n */\nvoid ath9k_htc_rx_msg(struct htc_target *htc_handle,\n\t\t      struct sk_buff *skb, u32 len, u8 pipe_id)\n{\n\tstruct htc_frame_hdr *htc_hdr;\n\tenum htc_endpoint_id epid;\n\tstruct htc_endpoint *endpoint;\n\t__be16 *msg_id;\n\n\tif (!htc_handle || !skb)\n\t\treturn;\n\n\thtc_hdr = (struct htc_frame_hdr *) skb->data;\n\tepid = htc_hdr->endpoint_id;\n\n\tif (epid == 0x99) {\n\t\tath9k_htc_fw_panic_report(htc_handle, skb);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (epid < 0 || epid >= ENDPOINT_MAX) {\n\t\tif (pipe_id != USB_REG_IN_PIPE)\n\t\t\tdev_kfree_skb_any(skb);\n\t\telse\n\t\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (epid == ENDPOINT0) {\n\n\t\t/* Handle trailer */\n\t\tif (htc_hdr->flags & HTC_FLAGS_RECV_TRAILER) {\n\t\t\tif (be32_to_cpu(*(__be32 *) skb->data) == 0x00C60000)\n\t\t\t\t/* Move past the Watchdog pattern */\n\t\t\t\thtc_hdr = (struct htc_frame_hdr *)(skb->data + 4);\n\t\t}\n\n\t\t/* Get the message ID */\n\t\tmsg_id = (__be16 *) ((void *) htc_hdr +\n\t\t\t\t     sizeof(struct htc_frame_hdr));\n\n\t\t/* Now process HTC messages */\n\t\tswitch (be16_to_cpu(*msg_id)) {\n\t\tcase HTC_MSG_READY_ID:\n\t\t\thtc_process_target_rdy(htc_handle, htc_hdr);\n\t\t\tbreak;\n\t\tcase HTC_MSG_CONNECT_SERVICE_RESPONSE_ID:\n\t\t\thtc_process_conn_rsp(htc_handle, htc_hdr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree_skb(skb);\n\n\t} else {\n\t\tif (htc_hdr->flags & HTC_FLAGS_RECV_TRAILER)\n\t\t\tskb_trim(skb, len - htc_hdr->control[0]);\n\n\t\tskb_pull(skb, sizeof(struct htc_frame_hdr));\n\n\t\tendpoint = &htc_handle->endpoint[epid];\n\t\tif (endpoint->ep_callbacks.rx)\n\t\t\tendpoint->ep_callbacks.rx(endpoint->ep_callbacks.priv,\n\t\t\t\t\t\t  skb, epid);\n\t}\n}\n\nstruct htc_target *ath9k_htc_hw_alloc(void *hif_handle,\n\t\t\t\t      struct ath9k_htc_hif *hif,\n\t\t\t\t      struct device *dev)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_target *target;\n\n\ttarget = kzalloc(sizeof(struct htc_target), GFP_KERNEL);\n\tif (!target)\n\t\treturn NULL;\n\n\tinit_completion(&target->target_wait);\n\tinit_completion(&target->cmd_wait);\n\n\ttarget->hif = hif;\n\ttarget->hif_dev = hif_handle;\n\ttarget->dev = dev;\n\n\t/* Assign control endpoint pipe IDs */\n\tendpoint = &target->endpoint[ENDPOINT0];\n\tendpoint->ul_pipeid = hif->control_ul_pipe;\n\tendpoint->dl_pipeid = hif->control_dl_pipe;\n\n\tatomic_set(&target->tgt_ready, 0);\n\n\treturn target;\n}\n\nvoid ath9k_htc_hw_free(struct htc_target *htc)\n{\n\tkfree(htc);\n}\n\nint ath9k_htc_hw_init(struct htc_target *target,\n\t\t      struct device *dev, u16 devid,\n\t\t      char *product, u32 drv_info)\n{\n\tif (ath9k_htc_probe_device(target, dev, devid, product, drv_info)) {\n\t\tpr_err(\"Failed to initialize the device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nvoid ath9k_htc_hw_deinit(struct htc_target *target, bool hot_unplug)\n{\n\tif (target)\n\t\tath9k_htc_disconnect_device(target, hot_unplug);\n}\n"], "filenames": ["drivers/net/wireless/ath/ath9k/htc_hst.c"], "buggy_code_start_loc": [172], "buggy_code_end_loc": [279], "fixing_code_start_loc": [173], "fixing_code_end_loc": [283], "type": "CWE-401", "message": "Memory leaks in drivers/net/wireless/ath/ath9k/htc_hst.c in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering wait_for_completion_timeout() failures. This affects the htc_config_pipe_credits() function, the htc_setup_complete() function, and the htc_connect_service() function, aka CID-853acf7caf10.", "other": {"cve": {"id": "CVE-2019-19073", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:13.187", "lastModified": "2021-06-14T18:15:18.383", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Memory leaks in drivers/net/wireless/ath/ath9k/htc_hst.c in the Linux kernel through 5.3.11 allow attackers to cause a denial of service (memory consumption) by triggering wait_for_completion_timeout() failures. This affects the htc_config_pipe_credits() function, the htc_setup_complete() function, and the htc_connect_service() function, aka CID-853acf7caf10."}, {"lang": "es", "value": "P\u00e9rdidas de memoria en el archivo drivers/net/wireless/ath/ath9k/htc_hst.c en el kernel de Linux versiones hasta la versi\u00f3n 5.3.11, permiten a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n wait_for_completion_timeout(). Esto afecta la funci\u00f3n htc_config_pipe_credits(), la funci\u00f3n htc_setup_complete() y la funci\u00f3n htc_connect_service(), tambi\u00e9n se conoce como CID-853acf7caf10."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.11", "matchCriteriaId": "EB2904AC-AD7A-498D-8619-CBB421E9165D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/853acf7caf10b828102d92d05b5c101666a6142b", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00032.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00034.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4526-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4527-1/", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/853acf7caf10b828102d92d05b5c101666a6142b"}}