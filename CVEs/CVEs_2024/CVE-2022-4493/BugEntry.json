{"buggy_code": ["/*\n * #%L\n * SCIFIO library for reading and converting scientific file formats.\n * %%\n * Copyright (C) 2011 - 2022 SCIFIO developers.\n * %%\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n * #L%\n */\n\npackage io.scif.util;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport javax.xml.bind.DatatypeConverter;\n\nimport org.freedesktop.BaseDirectory;\nimport org.scijava.download.DiskLocationCache;\nimport org.scijava.download.DownloadService;\nimport org.scijava.io.location.BytesLocation;\nimport org.scijava.io.location.FileLocation;\nimport org.scijava.io.location.Location;\nimport org.scijava.log.LogService;\nimport org.scijava.plugin.Parameter;\nimport org.scijava.plugin.Plugin;\nimport org.scijava.service.AbstractService;\nimport org.scijava.service.Service;\nimport org.scijava.task.Task;\nimport org.scijava.util.ByteArray;\nimport org.scijava.util.DigestUtils;\n\n/**\n * @author Gabriel Einsdorf, KNIME GmbH\n */\n@Plugin(type = Service.class)\npublic class DefaultSampleFilesService extends AbstractService implements\n\tSampleFileService\n{\n\n\t@Parameter\n\tprivate DownloadService downloadService;\n\n\t@Parameter\n\tprivate LogService log;\n\n\t/** Models which are already cached in memory. */\n\tprivate final Map<String, FileLocation> sources = new HashMap<>();\n\n\t/** stores retrieved sources locally */\n\tprivate DiskLocationCache sourceCache;\n\n\t@Override\n\tpublic FileLocation prepareFormatTestFolder(final Location... zipSources)\n\t\tthrows IOException\n\t{\n\t\tif (zipSources.length == 0) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"At least one zip source is required!\");\n\t\t}\n\n\t\tfinal byte[] bytes = Arrays.stream(zipSources).map(Object::toString).reduce(\n\t\t\t\"\", (a, b) -> a + b).getBytes();\n\t\tfinal String localFolderName = DatatypeConverter.printHexBinary(DigestUtils\n\t\t\t.sha1(bytes));\n\n\t\t// test if we already downloaded and unpacked the source\n\t\tFileLocation out = sources.get(localFolderName);\n\t\tif (out == null) {\n\t\t\t// not cached we need to download it\n\n\t\t\tfinal File basefolder = new File(sourceCache().getBaseDirectory(),\n\t\t\t\tlocalFolderName);\n\t\t\ttry {\n\t\t\t\tif (zipSources.length == 1) { // extract directly into basedir\n\t\t\t\t\tdownloadAndUnpackResource(zipSources[0], basefolder);\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tfor (final Location source : zipSources) {\n\t\t\t\t\t\tString targetName;\n\t\t\t\t\t\tif (source.getName().equals(source.defaultName())) {\n\t\t\t\t\t\t\ttargetName = source.getURI().getPath().substring(1).replaceAll(\"\\\\/\", \"-\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttargetName = source.getName();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfinal File target = new File(basefolder, targetName);\n\t\t\t\t\t\tdownloadAndUnpackResource(source, target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (final IOException | InterruptedException | ExecutionException e) {\n\t\t\t\t// cleanup\n\t\t\t\tif (basefolder.exists()) {\n\t\t\t\t\tbasefolder.delete();\n\t\t\t\t}\n\t\t\t\tthrow new IOException(e);\n\t\t\t}\n\n\t\t\tout = new FileLocation(basefolder);\n\t\t\tsources.put(localFolderName, out);\n\t\t}\n\n\t\treturn out;\n\t}\n\n\tprivate void downloadAndUnpackResource(final Location source,\n\t\tfinal File targetFolder) throws InterruptedException, ExecutionException,\n\t\tIOException\n\t{\n\t\t// allocate array\n\t\tfinal ByteArray byteArray = new ByteArray(1024 * 1024);\n\n\t\tlog.debug(\"Started download of \" + source.getURI());\n\t\t// Download the zip file\n\t\tfinal BytesLocation bytes = new BytesLocation(byteArray);\n\t\tfinal Task task = //\n\t\t\tdownloadService.download(source, bytes, sourceCache()).task();\n\t\ttask.waitFor();\n\n\t\t// extract to cache dir\n\t\tfinal byte[] buf = new byte[64 * 1024];\n\t\tfinal ByteArrayInputStream bais = new ByteArrayInputStream(//\n\t\t\tbyteArray.getArray(), 0, byteArray.size());\n\t\ttargetFolder.mkdirs();\n\t\tlog.debug(\"Unpacking files\");\n\t\ttry (final ZipInputStream zis = new ZipInputStream(bais)) {\n\t\t\twhile (true) {\n\t\t\t\tfinal ZipEntry entry = zis.getNextEntry();\n\t\t\t\tif (entry == null) break; // All done!\n\t\t\t\tfinal String name = entry.getName();\n\t\t\t\tfinal File outFile = new File(targetFolder, name);\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\toutFile.mkdirs();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal int size = (int) entry.getSize();\n\t\t\t\t\tint len = 0;\n\t\t\t\t\ttry (final FileOutputStream out = new FileOutputStream(outFile)) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tlog.debug(\"Unpacking \" + name + \"; completion\" + (double) len /\n\t\t\t\t\t\t\t\tsize * 100 + \"%\");\n\t\t\t\t\t\t\tfinal int r = zis.read(buf);\n\t\t\t\t\t\t\tif (r < 0) break; // end of entry\n\t\t\t\t\t\t\tlen += r;\n\t\t\t\t\t\t\tout.write(buf, 0, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate DiskLocationCache sourceCache() {\n\t\tif (sourceCache == null) initSourceCache();\n\t\treturn sourceCache;\n\t}\n\n\tprivate void initSourceCache() {\n\t\tfinal DiskLocationCache cache = new DiskLocationCache();\n\n\t\t// Follow XDG base directory specification:\n\t\t// https://specifications.freedesktop.org/basedir-spec/latest/\n\t\t//\n\t\t// By default, this resolves to:\n\t\t//\n\t\t// * %LOCALAPPDATA% on Windows\n\t\t// * $HOME/Library/Caches/scifio/ on macOS\n\t\t// * $HOME/.cache/scifio/ on other platforms\n\t\tfinal File cacheBase =\n\t\t\tnew File(BaseDirectory.get(BaseDirectory.XDG_CACHE_HOME), \"scifio\");\n\t\tif (!cacheBase.exists()) cacheBase.mkdirs();\n\t\tcache.setBaseDirectory(cacheBase);\n\n\t\tsourceCache = cache;\n\t}\n\n\t@Override\n\tpublic void dispose() {\n\t\tsources.clear();\n\t}\n}\n"], "fixing_code": ["/*\n * #%L\n * SCIFIO library for reading and converting scientific file formats.\n * %%\n * Copyright (C) 2011 - 2022 SCIFIO developers.\n * %%\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n * #L%\n */\n\npackage io.scif.util;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport javax.xml.bind.DatatypeConverter;\n\nimport org.freedesktop.BaseDirectory;\nimport org.scijava.download.DiskLocationCache;\nimport org.scijava.download.DownloadService;\nimport org.scijava.io.location.BytesLocation;\nimport org.scijava.io.location.FileLocation;\nimport org.scijava.io.location.Location;\nimport org.scijava.log.LogService;\nimport org.scijava.plugin.Parameter;\nimport org.scijava.plugin.Plugin;\nimport org.scijava.service.AbstractService;\nimport org.scijava.service.Service;\nimport org.scijava.task.Task;\nimport org.scijava.util.ByteArray;\nimport org.scijava.util.DigestUtils;\n\n/**\n * @author Gabriel Einsdorf, KNIME GmbH\n */\n@Plugin(type = Service.class)\npublic class DefaultSampleFilesService extends AbstractService implements\n\tSampleFileService\n{\n\n\t@Parameter\n\tprivate DownloadService downloadService;\n\n\t@Parameter\n\tprivate LogService log;\n\n\t/** Models which are already cached in memory. */\n\tprivate final Map<String, FileLocation> sources = new HashMap<>();\n\n\t/** stores retrieved sources locally */\n\tprivate DiskLocationCache sourceCache;\n\n\t@Override\n\tpublic FileLocation prepareFormatTestFolder(final Location... zipSources)\n\t\tthrows IOException\n\t{\n\t\tif (zipSources.length == 0) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"At least one zip source is required!\");\n\t\t}\n\n\t\tfinal byte[] bytes = Arrays.stream(zipSources).map(Object::toString).reduce(\n\t\t\t\"\", (a, b) -> a + b).getBytes();\n\t\tfinal String localFolderName = DatatypeConverter.printHexBinary(DigestUtils\n\t\t\t.sha1(bytes));\n\n\t\t// test if we already downloaded and unpacked the source\n\t\tFileLocation out = sources.get(localFolderName);\n\t\tif (out == null) {\n\t\t\t// not cached we need to download it\n\n\t\t\tfinal File basefolder = new File(sourceCache().getBaseDirectory(),\n\t\t\t\tlocalFolderName);\n\t\t\ttry {\n\t\t\t\tif (zipSources.length == 1) { // extract directly into basedir\n\t\t\t\t\tdownloadAndUnpackResource(zipSources[0], basefolder);\n\t\t\t\t}\n\t\t\t\telse {\n\n\t\t\t\t\tfor (final Location source : zipSources) {\n\t\t\t\t\t\tString targetName;\n\t\t\t\t\t\tif (source.getName().equals(source.defaultName())) {\n\t\t\t\t\t\t\ttargetName = source.getURI().getPath().substring(1).replaceAll(\"\\\\/\", \"-\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttargetName = source.getName();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfinal File target = new File(basefolder, targetName);\n\t\t\t\t\t\tdownloadAndUnpackResource(source, target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (final IOException | InterruptedException | ExecutionException e) {\n\t\t\t\t// cleanup\n\t\t\t\tif (basefolder.exists()) {\n\t\t\t\t\tbasefolder.delete();\n\t\t\t\t}\n\t\t\t\tthrow new IOException(e);\n\t\t\t}\n\n\t\t\tout = new FileLocation(basefolder);\n\t\t\tsources.put(localFolderName, out);\n\t\t}\n\n\t\treturn out;\n\t}\n\n\tprivate void downloadAndUnpackResource(final Location source,\n\t\tfinal File targetFolder) throws InterruptedException, ExecutionException,\n\t\tIOException\n\t{\n\t\t// allocate array\n\t\tfinal ByteArray byteArray = new ByteArray(1024 * 1024);\n\n\t\tlog.debug(\"Started download of \" + source.getURI());\n\t\t// Download the zip file\n\t\tfinal BytesLocation bytes = new BytesLocation(byteArray);\n\t\tfinal Task task = //\n\t\t\tdownloadService.download(source, bytes, sourceCache()).task();\n\t\ttask.waitFor();\n\n\t\t// extract to cache dir\n\t\tfinal byte[] buf = new byte[64 * 1024];\n\t\tfinal ByteArrayInputStream bais = new ByteArrayInputStream(//\n\t\t\tbyteArray.getArray(), 0, byteArray.size());\n\t\ttargetFolder.mkdirs();\n\t\tlog.debug(\"Unpacking files\");\n\t\ttry (final ZipInputStream zis = new ZipInputStream(bais)) {\n\t\t\twhile (true) {\n\t\t\t\tfinal ZipEntry entry = zis.getNextEntry();\n\t\t\t\tif (entry == null) break; // All done!\n\t\t\t\tfinal String name = entry.getName();\n\t\t\t\tfinal File outFile = new File(targetFolder, name);\n\t\t\t\tif (!outFile.toPath().normalize().startsWith(targetFolder.toPath().normalize())) {\n\t\t\t\t\tthrow new RuntimeException(\"Bad zip entry\");\n\t\t\t\t}\n\t\t\t\tif (entry.isDirectory()) {\n\t\t\t\t\toutFile.mkdirs();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal int size = (int) entry.getSize();\n\t\t\t\t\tint len = 0;\n\t\t\t\t\ttry (final FileOutputStream out = new FileOutputStream(outFile)) {\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tlog.debug(\"Unpacking \" + name + \"; completion\" + (double) len /\n\t\t\t\t\t\t\t\tsize * 100 + \"%\");\n\t\t\t\t\t\t\tfinal int r = zis.read(buf);\n\t\t\t\t\t\t\tif (r < 0) break; // end of entry\n\t\t\t\t\t\t\tlen += r;\n\t\t\t\t\t\t\tout.write(buf, 0, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate DiskLocationCache sourceCache() {\n\t\tif (sourceCache == null) initSourceCache();\n\t\treturn sourceCache;\n\t}\n\n\tprivate void initSourceCache() {\n\t\tfinal DiskLocationCache cache = new DiskLocationCache();\n\n\t\t// Follow XDG base directory specification:\n\t\t// https://specifications.freedesktop.org/basedir-spec/latest/\n\t\t//\n\t\t// By default, this resolves to:\n\t\t//\n\t\t// * %LOCALAPPDATA% on Windows\n\t\t// * $HOME/Library/Caches/scifio/ on macOS\n\t\t// * $HOME/.cache/scifio/ on other platforms\n\t\tfinal File cacheBase =\n\t\t\tnew File(BaseDirectory.get(BaseDirectory.XDG_CACHE_HOME), \"scifio\");\n\t\tif (!cacheBase.exists()) cacheBase.mkdirs();\n\t\tcache.setBaseDirectory(cacheBase);\n\n\t\tsourceCache = cache;\n\t}\n\n\t@Override\n\tpublic void dispose() {\n\t\tsources.clear();\n\t}\n}\n"], "filenames": ["src/test/java/io/scif/util/DefaultSampleFilesService.java"], "buggy_code_start_loc": [161], "buggy_code_end_loc": [161], "fixing_code_start_loc": [162], "fixing_code_end_loc": [165], "type": "CWE-22", "message": "A vulnerability classified as critical was found in scifio. Affected by this vulnerability is the function downloadAndUnpackResource of the file src/test/java/io/scif/util/DefaultSampleFilesService.java of the component ZIP File Handler. The manipulation leads to path traversal. The attack can be launched remotely. The name of the patch is fcb0dbca0ec72b22fe0c9ddc8abc9cb188a0ff31. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-215803.", "other": {"cve": {"id": "CVE-2022-4493", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-14T12:15:09.807", "lastModified": "2022-12-16T19:24:38.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as critical was found in scifio. Affected by this vulnerability is the function downloadAndUnpackResource of the file src/test/java/io/scif/util/DefaultSampleFilesService.java of the component ZIP File Handler. The manipulation leads to path traversal. The attack can be launched remotely. The name of the patch is fcb0dbca0ec72b22fe0c9ddc8abc9cb188a0ff31. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-215803."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:scif:scifio:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-07-29", "matchCriteriaId": "DADB7764-906A-45FF-8111-C0EEBB75ED0E"}]}]}], "references": [{"url": "https://github.com/scifio/scifio/commit/fcb0dbca0ec72b22fe0c9ddc8abc9cb188a0ff31", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.215803", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/scifio/scifio/commit/fcb0dbca0ec72b22fe0c9ddc8abc9cb188a0ff31"}}