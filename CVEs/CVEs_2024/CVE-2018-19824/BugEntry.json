{"buggy_code": ["/*\n *   (Tentative) USB Audio Driver for ALSA\n *\n *   Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>\n *\n *   Many codes borrowed from audio.c by\n *\t    Alan Cox (alan@lxorguk.ukuu.org.uk)\n *\t    Thomas Sailer (sailer@ife.ee.ethz.ch)\n *\n *   Audio Class 3.0 support by Ruslan Bilovol <ruslan.bilovol@gmail.com>\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n *\n *  NOTES:\n *\n *   - the linked URBs would be preferred but not used so far because of\n *     the instability of unlinking.\n *   - type II is not supported properly.  there is no device which supports\n *     this type *correctly*.  SB extigy looks as if it supports, but it's\n *     indeed an AC3 stream packed in SPDIF frames (i.e. no real AC3 stream).\n */\n\n\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/usb.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/usb/audio-v3.h>\n#include <linux/module.h>\n\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n\n#include \"usbaudio.h\"\n#include \"card.h\"\n#include \"midi.h\"\n#include \"mixer.h\"\n#include \"proc.h\"\n#include \"quirks.h\"\n#include \"endpoint.h\"\n#include \"helper.h\"\n#include \"debug.h\"\n#include \"pcm.h\"\n#include \"format.h\"\n#include \"power.h\"\n#include \"stream.h\"\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"USB Audio\");\nMODULE_LICENSE(\"GPL\");\nMODULE_SUPPORTED_DEVICE(\"{{Generic,USB Audio}}\");\n\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t/* Index 0-MAX */\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t/* ID for this card */\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */\n/* Vendor/product IDs for this card */\nstatic int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };\nstatic int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };\nstatic int device_setup[SNDRV_CARDS]; /* device parameter for this card */\nstatic bool ignore_ctl_error;\nstatic bool autoclock = true;\nstatic char *quirk_alias[SNDRV_CARDS];\n\nbool snd_usb_use_vmalloc = true;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the USB audio adapter.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the USB audio adapter.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable USB audio adapter.\");\nmodule_param_array(vid, int, NULL, 0444);\nMODULE_PARM_DESC(vid, \"Vendor ID for the USB audio device.\");\nmodule_param_array(pid, int, NULL, 0444);\nMODULE_PARM_DESC(pid, \"Product ID for the USB audio device.\");\nmodule_param_array(device_setup, int, NULL, 0444);\nMODULE_PARM_DESC(device_setup, \"Specific device setup (if needed).\");\nmodule_param(ignore_ctl_error, bool, 0444);\nMODULE_PARM_DESC(ignore_ctl_error,\n\t\t \"Ignore errors from USB controller for mixer interfaces.\");\nmodule_param(autoclock, bool, 0444);\nMODULE_PARM_DESC(autoclock, \"Enable auto-clock selection for UAC2 devices (default: yes).\");\nmodule_param_array(quirk_alias, charp, NULL, 0444);\nMODULE_PARM_DESC(quirk_alias, \"Quirk aliases, e.g. 0123abcd:5678beef.\");\nmodule_param_named(use_vmalloc, snd_usb_use_vmalloc, bool, 0444);\nMODULE_PARM_DESC(use_vmalloc, \"Use vmalloc for PCM intermediate buffers (default: yes).\");\n\n/*\n * we keep the snd_usb_audio_t instances by ourselves for merging\n * the all interfaces on the same card as one sound device.\n */\n\nstatic DEFINE_MUTEX(register_mutex);\nstatic struct snd_usb_audio *usb_chip[SNDRV_CARDS];\nstatic struct usb_driver usb_audio_driver;\n\n/*\n * disconnect streams\n * called from usb_audio_disconnect()\n */\nstatic void snd_usb_stream_disconnect(struct snd_usb_stream *as)\n{\n\tint idx;\n\tstruct snd_usb_substream *subs;\n\n\tfor (idx = 0; idx < 2; idx++) {\n\t\tsubs = &as->substream[idx];\n\t\tif (!subs->num_formats)\n\t\t\tcontinue;\n\t\tsubs->interface = -1;\n\t\tsubs->data_endpoint = NULL;\n\t\tsubs->sync_endpoint = NULL;\n\t}\n}\n\nstatic int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int interface)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tstruct usb_interface *iface = usb_ifnum_to_if(dev, interface);\n\n\tif (!iface) {\n\t\tdev_err(&dev->dev, \"%u:%d : does not exist\\n\",\n\t\t\tctrlif, interface);\n\t\treturn -EINVAL;\n\t}\n\n\talts = &iface->altsetting[0];\n\taltsd = get_iface_desc(alts);\n\n\t/*\n\t * Android with both accessory and audio interfaces enabled gets the\n\t * interface numbers wrong.\n\t */\n\tif ((chip->usb_id == USB_ID(0x18d1, 0x2d04) ||\n\t     chip->usb_id == USB_ID(0x18d1, 0x2d05)) &&\n\t    interface == 0 &&\n\t    altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC &&\n\t    altsd->bInterfaceSubClass == USB_SUBCLASS_VENDOR_SPEC) {\n\t\tinterface = 2;\n\t\tiface = usb_ifnum_to_if(dev, interface);\n\t\tif (!iface)\n\t\t\treturn -EINVAL;\n\t\talts = &iface->altsetting[0];\n\t\taltsd = get_iface_desc(alts);\n\t}\n\n\tif (usb_interface_claimed(iface)) {\n\t\tdev_dbg(&dev->dev, \"%d:%d: skipping, already claimed\\n\",\n\t\t\tctrlif, interface);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((altsd->bInterfaceClass == USB_CLASS_AUDIO ||\n\t     altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC) &&\n\t    altsd->bInterfaceSubClass == USB_SUBCLASS_MIDISTREAMING) {\n\t\tint err = __snd_usbmidi_create(chip->card, iface,\n\t\t\t\t\t     &chip->midi_list, NULL,\n\t\t\t\t\t     chip->usb_id);\n\t\tif (err < 0) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"%u:%d: cannot create sequencer device\\n\",\n\t\t\t\tctrlif, interface);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tusb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);\n\n\t\treturn 0;\n\t}\n\n\tif ((altsd->bInterfaceClass != USB_CLASS_AUDIO &&\n\t     altsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||\n\t    altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"%u:%d: skipping non-supported interface %d\\n\",\n\t\t\tctrlif, interface, altsd->bInterfaceClass);\n\t\t/* skip non-supported classes */\n\t\treturn -EINVAL;\n\t}\n\n\tif (snd_usb_get_speed(dev) == USB_SPEED_LOW) {\n\t\tdev_err(&dev->dev, \"low speed audio streaming not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (! snd_usb_parse_audio_interface(chip, interface)) {\n\t\tusb_set_interface(dev, interface, 0); /* reset the current interface */\n\t\tusb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);\n\t}\n\n\treturn 0;\n}\n\n/*\n * parse audio control descriptor and create pcm/midi streams\n */\nstatic int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tint i, protocol;\n\n\t/* find audiocontrol interface */\n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\t/* fall through */\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1;\n\t\tint rest_bytes;\n\n\t\th1 = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t\t NULL, UAC_HEADER);\n\t\tif (!h1) {\n\t\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trest_bytes = (void *)(host_iface->extra +\n\t\t\t\thost_iface->extralen) - (void *)h1;\n\n\t\t/* just to be sure -- this shouldn't hit at all */\n\t\tif (rest_bytes <= 0) {\n\t\t\tdev_err(&dev->dev, \"invalid control header\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rest_bytes < sizeof(*h1)) {\n\t\t\tdev_err(&dev->dev, \"too short v1 buffer descriptor\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rest_bytes < h1->bLength) {\n\t\t\tdev_err(&dev->dev, \"invalid buffer length (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2:\n\tcase UAC_VERSION_3: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t/*\n\t\t\t * Firmware writers cannot count to three.  So to find\n\t\t\t * the IAD on the NuForce UDH-100, also check the next\n\t\t\t * interface.\n\t\t\t */\n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2/v3 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (protocol == UAC_VERSION_3) {\n\t\t\tint badd = assoc->bFunctionSubClass;\n\n\t\t\tif (badd != UAC3_FUNCTION_SUBCLASS_FULL_ADC_3_0 &&\n\t\t\t    (badd < UAC3_FUNCTION_SUBCLASS_GENERIC_IO ||\n\t\t\t     badd > UAC3_FUNCTION_SUBCLASS_SPEAKERPHONE)) {\n\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t\"Unsupported UAC3 BADD profile\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tchip->badd_profile = badd;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * free the chip instance\n *\n * here we have to do not much, since pcm and controls are already freed\n *\n */\n\nstatic void snd_usb_audio_free(struct snd_card *card)\n{\n\tstruct snd_usb_audio *chip = card->private_data;\n\tstruct snd_usb_endpoint *ep, *n;\n\n\tlist_for_each_entry_safe(ep, n, &chip->ep_list, list)\n\t\tsnd_usb_endpoint_free(ep);\n\n\tmutex_destroy(&chip->mutex);\n\tif (!atomic_read(&chip->shutdown))\n\t\tdev_set_drvdata(&chip->dev->dev, NULL);\n}\n\nstatic void usb_audio_make_shortname(struct usb_device *dev,\n\t\t\t\t     struct snd_usb_audio *chip,\n\t\t\t\t     const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct snd_card *card = chip->card;\n\n\tif (quirk && quirk->product_name && *quirk->product_name) {\n\t\tstrlcpy(card->shortname, quirk->product_name,\n\t\t\tsizeof(card->shortname));\n\t\treturn;\n\t}\n\n\t/* retrieve the device string as shortname */\n\tif (!dev->descriptor.iProduct ||\n\t    usb_string(dev, dev->descriptor.iProduct,\n\t\t       card->shortname, sizeof(card->shortname)) <= 0) {\n\t\t/* no name available from anywhere, so use ID */\n\t\tsprintf(card->shortname, \"USB Device %#04x:%#04x\",\n\t\t\tUSB_ID_VENDOR(chip->usb_id),\n\t\t\tUSB_ID_PRODUCT(chip->usb_id));\n\t}\n\n\tstrim(card->shortname);\n}\n\nstatic void usb_audio_make_longname(struct usb_device *dev,\n\t\t\t\t    struct snd_usb_audio *chip,\n\t\t\t\t    const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct snd_card *card = chip->card;\n\tint len;\n\n\t/* shortcut - if any pre-defined string is given, use it */\n\tif (quirk && quirk->profile_name && *quirk->profile_name) {\n\t\tstrlcpy(card->longname, quirk->profile_name,\n\t\t\tsizeof(card->longname));\n\t\treturn;\n\t}\n\n\tif (quirk && quirk->vendor_name && *quirk->vendor_name) {\n\t\tlen = strlcpy(card->longname, quirk->vendor_name, sizeof(card->longname));\n\t} else {\n\t\t/* retrieve the vendor and device strings as longname */\n\t\tif (dev->descriptor.iManufacturer)\n\t\t\tlen = usb_string(dev, dev->descriptor.iManufacturer,\n\t\t\t\t\t card->longname, sizeof(card->longname));\n\t\telse\n\t\t\tlen = 0;\n\t\t/* we don't really care if there isn't any vendor string */\n\t}\n\tif (len > 0) {\n\t\tstrim(card->longname);\n\t\tif (*card->longname)\n\t\t\tstrlcat(card->longname, \" \", sizeof(card->longname));\n\t}\n\n\tstrlcat(card->longname, card->shortname, sizeof(card->longname));\n\n\tlen = strlcat(card->longname, \" at \", sizeof(card->longname));\n\n\tif (len < sizeof(card->longname))\n\t\tusb_make_path(dev, card->longname + len, sizeof(card->longname) - len);\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\t\tstrlcat(card->longname, \", low speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tstrlcat(card->longname, \", full speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tstrlcat(card->longname, \", high speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tstrlcat(card->longname, \", super speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tstrlcat(card->longname, \", super speed plus\", sizeof(card->longname));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/*\n * create a chip instance and set its names.\n */\nstatic int snd_usb_audio_create(struct usb_interface *intf,\n\t\t\t\tstruct usb_device *dev, int idx,\n\t\t\t\tconst struct snd_usb_audio_quirk *quirk,\n\t\t\t\tunsigned int usb_id,\n\t\t\t\tstruct snd_usb_audio **rchip)\n{\n\tstruct snd_card *card;\n\tstruct snd_usb_audio *chip;\n\tint err;\n\tchar component[14];\n\n\t*rchip = NULL;\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_WIRELESS:\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->dev, \"unknown device speed %d\\n\", snd_usb_get_speed(dev));\n\t\treturn -ENXIO;\n\t}\n\n\terr = snd_card_new(&intf->dev, index[idx], id[idx], THIS_MODULE,\n\t\t\t   sizeof(*chip), &card);\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, \"cannot create card instance %d\\n\", idx);\n\t\treturn err;\n\t}\n\n\tchip = card->private_data;\n\tmutex_init(&chip->mutex);\n\tinit_waitqueue_head(&chip->shutdown_wait);\n\tchip->index = idx;\n\tchip->dev = dev;\n\tchip->card = card;\n\tchip->setup = device_setup[idx];\n\tchip->autoclock = autoclock;\n\tatomic_set(&chip->active, 1); /* avoid autopm during probing */\n\tatomic_set(&chip->usage_count, 0);\n\tatomic_set(&chip->shutdown, 0);\n\n\tchip->usb_id = usb_id;\n\tINIT_LIST_HEAD(&chip->pcm_list);\n\tINIT_LIST_HEAD(&chip->ep_list);\n\tINIT_LIST_HEAD(&chip->midi_list);\n\tINIT_LIST_HEAD(&chip->mixer_list);\n\n\tcard->private_free = snd_usb_audio_free;\n\n\tstrcpy(card->driver, \"USB-Audio\");\n\tsprintf(component, \"USB%04x:%04x\",\n\t\tUSB_ID_VENDOR(chip->usb_id), USB_ID_PRODUCT(chip->usb_id));\n\tsnd_component_add(card, component);\n\n\tusb_audio_make_shortname(dev, chip, quirk);\n\tusb_audio_make_longname(dev, chip, quirk);\n\n\tsnd_usb_audio_create_proc(chip);\n\n\t*rchip = chip;\n\treturn 0;\n}\n\n/* look for a matching quirk alias id */\nstatic bool get_alias_id(struct usb_device *dev, unsigned int *id)\n{\n\tint i;\n\tunsigned int src, dst;\n\n\tfor (i = 0; i < ARRAY_SIZE(quirk_alias); i++) {\n\t\tif (!quirk_alias[i] ||\n\t\t    sscanf(quirk_alias[i], \"%x:%x\", &src, &dst) != 2 ||\n\t\t    src != *id)\n\t\t\tcontinue;\n\t\tdev_info(&dev->dev,\n\t\t\t \"device (%04x:%04x): applying quirk alias %04x:%04x\\n\",\n\t\t\t USB_ID_VENDOR(*id), USB_ID_PRODUCT(*id),\n\t\t\t USB_ID_VENDOR(dst), USB_ID_PRODUCT(dst));\n\t\t*id = dst;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct usb_device_id usb_audio_ids[]; /* defined below */\n\n/* look for the corresponding quirk */\nstatic const struct snd_usb_audio_quirk *\nget_alias_quirk(struct usb_device *dev, unsigned int id)\n{\n\tconst struct usb_device_id *p;\n\n\tfor (p = usb_audio_ids; p->match_flags; p++) {\n\t\t/* FIXME: this checks only vendor:product pair in the list */\n\t\tif ((p->match_flags & USB_DEVICE_ID_MATCH_DEVICE) ==\n\t\t    USB_DEVICE_ID_MATCH_DEVICE &&\n\t\t    p->idVendor == USB_ID_VENDOR(id) &&\n\t\t    p->idProduct == USB_ID_PRODUCT(id))\n\t\t\treturn (const struct snd_usb_audio_quirk *)p->driver_info;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * probe the active usb device\n *\n * note that this can be called multiple times per a device, when it\n * includes multiple audio control interfaces.\n *\n * thus we check the usb device pointer and creates the card instance\n * only at the first time.  the successive calls of this function will\n * append the pcm interface to the corresponding card.\n */\nstatic int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * found a config.  now register to ALSA\n\t */\n\n\t/* check whether it's already registered */\n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, \"USB device is in the shutdown state, cannot create a card instance\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active); /* avoid autopm */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\t/* it's a fresh one.\n\t\t * now look for an empty slot and create a new card instance\n\t\t */\n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (!usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\tif (enable[i]) {\n\t\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t\t   id, &chip);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\tgoto __error;\n\t\t\t\t\tchip->pm_intf = intf;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (vid[i] != -1 || pid[i] != -1) {\n\t\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t\t \"device (%04x:%04x) is disabled\\n\",\n\t\t\t\t\t\t USB_ID_VENDOR(id),\n\t\t\t\t\t\t USB_ID_PRODUCT(id));\n\t\t\t\t\terr = -ENOENT;\n\t\t\t\t\tgoto __error;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, \"no available usb audio device\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tdev_set_drvdata(&dev->dev, chip);\n\n\t/*\n\t * For devices with more than one control interface, we assume the\n\t * first contains the audio controls. We might need a more specific\n\t * check here in the future.\n\t */\n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\tchip->txfr_quirk = 0;\n\terr = 1; /* continue */\n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t/* need some special handlings */\n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t/* create normal USB audio interfaces */\n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\t/* we are allowed to call snd_card_register() many times */\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t\tatomic_dec(&chip->active);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}\n\n/*\n * we need to take care of counter, since disconnection can be called also\n * many times as well as usb_audio_probe().\n */\nstatic void usb_audio_disconnect(struct usb_interface *intf)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_card *card;\n\tstruct list_head *p;\n\n\tif (chip == (void *)-1L)\n\t\treturn;\n\n\tcard = chip->card;\n\n\tmutex_lock(&register_mutex);\n\tif (atomic_inc_return(&chip->shutdown) == 1) {\n\t\tstruct snd_usb_stream *as;\n\t\tstruct snd_usb_endpoint *ep;\n\t\tstruct usb_mixer_interface *mixer;\n\n\t\t/* wait until all pending tasks done;\n\t\t * they are protected by snd_usb_lock_shutdown()\n\t\t */\n\t\twait_event(chip->shutdown_wait,\n\t\t\t   !atomic_read(&chip->usage_count));\n\t\tsnd_card_disconnect(card);\n\t\t/* release the pcm resources */\n\t\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\t\tsnd_usb_stream_disconnect(as);\n\t\t}\n\t\t/* release the endpoint resources */\n\t\tlist_for_each_entry(ep, &chip->ep_list, list) {\n\t\t\tsnd_usb_endpoint_release(ep);\n\t\t}\n\t\t/* release the midi resources */\n\t\tlist_for_each(p, &chip->midi_list) {\n\t\t\tsnd_usbmidi_disconnect(p);\n\t\t}\n\t\t/* release mixer resources */\n\t\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\t\tsnd_usb_mixer_disconnect(mixer);\n\t\t}\n\t}\n\n\tchip->num_interfaces--;\n\tif (chip->num_interfaces <= 0) {\n\t\tusb_chip[chip->index] = NULL;\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_card_free_when_closed(card);\n\t} else {\n\t\tmutex_unlock(&register_mutex);\n\t}\n}\n\n/* lock the shutdown (disconnect) task and autoresume */\nint snd_usb_lock_shutdown(struct snd_usb_audio *chip)\n{\n\tint err;\n\n\tatomic_inc(&chip->usage_count);\n\tif (atomic_read(&chip->shutdown)) {\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\terr = snd_usb_autoresume(chip);\n\tif (err < 0)\n\t\tgoto error;\n\treturn 0;\n\n error:\n\tif (atomic_dec_and_test(&chip->usage_count))\n\t\twake_up(&chip->shutdown_wait);\n\treturn err;\n}\n\n/* autosuspend and unlock the shutdown */\nvoid snd_usb_unlock_shutdown(struct snd_usb_audio *chip)\n{\n\tsnd_usb_autosuspend(chip);\n\tif (atomic_dec_and_test(&chip->usage_count))\n\t\twake_up(&chip->shutdown_wait);\n}\n\n#ifdef CONFIG_PM\n\nint snd_usb_autoresume(struct snd_usb_audio *chip)\n{\n\tif (atomic_read(&chip->shutdown))\n\t\treturn -EIO;\n\tif (atomic_inc_return(&chip->active) == 1)\n\t\treturn usb_autopm_get_interface(chip->pm_intf);\n\treturn 0;\n}\n\nvoid snd_usb_autosuspend(struct snd_usb_audio *chip)\n{\n\tif (atomic_read(&chip->shutdown))\n\t\treturn;\n\tif (atomic_dec_and_test(&chip->active))\n\t\tusb_autopm_put_interface(chip->pm_intf);\n}\n\nstatic int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_usb_stream *as;\n\tstruct usb_mixer_interface *mixer;\n\tstruct list_head *p;\n\n\tif (chip == (void *)-1L)\n\t\treturn 0;\n\n\tchip->autosuspended = !!PMSG_IS_AUTO(message);\n\tif (!chip->autosuspended)\n\t\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);\n\tif (!chip->num_suspended_intf++) {\n\t\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\t\tsnd_pcm_suspend_all(as->pcm);\n\t\t\tsnd_usb_pcm_suspend(as);\n\t\t\tas->substream[0].need_setup_ep =\n\t\t\t\tas->substream[1].need_setup_ep = true;\n\t\t}\n\t\tlist_for_each(p, &chip->midi_list)\n\t\t\tsnd_usbmidi_suspend(p);\n\t\tlist_for_each_entry(mixer, &chip->mixer_list, list)\n\t\t\tsnd_usb_mixer_suspend(mixer);\n\t}\n\n\treturn 0;\n}\n\nstatic int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_usb_stream *as;\n\tstruct usb_mixer_interface *mixer;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tif (chip == (void *)-1L)\n\t\treturn 0;\n\tif (--chip->num_suspended_intf)\n\t\treturn 0;\n\n\tatomic_inc(&chip->active); /* avoid autopm */\n\n\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\terr = snd_usb_pcm_resume(as);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t}\n\n\t/*\n\t * ALSA leaves material resumption to user space\n\t * we just notify and restart the mixers\n\t */\n\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\terr = snd_usb_mixer_resume(mixer, reset_resume);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tlist_for_each(p, &chip->midi_list) {\n\t\tsnd_usbmidi_resume(p);\n\t}\n\n\tif (!chip->autosuspended)\n\t\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);\n\tchip->autosuspended = 0;\n\nerr_out:\n\tatomic_dec(&chip->active); /* allow autopm after this point */\n\treturn err;\n}\n\nstatic int usb_audio_resume(struct usb_interface *intf)\n{\n\treturn __usb_audio_resume(intf, false);\n}\n\nstatic int usb_audio_reset_resume(struct usb_interface *intf)\n{\n\treturn __usb_audio_resume(intf, true);\n}\n#else\n#define usb_audio_suspend\tNULL\n#define usb_audio_resume\tNULL\n#define usb_audio_reset_resume\tNULL\n#endif\t\t/* CONFIG_PM */\n\nstatic const struct usb_device_id usb_audio_ids [] = {\n#include \"quirks-table.h\"\n    { .match_flags = (USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS),\n      .bInterfaceClass = USB_CLASS_AUDIO,\n      .bInterfaceSubClass = USB_SUBCLASS_AUDIOCONTROL },\n    { }\t\t\t\t\t\t/* Terminating entry */\n};\nMODULE_DEVICE_TABLE(usb, usb_audio_ids);\n\n/*\n * entry point for linux usb interface\n */\n\nstatic struct usb_driver usb_audio_driver = {\n\t.name =\t\t\"snd-usb-audio\",\n\t.probe =\tusb_audio_probe,\n\t.disconnect =\tusb_audio_disconnect,\n\t.suspend =\tusb_audio_suspend,\n\t.resume =\tusb_audio_resume,\n\t.reset_resume =\tusb_audio_reset_resume,\n\t.id_table =\tusb_audio_ids,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(usb_audio_driver);\n"], "fixing_code": ["/*\n *   (Tentative) USB Audio Driver for ALSA\n *\n *   Copyright (c) 2002 by Takashi Iwai <tiwai@suse.de>\n *\n *   Many codes borrowed from audio.c by\n *\t    Alan Cox (alan@lxorguk.ukuu.org.uk)\n *\t    Thomas Sailer (sailer@ife.ee.ethz.ch)\n *\n *   Audio Class 3.0 support by Ruslan Bilovol <ruslan.bilovol@gmail.com>\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License as published by\n *   the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA\n *\n *\n *  NOTES:\n *\n *   - the linked URBs would be preferred but not used so far because of\n *     the instability of unlinking.\n *   - type II is not supported properly.  there is no device which supports\n *     this type *correctly*.  SB extigy looks as if it supports, but it's\n *     indeed an AC3 stream packed in SPDIF frames (i.e. no real AC3 stream).\n */\n\n\n#include <linux/bitops.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/usb.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/usb/audio-v3.h>\n#include <linux/module.h>\n\n#include <sound/control.h>\n#include <sound/core.h>\n#include <sound/info.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/initval.h>\n\n#include \"usbaudio.h\"\n#include \"card.h\"\n#include \"midi.h\"\n#include \"mixer.h\"\n#include \"proc.h\"\n#include \"quirks.h\"\n#include \"endpoint.h\"\n#include \"helper.h\"\n#include \"debug.h\"\n#include \"pcm.h\"\n#include \"format.h\"\n#include \"power.h\"\n#include \"stream.h\"\n\nMODULE_AUTHOR(\"Takashi Iwai <tiwai@suse.de>\");\nMODULE_DESCRIPTION(\"USB Audio\");\nMODULE_LICENSE(\"GPL\");\nMODULE_SUPPORTED_DEVICE(\"{{Generic,USB Audio}}\");\n\n\nstatic int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;\t/* Index 0-MAX */\nstatic char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;\t/* ID for this card */\nstatic bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card */\n/* Vendor/product IDs for this card */\nstatic int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };\nstatic int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };\nstatic int device_setup[SNDRV_CARDS]; /* device parameter for this card */\nstatic bool ignore_ctl_error;\nstatic bool autoclock = true;\nstatic char *quirk_alias[SNDRV_CARDS];\n\nbool snd_usb_use_vmalloc = true;\n\nmodule_param_array(index, int, NULL, 0444);\nMODULE_PARM_DESC(index, \"Index value for the USB audio adapter.\");\nmodule_param_array(id, charp, NULL, 0444);\nMODULE_PARM_DESC(id, \"ID string for the USB audio adapter.\");\nmodule_param_array(enable, bool, NULL, 0444);\nMODULE_PARM_DESC(enable, \"Enable USB audio adapter.\");\nmodule_param_array(vid, int, NULL, 0444);\nMODULE_PARM_DESC(vid, \"Vendor ID for the USB audio device.\");\nmodule_param_array(pid, int, NULL, 0444);\nMODULE_PARM_DESC(pid, \"Product ID for the USB audio device.\");\nmodule_param_array(device_setup, int, NULL, 0444);\nMODULE_PARM_DESC(device_setup, \"Specific device setup (if needed).\");\nmodule_param(ignore_ctl_error, bool, 0444);\nMODULE_PARM_DESC(ignore_ctl_error,\n\t\t \"Ignore errors from USB controller for mixer interfaces.\");\nmodule_param(autoclock, bool, 0444);\nMODULE_PARM_DESC(autoclock, \"Enable auto-clock selection for UAC2 devices (default: yes).\");\nmodule_param_array(quirk_alias, charp, NULL, 0444);\nMODULE_PARM_DESC(quirk_alias, \"Quirk aliases, e.g. 0123abcd:5678beef.\");\nmodule_param_named(use_vmalloc, snd_usb_use_vmalloc, bool, 0444);\nMODULE_PARM_DESC(use_vmalloc, \"Use vmalloc for PCM intermediate buffers (default: yes).\");\n\n/*\n * we keep the snd_usb_audio_t instances by ourselves for merging\n * the all interfaces on the same card as one sound device.\n */\n\nstatic DEFINE_MUTEX(register_mutex);\nstatic struct snd_usb_audio *usb_chip[SNDRV_CARDS];\nstatic struct usb_driver usb_audio_driver;\n\n/*\n * disconnect streams\n * called from usb_audio_disconnect()\n */\nstatic void snd_usb_stream_disconnect(struct snd_usb_stream *as)\n{\n\tint idx;\n\tstruct snd_usb_substream *subs;\n\n\tfor (idx = 0; idx < 2; idx++) {\n\t\tsubs = &as->substream[idx];\n\t\tif (!subs->num_formats)\n\t\t\tcontinue;\n\t\tsubs->interface = -1;\n\t\tsubs->data_endpoint = NULL;\n\t\tsubs->sync_endpoint = NULL;\n\t}\n}\n\nstatic int snd_usb_create_stream(struct snd_usb_audio *chip, int ctrlif, int interface)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *alts;\n\tstruct usb_interface_descriptor *altsd;\n\tstruct usb_interface *iface = usb_ifnum_to_if(dev, interface);\n\n\tif (!iface) {\n\t\tdev_err(&dev->dev, \"%u:%d : does not exist\\n\",\n\t\t\tctrlif, interface);\n\t\treturn -EINVAL;\n\t}\n\n\talts = &iface->altsetting[0];\n\taltsd = get_iface_desc(alts);\n\n\t/*\n\t * Android with both accessory and audio interfaces enabled gets the\n\t * interface numbers wrong.\n\t */\n\tif ((chip->usb_id == USB_ID(0x18d1, 0x2d04) ||\n\t     chip->usb_id == USB_ID(0x18d1, 0x2d05)) &&\n\t    interface == 0 &&\n\t    altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC &&\n\t    altsd->bInterfaceSubClass == USB_SUBCLASS_VENDOR_SPEC) {\n\t\tinterface = 2;\n\t\tiface = usb_ifnum_to_if(dev, interface);\n\t\tif (!iface)\n\t\t\treturn -EINVAL;\n\t\talts = &iface->altsetting[0];\n\t\taltsd = get_iface_desc(alts);\n\t}\n\n\tif (usb_interface_claimed(iface)) {\n\t\tdev_dbg(&dev->dev, \"%d:%d: skipping, already claimed\\n\",\n\t\t\tctrlif, interface);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((altsd->bInterfaceClass == USB_CLASS_AUDIO ||\n\t     altsd->bInterfaceClass == USB_CLASS_VENDOR_SPEC) &&\n\t    altsd->bInterfaceSubClass == USB_SUBCLASS_MIDISTREAMING) {\n\t\tint err = __snd_usbmidi_create(chip->card, iface,\n\t\t\t\t\t     &chip->midi_list, NULL,\n\t\t\t\t\t     chip->usb_id);\n\t\tif (err < 0) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"%u:%d: cannot create sequencer device\\n\",\n\t\t\t\tctrlif, interface);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tusb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);\n\n\t\treturn 0;\n\t}\n\n\tif ((altsd->bInterfaceClass != USB_CLASS_AUDIO &&\n\t     altsd->bInterfaceClass != USB_CLASS_VENDOR_SPEC) ||\n\t    altsd->bInterfaceSubClass != USB_SUBCLASS_AUDIOSTREAMING) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"%u:%d: skipping non-supported interface %d\\n\",\n\t\t\tctrlif, interface, altsd->bInterfaceClass);\n\t\t/* skip non-supported classes */\n\t\treturn -EINVAL;\n\t}\n\n\tif (snd_usb_get_speed(dev) == USB_SPEED_LOW) {\n\t\tdev_err(&dev->dev, \"low speed audio streaming not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (! snd_usb_parse_audio_interface(chip, interface)) {\n\t\tusb_set_interface(dev, interface, 0); /* reset the current interface */\n\t\tusb_driver_claim_interface(&usb_audio_driver, iface, (void *)-1L);\n\t}\n\n\treturn 0;\n}\n\n/*\n * parse audio control descriptor and create pcm/midi streams\n */\nstatic int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n{\n\tstruct usb_device *dev = chip->dev;\n\tstruct usb_host_interface *host_iface;\n\tstruct usb_interface_descriptor *altsd;\n\tint i, protocol;\n\n\t/* find audiocontrol interface */\n\thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n\taltsd = get_iface_desc(host_iface);\n\tprotocol = altsd->bInterfaceProtocol;\n\n\tswitch (protocol) {\n\tdefault:\n\t\tdev_warn(&dev->dev,\n\t\t\t \"unknown interface protocol %#02x, assuming v1\\n\",\n\t\t\t protocol);\n\t\t/* fall through */\n\n\tcase UAC_VERSION_1: {\n\t\tstruct uac1_ac_header_descriptor *h1;\n\t\tint rest_bytes;\n\n\t\th1 = snd_usb_find_csint_desc(host_iface->extra,\n\t\t\t\t\t\t\t host_iface->extralen,\n\t\t\t\t\t\t\t NULL, UAC_HEADER);\n\t\tif (!h1) {\n\t\t\tdev_err(&dev->dev, \"cannot find UAC_HEADER\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trest_bytes = (void *)(host_iface->extra +\n\t\t\t\thost_iface->extralen) - (void *)h1;\n\n\t\t/* just to be sure -- this shouldn't hit at all */\n\t\tif (rest_bytes <= 0) {\n\t\t\tdev_err(&dev->dev, \"invalid control header\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rest_bytes < sizeof(*h1)) {\n\t\t\tdev_err(&dev->dev, \"too short v1 buffer descriptor\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!h1->bInCollection) {\n\t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rest_bytes < h1->bLength) {\n\t\t\tdev_err(&dev->dev, \"invalid buffer length (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n\t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < h1->bInCollection; i++)\n\t\t\tsnd_usb_create_stream(chip, ctrlif, h1->baInterfaceNr[i]);\n\n\t\tbreak;\n\t}\n\n\tcase UAC_VERSION_2:\n\tcase UAC_VERSION_3: {\n\t\tstruct usb_interface_assoc_descriptor *assoc =\n\t\t\tusb_ifnum_to_if(dev, ctrlif)->intf_assoc;\n\n\t\tif (!assoc) {\n\t\t\t/*\n\t\t\t * Firmware writers cannot count to three.  So to find\n\t\t\t * the IAD on the NuForce UDH-100, also check the next\n\t\t\t * interface.\n\t\t\t */\n\t\t\tstruct usb_interface *iface =\n\t\t\t\tusb_ifnum_to_if(dev, ctrlif + 1);\n\t\t\tif (iface &&\n\t\t\t    iface->intf_assoc &&\n\t\t\t    iface->intf_assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t\t\t    iface->intf_assoc->bFunctionProtocol == UAC_VERSION_2)\n\t\t\t\tassoc = iface->intf_assoc;\n\t\t}\n\n\t\tif (!assoc) {\n\t\t\tdev_err(&dev->dev, \"Audio class v2/v3 interfaces need an interface association\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (protocol == UAC_VERSION_3) {\n\t\t\tint badd = assoc->bFunctionSubClass;\n\n\t\t\tif (badd != UAC3_FUNCTION_SUBCLASS_FULL_ADC_3_0 &&\n\t\t\t    (badd < UAC3_FUNCTION_SUBCLASS_GENERIC_IO ||\n\t\t\t     badd > UAC3_FUNCTION_SUBCLASS_SPEAKERPHONE)) {\n\t\t\t\tdev_err(&dev->dev,\n\t\t\t\t\t\"Unsupported UAC3 BADD profile\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tchip->badd_profile = badd;\n\t\t}\n\n\t\tfor (i = 0; i < assoc->bInterfaceCount; i++) {\n\t\t\tint intf = assoc->bFirstInterface + i;\n\n\t\t\tif (intf != ctrlif)\n\t\t\t\tsnd_usb_create_stream(chip, ctrlif, intf);\n\t\t}\n\n\t\tbreak;\n\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * free the chip instance\n *\n * here we have to do not much, since pcm and controls are already freed\n *\n */\n\nstatic void snd_usb_audio_free(struct snd_card *card)\n{\n\tstruct snd_usb_audio *chip = card->private_data;\n\tstruct snd_usb_endpoint *ep, *n;\n\n\tlist_for_each_entry_safe(ep, n, &chip->ep_list, list)\n\t\tsnd_usb_endpoint_free(ep);\n\n\tmutex_destroy(&chip->mutex);\n\tif (!atomic_read(&chip->shutdown))\n\t\tdev_set_drvdata(&chip->dev->dev, NULL);\n}\n\nstatic void usb_audio_make_shortname(struct usb_device *dev,\n\t\t\t\t     struct snd_usb_audio *chip,\n\t\t\t\t     const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct snd_card *card = chip->card;\n\n\tif (quirk && quirk->product_name && *quirk->product_name) {\n\t\tstrlcpy(card->shortname, quirk->product_name,\n\t\t\tsizeof(card->shortname));\n\t\treturn;\n\t}\n\n\t/* retrieve the device string as shortname */\n\tif (!dev->descriptor.iProduct ||\n\t    usb_string(dev, dev->descriptor.iProduct,\n\t\t       card->shortname, sizeof(card->shortname)) <= 0) {\n\t\t/* no name available from anywhere, so use ID */\n\t\tsprintf(card->shortname, \"USB Device %#04x:%#04x\",\n\t\t\tUSB_ID_VENDOR(chip->usb_id),\n\t\t\tUSB_ID_PRODUCT(chip->usb_id));\n\t}\n\n\tstrim(card->shortname);\n}\n\nstatic void usb_audio_make_longname(struct usb_device *dev,\n\t\t\t\t    struct snd_usb_audio *chip,\n\t\t\t\t    const struct snd_usb_audio_quirk *quirk)\n{\n\tstruct snd_card *card = chip->card;\n\tint len;\n\n\t/* shortcut - if any pre-defined string is given, use it */\n\tif (quirk && quirk->profile_name && *quirk->profile_name) {\n\t\tstrlcpy(card->longname, quirk->profile_name,\n\t\t\tsizeof(card->longname));\n\t\treturn;\n\t}\n\n\tif (quirk && quirk->vendor_name && *quirk->vendor_name) {\n\t\tlen = strlcpy(card->longname, quirk->vendor_name, sizeof(card->longname));\n\t} else {\n\t\t/* retrieve the vendor and device strings as longname */\n\t\tif (dev->descriptor.iManufacturer)\n\t\t\tlen = usb_string(dev, dev->descriptor.iManufacturer,\n\t\t\t\t\t card->longname, sizeof(card->longname));\n\t\telse\n\t\t\tlen = 0;\n\t\t/* we don't really care if there isn't any vendor string */\n\t}\n\tif (len > 0) {\n\t\tstrim(card->longname);\n\t\tif (*card->longname)\n\t\t\tstrlcat(card->longname, \" \", sizeof(card->longname));\n\t}\n\n\tstrlcat(card->longname, card->shortname, sizeof(card->longname));\n\n\tlen = strlcat(card->longname, \" at \", sizeof(card->longname));\n\n\tif (len < sizeof(card->longname))\n\t\tusb_make_path(dev, card->longname + len, sizeof(card->longname) - len);\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\t\tstrlcat(card->longname, \", low speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tstrlcat(card->longname, \", full speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tstrlcat(card->longname, \", high speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tstrlcat(card->longname, \", super speed\", sizeof(card->longname));\n\t\tbreak;\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tstrlcat(card->longname, \", super speed plus\", sizeof(card->longname));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n/*\n * create a chip instance and set its names.\n */\nstatic int snd_usb_audio_create(struct usb_interface *intf,\n\t\t\t\tstruct usb_device *dev, int idx,\n\t\t\t\tconst struct snd_usb_audio_quirk *quirk,\n\t\t\t\tunsigned int usb_id,\n\t\t\t\tstruct snd_usb_audio **rchip)\n{\n\tstruct snd_card *card;\n\tstruct snd_usb_audio *chip;\n\tint err;\n\tchar component[14];\n\n\t*rchip = NULL;\n\n\tswitch (snd_usb_get_speed(dev)) {\n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_WIRELESS:\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->dev, \"unknown device speed %d\\n\", snd_usb_get_speed(dev));\n\t\treturn -ENXIO;\n\t}\n\n\terr = snd_card_new(&intf->dev, index[idx], id[idx], THIS_MODULE,\n\t\t\t   sizeof(*chip), &card);\n\tif (err < 0) {\n\t\tdev_err(&dev->dev, \"cannot create card instance %d\\n\", idx);\n\t\treturn err;\n\t}\n\n\tchip = card->private_data;\n\tmutex_init(&chip->mutex);\n\tinit_waitqueue_head(&chip->shutdown_wait);\n\tchip->index = idx;\n\tchip->dev = dev;\n\tchip->card = card;\n\tchip->setup = device_setup[idx];\n\tchip->autoclock = autoclock;\n\tatomic_set(&chip->active, 1); /* avoid autopm during probing */\n\tatomic_set(&chip->usage_count, 0);\n\tatomic_set(&chip->shutdown, 0);\n\n\tchip->usb_id = usb_id;\n\tINIT_LIST_HEAD(&chip->pcm_list);\n\tINIT_LIST_HEAD(&chip->ep_list);\n\tINIT_LIST_HEAD(&chip->midi_list);\n\tINIT_LIST_HEAD(&chip->mixer_list);\n\n\tcard->private_free = snd_usb_audio_free;\n\n\tstrcpy(card->driver, \"USB-Audio\");\n\tsprintf(component, \"USB%04x:%04x\",\n\t\tUSB_ID_VENDOR(chip->usb_id), USB_ID_PRODUCT(chip->usb_id));\n\tsnd_component_add(card, component);\n\n\tusb_audio_make_shortname(dev, chip, quirk);\n\tusb_audio_make_longname(dev, chip, quirk);\n\n\tsnd_usb_audio_create_proc(chip);\n\n\t*rchip = chip;\n\treturn 0;\n}\n\n/* look for a matching quirk alias id */\nstatic bool get_alias_id(struct usb_device *dev, unsigned int *id)\n{\n\tint i;\n\tunsigned int src, dst;\n\n\tfor (i = 0; i < ARRAY_SIZE(quirk_alias); i++) {\n\t\tif (!quirk_alias[i] ||\n\t\t    sscanf(quirk_alias[i], \"%x:%x\", &src, &dst) != 2 ||\n\t\t    src != *id)\n\t\t\tcontinue;\n\t\tdev_info(&dev->dev,\n\t\t\t \"device (%04x:%04x): applying quirk alias %04x:%04x\\n\",\n\t\t\t USB_ID_VENDOR(*id), USB_ID_PRODUCT(*id),\n\t\t\t USB_ID_VENDOR(dst), USB_ID_PRODUCT(dst));\n\t\t*id = dst;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic const struct usb_device_id usb_audio_ids[]; /* defined below */\n\n/* look for the corresponding quirk */\nstatic const struct snd_usb_audio_quirk *\nget_alias_quirk(struct usb_device *dev, unsigned int id)\n{\n\tconst struct usb_device_id *p;\n\n\tfor (p = usb_audio_ids; p->match_flags; p++) {\n\t\t/* FIXME: this checks only vendor:product pair in the list */\n\t\tif ((p->match_flags & USB_DEVICE_ID_MATCH_DEVICE) ==\n\t\t    USB_DEVICE_ID_MATCH_DEVICE &&\n\t\t    p->idVendor == USB_ID_VENDOR(id) &&\n\t\t    p->idProduct == USB_ID_PRODUCT(id))\n\t\t\treturn (const struct snd_usb_audio_quirk *)p->driver_info;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * probe the active usb device\n *\n * note that this can be called multiple times per a device, when it\n * includes multiple audio control interfaces.\n *\n * thus we check the usb device pointer and creates the card instance\n * only at the first time.  the successive calls of this function will\n * append the pcm interface to the corresponding card.\n */\nstatic int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * found a config.  now register to ALSA\n\t */\n\n\t/* check whether it's already registered */\n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, \"USB device is in the shutdown state, cannot create a card instance\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active); /* avoid autopm */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\t/* it's a fresh one.\n\t\t * now look for an empty slot and create a new card instance\n\t\t */\n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (!usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\tif (enable[i]) {\n\t\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t\t   id, &chip);\n\t\t\t\t\tif (err < 0)\n\t\t\t\t\t\tgoto __error;\n\t\t\t\t\tchip->pm_intf = intf;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (vid[i] != -1 || pid[i] != -1) {\n\t\t\t\t\tdev_info(&dev->dev,\n\t\t\t\t\t\t \"device (%04x:%04x) is disabled\\n\",\n\t\t\t\t\t\t USB_ID_VENDOR(id),\n\t\t\t\t\t\t USB_ID_PRODUCT(id));\n\t\t\t\t\terr = -ENOENT;\n\t\t\t\t\tgoto __error;\n\t\t\t\t}\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, \"no available usb audio device\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tdev_set_drvdata(&dev->dev, chip);\n\n\t/*\n\t * For devices with more than one control interface, we assume the\n\t * first contains the audio controls. We might need a more specific\n\t * check here in the future.\n\t */\n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\tchip->txfr_quirk = 0;\n\terr = 1; /* continue */\n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t/* need some special handlings */\n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t/* create normal USB audio interfaces */\n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\t/* we are allowed to call snd_card_register() many times */\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\t/* chip->active is inside the chip->card object,\n\t\t * decrement before memory is possibly returned.\n\t\t */\n\t\tatomic_dec(&chip->active);\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}\n\n/*\n * we need to take care of counter, since disconnection can be called also\n * many times as well as usb_audio_probe().\n */\nstatic void usb_audio_disconnect(struct usb_interface *intf)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_card *card;\n\tstruct list_head *p;\n\n\tif (chip == (void *)-1L)\n\t\treturn;\n\n\tcard = chip->card;\n\n\tmutex_lock(&register_mutex);\n\tif (atomic_inc_return(&chip->shutdown) == 1) {\n\t\tstruct snd_usb_stream *as;\n\t\tstruct snd_usb_endpoint *ep;\n\t\tstruct usb_mixer_interface *mixer;\n\n\t\t/* wait until all pending tasks done;\n\t\t * they are protected by snd_usb_lock_shutdown()\n\t\t */\n\t\twait_event(chip->shutdown_wait,\n\t\t\t   !atomic_read(&chip->usage_count));\n\t\tsnd_card_disconnect(card);\n\t\t/* release the pcm resources */\n\t\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\t\tsnd_usb_stream_disconnect(as);\n\t\t}\n\t\t/* release the endpoint resources */\n\t\tlist_for_each_entry(ep, &chip->ep_list, list) {\n\t\t\tsnd_usb_endpoint_release(ep);\n\t\t}\n\t\t/* release the midi resources */\n\t\tlist_for_each(p, &chip->midi_list) {\n\t\t\tsnd_usbmidi_disconnect(p);\n\t\t}\n\t\t/* release mixer resources */\n\t\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\t\tsnd_usb_mixer_disconnect(mixer);\n\t\t}\n\t}\n\n\tchip->num_interfaces--;\n\tif (chip->num_interfaces <= 0) {\n\t\tusb_chip[chip->index] = NULL;\n\t\tmutex_unlock(&register_mutex);\n\t\tsnd_card_free_when_closed(card);\n\t} else {\n\t\tmutex_unlock(&register_mutex);\n\t}\n}\n\n/* lock the shutdown (disconnect) task and autoresume */\nint snd_usb_lock_shutdown(struct snd_usb_audio *chip)\n{\n\tint err;\n\n\tatomic_inc(&chip->usage_count);\n\tif (atomic_read(&chip->shutdown)) {\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\terr = snd_usb_autoresume(chip);\n\tif (err < 0)\n\t\tgoto error;\n\treturn 0;\n\n error:\n\tif (atomic_dec_and_test(&chip->usage_count))\n\t\twake_up(&chip->shutdown_wait);\n\treturn err;\n}\n\n/* autosuspend and unlock the shutdown */\nvoid snd_usb_unlock_shutdown(struct snd_usb_audio *chip)\n{\n\tsnd_usb_autosuspend(chip);\n\tif (atomic_dec_and_test(&chip->usage_count))\n\t\twake_up(&chip->shutdown_wait);\n}\n\n#ifdef CONFIG_PM\n\nint snd_usb_autoresume(struct snd_usb_audio *chip)\n{\n\tif (atomic_read(&chip->shutdown))\n\t\treturn -EIO;\n\tif (atomic_inc_return(&chip->active) == 1)\n\t\treturn usb_autopm_get_interface(chip->pm_intf);\n\treturn 0;\n}\n\nvoid snd_usb_autosuspend(struct snd_usb_audio *chip)\n{\n\tif (atomic_read(&chip->shutdown))\n\t\treturn;\n\tif (atomic_dec_and_test(&chip->active))\n\t\tusb_autopm_put_interface(chip->pm_intf);\n}\n\nstatic int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_usb_stream *as;\n\tstruct usb_mixer_interface *mixer;\n\tstruct list_head *p;\n\n\tif (chip == (void *)-1L)\n\t\treturn 0;\n\n\tchip->autosuspended = !!PMSG_IS_AUTO(message);\n\tif (!chip->autosuspended)\n\t\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D3hot);\n\tif (!chip->num_suspended_intf++) {\n\t\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\t\tsnd_pcm_suspend_all(as->pcm);\n\t\t\tsnd_usb_pcm_suspend(as);\n\t\t\tas->substream[0].need_setup_ep =\n\t\t\t\tas->substream[1].need_setup_ep = true;\n\t\t}\n\t\tlist_for_each(p, &chip->midi_list)\n\t\t\tsnd_usbmidi_suspend(p);\n\t\tlist_for_each_entry(mixer, &chip->mixer_list, list)\n\t\t\tsnd_usb_mixer_suspend(mixer);\n\t}\n\n\treturn 0;\n}\n\nstatic int __usb_audio_resume(struct usb_interface *intf, bool reset_resume)\n{\n\tstruct snd_usb_audio *chip = usb_get_intfdata(intf);\n\tstruct snd_usb_stream *as;\n\tstruct usb_mixer_interface *mixer;\n\tstruct list_head *p;\n\tint err = 0;\n\n\tif (chip == (void *)-1L)\n\t\treturn 0;\n\tif (--chip->num_suspended_intf)\n\t\treturn 0;\n\n\tatomic_inc(&chip->active); /* avoid autopm */\n\n\tlist_for_each_entry(as, &chip->pcm_list, list) {\n\t\terr = snd_usb_pcm_resume(as);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t}\n\n\t/*\n\t * ALSA leaves material resumption to user space\n\t * we just notify and restart the mixers\n\t */\n\tlist_for_each_entry(mixer, &chip->mixer_list, list) {\n\t\terr = snd_usb_mixer_resume(mixer, reset_resume);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t}\n\n\tlist_for_each(p, &chip->midi_list) {\n\t\tsnd_usbmidi_resume(p);\n\t}\n\n\tif (!chip->autosuspended)\n\t\tsnd_power_change_state(chip->card, SNDRV_CTL_POWER_D0);\n\tchip->autosuspended = 0;\n\nerr_out:\n\tatomic_dec(&chip->active); /* allow autopm after this point */\n\treturn err;\n}\n\nstatic int usb_audio_resume(struct usb_interface *intf)\n{\n\treturn __usb_audio_resume(intf, false);\n}\n\nstatic int usb_audio_reset_resume(struct usb_interface *intf)\n{\n\treturn __usb_audio_resume(intf, true);\n}\n#else\n#define usb_audio_suspend\tNULL\n#define usb_audio_resume\tNULL\n#define usb_audio_reset_resume\tNULL\n#endif\t\t/* CONFIG_PM */\n\nstatic const struct usb_device_id usb_audio_ids [] = {\n#include \"quirks-table.h\"\n    { .match_flags = (USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS),\n      .bInterfaceClass = USB_CLASS_AUDIO,\n      .bInterfaceSubClass = USB_SUBCLASS_AUDIOCONTROL },\n    { }\t\t\t\t\t\t/* Terminating entry */\n};\nMODULE_DEVICE_TABLE(usb, usb_audio_ids);\n\n/*\n * entry point for linux usb interface\n */\n\nstatic struct usb_driver usb_audio_driver = {\n\t.name =\t\t\"snd-usb-audio\",\n\t.probe =\tusb_audio_probe,\n\t.disconnect =\tusb_audio_disconnect,\n\t.suspend =\tusb_audio_suspend,\n\t.resume =\tusb_audio_resume,\n\t.reset_resume =\tusb_audio_reset_resume,\n\t.id_table =\tusb_audio_ids,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(usb_audio_driver);\n"], "filenames": ["sound/usb/card.c"], "buggy_code_start_loc": [684], "buggy_code_end_loc": [688], "fixing_code_start_loc": [685], "fixing_code_end_loc": [690], "type": "CWE-416", "message": "In the Linux kernel through 4.19.6, a local user could exploit a use-after-free in the ALSA driver by supplying a malicious USB Sound device (with zero interfaces) that is mishandled in usb_audio_probe in sound/usb/card.c.", "other": {"cve": {"id": "CVE-2018-19824", "sourceIdentifier": "cve@mitre.org", "published": "2018-12-03T17:29:00.517", "lastModified": "2019-09-10T22:15:10.813", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Linux kernel through 4.19.6, a local user could exploit a use-after-free in the ALSA driver by supplying a malicious USB Sound device (with zero interfaces) that is mishandled in usb_audio_probe in sound/usb/card.c."}, {"lang": "es", "value": "En el kernel de Linux hasta la versi\u00f3n 4.19.6, un usuario local podr\u00eda explotar memoria previamente liberada en el controlador ALSA suministrando un dispositivo de sonido USB malicioso (con cero interfaces) que no se maneja correctamente en usb_audio_probe en sound/usb/card.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.19.6", "matchCriteriaId": "461E9D3B-DF9E-4806-A060-CFDA74EF0999"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/106109", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2703", "source": "cve@mitre.org"}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1118152", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound.git/commit/?id=5f8cf712582617d523120df67d392059eaf2fc4b", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/5f8cf712582617d523120df67d392059eaf2fc4b", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/03/msg00034.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/04/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/05/msg00002.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K98155950", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3879-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3879-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3930-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3930-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3931-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3931-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3933-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3933-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/5f8cf712582617d523120df67d392059eaf2fc4b"}}