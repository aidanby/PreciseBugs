{"buggy_code": ["\" Test Vim9 classes\n\nsource check.vim\nimport './vim9.vim' as v9\n\ndef Test_class_basic()\n  var lines =<< trim END\n      class NotWorking\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1316:')\n\n  lines =<< trim END\n      vim9script\n      class notWorking\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1314:')\n\n  lines =<< trim END\n      vim9script\n      class Not@working\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1315:')\n\n  lines =<< trim END\n      vim9script\n      abstract noclass Something\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E475:')\n\n  lines =<< trim END\n      vim9script\n      abstract classy Something\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E475:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n      endcl\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n      endclass school's out\n  END\n  v9.CheckScriptFailure(lines, 'E488:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n      endclass | echo 'done'\n  END\n  v9.CheckScriptFailure(lines, 'E488:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1317:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this.\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1317:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this .count\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1317:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this. count\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1317:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this.count: number\n        that.count\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1318: Not a valid command in a class: that.count')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this.count\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1022:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        def new()\n          this.state = 0\n        enddef\n      endclass\n      var obj = Something.new()\n  END\n  v9.CheckScriptFailure(lines, 'E1089:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this.count : number\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1059:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this.count:number\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1069:')\n\n  lines =<< trim END\n      vim9script\n\n      class TextPosition\n        this.lnum: number\n        this.col: number\n\n        # make a nicely formatted string\n        def ToString(): string\n          return $'({this.lnum}, {this.col})'\n        enddef\n      endclass\n\n      # use the automatically generated new() method\n      var pos = TextPosition.new(2, 12)\n      assert_equal(2, pos.lnum)\n      assert_equal(12, pos.col)\n\n      # call an object method\n      assert_equal('(2, 12)', pos.ToString())\n\n      assert_equal(v:t_class, type(TextPosition))\n      assert_equal(v:t_object, type(pos))\n      assert_equal('class<TextPosition>', typename(TextPosition))\n      assert_equal('object<TextPosition>', typename(pos))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_defined_twice()\n  # class defined twice should fail\n  var lines =<< trim END\n      vim9script\n      class There\n      endclass\n      class There\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1041: Redefining script item: \"There\"')\n\n  # one class, reload same script twice is OK\n  lines =<< trim END\n      vim9script\n      class There\n      endclass\n  END\n  writefile(lines, 'XclassTwice.vim', 'D')\n  source XclassTwice.vim\n  source XclassTwice.vim\nenddef\n\ndef Test_returning_null_object()\n  # this was causing an internal error\n  var lines =<< trim END\n      vim9script\n\n      class BufferList\n          def Current(): any\n              return null_object\n          enddef\n      endclass\n\n      var buffers = BufferList.new()\n      echo buffers.Current()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_interface_wrong_end()\n  var lines =<< trim END\n      vim9script\n      abstract class SomeName\n        this.member = 'text'\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E476: Invalid command: endinterface, expected endclass')\n\n  lines =<< trim END\n      vim9script\n      export interface AnotherName\n        this.member: string\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E476: Invalid command: endclass, expected endinterface')\nenddef\n\ndef Test_object_not_set()\n  var lines =<< trim END\n      vim9script\n\n      class State\n        this.value = 'xyz'\n      endclass\n\n      var state: State\n      var db = {'xyz': 789}\n      echo db[state.value]\n  END\n  v9.CheckScriptFailure(lines, 'E1360:')\n\n  lines =<< trim END\n      vim9script\n\n      class Class\n          this.id: string\n          def Method1()\n              echo 'Method1' .. this.id\n          enddef\n      endclass\n\n      var obj: Class\n      def Func()\n          obj.Method1()\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E1360:')\n\n  lines =<< trim END\n      vim9script\n\n      class Background\n        this.background = 'dark'\n      endclass\n\n      class Colorscheme\n        this._bg: Background\n\n        def GetBackground(): string\n          return this._bg.background\n        enddef\n      endclass\n\n      var bg: Background           # UNINITIALIZED\n      echo Colorscheme.new(bg).GetBackground()\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected object<Background> but got object<Unknown>')\n\n  # TODO: this should not give an error but be handled at runtime\n  lines =<< trim END\n      vim9script\n\n      class Class\n          this.id: string\n          def Method1()\n              echo 'Method1' .. this.id\n          enddef\n      endclass\n\n      var obj = null_object\n      def Func()\n          obj.Method1()\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E1363:')\nenddef\n\ndef Test_class_member_initializer()\n  var lines =<< trim END\n      vim9script\n\n      class TextPosition\n        this.lnum: number = 1\n        this.col: number = 1\n\n        # constructor with only the line number\n        def new(lnum: number)\n          this.lnum = lnum\n        enddef\n      endclass\n\n      var pos = TextPosition.new(3)\n      assert_equal(3, pos.lnum)\n      assert_equal(1, pos.col)\n\n      var instr = execute('disassemble TextPosition.new')\n      assert_match('new\\_s*' ..\n            '0 NEW TextPosition size \\d\\+\\_s*' ..\n            '\\d PUSHNR 1\\_s*' ..\n            '\\d STORE_THIS 0\\_s*' ..\n            '\\d PUSHNR 1\\_s*' ..\n            '\\d STORE_THIS 1\\_s*' ..\n            'this.lnum = lnum\\_s*' ..\n            '\\d LOAD arg\\[-1]\\_s*' ..\n            '\\d PUSHNR 0\\_s*' ..\n            '\\d LOAD $0\\_s*' ..\n            '\\d\\+ STOREINDEX object\\_s*' ..\n            '\\d\\+ RETURN object.*',\n            instr)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_member_any_used_as_object()\n  var lines =<< trim END\n      vim9script\n\n      class Inner\n        this.value: number = 0\n      endclass\n\n      class Outer\n        this.inner: any\n      endclass\n\n      def F(outer: Outer)\n        outer.inner.value = 1\n      enddef\n\n      var inner_obj = Inner.new(0)\n      var outer_obj = Outer.new(inner_obj)\n      F(outer_obj)\n      assert_equal(1, inner_obj.value)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      class Inner\n        this.value: number = 0\n      endclass\n\n      class Outer\n        this.inner: Inner\n      endclass\n\n      def F(outer: Outer)\n        outer.inner.value = 1\n      enddef\n\n      def Test_assign_to_nested_typed_member()\n        var inner = Inner.new(0)\n        var outer = Outer.new(inner)\n        F(outer)\n        assert_equal(1, inner.value)\n      enddef\n\n      Test_assign_to_nested_typed_member()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_assignment_with_operator()\n  var lines =<< trim END\n      vim9script\n\n      class Foo\n        this.x: number\n\n        def Add(n: number)\n          this.x += n\n        enddef\n      endclass\n\n      var f =  Foo.new(3)\n      f.Add(17)\n      assert_equal(20, f.x)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_of_objects()\n  var lines =<< trim END\n      vim9script\n\n      class Foo\n        def Add()\n        enddef\n      endclass\n\n      def ProcessList(fooList: list<Foo>)\n        for foo in fooList\n          foo.Add()\n        endfor\n      enddef\n\n      var l: list<Foo> = [Foo.new()]\n      ProcessList(l)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_expr_after_using_object()\n  var lines =<< trim END\n      vim9script\n\n      class Something\n        this.label: string = ''\n      endclass\n\n      def Foo(): Something\n        var v = Something.new()\n        echo 'in Foo(): ' .. typename(v)\n        return v\n      enddef\n\n      Foo()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_default_new()\n  var lines =<< trim END\n      vim9script\n\n      class TextPosition\n        this.lnum: number = 1\n        this.col: number = 1\n      endclass\n\n      var pos = TextPosition.new()\n      assert_equal(1, pos.lnum)\n      assert_equal(1, pos.col)\n\n      pos = TextPosition.new(v:none, v:none)\n      assert_equal(1, pos.lnum)\n      assert_equal(1, pos.col)\n\n      pos = TextPosition.new(3, 22)\n      assert_equal(3, pos.lnum)\n      assert_equal(22, pos.col)\n\n      pos = TextPosition.new(v:none, 33)\n      assert_equal(1, pos.lnum)\n      assert_equal(33, pos.col)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class Person\n        this.name: string\n        this.age: number = 42\n        this.education: string = \"unknown\"\n\n        def new(this.name, this.age = v:none, this.education = v:none)\n        enddef\n      endclass\n\n      var piet = Person.new(\"Piet\")\n      assert_equal(\"Piet\", piet.name)\n      assert_equal(42, piet.age)\n      assert_equal(\"unknown\", piet.education)\n\n      var chris = Person.new(\"Chris\", 4, \"none\")\n      assert_equal(\"Chris\", chris.name)\n      assert_equal(4, chris.age)\n      assert_equal(\"none\", chris.education)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class Person\n        this.name: string\n        this.age: number = 42\n        this.education: string = \"unknown\"\n\n        def new(this.name, this.age = v:none, this.education = v:none)\n        enddef\n      endclass\n\n      var missing = Person.new()\n  END\n  v9.CheckScriptFailure(lines, 'E119:')\nenddef\n\ndef Test_class_object_member_inits()\n  var lines =<< trim END\n      vim9script\n      class TextPosition\n        this.lnum: number\n        this.col = 1\n        this.addcol: number = 2\n      endclass\n\n      var pos = TextPosition.new()\n      assert_equal(0, pos.lnum)\n      assert_equal(1, pos.col)\n      assert_equal(2, pos.addcol)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class TextPosition\n        this.lnum\n        this.col = 1\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1022:')\n\n  lines =<< trim END\n      vim9script\n      class TextPosition\n        this.lnum = v:none\n        this.col = 1\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1330:')\nenddef\n\ndef Test_class_object_member_access()\n  var lines =<< trim END\n      vim9script\n      class Triple\n         this._one = 1\n         this.two = 2\n         public this.three = 3\n\n         def GetOne(): number\n           return this._one\n         enddef\n      endclass\n\n      var trip = Triple.new()\n      assert_equal(1, trip.GetOne())\n      assert_equal(2, trip.two)\n      assert_equal(3, trip.three)\n      assert_fails('echo trip._one', 'E1333')\n\n      assert_fails('trip._one = 11', 'E1333')\n      assert_fails('trip.two = 22', 'E1335')\n      trip.three = 33\n      assert_equal(33, trip.three)\n\n      assert_fails('trip.four = 4', 'E1334')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      class MyCar\n        this.make: string\n        this.age = 5\n\n        def new(make_arg: string)\n          this.make = make_arg\n        enddef\n\n        def GetMake(): string\n          return $\"make = {this.make}\"\n        enddef\n        def GetAge(): number\n          return this.age\n        enddef\n      endclass\n\n      var c = MyCar.new(\"abc\")\n      assert_equal('make = abc', c.GetMake())\n\n      c = MyCar.new(\"def\")\n      assert_equal('make = def', c.GetMake())\n\n      var c2 = MyCar.new(\"123\")\n      assert_equal('make = 123', c2.GetMake())\n\n      def CheckCar()\n        assert_equal(\"make = def\", c.GetMake())\n        assert_equal(5, c.GetAge())\n      enddef\n      CheckCar()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      class MyCar\n        this.make: string\n\n        def new(make_arg: string)\n            this.make = make_arg\n        enddef\n      endclass\n\n      var c = MyCar.new(\"abc\")\n      var c = MyCar.new(\"def\")\n  END\n  v9.CheckScriptFailure(lines, 'E1041:')\n\n  lines =<< trim END\n      vim9script\n\n      class Foo\n        this.x: list<number> = []\n\n        def Add(n: number): any\n          this.x->add(n)\n          return this\n        enddef\n      endclass\n\n      echo Foo.new().Add(1).Add(2).x\n      echo Foo.new().Add(1).Add(2)\n            .x\n      echo Foo.new().Add(1)\n            .Add(2).x\n      echo Foo.new()\n            .Add(1).Add(2).x\n      echo Foo.new()\n            .Add(1) \n            .Add(2)\n            .x\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_object_compare()\n  var class_lines =<< trim END\n      vim9script\n      class Item\n        this.nr = 0\n        this.name = 'xx'\n      endclass\n  END\n\n  # used at the script level and in a compiled function\n  var test_lines =<< trim END\n      var i1 = Item.new()\n      assert_equal(i1, i1)\n      assert_true(i1 is i1)\n      var i2 = Item.new()\n      assert_equal(i1, i2)\n      assert_false(i1 is i2)\n      var i3 = Item.new(0, 'xx')\n      assert_equal(i1, i3)\n\n      var io1 = Item.new(1, 'xx')\n      assert_notequal(i1, io1)\n      var io2 = Item.new(0, 'yy')\n      assert_notequal(i1, io2)\n  END\n\n  v9.CheckScriptSuccess(class_lines + test_lines)\n  v9.CheckScriptSuccess(\n      class_lines + ['def Test()'] + test_lines + ['enddef', 'Test()'])\n\n  for op in ['>', '>=', '<', '<=', '=~', '!~']\n    var op_lines = [\n          'var i1 = Item.new()',\n          'var i2 = Item.new()',\n          'echo i1 ' .. op .. ' i2',\n          ]\n    v9.CheckScriptFailure(class_lines + op_lines, 'E1153: Invalid operation for object')\n    v9.CheckScriptFailure(class_lines\n          + ['def Test()'] + op_lines + ['enddef', 'Test()'], 'E1153: Invalid operation for object')\n  endfor\nenddef\n\ndef Test_object_type()\n  var lines =<< trim END\n      vim9script\n\n      class One\n        this.one = 1\n      endclass\n      class Two\n        this.two = 2\n      endclass\n      class TwoMore extends Two\n        this.more = 9\n      endclass\n\n      var o: One = One.new()\n      var t: Two = Two.new()\n      var m: TwoMore = TwoMore.new()\n      var tm: Two = TwoMore.new()\n\n      t = m\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      class One\n        this.one = 1\n      endclass\n      class Two\n        this.two = 2\n      endclass\n\n      var o: One = Two.new()\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected object<One> but got object<Two>')\n\n  lines =<< trim END\n      vim9script\n\n      interface One\n        def GetMember(): number\n      endinterface\n      class Two implements One\n        this.one = 1\n        def GetMember(): number\n          return this.one\n        enddef\n      endclass\n\n      var o: One = Two.new(5)\n      assert_equal(5, o.GetMember())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      class Num\n        this.n: number = 0\n      endclass\n\n      def Ref(name: string): func(Num): Num\n        return (arg: Num): Num => {\n          return eval(name)(arg)\n        }\n      enddef\n\n      const Fn = Ref('Double')\n      var Double = (m: Num): Num => Num.new(m.n * 2)\n\n      echo Fn(Num.new(4))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_member()\n  # check access rules\n  var lines =<< trim END\n      vim9script\n      class TextPos\n         this.lnum = 1\n         this.col = 1\n         static counter = 0\n         static _secret = 7\n         public static  anybody = 42\n\n         static def AddToCounter(nr: number)\n           counter += nr\n         enddef\n      endclass\n\n      assert_equal(0, TextPos.counter)\n      TextPos.AddToCounter(3)\n      assert_equal(3, TextPos.counter)\n      assert_fails('echo TextPos.noSuchMember', 'E1338:')\n\n      def GetCounter(): number\n        return TextPos.counter\n      enddef\n      assert_equal(3, GetCounter())\n\n      assert_fails('TextPos.noSuchMember = 2', 'E1337:')\n      assert_fails('TextPos.counter = 5', 'E1335:')\n      assert_fails('TextPos.counter += 5', 'E1335:')\n\n      assert_fails('echo TextPos._secret', 'E1333:')\n      assert_fails('TextPos._secret = 8', 'E1333:')\n\n      assert_equal(42, TextPos.anybody)\n      TextPos.anybody = 12\n      assert_equal(12, TextPos.anybody)\n      TextPos.anybody += 5\n      assert_equal(17, TextPos.anybody)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # example in the help\n  lines =<< trim END\n        vim9script\n\tclass OtherThing\n\t   this.size: number\n\t   static totalSize: number\n\n\t   def new(this.size)\n\t      totalSize += this.size\n\t   enddef\n\tendclass\n        assert_equal(0, OtherThing.totalSize)\n        var to3 = OtherThing.new(3)\n        assert_equal(3, OtherThing.totalSize)\n        var to7 = OtherThing.new(7)\n        assert_equal(10, OtherThing.totalSize)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # access private member in lambda\n  lines =<< trim END\n      vim9script\n\n      class Foo\n        this._x: number = 0\n\n        def Add(n: number): number\n          const F = (): number => this._x + n\n          return F()\n        enddef\n      endclass\n\n      var foo = Foo.new()\n      assert_equal(5, foo.Add(5))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # check shadowing\n  lines =<< trim END\n      vim9script\n\n      class Some\n        static count = 0\n        def Method(count: number)\n          echo count\n        enddef\n      endclass\n\n      var s = Some.new()\n      s.Method(7)\n  END\n  v9.CheckScriptFailure(lines, 'E1340: Argument already declared in the class: count')\n\n  lines =<< trim END\n      vim9script\n\n      class Some\n        static count = 0\n        def Method(arg: number)\n          var count = 3\n          echo arg count\n        enddef\n      endclass\n\n      var s = Some.new()\n      s.Method(7)\n  END\n  v9.CheckScriptFailure(lines, 'E1341: Variable already declared in the class: count')\nenddef\n\nfunc Test_class_garbagecollect()\n  let lines =<< trim END\n      vim9script\n\n      class Point\n        this.p = [2, 3]\n        static pl = ['a', 'b']\n        static pd = {a: 'a', b: 'b'}\n      endclass\n\n      echo Point.pl Point.pd\n      call test_garbagecollect_now()\n      echo Point.pl Point.pd\n  END\n  call v9.CheckScriptSuccess(lines)\nendfunc\n\ndef Test_class_function()\n  var lines =<< trim END\n      vim9script\n      class Value\n        this.value = 0\n        static objects = 0\n\n        def new(v: number)\n          this.value = v\n          ++objects\n        enddef\n\n        static def GetCount(): number\n          return objects\n        enddef\n      endclass\n\n      assert_equal(0, Value.GetCount())\n      var v1 = Value.new(2)\n      assert_equal(1, Value.GetCount())\n      var v2 = Value.new(7)\n      assert_equal(2, Value.GetCount())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_defcompile()\n  var lines =<< trim END\n      vim9script\n\n      class C\n          def Fo(i: number): string\n              return i\n          enddef\n      endclass\n\n      defcompile C.Fo\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected string but got number')\n\n  lines =<< trim END\n      vim9script\n\n      class C\n          static def Fc(): number\n            return 'x'\n          enddef\n      endclass\n\n      defcompile C.Fc\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected number but got string')\nenddef\n\ndef Test_class_object_to_string()\n  var lines =<< trim END\n      vim9script\n      class TextPosition\n        this.lnum = 1\n        this.col = 22\n      endclass\n\n      assert_equal(\"class TextPosition\", string(TextPosition))\n\n      var pos = TextPosition.new()\n      assert_equal(\"object of TextPosition {lnum: 1, col: 22}\", string(pos))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_interface_basics()\n  var lines =<< trim END\n      vim9script\n      interface Something\n        this.value: string\n        static count: number\n        def GetCount(): number\n      endinterface\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      interface SomethingWrong\n        static count = 7\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E1342:')\n\n  lines =<< trim END\n      vim9script\n\n      interface Some\n        static count: number\n        def Method(count: number)\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E1340: Argument already declared in the class: count')\n\n  lines =<< trim END\n      vim9script\n\n      interface Some\n        this.value: number\n        def Method(value: number)\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E1340: Argument already declared in the class: value')\n\n  lines =<< trim END\n      vim9script\n      interface somethingWrong\n        static count = 7\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E1343: Interface name must start with an uppercase letter: somethingWrong')\n\n  lines =<< trim END\n      vim9script\n      interface SomethingWrong\n        this.value: string\n        static count = 7\n        def GetCount(): number\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E1344:')\n\n  lines =<< trim END\n      vim9script\n      interface SomethingWrong\n        this.value: string\n        static count: number\n        def GetCount(): number\n          return 5\n        enddef\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E1345: Not a valid command in an interface: return 5')\n\n  lines =<< trim END\n      vim9script\n      export interface EnterExit\n          def Enter(): void\n          def Exit(): void\n      endinterface\n  END\n  writefile(lines, 'XdefIntf.vim', 'D')\n\n  lines =<< trim END\n      vim9script\n      import './XdefIntf.vim' as defIntf\n      export def With(ee: defIntf.EnterExit, F: func)\n          ee.Enter()\n          try\n              F()\n          finally\n              ee.Exit()\n          endtry\n      enddef\n  END\n  v9.CheckScriptSuccess(lines)\n\n  var imported =<< trim END\n      vim9script\n      export abstract class EnterExit\n          def Enter(): void\n          enddef\n          def Exit(): void\n          enddef\n      endclass\n  END\n  writefile(imported, 'XdefIntf2.vim', 'D')\n\n  lines[1] = \" import './XdefIntf2.vim' as defIntf\"\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_implements_interface()\n  var lines =<< trim END\n      vim9script\n\n      interface Some\n        static count: number\n        def Method(nr: number)\n      endinterface\n\n      class SomeImpl implements Some\n        static count: number\n        def Method(nr: number)\n          echo nr\n        enddef\n      endclass\n\n      interface Another\n        this.member: string\n      endinterface\n\n      class AnotherImpl implements Some, Another\n        this.member = 'abc'\n        static count: number\n        def Method(nr: number)\n          echo nr\n        enddef\n      endclass\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      interface Some\n        static counter: number\n      endinterface\n\n      class SomeImpl implements Some implements Some\n        static count: number\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1350:')\n\n  lines =<< trim END\n      vim9script\n\n      interface Some\n        static counter: number\n      endinterface\n\n      class SomeImpl implements Some, Some\n        static count: number\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1351: Duplicate interface after \"implements\": Some')\n\n  lines =<< trim END\n      vim9script\n\n      interface Some\n        static counter: number\n        def Method(nr: number)\n      endinterface\n\n      class SomeImpl implements Some\n        static count: number\n        def Method(nr: number)\n          echo nr\n        enddef\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1348: Member \"counter\" of interface \"Some\" not implemented')\n\n  lines =<< trim END\n      vim9script\n\n      interface Some\n        static count: number\n        def Methods(nr: number)\n      endinterface\n\n      class SomeImpl implements Some\n        static count: number\n        def Method(nr: number)\n          echo nr\n        enddef\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1349: Function \"Methods\" of interface \"Some\" not implemented')\n\n  # Check different order of members in class and interface works.\n  lines =<< trim END\n      vim9script\n\n      interface Result\n        public this.label: string\n        this.errpos: number\n      endinterface\n\n      # order of members is opposite of interface\n      class Failure implements Result\n        this.errpos: number = 42\n        public this.label: string = 'label'\n      endclass\n\n      def Test()\n        var result: Result = Failure.new()\n\n        assert_equal('label', result.label)\n        assert_equal(42, result.errpos)\n\n        result.label = 'different'\n        assert_equal('different', result.label)\n        assert_equal(42, result.errpos)\n      enddef\n\n      Test()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_call_interface_method()\n  var lines =<< trim END\n    vim9script\n    interface Base\n      def Enter(): void\n    endinterface\n\n    class Child implements Base\n      def Enter(): void\n        g:result ..= 'child'\n      enddef\n    endclass\n\n    def F(obj: Base)\n      obj.Enter()\n    enddef\n\n    g:result = ''\n    F(Child.new())\n    assert_equal('child', g:result)\n    unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    class Base\n      def Enter(): void\n        g:result ..= 'base'\n      enddef\n    endclass\n\n    class Child extends Base\n      def Enter(): void\n        g:result ..= 'child'\n      enddef\n    endclass\n\n    def F(obj: Base)\n      obj.Enter()\n    enddef\n\n    g:result = ''\n    F(Child.new())\n    assert_equal('child', g:result)\n    unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # method of interface returns a value\n  lines =<< trim END\n    vim9script\n    interface Base\n      def Enter(): string\n    endinterface\n\n    class Child implements Base\n      def Enter(): string\n        g:result ..= 'child'\n        return \"/resource\"\n      enddef\n    endclass\n\n    def F(obj: Base)\n      var r = obj.Enter()\n      g:result ..= r\n    enddef\n\n    g:result = ''\n    F(Child.new())\n    assert_equal('child/resource', g:result)\n    unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    class Base\n      def Enter(): string\n        return null_string\n      enddef\n    endclass\n\n    class Child extends Base\n      def Enter(): string\n        g:result ..= 'child'\n        return \"/resource\"\n      enddef\n    endclass\n\n    def F(obj: Base)\n      var r = obj.Enter()\n      g:result ..= r\n    enddef\n\n    g:result = ''\n    F(Child.new())\n    assert_equal('child/resource', g:result)\n    unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\n\n\n  # No class that implements the interface.\n  lines =<< trim END\n      vim9script\n\n      interface IWithEE\n          def Enter(): any\n          def Exit(): void\n      endinterface\n\n      def With1(ee: IWithEE, F: func)\n          var r = ee.Enter()\n      enddef\n\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_used_as_type()\n  var lines =<< trim END\n      vim9script\n\n      class Point\n        this.x = 0\n        this.y = 0\n      endclass\n\n      var p: Point\n      p = Point.new(2, 33)\n      assert_equal(2, p.x)\n      assert_equal(33, p.y)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      interface HasX\n        this.x: number\n      endinterface\n\n      class Point implements HasX\n        this.x = 0\n        this.y = 0\n      endclass\n\n      var p: Point\n      p = Point.new(2, 33)\n      var hx = p\n      assert_equal(2, hx.x)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      class Point\n        this.x = 0\n        this.y = 0\n      endclass\n\n      var p: Point\n      p = 'text'\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected object<Point> but got string')\nenddef\n\ndef Test_class_extends()\n  var lines =<< trim END\n      vim9script\n      class Base\n        this.one = 1\n        def GetOne(): number\n          return this.one\n        enddef\n      endclass\n      class Child extends Base\n        this.two = 2\n        def GetTotal(): number\n          return this.one + this.two\n        enddef\n      endclass\n      var o = Child.new()\n      assert_equal(1, o.one)\n      assert_equal(2, o.two)\n      assert_equal(1, o.GetOne())\n      assert_equal(3, o.GetTotal())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class Base\n        this.one = 1\n      endclass\n      class Child extends Base\n        this.two = 2\n      endclass\n      var o = Child.new(3, 44)\n      assert_equal(3, o.one)\n      assert_equal(44, o.two)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class Base\n        this.one = 1\n      endclass\n      class Child extends Base extends Base\n        this.two = 2\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1352: Duplicate \"extends\"')\n\n  lines =<< trim END\n      vim9script\n      class Child extends BaseClass\n        this.two = 2\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1353: Class name not found: BaseClass')\n\n  lines =<< trim END\n      vim9script\n      var SomeVar = 99\n      class Child extends SomeVar\n        this.two = 2\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1354: Cannot extend SomeVar')\n\n  lines =<< trim END\n      vim9script\n      class Base\n        this.name: string\n        def ToString(): string\n          return this.name\n        enddef\n      endclass\n\n      class Child extends Base\n        this.age: number\n        def ToString(): string\n          return super.ToString() .. ': ' .. this.age\n        enddef\n      endclass\n\n      var o = Child.new('John', 42)\n      assert_equal('John: 42', o.ToString())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class Child\n        this.age: number\n        def ToString(): number\n          return this.age\n        enddef\n        def ToString(): string\n          return this.age\n        enddef\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1355: Duplicate function: ToString')\n\n  lines =<< trim END\n      vim9script\n      class Child\n        this.age: number\n        def ToString(): string\n          return super .ToString() .. ': ' .. this.age\n        enddef\n      endclass\n      var o = Child.new(42)\n      echo o.ToString()\n  END\n  v9.CheckScriptFailure(lines, 'E1356:')\n\n  lines =<< trim END\n      vim9script\n      class Base\n        this.name: string\n        def ToString(): string\n          return this.name\n        enddef\n      endclass\n\n      var age = 42\n      def ToString(): string\n        return super.ToString() .. ': ' .. age\n      enddef\n      echo ToString()\n  END\n  v9.CheckScriptFailure(lines, 'E1357:')\n\n  lines =<< trim END\n      vim9script\n      class Child\n        this.age: number\n        def ToString(): string\n          return super.ToString() .. ': ' .. this.age\n        enddef\n      endclass\n      var o = Child.new(42)\n      echo o.ToString()\n  END\n  v9.CheckScriptFailure(lines, 'E1358:')\n\n  lines =<< trim END\n      vim9script\n      class Base\n        this.name: string\n        static def ToString(): string\n          return 'Base class'\n        enddef\n      endclass\n\n      class Child extends Base\n        this.age: number\n        def ToString(): string\n          return Base.ToString() .. ': ' .. this.age\n        enddef\n      endclass\n\n      var o = Child.new('John', 42)\n      assert_equal('Base class: 42', o.ToString())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class Base\n        this.value = 1\n        def new(init: number)\n          this.value = number + 1\n        enddef\n      endclass\n      class Child extends Base\n        def new()\n          this.new(3)\n        enddef\n      endclass\n      var c = Child.new()\n  END\n  v9.CheckScriptFailure(lines, 'E1325: Method not found on class \"Child\": new(')\n\n  # base class with more than one object member\n  lines =<< trim END\n      vim9script\n\n      class Result\n        this.success: bool\n        this.value: any = null\n      endclass\n\n      class Success extends Result\n        def new(this.value = v:none)\n          this.success = true\n        enddef\n      endclass\n\n      var v = Success.new('asdf')\n      assert_equal(\"object of Success {success: true, value: 'asdf'}\", string(v))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_using_base_class()\n  var lines =<< trim END\n    vim9script\n\n    class BaseEE\n        def Enter(): any\n            return null\n        enddef\n        def Exit(resource: any): void\n        enddef\n    endclass\n\n    class ChildEE extends BaseEE\n        def Enter(): any\n            return 42\n        enddef\n\n        def Exit(resource: number): void\n            g:result ..= '/exit'\n        enddef\n    endclass\n\n    def With(ee: BaseEE)\n        var r = ee.Enter()\n        try\n            g:result ..= r\n        finally\n            g:result ..= '/finally'\n            ee.Exit(r)\n        endtry\n    enddef\n\n    g:result = ''\n    With(ChildEE.new())\n    assert_equal('42/finally/exit', g:result)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:result\nenddef\n\n\ndef Test_class_import()\n  var lines =<< trim END\n      vim9script\n      export class Animal\n        this.kind: string\n        this.name: string\n      endclass\n  END\n  writefile(lines, 'Xanimal.vim', 'D')\n\n  lines =<< trim END\n      vim9script\n      import './Xanimal.vim' as animal\n\n      var a: animal.Animal\n      a = animal.Animal.new('fish', 'Eric')\n      assert_equal('fish', a.kind)\n      assert_equal('Eric', a.name)\n\n      var b: animal.Animal = animal.Animal.new('cat', 'Garfield')\n      assert_equal('cat', b.kind)\n      assert_equal('Garfield', b.name)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_abstract_class()\n  var lines =<< trim END\n      vim9script\n      abstract class Base\n        this.name: string\n      endclass\n      class Person extends Base\n        this.age: number\n      endclass\n      var p: Base = Person.new('Peter', 42)\n      assert_equal('Peter', p.name)\n      assert_equal(42, p.age)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      abstract class Base\n        this.name: string\n      endclass\n      class Person extends Base\n        this.age: number\n      endclass\n      var p = Base.new('Peter')\n  END\n  v9.CheckScriptFailure(lines, 'E1325: Method not found on class \"Base\": new(')\n\n  lines =<< trim END\n      abstract class Base\n        this.name: string\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1316:')\nenddef\n\ndef Test_closure_in_class()\n  var lines =<< trim END\n      vim9script\n\n      class Foo\n        this.y: list<string> = ['B']\n\n        def new()\n          g:result = filter(['A', 'B'], (_, v) => index(this.y, v) == -1)\n        enddef\n      endclass\n\n      Foo.new()\n      assert_equal(['A'], g:result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_defer_with_object()\n  var lines =<< trim END\n      vim9script\n\n      class CWithEE\n        def Enter()\n          g:result ..= \"entered/\"\n        enddef\n        def Exit()\n          g:result ..= \"exited\"\n        enddef\n      endclass\n\n      def With(ee: CWithEE, F: func)\n        ee.Enter()\n        defer ee.Exit()\n        F()\n      enddef\n\n      g:result = ''\n      var obj = CWithEE.new()\n      obj->With(() => {\n        g:result ..= \"called/\"\n      })\n      assert_equal('entered/called/exited', g:result)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:result\n\n  lines =<< trim END\n      vim9script\n\n      class BaseWithEE\n        def Enter()\n          g:result ..= \"entered-base/\"\n        enddef\n        def Exit()\n          g:result ..= \"exited-base\"\n        enddef\n      endclass\n\n      class CWithEE extends BaseWithEE\n        def Enter()\n          g:result ..= \"entered-child/\"\n        enddef\n        def Exit()\n          g:result ..= \"exited-child\"\n        enddef\n      endclass\n\n      def With(ee: BaseWithEE, F: func)\n        ee.Enter()\n        defer ee.Exit()\n        F()\n      enddef\n\n      g:result = ''\n      var obj = CWithEE.new()\n      obj->With(() => {\n        g:result ..= \"called/\"\n      })\n      assert_equal('entered-child/called/exited-child', g:result)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:result\nenddef\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9class.c: Vim9 script class support\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n/*\n * Parse a member declaration, both object and class member.\n * Returns OK or FAIL.  When OK then \"varname_end\" is set to just after the\n * variable name and \"type_ret\" is set to the decleared or detected type.\n * \"init_expr\" is set to the initialisation expression (allocated), if there is\n * one.  For an interface \"init_expr\" is NULL.\n */\n    static int\nparse_member(\n\texarg_T\t*eap,\n\tchar_u\t*line,\n\tchar_u\t*varname,\n\tint\thas_public,\t    // TRUE if \"public\" seen before \"varname\"\n\tchar_u\t**varname_end,\n\tgarray_T *type_list,\n\ttype_T\t**type_ret,\n\tchar_u\t**init_expr)\n{\n    *varname_end = to_name_end(varname, FALSE);\n    if (*varname == '_' && has_public)\n    {\n\tsemsg(_(e_public_member_name_cannot_start_with_underscore_str), line);\n\treturn FAIL;\n    }\n\n    char_u *colon = skipwhite(*varname_end);\n    char_u *type_arg = colon;\n    type_T *type = NULL;\n    if (*colon == ':')\n    {\n\tif (VIM_ISWHITE(**varname_end))\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_colon_str), varname);\n\t    return FAIL;\n\t}\n\tif (!VIM_ISWHITE(colon[1]))\n\t{\n\t    semsg(_(e_white_space_required_after_str_str), \":\", varname);\n\t    return FAIL;\n\t}\n\ttype_arg = skipwhite(colon + 1);\n\ttype = parse_type(&type_arg, type_list, TRUE);\n\tif (type == NULL)\n\t    return FAIL;\n    }\n\n    char_u *expr_start = skipwhite(type_arg);\n    char_u *expr_end = expr_start;\n    if (type == NULL && *expr_start != '=')\n    {\n\temsg(_(e_type_or_initialization_required));\n\treturn FAIL;\n    }\n\n    if (*expr_start == '=')\n    {\n\tif (!VIM_ISWHITE(expr_start[-1]) || !VIM_ISWHITE(expr_start[1]))\n\t{\n\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\"=\", type_arg);\n\t    return FAIL;\n\t}\n\texpr_start = skipwhite(expr_start + 1);\n\n\texpr_end = expr_start;\n\tevalarg_T evalarg;\n\tfill_evalarg_from_eap(&evalarg, eap, FALSE);\n\tskip_expr(&expr_end, NULL);\n\n\tif (type == NULL)\n\t{\n\t    // No type specified, use the type of the initializer.\n\t    typval_T tv;\n\t    tv.v_type = VAR_UNKNOWN;\n\t    char_u *expr = expr_start;\n\t    int res = eval0(expr, &tv, eap, &evalarg);\n\n\t    if (res == OK)\n\t    {\n\t\ttype = typval2type(&tv, get_copyID(), type_list,\n\t\t\t\t\t\t       TVTT_DO_MEMBER);\n\t\tclear_tv(&tv);\n\t    }\n\t    if (type == NULL)\n\t    {\n\t\tsemsg(_(e_cannot_get_object_member_type_from_initializer_str),\n\t\t\texpr_start);\n\t\tclear_evalarg(&evalarg, NULL);\n\t\treturn FAIL;\n\t    }\n\t}\n\tclear_evalarg(&evalarg, NULL);\n    }\n    if (!valid_declaration_type(type))\n\treturn FAIL;\n\n    *type_ret = type;\n    if (expr_end > expr_start)\n    {\n\tif (init_expr == NULL)\n\t{\n\t    emsg(_(e_cannot_initialize_member_in_interface));\n\t    return FAIL;\n\t}\n\t*init_expr = vim_strnsave(expr_start, expr_end - expr_start);\n    }\n    return OK;\n}\n\n/*\n * Add a member to an object or a class.\n * Returns OK when successful, \"init_expr\" will be consumed then.\n * Returns FAIL otherwise, caller might need to free \"init_expr\".\n */\n    static int\nadd_member(\n\tgarray_T    *gap,\n\tchar_u\t    *varname,\n\tchar_u\t    *varname_end,\n\tint\t    has_public,\n\ttype_T\t    *type,\n\tchar_u\t    *init_expr)\n{\n    if (ga_grow(gap, 1) == FAIL)\n\treturn FAIL;\n    ocmember_T *m = ((ocmember_T *)gap->ga_data) + gap->ga_len;\n    m->ocm_name = vim_strnsave(varname, varname_end - varname);\n    m->ocm_access = has_public ? VIM_ACCESS_ALL\n\t\t      : *varname == '_' ? VIM_ACCESS_PRIVATE : VIM_ACCESS_READ;\n    m->ocm_type = type;\n    if (init_expr != NULL)\n\tm->ocm_init = init_expr;\n    ++gap->ga_len;\n    return OK;\n}\n\n/*\n * Move the class or object members found while parsing a class into the class.\n * \"gap\" contains the found members.\n * \"parent_members\" points to the members in the parent class (if any)\n * \"parent_count\" is the number of members in the parent class\n * \"members\" will be set to the newly allocated array of members and\n * \"member_count\" set to the number of members.\n * Returns OK or FAIL.\n */\n    static int\nadd_members_to_class(\n    garray_T\t*gap,\n    ocmember_T\t*parent_members,\n    int\t\tparent_count,\n    ocmember_T\t**members,\n    int\t\t*member_count)\n{\n    *member_count = parent_count + gap->ga_len;\n    *members = *member_count == 0 ? NULL\n\t\t\t\t       : ALLOC_MULT(ocmember_T, *member_count);\n    if (*member_count > 0 && *members == NULL)\n\treturn FAIL;\n    for (int i = 0; i < parent_count; ++i)\n    {\n\t// parent members need to be copied\n\tocmember_T\t*m = *members + i;\n\t*m = parent_members[i];\n\tm->ocm_name = vim_strsave(m->ocm_name);\n\tif (m->ocm_init != NULL)\n\t    m->ocm_init = vim_strsave(m->ocm_init);\n    }\n    if (gap->ga_len > 0)\n\t// new members are moved\n\tmch_memmove(*members + parent_count,\n\t\t\t       gap->ga_data, sizeof(ocmember_T) * gap->ga_len);\n    VIM_CLEAR(gap->ga_data);\n    return OK;\n}\n\n/*\n * Convert a member index \"idx\" of interface \"itf\" to the member index of class\n * \"cl\" implementing that interface.\n */\n    int\nobject_index_from_itf_index(class_T *itf, int is_method, int idx, class_T *cl)\n{\n    if (idx > (is_method ? itf->class_obj_method_count\n\t\t\t\t\t\t: itf->class_obj_member_count))\n    {\n\tsiemsg(\"index %d out of range for interface %s\", idx, itf->class_name);\n\treturn 0;\n    }\n    itf2class_T *i2c;\n    for (i2c = itf->class_itf2class; i2c != NULL; i2c = i2c->i2c_next)\n\tif (i2c->i2c_class == cl && i2c->i2c_is_method == is_method)\n\t    break;\n    if (i2c == NULL)\n    {\n\tsiemsg(\"class %s not found on interface %s\",\n\t\t\t\t\t      cl->class_name, itf->class_name);\n\treturn 0;\n    }\n    int *table = (int *)(i2c + 1);\n    return table[idx];\n}\n\n/*\n * Handle \":class\" and \":abstract class\" up to \":endclass\".\n * Handle \":interface\" up to \":endinterface\".\n */\n    void\nex_class(exarg_T *eap)\n{\n    int\t    is_class = eap->cmdidx == CMD_class;  // FALSE for :interface\n    long    start_lnum = SOURCING_LNUM;\n\n    char_u *arg = eap->arg;\n    int is_abstract = eap->cmdidx == CMD_abstract;\n    if (is_abstract)\n    {\n\tif (STRNCMP(arg, \"class\", 5) != 0 || !VIM_ISWHITE(arg[5]))\n\t{\n\t    semsg(_(e_invalid_argument_str), arg);\n\t    return;\n\t}\n\targ = skipwhite(arg + 5);\n\tis_class = TRUE;\n    }\n\n    if (!current_script_is_vim9()\n\t\t|| (cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t|| !getline_equal(eap->getline, eap->cookie, getsourceline))\n    {\n\tif (is_class)\n\t    emsg(_(e_class_can_only_be_defined_in_vim9_script));\n\telse\n\t    emsg(_(e_interface_can_only_be_defined_in_vim9_script));\n\treturn;\n    }\n\n    if (!ASCII_ISUPPER(*arg))\n    {\n\tif (is_class)\n\t    semsg(_(e_class_name_must_start_with_uppercase_letter_str), arg);\n\telse\n\t    semsg(_(e_interface_name_must_start_with_uppercase_letter_str),\n\t\t\t\t\t\t\t\t\t  arg);\n\treturn;\n    }\n    char_u *name_end = find_name_end(arg, NULL, NULL, FNE_CHECK_START);\n    if (!IS_WHITE_OR_NUL(*name_end))\n    {\n\tsemsg(_(e_white_space_required_after_name_str), arg);\n\treturn;\n    }\n    char_u *name_start = arg;\n\n    // \"export class\" gets used when creating the class, don't use \"is_export\"\n    // for the items inside the class.\n    int class_export = is_export;\n    is_export = FALSE;\n\n    // TODO:\n    //    generics: <Tkey, Tentry>\n\n    // Name for \"extends BaseClass\"\n    char_u *extends = NULL;\n\n    // Names for \"implements SomeInterface\"\n    garray_T\tga_impl;\n    ga_init2(&ga_impl, sizeof(char_u *), 5);\n\n    arg = skipwhite(name_end);\n    while (*arg != NUL && *arg != '#' && *arg != '\\n')\n    {\n\t// TODO:\n\t//    specifies SomeInterface\n\tif (STRNCMP(arg, \"extends\", 7) == 0 && IS_WHITE_OR_NUL(arg[7]))\n\t{\n\t    if (extends != NULL)\n\t    {\n\t\temsg(_(e_duplicate_extends));\n\t\tgoto early_ret;\n\t    }\n\t    arg = skipwhite(arg + 7);\n\t    char_u *end = find_name_end(arg, NULL, NULL, FNE_CHECK_START);\n\t    if (!IS_WHITE_OR_NUL(*end))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_name_str), arg);\n\t\tgoto early_ret;\n\t    }\n\t    extends = vim_strnsave(arg, end - arg);\n\t    if (extends == NULL)\n\t\tgoto early_ret;\n\n\t    arg = skipwhite(end + 1);\n\t}\n\telse if (STRNCMP(arg, \"implements\", 10) == 0\n\t\t\t\t\t\t   && IS_WHITE_OR_NUL(arg[10]))\n\t{\n\t    if (ga_impl.ga_len > 0)\n\t    {\n\t\temsg(_(e_duplicate_implements));\n\t\tgoto early_ret;\n\t    }\n\t    arg = skipwhite(arg + 10);\n\n\t    for (;;)\n\t    {\n\t\tchar_u *impl_end = find_name_end(arg, NULL, NULL,\n\t\t\t\t\t\t\t      FNE_CHECK_START);\n\t\tif (!IS_WHITE_OR_NUL(*impl_end) && *impl_end != ',')\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_name_str), arg);\n\t\t    goto early_ret;\n\t\t}\n\t\tchar_u *iname = vim_strnsave(arg, impl_end - arg);\n\t\tif (iname == NULL)\n\t\t    goto early_ret;\n\t\tfor (int i = 0; i < ga_impl.ga_len; ++i)\n\t\t    if (STRCMP(((char_u **)ga_impl.ga_data)[i], iname) == 0)\n\t\t    {\n\t\t\tsemsg(_(e_duplicate_interface_after_implements_str),\n\t\t\t\t\t\t\t\t\tiname);\n\t\t\tvim_free(iname);\n\t\t\tgoto early_ret;\n\t\t    }\n\t\tif (ga_add_string(&ga_impl, iname) == FAIL)\n\t\t{\n\t\t    vim_free(iname);\n\t\t    goto early_ret;\n\t\t}\n\t\tif (*impl_end != ',')\n\t\t{\n\t\t    arg = skipwhite(impl_end);\n\t\t    break;\n\t\t}\n\t\targ = skipwhite(impl_end + 1);\n\t    }\n\t}\n\telse\n\t{\n\t    semsg(_(e_trailing_characters_str), arg);\nearly_ret:\n\t    vim_free(extends);\n\t    ga_clear_strings(&ga_impl);\n\t    return;\n\t}\n    }\n\n    garray_T\ttype_list;\t    // list of pointers to allocated types\n    ga_init2(&type_list, sizeof(type_T *), 10);\n\n    // Growarray with class members declared in the class.\n    garray_T classmembers;\n    ga_init2(&classmembers, sizeof(ocmember_T), 10);\n\n    // Growarray with functions declared in the class.\n    garray_T classfunctions;\n    ga_init2(&classfunctions, sizeof(ufunc_T *), 10);\n\n    // Growarray with object members declared in the class.\n    garray_T objmembers;\n    ga_init2(&objmembers, sizeof(ocmember_T), 10);\n\n    // Growarray with object methods declared in the class.\n    garray_T objmethods;\n    ga_init2(&objmethods, sizeof(ufunc_T *), 10);\n\n    /*\n     * Go over the body of the class/interface until \"endclass\" or\n     * \"endinterface\" is found.\n     */\n    char_u *theline = NULL;\n    int success = FALSE;\n    for (;;)\n    {\n\tvim_free(theline);\n\ttheline = eap->getline(':', eap->cookie, 0, GETLINE_CONCAT_ALL);\n\tif (theline == NULL)\n\t    break;\n\tchar_u *line = skipwhite(theline);\n\n\t// Skip empty and comment lines.\n\tif (*line == NUL)\n\t    continue;\n\tif (*line == '#')\n\t{\n\t    if (vim9_bad_comment(line))\n\t\tbreak;\n\t    continue;\n\t}\n\n\tchar_u *p = line;\n\tchar *end_name = is_class ? \"endclass\" : \"endinterface\";\n\tif (checkforcmd(&p, end_name, is_class ? 4 : 5))\n\t{\n\t    if (STRNCMP(line, end_name, is_class ? 8 : 12) != 0)\n\t\tsemsg(_(e_command_cannot_be_shortened_str), line);\n\t    else if (*p == '|' || !ends_excmd2(line, p))\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsuccess = TRUE;\n\t    break;\n\t}\n\tchar *wrong_name = is_class ? \"endinterface\" : \"endclass\";\n\tif (checkforcmd(&p, wrong_name, is_class ? 5 : 4))\n\t{\n\t    semsg(_(e_invalid_command_str_expected_str), line, end_name);\n\t    break;\n\t}\n\n\tint has_public = FALSE;\n\tif (checkforcmd(&p, \"public\", 3))\n\t{\n\t    if (STRNCMP(line, \"public\", 6) != 0)\n\t    {\n\t\tsemsg(_(e_command_cannot_be_shortened_str), line);\n\t\tbreak;\n\t    }\n\t    has_public = TRUE;\n\t    p = skipwhite(line + 6);\n\n\t    if (STRNCMP(p, \"this\", 4) != 0 && STRNCMP(p, \"static\", 6) != 0)\n\t    {\n\t\temsg(_(e_public_must_be_followed_by_this_or_static));\n\t\tbreak;\n\t    }\n\t}\n\n\tint has_static = FALSE;\n\tchar_u *ps = p;\n\tif (checkforcmd(&p, \"static\", 4))\n\t{\n\t    if (STRNCMP(ps, \"static\", 6) != 0)\n\t    {\n\t\tsemsg(_(e_command_cannot_be_shortened_str), ps);\n\t\tbreak;\n\t    }\n\t    has_static = TRUE;\n\t    p = skipwhite(ps + 6);\n\t}\n\n\t// object members (public, read access, private):\n\t//\t\"this._varname\"\n\t//\t\"this.varname\"\n\t//\t\"public this.varname\"\n\tif (STRNCMP(p, \"this\", 4) == 0)\n\t{\n\t    if (p[4] != '.' || !eval_isnamec1(p[5]))\n\t    {\n\t\tsemsg(_(e_invalid_object_member_declaration_str), p);\n\t\tbreak;\n\t    }\n\t    char_u *varname = p + 5;\n\t    char_u *varname_end = NULL;\n\t    type_T *type = NULL;\n\t    char_u *init_expr = NULL;\n\t    if (parse_member(eap, line, varname, has_public,\n\t\t\t  &varname_end, &type_list, &type,\n\t\t\t  is_class ? &init_expr: NULL) == FAIL)\n\t\tbreak;\n\t    if (add_member(&objmembers, varname, varname_end,\n\t\t\t\t\t  has_public, type, init_expr) == FAIL)\n\t    {\n\t\tvim_free(init_expr);\n\t\tbreak;\n\t    }\n\t}\n\n\t// constructors:\n\t//\t  def new()\n\t//\t  enddef\n\t//\t  def newOther()\n\t//\t  enddef\n\t// object methods and class functions:\n\t//\t  def SomeMethod()\n\t//\t  enddef\n\t//\t  static def ClassFunction()\n\t//\t  enddef\n\t// TODO:\n\t//\t  def <Tval> someMethod()\n\t//\t  enddef\n\telse if (checkforcmd(&p, \"def\", 3))\n\t{\n\t    exarg_T\tea;\n\t    garray_T\tlines_to_free;\n\n\t    // TODO: error for \"public static def Func()\"?\n\n\t    CLEAR_FIELD(ea);\n\t    ea.cmd = line;\n\t    ea.arg = p;\n\t    ea.cmdidx = CMD_def;\n\t    ea.getline = eap->getline;\n\t    ea.cookie = eap->cookie;\n\n\t    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n\t    ufunc_T *uf = define_function(&ea, NULL, &lines_to_free,\n\t\t\t\t\t   is_class ? CF_CLASS : CF_INTERFACE);\n\t    ga_clear_strings(&lines_to_free);\n\n\t    if (uf != NULL)\n\t    {\n\t\tchar_u *name = uf->uf_name;\n\t\tint is_new = STRNCMP(name, \"new\", 3) == 0;\n\t\tif (is_new && is_abstract)\n\t\t{\n\t\t    emsg(_(e_cannot_define_new_function_in_abstract_class));\n\t\t    success = FALSE;\n\t\t    break;\n\t\t}\n\t\tgarray_T *fgap = has_static || is_new\n\t\t\t\t\t       ? &classfunctions : &objmethods;\n\t\t// Check the name isn't used already.\n\t\tfor (int i = 0; i < fgap->ga_len; ++i)\n\t\t{\n\t\t    char_u *n = ((ufunc_T **)fgap->ga_data)[i]->uf_name;\n\t\t    if (STRCMP(name, n) == 0)\n\t\t    {\n\t\t\tsemsg(_(e_duplicate_function_str), name);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tif (ga_grow(fgap, 1) == OK)\n\t\t{\n\t\t    if (is_new)\n\t\t\tuf->uf_flags |= FC_NEW;\n\n\t\t    ((ufunc_T **)fgap->ga_data)[fgap->ga_len] = uf;\n\t\t    ++fgap->ga_len;\n\t\t}\n\t    }\n\t}\n\n\t// class members\n\telse if (has_static)\n\t{\n\t    // class members (public, read access, private):\n\t    //\t\"static _varname\"\n\t    //\t\"static varname\"\n\t    //\t\"public static varname\"\n\t    char_u *varname = p;\n\t    char_u *varname_end = NULL;\n\t    type_T *type = NULL;\n\t    char_u *init_expr = NULL;\n\t    if (parse_member(eap, line, varname, has_public,\n\t\t      &varname_end, &type_list, &type,\n\t\t      is_class ? &init_expr : NULL) == FAIL)\n\t\tbreak;\n\t    if (add_member(&classmembers, varname, varname_end,\n\t\t\t\t      has_public, type, init_expr) == FAIL)\n\t    {\n\t\tvim_free(init_expr);\n\t\tbreak;\n\t    }\n\t}\n\n\telse\n\t{\n\t    if (is_class)\n\t\tsemsg(_(e_not_valid_command_in_class_str), line);\n\t    else\n\t\tsemsg(_(e_not_valid_command_in_interface_str), line);\n\t    break;\n\t}\n    }\n    vim_free(theline);\n\n    class_T *extends_cl = NULL;  // class from \"extends\" argument\n\n    /*\n     * Check a few things before defining the class.\n     */\n\n    // Check the \"extends\" class is valid.\n    if (success && extends != NULL)\n    {\n\ttypval_T tv;\n\ttv.v_type = VAR_UNKNOWN;\n\tif (eval_variable_import(extends, &tv) == FAIL)\n\t{\n\t    semsg(_(e_class_name_not_found_str), extends);\n\t    success = FALSE;\n\t}\n\telse\n\t{\n\t    if (tv.v_type != VAR_CLASS\n\t\t    || tv.vval.v_class == NULL\n\t\t    || (tv.vval.v_class->class_flags & CLASS_INTERFACE) != 0)\n\t    {\n\t\tsemsg(_(e_cannot_extend_str), extends);\n\t\tsuccess = FALSE;\n\t    }\n\t    else\n\t    {\n\t\textends_cl = tv.vval.v_class;\n\t\t++extends_cl->class_refcount;\n\t    }\n\t    clear_tv(&tv);\n\t}\n    }\n    VIM_CLEAR(extends);\n\n    class_T **intf_classes = NULL;\n\n    // Check all \"implements\" entries are valid.\n    if (success && ga_impl.ga_len > 0)\n    {\n\tintf_classes = ALLOC_CLEAR_MULT(class_T *, ga_impl.ga_len);\n\n\tfor (int i = 0; i < ga_impl.ga_len && success; ++i)\n\t{\n\t    char_u *impl = ((char_u **)ga_impl.ga_data)[i];\n\t    typval_T tv;\n\t    tv.v_type = VAR_UNKNOWN;\n\t    if (eval_variable_import(impl, &tv) == FAIL)\n\t    {\n\t\tsemsg(_(e_interface_name_not_found_str), impl);\n\t\tsuccess = FALSE;\n\t\tbreak;\n\t    }\n\n\t    if (tv.v_type != VAR_CLASS\n\t\t    || tv.vval.v_class == NULL\n\t\t    || (tv.vval.v_class->class_flags & CLASS_INTERFACE) == 0)\n\t    {\n\t\tsemsg(_(e_not_valid_interface_str), impl);\n\t\tsuccess = FALSE;\n\t    }\n\n\t    class_T *ifcl = tv.vval.v_class;\n\t    intf_classes[i] = ifcl;\n\t    ++ifcl->class_refcount;\n\n\t    // check the members of the interface match the members of the class\n\t    for (int loop = 1; loop <= 2 && success; ++loop)\n\t    {\n\t\t// loop == 1: check class members\n\t\t// loop == 2: check object members\n\t\tint if_count = loop == 1 ? ifcl->class_class_member_count\n\t\t\t\t\t : ifcl->class_obj_member_count;\n\t\tif (if_count == 0)\n\t\t    continue;\n\t\tocmember_T *if_ms = loop == 1 ? ifcl->class_class_members\n\t\t\t\t\t       : ifcl->class_obj_members;\n\t\tocmember_T *cl_ms = (ocmember_T *)(loop == 1\n\t\t\t\t\t\t    ? classmembers.ga_data\n\t\t\t\t\t\t    : objmembers.ga_data);\n\t\tint cl_count = loop == 1 ? classmembers.ga_len\n\t\t\t\t\t\t\t   : objmembers.ga_len;\n\t\tfor (int if_i = 0; if_i < if_count; ++if_i)\n\t\t{\n\t\t    int cl_i;\n\t\t    for (cl_i = 0; cl_i < cl_count; ++cl_i)\n\t\t    {\n\t\t\tocmember_T *m = &cl_ms[cl_i];\n\t\t\tif (STRCMP(if_ms[if_i].ocm_name, m->ocm_name) == 0)\n\t\t\t{\n\t\t\t    // TODO: check type\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (cl_i == cl_count)\n\t\t    {\n\t\t\tsemsg(_(e_member_str_of_interface_str_not_implemented),\n\t\t\t\t\t\t   if_ms[if_i].ocm_name, impl);\n\t\t\tsuccess = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    // check the functions/methods of the interface match the\n\t    // functions/methods of the class\n\t    for (int loop = 1; loop <= 2 && success; ++loop)\n\t    {\n\t\t// loop == 1: check class functions\n\t\t// loop == 2: check object methods\n\t\tint if_count = loop == 1 ? ifcl->class_class_function_count\n\t\t\t\t\t : ifcl->class_obj_method_count;\n\t\tif (if_count == 0)\n\t\t    continue;\n\t\tufunc_T **if_fp = loop == 1 ? ifcl->class_class_functions\n\t\t\t\t\t    : ifcl->class_obj_methods;\n\t\tufunc_T **cl_fp = (ufunc_T **)(loop == 1\n\t\t\t\t\t\t? classfunctions.ga_data\n\t\t\t\t\t\t: objmethods.ga_data);\n\t\tint cl_count = loop == 1 ? classfunctions.ga_len\n\t\t\t\t\t\t\t   : objmethods.ga_len;\n\t\tfor (int if_i = 0; if_i < if_count; ++if_i)\n\t\t{\n\t\t    char_u *if_name = if_fp[if_i]->uf_name;\n\t\t    int cl_i;\n\t\t    for (cl_i = 0; cl_i < cl_count; ++cl_i)\n\t\t    {\n\t\t\tchar_u *cl_name = cl_fp[cl_i]->uf_name;\n\t\t\tif (STRCMP(if_name, cl_name) == 0)\n\t\t\t{\n\t\t\t    // TODO: check return and argument types\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (cl_i == cl_count)\n\t\t    {\n\t\t\tsemsg(_(e_function_str_of_interface_str_not_implemented),\n\t\t\t\t\t\t\t\tif_name, impl);\n\t\t\tsuccess = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    clear_tv(&tv);\n\t}\n    }\n\n    if (success)\n    {\n\t// Check no function argument name is used as an object/class member.\n\tfor (int loop = 1; loop <= 2 && success; ++loop)\n\t{\n\t    garray_T *gap = loop == 1 ? &classfunctions : &objmethods;\n\n\t    for (int fi = 0; fi < gap->ga_len && success; ++fi)\n\t    {\n\t\tufunc_T *uf = ((ufunc_T **)gap->ga_data)[fi];\n\n\t\tfor (int i = 0; i < uf->uf_args.ga_len && success; ++i)\n\t\t{\n\t\t    char_u *aname = ((char_u **)uf->uf_args.ga_data)[i];\n\t\t    for (int il = 1; il <= 2 && success; ++il)\n\t\t    {\n\t\t\t// For a \"new()\" function \"this.member\" arguments are\n\t\t\t// OK.  TODO: check for the \"this.\" prefix.\n\t\t\tif (STRNCMP(uf->uf_name, \"new\", 3) == 0 && il == 2)\n\t\t\t    continue;\n\t\t\tgarray_T *mgap = il == 1 ? &classmembers : &objmembers;\n\t\t\tfor (int mi = 0; mi < mgap->ga_len; ++mi)\n\t\t\t{\n\t\t\t    char_u *mname = ((ocmember_T *)mgap->ga_data\n\t\t\t\t\t\t\t       + mi)->ocm_name;\n\t\t\t    if (STRCMP(aname, mname) == 0)\n\t\t\t    {\n\t\t\t\tsuccess = FALSE;\n\t\t\t\tsemsg(_(e_argument_already_declared_in_class_str),\n\t\t\t\t\t\t\t\t\taname);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n\n    class_T *cl = NULL;\n    if (success)\n    {\n\t// \"endclass\" encountered without failures: Create the class.\n\n\tcl = ALLOC_CLEAR_ONE(class_T);\n\tif (cl == NULL)\n\t    goto cleanup;\n\tif (!is_class)\n\t    cl->class_flags = CLASS_INTERFACE;\n\n\tcl->class_refcount = 1;\n\tcl->class_name = vim_strnsave(name_start, name_end - name_start);\n\tif (cl->class_name == NULL)\n\t    goto cleanup;\n\n\tif (extends_cl != NULL)\n\t{\n\t    cl->class_extends = extends_cl;\n\t    extends_cl->class_flags |= CLASS_EXTENDED;\n\t}\n\n\t// Add class and object members to \"cl\".\n\tif (add_members_to_class(&classmembers,\n\t\t\t\t extends_cl == NULL ? NULL\n\t\t\t\t\t     : extends_cl->class_class_members,\n\t\t\t\t extends_cl == NULL ? 0\n\t\t\t\t\t: extends_cl->class_class_member_count,\n\t\t\t\t &cl->class_class_members,\n\t\t\t\t &cl->class_class_member_count) == FAIL\n\t\t|| add_members_to_class(&objmembers,\n\t\t\t\t extends_cl == NULL ? NULL\n\t\t\t\t\t       : extends_cl->class_obj_members,\n\t\t\t\t extends_cl == NULL ? 0\n\t\t\t\t\t  : extends_cl->class_obj_member_count,\n\t\t\t\t &cl->class_obj_members,\n\t\t\t\t &cl->class_obj_member_count) == FAIL)\n\t    goto cleanup;\n\n\tif (ga_impl.ga_len > 0)\n\t{\n\t    // Move the \"implements\" names into the class.\n\t    cl->class_interface_count = ga_impl.ga_len;\n\t    cl->class_interfaces = ALLOC_MULT(char_u *, ga_impl.ga_len);\n\t    if (cl->class_interfaces == NULL)\n\t\tgoto cleanup;\n\t    for (int i = 0; i < ga_impl.ga_len; ++i)\n\t\tcl->class_interfaces[i] = ((char_u **)ga_impl.ga_data)[i];\n\t    VIM_CLEAR(ga_impl.ga_data);\n\t    ga_impl.ga_len = 0;\n\n\t    cl->class_interfaces_cl = intf_classes;\n\t    intf_classes = NULL;\n\t}\n\n\tif (cl->class_interface_count > 0 || extends_cl != NULL)\n\t{\n\t    // For each interface add a lookuptable for the member index on the\n\t    // interface to the member index in this class.\n\t    // And a lookuptable for the object method index on the interface\n\t    // to the object method index in this class.\n\t    // Also do this for the extended class, if any.\n\t    for (int i = 0; i <= cl->class_interface_count; ++i)\n\t    {\n\t\tclass_T *ifcl = i < cl->class_interface_count\n\t\t\t\t\t    ? cl->class_interfaces_cl[i]\n\t\t\t\t\t    : extends_cl;\n\t\tif (ifcl == NULL)\n\t\t    continue;\n\n\t\t// Table for members.\n\t\titf2class_T *if2cl = alloc_clear(sizeof(itf2class_T)\n\t\t\t\t + ifcl->class_obj_member_count * sizeof(int));\n\t\tif (if2cl == NULL)\n\t\t    goto cleanup;\n\t\tif2cl->i2c_next = ifcl->class_itf2class;\n\t\tifcl->class_itf2class = if2cl;\n\t\tif2cl->i2c_class = cl;\n\t\tif2cl->i2c_is_method = FALSE;\n\n\t\tfor (int if_i = 0; if_i < ifcl->class_obj_member_count; ++if_i)\n\t\t    for (int cl_i = 0; cl_i < cl->class_obj_member_count;\n\t\t\t\t\t\t\t\t\t++cl_i)\n\t\t    {\n\t\t\tif (STRCMP(ifcl->class_obj_members[if_i].ocm_name,\n\t\t\t\t    cl->class_obj_members[cl_i].ocm_name) == 0)\n\t\t\t{\n\t\t\t    int *table = (int *)(if2cl + 1);\n\t\t\t    table[if_i] = cl_i;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\n\t\t// Table for methods.\n\t\tif2cl = alloc_clear(sizeof(itf2class_T)\n\t\t\t\t + ifcl->class_obj_method_count * sizeof(int));\n\t\tif (if2cl == NULL)\n\t\t    goto cleanup;\n\t\tif2cl->i2c_next = ifcl->class_itf2class;\n\t\tifcl->class_itf2class = if2cl;\n\t\tif2cl->i2c_class = cl;\n\t\tif2cl->i2c_is_method = TRUE;\n\n\t\tfor (int if_i = 0; if_i < ifcl->class_obj_method_count; ++if_i)\n\t\t{\n\t\t    int done = FALSE;\n\t\t    for (int cl_i = 0; cl_i < objmethods.ga_len; ++cl_i)\n\t\t    {\n\t\t\tif (STRCMP(ifcl->class_obj_methods[if_i]->uf_name,\n\t\t\t       ((ufunc_T **)objmethods.ga_data)[cl_i]->uf_name)\n\t\t\t\t\t\t\t\t\t  == 0)\n\t\t\t{\n\t\t\t    int *table = (int *)(if2cl + 1);\n\t\t\t    table[if_i] = cl_i;\n\t\t\t    done = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\n\t\t    if (!done && extends_cl != NULL)\n\t\t    {\n\t\t\tfor (int cl_i = 0;\n\t\t\t     cl_i < extends_cl->class_obj_member_count; ++cl_i)\n\t\t\t{\n\t\t\t    if (STRCMP(ifcl->class_obj_methods[if_i]->uf_name,\n\t\t\t\t   extends_cl->class_obj_methods[cl_i]->uf_name)\n\t\t\t\t\t\t\t\t\t  == 0)\n\t\t\t    {\n\t\t\t\tint *table = (int *)(if2cl + 1);\n\t\t\t\ttable[if_i] = cl_i;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (is_class && cl->class_class_member_count > 0)\n\t{\n\t    // Allocate a typval for each class member and initialize it.\n\t    cl->class_members_tv = ALLOC_CLEAR_MULT(typval_T,\n\t\t\t\t\t\t cl->class_class_member_count);\n\t    if (cl->class_members_tv != NULL)\n\t\tfor (int i = 0; i < cl->class_class_member_count; ++i)\n\t\t{\n\t\t    ocmember_T *m = &cl->class_class_members[i];\n\t\t    typval_T *tv = &cl->class_members_tv[i];\n\t\t    if (m->ocm_init != NULL)\n\t\t    {\n\t\t\ttypval_T *etv = eval_expr(m->ocm_init, eap);\n\t\t\tif (etv != NULL)\n\t\t\t{\n\t\t\t    *tv = *etv;\n\t\t\t    vim_free(etv);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// TODO: proper default value\n\t\t\ttv->v_type = m->ocm_type->tt_type;\n\t\t\ttv->vval.v_string = NULL;\n\t\t    }\n\t\t}\n\t}\n\n\tint have_new = FALSE;\n\tfor (int i = 0; i < classfunctions.ga_len; ++i)\n\t    if (STRCMP(((ufunc_T **)classfunctions.ga_data)[i]->uf_name,\n\t\t\t\t\t\t\t\t   \"new\") == 0)\n\t    {\n\t\thave_new = TRUE;\n\t\tbreak;\n\t    }\n\tif (is_class && !is_abstract && !have_new)\n\t{\n\t    // No new() method was defined, add the default constructor.\n\t    garray_T fga;\n\t    ga_init2(&fga, 1, 1000);\n\t    ga_concat(&fga, (char_u *)\"new(\");\n\t    for (int i = 0; i < cl->class_obj_member_count; ++i)\n\t    {\n\t\tif (i > 0)\n\t\t    ga_concat(&fga, (char_u *)\", \");\n\t\tga_concat(&fga, (char_u *)\"this.\");\n\t\tocmember_T *m = cl->class_obj_members + i;\n\t\tga_concat(&fga, (char_u *)m->ocm_name);\n\t\tga_concat(&fga, (char_u *)\" = v:none\");\n\t    }\n\t    ga_concat(&fga, (char_u *)\")\\nenddef\\n\");\n\t    ga_append(&fga, NUL);\n\n\t    exarg_T fea;\n\t    CLEAR_FIELD(fea);\n\t    fea.cmdidx = CMD_def;\n\t    fea.cmd = fea.arg = fga.ga_data;\n\n\t    garray_T lines_to_free;\n\t    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n\n\t    ufunc_T *nf = define_function(&fea, NULL, &lines_to_free, CF_CLASS);\n\n\t    ga_clear_strings(&lines_to_free);\n\t    vim_free(fga.ga_data);\n\n\t    if (nf != NULL && ga_grow(&classfunctions, 1) == OK)\n\t    {\n\t\t((ufunc_T **)classfunctions.ga_data)[classfunctions.ga_len]\n\t\t\t\t\t\t\t\t\t  = nf;\n\t\t++classfunctions.ga_len;\n\n\t\tnf->uf_flags |= FC_NEW;\n\t\tnf->uf_ret_type = get_type_ptr(&type_list);\n\t\tif (nf->uf_ret_type != NULL)\n\t\t{\n\t\t    nf->uf_ret_type->tt_type = VAR_OBJECT;\n\t\t    nf->uf_ret_type->tt_class = cl;\n\t\t    nf->uf_ret_type->tt_argcount = 0;\n\t\t    nf->uf_ret_type->tt_args = NULL;\n\t\t}\n\t    }\n\t}\n\n\t// Move all the functions into the created class.\n\t// loop 1: class functions, loop 2: object methods\n\tfor (int loop = 1; loop <= 2; ++loop)\n\t{\n\t    garray_T *gap = loop == 1 ? &classfunctions : &objmethods;\n\t    int\t     *fcount = loop == 1 ? &cl->class_class_function_count\n\t\t\t\t\t : &cl->class_obj_method_count;\n\t    ufunc_T ***fup = loop == 1 ? &cl->class_class_functions\n\t\t\t\t       : &cl->class_obj_methods;\n\n\t    int parent_count = 0;\n\t    if (extends_cl != NULL)\n\t\t// Include functions from the parent.\n\t\tparent_count = loop == 1\n\t\t\t\t    ? extends_cl->class_class_function_count\n\t\t\t\t    : extends_cl->class_obj_method_count;\n\n\t    *fcount = parent_count + gap->ga_len;\n\t    if (*fcount == 0)\n\t    {\n\t\t*fup = NULL;\n\t\tcontinue;\n\t    }\n\t    *fup = ALLOC_MULT(ufunc_T *, *fcount);\n\t    if (*fup == NULL)\n\t\tgoto cleanup;\n\n\t    mch_memmove(*fup, gap->ga_data, sizeof(ufunc_T *) * gap->ga_len);\n\t    vim_free(gap->ga_data);\n\t    if (loop == 1)\n\t\tcl->class_class_function_count_child = gap->ga_len;\n\t    else\n\t\tcl->class_obj_method_count_child = gap->ga_len;\n\n\t    int skipped = 0;\n\t    for (int i = 0; i < parent_count; ++i)\n\t    {\n\t\t// Copy functions from the parent.  Can't use the same\n\t\t// function, because \"uf_class\" is different and compilation\n\t\t// will have a different result.\n\t\t// Put them after the functions in the current class, object\n\t\t// methods may be overruled, then \"super.Method()\" is used to\n\t\t// find a method from the parent.\n\t\t// Skip \"new\" functions. TODO: not all of them.\n\t\tif (loop == 1 && STRNCMP(\n\t\t\t    extends_cl->class_class_functions[i]->uf_name,\n\t\t\t\t\t\t\t\t\"new\", 3) == 0)\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    ufunc_T *pf = (loop == 1\n\t\t\t\t\t? extends_cl->class_class_functions\n\t\t\t\t\t: extends_cl->class_obj_methods)[i];\n\t\t    (*fup)[gap->ga_len + i - skipped] = copy_function(pf);\n\n\t\t    // If the child class overrides a function from the parent\n\t\t    // the signature must be equal.\n\t\t    char_u *pname = pf->uf_name;\n\t\t    for (int ci = 0; ci < gap->ga_len; ++ci)\n\t\t    {\n\t\t\tufunc_T *cf = (*fup)[ci];\n\t\t\tchar_u *cname = cf->uf_name;\n\t\t\tif (STRCMP(pname, cname) == 0)\n\t\t\t{\n\t\t\t    where_T where = WHERE_INIT;\n\t\t\t    where.wt_func_name = (char *)pname;\n\t\t\t    (void)check_type(pf->uf_func_type, cf->uf_func_type,\n\t\t\t\t\t\t\t\t  TRUE, where);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    *fcount -= skipped;\n\n\t    // Set the class pointer on all the functions and object methods.\n\t    for (int i = 0; i < *fcount; ++i)\n\t    {\n\t\tufunc_T *fp = (*fup)[i];\n\t\tfp->uf_class = cl;\n\t\tif (loop == 2)\n\t\t    fp->uf_flags |= FC_OBJECT;\n\t    }\n\t}\n\n\tcl->class_type.tt_type = VAR_CLASS;\n\tcl->class_type.tt_class = cl;\n\tcl->class_object_type.tt_type = VAR_OBJECT;\n\tcl->class_object_type.tt_class = cl;\n\tcl->class_type_list = type_list;\n\n\t// TODO:\n\t// - Fill hashtab with object members and methods ?\n\n\t// Add the class to the script-local variables.\n\t// TODO: handle other context, e.g. in a function\n\ttypval_T tv;\n\ttv.v_type = VAR_CLASS;\n\ttv.vval.v_class = cl;\n\tis_export = class_export;\n\tSOURCING_LNUM = start_lnum;\n\tset_var_const(cl->class_name, current_sctx.sc_sid,\n\t\t\t\t\t\t       NULL, &tv, FALSE, 0, 0);\n\treturn;\n    }\n\ncleanup:\n    if (cl != NULL)\n    {\n\tvim_free(cl->class_name);\n\tvim_free(cl->class_class_functions);\n\tif (cl->class_interfaces != NULL)\n\t{\n\t    for (int i = 0; i < cl->class_interface_count; ++i)\n\t\tvim_free(cl->class_interfaces[i]);\n\t    vim_free(cl->class_interfaces);\n\t}\n\tif (cl->class_interfaces_cl != NULL)\n\t{\n\t    for (int i = 0; i < cl->class_interface_count; ++i)\n\t\tclass_unref(cl->class_interfaces_cl[i]);\n\t    vim_free(cl->class_interfaces_cl);\n\t}\n\tvim_free(cl->class_obj_members);\n\tvim_free(cl->class_obj_methods);\n\tvim_free(cl);\n    }\n\n    vim_free(extends);\n    class_unref(extends_cl);\n\n    if (intf_classes != NULL)\n    {\n\tfor (int i = 0; i < ga_impl.ga_len; ++i)\n\t    class_unref(intf_classes[i]);\n\tvim_free(intf_classes);\n    }\n    ga_clear_strings(&ga_impl);\n\n    for (int round = 1; round <= 2; ++round)\n    {\n\tgarray_T *gap = round == 1 ? &classmembers : &objmembers;\n\tif (gap->ga_len == 0 || gap->ga_data == NULL)\n\t    continue;\n\n\tfor (int i = 0; i < gap->ga_len; ++i)\n\t{\n\t    ocmember_T *m = ((ocmember_T *)gap->ga_data) + i;\n\t    vim_free(m->ocm_name);\n\t    vim_free(m->ocm_init);\n\t}\n\tga_clear(gap);\n    }\n\n    for (int i = 0; i < objmethods.ga_len; ++i)\n    {\n\tufunc_T *uf = ((ufunc_T **)objmethods.ga_data)[i];\n\tfunc_clear_free(uf, FALSE);\n    }\n    ga_clear(&objmethods);\n\n    for (int i = 0; i < classfunctions.ga_len; ++i)\n    {\n\tufunc_T *uf = ((ufunc_T **)classfunctions.ga_data)[i];\n\tfunc_clear_free(uf, FALSE);\n    }\n    ga_clear(&classfunctions);\n\n    clear_type_list(&type_list);\n}\n\n/*\n * Find member \"name\" in class \"cl\", set \"member_idx\" to the member index and\n * return its type.\n * When not found \"member_idx\" is set to -1 and t_any is returned.\n */\n    type_T *\nclass_member_type(\n\tclass_T *cl,\n\tchar_u\t*name,\n\tchar_u\t*name_end,\n\tint\t*member_idx)\n{\n    *member_idx = -1;  // not found (yet)\n    size_t len = name_end - name;\n\n    for (int i = 0; i < cl->class_obj_member_count; ++i)\n    {\n\tocmember_T *m = cl->class_obj_members + i;\n\tif (STRNCMP(m->ocm_name, name, len) == 0 && m->ocm_name[len] == NUL)\n\t{\n\t    *member_idx = i;\n\t    return m->ocm_type;\n\t}\n    }\n\n    semsg(_(e_unknown_variable_str), name);\n    return &t_any;\n}\n\n/*\n * Handle \":enum\" up to \":endenum\".\n */\n    void\nex_enum(exarg_T *eap UNUSED)\n{\n    // TODO\n}\n\n/*\n * Handle \":type\".\n */\n    void\nex_type(exarg_T *eap UNUSED)\n{\n    // TODO\n}\n\n/*\n * Evaluate what comes after a class:\n * - class member: SomeClass.varname\n * - class function: SomeClass.SomeMethod()\n * - class constructor: SomeClass.new()\n * - object member: someObject.varname\n * - object method: someObject.SomeMethod()\n *\n * \"*arg\" points to the '.'.\n * \"*arg\" is advanced to after the member name or method call.\n *\n * Returns FAIL or OK.\n */\n    int\nclass_object_index(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose UNUSED)\t// give error messages\n{\n    if (VIM_ISWHITE((*arg)[1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_after_str_str), \".\", *arg);\n\treturn FAIL;\n    }\n\n    ++*arg;\n    char_u *name = *arg;\n    char_u *name_end = find_name_end(name, NULL, NULL, FNE_CHECK_START);\n    if (name_end == name)\n\treturn FAIL;\n    size_t len = name_end - name;\n\n    class_T *cl;\n    if (rettv->v_type == VAR_CLASS)\n\tcl = rettv->vval.v_class;\n    else // VAR_OBJECT\n    {\n\tif (rettv->vval.v_object == NULL)\n\t{\n\t    emsg(_(e_using_null_object));\n\t    return FAIL;\n\t}\n\tcl = rettv->vval.v_object->obj_class;\n    }\n\n    if (*name_end == '(')\n    {\n\tint on_class = rettv->v_type == VAR_CLASS;\n\tint count = on_class ? cl->class_class_function_count\n\t\t\t     : cl->class_obj_method_count;\n\tfor (int i = 0; i < count; ++i)\n\t{\n\t    ufunc_T *fp = on_class ? cl->class_class_functions[i]\n\t\t\t\t   : cl->class_obj_methods[i];\n\t    // Use a separate pointer to avoid that ASAN complains about\n\t    // uf_name[] only being 4 characters.\n\t    char_u *ufname = (char_u *)fp->uf_name;\n\t    if (STRNCMP(name, ufname, len) == 0 && ufname[len] == NUL)\n\t    {\n\t\ttypval_T    argvars[MAX_FUNC_ARGS + 1];\n\t\tint\t    argcount = 0;\n\n\t\tchar_u *argp = name_end;\n\t\tint ret = get_func_arguments(&argp, evalarg, 0,\n\t\t\t\t\t\t\t   argvars, &argcount);\n\t\tif (ret == FAIL)\n\t\t    return FAIL;\n\n\t\tfuncexe_T   funcexe;\n\t\tCLEAR_FIELD(funcexe);\n\t\tfuncexe.fe_evaluate = TRUE;\n\t\tif (rettv->v_type == VAR_OBJECT)\n\t\t{\n\t\t    funcexe.fe_object = rettv->vval.v_object;\n\t\t    ++funcexe.fe_object->obj_refcount;\n\t\t}\n\n\t\t// Clear the class or object after calling the function, in\n\t\t// case the refcount is one.\n\t\ttypval_T tv_tofree = *rettv;\n\t\trettv->v_type = VAR_UNKNOWN;\n\n\t\t// Call the user function.  Result goes into rettv;\n\t\tint error = call_user_func_check(fp, argcount, argvars,\n\t\t\t\t\t\t\trettv, &funcexe, NULL);\n\n\t\t// Clear the previous rettv and the arguments.\n\t\tclear_tv(&tv_tofree);\n\t\tfor (int idx = 0; idx < argcount; ++idx)\n\t\t    clear_tv(&argvars[idx]);\n\n\t\tif (error != FCERR_NONE)\n\t\t{\n\t\t    user_func_error(error, printable_func_name(fp),\n\t\t\t\t\t\t\t funcexe.fe_found_var);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = argp;\n\t\treturn OK;\n\t    }\n\t}\n\n\tsemsg(_(e_method_not_found_on_class_str_str), cl->class_name, name);\n    }\n\n    else if (rettv->v_type == VAR_OBJECT)\n    {\n\tfor (int i = 0; i < cl->class_obj_member_count; ++i)\n\t{\n\t    ocmember_T *m = &cl->class_obj_members[i];\n\t    if (STRNCMP(name, m->ocm_name, len) == 0 && m->ocm_name[len] == NUL)\n\t    {\n\t\tif (*name == '_')\n\t\t{\n\t\t    semsg(_(e_cannot_access_private_member_str), m->ocm_name);\n\t\t    return FAIL;\n\t\t}\n\n\t\t// The object only contains a pointer to the class, the member\n\t\t// values array follows right after that.\n\t\tobject_T *obj = rettv->vval.v_object;\n\t\ttypval_T *tv = (typval_T *)(obj + 1) + i;\n\t\tcopy_tv(tv, rettv);\n\t\tobject_unref(obj);\n\n\t\t*arg = name_end;\n\t\treturn OK;\n\t    }\n\t}\n\n\tsemsg(_(e_member_not_found_on_object_str_str), cl->class_name, name);\n    }\n\n    else if (rettv->v_type == VAR_CLASS)\n    {\n\t// class member\n\tfor (int i = 0; i < cl->class_class_member_count; ++i)\n\t{\n\t    ocmember_T *m = &cl->class_class_members[i];\n\t    if (STRNCMP(name, m->ocm_name, len) == 0 && m->ocm_name[len] == NUL)\n\t    {\n\t\tif (*name == '_')\n\t\t{\n\t\t    semsg(_(e_cannot_access_private_member_str), m->ocm_name);\n\t\t    return FAIL;\n\t\t}\n\n\t\ttypval_T *tv = &cl->class_members_tv[i];\n\t\tcopy_tv(tv, rettv);\n\t\tclass_unref(cl);\n\n\t\t*arg = name_end;\n\t\treturn OK;\n\t    }\n\t}\n\n\tsemsg(_(e_member_not_found_on_class_str_str), cl->class_name, name);\n    }\n\n    return FAIL;\n}\n\n/*\n * If \"arg\" points to a class or object method, return it.\n * Otherwise return NULL.\n */\n    ufunc_T *\nfind_class_func(char_u **arg)\n{\n    char_u *name = *arg;\n    char_u *name_end = find_name_end(name, NULL, NULL, FNE_CHECK_START);\n    if (name_end == name || *name_end != '.')\n\treturn NULL;\n\n    size_t len = name_end - name;\n    typval_T tv;\n    tv.v_type = VAR_UNKNOWN;\n    if (eval_variable(name, (int)len,\n\t\t\t\t    0, &tv, NULL, EVAL_VAR_NOAUTOLOAD) == FAIL)\n\treturn NULL;\n    if (tv.v_type != VAR_CLASS && tv.v_type != VAR_OBJECT)\n\tgoto fail_after_eval;\n\n    class_T *cl = tv.v_type == VAR_CLASS ? tv.vval.v_class\n\t\t\t\t\t\t : tv.vval.v_object->obj_class;\n    if (cl == NULL)\n\tgoto fail_after_eval;\n    char_u *fname = name_end + 1;\n    char_u *fname_end = find_name_end(fname, NULL, NULL, FNE_CHECK_START);\n    if (fname_end == fname)\n\tgoto fail_after_eval;\n    len = fname_end - fname;\n\n    int count = tv.v_type == VAR_CLASS ? cl->class_class_function_count\n\t\t\t\t       : cl->class_obj_method_count;\n    ufunc_T **funcs = tv.v_type == VAR_CLASS ? cl->class_class_functions\n\t\t\t\t\t     : cl->class_obj_methods;\n    for (int i = 0; i < count; ++i)\n    {\n\tufunc_T *fp = funcs[i];\n\t// Use a separate pointer to avoid that ASAN complains about\n\t// uf_name[] only being 4 characters.\n\tchar_u *ufname = (char_u *)fp->uf_name;\n\tif (STRNCMP(fname, ufname, len) == 0 && ufname[len] == NUL)\n\t{\n\t    clear_tv(&tv);\n\t    return fp;\n\t}\n    }\n\nfail_after_eval:\n    clear_tv(&tv);\n    return NULL;\n}\n\n/*\n * If \"name[len]\" is a class member in cctx->ctx_ufunc->uf_class return the\n * index in class.class_class_members[].\n * If \"cl_ret\" is not NULL set it to the class.\n * Otherwise return -1;\n */\n    int\nclass_member_index(char_u *name, size_t len, class_T **cl_ret, cctx_T *cctx)\n{\n    if (cctx == NULL || cctx->ctx_ufunc == NULL\n\t\t\t\t\t  || cctx->ctx_ufunc->uf_class == NULL)\n\treturn -1;\n    class_T *cl = cctx->ctx_ufunc->uf_class;\n\n    for (int i = 0; i < cl->class_class_member_count; ++i)\n    {\n\tocmember_T *m = &cl->class_class_members[i];\n\tif (STRNCMP(name, m->ocm_name, len) == 0 && m->ocm_name[len] == NUL)\n\t{\n\t    if (cl_ret != NULL)\n\t\t*cl_ret = cl;\n\t    return i;\n\t}\n    }\n    return -1;\n}\n\n/*\n * Return TRUE if current context \"cctx_arg\" is inside class \"cl\".\n * Return FALSE if not.\n */\n    int\ninside_class(cctx_T *cctx_arg, class_T *cl)\n{\n    for (cctx_T *cctx = cctx_arg; cctx != NULL; cctx = cctx->ctx_outer)\n\tif (cctx->ctx_ufunc != NULL && cctx->ctx_ufunc->uf_class == cl)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Make a copy of an object.\n */\n    void\ncopy_object(typval_T *from, typval_T *to)\n{\n    *to = *from;\n    if (to->vval.v_object != NULL)\n\t++to->vval.v_object->obj_refcount;\n}\n\n/*\n * Free an object.\n */\n    static void\nobject_clear(object_T *obj)\n{\n    class_T *cl = obj->obj_class;\n\n    // the member values are just after the object structure\n    typval_T *tv = (typval_T *)(obj + 1);\n    for (int i = 0; i < cl->class_obj_member_count; ++i)\n\tclear_tv(tv + i);\n\n    // Remove from the list headed by \"first_object\".\n    object_cleared(obj);\n\n    vim_free(obj);\n    class_unref(cl);\n}\n\n/*\n * Unreference an object.\n */\n    void\nobject_unref(object_T *obj)\n{\n    if (obj != NULL && --obj->obj_refcount <= 0)\n\tobject_clear(obj);\n}\n\n/*\n * Make a copy of a class.\n */\n    void\ncopy_class(typval_T *from, typval_T *to)\n{\n    *to = *from;\n    if (to->vval.v_class != NULL)\n\t++to->vval.v_class->class_refcount;\n}\n\n/*\n * Unreference a class.  Free it when the reference count goes down to zero.\n */\n    void\nclass_unref(class_T *cl)\n{\n    if (cl != NULL && --cl->class_refcount <= 0 && cl->class_name != NULL)\n    {\n\t// Freeing what the class contains may recursively come back here.\n\t// Clear \"class_name\" first, if it is NULL the class does not need to\n\t// be freed.\n\tVIM_CLEAR(cl->class_name);\n\n\tclass_unref(cl->class_extends);\n\n\tfor (int i = 0; i < cl->class_interface_count; ++i)\n\t{\n\t    vim_free(((char_u **)cl->class_interfaces)[i]);\n\t    if (cl->class_interfaces_cl[i] != NULL)\n\t\tclass_unref(cl->class_interfaces_cl[i]);\n\t}\n\tvim_free(cl->class_interfaces);\n\tvim_free(cl->class_interfaces_cl);\n\n\titf2class_T *next;\n\tfor (itf2class_T *i2c = cl->class_itf2class; i2c != NULL; i2c = next)\n\t{\n\t    next = i2c->i2c_next;\n\t    vim_free(i2c);\n\t}\n\n\tfor (int i = 0; i < cl->class_class_member_count; ++i)\n\t{\n\t    ocmember_T *m = &cl->class_class_members[i];\n\t    vim_free(m->ocm_name);\n\t    vim_free(m->ocm_init);\n\t    if (cl->class_members_tv != NULL)\n\t\tclear_tv(&cl->class_members_tv[i]);\n\t}\n\tvim_free(cl->class_class_members);\n\tvim_free(cl->class_members_tv);\n\n\tfor (int i = 0; i < cl->class_obj_member_count; ++i)\n\t{\n\t    ocmember_T *m = &cl->class_obj_members[i];\n\t    vim_free(m->ocm_name);\n\t    vim_free(m->ocm_init);\n\t}\n\tvim_free(cl->class_obj_members);\n\n\tfor (int i = 0; i < cl->class_class_function_count; ++i)\n\t{\n\t    ufunc_T *uf = cl->class_class_functions[i];\n\t    func_clear_free(uf, FALSE);\n\t}\n\tvim_free(cl->class_class_functions);\n\n\tfor (int i = 0; i < cl->class_obj_method_count; ++i)\n\t{\n\t    ufunc_T *uf = cl->class_obj_methods[i];\n\t    func_clear_free(uf, FALSE);\n\t}\n\tvim_free(cl->class_obj_methods);\n\n\tclear_type_list(&cl->class_type_list);\n\n\tvim_free(cl);\n    }\n}\n\nstatic object_T *first_object = NULL;\n\n/*\n * Call this function when an object has been created.  It will be added to the\n * list headed by \"first_object\".\n */\n    void\nobject_created(object_T *obj)\n{\n    if (first_object != NULL)\n    {\n\tobj->obj_next_used = first_object;\n\tfirst_object->obj_prev_used = obj;\n    }\n    first_object = obj;\n}\n\n/*\n * Call this function when an object has been cleared and is about to be freed.\n * It is removed from the list headed by \"first_object\".\n */\n    void\nobject_cleared(object_T *obj)\n{\n    if (obj->obj_next_used != NULL)\n\tobj->obj_next_used->obj_prev_used = obj->obj_prev_used;\n    if (obj->obj_prev_used != NULL)\n\tobj->obj_prev_used->obj_next_used = obj->obj_next_used;\n    else if (first_object == obj)\n\tfirst_object = obj->obj_next_used;\n}\n\n/*\n * Go through the list of all objects and free items without \"copyID\".\n */\n    int\nobject_free_nonref(int copyID)\n{\n    int\t\tdid_free = FALSE;\n    object_T\t*next_obj;\n\n    for (object_T *obj = first_object; obj != NULL; obj = next_obj)\n    {\n\tnext_obj = obj->obj_next_used;\n\tif ((obj->obj_copyID & COPYID_MASK) != (copyID & COPYID_MASK))\n\t{\n\t    // Free the object and items it contains.\n\t    object_clear(obj);\n\t    did_free = TRUE;\n\t}\n    }\n\n    return did_free;\n}\n\n\n#endif // FEAT_EVAL\n"], "fixing_code": ["\" Test Vim9 classes\n\nsource check.vim\nimport './vim9.vim' as v9\n\ndef Test_class_basic()\n  var lines =<< trim END\n      class NotWorking\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1316:')\n\n  lines =<< trim END\n      vim9script\n      class notWorking\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1314:')\n\n  lines =<< trim END\n      vim9script\n      class Not@working\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1315:')\n\n  lines =<< trim END\n      vim9script\n      abstract noclass Something\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E475:')\n\n  lines =<< trim END\n      vim9script\n      abstract classy Something\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E475:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n      endcl\n  END\n  v9.CheckScriptFailure(lines, 'E1065:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n      endclass school's out\n  END\n  v9.CheckScriptFailure(lines, 'E488:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n      endclass | echo 'done'\n  END\n  v9.CheckScriptFailure(lines, 'E488:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1317:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this.\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1317:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this .count\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1317:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this. count\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1317:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this.count: number\n        that.count\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1318: Not a valid command in a class: that.count')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this.count\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1022:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        def new()\n          this.state = 0\n        enddef\n      endclass\n      var obj = Something.new()\n  END\n  v9.CheckScriptFailure(lines, 'E1089:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this.count : number\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1059:')\n\n  lines =<< trim END\n      vim9script\n      class Something\n        this.count:number\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1069:')\n\n  lines =<< trim END\n      vim9script\n\n      class TextPosition\n        this.lnum: number\n        this.col: number\n\n        # make a nicely formatted string\n        def ToString(): string\n          return $'({this.lnum}, {this.col})'\n        enddef\n      endclass\n\n      # use the automatically generated new() method\n      var pos = TextPosition.new(2, 12)\n      assert_equal(2, pos.lnum)\n      assert_equal(12, pos.col)\n\n      # call an object method\n      assert_equal('(2, 12)', pos.ToString())\n\n      assert_equal(v:t_class, type(TextPosition))\n      assert_equal(v:t_object, type(pos))\n      assert_equal('class<TextPosition>', typename(TextPosition))\n      assert_equal('object<TextPosition>', typename(pos))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_defined_twice()\n  # class defined twice should fail\n  var lines =<< trim END\n      vim9script\n      class There\n      endclass\n      class There\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1041: Redefining script item: \"There\"')\n\n  # one class, reload same script twice is OK\n  lines =<< trim END\n      vim9script\n      class There\n      endclass\n  END\n  writefile(lines, 'XclassTwice.vim', 'D')\n  source XclassTwice.vim\n  source XclassTwice.vim\nenddef\n\ndef Test_returning_null_object()\n  # this was causing an internal error\n  var lines =<< trim END\n      vim9script\n\n      class BufferList\n          def Current(): any\n              return null_object\n          enddef\n      endclass\n\n      var buffers = BufferList.new()\n      echo buffers.Current()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_using_null_class()\n  var lines =<< trim END\n      @_ = null_class.member\n  END\n  v9.CheckDefExecAndScriptFailure(lines, ['E715:', 'E1363:'])\nenddef\n\ndef Test_class_interface_wrong_end()\n  var lines =<< trim END\n      vim9script\n      abstract class SomeName\n        this.member = 'text'\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E476: Invalid command: endinterface, expected endclass')\n\n  lines =<< trim END\n      vim9script\n      export interface AnotherName\n        this.member: string\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E476: Invalid command: endclass, expected endinterface')\nenddef\n\ndef Test_object_not_set()\n  var lines =<< trim END\n      vim9script\n\n      class State\n        this.value = 'xyz'\n      endclass\n\n      var state: State\n      var db = {'xyz': 789}\n      echo db[state.value]\n  END\n  v9.CheckScriptFailure(lines, 'E1360:')\n\n  lines =<< trim END\n      vim9script\n\n      class Class\n          this.id: string\n          def Method1()\n              echo 'Method1' .. this.id\n          enddef\n      endclass\n\n      var obj: Class\n      def Func()\n          obj.Method1()\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E1360:')\n\n  lines =<< trim END\n      vim9script\n\n      class Background\n        this.background = 'dark'\n      endclass\n\n      class Colorscheme\n        this._bg: Background\n\n        def GetBackground(): string\n          return this._bg.background\n        enddef\n      endclass\n\n      var bg: Background           # UNINITIALIZED\n      echo Colorscheme.new(bg).GetBackground()\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected object<Background> but got object<Unknown>')\n\n  # TODO: this should not give an error but be handled at runtime\n  lines =<< trim END\n      vim9script\n\n      class Class\n          this.id: string\n          def Method1()\n              echo 'Method1' .. this.id\n          enddef\n      endclass\n\n      var obj = null_object\n      def Func()\n          obj.Method1()\n      enddef\n      Func()\n  END\n  v9.CheckScriptFailure(lines, 'E1363:')\nenddef\n\ndef Test_class_member_initializer()\n  var lines =<< trim END\n      vim9script\n\n      class TextPosition\n        this.lnum: number = 1\n        this.col: number = 1\n\n        # constructor with only the line number\n        def new(lnum: number)\n          this.lnum = lnum\n        enddef\n      endclass\n\n      var pos = TextPosition.new(3)\n      assert_equal(3, pos.lnum)\n      assert_equal(1, pos.col)\n\n      var instr = execute('disassemble TextPosition.new')\n      assert_match('new\\_s*' ..\n            '0 NEW TextPosition size \\d\\+\\_s*' ..\n            '\\d PUSHNR 1\\_s*' ..\n            '\\d STORE_THIS 0\\_s*' ..\n            '\\d PUSHNR 1\\_s*' ..\n            '\\d STORE_THIS 1\\_s*' ..\n            'this.lnum = lnum\\_s*' ..\n            '\\d LOAD arg\\[-1]\\_s*' ..\n            '\\d PUSHNR 0\\_s*' ..\n            '\\d LOAD $0\\_s*' ..\n            '\\d\\+ STOREINDEX object\\_s*' ..\n            '\\d\\+ RETURN object.*',\n            instr)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_member_any_used_as_object()\n  var lines =<< trim END\n      vim9script\n\n      class Inner\n        this.value: number = 0\n      endclass\n\n      class Outer\n        this.inner: any\n      endclass\n\n      def F(outer: Outer)\n        outer.inner.value = 1\n      enddef\n\n      var inner_obj = Inner.new(0)\n      var outer_obj = Outer.new(inner_obj)\n      F(outer_obj)\n      assert_equal(1, inner_obj.value)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      class Inner\n        this.value: number = 0\n      endclass\n\n      class Outer\n        this.inner: Inner\n      endclass\n\n      def F(outer: Outer)\n        outer.inner.value = 1\n      enddef\n\n      def Test_assign_to_nested_typed_member()\n        var inner = Inner.new(0)\n        var outer = Outer.new(inner)\n        F(outer)\n        assert_equal(1, inner.value)\n      enddef\n\n      Test_assign_to_nested_typed_member()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_assignment_with_operator()\n  var lines =<< trim END\n      vim9script\n\n      class Foo\n        this.x: number\n\n        def Add(n: number)\n          this.x += n\n        enddef\n      endclass\n\n      var f =  Foo.new(3)\n      f.Add(17)\n      assert_equal(20, f.x)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_list_of_objects()\n  var lines =<< trim END\n      vim9script\n\n      class Foo\n        def Add()\n        enddef\n      endclass\n\n      def ProcessList(fooList: list<Foo>)\n        for foo in fooList\n          foo.Add()\n        endfor\n      enddef\n\n      var l: list<Foo> = [Foo.new()]\n      ProcessList(l)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_expr_after_using_object()\n  var lines =<< trim END\n      vim9script\n\n      class Something\n        this.label: string = ''\n      endclass\n\n      def Foo(): Something\n        var v = Something.new()\n        echo 'in Foo(): ' .. typename(v)\n        return v\n      enddef\n\n      Foo()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_default_new()\n  var lines =<< trim END\n      vim9script\n\n      class TextPosition\n        this.lnum: number = 1\n        this.col: number = 1\n      endclass\n\n      var pos = TextPosition.new()\n      assert_equal(1, pos.lnum)\n      assert_equal(1, pos.col)\n\n      pos = TextPosition.new(v:none, v:none)\n      assert_equal(1, pos.lnum)\n      assert_equal(1, pos.col)\n\n      pos = TextPosition.new(3, 22)\n      assert_equal(3, pos.lnum)\n      assert_equal(22, pos.col)\n\n      pos = TextPosition.new(v:none, 33)\n      assert_equal(1, pos.lnum)\n      assert_equal(33, pos.col)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class Person\n        this.name: string\n        this.age: number = 42\n        this.education: string = \"unknown\"\n\n        def new(this.name, this.age = v:none, this.education = v:none)\n        enddef\n      endclass\n\n      var piet = Person.new(\"Piet\")\n      assert_equal(\"Piet\", piet.name)\n      assert_equal(42, piet.age)\n      assert_equal(\"unknown\", piet.education)\n\n      var chris = Person.new(\"Chris\", 4, \"none\")\n      assert_equal(\"Chris\", chris.name)\n      assert_equal(4, chris.age)\n      assert_equal(\"none\", chris.education)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class Person\n        this.name: string\n        this.age: number = 42\n        this.education: string = \"unknown\"\n\n        def new(this.name, this.age = v:none, this.education = v:none)\n        enddef\n      endclass\n\n      var missing = Person.new()\n  END\n  v9.CheckScriptFailure(lines, 'E119:')\nenddef\n\ndef Test_class_object_member_inits()\n  var lines =<< trim END\n      vim9script\n      class TextPosition\n        this.lnum: number\n        this.col = 1\n        this.addcol: number = 2\n      endclass\n\n      var pos = TextPosition.new()\n      assert_equal(0, pos.lnum)\n      assert_equal(1, pos.col)\n      assert_equal(2, pos.addcol)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class TextPosition\n        this.lnum\n        this.col = 1\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1022:')\n\n  lines =<< trim END\n      vim9script\n      class TextPosition\n        this.lnum = v:none\n        this.col = 1\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1330:')\nenddef\n\ndef Test_class_object_member_access()\n  var lines =<< trim END\n      vim9script\n      class Triple\n         this._one = 1\n         this.two = 2\n         public this.three = 3\n\n         def GetOne(): number\n           return this._one\n         enddef\n      endclass\n\n      var trip = Triple.new()\n      assert_equal(1, trip.GetOne())\n      assert_equal(2, trip.two)\n      assert_equal(3, trip.three)\n      assert_fails('echo trip._one', 'E1333')\n\n      assert_fails('trip._one = 11', 'E1333')\n      assert_fails('trip.two = 22', 'E1335')\n      trip.three = 33\n      assert_equal(33, trip.three)\n\n      assert_fails('trip.four = 4', 'E1334')\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      class MyCar\n        this.make: string\n        this.age = 5\n\n        def new(make_arg: string)\n          this.make = make_arg\n        enddef\n\n        def GetMake(): string\n          return $\"make = {this.make}\"\n        enddef\n        def GetAge(): number\n          return this.age\n        enddef\n      endclass\n\n      var c = MyCar.new(\"abc\")\n      assert_equal('make = abc', c.GetMake())\n\n      c = MyCar.new(\"def\")\n      assert_equal('make = def', c.GetMake())\n\n      var c2 = MyCar.new(\"123\")\n      assert_equal('make = 123', c2.GetMake())\n\n      def CheckCar()\n        assert_equal(\"make = def\", c.GetMake())\n        assert_equal(5, c.GetAge())\n      enddef\n      CheckCar()\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      class MyCar\n        this.make: string\n\n        def new(make_arg: string)\n            this.make = make_arg\n        enddef\n      endclass\n\n      var c = MyCar.new(\"abc\")\n      var c = MyCar.new(\"def\")\n  END\n  v9.CheckScriptFailure(lines, 'E1041:')\n\n  lines =<< trim END\n      vim9script\n\n      class Foo\n        this.x: list<number> = []\n\n        def Add(n: number): any\n          this.x->add(n)\n          return this\n        enddef\n      endclass\n\n      echo Foo.new().Add(1).Add(2).x\n      echo Foo.new().Add(1).Add(2)\n            .x\n      echo Foo.new().Add(1)\n            .Add(2).x\n      echo Foo.new()\n            .Add(1).Add(2).x\n      echo Foo.new()\n            .Add(1) \n            .Add(2)\n            .x\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_object_compare()\n  var class_lines =<< trim END\n      vim9script\n      class Item\n        this.nr = 0\n        this.name = 'xx'\n      endclass\n  END\n\n  # used at the script level and in a compiled function\n  var test_lines =<< trim END\n      var i1 = Item.new()\n      assert_equal(i1, i1)\n      assert_true(i1 is i1)\n      var i2 = Item.new()\n      assert_equal(i1, i2)\n      assert_false(i1 is i2)\n      var i3 = Item.new(0, 'xx')\n      assert_equal(i1, i3)\n\n      var io1 = Item.new(1, 'xx')\n      assert_notequal(i1, io1)\n      var io2 = Item.new(0, 'yy')\n      assert_notequal(i1, io2)\n  END\n\n  v9.CheckScriptSuccess(class_lines + test_lines)\n  v9.CheckScriptSuccess(\n      class_lines + ['def Test()'] + test_lines + ['enddef', 'Test()'])\n\n  for op in ['>', '>=', '<', '<=', '=~', '!~']\n    var op_lines = [\n          'var i1 = Item.new()',\n          'var i2 = Item.new()',\n          'echo i1 ' .. op .. ' i2',\n          ]\n    v9.CheckScriptFailure(class_lines + op_lines, 'E1153: Invalid operation for object')\n    v9.CheckScriptFailure(class_lines\n          + ['def Test()'] + op_lines + ['enddef', 'Test()'], 'E1153: Invalid operation for object')\n  endfor\nenddef\n\ndef Test_object_type()\n  var lines =<< trim END\n      vim9script\n\n      class One\n        this.one = 1\n      endclass\n      class Two\n        this.two = 2\n      endclass\n      class TwoMore extends Two\n        this.more = 9\n      endclass\n\n      var o: One = One.new()\n      var t: Two = Two.new()\n      var m: TwoMore = TwoMore.new()\n      var tm: Two = TwoMore.new()\n\n      t = m\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      class One\n        this.one = 1\n      endclass\n      class Two\n        this.two = 2\n      endclass\n\n      var o: One = Two.new()\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected object<One> but got object<Two>')\n\n  lines =<< trim END\n      vim9script\n\n      interface One\n        def GetMember(): number\n      endinterface\n      class Two implements One\n        this.one = 1\n        def GetMember(): number\n          return this.one\n        enddef\n      endclass\n\n      var o: One = Two.new(5)\n      assert_equal(5, o.GetMember())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      class Num\n        this.n: number = 0\n      endclass\n\n      def Ref(name: string): func(Num): Num\n        return (arg: Num): Num => {\n          return eval(name)(arg)\n        }\n      enddef\n\n      const Fn = Ref('Double')\n      var Double = (m: Num): Num => Num.new(m.n * 2)\n\n      echo Fn(Num.new(4))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_member()\n  # check access rules\n  var lines =<< trim END\n      vim9script\n      class TextPos\n         this.lnum = 1\n         this.col = 1\n         static counter = 0\n         static _secret = 7\n         public static  anybody = 42\n\n         static def AddToCounter(nr: number)\n           counter += nr\n         enddef\n      endclass\n\n      assert_equal(0, TextPos.counter)\n      TextPos.AddToCounter(3)\n      assert_equal(3, TextPos.counter)\n      assert_fails('echo TextPos.noSuchMember', 'E1338:')\n\n      def GetCounter(): number\n        return TextPos.counter\n      enddef\n      assert_equal(3, GetCounter())\n\n      assert_fails('TextPos.noSuchMember = 2', 'E1337:')\n      assert_fails('TextPos.counter = 5', 'E1335:')\n      assert_fails('TextPos.counter += 5', 'E1335:')\n\n      assert_fails('echo TextPos._secret', 'E1333:')\n      assert_fails('TextPos._secret = 8', 'E1333:')\n\n      assert_equal(42, TextPos.anybody)\n      TextPos.anybody = 12\n      assert_equal(12, TextPos.anybody)\n      TextPos.anybody += 5\n      assert_equal(17, TextPos.anybody)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # example in the help\n  lines =<< trim END\n        vim9script\n\tclass OtherThing\n\t   this.size: number\n\t   static totalSize: number\n\n\t   def new(this.size)\n\t      totalSize += this.size\n\t   enddef\n\tendclass\n        assert_equal(0, OtherThing.totalSize)\n        var to3 = OtherThing.new(3)\n        assert_equal(3, OtherThing.totalSize)\n        var to7 = OtherThing.new(7)\n        assert_equal(10, OtherThing.totalSize)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # access private member in lambda\n  lines =<< trim END\n      vim9script\n\n      class Foo\n        this._x: number = 0\n\n        def Add(n: number): number\n          const F = (): number => this._x + n\n          return F()\n        enddef\n      endclass\n\n      var foo = Foo.new()\n      assert_equal(5, foo.Add(5))\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # check shadowing\n  lines =<< trim END\n      vim9script\n\n      class Some\n        static count = 0\n        def Method(count: number)\n          echo count\n        enddef\n      endclass\n\n      var s = Some.new()\n      s.Method(7)\n  END\n  v9.CheckScriptFailure(lines, 'E1340: Argument already declared in the class: count')\n\n  lines =<< trim END\n      vim9script\n\n      class Some\n        static count = 0\n        def Method(arg: number)\n          var count = 3\n          echo arg count\n        enddef\n      endclass\n\n      var s = Some.new()\n      s.Method(7)\n  END\n  v9.CheckScriptFailure(lines, 'E1341: Variable already declared in the class: count')\nenddef\n\nfunc Test_class_garbagecollect()\n  let lines =<< trim END\n      vim9script\n\n      class Point\n        this.p = [2, 3]\n        static pl = ['a', 'b']\n        static pd = {a: 'a', b: 'b'}\n      endclass\n\n      echo Point.pl Point.pd\n      call test_garbagecollect_now()\n      echo Point.pl Point.pd\n  END\n  call v9.CheckScriptSuccess(lines)\nendfunc\n\ndef Test_class_function()\n  var lines =<< trim END\n      vim9script\n      class Value\n        this.value = 0\n        static objects = 0\n\n        def new(v: number)\n          this.value = v\n          ++objects\n        enddef\n\n        static def GetCount(): number\n          return objects\n        enddef\n      endclass\n\n      assert_equal(0, Value.GetCount())\n      var v1 = Value.new(2)\n      assert_equal(1, Value.GetCount())\n      var v2 = Value.new(7)\n      assert_equal(2, Value.GetCount())\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_defcompile()\n  var lines =<< trim END\n      vim9script\n\n      class C\n          def Fo(i: number): string\n              return i\n          enddef\n      endclass\n\n      defcompile C.Fo\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected string but got number')\n\n  lines =<< trim END\n      vim9script\n\n      class C\n          static def Fc(): number\n            return 'x'\n          enddef\n      endclass\n\n      defcompile C.Fc\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected number but got string')\nenddef\n\ndef Test_class_object_to_string()\n  var lines =<< trim END\n      vim9script\n      class TextPosition\n        this.lnum = 1\n        this.col = 22\n      endclass\n\n      assert_equal(\"class TextPosition\", string(TextPosition))\n\n      var pos = TextPosition.new()\n      assert_equal(\"object of TextPosition {lnum: 1, col: 22}\", string(pos))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_interface_basics()\n  var lines =<< trim END\n      vim9script\n      interface Something\n        this.value: string\n        static count: number\n        def GetCount(): number\n      endinterface\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      interface SomethingWrong\n        static count = 7\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E1342:')\n\n  lines =<< trim END\n      vim9script\n\n      interface Some\n        static count: number\n        def Method(count: number)\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E1340: Argument already declared in the class: count')\n\n  lines =<< trim END\n      vim9script\n\n      interface Some\n        this.value: number\n        def Method(value: number)\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E1340: Argument already declared in the class: value')\n\n  lines =<< trim END\n      vim9script\n      interface somethingWrong\n        static count = 7\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E1343: Interface name must start with an uppercase letter: somethingWrong')\n\n  lines =<< trim END\n      vim9script\n      interface SomethingWrong\n        this.value: string\n        static count = 7\n        def GetCount(): number\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E1344:')\n\n  lines =<< trim END\n      vim9script\n      interface SomethingWrong\n        this.value: string\n        static count: number\n        def GetCount(): number\n          return 5\n        enddef\n      endinterface\n  END\n  v9.CheckScriptFailure(lines, 'E1345: Not a valid command in an interface: return 5')\n\n  lines =<< trim END\n      vim9script\n      export interface EnterExit\n          def Enter(): void\n          def Exit(): void\n      endinterface\n  END\n  writefile(lines, 'XdefIntf.vim', 'D')\n\n  lines =<< trim END\n      vim9script\n      import './XdefIntf.vim' as defIntf\n      export def With(ee: defIntf.EnterExit, F: func)\n          ee.Enter()\n          try\n              F()\n          finally\n              ee.Exit()\n          endtry\n      enddef\n  END\n  v9.CheckScriptSuccess(lines)\n\n  var imported =<< trim END\n      vim9script\n      export abstract class EnterExit\n          def Enter(): void\n          enddef\n          def Exit(): void\n          enddef\n      endclass\n  END\n  writefile(imported, 'XdefIntf2.vim', 'D')\n\n  lines[1] = \" import './XdefIntf2.vim' as defIntf\"\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_implements_interface()\n  var lines =<< trim END\n      vim9script\n\n      interface Some\n        static count: number\n        def Method(nr: number)\n      endinterface\n\n      class SomeImpl implements Some\n        static count: number\n        def Method(nr: number)\n          echo nr\n        enddef\n      endclass\n\n      interface Another\n        this.member: string\n      endinterface\n\n      class AnotherImpl implements Some, Another\n        this.member = 'abc'\n        static count: number\n        def Method(nr: number)\n          echo nr\n        enddef\n      endclass\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      interface Some\n        static counter: number\n      endinterface\n\n      class SomeImpl implements Some implements Some\n        static count: number\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1350:')\n\n  lines =<< trim END\n      vim9script\n\n      interface Some\n        static counter: number\n      endinterface\n\n      class SomeImpl implements Some, Some\n        static count: number\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1351: Duplicate interface after \"implements\": Some')\n\n  lines =<< trim END\n      vim9script\n\n      interface Some\n        static counter: number\n        def Method(nr: number)\n      endinterface\n\n      class SomeImpl implements Some\n        static count: number\n        def Method(nr: number)\n          echo nr\n        enddef\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1348: Member \"counter\" of interface \"Some\" not implemented')\n\n  lines =<< trim END\n      vim9script\n\n      interface Some\n        static count: number\n        def Methods(nr: number)\n      endinterface\n\n      class SomeImpl implements Some\n        static count: number\n        def Method(nr: number)\n          echo nr\n        enddef\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1349: Function \"Methods\" of interface \"Some\" not implemented')\n\n  # Check different order of members in class and interface works.\n  lines =<< trim END\n      vim9script\n\n      interface Result\n        public this.label: string\n        this.errpos: number\n      endinterface\n\n      # order of members is opposite of interface\n      class Failure implements Result\n        this.errpos: number = 42\n        public this.label: string = 'label'\n      endclass\n\n      def Test()\n        var result: Result = Failure.new()\n\n        assert_equal('label', result.label)\n        assert_equal(42, result.errpos)\n\n        result.label = 'different'\n        assert_equal('different', result.label)\n        assert_equal(42, result.errpos)\n      enddef\n\n      Test()\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_call_interface_method()\n  var lines =<< trim END\n    vim9script\n    interface Base\n      def Enter(): void\n    endinterface\n\n    class Child implements Base\n      def Enter(): void\n        g:result ..= 'child'\n      enddef\n    endclass\n\n    def F(obj: Base)\n      obj.Enter()\n    enddef\n\n    g:result = ''\n    F(Child.new())\n    assert_equal('child', g:result)\n    unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    class Base\n      def Enter(): void\n        g:result ..= 'base'\n      enddef\n    endclass\n\n    class Child extends Base\n      def Enter(): void\n        g:result ..= 'child'\n      enddef\n    endclass\n\n    def F(obj: Base)\n      obj.Enter()\n    enddef\n\n    g:result = ''\n    F(Child.new())\n    assert_equal('child', g:result)\n    unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\n\n  # method of interface returns a value\n  lines =<< trim END\n    vim9script\n    interface Base\n      def Enter(): string\n    endinterface\n\n    class Child implements Base\n      def Enter(): string\n        g:result ..= 'child'\n        return \"/resource\"\n      enddef\n    endclass\n\n    def F(obj: Base)\n      var r = obj.Enter()\n      g:result ..= r\n    enddef\n\n    g:result = ''\n    F(Child.new())\n    assert_equal('child/resource', g:result)\n    unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n    vim9script\n    class Base\n      def Enter(): string\n        return null_string\n      enddef\n    endclass\n\n    class Child extends Base\n      def Enter(): string\n        g:result ..= 'child'\n        return \"/resource\"\n      enddef\n    endclass\n\n    def F(obj: Base)\n      var r = obj.Enter()\n      g:result ..= r\n    enddef\n\n    g:result = ''\n    F(Child.new())\n    assert_equal('child/resource', g:result)\n    unlet g:result\n  END\n  v9.CheckScriptSuccess(lines)\n\n\n  # No class that implements the interface.\n  lines =<< trim END\n      vim9script\n\n      interface IWithEE\n          def Enter(): any\n          def Exit(): void\n      endinterface\n\n      def With1(ee: IWithEE, F: func)\n          var r = ee.Enter()\n      enddef\n\n      defcompile\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_class_used_as_type()\n  var lines =<< trim END\n      vim9script\n\n      class Point\n        this.x = 0\n        this.y = 0\n      endclass\n\n      var p: Point\n      p = Point.new(2, 33)\n      assert_equal(2, p.x)\n      assert_equal(33, p.y)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      interface HasX\n        this.x: number\n      endinterface\n\n      class Point implements HasX\n        this.x = 0\n        this.y = 0\n      endclass\n\n      var p: Point\n      p = Point.new(2, 33)\n      var hx = p\n      assert_equal(2, hx.x)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n\n      class Point\n        this.x = 0\n        this.y = 0\n      endclass\n\n      var p: Point\n      p = 'text'\n  END\n  v9.CheckScriptFailure(lines, 'E1012: Type mismatch; expected object<Point> but got string')\nenddef\n\ndef Test_class_extends()\n  var lines =<< trim END\n      vim9script\n      class Base\n        this.one = 1\n        def GetOne(): number\n          return this.one\n        enddef\n      endclass\n      class Child extends Base\n        this.two = 2\n        def GetTotal(): number\n          return this.one + this.two\n        enddef\n      endclass\n      var o = Child.new()\n      assert_equal(1, o.one)\n      assert_equal(2, o.two)\n      assert_equal(1, o.GetOne())\n      assert_equal(3, o.GetTotal())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class Base\n        this.one = 1\n      endclass\n      class Child extends Base\n        this.two = 2\n      endclass\n      var o = Child.new(3, 44)\n      assert_equal(3, o.one)\n      assert_equal(44, o.two)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class Base\n        this.one = 1\n      endclass\n      class Child extends Base extends Base\n        this.two = 2\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1352: Duplicate \"extends\"')\n\n  lines =<< trim END\n      vim9script\n      class Child extends BaseClass\n        this.two = 2\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1353: Class name not found: BaseClass')\n\n  lines =<< trim END\n      vim9script\n      var SomeVar = 99\n      class Child extends SomeVar\n        this.two = 2\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1354: Cannot extend SomeVar')\n\n  lines =<< trim END\n      vim9script\n      class Base\n        this.name: string\n        def ToString(): string\n          return this.name\n        enddef\n      endclass\n\n      class Child extends Base\n        this.age: number\n        def ToString(): string\n          return super.ToString() .. ': ' .. this.age\n        enddef\n      endclass\n\n      var o = Child.new('John', 42)\n      assert_equal('John: 42', o.ToString())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class Child\n        this.age: number\n        def ToString(): number\n          return this.age\n        enddef\n        def ToString(): string\n          return this.age\n        enddef\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1355: Duplicate function: ToString')\n\n  lines =<< trim END\n      vim9script\n      class Child\n        this.age: number\n        def ToString(): string\n          return super .ToString() .. ': ' .. this.age\n        enddef\n      endclass\n      var o = Child.new(42)\n      echo o.ToString()\n  END\n  v9.CheckScriptFailure(lines, 'E1356:')\n\n  lines =<< trim END\n      vim9script\n      class Base\n        this.name: string\n        def ToString(): string\n          return this.name\n        enddef\n      endclass\n\n      var age = 42\n      def ToString(): string\n        return super.ToString() .. ': ' .. age\n      enddef\n      echo ToString()\n  END\n  v9.CheckScriptFailure(lines, 'E1357:')\n\n  lines =<< trim END\n      vim9script\n      class Child\n        this.age: number\n        def ToString(): string\n          return super.ToString() .. ': ' .. this.age\n        enddef\n      endclass\n      var o = Child.new(42)\n      echo o.ToString()\n  END\n  v9.CheckScriptFailure(lines, 'E1358:')\n\n  lines =<< trim END\n      vim9script\n      class Base\n        this.name: string\n        static def ToString(): string\n          return 'Base class'\n        enddef\n      endclass\n\n      class Child extends Base\n        this.age: number\n        def ToString(): string\n          return Base.ToString() .. ': ' .. this.age\n        enddef\n      endclass\n\n      var o = Child.new('John', 42)\n      assert_equal('Base class: 42', o.ToString())\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      class Base\n        this.value = 1\n        def new(init: number)\n          this.value = number + 1\n        enddef\n      endclass\n      class Child extends Base\n        def new()\n          this.new(3)\n        enddef\n      endclass\n      var c = Child.new()\n  END\n  v9.CheckScriptFailure(lines, 'E1325: Method not found on class \"Child\": new(')\n\n  # base class with more than one object member\n  lines =<< trim END\n      vim9script\n\n      class Result\n        this.success: bool\n        this.value: any = null\n      endclass\n\n      class Success extends Result\n        def new(this.value = v:none)\n          this.success = true\n        enddef\n      endclass\n\n      var v = Success.new('asdf')\n      assert_equal(\"object of Success {success: true, value: 'asdf'}\", string(v))\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_using_base_class()\n  var lines =<< trim END\n    vim9script\n\n    class BaseEE\n        def Enter(): any\n            return null\n        enddef\n        def Exit(resource: any): void\n        enddef\n    endclass\n\n    class ChildEE extends BaseEE\n        def Enter(): any\n            return 42\n        enddef\n\n        def Exit(resource: number): void\n            g:result ..= '/exit'\n        enddef\n    endclass\n\n    def With(ee: BaseEE)\n        var r = ee.Enter()\n        try\n            g:result ..= r\n        finally\n            g:result ..= '/finally'\n            ee.Exit(r)\n        endtry\n    enddef\n\n    g:result = ''\n    With(ChildEE.new())\n    assert_equal('42/finally/exit', g:result)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:result\nenddef\n\n\ndef Test_class_import()\n  var lines =<< trim END\n      vim9script\n      export class Animal\n        this.kind: string\n        this.name: string\n      endclass\n  END\n  writefile(lines, 'Xanimal.vim', 'D')\n\n  lines =<< trim END\n      vim9script\n      import './Xanimal.vim' as animal\n\n      var a: animal.Animal\n      a = animal.Animal.new('fish', 'Eric')\n      assert_equal('fish', a.kind)\n      assert_equal('Eric', a.name)\n\n      var b: animal.Animal = animal.Animal.new('cat', 'Garfield')\n      assert_equal('cat', b.kind)\n      assert_equal('Garfield', b.name)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_abstract_class()\n  var lines =<< trim END\n      vim9script\n      abstract class Base\n        this.name: string\n      endclass\n      class Person extends Base\n        this.age: number\n      endclass\n      var p: Base = Person.new('Peter', 42)\n      assert_equal('Peter', p.name)\n      assert_equal(42, p.age)\n  END\n  v9.CheckScriptSuccess(lines)\n\n  lines =<< trim END\n      vim9script\n      abstract class Base\n        this.name: string\n      endclass\n      class Person extends Base\n        this.age: number\n      endclass\n      var p = Base.new('Peter')\n  END\n  v9.CheckScriptFailure(lines, 'E1325: Method not found on class \"Base\": new(')\n\n  lines =<< trim END\n      abstract class Base\n        this.name: string\n      endclass\n  END\n  v9.CheckScriptFailure(lines, 'E1316:')\nenddef\n\ndef Test_closure_in_class()\n  var lines =<< trim END\n      vim9script\n\n      class Foo\n        this.y: list<string> = ['B']\n\n        def new()\n          g:result = filter(['A', 'B'], (_, v) => index(this.y, v) == -1)\n        enddef\n      endclass\n\n      Foo.new()\n      assert_equal(['A'], g:result)\n  END\n  v9.CheckScriptSuccess(lines)\nenddef\n\ndef Test_defer_with_object()\n  var lines =<< trim END\n      vim9script\n\n      class CWithEE\n        def Enter()\n          g:result ..= \"entered/\"\n        enddef\n        def Exit()\n          g:result ..= \"exited\"\n        enddef\n      endclass\n\n      def With(ee: CWithEE, F: func)\n        ee.Enter()\n        defer ee.Exit()\n        F()\n      enddef\n\n      g:result = ''\n      var obj = CWithEE.new()\n      obj->With(() => {\n        g:result ..= \"called/\"\n      })\n      assert_equal('entered/called/exited', g:result)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:result\n\n  lines =<< trim END\n      vim9script\n\n      class BaseWithEE\n        def Enter()\n          g:result ..= \"entered-base/\"\n        enddef\n        def Exit()\n          g:result ..= \"exited-base\"\n        enddef\n      endclass\n\n      class CWithEE extends BaseWithEE\n        def Enter()\n          g:result ..= \"entered-child/\"\n        enddef\n        def Exit()\n          g:result ..= \"exited-child\"\n        enddef\n      endclass\n\n      def With(ee: BaseWithEE, F: func)\n        ee.Enter()\n        defer ee.Exit()\n        F()\n      enddef\n\n      g:result = ''\n      var obj = CWithEE.new()\n      obj->With(() => {\n        g:result ..= \"called/\"\n      })\n      assert_equal('entered-child/called/exited-child', g:result)\n  END\n  v9.CheckScriptSuccess(lines)\n  unlet g:result\nenddef\n\n\n\" vim: ts=8 sw=2 sts=2 expandtab tw=80 fdm=marker\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * vim9class.c: Vim9 script class support\n */\n\n#define USING_FLOAT_STUFF\n#include \"vim.h\"\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n// When not generating protos this is included in proto.h\n#ifdef PROTO\n# include \"vim9.h\"\n#endif\n\n/*\n * Parse a member declaration, both object and class member.\n * Returns OK or FAIL.  When OK then \"varname_end\" is set to just after the\n * variable name and \"type_ret\" is set to the decleared or detected type.\n * \"init_expr\" is set to the initialisation expression (allocated), if there is\n * one.  For an interface \"init_expr\" is NULL.\n */\n    static int\nparse_member(\n\texarg_T\t*eap,\n\tchar_u\t*line,\n\tchar_u\t*varname,\n\tint\thas_public,\t    // TRUE if \"public\" seen before \"varname\"\n\tchar_u\t**varname_end,\n\tgarray_T *type_list,\n\ttype_T\t**type_ret,\n\tchar_u\t**init_expr)\n{\n    *varname_end = to_name_end(varname, FALSE);\n    if (*varname == '_' && has_public)\n    {\n\tsemsg(_(e_public_member_name_cannot_start_with_underscore_str), line);\n\treturn FAIL;\n    }\n\n    char_u *colon = skipwhite(*varname_end);\n    char_u *type_arg = colon;\n    type_T *type = NULL;\n    if (*colon == ':')\n    {\n\tif (VIM_ISWHITE(**varname_end))\n\t{\n\t    semsg(_(e_no_white_space_allowed_before_colon_str), varname);\n\t    return FAIL;\n\t}\n\tif (!VIM_ISWHITE(colon[1]))\n\t{\n\t    semsg(_(e_white_space_required_after_str_str), \":\", varname);\n\t    return FAIL;\n\t}\n\ttype_arg = skipwhite(colon + 1);\n\ttype = parse_type(&type_arg, type_list, TRUE);\n\tif (type == NULL)\n\t    return FAIL;\n    }\n\n    char_u *expr_start = skipwhite(type_arg);\n    char_u *expr_end = expr_start;\n    if (type == NULL && *expr_start != '=')\n    {\n\temsg(_(e_type_or_initialization_required));\n\treturn FAIL;\n    }\n\n    if (*expr_start == '=')\n    {\n\tif (!VIM_ISWHITE(expr_start[-1]) || !VIM_ISWHITE(expr_start[1]))\n\t{\n\t    semsg(_(e_white_space_required_before_and_after_str_at_str),\n\t\t\t\t\t\t\t\"=\", type_arg);\n\t    return FAIL;\n\t}\n\texpr_start = skipwhite(expr_start + 1);\n\n\texpr_end = expr_start;\n\tevalarg_T evalarg;\n\tfill_evalarg_from_eap(&evalarg, eap, FALSE);\n\tskip_expr(&expr_end, NULL);\n\n\tif (type == NULL)\n\t{\n\t    // No type specified, use the type of the initializer.\n\t    typval_T tv;\n\t    tv.v_type = VAR_UNKNOWN;\n\t    char_u *expr = expr_start;\n\t    int res = eval0(expr, &tv, eap, &evalarg);\n\n\t    if (res == OK)\n\t    {\n\t\ttype = typval2type(&tv, get_copyID(), type_list,\n\t\t\t\t\t\t       TVTT_DO_MEMBER);\n\t\tclear_tv(&tv);\n\t    }\n\t    if (type == NULL)\n\t    {\n\t\tsemsg(_(e_cannot_get_object_member_type_from_initializer_str),\n\t\t\texpr_start);\n\t\tclear_evalarg(&evalarg, NULL);\n\t\treturn FAIL;\n\t    }\n\t}\n\tclear_evalarg(&evalarg, NULL);\n    }\n    if (!valid_declaration_type(type))\n\treturn FAIL;\n\n    *type_ret = type;\n    if (expr_end > expr_start)\n    {\n\tif (init_expr == NULL)\n\t{\n\t    emsg(_(e_cannot_initialize_member_in_interface));\n\t    return FAIL;\n\t}\n\t*init_expr = vim_strnsave(expr_start, expr_end - expr_start);\n    }\n    return OK;\n}\n\n/*\n * Add a member to an object or a class.\n * Returns OK when successful, \"init_expr\" will be consumed then.\n * Returns FAIL otherwise, caller might need to free \"init_expr\".\n */\n    static int\nadd_member(\n\tgarray_T    *gap,\n\tchar_u\t    *varname,\n\tchar_u\t    *varname_end,\n\tint\t    has_public,\n\ttype_T\t    *type,\n\tchar_u\t    *init_expr)\n{\n    if (ga_grow(gap, 1) == FAIL)\n\treturn FAIL;\n    ocmember_T *m = ((ocmember_T *)gap->ga_data) + gap->ga_len;\n    m->ocm_name = vim_strnsave(varname, varname_end - varname);\n    m->ocm_access = has_public ? VIM_ACCESS_ALL\n\t\t      : *varname == '_' ? VIM_ACCESS_PRIVATE : VIM_ACCESS_READ;\n    m->ocm_type = type;\n    if (init_expr != NULL)\n\tm->ocm_init = init_expr;\n    ++gap->ga_len;\n    return OK;\n}\n\n/*\n * Move the class or object members found while parsing a class into the class.\n * \"gap\" contains the found members.\n * \"parent_members\" points to the members in the parent class (if any)\n * \"parent_count\" is the number of members in the parent class\n * \"members\" will be set to the newly allocated array of members and\n * \"member_count\" set to the number of members.\n * Returns OK or FAIL.\n */\n    static int\nadd_members_to_class(\n    garray_T\t*gap,\n    ocmember_T\t*parent_members,\n    int\t\tparent_count,\n    ocmember_T\t**members,\n    int\t\t*member_count)\n{\n    *member_count = parent_count + gap->ga_len;\n    *members = *member_count == 0 ? NULL\n\t\t\t\t       : ALLOC_MULT(ocmember_T, *member_count);\n    if (*member_count > 0 && *members == NULL)\n\treturn FAIL;\n    for (int i = 0; i < parent_count; ++i)\n    {\n\t// parent members need to be copied\n\tocmember_T\t*m = *members + i;\n\t*m = parent_members[i];\n\tm->ocm_name = vim_strsave(m->ocm_name);\n\tif (m->ocm_init != NULL)\n\t    m->ocm_init = vim_strsave(m->ocm_init);\n    }\n    if (gap->ga_len > 0)\n\t// new members are moved\n\tmch_memmove(*members + parent_count,\n\t\t\t       gap->ga_data, sizeof(ocmember_T) * gap->ga_len);\n    VIM_CLEAR(gap->ga_data);\n    return OK;\n}\n\n/*\n * Convert a member index \"idx\" of interface \"itf\" to the member index of class\n * \"cl\" implementing that interface.\n */\n    int\nobject_index_from_itf_index(class_T *itf, int is_method, int idx, class_T *cl)\n{\n    if (idx > (is_method ? itf->class_obj_method_count\n\t\t\t\t\t\t: itf->class_obj_member_count))\n    {\n\tsiemsg(\"index %d out of range for interface %s\", idx, itf->class_name);\n\treturn 0;\n    }\n    itf2class_T *i2c;\n    for (i2c = itf->class_itf2class; i2c != NULL; i2c = i2c->i2c_next)\n\tif (i2c->i2c_class == cl && i2c->i2c_is_method == is_method)\n\t    break;\n    if (i2c == NULL)\n    {\n\tsiemsg(\"class %s not found on interface %s\",\n\t\t\t\t\t      cl->class_name, itf->class_name);\n\treturn 0;\n    }\n    int *table = (int *)(i2c + 1);\n    return table[idx];\n}\n\n/*\n * Handle \":class\" and \":abstract class\" up to \":endclass\".\n * Handle \":interface\" up to \":endinterface\".\n */\n    void\nex_class(exarg_T *eap)\n{\n    int\t    is_class = eap->cmdidx == CMD_class;  // FALSE for :interface\n    long    start_lnum = SOURCING_LNUM;\n\n    char_u *arg = eap->arg;\n    int is_abstract = eap->cmdidx == CMD_abstract;\n    if (is_abstract)\n    {\n\tif (STRNCMP(arg, \"class\", 5) != 0 || !VIM_ISWHITE(arg[5]))\n\t{\n\t    semsg(_(e_invalid_argument_str), arg);\n\t    return;\n\t}\n\targ = skipwhite(arg + 5);\n\tis_class = TRUE;\n    }\n\n    if (!current_script_is_vim9()\n\t\t|| (cmdmod.cmod_flags & CMOD_LEGACY)\n\t\t|| !getline_equal(eap->getline, eap->cookie, getsourceline))\n    {\n\tif (is_class)\n\t    emsg(_(e_class_can_only_be_defined_in_vim9_script));\n\telse\n\t    emsg(_(e_interface_can_only_be_defined_in_vim9_script));\n\treturn;\n    }\n\n    if (!ASCII_ISUPPER(*arg))\n    {\n\tif (is_class)\n\t    semsg(_(e_class_name_must_start_with_uppercase_letter_str), arg);\n\telse\n\t    semsg(_(e_interface_name_must_start_with_uppercase_letter_str),\n\t\t\t\t\t\t\t\t\t  arg);\n\treturn;\n    }\n    char_u *name_end = find_name_end(arg, NULL, NULL, FNE_CHECK_START);\n    if (!IS_WHITE_OR_NUL(*name_end))\n    {\n\tsemsg(_(e_white_space_required_after_name_str), arg);\n\treturn;\n    }\n    char_u *name_start = arg;\n\n    // \"export class\" gets used when creating the class, don't use \"is_export\"\n    // for the items inside the class.\n    int class_export = is_export;\n    is_export = FALSE;\n\n    // TODO:\n    //    generics: <Tkey, Tentry>\n\n    // Name for \"extends BaseClass\"\n    char_u *extends = NULL;\n\n    // Names for \"implements SomeInterface\"\n    garray_T\tga_impl;\n    ga_init2(&ga_impl, sizeof(char_u *), 5);\n\n    arg = skipwhite(name_end);\n    while (*arg != NUL && *arg != '#' && *arg != '\\n')\n    {\n\t// TODO:\n\t//    specifies SomeInterface\n\tif (STRNCMP(arg, \"extends\", 7) == 0 && IS_WHITE_OR_NUL(arg[7]))\n\t{\n\t    if (extends != NULL)\n\t    {\n\t\temsg(_(e_duplicate_extends));\n\t\tgoto early_ret;\n\t    }\n\t    arg = skipwhite(arg + 7);\n\t    char_u *end = find_name_end(arg, NULL, NULL, FNE_CHECK_START);\n\t    if (!IS_WHITE_OR_NUL(*end))\n\t    {\n\t\tsemsg(_(e_white_space_required_after_name_str), arg);\n\t\tgoto early_ret;\n\t    }\n\t    extends = vim_strnsave(arg, end - arg);\n\t    if (extends == NULL)\n\t\tgoto early_ret;\n\n\t    arg = skipwhite(end + 1);\n\t}\n\telse if (STRNCMP(arg, \"implements\", 10) == 0\n\t\t\t\t\t\t   && IS_WHITE_OR_NUL(arg[10]))\n\t{\n\t    if (ga_impl.ga_len > 0)\n\t    {\n\t\temsg(_(e_duplicate_implements));\n\t\tgoto early_ret;\n\t    }\n\t    arg = skipwhite(arg + 10);\n\n\t    for (;;)\n\t    {\n\t\tchar_u *impl_end = find_name_end(arg, NULL, NULL,\n\t\t\t\t\t\t\t      FNE_CHECK_START);\n\t\tif (!IS_WHITE_OR_NUL(*impl_end) && *impl_end != ',')\n\t\t{\n\t\t    semsg(_(e_white_space_required_after_name_str), arg);\n\t\t    goto early_ret;\n\t\t}\n\t\tchar_u *iname = vim_strnsave(arg, impl_end - arg);\n\t\tif (iname == NULL)\n\t\t    goto early_ret;\n\t\tfor (int i = 0; i < ga_impl.ga_len; ++i)\n\t\t    if (STRCMP(((char_u **)ga_impl.ga_data)[i], iname) == 0)\n\t\t    {\n\t\t\tsemsg(_(e_duplicate_interface_after_implements_str),\n\t\t\t\t\t\t\t\t\tiname);\n\t\t\tvim_free(iname);\n\t\t\tgoto early_ret;\n\t\t    }\n\t\tif (ga_add_string(&ga_impl, iname) == FAIL)\n\t\t{\n\t\t    vim_free(iname);\n\t\t    goto early_ret;\n\t\t}\n\t\tif (*impl_end != ',')\n\t\t{\n\t\t    arg = skipwhite(impl_end);\n\t\t    break;\n\t\t}\n\t\targ = skipwhite(impl_end + 1);\n\t    }\n\t}\n\telse\n\t{\n\t    semsg(_(e_trailing_characters_str), arg);\nearly_ret:\n\t    vim_free(extends);\n\t    ga_clear_strings(&ga_impl);\n\t    return;\n\t}\n    }\n\n    garray_T\ttype_list;\t    // list of pointers to allocated types\n    ga_init2(&type_list, sizeof(type_T *), 10);\n\n    // Growarray with class members declared in the class.\n    garray_T classmembers;\n    ga_init2(&classmembers, sizeof(ocmember_T), 10);\n\n    // Growarray with functions declared in the class.\n    garray_T classfunctions;\n    ga_init2(&classfunctions, sizeof(ufunc_T *), 10);\n\n    // Growarray with object members declared in the class.\n    garray_T objmembers;\n    ga_init2(&objmembers, sizeof(ocmember_T), 10);\n\n    // Growarray with object methods declared in the class.\n    garray_T objmethods;\n    ga_init2(&objmethods, sizeof(ufunc_T *), 10);\n\n    /*\n     * Go over the body of the class/interface until \"endclass\" or\n     * \"endinterface\" is found.\n     */\n    char_u *theline = NULL;\n    int success = FALSE;\n    for (;;)\n    {\n\tvim_free(theline);\n\ttheline = eap->getline(':', eap->cookie, 0, GETLINE_CONCAT_ALL);\n\tif (theline == NULL)\n\t    break;\n\tchar_u *line = skipwhite(theline);\n\n\t// Skip empty and comment lines.\n\tif (*line == NUL)\n\t    continue;\n\tif (*line == '#')\n\t{\n\t    if (vim9_bad_comment(line))\n\t\tbreak;\n\t    continue;\n\t}\n\n\tchar_u *p = line;\n\tchar *end_name = is_class ? \"endclass\" : \"endinterface\";\n\tif (checkforcmd(&p, end_name, is_class ? 4 : 5))\n\t{\n\t    if (STRNCMP(line, end_name, is_class ? 8 : 12) != 0)\n\t\tsemsg(_(e_command_cannot_be_shortened_str), line);\n\t    else if (*p == '|' || !ends_excmd2(line, p))\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsuccess = TRUE;\n\t    break;\n\t}\n\tchar *wrong_name = is_class ? \"endinterface\" : \"endclass\";\n\tif (checkforcmd(&p, wrong_name, is_class ? 5 : 4))\n\t{\n\t    semsg(_(e_invalid_command_str_expected_str), line, end_name);\n\t    break;\n\t}\n\n\tint has_public = FALSE;\n\tif (checkforcmd(&p, \"public\", 3))\n\t{\n\t    if (STRNCMP(line, \"public\", 6) != 0)\n\t    {\n\t\tsemsg(_(e_command_cannot_be_shortened_str), line);\n\t\tbreak;\n\t    }\n\t    has_public = TRUE;\n\t    p = skipwhite(line + 6);\n\n\t    if (STRNCMP(p, \"this\", 4) != 0 && STRNCMP(p, \"static\", 6) != 0)\n\t    {\n\t\temsg(_(e_public_must_be_followed_by_this_or_static));\n\t\tbreak;\n\t    }\n\t}\n\n\tint has_static = FALSE;\n\tchar_u *ps = p;\n\tif (checkforcmd(&p, \"static\", 4))\n\t{\n\t    if (STRNCMP(ps, \"static\", 6) != 0)\n\t    {\n\t\tsemsg(_(e_command_cannot_be_shortened_str), ps);\n\t\tbreak;\n\t    }\n\t    has_static = TRUE;\n\t    p = skipwhite(ps + 6);\n\t}\n\n\t// object members (public, read access, private):\n\t//\t\"this._varname\"\n\t//\t\"this.varname\"\n\t//\t\"public this.varname\"\n\tif (STRNCMP(p, \"this\", 4) == 0)\n\t{\n\t    if (p[4] != '.' || !eval_isnamec1(p[5]))\n\t    {\n\t\tsemsg(_(e_invalid_object_member_declaration_str), p);\n\t\tbreak;\n\t    }\n\t    char_u *varname = p + 5;\n\t    char_u *varname_end = NULL;\n\t    type_T *type = NULL;\n\t    char_u *init_expr = NULL;\n\t    if (parse_member(eap, line, varname, has_public,\n\t\t\t  &varname_end, &type_list, &type,\n\t\t\t  is_class ? &init_expr: NULL) == FAIL)\n\t\tbreak;\n\t    if (add_member(&objmembers, varname, varname_end,\n\t\t\t\t\t  has_public, type, init_expr) == FAIL)\n\t    {\n\t\tvim_free(init_expr);\n\t\tbreak;\n\t    }\n\t}\n\n\t// constructors:\n\t//\t  def new()\n\t//\t  enddef\n\t//\t  def newOther()\n\t//\t  enddef\n\t// object methods and class functions:\n\t//\t  def SomeMethod()\n\t//\t  enddef\n\t//\t  static def ClassFunction()\n\t//\t  enddef\n\t// TODO:\n\t//\t  def <Tval> someMethod()\n\t//\t  enddef\n\telse if (checkforcmd(&p, \"def\", 3))\n\t{\n\t    exarg_T\tea;\n\t    garray_T\tlines_to_free;\n\n\t    // TODO: error for \"public static def Func()\"?\n\n\t    CLEAR_FIELD(ea);\n\t    ea.cmd = line;\n\t    ea.arg = p;\n\t    ea.cmdidx = CMD_def;\n\t    ea.getline = eap->getline;\n\t    ea.cookie = eap->cookie;\n\n\t    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n\t    ufunc_T *uf = define_function(&ea, NULL, &lines_to_free,\n\t\t\t\t\t   is_class ? CF_CLASS : CF_INTERFACE);\n\t    ga_clear_strings(&lines_to_free);\n\n\t    if (uf != NULL)\n\t    {\n\t\tchar_u *name = uf->uf_name;\n\t\tint is_new = STRNCMP(name, \"new\", 3) == 0;\n\t\tif (is_new && is_abstract)\n\t\t{\n\t\t    emsg(_(e_cannot_define_new_function_in_abstract_class));\n\t\t    success = FALSE;\n\t\t    break;\n\t\t}\n\t\tgarray_T *fgap = has_static || is_new\n\t\t\t\t\t       ? &classfunctions : &objmethods;\n\t\t// Check the name isn't used already.\n\t\tfor (int i = 0; i < fgap->ga_len; ++i)\n\t\t{\n\t\t    char_u *n = ((ufunc_T **)fgap->ga_data)[i]->uf_name;\n\t\t    if (STRCMP(name, n) == 0)\n\t\t    {\n\t\t\tsemsg(_(e_duplicate_function_str), name);\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\n\t\tif (ga_grow(fgap, 1) == OK)\n\t\t{\n\t\t    if (is_new)\n\t\t\tuf->uf_flags |= FC_NEW;\n\n\t\t    ((ufunc_T **)fgap->ga_data)[fgap->ga_len] = uf;\n\t\t    ++fgap->ga_len;\n\t\t}\n\t    }\n\t}\n\n\t// class members\n\telse if (has_static)\n\t{\n\t    // class members (public, read access, private):\n\t    //\t\"static _varname\"\n\t    //\t\"static varname\"\n\t    //\t\"public static varname\"\n\t    char_u *varname = p;\n\t    char_u *varname_end = NULL;\n\t    type_T *type = NULL;\n\t    char_u *init_expr = NULL;\n\t    if (parse_member(eap, line, varname, has_public,\n\t\t      &varname_end, &type_list, &type,\n\t\t      is_class ? &init_expr : NULL) == FAIL)\n\t\tbreak;\n\t    if (add_member(&classmembers, varname, varname_end,\n\t\t\t\t      has_public, type, init_expr) == FAIL)\n\t    {\n\t\tvim_free(init_expr);\n\t\tbreak;\n\t    }\n\t}\n\n\telse\n\t{\n\t    if (is_class)\n\t\tsemsg(_(e_not_valid_command_in_class_str), line);\n\t    else\n\t\tsemsg(_(e_not_valid_command_in_interface_str), line);\n\t    break;\n\t}\n    }\n    vim_free(theline);\n\n    class_T *extends_cl = NULL;  // class from \"extends\" argument\n\n    /*\n     * Check a few things before defining the class.\n     */\n\n    // Check the \"extends\" class is valid.\n    if (success && extends != NULL)\n    {\n\ttypval_T tv;\n\ttv.v_type = VAR_UNKNOWN;\n\tif (eval_variable_import(extends, &tv) == FAIL)\n\t{\n\t    semsg(_(e_class_name_not_found_str), extends);\n\t    success = FALSE;\n\t}\n\telse\n\t{\n\t    if (tv.v_type != VAR_CLASS\n\t\t    || tv.vval.v_class == NULL\n\t\t    || (tv.vval.v_class->class_flags & CLASS_INTERFACE) != 0)\n\t    {\n\t\tsemsg(_(e_cannot_extend_str), extends);\n\t\tsuccess = FALSE;\n\t    }\n\t    else\n\t    {\n\t\textends_cl = tv.vval.v_class;\n\t\t++extends_cl->class_refcount;\n\t    }\n\t    clear_tv(&tv);\n\t}\n    }\n    VIM_CLEAR(extends);\n\n    class_T **intf_classes = NULL;\n\n    // Check all \"implements\" entries are valid.\n    if (success && ga_impl.ga_len > 0)\n    {\n\tintf_classes = ALLOC_CLEAR_MULT(class_T *, ga_impl.ga_len);\n\n\tfor (int i = 0; i < ga_impl.ga_len && success; ++i)\n\t{\n\t    char_u *impl = ((char_u **)ga_impl.ga_data)[i];\n\t    typval_T tv;\n\t    tv.v_type = VAR_UNKNOWN;\n\t    if (eval_variable_import(impl, &tv) == FAIL)\n\t    {\n\t\tsemsg(_(e_interface_name_not_found_str), impl);\n\t\tsuccess = FALSE;\n\t\tbreak;\n\t    }\n\n\t    if (tv.v_type != VAR_CLASS\n\t\t    || tv.vval.v_class == NULL\n\t\t    || (tv.vval.v_class->class_flags & CLASS_INTERFACE) == 0)\n\t    {\n\t\tsemsg(_(e_not_valid_interface_str), impl);\n\t\tsuccess = FALSE;\n\t    }\n\n\t    class_T *ifcl = tv.vval.v_class;\n\t    intf_classes[i] = ifcl;\n\t    ++ifcl->class_refcount;\n\n\t    // check the members of the interface match the members of the class\n\t    for (int loop = 1; loop <= 2 && success; ++loop)\n\t    {\n\t\t// loop == 1: check class members\n\t\t// loop == 2: check object members\n\t\tint if_count = loop == 1 ? ifcl->class_class_member_count\n\t\t\t\t\t : ifcl->class_obj_member_count;\n\t\tif (if_count == 0)\n\t\t    continue;\n\t\tocmember_T *if_ms = loop == 1 ? ifcl->class_class_members\n\t\t\t\t\t       : ifcl->class_obj_members;\n\t\tocmember_T *cl_ms = (ocmember_T *)(loop == 1\n\t\t\t\t\t\t    ? classmembers.ga_data\n\t\t\t\t\t\t    : objmembers.ga_data);\n\t\tint cl_count = loop == 1 ? classmembers.ga_len\n\t\t\t\t\t\t\t   : objmembers.ga_len;\n\t\tfor (int if_i = 0; if_i < if_count; ++if_i)\n\t\t{\n\t\t    int cl_i;\n\t\t    for (cl_i = 0; cl_i < cl_count; ++cl_i)\n\t\t    {\n\t\t\tocmember_T *m = &cl_ms[cl_i];\n\t\t\tif (STRCMP(if_ms[if_i].ocm_name, m->ocm_name) == 0)\n\t\t\t{\n\t\t\t    // TODO: check type\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (cl_i == cl_count)\n\t\t    {\n\t\t\tsemsg(_(e_member_str_of_interface_str_not_implemented),\n\t\t\t\t\t\t   if_ms[if_i].ocm_name, impl);\n\t\t\tsuccess = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    // check the functions/methods of the interface match the\n\t    // functions/methods of the class\n\t    for (int loop = 1; loop <= 2 && success; ++loop)\n\t    {\n\t\t// loop == 1: check class functions\n\t\t// loop == 2: check object methods\n\t\tint if_count = loop == 1 ? ifcl->class_class_function_count\n\t\t\t\t\t : ifcl->class_obj_method_count;\n\t\tif (if_count == 0)\n\t\t    continue;\n\t\tufunc_T **if_fp = loop == 1 ? ifcl->class_class_functions\n\t\t\t\t\t    : ifcl->class_obj_methods;\n\t\tufunc_T **cl_fp = (ufunc_T **)(loop == 1\n\t\t\t\t\t\t? classfunctions.ga_data\n\t\t\t\t\t\t: objmethods.ga_data);\n\t\tint cl_count = loop == 1 ? classfunctions.ga_len\n\t\t\t\t\t\t\t   : objmethods.ga_len;\n\t\tfor (int if_i = 0; if_i < if_count; ++if_i)\n\t\t{\n\t\t    char_u *if_name = if_fp[if_i]->uf_name;\n\t\t    int cl_i;\n\t\t    for (cl_i = 0; cl_i < cl_count; ++cl_i)\n\t\t    {\n\t\t\tchar_u *cl_name = cl_fp[cl_i]->uf_name;\n\t\t\tif (STRCMP(if_name, cl_name) == 0)\n\t\t\t{\n\t\t\t    // TODO: check return and argument types\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (cl_i == cl_count)\n\t\t    {\n\t\t\tsemsg(_(e_function_str_of_interface_str_not_implemented),\n\t\t\t\t\t\t\t\tif_name, impl);\n\t\t\tsuccess = FALSE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    clear_tv(&tv);\n\t}\n    }\n\n    if (success)\n    {\n\t// Check no function argument name is used as an object/class member.\n\tfor (int loop = 1; loop <= 2 && success; ++loop)\n\t{\n\t    garray_T *gap = loop == 1 ? &classfunctions : &objmethods;\n\n\t    for (int fi = 0; fi < gap->ga_len && success; ++fi)\n\t    {\n\t\tufunc_T *uf = ((ufunc_T **)gap->ga_data)[fi];\n\n\t\tfor (int i = 0; i < uf->uf_args.ga_len && success; ++i)\n\t\t{\n\t\t    char_u *aname = ((char_u **)uf->uf_args.ga_data)[i];\n\t\t    for (int il = 1; il <= 2 && success; ++il)\n\t\t    {\n\t\t\t// For a \"new()\" function \"this.member\" arguments are\n\t\t\t// OK.  TODO: check for the \"this.\" prefix.\n\t\t\tif (STRNCMP(uf->uf_name, \"new\", 3) == 0 && il == 2)\n\t\t\t    continue;\n\t\t\tgarray_T *mgap = il == 1 ? &classmembers : &objmembers;\n\t\t\tfor (int mi = 0; mi < mgap->ga_len; ++mi)\n\t\t\t{\n\t\t\t    char_u *mname = ((ocmember_T *)mgap->ga_data\n\t\t\t\t\t\t\t       + mi)->ocm_name;\n\t\t\t    if (STRCMP(aname, mname) == 0)\n\t\t\t    {\n\t\t\t\tsuccess = FALSE;\n\t\t\t\tsemsg(_(e_argument_already_declared_in_class_str),\n\t\t\t\t\t\t\t\t\taname);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n\n    class_T *cl = NULL;\n    if (success)\n    {\n\t// \"endclass\" encountered without failures: Create the class.\n\n\tcl = ALLOC_CLEAR_ONE(class_T);\n\tif (cl == NULL)\n\t    goto cleanup;\n\tif (!is_class)\n\t    cl->class_flags = CLASS_INTERFACE;\n\n\tcl->class_refcount = 1;\n\tcl->class_name = vim_strnsave(name_start, name_end - name_start);\n\tif (cl->class_name == NULL)\n\t    goto cleanup;\n\n\tif (extends_cl != NULL)\n\t{\n\t    cl->class_extends = extends_cl;\n\t    extends_cl->class_flags |= CLASS_EXTENDED;\n\t}\n\n\t// Add class and object members to \"cl\".\n\tif (add_members_to_class(&classmembers,\n\t\t\t\t extends_cl == NULL ? NULL\n\t\t\t\t\t     : extends_cl->class_class_members,\n\t\t\t\t extends_cl == NULL ? 0\n\t\t\t\t\t: extends_cl->class_class_member_count,\n\t\t\t\t &cl->class_class_members,\n\t\t\t\t &cl->class_class_member_count) == FAIL\n\t\t|| add_members_to_class(&objmembers,\n\t\t\t\t extends_cl == NULL ? NULL\n\t\t\t\t\t       : extends_cl->class_obj_members,\n\t\t\t\t extends_cl == NULL ? 0\n\t\t\t\t\t  : extends_cl->class_obj_member_count,\n\t\t\t\t &cl->class_obj_members,\n\t\t\t\t &cl->class_obj_member_count) == FAIL)\n\t    goto cleanup;\n\n\tif (ga_impl.ga_len > 0)\n\t{\n\t    // Move the \"implements\" names into the class.\n\t    cl->class_interface_count = ga_impl.ga_len;\n\t    cl->class_interfaces = ALLOC_MULT(char_u *, ga_impl.ga_len);\n\t    if (cl->class_interfaces == NULL)\n\t\tgoto cleanup;\n\t    for (int i = 0; i < ga_impl.ga_len; ++i)\n\t\tcl->class_interfaces[i] = ((char_u **)ga_impl.ga_data)[i];\n\t    VIM_CLEAR(ga_impl.ga_data);\n\t    ga_impl.ga_len = 0;\n\n\t    cl->class_interfaces_cl = intf_classes;\n\t    intf_classes = NULL;\n\t}\n\n\tif (cl->class_interface_count > 0 || extends_cl != NULL)\n\t{\n\t    // For each interface add a lookuptable for the member index on the\n\t    // interface to the member index in this class.\n\t    // And a lookuptable for the object method index on the interface\n\t    // to the object method index in this class.\n\t    // Also do this for the extended class, if any.\n\t    for (int i = 0; i <= cl->class_interface_count; ++i)\n\t    {\n\t\tclass_T *ifcl = i < cl->class_interface_count\n\t\t\t\t\t    ? cl->class_interfaces_cl[i]\n\t\t\t\t\t    : extends_cl;\n\t\tif (ifcl == NULL)\n\t\t    continue;\n\n\t\t// Table for members.\n\t\titf2class_T *if2cl = alloc_clear(sizeof(itf2class_T)\n\t\t\t\t + ifcl->class_obj_member_count * sizeof(int));\n\t\tif (if2cl == NULL)\n\t\t    goto cleanup;\n\t\tif2cl->i2c_next = ifcl->class_itf2class;\n\t\tifcl->class_itf2class = if2cl;\n\t\tif2cl->i2c_class = cl;\n\t\tif2cl->i2c_is_method = FALSE;\n\n\t\tfor (int if_i = 0; if_i < ifcl->class_obj_member_count; ++if_i)\n\t\t    for (int cl_i = 0; cl_i < cl->class_obj_member_count;\n\t\t\t\t\t\t\t\t\t++cl_i)\n\t\t    {\n\t\t\tif (STRCMP(ifcl->class_obj_members[if_i].ocm_name,\n\t\t\t\t    cl->class_obj_members[cl_i].ocm_name) == 0)\n\t\t\t{\n\t\t\t    int *table = (int *)(if2cl + 1);\n\t\t\t    table[if_i] = cl_i;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\n\t\t// Table for methods.\n\t\tif2cl = alloc_clear(sizeof(itf2class_T)\n\t\t\t\t + ifcl->class_obj_method_count * sizeof(int));\n\t\tif (if2cl == NULL)\n\t\t    goto cleanup;\n\t\tif2cl->i2c_next = ifcl->class_itf2class;\n\t\tifcl->class_itf2class = if2cl;\n\t\tif2cl->i2c_class = cl;\n\t\tif2cl->i2c_is_method = TRUE;\n\n\t\tfor (int if_i = 0; if_i < ifcl->class_obj_method_count; ++if_i)\n\t\t{\n\t\t    int done = FALSE;\n\t\t    for (int cl_i = 0; cl_i < objmethods.ga_len; ++cl_i)\n\t\t    {\n\t\t\tif (STRCMP(ifcl->class_obj_methods[if_i]->uf_name,\n\t\t\t       ((ufunc_T **)objmethods.ga_data)[cl_i]->uf_name)\n\t\t\t\t\t\t\t\t\t  == 0)\n\t\t\t{\n\t\t\t    int *table = (int *)(if2cl + 1);\n\t\t\t    table[if_i] = cl_i;\n\t\t\t    done = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\n\t\t    if (!done && extends_cl != NULL)\n\t\t    {\n\t\t\tfor (int cl_i = 0;\n\t\t\t     cl_i < extends_cl->class_obj_member_count; ++cl_i)\n\t\t\t{\n\t\t\t    if (STRCMP(ifcl->class_obj_methods[if_i]->uf_name,\n\t\t\t\t   extends_cl->class_obj_methods[cl_i]->uf_name)\n\t\t\t\t\t\t\t\t\t  == 0)\n\t\t\t    {\n\t\t\t\tint *table = (int *)(if2cl + 1);\n\t\t\t\ttable[if_i] = cl_i;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (is_class && cl->class_class_member_count > 0)\n\t{\n\t    // Allocate a typval for each class member and initialize it.\n\t    cl->class_members_tv = ALLOC_CLEAR_MULT(typval_T,\n\t\t\t\t\t\t cl->class_class_member_count);\n\t    if (cl->class_members_tv != NULL)\n\t\tfor (int i = 0; i < cl->class_class_member_count; ++i)\n\t\t{\n\t\t    ocmember_T *m = &cl->class_class_members[i];\n\t\t    typval_T *tv = &cl->class_members_tv[i];\n\t\t    if (m->ocm_init != NULL)\n\t\t    {\n\t\t\ttypval_T *etv = eval_expr(m->ocm_init, eap);\n\t\t\tif (etv != NULL)\n\t\t\t{\n\t\t\t    *tv = *etv;\n\t\t\t    vim_free(etv);\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// TODO: proper default value\n\t\t\ttv->v_type = m->ocm_type->tt_type;\n\t\t\ttv->vval.v_string = NULL;\n\t\t    }\n\t\t}\n\t}\n\n\tint have_new = FALSE;\n\tfor (int i = 0; i < classfunctions.ga_len; ++i)\n\t    if (STRCMP(((ufunc_T **)classfunctions.ga_data)[i]->uf_name,\n\t\t\t\t\t\t\t\t   \"new\") == 0)\n\t    {\n\t\thave_new = TRUE;\n\t\tbreak;\n\t    }\n\tif (is_class && !is_abstract && !have_new)\n\t{\n\t    // No new() method was defined, add the default constructor.\n\t    garray_T fga;\n\t    ga_init2(&fga, 1, 1000);\n\t    ga_concat(&fga, (char_u *)\"new(\");\n\t    for (int i = 0; i < cl->class_obj_member_count; ++i)\n\t    {\n\t\tif (i > 0)\n\t\t    ga_concat(&fga, (char_u *)\", \");\n\t\tga_concat(&fga, (char_u *)\"this.\");\n\t\tocmember_T *m = cl->class_obj_members + i;\n\t\tga_concat(&fga, (char_u *)m->ocm_name);\n\t\tga_concat(&fga, (char_u *)\" = v:none\");\n\t    }\n\t    ga_concat(&fga, (char_u *)\")\\nenddef\\n\");\n\t    ga_append(&fga, NUL);\n\n\t    exarg_T fea;\n\t    CLEAR_FIELD(fea);\n\t    fea.cmdidx = CMD_def;\n\t    fea.cmd = fea.arg = fga.ga_data;\n\n\t    garray_T lines_to_free;\n\t    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n\n\t    ufunc_T *nf = define_function(&fea, NULL, &lines_to_free, CF_CLASS);\n\n\t    ga_clear_strings(&lines_to_free);\n\t    vim_free(fga.ga_data);\n\n\t    if (nf != NULL && ga_grow(&classfunctions, 1) == OK)\n\t    {\n\t\t((ufunc_T **)classfunctions.ga_data)[classfunctions.ga_len]\n\t\t\t\t\t\t\t\t\t  = nf;\n\t\t++classfunctions.ga_len;\n\n\t\tnf->uf_flags |= FC_NEW;\n\t\tnf->uf_ret_type = get_type_ptr(&type_list);\n\t\tif (nf->uf_ret_type != NULL)\n\t\t{\n\t\t    nf->uf_ret_type->tt_type = VAR_OBJECT;\n\t\t    nf->uf_ret_type->tt_class = cl;\n\t\t    nf->uf_ret_type->tt_argcount = 0;\n\t\t    nf->uf_ret_type->tt_args = NULL;\n\t\t}\n\t    }\n\t}\n\n\t// Move all the functions into the created class.\n\t// loop 1: class functions, loop 2: object methods\n\tfor (int loop = 1; loop <= 2; ++loop)\n\t{\n\t    garray_T *gap = loop == 1 ? &classfunctions : &objmethods;\n\t    int\t     *fcount = loop == 1 ? &cl->class_class_function_count\n\t\t\t\t\t : &cl->class_obj_method_count;\n\t    ufunc_T ***fup = loop == 1 ? &cl->class_class_functions\n\t\t\t\t       : &cl->class_obj_methods;\n\n\t    int parent_count = 0;\n\t    if (extends_cl != NULL)\n\t\t// Include functions from the parent.\n\t\tparent_count = loop == 1\n\t\t\t\t    ? extends_cl->class_class_function_count\n\t\t\t\t    : extends_cl->class_obj_method_count;\n\n\t    *fcount = parent_count + gap->ga_len;\n\t    if (*fcount == 0)\n\t    {\n\t\t*fup = NULL;\n\t\tcontinue;\n\t    }\n\t    *fup = ALLOC_MULT(ufunc_T *, *fcount);\n\t    if (*fup == NULL)\n\t\tgoto cleanup;\n\n\t    mch_memmove(*fup, gap->ga_data, sizeof(ufunc_T *) * gap->ga_len);\n\t    vim_free(gap->ga_data);\n\t    if (loop == 1)\n\t\tcl->class_class_function_count_child = gap->ga_len;\n\t    else\n\t\tcl->class_obj_method_count_child = gap->ga_len;\n\n\t    int skipped = 0;\n\t    for (int i = 0; i < parent_count; ++i)\n\t    {\n\t\t// Copy functions from the parent.  Can't use the same\n\t\t// function, because \"uf_class\" is different and compilation\n\t\t// will have a different result.\n\t\t// Put them after the functions in the current class, object\n\t\t// methods may be overruled, then \"super.Method()\" is used to\n\t\t// find a method from the parent.\n\t\t// Skip \"new\" functions. TODO: not all of them.\n\t\tif (loop == 1 && STRNCMP(\n\t\t\t    extends_cl->class_class_functions[i]->uf_name,\n\t\t\t\t\t\t\t\t\"new\", 3) == 0)\n\t\t    ++skipped;\n\t\telse\n\t\t{\n\t\t    ufunc_T *pf = (loop == 1\n\t\t\t\t\t? extends_cl->class_class_functions\n\t\t\t\t\t: extends_cl->class_obj_methods)[i];\n\t\t    (*fup)[gap->ga_len + i - skipped] = copy_function(pf);\n\n\t\t    // If the child class overrides a function from the parent\n\t\t    // the signature must be equal.\n\t\t    char_u *pname = pf->uf_name;\n\t\t    for (int ci = 0; ci < gap->ga_len; ++ci)\n\t\t    {\n\t\t\tufunc_T *cf = (*fup)[ci];\n\t\t\tchar_u *cname = cf->uf_name;\n\t\t\tif (STRCMP(pname, cname) == 0)\n\t\t\t{\n\t\t\t    where_T where = WHERE_INIT;\n\t\t\t    where.wt_func_name = (char *)pname;\n\t\t\t    (void)check_type(pf->uf_func_type, cf->uf_func_type,\n\t\t\t\t\t\t\t\t  TRUE, where);\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\n\t    *fcount -= skipped;\n\n\t    // Set the class pointer on all the functions and object methods.\n\t    for (int i = 0; i < *fcount; ++i)\n\t    {\n\t\tufunc_T *fp = (*fup)[i];\n\t\tfp->uf_class = cl;\n\t\tif (loop == 2)\n\t\t    fp->uf_flags |= FC_OBJECT;\n\t    }\n\t}\n\n\tcl->class_type.tt_type = VAR_CLASS;\n\tcl->class_type.tt_class = cl;\n\tcl->class_object_type.tt_type = VAR_OBJECT;\n\tcl->class_object_type.tt_class = cl;\n\tcl->class_type_list = type_list;\n\n\t// TODO:\n\t// - Fill hashtab with object members and methods ?\n\n\t// Add the class to the script-local variables.\n\t// TODO: handle other context, e.g. in a function\n\ttypval_T tv;\n\ttv.v_type = VAR_CLASS;\n\ttv.vval.v_class = cl;\n\tis_export = class_export;\n\tSOURCING_LNUM = start_lnum;\n\tset_var_const(cl->class_name, current_sctx.sc_sid,\n\t\t\t\t\t\t       NULL, &tv, FALSE, 0, 0);\n\treturn;\n    }\n\ncleanup:\n    if (cl != NULL)\n    {\n\tvim_free(cl->class_name);\n\tvim_free(cl->class_class_functions);\n\tif (cl->class_interfaces != NULL)\n\t{\n\t    for (int i = 0; i < cl->class_interface_count; ++i)\n\t\tvim_free(cl->class_interfaces[i]);\n\t    vim_free(cl->class_interfaces);\n\t}\n\tif (cl->class_interfaces_cl != NULL)\n\t{\n\t    for (int i = 0; i < cl->class_interface_count; ++i)\n\t\tclass_unref(cl->class_interfaces_cl[i]);\n\t    vim_free(cl->class_interfaces_cl);\n\t}\n\tvim_free(cl->class_obj_members);\n\tvim_free(cl->class_obj_methods);\n\tvim_free(cl);\n    }\n\n    vim_free(extends);\n    class_unref(extends_cl);\n\n    if (intf_classes != NULL)\n    {\n\tfor (int i = 0; i < ga_impl.ga_len; ++i)\n\t    class_unref(intf_classes[i]);\n\tvim_free(intf_classes);\n    }\n    ga_clear_strings(&ga_impl);\n\n    for (int round = 1; round <= 2; ++round)\n    {\n\tgarray_T *gap = round == 1 ? &classmembers : &objmembers;\n\tif (gap->ga_len == 0 || gap->ga_data == NULL)\n\t    continue;\n\n\tfor (int i = 0; i < gap->ga_len; ++i)\n\t{\n\t    ocmember_T *m = ((ocmember_T *)gap->ga_data) + i;\n\t    vim_free(m->ocm_name);\n\t    vim_free(m->ocm_init);\n\t}\n\tga_clear(gap);\n    }\n\n    for (int i = 0; i < objmethods.ga_len; ++i)\n    {\n\tufunc_T *uf = ((ufunc_T **)objmethods.ga_data)[i];\n\tfunc_clear_free(uf, FALSE);\n    }\n    ga_clear(&objmethods);\n\n    for (int i = 0; i < classfunctions.ga_len; ++i)\n    {\n\tufunc_T *uf = ((ufunc_T **)classfunctions.ga_data)[i];\n\tfunc_clear_free(uf, FALSE);\n    }\n    ga_clear(&classfunctions);\n\n    clear_type_list(&type_list);\n}\n\n/*\n * Find member \"name\" in class \"cl\", set \"member_idx\" to the member index and\n * return its type.\n * When not found \"member_idx\" is set to -1 and t_any is returned.\n */\n    type_T *\nclass_member_type(\n\tclass_T *cl,\n\tchar_u\t*name,\n\tchar_u\t*name_end,\n\tint\t*member_idx)\n{\n    *member_idx = -1;  // not found (yet)\n    size_t len = name_end - name;\n\n    for (int i = 0; i < cl->class_obj_member_count; ++i)\n    {\n\tocmember_T *m = cl->class_obj_members + i;\n\tif (STRNCMP(m->ocm_name, name, len) == 0 && m->ocm_name[len] == NUL)\n\t{\n\t    *member_idx = i;\n\t    return m->ocm_type;\n\t}\n    }\n\n    semsg(_(e_unknown_variable_str), name);\n    return &t_any;\n}\n\n/*\n * Handle \":enum\" up to \":endenum\".\n */\n    void\nex_enum(exarg_T *eap UNUSED)\n{\n    // TODO\n}\n\n/*\n * Handle \":type\".\n */\n    void\nex_type(exarg_T *eap UNUSED)\n{\n    // TODO\n}\n\n/*\n * Evaluate what comes after a class:\n * - class member: SomeClass.varname\n * - class function: SomeClass.SomeMethod()\n * - class constructor: SomeClass.new()\n * - object member: someObject.varname\n * - object method: someObject.SomeMethod()\n *\n * \"*arg\" points to the '.'.\n * \"*arg\" is advanced to after the member name or method call.\n *\n * Returns FAIL or OK.\n */\n    int\nclass_object_index(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose UNUSED)\t// give error messages\n{\n    if (VIM_ISWHITE((*arg)[1]))\n    {\n\tsemsg(_(e_no_white_space_allowed_after_str_str), \".\", *arg);\n\treturn FAIL;\n    }\n\n    ++*arg;\n    char_u *name = *arg;\n    char_u *name_end = find_name_end(name, NULL, NULL, FNE_CHECK_START);\n    if (name_end == name)\n\treturn FAIL;\n    size_t len = name_end - name;\n\n    class_T *cl;\n    if (rettv->v_type == VAR_CLASS)\n\tcl = rettv->vval.v_class;\n    else // VAR_OBJECT\n    {\n\tif (rettv->vval.v_object == NULL)\n\t{\n\t    emsg(_(e_using_null_object));\n\t    return FAIL;\n\t}\n\tcl = rettv->vval.v_object->obj_class;\n    }\n\n    if (cl == NULL)\n    {\n\temsg(_(e_incomplete_type));\n\treturn FAIL;\n    }\n\n    if (*name_end == '(')\n    {\n\tint on_class = rettv->v_type == VAR_CLASS;\n\tint count = on_class ? cl->class_class_function_count\n\t\t\t     : cl->class_obj_method_count;\n\tfor (int i = 0; i < count; ++i)\n\t{\n\t    ufunc_T *fp = on_class ? cl->class_class_functions[i]\n\t\t\t\t   : cl->class_obj_methods[i];\n\t    // Use a separate pointer to avoid that ASAN complains about\n\t    // uf_name[] only being 4 characters.\n\t    char_u *ufname = (char_u *)fp->uf_name;\n\t    if (STRNCMP(name, ufname, len) == 0 && ufname[len] == NUL)\n\t    {\n\t\ttypval_T    argvars[MAX_FUNC_ARGS + 1];\n\t\tint\t    argcount = 0;\n\n\t\tchar_u *argp = name_end;\n\t\tint ret = get_func_arguments(&argp, evalarg, 0,\n\t\t\t\t\t\t\t   argvars, &argcount);\n\t\tif (ret == FAIL)\n\t\t    return FAIL;\n\n\t\tfuncexe_T   funcexe;\n\t\tCLEAR_FIELD(funcexe);\n\t\tfuncexe.fe_evaluate = TRUE;\n\t\tif (rettv->v_type == VAR_OBJECT)\n\t\t{\n\t\t    funcexe.fe_object = rettv->vval.v_object;\n\t\t    ++funcexe.fe_object->obj_refcount;\n\t\t}\n\n\t\t// Clear the class or object after calling the function, in\n\t\t// case the refcount is one.\n\t\ttypval_T tv_tofree = *rettv;\n\t\trettv->v_type = VAR_UNKNOWN;\n\n\t\t// Call the user function.  Result goes into rettv;\n\t\tint error = call_user_func_check(fp, argcount, argvars,\n\t\t\t\t\t\t\trettv, &funcexe, NULL);\n\n\t\t// Clear the previous rettv and the arguments.\n\t\tclear_tv(&tv_tofree);\n\t\tfor (int idx = 0; idx < argcount; ++idx)\n\t\t    clear_tv(&argvars[idx]);\n\n\t\tif (error != FCERR_NONE)\n\t\t{\n\t\t    user_func_error(error, printable_func_name(fp),\n\t\t\t\t\t\t\t funcexe.fe_found_var);\n\t\t    return FAIL;\n\t\t}\n\t\t*arg = argp;\n\t\treturn OK;\n\t    }\n\t}\n\n\tsemsg(_(e_method_not_found_on_class_str_str), cl->class_name, name);\n    }\n\n    else if (rettv->v_type == VAR_OBJECT)\n    {\n\tfor (int i = 0; i < cl->class_obj_member_count; ++i)\n\t{\n\t    ocmember_T *m = &cl->class_obj_members[i];\n\t    if (STRNCMP(name, m->ocm_name, len) == 0 && m->ocm_name[len] == NUL)\n\t    {\n\t\tif (*name == '_')\n\t\t{\n\t\t    semsg(_(e_cannot_access_private_member_str), m->ocm_name);\n\t\t    return FAIL;\n\t\t}\n\n\t\t// The object only contains a pointer to the class, the member\n\t\t// values array follows right after that.\n\t\tobject_T *obj = rettv->vval.v_object;\n\t\ttypval_T *tv = (typval_T *)(obj + 1) + i;\n\t\tcopy_tv(tv, rettv);\n\t\tobject_unref(obj);\n\n\t\t*arg = name_end;\n\t\treturn OK;\n\t    }\n\t}\n\n\tsemsg(_(e_member_not_found_on_object_str_str), cl->class_name, name);\n    }\n\n    else if (rettv->v_type == VAR_CLASS)\n    {\n\t// class member\n\tfor (int i = 0; i < cl->class_class_member_count; ++i)\n\t{\n\t    ocmember_T *m = &cl->class_class_members[i];\n\t    if (STRNCMP(name, m->ocm_name, len) == 0 && m->ocm_name[len] == NUL)\n\t    {\n\t\tif (*name == '_')\n\t\t{\n\t\t    semsg(_(e_cannot_access_private_member_str), m->ocm_name);\n\t\t    return FAIL;\n\t\t}\n\n\t\ttypval_T *tv = &cl->class_members_tv[i];\n\t\tcopy_tv(tv, rettv);\n\t\tclass_unref(cl);\n\n\t\t*arg = name_end;\n\t\treturn OK;\n\t    }\n\t}\n\n\tsemsg(_(e_member_not_found_on_class_str_str), cl->class_name, name);\n    }\n\n    return FAIL;\n}\n\n/*\n * If \"arg\" points to a class or object method, return it.\n * Otherwise return NULL.\n */\n    ufunc_T *\nfind_class_func(char_u **arg)\n{\n    char_u *name = *arg;\n    char_u *name_end = find_name_end(name, NULL, NULL, FNE_CHECK_START);\n    if (name_end == name || *name_end != '.')\n\treturn NULL;\n\n    size_t len = name_end - name;\n    typval_T tv;\n    tv.v_type = VAR_UNKNOWN;\n    if (eval_variable(name, (int)len,\n\t\t\t\t    0, &tv, NULL, EVAL_VAR_NOAUTOLOAD) == FAIL)\n\treturn NULL;\n    if (tv.v_type != VAR_CLASS && tv.v_type != VAR_OBJECT)\n\tgoto fail_after_eval;\n\n    class_T *cl = tv.v_type == VAR_CLASS ? tv.vval.v_class\n\t\t\t\t\t\t : tv.vval.v_object->obj_class;\n    if (cl == NULL)\n\tgoto fail_after_eval;\n    char_u *fname = name_end + 1;\n    char_u *fname_end = find_name_end(fname, NULL, NULL, FNE_CHECK_START);\n    if (fname_end == fname)\n\tgoto fail_after_eval;\n    len = fname_end - fname;\n\n    int count = tv.v_type == VAR_CLASS ? cl->class_class_function_count\n\t\t\t\t       : cl->class_obj_method_count;\n    ufunc_T **funcs = tv.v_type == VAR_CLASS ? cl->class_class_functions\n\t\t\t\t\t     : cl->class_obj_methods;\n    for (int i = 0; i < count; ++i)\n    {\n\tufunc_T *fp = funcs[i];\n\t// Use a separate pointer to avoid that ASAN complains about\n\t// uf_name[] only being 4 characters.\n\tchar_u *ufname = (char_u *)fp->uf_name;\n\tif (STRNCMP(fname, ufname, len) == 0 && ufname[len] == NUL)\n\t{\n\t    clear_tv(&tv);\n\t    return fp;\n\t}\n    }\n\nfail_after_eval:\n    clear_tv(&tv);\n    return NULL;\n}\n\n/*\n * If \"name[len]\" is a class member in cctx->ctx_ufunc->uf_class return the\n * index in class.class_class_members[].\n * If \"cl_ret\" is not NULL set it to the class.\n * Otherwise return -1;\n */\n    int\nclass_member_index(char_u *name, size_t len, class_T **cl_ret, cctx_T *cctx)\n{\n    if (cctx == NULL || cctx->ctx_ufunc == NULL\n\t\t\t\t\t  || cctx->ctx_ufunc->uf_class == NULL)\n\treturn -1;\n    class_T *cl = cctx->ctx_ufunc->uf_class;\n\n    for (int i = 0; i < cl->class_class_member_count; ++i)\n    {\n\tocmember_T *m = &cl->class_class_members[i];\n\tif (STRNCMP(name, m->ocm_name, len) == 0 && m->ocm_name[len] == NUL)\n\t{\n\t    if (cl_ret != NULL)\n\t\t*cl_ret = cl;\n\t    return i;\n\t}\n    }\n    return -1;\n}\n\n/*\n * Return TRUE if current context \"cctx_arg\" is inside class \"cl\".\n * Return FALSE if not.\n */\n    int\ninside_class(cctx_T *cctx_arg, class_T *cl)\n{\n    for (cctx_T *cctx = cctx_arg; cctx != NULL; cctx = cctx->ctx_outer)\n\tif (cctx->ctx_ufunc != NULL && cctx->ctx_ufunc->uf_class == cl)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * Make a copy of an object.\n */\n    void\ncopy_object(typval_T *from, typval_T *to)\n{\n    *to = *from;\n    if (to->vval.v_object != NULL)\n\t++to->vval.v_object->obj_refcount;\n}\n\n/*\n * Free an object.\n */\n    static void\nobject_clear(object_T *obj)\n{\n    class_T *cl = obj->obj_class;\n\n    // the member values are just after the object structure\n    typval_T *tv = (typval_T *)(obj + 1);\n    for (int i = 0; i < cl->class_obj_member_count; ++i)\n\tclear_tv(tv + i);\n\n    // Remove from the list headed by \"first_object\".\n    object_cleared(obj);\n\n    vim_free(obj);\n    class_unref(cl);\n}\n\n/*\n * Unreference an object.\n */\n    void\nobject_unref(object_T *obj)\n{\n    if (obj != NULL && --obj->obj_refcount <= 0)\n\tobject_clear(obj);\n}\n\n/*\n * Make a copy of a class.\n */\n    void\ncopy_class(typval_T *from, typval_T *to)\n{\n    *to = *from;\n    if (to->vval.v_class != NULL)\n\t++to->vval.v_class->class_refcount;\n}\n\n/*\n * Unreference a class.  Free it when the reference count goes down to zero.\n */\n    void\nclass_unref(class_T *cl)\n{\n    if (cl != NULL && --cl->class_refcount <= 0 && cl->class_name != NULL)\n    {\n\t// Freeing what the class contains may recursively come back here.\n\t// Clear \"class_name\" first, if it is NULL the class does not need to\n\t// be freed.\n\tVIM_CLEAR(cl->class_name);\n\n\tclass_unref(cl->class_extends);\n\n\tfor (int i = 0; i < cl->class_interface_count; ++i)\n\t{\n\t    vim_free(((char_u **)cl->class_interfaces)[i]);\n\t    if (cl->class_interfaces_cl[i] != NULL)\n\t\tclass_unref(cl->class_interfaces_cl[i]);\n\t}\n\tvim_free(cl->class_interfaces);\n\tvim_free(cl->class_interfaces_cl);\n\n\titf2class_T *next;\n\tfor (itf2class_T *i2c = cl->class_itf2class; i2c != NULL; i2c = next)\n\t{\n\t    next = i2c->i2c_next;\n\t    vim_free(i2c);\n\t}\n\n\tfor (int i = 0; i < cl->class_class_member_count; ++i)\n\t{\n\t    ocmember_T *m = &cl->class_class_members[i];\n\t    vim_free(m->ocm_name);\n\t    vim_free(m->ocm_init);\n\t    if (cl->class_members_tv != NULL)\n\t\tclear_tv(&cl->class_members_tv[i]);\n\t}\n\tvim_free(cl->class_class_members);\n\tvim_free(cl->class_members_tv);\n\n\tfor (int i = 0; i < cl->class_obj_member_count; ++i)\n\t{\n\t    ocmember_T *m = &cl->class_obj_members[i];\n\t    vim_free(m->ocm_name);\n\t    vim_free(m->ocm_init);\n\t}\n\tvim_free(cl->class_obj_members);\n\n\tfor (int i = 0; i < cl->class_class_function_count; ++i)\n\t{\n\t    ufunc_T *uf = cl->class_class_functions[i];\n\t    func_clear_free(uf, FALSE);\n\t}\n\tvim_free(cl->class_class_functions);\n\n\tfor (int i = 0; i < cl->class_obj_method_count; ++i)\n\t{\n\t    ufunc_T *uf = cl->class_obj_methods[i];\n\t    func_clear_free(uf, FALSE);\n\t}\n\tvim_free(cl->class_obj_methods);\n\n\tclear_type_list(&cl->class_type_list);\n\n\tvim_free(cl);\n    }\n}\n\nstatic object_T *first_object = NULL;\n\n/*\n * Call this function when an object has been created.  It will be added to the\n * list headed by \"first_object\".\n */\n    void\nobject_created(object_T *obj)\n{\n    if (first_object != NULL)\n    {\n\tobj->obj_next_used = first_object;\n\tfirst_object->obj_prev_used = obj;\n    }\n    first_object = obj;\n}\n\n/*\n * Call this function when an object has been cleared and is about to be freed.\n * It is removed from the list headed by \"first_object\".\n */\n    void\nobject_cleared(object_T *obj)\n{\n    if (obj->obj_next_used != NULL)\n\tobj->obj_next_used->obj_prev_used = obj->obj_prev_used;\n    if (obj->obj_prev_used != NULL)\n\tobj->obj_prev_used->obj_next_used = obj->obj_next_used;\n    else if (first_object == obj)\n\tfirst_object = obj->obj_next_used;\n}\n\n/*\n * Go through the list of all objects and free items without \"copyID\".\n */\n    int\nobject_free_nonref(int copyID)\n{\n    int\t\tdid_free = FALSE;\n    object_T\t*next_obj;\n\n    for (object_T *obj = first_object; obj != NULL; obj = next_obj)\n    {\n\tnext_obj = obj->obj_next_used;\n\tif ((obj->obj_copyID & COPYID_MASK) != (copyID & COPYID_MASK))\n\t{\n\t    // Free the object and items it contains.\n\t    object_clear(obj);\n\t    did_free = TRUE;\n\t}\n    }\n\n    return did_free;\n}\n\n\n#endif // FEAT_EVAL\n"], "filenames": ["src/testdir/test_vim9_class.vim", "src/version.c", "src/vim9class.c"], "buggy_code_start_loc": [203, 697, 1264], "buggy_code_end_loc": [203, 697, 1264], "fixing_code_start_loc": [204, 698, 1265], "fixing_code_end_loc": [211, 700, 1271], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.1402.", "other": {"cve": {"id": "CVE-2023-1355", "sourceIdentifier": "security@huntr.dev", "published": "2023-03-11T22:15:10.133", "lastModified": "2023-04-02T03:15:10.897", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.1402."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.4, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.5, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.1402", "matchCriteriaId": "393C0746-487F-4B80-B53D-C28B95737769"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/d13dd30240e32071210f55b587182ff48757ea46", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/4d0a9615-d438-4f5c-8dd6-aa22f4b716d9", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IE44W6WMMREYCW3GJHPSYP7NK2VT5NY6/", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/d13dd30240e32071210f55b587182ff48757ea46"}}