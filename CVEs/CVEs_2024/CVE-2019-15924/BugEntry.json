{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/* Copyright(c) 2013 - 2018 Intel Corporation. */\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/tcp.h>\n#include <linux/if_macvlan.h>\n#include <linux/prefetch.h>\n\n#include \"fm10k.h\"\n\n#define DRV_VERSION\t\"0.26.1-k\"\n#define DRV_SUMMARY\t\"Intel(R) Ethernet Switch Host Interface Driver\"\nconst char fm10k_driver_version[] = DRV_VERSION;\nchar fm10k_driver_name[] = \"fm10k\";\nstatic const char fm10k_driver_string[] = DRV_SUMMARY;\nstatic const char fm10k_copyright[] =\n\t\"Copyright(c) 2013 - 2018 Intel Corporation.\";\n\nMODULE_AUTHOR(\"Intel Corporation, <linux.nics@intel.com>\");\nMODULE_DESCRIPTION(DRV_SUMMARY);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(DRV_VERSION);\n\n/* single workqueue for entire fm10k driver */\nstruct workqueue_struct *fm10k_workqueue;\n\n/**\n * fm10k_init_module - Driver Registration Routine\n *\n * fm10k_init_module is the first routine called when the driver is\n * loaded.  All it does is register with the PCI subsystem.\n **/\nstatic int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\n\t/* create driver workqueue */\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\n\tfm10k_dbg_init();\n\n\treturn fm10k_register_pci_driver();\n}\nmodule_init(fm10k_init_module);\n\n/**\n * fm10k_exit_module - Driver Exit Cleanup Routine\n *\n * fm10k_exit_module is called just before the driver is removed\n * from memory.\n **/\nstatic void __exit fm10k_exit_module(void)\n{\n\tfm10k_unregister_pci_driver();\n\n\tfm10k_dbg_exit();\n\n\t/* destroy driver workqueue */\n\tdestroy_workqueue(fm10k_workqueue);\n}\nmodule_exit(fm10k_exit_module);\n\nstatic bool fm10k_alloc_mapped_page(struct fm10k_ring *rx_ring,\n\t\t\t\t    struct fm10k_rx_buffer *bi)\n{\n\tstruct page *page = bi->page;\n\tdma_addr_t dma;\n\n\t/* Only page will be NULL if buffer was consumed */\n\tif (likely(page))\n\t\treturn true;\n\n\t/* alloc new page for storage */\n\tpage = dev_alloc_page();\n\tif (unlikely(!page)) {\n\t\trx_ring->rx_stats.alloc_failed++;\n\t\treturn false;\n\t}\n\n\t/* map page for use */\n\tdma = dma_map_page(rx_ring->dev, page, 0, PAGE_SIZE, DMA_FROM_DEVICE);\n\n\t/* if mapping failed free memory back to system since\n\t * there isn't much point in holding memory we can't use\n\t */\n\tif (dma_mapping_error(rx_ring->dev, dma)) {\n\t\t__free_page(page);\n\n\t\trx_ring->rx_stats.alloc_failed++;\n\t\treturn false;\n\t}\n\n\tbi->dma = dma;\n\tbi->page = page;\n\tbi->page_offset = 0;\n\n\treturn true;\n}\n\n/**\n * fm10k_alloc_rx_buffers - Replace used receive buffers\n * @rx_ring: ring to place buffers on\n * @cleaned_count: number of buffers to replace\n **/\nvoid fm10k_alloc_rx_buffers(struct fm10k_ring *rx_ring, u16 cleaned_count)\n{\n\tunion fm10k_rx_desc *rx_desc;\n\tstruct fm10k_rx_buffer *bi;\n\tu16 i = rx_ring->next_to_use;\n\n\t/* nothing to do */\n\tif (!cleaned_count)\n\t\treturn;\n\n\trx_desc = FM10K_RX_DESC(rx_ring, i);\n\tbi = &rx_ring->rx_buffer[i];\n\ti -= rx_ring->count;\n\n\tdo {\n\t\tif (!fm10k_alloc_mapped_page(rx_ring, bi))\n\t\t\tbreak;\n\n\t\t/* Refresh the desc even if buffer_addrs didn't change\n\t\t * because each write-back erases this info.\n\t\t */\n\t\trx_desc->q.pkt_addr = cpu_to_le64(bi->dma + bi->page_offset);\n\n\t\trx_desc++;\n\t\tbi++;\n\t\ti++;\n\t\tif (unlikely(!i)) {\n\t\t\trx_desc = FM10K_RX_DESC(rx_ring, 0);\n\t\t\tbi = rx_ring->rx_buffer;\n\t\t\ti -= rx_ring->count;\n\t\t}\n\n\t\t/* clear the status bits for the next_to_use descriptor */\n\t\trx_desc->d.staterr = 0;\n\n\t\tcleaned_count--;\n\t} while (cleaned_count);\n\n\ti += rx_ring->count;\n\n\tif (rx_ring->next_to_use != i) {\n\t\t/* record the next descriptor to use */\n\t\trx_ring->next_to_use = i;\n\n\t\t/* update next to alloc since we have filled the ring */\n\t\trx_ring->next_to_alloc = i;\n\n\t\t/* Force memory writes to complete before letting h/w\n\t\t * know there are new descriptors to fetch.  (Only\n\t\t * applicable for weak-ordered memory model archs,\n\t\t * such as IA-64).\n\t\t */\n\t\twmb();\n\n\t\t/* notify hardware of new descriptors */\n\t\twritel(i, rx_ring->tail);\n\t}\n}\n\n/**\n * fm10k_reuse_rx_page - page flip buffer and store it back on the ring\n * @rx_ring: rx descriptor ring to store buffers on\n * @old_buff: donor buffer to have page reused\n *\n * Synchronizes page for reuse by the interface\n **/\nstatic void fm10k_reuse_rx_page(struct fm10k_ring *rx_ring,\n\t\t\t\tstruct fm10k_rx_buffer *old_buff)\n{\n\tstruct fm10k_rx_buffer *new_buff;\n\tu16 nta = rx_ring->next_to_alloc;\n\n\tnew_buff = &rx_ring->rx_buffer[nta];\n\n\t/* update, and store next to alloc */\n\tnta++;\n\trx_ring->next_to_alloc = (nta < rx_ring->count) ? nta : 0;\n\n\t/* transfer page from old buffer to new buffer */\n\t*new_buff = *old_buff;\n\n\t/* sync the buffer for use by the device */\n\tdma_sync_single_range_for_device(rx_ring->dev, old_buff->dma,\n\t\t\t\t\t old_buff->page_offset,\n\t\t\t\t\t FM10K_RX_BUFSZ,\n\t\t\t\t\t DMA_FROM_DEVICE);\n}\n\nstatic inline bool fm10k_page_is_reserved(struct page *page)\n{\n\treturn (page_to_nid(page) != numa_mem_id()) || page_is_pfmemalloc(page);\n}\n\nstatic bool fm10k_can_reuse_rx_page(struct fm10k_rx_buffer *rx_buffer,\n\t\t\t\t    struct page *page,\n\t\t\t\t    unsigned int __maybe_unused truesize)\n{\n\t/* avoid re-using remote pages */\n\tif (unlikely(fm10k_page_is_reserved(page)))\n\t\treturn false;\n\n#if (PAGE_SIZE < 8192)\n\t/* if we are only owner of page we can reuse it */\n\tif (unlikely(page_count(page) != 1))\n\t\treturn false;\n\n\t/* flip page offset to other buffer */\n\trx_buffer->page_offset ^= FM10K_RX_BUFSZ;\n#else\n\t/* move offset up to the next cache line */\n\trx_buffer->page_offset += truesize;\n\n\tif (rx_buffer->page_offset > (PAGE_SIZE - FM10K_RX_BUFSZ))\n\t\treturn false;\n#endif\n\n\t/* Even if we own the page, we are not allowed to use atomic_set()\n\t * This would break get_page_unless_zero() users.\n\t */\n\tpage_ref_inc(page);\n\n\treturn true;\n}\n\n/**\n * fm10k_add_rx_frag - Add contents of Rx buffer to sk_buff\n * @rx_buffer: buffer containing page to add\n * @size: packet size from rx_desc\n * @rx_desc: descriptor containing length of buffer written by hardware\n * @skb: sk_buff to place the data into\n *\n * This function will add the data contained in rx_buffer->page to the skb.\n * This is done either through a direct copy if the data in the buffer is\n * less than the skb header size, otherwise it will just attach the page as\n * a frag to the skb.\n *\n * The function will then update the page offset if necessary and return\n * true if the buffer can be reused by the interface.\n **/\nstatic bool fm10k_add_rx_frag(struct fm10k_rx_buffer *rx_buffer,\n\t\t\t      unsigned int size,\n\t\t\t      union fm10k_rx_desc *rx_desc,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct page *page = rx_buffer->page;\n\tunsigned char *va = page_address(page) + rx_buffer->page_offset;\n#if (PAGE_SIZE < 8192)\n\tunsigned int truesize = FM10K_RX_BUFSZ;\n#else\n\tunsigned int truesize = ALIGN(size, 512);\n#endif\n\tunsigned int pull_len;\n\n\tif (unlikely(skb_is_nonlinear(skb)))\n\t\tgoto add_tail_frag;\n\n\tif (likely(size <= FM10K_RX_HDR_LEN)) {\n\t\tmemcpy(__skb_put(skb, size), va, ALIGN(size, sizeof(long)));\n\n\t\t/* page is not reserved, we can reuse buffer as-is */\n\t\tif (likely(!fm10k_page_is_reserved(page)))\n\t\t\treturn true;\n\n\t\t/* this page cannot be reused so discard it */\n\t\t__free_page(page);\n\t\treturn false;\n\t}\n\n\t/* we need the header to contain the greater of either ETH_HLEN or\n\t * 60 bytes if the skb->len is less than 60 for skb_pad.\n\t */\n\tpull_len = eth_get_headlen(va, FM10K_RX_HDR_LEN);\n\n\t/* align pull length to size of long to optimize memcpy performance */\n\tmemcpy(__skb_put(skb, pull_len), va, ALIGN(pull_len, sizeof(long)));\n\n\t/* update all of the pointers */\n\tva += pull_len;\n\tsize -= pull_len;\n\nadd_tail_frag:\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,\n\t\t\t(unsigned long)va & ~PAGE_MASK, size, truesize);\n\n\treturn fm10k_can_reuse_rx_page(rx_buffer, page, truesize);\n}\n\nstatic struct sk_buff *fm10k_fetch_rx_buffer(struct fm10k_ring *rx_ring,\n\t\t\t\t\t     union fm10k_rx_desc *rx_desc,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tunsigned int size = le16_to_cpu(rx_desc->w.length);\n\tstruct fm10k_rx_buffer *rx_buffer;\n\tstruct page *page;\n\n\trx_buffer = &rx_ring->rx_buffer[rx_ring->next_to_clean];\n\tpage = rx_buffer->page;\n\tprefetchw(page);\n\n\tif (likely(!skb)) {\n\t\tvoid *page_addr = page_address(page) +\n\t\t\t\t  rx_buffer->page_offset;\n\n\t\t/* prefetch first cache line of first page */\n\t\tprefetch(page_addr);\n#if L1_CACHE_BYTES < 128\n\t\tprefetch(page_addr + L1_CACHE_BYTES);\n#endif\n\n\t\t/* allocate a skb to store the frags */\n\t\tskb = napi_alloc_skb(&rx_ring->q_vector->napi,\n\t\t\t\t     FM10K_RX_HDR_LEN);\n\t\tif (unlikely(!skb)) {\n\t\t\trx_ring->rx_stats.alloc_failed++;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* we will be copying header into skb->data in\n\t\t * pskb_may_pull so it is in our interest to prefetch\n\t\t * it now to avoid a possible cache miss\n\t\t */\n\t\tprefetchw(skb->data);\n\t}\n\n\t/* we are reusing so sync this buffer for CPU use */\n\tdma_sync_single_range_for_cpu(rx_ring->dev,\n\t\t\t\t      rx_buffer->dma,\n\t\t\t\t      rx_buffer->page_offset,\n\t\t\t\t      size,\n\t\t\t\t      DMA_FROM_DEVICE);\n\n\t/* pull page into skb */\n\tif (fm10k_add_rx_frag(rx_buffer, size, rx_desc, skb)) {\n\t\t/* hand second half of page back to the ring */\n\t\tfm10k_reuse_rx_page(rx_ring, rx_buffer);\n\t} else {\n\t\t/* we are not reusing the buffer so unmap it */\n\t\tdma_unmap_page(rx_ring->dev, rx_buffer->dma,\n\t\t\t       PAGE_SIZE, DMA_FROM_DEVICE);\n\t}\n\n\t/* clear contents of rx_buffer */\n\trx_buffer->page = NULL;\n\n\treturn skb;\n}\n\nstatic inline void fm10k_rx_checksum(struct fm10k_ring *ring,\n\t\t\t\t     union fm10k_rx_desc *rx_desc,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tskb_checksum_none_assert(skb);\n\n\t/* Rx checksum disabled via ethtool */\n\tif (!(ring->netdev->features & NETIF_F_RXCSUM))\n\t\treturn;\n\n\t/* TCP/UDP checksum error bit is set */\n\tif (fm10k_test_staterr(rx_desc,\n\t\t\t       FM10K_RXD_STATUS_L4E |\n\t\t\t       FM10K_RXD_STATUS_L4E2 |\n\t\t\t       FM10K_RXD_STATUS_IPE |\n\t\t\t       FM10K_RXD_STATUS_IPE2)) {\n\t\tring->rx_stats.csum_err++;\n\t\treturn;\n\t}\n\n\t/* It must be a TCP or UDP packet with a valid checksum */\n\tif (fm10k_test_staterr(rx_desc, FM10K_RXD_STATUS_L4CS2))\n\t\tskb->encapsulation = true;\n\telse if (!fm10k_test_staterr(rx_desc, FM10K_RXD_STATUS_L4CS))\n\t\treturn;\n\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tring->rx_stats.csum_good++;\n}\n\n#define FM10K_RSS_L4_TYPES_MASK \\\n\t(BIT(FM10K_RSSTYPE_IPV4_TCP) | \\\n\t BIT(FM10K_RSSTYPE_IPV4_UDP) | \\\n\t BIT(FM10K_RSSTYPE_IPV6_TCP) | \\\n\t BIT(FM10K_RSSTYPE_IPV6_UDP))\n\nstatic inline void fm10k_rx_hash(struct fm10k_ring *ring,\n\t\t\t\t union fm10k_rx_desc *rx_desc,\n\t\t\t\t struct sk_buff *skb)\n{\n\tu16 rss_type;\n\n\tif (!(ring->netdev->features & NETIF_F_RXHASH))\n\t\treturn;\n\n\trss_type = le16_to_cpu(rx_desc->w.pkt_info) & FM10K_RXD_RSSTYPE_MASK;\n\tif (!rss_type)\n\t\treturn;\n\n\tskb_set_hash(skb, le32_to_cpu(rx_desc->d.rss),\n\t\t     (BIT(rss_type) & FM10K_RSS_L4_TYPES_MASK) ?\n\t\t     PKT_HASH_TYPE_L4 : PKT_HASH_TYPE_L3);\n}\n\nstatic void fm10k_type_trans(struct fm10k_ring *rx_ring,\n\t\t\t     union fm10k_rx_desc __maybe_unused *rx_desc,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct net_device *dev = rx_ring->netdev;\n\tstruct fm10k_l2_accel *l2_accel = rcu_dereference_bh(rx_ring->l2_accel);\n\n\t/* check to see if DGLORT belongs to a MACVLAN */\n\tif (l2_accel) {\n\t\tu16 idx = le16_to_cpu(FM10K_CB(skb)->fi.w.dglort) - 1;\n\n\t\tidx -= l2_accel->dglort;\n\t\tif (idx < l2_accel->size && l2_accel->macvlan[idx])\n\t\t\tdev = l2_accel->macvlan[idx];\n\t\telse\n\t\t\tl2_accel = NULL;\n\t}\n\n\t/* Record Rx queue, or update macvlan statistics */\n\tif (!l2_accel)\n\t\tskb_record_rx_queue(skb, rx_ring->queue_index);\n\telse\n\t\tmacvlan_count_rx(netdev_priv(dev), skb->len + ETH_HLEN, true,\n\t\t\t\t false);\n\n\tskb->protocol = eth_type_trans(skb, dev);\n}\n\n/**\n * fm10k_process_skb_fields - Populate skb header fields from Rx descriptor\n * @rx_ring: rx descriptor ring packet is being transacted on\n * @rx_desc: pointer to the EOP Rx descriptor\n * @skb: pointer to current skb being populated\n *\n * This function checks the ring, descriptor, and packet information in\n * order to populate the hash, checksum, VLAN, timestamp, protocol, and\n * other fields within the skb.\n **/\nstatic unsigned int fm10k_process_skb_fields(struct fm10k_ring *rx_ring,\n\t\t\t\t\t     union fm10k_rx_desc *rx_desc,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tunsigned int len = skb->len;\n\n\tfm10k_rx_hash(rx_ring, rx_desc, skb);\n\n\tfm10k_rx_checksum(rx_ring, rx_desc, skb);\n\n\tFM10K_CB(skb)->tstamp = rx_desc->q.timestamp;\n\n\tFM10K_CB(skb)->fi.w.vlan = rx_desc->w.vlan;\n\n\tFM10K_CB(skb)->fi.d.glort = rx_desc->d.glort;\n\n\tif (rx_desc->w.vlan) {\n\t\tu16 vid = le16_to_cpu(rx_desc->w.vlan);\n\n\t\tif ((vid & VLAN_VID_MASK) != rx_ring->vid)\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);\n\t\telse if (vid & VLAN_PRIO_MASK)\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t\t       vid & VLAN_PRIO_MASK);\n\t}\n\n\tfm10k_type_trans(rx_ring, rx_desc, skb);\n\n\treturn len;\n}\n\n/**\n * fm10k_is_non_eop - process handling of non-EOP buffers\n * @rx_ring: Rx ring being processed\n * @rx_desc: Rx descriptor for current buffer\n *\n * This function updates next to clean.  If the buffer is an EOP buffer\n * this function exits returning false, otherwise it will place the\n * sk_buff in the next buffer to be chained and return true indicating\n * that this is in fact a non-EOP buffer.\n **/\nstatic bool fm10k_is_non_eop(struct fm10k_ring *rx_ring,\n\t\t\t     union fm10k_rx_desc *rx_desc)\n{\n\tu32 ntc = rx_ring->next_to_clean + 1;\n\n\t/* fetch, update, and store next to clean */\n\tntc = (ntc < rx_ring->count) ? ntc : 0;\n\trx_ring->next_to_clean = ntc;\n\n\tprefetch(FM10K_RX_DESC(rx_ring, ntc));\n\n\tif (likely(fm10k_test_staterr(rx_desc, FM10K_RXD_STATUS_EOP)))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * fm10k_cleanup_headers - Correct corrupted or empty headers\n * @rx_ring: rx descriptor ring packet is being transacted on\n * @rx_desc: pointer to the EOP Rx descriptor\n * @skb: pointer to current skb being fixed\n *\n * Address the case where we are pulling data in on pages only\n * and as such no data is present in the skb header.\n *\n * In addition if skb is not at least 60 bytes we need to pad it so that\n * it is large enough to qualify as a valid Ethernet frame.\n *\n * Returns true if an error was encountered and skb was freed.\n **/\nstatic bool fm10k_cleanup_headers(struct fm10k_ring *rx_ring,\n\t\t\t\t  union fm10k_rx_desc *rx_desc,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tif (unlikely((fm10k_test_staterr(rx_desc,\n\t\t\t\t\t FM10K_RXD_STATUS_RXE)))) {\n#define FM10K_TEST_RXD_BIT(rxd, bit) \\\n\t((rxd)->w.csum_err & cpu_to_le16(bit))\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_SWITCH_ERROR))\n\t\t\trx_ring->rx_stats.switch_errors++;\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_NO_DESCRIPTOR))\n\t\t\trx_ring->rx_stats.drops++;\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_PP_ERROR))\n\t\t\trx_ring->rx_stats.pp_errors++;\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_SWITCH_READY))\n\t\t\trx_ring->rx_stats.link_errors++;\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_TOO_BIG))\n\t\t\trx_ring->rx_stats.length_errors++;\n\t\tdev_kfree_skb_any(skb);\n\t\trx_ring->rx_stats.errors++;\n\t\treturn true;\n\t}\n\n\t/* if eth_skb_pad returns an error the skb was freed */\n\tif (eth_skb_pad(skb))\n\t\treturn true;\n\n\treturn false;\n}\n\n/**\n * fm10k_receive_skb - helper function to handle rx indications\n * @q_vector: structure containing interrupt and ring information\n * @skb: packet to send up\n **/\nstatic void fm10k_receive_skb(struct fm10k_q_vector *q_vector,\n\t\t\t      struct sk_buff *skb)\n{\n\tnapi_gro_receive(&q_vector->napi, skb);\n}\n\nstatic int fm10k_clean_rx_irq(struct fm10k_q_vector *q_vector,\n\t\t\t      struct fm10k_ring *rx_ring,\n\t\t\t      int budget)\n{\n\tstruct sk_buff *skb = rx_ring->skb;\n\tunsigned int total_bytes = 0, total_packets = 0;\n\tu16 cleaned_count = fm10k_desc_unused(rx_ring);\n\n\twhile (likely(total_packets < budget)) {\n\t\tunion fm10k_rx_desc *rx_desc;\n\n\t\t/* return some buffers to hardware, one at a time is too slow */\n\t\tif (cleaned_count >= FM10K_RX_BUFFER_WRITE) {\n\t\t\tfm10k_alloc_rx_buffers(rx_ring, cleaned_count);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\trx_desc = FM10K_RX_DESC(rx_ring, rx_ring->next_to_clean);\n\n\t\tif (!rx_desc->d.staterr)\n\t\t\tbreak;\n\n\t\t/* This memory barrier is needed to keep us from reading\n\t\t * any other fields out of the rx_desc until we know the\n\t\t * descriptor has been written back\n\t\t */\n\t\tdma_rmb();\n\n\t\t/* retrieve a buffer from the ring */\n\t\tskb = fm10k_fetch_rx_buffer(rx_ring, rx_desc, skb);\n\n\t\t/* exit if we failed to retrieve a buffer */\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tcleaned_count++;\n\n\t\t/* fetch next buffer in frame if non-eop */\n\t\tif (fm10k_is_non_eop(rx_ring, rx_desc))\n\t\t\tcontinue;\n\n\t\t/* verify the packet layout is correct */\n\t\tif (fm10k_cleanup_headers(rx_ring, rx_desc, skb)) {\n\t\t\tskb = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* populate checksum, timestamp, VLAN, and protocol */\n\t\ttotal_bytes += fm10k_process_skb_fields(rx_ring, rx_desc, skb);\n\n\t\tfm10k_receive_skb(q_vector, skb);\n\n\t\t/* reset skb pointer */\n\t\tskb = NULL;\n\n\t\t/* update budget accounting */\n\t\ttotal_packets++;\n\t}\n\n\t/* place incomplete frames back on ring for completion */\n\trx_ring->skb = skb;\n\n\tu64_stats_update_begin(&rx_ring->syncp);\n\trx_ring->stats.packets += total_packets;\n\trx_ring->stats.bytes += total_bytes;\n\tu64_stats_update_end(&rx_ring->syncp);\n\tq_vector->rx.total_packets += total_packets;\n\tq_vector->rx.total_bytes += total_bytes;\n\n\treturn total_packets;\n}\n\n#define VXLAN_HLEN (sizeof(struct udphdr) + 8)\nstatic struct ethhdr *fm10k_port_is_vxlan(struct sk_buff *skb)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(skb->dev);\n\tstruct fm10k_udp_port *vxlan_port;\n\n\t/* we can only offload a vxlan if we recognize it as such */\n\tvxlan_port = list_first_entry_or_null(&interface->vxlan_port,\n\t\t\t\t\t      struct fm10k_udp_port, list);\n\n\tif (!vxlan_port)\n\t\treturn NULL;\n\tif (vxlan_port->port != udp_hdr(skb)->dest)\n\t\treturn NULL;\n\n\t/* return offset of udp_hdr plus 8 bytes for VXLAN header */\n\treturn (struct ethhdr *)(skb_transport_header(skb) + VXLAN_HLEN);\n}\n\n#define FM10K_NVGRE_RESERVED0_FLAGS htons(0x9FFF)\n#define NVGRE_TNI htons(0x2000)\nstruct fm10k_nvgre_hdr {\n\t__be16 flags;\n\t__be16 proto;\n\t__be32 tni;\n};\n\nstatic struct ethhdr *fm10k_gre_is_nvgre(struct sk_buff *skb)\n{\n\tstruct fm10k_nvgre_hdr *nvgre_hdr;\n\tint hlen = ip_hdrlen(skb);\n\n\t/* currently only IPv4 is supported due to hlen above */\n\tif (vlan_get_protocol(skb) != htons(ETH_P_IP))\n\t\treturn NULL;\n\n\t/* our transport header should be NVGRE */\n\tnvgre_hdr = (struct fm10k_nvgre_hdr *)(skb_network_header(skb) + hlen);\n\n\t/* verify all reserved flags are 0 */\n\tif (nvgre_hdr->flags & FM10K_NVGRE_RESERVED0_FLAGS)\n\t\treturn NULL;\n\n\t/* report start of ethernet header */\n\tif (nvgre_hdr->flags & NVGRE_TNI)\n\t\treturn (struct ethhdr *)(nvgre_hdr + 1);\n\n\treturn (struct ethhdr *)(&nvgre_hdr->tni);\n}\n\n__be16 fm10k_tx_encap_offload(struct sk_buff *skb)\n{\n\tu8 l4_hdr = 0, inner_l4_hdr = 0, inner_l4_hlen;\n\tstruct ethhdr *eth_hdr;\n\n\tif (skb->inner_protocol_type != ENCAP_TYPE_ETHER ||\n\t    skb->inner_protocol != htons(ETH_P_TEB))\n\t\treturn 0;\n\n\tswitch (vlan_get_protocol(skb)) {\n\tcase htons(ETH_P_IP):\n\t\tl4_hdr = ip_hdr(skb)->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tl4_hdr = ipv6_hdr(skb)->nexthdr;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tswitch (l4_hdr) {\n\tcase IPPROTO_UDP:\n\t\teth_hdr = fm10k_port_is_vxlan(skb);\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\teth_hdr = fm10k_gre_is_nvgre(skb);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (!eth_hdr)\n\t\treturn 0;\n\n\tswitch (eth_hdr->h_proto) {\n\tcase htons(ETH_P_IP):\n\t\tinner_l4_hdr = inner_ip_hdr(skb)->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tinner_l4_hdr = inner_ipv6_hdr(skb)->nexthdr;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tswitch (inner_l4_hdr) {\n\tcase IPPROTO_TCP:\n\t\tinner_l4_hlen = inner_tcp_hdrlen(skb);\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tinner_l4_hlen = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t/* The hardware allows tunnel offloads only if the combined inner and\n\t * outer header is 184 bytes or less\n\t */\n\tif (skb_inner_transport_header(skb) + inner_l4_hlen -\n\t    skb_mac_header(skb) > FM10K_TUNNEL_HEADER_LENGTH)\n\t\treturn 0;\n\n\treturn eth_hdr->h_proto;\n}\n\nstatic int fm10k_tso(struct fm10k_ring *tx_ring,\n\t\t     struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_desc *tx_desc;\n\tunsigned char *th;\n\tu8 hdrlen;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn 0;\n\n\tif (!skb_is_gso(skb))\n\t\treturn 0;\n\n\t/* compute header lengths */\n\tif (skb->encapsulation) {\n\t\tif (!fm10k_tx_encap_offload(skb))\n\t\t\tgoto err_vxlan;\n\t\tth = skb_inner_transport_header(skb);\n\t} else {\n\t\tth = skb_transport_header(skb);\n\t}\n\n\t/* compute offset from SOF to transport header and add header len */\n\thdrlen = (th - skb->data) + (((struct tcphdr *)th)->doff << 2);\n\n\tfirst->tx_flags |= FM10K_TX_FLAGS_CSUM;\n\n\t/* update gso size and bytecount with header size */\n\tfirst->gso_segs = skb_shinfo(skb)->gso_segs;\n\tfirst->bytecount += (first->gso_segs - 1) * hdrlen;\n\n\t/* populate Tx descriptor header size and mss */\n\ttx_desc = FM10K_TX_DESC(tx_ring, tx_ring->next_to_use);\n\ttx_desc->hdrlen = hdrlen;\n\ttx_desc->mss = cpu_to_le16(skb_shinfo(skb)->gso_size);\n\n\treturn 1;\n\nerr_vxlan:\n\ttx_ring->netdev->features &= ~NETIF_F_GSO_UDP_TUNNEL;\n\tif (net_ratelimit())\n\t\tnetdev_err(tx_ring->netdev,\n\t\t\t   \"TSO requested for unsupported tunnel, disabling offload\\n\");\n\treturn -1;\n}\n\nstatic void fm10k_tx_csum(struct fm10k_ring *tx_ring,\n\t\t\t  struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_desc *tx_desc;\n\tunion {\n\t\tstruct iphdr *ipv4;\n\t\tstruct ipv6hdr *ipv6;\n\t\tu8 *raw;\n\t} network_hdr;\n\tu8 *transport_hdr;\n\t__be16 frag_off;\n\t__be16 protocol;\n\tu8 l4_hdr = 0;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\tgoto no_csum;\n\n\tif (skb->encapsulation) {\n\t\tprotocol = fm10k_tx_encap_offload(skb);\n\t\tif (!protocol) {\n\t\t\tif (skb_checksum_help(skb)) {\n\t\t\t\tdev_warn(tx_ring->dev,\n\t\t\t\t\t \"failed to offload encap csum!\\n\");\n\t\t\t\ttx_ring->tx_stats.csum_err++;\n\t\t\t}\n\t\t\tgoto no_csum;\n\t\t}\n\t\tnetwork_hdr.raw = skb_inner_network_header(skb);\n\t\ttransport_hdr = skb_inner_transport_header(skb);\n\t} else {\n\t\tprotocol = vlan_get_protocol(skb);\n\t\tnetwork_hdr.raw = skb_network_header(skb);\n\t\ttransport_hdr = skb_transport_header(skb);\n\t}\n\n\tswitch (protocol) {\n\tcase htons(ETH_P_IP):\n\t\tl4_hdr = network_hdr.ipv4->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tl4_hdr = network_hdr.ipv6->nexthdr;\n\t\tif (likely((transport_hdr - network_hdr.raw) ==\n\t\t\t   sizeof(struct ipv6hdr)))\n\t\t\tbreak;\n\t\tipv6_skip_exthdr(skb, network_hdr.raw - skb->data +\n\t\t\t\t      sizeof(struct ipv6hdr),\n\t\t\t\t &l4_hdr, &frag_off);\n\t\tif (unlikely(frag_off))\n\t\t\tl4_hdr = NEXTHDR_FRAGMENT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (l4_hdr) {\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\tif (skb->encapsulation)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tif (unlikely(net_ratelimit())) {\n\t\t\tdev_warn(tx_ring->dev,\n\t\t\t\t \"partial checksum, version=%d l4 proto=%x\\n\",\n\t\t\t\t protocol, l4_hdr);\n\t\t}\n\t\tskb_checksum_help(skb);\n\t\ttx_ring->tx_stats.csum_err++;\n\t\tgoto no_csum;\n\t}\n\n\t/* update TX checksum flag */\n\tfirst->tx_flags |= FM10K_TX_FLAGS_CSUM;\n\ttx_ring->tx_stats.csum_good++;\n\nno_csum:\n\t/* populate Tx descriptor header size and mss */\n\ttx_desc = FM10K_TX_DESC(tx_ring, tx_ring->next_to_use);\n\ttx_desc->hdrlen = 0;\n\ttx_desc->mss = 0;\n}\n\n#define FM10K_SET_FLAG(_input, _flag, _result) \\\n\t((_flag <= _result) ? \\\n\t ((u32)(_input & _flag) * (_result / _flag)) : \\\n\t ((u32)(_input & _flag) / (_flag / _result)))\n\nstatic u8 fm10k_tx_desc_flags(struct sk_buff *skb, u32 tx_flags)\n{\n\t/* set type for advanced descriptor with frame checksum insertion */\n\tu32 desc_flags = 0;\n\n\t/* set checksum offload bits */\n\tdesc_flags |= FM10K_SET_FLAG(tx_flags, FM10K_TX_FLAGS_CSUM,\n\t\t\t\t     FM10K_TXD_FLAG_CSUM);\n\n\treturn desc_flags;\n}\n\nstatic bool fm10k_tx_desc_push(struct fm10k_ring *tx_ring,\n\t\t\t       struct fm10k_tx_desc *tx_desc, u16 i,\n\t\t\t       dma_addr_t dma, unsigned int size, u8 desc_flags)\n{\n\t/* set RS and INT for last frame in a cache line */\n\tif ((++i & (FM10K_TXD_WB_FIFO_SIZE - 1)) == 0)\n\t\tdesc_flags |= FM10K_TXD_FLAG_RS | FM10K_TXD_FLAG_INT;\n\n\t/* record values to descriptor */\n\ttx_desc->buffer_addr = cpu_to_le64(dma);\n\ttx_desc->flags = desc_flags;\n\ttx_desc->buflen = cpu_to_le16(size);\n\n\t/* return true if we just wrapped the ring */\n\treturn i == tx_ring->count;\n}\n\nstatic int __fm10k_maybe_stop_tx(struct fm10k_ring *tx_ring, u16 size)\n{\n\tnetif_stop_subqueue(tx_ring->netdev, tx_ring->queue_index);\n\n\t/* Memory barrier before checking head and tail */\n\tsmp_mb();\n\n\t/* Check again in a case another CPU has just made room available */\n\tif (likely(fm10k_desc_unused(tx_ring) < size))\n\t\treturn -EBUSY;\n\n\t/* A reprieve! - use start_queue because it doesn't call schedule */\n\tnetif_start_subqueue(tx_ring->netdev, tx_ring->queue_index);\n\t++tx_ring->tx_stats.restart_queue;\n\treturn 0;\n}\n\nstatic inline int fm10k_maybe_stop_tx(struct fm10k_ring *tx_ring, u16 size)\n{\n\tif (likely(fm10k_desc_unused(tx_ring) >= size))\n\t\treturn 0;\n\treturn __fm10k_maybe_stop_tx(tx_ring, size);\n}\n\nstatic void fm10k_tx_map(struct fm10k_ring *tx_ring,\n\t\t\t struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_buffer *tx_buffer;\n\tstruct fm10k_tx_desc *tx_desc;\n\tstruct skb_frag_struct *frag;\n\tunsigned char *data;\n\tdma_addr_t dma;\n\tunsigned int data_len, size;\n\tu32 tx_flags = first->tx_flags;\n\tu16 i = tx_ring->next_to_use;\n\tu8 flags = fm10k_tx_desc_flags(skb, tx_flags);\n\n\ttx_desc = FM10K_TX_DESC(tx_ring, i);\n\n\t/* add HW VLAN tag */\n\tif (skb_vlan_tag_present(skb))\n\t\ttx_desc->vlan = cpu_to_le16(skb_vlan_tag_get(skb));\n\telse\n\t\ttx_desc->vlan = 0;\n\n\tsize = skb_headlen(skb);\n\tdata = skb->data;\n\n\tdma = dma_map_single(tx_ring->dev, data, size, DMA_TO_DEVICE);\n\n\tdata_len = skb->data_len;\n\ttx_buffer = first;\n\n\tfor (frag = &skb_shinfo(skb)->frags[0];; frag++) {\n\t\tif (dma_mapping_error(tx_ring->dev, dma))\n\t\t\tgoto dma_error;\n\n\t\t/* record length, and DMA address */\n\t\tdma_unmap_len_set(tx_buffer, len, size);\n\t\tdma_unmap_addr_set(tx_buffer, dma, dma);\n\n\t\twhile (unlikely(size > FM10K_MAX_DATA_PER_TXD)) {\n\t\t\tif (fm10k_tx_desc_push(tx_ring, tx_desc++, i++, dma,\n\t\t\t\t\t       FM10K_MAX_DATA_PER_TXD, flags)) {\n\t\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\t\ti = 0;\n\t\t\t}\n\n\t\t\tdma += FM10K_MAX_DATA_PER_TXD;\n\t\t\tsize -= FM10K_MAX_DATA_PER_TXD;\n\t\t}\n\n\t\tif (likely(!data_len))\n\t\t\tbreak;\n\n\t\tif (fm10k_tx_desc_push(tx_ring, tx_desc++, i++,\n\t\t\t\t       dma, size, flags)) {\n\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\ti = 0;\n\t\t}\n\n\t\tsize = skb_frag_size(frag);\n\t\tdata_len -= size;\n\n\t\tdma = skb_frag_dma_map(tx_ring->dev, frag, 0, size,\n\t\t\t\t       DMA_TO_DEVICE);\n\n\t\ttx_buffer = &tx_ring->tx_buffer[i];\n\t}\n\n\t/* write last descriptor with LAST bit set */\n\tflags |= FM10K_TXD_FLAG_LAST;\n\n\tif (fm10k_tx_desc_push(tx_ring, tx_desc, i++, dma, size, flags))\n\t\ti = 0;\n\n\t/* record bytecount for BQL */\n\tnetdev_tx_sent_queue(txring_txq(tx_ring), first->bytecount);\n\n\t/* record SW timestamp if HW timestamp is not available */\n\tskb_tx_timestamp(first->skb);\n\n\t/* Force memory writes to complete before letting h/w know there\n\t * are new descriptors to fetch.  (Only applicable for weak-ordered\n\t * memory model archs, such as IA-64).\n\t *\n\t * We also need this memory barrier to make certain all of the\n\t * status bits have been updated before next_to_watch is written.\n\t */\n\twmb();\n\n\t/* set next_to_watch value indicating a packet is present */\n\tfirst->next_to_watch = tx_desc;\n\n\ttx_ring->next_to_use = i;\n\n\t/* Make sure there is space in the ring for the next send. */\n\tfm10k_maybe_stop_tx(tx_ring, DESC_NEEDED);\n\n\t/* notify HW of packet */\n\tif (netif_xmit_stopped(txring_txq(tx_ring)) || !skb->xmit_more) {\n\t\twritel(i, tx_ring->tail);\n\n\t\t/* we need this if more than one processor can write to our tail\n\t\t * at a time, it synchronizes IO on IA64/Altix systems\n\t\t */\n\t\tmmiowb();\n\t}\n\n\treturn;\ndma_error:\n\tdev_err(tx_ring->dev, \"TX DMA map failed\\n\");\n\n\t/* clear dma mappings for failed tx_buffer map */\n\tfor (;;) {\n\t\ttx_buffer = &tx_ring->tx_buffer[i];\n\t\tfm10k_unmap_and_free_tx_resource(tx_ring, tx_buffer);\n\t\tif (tx_buffer == first)\n\t\t\tbreak;\n\t\tif (i == 0)\n\t\t\ti = tx_ring->count;\n\t\ti--;\n\t}\n\n\ttx_ring->next_to_use = i;\n}\n\nnetdev_tx_t fm10k_xmit_frame_ring(struct sk_buff *skb,\n\t\t\t\t  struct fm10k_ring *tx_ring)\n{\n\tu16 count = TXD_USE_COUNT(skb_headlen(skb));\n\tstruct fm10k_tx_buffer *first;\n\tunsigned short f;\n\tu32 tx_flags = 0;\n\tint tso;\n\n\t/* need: 1 descriptor per page * PAGE_SIZE/FM10K_MAX_DATA_PER_TXD,\n\t *       + 1 desc for skb_headlen/FM10K_MAX_DATA_PER_TXD,\n\t *       + 2 desc gap to keep tail from touching head\n\t * otherwise try next time\n\t */\n\tfor (f = 0; f < skb_shinfo(skb)->nr_frags; f++)\n\t\tcount += TXD_USE_COUNT(skb_shinfo(skb)->frags[f].size);\n\n\tif (fm10k_maybe_stop_tx(tx_ring, count + 3)) {\n\t\ttx_ring->tx_stats.tx_busy++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t/* record the location of the first descriptor for this packet */\n\tfirst = &tx_ring->tx_buffer[tx_ring->next_to_use];\n\tfirst->skb = skb;\n\tfirst->bytecount = max_t(unsigned int, skb->len, ETH_ZLEN);\n\tfirst->gso_segs = 1;\n\n\t/* record initial flags and protocol */\n\tfirst->tx_flags = tx_flags;\n\n\ttso = fm10k_tso(tx_ring, first);\n\tif (tso < 0)\n\t\tgoto out_drop;\n\telse if (!tso)\n\t\tfm10k_tx_csum(tx_ring, first);\n\n\tfm10k_tx_map(tx_ring, first);\n\n\treturn NETDEV_TX_OK;\n\nout_drop:\n\tdev_kfree_skb_any(first->skb);\n\tfirst->skb = NULL;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic u64 fm10k_get_tx_completed(struct fm10k_ring *ring)\n{\n\treturn ring->stats.packets;\n}\n\n/**\n * fm10k_get_tx_pending - how many Tx descriptors not processed\n * @ring: the ring structure\n * @in_sw: is tx_pending being checked in SW or in HW?\n */\nu64 fm10k_get_tx_pending(struct fm10k_ring *ring, bool in_sw)\n{\n\tstruct fm10k_intfc *interface = ring->q_vector->interface;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tu32 head, tail;\n\n\tif (likely(in_sw)) {\n\t\thead = ring->next_to_clean;\n\t\ttail = ring->next_to_use;\n\t} else {\n\t\thead = fm10k_read_reg(hw, FM10K_TDH(ring->reg_idx));\n\t\ttail = fm10k_read_reg(hw, FM10K_TDT(ring->reg_idx));\n\t}\n\n\treturn ((head <= tail) ? tail : tail + ring->count) - head;\n}\n\nbool fm10k_check_tx_hang(struct fm10k_ring *tx_ring)\n{\n\tu32 tx_done = fm10k_get_tx_completed(tx_ring);\n\tu32 tx_done_old = tx_ring->tx_stats.tx_done_old;\n\tu32 tx_pending = fm10k_get_tx_pending(tx_ring, true);\n\n\tclear_check_for_tx_hang(tx_ring);\n\n\t/* Check for a hung queue, but be thorough. This verifies\n\t * that a transmit has been completed since the previous\n\t * check AND there is at least one packet pending. By\n\t * requiring this to fail twice we avoid races with\n\t * clearing the ARMED bit and conditions where we\n\t * run the check_tx_hang logic with a transmit completion\n\t * pending but without time to complete it yet.\n\t */\n\tif (!tx_pending || (tx_done_old != tx_done)) {\n\t\t/* update completed stats and continue */\n\t\ttx_ring->tx_stats.tx_done_old = tx_done;\n\t\t/* reset the countdown */\n\t\tclear_bit(__FM10K_HANG_CHECK_ARMED, tx_ring->state);\n\n\t\treturn false;\n\t}\n\n\t/* make sure it is true for two checks in a row */\n\treturn test_and_set_bit(__FM10K_HANG_CHECK_ARMED, tx_ring->state);\n}\n\n/**\n * fm10k_tx_timeout_reset - initiate reset due to Tx timeout\n * @interface: driver private struct\n **/\nvoid fm10k_tx_timeout_reset(struct fm10k_intfc *interface)\n{\n\t/* Do the reset outside of interrupt context */\n\tif (!test_bit(__FM10K_DOWN, interface->state)) {\n\t\tinterface->tx_timeout_count++;\n\t\tset_bit(FM10K_FLAG_RESET_REQUESTED, interface->flags);\n\t\tfm10k_service_event_schedule(interface);\n\t}\n}\n\n/**\n * fm10k_clean_tx_irq - Reclaim resources after transmit completes\n * @q_vector: structure containing interrupt and ring information\n * @tx_ring: tx ring to clean\n * @napi_budget: Used to determine if we are in netpoll\n **/\nstatic bool fm10k_clean_tx_irq(struct fm10k_q_vector *q_vector,\n\t\t\t       struct fm10k_ring *tx_ring, int napi_budget)\n{\n\tstruct fm10k_intfc *interface = q_vector->interface;\n\tstruct fm10k_tx_buffer *tx_buffer;\n\tstruct fm10k_tx_desc *tx_desc;\n\tunsigned int total_bytes = 0, total_packets = 0;\n\tunsigned int budget = q_vector->tx.work_limit;\n\tunsigned int i = tx_ring->next_to_clean;\n\n\tif (test_bit(__FM10K_DOWN, interface->state))\n\t\treturn true;\n\n\ttx_buffer = &tx_ring->tx_buffer[i];\n\ttx_desc = FM10K_TX_DESC(tx_ring, i);\n\ti -= tx_ring->count;\n\n\tdo {\n\t\tstruct fm10k_tx_desc *eop_desc = tx_buffer->next_to_watch;\n\n\t\t/* if next_to_watch is not set then there is no work pending */\n\t\tif (!eop_desc)\n\t\t\tbreak;\n\n\t\t/* prevent any other reads prior to eop_desc */\n\t\tsmp_rmb();\n\n\t\t/* if DD is not set pending work has not been completed */\n\t\tif (!(eop_desc->flags & FM10K_TXD_FLAG_DONE))\n\t\t\tbreak;\n\n\t\t/* clear next_to_watch to prevent false hangs */\n\t\ttx_buffer->next_to_watch = NULL;\n\n\t\t/* update the statistics for this packet */\n\t\ttotal_bytes += tx_buffer->bytecount;\n\t\ttotal_packets += tx_buffer->gso_segs;\n\n\t\t/* free the skb */\n\t\tnapi_consume_skb(tx_buffer->skb, napi_budget);\n\n\t\t/* unmap skb header data */\n\t\tdma_unmap_single(tx_ring->dev,\n\t\t\t\t dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t dma_unmap_len(tx_buffer, len),\n\t\t\t\t DMA_TO_DEVICE);\n\n\t\t/* clear tx_buffer data */\n\t\ttx_buffer->skb = NULL;\n\t\tdma_unmap_len_set(tx_buffer, len, 0);\n\n\t\t/* unmap remaining buffers */\n\t\twhile (tx_desc != eop_desc) {\n\t\t\ttx_buffer++;\n\t\t\ttx_desc++;\n\t\t\ti++;\n\t\t\tif (unlikely(!i)) {\n\t\t\t\ti -= tx_ring->count;\n\t\t\t\ttx_buffer = tx_ring->tx_buffer;\n\t\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\t}\n\n\t\t\t/* unmap any remaining paged data */\n\t\t\tif (dma_unmap_len(tx_buffer, len)) {\n\t\t\t\tdma_unmap_page(tx_ring->dev,\n\t\t\t\t\t       dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t\t       dma_unmap_len(tx_buffer, len),\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t\t\tdma_unmap_len_set(tx_buffer, len, 0);\n\t\t\t}\n\t\t}\n\n\t\t/* move us one more past the eop_desc for start of next pkt */\n\t\ttx_buffer++;\n\t\ttx_desc++;\n\t\ti++;\n\t\tif (unlikely(!i)) {\n\t\t\ti -= tx_ring->count;\n\t\t\ttx_buffer = tx_ring->tx_buffer;\n\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t}\n\n\t\t/* issue prefetch for next Tx descriptor */\n\t\tprefetch(tx_desc);\n\n\t\t/* update budget accounting */\n\t\tbudget--;\n\t} while (likely(budget));\n\n\ti += tx_ring->count;\n\ttx_ring->next_to_clean = i;\n\tu64_stats_update_begin(&tx_ring->syncp);\n\ttx_ring->stats.bytes += total_bytes;\n\ttx_ring->stats.packets += total_packets;\n\tu64_stats_update_end(&tx_ring->syncp);\n\tq_vector->tx.total_bytes += total_bytes;\n\tq_vector->tx.total_packets += total_packets;\n\n\tif (check_for_tx_hang(tx_ring) && fm10k_check_tx_hang(tx_ring)) {\n\t\t/* schedule immediate reset if we believe we hung */\n\t\tstruct fm10k_hw *hw = &interface->hw;\n\n\t\tnetif_err(interface, drv, tx_ring->netdev,\n\t\t\t  \"Detected Tx Unit Hang\\n\"\n\t\t\t  \"  Tx Queue             <%d>\\n\"\n\t\t\t  \"  TDH, TDT             <%x>, <%x>\\n\"\n\t\t\t  \"  next_to_use          <%x>\\n\"\n\t\t\t  \"  next_to_clean        <%x>\\n\",\n\t\t\t  tx_ring->queue_index,\n\t\t\t  fm10k_read_reg(hw, FM10K_TDH(tx_ring->reg_idx)),\n\t\t\t  fm10k_read_reg(hw, FM10K_TDT(tx_ring->reg_idx)),\n\t\t\t  tx_ring->next_to_use, i);\n\n\t\tnetif_stop_subqueue(tx_ring->netdev,\n\t\t\t\t    tx_ring->queue_index);\n\n\t\tnetif_info(interface, probe, tx_ring->netdev,\n\t\t\t   \"tx hang %d detected on queue %d, resetting interface\\n\",\n\t\t\t   interface->tx_timeout_count + 1,\n\t\t\t   tx_ring->queue_index);\n\n\t\tfm10k_tx_timeout_reset(interface);\n\n\t\t/* the netdev is about to reset, no point in enabling stuff */\n\t\treturn true;\n\t}\n\n\t/* notify netdev of completed buffers */\n\tnetdev_tx_completed_queue(txring_txq(tx_ring),\n\t\t\t\t  total_packets, total_bytes);\n\n#define TX_WAKE_THRESHOLD min_t(u16, FM10K_MIN_TXD - 1, DESC_NEEDED * 2)\n\tif (unlikely(total_packets && netif_carrier_ok(tx_ring->netdev) &&\n\t\t     (fm10k_desc_unused(tx_ring) >= TX_WAKE_THRESHOLD))) {\n\t\t/* Make sure that anybody stopping the queue after this\n\t\t * sees the new next_to_clean.\n\t\t */\n\t\tsmp_mb();\n\t\tif (__netif_subqueue_stopped(tx_ring->netdev,\n\t\t\t\t\t     tx_ring->queue_index) &&\n\t\t    !test_bit(__FM10K_DOWN, interface->state)) {\n\t\t\tnetif_wake_subqueue(tx_ring->netdev,\n\t\t\t\t\t    tx_ring->queue_index);\n\t\t\t++tx_ring->tx_stats.restart_queue;\n\t\t}\n\t}\n\n\treturn !!budget;\n}\n\n/**\n * fm10k_update_itr - update the dynamic ITR value based on packet size\n *\n *      Stores a new ITR value based on strictly on packet size.  The\n *      divisors and thresholds used by this function were determined based\n *      on theoretical maximum wire speed and testing data, in order to\n *      minimize response time while increasing bulk throughput.\n *\n * @ring_container: Container for rings to have ITR updated\n **/\nstatic void fm10k_update_itr(struct fm10k_ring_container *ring_container)\n{\n\tunsigned int avg_wire_size, packets, itr_round;\n\n\t/* Only update ITR if we are using adaptive setting */\n\tif (!ITR_IS_ADAPTIVE(ring_container->itr))\n\t\tgoto clear_counts;\n\n\tpackets = ring_container->total_packets;\n\tif (!packets)\n\t\tgoto clear_counts;\n\n\tavg_wire_size = ring_container->total_bytes / packets;\n\n\t/* The following is a crude approximation of:\n\t *  wmem_default / (size + overhead) = desired_pkts_per_int\n\t *  rate / bits_per_byte / (size + ethernet overhead) = pkt_rate\n\t *  (desired_pkt_rate / pkt_rate) * usecs_per_sec = ITR value\n\t *\n\t * Assuming wmem_default is 212992 and overhead is 640 bytes per\n\t * packet, (256 skb, 64 headroom, 320 shared info), we can reduce the\n\t * formula down to\n\t *\n\t *  (34 * (size + 24)) / (size + 640) = ITR\n\t *\n\t * We first do some math on the packet size and then finally bitshift\n\t * by 8 after rounding up. We also have to account for PCIe link speed\n\t * difference as ITR scales based on this.\n\t */\n\tif (avg_wire_size <= 360) {\n\t\t/* Start at 250K ints/sec and gradually drop to 77K ints/sec */\n\t\tavg_wire_size *= 8;\n\t\tavg_wire_size += 376;\n\t} else if (avg_wire_size <= 1152) {\n\t\t/* 77K ints/sec to 45K ints/sec */\n\t\tavg_wire_size *= 3;\n\t\tavg_wire_size += 2176;\n\t} else if (avg_wire_size <= 1920) {\n\t\t/* 45K ints/sec to 38K ints/sec */\n\t\tavg_wire_size += 4480;\n\t} else {\n\t\t/* plateau at a limit of 38K ints/sec */\n\t\tavg_wire_size = 6656;\n\t}\n\n\t/* Perform final bitshift for division after rounding up to ensure\n\t * that the calculation will never get below a 1. The bit shift\n\t * accounts for changes in the ITR due to PCIe link speed.\n\t */\n\titr_round = READ_ONCE(ring_container->itr_scale) + 8;\n\tavg_wire_size += BIT(itr_round) - 1;\n\tavg_wire_size >>= itr_round;\n\n\t/* write back value and retain adaptive flag */\n\tring_container->itr = avg_wire_size | FM10K_ITR_ADAPTIVE;\n\nclear_counts:\n\tring_container->total_bytes = 0;\n\tring_container->total_packets = 0;\n}\n\nstatic void fm10k_qv_enable(struct fm10k_q_vector *q_vector)\n{\n\t/* Enable auto-mask and clear the current mask */\n\tu32 itr = FM10K_ITR_ENABLE;\n\n\t/* Update Tx ITR */\n\tfm10k_update_itr(&q_vector->tx);\n\n\t/* Update Rx ITR */\n\tfm10k_update_itr(&q_vector->rx);\n\n\t/* Store Tx itr in timer slot 0 */\n\titr |= (q_vector->tx.itr & FM10K_ITR_MAX);\n\n\t/* Shift Rx itr to timer slot 1 */\n\titr |= (q_vector->rx.itr & FM10K_ITR_MAX) << FM10K_ITR_INTERVAL1_SHIFT;\n\n\t/* Write the final value to the ITR register */\n\twritel(itr, q_vector->itr);\n}\n\nstatic int fm10k_poll(struct napi_struct *napi, int budget)\n{\n\tstruct fm10k_q_vector *q_vector =\n\t\t\t       container_of(napi, struct fm10k_q_vector, napi);\n\tstruct fm10k_ring *ring;\n\tint per_ring_budget, work_done = 0;\n\tbool clean_complete = true;\n\n\tfm10k_for_each_ring(ring, q_vector->tx) {\n\t\tif (!fm10k_clean_tx_irq(q_vector, ring, budget))\n\t\t\tclean_complete = false;\n\t}\n\n\t/* Handle case where we are called by netpoll with a budget of 0 */\n\tif (budget <= 0)\n\t\treturn budget;\n\n\t/* attempt to distribute budget to each queue fairly, but don't\n\t * allow the budget to go below 1 because we'll exit polling\n\t */\n\tif (q_vector->rx.count > 1)\n\t\tper_ring_budget = max(budget / q_vector->rx.count, 1);\n\telse\n\t\tper_ring_budget = budget;\n\n\tfm10k_for_each_ring(ring, q_vector->rx) {\n\t\tint work = fm10k_clean_rx_irq(q_vector, ring, per_ring_budget);\n\n\t\twork_done += work;\n\t\tif (work >= per_ring_budget)\n\t\t\tclean_complete = false;\n\t}\n\n\t/* If all work not completed, return budget and keep polling */\n\tif (!clean_complete)\n\t\treturn budget;\n\n\t/* Exit the polling mode, but don't re-enable interrupts if stack might\n\t * poll us due to busy-polling\n\t */\n\tif (likely(napi_complete_done(napi, work_done)))\n\t\tfm10k_qv_enable(q_vector);\n\n\treturn min(work_done, budget - 1);\n}\n\n/**\n * fm10k_set_qos_queues: Allocate queues for a QOS-enabled device\n * @interface: board private structure to initialize\n *\n * When QoS (Quality of Service) is enabled, allocate queues for\n * each traffic class.  If multiqueue isn't available,then abort QoS\n * initialization.\n *\n * This function handles all combinations of Qos and RSS.\n *\n **/\nstatic bool fm10k_set_qos_queues(struct fm10k_intfc *interface)\n{\n\tstruct net_device *dev = interface->netdev;\n\tstruct fm10k_ring_feature *f;\n\tint rss_i, i;\n\tint pcs;\n\n\t/* Map queue offset and counts onto allocated tx queues */\n\tpcs = netdev_get_num_tc(dev);\n\n\tif (pcs <= 1)\n\t\treturn false;\n\n\t/* set QoS mask and indices */\n\tf = &interface->ring_feature[RING_F_QOS];\n\tf->indices = pcs;\n\tf->mask = BIT(fls(pcs - 1)) - 1;\n\n\t/* determine the upper limit for our current DCB mode */\n\trss_i = interface->hw.mac.max_queues / pcs;\n\trss_i = BIT(fls(rss_i) - 1);\n\n\t/* set RSS mask and indices */\n\tf = &interface->ring_feature[RING_F_RSS];\n\trss_i = min_t(u16, rss_i, f->limit);\n\tf->indices = rss_i;\n\tf->mask = BIT(fls(rss_i - 1)) - 1;\n\n\t/* configure pause class to queue mapping */\n\tfor (i = 0; i < pcs; i++)\n\t\tnetdev_set_tc_queue(dev, i, rss_i, rss_i * i);\n\n\tinterface->num_rx_queues = rss_i * pcs;\n\tinterface->num_tx_queues = rss_i * pcs;\n\n\treturn true;\n}\n\n/**\n * fm10k_set_rss_queues: Allocate queues for RSS\n * @interface: board private structure to initialize\n *\n * This is our \"base\" multiqueue mode.  RSS (Receive Side Scaling) will try\n * to allocate one Rx queue per CPU, and if available, one Tx queue per CPU.\n *\n **/\nstatic bool fm10k_set_rss_queues(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_ring_feature *f;\n\tu16 rss_i;\n\n\tf = &interface->ring_feature[RING_F_RSS];\n\trss_i = min_t(u16, interface->hw.mac.max_queues, f->limit);\n\n\t/* record indices and power of 2 mask for RSS */\n\tf->indices = rss_i;\n\tf->mask = BIT(fls(rss_i - 1)) - 1;\n\n\tinterface->num_rx_queues = rss_i;\n\tinterface->num_tx_queues = rss_i;\n\n\treturn true;\n}\n\n/**\n * fm10k_set_num_queues: Allocate queues for device, feature dependent\n * @interface: board private structure to initialize\n *\n * This is the top level queue allocation routine.  The order here is very\n * important, starting with the \"most\" number of features turned on at once,\n * and ending with the smallest set of features.  This way large combinations\n * can be allocated if they're turned on, and smaller combinations are the\n * fallthrough conditions.\n *\n **/\nstatic void fm10k_set_num_queues(struct fm10k_intfc *interface)\n{\n\t/* Attempt to setup QoS and RSS first */\n\tif (fm10k_set_qos_queues(interface))\n\t\treturn;\n\n\t/* If we don't have QoS, just fallback to only RSS. */\n\tfm10k_set_rss_queues(interface);\n}\n\n/**\n * fm10k_reset_num_queues - Reset the number of queues to zero\n * @interface: board private structure\n *\n * This function should be called whenever we need to reset the number of\n * queues after an error condition.\n */\nstatic void fm10k_reset_num_queues(struct fm10k_intfc *interface)\n{\n\tinterface->num_tx_queues = 0;\n\tinterface->num_rx_queues = 0;\n\tinterface->num_q_vectors = 0;\n}\n\n/**\n * fm10k_alloc_q_vector - Allocate memory for a single interrupt vector\n * @interface: board private structure to initialize\n * @v_count: q_vectors allocated on interface, used for ring interleaving\n * @v_idx: index of vector in interface struct\n * @txr_count: total number of Tx rings to allocate\n * @txr_idx: index of first Tx ring to allocate\n * @rxr_count: total number of Rx rings to allocate\n * @rxr_idx: index of first Rx ring to allocate\n *\n * We allocate one q_vector.  If allocation fails we return -ENOMEM.\n **/\nstatic int fm10k_alloc_q_vector(struct fm10k_intfc *interface,\n\t\t\t\tunsigned int v_count, unsigned int v_idx,\n\t\t\t\tunsigned int txr_count, unsigned int txr_idx,\n\t\t\t\tunsigned int rxr_count, unsigned int rxr_idx)\n{\n\tstruct fm10k_q_vector *q_vector;\n\tstruct fm10k_ring *ring;\n\tint ring_count;\n\n\tring_count = txr_count + rxr_count;\n\n\t/* allocate q_vector and rings */\n\tq_vector = kzalloc(struct_size(q_vector, ring, ring_count), GFP_KERNEL);\n\tif (!q_vector)\n\t\treturn -ENOMEM;\n\n\t/* initialize NAPI */\n\tnetif_napi_add(interface->netdev, &q_vector->napi,\n\t\t       fm10k_poll, NAPI_POLL_WEIGHT);\n\n\t/* tie q_vector and interface together */\n\tinterface->q_vector[v_idx] = q_vector;\n\tq_vector->interface = interface;\n\tq_vector->v_idx = v_idx;\n\n\t/* initialize pointer to rings */\n\tring = q_vector->ring;\n\n\t/* save Tx ring container info */\n\tq_vector->tx.ring = ring;\n\tq_vector->tx.work_limit = FM10K_DEFAULT_TX_WORK;\n\tq_vector->tx.itr = interface->tx_itr;\n\tq_vector->tx.itr_scale = interface->hw.mac.itr_scale;\n\tq_vector->tx.count = txr_count;\n\n\twhile (txr_count) {\n\t\t/* assign generic ring traits */\n\t\tring->dev = &interface->pdev->dev;\n\t\tring->netdev = interface->netdev;\n\n\t\t/* configure backlink on ring */\n\t\tring->q_vector = q_vector;\n\n\t\t/* apply Tx specific ring traits */\n\t\tring->count = interface->tx_ring_count;\n\t\tring->queue_index = txr_idx;\n\n\t\t/* assign ring to interface */\n\t\tinterface->tx_ring[txr_idx] = ring;\n\n\t\t/* update count and index */\n\t\ttxr_count--;\n\t\ttxr_idx += v_count;\n\n\t\t/* push pointer to next ring */\n\t\tring++;\n\t}\n\n\t/* save Rx ring container info */\n\tq_vector->rx.ring = ring;\n\tq_vector->rx.itr = interface->rx_itr;\n\tq_vector->rx.itr_scale = interface->hw.mac.itr_scale;\n\tq_vector->rx.count = rxr_count;\n\n\twhile (rxr_count) {\n\t\t/* assign generic ring traits */\n\t\tring->dev = &interface->pdev->dev;\n\t\tring->netdev = interface->netdev;\n\t\trcu_assign_pointer(ring->l2_accel, interface->l2_accel);\n\n\t\t/* configure backlink on ring */\n\t\tring->q_vector = q_vector;\n\n\t\t/* apply Rx specific ring traits */\n\t\tring->count = interface->rx_ring_count;\n\t\tring->queue_index = rxr_idx;\n\n\t\t/* assign ring to interface */\n\t\tinterface->rx_ring[rxr_idx] = ring;\n\n\t\t/* update count and index */\n\t\trxr_count--;\n\t\trxr_idx += v_count;\n\n\t\t/* push pointer to next ring */\n\t\tring++;\n\t}\n\n\tfm10k_dbg_q_vector_init(q_vector);\n\n\treturn 0;\n}\n\n/**\n * fm10k_free_q_vector - Free memory allocated for specific interrupt vector\n * @interface: board private structure to initialize\n * @v_idx: Index of vector to be freed\n *\n * This function frees the memory allocated to the q_vector.  In addition if\n * NAPI is enabled it will delete any references to the NAPI struct prior\n * to freeing the q_vector.\n **/\nstatic void fm10k_free_q_vector(struct fm10k_intfc *interface, int v_idx)\n{\n\tstruct fm10k_q_vector *q_vector = interface->q_vector[v_idx];\n\tstruct fm10k_ring *ring;\n\n\tfm10k_dbg_q_vector_exit(q_vector);\n\n\tfm10k_for_each_ring(ring, q_vector->tx)\n\t\tinterface->tx_ring[ring->queue_index] = NULL;\n\n\tfm10k_for_each_ring(ring, q_vector->rx)\n\t\tinterface->rx_ring[ring->queue_index] = NULL;\n\n\tinterface->q_vector[v_idx] = NULL;\n\tnetif_napi_del(&q_vector->napi);\n\tkfree_rcu(q_vector, rcu);\n}\n\n/**\n * fm10k_alloc_q_vectors - Allocate memory for interrupt vectors\n * @interface: board private structure to initialize\n *\n * We allocate one q_vector per queue interrupt.  If allocation fails we\n * return -ENOMEM.\n **/\nstatic int fm10k_alloc_q_vectors(struct fm10k_intfc *interface)\n{\n\tunsigned int q_vectors = interface->num_q_vectors;\n\tunsigned int rxr_remaining = interface->num_rx_queues;\n\tunsigned int txr_remaining = interface->num_tx_queues;\n\tunsigned int rxr_idx = 0, txr_idx = 0, v_idx = 0;\n\tint err;\n\n\tif (q_vectors >= (rxr_remaining + txr_remaining)) {\n\t\tfor (; rxr_remaining; v_idx++) {\n\t\t\terr = fm10k_alloc_q_vector(interface, q_vectors, v_idx,\n\t\t\t\t\t\t   0, 0, 1, rxr_idx);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\n\t\t\t/* update counts and index */\n\t\t\trxr_remaining--;\n\t\t\trxr_idx++;\n\t\t}\n\t}\n\n\tfor (; v_idx < q_vectors; v_idx++) {\n\t\tint rqpv = DIV_ROUND_UP(rxr_remaining, q_vectors - v_idx);\n\t\tint tqpv = DIV_ROUND_UP(txr_remaining, q_vectors - v_idx);\n\n\t\terr = fm10k_alloc_q_vector(interface, q_vectors, v_idx,\n\t\t\t\t\t   tqpv, txr_idx,\n\t\t\t\t\t   rqpv, rxr_idx);\n\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\t/* update counts and index */\n\t\trxr_remaining -= rqpv;\n\t\ttxr_remaining -= tqpv;\n\t\trxr_idx++;\n\t\ttxr_idx++;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tfm10k_reset_num_queues(interface);\n\n\twhile (v_idx--)\n\t\tfm10k_free_q_vector(interface, v_idx);\n\n\treturn -ENOMEM;\n}\n\n/**\n * fm10k_free_q_vectors - Free memory allocated for interrupt vectors\n * @interface: board private structure to initialize\n *\n * This function frees the memory allocated to the q_vectors.  In addition if\n * NAPI is enabled it will delete any references to the NAPI struct prior\n * to freeing the q_vector.\n **/\nstatic void fm10k_free_q_vectors(struct fm10k_intfc *interface)\n{\n\tint v_idx = interface->num_q_vectors;\n\n\tfm10k_reset_num_queues(interface);\n\n\twhile (v_idx--)\n\t\tfm10k_free_q_vector(interface, v_idx);\n}\n\n/**\n * f10k_reset_msix_capability - reset MSI-X capability\n * @interface: board private structure to initialize\n *\n * Reset the MSI-X capability back to its starting state\n **/\nstatic void fm10k_reset_msix_capability(struct fm10k_intfc *interface)\n{\n\tpci_disable_msix(interface->pdev);\n\tkfree(interface->msix_entries);\n\tinterface->msix_entries = NULL;\n}\n\n/**\n * f10k_init_msix_capability - configure MSI-X capability\n * @interface: board private structure to initialize\n *\n * Attempt to configure the interrupts using the best available\n * capabilities of the hardware and the kernel.\n **/\nstatic int fm10k_init_msix_capability(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint v_budget, vector;\n\n\t/* It's easy to be greedy for MSI-X vectors, but it really\n\t * doesn't do us much good if we have a lot more vectors\n\t * than CPU's.  So let's be conservative and only ask for\n\t * (roughly) the same number of vectors as there are CPU's.\n\t * the default is to use pairs of vectors\n\t */\n\tv_budget = max(interface->num_rx_queues, interface->num_tx_queues);\n\tv_budget = min_t(u16, v_budget, num_online_cpus());\n\n\t/* account for vectors not related to queues */\n\tv_budget += NON_Q_VECTORS(hw);\n\n\t/* At the same time, hardware can only support a maximum of\n\t * hw.mac->max_msix_vectors vectors.  With features\n\t * such as RSS and VMDq, we can easily surpass the number of Rx and Tx\n\t * descriptor queues supported by our device.  Thus, we cap it off in\n\t * those rare cases where the cpu count also exceeds our vector limit.\n\t */\n\tv_budget = min_t(int, v_budget, hw->mac.max_msix_vectors);\n\n\t/* A failure in MSI-X entry allocation is fatal. */\n\tinterface->msix_entries = kcalloc(v_budget, sizeof(struct msix_entry),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!interface->msix_entries)\n\t\treturn -ENOMEM;\n\n\t/* populate entry values */\n\tfor (vector = 0; vector < v_budget; vector++)\n\t\tinterface->msix_entries[vector].entry = vector;\n\n\t/* Attempt to enable MSI-X with requested value */\n\tv_budget = pci_enable_msix_range(interface->pdev,\n\t\t\t\t\t interface->msix_entries,\n\t\t\t\t\t MIN_MSIX_COUNT(hw),\n\t\t\t\t\t v_budget);\n\tif (v_budget < 0) {\n\t\tkfree(interface->msix_entries);\n\t\tinterface->msix_entries = NULL;\n\t\treturn v_budget;\n\t}\n\n\t/* record the number of queues available for q_vectors */\n\tinterface->num_q_vectors = v_budget - NON_Q_VECTORS(hw);\n\n\treturn 0;\n}\n\n/**\n * fm10k_cache_ring_qos - Descriptor ring to register mapping for QoS\n * @interface: Interface structure continaining rings and devices\n *\n * Cache the descriptor ring offsets for Qos\n **/\nstatic bool fm10k_cache_ring_qos(struct fm10k_intfc *interface)\n{\n\tstruct net_device *dev = interface->netdev;\n\tint pc, offset, rss_i, i, q_idx;\n\tu16 pc_stride = interface->ring_feature[RING_F_QOS].mask + 1;\n\tu8 num_pcs = netdev_get_num_tc(dev);\n\n\tif (num_pcs <= 1)\n\t\treturn false;\n\n\trss_i = interface->ring_feature[RING_F_RSS].indices;\n\n\tfor (pc = 0, offset = 0; pc < num_pcs; pc++, offset += rss_i) {\n\t\tq_idx = pc;\n\t\tfor (i = 0; i < rss_i; i++) {\n\t\t\tinterface->tx_ring[offset + i]->reg_idx = q_idx;\n\t\t\tinterface->tx_ring[offset + i]->qos_pc = pc;\n\t\t\tinterface->rx_ring[offset + i]->reg_idx = q_idx;\n\t\t\tinterface->rx_ring[offset + i]->qos_pc = pc;\n\t\t\tq_idx += pc_stride;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * fm10k_cache_ring_rss - Descriptor ring to register mapping for RSS\n * @interface: Interface structure continaining rings and devices\n *\n * Cache the descriptor ring offsets for RSS\n **/\nstatic void fm10k_cache_ring_rss(struct fm10k_intfc *interface)\n{\n\tint i;\n\n\tfor (i = 0; i < interface->num_rx_queues; i++)\n\t\tinterface->rx_ring[i]->reg_idx = i;\n\n\tfor (i = 0; i < interface->num_tx_queues; i++)\n\t\tinterface->tx_ring[i]->reg_idx = i;\n}\n\n/**\n * fm10k_assign_rings - Map rings to network devices\n * @interface: Interface structure containing rings and devices\n *\n * This function is meant to go though and configure both the network\n * devices so that they contain rings, and configure the rings so that\n * they function with their network devices.\n **/\nstatic void fm10k_assign_rings(struct fm10k_intfc *interface)\n{\n\tif (fm10k_cache_ring_qos(interface))\n\t\treturn;\n\n\tfm10k_cache_ring_rss(interface);\n}\n\nstatic void fm10k_init_reta(struct fm10k_intfc *interface)\n{\n\tu16 i, rss_i = interface->ring_feature[RING_F_RSS].indices;\n\tu32 reta;\n\n\t/* If the Rx flow indirection table has been configured manually, we\n\t * need to maintain it when possible.\n\t */\n\tif (netif_is_rxfh_configured(interface->netdev)) {\n\t\tfor (i = FM10K_RETA_SIZE; i--;) {\n\t\t\treta = interface->reta[i];\n\t\t\tif ((((reta << 24) >> 24) < rss_i) &&\n\t\t\t    (((reta << 16) >> 24) < rss_i) &&\n\t\t\t    (((reta <<  8) >> 24) < rss_i) &&\n\t\t\t    (((reta)       >> 24) < rss_i))\n\t\t\t\tcontinue;\n\n\t\t\t/* this should never happen */\n\t\t\tdev_err(&interface->pdev->dev,\n\t\t\t\t\"RSS indirection table assigned flows out of queue bounds. Reconfiguring.\\n\");\n\t\t\tgoto repopulate_reta;\n\t\t}\n\n\t\t/* do nothing if all of the elements are in bounds */\n\t\treturn;\n\t}\n\nrepopulate_reta:\n\tfm10k_write_reta(interface, NULL);\n}\n\n/**\n * fm10k_init_queueing_scheme - Determine proper queueing scheme\n * @interface: board private structure to initialize\n *\n * We determine which queueing scheme to use based on...\n * - Hardware queue count (num_*_queues)\n *   - defined by miscellaneous hardware support/features (RSS, etc.)\n **/\nint fm10k_init_queueing_scheme(struct fm10k_intfc *interface)\n{\n\tint err;\n\n\t/* Number of supported queues */\n\tfm10k_set_num_queues(interface);\n\n\t/* Configure MSI-X capability */\n\terr = fm10k_init_msix_capability(interface);\n\tif (err) {\n\t\tdev_err(&interface->pdev->dev,\n\t\t\t\"Unable to initialize MSI-X capability\\n\");\n\t\tgoto err_init_msix;\n\t}\n\n\t/* Allocate memory for queues */\n\terr = fm10k_alloc_q_vectors(interface);\n\tif (err) {\n\t\tdev_err(&interface->pdev->dev,\n\t\t\t\"Unable to allocate queue vectors\\n\");\n\t\tgoto err_alloc_q_vectors;\n\t}\n\n\t/* Map rings to devices, and map devices to physical queues */\n\tfm10k_assign_rings(interface);\n\n\t/* Initialize RSS redirection table */\n\tfm10k_init_reta(interface);\n\n\treturn 0;\n\nerr_alloc_q_vectors:\n\tfm10k_reset_msix_capability(interface);\nerr_init_msix:\n\tfm10k_reset_num_queues(interface);\n\treturn err;\n}\n\n/**\n * fm10k_clear_queueing_scheme - Clear the current queueing scheme settings\n * @interface: board private structure to clear queueing scheme on\n *\n * We go through and clear queueing specific resources and reset the structure\n * to pre-load conditions\n **/\nvoid fm10k_clear_queueing_scheme(struct fm10k_intfc *interface)\n{\n\tfm10k_free_q_vectors(interface);\n\tfm10k_reset_msix_capability(interface);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/* Copyright(c) 2013 - 2018 Intel Corporation. */\n\n#include <linux/types.h>\n#include <linux/module.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/tcp.h>\n#include <linux/if_macvlan.h>\n#include <linux/prefetch.h>\n\n#include \"fm10k.h\"\n\n#define DRV_VERSION\t\"0.26.1-k\"\n#define DRV_SUMMARY\t\"Intel(R) Ethernet Switch Host Interface Driver\"\nconst char fm10k_driver_version[] = DRV_VERSION;\nchar fm10k_driver_name[] = \"fm10k\";\nstatic const char fm10k_driver_string[] = DRV_SUMMARY;\nstatic const char fm10k_copyright[] =\n\t\"Copyright(c) 2013 - 2018 Intel Corporation.\";\n\nMODULE_AUTHOR(\"Intel Corporation, <linux.nics@intel.com>\");\nMODULE_DESCRIPTION(DRV_SUMMARY);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_VERSION(DRV_VERSION);\n\n/* single workqueue for entire fm10k driver */\nstruct workqueue_struct *fm10k_workqueue;\n\n/**\n * fm10k_init_module - Driver Registration Routine\n *\n * fm10k_init_module is the first routine called when the driver is\n * loaded.  All it does is register with the PCI subsystem.\n **/\nstatic int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\n\t/* create driver workqueue */\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\tif (!fm10k_workqueue)\n\t\treturn -ENOMEM;\n\n\tfm10k_dbg_init();\n\n\treturn fm10k_register_pci_driver();\n}\nmodule_init(fm10k_init_module);\n\n/**\n * fm10k_exit_module - Driver Exit Cleanup Routine\n *\n * fm10k_exit_module is called just before the driver is removed\n * from memory.\n **/\nstatic void __exit fm10k_exit_module(void)\n{\n\tfm10k_unregister_pci_driver();\n\n\tfm10k_dbg_exit();\n\n\t/* destroy driver workqueue */\n\tdestroy_workqueue(fm10k_workqueue);\n}\nmodule_exit(fm10k_exit_module);\n\nstatic bool fm10k_alloc_mapped_page(struct fm10k_ring *rx_ring,\n\t\t\t\t    struct fm10k_rx_buffer *bi)\n{\n\tstruct page *page = bi->page;\n\tdma_addr_t dma;\n\n\t/* Only page will be NULL if buffer was consumed */\n\tif (likely(page))\n\t\treturn true;\n\n\t/* alloc new page for storage */\n\tpage = dev_alloc_page();\n\tif (unlikely(!page)) {\n\t\trx_ring->rx_stats.alloc_failed++;\n\t\treturn false;\n\t}\n\n\t/* map page for use */\n\tdma = dma_map_page(rx_ring->dev, page, 0, PAGE_SIZE, DMA_FROM_DEVICE);\n\n\t/* if mapping failed free memory back to system since\n\t * there isn't much point in holding memory we can't use\n\t */\n\tif (dma_mapping_error(rx_ring->dev, dma)) {\n\t\t__free_page(page);\n\n\t\trx_ring->rx_stats.alloc_failed++;\n\t\treturn false;\n\t}\n\n\tbi->dma = dma;\n\tbi->page = page;\n\tbi->page_offset = 0;\n\n\treturn true;\n}\n\n/**\n * fm10k_alloc_rx_buffers - Replace used receive buffers\n * @rx_ring: ring to place buffers on\n * @cleaned_count: number of buffers to replace\n **/\nvoid fm10k_alloc_rx_buffers(struct fm10k_ring *rx_ring, u16 cleaned_count)\n{\n\tunion fm10k_rx_desc *rx_desc;\n\tstruct fm10k_rx_buffer *bi;\n\tu16 i = rx_ring->next_to_use;\n\n\t/* nothing to do */\n\tif (!cleaned_count)\n\t\treturn;\n\n\trx_desc = FM10K_RX_DESC(rx_ring, i);\n\tbi = &rx_ring->rx_buffer[i];\n\ti -= rx_ring->count;\n\n\tdo {\n\t\tif (!fm10k_alloc_mapped_page(rx_ring, bi))\n\t\t\tbreak;\n\n\t\t/* Refresh the desc even if buffer_addrs didn't change\n\t\t * because each write-back erases this info.\n\t\t */\n\t\trx_desc->q.pkt_addr = cpu_to_le64(bi->dma + bi->page_offset);\n\n\t\trx_desc++;\n\t\tbi++;\n\t\ti++;\n\t\tif (unlikely(!i)) {\n\t\t\trx_desc = FM10K_RX_DESC(rx_ring, 0);\n\t\t\tbi = rx_ring->rx_buffer;\n\t\t\ti -= rx_ring->count;\n\t\t}\n\n\t\t/* clear the status bits for the next_to_use descriptor */\n\t\trx_desc->d.staterr = 0;\n\n\t\tcleaned_count--;\n\t} while (cleaned_count);\n\n\ti += rx_ring->count;\n\n\tif (rx_ring->next_to_use != i) {\n\t\t/* record the next descriptor to use */\n\t\trx_ring->next_to_use = i;\n\n\t\t/* update next to alloc since we have filled the ring */\n\t\trx_ring->next_to_alloc = i;\n\n\t\t/* Force memory writes to complete before letting h/w\n\t\t * know there are new descriptors to fetch.  (Only\n\t\t * applicable for weak-ordered memory model archs,\n\t\t * such as IA-64).\n\t\t */\n\t\twmb();\n\n\t\t/* notify hardware of new descriptors */\n\t\twritel(i, rx_ring->tail);\n\t}\n}\n\n/**\n * fm10k_reuse_rx_page - page flip buffer and store it back on the ring\n * @rx_ring: rx descriptor ring to store buffers on\n * @old_buff: donor buffer to have page reused\n *\n * Synchronizes page for reuse by the interface\n **/\nstatic void fm10k_reuse_rx_page(struct fm10k_ring *rx_ring,\n\t\t\t\tstruct fm10k_rx_buffer *old_buff)\n{\n\tstruct fm10k_rx_buffer *new_buff;\n\tu16 nta = rx_ring->next_to_alloc;\n\n\tnew_buff = &rx_ring->rx_buffer[nta];\n\n\t/* update, and store next to alloc */\n\tnta++;\n\trx_ring->next_to_alloc = (nta < rx_ring->count) ? nta : 0;\n\n\t/* transfer page from old buffer to new buffer */\n\t*new_buff = *old_buff;\n\n\t/* sync the buffer for use by the device */\n\tdma_sync_single_range_for_device(rx_ring->dev, old_buff->dma,\n\t\t\t\t\t old_buff->page_offset,\n\t\t\t\t\t FM10K_RX_BUFSZ,\n\t\t\t\t\t DMA_FROM_DEVICE);\n}\n\nstatic inline bool fm10k_page_is_reserved(struct page *page)\n{\n\treturn (page_to_nid(page) != numa_mem_id()) || page_is_pfmemalloc(page);\n}\n\nstatic bool fm10k_can_reuse_rx_page(struct fm10k_rx_buffer *rx_buffer,\n\t\t\t\t    struct page *page,\n\t\t\t\t    unsigned int __maybe_unused truesize)\n{\n\t/* avoid re-using remote pages */\n\tif (unlikely(fm10k_page_is_reserved(page)))\n\t\treturn false;\n\n#if (PAGE_SIZE < 8192)\n\t/* if we are only owner of page we can reuse it */\n\tif (unlikely(page_count(page) != 1))\n\t\treturn false;\n\n\t/* flip page offset to other buffer */\n\trx_buffer->page_offset ^= FM10K_RX_BUFSZ;\n#else\n\t/* move offset up to the next cache line */\n\trx_buffer->page_offset += truesize;\n\n\tif (rx_buffer->page_offset > (PAGE_SIZE - FM10K_RX_BUFSZ))\n\t\treturn false;\n#endif\n\n\t/* Even if we own the page, we are not allowed to use atomic_set()\n\t * This would break get_page_unless_zero() users.\n\t */\n\tpage_ref_inc(page);\n\n\treturn true;\n}\n\n/**\n * fm10k_add_rx_frag - Add contents of Rx buffer to sk_buff\n * @rx_buffer: buffer containing page to add\n * @size: packet size from rx_desc\n * @rx_desc: descriptor containing length of buffer written by hardware\n * @skb: sk_buff to place the data into\n *\n * This function will add the data contained in rx_buffer->page to the skb.\n * This is done either through a direct copy if the data in the buffer is\n * less than the skb header size, otherwise it will just attach the page as\n * a frag to the skb.\n *\n * The function will then update the page offset if necessary and return\n * true if the buffer can be reused by the interface.\n **/\nstatic bool fm10k_add_rx_frag(struct fm10k_rx_buffer *rx_buffer,\n\t\t\t      unsigned int size,\n\t\t\t      union fm10k_rx_desc *rx_desc,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct page *page = rx_buffer->page;\n\tunsigned char *va = page_address(page) + rx_buffer->page_offset;\n#if (PAGE_SIZE < 8192)\n\tunsigned int truesize = FM10K_RX_BUFSZ;\n#else\n\tunsigned int truesize = ALIGN(size, 512);\n#endif\n\tunsigned int pull_len;\n\n\tif (unlikely(skb_is_nonlinear(skb)))\n\t\tgoto add_tail_frag;\n\n\tif (likely(size <= FM10K_RX_HDR_LEN)) {\n\t\tmemcpy(__skb_put(skb, size), va, ALIGN(size, sizeof(long)));\n\n\t\t/* page is not reserved, we can reuse buffer as-is */\n\t\tif (likely(!fm10k_page_is_reserved(page)))\n\t\t\treturn true;\n\n\t\t/* this page cannot be reused so discard it */\n\t\t__free_page(page);\n\t\treturn false;\n\t}\n\n\t/* we need the header to contain the greater of either ETH_HLEN or\n\t * 60 bytes if the skb->len is less than 60 for skb_pad.\n\t */\n\tpull_len = eth_get_headlen(va, FM10K_RX_HDR_LEN);\n\n\t/* align pull length to size of long to optimize memcpy performance */\n\tmemcpy(__skb_put(skb, pull_len), va, ALIGN(pull_len, sizeof(long)));\n\n\t/* update all of the pointers */\n\tva += pull_len;\n\tsize -= pull_len;\n\nadd_tail_frag:\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,\n\t\t\t(unsigned long)va & ~PAGE_MASK, size, truesize);\n\n\treturn fm10k_can_reuse_rx_page(rx_buffer, page, truesize);\n}\n\nstatic struct sk_buff *fm10k_fetch_rx_buffer(struct fm10k_ring *rx_ring,\n\t\t\t\t\t     union fm10k_rx_desc *rx_desc,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tunsigned int size = le16_to_cpu(rx_desc->w.length);\n\tstruct fm10k_rx_buffer *rx_buffer;\n\tstruct page *page;\n\n\trx_buffer = &rx_ring->rx_buffer[rx_ring->next_to_clean];\n\tpage = rx_buffer->page;\n\tprefetchw(page);\n\n\tif (likely(!skb)) {\n\t\tvoid *page_addr = page_address(page) +\n\t\t\t\t  rx_buffer->page_offset;\n\n\t\t/* prefetch first cache line of first page */\n\t\tprefetch(page_addr);\n#if L1_CACHE_BYTES < 128\n\t\tprefetch(page_addr + L1_CACHE_BYTES);\n#endif\n\n\t\t/* allocate a skb to store the frags */\n\t\tskb = napi_alloc_skb(&rx_ring->q_vector->napi,\n\t\t\t\t     FM10K_RX_HDR_LEN);\n\t\tif (unlikely(!skb)) {\n\t\t\trx_ring->rx_stats.alloc_failed++;\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* we will be copying header into skb->data in\n\t\t * pskb_may_pull so it is in our interest to prefetch\n\t\t * it now to avoid a possible cache miss\n\t\t */\n\t\tprefetchw(skb->data);\n\t}\n\n\t/* we are reusing so sync this buffer for CPU use */\n\tdma_sync_single_range_for_cpu(rx_ring->dev,\n\t\t\t\t      rx_buffer->dma,\n\t\t\t\t      rx_buffer->page_offset,\n\t\t\t\t      size,\n\t\t\t\t      DMA_FROM_DEVICE);\n\n\t/* pull page into skb */\n\tif (fm10k_add_rx_frag(rx_buffer, size, rx_desc, skb)) {\n\t\t/* hand second half of page back to the ring */\n\t\tfm10k_reuse_rx_page(rx_ring, rx_buffer);\n\t} else {\n\t\t/* we are not reusing the buffer so unmap it */\n\t\tdma_unmap_page(rx_ring->dev, rx_buffer->dma,\n\t\t\t       PAGE_SIZE, DMA_FROM_DEVICE);\n\t}\n\n\t/* clear contents of rx_buffer */\n\trx_buffer->page = NULL;\n\n\treturn skb;\n}\n\nstatic inline void fm10k_rx_checksum(struct fm10k_ring *ring,\n\t\t\t\t     union fm10k_rx_desc *rx_desc,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tskb_checksum_none_assert(skb);\n\n\t/* Rx checksum disabled via ethtool */\n\tif (!(ring->netdev->features & NETIF_F_RXCSUM))\n\t\treturn;\n\n\t/* TCP/UDP checksum error bit is set */\n\tif (fm10k_test_staterr(rx_desc,\n\t\t\t       FM10K_RXD_STATUS_L4E |\n\t\t\t       FM10K_RXD_STATUS_L4E2 |\n\t\t\t       FM10K_RXD_STATUS_IPE |\n\t\t\t       FM10K_RXD_STATUS_IPE2)) {\n\t\tring->rx_stats.csum_err++;\n\t\treturn;\n\t}\n\n\t/* It must be a TCP or UDP packet with a valid checksum */\n\tif (fm10k_test_staterr(rx_desc, FM10K_RXD_STATUS_L4CS2))\n\t\tskb->encapsulation = true;\n\telse if (!fm10k_test_staterr(rx_desc, FM10K_RXD_STATUS_L4CS))\n\t\treturn;\n\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tring->rx_stats.csum_good++;\n}\n\n#define FM10K_RSS_L4_TYPES_MASK \\\n\t(BIT(FM10K_RSSTYPE_IPV4_TCP) | \\\n\t BIT(FM10K_RSSTYPE_IPV4_UDP) | \\\n\t BIT(FM10K_RSSTYPE_IPV6_TCP) | \\\n\t BIT(FM10K_RSSTYPE_IPV6_UDP))\n\nstatic inline void fm10k_rx_hash(struct fm10k_ring *ring,\n\t\t\t\t union fm10k_rx_desc *rx_desc,\n\t\t\t\t struct sk_buff *skb)\n{\n\tu16 rss_type;\n\n\tif (!(ring->netdev->features & NETIF_F_RXHASH))\n\t\treturn;\n\n\trss_type = le16_to_cpu(rx_desc->w.pkt_info) & FM10K_RXD_RSSTYPE_MASK;\n\tif (!rss_type)\n\t\treturn;\n\n\tskb_set_hash(skb, le32_to_cpu(rx_desc->d.rss),\n\t\t     (BIT(rss_type) & FM10K_RSS_L4_TYPES_MASK) ?\n\t\t     PKT_HASH_TYPE_L4 : PKT_HASH_TYPE_L3);\n}\n\nstatic void fm10k_type_trans(struct fm10k_ring *rx_ring,\n\t\t\t     union fm10k_rx_desc __maybe_unused *rx_desc,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct net_device *dev = rx_ring->netdev;\n\tstruct fm10k_l2_accel *l2_accel = rcu_dereference_bh(rx_ring->l2_accel);\n\n\t/* check to see if DGLORT belongs to a MACVLAN */\n\tif (l2_accel) {\n\t\tu16 idx = le16_to_cpu(FM10K_CB(skb)->fi.w.dglort) - 1;\n\n\t\tidx -= l2_accel->dglort;\n\t\tif (idx < l2_accel->size && l2_accel->macvlan[idx])\n\t\t\tdev = l2_accel->macvlan[idx];\n\t\telse\n\t\t\tl2_accel = NULL;\n\t}\n\n\t/* Record Rx queue, or update macvlan statistics */\n\tif (!l2_accel)\n\t\tskb_record_rx_queue(skb, rx_ring->queue_index);\n\telse\n\t\tmacvlan_count_rx(netdev_priv(dev), skb->len + ETH_HLEN, true,\n\t\t\t\t false);\n\n\tskb->protocol = eth_type_trans(skb, dev);\n}\n\n/**\n * fm10k_process_skb_fields - Populate skb header fields from Rx descriptor\n * @rx_ring: rx descriptor ring packet is being transacted on\n * @rx_desc: pointer to the EOP Rx descriptor\n * @skb: pointer to current skb being populated\n *\n * This function checks the ring, descriptor, and packet information in\n * order to populate the hash, checksum, VLAN, timestamp, protocol, and\n * other fields within the skb.\n **/\nstatic unsigned int fm10k_process_skb_fields(struct fm10k_ring *rx_ring,\n\t\t\t\t\t     union fm10k_rx_desc *rx_desc,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tunsigned int len = skb->len;\n\n\tfm10k_rx_hash(rx_ring, rx_desc, skb);\n\n\tfm10k_rx_checksum(rx_ring, rx_desc, skb);\n\n\tFM10K_CB(skb)->tstamp = rx_desc->q.timestamp;\n\n\tFM10K_CB(skb)->fi.w.vlan = rx_desc->w.vlan;\n\n\tFM10K_CB(skb)->fi.d.glort = rx_desc->d.glort;\n\n\tif (rx_desc->w.vlan) {\n\t\tu16 vid = le16_to_cpu(rx_desc->w.vlan);\n\n\t\tif ((vid & VLAN_VID_MASK) != rx_ring->vid)\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);\n\t\telse if (vid & VLAN_PRIO_MASK)\n\t\t\t__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),\n\t\t\t\t\t       vid & VLAN_PRIO_MASK);\n\t}\n\n\tfm10k_type_trans(rx_ring, rx_desc, skb);\n\n\treturn len;\n}\n\n/**\n * fm10k_is_non_eop - process handling of non-EOP buffers\n * @rx_ring: Rx ring being processed\n * @rx_desc: Rx descriptor for current buffer\n *\n * This function updates next to clean.  If the buffer is an EOP buffer\n * this function exits returning false, otherwise it will place the\n * sk_buff in the next buffer to be chained and return true indicating\n * that this is in fact a non-EOP buffer.\n **/\nstatic bool fm10k_is_non_eop(struct fm10k_ring *rx_ring,\n\t\t\t     union fm10k_rx_desc *rx_desc)\n{\n\tu32 ntc = rx_ring->next_to_clean + 1;\n\n\t/* fetch, update, and store next to clean */\n\tntc = (ntc < rx_ring->count) ? ntc : 0;\n\trx_ring->next_to_clean = ntc;\n\n\tprefetch(FM10K_RX_DESC(rx_ring, ntc));\n\n\tif (likely(fm10k_test_staterr(rx_desc, FM10K_RXD_STATUS_EOP)))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * fm10k_cleanup_headers - Correct corrupted or empty headers\n * @rx_ring: rx descriptor ring packet is being transacted on\n * @rx_desc: pointer to the EOP Rx descriptor\n * @skb: pointer to current skb being fixed\n *\n * Address the case where we are pulling data in on pages only\n * and as such no data is present in the skb header.\n *\n * In addition if skb is not at least 60 bytes we need to pad it so that\n * it is large enough to qualify as a valid Ethernet frame.\n *\n * Returns true if an error was encountered and skb was freed.\n **/\nstatic bool fm10k_cleanup_headers(struct fm10k_ring *rx_ring,\n\t\t\t\t  union fm10k_rx_desc *rx_desc,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tif (unlikely((fm10k_test_staterr(rx_desc,\n\t\t\t\t\t FM10K_RXD_STATUS_RXE)))) {\n#define FM10K_TEST_RXD_BIT(rxd, bit) \\\n\t((rxd)->w.csum_err & cpu_to_le16(bit))\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_SWITCH_ERROR))\n\t\t\trx_ring->rx_stats.switch_errors++;\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_NO_DESCRIPTOR))\n\t\t\trx_ring->rx_stats.drops++;\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_PP_ERROR))\n\t\t\trx_ring->rx_stats.pp_errors++;\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_SWITCH_READY))\n\t\t\trx_ring->rx_stats.link_errors++;\n\t\tif (FM10K_TEST_RXD_BIT(rx_desc, FM10K_RXD_ERR_TOO_BIG))\n\t\t\trx_ring->rx_stats.length_errors++;\n\t\tdev_kfree_skb_any(skb);\n\t\trx_ring->rx_stats.errors++;\n\t\treturn true;\n\t}\n\n\t/* if eth_skb_pad returns an error the skb was freed */\n\tif (eth_skb_pad(skb))\n\t\treturn true;\n\n\treturn false;\n}\n\n/**\n * fm10k_receive_skb - helper function to handle rx indications\n * @q_vector: structure containing interrupt and ring information\n * @skb: packet to send up\n **/\nstatic void fm10k_receive_skb(struct fm10k_q_vector *q_vector,\n\t\t\t      struct sk_buff *skb)\n{\n\tnapi_gro_receive(&q_vector->napi, skb);\n}\n\nstatic int fm10k_clean_rx_irq(struct fm10k_q_vector *q_vector,\n\t\t\t      struct fm10k_ring *rx_ring,\n\t\t\t      int budget)\n{\n\tstruct sk_buff *skb = rx_ring->skb;\n\tunsigned int total_bytes = 0, total_packets = 0;\n\tu16 cleaned_count = fm10k_desc_unused(rx_ring);\n\n\twhile (likely(total_packets < budget)) {\n\t\tunion fm10k_rx_desc *rx_desc;\n\n\t\t/* return some buffers to hardware, one at a time is too slow */\n\t\tif (cleaned_count >= FM10K_RX_BUFFER_WRITE) {\n\t\t\tfm10k_alloc_rx_buffers(rx_ring, cleaned_count);\n\t\t\tcleaned_count = 0;\n\t\t}\n\n\t\trx_desc = FM10K_RX_DESC(rx_ring, rx_ring->next_to_clean);\n\n\t\tif (!rx_desc->d.staterr)\n\t\t\tbreak;\n\n\t\t/* This memory barrier is needed to keep us from reading\n\t\t * any other fields out of the rx_desc until we know the\n\t\t * descriptor has been written back\n\t\t */\n\t\tdma_rmb();\n\n\t\t/* retrieve a buffer from the ring */\n\t\tskb = fm10k_fetch_rx_buffer(rx_ring, rx_desc, skb);\n\n\t\t/* exit if we failed to retrieve a buffer */\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tcleaned_count++;\n\n\t\t/* fetch next buffer in frame if non-eop */\n\t\tif (fm10k_is_non_eop(rx_ring, rx_desc))\n\t\t\tcontinue;\n\n\t\t/* verify the packet layout is correct */\n\t\tif (fm10k_cleanup_headers(rx_ring, rx_desc, skb)) {\n\t\t\tskb = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* populate checksum, timestamp, VLAN, and protocol */\n\t\ttotal_bytes += fm10k_process_skb_fields(rx_ring, rx_desc, skb);\n\n\t\tfm10k_receive_skb(q_vector, skb);\n\n\t\t/* reset skb pointer */\n\t\tskb = NULL;\n\n\t\t/* update budget accounting */\n\t\ttotal_packets++;\n\t}\n\n\t/* place incomplete frames back on ring for completion */\n\trx_ring->skb = skb;\n\n\tu64_stats_update_begin(&rx_ring->syncp);\n\trx_ring->stats.packets += total_packets;\n\trx_ring->stats.bytes += total_bytes;\n\tu64_stats_update_end(&rx_ring->syncp);\n\tq_vector->rx.total_packets += total_packets;\n\tq_vector->rx.total_bytes += total_bytes;\n\n\treturn total_packets;\n}\n\n#define VXLAN_HLEN (sizeof(struct udphdr) + 8)\nstatic struct ethhdr *fm10k_port_is_vxlan(struct sk_buff *skb)\n{\n\tstruct fm10k_intfc *interface = netdev_priv(skb->dev);\n\tstruct fm10k_udp_port *vxlan_port;\n\n\t/* we can only offload a vxlan if we recognize it as such */\n\tvxlan_port = list_first_entry_or_null(&interface->vxlan_port,\n\t\t\t\t\t      struct fm10k_udp_port, list);\n\n\tif (!vxlan_port)\n\t\treturn NULL;\n\tif (vxlan_port->port != udp_hdr(skb)->dest)\n\t\treturn NULL;\n\n\t/* return offset of udp_hdr plus 8 bytes for VXLAN header */\n\treturn (struct ethhdr *)(skb_transport_header(skb) + VXLAN_HLEN);\n}\n\n#define FM10K_NVGRE_RESERVED0_FLAGS htons(0x9FFF)\n#define NVGRE_TNI htons(0x2000)\nstruct fm10k_nvgre_hdr {\n\t__be16 flags;\n\t__be16 proto;\n\t__be32 tni;\n};\n\nstatic struct ethhdr *fm10k_gre_is_nvgre(struct sk_buff *skb)\n{\n\tstruct fm10k_nvgre_hdr *nvgre_hdr;\n\tint hlen = ip_hdrlen(skb);\n\n\t/* currently only IPv4 is supported due to hlen above */\n\tif (vlan_get_protocol(skb) != htons(ETH_P_IP))\n\t\treturn NULL;\n\n\t/* our transport header should be NVGRE */\n\tnvgre_hdr = (struct fm10k_nvgre_hdr *)(skb_network_header(skb) + hlen);\n\n\t/* verify all reserved flags are 0 */\n\tif (nvgre_hdr->flags & FM10K_NVGRE_RESERVED0_FLAGS)\n\t\treturn NULL;\n\n\t/* report start of ethernet header */\n\tif (nvgre_hdr->flags & NVGRE_TNI)\n\t\treturn (struct ethhdr *)(nvgre_hdr + 1);\n\n\treturn (struct ethhdr *)(&nvgre_hdr->tni);\n}\n\n__be16 fm10k_tx_encap_offload(struct sk_buff *skb)\n{\n\tu8 l4_hdr = 0, inner_l4_hdr = 0, inner_l4_hlen;\n\tstruct ethhdr *eth_hdr;\n\n\tif (skb->inner_protocol_type != ENCAP_TYPE_ETHER ||\n\t    skb->inner_protocol != htons(ETH_P_TEB))\n\t\treturn 0;\n\n\tswitch (vlan_get_protocol(skb)) {\n\tcase htons(ETH_P_IP):\n\t\tl4_hdr = ip_hdr(skb)->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tl4_hdr = ipv6_hdr(skb)->nexthdr;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tswitch (l4_hdr) {\n\tcase IPPROTO_UDP:\n\t\teth_hdr = fm10k_port_is_vxlan(skb);\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\teth_hdr = fm10k_gre_is_nvgre(skb);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (!eth_hdr)\n\t\treturn 0;\n\n\tswitch (eth_hdr->h_proto) {\n\tcase htons(ETH_P_IP):\n\t\tinner_l4_hdr = inner_ip_hdr(skb)->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tinner_l4_hdr = inner_ipv6_hdr(skb)->nexthdr;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tswitch (inner_l4_hdr) {\n\tcase IPPROTO_TCP:\n\t\tinner_l4_hlen = inner_tcp_hdrlen(skb);\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tinner_l4_hlen = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t/* The hardware allows tunnel offloads only if the combined inner and\n\t * outer header is 184 bytes or less\n\t */\n\tif (skb_inner_transport_header(skb) + inner_l4_hlen -\n\t    skb_mac_header(skb) > FM10K_TUNNEL_HEADER_LENGTH)\n\t\treturn 0;\n\n\treturn eth_hdr->h_proto;\n}\n\nstatic int fm10k_tso(struct fm10k_ring *tx_ring,\n\t\t     struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_desc *tx_desc;\n\tunsigned char *th;\n\tu8 hdrlen;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn 0;\n\n\tif (!skb_is_gso(skb))\n\t\treturn 0;\n\n\t/* compute header lengths */\n\tif (skb->encapsulation) {\n\t\tif (!fm10k_tx_encap_offload(skb))\n\t\t\tgoto err_vxlan;\n\t\tth = skb_inner_transport_header(skb);\n\t} else {\n\t\tth = skb_transport_header(skb);\n\t}\n\n\t/* compute offset from SOF to transport header and add header len */\n\thdrlen = (th - skb->data) + (((struct tcphdr *)th)->doff << 2);\n\n\tfirst->tx_flags |= FM10K_TX_FLAGS_CSUM;\n\n\t/* update gso size and bytecount with header size */\n\tfirst->gso_segs = skb_shinfo(skb)->gso_segs;\n\tfirst->bytecount += (first->gso_segs - 1) * hdrlen;\n\n\t/* populate Tx descriptor header size and mss */\n\ttx_desc = FM10K_TX_DESC(tx_ring, tx_ring->next_to_use);\n\ttx_desc->hdrlen = hdrlen;\n\ttx_desc->mss = cpu_to_le16(skb_shinfo(skb)->gso_size);\n\n\treturn 1;\n\nerr_vxlan:\n\ttx_ring->netdev->features &= ~NETIF_F_GSO_UDP_TUNNEL;\n\tif (net_ratelimit())\n\t\tnetdev_err(tx_ring->netdev,\n\t\t\t   \"TSO requested for unsupported tunnel, disabling offload\\n\");\n\treturn -1;\n}\n\nstatic void fm10k_tx_csum(struct fm10k_ring *tx_ring,\n\t\t\t  struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_desc *tx_desc;\n\tunion {\n\t\tstruct iphdr *ipv4;\n\t\tstruct ipv6hdr *ipv6;\n\t\tu8 *raw;\n\t} network_hdr;\n\tu8 *transport_hdr;\n\t__be16 frag_off;\n\t__be16 protocol;\n\tu8 l4_hdr = 0;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\tgoto no_csum;\n\n\tif (skb->encapsulation) {\n\t\tprotocol = fm10k_tx_encap_offload(skb);\n\t\tif (!protocol) {\n\t\t\tif (skb_checksum_help(skb)) {\n\t\t\t\tdev_warn(tx_ring->dev,\n\t\t\t\t\t \"failed to offload encap csum!\\n\");\n\t\t\t\ttx_ring->tx_stats.csum_err++;\n\t\t\t}\n\t\t\tgoto no_csum;\n\t\t}\n\t\tnetwork_hdr.raw = skb_inner_network_header(skb);\n\t\ttransport_hdr = skb_inner_transport_header(skb);\n\t} else {\n\t\tprotocol = vlan_get_protocol(skb);\n\t\tnetwork_hdr.raw = skb_network_header(skb);\n\t\ttransport_hdr = skb_transport_header(skb);\n\t}\n\n\tswitch (protocol) {\n\tcase htons(ETH_P_IP):\n\t\tl4_hdr = network_hdr.ipv4->protocol;\n\t\tbreak;\n\tcase htons(ETH_P_IPV6):\n\t\tl4_hdr = network_hdr.ipv6->nexthdr;\n\t\tif (likely((transport_hdr - network_hdr.raw) ==\n\t\t\t   sizeof(struct ipv6hdr)))\n\t\t\tbreak;\n\t\tipv6_skip_exthdr(skb, network_hdr.raw - skb->data +\n\t\t\t\t      sizeof(struct ipv6hdr),\n\t\t\t\t &l4_hdr, &frag_off);\n\t\tif (unlikely(frag_off))\n\t\t\tl4_hdr = NEXTHDR_FRAGMENT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (l4_hdr) {\n\tcase IPPROTO_TCP:\n\tcase IPPROTO_UDP:\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\tif (skb->encapsulation)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tif (unlikely(net_ratelimit())) {\n\t\t\tdev_warn(tx_ring->dev,\n\t\t\t\t \"partial checksum, version=%d l4 proto=%x\\n\",\n\t\t\t\t protocol, l4_hdr);\n\t\t}\n\t\tskb_checksum_help(skb);\n\t\ttx_ring->tx_stats.csum_err++;\n\t\tgoto no_csum;\n\t}\n\n\t/* update TX checksum flag */\n\tfirst->tx_flags |= FM10K_TX_FLAGS_CSUM;\n\ttx_ring->tx_stats.csum_good++;\n\nno_csum:\n\t/* populate Tx descriptor header size and mss */\n\ttx_desc = FM10K_TX_DESC(tx_ring, tx_ring->next_to_use);\n\ttx_desc->hdrlen = 0;\n\ttx_desc->mss = 0;\n}\n\n#define FM10K_SET_FLAG(_input, _flag, _result) \\\n\t((_flag <= _result) ? \\\n\t ((u32)(_input & _flag) * (_result / _flag)) : \\\n\t ((u32)(_input & _flag) / (_flag / _result)))\n\nstatic u8 fm10k_tx_desc_flags(struct sk_buff *skb, u32 tx_flags)\n{\n\t/* set type for advanced descriptor with frame checksum insertion */\n\tu32 desc_flags = 0;\n\n\t/* set checksum offload bits */\n\tdesc_flags |= FM10K_SET_FLAG(tx_flags, FM10K_TX_FLAGS_CSUM,\n\t\t\t\t     FM10K_TXD_FLAG_CSUM);\n\n\treturn desc_flags;\n}\n\nstatic bool fm10k_tx_desc_push(struct fm10k_ring *tx_ring,\n\t\t\t       struct fm10k_tx_desc *tx_desc, u16 i,\n\t\t\t       dma_addr_t dma, unsigned int size, u8 desc_flags)\n{\n\t/* set RS and INT for last frame in a cache line */\n\tif ((++i & (FM10K_TXD_WB_FIFO_SIZE - 1)) == 0)\n\t\tdesc_flags |= FM10K_TXD_FLAG_RS | FM10K_TXD_FLAG_INT;\n\n\t/* record values to descriptor */\n\ttx_desc->buffer_addr = cpu_to_le64(dma);\n\ttx_desc->flags = desc_flags;\n\ttx_desc->buflen = cpu_to_le16(size);\n\n\t/* return true if we just wrapped the ring */\n\treturn i == tx_ring->count;\n}\n\nstatic int __fm10k_maybe_stop_tx(struct fm10k_ring *tx_ring, u16 size)\n{\n\tnetif_stop_subqueue(tx_ring->netdev, tx_ring->queue_index);\n\n\t/* Memory barrier before checking head and tail */\n\tsmp_mb();\n\n\t/* Check again in a case another CPU has just made room available */\n\tif (likely(fm10k_desc_unused(tx_ring) < size))\n\t\treturn -EBUSY;\n\n\t/* A reprieve! - use start_queue because it doesn't call schedule */\n\tnetif_start_subqueue(tx_ring->netdev, tx_ring->queue_index);\n\t++tx_ring->tx_stats.restart_queue;\n\treturn 0;\n}\n\nstatic inline int fm10k_maybe_stop_tx(struct fm10k_ring *tx_ring, u16 size)\n{\n\tif (likely(fm10k_desc_unused(tx_ring) >= size))\n\t\treturn 0;\n\treturn __fm10k_maybe_stop_tx(tx_ring, size);\n}\n\nstatic void fm10k_tx_map(struct fm10k_ring *tx_ring,\n\t\t\t struct fm10k_tx_buffer *first)\n{\n\tstruct sk_buff *skb = first->skb;\n\tstruct fm10k_tx_buffer *tx_buffer;\n\tstruct fm10k_tx_desc *tx_desc;\n\tstruct skb_frag_struct *frag;\n\tunsigned char *data;\n\tdma_addr_t dma;\n\tunsigned int data_len, size;\n\tu32 tx_flags = first->tx_flags;\n\tu16 i = tx_ring->next_to_use;\n\tu8 flags = fm10k_tx_desc_flags(skb, tx_flags);\n\n\ttx_desc = FM10K_TX_DESC(tx_ring, i);\n\n\t/* add HW VLAN tag */\n\tif (skb_vlan_tag_present(skb))\n\t\ttx_desc->vlan = cpu_to_le16(skb_vlan_tag_get(skb));\n\telse\n\t\ttx_desc->vlan = 0;\n\n\tsize = skb_headlen(skb);\n\tdata = skb->data;\n\n\tdma = dma_map_single(tx_ring->dev, data, size, DMA_TO_DEVICE);\n\n\tdata_len = skb->data_len;\n\ttx_buffer = first;\n\n\tfor (frag = &skb_shinfo(skb)->frags[0];; frag++) {\n\t\tif (dma_mapping_error(tx_ring->dev, dma))\n\t\t\tgoto dma_error;\n\n\t\t/* record length, and DMA address */\n\t\tdma_unmap_len_set(tx_buffer, len, size);\n\t\tdma_unmap_addr_set(tx_buffer, dma, dma);\n\n\t\twhile (unlikely(size > FM10K_MAX_DATA_PER_TXD)) {\n\t\t\tif (fm10k_tx_desc_push(tx_ring, tx_desc++, i++, dma,\n\t\t\t\t\t       FM10K_MAX_DATA_PER_TXD, flags)) {\n\t\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\t\ti = 0;\n\t\t\t}\n\n\t\t\tdma += FM10K_MAX_DATA_PER_TXD;\n\t\t\tsize -= FM10K_MAX_DATA_PER_TXD;\n\t\t}\n\n\t\tif (likely(!data_len))\n\t\t\tbreak;\n\n\t\tif (fm10k_tx_desc_push(tx_ring, tx_desc++, i++,\n\t\t\t\t       dma, size, flags)) {\n\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\ti = 0;\n\t\t}\n\n\t\tsize = skb_frag_size(frag);\n\t\tdata_len -= size;\n\n\t\tdma = skb_frag_dma_map(tx_ring->dev, frag, 0, size,\n\t\t\t\t       DMA_TO_DEVICE);\n\n\t\ttx_buffer = &tx_ring->tx_buffer[i];\n\t}\n\n\t/* write last descriptor with LAST bit set */\n\tflags |= FM10K_TXD_FLAG_LAST;\n\n\tif (fm10k_tx_desc_push(tx_ring, tx_desc, i++, dma, size, flags))\n\t\ti = 0;\n\n\t/* record bytecount for BQL */\n\tnetdev_tx_sent_queue(txring_txq(tx_ring), first->bytecount);\n\n\t/* record SW timestamp if HW timestamp is not available */\n\tskb_tx_timestamp(first->skb);\n\n\t/* Force memory writes to complete before letting h/w know there\n\t * are new descriptors to fetch.  (Only applicable for weak-ordered\n\t * memory model archs, such as IA-64).\n\t *\n\t * We also need this memory barrier to make certain all of the\n\t * status bits have been updated before next_to_watch is written.\n\t */\n\twmb();\n\n\t/* set next_to_watch value indicating a packet is present */\n\tfirst->next_to_watch = tx_desc;\n\n\ttx_ring->next_to_use = i;\n\n\t/* Make sure there is space in the ring for the next send. */\n\tfm10k_maybe_stop_tx(tx_ring, DESC_NEEDED);\n\n\t/* notify HW of packet */\n\tif (netif_xmit_stopped(txring_txq(tx_ring)) || !skb->xmit_more) {\n\t\twritel(i, tx_ring->tail);\n\n\t\t/* we need this if more than one processor can write to our tail\n\t\t * at a time, it synchronizes IO on IA64/Altix systems\n\t\t */\n\t\tmmiowb();\n\t}\n\n\treturn;\ndma_error:\n\tdev_err(tx_ring->dev, \"TX DMA map failed\\n\");\n\n\t/* clear dma mappings for failed tx_buffer map */\n\tfor (;;) {\n\t\ttx_buffer = &tx_ring->tx_buffer[i];\n\t\tfm10k_unmap_and_free_tx_resource(tx_ring, tx_buffer);\n\t\tif (tx_buffer == first)\n\t\t\tbreak;\n\t\tif (i == 0)\n\t\t\ti = tx_ring->count;\n\t\ti--;\n\t}\n\n\ttx_ring->next_to_use = i;\n}\n\nnetdev_tx_t fm10k_xmit_frame_ring(struct sk_buff *skb,\n\t\t\t\t  struct fm10k_ring *tx_ring)\n{\n\tu16 count = TXD_USE_COUNT(skb_headlen(skb));\n\tstruct fm10k_tx_buffer *first;\n\tunsigned short f;\n\tu32 tx_flags = 0;\n\tint tso;\n\n\t/* need: 1 descriptor per page * PAGE_SIZE/FM10K_MAX_DATA_PER_TXD,\n\t *       + 1 desc for skb_headlen/FM10K_MAX_DATA_PER_TXD,\n\t *       + 2 desc gap to keep tail from touching head\n\t * otherwise try next time\n\t */\n\tfor (f = 0; f < skb_shinfo(skb)->nr_frags; f++)\n\t\tcount += TXD_USE_COUNT(skb_shinfo(skb)->frags[f].size);\n\n\tif (fm10k_maybe_stop_tx(tx_ring, count + 3)) {\n\t\ttx_ring->tx_stats.tx_busy++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t/* record the location of the first descriptor for this packet */\n\tfirst = &tx_ring->tx_buffer[tx_ring->next_to_use];\n\tfirst->skb = skb;\n\tfirst->bytecount = max_t(unsigned int, skb->len, ETH_ZLEN);\n\tfirst->gso_segs = 1;\n\n\t/* record initial flags and protocol */\n\tfirst->tx_flags = tx_flags;\n\n\ttso = fm10k_tso(tx_ring, first);\n\tif (tso < 0)\n\t\tgoto out_drop;\n\telse if (!tso)\n\t\tfm10k_tx_csum(tx_ring, first);\n\n\tfm10k_tx_map(tx_ring, first);\n\n\treturn NETDEV_TX_OK;\n\nout_drop:\n\tdev_kfree_skb_any(first->skb);\n\tfirst->skb = NULL;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic u64 fm10k_get_tx_completed(struct fm10k_ring *ring)\n{\n\treturn ring->stats.packets;\n}\n\n/**\n * fm10k_get_tx_pending - how many Tx descriptors not processed\n * @ring: the ring structure\n * @in_sw: is tx_pending being checked in SW or in HW?\n */\nu64 fm10k_get_tx_pending(struct fm10k_ring *ring, bool in_sw)\n{\n\tstruct fm10k_intfc *interface = ring->q_vector->interface;\n\tstruct fm10k_hw *hw = &interface->hw;\n\tu32 head, tail;\n\n\tif (likely(in_sw)) {\n\t\thead = ring->next_to_clean;\n\t\ttail = ring->next_to_use;\n\t} else {\n\t\thead = fm10k_read_reg(hw, FM10K_TDH(ring->reg_idx));\n\t\ttail = fm10k_read_reg(hw, FM10K_TDT(ring->reg_idx));\n\t}\n\n\treturn ((head <= tail) ? tail : tail + ring->count) - head;\n}\n\nbool fm10k_check_tx_hang(struct fm10k_ring *tx_ring)\n{\n\tu32 tx_done = fm10k_get_tx_completed(tx_ring);\n\tu32 tx_done_old = tx_ring->tx_stats.tx_done_old;\n\tu32 tx_pending = fm10k_get_tx_pending(tx_ring, true);\n\n\tclear_check_for_tx_hang(tx_ring);\n\n\t/* Check for a hung queue, but be thorough. This verifies\n\t * that a transmit has been completed since the previous\n\t * check AND there is at least one packet pending. By\n\t * requiring this to fail twice we avoid races with\n\t * clearing the ARMED bit and conditions where we\n\t * run the check_tx_hang logic with a transmit completion\n\t * pending but without time to complete it yet.\n\t */\n\tif (!tx_pending || (tx_done_old != tx_done)) {\n\t\t/* update completed stats and continue */\n\t\ttx_ring->tx_stats.tx_done_old = tx_done;\n\t\t/* reset the countdown */\n\t\tclear_bit(__FM10K_HANG_CHECK_ARMED, tx_ring->state);\n\n\t\treturn false;\n\t}\n\n\t/* make sure it is true for two checks in a row */\n\treturn test_and_set_bit(__FM10K_HANG_CHECK_ARMED, tx_ring->state);\n}\n\n/**\n * fm10k_tx_timeout_reset - initiate reset due to Tx timeout\n * @interface: driver private struct\n **/\nvoid fm10k_tx_timeout_reset(struct fm10k_intfc *interface)\n{\n\t/* Do the reset outside of interrupt context */\n\tif (!test_bit(__FM10K_DOWN, interface->state)) {\n\t\tinterface->tx_timeout_count++;\n\t\tset_bit(FM10K_FLAG_RESET_REQUESTED, interface->flags);\n\t\tfm10k_service_event_schedule(interface);\n\t}\n}\n\n/**\n * fm10k_clean_tx_irq - Reclaim resources after transmit completes\n * @q_vector: structure containing interrupt and ring information\n * @tx_ring: tx ring to clean\n * @napi_budget: Used to determine if we are in netpoll\n **/\nstatic bool fm10k_clean_tx_irq(struct fm10k_q_vector *q_vector,\n\t\t\t       struct fm10k_ring *tx_ring, int napi_budget)\n{\n\tstruct fm10k_intfc *interface = q_vector->interface;\n\tstruct fm10k_tx_buffer *tx_buffer;\n\tstruct fm10k_tx_desc *tx_desc;\n\tunsigned int total_bytes = 0, total_packets = 0;\n\tunsigned int budget = q_vector->tx.work_limit;\n\tunsigned int i = tx_ring->next_to_clean;\n\n\tif (test_bit(__FM10K_DOWN, interface->state))\n\t\treturn true;\n\n\ttx_buffer = &tx_ring->tx_buffer[i];\n\ttx_desc = FM10K_TX_DESC(tx_ring, i);\n\ti -= tx_ring->count;\n\n\tdo {\n\t\tstruct fm10k_tx_desc *eop_desc = tx_buffer->next_to_watch;\n\n\t\t/* if next_to_watch is not set then there is no work pending */\n\t\tif (!eop_desc)\n\t\t\tbreak;\n\n\t\t/* prevent any other reads prior to eop_desc */\n\t\tsmp_rmb();\n\n\t\t/* if DD is not set pending work has not been completed */\n\t\tif (!(eop_desc->flags & FM10K_TXD_FLAG_DONE))\n\t\t\tbreak;\n\n\t\t/* clear next_to_watch to prevent false hangs */\n\t\ttx_buffer->next_to_watch = NULL;\n\n\t\t/* update the statistics for this packet */\n\t\ttotal_bytes += tx_buffer->bytecount;\n\t\ttotal_packets += tx_buffer->gso_segs;\n\n\t\t/* free the skb */\n\t\tnapi_consume_skb(tx_buffer->skb, napi_budget);\n\n\t\t/* unmap skb header data */\n\t\tdma_unmap_single(tx_ring->dev,\n\t\t\t\t dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t dma_unmap_len(tx_buffer, len),\n\t\t\t\t DMA_TO_DEVICE);\n\n\t\t/* clear tx_buffer data */\n\t\ttx_buffer->skb = NULL;\n\t\tdma_unmap_len_set(tx_buffer, len, 0);\n\n\t\t/* unmap remaining buffers */\n\t\twhile (tx_desc != eop_desc) {\n\t\t\ttx_buffer++;\n\t\t\ttx_desc++;\n\t\t\ti++;\n\t\t\tif (unlikely(!i)) {\n\t\t\t\ti -= tx_ring->count;\n\t\t\t\ttx_buffer = tx_ring->tx_buffer;\n\t\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t\t}\n\n\t\t\t/* unmap any remaining paged data */\n\t\t\tif (dma_unmap_len(tx_buffer, len)) {\n\t\t\t\tdma_unmap_page(tx_ring->dev,\n\t\t\t\t\t       dma_unmap_addr(tx_buffer, dma),\n\t\t\t\t\t       dma_unmap_len(tx_buffer, len),\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t\t\tdma_unmap_len_set(tx_buffer, len, 0);\n\t\t\t}\n\t\t}\n\n\t\t/* move us one more past the eop_desc for start of next pkt */\n\t\ttx_buffer++;\n\t\ttx_desc++;\n\t\ti++;\n\t\tif (unlikely(!i)) {\n\t\t\ti -= tx_ring->count;\n\t\t\ttx_buffer = tx_ring->tx_buffer;\n\t\t\ttx_desc = FM10K_TX_DESC(tx_ring, 0);\n\t\t}\n\n\t\t/* issue prefetch for next Tx descriptor */\n\t\tprefetch(tx_desc);\n\n\t\t/* update budget accounting */\n\t\tbudget--;\n\t} while (likely(budget));\n\n\ti += tx_ring->count;\n\ttx_ring->next_to_clean = i;\n\tu64_stats_update_begin(&tx_ring->syncp);\n\ttx_ring->stats.bytes += total_bytes;\n\ttx_ring->stats.packets += total_packets;\n\tu64_stats_update_end(&tx_ring->syncp);\n\tq_vector->tx.total_bytes += total_bytes;\n\tq_vector->tx.total_packets += total_packets;\n\n\tif (check_for_tx_hang(tx_ring) && fm10k_check_tx_hang(tx_ring)) {\n\t\t/* schedule immediate reset if we believe we hung */\n\t\tstruct fm10k_hw *hw = &interface->hw;\n\n\t\tnetif_err(interface, drv, tx_ring->netdev,\n\t\t\t  \"Detected Tx Unit Hang\\n\"\n\t\t\t  \"  Tx Queue             <%d>\\n\"\n\t\t\t  \"  TDH, TDT             <%x>, <%x>\\n\"\n\t\t\t  \"  next_to_use          <%x>\\n\"\n\t\t\t  \"  next_to_clean        <%x>\\n\",\n\t\t\t  tx_ring->queue_index,\n\t\t\t  fm10k_read_reg(hw, FM10K_TDH(tx_ring->reg_idx)),\n\t\t\t  fm10k_read_reg(hw, FM10K_TDT(tx_ring->reg_idx)),\n\t\t\t  tx_ring->next_to_use, i);\n\n\t\tnetif_stop_subqueue(tx_ring->netdev,\n\t\t\t\t    tx_ring->queue_index);\n\n\t\tnetif_info(interface, probe, tx_ring->netdev,\n\t\t\t   \"tx hang %d detected on queue %d, resetting interface\\n\",\n\t\t\t   interface->tx_timeout_count + 1,\n\t\t\t   tx_ring->queue_index);\n\n\t\tfm10k_tx_timeout_reset(interface);\n\n\t\t/* the netdev is about to reset, no point in enabling stuff */\n\t\treturn true;\n\t}\n\n\t/* notify netdev of completed buffers */\n\tnetdev_tx_completed_queue(txring_txq(tx_ring),\n\t\t\t\t  total_packets, total_bytes);\n\n#define TX_WAKE_THRESHOLD min_t(u16, FM10K_MIN_TXD - 1, DESC_NEEDED * 2)\n\tif (unlikely(total_packets && netif_carrier_ok(tx_ring->netdev) &&\n\t\t     (fm10k_desc_unused(tx_ring) >= TX_WAKE_THRESHOLD))) {\n\t\t/* Make sure that anybody stopping the queue after this\n\t\t * sees the new next_to_clean.\n\t\t */\n\t\tsmp_mb();\n\t\tif (__netif_subqueue_stopped(tx_ring->netdev,\n\t\t\t\t\t     tx_ring->queue_index) &&\n\t\t    !test_bit(__FM10K_DOWN, interface->state)) {\n\t\t\tnetif_wake_subqueue(tx_ring->netdev,\n\t\t\t\t\t    tx_ring->queue_index);\n\t\t\t++tx_ring->tx_stats.restart_queue;\n\t\t}\n\t}\n\n\treturn !!budget;\n}\n\n/**\n * fm10k_update_itr - update the dynamic ITR value based on packet size\n *\n *      Stores a new ITR value based on strictly on packet size.  The\n *      divisors and thresholds used by this function were determined based\n *      on theoretical maximum wire speed and testing data, in order to\n *      minimize response time while increasing bulk throughput.\n *\n * @ring_container: Container for rings to have ITR updated\n **/\nstatic void fm10k_update_itr(struct fm10k_ring_container *ring_container)\n{\n\tunsigned int avg_wire_size, packets, itr_round;\n\n\t/* Only update ITR if we are using adaptive setting */\n\tif (!ITR_IS_ADAPTIVE(ring_container->itr))\n\t\tgoto clear_counts;\n\n\tpackets = ring_container->total_packets;\n\tif (!packets)\n\t\tgoto clear_counts;\n\n\tavg_wire_size = ring_container->total_bytes / packets;\n\n\t/* The following is a crude approximation of:\n\t *  wmem_default / (size + overhead) = desired_pkts_per_int\n\t *  rate / bits_per_byte / (size + ethernet overhead) = pkt_rate\n\t *  (desired_pkt_rate / pkt_rate) * usecs_per_sec = ITR value\n\t *\n\t * Assuming wmem_default is 212992 and overhead is 640 bytes per\n\t * packet, (256 skb, 64 headroom, 320 shared info), we can reduce the\n\t * formula down to\n\t *\n\t *  (34 * (size + 24)) / (size + 640) = ITR\n\t *\n\t * We first do some math on the packet size and then finally bitshift\n\t * by 8 after rounding up. We also have to account for PCIe link speed\n\t * difference as ITR scales based on this.\n\t */\n\tif (avg_wire_size <= 360) {\n\t\t/* Start at 250K ints/sec and gradually drop to 77K ints/sec */\n\t\tavg_wire_size *= 8;\n\t\tavg_wire_size += 376;\n\t} else if (avg_wire_size <= 1152) {\n\t\t/* 77K ints/sec to 45K ints/sec */\n\t\tavg_wire_size *= 3;\n\t\tavg_wire_size += 2176;\n\t} else if (avg_wire_size <= 1920) {\n\t\t/* 45K ints/sec to 38K ints/sec */\n\t\tavg_wire_size += 4480;\n\t} else {\n\t\t/* plateau at a limit of 38K ints/sec */\n\t\tavg_wire_size = 6656;\n\t}\n\n\t/* Perform final bitshift for division after rounding up to ensure\n\t * that the calculation will never get below a 1. The bit shift\n\t * accounts for changes in the ITR due to PCIe link speed.\n\t */\n\titr_round = READ_ONCE(ring_container->itr_scale) + 8;\n\tavg_wire_size += BIT(itr_round) - 1;\n\tavg_wire_size >>= itr_round;\n\n\t/* write back value and retain adaptive flag */\n\tring_container->itr = avg_wire_size | FM10K_ITR_ADAPTIVE;\n\nclear_counts:\n\tring_container->total_bytes = 0;\n\tring_container->total_packets = 0;\n}\n\nstatic void fm10k_qv_enable(struct fm10k_q_vector *q_vector)\n{\n\t/* Enable auto-mask and clear the current mask */\n\tu32 itr = FM10K_ITR_ENABLE;\n\n\t/* Update Tx ITR */\n\tfm10k_update_itr(&q_vector->tx);\n\n\t/* Update Rx ITR */\n\tfm10k_update_itr(&q_vector->rx);\n\n\t/* Store Tx itr in timer slot 0 */\n\titr |= (q_vector->tx.itr & FM10K_ITR_MAX);\n\n\t/* Shift Rx itr to timer slot 1 */\n\titr |= (q_vector->rx.itr & FM10K_ITR_MAX) << FM10K_ITR_INTERVAL1_SHIFT;\n\n\t/* Write the final value to the ITR register */\n\twritel(itr, q_vector->itr);\n}\n\nstatic int fm10k_poll(struct napi_struct *napi, int budget)\n{\n\tstruct fm10k_q_vector *q_vector =\n\t\t\t       container_of(napi, struct fm10k_q_vector, napi);\n\tstruct fm10k_ring *ring;\n\tint per_ring_budget, work_done = 0;\n\tbool clean_complete = true;\n\n\tfm10k_for_each_ring(ring, q_vector->tx) {\n\t\tif (!fm10k_clean_tx_irq(q_vector, ring, budget))\n\t\t\tclean_complete = false;\n\t}\n\n\t/* Handle case where we are called by netpoll with a budget of 0 */\n\tif (budget <= 0)\n\t\treturn budget;\n\n\t/* attempt to distribute budget to each queue fairly, but don't\n\t * allow the budget to go below 1 because we'll exit polling\n\t */\n\tif (q_vector->rx.count > 1)\n\t\tper_ring_budget = max(budget / q_vector->rx.count, 1);\n\telse\n\t\tper_ring_budget = budget;\n\n\tfm10k_for_each_ring(ring, q_vector->rx) {\n\t\tint work = fm10k_clean_rx_irq(q_vector, ring, per_ring_budget);\n\n\t\twork_done += work;\n\t\tif (work >= per_ring_budget)\n\t\t\tclean_complete = false;\n\t}\n\n\t/* If all work not completed, return budget and keep polling */\n\tif (!clean_complete)\n\t\treturn budget;\n\n\t/* Exit the polling mode, but don't re-enable interrupts if stack might\n\t * poll us due to busy-polling\n\t */\n\tif (likely(napi_complete_done(napi, work_done)))\n\t\tfm10k_qv_enable(q_vector);\n\n\treturn min(work_done, budget - 1);\n}\n\n/**\n * fm10k_set_qos_queues: Allocate queues for a QOS-enabled device\n * @interface: board private structure to initialize\n *\n * When QoS (Quality of Service) is enabled, allocate queues for\n * each traffic class.  If multiqueue isn't available,then abort QoS\n * initialization.\n *\n * This function handles all combinations of Qos and RSS.\n *\n **/\nstatic bool fm10k_set_qos_queues(struct fm10k_intfc *interface)\n{\n\tstruct net_device *dev = interface->netdev;\n\tstruct fm10k_ring_feature *f;\n\tint rss_i, i;\n\tint pcs;\n\n\t/* Map queue offset and counts onto allocated tx queues */\n\tpcs = netdev_get_num_tc(dev);\n\n\tif (pcs <= 1)\n\t\treturn false;\n\n\t/* set QoS mask and indices */\n\tf = &interface->ring_feature[RING_F_QOS];\n\tf->indices = pcs;\n\tf->mask = BIT(fls(pcs - 1)) - 1;\n\n\t/* determine the upper limit for our current DCB mode */\n\trss_i = interface->hw.mac.max_queues / pcs;\n\trss_i = BIT(fls(rss_i) - 1);\n\n\t/* set RSS mask and indices */\n\tf = &interface->ring_feature[RING_F_RSS];\n\trss_i = min_t(u16, rss_i, f->limit);\n\tf->indices = rss_i;\n\tf->mask = BIT(fls(rss_i - 1)) - 1;\n\n\t/* configure pause class to queue mapping */\n\tfor (i = 0; i < pcs; i++)\n\t\tnetdev_set_tc_queue(dev, i, rss_i, rss_i * i);\n\n\tinterface->num_rx_queues = rss_i * pcs;\n\tinterface->num_tx_queues = rss_i * pcs;\n\n\treturn true;\n}\n\n/**\n * fm10k_set_rss_queues: Allocate queues for RSS\n * @interface: board private structure to initialize\n *\n * This is our \"base\" multiqueue mode.  RSS (Receive Side Scaling) will try\n * to allocate one Rx queue per CPU, and if available, one Tx queue per CPU.\n *\n **/\nstatic bool fm10k_set_rss_queues(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_ring_feature *f;\n\tu16 rss_i;\n\n\tf = &interface->ring_feature[RING_F_RSS];\n\trss_i = min_t(u16, interface->hw.mac.max_queues, f->limit);\n\n\t/* record indices and power of 2 mask for RSS */\n\tf->indices = rss_i;\n\tf->mask = BIT(fls(rss_i - 1)) - 1;\n\n\tinterface->num_rx_queues = rss_i;\n\tinterface->num_tx_queues = rss_i;\n\n\treturn true;\n}\n\n/**\n * fm10k_set_num_queues: Allocate queues for device, feature dependent\n * @interface: board private structure to initialize\n *\n * This is the top level queue allocation routine.  The order here is very\n * important, starting with the \"most\" number of features turned on at once,\n * and ending with the smallest set of features.  This way large combinations\n * can be allocated if they're turned on, and smaller combinations are the\n * fallthrough conditions.\n *\n **/\nstatic void fm10k_set_num_queues(struct fm10k_intfc *interface)\n{\n\t/* Attempt to setup QoS and RSS first */\n\tif (fm10k_set_qos_queues(interface))\n\t\treturn;\n\n\t/* If we don't have QoS, just fallback to only RSS. */\n\tfm10k_set_rss_queues(interface);\n}\n\n/**\n * fm10k_reset_num_queues - Reset the number of queues to zero\n * @interface: board private structure\n *\n * This function should be called whenever we need to reset the number of\n * queues after an error condition.\n */\nstatic void fm10k_reset_num_queues(struct fm10k_intfc *interface)\n{\n\tinterface->num_tx_queues = 0;\n\tinterface->num_rx_queues = 0;\n\tinterface->num_q_vectors = 0;\n}\n\n/**\n * fm10k_alloc_q_vector - Allocate memory for a single interrupt vector\n * @interface: board private structure to initialize\n * @v_count: q_vectors allocated on interface, used for ring interleaving\n * @v_idx: index of vector in interface struct\n * @txr_count: total number of Tx rings to allocate\n * @txr_idx: index of first Tx ring to allocate\n * @rxr_count: total number of Rx rings to allocate\n * @rxr_idx: index of first Rx ring to allocate\n *\n * We allocate one q_vector.  If allocation fails we return -ENOMEM.\n **/\nstatic int fm10k_alloc_q_vector(struct fm10k_intfc *interface,\n\t\t\t\tunsigned int v_count, unsigned int v_idx,\n\t\t\t\tunsigned int txr_count, unsigned int txr_idx,\n\t\t\t\tunsigned int rxr_count, unsigned int rxr_idx)\n{\n\tstruct fm10k_q_vector *q_vector;\n\tstruct fm10k_ring *ring;\n\tint ring_count;\n\n\tring_count = txr_count + rxr_count;\n\n\t/* allocate q_vector and rings */\n\tq_vector = kzalloc(struct_size(q_vector, ring, ring_count), GFP_KERNEL);\n\tif (!q_vector)\n\t\treturn -ENOMEM;\n\n\t/* initialize NAPI */\n\tnetif_napi_add(interface->netdev, &q_vector->napi,\n\t\t       fm10k_poll, NAPI_POLL_WEIGHT);\n\n\t/* tie q_vector and interface together */\n\tinterface->q_vector[v_idx] = q_vector;\n\tq_vector->interface = interface;\n\tq_vector->v_idx = v_idx;\n\n\t/* initialize pointer to rings */\n\tring = q_vector->ring;\n\n\t/* save Tx ring container info */\n\tq_vector->tx.ring = ring;\n\tq_vector->tx.work_limit = FM10K_DEFAULT_TX_WORK;\n\tq_vector->tx.itr = interface->tx_itr;\n\tq_vector->tx.itr_scale = interface->hw.mac.itr_scale;\n\tq_vector->tx.count = txr_count;\n\n\twhile (txr_count) {\n\t\t/* assign generic ring traits */\n\t\tring->dev = &interface->pdev->dev;\n\t\tring->netdev = interface->netdev;\n\n\t\t/* configure backlink on ring */\n\t\tring->q_vector = q_vector;\n\n\t\t/* apply Tx specific ring traits */\n\t\tring->count = interface->tx_ring_count;\n\t\tring->queue_index = txr_idx;\n\n\t\t/* assign ring to interface */\n\t\tinterface->tx_ring[txr_idx] = ring;\n\n\t\t/* update count and index */\n\t\ttxr_count--;\n\t\ttxr_idx += v_count;\n\n\t\t/* push pointer to next ring */\n\t\tring++;\n\t}\n\n\t/* save Rx ring container info */\n\tq_vector->rx.ring = ring;\n\tq_vector->rx.itr = interface->rx_itr;\n\tq_vector->rx.itr_scale = interface->hw.mac.itr_scale;\n\tq_vector->rx.count = rxr_count;\n\n\twhile (rxr_count) {\n\t\t/* assign generic ring traits */\n\t\tring->dev = &interface->pdev->dev;\n\t\tring->netdev = interface->netdev;\n\t\trcu_assign_pointer(ring->l2_accel, interface->l2_accel);\n\n\t\t/* configure backlink on ring */\n\t\tring->q_vector = q_vector;\n\n\t\t/* apply Rx specific ring traits */\n\t\tring->count = interface->rx_ring_count;\n\t\tring->queue_index = rxr_idx;\n\n\t\t/* assign ring to interface */\n\t\tinterface->rx_ring[rxr_idx] = ring;\n\n\t\t/* update count and index */\n\t\trxr_count--;\n\t\trxr_idx += v_count;\n\n\t\t/* push pointer to next ring */\n\t\tring++;\n\t}\n\n\tfm10k_dbg_q_vector_init(q_vector);\n\n\treturn 0;\n}\n\n/**\n * fm10k_free_q_vector - Free memory allocated for specific interrupt vector\n * @interface: board private structure to initialize\n * @v_idx: Index of vector to be freed\n *\n * This function frees the memory allocated to the q_vector.  In addition if\n * NAPI is enabled it will delete any references to the NAPI struct prior\n * to freeing the q_vector.\n **/\nstatic void fm10k_free_q_vector(struct fm10k_intfc *interface, int v_idx)\n{\n\tstruct fm10k_q_vector *q_vector = interface->q_vector[v_idx];\n\tstruct fm10k_ring *ring;\n\n\tfm10k_dbg_q_vector_exit(q_vector);\n\n\tfm10k_for_each_ring(ring, q_vector->tx)\n\t\tinterface->tx_ring[ring->queue_index] = NULL;\n\n\tfm10k_for_each_ring(ring, q_vector->rx)\n\t\tinterface->rx_ring[ring->queue_index] = NULL;\n\n\tinterface->q_vector[v_idx] = NULL;\n\tnetif_napi_del(&q_vector->napi);\n\tkfree_rcu(q_vector, rcu);\n}\n\n/**\n * fm10k_alloc_q_vectors - Allocate memory for interrupt vectors\n * @interface: board private structure to initialize\n *\n * We allocate one q_vector per queue interrupt.  If allocation fails we\n * return -ENOMEM.\n **/\nstatic int fm10k_alloc_q_vectors(struct fm10k_intfc *interface)\n{\n\tunsigned int q_vectors = interface->num_q_vectors;\n\tunsigned int rxr_remaining = interface->num_rx_queues;\n\tunsigned int txr_remaining = interface->num_tx_queues;\n\tunsigned int rxr_idx = 0, txr_idx = 0, v_idx = 0;\n\tint err;\n\n\tif (q_vectors >= (rxr_remaining + txr_remaining)) {\n\t\tfor (; rxr_remaining; v_idx++) {\n\t\t\terr = fm10k_alloc_q_vector(interface, q_vectors, v_idx,\n\t\t\t\t\t\t   0, 0, 1, rxr_idx);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\n\t\t\t/* update counts and index */\n\t\t\trxr_remaining--;\n\t\t\trxr_idx++;\n\t\t}\n\t}\n\n\tfor (; v_idx < q_vectors; v_idx++) {\n\t\tint rqpv = DIV_ROUND_UP(rxr_remaining, q_vectors - v_idx);\n\t\tint tqpv = DIV_ROUND_UP(txr_remaining, q_vectors - v_idx);\n\n\t\terr = fm10k_alloc_q_vector(interface, q_vectors, v_idx,\n\t\t\t\t\t   tqpv, txr_idx,\n\t\t\t\t\t   rqpv, rxr_idx);\n\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\t/* update counts and index */\n\t\trxr_remaining -= rqpv;\n\t\ttxr_remaining -= tqpv;\n\t\trxr_idx++;\n\t\ttxr_idx++;\n\t}\n\n\treturn 0;\n\nerr_out:\n\tfm10k_reset_num_queues(interface);\n\n\twhile (v_idx--)\n\t\tfm10k_free_q_vector(interface, v_idx);\n\n\treturn -ENOMEM;\n}\n\n/**\n * fm10k_free_q_vectors - Free memory allocated for interrupt vectors\n * @interface: board private structure to initialize\n *\n * This function frees the memory allocated to the q_vectors.  In addition if\n * NAPI is enabled it will delete any references to the NAPI struct prior\n * to freeing the q_vector.\n **/\nstatic void fm10k_free_q_vectors(struct fm10k_intfc *interface)\n{\n\tint v_idx = interface->num_q_vectors;\n\n\tfm10k_reset_num_queues(interface);\n\n\twhile (v_idx--)\n\t\tfm10k_free_q_vector(interface, v_idx);\n}\n\n/**\n * f10k_reset_msix_capability - reset MSI-X capability\n * @interface: board private structure to initialize\n *\n * Reset the MSI-X capability back to its starting state\n **/\nstatic void fm10k_reset_msix_capability(struct fm10k_intfc *interface)\n{\n\tpci_disable_msix(interface->pdev);\n\tkfree(interface->msix_entries);\n\tinterface->msix_entries = NULL;\n}\n\n/**\n * f10k_init_msix_capability - configure MSI-X capability\n * @interface: board private structure to initialize\n *\n * Attempt to configure the interrupts using the best available\n * capabilities of the hardware and the kernel.\n **/\nstatic int fm10k_init_msix_capability(struct fm10k_intfc *interface)\n{\n\tstruct fm10k_hw *hw = &interface->hw;\n\tint v_budget, vector;\n\n\t/* It's easy to be greedy for MSI-X vectors, but it really\n\t * doesn't do us much good if we have a lot more vectors\n\t * than CPU's.  So let's be conservative and only ask for\n\t * (roughly) the same number of vectors as there are CPU's.\n\t * the default is to use pairs of vectors\n\t */\n\tv_budget = max(interface->num_rx_queues, interface->num_tx_queues);\n\tv_budget = min_t(u16, v_budget, num_online_cpus());\n\n\t/* account for vectors not related to queues */\n\tv_budget += NON_Q_VECTORS(hw);\n\n\t/* At the same time, hardware can only support a maximum of\n\t * hw.mac->max_msix_vectors vectors.  With features\n\t * such as RSS and VMDq, we can easily surpass the number of Rx and Tx\n\t * descriptor queues supported by our device.  Thus, we cap it off in\n\t * those rare cases where the cpu count also exceeds our vector limit.\n\t */\n\tv_budget = min_t(int, v_budget, hw->mac.max_msix_vectors);\n\n\t/* A failure in MSI-X entry allocation is fatal. */\n\tinterface->msix_entries = kcalloc(v_budget, sizeof(struct msix_entry),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!interface->msix_entries)\n\t\treturn -ENOMEM;\n\n\t/* populate entry values */\n\tfor (vector = 0; vector < v_budget; vector++)\n\t\tinterface->msix_entries[vector].entry = vector;\n\n\t/* Attempt to enable MSI-X with requested value */\n\tv_budget = pci_enable_msix_range(interface->pdev,\n\t\t\t\t\t interface->msix_entries,\n\t\t\t\t\t MIN_MSIX_COUNT(hw),\n\t\t\t\t\t v_budget);\n\tif (v_budget < 0) {\n\t\tkfree(interface->msix_entries);\n\t\tinterface->msix_entries = NULL;\n\t\treturn v_budget;\n\t}\n\n\t/* record the number of queues available for q_vectors */\n\tinterface->num_q_vectors = v_budget - NON_Q_VECTORS(hw);\n\n\treturn 0;\n}\n\n/**\n * fm10k_cache_ring_qos - Descriptor ring to register mapping for QoS\n * @interface: Interface structure continaining rings and devices\n *\n * Cache the descriptor ring offsets for Qos\n **/\nstatic bool fm10k_cache_ring_qos(struct fm10k_intfc *interface)\n{\n\tstruct net_device *dev = interface->netdev;\n\tint pc, offset, rss_i, i, q_idx;\n\tu16 pc_stride = interface->ring_feature[RING_F_QOS].mask + 1;\n\tu8 num_pcs = netdev_get_num_tc(dev);\n\n\tif (num_pcs <= 1)\n\t\treturn false;\n\n\trss_i = interface->ring_feature[RING_F_RSS].indices;\n\n\tfor (pc = 0, offset = 0; pc < num_pcs; pc++, offset += rss_i) {\n\t\tq_idx = pc;\n\t\tfor (i = 0; i < rss_i; i++) {\n\t\t\tinterface->tx_ring[offset + i]->reg_idx = q_idx;\n\t\t\tinterface->tx_ring[offset + i]->qos_pc = pc;\n\t\t\tinterface->rx_ring[offset + i]->reg_idx = q_idx;\n\t\t\tinterface->rx_ring[offset + i]->qos_pc = pc;\n\t\t\tq_idx += pc_stride;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * fm10k_cache_ring_rss - Descriptor ring to register mapping for RSS\n * @interface: Interface structure continaining rings and devices\n *\n * Cache the descriptor ring offsets for RSS\n **/\nstatic void fm10k_cache_ring_rss(struct fm10k_intfc *interface)\n{\n\tint i;\n\n\tfor (i = 0; i < interface->num_rx_queues; i++)\n\t\tinterface->rx_ring[i]->reg_idx = i;\n\n\tfor (i = 0; i < interface->num_tx_queues; i++)\n\t\tinterface->tx_ring[i]->reg_idx = i;\n}\n\n/**\n * fm10k_assign_rings - Map rings to network devices\n * @interface: Interface structure containing rings and devices\n *\n * This function is meant to go though and configure both the network\n * devices so that they contain rings, and configure the rings so that\n * they function with their network devices.\n **/\nstatic void fm10k_assign_rings(struct fm10k_intfc *interface)\n{\n\tif (fm10k_cache_ring_qos(interface))\n\t\treturn;\n\n\tfm10k_cache_ring_rss(interface);\n}\n\nstatic void fm10k_init_reta(struct fm10k_intfc *interface)\n{\n\tu16 i, rss_i = interface->ring_feature[RING_F_RSS].indices;\n\tu32 reta;\n\n\t/* If the Rx flow indirection table has been configured manually, we\n\t * need to maintain it when possible.\n\t */\n\tif (netif_is_rxfh_configured(interface->netdev)) {\n\t\tfor (i = FM10K_RETA_SIZE; i--;) {\n\t\t\treta = interface->reta[i];\n\t\t\tif ((((reta << 24) >> 24) < rss_i) &&\n\t\t\t    (((reta << 16) >> 24) < rss_i) &&\n\t\t\t    (((reta <<  8) >> 24) < rss_i) &&\n\t\t\t    (((reta)       >> 24) < rss_i))\n\t\t\t\tcontinue;\n\n\t\t\t/* this should never happen */\n\t\t\tdev_err(&interface->pdev->dev,\n\t\t\t\t\"RSS indirection table assigned flows out of queue bounds. Reconfiguring.\\n\");\n\t\t\tgoto repopulate_reta;\n\t\t}\n\n\t\t/* do nothing if all of the elements are in bounds */\n\t\treturn;\n\t}\n\nrepopulate_reta:\n\tfm10k_write_reta(interface, NULL);\n}\n\n/**\n * fm10k_init_queueing_scheme - Determine proper queueing scheme\n * @interface: board private structure to initialize\n *\n * We determine which queueing scheme to use based on...\n * - Hardware queue count (num_*_queues)\n *   - defined by miscellaneous hardware support/features (RSS, etc.)\n **/\nint fm10k_init_queueing_scheme(struct fm10k_intfc *interface)\n{\n\tint err;\n\n\t/* Number of supported queues */\n\tfm10k_set_num_queues(interface);\n\n\t/* Configure MSI-X capability */\n\terr = fm10k_init_msix_capability(interface);\n\tif (err) {\n\t\tdev_err(&interface->pdev->dev,\n\t\t\t\"Unable to initialize MSI-X capability\\n\");\n\t\tgoto err_init_msix;\n\t}\n\n\t/* Allocate memory for queues */\n\terr = fm10k_alloc_q_vectors(interface);\n\tif (err) {\n\t\tdev_err(&interface->pdev->dev,\n\t\t\t\"Unable to allocate queue vectors\\n\");\n\t\tgoto err_alloc_q_vectors;\n\t}\n\n\t/* Map rings to devices, and map devices to physical queues */\n\tfm10k_assign_rings(interface);\n\n\t/* Initialize RSS redirection table */\n\tfm10k_init_reta(interface);\n\n\treturn 0;\n\nerr_alloc_q_vectors:\n\tfm10k_reset_msix_capability(interface);\nerr_init_msix:\n\tfm10k_reset_num_queues(interface);\n\treturn err;\n}\n\n/**\n * fm10k_clear_queueing_scheme - Clear the current queueing scheme settings\n * @interface: board private structure to clear queueing scheme on\n *\n * We go through and clear queueing specific resources and reset the structure\n * to pre-load conditions\n **/\nvoid fm10k_clear_queueing_scheme(struct fm10k_intfc *interface)\n{\n\tfm10k_free_q_vectors(interface);\n\tfm10k_reset_msix_capability(interface);\n}\n"], "filenames": ["drivers/net/ethernet/intel/fm10k/fm10k_main.c"], "buggy_code_start_loc": [43], "buggy_code_end_loc": [43], "fixing_code_start_loc": [44], "fixing_code_end_loc": [46], "type": "CWE-476", "message": "An issue was discovered in the Linux kernel before 5.0.11. fm10k_init_module in drivers/net/ethernet/intel/fm10k/fm10k_main.c has a NULL pointer dereference because there is no -ENOMEM upon an alloc_workqueue failure.", "other": {"cve": {"id": "CVE-2019-15924", "sourceIdentifier": "cve@mitre.org", "published": "2019-09-04T19:15:12.410", "lastModified": "2019-09-14T04:15:16.653", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 5.0.11. fm10k_init_module in drivers/net/ethernet/intel/fm10k/fm10k_main.c has a NULL pointer dereference because there is no -ENOMEM upon an alloc_workqueue failure."}, {"lang": "es", "value": "Se detect\u00f3 un problema en el kernel de Linux versiones anteriores a 5.0.11. La funci\u00f3n fm10k_init_module en el archivo drivers/net/ethernet/intel/fm10k/fm10k_main.c presenta una desreferencia del puntero NULL porque no existe -ENOMEM tras un fallo de alloc_workqueue."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.0.11", "matchCriteriaId": "3094BD29-43CB-4B7E-9DE7-185AE7301A66"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00064.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-09/msg00066.html", "source": "cve@mitre.org"}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.0.11", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/01ca667133d019edc9f0a1f70a272447c84ec41f", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/09/msg00014.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2019/09/msg00015.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20191004-0001/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/01ca667133d019edc9f0a1f70a272447c84ec41f"}}