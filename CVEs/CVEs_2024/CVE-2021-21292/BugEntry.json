{"buggy_code": ["/*\n * Copyright 2018 Anton Tananaev (anton@traccar.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.traccar;\n\nimport com.sun.jna.Pointer;\nimport com.sun.jna.platform.win32.Advapi32;\nimport com.sun.jna.platform.win32.WinError;\nimport com.sun.jna.platform.win32.WinNT;\nimport com.sun.jna.platform.win32.Winsvc;\nimport com.sun.jna.platform.win32.Winsvc.HandlerEx;\nimport com.sun.jna.platform.win32.Winsvc.SC_HANDLE;\nimport com.sun.jna.platform.win32.Winsvc.SERVICE_DESCRIPTION;\nimport com.sun.jna.platform.win32.Winsvc.SERVICE_MAIN_FUNCTION;\nimport com.sun.jna.platform.win32.Winsvc.SERVICE_STATUS;\nimport com.sun.jna.platform.win32.Winsvc.SERVICE_STATUS_HANDLE;\nimport com.sun.jna.platform.win32.Winsvc.SERVICE_TABLE_ENTRY;\nimport jnr.posix.POSIXFactory;\n\nimport java.io.File;\nimport java.net.URISyntaxException;\n\npublic abstract class WindowsService {\n\n    private static final Advapi32 ADVAPI_32 = Advapi32.INSTANCE;\n\n    private final Object waitObject = new Object();\n\n    private final String serviceName;\n    private SERVICE_STATUS_HANDLE serviceStatusHandle;\n\n    public WindowsService(String serviceName) {\n        this.serviceName = serviceName;\n    }\n\n    public void install(\n            String displayName, String description, String[] dependencies,\n            String account, String password, String config) throws URISyntaxException {\n\n        String javaHome = System.getProperty(\"java.home\");\n        String javaBinary = javaHome + \"\\\\bin\\\\java.exe\";\n\n        File jar = new File(WindowsService.class.getProtectionDomain().getCodeSource().getLocation().toURI());\n        String command = javaBinary\n                + \" -Duser.dir=\\\"\" + jar.getParentFile().getAbsolutePath() + \"\\\"\"\n                + \" -jar \\\"\" + jar.getAbsolutePath() + \"\\\"\"\n                + \" --service \\\"\" + config + \"\\\"\";\n\n        StringBuilder dep = new StringBuilder();\n\n        if (dependencies != null) {\n            for (String s : dependencies) {\n                dep.append(s);\n                dep.append(\"\\0\");\n            }\n        }\n        dep.append(\"\\0\");\n\n        SERVICE_DESCRIPTION desc = new SERVICE_DESCRIPTION();\n        desc.lpDescription = description;\n\n        SC_HANDLE serviceManager = openServiceControlManager(null, Winsvc.SC_MANAGER_ALL_ACCESS);\n\n        if (serviceManager != null) {\n            SC_HANDLE service = ADVAPI_32.CreateService(serviceManager, serviceName, displayName,\n                    Winsvc.SERVICE_ALL_ACCESS, WinNT.SERVICE_WIN32_OWN_PROCESS, WinNT.SERVICE_AUTO_START,\n                    WinNT.SERVICE_ERROR_NORMAL,\n                    command,\n                    null, null, dep.toString(), account, password);\n\n            if (service != null) {\n                ADVAPI_32.ChangeServiceConfig2(service, Winsvc.SERVICE_CONFIG_DESCRIPTION, desc);\n                ADVAPI_32.CloseServiceHandle(service);\n            }\n            ADVAPI_32.CloseServiceHandle(serviceManager);\n        }\n    }\n\n    public void uninstall() {\n        SC_HANDLE serviceManager = openServiceControlManager(null, Winsvc.SC_MANAGER_ALL_ACCESS);\n\n        if (serviceManager != null) {\n            SC_HANDLE service = ADVAPI_32.OpenService(serviceManager, serviceName, Winsvc.SERVICE_ALL_ACCESS);\n\n            if (service != null) {\n                ADVAPI_32.DeleteService(service);\n                ADVAPI_32.CloseServiceHandle(service);\n            }\n            ADVAPI_32.CloseServiceHandle(serviceManager);\n        }\n    }\n\n    public boolean start() {\n        boolean success = false;\n\n        SC_HANDLE serviceManager = openServiceControlManager(null, WinNT.GENERIC_EXECUTE);\n\n        if (serviceManager != null) {\n            SC_HANDLE service = ADVAPI_32.OpenService(serviceManager, serviceName, WinNT.GENERIC_EXECUTE);\n\n            if (service != null) {\n                success = ADVAPI_32.StartService(service, 0, null);\n                ADVAPI_32.CloseServiceHandle(service);\n            }\n            ADVAPI_32.CloseServiceHandle(serviceManager);\n        }\n\n        return success;\n    }\n\n    public boolean stop() {\n        boolean success = false;\n\n        SC_HANDLE serviceManager = openServiceControlManager(null, WinNT.GENERIC_EXECUTE);\n\n        if (serviceManager != null) {\n            SC_HANDLE service = Advapi32.INSTANCE.OpenService(serviceManager, serviceName, WinNT.GENERIC_EXECUTE);\n\n            if (service != null) {\n                SERVICE_STATUS serviceStatus = new SERVICE_STATUS();\n                success = Advapi32.INSTANCE.ControlService(service, Winsvc.SERVICE_CONTROL_STOP, serviceStatus);\n                Advapi32.INSTANCE.CloseServiceHandle(service);\n            }\n            Advapi32.INSTANCE.CloseServiceHandle(serviceManager);\n        }\n\n        return success;\n    }\n\n    public void init() throws URISyntaxException {\n        String path = new File(\n                WindowsService.class.getProtectionDomain().getCodeSource().getLocation().toURI()).getParent();\n\n        POSIXFactory.getPOSIX().chdir(path);\n\n        ServiceMain serviceMain = new ServiceMain();\n        SERVICE_TABLE_ENTRY entry = new SERVICE_TABLE_ENTRY();\n        entry.lpServiceName = serviceName;\n        entry.lpServiceProc = serviceMain;\n\n        Advapi32.INSTANCE.StartServiceCtrlDispatcher((SERVICE_TABLE_ENTRY[]) entry.toArray(2));\n    }\n\n    private SC_HANDLE openServiceControlManager(String machine, int access) {\n        return ADVAPI_32.OpenSCManager(machine, null, access);\n    }\n\n    private void reportStatus(int status, int win32ExitCode, int waitHint) {\n        SERVICE_STATUS serviceStatus = new SERVICE_STATUS();\n        serviceStatus.dwServiceType = WinNT.SERVICE_WIN32_OWN_PROCESS;\n        serviceStatus.dwControlsAccepted = Winsvc.SERVICE_ACCEPT_STOP | Winsvc.SERVICE_ACCEPT_SHUTDOWN;\n        serviceStatus.dwWin32ExitCode = win32ExitCode;\n        serviceStatus.dwWaitHint = waitHint;\n        serviceStatus.dwCurrentState = status;\n\n        ADVAPI_32.SetServiceStatus(serviceStatusHandle, serviceStatus);\n    }\n\n    public abstract void run();\n\n    private class ServiceMain implements SERVICE_MAIN_FUNCTION {\n\n        public void callback(int dwArgc, Pointer lpszArgv) {\n            ServiceControl serviceControl = new ServiceControl();\n            serviceStatusHandle = ADVAPI_32.RegisterServiceCtrlHandlerEx(serviceName, serviceControl, null);\n\n            reportStatus(Winsvc.SERVICE_START_PENDING, WinError.NO_ERROR, 3000);\n            reportStatus(Winsvc.SERVICE_RUNNING, WinError.NO_ERROR, 0);\n\n            Thread.currentThread().setContextClassLoader(WindowsService.class.getClassLoader());\n\n            run();\n\n            try {\n                synchronized (waitObject) {\n                    waitObject.wait();\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            reportStatus(Winsvc.SERVICE_STOPPED, WinError.NO_ERROR, 0);\n\n            // Avoid returning from ServiceMain, which will cause a crash\n            // See http://support.microsoft.com/kb/201349, which recommends\n            // having init() wait for this thread.\n            // Waiting on this thread in init() won't fix the crash, though.\n\n            System.exit(0);\n        }\n\n    }\n\n    private class ServiceControl implements HandlerEx {\n\n        public int callback(int dwControl, int dwEventType, Pointer lpEventData, Pointer lpContext) {\n            switch (dwControl) {\n                case Winsvc.SERVICE_CONTROL_STOP:\n                case Winsvc.SERVICE_CONTROL_SHUTDOWN:\n                    reportStatus(Winsvc.SERVICE_STOP_PENDING, WinError.NO_ERROR, 5000);\n                    synchronized (waitObject) {\n                        waitObject.notifyAll();\n                    }\n                    break;\n                default:\n                    break;\n            }\n            return WinError.NO_ERROR;\n        }\n\n    }\n\n}\n"], "fixing_code": ["/*\n * Copyright 2018 - 2020 Anton Tananaev (anton@traccar.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.traccar;\n\nimport com.sun.jna.Pointer;\nimport com.sun.jna.platform.win32.Advapi32;\nimport com.sun.jna.platform.win32.WinError;\nimport com.sun.jna.platform.win32.WinNT;\nimport com.sun.jna.platform.win32.Winsvc;\nimport com.sun.jna.platform.win32.Winsvc.HandlerEx;\nimport com.sun.jna.platform.win32.Winsvc.SC_HANDLE;\nimport com.sun.jna.platform.win32.Winsvc.SERVICE_DESCRIPTION;\nimport com.sun.jna.platform.win32.Winsvc.SERVICE_MAIN_FUNCTION;\nimport com.sun.jna.platform.win32.Winsvc.SERVICE_STATUS;\nimport com.sun.jna.platform.win32.Winsvc.SERVICE_STATUS_HANDLE;\nimport com.sun.jna.platform.win32.Winsvc.SERVICE_TABLE_ENTRY;\nimport jnr.posix.POSIXFactory;\n\nimport java.io.File;\nimport java.net.URISyntaxException;\n\npublic abstract class WindowsService {\n\n    private static final Advapi32 ADVAPI_32 = Advapi32.INSTANCE;\n\n    private final Object waitObject = new Object();\n\n    private final String serviceName;\n    private SERVICE_STATUS_HANDLE serviceStatusHandle;\n\n    public WindowsService(String serviceName) {\n        this.serviceName = serviceName;\n    }\n\n    public void install(\n            String displayName, String description, String[] dependencies,\n            String account, String password, String config) throws URISyntaxException {\n\n        String javaHome = System.getProperty(\"java.home\");\n        String javaBinary = \"\\\"\" + javaHome + \"\\\\bin\\\\java.exe\\\"\";\n\n        File jar = new File(WindowsService.class.getProtectionDomain().getCodeSource().getLocation().toURI());\n        String command = javaBinary\n                + \" -Duser.dir=\\\"\" + jar.getParentFile().getAbsolutePath() + \"\\\"\"\n                + \" -jar \\\"\" + jar.getAbsolutePath() + \"\\\"\"\n                + \" --service \\\"\" + config + \"\\\"\";\n\n        StringBuilder dep = new StringBuilder();\n\n        if (dependencies != null) {\n            for (String s : dependencies) {\n                dep.append(s);\n                dep.append(\"\\0\");\n            }\n        }\n        dep.append(\"\\0\");\n\n        SERVICE_DESCRIPTION desc = new SERVICE_DESCRIPTION();\n        desc.lpDescription = description;\n\n        SC_HANDLE serviceManager = openServiceControlManager(null, Winsvc.SC_MANAGER_ALL_ACCESS);\n\n        if (serviceManager != null) {\n            SC_HANDLE service = ADVAPI_32.CreateService(serviceManager, serviceName, displayName,\n                    Winsvc.SERVICE_ALL_ACCESS, WinNT.SERVICE_WIN32_OWN_PROCESS, WinNT.SERVICE_AUTO_START,\n                    WinNT.SERVICE_ERROR_NORMAL,\n                    command,\n                    null, null, dep.toString(), account, password);\n\n            if (service != null) {\n                ADVAPI_32.ChangeServiceConfig2(service, Winsvc.SERVICE_CONFIG_DESCRIPTION, desc);\n                ADVAPI_32.CloseServiceHandle(service);\n            }\n            ADVAPI_32.CloseServiceHandle(serviceManager);\n        }\n    }\n\n    public void uninstall() {\n        SC_HANDLE serviceManager = openServiceControlManager(null, Winsvc.SC_MANAGER_ALL_ACCESS);\n\n        if (serviceManager != null) {\n            SC_HANDLE service = ADVAPI_32.OpenService(serviceManager, serviceName, Winsvc.SERVICE_ALL_ACCESS);\n\n            if (service != null) {\n                ADVAPI_32.DeleteService(service);\n                ADVAPI_32.CloseServiceHandle(service);\n            }\n            ADVAPI_32.CloseServiceHandle(serviceManager);\n        }\n    }\n\n    public boolean start() {\n        boolean success = false;\n\n        SC_HANDLE serviceManager = openServiceControlManager(null, WinNT.GENERIC_EXECUTE);\n\n        if (serviceManager != null) {\n            SC_HANDLE service = ADVAPI_32.OpenService(serviceManager, serviceName, WinNT.GENERIC_EXECUTE);\n\n            if (service != null) {\n                success = ADVAPI_32.StartService(service, 0, null);\n                ADVAPI_32.CloseServiceHandle(service);\n            }\n            ADVAPI_32.CloseServiceHandle(serviceManager);\n        }\n\n        return success;\n    }\n\n    public boolean stop() {\n        boolean success = false;\n\n        SC_HANDLE serviceManager = openServiceControlManager(null, WinNT.GENERIC_EXECUTE);\n\n        if (serviceManager != null) {\n            SC_HANDLE service = Advapi32.INSTANCE.OpenService(serviceManager, serviceName, WinNT.GENERIC_EXECUTE);\n\n            if (service != null) {\n                SERVICE_STATUS serviceStatus = new SERVICE_STATUS();\n                success = Advapi32.INSTANCE.ControlService(service, Winsvc.SERVICE_CONTROL_STOP, serviceStatus);\n                Advapi32.INSTANCE.CloseServiceHandle(service);\n            }\n            Advapi32.INSTANCE.CloseServiceHandle(serviceManager);\n        }\n\n        return success;\n    }\n\n    public void init() throws URISyntaxException {\n        String path = new File(\n                WindowsService.class.getProtectionDomain().getCodeSource().getLocation().toURI()).getParent();\n\n        POSIXFactory.getPOSIX().chdir(path);\n\n        ServiceMain serviceMain = new ServiceMain();\n        SERVICE_TABLE_ENTRY entry = new SERVICE_TABLE_ENTRY();\n        entry.lpServiceName = serviceName;\n        entry.lpServiceProc = serviceMain;\n\n        Advapi32.INSTANCE.StartServiceCtrlDispatcher((SERVICE_TABLE_ENTRY[]) entry.toArray(2));\n    }\n\n    private SC_HANDLE openServiceControlManager(String machine, int access) {\n        return ADVAPI_32.OpenSCManager(machine, null, access);\n    }\n\n    private void reportStatus(int status, int win32ExitCode, int waitHint) {\n        SERVICE_STATUS serviceStatus = new SERVICE_STATUS();\n        serviceStatus.dwServiceType = WinNT.SERVICE_WIN32_OWN_PROCESS;\n        serviceStatus.dwControlsAccepted = Winsvc.SERVICE_ACCEPT_STOP | Winsvc.SERVICE_ACCEPT_SHUTDOWN;\n        serviceStatus.dwWin32ExitCode = win32ExitCode;\n        serviceStatus.dwWaitHint = waitHint;\n        serviceStatus.dwCurrentState = status;\n\n        ADVAPI_32.SetServiceStatus(serviceStatusHandle, serviceStatus);\n    }\n\n    public abstract void run();\n\n    private class ServiceMain implements SERVICE_MAIN_FUNCTION {\n\n        public void callback(int dwArgc, Pointer lpszArgv) {\n            ServiceControl serviceControl = new ServiceControl();\n            serviceStatusHandle = ADVAPI_32.RegisterServiceCtrlHandlerEx(serviceName, serviceControl, null);\n\n            reportStatus(Winsvc.SERVICE_START_PENDING, WinError.NO_ERROR, 3000);\n            reportStatus(Winsvc.SERVICE_RUNNING, WinError.NO_ERROR, 0);\n\n            Thread.currentThread().setContextClassLoader(WindowsService.class.getClassLoader());\n\n            run();\n\n            try {\n                synchronized (waitObject) {\n                    waitObject.wait();\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            reportStatus(Winsvc.SERVICE_STOPPED, WinError.NO_ERROR, 0);\n\n            // Avoid returning from ServiceMain, which will cause a crash\n            // See http://support.microsoft.com/kb/201349, which recommends\n            // having init() wait for this thread.\n            // Waiting on this thread in init() won't fix the crash, though.\n\n            System.exit(0);\n        }\n\n    }\n\n    private class ServiceControl implements HandlerEx {\n\n        public int callback(int dwControl, int dwEventType, Pointer lpEventData, Pointer lpContext) {\n            switch (dwControl) {\n                case Winsvc.SERVICE_CONTROL_STOP:\n                case Winsvc.SERVICE_CONTROL_SHUTDOWN:\n                    reportStatus(Winsvc.SERVICE_STOP_PENDING, WinError.NO_ERROR, 5000);\n                    synchronized (waitObject) {\n                        waitObject.notifyAll();\n                    }\n                    break;\n                default:\n                    break;\n            }\n            return WinError.NO_ERROR;\n        }\n\n    }\n\n}\n"], "filenames": ["src/main/java/org/traccar/WindowsService.java"], "buggy_code_start_loc": [2], "buggy_code_end_loc": [54], "fixing_code_start_loc": [2], "fixing_code_end_loc": [54], "type": "CWE-428", "message": "Traccar is an open source GPS tracking system. In Traccar before version 4.12 there is an unquoted Windows binary path vulnerability. Only Windows versions are impacted. Attacker needs write access to the filesystem on the host machine. If Java path includes a space, then attacker can lift their privilege to the same as Traccar service (system). This is fixed in version 4.12.", "other": {"cve": {"id": "CVE-2021-21292", "sourceIdentifier": "security-advisories@github.com", "published": "2021-02-02T20:15:12.173", "lastModified": "2021-02-08T18:37:38.473", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Traccar is an open source GPS tracking system. In Traccar before version 4.12 there is an unquoted Windows binary path vulnerability. Only Windows versions are impacted. Attacker needs write access to the filesystem on the host machine. If Java path includes a space, then attacker can lift their privilege to the same as Traccar service (system). This is fixed in version 4.12."}, {"lang": "es", "value": "Traccar es un sistema de rastreo GPS de c\u00f3digo abierto.&#xa0;En Traccar anterior a versi\u00f3n 4.12, se presenta una vulnerabilidad de ruta binaria de Windows sin comillas.&#xa0;Solo las versiones de Windows est\u00e1n afectadas.&#xa0;El atacante necesita acceso de escritura al sistema de archivos en la m\u00e1quina host.&#xa0;Si la ruta de Java incluye un espacio, entonces el atacante puede elevar su privilegio al mismo que el servicio Traccar (system).&#xa0;Esto se corregido en la versi\u00f3n 4.12"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:C/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-428"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:traccar:traccar:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.12", "matchCriteriaId": "A40F3F41-19A1-47C2-85B5-BF4DBBFD405E"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:microsoft:windows:-:*:*:*:*:*:*:*", "matchCriteriaId": "A2572D17-1DE6-457B-99CC-64AFD54487EA"}]}]}], "references": [{"url": "https://github.com/traccar/traccar/commit/cc69a9907ac9878db3750aa14ffedb28626455da", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/traccar/traccar/security/advisories/GHSA-j75r-7qm5-62q5", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.traccar.org/", "source": "security-advisories@github.com", "tags": ["Product"]}]}, "github_commit_url": "https://github.com/traccar/traccar/commit/cc69a9907ac9878db3750aa14ffedb28626455da"}}