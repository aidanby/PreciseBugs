{"buggy_code": ["/* p_tmt.cpp --\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2022 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2022 Laszlo Molnar\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_tmt.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-dos32.tmt.h\"\n\n#define EXTRA_INFO 4 // original entry point\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackTmt::PackTmt(InputFile *f) : super(f) {\n    bele = &N_BELE_RTP::le_policy;\n    COMPILE_TIME_ASSERT(sizeof(tmt_header_t) == 44)\n}\n\nconst int *PackTmt::getCompressionMethods(int method, int level) const {\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\nconst int *PackTmt::getFilters() const {\n    static const int filters[] = {0x26, 0x24,           0x49, 0x46, 0x16, 0x13,  0x14,\n                                  0x11, FT_ULTRA_BRUTE, 0x25, 0x15, 0x12, FT_END};\n    return filters;\n}\n\nunsigned PackTmt::findOverlapOverhead(const upx_bytep buf, const upx_bytep tbuf, unsigned range,\n                                      unsigned upper_limit) const {\n    // make sure the decompressor will be paragraph aligned\n    unsigned o = super::findOverlapOverhead(buf, tbuf, range, upper_limit);\n    o = ((o + 0x20) & ~0xf) - (ph.u_len & 0xf);\n    return o;\n}\n\nLinker *PackTmt::newLinker() const { return new ElfLinkerX86; }\n\nvoid PackTmt::buildLoader(const Filter *ft) {\n    // prepare loader\n    initLoader(stub_i386_dos32_tmt, sizeof(stub_i386_dos32_tmt));\n    addLoader(\"IDENTSTR,TMTMAIN1\", ph.first_offset_found == 1 ? \"TMTMAIN1A\" : \"\", \"TMTMAIN1B\",\n              ft->id ? \"TMTCALT1\" : \"\", \"TMTMAIN2,UPX1HEAD,TMTCUTPO\", nullptr);\n\n    // fake alignment for the start of the decompressor\n    linker->defineSymbol(\"TMTCUTPO\", 0x1000);\n\n    addLoader(getDecompressorSections(), \"TMTMAIN5\", nullptr);\n    if (ft->id) {\n        assert(ft->calls > 0);\n        addLoader(\"TMTCALT2\", nullptr);\n        addFilter32(ft->id);\n    }\n    addLoader(\"TMTRELOC,RELOC320\", big_relocs ? \"REL32BIG\" : \"\", \"RELOC32J,TMTJUMP1\", nullptr);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint PackTmt::readFileHeader() {\n#define H(x) get_le16(h + 2 * (x))\n#define H4(x) get_le32(h + (x))\n    unsigned char h[0x40];\n    int ic;\n    unsigned exe_offset = 0;\n    adam_offset = 0;\n\n    for (ic = 0; ic < 20; ic++) {\n        fi->seek(adam_offset, SEEK_SET);\n        fi->readx(h, sizeof(h));\n\n        if (memcmp(h, \"MZ\", 2) == 0) // dos exe\n        {\n            exe_offset = adam_offset;\n            adam_offset += H(2) * 512 + H(1);\n            if (H(1))\n                adam_offset -= 512;\n            if (H(0x18 / 2) == 0x40 && H4(0x3c))\n                adam_offset = H4(0x3c);\n        } else if (memcmp(h, \"BW\", 2) == 0)\n            adam_offset += H(2) * 512 + H(1);\n        else if (memcmp(h, \"PMW1\", 4) == 0) {\n            fi->seek(adam_offset + H4(0x18), SEEK_SET);\n            adam_offset += H4(0x24);\n            int objs = H4(0x1c);\n            while (objs--) {\n                fi->readx(h, 0x18);\n                adam_offset += H4(4);\n            }\n        } else if (memcmp(h, \"LE\", 2) == 0) {\n            // + (memory_pages-1)*memory_page_size+bytes_on_last_page\n            unsigned offs = exe_offset + (H4(0x14) - 1) * H4(0x28) + H4(0x2c);\n            fi->seek(adam_offset + 0x80, SEEK_SET);\n            fi->readx(h, 4);\n            // + data_pages_offset\n            adam_offset = offs + H4(0);\n        } else if (memcmp(h, \"Adam\", 4) == 0)\n            break;\n        else\n            return 0;\n    }\n    if (ic == 20)\n        return 0;\n\n    fi->seek(adam_offset, SEEK_SET);\n    fi->readx(&ih, sizeof(ih));\n    // FIXME: should add more checks for the values in 'ih'\n    unsigned const imagesize = ih.imagesize;\n    unsigned const entry = ih.entry;\n    unsigned const relocsize = ih.relocsize;\n    if (!imagesize || file_size <= imagesize || file_size <= entry || file_size <= relocsize) {\n        printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,\n                  entry, relocsize);\n        return 0;\n    }\n\n    return UPX_F_TMT_ADAM;\n#undef H4\n#undef H\n}\n\nbool PackTmt::canPack() {\n    if (!readFileHeader())\n        return false;\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackTmt::pack(OutputFile *fo) {\n    big_relocs = 0;\n\n    Packer::handleStub(fi, fo, adam_offset);\n\n    const unsigned usize = ih.imagesize;\n    const unsigned rsize = ih.relocsize;\n\n    ibuf.alloc(usize + rsize + 128);\n    obuf.allocForCompression(usize + rsize + 128);\n\n    MemBuffer mb_wrkmem;\n    mb_wrkmem.alloc(rsize + EXTRA_INFO); // relocations\n    SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem);\n\n    fi->seek(adam_offset + sizeof(ih), SEEK_SET);\n    fi->readx(ibuf, usize);\n    fi->readx(wrkmem + 4, rsize);\n    const unsigned overlay = file_size - fi->tell();\n\n    if (find_le32(ibuf, 128, get_le32(\"UPX \")) >= 0)\n        throwAlreadyPacked();\n    if (rsize == 0)\n        throwCantPack(\"file is already compressed with another packer\");\n\n    checkOverlay(overlay);\n\n    unsigned relocsize = 0;\n    // if (rsize)\n    {\n        for (unsigned ic = 4; ic <= rsize; ic += 4)\n            set_le32(wrkmem + ic, get_le32(wrkmem + ic) - 4);\n        relocsize =\n            optimizeReloc32(wrkmem + 4, rsize / 4, wrkmem, ibuf, file_size, true, &big_relocs);\n    }\n\n    wrkmem[relocsize++] = 0;\n    set_le32(wrkmem + relocsize, ih.entry); // save original entry point\n    relocsize += 4;\n    set_le32(wrkmem + relocsize, relocsize + 4);\n    relocsize += 4;\n    memcpy(ibuf + usize, wrkmem, relocsize);\n\n    // prepare packheader\n    ph.u_len = usize + relocsize;\n    // prepare filter\n    Filter ft(ph.level);\n    ft.buf_len = usize;\n    // compress\n    upx_compress_config_t cconf;\n    cconf.reset();\n    // limit stack size needed for runtime decompression\n    cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack\n    compressWithFilters(&ft, 512, &cconf);\n\n    const unsigned lsize = getLoaderSize();\n    const unsigned s_point = getLoaderSection(\"TMTMAIN1\");\n    int e_len = getLoaderSectionStart(\"TMTCUTPO\");\n    const unsigned d_len = lsize - e_len;\n    assert(e_len > 0 && s_point > 0);\n\n    // patch loader\n    linker->defineSymbol(\"original_entry\", ih.entry);\n    defineDecompressorSymbols();\n    defineFilterSymbols(&ft);\n\n    linker->defineSymbol(\"bytes_to_copy\", ph.c_len + d_len);\n    linker->defineSymbol(\"copy_dest\", 0u - (ph.u_len + ph.overlap_overhead + d_len - 1));\n    linker->defineSymbol(\"copy_source\", ph.c_len + lsize - 1);\n    linker->defineSymbol(\"TMTCUTPO\", ph.u_len + ph.overlap_overhead);\n    relocateLoader();\n\n    MemBuffer loader(lsize);\n    memcpy(loader, getLoader(), lsize);\n    patchPackHeader(loader, e_len);\n\n    memcpy(&oh, &ih, sizeof(oh));\n    oh.imagesize = ph.c_len + lsize; // new size\n    oh.entry = s_point;              // new entry point\n    oh.relocsize = 4;\n\n    // write loader + compressed file\n    fo->write(&oh, sizeof(oh));\n    fo->write(loader, e_len);\n    fo->write(obuf, ph.c_len);\n    fo->write(loader + lsize - d_len, d_len); // decompressor\n    char rel_entry[4];\n    set_le32(rel_entry, 5 + s_point);\n    fo->write(rel_entry, sizeof(rel_entry));\n\n    // verify\n    verifyOverlappingDecompression();\n\n    // copy the overlay\n    copyOverlay(fo, overlay, obuf);\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\nint PackTmt::canUnpack() {\n    if (!readFileHeader())\n        return false;\n    fi->seek(adam_offset, SEEK_SET);\n    return readPackHeader(512) ? 1 : -1;\n}\n\nvoid PackTmt::unpack(OutputFile *fo) {\n    Packer::handleStub(fi, fo, adam_offset);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForDecompression(ph.u_len);\n\n    fi->seek(adam_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // decode relocations\n    const unsigned osize = ph.u_len - get_le32(obuf + ph.u_len - 4);\n    SPAN_P_VAR(upx_byte, relocs, obuf + osize);\n    const unsigned origstart = get_le32(obuf + ph.u_len - 8);\n\n    // unfilter\n    if (ph.filter) {\n        Filter ft(ph.level);\n        ft.init(ph.filter, 0);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(obuf + ph.u_len - 12) >> 24);\n        ft.unfilter(obuf, ptr_udiff_bytes(relocs, obuf));\n    }\n\n    // decode relocations\n    MemBuffer mb_wrkmem;\n    const unsigned relocn = unoptimizeReloc32(relocs, obuf, mb_wrkmem, true);\n    SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem);\n    for (unsigned ic = 0; ic < relocn; ic++)\n        set_le32(wrkmem + ic * 4, get_le32(wrkmem + ic * 4) + 4);\n\n    memcpy(&oh, &ih, sizeof(oh));\n    oh.imagesize = osize;\n    oh.entry = origstart;\n    oh.relocsize = relocn * 4;\n\n    const unsigned overlay = file_size - adam_offset - ih.imagesize - ih.relocsize - sizeof(ih);\n    checkOverlay(overlay);\n\n    // write decompressed file\n    if (fo) {\n        fo->write(&oh, sizeof(oh));\n        fo->write(obuf, osize);\n        fo->write(raw_bytes(wrkmem, relocn * 4), relocn * 4);\n    }\n\n    // copy the overlay\n    copyOverlay(fo, overlay, obuf);\n}\n\n/* vim:set ts=4 sw=4 et: */\n"], "fixing_code": ["/* p_tmt.cpp --\n\n   This file is part of the UPX executable compressor.\n\n   Copyright (C) 1996-2022 Markus Franz Xaver Johannes Oberhumer\n   Copyright (C) 1996-2022 Laszlo Molnar\n   All Rights Reserved.\n\n   UPX and the UCL library are free software; you can redistribute them\n   and/or modify them under the terms of the GNU General Public License as\n   published by the Free Software Foundation; either version 2 of\n   the License, or (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; see the file COPYING.\n   If not, write to the Free Software Foundation, Inc.,\n   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n\n   Markus F.X.J. Oberhumer              Laszlo Molnar\n   <markus@oberhumer.com>               <ezerotven+github@gmail.com>\n */\n\n#include \"conf.h\"\n#include \"file.h\"\n#include \"filter.h\"\n#include \"packer.h\"\n#include \"p_tmt.h\"\n#include \"linker.h\"\n\nstatic const CLANG_FORMAT_DUMMY_STATEMENT\n#include \"stub/i386-dos32.tmt.h\"\n\n#define EXTRA_INFO 4 // original entry point\n\n/*************************************************************************\n//\n**************************************************************************/\n\nPackTmt::PackTmt(InputFile *f) : super(f) {\n    bele = &N_BELE_RTP::le_policy;\n    COMPILE_TIME_ASSERT(sizeof(tmt_header_t) == 44)\n}\n\nconst int *PackTmt::getCompressionMethods(int method, int level) const {\n    return Packer::getDefaultCompressionMethods_le32(method, level);\n}\n\nconst int *PackTmt::getFilters() const {\n    static const int filters[] = {0x26, 0x24,           0x49, 0x46, 0x16, 0x13,  0x14,\n                                  0x11, FT_ULTRA_BRUTE, 0x25, 0x15, 0x12, FT_END};\n    return filters;\n}\n\nunsigned PackTmt::findOverlapOverhead(const upx_bytep buf, const upx_bytep tbuf, unsigned range,\n                                      unsigned upper_limit) const {\n    // make sure the decompressor will be paragraph aligned\n    unsigned o = super::findOverlapOverhead(buf, tbuf, range, upper_limit);\n    o = ((o + 0x20) & ~0xf) - (ph.u_len & 0xf);\n    return o;\n}\n\nLinker *PackTmt::newLinker() const { return new ElfLinkerX86; }\n\nvoid PackTmt::buildLoader(const Filter *ft) {\n    // prepare loader\n    initLoader(stub_i386_dos32_tmt, sizeof(stub_i386_dos32_tmt));\n    addLoader(\"IDENTSTR,TMTMAIN1\", ph.first_offset_found == 1 ? \"TMTMAIN1A\" : \"\", \"TMTMAIN1B\",\n              ft->id ? \"TMTCALT1\" : \"\", \"TMTMAIN2,UPX1HEAD,TMTCUTPO\", nullptr);\n\n    // fake alignment for the start of the decompressor\n    linker->defineSymbol(\"TMTCUTPO\", 0x1000);\n\n    addLoader(getDecompressorSections(), \"TMTMAIN5\", nullptr);\n    if (ft->id) {\n        assert(ft->calls > 0);\n        addLoader(\"TMTCALT2\", nullptr);\n        addFilter32(ft->id);\n    }\n    addLoader(\"TMTRELOC,RELOC320\", big_relocs ? \"REL32BIG\" : \"\", \"RELOC32J,TMTJUMP1\", nullptr);\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nint PackTmt::readFileHeader() {\n#define H(x) get_le16(h + 2 * (x))\n#define H4(x) get_le32(h + (x))\n    unsigned char h[0x40];\n    int ic;\n    unsigned exe_offset = 0;\n    adam_offset = 0;\n\n    for (ic = 0; ic < 20; ic++) {\n        fi->seek(adam_offset, SEEK_SET);\n        fi->readx(h, sizeof(h));\n\n        if (memcmp(h, \"MZ\", 2) == 0) // dos exe\n        {\n            exe_offset = adam_offset;\n            adam_offset += H(2) * 512 + H(1);\n            if (H(1))\n                adam_offset -= 512;\n            if (H(0x18 / 2) == 0x40 && H4(0x3c))\n                adam_offset = H4(0x3c);\n        } else if (memcmp(h, \"BW\", 2) == 0)\n            adam_offset += H(2) * 512 + H(1);\n        else if (memcmp(h, \"PMW1\", 4) == 0) {\n            fi->seek(adam_offset + H4(0x18), SEEK_SET);\n            adam_offset += H4(0x24);\n            int objs = H4(0x1c);\n            while (objs--) {\n                fi->readx(h, 0x18);\n                adam_offset += H4(4);\n            }\n        } else if (memcmp(h, \"LE\", 2) == 0) {\n            // + (memory_pages-1)*memory_page_size+bytes_on_last_page\n            unsigned offs = exe_offset + (H4(0x14) - 1) * H4(0x28) + H4(0x2c);\n            fi->seek(adam_offset + 0x80, SEEK_SET);\n            fi->readx(h, 4);\n            // + data_pages_offset\n            adam_offset = offs + H4(0);\n        } else if (memcmp(h, \"Adam\", 4) == 0)\n            break;\n        else\n            return 0;\n    }\n    if (ic == 20)\n        return 0;\n\n    fi->seek(adam_offset, SEEK_SET);\n    fi->readx(&ih, sizeof(ih));\n    // FIXME: should add more checks for the values in 'ih'\n    unsigned const imagesize = ih.imagesize;\n    unsigned const entry = ih.entry;\n    unsigned const relocsize = ih.relocsize;\n    if (imagesize < sizeof(ih) || entry < sizeof(ih) || file_size <= imagesize ||\n        file_size <= entry || file_size <= relocsize) {\n        printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,\n                  entry, relocsize);\n        return 0;\n    }\n\n    return UPX_F_TMT_ADAM;\n#undef H4\n#undef H\n}\n\nbool PackTmt::canPack() {\n    if (!readFileHeader())\n        return false;\n    return true;\n}\n\n/*************************************************************************\n//\n**************************************************************************/\n\nvoid PackTmt::pack(OutputFile *fo) {\n    big_relocs = 0;\n\n    Packer::handleStub(fi, fo, adam_offset);\n\n    const unsigned usize = ih.imagesize;\n    const unsigned rsize = ih.relocsize;\n\n    ibuf.alloc(usize + rsize + 128);\n    obuf.allocForCompression(usize + rsize + 128);\n\n    MemBuffer mb_wrkmem;\n    mb_wrkmem.alloc(rsize + EXTRA_INFO + 4); // relocations + original entry point + relocsize\n    SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem);\n\n    fi->seek(adam_offset + sizeof(ih), SEEK_SET);\n    fi->readx(ibuf, usize);\n    fi->readx(wrkmem + 4, rsize);\n    const unsigned overlay = file_size - fi->tell();\n\n    if (find_le32(ibuf, UPX_MIN(128u, usize), get_le32(\"UPX \")) >= 0)\n        throwAlreadyPacked();\n    if (rsize == 0)\n        throwCantPack(\"file is already compressed with another packer\");\n\n    checkOverlay(overlay);\n\n    unsigned relocsize = 0;\n    // if (rsize)\n    {\n        for (unsigned ic = 4; ic <= rsize; ic += 4)\n            set_le32(wrkmem + ic, get_le32(wrkmem + ic) - 4);\n        relocsize =\n            optimizeReloc32(wrkmem + 4, rsize / 4, wrkmem, ibuf, file_size, true, &big_relocs);\n    }\n\n    wrkmem[relocsize++] = 0;\n    set_le32(wrkmem + relocsize, ih.entry); // save original entry point\n    relocsize += 4;\n    set_le32(wrkmem + relocsize, relocsize + 4);\n    relocsize += 4;\n    memcpy(ibuf + usize, wrkmem, relocsize);\n\n    // prepare packheader\n    ph.u_len = usize + relocsize;\n    // prepare filter\n    Filter ft(ph.level);\n    ft.buf_len = usize;\n    // compress\n    upx_compress_config_t cconf;\n    cconf.reset();\n    // limit stack size needed for runtime decompression\n    cconf.conf_lzma.max_num_probs = 1846 + (768 << 4); // ushort: ~28 KiB stack\n    compressWithFilters(&ft, 512, &cconf);\n\n    const unsigned lsize = getLoaderSize();\n    const unsigned s_point = getLoaderSection(\"TMTMAIN1\");\n    int e_len = getLoaderSectionStart(\"TMTCUTPO\");\n    const unsigned d_len = lsize - e_len;\n    assert(e_len > 0 && s_point > 0);\n\n    // patch loader\n    linker->defineSymbol(\"original_entry\", ih.entry);\n    defineDecompressorSymbols();\n    defineFilterSymbols(&ft);\n\n    linker->defineSymbol(\"bytes_to_copy\", ph.c_len + d_len);\n    linker->defineSymbol(\"copy_dest\", 0u - (ph.u_len + ph.overlap_overhead + d_len - 1));\n    linker->defineSymbol(\"copy_source\", ph.c_len + lsize - 1);\n    linker->defineSymbol(\"TMTCUTPO\", ph.u_len + ph.overlap_overhead);\n    relocateLoader();\n\n    MemBuffer loader(lsize);\n    memcpy(loader, getLoader(), lsize);\n    patchPackHeader(loader, e_len);\n\n    memcpy(&oh, &ih, sizeof(oh));\n    oh.imagesize = ph.c_len + lsize; // new size\n    oh.entry = s_point;              // new entry point\n    oh.relocsize = 4;\n\n    // write loader + compressed file\n    fo->write(&oh, sizeof(oh));\n    fo->write(loader, e_len);\n    fo->write(obuf, ph.c_len);\n    fo->write(loader + lsize - d_len, d_len); // decompressor\n    char rel_entry[4];\n    set_le32(rel_entry, 5 + s_point);\n    fo->write(rel_entry, sizeof(rel_entry));\n\n    // verify\n    verifyOverlappingDecompression();\n\n    // copy the overlay\n    copyOverlay(fo, overlay, obuf);\n\n    // finally check the compression ratio\n    if (!checkFinalCompressionRatio(fo))\n        throwNotCompressible();\n}\n\nint PackTmt::canUnpack() {\n    if (!readFileHeader())\n        return false;\n    fi->seek(adam_offset, SEEK_SET);\n    return readPackHeader(512) ? 1 : -1;\n}\n\nvoid PackTmt::unpack(OutputFile *fo) {\n    Packer::handleStub(fi, fo, adam_offset);\n\n    ibuf.alloc(ph.c_len);\n    obuf.allocForDecompression(ph.u_len);\n\n    fi->seek(adam_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);\n    fi->readx(ibuf, ph.c_len);\n\n    // decompress\n    decompress(ibuf, obuf);\n\n    // decode relocations\n    const unsigned osize = ph.u_len - get_le32(obuf + ph.u_len - 4);\n    SPAN_P_VAR(upx_byte, relocs, obuf + osize);\n    const unsigned origstart = get_le32(obuf + ph.u_len - 8);\n\n    // unfilter\n    if (ph.filter) {\n        Filter ft(ph.level);\n        ft.init(ph.filter, 0);\n        ft.cto = (unsigned char) ph.filter_cto;\n        if (ph.version < 11)\n            ft.cto = (unsigned char) (get_le32(obuf + ph.u_len - 12) >> 24);\n        ft.unfilter(obuf, ptr_udiff_bytes(relocs, obuf));\n    }\n\n    // decode relocations\n    MemBuffer mb_wrkmem;\n    const unsigned relocn = unoptimizeReloc32(relocs, obuf, mb_wrkmem, true);\n    SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem);\n    for (unsigned ic = 0; ic < relocn; ic++)\n        set_le32(wrkmem + ic * 4, get_le32(wrkmem + ic * 4) + 4);\n\n    memcpy(&oh, &ih, sizeof(oh));\n    oh.imagesize = osize;\n    oh.entry = origstart;\n    oh.relocsize = relocn * 4;\n\n    const unsigned overlay = file_size - adam_offset - ih.imagesize - ih.relocsize - sizeof(ih);\n    checkOverlay(overlay);\n\n    // write decompressed file\n    if (fo) {\n        fo->write(&oh, sizeof(oh));\n        fo->write(obuf, osize);\n        fo->write(raw_bytes(wrkmem, relocn * 4), relocn * 4);\n    }\n\n    // copy the overlay\n    copyOverlay(fo, overlay, obuf);\n}\n\n/* vim:set ts=4 sw=4 et: */\n"], "filenames": ["src/p_tmt.cpp"], "buggy_code_start_loc": [142], "buggy_code_end_loc": [184], "fixing_code_start_loc": [142], "fixing_code_end_loc": [185], "type": "CWE-787", "message": "A heap-based buffer overflow issue was discovered in UPX in PackTmt::pack() in p_tmt.cpp file. The flow allows an attacker to cause a denial of service (abort) via a crafted file.", "other": {"cve": {"id": "CVE-2023-23456", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2023-01-12T19:15:24.693", "lastModified": "2023-01-23T15:21:39.870", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A heap-based buffer overflow issue was discovered in UPX in PackTmt::pack() in p_tmt.cpp file. The flow allows an attacker to cause a denial of service (abort) via a crafted file."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-122"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:upx_project:upx:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-11-24", "matchCriteriaId": "CB529776-278E-419A-B8E1-F7A101A77E24"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2160381", "source": "patrick@puiterwijk.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/upx/upx/commit/510505a85cbe45e51fbd470f1aa8b02157c429d4", "source": "patrick@puiterwijk.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/upx/upx/issues/632", "source": "patrick@puiterwijk.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EL3BVKIGG3SH6I3KPOYQAWCBD4UMPOPI/", "source": "patrick@puiterwijk.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TGEP3FBNRZXGLIA2B2ICMB32JVMPREFZ/", "source": "patrick@puiterwijk.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/upx/upx/commit/510505a85cbe45e51fbd470f1aa8b02157c429d4"}}