{"buggy_code": ["#\n# Monitorix - A lightweight system monitoring tool.\n#\n# Copyright (C) 2005-2020 by Jordi Sanfeliu <jordi@fibranet.cat>\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along\n# with this program; if not, write to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n#\n\npackage HTTPServer;\n\nuse strict;\nuse warnings;\nuse Monitorix qw(trim);\nuse POSIX qw(strftime);\nuse HTTP::Server::Simple::CGI;\nuse base qw(HTTP::Server::Simple::CGI);\nuse MIME::Base64 qw(decode_base64);\nuse Socket;\n\nsub logger {\n\tmy ($url, $type) = @_;\n\n\tif($main::config{httpd_builtin}->{log_file}) {\n\t\tif(open(OUT, \">> $main::config{httpd_builtin}->{log_file}\")) {\n\t\t\tif($type eq \"OK\") {\n\t\t\t\tprint OUT localtime() . \" - $type - [$ENV{REMOTE_ADDR}] \\\"$ENV{REQUEST_METHOD} $url - \" . ($ENV{HTTP_USER_AGENT} || \"\") . \"\\\"\\n\";\n\t\t\t} elsif($type eq \"NOTEXIST\") {\n\t\t\t\tprint OUT localtime() . \" - $type - [$ENV{REMOTE_ADDR}] File does not exist: $url\\n\";\n\t\t\t} elsif($type eq \"AUTHERR\") {\n\t\t\t\tprint OUT localtime() . \" - $type - [$ENV{REMOTE_ADDR}] Authentication error: $url\\n\";\n\t\t\t} elsif($type eq \"NOTALLOWED\") {\n\t\t\t\tprint OUT localtime() . \" - $type - [$ENV{REMOTE_ADDR}] Access not allowed: $url\\n\";\n\t\t\t} else {\n\t\t\t\tprint OUT localtime() . \" - $type - [$ENV{REMOTE_ADDR}] $url\\n\";\n\t\t\t}\n\t\t\tclose(OUT);\n\t\t} else {\n\t\t\tprint STDERR localtime() . \" - ERROR: unable to open logfile '$main::config{httpd_builtin}->{log_file}'.\\n\";\n\t\t}\n\t} else {\n\t\tmy $msg;\n\t\tif($type eq \"OK\") {\n\t\t\t$msg = localtime() . \" - $type - [$ENV{REMOTE_ADDR}] \\\"$ENV{REQUEST_METHOD} $url - \" . ($ENV{HTTP_USER_AGENT} || \"\") . \"\\\"\\n\";\n\t\t} elsif($type eq \"NOTEXIST\") {\n\t\t\t$msg = localtime() . \" - $type - [$ENV{REMOTE_ADDR}] File does not exist: $url\\n\";\n\t\t} elsif($type eq \"AUTHERR\") {\n\t\t\t$msg = localtime() . \" - $type - [$ENV{REMOTE_ADDR}] Authentication error: $url\\n\";\n\t\t} elsif($type eq \"NOTALLOWED\") {\n\t\t\t$msg = localtime() . \" - $type - [$ENV{REMOTE_ADDR}] Access not allowed: $url\\n\";\n\t\t} else {\n\t\t\t$msg = localtime() . \" - $type - [$ENV{REMOTE_ADDR}] $url\\n\";\n\t\t}\n\t\tprint(\"$msg\");\n\t}\n}\n\nsub check_passwd {\n\tmy ($user, $pass) = @_;\n\n\tif(open(IN, $main::config{httpd_builtin}->{auth}->{htpasswd})) {\n\t\twhile(<IN>) {\n\t\t\tmy $line = trim($_);\n\n\t\t\t# append character ':' if not exist\n\t\t\tif(index($line, \":\") < 0) {\n\t\t\t\tlogger(\"Malformed line in \" . $main::config{httpd_builtin}->{auth}->{htpasswd}, \"ERROR\");\n\t\t\t\t$line .= \":\" if index($line, \":\") < 0;\n\t\t\t}\n\n\t\t\t# discard that line if password is missing\n\t\t\tif(length($line) == index($line, \":\") + 1) {\n\t\t\t\tlogger(\"Malformed line in \" . $main::config{httpd_builtin}->{auth}->{htpasswd}, \"ERROR\");\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\tmy %pair = split(':', $line);\n\t\t\tif($pair{$user || \"\"}) {\n\t\t\t\tchomp($pair{$user});\n\t\t\t\tif(crypt($pass, $pair{$user}) ne $pair{$user}) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tclose(IN);\n\t} else {\n\t\tprint STDERR localtime() . \" - ERROR: can't open file '$main::config{httpd_builtin}->{auth}->{htpasswd}'.\\n\";\n\t}\n\treturn 1;\n}\n\nsub ip_validity {\n\tmy ($myip, $hosts) = @_;\n\tmy $valid = 0;\n\n\tforeach my $address (split(',', $hosts)) {\n\t\tmy $myip_bin = inet_aton($myip);\n\n\t\t$address = \"0.0.0.0/0\" if $address eq \"all\";\n\t\tmy ($ip, $netmask) = split('/', trim($address) . \"/\");\n\t\tmy $ip_bin = inet_aton($ip);\n\n\t\t$netmask = \"255.255.255.255\" if $netmask eq \"\";\n\t\t$netmask = unpack(\"%32b*\", inet_aton($netmask)) if length($netmask) > 2;\n\t\tmy $netmask_bin = ~pack(\"N\", (2**(32-$netmask))-1);\n\n\t\tmy $first_valid = unpack(\"N\", $ip_bin & $netmask_bin) + ($netmask eq \"32\" ? 0 : 1);\n\t\tmy $last_valid = unpack(\"N\", $ip_bin | ~$netmask_bin) - ($netmask eq \"32\" ? 0 : 1);\n\n\t\t$myip_bin = unpack(\"N\", $myip_bin);\n\t\tif($myip_bin >= $first_valid && $myip_bin <= $last_valid) {\n\t\t\t$valid++;\n\t\t}\n\t}\n\treturn $valid;\n}\n\nsub http_header {\n\tmy ($code, $mimetype) = @_;\n\tmy $msg = $main::config{httpd_builtin}->{auth}->{msg} || \"\";\n\tmy $hosts_deny = $main::config{httpd_builtin}->{auth}->{hosts_deny} || \"\";\n\tmy $hosts_allow = $main::config{httpd_builtin}->{auth}->{hosts_allow} || \"\";\n\n\tif($code eq \"200\") {\n\t\tprint \"HTTP/1.0 200 OK\\r\\n\";\n\t} elsif($code eq \"401\") {\n\t\t# check if the IP address is forced to auth\n\t\tmy $denied;\n\t\tmy $allowed = ip_validity($ENV{REMOTE_ADDR}, $hosts_allow);\n\t\t$denied = ip_validity($ENV{REMOTE_ADDR}, $hosts_deny) if !$allowed;\n\t\tif(!$allowed && $denied) {\n\t\t\tmy (undef, $encoded_str) = split(' ', $ENV{HTTP_AUTHORIZATION} || \"\");\n\t\t\tmy ($user, $pass) = split(':', decode_base64($encoded_str || \":\"));\n\n\t\t\tif(check_passwd($user, $pass)) {\n\t\t\t\tprint \"HTTP/1.0 401 Access Denied\\r\\n\";\n\t\t\t\tprint \"WWW-Authenticate: Basic realm=\\\"$msg\\\"\\r\\n\";\n\t\t\t\tprint \"Content-Length: 0\\r\\n\";\n\t\t\t\tprint \"\\r\\n\";\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t} elsif($code eq \"404\") {\n\t\tprint \"HTTP/1.0 404 Not found\\r\\n\";\n\t} else {\n\t\tprint \"HTTP/1.0 403 Forbidden\\r\\n\";\n\t}\n\n\tprint \"Date: \" . strftime(\"%a, %d %b %Y %H:%M:%S %z\", localtime) . \"\\r\\n\";\n\tprint \"Server: Monitorix HTTP Server\\r\\n\";\n\tprint \"Connection: close\\r\\n\";\n\n\tif($mimetype =~ m/(html|cgi)/) {\n\t\tprint \"Content-Type: text/html; charset=UTF-8\\r\\n\";\n\t} elsif($mimetype eq \"css\") {\n\t\tprint \"Content-Type: text/css; charset=UTF-8\\r\\n\";\n\t} elsif($mimetype eq \"svg\") {\n\t\tprint \"Content-Type: image/svg+xml; charset=UTF-8\\r\\n\";\n\t} else {\n\t\tprint \"Content-Type: image/$mimetype;\\r\\n\";\n\t}\n\n\tprint \"\\r\\n\";\n\treturn 0;\n}\n\nsub handle_request {\n\tmy ($self, $cgi) = @_;\n\tmy $base_url = $main::config{base_url};\n\tmy $base_cgi = $main::config{base_cgi};\n\tmy $host = $main::config{httpd_builtin}->{host} || \"localhost\";\n\tmy $port = $main::config{httpd_builtin}->{port} || \"8080\";\n\tmy $hosts_deny = $main::config{httpd_builtin}->{hosts_deny} || \"\";\n\tmy $hosts_allow = $main::config{httpd_builtin}->{hosts_allow} || \"\";\n\tmy $auth = lc($main::config{httpd_builtin}->{auth}->{enabled});\n\tmy $mimetype;\n\tmy $target;\n\tmy $target_cgi;\n\tmy @data;\n\tmy $OK_CHARS='-a-zA-Z0-9_./';\t# a restrictive list of valid chars\n\n\treturn if fork();\t# parent returns\n\n\tmy $url = $cgi->path_info();\n\tmy $url_disarmed = $url;\n\n\t# this should disarm all XSS and Cookie Injection attempts\n\t$url_disarmed =~ s/\\&/&amp;/g;\n\t$url_disarmed =~ s/\\</&lt;/g;\n\t$url_disarmed =~ s/\\>/&gt;/g;\n\t$url_disarmed =~ s/\\\"/&quot;/g;\n\t$url_disarmed =~ s/\\'/&#x27;/g;\n\t$url_disarmed =~ s/\\(/&#x28;/g;\n\t$url_disarmed =~ s/\\)/&#x29;/g;\n\t$url_disarmed =~ s/\\//&#x2F;/g;\n\n\t$0 = \"monitorix-httpd\";\t# change process' name\n\n\t# check if the IP address is allowed to connect\n\tmy $denied;\n\tmy $allowed = ip_validity($ENV{REMOTE_ADDR}, $hosts_allow);\n\t$denied = ip_validity($ENV{REMOTE_ADDR}, $hosts_deny) if !$allowed;\n\tif(!$allowed && $denied) {\n\t\thttp_header(\"403\", \"html\");\n\t\tprint(\"<!DOCTYPE html '-//W3C//DTD HTML 4.01 Final//EN'>\\r\\n\");\n\t\tprint \"<html><head>\\r\\n\";\n\t\tprint \"<title>403 Forbidden</title>\\r\\n\";\n\t\tprint \"</head><body>\\r\\n\";\n\t\tprint \"<h1>Forbidden</h1>\\r\\n\";\n\t\tprint \"<p>You don't have permission to access $url_disarmed\\r\\n\";\n\t\tprint \"on this server.</p>\\r\\n\";\n\t\tprint \"<hr>\\r\\n\";\n\t\tprint \"<address>Monitorix HTTP Server listening at $host Port $port</address>\\r\\n\";\n\t\tprint \"</body></html>\\r\\n\";\n\t\tlogger($url, \"NOTALLOWED\");\n\t\texit(0);\n\t}\n\n\t# sanitizes the $target\n\t$target = $url;\n\twhile() {\n\t\tmy $cur = length($target);\n\t\t$target =~ s/\\.\\.\\///;\n\t\t$target =~ s/^\\///;\n\t\t$target =~ s/\\/$//;\n\t\tlast unless $cur ne length($target);\n\t}\n\t$target = $target_cgi = \"/$target\";\n\n\t$target =~ s/^$base_url//;\t# removes the 'base_url' part\n\t$target_cgi =~ s/^$base_cgi//;\t# removes the 'base_cgi' part\n\tif(!$target || $target eq $base_url) {\n\t\t$target = \"index.html\" unless $target;\n\t}\n\t($mimetype) = ($target =~ m/.*\\.(html|cgi|css|png|svg)$/);\n\n\t$target =~ s/^\\/*//;\t\t# removes leading slashes\n\t$target_cgi =~ s/^\\/*//;\t# removes leading slashes\n\n\t$target =~ s/[^$OK_CHARS]/_/go;\t\t# only $OK_CHARS are allowed\n\t$target_cgi =~ s/[^$OK_CHARS]/_/go;\t# only $OK_CHARS are allowed\n\n\tif($target_cgi eq \"monitorix.cgi\") {\n\t\tchdir(\"cgi\");\n\t\topen(EXEC, \"./$target_cgi |\");\n\t\t@data = <EXEC>;\n\t\tclose(EXEC);\n\t} elsif($target) {\n\t\tif(open(IN, $target)) {\n\t\t\t@data = <IN>;\n\t\t\tclose(IN);\n\t\t}\n\t}\n\n\tif($auth eq \"y\") {\n\t\tif(http_header(\"401\", $mimetype)) {\n\t\t\tprint(\"<!DOCTYPE html '-//W3C//DTD HTML 4.01 Final//EN'>\\r\\n\");\n\t\t\tprint \"<html><head>\\r\\n\";\n\t\t\tprint \"<title>401 Authorization Required</title>\\r\\n\";\n\t\t\tprint \"</head><body>\\r\\n\";\n\t\t\tprint \"<h1>Authorization Required</h1>\\r\\n\";\n\t\t\tprint \"<p>This server could not verify that you\\r\\n\";\n\t\t\tprint \"are authorized to access the document\\r\\n\";\n\t\t\tprint \"requested.  Either you supplied the wrong\\r\\n\";\n\t\t\tprint \"credentials (e.g., bad password), or your\\r\\n\";\n\t\t\tprint \"browser doesn't understand how to supply\\r\\n\";\n\t\t\tprint \"the credentials required.</p>\\r\\n\";\n\t\t\tprint \"</body></html>\\r\\n\";\n\t\t\tlogger($url, \"AUTHERR\");\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tif(scalar(@data)) {\n\t\thttp_header(\"200\", $mimetype);\n\t\tforeach(@data) {\n\t\t\tprint $_;\n\t\t}\n\t\tlogger($url, \"OK\");\n\t} else {\n\t\thttp_header(\"404\", \"html\");\n\t\tprint(\"<!DOCTYPE html '-//W3C//DTD HTML 4.01 Final//EN'>\\r\\n\");\n\t\tprint \"<html><head>\\r\\n\";\n\t\tprint \"<title>404 Not Found</title>\\r\\n\";\n\t\tprint \"</head><body>\\r\\n\";\n\t\tprint \"<h1>Not Found</h1>\\r\\n\";\n\t\tprint \"The requested URL $url_disarmed was not found on this server.<p>\\r\\n\";\n\t\tprint \"<hr>\\r\\n\";\n\t\tprint \"<address>Monitorix HTTP Server listening at $host Port $port</address>\\r\\n\";\n\t\tprint \"</body></html>\\r\\n\";\n\t\tlogger($url, \"NOTEXIST\");\n\t}\n\n\texit(0);\n}\n\n1;\n"], "fixing_code": ["#\n# Monitorix - A lightweight system monitoring tool.\n#\n# Copyright (C) 2005-2020 by Jordi Sanfeliu <jordi@fibranet.cat>\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along\n# with this program; if not, write to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n#\n\npackage HTTPServer;\n\nuse strict;\nuse warnings;\nuse Monitorix qw(trim);\nuse POSIX qw(strftime);\nuse HTTP::Server::Simple::CGI;\nuse base qw(HTTP::Server::Simple::CGI);\nuse MIME::Base64 qw(decode_base64);\nuse Socket;\n\nsub logger {\n\tmy ($url, $type) = @_;\n\n\tif($main::config{httpd_builtin}->{log_file}) {\n\t\tif(open(OUT, \">> $main::config{httpd_builtin}->{log_file}\")) {\n\t\t\tif($type eq \"OK\") {\n\t\t\t\tprint OUT localtime() . \" - $type - [$ENV{REMOTE_ADDR}] \\\"$ENV{REQUEST_METHOD} $url - \" . ($ENV{HTTP_USER_AGENT} || \"\") . \"\\\"\\n\";\n\t\t\t} elsif($type eq \"NOTEXIST\") {\n\t\t\t\tprint OUT localtime() . \" - $type - [$ENV{REMOTE_ADDR}] File does not exist: $url\\n\";\n\t\t\t} elsif($type eq \"AUTHERR\") {\n\t\t\t\tprint OUT localtime() . \" - $type - [$ENV{REMOTE_ADDR}] Authentication error: $url\\n\";\n\t\t\t} elsif($type eq \"NOTALLOWED\") {\n\t\t\t\tprint OUT localtime() . \" - $type - [$ENV{REMOTE_ADDR}] Access not allowed: $url\\n\";\n\t\t\t} else {\n\t\t\t\tprint OUT localtime() . \" - $type - [$ENV{REMOTE_ADDR}] $url\\n\";\n\t\t\t}\n\t\t\tclose(OUT);\n\t\t} else {\n\t\t\tprint STDERR localtime() . \" - ERROR: unable to open logfile '$main::config{httpd_builtin}->{log_file}'.\\n\";\n\t\t}\n\t} else {\n\t\tmy $msg;\n\t\tif($type eq \"OK\") {\n\t\t\t$msg = localtime() . \" - $type - [$ENV{REMOTE_ADDR}] \\\"$ENV{REQUEST_METHOD} $url - \" . ($ENV{HTTP_USER_AGENT} || \"\") . \"\\\"\\n\";\n\t\t} elsif($type eq \"NOTEXIST\") {\n\t\t\t$msg = localtime() . \" - $type - [$ENV{REMOTE_ADDR}] File does not exist: $url\\n\";\n\t\t} elsif($type eq \"AUTHERR\") {\n\t\t\t$msg = localtime() . \" - $type - [$ENV{REMOTE_ADDR}] Authentication error: $url\\n\";\n\t\t} elsif($type eq \"NOTALLOWED\") {\n\t\t\t$msg = localtime() . \" - $type - [$ENV{REMOTE_ADDR}] Access not allowed: $url\\n\";\n\t\t} else {\n\t\t\t$msg = localtime() . \" - $type - [$ENV{REMOTE_ADDR}] $url\\n\";\n\t\t}\n\t\tprint(\"$msg\");\n\t}\n}\n\nsub check_passwd {\n\tmy ($user, $pass) = @_;\n\n\tif(open(IN, $main::config{httpd_builtin}->{auth}->{htpasswd})) {\n\t\twhile(<IN>) {\n\t\t\tmy $line = trim($_);\n\n\t\t\t# append character ':' if not exist\n\t\t\tif(index($line, \":\") < 0) {\n\t\t\t\tlogger(\"Malformed line in \" . $main::config{httpd_builtin}->{auth}->{htpasswd}, \"ERROR\");\n\t\t\t\t$line .= \":\" if index($line, \":\") < 0;\n\t\t\t}\n\n\t\t\t# discard that line if password is missing\n\t\t\tif(length($line) == index($line, \":\") + 1) {\n\t\t\t\tlogger(\"Malformed line in \" . $main::config{httpd_builtin}->{auth}->{htpasswd}, \"ERROR\");\n\t\t\t\tnext;\n\t\t\t}\n\n\t\t\tmy %pair = split(':', $line);\n\t\t\tif($pair{$user || \"\"}) {\n\t\t\t\tchomp($pair{$user});\n\t\t\t\tif(crypt($pass, $pair{$user}) ne $pair{$user}) {\n\t\t\t\t\tnext;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tclose(IN);\n\t} else {\n\t\tprint STDERR localtime() . \" - ERROR: can't open file '$main::config{httpd_builtin}->{auth}->{htpasswd}'.\\n\";\n\t}\n\treturn 1;\n}\n\nsub ip_validity {\n\tmy ($myip, $hosts) = @_;\n\tmy $valid = 0;\n\n\tforeach my $address (split(',', $hosts)) {\n\t\tmy $myip_bin = inet_aton($myip);\n\n\t\t$address = \"0.0.0.0/0\" if $address eq \"all\";\n\t\tmy ($ip, $netmask) = split('/', trim($address) . \"/\");\n\t\tmy $ip_bin = inet_aton($ip);\n\n\t\t$netmask = \"255.255.255.255\" if $netmask eq \"\";\n\t\t$netmask = unpack(\"%32b*\", inet_aton($netmask)) if length($netmask) > 2;\n\t\tmy $netmask_bin = ~pack(\"N\", (2**(32-$netmask))-1);\n\n\t\tmy $first_valid = unpack(\"N\", $ip_bin & $netmask_bin) + ($netmask eq \"32\" ? 0 : 1);\n\t\tmy $last_valid = unpack(\"N\", $ip_bin | ~$netmask_bin) - ($netmask eq \"32\" ? 0 : 1);\n\n\t\t$myip_bin = unpack(\"N\", $myip_bin);\n\t\tif($myip_bin >= $first_valid && $myip_bin <= $last_valid) {\n\t\t\t$valid++;\n\t\t}\n\t}\n\treturn $valid;\n}\n\nsub http_header {\n\tmy ($code, $mimetype) = @_;\n\tmy $msg = $main::config{httpd_builtin}->{auth}->{msg} || \"\";\n\tmy $hosts_deny = $main::config{httpd_builtin}->{auth}->{hosts_deny} || \"\";\n\tmy $hosts_allow = $main::config{httpd_builtin}->{auth}->{hosts_allow} || \"\";\n\n\tif($code eq \"200\") {\n\t\tprint \"HTTP/1.0 200 OK\\r\\n\";\n\t} elsif($code eq \"401\") {\n\t\t# check if the IP address is forced to auth\n\t\tmy $denied;\n\t\tmy $allowed = ip_validity($ENV{REMOTE_ADDR}, $hosts_allow);\n\n\t\t# specific behavior\n\t\t$hosts_deny = \"all\" if !$hosts_deny;\n\n\t\t$denied = ip_validity($ENV{REMOTE_ADDR}, $hosts_deny) if !$allowed;\n\t\tif(!$allowed && $denied) {\n\t\t\tmy (undef, $encoded_str) = split(' ', $ENV{HTTP_AUTHORIZATION} || \"\");\n\t\t\tmy ($user, $pass) = split(':', decode_base64($encoded_str || \":\"));\n\n\t\t\tif(check_passwd($user, $pass)) {\n\t\t\t\tprint \"HTTP/1.0 401 Access Denied\\r\\n\";\n\t\t\t\tprint \"WWW-Authenticate: Basic realm=\\\"$msg\\\"\\r\\n\";\n\t\t\t\tprint \"Content-Length: 0\\r\\n\";\n\t\t\t\tprint \"\\r\\n\";\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t} elsif($code eq \"404\") {\n\t\tprint \"HTTP/1.0 404 Not found\\r\\n\";\n\t} else {\n\t\tprint \"HTTP/1.0 403 Forbidden\\r\\n\";\n\t}\n\n\tprint \"Date: \" . strftime(\"%a, %d %b %Y %H:%M:%S %z\", localtime) . \"\\r\\n\";\n\tprint \"Server: Monitorix HTTP Server\\r\\n\";\n\tprint \"Connection: close\\r\\n\";\n\n\tif($mimetype =~ m/(html|cgi)/) {\n\t\tprint \"Content-Type: text/html; charset=UTF-8\\r\\n\";\n\t} elsif($mimetype eq \"css\") {\n\t\tprint \"Content-Type: text/css; charset=UTF-8\\r\\n\";\n\t} elsif($mimetype eq \"svg\") {\n\t\tprint \"Content-Type: image/svg+xml; charset=UTF-8\\r\\n\";\n\t} else {\n\t\tprint \"Content-Type: image/$mimetype;\\r\\n\";\n\t}\n\n\tprint \"\\r\\n\";\n\treturn 0;\n}\n\nsub handle_request {\n\tmy ($self, $cgi) = @_;\n\tmy $base_url = $main::config{base_url};\n\tmy $base_cgi = $main::config{base_cgi};\n\tmy $host = $main::config{httpd_builtin}->{host} || \"localhost\";\n\tmy $port = $main::config{httpd_builtin}->{port} || \"8080\";\n\tmy $hosts_deny = $main::config{httpd_builtin}->{hosts_deny} || \"\";\n\tmy $hosts_allow = $main::config{httpd_builtin}->{hosts_allow} || \"\";\n\tmy $auth = lc($main::config{httpd_builtin}->{auth}->{enabled});\n\tmy $mimetype;\n\tmy $target;\n\tmy $target_cgi;\n\tmy @data;\n\tmy $OK_CHARS='-a-zA-Z0-9_./';\t# a restrictive list of valid chars\n\n\treturn if fork();\t# parent returns\n\n\tmy $url = $cgi->path_info();\n\tmy $url_disarmed = $url;\n\n\t# this should disarm all XSS and Cookie Injection attempts\n\t$url_disarmed =~ s/\\&/&amp;/g;\n\t$url_disarmed =~ s/\\</&lt;/g;\n\t$url_disarmed =~ s/\\>/&gt;/g;\n\t$url_disarmed =~ s/\\\"/&quot;/g;\n\t$url_disarmed =~ s/\\'/&#x27;/g;\n\t$url_disarmed =~ s/\\(/&#x28;/g;\n\t$url_disarmed =~ s/\\)/&#x29;/g;\n\t$url_disarmed =~ s/\\//&#x2F;/g;\n\n\t$0 = \"monitorix-httpd\";\t# change process' name\n\n\t# check if the IP address is allowed to connect\n\tmy $denied;\n\tmy $allowed = ip_validity($ENV{REMOTE_ADDR}, $hosts_allow);\n\t$denied = ip_validity($ENV{REMOTE_ADDR}, $hosts_deny) if !$allowed;\n\tif(!$allowed && $denied) {\n\t\thttp_header(\"403\", \"html\");\n\t\tprint(\"<!DOCTYPE html '-//W3C//DTD HTML 4.01 Final//EN'>\\r\\n\");\n\t\tprint \"<html><head>\\r\\n\";\n\t\tprint \"<title>403 Forbidden</title>\\r\\n\";\n\t\tprint \"</head><body>\\r\\n\";\n\t\tprint \"<h1>Forbidden</h1>\\r\\n\";\n\t\tprint \"<p>You don't have permission to access $url_disarmed\\r\\n\";\n\t\tprint \"on this server.</p>\\r\\n\";\n\t\tprint \"<hr>\\r\\n\";\n\t\tprint \"<address>Monitorix HTTP Server listening at $host Port $port</address>\\r\\n\";\n\t\tprint \"</body></html>\\r\\n\";\n\t\tlogger($url, \"NOTALLOWED\");\n\t\texit(0);\n\t}\n\n\t# sanitizes the $target\n\t$target = $url;\n\twhile() {\n\t\tmy $cur = length($target);\n\t\t$target =~ s/\\.\\.\\///;\n\t\t$target =~ s/^\\///;\n\t\t$target =~ s/\\/$//;\n\t\tlast unless $cur ne length($target);\n\t}\n\t$target = $target_cgi = \"/$target\";\n\n\t$target =~ s/^$base_url//;\t# removes the 'base_url' part\n\t$target_cgi =~ s/^$base_cgi//;\t# removes the 'base_cgi' part\n\tif(!$target || $target eq $base_url) {\n\t\t$target = \"index.html\" unless $target;\n\t}\n\t($mimetype) = ($target =~ m/.*\\.(html|cgi|css|png|svg)$/);\n\n\t$target =~ s/^\\/*//;\t\t# removes leading slashes\n\t$target_cgi =~ s/^\\/*//;\t# removes leading slashes\n\n\t$target =~ s/[^$OK_CHARS]/_/go;\t\t# only $OK_CHARS are allowed\n\t$target_cgi =~ s/[^$OK_CHARS]/_/go;\t# only $OK_CHARS are allowed\n\n\tif($target_cgi eq \"monitorix.cgi\") {\n\t\tchdir(\"cgi\");\n\t\topen(EXEC, \"./$target_cgi |\");\n\t\t@data = <EXEC>;\n\t\tclose(EXEC);\n\t} elsif($target) {\n\t\tif(open(IN, $target)) {\n\t\t\t@data = <IN>;\n\t\t\tclose(IN);\n\t\t}\n\t}\n\n\tif($auth eq \"y\") {\n\t\tif(http_header(\"401\", $mimetype)) {\n\t\t\tprint(\"<!DOCTYPE html '-//W3C//DTD HTML 4.01 Final//EN'>\\r\\n\");\n\t\t\tprint \"<html><head>\\r\\n\";\n\t\t\tprint \"<title>401 Authorization Required</title>\\r\\n\";\n\t\t\tprint \"</head><body>\\r\\n\";\n\t\t\tprint \"<h1>Authorization Required</h1>\\r\\n\";\n\t\t\tprint \"<p>This server could not verify that you\\r\\n\";\n\t\t\tprint \"are authorized to access the document\\r\\n\";\n\t\t\tprint \"requested.  Either you supplied the wrong\\r\\n\";\n\t\t\tprint \"credentials (e.g., bad password), or your\\r\\n\";\n\t\t\tprint \"browser doesn't understand how to supply\\r\\n\";\n\t\t\tprint \"the credentials required.</p>\\r\\n\";\n\t\t\tprint \"</body></html>\\r\\n\";\n\t\t\tlogger($url, \"AUTHERR\");\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tif(scalar(@data)) {\n\t\thttp_header(\"200\", $mimetype);\n\t\tforeach(@data) {\n\t\t\tprint $_;\n\t\t}\n\t\tlogger($url, \"OK\");\n\t} else {\n\t\thttp_header(\"404\", \"html\");\n\t\tprint(\"<!DOCTYPE html '-//W3C//DTD HTML 4.01 Final//EN'>\\r\\n\");\n\t\tprint \"<html><head>\\r\\n\";\n\t\tprint \"<title>404 Not Found</title>\\r\\n\";\n\t\tprint \"</head><body>\\r\\n\";\n\t\tprint \"<h1>Not Found</h1>\\r\\n\";\n\t\tprint \"The requested URL $url_disarmed was not found on this server.<p>\\r\\n\";\n\t\tprint \"<hr>\\r\\n\";\n\t\tprint \"<address>Monitorix HTTP Server listening at $host Port $port</address>\\r\\n\";\n\t\tprint \"</body></html>\\r\\n\";\n\t\tlogger($url, \"NOTEXIST\");\n\t}\n\n\texit(0);\n}\n\n1;\n"], "filenames": ["lib/HTTPServer.pm"], "buggy_code_start_loc": [141], "buggy_code_end_loc": [141], "fixing_code_start_loc": [142], "fixing_code_end_loc": [146], "type": "NVD-CWE-Other", "message": "Monitorix 3.13.0 allows remote attackers to bypass Basic Authentication in a default installation (i.e., an installation without a hosts_deny option). This issue occurred because a new access-control feature was introduced without considering that some exiting installations became unsafe, upon an update to 3.13.0, unless the new feature was immediately configured.", "other": {"cve": {"id": "CVE-2021-3325", "sourceIdentifier": "cve@mitre.org", "published": "2021-01-27T19:15:13.983", "lastModified": "2022-07-12T17:42:04.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Monitorix 3.13.0 allows remote attackers to bypass Basic Authentication in a default installation (i.e., an installation without a hosts_deny option). This issue occurred because a new access-control feature was introduced without considering that some exiting installations became unsafe, upon an update to 3.13.0, unless the new feature was immediately configured."}, {"lang": "es", "value": "Monitorix versi\u00f3n 3.13.0, permite a atacantes remotos omitir la Autenticaci\u00f3n B\u00e1sica en una instalaci\u00f3n predeterminada (es decir, una instalaci\u00f3n sin la opci\u00f3n hosts_deny).&#xa0;Este problema ocurri\u00f3 porque una nueva funcionalidad de control de acceso fue introducida sin considerar que algunas instalaciones existentes se volvieron no seguras, tras una actualizaci\u00f3n a la versi\u00f3n 3.13.0, a menos que la nueva funcionalidad fue configurada inmediatamente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fibranet:monitorix:3.13.0:*:*:*:*:*:*:*", "matchCriteriaId": "4CE46B7E-5768-4477-82FB-255DD5D6DD16"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}], "references": [{"url": "https://github.com/mikaku/Monitorix/commit/d6816e20da1a98bcdc6372d9c36a093df5238f4a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mikaku/Monitorix/compare/v3.13.0...v3.13.1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mikaku/Monitorix/issues/309", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/67DDUU56LP76AJ2K7WJ733QPL2FHKKNG/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IGG6WK44CYY6GEFRTCUEDANVNSX5NDH7/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.monitorix.org/news.html?n=20210127", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mikaku/Monitorix/commit/d6816e20da1a98bcdc6372d9c36a093df5238f4a"}}