{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * trace_events_filter - generic event filtering\n *\n * Copyright (C) 2009 Tom Zanussi <tzanussi@gmail.com>\n */\n\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n\n#include \"trace.h\"\n#include \"trace_output.h\"\n\n#define DEFAULT_SYS_FILTER_MESSAGE\t\t\t\t\t\\\n\t\"### global filter ###\\n\"\t\t\t\t\t\\\n\t\"# Use this to set filters for multiple events.\\n\"\t\t\\\n\t\"# Only events with the given fields will be affected.\\n\"\t\\\n\t\"# If no events are modified, an error message will be displayed here\"\n\n/* Due to token parsing '<=' must be before '<' and '>=' must be before '>' */\n#define OPS\t\t\t\t\t\\\n\tC( OP_GLOB,\t\"~\"  ),\t\t\t\\\n\tC( OP_NE,\t\"!=\" ),\t\t\t\\\n\tC( OP_EQ,\t\"==\" ),\t\t\t\\\n\tC( OP_LE,\t\"<=\" ),\t\t\t\\\n\tC( OP_LT,\t\"<\"  ),\t\t\t\\\n\tC( OP_GE,\t\">=\" ),\t\t\t\\\n\tC( OP_GT,\t\">\"  ),\t\t\t\\\n\tC( OP_BAND,\t\"&\"  ),\t\t\t\\\n\tC( OP_MAX,\tNULL )\n\n#undef C\n#define C(a, b)\ta\n\nenum filter_op_ids { OPS };\n\n#undef C\n#define C(a, b)\tb\n\nstatic const char * ops[] = { OPS };\n\n/*\n * pred functions are OP_LE, OP_LT, OP_GE, OP_GT, and OP_BAND\n * pred_funcs_##type below must match the order of them above.\n */\n#define PRED_FUNC_START\t\t\tOP_LE\n#define PRED_FUNC_MAX\t\t\t(OP_BAND - PRED_FUNC_START)\n\n#define ERRORS\t\t\t\t\t\t\t\t\\\n\tC(NONE,\t\t\t\"No error\"),\t\t\t\t\\\n\tC(INVALID_OP,\t\t\"Invalid operator\"),\t\t\t\\\n\tC(TOO_MANY_OPEN,\t\"Too many '('\"),\t\t\t\\\n\tC(TOO_MANY_CLOSE,\t\"Too few '('\"),\t\t\t\t\\\n\tC(MISSING_QUOTE,\t\"Missing matching quote\"),\t\t\\\n\tC(OPERAND_TOO_LONG,\t\"Operand too long\"),\t\t\t\\\n\tC(EXPECT_STRING,\t\"Expecting string field\"),\t\t\\\n\tC(EXPECT_DIGIT,\t\t\"Expecting numeric field\"),\t\t\\\n\tC(ILLEGAL_FIELD_OP,\t\"Illegal operation for field type\"),\t\\\n\tC(FIELD_NOT_FOUND,\t\"Field not found\"),\t\t\t\\\n\tC(ILLEGAL_INTVAL,\t\"Illegal integer value\"),\t\t\\\n\tC(BAD_SUBSYS_FILTER,\t\"Couldn't find or set field in one of a subsystem's events\"), \\\n\tC(TOO_MANY_PREDS,\t\"Too many terms in predicate expression\"), \\\n\tC(INVALID_FILTER,\t\"Meaningless filter expression\"),\t\\\n\tC(IP_FIELD_ONLY,\t\"Only 'ip' field is supported for function trace\"), \\\n\tC(INVALID_VALUE,\t\"Invalid value (did you forget quotes)?\"), \\\n\tC(ERRNO,\t\t\"Error\"),\t\t\t\t\\\n\tC(NO_FILTER,\t\t\"No filter found\")\n\n#undef C\n#define C(a, b)\t\tFILT_ERR_##a\n\nenum { ERRORS };\n\n#undef C\n#define C(a, b)\t\tb\n\nstatic const char *err_text[] = { ERRORS };\n\n/* Called after a '!' character but \"!=\" and \"!~\" are not \"not\"s */\nstatic bool is_not(const char *str)\n{\n\tswitch (str[1]) {\n\tcase '=':\n\tcase '~':\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n/**\n * prog_entry - a singe entry in the filter program\n * @target:\t     Index to jump to on a branch (actually one minus the index)\n * @when_to_branch:  The value of the result of the predicate to do a branch\n * @pred:\t     The predicate to execute.\n */\nstruct prog_entry {\n\tint\t\t\ttarget;\n\tint\t\t\twhen_to_branch;\n\tstruct filter_pred\t*pred;\n};\n\n/**\n * update_preds- assign a program entry a label target\n * @prog: The program array\n * @N: The index of the current entry in @prog\n * @when_to_branch: What to assign a program entry for its branch condition\n *\n * The program entry at @N has a target that points to the index of a program\n * entry that can have its target and when_to_branch fields updated.\n * Update the current program entry denoted by index @N target field to be\n * that of the updated entry. This will denote the entry to update if\n * we are processing an \"||\" after an \"&&\"\n */\nstatic void update_preds(struct prog_entry *prog, int N, int invert)\n{\n\tint t, s;\n\n\tt = prog[N].target;\n\ts = prog[t].target;\n\tprog[t].when_to_branch = invert;\n\tprog[t].target = N;\n\tprog[N].target = s;\n}\n\nstruct filter_parse_error {\n\tint lasterr;\n\tint lasterr_pos;\n};\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}\n\ntypedef int (*parse_pred_fn)(const char *str, void *data, int pos,\n\t\t\t     struct filter_parse_error *pe,\n\t\t\t     struct filter_pred **pred);\n\nenum {\n\tINVERT\t\t= 1,\n\tPROCESS_AND\t= 2,\n\tPROCESS_OR\t= 4,\n};\n\n/*\n * Without going into a formal proof, this explains the method that is used in\n * parsing the logical expressions.\n *\n * For example, if we have: \"a && !(!b || (c && g)) || d || e && !f\"\n * The first pass will convert it into the following program:\n *\n * n1: r=a;       l1: if (!r) goto l4;\n * n2: r=b;       l2: if (!r) goto l4;\n * n3: r=c; r=!r; l3: if (r) goto l4;\n * n4: r=g; r=!r; l4: if (r) goto l5;\n * n5: r=d;       l5: if (r) goto T\n * n6: r=e;       l6: if (!r) goto l7;\n * n7: r=f; r=!r; l7: if (!r) goto F\n * T: return TRUE\n * F: return FALSE\n *\n * To do this, we use a data structure to represent each of the above\n * predicate and conditions that has:\n *\n *  predicate, when_to_branch, invert, target\n *\n * The \"predicate\" will hold the function to determine the result \"r\".\n * The \"when_to_branch\" denotes what \"r\" should be if a branch is to be taken\n * \"&&\" would contain \"!r\" or (0) and \"||\" would contain \"r\" or (1).\n * The \"invert\" holds whether the value should be reversed before testing.\n * The \"target\" contains the label \"l#\" to jump to.\n *\n * A stack is created to hold values when parentheses are used.\n *\n * To simplify the logic, the labels will start at 0 and not 1.\n *\n * The possible invert values are 1 and 0. The number of \"!\"s that are in scope\n * before the predicate determines the invert value, if the number is odd then\n * the invert value is 1 and 0 otherwise. This means the invert value only\n * needs to be toggled when a new \"!\" is introduced compared to what is stored\n * on the stack, where parentheses were used.\n *\n * The top of the stack and \"invert\" are initialized to zero.\n *\n * ** FIRST PASS **\n *\n * #1 A loop through all the tokens is done:\n *\n * #2 If the token is an \"(\", the stack is push, and the current stack value\n *    gets the current invert value, and the loop continues to the next token.\n *    The top of the stack saves the \"invert\" value to keep track of what\n *    the current inversion is. As \"!(a && !b || c)\" would require all\n *    predicates being affected separately by the \"!\" before the parentheses.\n *    And that would end up being equivalent to \"(!a || b) && !c\"\n *\n * #3 If the token is an \"!\", the current \"invert\" value gets inverted, and\n *    the loop continues. Note, if the next token is a predicate, then\n *    this \"invert\" value is only valid for the current program entry,\n *    and does not affect other predicates later on.\n *\n * The only other acceptable token is the predicate string.\n *\n * #4 A new entry into the program is added saving: the predicate and the\n *    current value of \"invert\". The target is currently assigned to the\n *    previous program index (this will not be its final value).\n *\n * #5 We now enter another loop and look at the next token. The only valid\n *    tokens are \")\", \"&&\", \"||\" or end of the input string \"\\0\".\n *\n * #6 The invert variable is reset to the current value saved on the top of\n *    the stack.\n *\n * #7 The top of the stack holds not only the current invert value, but also\n *    if a \"&&\" or \"||\" needs to be processed. Note, the \"&&\" takes higher\n *    precedence than \"||\". That is \"a && b || c && d\" is equivalent to\n *    \"(a && b) || (c && d)\". Thus the first thing to do is to see if \"&&\" needs\n *    to be processed. This is the case if an \"&&\" was the last token. If it was\n *    then we call update_preds(). This takes the program, the current index in\n *    the program, and the current value of \"invert\".  More will be described\n *    below about this function.\n *\n * #8 If the next token is \"&&\" then we set a flag in the top of the stack\n *    that denotes that \"&&\" needs to be processed, break out of this loop\n *    and continue with the outer loop.\n *\n * #9 Otherwise, if a \"||\" needs to be processed then update_preds() is called.\n *    This is called with the program, the current index in the program, but\n *    this time with an inverted value of \"invert\" (that is !invert). This is\n *    because the value taken will become the \"when_to_branch\" value of the\n *    program.\n *    Note, this is called when the next token is not an \"&&\". As stated before,\n *    \"&&\" takes higher precedence, and \"||\" should not be processed yet if the\n *    next logical operation is \"&&\".\n *\n * #10 If the next token is \"||\" then we set a flag in the top of the stack\n *     that denotes that \"||\" needs to be processed, break out of this loop\n *     and continue with the outer loop.\n *\n * #11 If this is the end of the input string \"\\0\" then we break out of both\n *     loops.\n *\n * #12 Otherwise, the next token is \")\", where we pop the stack and continue\n *     this inner loop.\n *\n * Now to discuss the update_pred() function, as that is key to the setting up\n * of the program. Remember the \"target\" of the program is initialized to the\n * previous index and not the \"l\" label. The target holds the index into the\n * program that gets affected by the operand. Thus if we have something like\n *  \"a || b && c\", when we process \"a\" the target will be \"-1\" (undefined).\n * When we process \"b\", its target is \"0\", which is the index of \"a\", as that's\n * the predicate that is affected by \"||\". But because the next token after \"b\"\n * is \"&&\" we don't call update_preds(). Instead continue to \"c\". As the\n * next token after \"c\" is not \"&&\" but the end of input, we first process the\n * \"&&\" by calling update_preds() for the \"&&\" then we process the \"||\" by\n * callin updates_preds() with the values for processing \"||\".\n *\n * What does that mean? What update_preds() does is to first save the \"target\"\n * of the program entry indexed by the current program entry's \"target\"\n * (remember the \"target\" is initialized to previous program entry), and then\n * sets that \"target\" to the current index which represents the label \"l#\".\n * That entry's \"when_to_branch\" is set to the value passed in (the \"invert\"\n * or \"!invert\"). Then it sets the current program entry's target to the saved\n * \"target\" value (the old value of the program that had its \"target\" updated\n * to the label).\n *\n * Looking back at \"a || b && c\", we have the following steps:\n *  \"a\"  - prog[0] = { \"a\", X, -1 } // pred, when_to_branch, target\n *  \"||\" - flag that we need to process \"||\"; continue outer loop\n *  \"b\"  - prog[1] = { \"b\", X, 0 }\n *  \"&&\" - flag that we need to process \"&&\"; continue outer loop\n * (Notice we did not process \"||\")\n *  \"c\"  - prog[2] = { \"c\", X, 1 }\n *  update_preds(prog, 2, 0); // invert = 0 as we are processing \"&&\"\n *    t = prog[2].target; // t = 1\n *    s = prog[t].target; // s = 0\n *    prog[t].target = 2; // Set target to \"l2\"\n *    prog[t].when_to_branch = 0;\n *    prog[2].target = s;\n * update_preds(prog, 2, 1); // invert = 1 as we are now processing \"||\"\n *    t = prog[2].target; // t = 0\n *    s = prog[t].target; // s = -1\n *    prog[t].target = 2; // Set target to \"l2\"\n *    prog[t].when_to_branch = 1;\n *    prog[2].target = s;\n *\n * #13 Which brings us to the final step of the first pass, which is to set\n *     the last program entry's when_to_branch and target, which will be\n *     when_to_branch = 0; target = N; ( the label after the program entry after\n *     the last program entry processed above).\n *\n * If we denote \"TRUE\" to be the entry after the last program entry processed,\n * and \"FALSE\" the program entry after that, we are now done with the first\n * pass.\n *\n * Making the above \"a || b && c\" have a progam of:\n *  prog[0] = { \"a\", 1, 2 }\n *  prog[1] = { \"b\", 0, 2 }\n *  prog[2] = { \"c\", 0, 3 }\n *\n * Which translates into:\n * n0: r = a; l0: if (r) goto l2;\n * n1: r = b; l1: if (!r) goto l2;\n * n2: r = c; l2: if (!r) goto l3;  // Which is the same as \"goto F;\"\n * T: return TRUE; l3:\n * F: return FALSE\n *\n * Although, after the first pass, the program is correct, it is\n * inefficient. The simple sample of \"a || b && c\" could be easily been\n * converted into:\n * n0: r = a; if (r) goto T\n * n1: r = b; if (!r) goto F\n * n2: r = c; if (!r) goto F\n * T: return TRUE;\n * F: return FALSE;\n *\n * The First Pass is over the input string. The next too passes are over\n * the program itself.\n *\n * ** SECOND PASS **\n *\n * Which brings us to the second pass. If a jump to a label has the\n * same condition as that label, it can instead jump to its target.\n * The original example of \"a && !(!b || (c && g)) || d || e && !f\"\n * where the first pass gives us:\n *\n * n1: r=a;       l1: if (!r) goto l4;\n * n2: r=b;       l2: if (!r) goto l4;\n * n3: r=c; r=!r; l3: if (r) goto l4;\n * n4: r=g; r=!r; l4: if (r) goto l5;\n * n5: r=d;       l5: if (r) goto T\n * n6: r=e;       l6: if (!r) goto l7;\n * n7: r=f; r=!r; l7: if (!r) goto F:\n * T: return TRUE;\n * F: return FALSE\n *\n * We can see that \"l3: if (r) goto l4;\" and at l4, we have \"if (r) goto l5;\".\n * And \"l5: if (r) goto T\", we could optimize this by converting l3 and l4\n * to go directly to T. To accomplish this, we start from the last\n * entry in the program and work our way back. If the target of the entry\n * has the same \"when_to_branch\" then we could use that entry's target.\n * Doing this, the above would end up as:\n *\n * n1: r=a;       l1: if (!r) goto l4;\n * n2: r=b;       l2: if (!r) goto l4;\n * n3: r=c; r=!r; l3: if (r) goto T;\n * n4: r=g; r=!r; l4: if (r) goto T;\n * n5: r=d;       l5: if (r) goto T;\n * n6: r=e;       l6: if (!r) goto F;\n * n7: r=f; r=!r; l7: if (!r) goto F;\n * T: return TRUE\n * F: return FALSE\n *\n * In that same pass, if the \"when_to_branch\" doesn't match, we can simply\n * go to the program entry after the label. That is, \"l2: if (!r) goto l4;\"\n * where \"l4: if (r) goto T;\", then we can convert l2 to be:\n * \"l2: if (!r) goto n5;\".\n *\n * This will have the second pass give us:\n * n1: r=a;       l1: if (!r) goto n5;\n * n2: r=b;       l2: if (!r) goto n5;\n * n3: r=c; r=!r; l3: if (r) goto T;\n * n4: r=g; r=!r; l4: if (r) goto T;\n * n5: r=d;       l5: if (r) goto T\n * n6: r=e;       l6: if (!r) goto F;\n * n7: r=f; r=!r; l7: if (!r) goto F\n * T: return TRUE\n * F: return FALSE\n *\n * Notice, all the \"l#\" labels are no longer used, and they can now\n * be discarded.\n *\n * ** THIRD PASS **\n *\n * For the third pass we deal with the inverts. As they simply just\n * make the \"when_to_branch\" get inverted, a simple loop over the\n * program to that does: \"when_to_branch ^= invert;\" will do the\n * job, leaving us with:\n * n1: r=a; if (!r) goto n5;\n * n2: r=b; if (!r) goto n5;\n * n3: r=c: if (!r) goto T;\n * n4: r=g; if (!r) goto T;\n * n5: r=d; if (r) goto T\n * n6: r=e; if (!r) goto F;\n * n7: r=f; if (r) goto F\n * T: return TRUE\n * F: return FALSE\n *\n * As \"r = a; if (!r) goto n5;\" is obviously the same as\n * \"if (!a) goto n5;\" without doing anything we can interperate the\n * program as:\n * n1: if (!a) goto n5;\n * n2: if (!b) goto n5;\n * n3: if (!c) goto T;\n * n4: if (!g) goto T;\n * n5: if (d) goto T\n * n6: if (!e) goto F;\n * n7: if (f) goto F\n * T: return TRUE\n * F: return FALSE\n *\n * Since the inverts are discarded at the end, there's no reason to store\n * them in the program array (and waste memory). A separate array to hold\n * the inverts is used and freed at the end.\n */\nstatic struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kcalloc(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens)\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\t/* accepting only \"&&\" or \"||\" */\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* fall through */\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tkfree(op_stack);\n\tkfree(inverts);\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(inverts);\n\tif (prog_stack) {\n\t\tfor (i = 0; prog_stack[i].pred; i++)\n\t\t\tkfree(prog_stack[i].pred);\n\t\tkfree(prog_stack);\n\t}\n\treturn ERR_PTR(ret);\n}\n\n#define DEFINE_COMPARISON_PRED(type)\t\t\t\t\t\\\nstatic int filter_pred_LT_##type(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype *addr = (type *)(event + pred->offset);\t\t\t\\\n\ttype val = (type)pred->val;\t\t\t\t\t\\\n\treturn *addr < val;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic int filter_pred_LE_##type(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype *addr = (type *)(event + pred->offset);\t\t\t\\\n\ttype val = (type)pred->val;\t\t\t\t\t\\\n\treturn *addr <= val;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic int filter_pred_GT_##type(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype *addr = (type *)(event + pred->offset);\t\t\t\\\n\ttype val = (type)pred->val;\t\t\t\t\t\\\n\treturn *addr > val;\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic int filter_pred_GE_##type(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype *addr = (type *)(event + pred->offset);\t\t\t\\\n\ttype val = (type)pred->val;\t\t\t\t\t\\\n\treturn *addr >= val;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic int filter_pred_BAND_##type(struct filter_pred *pred, void *event) \\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype *addr = (type *)(event + pred->offset);\t\t\t\\\n\ttype val = (type)pred->val;\t\t\t\t\t\\\n\treturn !!(*addr & val);\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic const filter_pred_fn_t pred_funcs_##type[] = {\t\t\t\\\n\tfilter_pred_LE_##type,\t\t\t\t\t\t\\\n\tfilter_pred_LT_##type,\t\t\t\t\t\t\\\n\tfilter_pred_GE_##type,\t\t\t\t\t\t\\\n\tfilter_pred_GT_##type,\t\t\t\t\t\t\\\n\tfilter_pred_BAND_##type,\t\t\t\t\t\\\n};\n\n#define DEFINE_EQUALITY_PRED(size)\t\t\t\t\t\\\nstatic int filter_pred_##size(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu##size *addr = (u##size *)(event + pred->offset);\t\t\\\n\tu##size val = (u##size)pred->val;\t\t\t\t\\\n\tint match;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmatch = (val == *addr) ^ pred->not;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn match;\t\t\t\t\t\t\t\\\n}\n\nDEFINE_COMPARISON_PRED(s64);\nDEFINE_COMPARISON_PRED(u64);\nDEFINE_COMPARISON_PRED(s32);\nDEFINE_COMPARISON_PRED(u32);\nDEFINE_COMPARISON_PRED(s16);\nDEFINE_COMPARISON_PRED(u16);\nDEFINE_COMPARISON_PRED(s8);\nDEFINE_COMPARISON_PRED(u8);\n\nDEFINE_EQUALITY_PRED(64);\nDEFINE_EQUALITY_PRED(32);\nDEFINE_EQUALITY_PRED(16);\nDEFINE_EQUALITY_PRED(8);\n\n/* Filter predicate for fixed sized arrays of characters */\nstatic int filter_pred_string(struct filter_pred *pred, void *event)\n{\n\tchar *addr = (char *)(event + pred->offset);\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, pred->regex.field_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}\n\n/* Filter predicate for char * pointers */\nstatic int filter_pred_pchar(struct filter_pred *pred, void *event)\n{\n\tchar **addr = (char **)(event + pred->offset);\n\tint cmp, match;\n\tint len = strlen(*addr) + 1;\t/* including tailing '\\0' */\n\n\tcmp = pred->regex.match(*addr, &pred->regex, len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}\n\n/*\n * Filter predicate for dynamic sized arrays of characters.\n * These are implemented through a list of strings at the end\n * of the entry.\n * Also each of these strings have a field in the entry which\n * contains its offset from the beginning of the entry.\n * We have then first to get this field, dereference it\n * and add it to the address of the entry, and at last we have\n * the address of the string.\n */\nstatic int filter_pred_strloc(struct filter_pred *pred, void *event)\n{\n\tu32 str_item = *(u32 *)(event + pred->offset);\n\tint str_loc = str_item & 0xffff;\n\tint str_len = str_item >> 16;\n\tchar *addr = (char *)(event + str_loc);\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, str_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}\n\n/* Filter predicate for CPUs. */\nstatic int filter_pred_cpu(struct filter_pred *pred, void *event)\n{\n\tint cpu, cmp;\n\n\tcpu = raw_smp_processor_id();\n\tcmp = pred->val;\n\n\tswitch (pred->op) {\n\tcase OP_EQ:\n\t\treturn cpu == cmp;\n\tcase OP_NE:\n\t\treturn cpu != cmp;\n\tcase OP_LT:\n\t\treturn cpu < cmp;\n\tcase OP_LE:\n\t\treturn cpu <= cmp;\n\tcase OP_GT:\n\t\treturn cpu > cmp;\n\tcase OP_GE:\n\t\treturn cpu >= cmp;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n/* Filter predicate for COMM. */\nstatic int filter_pred_comm(struct filter_pred *pred, void *event)\n{\n\tint cmp;\n\n\tcmp = pred->regex.match(current->comm, &pred->regex,\n\t\t\t\tTASK_COMM_LEN);\n\treturn cmp ^ pred->not;\n}\n\nstatic int filter_pred_none(struct filter_pred *pred, void *event)\n{\n\treturn 0;\n}\n\n/*\n * regex_match_foo - Basic regex callbacks\n *\n * @str: the string to be searched\n * @r:   the regex structure containing the pattern string\n * @len: the length of the string to be searched (including '\\0')\n *\n * Note:\n * - @str might not be NULL-terminated if it's of type DYN_STRING\n *   or STATIC_STRING, unless @len is zero.\n */\n\nstatic int regex_match_full(char *str, struct regex *r, int len)\n{\n\t/* len of zero means str is dynamic and ends with '\\0' */\n\tif (!len)\n\t\treturn strcmp(str, r->pattern) == 0;\n\n\treturn strncmp(str, r->pattern, len) == 0;\n}\n\nstatic int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}\n\nstatic int regex_match_middle(char *str, struct regex *r, int len)\n{\n\tif (!len)\n\t\treturn strstr(str, r->pattern) != NULL;\n\n\treturn strnstr(str, r->pattern, len) != NULL;\n}\n\nstatic int regex_match_end(char *str, struct regex *r, int len)\n{\n\tint strlen = len - 1;\n\n\tif (strlen >= r->len &&\n\t    memcmp(str + strlen - r->len, r->pattern, r->len) == 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int regex_match_glob(char *str, struct regex *r, int len __maybe_unused)\n{\n\tif (glob_match(r->pattern, str))\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * filter_parse_regex - parse a basic regex\n * @buff:   the raw regex\n * @len:    length of the regex\n * @search: will point to the beginning of the string to compare\n * @not:    tell whether the match will have to be inverted\n *\n * This passes in a buffer containing a regex and this function will\n * set search to point to the search part of the buffer and\n * return the type of search it is (see enum above).\n * This does modify buff.\n *\n * Returns enum type.\n *  search returns the pointer to use for comparison.\n *  not returns 1 if buff started with a '!'\n *     0 otherwise.\n */\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}\n\nstatic void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = &pred->regex;\n\tchar *search;\n\tenum regex_type type = MATCH_FULL;\n\n\tif (pred->op == OP_GLOB) {\n\t\ttype = filter_parse_regex(r->pattern, r->len, &search, &pred->not);\n\t\tr->len = strlen(search);\n\t\tmemmove(r->pattern, search, r->len+1);\n\t}\n\n\tswitch (type) {\n\t/* MATCH_INDEX should not happen, but if it does, match full */\n\tcase MATCH_INDEX:\n\tcase MATCH_FULL:\n\t\tr->match = regex_match_full;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tr->match = regex_match_front;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tr->match = regex_match_middle;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tr->match = regex_match_end;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tr->match = regex_match_glob;\n\t\tbreak;\n\t}\n}\n\n/* return 1 if event matches, 0 otherwise (discard) */\nint filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}\nEXPORT_SYMBOL_GPL(filter_match_preds);\n\nstatic void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}\n\nstatic void append_filter_err(struct trace_array *tr,\n\t\t\t      struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tpe->lasterr, pe->lasterr_pos);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tFILT_ERR_ERRNO, 0);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}\n\nstatic inline struct event_filter *event_filter(struct trace_event_file *file)\n{\n\treturn file->filter;\n}\n\n/* caller must hold event_mutex */\nvoid print_event_filter(struct trace_event_file *file, struct trace_seq *s)\n{\n\tstruct event_filter *filter = event_filter(file);\n\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, \"none\\n\");\n}\n\nvoid print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t  struct trace_seq *s)\n{\n\tstruct event_filter *filter;\n\n\tmutex_lock(&event_mutex);\n\tfilter = system->filter;\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");\n\tmutex_unlock(&event_mutex);\n}\n\nstatic void free_prog(struct event_filter *filter)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\tprog = rcu_access_pointer(filter->prog);\n\tif (!prog)\n\t\treturn;\n\n\tfor (i = 0; prog[i].pred; i++)\n\t\tkfree(prog[i].pred);\n\tkfree(prog);\n}\n\nstatic void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}\n\nstatic inline void __remove_filter(struct trace_event_file *file)\n{\n\tfilter_disable(file);\n\tremove_filter_string(file->filter);\n}\n\nstatic void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__remove_filter(file);\n\t}\n}\n\nstatic inline void __free_subsystem_filter(struct trace_event_file *file)\n{\n\t__free_filter(file->filter);\n\tfile->filter = NULL;\n}\n\nstatic void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n\t\t\t\t\t  struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__free_subsystem_filter(file);\n\t}\n}\n\nint filter_assign_type(const char *type)\n{\n\tif (strstr(type, \"__data_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_DYN_STRING;\n\n\tif (strchr(type, '[') && strstr(type, \"char\"))\n\t\treturn FILTER_STATIC_STRING;\n\n\tif (strcmp(type, \"char *\") == 0 || strcmp(type, \"const char *\") == 0)\n\t\treturn FILTER_PTR_STRING;\n\n\treturn FILTER_OTHER;\n}\n\nstatic filter_pred_fn_t select_comparison_fn(enum filter_op_ids op,\n\t\t\t\t\t    int field_size, int field_is_signed)\n{\n\tfilter_pred_fn_t fn = NULL;\n\tint pred_func_index = -1;\n\n\tswitch (op) {\n\tcase OP_EQ:\n\tcase OP_NE:\n\t\tbreak;\n\tdefault:\n\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))\n\t\t\treturn NULL;\n\t\tpred_func_index = op - PRED_FUNC_START;\n\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))\n\t\t\treturn NULL;\n\t}\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_64;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s64[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u64[pred_func_index];\n\t\tbreak;\n\tcase 4:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_32;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s32[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u32[pred_func_index];\n\t\tbreak;\n\tcase 2:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_16;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s16[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u16[pred_func_index];\n\t\tbreak;\n\tcase 1:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_8;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s8[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u8[pred_func_index];\n\t\tbreak;\n\t}\n\n\treturn fn;\n}\n\n/* Called when a predicate is encountered by predicate_parse() */\nstatic int parse_pred(const char *str, void *data,\n\t\t      int pos, struct filter_parse_error *pe,\n\t\t      struct filter_pred **pred_ptr)\n{\n\tstruct trace_event_call *call = data;\n\tstruct ftrace_event_field *field;\n\tstruct filter_pred *pred = NULL;\n\tchar num_buf[24];\t/* Big enough to hold an address */\n\tchar *field_name;\n\tchar q;\n\tu64 val;\n\tint len;\n\tint ret;\n\tint op;\n\tint s;\n\tint i = 0;\n\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\n\tlen = i - s;\n\n\tif (!len)\n\t\treturn -1;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\n\t/* Make sure that the field exists */\n\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field) {\n\t\tparse_error(pe, FILT_ERR_FIELD_NOT_FOUND, pos + i);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\t/* Make sure this op is supported */\n\tfor (op = 0; ops[op]; op++) {\n\t\t/* This is why '<=' must come before '<' in ops[] */\n\t\tif (strncmp(str + i, ops[op], strlen(ops[op])) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ops[op]) {\n\t\tparse_error(pe, FILT_ERR_INVALID_OP, pos + i);\n\t\tgoto err_free;\n\t}\n\n\ti += strlen(ops[op]);\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\ts = i;\n\n\tpred = kzalloc(sizeof(*pred), GFP_KERNEL);\n\tif (!pred)\n\t\treturn -ENOMEM;\n\n\tpred->field = field;\n\tpred->offset = field->offset;\n\tpred->op = op;\n\n\tif (ftrace_event_is_function(call)) {\n\t\t/*\n\t\t * Perf does things different with function events.\n\t\t * It only allows an \"ip\" field, and expects a string.\n\t\t * But the string does not need to be surrounded by quotes.\n\t\t * If it is a string, the assigned function as a nop,\n\t\t * (perf doesn't use it) and grab everything.\n\t\t */\n\t\tif (strcmp(field->name, \"ip\") != 0) {\n\t\t\tparse_error(pe, FILT_ERR_IP_FIELD_ONLY, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\t\tpred->fn = filter_pred_none;\n\n\t\t/*\n\t\t * Quotes are not required, but if they exist then we need\n\t\t * to read them till we hit a matching one.\n\t\t */\n\t\tif (str[i] == '\\'' || str[i] == '\"')\n\t\t\tq = str[i];\n\t\telse\n\t\t\tq = 0;\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (q && str[i] == q)\n\t\t\t\tbreak;\n\t\t\tif (!q && (str[i] == ')' || str[i] == '&' ||\n\t\t\t\t   str[i] == '|'))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Skip quotes */\n\t\tif (q)\n\t\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t/* This is either a string, or an integer */\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the op is OK for strings */\n\t\tswitch (op) {\n\t\tcase OP_NE:\n\t\t\tpred->not = 1;\n\t\t\t/* Fall through */\n\t\tcase OP_GLOB:\n\t\tcase OP_EQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_DIGIT, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i]) {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t\tfilter_build_regex(pred);\n\n\t\tif (field->filter_type == FILTER_COMM) {\n\t\t\tpred->fn = filter_pred_comm;\n\n\t\t} else if (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\tpred->fn = filter_pred_string;\n\t\t\tpred->regex.field_len = field->size;\n\n\t\t} else if (field->filter_type == FILTER_DYN_STRING)\n\t\t\tpred->fn = filter_pred_strloc;\n\t\telse\n\t\t\tpred->fn = filter_pred_pchar;\n\t\t/* go past the last quote */\n\t\ti++;\n\n\t} else if (isdigit(str[i]) || str[i] == '-') {\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_STRING, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (op == OP_GLOB) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (str[i] == '-')\n\t\t\ti++;\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\n\t\tlen = i - s;\n\t\t/* 0xfeedfacedeadbeef is 18 chars max */\n\t\tif (len >= sizeof(num_buf)) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tstrncpy(num_buf, str + s, len);\n\t\tnum_buf[len] = 0;\n\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num_buf, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num_buf, 0, &val);\n\t\tif (ret) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_INTVAL, pos + s);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->val = val;\n\n\t\tif (field->filter_type == FILTER_CPU)\n\t\t\tpred->fn = filter_pred_cpu;\n\t\telse {\n\t\t\tpred->fn = select_comparison_fn(pred->op, field->size,\n\t\t\t\t\t\t\tfield->is_signed);\n\t\t\tif (pred->op == OP_NE)\n\t\t\t\tpred->not = 1;\n\t\t}\n\n\t} else {\n\t\tparse_error(pe, FILT_ERR_INVALID_VALUE, pos + i);\n\t\tgoto err_free;\n\t}\n\n\t*pred_ptr = pred;\n\treturn i;\n\nerr_free:\n\tkfree(pred);\n\treturn -EINVAL;\n}\n\nenum {\n\tTOO_MANY_CLOSE\t\t= -1,\n\tTOO_MANY_OPEN\t\t= -2,\n\tMISSING_QUOTE\t\t= -3,\n};\n\n/*\n * Read the filter string once to calculate the number of predicates\n * as well as how deep the parentheses go.\n *\n * Returns:\n *   0 - everything is fine (err is undefined)\n *  -1 - too many ')'\n *  -2 - too many '('\n *  -3 - No matching quote\n */\nstatic int calc_stack(const char *str, int *parens, int *preds, int *err)\n{\n\tbool is_pred = false;\n\tint nr_preds = 0;\n\tint open = 1; /* Count the expression as \"(E)\" */\n\tint last_quote = 0;\n\tint max_open = 1;\n\tint quote = 0;\n\tint i;\n\n\t*err = 0;\n\n\tfor (i = 0; str[i]; i++) {\n\t\tif (isspace(str[i]))\n\t\t\tcontinue;\n\t\tif (quote) {\n\t\t\tif (str[i] == quote)\n\t\t\t       quote = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[i]) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tquote = str[i];\n\t\t\tlast_quote = i;\n\t\t\tbreak;\n\t\tcase '|':\n\t\tcase '&':\n\t\t\tif (str[i+1] != str[i])\n\t\t\t\tbreak;\n\t\t\tis_pred = false;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tis_pred = false;\n\t\t\topen++;\n\t\t\tif (open > max_open)\n\t\t\t\tmax_open = open;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tis_pred = false;\n\t\t\tif (open == 1) {\n\t\t\t\t*err = i;\n\t\t\t\treturn TOO_MANY_CLOSE;\n\t\t\t}\n\t\t\topen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!is_pred) {\n\t\t\tnr_preds++;\n\t\t\tis_pred = true;\n\t\t}\n\t}\n\n\tif (quote) {\n\t\t*err = last_quote;\n\t\treturn MISSING_QUOTE;\n\t}\n\n\tif (open != 1) {\n\t\tint level = open;\n\n\t\t/* find the bad open */\n\t\tfor (i--; i; i--) {\n\t\t\tif (quote) {\n\t\t\t\tif (str[i] == quote)\n\t\t\t\t\tquote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\tif (level == open) {\n\t\t\t\t\t*err = i;\n\t\t\t\t\treturn TOO_MANY_OPEN;\n\t\t\t\t}\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tquote = str[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* First character is the '(' with missing ')' */\n\t\t*err = 0;\n\t\treturn TOO_MANY_OPEN;\n\t}\n\n\t/* Set the size of the required stacks */\n\t*parens = max_open;\n\t*preds = nr_preds;\n\treturn 0;\n}\n\nstatic int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}\n\nstatic inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}\n\nstatic inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}\n\nstatic inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}\n\nstatic inline void\nevent_set_no_set_filter_flag(struct trace_event_file *file)\n{\n\tfile->flags |= EVENT_FILE_FL_NO_SET_FILTER;\n}\n\nstatic inline void\nevent_clear_no_set_filter_flag(struct trace_event_file *file)\n{\n\tfile->flags &= ~EVENT_FILE_FL_NO_SET_FILTER;\n}\n\nstatic inline bool\nevent_no_set_filter_flag(struct trace_event_file *file)\n{\n\tif (file->flags & EVENT_FILE_FL_NO_SET_FILTER)\n\t\treturn true;\n\n\treturn false;\n}\n\nstruct filter_list {\n\tstruct list_head\tlist;\n\tstruct event_filter\t*filter;\n};\n\nstatic int process_system_preds(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tstruct filter_parse_error *pe,\n\t\t\t\tchar *filter_string)\n{\n\tstruct trace_event_file *file;\n\tstruct filter_list *filter_item;\n\tstruct event_filter *filter = NULL;\n\tstruct filter_list *tmp;\n\tLIST_HEAD(filter_list);\n\tbool fail = true;\n\tint err;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\n\t\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (!filter)\n\t\t\tgoto fail_mem;\n\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\tgoto fail_mem;\n\n\t\terr = process_preds(file->event_call, filter_string, filter, pe);\n\t\tif (err) {\n\t\t\tfilter_disable(file);\n\t\t\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\t\t\tappend_filter_err(tr, pe, filter);\n\t\t} else\n\t\t\tevent_set_filtered_flag(file);\n\n\n\t\tfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);\n\t\tif (!filter_item)\n\t\t\tgoto fail_mem;\n\n\t\tlist_add_tail(&filter_item->list, &filter_list);\n\t\t/*\n\t\t * Regardless of if this returned an error, we still\n\t\t * replace the filter for the call.\n\t\t */\n\t\tfilter_item->filter = event_filter(file);\n\t\tevent_set_filter(file, filter);\n\t\tfilter = NULL;\n\n\t\tfail = false;\n\t}\n\n\tif (fail)\n\t\tgoto fail;\n\n\t/*\n\t * The calls can still be using the old filters.\n\t * Do a synchronize_rcu() and to ensure all calls are\n\t * done with them before we free them.\n\t */\n\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn 0;\n fail:\n\t/* No call succeeded */\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\treturn -EINVAL;\n fail_mem:\n\tkfree(filter);\n\t/* If any call succeeded, we still need to sync */\n\tif (!fail)\n\t\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn -ENOMEM;\n}\n\nstatic int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}\n\nstatic void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}\n\n/**\n * create_filter - create a filter for a trace_event_call\n * @call: trace_event_call to create a filter for\n * @filter_str: filter string\n * @set_str: remember @filter_str and enable detailed error in filter\n * @filterp: out param for created filter (always updated on return)\n *           Must be a pointer that references a NULL pointer.\n *\n * Creates a filter for @call with @filter_str.  If @set_str is %true,\n * @filter_str is copied and recorded in the new filter.\n *\n * On success, returns 0 and *@filterp points to the new filter.  On\n * failure, returns -errno and *@filterp may point to %NULL or to a new\n * filter.  In the latter case, the returned filter contains error\n * information if @set_str is %true and the caller is responsible for\n * freeing it.\n */\nstatic int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}\n\nint create_event_filter(struct trace_array *tr,\n\t\t\tstruct trace_event_call *call,\n\t\t\tchar *filter_str, bool set_str,\n\t\t\tstruct event_filter **filterp)\n{\n\treturn create_filter(tr, call, filter_str, set_str, filterp);\n}\n\n/**\n * create_system_filter - create a filter for an event_subsystem\n * @system: event_subsystem to create a filter for\n * @filter_str: filter string\n * @filterp: out param for created filter (always updated on return)\n *\n * Identical to create_filter() except that it creates a subsystem filter\n * and always remembers @filter_str.\n */\nstatic int create_system_filter(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tchar *filter_str, struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\terr = create_filter_start(filter_str, true, &pe, filterp);\n\tif (!err) {\n\t\terr = process_system_preds(dir, tr, pe, filter_str);\n\t\tif (!err) {\n\t\t\t/* System filters just show a default message */\n\t\t\tkfree((*filterp)->filter_string);\n\t\t\t(*filterp)->filter_string = NULL;\n\t\t} else {\n\t\t\tappend_filter_err(tr, pe, *filterp);\n\t\t}\n\t}\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}\n\n/* caller must hold event_mutex */\nint apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t/* Make sure the filter is not being used */\n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(file->tr, call, filter_string, true, &filter);\n\n\t/*\n\t * Always swap the call filter with the new filter\n\t * even if there was an error. If there was an error\n\t * in the filter, we disable the filter and show the error\n\t * string\n\t */\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t/* Make sure the call is done with the filter */\n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\n\t\t\t\t char *filter_string)\n{\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_array *tr = dir->tr;\n\tstruct event_filter *filter = NULL;\n\tint err = 0;\n\n\tmutex_lock(&event_mutex);\n\n\t/* Make sure the system still has events */\n\tif (!dir->nr_events) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_free_subsystem_preds(dir, tr);\n\t\tremove_filter_string(system->filter);\n\t\tfilter = system->filter;\n\t\tsystem->filter = NULL;\n\t\t/* Ensure all filters are no longer used */\n\t\ttracepoint_synchronize_unregister();\n\t\tfilter_free_subsystem_filters(dir, tr);\n\t\t__free_filter(filter);\n\t\tgoto out_unlock;\n\t}\n\n\terr = create_system_filter(dir, tr, filter_string, &filter);\n\tif (filter) {\n\t\t/*\n\t\t * No event actually uses the system filter\n\t\t * we can free it without synchronize_rcu().\n\t\t */\n\t\t__free_filter(system->filter);\n\t\tsystem->filter = filter;\n\t}\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}\n\n#ifdef CONFIG_PERF_EVENTS\n\nvoid ftrace_profile_free_filter(struct perf_event *event)\n{\n\tstruct event_filter *filter = event->filter;\n\n\tevent->filter = NULL;\n\t__free_filter(filter);\n}\n\nstruct function_filter_data {\n\tstruct ftrace_ops *ops;\n\tint first_filter;\n\tint first_notrace;\n};\n\n#ifdef CONFIG_FUNCTION_TRACER\nstatic char **\nftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t/*\n\t * The argv_split function takes white space\n\t * as a separator, so convert ',' into spaces.\n\t */\n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}\n\nstatic int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\n\treturn ret;\n}\n\nstatic int __ftrace_function_set_filter(int filter, char *buf, int len,\n\t\t\t\t\tstruct function_filter_data *data)\n{\n\tint i, re_cnt, ret = -EINVAL;\n\tint *reset;\n\tchar **re;\n\n\treset = filter ? &data->first_filter : &data->first_notrace;\n\n\t/*\n\t * The 'ip' field could have multiple filters set, separated\n\t * either by space or comma. We first cut the filter and apply\n\t * all pieces separatelly.\n\t */\n\tre = ftrace_function_filter_re(buf, len, &re_cnt);\n\tif (!re)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,\n\t\t\t\t\t\t re[i], strlen(re[i]));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (*reset)\n\t\t\t*reset = 0;\n\t}\n\n\targv_free(re);\n\treturn ret;\n}\n\nstatic int ftrace_function_check_pred(struct filter_pred *pred)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\t/*\n\t * Check the predicate for function trace, verify:\n\t *  - only '==' and '!=' is used\n\t *  - the 'ip' field is used\n\t */\n\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))\n\t\treturn -EINVAL;\n\n\tif (strcmp(field->name, \"ip\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\n\t/* Checking the node is valid for function trace. */\n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex.pattern,\n\t\t\t\t\t    pred->regex.len,\n\t\t\t\t\t    data);\n}\n\nstatic bool is_or(struct prog_entry *prog, int i)\n{\n\tint target;\n\n\t/*\n\t * Only \"||\" is allowed for function events, thus,\n\t * all true branches should jump to true, and any\n\t * false branch should jump to false.\n\t */\n\ttarget = prog[i].target + 1;\n\t/* True and false have NULL preds (all prog entries should jump to one */\n\tif (prog[target].pred)\n\t\treturn false;\n\n\t/* prog[target].target is 1 for TRUE, 0 for FALSE */\n\treturn prog[i].when_to_branch == prog[target].target;\n}\n\nstatic int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tstruct function_filter_data data = {\n\t\t.first_filter  = 1,\n\t\t.first_notrace = 1,\n\t\t.ops           = &event->ftrace_ops,\n\t};\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\n\t\tif (!is_or(prog, i))\n\t\t\treturn -EINVAL;\n\n\t\tif (ftrace_function_set_filter_pred(pred, &data) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n#else\nstatic int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\treturn -ENODEV;\n}\n#endif /* CONFIG_FUNCTION_TRACER */\n\nint ftrace_profile_set_filter(struct perf_event *event, int event_id,\n\t\t\t      char *filter_str)\n{\n\tint err;\n\tstruct event_filter *filter = NULL;\n\tstruct trace_event_call *call;\n\n\tmutex_lock(&event_mutex);\n\n\tcall = event->tp_event;\n\n\terr = -EINVAL;\n\tif (!call)\n\t\tgoto out_unlock;\n\n\terr = -EEXIST;\n\tif (event->filter)\n\t\tgoto out_unlock;\n\n\terr = create_filter(NULL, call, filter_str, false, &filter);\n\tif (err)\n\t\tgoto free_filter;\n\n\tif (ftrace_event_is_function(call))\n\t\terr = ftrace_function_set_filter(event, filter);\n\telse\n\t\tevent->filter = filter;\n\nfree_filter:\n\tif (err || ftrace_event_is_function(call))\n\t\t__free_filter(filter);\n\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}\n\n#endif /* CONFIG_PERF_EVENTS */\n\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n\n#define CREATE_TRACE_POINTS\n#include \"trace_events_filter_test.h\"\n\n#define DATA_REC(m, va, vb, vc, vd, ve, vf, vg, vh, nvisit) \\\n{ \\\n\t.filter = FILTER, \\\n\t.rec    = { .a = va, .b = vb, .c = vc, .d = vd, \\\n\t\t    .e = ve, .f = vf, .g = vg, .h = vh }, \\\n\t.match  = m, \\\n\t.not_visited = nvisit, \\\n}\n#define YES 1\n#define NO  0\n\nstatic struct test_filter_data_t {\n\tchar *filter;\n\tstruct trace_event_raw_ftrace_test_filter rec;\n\tint match;\n\tchar *not_visited;\n} test_filter_data[] = {\n#define FILTER \"a == 1 && b == 1 && c == 1 && d == 1 && \" \\\n\t       \"e == 1 && f == 1 && g == 1 && h == 1\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 1, 1, \"\"),\n\tDATA_REC(NO,  0, 1, 1, 1, 1, 1, 1, 1, \"bcdefgh\"),\n\tDATA_REC(NO,  1, 1, 1, 1, 1, 1, 1, 0, \"\"),\n#undef FILTER\n#define FILTER \"a == 1 || b == 1 || c == 1 || d == 1 || \" \\\n\t       \"e == 1 || f == 1 || g == 1 || h == 1\"\n\tDATA_REC(NO,  0, 0, 0, 0, 0, 0, 0, 0, \"\"),\n\tDATA_REC(YES, 0, 0, 0, 0, 0, 0, 0, 1, \"\"),\n\tDATA_REC(YES, 1, 0, 0, 0, 0, 0, 0, 0, \"bcdefgh\"),\n#undef FILTER\n#define FILTER \"(a == 1 || b == 1) && (c == 1 || d == 1) && \" \\\n\t       \"(e == 1 || f == 1) && (g == 1 || h == 1)\"\n\tDATA_REC(NO,  0, 0, 1, 1, 1, 1, 1, 1, \"dfh\"),\n\tDATA_REC(YES, 0, 1, 0, 1, 0, 1, 0, 1, \"\"),\n\tDATA_REC(YES, 1, 0, 1, 0, 0, 1, 0, 1, \"bd\"),\n\tDATA_REC(NO,  1, 0, 1, 0, 0, 1, 0, 0, \"bd\"),\n#undef FILTER\n#define FILTER \"(a == 1 && b == 1) || (c == 1 && d == 1) || \" \\\n\t       \"(e == 1 && f == 1) || (g == 1 && h == 1)\"\n\tDATA_REC(YES, 1, 0, 1, 1, 1, 1, 1, 1, \"efgh\"),\n\tDATA_REC(YES, 0, 0, 0, 0, 0, 0, 1, 1, \"\"),\n\tDATA_REC(NO,  0, 0, 0, 0, 0, 0, 0, 1, \"\"),\n#undef FILTER\n#define FILTER \"(a == 1 && b == 1) && (c == 1 && d == 1) && \" \\\n\t       \"(e == 1 && f == 1) || (g == 1 && h == 1)\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 0, 0, \"gh\"),\n\tDATA_REC(NO,  0, 0, 0, 0, 0, 0, 0, 1, \"\"),\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 0, 1, 1, \"\"),\n#undef FILTER\n#define FILTER \"((a == 1 || b == 1) || (c == 1 || d == 1) || \" \\\n\t       \"(e == 1 || f == 1)) && (g == 1 || h == 1)\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 0, 1, \"bcdef\"),\n\tDATA_REC(NO,  0, 0, 0, 0, 0, 0, 0, 0, \"\"),\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 0, 1, 1, \"h\"),\n#undef FILTER\n#define FILTER \"((((((((a == 1) && (b == 1)) || (c == 1)) && (d == 1)) || \" \\\n\t       \"(e == 1)) && (f == 1)) || (g == 1)) && (h == 1))\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 1, 1, \"ceg\"),\n\tDATA_REC(NO,  0, 1, 0, 1, 0, 1, 0, 1, \"\"),\n\tDATA_REC(NO,  1, 0, 1, 0, 1, 0, 1, 0, \"\"),\n#undef FILTER\n#define FILTER \"((((((((a == 1) || (b == 1)) && (c == 1)) || (d == 1)) && \" \\\n\t       \"(e == 1)) || (f == 1)) && (g == 1)) || (h == 1))\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 1, 1, \"bdfh\"),\n\tDATA_REC(YES, 0, 1, 0, 1, 0, 1, 0, 1, \"\"),\n\tDATA_REC(YES, 1, 0, 1, 0, 1, 0, 1, 0, \"bdfh\"),\n};\n\n#undef DATA_REC\n#undef FILTER\n#undef YES\n#undef NO\n\n#define DATA_CNT ARRAY_SIZE(test_filter_data)\n\nstatic int test_pred_visited;\n\nstatic int test_pred_visited_fn(struct filter_pred *pred, void *event)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\ttest_pred_visited = 1;\n\tprintk(KERN_INFO \"\\npred visited %s\\n\", field->name);\n\treturn 1;\n}\n\nstatic void update_pred_fn(struct event_filter *filter, char *fields)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tstruct ftrace_event_field *field = pred->field;\n\n\t\tWARN_ON_ONCE(!pred->fn);\n\n\t\tif (!field) {\n\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strchr(fields, *field->name))\n\t\t\tcontinue;\n\n\t\tpred->fn = test_pred_visited_fn;\n\t}\n}\n\nstatic __init int ftrace_test_event_filter(void)\n{\n\tint i;\n\n\tprintk(KERN_INFO \"Testing ftrace filter: \");\n\n\tfor (i = 0; i < DATA_CNT; i++) {\n\t\tstruct event_filter *filter = NULL;\n\t\tstruct test_filter_data_t *d = &test_filter_data[i];\n\t\tint err;\n\n\t\terr = create_filter(NULL, &event_ftrace_test_filter,\n\t\t\t\t    d->filter, false, &filter);\n\t\tif (err) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to get filter for '%s', err %d\\n\",\n\t\t\t       d->filter, err);\n\t\t\t__free_filter(filter);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Needed to dereference filter->prog */\n\t\tmutex_lock(&event_mutex);\n\t\t/*\n\t\t * The preemption disabling is not really needed for self\n\t\t * tests, but the rcu dereference will complain without it.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (*d->not_visited)\n\t\t\tupdate_pred_fn(filter, d->not_visited);\n\n\t\ttest_pred_visited = 0;\n\t\terr = filter_match_preds(filter, &d->rec);\n\t\tpreempt_enable();\n\n\t\tmutex_unlock(&event_mutex);\n\n\t\t__free_filter(filter);\n\n\t\tif (test_pred_visited) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\",\n\t\t\t       d->filter);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err != d->match) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to match filter '%s', expected %d\\n\",\n\t\t\t       d->filter, d->match);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DATA_CNT)\n\t\tprintk(KERN_CONT \"OK\\n\");\n\n\treturn 0;\n}\n\nlate_initcall(ftrace_test_event_filter);\n\n#endif /* CONFIG_FTRACE_STARTUP_TEST */\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * trace_events_filter - generic event filtering\n *\n * Copyright (C) 2009 Tom Zanussi <tzanussi@gmail.com>\n */\n\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n\n#include \"trace.h\"\n#include \"trace_output.h\"\n\n#define DEFAULT_SYS_FILTER_MESSAGE\t\t\t\t\t\\\n\t\"### global filter ###\\n\"\t\t\t\t\t\\\n\t\"# Use this to set filters for multiple events.\\n\"\t\t\\\n\t\"# Only events with the given fields will be affected.\\n\"\t\\\n\t\"# If no events are modified, an error message will be displayed here\"\n\n/* Due to token parsing '<=' must be before '<' and '>=' must be before '>' */\n#define OPS\t\t\t\t\t\\\n\tC( OP_GLOB,\t\"~\"  ),\t\t\t\\\n\tC( OP_NE,\t\"!=\" ),\t\t\t\\\n\tC( OP_EQ,\t\"==\" ),\t\t\t\\\n\tC( OP_LE,\t\"<=\" ),\t\t\t\\\n\tC( OP_LT,\t\"<\"  ),\t\t\t\\\n\tC( OP_GE,\t\">=\" ),\t\t\t\\\n\tC( OP_GT,\t\">\"  ),\t\t\t\\\n\tC( OP_BAND,\t\"&\"  ),\t\t\t\\\n\tC( OP_MAX,\tNULL )\n\n#undef C\n#define C(a, b)\ta\n\nenum filter_op_ids { OPS };\n\n#undef C\n#define C(a, b)\tb\n\nstatic const char * ops[] = { OPS };\n\n/*\n * pred functions are OP_LE, OP_LT, OP_GE, OP_GT, and OP_BAND\n * pred_funcs_##type below must match the order of them above.\n */\n#define PRED_FUNC_START\t\t\tOP_LE\n#define PRED_FUNC_MAX\t\t\t(OP_BAND - PRED_FUNC_START)\n\n#define ERRORS\t\t\t\t\t\t\t\t\\\n\tC(NONE,\t\t\t\"No error\"),\t\t\t\t\\\n\tC(INVALID_OP,\t\t\"Invalid operator\"),\t\t\t\\\n\tC(TOO_MANY_OPEN,\t\"Too many '('\"),\t\t\t\\\n\tC(TOO_MANY_CLOSE,\t\"Too few '('\"),\t\t\t\t\\\n\tC(MISSING_QUOTE,\t\"Missing matching quote\"),\t\t\\\n\tC(OPERAND_TOO_LONG,\t\"Operand too long\"),\t\t\t\\\n\tC(EXPECT_STRING,\t\"Expecting string field\"),\t\t\\\n\tC(EXPECT_DIGIT,\t\t\"Expecting numeric field\"),\t\t\\\n\tC(ILLEGAL_FIELD_OP,\t\"Illegal operation for field type\"),\t\\\n\tC(FIELD_NOT_FOUND,\t\"Field not found\"),\t\t\t\\\n\tC(ILLEGAL_INTVAL,\t\"Illegal integer value\"),\t\t\\\n\tC(BAD_SUBSYS_FILTER,\t\"Couldn't find or set field in one of a subsystem's events\"), \\\n\tC(TOO_MANY_PREDS,\t\"Too many terms in predicate expression\"), \\\n\tC(INVALID_FILTER,\t\"Meaningless filter expression\"),\t\\\n\tC(IP_FIELD_ONLY,\t\"Only 'ip' field is supported for function trace\"), \\\n\tC(INVALID_VALUE,\t\"Invalid value (did you forget quotes)?\"), \\\n\tC(ERRNO,\t\t\"Error\"),\t\t\t\t\\\n\tC(NO_FILTER,\t\t\"No filter found\")\n\n#undef C\n#define C(a, b)\t\tFILT_ERR_##a\n\nenum { ERRORS };\n\n#undef C\n#define C(a, b)\t\tb\n\nstatic const char *err_text[] = { ERRORS };\n\n/* Called after a '!' character but \"!=\" and \"!~\" are not \"not\"s */\nstatic bool is_not(const char *str)\n{\n\tswitch (str[1]) {\n\tcase '=':\n\tcase '~':\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n/**\n * prog_entry - a singe entry in the filter program\n * @target:\t     Index to jump to on a branch (actually one minus the index)\n * @when_to_branch:  The value of the result of the predicate to do a branch\n * @pred:\t     The predicate to execute.\n */\nstruct prog_entry {\n\tint\t\t\ttarget;\n\tint\t\t\twhen_to_branch;\n\tstruct filter_pred\t*pred;\n};\n\n/**\n * update_preds- assign a program entry a label target\n * @prog: The program array\n * @N: The index of the current entry in @prog\n * @when_to_branch: What to assign a program entry for its branch condition\n *\n * The program entry at @N has a target that points to the index of a program\n * entry that can have its target and when_to_branch fields updated.\n * Update the current program entry denoted by index @N target field to be\n * that of the updated entry. This will denote the entry to update if\n * we are processing an \"||\" after an \"&&\"\n */\nstatic void update_preds(struct prog_entry *prog, int N, int invert)\n{\n\tint t, s;\n\n\tt = prog[N].target;\n\ts = prog[t].target;\n\tprog[t].when_to_branch = invert;\n\tprog[t].target = N;\n\tprog[N].target = s;\n}\n\nstruct filter_parse_error {\n\tint lasterr;\n\tint lasterr_pos;\n};\n\nstatic void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}\n\ntypedef int (*parse_pred_fn)(const char *str, void *data, int pos,\n\t\t\t     struct filter_parse_error *pe,\n\t\t\t     struct filter_pred **pred);\n\nenum {\n\tINVERT\t\t= 1,\n\tPROCESS_AND\t= 2,\n\tPROCESS_OR\t= 4,\n};\n\n/*\n * Without going into a formal proof, this explains the method that is used in\n * parsing the logical expressions.\n *\n * For example, if we have: \"a && !(!b || (c && g)) || d || e && !f\"\n * The first pass will convert it into the following program:\n *\n * n1: r=a;       l1: if (!r) goto l4;\n * n2: r=b;       l2: if (!r) goto l4;\n * n3: r=c; r=!r; l3: if (r) goto l4;\n * n4: r=g; r=!r; l4: if (r) goto l5;\n * n5: r=d;       l5: if (r) goto T\n * n6: r=e;       l6: if (!r) goto l7;\n * n7: r=f; r=!r; l7: if (!r) goto F\n * T: return TRUE\n * F: return FALSE\n *\n * To do this, we use a data structure to represent each of the above\n * predicate and conditions that has:\n *\n *  predicate, when_to_branch, invert, target\n *\n * The \"predicate\" will hold the function to determine the result \"r\".\n * The \"when_to_branch\" denotes what \"r\" should be if a branch is to be taken\n * \"&&\" would contain \"!r\" or (0) and \"||\" would contain \"r\" or (1).\n * The \"invert\" holds whether the value should be reversed before testing.\n * The \"target\" contains the label \"l#\" to jump to.\n *\n * A stack is created to hold values when parentheses are used.\n *\n * To simplify the logic, the labels will start at 0 and not 1.\n *\n * The possible invert values are 1 and 0. The number of \"!\"s that are in scope\n * before the predicate determines the invert value, if the number is odd then\n * the invert value is 1 and 0 otherwise. This means the invert value only\n * needs to be toggled when a new \"!\" is introduced compared to what is stored\n * on the stack, where parentheses were used.\n *\n * The top of the stack and \"invert\" are initialized to zero.\n *\n * ** FIRST PASS **\n *\n * #1 A loop through all the tokens is done:\n *\n * #2 If the token is an \"(\", the stack is push, and the current stack value\n *    gets the current invert value, and the loop continues to the next token.\n *    The top of the stack saves the \"invert\" value to keep track of what\n *    the current inversion is. As \"!(a && !b || c)\" would require all\n *    predicates being affected separately by the \"!\" before the parentheses.\n *    And that would end up being equivalent to \"(!a || b) && !c\"\n *\n * #3 If the token is an \"!\", the current \"invert\" value gets inverted, and\n *    the loop continues. Note, if the next token is a predicate, then\n *    this \"invert\" value is only valid for the current program entry,\n *    and does not affect other predicates later on.\n *\n * The only other acceptable token is the predicate string.\n *\n * #4 A new entry into the program is added saving: the predicate and the\n *    current value of \"invert\". The target is currently assigned to the\n *    previous program index (this will not be its final value).\n *\n * #5 We now enter another loop and look at the next token. The only valid\n *    tokens are \")\", \"&&\", \"||\" or end of the input string \"\\0\".\n *\n * #6 The invert variable is reset to the current value saved on the top of\n *    the stack.\n *\n * #7 The top of the stack holds not only the current invert value, but also\n *    if a \"&&\" or \"||\" needs to be processed. Note, the \"&&\" takes higher\n *    precedence than \"||\". That is \"a && b || c && d\" is equivalent to\n *    \"(a && b) || (c && d)\". Thus the first thing to do is to see if \"&&\" needs\n *    to be processed. This is the case if an \"&&\" was the last token. If it was\n *    then we call update_preds(). This takes the program, the current index in\n *    the program, and the current value of \"invert\".  More will be described\n *    below about this function.\n *\n * #8 If the next token is \"&&\" then we set a flag in the top of the stack\n *    that denotes that \"&&\" needs to be processed, break out of this loop\n *    and continue with the outer loop.\n *\n * #9 Otherwise, if a \"||\" needs to be processed then update_preds() is called.\n *    This is called with the program, the current index in the program, but\n *    this time with an inverted value of \"invert\" (that is !invert). This is\n *    because the value taken will become the \"when_to_branch\" value of the\n *    program.\n *    Note, this is called when the next token is not an \"&&\". As stated before,\n *    \"&&\" takes higher precedence, and \"||\" should not be processed yet if the\n *    next logical operation is \"&&\".\n *\n * #10 If the next token is \"||\" then we set a flag in the top of the stack\n *     that denotes that \"||\" needs to be processed, break out of this loop\n *     and continue with the outer loop.\n *\n * #11 If this is the end of the input string \"\\0\" then we break out of both\n *     loops.\n *\n * #12 Otherwise, the next token is \")\", where we pop the stack and continue\n *     this inner loop.\n *\n * Now to discuss the update_pred() function, as that is key to the setting up\n * of the program. Remember the \"target\" of the program is initialized to the\n * previous index and not the \"l\" label. The target holds the index into the\n * program that gets affected by the operand. Thus if we have something like\n *  \"a || b && c\", when we process \"a\" the target will be \"-1\" (undefined).\n * When we process \"b\", its target is \"0\", which is the index of \"a\", as that's\n * the predicate that is affected by \"||\". But because the next token after \"b\"\n * is \"&&\" we don't call update_preds(). Instead continue to \"c\". As the\n * next token after \"c\" is not \"&&\" but the end of input, we first process the\n * \"&&\" by calling update_preds() for the \"&&\" then we process the \"||\" by\n * callin updates_preds() with the values for processing \"||\".\n *\n * What does that mean? What update_preds() does is to first save the \"target\"\n * of the program entry indexed by the current program entry's \"target\"\n * (remember the \"target\" is initialized to previous program entry), and then\n * sets that \"target\" to the current index which represents the label \"l#\".\n * That entry's \"when_to_branch\" is set to the value passed in (the \"invert\"\n * or \"!invert\"). Then it sets the current program entry's target to the saved\n * \"target\" value (the old value of the program that had its \"target\" updated\n * to the label).\n *\n * Looking back at \"a || b && c\", we have the following steps:\n *  \"a\"  - prog[0] = { \"a\", X, -1 } // pred, when_to_branch, target\n *  \"||\" - flag that we need to process \"||\"; continue outer loop\n *  \"b\"  - prog[1] = { \"b\", X, 0 }\n *  \"&&\" - flag that we need to process \"&&\"; continue outer loop\n * (Notice we did not process \"||\")\n *  \"c\"  - prog[2] = { \"c\", X, 1 }\n *  update_preds(prog, 2, 0); // invert = 0 as we are processing \"&&\"\n *    t = prog[2].target; // t = 1\n *    s = prog[t].target; // s = 0\n *    prog[t].target = 2; // Set target to \"l2\"\n *    prog[t].when_to_branch = 0;\n *    prog[2].target = s;\n * update_preds(prog, 2, 1); // invert = 1 as we are now processing \"||\"\n *    t = prog[2].target; // t = 0\n *    s = prog[t].target; // s = -1\n *    prog[t].target = 2; // Set target to \"l2\"\n *    prog[t].when_to_branch = 1;\n *    prog[2].target = s;\n *\n * #13 Which brings us to the final step of the first pass, which is to set\n *     the last program entry's when_to_branch and target, which will be\n *     when_to_branch = 0; target = N; ( the label after the program entry after\n *     the last program entry processed above).\n *\n * If we denote \"TRUE\" to be the entry after the last program entry processed,\n * and \"FALSE\" the program entry after that, we are now done with the first\n * pass.\n *\n * Making the above \"a || b && c\" have a progam of:\n *  prog[0] = { \"a\", 1, 2 }\n *  prog[1] = { \"b\", 0, 2 }\n *  prog[2] = { \"c\", 0, 3 }\n *\n * Which translates into:\n * n0: r = a; l0: if (r) goto l2;\n * n1: r = b; l1: if (!r) goto l2;\n * n2: r = c; l2: if (!r) goto l3;  // Which is the same as \"goto F;\"\n * T: return TRUE; l3:\n * F: return FALSE\n *\n * Although, after the first pass, the program is correct, it is\n * inefficient. The simple sample of \"a || b && c\" could be easily been\n * converted into:\n * n0: r = a; if (r) goto T\n * n1: r = b; if (!r) goto F\n * n2: r = c; if (!r) goto F\n * T: return TRUE;\n * F: return FALSE;\n *\n * The First Pass is over the input string. The next too passes are over\n * the program itself.\n *\n * ** SECOND PASS **\n *\n * Which brings us to the second pass. If a jump to a label has the\n * same condition as that label, it can instead jump to its target.\n * The original example of \"a && !(!b || (c && g)) || d || e && !f\"\n * where the first pass gives us:\n *\n * n1: r=a;       l1: if (!r) goto l4;\n * n2: r=b;       l2: if (!r) goto l4;\n * n3: r=c; r=!r; l3: if (r) goto l4;\n * n4: r=g; r=!r; l4: if (r) goto l5;\n * n5: r=d;       l5: if (r) goto T\n * n6: r=e;       l6: if (!r) goto l7;\n * n7: r=f; r=!r; l7: if (!r) goto F:\n * T: return TRUE;\n * F: return FALSE\n *\n * We can see that \"l3: if (r) goto l4;\" and at l4, we have \"if (r) goto l5;\".\n * And \"l5: if (r) goto T\", we could optimize this by converting l3 and l4\n * to go directly to T. To accomplish this, we start from the last\n * entry in the program and work our way back. If the target of the entry\n * has the same \"when_to_branch\" then we could use that entry's target.\n * Doing this, the above would end up as:\n *\n * n1: r=a;       l1: if (!r) goto l4;\n * n2: r=b;       l2: if (!r) goto l4;\n * n3: r=c; r=!r; l3: if (r) goto T;\n * n4: r=g; r=!r; l4: if (r) goto T;\n * n5: r=d;       l5: if (r) goto T;\n * n6: r=e;       l6: if (!r) goto F;\n * n7: r=f; r=!r; l7: if (!r) goto F;\n * T: return TRUE\n * F: return FALSE\n *\n * In that same pass, if the \"when_to_branch\" doesn't match, we can simply\n * go to the program entry after the label. That is, \"l2: if (!r) goto l4;\"\n * where \"l4: if (r) goto T;\", then we can convert l2 to be:\n * \"l2: if (!r) goto n5;\".\n *\n * This will have the second pass give us:\n * n1: r=a;       l1: if (!r) goto n5;\n * n2: r=b;       l2: if (!r) goto n5;\n * n3: r=c; r=!r; l3: if (r) goto T;\n * n4: r=g; r=!r; l4: if (r) goto T;\n * n5: r=d;       l5: if (r) goto T\n * n6: r=e;       l6: if (!r) goto F;\n * n7: r=f; r=!r; l7: if (!r) goto F\n * T: return TRUE\n * F: return FALSE\n *\n * Notice, all the \"l#\" labels are no longer used, and they can now\n * be discarded.\n *\n * ** THIRD PASS **\n *\n * For the third pass we deal with the inverts. As they simply just\n * make the \"when_to_branch\" get inverted, a simple loop over the\n * program to that does: \"when_to_branch ^= invert;\" will do the\n * job, leaving us with:\n * n1: r=a; if (!r) goto n5;\n * n2: r=b; if (!r) goto n5;\n * n3: r=c: if (!r) goto T;\n * n4: r=g; if (!r) goto T;\n * n5: r=d; if (r) goto T\n * n6: r=e; if (!r) goto F;\n * n7: r=f; if (r) goto F\n * T: return TRUE\n * F: return FALSE\n *\n * As \"r = a; if (!r) goto n5;\" is obviously the same as\n * \"if (!a) goto n5;\" without doing anything we can interperate the\n * program as:\n * n1: if (!a) goto n5;\n * n2: if (!b) goto n5;\n * n3: if (!c) goto T;\n * n4: if (!g) goto T;\n * n5: if (d) goto T\n * n6: if (!e) goto F;\n * n7: if (f) goto F\n * T: return TRUE\n * F: return FALSE\n *\n * Since the inverts are discarded at the end, there's no reason to store\n * them in the program array (and waste memory). A separate array to hold\n * the inverts is used and freed at the end.\n */\nstatic struct prog_entry *\npredicate_parse(const char *str, int nr_parens, int nr_preds,\n\t\tparse_pred_fn parse_pred, void *data,\n\t\tstruct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog_stack;\n\tstruct prog_entry *prog;\n\tconst char *ptr = str;\n\tchar *inverts = NULL;\n\tint *op_stack;\n\tint *top;\n\tint invert = 0;\n\tint ret = -ENOMEM;\n\tint len;\n\tint N = 0;\n\tint i;\n\n\tnr_preds += 2; /* For TRUE and FALSE */\n\n\top_stack = kmalloc_array(nr_parens, sizeof(*op_stack), GFP_KERNEL);\n\tif (!op_stack)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprog_stack = kcalloc(nr_preds, sizeof(*prog_stack), GFP_KERNEL);\n\tif (!prog_stack) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\tinverts = kmalloc_array(nr_preds, sizeof(*inverts), GFP_KERNEL);\n\tif (!inverts) {\n\t\tparse_error(pe, -ENOMEM, 0);\n\t\tgoto out_free;\n\t}\n\n\ttop = op_stack;\n\tprog = prog_stack;\n\t*top = 0;\n\n\t/* First pass */\n\twhile (*ptr) {\t\t\t\t\t\t/* #1 */\n\t\tconst char *next = ptr++;\n\n\t\tif (isspace(*next))\n\t\t\tcontinue;\n\n\t\tswitch (*next) {\n\t\tcase '(':\t\t\t\t\t/* #2 */\n\t\t\tif (top - op_stack > nr_parens) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t*(++top) = invert;\n\t\t\tcontinue;\n\t\tcase '!':\t\t\t\t\t/* #3 */\n\t\t\tif (!is_not(next))\n\t\t\t\tbreak;\n\t\t\tinvert = !invert;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (N >= nr_preds) {\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS, next - str);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tinverts[N] = invert;\t\t\t\t/* #4 */\n\t\tprog[N].target = N-1;\n\n\t\tlen = parse_pred(next, data, ptr - str, pe, &prog[N].pred);\n\t\tif (len < 0) {\n\t\t\tret = len;\n\t\t\tgoto out_free;\n\t\t}\n\t\tptr = next + len;\n\n\t\tN++;\n\n\t\tret = -1;\n\t\twhile (1) {\t\t\t\t\t/* #5 */\n\t\t\tnext = ptr++;\n\t\t\tif (isspace(*next))\n\t\t\t\tcontinue;\n\n\t\t\tswitch (*next) {\n\t\t\tcase ')':\n\t\t\tcase '\\0':\n\t\t\t\tbreak;\n\t\t\tcase '&':\n\t\t\tcase '|':\n\t\t\t\t/* accepting only \"&&\" or \"||\" */\n\t\t\t\tif (next[1] == next[0]) {\n\t\t\t\t\tptr++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* fall through */\n\t\t\tdefault:\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_PREDS,\n\t\t\t\t\t    next - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\tinvert = *top & INVERT;\n\n\t\t\tif (*top & PROCESS_AND) {\t\t/* #7 */\n\t\t\t\tupdate_preds(prog, N - 1, invert);\n\t\t\t\t*top &= ~PROCESS_AND;\n\t\t\t}\n\t\t\tif (*next == '&') {\t\t\t/* #8 */\n\t\t\t\t*top |= PROCESS_AND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (*top & PROCESS_OR) {\t\t/* #9 */\n\t\t\t\tupdate_preds(prog, N - 1, !invert);\n\t\t\t\t*top &= ~PROCESS_OR;\n\t\t\t}\n\t\t\tif (*next == '|') {\t\t\t/* #10 */\n\t\t\t\t*top |= PROCESS_OR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!*next)\t\t\t\t/* #11 */\n\t\t\t\tgoto out;\n\n\t\t\tif (top == op_stack) {\n\t\t\t\tret = -1;\n\t\t\t\t/* Too few '(' */\n\t\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, ptr - str);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\ttop--;\t\t\t\t\t/* #12 */\n\t\t}\n\t}\n out:\n\tif (top != op_stack) {\n\t\t/* Too many '(' */\n\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tif (!N) {\n\t\t/* No program? */\n\t\tret = -EINVAL;\n\t\tparse_error(pe, FILT_ERR_NO_FILTER, ptr - str);\n\t\tgoto out_free;\n\t}\n\n\tprog[N].pred = NULL;\t\t\t\t\t/* #13 */\n\tprog[N].target = 1;\t\t/* TRUE */\n\tprog[N+1].pred = NULL;\n\tprog[N+1].target = 0;\t\t/* FALSE */\n\tprog[N-1].target = N;\n\tprog[N-1].when_to_branch = false;\n\n\t/* Second Pass */\n\tfor (i = N-1 ; i--; ) {\n\t\tint target = prog[i].target;\n\t\tif (prog[i].when_to_branch == prog[target].when_to_branch)\n\t\t\tprog[i].target = prog[target].target;\n\t}\n\n\t/* Third Pass */\n\tfor (i = 0; i < N; i++) {\n\t\tinvert = inverts[i] ^ prog[i].when_to_branch;\n\t\tprog[i].when_to_branch = invert;\n\t\t/* Make sure the program always moves forward */\n\t\tif (WARN_ON(prog[i].target <= i)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\n\tkfree(op_stack);\n\tkfree(inverts);\n\treturn prog;\nout_free:\n\tkfree(op_stack);\n\tkfree(inverts);\n\tif (prog_stack) {\n\t\tfor (i = 0; prog_stack[i].pred; i++)\n\t\t\tkfree(prog_stack[i].pred);\n\t\tkfree(prog_stack);\n\t}\n\treturn ERR_PTR(ret);\n}\n\n#define DEFINE_COMPARISON_PRED(type)\t\t\t\t\t\\\nstatic int filter_pred_LT_##type(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype *addr = (type *)(event + pred->offset);\t\t\t\\\n\ttype val = (type)pred->val;\t\t\t\t\t\\\n\treturn *addr < val;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic int filter_pred_LE_##type(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype *addr = (type *)(event + pred->offset);\t\t\t\\\n\ttype val = (type)pred->val;\t\t\t\t\t\\\n\treturn *addr <= val;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic int filter_pred_GT_##type(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype *addr = (type *)(event + pred->offset);\t\t\t\\\n\ttype val = (type)pred->val;\t\t\t\t\t\\\n\treturn *addr > val;\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic int filter_pred_GE_##type(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype *addr = (type *)(event + pred->offset);\t\t\t\\\n\ttype val = (type)pred->val;\t\t\t\t\t\\\n\treturn *addr >= val;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic int filter_pred_BAND_##type(struct filter_pred *pred, void *event) \\\n{\t\t\t\t\t\t\t\t\t\\\n\ttype *addr = (type *)(event + pred->offset);\t\t\t\\\n\ttype val = (type)pred->val;\t\t\t\t\t\\\n\treturn !!(*addr & val);\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic const filter_pred_fn_t pred_funcs_##type[] = {\t\t\t\\\n\tfilter_pred_LE_##type,\t\t\t\t\t\t\\\n\tfilter_pred_LT_##type,\t\t\t\t\t\t\\\n\tfilter_pred_GE_##type,\t\t\t\t\t\t\\\n\tfilter_pred_GT_##type,\t\t\t\t\t\t\\\n\tfilter_pred_BAND_##type,\t\t\t\t\t\\\n};\n\n#define DEFINE_EQUALITY_PRED(size)\t\t\t\t\t\\\nstatic int filter_pred_##size(struct filter_pred *pred, void *event)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu##size *addr = (u##size *)(event + pred->offset);\t\t\\\n\tu##size val = (u##size)pred->val;\t\t\t\t\\\n\tint match;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmatch = (val == *addr) ^ pred->not;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn match;\t\t\t\t\t\t\t\\\n}\n\nDEFINE_COMPARISON_PRED(s64);\nDEFINE_COMPARISON_PRED(u64);\nDEFINE_COMPARISON_PRED(s32);\nDEFINE_COMPARISON_PRED(u32);\nDEFINE_COMPARISON_PRED(s16);\nDEFINE_COMPARISON_PRED(u16);\nDEFINE_COMPARISON_PRED(s8);\nDEFINE_COMPARISON_PRED(u8);\n\nDEFINE_EQUALITY_PRED(64);\nDEFINE_EQUALITY_PRED(32);\nDEFINE_EQUALITY_PRED(16);\nDEFINE_EQUALITY_PRED(8);\n\n/* Filter predicate for fixed sized arrays of characters */\nstatic int filter_pred_string(struct filter_pred *pred, void *event)\n{\n\tchar *addr = (char *)(event + pred->offset);\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, pred->regex.field_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}\n\n/* Filter predicate for char * pointers */\nstatic int filter_pred_pchar(struct filter_pred *pred, void *event)\n{\n\tchar **addr = (char **)(event + pred->offset);\n\tint cmp, match;\n\tint len = strlen(*addr) + 1;\t/* including tailing '\\0' */\n\n\tcmp = pred->regex.match(*addr, &pred->regex, len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}\n\n/*\n * Filter predicate for dynamic sized arrays of characters.\n * These are implemented through a list of strings at the end\n * of the entry.\n * Also each of these strings have a field in the entry which\n * contains its offset from the beginning of the entry.\n * We have then first to get this field, dereference it\n * and add it to the address of the entry, and at last we have\n * the address of the string.\n */\nstatic int filter_pred_strloc(struct filter_pred *pred, void *event)\n{\n\tu32 str_item = *(u32 *)(event + pred->offset);\n\tint str_loc = str_item & 0xffff;\n\tint str_len = str_item >> 16;\n\tchar *addr = (char *)(event + str_loc);\n\tint cmp, match;\n\n\tcmp = pred->regex.match(addr, &pred->regex, str_len);\n\n\tmatch = cmp ^ pred->not;\n\n\treturn match;\n}\n\n/* Filter predicate for CPUs. */\nstatic int filter_pred_cpu(struct filter_pred *pred, void *event)\n{\n\tint cpu, cmp;\n\n\tcpu = raw_smp_processor_id();\n\tcmp = pred->val;\n\n\tswitch (pred->op) {\n\tcase OP_EQ:\n\t\treturn cpu == cmp;\n\tcase OP_NE:\n\t\treturn cpu != cmp;\n\tcase OP_LT:\n\t\treturn cpu < cmp;\n\tcase OP_LE:\n\t\treturn cpu <= cmp;\n\tcase OP_GT:\n\t\treturn cpu > cmp;\n\tcase OP_GE:\n\t\treturn cpu >= cmp;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n/* Filter predicate for COMM. */\nstatic int filter_pred_comm(struct filter_pred *pred, void *event)\n{\n\tint cmp;\n\n\tcmp = pred->regex.match(current->comm, &pred->regex,\n\t\t\t\tTASK_COMM_LEN);\n\treturn cmp ^ pred->not;\n}\n\nstatic int filter_pred_none(struct filter_pred *pred, void *event)\n{\n\treturn 0;\n}\n\n/*\n * regex_match_foo - Basic regex callbacks\n *\n * @str: the string to be searched\n * @r:   the regex structure containing the pattern string\n * @len: the length of the string to be searched (including '\\0')\n *\n * Note:\n * - @str might not be NULL-terminated if it's of type DYN_STRING\n *   or STATIC_STRING, unless @len is zero.\n */\n\nstatic int regex_match_full(char *str, struct regex *r, int len)\n{\n\t/* len of zero means str is dynamic and ends with '\\0' */\n\tif (!len)\n\t\treturn strcmp(str, r->pattern) == 0;\n\n\treturn strncmp(str, r->pattern, len) == 0;\n}\n\nstatic int regex_match_front(char *str, struct regex *r, int len)\n{\n\tif (len && len < r->len)\n\t\treturn 0;\n\n\treturn strncmp(str, r->pattern, r->len) == 0;\n}\n\nstatic int regex_match_middle(char *str, struct regex *r, int len)\n{\n\tif (!len)\n\t\treturn strstr(str, r->pattern) != NULL;\n\n\treturn strnstr(str, r->pattern, len) != NULL;\n}\n\nstatic int regex_match_end(char *str, struct regex *r, int len)\n{\n\tint strlen = len - 1;\n\n\tif (strlen >= r->len &&\n\t    memcmp(str + strlen - r->len, r->pattern, r->len) == 0)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int regex_match_glob(char *str, struct regex *r, int len __maybe_unused)\n{\n\tif (glob_match(r->pattern, str))\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * filter_parse_regex - parse a basic regex\n * @buff:   the raw regex\n * @len:    length of the regex\n * @search: will point to the beginning of the string to compare\n * @not:    tell whether the match will have to be inverted\n *\n * This passes in a buffer containing a regex and this function will\n * set search to point to the search part of the buffer and\n * return the type of search it is (see enum above).\n * This does modify buff.\n *\n * Returns enum type.\n *  search returns the pointer to use for comparison.\n *  not returns 1 if buff started with a '!'\n *     0 otherwise.\n */\nenum regex_type filter_parse_regex(char *buff, int len, char **search, int *not)\n{\n\tint type = MATCH_FULL;\n\tint i;\n\n\tif (buff[0] == '!') {\n\t\t*not = 1;\n\t\tbuff++;\n\t\tlen--;\n\t} else\n\t\t*not = 0;\n\n\t*search = buff;\n\n\tif (isdigit(buff[0]))\n\t\treturn MATCH_INDEX;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\ttype = MATCH_END_ONLY;\n\t\t\t} else if (i == len - 1) {\n\t\t\t\tif (type == MATCH_END_ONLY)\n\t\t\t\t\ttype = MATCH_MIDDLE_ONLY;\n\t\t\t\telse\n\t\t\t\t\ttype = MATCH_FRONT_ONLY;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t} else {\t/* pattern continues, use full glob */\n\t\t\t\treturn MATCH_GLOB;\n\t\t\t}\n\t\t} else if (strchr(\"[?\\\\\", buff[i])) {\n\t\t\treturn MATCH_GLOB;\n\t\t}\n\t}\n\tif (buff[0] == '*')\n\t\t*search = buff + 1;\n\n\treturn type;\n}\n\nstatic void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = &pred->regex;\n\tchar *search;\n\tenum regex_type type = MATCH_FULL;\n\n\tif (pred->op == OP_GLOB) {\n\t\ttype = filter_parse_regex(r->pattern, r->len, &search, &pred->not);\n\t\tr->len = strlen(search);\n\t\tmemmove(r->pattern, search, r->len+1);\n\t}\n\n\tswitch (type) {\n\t/* MATCH_INDEX should not happen, but if it does, match full */\n\tcase MATCH_INDEX:\n\tcase MATCH_FULL:\n\t\tr->match = regex_match_full;\n\t\tbreak;\n\tcase MATCH_FRONT_ONLY:\n\t\tr->match = regex_match_front;\n\t\tbreak;\n\tcase MATCH_MIDDLE_ONLY:\n\t\tr->match = regex_match_middle;\n\t\tbreak;\n\tcase MATCH_END_ONLY:\n\t\tr->match = regex_match_end;\n\t\tbreak;\n\tcase MATCH_GLOB:\n\t\tr->match = regex_match_glob;\n\t\tbreak;\n\t}\n}\n\n/* return 1 if event matches, 0 otherwise (discard) */\nint filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\t/* no filter is considered a match */\n\tif (!filter)\n\t\treturn 1;\n\n\t/* Protected by either SRCU(tracepoint_srcu) or preempt_disable */\n\tprog = rcu_dereference_raw(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}\nEXPORT_SYMBOL_GPL(filter_match_preds);\n\nstatic void remove_filter_string(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tkfree(filter->filter_string);\n\tfilter->filter_string = NULL;\n}\n\nstatic void append_filter_err(struct trace_array *tr,\n\t\t\t      struct filter_parse_error *pe,\n\t\t\t      struct event_filter *filter)\n{\n\tstruct trace_seq *s;\n\tint pos = pe->lasterr_pos;\n\tchar *buf;\n\tint len;\n\n\tif (WARN_ON(!filter->filter_string))\n\t\treturn;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s)\n\t\treturn;\n\ttrace_seq_init(s);\n\n\tlen = strlen(filter->filter_string);\n\tif (pos > len)\n\t\tpos = len;\n\n\t/* indexing is off by one */\n\tif (pos)\n\t\tpos++;\n\n\ttrace_seq_puts(s, filter->filter_string);\n\tif (pe->lasterr > 0) {\n\t\ttrace_seq_printf(s, \"\\n%*s\", pos, \"^\");\n\t\ttrace_seq_printf(s, \"\\nparse_error: %s\\n\", err_text[pe->lasterr]);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tpe->lasterr, pe->lasterr_pos);\n\t} else {\n\t\ttrace_seq_printf(s, \"\\nError: (%d)\\n\", pe->lasterr);\n\t\ttracing_log_err(tr, \"event filter parse error\",\n\t\t\t\tfilter->filter_string, err_text,\n\t\t\t\tFILT_ERR_ERRNO, 0);\n\t}\n\ttrace_seq_putc(s, 0);\n\tbuf = kmemdup_nul(s->buffer, s->seq.len, GFP_KERNEL);\n\tif (buf) {\n\t\tkfree(filter->filter_string);\n\t\tfilter->filter_string = buf;\n\t}\n\tkfree(s);\n}\n\nstatic inline struct event_filter *event_filter(struct trace_event_file *file)\n{\n\treturn file->filter;\n}\n\n/* caller must hold event_mutex */\nvoid print_event_filter(struct trace_event_file *file, struct trace_seq *s)\n{\n\tstruct event_filter *filter = event_filter(file);\n\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, \"none\\n\");\n}\n\nvoid print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t  struct trace_seq *s)\n{\n\tstruct event_filter *filter;\n\n\tmutex_lock(&event_mutex);\n\tfilter = system->filter;\n\tif (filter && filter->filter_string)\n\t\ttrace_seq_printf(s, \"%s\\n\", filter->filter_string);\n\telse\n\t\ttrace_seq_puts(s, DEFAULT_SYS_FILTER_MESSAGE \"\\n\");\n\tmutex_unlock(&event_mutex);\n}\n\nstatic void free_prog(struct event_filter *filter)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\n\tprog = rcu_access_pointer(filter->prog);\n\tif (!prog)\n\t\treturn;\n\n\tfor (i = 0; prog[i].pred; i++)\n\t\tkfree(prog[i].pred);\n\tkfree(prog);\n}\n\nstatic void filter_disable(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags &= ~EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_disable();\n}\n\nstatic void __free_filter(struct event_filter *filter)\n{\n\tif (!filter)\n\t\treturn;\n\n\tfree_prog(filter);\n\tkfree(filter->filter_string);\n\tkfree(filter);\n}\n\nvoid free_event_filter(struct event_filter *filter)\n{\n\t__free_filter(filter);\n}\n\nstatic inline void __remove_filter(struct trace_event_file *file)\n{\n\tfilter_disable(file);\n\tremove_filter_string(file->filter);\n}\n\nstatic void filter_free_subsystem_preds(struct trace_subsystem_dir *dir,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__remove_filter(file);\n\t}\n}\n\nstatic inline void __free_subsystem_filter(struct trace_event_file *file)\n{\n\t__free_filter(file->filter);\n\tfile->filter = NULL;\n}\n\nstatic void filter_free_subsystem_filters(struct trace_subsystem_dir *dir,\n\t\t\t\t\t  struct trace_array *tr)\n{\n\tstruct trace_event_file *file;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\t\t__free_subsystem_filter(file);\n\t}\n}\n\nint filter_assign_type(const char *type)\n{\n\tif (strstr(type, \"__data_loc\") && strstr(type, \"char\"))\n\t\treturn FILTER_DYN_STRING;\n\n\tif (strchr(type, '[') && strstr(type, \"char\"))\n\t\treturn FILTER_STATIC_STRING;\n\n\tif (strcmp(type, \"char *\") == 0 || strcmp(type, \"const char *\") == 0)\n\t\treturn FILTER_PTR_STRING;\n\n\treturn FILTER_OTHER;\n}\n\nstatic filter_pred_fn_t select_comparison_fn(enum filter_op_ids op,\n\t\t\t\t\t    int field_size, int field_is_signed)\n{\n\tfilter_pred_fn_t fn = NULL;\n\tint pred_func_index = -1;\n\n\tswitch (op) {\n\tcase OP_EQ:\n\tcase OP_NE:\n\t\tbreak;\n\tdefault:\n\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))\n\t\t\treturn NULL;\n\t\tpred_func_index = op - PRED_FUNC_START;\n\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))\n\t\t\treturn NULL;\n\t}\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_64;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s64[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u64[pred_func_index];\n\t\tbreak;\n\tcase 4:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_32;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s32[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u32[pred_func_index];\n\t\tbreak;\n\tcase 2:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_16;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s16[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u16[pred_func_index];\n\t\tbreak;\n\tcase 1:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_8;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s8[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u8[pred_func_index];\n\t\tbreak;\n\t}\n\n\treturn fn;\n}\n\n/* Called when a predicate is encountered by predicate_parse() */\nstatic int parse_pred(const char *str, void *data,\n\t\t      int pos, struct filter_parse_error *pe,\n\t\t      struct filter_pred **pred_ptr)\n{\n\tstruct trace_event_call *call = data;\n\tstruct ftrace_event_field *field;\n\tstruct filter_pred *pred = NULL;\n\tchar num_buf[24];\t/* Big enough to hold an address */\n\tchar *field_name;\n\tchar q;\n\tu64 val;\n\tint len;\n\tint ret;\n\tint op;\n\tint s;\n\tint i = 0;\n\n\t/* First find the field to associate to */\n\twhile (isspace(str[i]))\n\t\ti++;\n\ts = i;\n\n\twhile (isalnum(str[i]) || str[i] == '_')\n\t\ti++;\n\n\tlen = i - s;\n\n\tif (!len)\n\t\treturn -1;\n\n\tfield_name = kmemdup_nul(str + s, len, GFP_KERNEL);\n\tif (!field_name)\n\t\treturn -ENOMEM;\n\n\t/* Make sure that the field exists */\n\n\tfield = trace_find_event_field(call, field_name);\n\tkfree(field_name);\n\tif (!field) {\n\t\tparse_error(pe, FILT_ERR_FIELD_NOT_FOUND, pos + i);\n\t\treturn -EINVAL;\n\t}\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\t/* Make sure this op is supported */\n\tfor (op = 0; ops[op]; op++) {\n\t\t/* This is why '<=' must come before '<' in ops[] */\n\t\tif (strncmp(str + i, ops[op], strlen(ops[op])) == 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ops[op]) {\n\t\tparse_error(pe, FILT_ERR_INVALID_OP, pos + i);\n\t\tgoto err_free;\n\t}\n\n\ti += strlen(ops[op]);\n\n\twhile (isspace(str[i]))\n\t\ti++;\n\n\ts = i;\n\n\tpred = kzalloc(sizeof(*pred), GFP_KERNEL);\n\tif (!pred)\n\t\treturn -ENOMEM;\n\n\tpred->field = field;\n\tpred->offset = field->offset;\n\tpred->op = op;\n\n\tif (ftrace_event_is_function(call)) {\n\t\t/*\n\t\t * Perf does things different with function events.\n\t\t * It only allows an \"ip\" field, and expects a string.\n\t\t * But the string does not need to be surrounded by quotes.\n\t\t * If it is a string, the assigned function as a nop,\n\t\t * (perf doesn't use it) and grab everything.\n\t\t */\n\t\tif (strcmp(field->name, \"ip\") != 0) {\n\t\t\tparse_error(pe, FILT_ERR_IP_FIELD_ONLY, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\t\tpred->fn = filter_pred_none;\n\n\t\t/*\n\t\t * Quotes are not required, but if they exist then we need\n\t\t * to read them till we hit a matching one.\n\t\t */\n\t\tif (str[i] == '\\'' || str[i] == '\"')\n\t\t\tq = str[i];\n\t\telse\n\t\t\tq = 0;\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (q && str[i] == q)\n\t\t\t\tbreak;\n\t\t\tif (!q && (str[i] == ')' || str[i] == '&' ||\n\t\t\t\t   str[i] == '|'))\n\t\t\t\tbreak;\n\t\t}\n\t\t/* Skip quotes */\n\t\tif (q)\n\t\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t/* This is either a string, or an integer */\n\t} else if (str[i] == '\\'' || str[i] == '\"') {\n\t\tchar q = str[i];\n\n\t\t/* Make sure the op is OK for strings */\n\t\tswitch (op) {\n\t\tcase OP_NE:\n\t\t\tpred->not = 1;\n\t\t\t/* Fall through */\n\t\tcase OP_GLOB:\n\t\tcase OP_EQ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Make sure the field is OK for strings */\n\t\tif (!is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_DIGIT, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tfor (i++; str[i]; i++) {\n\t\t\tif (str[i] == q)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!str[i]) {\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t/* Skip quotes */\n\t\ts++;\n\t\tlen = i - s;\n\t\tif (len >= MAX_FILTER_STR_VAL) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->regex.len = len;\n\t\tstrncpy(pred->regex.pattern, str + s, len);\n\t\tpred->regex.pattern[len] = 0;\n\n\t\tfilter_build_regex(pred);\n\n\t\tif (field->filter_type == FILTER_COMM) {\n\t\t\tpred->fn = filter_pred_comm;\n\n\t\t} else if (field->filter_type == FILTER_STATIC_STRING) {\n\t\t\tpred->fn = filter_pred_string;\n\t\t\tpred->regex.field_len = field->size;\n\n\t\t} else if (field->filter_type == FILTER_DYN_STRING)\n\t\t\tpred->fn = filter_pred_strloc;\n\t\telse\n\t\t\tpred->fn = filter_pred_pchar;\n\t\t/* go past the last quote */\n\t\ti++;\n\n\t} else if (isdigit(str[i]) || str[i] == '-') {\n\n\t\t/* Make sure the field is not a string */\n\t\tif (is_string_field(field)) {\n\t\t\tparse_error(pe, FILT_ERR_EXPECT_STRING, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (op == OP_GLOB) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_FIELD_OP, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tif (str[i] == '-')\n\t\t\ti++;\n\n\t\t/* We allow 0xDEADBEEF */\n\t\twhile (isalnum(str[i]))\n\t\t\ti++;\n\n\t\tlen = i - s;\n\t\t/* 0xfeedfacedeadbeef is 18 chars max */\n\t\tif (len >= sizeof(num_buf)) {\n\t\t\tparse_error(pe, FILT_ERR_OPERAND_TOO_LONG, pos + i);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tstrncpy(num_buf, str + s, len);\n\t\tnum_buf[len] = 0;\n\n\t\t/* Make sure it is a value */\n\t\tif (field->is_signed)\n\t\t\tret = kstrtoll(num_buf, 0, &val);\n\t\telse\n\t\t\tret = kstrtoull(num_buf, 0, &val);\n\t\tif (ret) {\n\t\t\tparse_error(pe, FILT_ERR_ILLEGAL_INTVAL, pos + s);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tpred->val = val;\n\n\t\tif (field->filter_type == FILTER_CPU)\n\t\t\tpred->fn = filter_pred_cpu;\n\t\telse {\n\t\t\tpred->fn = select_comparison_fn(pred->op, field->size,\n\t\t\t\t\t\t\tfield->is_signed);\n\t\t\tif (pred->op == OP_NE)\n\t\t\t\tpred->not = 1;\n\t\t}\n\n\t} else {\n\t\tparse_error(pe, FILT_ERR_INVALID_VALUE, pos + i);\n\t\tgoto err_free;\n\t}\n\n\t*pred_ptr = pred;\n\treturn i;\n\nerr_free:\n\tkfree(pred);\n\treturn -EINVAL;\n}\n\nenum {\n\tTOO_MANY_CLOSE\t\t= -1,\n\tTOO_MANY_OPEN\t\t= -2,\n\tMISSING_QUOTE\t\t= -3,\n};\n\n/*\n * Read the filter string once to calculate the number of predicates\n * as well as how deep the parentheses go.\n *\n * Returns:\n *   0 - everything is fine (err is undefined)\n *  -1 - too many ')'\n *  -2 - too many '('\n *  -3 - No matching quote\n */\nstatic int calc_stack(const char *str, int *parens, int *preds, int *err)\n{\n\tbool is_pred = false;\n\tint nr_preds = 0;\n\tint open = 1; /* Count the expression as \"(E)\" */\n\tint last_quote = 0;\n\tint max_open = 1;\n\tint quote = 0;\n\tint i;\n\n\t*err = 0;\n\n\tfor (i = 0; str[i]; i++) {\n\t\tif (isspace(str[i]))\n\t\t\tcontinue;\n\t\tif (quote) {\n\t\t\tif (str[i] == quote)\n\t\t\t       quote = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (str[i]) {\n\t\tcase '\\'':\n\t\tcase '\"':\n\t\t\tquote = str[i];\n\t\t\tlast_quote = i;\n\t\t\tbreak;\n\t\tcase '|':\n\t\tcase '&':\n\t\t\tif (str[i+1] != str[i])\n\t\t\t\tbreak;\n\t\t\tis_pred = false;\n\t\t\tcontinue;\n\t\tcase '(':\n\t\t\tis_pred = false;\n\t\t\topen++;\n\t\t\tif (open > max_open)\n\t\t\t\tmax_open = open;\n\t\t\tcontinue;\n\t\tcase ')':\n\t\t\tis_pred = false;\n\t\t\tif (open == 1) {\n\t\t\t\t*err = i;\n\t\t\t\treturn TOO_MANY_CLOSE;\n\t\t\t}\n\t\t\topen--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!is_pred) {\n\t\t\tnr_preds++;\n\t\t\tis_pred = true;\n\t\t}\n\t}\n\n\tif (quote) {\n\t\t*err = last_quote;\n\t\treturn MISSING_QUOTE;\n\t}\n\n\tif (open != 1) {\n\t\tint level = open;\n\n\t\t/* find the bad open */\n\t\tfor (i--; i; i--) {\n\t\t\tif (quote) {\n\t\t\t\tif (str[i] == quote)\n\t\t\t\t\tquote = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (str[i]) {\n\t\t\tcase '(':\n\t\t\t\tif (level == open) {\n\t\t\t\t\t*err = i;\n\t\t\t\t\treturn TOO_MANY_OPEN;\n\t\t\t\t}\n\t\t\t\tlevel--;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlevel++;\n\t\t\t\tbreak;\n\t\t\tcase '\\'':\n\t\t\tcase '\"':\n\t\t\t\tquote = str[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* First character is the '(' with missing ')' */\n\t\t*err = 0;\n\t\treturn TOO_MANY_OPEN;\n\t}\n\n\t/* Set the size of the required stacks */\n\t*parens = max_open;\n\t*preds = nr_preds;\n\treturn 0;\n}\n\nstatic int process_preds(struct trace_event_call *call,\n\t\t\t const char *filter_string,\n\t\t\t struct event_filter *filter,\n\t\t\t struct filter_parse_error *pe)\n{\n\tstruct prog_entry *prog;\n\tint nr_parens;\n\tint nr_preds;\n\tint index;\n\tint ret;\n\n\tret = calc_stack(filter_string, &nr_parens, &nr_preds, &index);\n\tif (ret < 0) {\n\t\tswitch (ret) {\n\t\tcase MISSING_QUOTE:\n\t\t\tparse_error(pe, FILT_ERR_MISSING_QUOTE, index);\n\t\t\tbreak;\n\t\tcase TOO_MANY_OPEN:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_OPEN, index);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparse_error(pe, FILT_ERR_TOO_MANY_CLOSE, index);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (!nr_preds)\n\t\treturn -EINVAL;\n\n\tprog = predicate_parse(filter_string, nr_parens, nr_preds,\n\t\t\t       parse_pred, call, pe);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\trcu_assign_pointer(filter->prog, prog);\n\treturn 0;\n}\n\nstatic inline void event_set_filtered_flag(struct trace_event_file *file)\n{\n\tunsigned long old_flags = file->flags;\n\n\tfile->flags |= EVENT_FILE_FL_FILTERED;\n\n\tif (old_flags != file->flags)\n\t\ttrace_buffered_event_enable();\n}\n\nstatic inline void event_set_filter(struct trace_event_file *file,\n\t\t\t\t    struct event_filter *filter)\n{\n\trcu_assign_pointer(file->filter, filter);\n}\n\nstatic inline void event_clear_filter(struct trace_event_file *file)\n{\n\tRCU_INIT_POINTER(file->filter, NULL);\n}\n\nstatic inline void\nevent_set_no_set_filter_flag(struct trace_event_file *file)\n{\n\tfile->flags |= EVENT_FILE_FL_NO_SET_FILTER;\n}\n\nstatic inline void\nevent_clear_no_set_filter_flag(struct trace_event_file *file)\n{\n\tfile->flags &= ~EVENT_FILE_FL_NO_SET_FILTER;\n}\n\nstatic inline bool\nevent_no_set_filter_flag(struct trace_event_file *file)\n{\n\tif (file->flags & EVENT_FILE_FL_NO_SET_FILTER)\n\t\treturn true;\n\n\treturn false;\n}\n\nstruct filter_list {\n\tstruct list_head\tlist;\n\tstruct event_filter\t*filter;\n};\n\nstatic int process_system_preds(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tstruct filter_parse_error *pe,\n\t\t\t\tchar *filter_string)\n{\n\tstruct trace_event_file *file;\n\tstruct filter_list *filter_item;\n\tstruct event_filter *filter = NULL;\n\tstruct filter_list *tmp;\n\tLIST_HEAD(filter_list);\n\tbool fail = true;\n\tint err;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tif (file->system != dir)\n\t\t\tcontinue;\n\n\t\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\t\tif (!filter)\n\t\t\tgoto fail_mem;\n\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\tgoto fail_mem;\n\n\t\terr = process_preds(file->event_call, filter_string, filter, pe);\n\t\tif (err) {\n\t\t\tfilter_disable(file);\n\t\t\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\t\t\tappend_filter_err(tr, pe, filter);\n\t\t} else\n\t\t\tevent_set_filtered_flag(file);\n\n\n\t\tfilter_item = kzalloc(sizeof(*filter_item), GFP_KERNEL);\n\t\tif (!filter_item)\n\t\t\tgoto fail_mem;\n\n\t\tlist_add_tail(&filter_item->list, &filter_list);\n\t\t/*\n\t\t * Regardless of if this returned an error, we still\n\t\t * replace the filter for the call.\n\t\t */\n\t\tfilter_item->filter = event_filter(file);\n\t\tevent_set_filter(file, filter);\n\t\tfilter = NULL;\n\n\t\tfail = false;\n\t}\n\n\tif (fail)\n\t\tgoto fail;\n\n\t/*\n\t * The calls can still be using the old filters.\n\t * Do a synchronize_rcu() and to ensure all calls are\n\t * done with them before we free them.\n\t */\n\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn 0;\n fail:\n\t/* No call succeeded */\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\tparse_error(pe, FILT_ERR_BAD_SUBSYS_FILTER, 0);\n\treturn -EINVAL;\n fail_mem:\n\tkfree(filter);\n\t/* If any call succeeded, we still need to sync */\n\tif (!fail)\n\t\ttracepoint_synchronize_unregister();\n\tlist_for_each_entry_safe(filter_item, tmp, &filter_list, list) {\n\t\t__free_filter(filter_item->filter);\n\t\tlist_del(&filter_item->list);\n\t\tkfree(filter_item);\n\t}\n\treturn -ENOMEM;\n}\n\nstatic int create_filter_start(char *filter_string, bool set_str,\n\t\t\t       struct filter_parse_error **pse,\n\t\t\t       struct event_filter **filterp)\n{\n\tstruct event_filter *filter;\n\tstruct filter_parse_error *pe = NULL;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(*pse || *filterp))\n\t\treturn -EINVAL;\n\n\tfilter = kzalloc(sizeof(*filter), GFP_KERNEL);\n\tif (filter && set_str) {\n\t\tfilter->filter_string = kstrdup(filter_string, GFP_KERNEL);\n\t\tif (!filter->filter_string)\n\t\t\terr = -ENOMEM;\n\t}\n\n\tpe = kzalloc(sizeof(*pe), GFP_KERNEL);\n\n\tif (!filter || !pe || err) {\n\t\tkfree(pe);\n\t\t__free_filter(filter);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* we're committed to creating a new filter */\n\t*filterp = filter;\n\t*pse = pe;\n\n\treturn 0;\n}\n\nstatic void create_filter_finish(struct filter_parse_error *pe)\n{\n\tkfree(pe);\n}\n\n/**\n * create_filter - create a filter for a trace_event_call\n * @call: trace_event_call to create a filter for\n * @filter_str: filter string\n * @set_str: remember @filter_str and enable detailed error in filter\n * @filterp: out param for created filter (always updated on return)\n *           Must be a pointer that references a NULL pointer.\n *\n * Creates a filter for @call with @filter_str.  If @set_str is %true,\n * @filter_str is copied and recorded in the new filter.\n *\n * On success, returns 0 and *@filterp points to the new filter.  On\n * failure, returns -errno and *@filterp may point to %NULL or to a new\n * filter.  In the latter case, the returned filter contains error\n * information if @set_str is %true and the caller is responsible for\n * freeing it.\n */\nstatic int create_filter(struct trace_array *tr,\n\t\t\t struct trace_event_call *call,\n\t\t\t char *filter_string, bool set_str,\n\t\t\t struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\t/* filterp must point to NULL */\n\tif (WARN_ON(*filterp))\n\t\t*filterp = NULL;\n\n\terr = create_filter_start(filter_string, set_str, &pe, filterp);\n\tif (err)\n\t\treturn err;\n\n\terr = process_preds(call, filter_string, *filterp, pe);\n\tif (err && set_str)\n\t\tappend_filter_err(tr, pe, *filterp);\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}\n\nint create_event_filter(struct trace_array *tr,\n\t\t\tstruct trace_event_call *call,\n\t\t\tchar *filter_str, bool set_str,\n\t\t\tstruct event_filter **filterp)\n{\n\treturn create_filter(tr, call, filter_str, set_str, filterp);\n}\n\n/**\n * create_system_filter - create a filter for an event_subsystem\n * @system: event_subsystem to create a filter for\n * @filter_str: filter string\n * @filterp: out param for created filter (always updated on return)\n *\n * Identical to create_filter() except that it creates a subsystem filter\n * and always remembers @filter_str.\n */\nstatic int create_system_filter(struct trace_subsystem_dir *dir,\n\t\t\t\tstruct trace_array *tr,\n\t\t\t\tchar *filter_str, struct event_filter **filterp)\n{\n\tstruct filter_parse_error *pe = NULL;\n\tint err;\n\n\terr = create_filter_start(filter_str, true, &pe, filterp);\n\tif (!err) {\n\t\terr = process_system_preds(dir, tr, pe, filter_str);\n\t\tif (!err) {\n\t\t\t/* System filters just show a default message */\n\t\t\tkfree((*filterp)->filter_string);\n\t\t\t(*filterp)->filter_string = NULL;\n\t\t} else {\n\t\t\tappend_filter_err(tr, pe, *filterp);\n\t\t}\n\t}\n\tcreate_filter_finish(pe);\n\n\treturn err;\n}\n\n/* caller must hold event_mutex */\nint apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\n\t\tif (!filter)\n\t\t\treturn 0;\n\n\t\tevent_clear_filter(file);\n\n\t\t/* Make sure the filter is not being used */\n\t\ttracepoint_synchronize_unregister();\n\t\t__free_filter(filter);\n\n\t\treturn 0;\n\t}\n\n\terr = create_filter(file->tr, call, filter_string, true, &filter);\n\n\t/*\n\t * Always swap the call filter with the new filter\n\t * even if there was an error. If there was an error\n\t * in the filter, we disable the filter and show the error\n\t * string\n\t */\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\n\t\tevent_set_filter(file, filter);\n\n\t\tif (tmp) {\n\t\t\t/* Make sure the call is done with the filter */\n\t\t\ttracepoint_synchronize_unregister();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint apply_subsystem_event_filter(struct trace_subsystem_dir *dir,\n\t\t\t\t char *filter_string)\n{\n\tstruct event_subsystem *system = dir->subsystem;\n\tstruct trace_array *tr = dir->tr;\n\tstruct event_filter *filter = NULL;\n\tint err = 0;\n\n\tmutex_lock(&event_mutex);\n\n\t/* Make sure the system still has events */\n\tif (!dir->nr_events) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_free_subsystem_preds(dir, tr);\n\t\tremove_filter_string(system->filter);\n\t\tfilter = system->filter;\n\t\tsystem->filter = NULL;\n\t\t/* Ensure all filters are no longer used */\n\t\ttracepoint_synchronize_unregister();\n\t\tfilter_free_subsystem_filters(dir, tr);\n\t\t__free_filter(filter);\n\t\tgoto out_unlock;\n\t}\n\n\terr = create_system_filter(dir, tr, filter_string, &filter);\n\tif (filter) {\n\t\t/*\n\t\t * No event actually uses the system filter\n\t\t * we can free it without synchronize_rcu().\n\t\t */\n\t\t__free_filter(system->filter);\n\t\tsystem->filter = filter;\n\t}\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}\n\n#ifdef CONFIG_PERF_EVENTS\n\nvoid ftrace_profile_free_filter(struct perf_event *event)\n{\n\tstruct event_filter *filter = event->filter;\n\n\tevent->filter = NULL;\n\t__free_filter(filter);\n}\n\nstruct function_filter_data {\n\tstruct ftrace_ops *ops;\n\tint first_filter;\n\tint first_notrace;\n};\n\n#ifdef CONFIG_FUNCTION_TRACER\nstatic char **\nftrace_function_filter_re(char *buf, int len, int *count)\n{\n\tchar *str, **re;\n\n\tstr = kstrndup(buf, len, GFP_KERNEL);\n\tif (!str)\n\t\treturn NULL;\n\n\t/*\n\t * The argv_split function takes white space\n\t * as a separator, so convert ',' into spaces.\n\t */\n\tstrreplace(str, ',', ' ');\n\n\tre = argv_split(GFP_KERNEL, str, count);\n\tkfree(str);\n\treturn re;\n}\n\nstatic int ftrace_function_set_regexp(struct ftrace_ops *ops, int filter,\n\t\t\t\t      int reset, char *re, int len)\n{\n\tint ret;\n\n\tif (filter)\n\t\tret = ftrace_set_filter(ops, re, len, reset);\n\telse\n\t\tret = ftrace_set_notrace(ops, re, len, reset);\n\n\treturn ret;\n}\n\nstatic int __ftrace_function_set_filter(int filter, char *buf, int len,\n\t\t\t\t\tstruct function_filter_data *data)\n{\n\tint i, re_cnt, ret = -EINVAL;\n\tint *reset;\n\tchar **re;\n\n\treset = filter ? &data->first_filter : &data->first_notrace;\n\n\t/*\n\t * The 'ip' field could have multiple filters set, separated\n\t * either by space or comma. We first cut the filter and apply\n\t * all pieces separatelly.\n\t */\n\tre = ftrace_function_filter_re(buf, len, &re_cnt);\n\tif (!re)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->ops, filter, *reset,\n\t\t\t\t\t\t re[i], strlen(re[i]));\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (*reset)\n\t\t\t*reset = 0;\n\t}\n\n\targv_free(re);\n\treturn ret;\n}\n\nstatic int ftrace_function_check_pred(struct filter_pred *pred)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\t/*\n\t * Check the predicate for function trace, verify:\n\t *  - only '==' and '!=' is used\n\t *  - the 'ip' field is used\n\t */\n\tif ((pred->op != OP_EQ) && (pred->op != OP_NE))\n\t\treturn -EINVAL;\n\n\tif (strcmp(field->name, \"ip\"))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ftrace_function_set_filter_pred(struct filter_pred *pred,\n\t\t\t\t\t   struct function_filter_data *data)\n{\n\tint ret;\n\n\t/* Checking the node is valid for function trace. */\n\tret = ftrace_function_check_pred(pred);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __ftrace_function_set_filter(pred->op == OP_EQ,\n\t\t\t\t\t    pred->regex.pattern,\n\t\t\t\t\t    pred->regex.len,\n\t\t\t\t\t    data);\n}\n\nstatic bool is_or(struct prog_entry *prog, int i)\n{\n\tint target;\n\n\t/*\n\t * Only \"||\" is allowed for function events, thus,\n\t * all true branches should jump to true, and any\n\t * false branch should jump to false.\n\t */\n\ttarget = prog[i].target + 1;\n\t/* True and false have NULL preds (all prog entries should jump to one */\n\tif (prog[target].pred)\n\t\treturn false;\n\n\t/* prog[target].target is 1 for TRUE, 0 for FALSE */\n\treturn prog[i].when_to_branch == prog[target].target;\n}\n\nstatic int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tstruct function_filter_data data = {\n\t\t.first_filter  = 1,\n\t\t.first_notrace = 1,\n\t\t.ops           = &event->ftrace_ops,\n\t};\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\n\t\tif (!is_or(prog, i))\n\t\t\treturn -EINVAL;\n\n\t\tif (ftrace_function_set_filter_pred(pred, &data) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n#else\nstatic int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\treturn -ENODEV;\n}\n#endif /* CONFIG_FUNCTION_TRACER */\n\nint ftrace_profile_set_filter(struct perf_event *event, int event_id,\n\t\t\t      char *filter_str)\n{\n\tint err;\n\tstruct event_filter *filter = NULL;\n\tstruct trace_event_call *call;\n\n\tmutex_lock(&event_mutex);\n\n\tcall = event->tp_event;\n\n\terr = -EINVAL;\n\tif (!call)\n\t\tgoto out_unlock;\n\n\terr = -EEXIST;\n\tif (event->filter)\n\t\tgoto out_unlock;\n\n\terr = create_filter(NULL, call, filter_str, false, &filter);\n\tif (err)\n\t\tgoto free_filter;\n\n\tif (ftrace_event_is_function(call))\n\t\terr = ftrace_function_set_filter(event, filter);\n\telse\n\t\tevent->filter = filter;\n\nfree_filter:\n\tif (err || ftrace_event_is_function(call))\n\t\t__free_filter(filter);\n\nout_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn err;\n}\n\n#endif /* CONFIG_PERF_EVENTS */\n\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n\n#define CREATE_TRACE_POINTS\n#include \"trace_events_filter_test.h\"\n\n#define DATA_REC(m, va, vb, vc, vd, ve, vf, vg, vh, nvisit) \\\n{ \\\n\t.filter = FILTER, \\\n\t.rec    = { .a = va, .b = vb, .c = vc, .d = vd, \\\n\t\t    .e = ve, .f = vf, .g = vg, .h = vh }, \\\n\t.match  = m, \\\n\t.not_visited = nvisit, \\\n}\n#define YES 1\n#define NO  0\n\nstatic struct test_filter_data_t {\n\tchar *filter;\n\tstruct trace_event_raw_ftrace_test_filter rec;\n\tint match;\n\tchar *not_visited;\n} test_filter_data[] = {\n#define FILTER \"a == 1 && b == 1 && c == 1 && d == 1 && \" \\\n\t       \"e == 1 && f == 1 && g == 1 && h == 1\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 1, 1, \"\"),\n\tDATA_REC(NO,  0, 1, 1, 1, 1, 1, 1, 1, \"bcdefgh\"),\n\tDATA_REC(NO,  1, 1, 1, 1, 1, 1, 1, 0, \"\"),\n#undef FILTER\n#define FILTER \"a == 1 || b == 1 || c == 1 || d == 1 || \" \\\n\t       \"e == 1 || f == 1 || g == 1 || h == 1\"\n\tDATA_REC(NO,  0, 0, 0, 0, 0, 0, 0, 0, \"\"),\n\tDATA_REC(YES, 0, 0, 0, 0, 0, 0, 0, 1, \"\"),\n\tDATA_REC(YES, 1, 0, 0, 0, 0, 0, 0, 0, \"bcdefgh\"),\n#undef FILTER\n#define FILTER \"(a == 1 || b == 1) && (c == 1 || d == 1) && \" \\\n\t       \"(e == 1 || f == 1) && (g == 1 || h == 1)\"\n\tDATA_REC(NO,  0, 0, 1, 1, 1, 1, 1, 1, \"dfh\"),\n\tDATA_REC(YES, 0, 1, 0, 1, 0, 1, 0, 1, \"\"),\n\tDATA_REC(YES, 1, 0, 1, 0, 0, 1, 0, 1, \"bd\"),\n\tDATA_REC(NO,  1, 0, 1, 0, 0, 1, 0, 0, \"bd\"),\n#undef FILTER\n#define FILTER \"(a == 1 && b == 1) || (c == 1 && d == 1) || \" \\\n\t       \"(e == 1 && f == 1) || (g == 1 && h == 1)\"\n\tDATA_REC(YES, 1, 0, 1, 1, 1, 1, 1, 1, \"efgh\"),\n\tDATA_REC(YES, 0, 0, 0, 0, 0, 0, 1, 1, \"\"),\n\tDATA_REC(NO,  0, 0, 0, 0, 0, 0, 0, 1, \"\"),\n#undef FILTER\n#define FILTER \"(a == 1 && b == 1) && (c == 1 && d == 1) && \" \\\n\t       \"(e == 1 && f == 1) || (g == 1 && h == 1)\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 0, 0, \"gh\"),\n\tDATA_REC(NO,  0, 0, 0, 0, 0, 0, 0, 1, \"\"),\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 0, 1, 1, \"\"),\n#undef FILTER\n#define FILTER \"((a == 1 || b == 1) || (c == 1 || d == 1) || \" \\\n\t       \"(e == 1 || f == 1)) && (g == 1 || h == 1)\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 0, 1, \"bcdef\"),\n\tDATA_REC(NO,  0, 0, 0, 0, 0, 0, 0, 0, \"\"),\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 0, 1, 1, \"h\"),\n#undef FILTER\n#define FILTER \"((((((((a == 1) && (b == 1)) || (c == 1)) && (d == 1)) || \" \\\n\t       \"(e == 1)) && (f == 1)) || (g == 1)) && (h == 1))\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 1, 1, \"ceg\"),\n\tDATA_REC(NO,  0, 1, 0, 1, 0, 1, 0, 1, \"\"),\n\tDATA_REC(NO,  1, 0, 1, 0, 1, 0, 1, 0, \"\"),\n#undef FILTER\n#define FILTER \"((((((((a == 1) || (b == 1)) && (c == 1)) || (d == 1)) && \" \\\n\t       \"(e == 1)) || (f == 1)) && (g == 1)) || (h == 1))\"\n\tDATA_REC(YES, 1, 1, 1, 1, 1, 1, 1, 1, \"bdfh\"),\n\tDATA_REC(YES, 0, 1, 0, 1, 0, 1, 0, 1, \"\"),\n\tDATA_REC(YES, 1, 0, 1, 0, 1, 0, 1, 0, \"bdfh\"),\n};\n\n#undef DATA_REC\n#undef FILTER\n#undef YES\n#undef NO\n\n#define DATA_CNT ARRAY_SIZE(test_filter_data)\n\nstatic int test_pred_visited;\n\nstatic int test_pred_visited_fn(struct filter_pred *pred, void *event)\n{\n\tstruct ftrace_event_field *field = pred->field;\n\n\ttest_pred_visited = 1;\n\tprintk(KERN_INFO \"\\npred visited %s\\n\", field->name);\n\treturn 1;\n}\n\nstatic void update_pred_fn(struct event_filter *filter, char *fields)\n{\n\tstruct prog_entry *prog = rcu_dereference_protected(filter->prog,\n\t\t\t\t\t\tlockdep_is_held(&event_mutex));\n\tint i;\n\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tstruct ftrace_event_field *field = pred->field;\n\n\t\tWARN_ON_ONCE(!pred->fn);\n\n\t\tif (!field) {\n\t\t\tWARN_ONCE(1, \"all leafs should have field defined %d\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strchr(fields, *field->name))\n\t\t\tcontinue;\n\n\t\tpred->fn = test_pred_visited_fn;\n\t}\n}\n\nstatic __init int ftrace_test_event_filter(void)\n{\n\tint i;\n\n\tprintk(KERN_INFO \"Testing ftrace filter: \");\n\n\tfor (i = 0; i < DATA_CNT; i++) {\n\t\tstruct event_filter *filter = NULL;\n\t\tstruct test_filter_data_t *d = &test_filter_data[i];\n\t\tint err;\n\n\t\terr = create_filter(NULL, &event_ftrace_test_filter,\n\t\t\t\t    d->filter, false, &filter);\n\t\tif (err) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to get filter for '%s', err %d\\n\",\n\t\t\t       d->filter, err);\n\t\t\t__free_filter(filter);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Needed to dereference filter->prog */\n\t\tmutex_lock(&event_mutex);\n\t\t/*\n\t\t * The preemption disabling is not really needed for self\n\t\t * tests, but the rcu dereference will complain without it.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (*d->not_visited)\n\t\t\tupdate_pred_fn(filter, d->not_visited);\n\n\t\ttest_pred_visited = 0;\n\t\terr = filter_match_preds(filter, &d->rec);\n\t\tpreempt_enable();\n\n\t\tmutex_unlock(&event_mutex);\n\n\t\t__free_filter(filter);\n\n\t\tif (test_pred_visited) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed, unwanted pred visited for filter %s\\n\",\n\t\t\t       d->filter);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err != d->match) {\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"Failed to match filter '%s', expected %d\\n\",\n\t\t\t       d->filter, d->match);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == DATA_CNT)\n\t\tprintk(KERN_CONT \"OK\\n\");\n\n\treturn 0;\n}\n\nlate_initcall(ftrace_test_event_filter);\n\n#endif /* CONFIG_FTRACE_STARTUP_TEST */\n"], "filenames": ["kernel/trace/trace_events_filter.c"], "buggy_code_start_loc": [455], "buggy_code_end_loc": [457], "fixing_code_start_loc": [455], "fixing_code_end_loc": [459], "type": "CWE-401", "message": "A memory leak in the predicate_parse() function in kernel/trace/trace_events_filter.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption), aka CID-96c5c6e6a5b6.", "other": {"cve": {"id": "CVE-2019-19072", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:13.123", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory leak in the predicate_parse() function in kernel/trace/trace_events_filter.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption), aka CID-96c5c6e6a5b6."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n predicate_parse() en el archivo kernel/trace/trace_events_filter.c en el kernel de Linux versiones hasta la versi\u00f3n 5.3.11, permite a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria), tambi\u00e9n se conoce como CID-96c5c6e6a5b6."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.3.11", "matchCriteriaId": "EB2904AC-AD7A-498D-8619-CBB421E9165D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/96c5c6e6a5b6db592acae039fed54b5c8844cd35", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/O3PSDE6PTOTVBK2YTKB2TFQP2SUBVSNF/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PY7LJMSPAGRIKABJPDKQDTXYW3L5RX2T/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20191205-0001/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4225-2/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4226-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/96c5c6e6a5b6db592acae039fed54b5c8844cd35"}}