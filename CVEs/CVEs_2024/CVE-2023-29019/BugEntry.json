{"buggy_code": ["/// <reference types=\"@fastify/secure-session\" />\nimport { FastifyRequest } from 'fastify'\nimport { SerializeFunction } from '../Authenticator'\n\n/** Class for storing passport data in the session using `@fastify/secure-session` or `@fastify/session` */\nexport class SecureSessionManager {\n  key: string\n  serializeUser: SerializeFunction\n\n  constructor(serializeUser: SerializeFunction)\n  constructor(options: { key?: string }, serializeUser: SerializeFunction)\n  constructor(options: SerializeFunction | { key?: string }, serializeUser?: SerializeFunction) {\n    if (typeof options === 'function') {\n      this.serializeUser = options\n      this.key = 'passport'\n    } else if (typeof serializeUser === 'function') {\n      this.serializeUser = serializeUser\n      this.key =\n        (options && typeof options === 'object' && typeof options.key === 'string' && options.key) || 'passport'\n    } else {\n      throw new Error('SecureSessionManager#constructor must have a valid serializeUser-function passed as a parameter')\n    }\n  }\n\n  async logIn(request: FastifyRequest, user: any) {\n    const object = await this.serializeUser(user, request)\n    request.session.set(this.key, object)\n  }\n\n  async logOut(request: FastifyRequest) {\n    request.session.set(this.key, undefined)\n  }\n\n  getUserFromSession(request: FastifyRequest) {\n    return request.session.get(this.key)\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-empty-function */\nimport { generateTestUser, getConfiguredTestServer, TestBrowserSession } from './helpers'\n\nconst { server, fastifyPassport } = getConfiguredTestServer()\n\nserver.get(\n  '/protected',\n  { preValidation: fastifyPassport.authenticate('test', { authInfo: false }) },\n  async () => 'hello!'\n)\nserver.get('/my-id', { preValidation: fastifyPassport.authenticate('test', { authInfo: false }) }, async (request) =>\n  String((request.user as any).id)\n)\nserver.post(\n  '/login',\n  { preValidation: fastifyPassport.authenticate('test', { authInfo: false }) },\n  async () => 'success'\n)\n\nserver.post('/force-login', async (request, reply) => {\n  await request.logIn(generateTestUser())\n  void reply.send('logged in')\n})\n\nserver.post(\n  '/logout',\n  { preValidation: fastifyPassport.authenticate('test', { authInfo: false }) },\n  async (request, reply) => {\n    await request.logout()\n    void reply.send('logged out')\n  }\n)\n\nconst suite = (sessionPluginName) => {\n  describe(`${sessionPluginName} tests`, () => {\n    describe('session isolation', () => {\n      let userA, userB, userC\n\n      beforeEach(() => {\n        userA = new TestBrowserSession(server)\n        userB = new TestBrowserSession(server)\n        userC = new TestBrowserSession(server)\n      })\n      test(`should return 401 Unauthorized if not logged in`, async () => {\n        await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(401)\n          })\n        )\n\n        await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(401)\n          })\n        )\n      })\n\n      test(`logging in one user shouldn't log in the others`, async () => {\n        await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(401)\n          })\n        )\n\n        let response = await userA.inject({\n          method: 'POST',\n          url: '/login',\n          payload: { login: 'test', password: 'test' },\n        })\n        expect(response.statusCode).toEqual(200)\n        expect(response.body).toEqual('success')\n\n        response = await userA.inject({ method: 'GET', url: '/protected' })\n        expect(response.statusCode).toEqual(200)\n        expect(response.body).toEqual('hello!')\n\n        await Promise.all(\n          [userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(401)\n          })\n        )\n\n        response = await userA.inject({ method: 'GET', url: '/protected' })\n        expect(response.statusCode).toEqual(200)\n        expect(response.body).toEqual('hello!')\n      })\n\n      test(`logging in each user should keep their sessions independent`, async () => {\n        await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            let response = await user.inject({\n              method: 'POST',\n              url: '/login',\n              payload: { login: 'test', password: 'test' },\n            })\n            expect(response.statusCode).toEqual(200)\n            expect(response.body).toEqual('success')\n\n            response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(200)\n            expect(response.body).toEqual('hello!')\n          })\n        )\n\n        const ids = await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/my-id' })\n            expect(response.statusCode).toEqual(200)\n            return response.body\n          })\n        )\n\n        // expect each returned ID to be unique\n        expect(Array.from(new Set(ids)).sort()).toEqual(ids.sort())\n      })\n\n      test(`logging out one user shouldn't log out the others`, async () => {\n        await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            let response = await user.inject({\n              method: 'POST',\n              url: '/login',\n              payload: { login: 'test', password: 'test' },\n            })\n            expect(response.statusCode).toEqual(200)\n            expect(response.body).toEqual('success')\n\n            response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(200)\n            expect(response.body).toEqual('hello!')\n          })\n        )\n\n        let response = await userB.inject({\n          url: '/logout',\n          method: 'POST',\n        })\n        expect(response.statusCode).toEqual(200)\n\n        response = await userB.inject({\n          url: '/protected',\n          method: 'GET',\n        })\n        expect(response.statusCode).toEqual(401)\n\n        await Promise.all(\n          [userA, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(200)\n            expect(response.body).toEqual('hello!')\n          })\n        )\n      })\n\n      test(`force logging in users shouldn't change the login state of the others`, async () => {\n        await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'POST', url: '/force-login' })\n            expect(response.statusCode).toEqual(200)\n          })\n        )\n\n        const ids = await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/my-id' })\n            expect(response.statusCode).toEqual(200)\n            return response.body\n          })\n        )\n\n        // expect each returned ID to be unique\n        expect(Array.from(new Set(ids)).sort()).toEqual(ids.sort())\n      })\n    })\n  })\n}\n\nsuite('@fastify/session')\nsuite('@fastify/secure-session')\n"], "fixing_code": ["/// <reference types=\"@fastify/secure-session\" />\nimport { FastifyRequest } from 'fastify'\nimport { SerializeFunction } from '../Authenticator'\n\n/** Class for storing passport data in the session using `@fastify/secure-session` or `@fastify/session` */\nexport class SecureSessionManager {\n  key: string\n  serializeUser: SerializeFunction\n\n  constructor(serializeUser: SerializeFunction)\n  constructor(options: { key?: string }, serializeUser: SerializeFunction)\n  constructor(options: SerializeFunction | { key?: string }, serializeUser?: SerializeFunction) {\n    if (typeof options === 'function') {\n      this.serializeUser = options\n      this.key = 'passport'\n    } else if (typeof serializeUser === 'function') {\n      this.serializeUser = serializeUser\n      this.key =\n        (options && typeof options === 'object' && typeof options.key === 'string' && options.key) || 'passport'\n    } else {\n      throw new Error('SecureSessionManager#constructor must have a valid serializeUser-function passed as a parameter')\n    }\n  }\n\n  async logIn(request: FastifyRequest, user: any) {\n    const object = await this.serializeUser(user, request)\n    // Handle sessions using @fastify/session\n    if (request.session.regenerate) {\n      // regenerate session to guard against session fixation\n      await request.session.regenerate()\n    }\n    request.session.set(this.key, object)\n  }\n\n  async logOut(request: FastifyRequest) {\n    request.session.set(this.key, undefined)\n    if (request.session.regenerate) {\n      await request.session.regenerate()\n    }\n  }\n\n  getUserFromSession(request: FastifyRequest) {\n    return request.session.get(this.key)\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-empty-function */\nimport { generateTestUser, getConfiguredTestServer, TestBrowserSession } from './helpers'\n\nfunction createServer() {\n  const { server, fastifyPassport } = getConfiguredTestServer()\n\n  server.get(\n    '/protected',\n    { preValidation: fastifyPassport.authenticate('test', { authInfo: false }) },\n    async () => 'hello!'\n  )\n  server.get('/my-id', { preValidation: fastifyPassport.authenticate('test', { authInfo: false }) }, async (request) =>\n    String((request.user as any).id)\n  )\n  server.post(\n    '/login',\n    { preValidation: fastifyPassport.authenticate('test', { authInfo: false }) },\n    async () => 'success'\n  )\n\n  server.post('/force-login', async (request, reply) => {\n    await request.logIn(generateTestUser())\n    void reply.send('logged in')\n  })\n\n  server.post(\n    '/logout',\n    { preValidation: fastifyPassport.authenticate('test', { authInfo: false }) },\n    async (request, reply) => {\n      await request.logout()\n      void reply.send('logged out')\n    }\n  )\n  return server\n}\n\nconst suite = (sessionPluginName) => {\n  process.env.SESSION_PLUGIN = sessionPluginName\n  const server = createServer()\n  describe(`${sessionPluginName} tests`, () => {\n    const sessionOnlyTest = sessionPluginName === '@fastify/session' ? test : test.skip\n    describe('session isolation', () => {\n      let userA, userB, userC\n\n      beforeEach(() => {\n        userA = new TestBrowserSession(server)\n        userB = new TestBrowserSession(server)\n        userC = new TestBrowserSession(server)\n      })\n      test(`should return 401 Unauthorized if not logged in`, async () => {\n        await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(401)\n          })\n        )\n\n        await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(401)\n          })\n        )\n      })\n\n      test(`logging in one user shouldn't log in the others`, async () => {\n        await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(401)\n          })\n        )\n\n        let response = await userA.inject({\n          method: 'POST',\n          url: '/login',\n          payload: { login: 'test', password: 'test' },\n        })\n        expect(response.statusCode).toEqual(200)\n        expect(response.body).toEqual('success')\n\n        response = await userA.inject({ method: 'GET', url: '/protected' })\n        expect(response.statusCode).toEqual(200)\n        expect(response.body).toEqual('hello!')\n\n        await Promise.all(\n          [userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(401)\n          })\n        )\n\n        response = await userA.inject({ method: 'GET', url: '/protected' })\n        expect(response.statusCode).toEqual(200)\n        expect(response.body).toEqual('hello!')\n      })\n\n      test(`logging in each user should keep their sessions independent`, async () => {\n        await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            let response = await user.inject({\n              method: 'POST',\n              url: '/login',\n              payload: { login: 'test', password: 'test' },\n            })\n            expect(response.statusCode).toEqual(200)\n            expect(response.body).toEqual('success')\n\n            response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(200)\n            expect(response.body).toEqual('hello!')\n          })\n        )\n\n        const ids = await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/my-id' })\n            expect(response.statusCode).toEqual(200)\n            return response.body\n          })\n        )\n\n        // expect each returned ID to be unique\n        expect(Array.from(new Set(ids)).sort()).toEqual(ids.sort())\n      })\n\n      test(`logging out one user shouldn't log out the others`, async () => {\n        await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            let response = await user.inject({\n              method: 'POST',\n              url: '/login',\n              payload: { login: 'test', password: 'test' },\n            })\n            expect(response.statusCode).toEqual(200)\n            expect(response.body).toEqual('success')\n\n            response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(200)\n            expect(response.body).toEqual('hello!')\n          })\n        )\n\n        let response = await userB.inject({\n          url: '/logout',\n          method: 'POST',\n        })\n        expect(response.statusCode).toEqual(200)\n\n        response = await userB.inject({\n          url: '/protected',\n          method: 'GET',\n        })\n        expect(response.statusCode).toEqual(401)\n\n        await Promise.all(\n          [userA, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/protected' })\n            expect(response.statusCode).toEqual(200)\n            expect(response.body).toEqual('hello!')\n          })\n        )\n      })\n\n      test(`force logging in users shouldn't change the login state of the others`, async () => {\n        await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'POST', url: '/force-login' })\n            expect(response.statusCode).toEqual(200)\n          })\n        )\n\n        const ids = await Promise.all(\n          [userA, userB, userC].map(async (user) => {\n            const response = await user.inject({ method: 'GET', url: '/my-id' })\n            expect(response.statusCode).toEqual(200)\n            return response.body\n          })\n        )\n\n        // expect each returned ID to be unique\n        expect(Array.from(new Set(ids)).sort()).toEqual(ids.sort())\n      })\n\n      sessionOnlyTest('should regenerate session on login', async () => {\n        expect(userA.cookies['sessionId']).toBeUndefined()\n        await userA.inject({ method: 'GET', url: '/protected' })\n        expect(userA.cookies['sessionId']).not.toBeUndefined()\n        const prevSessionId = userA.cookies.sessionId\n        await userA.inject({\n          method: 'POST',\n          url: '/login',\n          payload: { login: 'test', password: 'test' },\n        })\n        expect(userA.cookies.sessionId).not.toBe(prevSessionId)\n      })\n    })\n  })\n  delete process.env.SESSION_PLUGIN\n}\n\nsuite('@fastify/session')\nsuite('@fastify/secure-session')\n"], "filenames": ["src/session-managers/SecureSessionManager.ts", "test/session-isolation.test.ts"], "buggy_code_start_loc": [26, 4], "buggy_code_end_loc": [31, 179], "fixing_code_start_loc": [27, 4], "fixing_code_end_loc": [40, 200], "type": "CWE-384", "message": "@fastify/passport is a port of passport authentication library for the Fastify ecosystem. Applications using `@fastify/passport` in affected versions for user authentication, in combination with `@fastify/session` as the underlying session management mechanism, are vulnerable to session fixation attacks from network and same-site attackers. fastify applications rely on the `@fastify/passport` library for user authentication. The login and user validation are performed by the `authenticate` function. When executing this function, the `sessionId` is preserved between the pre-login and the authenticated session. Network and same-site attackers can hijack the victim's session by tossing a valid `sessionId` cookie in the victim's browser and waiting for the victim to log in on the website. As a solution, newer versions of `@fastify/passport` regenerate `sessionId` upon login, preventing the attacker-controlled pre-session cookie from being upgraded to an authenticated session. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n", "other": {"cve": {"id": "CVE-2023-29019", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-21T23:15:20.197", "lastModified": "2023-05-04T14:43:34.297", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "@fastify/passport is a port of passport authentication library for the Fastify ecosystem. Applications using `@fastify/passport` in affected versions for user authentication, in combination with `@fastify/session` as the underlying session management mechanism, are vulnerable to session fixation attacks from network and same-site attackers. fastify applications rely on the `@fastify/passport` library for user authentication. The login and user validation are performed by the `authenticate` function. When executing this function, the `sessionId` is preserved between the pre-login and the authenticated session. Network and same-site attackers can hijack the victim's session by tossing a valid `sessionId` cookie in the victim's browser and waiting for the victim to log in on the website. As a solution, newer versions of `@fastify/passport` regenerate `sessionId` upon login, preventing the attacker-controlled pre-session cookie from being upgraded to an authenticated session. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-384"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-384"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fastify:passport:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "1.1.0", "matchCriteriaId": "3F071BA9-FBA0-4860-9B99-9D48230422D2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:fastify:passport:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.3.0", "matchCriteriaId": "341AD078-D84A-45B6-876F-7FA286EECAAA"}]}]}], "references": [{"url": "https://github.com/fastify/fastify-passport/commit/43c82c321db58ea3e375dd475de60befbfcf2a11", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/fastify/fastify-passport/security/advisories/GHSA-4m3m-ppvx-xgw9", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://owasp.org/www-community/attacks/Session_fixation", "source": "security-advisories@github.com", "tags": ["Technical Description"]}]}, "github_commit_url": "https://github.com/fastify/fastify-passport/commit/43c82c321db58ea3e375dd475de60befbfcf2a11"}}