{"buggy_code": ["#\n#\n#            Nim's Runtime Library\n#        (c) Copyright 2012 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n## This module implements a generator of HTML/Latex from\n## `reStructuredText`:idx: (see http://docutils.sourceforge.net/rst.html for\n## information on this markup syntax) and is used by the compiler's `docgen\n## tools <docgen.html>`_.\n##\n## You can generate HTML output through the convenience proc ``rstToHtml``,\n## which provided an input string with rst markup returns a string with the\n## generated HTML. The final output is meant to be embedded inside a full\n## document you provide yourself, so it won't contain the usual ``<header>`` or\n## ``<body>`` parts.\n##\n## You can also create a ``RstGenerator`` structure and populate it with the\n## other lower level methods to finally build complete documents. This requires\n## many options and tweaking, but you are not limited to snippets and can\n## generate `LaTeX documents <https://en.wikipedia.org/wiki/LaTeX>`_ too.\n##\n## `Docutils configuration files`_ are not supported. Instead HTML generation\n## can be tweaked by editing file ``config/nimdoc.cfg``.\n##\n## .. _Docutils configuration files: https://docutils.sourceforge.io/docs/user/config.htm\n##\n## There are stylistic difference between how this module renders some elements\n## and how original Python Docutils does:\n##\n## * Backreferences to TOC in section headings are not generated.\n##   In HTML each section is also a link that points to the section itself:\n##   this is done for user to be able to copy the link into clipboard.\n##\n## * The same goes for footnotes/citations links: they point to themselves.\n##   No backreferences are generated since finding all references of a footnote\n##   can be done by simply searching for [footnoteName].\n\nimport strutils, os, hashes, strtabs, rstast, rst, highlite, tables, sequtils,\n  algorithm, parseutils, std/strbasics\n\nimport ../../std/private/since\n\nconst\n  HtmlExt = \"html\"\n  IndexExt* = \".idx\"\n\ntype\n  OutputTarget* = enum ## which document type to generate\n    outHtml,            # output is HTML\n    outLatex            # output is Latex\n\n  TocEntry = object\n    n*: PRstNode\n    refname*, header*: string\n\n  MetaEnum* = enum\n    metaNone, metaTitle, metaSubtitle, metaAuthor, metaVersion\n\n  EscapeMode = enum  # in Latex text inside options [] and URLs is\n                     # escaped slightly differently than in normal text\n    emText, emOption, emUrl  # emText is currently used for code also\n\n  RstGenerator* = object of RootObj\n    target*: OutputTarget\n    config*: StringTableRef\n    splitAfter*: int          # split too long entries in the TOC\n    listingCounter*: int\n    tocPart*: seq[TocEntry]\n    hasToc*: bool\n    theIndex: string # Contents of the index file to be dumped at the end.\n    findFile*: FindFileHandler\n    msgHandler*: MsgHandler\n    outDir*: string      ## output directory, initialized by docgen.nim\n    destFile*: string    ## output (HTML) file, initialized by docgen.nim\n    filenames*: RstFileTable\n    filename*: string         ## source Nim or Rst file\n    meta*: array[MetaEnum, string]\n    currentSection: string ## \\\n    ## Stores the empty string or the last headline/overline found in the rst\n    ## document, so it can be used as a prettier name for term index generation.\n    seenIndexTerms: Table[string, int] ## \\\n    ## Keeps count of same text index terms to generate different identifiers\n    ## for hyperlinks. See renderIndexTerm proc for details.\n    id*: int               ## A counter useful for generating IDs.\n    onTestSnippet*: proc (d: var RstGenerator; filename, cmd: string; status: int;\n                          content: string)\n    escMode*: EscapeMode\n\n  PDoc = var RstGenerator ## Alias to type less.\n\n  CodeBlockParams = object ## Stores code block params.\n    numberLines: bool ## True if the renderer has to show line numbers.\n    startLine: int ## The starting line of the code block, by default 1.\n    langStr: string ## Input string used to specify the language.\n    lang: SourceLanguage ## Type of highlighting, by default none.\n    filename: string\n    testCmd: string\n    status: int\n\nproc prettyLink*(file: string): string =\n  changeFileExt(file, \"\").replace(\"_._\", \"..\")\n\nproc init(p: var CodeBlockParams) =\n  ## Default initialisation of CodeBlockParams to sane values.\n  p.startLine = 1\n  p.lang = langNone\n  p.langStr = \"\"\n\nproc initRstGenerator*(g: var RstGenerator, target: OutputTarget,\n                       config: StringTableRef, filename: string,\n                       findFile: FindFileHandler = nil,\n                       msgHandler: MsgHandler = nil,\n                       filenames = default(RstFileTable)) =\n  ## Initializes a ``RstGenerator``.\n  ##\n  ## You need to call this before using a ``RstGenerator`` with any other\n  ## procs in this module. Pass a non ``nil`` ``StringTableRef`` value as\n  ## `config` with parameters used by the HTML output generator.  If you don't\n  ## know what to use, pass the results of the `defaultConfig()\n  ## <#defaultConfig>_` proc.\n  ##\n  ## The `filename` parameter will be used for error reporting and creating\n  ## index hyperlinks to the file, but you can pass an empty string here if you\n  ## are parsing a stream in memory. If `filename` ends with the ``.nim``\n  ## extension, the title for the document will be set by default to ``Module\n  ## filename``.  This default title can be overridden by the embedded rst, but\n  ## it helps to prettify the generated index if no title is found.\n  ##\n  ## The ``RstParseOptions``, ``FindFileHandler`` and ``MsgHandler`` types\n  ## are defined in the `packages/docutils/rst module <rst.html>`_.\n  ## ``options`` selects the behaviour of the rst parser.\n  ##\n  ## ``findFile`` is a proc used by the rst ``include`` directive among others.\n  ## The purpose of this proc is to mangle or filter paths. It receives paths\n  ## specified in the rst document and has to return a valid path to existing\n  ## files or the empty string otherwise.  If you pass ``nil``, a default proc\n  ## will be used which given a path returns the input path only if the file\n  ## exists. One use for this proc is to transform relative paths found in the\n  ## document to absolute path, useful if the rst file and the resources it\n  ## references are not in the same directory as the current working directory.\n  ##\n  ## The ``msgHandler`` is a proc used for user error reporting. It will be\n  ## called with the filename, line, col, and type of any error found during\n  ## parsing. If you pass ``nil``, a default message handler will be used which\n  ## writes the messages to the standard output.\n  ##\n  ## Example:\n  ##\n  ## .. code-block:: nim\n  ##\n  ##   import packages/docutils/rstgen\n  ##\n  ##   var gen: RstGenerator\n  ##   gen.initRstGenerator(outHtml, defaultConfig(), \"filename\", {})\n  g.config = config\n  g.target = target\n  g.tocPart = @[]\n  g.filename = filename\n  g.filenames = filenames\n  g.splitAfter = 20\n  g.theIndex = \"\"\n  g.findFile = findFile\n  g.currentSection = \"\"\n  g.id = 0\n  g.escMode = emText\n  let fileParts = filename.splitFile\n  if fileParts.ext == \".nim\":\n    g.currentSection = \"Module \" & fileParts.name\n  g.seenIndexTerms = initTable[string, int]()\n  g.msgHandler = msgHandler\n\n  let s = config.getOrDefault\"split.item.toc\"\n  if s != \"\": g.splitAfter = parseInt(s)\n  for i in low(g.meta)..high(g.meta): g.meta[i] = \"\"\n\nproc writeIndexFile*(g: var RstGenerator, outfile: string) =\n  ## Writes the current index buffer to the specified output file.\n  ##\n  ## You previously need to add entries to the index with the `setIndexTerm()\n  ## <#setIndexTerm,RstGenerator,string,string,string,string,string>`_ proc.\n  ## If the index is empty the file won't be created.\n  if g.theIndex.len > 0: writeFile(outfile, g.theIndex)\n\nproc addHtmlChar(dest: var string, c: char) =\n  # Escapes HTML characters. Note that single quote ' is not escaped as\n  # &apos; -- unlike XML (for standards pre HTML5 it was even forbidden).\n  case c\n  of '&': add(dest, \"&amp;\")\n  of '<': add(dest, \"&lt;\")\n  of '>': add(dest, \"&gt;\")\n  of '\\\"': add(dest, \"&quot;\")\n  else: add(dest, c)\n\nproc addTexChar(dest: var string, c: char, escMode: EscapeMode) =\n  ## Escapes 10 special Latex characters and sometimes ` and [, ].\n  ## TODO: @ is always a normal symbol (besides the header), am I wrong?\n  ## All escapes that need to work in text and code blocks (`emText` mode)\n  ## should start from \\ (to be compatible with fancyvrb/fvextra).\n  case c\n  of '_', '$', '&', '#', '%': add(dest, \"\\\\\" & c)\n  # \\~ and \\^ have a special meaning unless they are followed by {}\n  of '~', '^': add(dest, \"\\\\\" & c & \"{}\")\n  # Latex loves to substitute ` to opening quote, even in texttt mode!\n  of '`': add(dest, \"\\\\textasciigrave{}\")\n  # add {} to avoid gobbling up space by \\textbackslash\n  of '\\\\': add(dest, \"\\\\textbackslash{}\")\n  # Using { and } in URL in Latex: https://tex.stackexchange.com/a/469175\n  of '{':\n    add(dest, if escMode == emUrl: \"\\\\%7B\" else: \"\\\\{\")\n  of '}':\n    add(dest, if escMode == emUrl: \"\\\\%7D\" else: \"\\\\}\")\n  of ']':\n    # escape ] inside an optional argument in e.g. \\section[static[T]]{..\n    add(dest, if escMode == emOption: \"\\\\text{]}\" else: \"]\")\n  else: add(dest, c)\n\nproc escChar*(target: OutputTarget, dest: var string,\n              c: char, escMode: EscapeMode) {.inline.} =\n  case target\n  of outHtml:  addHtmlChar(dest, c)\n  of outLatex: addTexChar(dest, c, escMode)\n\nproc addSplitter(target: OutputTarget; dest: var string) {.inline.} =\n  case target\n  of outHtml: add(dest, \"<wbr />\")\n  of outLatex: add(dest, \"\\\\-\")\n\nproc nextSplitPoint*(s: string, start: int): int =\n  result = start\n  while result < len(s) + 0:\n    case s[result]\n    of '_': return\n    of 'a'..'z':\n      if result + 1 < len(s) + 0:\n        if s[result + 1] in {'A'..'Z'}: return\n    else: discard\n    inc(result)\n  dec(result)                 # last valid index\n\nproc esc*(target: OutputTarget, s: string, splitAfter = -1, escMode = emText): string =\n  ## Escapes the HTML.\n  result = \"\"\n  if splitAfter >= 0:\n    var partLen = 0\n    var j = 0\n    while j < len(s):\n      var k = nextSplitPoint(s, j)\n      #if (splitter != \" \") or (partLen + k - j + 1 > splitAfter):\n      partLen = 0\n      addSplitter(target, result)\n      for i in countup(j, k): escChar(target, result, s[i], escMode)\n      inc(partLen, k - j + 1)\n      j = k + 1\n  else:\n    for i in countup(0, len(s) - 1): escChar(target, result, s[i], escMode)\n\n\nproc disp(target: OutputTarget, xml, tex: string): string =\n  if target != outLatex: result = xml\n  else: result = tex\n\nproc dispF(target: OutputTarget, xml, tex: string,\n           args: varargs[string]): string =\n  if target != outLatex: result = xml % args\n  else: result = tex % args\n\nproc dispA(target: OutputTarget, dest: var string,\n           xml, tex: string, args: varargs[string]) =\n  if target != outLatex: addf(dest, xml, args)\n  else: addf(dest, tex, args)\n\nproc `or`(x, y: string): string {.inline.} =\n  result = if x.len == 0: y else: x\n\nproc renderRstToOut*(d: var RstGenerator, n: PRstNode, result: var string)\n  ## Writes into ``result`` the rst ast ``n`` using the ``d`` configuration.\n  ##\n  ## Before using this proc you need to initialise a ``RstGenerator`` with\n  ## ``initRstGenerator`` and parse a rst file with ``rstParse`` from the\n  ## `packages/docutils/rst module <rst.html>`_. Example:\n  ##\n  ## .. code-block:: nim\n  ##\n  ##   # ...configure gen and rst vars...\n  ##   var generatedHtml = \"\"\n  ##   renderRstToOut(gen, rst, generatedHtml)\n  ##   echo generatedHtml\n\nproc renderAux(d: PDoc, n: PRstNode, result: var string) =\n  for i in countup(0, len(n)-1): renderRstToOut(d, n.sons[i], result)\n\ntemplate idS(txt: string): string =\n  if txt == \"\": \"\"\n  else:\n    case d.target\n    of outHtml:\n      \" id=\\\"\" & txt & \"\\\"\"\n    of outLatex:\n      \"\\\\label{\" & txt & \"}\\\\hypertarget{\" & txt & \"}{}\"\n        # we add \\label for page number references via \\pageref, while\n        # \\hypertarget is for clickable links via \\hyperlink.\n\nproc renderAux(d: PDoc, n: PRstNode, html, tex: string, result: var string) =\n  # formats sons of `n` as substitution variable $1 inside strings `html` and\n  # `tex`, internal target (anchor) is provided as substitute $2.\n  var tmp = \"\"\n  for i in countup(0, len(n)-1): renderRstToOut(d, n.sons[i], tmp)\n  case d.target\n  of outHtml:  result.addf(html, [tmp, n.anchor.idS])\n  of outLatex: result.addf(tex,  [tmp, n.anchor.idS])\n\n# ---------------- index handling --------------------------------------------\n\nproc quoteIndexColumn(text: string): string =\n  ## Returns a safe version of `text` for serialization to the ``.idx`` file.\n  ##\n  ## The returned version can be put without worries in a line based tab\n  ## separated column text file. The following character sequence replacements\n  ## will be performed for that goal:\n  ##\n  ## * ``\"\\\\\"`` => ``\"\\\\\\\\\"``\n  ## * ``\"\\n\"`` => ``\"\\\\n\"``\n  ## * ``\"\\t\"`` => ``\"\\\\t\"``\n  result = newStringOfCap(text.len + 3)\n  for c in text:\n    case c\n    of '\\\\': result.add \"\\\\\"\n    of '\\L': result.add \"\\\\n\"\n    of '\\C': discard\n    of '\\t': result.add \"\\\\t\"\n    else: result.add c\n\nproc unquoteIndexColumn(text: string): string =\n  ## Returns the unquoted version generated by ``quoteIndexColumn``.\n  result = text.multiReplace((\"\\\\t\", \"\\t\"), (\"\\\\n\", \"\\n\"), (\"\\\\\\\\\", \"\\\\\"))\n\nproc setIndexTerm*(d: var RstGenerator, htmlFile, id, term: string,\n                   linkTitle, linkDesc = \"\") =\n  ## Adds a `term` to the index using the specified hyperlink identifier.\n  ##\n  ## A new entry will be added to the index using the format\n  ## ``term<tab>file#id``. The file part will come from the `htmlFile`\n  ## parameter.\n  ##\n  ## The `id` will be appended with a hash character only if its length is not\n  ## zero, otherwise no specific anchor will be generated. In general you\n  ## should only pass an empty `id` value for the title of standalone rst\n  ## documents (they are special for the `mergeIndexes() <#mergeIndexes,string>`_\n  ## proc, see `Index (idx) file format <docgen.html#index-idx-file-format>`_\n  ## for more information). Unlike other index terms, title entries are\n  ## inserted at the beginning of the accumulated buffer to maintain a logical\n  ## order of entries.\n  ##\n  ## If `linkTitle` or `linkDesc` are not the empty string, two additional\n  ## columns with their contents will be added.\n  ##\n  ## The index won't be written to disk unless you call `writeIndexFile()\n  ## <#writeIndexFile,RstGenerator,string>`_. The purpose of the index is\n  ## documented in the `docgen tools guide\n  ## <docgen.html#related-options-index-switch>`_.\n  var\n    entry = term\n    isTitle = false\n  entry.add('\\t')\n  entry.add(htmlFile)\n  if id.len > 0:\n    entry.add('#')\n    entry.add(id)\n  else:\n    isTitle = true\n  if linkTitle.len > 0 or linkDesc.len > 0:\n    entry.add('\\t' & linkTitle.quoteIndexColumn)\n    entry.add('\\t' & linkDesc.quoteIndexColumn)\n  entry.add(\"\\n\")\n\n  if isTitle: d.theIndex.insert(entry)\n  else: d.theIndex.add(entry)\n\nproc hash(n: PRstNode): int =\n  if n.kind == rnLeaf:\n    result = hash(n.text)\n  elif n.len > 0:\n    result = hash(n.sons[0])\n    for i in 1 ..< len(n):\n      result = result !& hash(n.sons[i])\n    result = !$result\n\nproc renderIndexTerm*(d: PDoc, n: PRstNode, result: var string) =\n  ## Renders the string decorated within \\`foobar\\`\\:idx\\: markers.\n  ##\n  ## Additionally adds the enclosed text to the index as a term. Since we are\n  ## interested in different instances of the same term to have different\n  ## entries, a table is used to keep track of the amount of times a term has\n  ## previously appeared to give a different identifier value for each.\n  let refname = n.rstnodeToRefname\n  if d.seenIndexTerms.hasKey(refname):\n    d.seenIndexTerms[refname] = d.seenIndexTerms.getOrDefault(refname) + 1\n  else:\n    d.seenIndexTerms[refname] = 1\n  let id = refname & '_' & $d.seenIndexTerms.getOrDefault(refname)\n\n  var term = \"\"\n  renderAux(d, n, term)\n  setIndexTerm(d, changeFileExt(extractFilename(d.filename), HtmlExt), id, term, d.currentSection)\n  dispA(d.target, result, \"<span id=\\\"$1\\\">$2</span>\", \"\\\\nimindexterm{$1}{$2}\",\n        [id, term])\n\ntype\n  IndexEntry = object\n    keyword: string\n    link: string\n    linkTitle: string ## contains a prettier text for the href\n    linkDesc: string ## the title attribute of the final href\n\n  IndexedDocs = Table[IndexEntry, seq[IndexEntry]] ## \\\n    ## Contains the index sequences for doc types.\n    ##\n    ## The key is a *fake* IndexEntry which will contain the title of the\n    ## document in the `keyword` field and `link` will contain the html\n    ## filename for the document. `linkTitle` and `linkDesc` will be empty.\n    ##\n    ## The value indexed by this IndexEntry is a sequence with the real index\n    ## entries found in the ``.idx`` file.\n\nproc cmp(a, b: IndexEntry): int =\n  ## Sorts two ``IndexEntry`` first by `keyword` field, then by `link`.\n  result = cmpIgnoreStyle(a.keyword, b.keyword)\n  if result == 0:\n    result = cmpIgnoreStyle(a.link, b.link)\n\nproc hash(x: IndexEntry): Hash =\n  ## Returns the hash for the combined fields of the type.\n  ##\n  ## The hash is computed as the chained hash of the individual string hashes.\n  result = x.keyword.hash !& x.link.hash\n  result = result !& x.linkTitle.hash\n  result = result !& x.linkDesc.hash\n  result = !$result\n\nwhen defined(gcDestructors):\n  template `<-`(a, b: var IndexEntry) = a = move(b)\nelse:\n  proc `<-`(a: var IndexEntry, b: IndexEntry) =\n    shallowCopy a.keyword, b.keyword\n    shallowCopy a.link, b.link\n    shallowCopy a.linkTitle, b.linkTitle\n    shallowCopy a.linkDesc, b.linkDesc\n\nproc sortIndex(a: var openArray[IndexEntry]) =\n  # we use shellsort here; fast and simple\n  let n = len(a)\n  var h = 1\n  while true:\n    h = 3 * h + 1\n    if h > n: break\n  while true:\n    h = h div 3\n    for i in countup(h, n - 1):\n      var v: IndexEntry\n      v <- a[i]\n      var j = i\n      while cmp(a[j-h], v) >= 0:\n        a[j] <- a[j-h]\n        j = j-h\n        if j < h: break\n      a[j] <- v\n    if h == 1: break\n\nproc escapeLink(s: string): string =\n  ## This proc is mostly copied from uri/encodeUrl except that\n  ## these chars are also left unencoded: '#', '/'.\n  result = newStringOfCap(s.len + s.len shr 2)\n  for c in items(s):\n    case c\n    of 'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~': # same as that in uri/encodeUrl\n      add(result, c)\n    of '#', '/': # example.com/foo/#bar (don't escape the '/' and '#' in such links)\n      add(result, c)\n    else:\n      add(result, \"%\")\n      add(result, toHex(ord(c), 2))\n\nproc generateSymbolIndex(symbols: seq[IndexEntry]): string =\n  result = \"<dl>\"\n  var i = 0\n  while i < symbols.len:\n    let keyword = symbols[i].keyword\n    let cleanedKeyword = keyword.escapeLink\n    result.addf(\"<dt><a name=\\\"$2\\\" href=\\\"#$2\\\"><span>$1:</span></a></dt><dd><ul class=\\\"simple\\\">\\n\",\n                [keyword, cleanedKeyword])\n    var j = i\n    while j < symbols.len and keyword == symbols[j].keyword:\n      let\n        url = symbols[j].link.escapeLink\n        text = if symbols[j].linkTitle.len > 0: symbols[j].linkTitle else: url\n        desc = if symbols[j].linkDesc.len > 0: symbols[j].linkDesc else: \"\"\n      if desc.len > 0:\n        result.addf(\"\"\"<li><a class=\"reference external\"\n          title=\"$3\" data-doc-search-tag=\"$2\" href=\"$1\">$2</a></li>\n          \"\"\", [url, text, desc])\n      else:\n        result.addf(\"\"\"<li><a class=\"reference external\"\n          data-doc-search-tag=\"$2\" href=\"$1\">$2</a></li>\n          \"\"\", [url, text])\n      inc j\n    result.add(\"</ul></dd>\\n\")\n    i = j\n  result.add(\"</dl>\")\n\nproc isDocumentationTitle(hyperlink: string): bool =\n  ## Returns true if the hyperlink is actually a documentation title.\n  ##\n  ## Documentation titles lack the hash. See `mergeIndexes()\n  ## <#mergeIndexes,string>`_ for a more detailed explanation.\n  result = hyperlink.find('#') < 0\n\nproc stripTocLevel(s: string): tuple[level: int, text: string] =\n  ## Returns the *level* of the toc along with the text without it.\n  for c in 0 ..< s.len:\n    result.level = c\n    if s[c] != ' ': break\n  result.text = s[result.level ..< s.len]\n\nproc indentToLevel(level: var int, newLevel: int): string =\n  ## Returns the sequence of <ul>|</ul> characters to switch to `newLevel`.\n  ##\n  ## The amount of lists added/removed will be based on the `level` variable,\n  ## which will be reset to `newLevel` at the end of the proc.\n  result = \"\"\n  if level == newLevel:\n    return\n  if newLevel > level:\n    result = repeat(\"<li><ul>\", newLevel - level)\n  else:\n    result = repeat(\"</ul></li>\", level - newLevel)\n  level = newLevel\n\nproc generateDocumentationToc(entries: seq[IndexEntry]): string =\n  ## Returns the sequence of index entries in an HTML hierarchical list.\n  result = \"\"\n  # Build a list of levels and extracted titles to make processing easier.\n  var\n    titleRef: string\n    titleTag: string\n    levels: seq[tuple[level: int, text: string]]\n    L = 0\n    level = 1\n  levels.newSeq(entries.len)\n  for entry in entries:\n    let (rawLevel, rawText) = stripTocLevel(entry.linkTitle or entry.keyword)\n    if rawLevel < 1:\n      # This is a normal symbol, push it *inside* one level from the last one.\n      levels[L].level = level + 1\n      # Also, ignore the linkTitle and use directly the keyword.\n      levels[L].text = entry.keyword\n    else:\n      # The level did change, update the level indicator.\n      level = rawLevel\n      levels[L].level = rawLevel\n      levels[L].text = rawText\n    inc L\n\n  # Now generate hierarchical lists based on the precalculated levels.\n  result = \"<ul>\\n\"\n  level = 1\n  L = 0\n  while L < entries.len:\n    let link = entries[L].link\n    if link.isDocumentationTitle:\n      titleRef = link\n      titleTag = levels[L].text\n    else:\n      result.add(level.indentToLevel(levels[L].level))\n      result.addf(\"\"\"<li><a class=\"reference\" data-doc-search-tag=\"$1: $2\" href=\"$3\">\n        $3</a></li>\n        \"\"\", [titleTag, levels[L].text, link, levels[L].text])\n    inc L\n  result.add(level.indentToLevel(1) & \"</ul>\\n\")\n\nproc generateDocumentationIndex(docs: IndexedDocs): string =\n  ## Returns all the documentation TOCs in an HTML hierarchical list.\n  result = \"\"\n\n  # Sort the titles to generate their toc in alphabetical order.\n  var titles = toSeq(keys[IndexEntry, seq[IndexEntry]](docs))\n  sort(titles, cmp)\n\n  for title in titles:\n    let tocList = generateDocumentationToc(docs.getOrDefault(title))\n    result.add(\"<ul><li><a href=\\\"\" &\n      title.link & \"\\\">\" & title.keyword & \"</a>\\n\" & tocList & \"</li></ul>\\n\")\n\nproc generateDocumentationJumps(docs: IndexedDocs): string =\n  ## Returns a plain list of hyperlinks to documentation TOCs in HTML.\n  result = \"Documents: \"\n\n  # Sort the titles to generate their toc in alphabetical order.\n  var titles = toSeq(keys[IndexEntry, seq[IndexEntry]](docs))\n  sort(titles, cmp)\n\n  var chunks: seq[string] = @[]\n  for title in titles:\n    chunks.add(\"<a href=\\\"\" & title.link & \"\\\">\" & title.keyword & \"</a>\")\n\n  result.add(chunks.join(\", \") & \".<br/>\")\n\nproc generateModuleJumps(modules: seq[string]): string =\n  ## Returns a plain list of hyperlinks to the list of modules.\n  result = \"Modules: \"\n\n  var chunks: seq[string] = @[]\n  for name in modules:\n    chunks.add(\"<a href=\\\"$1.html\\\">$2</a>\" % [name, name.prettyLink])\n\n  result.add(chunks.join(\", \") & \".<br/>\")\n\nproc readIndexDir(dir: string):\n    tuple[modules: seq[string], symbols: seq[IndexEntry], docs: IndexedDocs] =\n  ## Walks `dir` reading ``.idx`` files converting them in IndexEntry items.\n  ##\n  ## Returns the list of found module names, the list of free symbol entries\n  ## and the different documentation indexes. The list of modules is sorted.\n  ## See the documentation of ``mergeIndexes`` for details.\n  result.modules = @[]\n  result.docs = initTable[IndexEntry, seq[IndexEntry]](32)\n  newSeq(result.symbols, 15_000)\n  setLen(result.symbols, 0)\n  var L = 0\n  # Scan index files and build the list of symbols.\n  for path in walkDirRec(dir):\n    if path.endsWith(IndexExt):\n      var\n        fileEntries: seq[IndexEntry]\n        title: IndexEntry\n        f = 0\n      newSeq(fileEntries, 500)\n      setLen(fileEntries, 0)\n      for line in lines(path):\n        let s = line.find('\\t')\n        if s < 0: continue\n        setLen(fileEntries, f+1)\n        fileEntries[f].keyword = line.substr(0, s-1)\n        fileEntries[f].link = line.substr(s+1)\n        # See if we detect a title, a link without a `#foobar` trailing part.\n        if title.keyword.len == 0 and fileEntries[f].link.isDocumentationTitle:\n          title.keyword = fileEntries[f].keyword\n          title.link = fileEntries[f].link\n\n        if fileEntries[f].link.find('\\t') > 0:\n          let extraCols = fileEntries[f].link.split('\\t')\n          fileEntries[f].link = extraCols[0]\n          assert extraCols.len == 3\n          fileEntries[f].linkTitle = extraCols[1].unquoteIndexColumn\n          fileEntries[f].linkDesc = extraCols[2].unquoteIndexColumn\n        else:\n          fileEntries[f].linkTitle = \"\"\n          fileEntries[f].linkDesc = \"\"\n        inc f\n      # Depending on type add this to the list of symbols or table of APIs.\n      if title.keyword.len == 0:\n        for i in 0 ..< f:\n          # Don't add to symbols TOC entries (they start with a whitespace).\n          let toc = fileEntries[i].linkTitle\n          if toc.len > 0 and toc[0] == ' ':\n            continue\n          # Ok, non TOC entry, add it.\n          setLen(result.symbols, L + 1)\n          result.symbols[L] = fileEntries[i]\n          inc L\n        if fileEntries.len > 0:\n          var x = fileEntries[0].link\n          let i = find(x, '#')\n          if i > 0:\n            x.setLen(i)\n          if i != 0:\n            # don't add entries starting with '#'\n            result.modules.add(x.changeFileExt(\"\"))\n      else:\n        # Generate the symbolic anchor for index quickjumps.\n        title.linkTitle = \"doc_toc_\" & $result.docs.len\n        result.docs[title] = fileEntries\n\n  sort(result.modules, system.cmp)\n\nproc mergeIndexes*(dir: string): string =\n  ## Merges all index files in `dir` and returns the generated index as HTML.\n  ##\n  ## This proc will first scan `dir` for index files with the ``.idx``\n  ## extension previously created by commands like ``nim doc|rst2html``\n  ## which use the ``--index:on`` switch. These index files are the result of\n  ## calls to `setIndexTerm()\n  ## <#setIndexTerm,RstGenerator,string,string,string,string,string>`_\n  ## and `writeIndexFile() <#writeIndexFile,RstGenerator,string>`_, so they are\n  ## simple tab separated files.\n  ##\n  ## As convention this proc will split index files into two categories:\n  ## documentation and API. API indices will be all joined together into a\n  ## single big sorted index, making the bulk of the final index. This is good\n  ## for API documentation because many symbols are repeated in different\n  ## modules. On the other hand, documentation indices are essentially table of\n  ## contents plus a few special markers. These documents will be rendered in a\n  ## separate section which tries to maintain the order and hierarchy of the\n  ## symbols in the index file.\n  ##\n  ## To differentiate between a documentation and API file a convention is\n  ## used: indices which contain one entry without the HTML hash character (#)\n  ## will be considered `documentation`, since this hash-less entry is the\n  ## explicit title of the document.  Indices without this explicit entry will\n  ## be considered `generated API` extracted out of a source ``.nim`` file.\n  ##\n  ## Returns the merged and sorted indices into a single HTML block which can\n  ## be further embedded into nimdoc templates.\n  var (modules, symbols, docs) = readIndexDir(dir)\n\n  result = \"\"\n  # Generate a quick jump list of documents.\n  if docs.len > 0:\n    result.add(generateDocumentationJumps(docs))\n    result.add(\"<p />\")\n\n  # Generate hyperlinks to all the linked modules.\n  if modules.len > 0:\n    result.add(generateModuleJumps(modules))\n    result.add(\"<p />\")\n\n  when false:\n    # Generate the HTML block with API documents.\n    if docs.len > 0:\n      result.add(\"<h2>Documentation files</h2>\\n\")\n      result.add(generateDocumentationIndex(docs))\n\n  # Generate the HTML block with symbols.\n  if symbols.len > 0:\n    sortIndex(symbols)\n    result.add(\"<h2>API symbols</h2>\\n\")\n    result.add(generateSymbolIndex(symbols))\n\n\n# ----------------------------------------------------------------------------\n\nproc stripTocHtml(s: string): string =\n  ## Ugly quick hack to remove HTML tags from TOC titles.\n  ##\n  ## A TocEntry.header field already contains rendered HTML tags. Instead of\n  ## implementing a proper version of renderRstToOut() which recursively\n  ## renders an rst tree to plain text, we simply remove text found between\n  ## angled brackets. Given the limited possibilities of rst inside TOC titles\n  ## this should be enough.\n  result = s\n  var first = result.find('<')\n  while first >= 0:\n    let last = result.find('>', first)\n    if last < 0:\n      # Abort, since we didn't found a closing angled bracket.\n      return\n    result.delete(first, last)\n    first = result.find('<', first)\n\nproc renderHeadline(d: PDoc, n: PRstNode, result: var string) =\n  var tmp = \"\"\n  for i in countup(0, len(n) - 1): renderRstToOut(d, n.sons[i], tmp)\n  d.currentSection = tmp\n  # Find the last higher level section for unique reference name\n  var sectionPrefix = \"\"\n  for i in countdown(d.tocPart.high, 0):\n    let n2 = d.tocPart[i].n\n    if n2.level < n.level:\n      sectionPrefix = rstnodeToRefname(n2) & \"-\"\n      break\n  var refname = sectionPrefix & rstnodeToRefname(n)\n  var tocName = esc(d.target, renderRstToText(n), escMode = emOption)\n    # for Latex: simple text without commands that may break TOC/hyperref\n  if d.hasToc:\n    var length = len(d.tocPart)\n    setLen(d.tocPart, length + 1)\n    d.tocPart[length].refname = refname\n    d.tocPart[length].n = n\n    d.tocPart[length].header = tmp\n\n    dispA(d.target, result, \"\\n<h$1><a class=\\\"toc-backref\\\"\" &\n      \"$2 href=\\\"#$5\\\">$3</a></h$1>\", \"\\\\rsth$4[$6]{$3}$2\\n\",\n      [$n.level, refname.idS, tmp,\n       $chr(n.level - 1 + ord('A')), refname, tocName])\n  else:\n    dispA(d.target, result, \"\\n<h$1$2>$3</h$1>\",\n                            \"\\\\rsth$4[$5]{$3}$2\\n\", [\n        $n.level, refname.idS, tmp,\n        $chr(n.level - 1 + ord('A')), tocName])\n\n  # Generate index entry using spaces to indicate TOC level for the output HTML.\n  assert n.level >= 0\n  let\n    htmlFileRelPath = if d.outDir.len == 0:\n                        # /foo/bar/zoo.nim -> zoo.html\n                        changeFileExt(extractFilename(d.filename), HtmlExt)\n                      else: # d is initialized in docgen.nim\n                        # outDir   = /foo              -\\\n                        # destFile = /foo/bar/zoo.html -|-> bar/zoo.html\n                        d.destFile.relativePath(d.outDir, '/')\n  setIndexTerm(d, htmlFileRelPath, refname, tmp.stripTocHtml,\n    spaces(max(0, n.level)) & tmp)\n\nproc renderOverline(d: PDoc, n: PRstNode, result: var string) =\n  if n.level == 0 and d.meta[metaTitle].len == 0:\n    for i in countup(0, len(n)-1):\n      renderRstToOut(d, n.sons[i], d.meta[metaTitle])\n    d.currentSection = d.meta[metaTitle]\n  elif n.level == 0 and d.meta[metaSubtitle].len == 0:\n    for i in countup(0, len(n)-1):\n      renderRstToOut(d, n.sons[i], d.meta[metaSubtitle])\n    d.currentSection = d.meta[metaSubtitle]\n  else:\n    var tmp = \"\"\n    for i in countup(0, len(n) - 1): renderRstToOut(d, n.sons[i], tmp)\n    d.currentSection = tmp\n    var tocName = esc(d.target, renderRstToText(n), escMode=emOption)\n    dispA(d.target, result, \"<h$1$2><center>$3</center></h$1>\",\n                   \"\\\\rstov$4[$5]{$3}$2\\n\", [$n.level,\n        rstnodeToRefname(n).idS, tmp, $chr(n.level - 1 + ord('A')), tocName])\n\n\nproc renderTocEntry(d: PDoc, e: TocEntry, result: var string) =\n  dispA(d.target, result,\n    \"<li><a class=\\\"reference\\\" id=\\\"$1_toc\\\" href=\\\"#$1\\\">$2</a></li>\\n\",\n    \"\\\\item\\\\label{$1_toc} $2\\\\ref{$1}\\n\", [e.refname, e.header])\n\nproc renderTocEntries*(d: var RstGenerator, j: var int, lvl: int,\n                       result: var string) =\n  var tmp = \"\"\n  while j <= high(d.tocPart):\n    var a = abs(d.tocPart[j].n.level)\n    if a == lvl:\n      renderTocEntry(d, d.tocPart[j], tmp)\n      inc(j)\n    elif a > lvl:\n      renderTocEntries(d, j, a, tmp)\n    else:\n      break\n  if lvl > 1:\n    dispA(d.target, result, \"<ul class=\\\"simple\\\">$1</ul>\",\n                            \"\\\\begin{enumerate}$1\\\\end{enumerate}\", [tmp])\n  else:\n    result.add(tmp)\n\nproc renderImage(d: PDoc, n: PRstNode, result: var string) =\n  let\n    arg = getArgument(n)\n  var\n    options = \"\"\n\n  var s = esc(d.target, getFieldValue(n, \"scale\").strip())\n  if s.len > 0:\n    dispA(d.target, options, \" scale=\\\"$1\\\"\", \" scale=$1\", [s])\n\n  s = esc(d.target, getFieldValue(n, \"height\").strip())\n  if s.len > 0:\n    dispA(d.target, options, \" height=\\\"$1\\\"\", \" height=$1\", [s])\n\n  s = esc(d.target, getFieldValue(n, \"width\").strip())\n  if s.len > 0:\n    dispA(d.target, options, \" width=\\\"$1\\\"\", \" width=$1\", [s])\n\n  s = esc(d.target, getFieldValue(n, \"alt\").strip())\n  if s.len > 0:\n    dispA(d.target, options, \" alt=\\\"$1\\\"\", \"\", [s])\n\n  s = esc(d.target, getFieldValue(n, \"align\").strip())\n  if s.len > 0:\n    dispA(d.target, options, \" align=\\\"$1\\\"\", \"\", [s])\n\n  if options.len > 0: options = dispF(d.target, \"$1\", \"[$1]\", [options])\n\n  var htmlOut = \"\"\n  if arg.endsWith(\".mp4\") or arg.endsWith(\".ogg\") or\n     arg.endsWith(\".webm\"):\n    htmlOut = \"\"\"\n      <video$3 src=\"$1\"$2 autoPlay='true' loop='true' muted='true'>\n      Sorry, your browser doesn't support embedded videos\n      </video>\n    \"\"\"\n  else:\n    htmlOut = \"<img$3 src=\\\"$1\\\"$2/>\"\n\n  # support for `:target:` links for images:\n  var target = esc(d.target, getFieldValue(n, \"target\").strip(), escMode=emUrl)\n  if target.len > 0:\n    # `htmlOut` needs to be of the following format for link to work for images:\n    # <a class=\"reference external\" href=\"target\"><img src=\\\"$1\\\"$2/></a>\n    var htmlOutWithLink = \"\"\n    dispA(d.target, htmlOutWithLink,\n      \"<a class=\\\"reference external\\\" href=\\\"$2\\\">$1</a>\",\n      \"\\\\href{$2}{$1}\", [htmlOut, target])\n    htmlOut = htmlOutWithLink\n\n  dispA(d.target, result, htmlOut, \"$3\\\\includegraphics$2{$1}\",\n        [esc(d.target, arg), options, n.anchor.idS])\n  if len(n) >= 3: renderRstToOut(d, n.sons[2], result)\n\nproc renderSmiley(d: PDoc, n: PRstNode, result: var string) =\n  dispA(d.target, result,\n    \"\"\"<img src=\"$1\" width=\"15\"\n        height=\"17\" hspace=\"2\" vspace=\"2\" class=\"smiley\" />\"\"\",\n    \"\\\\includegraphics{$1}\",\n    [d.config.getOrDefault\"doc.smiley_format\" % n.text])\n\nproc getField1Int(d: PDoc, n: PRstNode, fieldName: string): int =\n  template err(msg: string) =\n    rstMessage(d.filenames, d.msgHandler, n.info, meInvalidField, msg)\n  let value = n.getFieldValue\n  var number: int\n  let nChars = parseInt(value, number)\n  if nChars == 0:\n    if value.len == 0:\n      err(\"field $1 requires an argument\" % [fieldName])\n    else:\n      err(\"field $1 requires an integer, but '$2' was given\" %\n          [fieldName, value])\n  elif nChars < value.len:\n    err(\"extra arguments were given to $1: '$2'\" %\n        [fieldName, value[nChars..^1]])\n  else:\n    result = number\n\nproc parseCodeBlockField(d: PDoc, n: PRstNode, params: var CodeBlockParams) =\n  ## Parses useful fields which can appear before a code block.\n  ##\n  ## This supports the special ``default-language`` internal string generated\n  ## by the ``rst`` module to communicate a specific default language.\n  case n.getArgument.toLowerAscii\n  of \"number-lines\":\n    params.numberLines = true\n    # See if the field has a parameter specifying a different line than 1.\n    params.startLine = getField1Int(d, n, \"number-lines\")\n  of \"file\", \"filename\":\n    # The ``file`` option is a Nim extension to the official spec, it acts\n    # like it would for other directives like ``raw`` or ``cvs-table``. This\n    # field is dealt with in ``rst.nim`` which replaces the existing block with\n    # the referenced file, so we only need to ignore it here to avoid incorrect\n    # warning messages.\n    params.filename = n.getFieldValue.strip\n  of \"test\":\n    params.testCmd = n.getFieldValue.strip\n    if params.testCmd.len == 0:\n      # factor with D20210224T221756. Note that `$docCmd` should appear before `$file`\n      # but after all other options, but currently `$options` merges both options and `$file` so it's tricky.\n      params.testCmd = \"$nim r --backend:$backend --lib:$libpath $docCmd $options\"\n    else:\n      # consider whether `$docCmd` should be appended here too\n      params.testCmd = unescape(params.testCmd)\n  of \"status\", \"exitcode\":\n    params.status = getField1Int(d, n, n.getArgument)\n  of \"default-language\":\n    params.langStr = n.getFieldValue.strip\n    params.lang = params.langStr.getSourceLanguage\n  else:\n    rstMessage(d.filenames, d.msgHandler, n.info, mwUnsupportedField,\n               n.getArgument)\n\nproc parseCodeBlockParams(d: PDoc, n: PRstNode): CodeBlockParams =\n  ## Iterates over all code block fields and returns processed params.\n  ##\n  ## Also processes the argument of the directive as the default language. This\n  ## is done last so as to override any internal communication field variables.\n  result.init\n  if n.isNil:\n    return\n  assert n.kind in {rnCodeBlock, rnInlineCode}\n\n  # Parse the field list for rendering parameters if there are any.\n  if not n.sons[1].isNil:\n    for son in n.sons[1].sons: d.parseCodeBlockField(son, result)\n\n  # Parse the argument and override the language.\n  result.langStr = strip(getArgument(n))\n  if result.langStr != \"\":\n    result.lang = getSourceLanguage(result.langStr)\n\nproc buildLinesHtmlTable(d: PDoc; params: CodeBlockParams, code: string,\n                         idStr: string):\n    tuple[beginTable, endTable: string] =\n  ## Returns the necessary tags to start/end a code block in HTML.\n  ##\n  ## If the numberLines has not been used, the tags will default to a simple\n  ## <pre> pair. Otherwise it will build a table and insert an initial column\n  ## with all the line numbers, which requires you to pass the `code` to detect\n  ## how many lines have to be generated (and starting at which point!).\n  inc d.listingCounter\n  let id = $d.listingCounter\n  if not params.numberLines:\n    result = (d.config.getOrDefault\"doc.listing_start\" %\n                [id, sourceLanguageToStr[params.lang], idStr],\n              d.config.getOrDefault\"doc.listing_end\" % id)\n    return\n\n  var codeLines = code.strip.countLines\n  assert codeLines > 0\n  result.beginTable = \"\"\"<table$1 class=\"line-nums-table\">\"\"\" % [idStr] &\n      \"\"\"<tbody><tr><td class=\"blob-line-nums\"><pre class=\"line-nums\">\"\"\"\n  var line = params.startLine\n  while codeLines > 0:\n    result.beginTable.add($line & \"\\n\")\n    line.inc\n    codeLines.dec\n  result.beginTable.add(\"</pre></td><td>\" & (\n      d.config.getOrDefault\"doc.listing_start\" %\n        [id, sourceLanguageToStr[params.lang], idStr]))\n  result.endTable = (d.config.getOrDefault\"doc.listing_end\" % id) &\n      \"</td></tr></tbody></table>\" & (\n      d.config.getOrDefault\"doc.listing_button\" % id)\n\nproc renderCodeLang*(result: var string, lang: SourceLanguage, code: string,\n                     target: OutputTarget) =\n  var g: GeneralTokenizer\n  initGeneralTokenizer(g, code)\n  while true:\n    getNextToken(g, lang)\n    case g.kind\n    of gtEof: break\n    of gtNone, gtWhitespace:\n      add(result, substr(code, g.start, g.length + g.start - 1))\n    else:\n      dispA(target, result, \"<span class=\\\"$2\\\">$1</span>\", \"\\\\span$2{$1}\", [\n        esc(target, substr(code, g.start, g.length+g.start-1)),\n        tokenClassToStr[g.kind]])\n  deinitGeneralTokenizer(g)\n\nproc renderNimCode*(result: var string, code: string, target: OutputTarget) =\n  renderCodeLang(result, langNim, code, target)\n\nproc renderCode(d: PDoc, n: PRstNode, result: var string) =\n  ## Renders a code (code block or inline code), appending it to `result`.\n  ##\n  ## If the code block uses the ``number-lines`` option, a table will be\n  ## generated with two columns, the first being a list of numbers and the\n  ## second the code block itself. The code block can use syntax highlighting,\n  ## which depends on the directive argument specified by the rst input, and\n  ## may also come from the parser through the internal ``default-language``\n  ## option to differentiate between a plain code block and Nim's code block\n  ## extension.\n  assert n.kind in {rnCodeBlock, rnInlineCode}\n  var params = d.parseCodeBlockParams(n)\n  if n.sons[2] == nil: return\n  var m = n.sons[2].sons[0]\n  assert m.kind == rnLeaf\n\n  if params.testCmd.len > 0 and d.onTestSnippet != nil:\n    d.onTestSnippet(d, params.filename, params.testCmd, params.status, m.text)\n\n  var blockStart, blockEnd: string\n  case d.target\n  of outHtml:\n    if n.kind == rnCodeBlock:\n      (blockStart, blockEnd) = buildLinesHtmlTable(d, params, m.text,\n                                                   n.anchor.idS)\n    else:  # rnInlineCode\n      blockStart = \"<tt class=\\\"docutils literal\\\"><span class=\\\"pre\\\">\"\n      blockEnd = \"</span></tt>\"\n  of outLatex:\n    if n.kind == rnCodeBlock:\n      blockStart = \"\\n\\n\" & n.anchor.idS & \"\\\\begin{rstpre}\\n\"\n      blockEnd = \"\\n\\\\end{rstpre}\\n\\n\"\n    else:  # rnInlineCode\n      blockStart = \"\\\\rstcode{\"\n      blockEnd = \"}\"\n  dispA(d.target, result, blockStart, blockStart, [])\n  if params.lang == langNone:\n    if len(params.langStr) > 0:\n      rstMessage(d.filenames, d.msgHandler, n.info, mwUnsupportedLanguage,\n                 params.langStr)\n    for letter in m.text: escChar(d.target, result, letter, emText)\n  else:\n    renderCodeLang(result, params.lang, m.text, d.target)\n  dispA(d.target, result, blockEnd, blockEnd)\n\nproc renderContainer(d: PDoc, n: PRstNode, result: var string) =\n  var tmp = \"\"\n  renderRstToOut(d, n.sons[2], tmp)\n  var arg = esc(d.target, strip(getArgument(n)))\n  if arg == \"\":\n    dispA(d.target, result, \"<div>$1</div>\", \"$1\", [tmp])\n  else:\n    dispA(d.target, result, \"<div class=\\\"$1\\\">$2</div>\", \"$2\", [arg, tmp])\n\nproc texColumns(n: PRstNode): string =\n  let nColumns = if n.sons.len > 0: len(n.sons[0]) else: 1\n  result = \"L\".repeat(nColumns)\n\nproc renderField(d: PDoc, n: PRstNode, result: var string) =\n  var b = false\n  if d.target == outLatex:\n    var fieldname = addNodes(n.sons[0])\n    var fieldval = esc(d.target, strip(addNodes(n.sons[1])))\n    if cmpIgnoreStyle(fieldname, \"author\") == 0 or\n       cmpIgnoreStyle(fieldname, \"authors\") == 0:\n      if d.meta[metaAuthor].len == 0:\n        d.meta[metaAuthor] = fieldval\n        b = true\n    elif cmpIgnoreStyle(fieldname, \"version\") == 0:\n      if d.meta[metaVersion].len == 0:\n        d.meta[metaVersion] = fieldval\n        b = true\n  if not b:\n    renderAux(d, n, \"<tr>$1</tr>\\n\", \"$1\", result)\n\nproc renderEnumList(d: PDoc, n: PRstNode, result: var string) =\n  var\n    specifier = \"\"\n    specStart = \"\"\n    i1 = 0\n    pre = \"\"\n    i2 = n.labelFmt.len - 1\n    post = \"\"\n  if n.labelFmt[0] == '(':\n    i1 = 1\n    pre = \"(\"\n  if n.labelFmt[^1] == ')' or n.labelFmt[^1] == '.':\n    i2 = n.labelFmt.len - 2\n    post = $n.labelFmt[^1]\n  let enumR = i1 .. i2  # enumerator range without surrounding (, ), .\n  if d.target == outLatex:\n    result.add (\"\\n%\" & n.labelFmt & \"\\n\")\n    # use enumerate parameters from package enumitem\n    if n.labelFmt[i1].isDigit:\n      var labelDef = \"\"\n      if pre != \"\" or post != \"\":\n        labelDef = \"label=\" & pre & \"\\\\arabic*\" & post & \",\"\n      if n.labelFmt[enumR] != \"1\":\n        specStart = \"start=$1\" % [n.labelFmt[enumR]]\n      if labelDef != \"\" or specStart != \"\":\n        specifier = \"[$1$2]\" % [labelDef, specStart]\n    else:\n      let (first, labelDef) =\n        if n.labelFmt[i1].isUpperAscii: ('A', \"label=\" & pre & \"\\\\Alph*\" & post)\n        else: ('a', \"label=\" & pre & \"\\\\alph*\" & post)\n      if n.labelFmt[i1] != first:\n        specStart = \",start=\" & $(ord(n.labelFmt[i1]) - ord(first) + 1)\n      specifier = \"[$1$2]\" % [labelDef, specStart]\n  else:  # HTML\n    # TODO: implement enumerator formatting using pre and post ( and ) for HTML\n    if n.labelFmt[i1].isDigit:\n      if n.labelFmt[enumR] != \"1\":\n        specStart = \" start=\\\"$1\\\"\" % [n.labelFmt[enumR]]\n      specifier = \"class=\\\"simple\\\"\" & specStart\n    else:\n      let (first, labelDef) =\n        if n.labelFmt[i1].isUpperAscii: ('A', \"class=\\\"upperalpha simple\\\"\")\n        else: ('a', \"class=\\\"loweralpha simple\\\"\")\n      if n.labelFmt[i1] != first:\n        specStart = \" start=\\\"$1\\\"\" % [ $(ord(n.labelFmt[i1]) - ord(first) + 1) ]\n      specifier = labelDef & specStart\n  renderAux(d, n, \"<ol$2 \" & specifier & \">$1</ol>\\n\",\n            \"\\\\begin{enumerate}\" & specifier & \"$2$1\\\\end{enumerate}\\n\",\n            result)\n\nproc renderAdmonition(d: PDoc, n: PRstNode, result: var string) =\n  var\n    htmlCls = \"admonition_warning\"\n    texSz = \"\\\\large\"\n    texColor = \"orange\"\n  case n.adType\n  of \"hint\", \"note\", \"tip\":\n    htmlCls = \"admonition-info\"; texSz = \"\\\\normalsize\"; texColor = \"green\"\n  of \"attention\", \"admonition\", \"important\", \"warning\", \"caution\":\n    htmlCls = \"admonition-warning\"; texSz = \"\\\\large\"; texColor = \"orange\"\n  of \"danger\", \"error\":\n    htmlCls = \"admonition-error\"; texSz = \"\\\\Large\"; texColor = \"red\"\n  else: discard\n  let txt = n.adType.capitalizeAscii()\n  let htmlHead = \"<div class=\\\"admonition \" & htmlCls & \"\\\">\"\n  renderAux(d, n,\n      htmlHead & \"<span$2 class=\\\"\" & htmlCls & \"-text\\\"><b>\" & txt &\n        \":</b></span>\\n\" & \"$1</div>\\n\",\n      \"\\n\\n\\\\begin{rstadmonition}[borderline west={0.2em}{0pt}{\" &\n        texColor & \"}]$2\\n\" &\n        \"{\" & texSz & \"\\\\color{\" & texColor & \"}{\\\\textbf{\" & txt & \":}}} \" &\n        \"$1\\n\\\\end{rstadmonition}\\n\",\n      result)\n\nproc renderHyperlink(d: PDoc, text, link: PRstNode, result: var string, external: bool) =\n  var linkStr = \"\"\n  block:\n    let mode = d.escMode\n    d.escMode = emUrl\n    renderRstToOut(d, link, linkStr)\n    d.escMode = mode\n  var textStr = \"\"\n  renderRstToOut(d, text, textStr)\n  if external:\n    dispA(d.target, result,\n      \"<a class=\\\"reference external\\\" href=\\\"$2\\\">$1</a>\",\n      \"\\\\href{$2}{$1}\", [textStr, linkStr])\n  else:\n    dispA(d.target, result,\n      \"<a class=\\\"reference internal\\\" href=\\\"#$2\\\">$1</a>\",\n      \"\\\\hyperlink{$2}{$1} (p.~\\\\pageref{$2})\", [textStr, linkStr])\n\nproc renderRstToOut(d: PDoc, n: PRstNode, result: var string) =\n  if n == nil: return\n  case n.kind\n  of rnInner: renderAux(d, n, result)\n  of rnHeadline, rnMarkdownHeadline: renderHeadline(d, n, result)\n  of rnOverline: renderOverline(d, n, result)\n  of rnTransition: renderAux(d, n, \"<hr$2 />\\n\", \"\\n\\n\\\\vspace{0.6em}\\\\hrule$2\\n\", result)\n  of rnParagraph: renderAux(d, n, \"<p$2>$1</p>\\n\", \"\\n\\n$2\\n$1\\n\\n\", result)\n  of rnBulletList:\n    renderAux(d, n, \"<ul$2 class=\\\"simple\\\">$1</ul>\\n\",\n                    \"\\\\begin{itemize}\\n$2\\n$1\\\\end{itemize}\\n\", result)\n  of rnBulletItem, rnEnumItem:\n    renderAux(d, n, \"<li$2>$1</li>\\n\", \"\\\\item $2$1\\n\", result)\n  of rnEnumList: renderEnumList(d, n, result)\n  of rnDefList:\n    renderAux(d, n, \"<dl$2 class=\\\"docutils\\\">$1</dl>\\n\",\n                    \"\\\\begin{description}\\n$2\\n$1\\\\end{description}\\n\", result)\n  of rnDefItem: renderAux(d, n, result)\n  of rnDefName: renderAux(d, n, \"<dt$2>$1</dt>\\n\", \"$2\\\\item[$1]\\\\  \", result)\n  of rnDefBody: renderAux(d, n, \"<dd$2>$1</dd>\\n\", \"$2\\n$1\\n\", result)\n  of rnFieldList:\n    var tmp = \"\"\n    for i in countup(0, len(n) - 1):\n      renderRstToOut(d, n.sons[i], tmp)\n    if tmp.len != 0:\n      dispA(d.target, result,\n          \"<table$2 class=\\\"docinfo\\\" frame=\\\"void\\\" rules=\\\"none\\\">\" &\n          \"<col class=\\\"docinfo-name\\\" />\" &\n          \"<col class=\\\"docinfo-content\\\" />\" &\n          \"<tbody valign=\\\"top\\\">$1\" &\n          \"</tbody></table>\",\n          \"\\\\begin{description}\\n$2\\n$1\\\\end{description}\\n\",\n          [tmp, n.anchor.idS])\n  of rnField: renderField(d, n, result)\n  of rnFieldName:\n    renderAux(d, n, \"<th class=\\\"docinfo-name\\\">$1:</th>\",\n                    \"\\\\item[$1:]\", result)\n  of rnFieldBody:\n    renderAux(d, n, \"<td>$1</td>\", \" $1\\n\", result)\n  of rnIndex:\n    renderRstToOut(d, n.sons[2], result)\n  of rnOptionList:\n    renderAux(d, n, \"<div$2 class=\\\"option-list\\\">$1</div>\",\n        \"\\\\begin{rstoptlist}$2\\n$1\\\\end{rstoptlist}\", result)\n  of rnOptionListItem:\n    var addclass = if n.order mod 2 == 1: \" odd\" else: \"\"\n    renderAux(d, n,\n        \"<div class=\\\"option-list-item\" & addclass & \"\\\">$1</div>\\n\",\n        \"$1\", result)\n  of rnOptionGroup:\n    renderAux(d, n,\n        \"<div class=\\\"option-list-label\\\"><tt><span class=\\\"option\\\">\" &\n        \"$1</span></tt></div>\",\n        \"\\\\item[\\\\rstcodeitem{\\\\spanoption{$1}}]\", result)\n  of rnDescription:\n    renderAux(d, n, \"<div class=\\\"option-list-description\\\">$1</div>\",\n        \" $1\\n\", result)\n  of rnOption, rnOptionString, rnOptionArgument:\n    doAssert false, \"renderRstToOut\"\n  of rnLiteralBlock:\n    renderAux(d, n, \"<pre$2>$1</pre>\\n\",\n                    \"\\n\\n$2\\\\begin{rstpre}\\n$1\\n\\\\end{rstpre}\\n\\n\", result)\n  of rnQuotedLiteralBlock:\n    doAssert false, \"renderRstToOut\"\n  of rnLineBlock:\n    if n.sons.len == 1 and n.sons[0].lineIndent == \"\\n\":\n      # whole line block is one empty line, no need to add extra spacing\n      renderAux(d, n, \"<p$2>$1</p> \", \"\\n\\n$2\\n$1\", result)\n    else:  # add extra spacing around the line block for Latex\n      renderAux(d, n, \"<p$2>$1</p>\",\n        \"\\n\\\\vspace{0.5em}$2\\n$1\\\\vspace{0.5em}\\n\", result)\n  of rnLineBlockItem:\n    if n.lineIndent.len == 0:  # normal case - no additional indentation\n      renderAux(d, n, \"$1<br/>\", \"\\\\noindent $1\\n\\n\", result)\n    elif n.lineIndent == \"\\n\":  # add one empty line\n      renderAux(d, n, \"<br/>\", \"\\\\vspace{1em}\\n\", result)\n    else:  # additional indentation w.r.t. '| '\n      let indent = $(0.5 * (n.lineIndent.len - 1).toFloat) & \"em\"\n      renderAux(d, n,\n        \"<span style=\\\"margin-left: \" & indent & \"\\\">$1</span><br/>\",\n        \"\\\\noindent\\\\hspace{\" & indent & \"}$1\\n\\n\", result)\n  of rnBlockQuote:\n    renderAux(d, n, \"<blockquote$2><p>$1</p></blockquote>\\n\",\n                    \"\\\\begin{quote}\\n$2\\n$1\\\\end{quote}\\n\", result)\n  of rnAdmonition: renderAdmonition(d, n, result)\n  of rnTable, rnGridTable, rnMarkdownTable:\n    renderAux(d, n,\n      \"<table$2 border=\\\"1\\\" class=\\\"docutils\\\">$1</table>\",\n      \"\\n$2\\n\\\\begin{rsttab}{\" &\n        texColumns(n) & \"}\\n\\\\hline\\n$1\\\\end{rsttab}\", result)\n  of rnTableRow:\n    if len(n) >= 1:\n      if d.target == outLatex:\n        #var tmp = \"\"\n        renderRstToOut(d, n.sons[0], result)\n        for i in countup(1, len(n) - 1):\n          result.add(\" & \")\n          renderRstToOut(d, n.sons[i], result)\n        result.add(\"\\\\\\\\\\n\\\\hline\\n\")\n      else:\n        result.add(\"<tr>\")\n        renderAux(d, n, result)\n        result.add(\"</tr>\\n\")\n  of rnTableDataCell:\n    renderAux(d, n, \"<td>$1</td>\", \"$1\", result)\n  of rnTableHeaderCell:\n    renderAux(d, n, \"<th>$1</th>\", \"\\\\textbf{$1}\", result)\n  of rnFootnoteGroup:\n    renderAux(d, n,\n      \"<hr class=\\\"footnote\\\">\" &\n          \"<div class=\\\"footnote-group\\\">\\n$1</div>\\n\",\n      \"\\n\\n\\\\noindent\\\\rule{0.25\\\\linewidth}{.4pt}\\n\" &\n          \"\\\\begin{rstfootnote}\\n$1\\\\end{rstfootnote}\\n\\n\",\n      result)\n  of rnFootnote, rnCitation:\n    var mark = \"\"\n    renderAux(d, n.sons[0], mark)\n    var body = \"\"\n    renderRstToOut(d, n.sons[1], body)\n    dispA(d.target, result,\n      \"<div$2><div class=\\\"footnote-label\\\">\" &\n          \"<sup><strong><a href=\\\"#$4\\\">[$3]</a></strong></sup>\" &\n          \"</div> &ensp; $1\\n</div>\\n\",\n      \"\\\\item[\\\\textsuperscript{[$3]}]$2 $1\\n\",\n      [body, n.anchor.idS, mark, n.anchor])\n  of rnRef:\n    renderHyperlink(d, text=n.sons[0], link=n.sons[0], result, external=false)\n  of rnStandaloneHyperlink:\n    renderHyperlink(d, text=n.sons[0], link=n.sons[0], result, external=true)\n  of rnInternalRef:\n    renderHyperlink(d, text=n.sons[0], link=n.sons[1], result, external=false)\n  of rnHyperlink:\n    renderHyperlink(d, text=n.sons[0], link=n.sons[1], result, external=true)\n  of rnFootnoteRef:\n    var tmp = \"[\"\n    renderAux(d, n.sons[0], tmp)\n    tmp.add \"]\"\n    dispA(d.target, result,\n      \"<sup><strong><a class=\\\"reference internal\\\" href=\\\"#$2\\\">\" &\n          \"$1</a></strong></sup>\",\n      \"\\\\textsuperscript{\\\\hyperlink{$2}{\\\\textbf{$1}}}\",\n      [tmp, n.sons[1].text])\n  of rnDirArg, rnRaw: renderAux(d, n, result)\n  of rnRawHtml:\n    if d.target != outLatex and not lastSon(n).isNil:\n      result.add addNodes(lastSon(n))\n  of rnRawLatex:\n    if d.target == outLatex and not lastSon(n).isNil:\n      result.add addNodes(lastSon(n))\n\n  of rnImage, rnFigure: renderImage(d, n, result)\n  of rnCodeBlock, rnInlineCode: renderCode(d, n, result)\n  of rnContainer: renderContainer(d, n, result)\n  of rnSubstitutionReferences, rnSubstitutionDef:\n    renderAux(d, n, \"|$1|\", \"|$1|\", result)\n  of rnDirective:\n    renderAux(d, n, \"\", \"\", result)\n  of rnUnknownRole, rnCodeFragment:\n    var tmp0 = \"\"\n    var tmp1 = \"\"\n    renderRstToOut(d, n.sons[0], tmp0)\n    renderRstToOut(d, n.sons[1], tmp1)\n    var class = tmp1\n    # don't allow missing role break latex compilation:\n    if d.target == outLatex and n.kind == rnUnknownRole: class = \"Other\"\n    if n.kind == rnCodeFragment:\n      dispA(d.target, result,\n            \"<tt class=\\\"docutils literal\\\"><span class=\\\"pre $2\\\">\" &\n              \"$1</span></tt>\",\n            \"\\\\rstcode{\\\\span$2{$1}}\", [tmp0, class])\n    else:  # rnUnknownRole, not necessarily code/monospace font\n      dispA(d.target, result, \"<span class=\\\"$2\\\">$1</span>\", \"\\\\span$2{$1}\",\n            [tmp0, class])\n  of rnSub: renderAux(d, n, \"<sub>$1</sub>\", \"\\\\rstsub{$1}\", result)\n  of rnSup: renderAux(d, n, \"<sup>$1</sup>\", \"\\\\rstsup{$1}\", result)\n  of rnEmphasis: renderAux(d, n, \"<em>$1</em>\", \"\\\\emph{$1}\", result)\n  of rnStrongEmphasis:\n    renderAux(d, n, \"<strong>$1</strong>\", \"\\\\textbf{$1}\", result)\n  of rnTripleEmphasis:\n    renderAux(d, n, \"<strong><em>$1</em></strong>\",\n                    \"\\\\textbf{emph{$1}}\", result)\n  of rnIdx:\n    renderIndexTerm(d, n, result)\n  of rnInlineLiteral, rnInterpretedText:\n    renderAux(d, n,\n      \"<tt class=\\\"docutils literal\\\"><span class=\\\"pre\\\">$1</span></tt>\",\n      \"\\\\rstcode{$1}\", result)\n  of rnInlineTarget:\n    var tmp = \"\"\n    renderAux(d, n, tmp)\n    dispA(d.target, result,\n      \"<span class=\\\"target\\\" id=\\\"$2\\\">$1</span>\",\n      \"\\\\label{$2}\\\\hypertarget{$2}{$1}\",\n      [tmp, rstnodeToRefname(n)])\n  of rnSmiley: renderSmiley(d, n, result)\n  of rnLeaf: result.add(esc(d.target, n.text, escMode=d.escMode))\n  of rnContents: d.hasToc = true\n  of rnDefaultRole: discard\n  of rnTitle:\n    d.meta[metaTitle] = \"\"\n    renderRstToOut(d, n.sons[0], d.meta[metaTitle])\n\n# -----------------------------------------------------------------------------\n\nproc getVarIdx(varnames: openArray[string], id: string): int =\n  for i in countup(0, high(varnames)):\n    if cmpIgnoreStyle(varnames[i], id) == 0:\n      return i\n  result = -1\n\nproc formatNamedVars*(frmt: string, varnames: openArray[string],\n                      varvalues: openArray[string]): string =\n  var i = 0\n  var L = len(frmt)\n  result = \"\"\n  var num = 0\n  while i < L:\n    if frmt[i] == '$':\n      inc(i)                  # skip '$'\n      case frmt[i]\n      of '#':\n        add(result, varvalues[num])\n        inc(num)\n        inc(i)\n      of '$':\n        add(result, \"$\")\n        inc(i)\n      of '0'..'9':\n        var j = 0\n        while true:\n          j = (j * 10) + ord(frmt[i]) - ord('0')\n          inc(i)\n          if i > L-1 or frmt[i] notin {'0'..'9'}: break\n        if j > high(varvalues) + 1:\n          raise newException(ValueError, \"invalid index: \" & $j)\n        num = j\n        add(result, varvalues[j - 1])\n      of 'A'..'Z', 'a'..'z', '\\x80'..'\\xFF':\n        var id = \"\"\n        while true:\n          add(id, frmt[i])\n          inc(i)\n          if frmt[i] notin {'A'..'Z', '_', 'a'..'z', '\\x80'..'\\xFF'}: break\n        var idx = getVarIdx(varnames, id)\n        if idx >= 0:\n          add(result, varvalues[idx])\n        else:\n          raise newException(ValueError, \"unknown substitution var: \" & id)\n      of '{':\n        var id = \"\"\n        inc(i)\n        while frmt[i] != '}':\n          if frmt[i] == '\\0':\n            raise newException(ValueError, \"'}' expected\")\n          add(id, frmt[i])\n          inc(i)\n        inc(i)                # skip }\n                              # search for the variable:\n        var idx = getVarIdx(varnames, id)\n        if idx >= 0: add(result, varvalues[idx])\n        else:\n          raise newException(ValueError, \"unknown substitution var: \" & id)\n      else:\n        raise newException(ValueError, \"unknown substitution: $\" & $frmt[i])\n    var start = i\n    while i < L:\n      if frmt[i] != '$': inc(i)\n      else: break\n    if i-1 >= start: add(result, substr(frmt, start, i - 1))\n\n\nproc defaultConfig*(): StringTableRef =\n  ## Returns a default configuration for embedded HTML generation.\n  ##\n  ## The returned ``StringTableRef`` contains the parameters used by the HTML\n  ## engine to build the final output. For information on what these parameters\n  ## are and their purpose, please look up the file ``config/nimdoc.cfg``\n  ## bundled with the compiler.\n  ##\n  ## The only difference between the contents of that file and the values\n  ## provided by this proc is the ``doc.file`` variable. The ``doc.file``\n  ## variable of the configuration file contains HTML to build standalone\n  ## pages, while this proc returns just the content for procs like\n  ## ``rstToHtml`` to generate the bare minimum HTML.\n  result = newStringTable(modeStyleInsensitive)\n\n  template setConfigVar(key, val) =\n    result[key] = val\n\n  # If you need to modify these values, it might be worth updating the template\n  # file in config/nimdoc.cfg.\n  setConfigVar(\"split.item.toc\", \"20\")\n  setConfigVar(\"doc.section\", \"\"\"\n<div class=\"section\" id=\"$sectionID\">\n<h1><a class=\"toc-backref\" href=\"#$sectionTitleID\">$sectionTitle</a></h1>\n<dl class=\"item\">\n$content\n</dl></div>\n\"\"\")\n  setConfigVar(\"doc.section.toc\", \"\"\"\n<li>\n  <a class=\"reference\" href=\"#$sectionID\" id=\"$sectionTitleID\">$sectionTitle</a>\n  <ul class=\"simple\">\n    $content\n  </ul>\n</li>\n\"\"\")\n  setConfigVar(\"doc.item\", \"\"\"\n<dt id=\"$itemID\"><a name=\"$itemSymOrIDEnc\"></a><pre>$header</pre></dt>\n<dd>\n$desc\n</dd>\n\"\"\")\n  setConfigVar(\"doc.item.toc\", \"\"\"\n  <li><a class=\"reference\" href=\"#$itemSymOrIDEnc\"\n    title=\"$header_plain\">$name</a></li>\n\"\"\")\n  setConfigVar(\"doc.toc\", \"\"\"\n<div class=\"navigation\" id=\"navigation\">\n<ul class=\"simple\">\n$content\n</ul>\n</div>\"\"\")\n  setConfigVar(\"doc.body_toc\", \"\"\"\n$tableofcontents\n<div class=\"content\" id=\"content\">\n$moduledesc\n$content\n</div>\n\"\"\")\n  setConfigVar(\"doc.listing_start\", \"<pre$3 class = \\\"listing\\\">\")\n  setConfigVar(\"doc.listing_end\", \"</pre>\")\n  setConfigVar(\"doc.listing_button\", \"</pre>\")\n  setConfigVar(\"doc.body_no_toc\", \"$moduledesc $content\")\n  setConfigVar(\"doc.file\", \"$content\")\n  setConfigVar(\"doc.smiley_format\", \"/images/smilies/$1.gif\")\n\n# ---------- forum ---------------------------------------------------------\n\nproc rstToHtml*(s: string, options: RstParseOptions,\n                config: StringTableRef,\n                msgHandler: MsgHandler = rst.defaultMsgHandler): string =\n  ## Converts an input rst string into embeddable HTML.\n  ##\n  ## This convenience proc parses any input string using rst markup (it doesn't\n  ## have to be a full document!) and returns an embeddable piece of HTML. The\n  ## proc is meant to be used in *online* environments without access to a\n  ## meaningful filesystem, and therefore rst ``include`` like directives won't\n  ## work. For an explanation of the ``config`` parameter see the\n  ## ``initRstGenerator`` proc. Example:\n  ##\n  ## .. code-block:: nim\n  ##   import packages/docutils/rstgen, strtabs\n  ##\n  ##   echo rstToHtml(\"*Hello* **world**!\", {},\n  ##     newStringTable(modeStyleInsensitive))\n  ##   # --> <em>Hello</em> <strong>world</strong>!\n  ##\n  ## If you need to allow the rst ``include`` directive or tweak the generated\n  ## output you have to create your own ``RstGenerator`` with\n  ## ``initRstGenerator`` and related procs.\n\n  proc myFindFile(filename: string): string =\n    # we don't find any files in online mode:\n    result = \"\"\n\n  const filen = \"input\"\n  let (rst, filenames, _) = rstParse(s, filen,\n                                     line=LineRstInit, column=ColRstInit,\n                                     options, myFindFile, msgHandler)\n  var d: RstGenerator\n  initRstGenerator(d, outHtml, config, filen, myFindFile, msgHandler, filenames)\n  result = \"\"\n  renderRstToOut(d, rst, result)\n  strbasics.strip(result)\n\n\nproc rstToLatex*(rstSource: string; options: RstParseOptions): string {.inline, since: (1, 3).} =\n  ## Convenience proc for `renderRstToOut` and `initRstGenerator`.\n  runnableExamples: doAssert rstToLatex(\"*Hello* **world**\", {}) == \"\"\"\\emph{Hello} \\textbf{world}\"\"\"\n  if rstSource.len == 0: return\n  let (rst, filenames, _) = rstParse(rstSource, \"\",\n                                     line=LineRstInit, column=ColRstInit,\n                                     options)\n  var rstGenera: RstGenerator\n  rstGenera.initRstGenerator(outLatex, defaultConfig(), \"input\", filenames=filenames)\n  rstGenera.renderRstToOut(rst, result)\n  strbasics.strip(result)\n", "discard \"\"\"\noutputsub: \"\"\n\"\"\"\n\n# tests for rstgen module.\n\nimport ../../lib/packages/docutils/rstgen\nimport ../../lib/packages/docutils/rst\nimport unittest, strutils, strtabs\nimport std/private/miscdollars\n\nproc toHtml(input: string,\n            rstOptions: RstParseOptions = {roPreferMarkdown, roSupportMarkdown, roNimFile},\n            error: ref string = nil,\n            warnings: ref seq[string] = nil): string =\n  ## If `error` is nil then no errors should be generated.\n  ## The same goes for `warnings`.\n  proc testMsgHandler(filename: string, line, col: int, msgkind: MsgKind,\n                      arg: string) =\n    let mc = msgkind.whichMsgClass\n    let a = $msgkind % arg\n    var message: string\n    toLocation(message, filename, line, col + ColRstOffset)\n    message.add \" $1: $2\" % [$mc, a]\n    if mc == mcError:\n      if error == nil:\n        raise newException(EParseError, \"[unexpected error] \" & message)\n      error[] = message\n      # we check only first error because subsequent ones may be meaningless\n      raise newException(EParseError, \"\")\n    else:\n      doAssert warnings != nil, \"unexpected RST warning '\" & message & \"'\"\n      warnings[].add message\n  try:\n    result = rstToHtml(input, rstOptions, defaultConfig(),\n                       msgHandler=testMsgHandler)\n  except EParseError as e:\n    if e.msg != \"\":\n      result = e.msg\n\n# inline code tags (for parsing originated from highlite.nim)\nproc id(str: string): string = \"\"\"<span class=\"Identifier\">\"\"\"  & str & \"</span>\"\nproc op(str: string): string = \"\"\"<span class=\"Operator\">\"\"\"    & str & \"</span>\"\nproc pu(str: string): string = \"\"\"<span class=\"Punctuation\">\"\"\" & str & \"</span>\"\nproc optionListLabel(opt: string): string =\n  \"\"\"<div class=\"option-list-label\"><tt><span class=\"option\">\"\"\" &\n  opt &\n  \"</span></tt></div>\"\n\nsuite \"YAML syntax highlighting\":\n  test \"Basics\":\n    let input = \"\"\".. code-block:: yaml\n    %YAML 1.2\n    ---\n    a string: string\n    a list:\n      - item 1\n      - item 2\n    a map:\n    ? key\n    : value\n    ...\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Directive\">%YAML 1.2</span>\n<span class=\"Keyword\">---</span>\n<span class=\"StringLit\">a string</span><span class=\"Punctuation\">:</span> <span class=\"StringLit\">string</span>\n<span class=\"StringLit\">a list</span><span class=\"Punctuation\">:</span>\n  <span class=\"Punctuation\">-</span> <span class=\"StringLit\">item 1</span>\n  <span class=\"Punctuation\">-</span> <span class=\"StringLit\">item 2</span>\n<span class=\"StringLit\">a map</span><span class=\"Punctuation\">:</span>\n<span class=\"Punctuation\">?</span> <span class=\"StringLit\">key</span>\n<span class=\"Punctuation\">:</span> <span class=\"StringLit\">value</span>\n<span class=\"Keyword\">...</span></pre>\"\"\"\n\n  test \"Block scalars\":\n    let input = \"\"\".. code-block:: yaml\n    a literal block scalar: |\n      some text\n      # not a comment\n     # a comment, since less indented\n      # another comment\n    a folded block scalar: >2\n       some text\n      # not a comment since indented as specified\n     # a comment\n    another literal block scalar:\n      |+ # comment after header\n     allowed, since more indented than parent\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"StringLit\">a literal block scalar</span><span class=\"Punctuation\">:</span> <span class=\"Command\">|</span><span class=\"Command\"></span><span class=\"LongStringLit\">\n  some text\n  # not a comment\n </span><span class=\"Comment\"># a comment, since less indented</span>\n  <span class=\"Comment\"># another comment</span>\n<span class=\"StringLit\">a folded block scalar</span><span class=\"Punctuation\">:</span> <span class=\"Command\">&gt;2</span><span class=\"Command\"></span><span class=\"LongStringLit\">\n   some text\n  # not a comment since indented as specified\n </span><span class=\"Comment\"># a comment</span>\n<span class=\"StringLit\">another literal block scalar</span><span class=\"Punctuation\">:</span>\n  <span class=\"Command\">|+</span> <span class=\"Comment\"># comment after header</span><span class=\"LongStringLit\">\n allowed, since more indented than parent</span></pre>\"\"\"\n\n  test \"Directives\":\n    let input = \"\"\".. code-block:: yaml\n    %YAML 1.2\n    ---\n    %not a directive\n    ...\n    %a directive\n    ...\n    a string\n    % not a directive\n    ...\n    %TAG ! !foo:\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Directive\">%YAML 1.2</span>\n<span class=\"Keyword\">---</span>\n<span class=\"StringLit\">%not a directive</span>\n<span class=\"Keyword\">...</span>\n<span class=\"Directive\">%a directive</span>\n<span class=\"Keyword\">...</span>\n<span class=\"StringLit\">a string</span>\n<span class=\"StringLit\">% not a directive</span>\n<span class=\"Keyword\">...</span>\n<span class=\"Directive\">%TAG ! !foo:</span></pre>\"\"\"\n\n  test \"Flow Style and Numbers\":\n    let input = \"\"\".. code-block:: yaml\n    {\n      \"quoted string\": 42,\n      'single quoted string': false,\n      [ list, \"with\", 'entries' ]: 73.32e-73,\n      more numbers: [-783, 11e78],\n      not numbers: [ 42e, 0023, +32.37, 8 ball]\n    }\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Punctuation\">{</span>\n  <span class=\"StringLit\">&quot;</span><span class=\"StringLit\">quoted string&quot;</span><span class=\"Punctuation\">:</span> <span class=\"DecNumber\">42</span><span class=\"Punctuation\">,</span>\n  <span class=\"StringLit\">'single quoted string'</span><span class=\"Punctuation\">:</span> <span class=\"StringLit\">false</span><span class=\"Punctuation\">,</span>\n  <span class=\"Punctuation\">[</span> <span class=\"StringLit\">list</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;</span><span class=\"StringLit\">with&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">'entries'</span> <span class=\"Punctuation\">]</span><span class=\"Punctuation\">:</span> <span class=\"FloatNumber\">73.32e-73</span><span class=\"Punctuation\">,</span>\n  <span class=\"StringLit\">more numbers</span><span class=\"Punctuation\">:</span> <span class=\"Punctuation\">[</span><span class=\"DecNumber\">-783</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">11e78</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">,</span>\n  <span class=\"StringLit\">not numbers</span><span class=\"Punctuation\">:</span> <span class=\"Punctuation\">[</span> <span class=\"StringLit\">42e</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">0023</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">+32.37</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">8 ball</span><span class=\"Punctuation\">]</span>\n<span class=\"Punctuation\">}</span></pre>\"\"\"\n\n  test \"Directives: warnings\":\n    let input = dedent\"\"\"\n      .. non-existent-warning: Paragraph.\n\n      .. another.wrong:warning::: Paragraph.\n      \"\"\"\n    var warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    check output == \"\"\n    doAssert warnings[].len == 2\n    check \"(1, 24) Warning: RST style:\" in warnings[0]\n    check \"double colon :: may be missing at end of 'non-existent-warning'\" in warnings[0]\n    check \"(3, 25) Warning: RST style:\" in warnings[1]\n    check \"RST style: too many colons for a directive (should be ::)\" in warnings[1]\n\n  test \"not a directive\":\n    let input = \"..warning:: I am not a warning.\"\n    check input.toHtml == input\n\n  test \"Anchors, Aliases, Tags\":\n    let input = \"\"\".. code-block:: yaml\n    --- !!map\n    !!str string: !<tag:yaml.org,2002:int> 42\n    ? &anchor !!seq []:\n    : !localtag foo\n    alias: *anchor\n    \"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Keyword\">---</span> <span class=\"TagStart\">!!map</span>\n<span class=\"TagStart\">!!str</span> <span class=\"StringLit\">string</span><span class=\"Punctuation\">:</span> <span class=\"TagStart\">!&lt;tag:yaml.org,2002:int&gt;</span> <span class=\"DecNumber\">42</span>\n<span class=\"Punctuation\">?</span> <span class=\"Label\">&amp;anchor</span> <span class=\"TagStart\">!!seq</span> <span class=\"Punctuation\">[</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">:</span>\n<span class=\"Punctuation\">:</span> <span class=\"TagStart\">!localtag</span> <span class=\"StringLit\">foo</span>\n<span class=\"StringLit\">alias</span><span class=\"Punctuation\">:</span> <span class=\"Reference\">*anchor</span></pre>\"\"\"\n\n  test \"Edge cases\":\n    let input = \"\"\".. code-block:: yaml\n    ...\n     %a string:\n      a:string:not:a:map\n    ...\n    not a list:\n      -2\n      -3\n      -4\n    example.com/not/a#comment:\n      ?not a map key\n    \"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Keyword\">...</span>\n <span class=\"StringLit\">%a string</span><span class=\"Punctuation\">:</span>\n  <span class=\"StringLit\">a:string:not:a:map</span>\n<span class=\"Keyword\">...</span>\n<span class=\"StringLit\">not a list</span><span class=\"Punctuation\">:</span>\n  <span class=\"DecNumber\">-2</span>\n  <span class=\"DecNumber\">-3</span>\n  <span class=\"DecNumber\">-4</span>\n<span class=\"StringLit\">example.com/not/a#comment</span><span class=\"Punctuation\">:</span>\n  <span class=\"StringLit\">?not a map key</span></pre>\"\"\"\n\n\nsuite \"RST/Markdown general\":\n  test \"RST emphasis\":\n    doAssert rstToHtml(\"*Hello* **world**!\", {},\n      newStringTable(modeStyleInsensitive)) ==\n      \"<em>Hello</em> <strong>world</strong>!\"\n\n  test \"Markdown links\":\n    check(\"(( [Nim](https://nim-lang.org/) ))\".toHtml ==\n        \"\"\"(( <a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a> ))\"\"\")\n    check(\"(([Nim](https://nim-lang.org/)))\".toHtml ==\n        \"\"\"((<a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a>))\"\"\")\n    check(\"[[Nim](https://nim-lang.org/)]\".toHtml ==\n        \"\"\"[<a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a>]\"\"\")\n\n  test \"Markdown tables\":\n    let input1 = \"\"\"\n| A1 header    | A2 \\| not fooled\n| :---         | ----:       |\n| C1           | C2 **bold** | ignored |\n| D1 `code \\|` | D2          | also ignored\n| E1 \\| text   |\n|              | F2 without pipe\nnot in table\"\"\"\n    let output1 = input1.toHtml\n    #[\n    TODO: `\\|` inside a table cell should render as `|`\n        `|` outside a table cell should render as `\\|`\n    consistently with markdown, see https://stackoverflow.com/a/66557930/1426932\n    ]#\n    check(output1 == \"\"\"\n<table border=\"1\" class=\"docutils\"><tr><th>A1 header</th><th>A2 | not fooled</th></tr>\n<tr><td>C1</td><td>C2 <strong>bold</strong></td></tr>\n<tr><td>D1 <tt class=\"docutils literal\"><span class=\"pre\">\"\"\" & id\"code\" & \" \" & op\"\\|\" & \"\"\"</span></tt></td><td>D2</td></tr>\n<tr><td>E1 | text</td><td></td></tr>\n<tr><td></td><td>F2 without pipe</td></tr>\n</table><p>not in table</p>\"\"\")\n    let input2 = \"\"\"\n| A1 header | A2 |\n| --- | --- |\"\"\"\n    let output2 = input2.toHtml\n    doAssert output2 == \"\"\"<table border=\"1\" class=\"docutils\"><tr><th>A1 header</th><th>A2</th></tr>\n</table>\"\"\"\n\n  test \"RST tables\":\n    let input1 = \"\"\"\nTest 2 column/4 rows table:\n====   ===\nH0     H1\n====   ===\nA0     A1\n====   ===\nA2     A3\n====   ===\nA4     A5\n====   === \"\"\"\n    let output1 = rstToLatex(input1, {})\n    doAssert \"{LL}\" in output1  # 2 columns\n    doAssert count(output1, \"\\\\\\\\\") == 4  # 4 rows\n    for cell in [\"H0\", \"H1\", \"A0\", \"A1\", \"A2\", \"A3\", \"A4\", \"A5\"]:\n      doAssert cell in output1\n\n    let input2 = \"\"\"\nNow test 3 columns / 2 rows, and also borders containing 4 =, 3 =, 1 = signs:\n\n====   ===  =\nH0     H1   H\n====   ===  =\nA0     A1   X\n       Ax   Y\n====   ===  = \"\"\"\n    let output2 = rstToLatex(input2, {})\n    doAssert \"{LLL}\" in output2  # 3 columns\n    doAssert count(output2, \"\\\\\\\\\") == 2  # 2 rows\n    for cell in [\"H0\", \"H1\", \"H\", \"A0\", \"A1\", \"X\", \"Ax\", \"Y\"]:\n      doAssert cell in output2\n\n\n  test \"RST adornments\":\n    let input1 = \"\"\"\nCheck that a few punctuation symbols are not parsed as adornments:\n:word1: word2 .... word3 \"\"\"\n    let output1 = input1.toHtml\n    discard output1\n\n  test \"RST sections\":\n    let input1 = \"\"\"\nLong chapter name\n'''''''''''''''''''\n\"\"\"\n    let output1 = input1.toHtml\n    doAssert \"Long chapter name\" in output1 and \"<h1\" in output1\n\n    let input2 = \"\"\"\nShort chapter name:\n\nChA\n===\n\"\"\"\n    let output2 = input2.toHtml\n    doAssert \"ChA\" in output2 and \"<h1\" in output2\n\n    let input3 = \"\"\"\nVery short chapter name:\n\nX\n~\n\"\"\"\n    let output3 = input3.toHtml\n    doAssert \"X\" in output3 and \"<h1\" in output3\n\n    let input4 = \"\"\"\nCheck that short underline is not enough to make section:\n\nWrong chapter\n------------\n\n\"\"\"\n    var error4 = new string\n    let output4 = input4.toHtml(error = error4)\n    check(error4[] == \"input(3, 1) Error: new section expected (underline \" &\n            \"\\'------------\\' is too short)\")\n\n    let input5 = \"\"\"\nCheck that punctuation after adornment and indent are not detected as adornment.\n\nSome chapter\n--------------\n\n  \"punctuation symbols\" \"\"\"\n    let output5 = input5.toHtml\n    doAssert \"&quot;punctuation symbols&quot;\" in output5 and \"<h1\" in output5\n\n    # check that EOF after adornment does not prevent it parsing as heading\n    let input6 = dedent \"\"\"\n      Some chapter\n      ------------\"\"\"\n    let output6 = input6.toHtml\n    doAssert \"<h1 id=\\\"some-chapter\\\">Some chapter</h1>\" in output6\n\n    # check that overline and underline match\n    let input7 = dedent \"\"\"\n      ------------\n      Some chapter\n      -----------\n      \"\"\"\n    var error7 = new string\n    let output7 = input7.toHtml(error=error7)\n    check(error7[] == \"input(1, 1) Error: new section expected (underline \" &\n            \"\\'-----------\\' does not match overline \\'------------\\')\")\n\n    let input8 = dedent \"\"\"\n      -----------\n          Overflow\n      -----------\n      \"\"\"\n    var error8 = new string\n    let output8 = input8.toHtml(error=error8)\n    check(error8[] == \"input(1, 1) Error: new section expected (overline \" &\n            \"\\'-----------\\' is too short)\")\n\n    # check that hierarchy of title styles works\n    let input9good = dedent \"\"\"\n      Level1\n      ======\n\n      Level2\n      ------\n\n      Level3\n      ~~~~~~\n\n      L1\n      ==\n\n      Another2\n      --------\n\n      More3\n      ~~~~~\n\n      \"\"\"\n    let output9good = input9good.toHtml\n    doAssert \"<h1 id=\\\"level1\\\">Level1</h1>\" in output9good\n    doAssert \"<h2 id=\\\"level2\\\">Level2</h2>\" in output9good\n    doAssert \"<h3 id=\\\"level3\\\">Level3</h3>\" in output9good\n    doAssert \"<h1 id=\\\"l1\\\">L1</h1>\" in output9good\n    doAssert \"<h2 id=\\\"another2\\\">Another2</h2>\" in output9good\n    doAssert \"<h3 id=\\\"more3\\\">More3</h3>\" in output9good\n\n    # check that swap causes an exception\n    let input9Bad = dedent \"\"\"\n      Level1\n      ======\n\n      Level2\n      ------\n      \n      Level3\n      ~~~~~~\n\n      L1\n      ==\n\n      More\n      ~~~~\n      \n      Another\n      -------\n\n      \"\"\"\n    var error9Bad = new string\n    let output9Bad = input9bad.toHtml(error=error9Bad)\n    check(error9Bad[] == \"input(15, 1) Error: new section expected (section \" &\n            \"level inconsistent: underline ~~~~~ unexpectedly found, while \" &\n            \"the following intermediate section level(s) are missing on \" &\n            \"lines 12..15: underline -----)\")\n\n  test \"RST sections overline\":\n    # the same as input9good but with overline headings\n    # first overline heading has a special meaning: document title\n    let input = dedent \"\"\"\n      ======\n      Title0\n      ======\n\n      +++++++++\n      SubTitle0\n      +++++++++\n\n      ------\n      Level1\n      ------\n\n      Level2\n      ------\n\n      ~~~~~~\n      Level3\n      ~~~~~~\n\n      --\n      L1\n      --\n\n      Another2\n      --------\n\n      ~~~~~\n      More3\n      ~~~~~\n\n      \"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames = files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"Title0\"\n    doAssert rstGenera.meta[metaSubTitle] == \"SubTitle0\"\n    doAssert \"<h1 id=\\\"level1\\\"><center>Level1</center></h1>\" in output\n    doAssert \"<h2 id=\\\"level2\\\">Level2</h2>\" in output\n    doAssert \"<h3 id=\\\"level3\\\"><center>Level3</center></h3>\" in output\n    doAssert \"<h1 id=\\\"l1\\\"><center>L1</center></h1>\" in output\n    doAssert \"<h2 id=\\\"another2\\\">Another2</h2>\" in output\n    doAssert \"<h3 id=\\\"more3\\\"><center>More3</center></h3>\" in output\n\n  test \"RST sections overline 2\":\n    # check that a paragraph prevents interpreting overlines as document titles\n    let input = dedent \"\"\"\n      Paragraph\n\n      ======\n      Title0\n      ======\n\n      +++++++++\n      SubTitle0\n      +++++++++\n      \"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames=files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"\"\n    doAssert rstGenera.meta[metaSubTitle] == \"\"\n    doAssert \"<h1 id=\\\"title0\\\"><center>Title0</center></h1>\" in output\n    doAssert \"<h2 id=\\\"subtitle0\\\"><center>SubTitle0</center></h2>\" in output\n\n  test \"RST+Markdown sections\":\n    # check that RST and Markdown headings don't interfere\n    let input = dedent \"\"\"\n      ======\n      Title0\n      ======\n\n      MySection1a\n      +++++++++++\n\n      # MySection1b\n\n      MySection1c\n      +++++++++++\n\n      ##### MySection5a\n\n      MySection2a\n      -----------\n      \"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {roSupportMarkdown})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames=files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"Title0\"\n    doAssert rstGenera.meta[metaSubTitle] == \"\"\n    doAssert output ==\n             \"\\n<h1 id=\\\"mysection1a\\\">MySection1a</h1>\" & # RST\n             \"\\n<h1 id=\\\"mysection1b\\\">MySection1b</h1>\" & # Markdown\n             \"\\n<h1 id=\\\"mysection1c\\\">MySection1c</h1>\" & # RST\n             \"\\n<h5 id=\\\"mysection5a\\\">MySection5a</h5>\" & # Markdown\n             \"\\n<h2 id=\\\"mysection2a\\\">MySection2a</h2>\"   # RST\n\n  test \"RST inline text\":\n    let input1 = \"GC_step\"\n    let output1 = input1.toHtml\n    doAssert output1 == \"GC_step\"\n\n  test \"RST links\":\n    let input1 = \"\"\"\nWant to learn about `my favorite programming language`_?\n\n.. _my favorite programming language: https://nim-lang.org\"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<a\" in output1 and \"href=\\\"https://nim-lang.org\\\"\" in output1\n\n  test \"RST transitions\":\n    let input1 = \"\"\"\ncontext1\n\n~~~~\n\ncontext2\n\"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<hr\" in output1\n\n    let input2 = \"\"\"\nThis is too short to be a transition:\n\n---\n\ncontext2\n\"\"\"\n    var error2 = new string\n    let output2 = input2.toHtml(error=error2)\n    check(error2[] == \"input(3, 1) Error: new section expected (overline \" &\n            \"\\'---\\' is too short)\")\n\n  test \"RST literal block\":\n    let input1 = \"\"\"\nTest literal block\n\n::\n\n  check \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<pre>\" in output1\n\n  test \"Markdown code block\":\n    let input1 = \"\"\"\n```\nlet x = 1\n``` \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<pre\" in output1 and \"class=\\\"Keyword\\\"\" notin output1\n\n    let input2 = \"\"\"\nParse the block with language specifier:\n```Nim\nlet x = 1\n``` \"\"\"\n    let output2 = input2.toHtml\n    doAssert \"<pre\" in output2 and \"class=\\\"Keyword\\\"\" in output2\n\n  test \"interpreted text\":\n    check(\"\"\"`foo.bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"foo\" & op\".\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`foo\\`\\`bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"foo\" & pu\"`\" & pu\"`\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`foo\\`bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"foo\" & pu\"`\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`\\`bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      pu\"`\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`a\\b\\x\\\\ar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"a\" & op\"\"\"\\\"\"\" & id\"b\" & op\"\"\"\\\"\"\" & id\"x\" & op\"\"\"\\\\\"\"\" & id\"ar\" &\n      \"</span></tt>\")\n\n  test \"inline literal\":\n    check \"\"\"``foo.bar``\"\"\".toHtml == \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">foo.bar</span></tt>\"\"\"\n    check \"\"\"``foo\\bar``\"\"\".toHtml == \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">foo\\bar</span></tt>\"\"\"\n    check \"\"\"``f\\`o\\\\o\\b`ar``\"\"\".toHtml == \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">f\\`o\\\\o\\b`ar</span></tt>\"\"\"\n\n  test \"default-role\":\n    # nim(default) -> literal -> nim -> code(=literal)\n    let input = dedent\"\"\"\n      Par1 `value1`.\n\n      .. default-role:: literal\n\n      Par2 `value2`.\n\n      .. default-role:: nim\n\n      Par3 `value3`.\n\n      .. default-role:: code\n\n      Par4 `value4`.\"\"\"\n    let p1 = \"\"\"Par1 <tt class=\"docutils literal\"><span class=\"pre\">\"\"\" & id\"value1\" & \"</span></tt>.\"\n    let p2 = \"\"\"<p>Par2 <tt class=\"docutils literal\"><span class=\"pre\">value2</span></tt>.</p>\"\"\"\n    let p3 = \"\"\"<p>Par3 <tt class=\"docutils literal\"><span class=\"pre\">\"\"\" & id\"value3\" & \"</span></tt>.</p>\"\n    let p4 = \"\"\"<p>Par4 <tt class=\"docutils literal\"><span class=\"pre\">value4</span></tt>.</p>\"\"\"\n    let expected = p1 & p2 & \"\\n\" & p3 & \"\\n\" & p4\n    check(input.toHtml == expected)\n\n  test \"role directive\":\n    let input = dedent\"\"\"\n      .. role:: y(code)\n         :language: yaml\n\n      .. role:: brainhelp(code)\n         :language: brainhelp\n    \"\"\"\n    var warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    check(warnings[].len == 1 and \"language 'brainhelp' not supported\" in warnings[0])\n\n  test \"RST comments\":\n    let input1 = \"\"\"\n\nCheck that comment disappears:\n\n..\n  some comment \"\"\"\n    let output1 = input1.toHtml\n    doAssert output1 == \"Check that comment disappears:\"\n\n  test \"RST line blocks + headings\":\n    let input = \"\"\"\n=====\nTest1\n=====\n\n|\n|\n| line block\n| other line\n\n\"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames=files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"Test1\"\n      # check that title was not overwritten to '|'\n    doAssert output == \"<p><br/><br/>line block<br/>other line<br/></p>\"\n    let output1l = rstToLatex(input, {})\n    doAssert \"line block\\n\\n\" in output1l\n    doAssert \"other line\\n\\n\" in output1l\n    doAssert output1l.count(\"\\\\vspace\") == 2 + 2  # +2 surrounding paddings\n\n  test \"RST line blocks\":\n    let input2 = dedent\"\"\"\n      Paragraph1\n      \n      |\n\n      Paragraph2\"\"\"\n\n    let output2 = input2.toHtml\n    doAssert \"Paragraph1<p><br/></p> <p>Paragraph2</p>\" == output2\n\n    let input3 = dedent\"\"\"\n      | xxx\n      |   yyy\n      |     zzz\"\"\"\n\n    let output3 = input3.toHtml\n    doAssert \"xxx<br/>\" in output3\n    doAssert \"<span style=\\\"margin-left: 1.0em\\\">yyy</span><br/>\" in output3\n    doAssert \"<span style=\\\"margin-left: 2.0em\\\">zzz</span><br/>\" in output3\n\n    # check that '|   ' with a few spaces is still parsed as new line\n    let input4 = dedent\"\"\"\n      | xxx\n      |      \n      |     zzz\"\"\"\n\n    let output4 = input4.toHtml\n    doAssert \"xxx<br/><br/>\" in output4\n    doAssert \"<span style=\\\"margin-left: 2.0em\\\">zzz</span><br/>\" in output4\n\n  test \"RST enumerated lists\":\n    let input1 = dedent \"\"\"\n      1. line1\n         1\n      2. line2\n         2\n\n      3. line3\n         3\n\n\n      4. line4\n         4\n\n\n\n      5. line5\n         5\n      \"\"\"\n    let output1 = input1.toHtml\n    for i in 1..5:\n      doAssert ($i & \". line\" & $i) notin output1\n      doAssert (\"<li>line\" & $i & \" \" & $i & \"</li>\") in output1\n\n    let input2 = dedent \"\"\"\n      3. line3\n\n      4. line4\n\n\n      5. line5\n\n\n\n      7. line7\n\n\n\n\n      8. line8\n      \"\"\"\n    let output2 = input2.toHtml\n    for i in [3, 4, 5, 7, 8]:\n      doAssert ($i & \". line\" & $i) notin output2\n      doAssert (\"<li>line\" & $i & \"</li>\") in output2\n\n    # check that nested enumerated lists work\n    let input3 = dedent \"\"\"\n      1.  a) string1\n      2. string2\n      \"\"\"\n    let output3 = input3.toHtml\n    doAssert count(output3, \"<ol \") == 2\n    doAssert count(output3, \"</ol>\") == 2\n    doAssert \"<li>string1</li>\" in output3 and \"<li>string2</li>\" in output3\n\n    let input4 = dedent \"\"\"\n      Check that enumeration specifiers are respected\n\n      9. string1\n      10. string2\n      12. string3\n\n      b) string4\n      c) string5\n      e) string6\n      \"\"\"\n    let output4 = input4.toHtml\n    doAssert count(output4, \"<ol \") == 4\n    doAssert count(output4, \"</ol>\") == 4\n    for enumerator in [9, 12]:\n      doAssert \"start=\\\"$1\\\"\" % [$enumerator] in output4\n    for enumerator in [2, 5]:  # 2=b, 5=e\n      doAssert \"start=\\\"$1\\\"\" % [$enumerator] in output4\n\n    let input5 = dedent \"\"\"\n      Check that auto-numbered enumeration lists work.\n\n      #. string1\n\n      #. string2\n\n      #. string3\n\n      #) string5\n      #) string6\n      \"\"\"\n    let output5 = input5.toHtml\n    doAssert count(output5, \"<ol \") == 2\n    doAssert count(output5, \"</ol>\") == 2\n    doAssert count(output5, \"<li>\") == 5\n\n    let input5a = dedent \"\"\"\n      Auto-numbered RST list can start with 1 even when Markdown support is on.\n\n      1. string1\n      #. string2\n      #. string3\n      \"\"\"\n    let output5a = input5a.toHtml\n    doAssert count(output5a, \"<ol \") == 1\n    doAssert count(output5a, \"</ol>\") == 1\n    doAssert count(output5a, \"<li>\") == 3\n\n    let input6 = dedent \"\"\"\n      ... And for alphabetic enumerators too!\n\n      b. string1\n      #. string2\n      #. string3\n      \"\"\"\n    let output6 = input6.toHtml\n    doAssert count(output6, \"<ol \") == 1\n    doAssert count(output6, \"</ol>\") == 1\n    doAssert count(output6, \"<li>\") == 3\n    doAssert \"start=\\\"2\\\"\" in output6 and \"class=\\\"loweralpha simple\\\"\" in output6\n\n    let input7 = dedent \"\"\"\n      ... And for uppercase alphabetic enumerators.\n\n      C. string1\n      #. string2\n      #. string3\n      \"\"\"\n    let output7 = input7.toHtml\n    doAssert count(output7, \"<ol \") == 1\n    doAssert count(output7, \"</ol>\") == 1\n    doAssert count(output7, \"<li>\") == 3\n    doAssert \"start=\\\"3\\\"\" in output7 and \"class=\\\"upperalpha simple\\\"\" in output7\n\n    # check that it's not recognized as enum.list without indentation on 2nd line\n    let input8 = dedent \"\"\"\n      Paragraph.\n\n      A. stringA\n      B. stringB\n      C. string1\n      string2\n      \"\"\"\n    var warnings8 = new seq[string]\n    let output8 = input8.toHtml(warnings = warnings8)\n    check(warnings8[].len == 1)\n    check(\"input(6, 1) Warning: RST style: \\n\" &\n          \"not enough indentation on line 6\" in warnings8[0])\n    doAssert output8 == \"Paragraph.<ol class=\\\"upperalpha simple\\\">\" &\n        \"<li>stringA</li>\\n<li>stringB</li>\\n</ol>\\n<p>C. string1 string2 </p>\"\n\n  test \"Markdown enumerated lists\":\n    let input1 = dedent \"\"\"\n      Below are 2 enumerated lists: Markdown-style (5 items) and RST (1 item)\n      1. line1\n      1. line2\n      1. line3\n      1. line4\n\n      1. line5\n\n      #. lineA\n      \"\"\"\n    let output1 = input1.toHtml\n    for i in 1..5:\n      doAssert ($i & \". line\" & $i) notin output1\n      doAssert (\"<li>line\" & $i & \"</li>\") in output1\n    doAssert count(output1, \"<ol \") == 2\n    doAssert count(output1, \"</ol>\") == 2\n\n  test \"RST bullet lists\":\n    let input1 = dedent \"\"\"\n      * line1\n        1\n      * line2\n        2\n\n      * line3\n        3\n\n\n      * line4\n        4\n\n\n\n      * line5\n        5\n      \"\"\"\n    let output1 = input1.toHtml\n    for i in 1..5:\n      doAssert (\"<li>line\" & $i & \" \" & $i & \"</li>\") in output1\n    doAssert count(output1, \"<ul \") == 1\n    doAssert count(output1, \"</ul>\") == 1\n\n  test \"Nim RST footnotes and citations\":\n    # check that auto-label footnote enumerated properly after a manual one\n    let input1 = dedent \"\"\"\n      .. [1] Body1.\n      .. [#note] Body2\n\n      Ref. [#note]_\n      \"\"\"\n    let output1 = input1.toHtml\n    doAssert output1.count(\">[1]</a>\") == 1\n    doAssert output1.count(\">[2]</a>\") == 2\n    doAssert \"href=\\\"#footnote-note\\\"\" in output1\n    doAssert \">[-1]\" notin output1\n    doAssert \"Body1.\" in output1\n    doAssert \"Body2\" in output1\n\n    # check that there are NO footnotes/citations, only comments:\n    let input2 = dedent \"\"\"\n      .. [1 #] Body1.\n      .. [# note] Body2.\n      .. [wrong citation] That gives you a comment.\n\n      .. [not&allowed] That gives you a comment.\n\n      Not references[#note]_[1 #]_ [wrong citation]_ and [not&allowed]_.\n      \"\"\"\n    let output2 = input2.toHtml\n    doAssert output2 == \"Not references[#note]_[1 #]_ [wrong citation]_ and [not&amp;allowed]_.\"\n\n    # check that auto-symbol footnotes work:\n    let input3 = dedent \"\"\"\n      Ref. [*]_ and [*]_ and [*]_.\n\n      .. [*] Body1\n      .. [*] Body2.\n\n\n      .. [*] Body3.\n      .. [*] Body4\n\n      And [*]_.\n      \"\"\"\n    let output3 = input3.toHtml\n    # both references and footnotes. Footnotes have link to themselves.\n    doAssert output3.count(\"href=\\\"#footnotesym-1\\\">[*]</a>\") == 2\n    doAssert output3.count(\"href=\\\"#footnotesym-2\\\">[**]</a>\") == 2\n    doAssert output3.count(\"href=\\\"#footnotesym-3\\\">[***]</a>\") == 2\n    doAssert output3.count(\"href=\\\"#footnotesym-4\\\">[^]</a>\") == 2\n    # footnote group\n    doAssert output3.count(\"<hr class=\\\"footnote\\\">\" &\n                           \"<div class=\\\"footnote-group\\\">\") == 1\n    # footnotes\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-1\\\">[*]</a></strong></sup></div>\") == 1\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-2\\\">[**]</a></strong></sup></div>\") == 1\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-3\\\">[***]</a></strong></sup></div>\") == 1\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-4\\\">[^]</a></strong></sup></div>\") == 1\n    for i in 1 .. 4: doAssert (\"Body\" & $i) in output3\n\n    # check manual, auto-number and auto-label footnote enumeration\n    let input4 = dedent \"\"\"\n      .. [3] Manual1.\n      .. [#] Auto-number1.\n      .. [#mylabel] Auto-label1.\n      .. [#note] Auto-label2.\n      .. [#] Auto-number2.\n\n      Ref. [#note]_ and [#]_ and [#]_.\n      \"\"\"\n    let output4 = input4.toHtml\n    doAssert \">[-1]\" notin output1\n    let order = @[\n        \"footnote-3\", \"[3]\", \"Manual1.\",\n        \"footnoteauto-1\", \"[1]\", \"Auto-number1\",\n        \"footnote-mylabel\", \"[2]\", \"Auto-label1\",\n        \"footnote-note\", \"[4]\", \"Auto-label2\",\n        \"footnoteauto-2\", \"[5]\", \"Auto-number2\",\n        ]\n    for i in 0 .. order.len-2:\n      let pos1 = output4.find(order[i])\n      let pos2 = output4.find(order[i+1])\n      doAssert pos1 >= 0\n      doAssert pos2 >= 0\n      doAssert pos1 < pos2\n\n    # forgot [#]_\n    let input5 = dedent \"\"\"\n      .. [3] Manual1.\n      .. [#] Auto-number1.\n      .. [#note] Auto-label2.\n\n      Ref. [#note]_\n      \"\"\"\n    var error5 = new string\n    let output5 = input5.toHtml(error=error5)\n    check(error5[] == \"input(1, 1) Error: mismatch in number of footnotes \" &\n            \"and their refs: 1 (lines 2) != 0 (lines ) for auto-numbered \" &\n            \"footnotes\")\n\n    # extra [*]_\n    let input6 = dedent \"\"\"\n      Ref. [*]_\n\n      .. [*] Auto-Symbol.\n\n      Ref. [*]_\n      \"\"\"\n    var error6 = new string\n    let output6 = input6.toHtml(error=error6)\n    check(error6[] == \"input(1, 1) Error: mismatch in number of footnotes \" &\n            \"and their refs: 1 (lines 3) != 2 (lines 2, 6) for auto-symbol \" &\n            \"footnotes\")\n\n    let input7 = dedent \"\"\"\n      .. [Some:CITATION-2020] Citation.\n\n      Ref. [some:citation-2020]_.\n      \"\"\"\n    let output7 = input7.toHtml\n    doAssert output7.count(\"href=\\\"#citation-somecoloncitationminus2020\\\"\") == 2\n    doAssert output7.count(\"[Some:CITATION-2020]\") == 1\n    doAssert output7.count(\"[some:citation-2020]\") == 1\n    doAssert output3.count(\"<hr class=\\\"footnote\\\">\" &\n                           \"<div class=\\\"footnote-group\\\">\") == 1\n\n    let input8 = dedent \"\"\"\n      .. [Some] Citation.\n\n      Ref. [som]_.\n      \"\"\"\n    var warnings8 = new seq[string]\n    let output8 = input8.toHtml(warnings=warnings8)\n    check(warnings8[] == @[\"input(3, 7) Warning: broken link 'citation-som'\"])\n\n    # check that footnote group does not break parsing of other directives:\n    let input9 = dedent \"\"\"\n      .. [Some] Citation.\n\n      .. _`internal anchor`:\n\n      .. [Another] Citation.\n      .. just comment.\n      .. [Third] Citation.\n\n      Paragraph1.\n\n      Paragraph2 ref `internal anchor`_.\n      \"\"\"\n    let output9 = input9.toHtml\n    #doAssert \"id=\\\"internal-anchor\\\"\" in output9\n    #doAssert \"internal anchor\" notin output9\n    doAssert output9.count(\"<hr class=\\\"footnote\\\">\" &\n                           \"<div class=\\\"footnote-group\\\">\") == 1\n    doAssert output9.count(\"<div class=\\\"footnote-label\\\">\") == 3\n    doAssert \"just comment\" notin output9\n\n    # check that nested citations/footnotes work\n    let input10 = dedent \"\"\"\n      Paragraph1 [#]_.\n\n      .. [First] Citation.\n\n         .. [#] Footnote.\n\n            .. [Third] Citation.\n      \"\"\"\n    let output10 = input10.toHtml\n    doAssert output10.count(\"<hr class=\\\"footnote\\\">\" &\n                            \"<div class=\\\"footnote-group\\\">\") == 3\n    doAssert output10.count(\"<div class=\\\"footnote-label\\\">\") == 3\n    doAssert \"<a href=\\\"#citation-first\\\">[First]</a>\" in output10\n    doAssert \"<a href=\\\"#footnoteauto-1\\\">[1]</a>\" in output10\n    doAssert \"<a href=\\\"#citation-third\\\">[Third]</a>\" in output10\n\n    let input11 = \".. [note]\\n\"  # should not crash\n    let output11 = input11.toHtml\n    doAssert \"<a href=\\\"#citation-note\\\">[note]</a>\" in output11\n\n    # check that references to auto-numbered footnotes work\n    let input12 = dedent \"\"\"\n      Ref. [#]_ and [#]_ STOP.\n\n      .. [#] Body1.\n      .. [#] Body3\n      .. [2] Body2.\n      \"\"\"\n    let output12 = input12.toHtml\n    let orderAuto = @[\n        \"#footnoteauto-1\", \"[1]\",\n        \"#footnoteauto-2\", \"[3]\",\n        \"STOP.\",\n        \"Body1.\", \"Body3\", \"Body2.\"\n        ]\n    for i in 0 .. orderAuto.len-2:\n      let pos1 = output12.find(orderAuto[i])\n      let pos2 = output12.find(orderAuto[i+1])\n      doAssert pos1 >= 0\n      doAssert pos2 >= 0\n      doAssert pos1 < pos2\n\n  test \"Nim (RST extension) code-block\":\n    # check that presence of fields doesn't consume the following text as\n    # its code (which is a literal block)\n    let input0 = dedent \"\"\"\n      .. code-block:: nim\n         :number-lines: 0\n\n      Paragraph1\"\"\"\n    let output0 = input0.toHtml\n    doAssert \"<p>Paragraph1</p>\" in output0\n\n  test \"Nim code-block :number-lines:\":\n    let input = dedent \"\"\"\n      .. code-block:: nim\n         :number-lines: 55\n\n         x\n         y\n      \"\"\"\n    check \"<pre class=\\\"line-nums\\\">55\\n56\\n</pre>\" in input.toHtml\n\n  test \"Nim code-block indentation\":\n    let input = dedent \"\"\"\n      .. code-block:: nim\n        :number-lines: 55\n\n       x\n      \"\"\"\n    let output = input.toHtml\n    check \"<pre class=\\\"line-nums\\\">55\\n</pre>\" in output\n    check \"<span class=\\\"Identifier\\\">x</span>\" in output\n\n  test \"Nim code-block indentation\":\n    let input = dedent \"\"\"\n      .. code-block:: nim\n        :number-lines: 55\n         let a = 1\n      \"\"\"\n    var error = new string\n    let output = input.toHtml(error=error)\n    check(error[] == \"input(2, 3) Error: invalid field: \" &\n                     \"extra arguments were given to number-lines: ' let a = 1'\")\n    check \"\" == output\n\n  test \"code-block warning\":\n    let input = dedent \"\"\"\n      .. code:: Nim\n         :unsupportedField: anything\n\n      .. code:: unsupportedLang\n\n         anything\n\n      ```anotherLang\n      someCode\n      ```\n      \"\"\"\n    let warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    check(warnings[] == @[\n        \"input(2, 4) Warning: field 'unsupportedField' not supported\",\n        \"input(4, 11) Warning: language 'unsupportedLang' not supported\",\n        \"input(8, 4) Warning: language 'anotherLang' not supported\"\n        ])\n    check(output == \"<pre class = \\\"listing\\\">anything</pre>\" &\n                    \"<p><pre class = \\\"listing\\\">\\nsomeCode\\n</pre> </p>\")\n\n  test \"RST admonitions\":\n    # check that all admonitions are implemented\n    let input0 = dedent \"\"\"\n      .. admonition:: endOf admonition\n      .. attention:: endOf attention\n      .. caution:: endOf caution\n      .. danger:: endOf danger\n      .. error:: endOf error\n      .. hint:: endOf hint\n      .. important:: endOf important\n      .. note:: endOf note\n      .. tip:: endOf tip\n      .. warning:: endOf warning\n    \"\"\"\n    let output0 = input0.toHtml\n    for a in [\"admonition\", \"attention\", \"caution\", \"danger\", \"error\", \"hint\",\n        \"important\", \"note\", \"tip\", \"warning\" ]:\n      doAssert \"endOf \" & a & \"</div>\" in output0\n\n    # Test that admonition does not swallow up the next paragraph.\n    let input1 = dedent \"\"\"\n      .. error:: endOfError\n\n      Test paragraph.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"endOfError</div>\" in output1\n    doAssert \"<p>Test paragraph. </p>\" in output1\n    doAssert \"class=\\\"admonition admonition-error\\\"\" in output1\n\n    # Test that second line is parsed as continuation of the first line.\n    let input2 = dedent \"\"\"\n      .. error:: endOfError\n        Test2p.\n\n      Test paragraph.\n    \"\"\"\n    let output2 = input2.toHtml\n    doAssert \"endOfError Test2p.</div>\" in output2\n    doAssert \"<p>Test paragraph. </p>\" in output2\n    doAssert \"class=\\\"admonition admonition-error\\\"\" in output2\n\n    let input3 = dedent \"\"\"\n      .. note:: endOfNote\n    \"\"\"\n    let output3 = input3.toHtml\n    doAssert \"endOfNote</div>\" in output3\n    doAssert \"class=\\\"admonition admonition-info\\\"\" in output3\n\n  test \"RST internal links\":\n    let input1 = dedent \"\"\"\n      Start.\n\n      .. _target000:\n\n      Paragraph.\n\n      .. _target001:\n\n      * bullet list\n      * Y\n\n      .. _target002:\n\n      1. enumeration list\n      2. Y\n\n      .. _target003:\n\n      term 1\n        Definition list 1.\n\n      .. _target004:\n\n      | line block\n\n      .. _target005:\n\n      :a: field list value\n\n      .. _target006:\n\n      -a  option description\n\n      .. _target007:\n\n      ::\n\n        Literal block\n\n      .. _target008:\n\n      Doctest blocks are not implemented.\n\n      .. _target009:\n\n          block quote\n\n      .. _target010:\n\n      =====  =====  =======\n        A      B    A and B\n      =====  =====  =======\n      False  False  False\n      =====  =====  =======\n\n      .. _target100:\n\n      .. CAUTION:: admonition\n\n      .. _target101:\n\n      .. code:: nim\n\n         const pi = 3.14\n\n      .. _target102:\n\n      .. code-block::\n\n         const pi = 3.14\n\n      Paragraph2.\n\n      .. _target202:\n\n      ----\n\n      That was a transition.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<p id=\\\"target000\\\"\"     in output1\n    doAssert \"<ul id=\\\"target001\\\"\"    in output1\n    doAssert \"<ol id=\\\"target002\\\"\"    in output1\n    doAssert \"<dl id=\\\"target003\\\"\"    in output1\n    doAssert \"<p id=\\\"target004\\\"\"     in output1\n    doAssert \"<table id=\\\"target005\\\"\" in output1  # field list\n    doAssert \"<div id=\\\"target006\\\"\"   in output1  # option list\n    doAssert \"<pre id=\\\"target007\\\"\"   in output1\n    doAssert \"<blockquote id=\\\"target009\\\"\" in output1\n    doAssert \"<table id=\\\"target010\\\"\" in output1  # just table\n    doAssert \"<span id=\\\"target100\\\"\"  in output1\n    doAssert \"<pre id=\\\"target101\\\"\"   in output1  # code\n    doAssert \"<pre id=\\\"target102\\\"\"   in output1  # code-block\n    doAssert \"<hr id=\\\"target202\\\"\"    in output1\n\n  test \"RST internal links for sections\":\n    let input1 = dedent \"\"\"\n      .. _target101:\n      .. _target102:\n\n      Section xyz\n      -----------\n\n      Ref. target101_\n    \"\"\"\n    let output1 = input1.toHtml\n    # \"target101\" should be erased and changed to \"section-xyz\":\n    doAssert \"href=\\\"#target101\\\"\" notin output1\n    doAssert \"id=\\\"target101\\\"\"    notin output1\n    doAssert \"href=\\\"#target102\\\"\" notin output1\n    doAssert \"id=\\\"target102\\\"\"    notin output1\n    doAssert \"id=\\\"section-xyz\\\"\"     in output1\n    doAssert \"href=\\\"#section-xyz\\\"\"  in output1\n\n    let input2 = dedent \"\"\"\n      .. _target300:\n\n      Section xyz\n      ===========\n\n      .. _target301:\n\n      SubsectionA\n      -----------\n\n      Ref. target300_ and target301_.\n\n      .. _target103:\n\n      .. [cit2020] note.\n\n      Ref. target103_.\n\n    \"\"\"\n    let output2 = input2.toHtml\n    # \"target101\" should be erased and changed to \"section-xyz\":\n    doAssert \"href=\\\"#target300\\\"\" notin output2\n    doAssert \"id=\\\"target300\\\"\"    notin output2\n    doAssert \"href=\\\"#target301\\\"\" notin output2\n    doAssert \"id=\\\"target301\\\"\"    notin output2\n    doAssert \"<h1 id=\\\"section-xyz\\\"\" in output2\n    doAssert \"<h2 id=\\\"subsectiona\\\"\" in output2\n    # links should preserve their original names but point to section labels:\n    doAssert \"href=\\\"#section-xyz\\\">target300\" in output2\n    doAssert \"href=\\\"#subsectiona\\\">target301\" in output2\n    doAssert \"href=\\\"#citation-cit2020\\\">target103\" in output2\n\n    let output2l = rstToLatex(input2, {})\n    doAssert \"\\\\label{section-xyz}\\\\hypertarget{section-xyz}{}\" in output2l\n    doAssert \"\\\\hyperlink{section-xyz}{target300}\"  in output2l\n    doAssert \"\\\\hyperlink{subsectiona}{target301}\"  in output2l\n\n  test \"RST internal links (inline)\":\n    let input1 = dedent \"\"\"\n      Paragraph with _`some definition`.\n\n      Ref. `some definition`_.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<span class=\\\"target\\\" \" &\n        \"id=\\\"some-definition\\\">some definition</span>\" in output1\n    doAssert \"Ref. <a class=\\\"reference internal\\\" \" &\n        \"href=\\\"#some-definition\\\">some definition</a>\" in output1\n\n  test \"RST references (additional symbols)\":\n    # check that ., _, -, +, : are allowed symbols in references without ` `\n    let input1 = dedent \"\"\"\n      sec.1\n      -----\n\n      2-other:sec+c_2\n      ^^^^^^^^^^^^^^^\n\n      .. _link.1_2021:\n\n      Paragraph\n\n      Ref. sec.1_! and 2-other:sec+c_2_;and link.1_2021_.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"id=\\\"secdot1\\\"\" in output1\n    doAssert \"id=\\\"Z2minusothercolonsecplusc-2\\\"\" in output1\n    doAssert \"id=\\\"linkdot1-2021\\\"\" in output1\n    let ref1 = \"<a class=\\\"reference internal\\\" href=\\\"#secdot1\\\">sec.1</a>\"\n    let ref2 = \"<a class=\\\"reference internal\\\" href=\\\"#Z2minusothercolonsecplusc-2\\\">2-other:sec+c_2</a>\"\n    let ref3 = \"<a class=\\\"reference internal\\\" href=\\\"#linkdot1-2021\\\">link.1_2021</a>\"\n    let refline = \"Ref. \" & ref1 & \"! and \" & ref2 & \";and \" & ref3 & \".\"\n    doAssert refline in output1\n\n  test \"Option lists 1\":\n    # check that \"* b\" is not consumed by previous bullet item because of\n    # incorrect indentation handling in option lists\n    let input = dedent \"\"\"\n      * a\n        -m   desc\n        -n   very long\n             desc\n      * b\"\"\"\n    let output = input.toHtml\n    check(output.count(\"<ul\") == 1)\n    check(output.count(\"<li>\") == 2)\n    check(output.count(\"<div class=\\\"option-list\\\"\") == 1)\n    check(optionListLabel(\"-m\") &\n          \"\"\"<div class=\"option-list-description\">desc</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-n\") &\n          \"\"\"<div class=\"option-list-description\">very long desc</div></div>\"\"\" in\n          output)\n\n  test \"Option lists 2\":\n    # check that 2nd option list is not united with the 1st\n    let input = dedent \"\"\"\n      * a\n        -m   desc\n        -n   very long\n             desc\n      -d  option\"\"\"\n    let output = input.toHtml\n    check(output.count(\"<ul\") == 1)\n    check output.count(\"<div class=\\\"option-list\\\"\") == 2\n    check(optionListLabel(\"-m\") &\n          \"\"\"<div class=\"option-list-description\">desc</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-n\") &\n          \"\"\"<div class=\"option-list-description\">very long desc</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-d\") &\n          \"\"\"<div class=\"option-list-description\">option</div></div>\"\"\" in\n          output)\n    check \"<p>option</p>\" notin output\n\n  test \"Option list 3 (double /)\":\n    let input = dedent \"\"\"\n      * a\n        //compile  compile1\n        //doc      doc1\n                   cont\n      -d  option\"\"\"\n    let output = input.toHtml\n    check(output.count(\"<ul\") == 1)\n    check output.count(\"<div class=\\\"option-list\\\"\") == 2\n    check(optionListLabel(\"compile\") &\n          \"\"\"<div class=\"option-list-description\">compile1</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"doc\") &\n          \"\"\"<div class=\"option-list-description\">doc1 cont</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-d\") &\n          \"\"\"<div class=\"option-list-description\">option</div></div>\"\"\" in\n          output)\n    check \"<p>option</p>\" notin output\n\n  test \"Roles: subscript prefix/postfix\":\n    let expected = \"See <sub>some text</sub>.\"\n    check \"See :subscript:`some text`.\".toHtml == expected\n    check \"See `some text`:subscript:.\".toHtml == expected\n\n  test \"Roles: correct parsing from beginning of line\":\n    let expected = \"<sup>3</sup>He is an isotope of helium.\"\n    check \"\"\":superscript:`3`\\ He is an isotope of helium.\"\"\".toHtml == expected\n    check \"\"\":sup:`3`\\ He is an isotope of helium.\"\"\".toHtml == expected\n    check \"\"\"`3`:sup:\\ He is an isotope of helium.\"\"\".toHtml == expected\n    check \"\"\"`3`:superscript:\\ He is an isotope of helium.\"\"\".toHtml == expected\n\n  test \"Roles: warnings\":\n    let input = dedent\"\"\"\n      See function :py:func:`spam`.\n\n      See also `egg`:py:class:.\n      \"\"\"\n    var warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    doAssert warnings[].len == 2\n    check \"(1, 14) Warning: \" in warnings[0]\n    check \"language 'py:func' not supported\" in warnings[0]\n    check \"(3, 15) Warning: \" in warnings[1]\n    check \"language 'py:class' not supported\" in warnings[1]\n    check(\"\"\"<p>See function <span class=\"py:func\">spam</span>.</p>\"\"\" & \"\\n\" &\n          \"\"\"<p>See also <span class=\"py:class\">egg</span>. </p>\"\"\" ==\n          output)\n\n  test \"(not) Roles: check escaping 1\":\n    let expected = \"\"\"See :subscript:<tt class=\"docutils literal\">\"\"\" &\n                   \"\"\"<span class=\"pre\">\"\"\" & id\"some\" & \" \" & id\"text\" &\n                   \"</span></tt>.\"\n    check \"\"\"See \\:subscript:`some text`.\"\"\".toHtml == expected\n    check \"\"\"See :subscript\\:`some text`.\"\"\".toHtml == expected\n\n  test \"(not) Roles: check escaping 2\":\n    check(\"\"\"See :subscript:\\`some text\\`.\"\"\".toHtml ==\n          \"See :subscript:`some text`.\")\n\n  test \"Field list\":\n    check(\":field: text\".toHtml ==\n            \"\"\"<table class=\"docinfo\" frame=\"void\" rules=\"none\">\"\"\" &\n            \"\"\"<col class=\"docinfo-name\" /><col class=\"docinfo-content\" />\"\"\" &\n            \"\"\"<tbody valign=\"top\"><tr><th class=\"docinfo-name\">field:</th>\"\"\" &\n            \"\"\"<td>text</td></tr>\"\"\" & \"\\n</tbody></table>\")\n\n  test \"Field list: body after newline\":\n    let output = dedent \"\"\"\n      :field:\n        text1\"\"\".toHtml\n    check \"<table class=\\\"docinfo\\\"\" in output\n    check \">field:</th>\" in output\n    check \"<td>text1</td>\" in output\n\n  test \"Field list (incorrect)\":\n    check \":field:text\".toHtml == \":field:text\"\n\nsuite \"RST/Code highlight\":\n  test \"Basic Python code highlight\":\n    let pythonCode = \"\"\"\n    .. code-block:: python\n\n      def f_name(arg=42):\n          print(f\"{arg}\")\n\n    \"\"\"\n\n    let expected = \"\"\"<blockquote><p><span class=\"Keyword\">def</span> f_name<span class=\"Punctuation\">(</span><span class=\"Punctuation\">arg</span><span class=\"Operator\">=</span><span class=\"DecNumber\">42</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\n    print<span class=\"Punctuation\">(</span><span class=\"RawData\">f&quot;{arg}&quot;</span><span class=\"Punctuation\">)</span></p></blockquote>\"\"\"\n\n    check strip(rstToHtml(pythonCode, {}, newStringTable(modeCaseSensitive))) ==\n      strip(expected)\n"], "fixing_code": ["#\n#\n#            Nim's Runtime Library\n#        (c) Copyright 2012 Andreas Rumpf\n#\n#    See the file \"copying.txt\", included in this\n#    distribution, for details about the copyright.\n#\n\n## This module implements a generator of HTML/Latex from\n## `reStructuredText`:idx: (see http://docutils.sourceforge.net/rst.html for\n## information on this markup syntax) and is used by the compiler's `docgen\n## tools <docgen.html>`_.\n##\n## You can generate HTML output through the convenience proc ``rstToHtml``,\n## which provided an input string with rst markup returns a string with the\n## generated HTML. The final output is meant to be embedded inside a full\n## document you provide yourself, so it won't contain the usual ``<header>`` or\n## ``<body>`` parts.\n##\n## You can also create a ``RstGenerator`` structure and populate it with the\n## other lower level methods to finally build complete documents. This requires\n## many options and tweaking, but you are not limited to snippets and can\n## generate `LaTeX documents <https://en.wikipedia.org/wiki/LaTeX>`_ too.\n##\n## `Docutils configuration files`_ are not supported. Instead HTML generation\n## can be tweaked by editing file ``config/nimdoc.cfg``.\n##\n## .. _Docutils configuration files: https://docutils.sourceforge.io/docs/user/config.htm\n##\n## There are stylistic difference between how this module renders some elements\n## and how original Python Docutils does:\n##\n## * Backreferences to TOC in section headings are not generated.\n##   In HTML each section is also a link that points to the section itself:\n##   this is done for user to be able to copy the link into clipboard.\n##\n## * The same goes for footnotes/citations links: they point to themselves.\n##   No backreferences are generated since finding all references of a footnote\n##   can be done by simply searching for [footnoteName].\n\nimport strutils, os, hashes, strtabs, rstast, rst, highlite, tables, sequtils,\n  algorithm, parseutils, std/strbasics, strscans\n\nimport ../../std/private/since\n\nconst\n  HtmlExt = \"html\"\n  IndexExt* = \".idx\"\n\ntype\n  OutputTarget* = enum ## which document type to generate\n    outHtml,            # output is HTML\n    outLatex            # output is Latex\n\n  TocEntry = object\n    n*: PRstNode\n    refname*, header*: string\n\n  MetaEnum* = enum\n    metaNone, metaTitle, metaSubtitle, metaAuthor, metaVersion\n\n  EscapeMode = enum  # in Latex text inside options [] and URLs is\n                     # escaped slightly differently than in normal text\n    emText, emOption, emUrl  # emText is currently used for code also\n\n  RstGenerator* = object of RootObj\n    target*: OutputTarget\n    config*: StringTableRef\n    splitAfter*: int          # split too long entries in the TOC\n    listingCounter*: int\n    tocPart*: seq[TocEntry]\n    hasToc*: bool\n    theIndex: string # Contents of the index file to be dumped at the end.\n    findFile*: FindFileHandler\n    msgHandler*: MsgHandler\n    outDir*: string      ## output directory, initialized by docgen.nim\n    destFile*: string    ## output (HTML) file, initialized by docgen.nim\n    filenames*: RstFileTable\n    filename*: string         ## source Nim or Rst file\n    meta*: array[MetaEnum, string]\n    currentSection: string ## \\\n    ## Stores the empty string or the last headline/overline found in the rst\n    ## document, so it can be used as a prettier name for term index generation.\n    seenIndexTerms: Table[string, int] ## \\\n    ## Keeps count of same text index terms to generate different identifiers\n    ## for hyperlinks. See renderIndexTerm proc for details.\n    id*: int               ## A counter useful for generating IDs.\n    onTestSnippet*: proc (d: var RstGenerator; filename, cmd: string; status: int;\n                          content: string)\n    escMode*: EscapeMode\n\n  PDoc = var RstGenerator ## Alias to type less.\n\n  CodeBlockParams = object ## Stores code block params.\n    numberLines: bool ## True if the renderer has to show line numbers.\n    startLine: int ## The starting line of the code block, by default 1.\n    langStr: string ## Input string used to specify the language.\n    lang: SourceLanguage ## Type of highlighting, by default none.\n    filename: string\n    testCmd: string\n    status: int\n\nproc prettyLink*(file: string): string =\n  changeFileExt(file, \"\").replace(\"_._\", \"..\")\n\nproc init(p: var CodeBlockParams) =\n  ## Default initialisation of CodeBlockParams to sane values.\n  p.startLine = 1\n  p.lang = langNone\n  p.langStr = \"\"\n\nproc initRstGenerator*(g: var RstGenerator, target: OutputTarget,\n                       config: StringTableRef, filename: string,\n                       findFile: FindFileHandler = nil,\n                       msgHandler: MsgHandler = nil,\n                       filenames = default(RstFileTable)) =\n  ## Initializes a ``RstGenerator``.\n  ##\n  ## You need to call this before using a ``RstGenerator`` with any other\n  ## procs in this module. Pass a non ``nil`` ``StringTableRef`` value as\n  ## `config` with parameters used by the HTML output generator.  If you don't\n  ## know what to use, pass the results of the `defaultConfig()\n  ## <#defaultConfig>_` proc.\n  ##\n  ## The `filename` parameter will be used for error reporting and creating\n  ## index hyperlinks to the file, but you can pass an empty string here if you\n  ## are parsing a stream in memory. If `filename` ends with the ``.nim``\n  ## extension, the title for the document will be set by default to ``Module\n  ## filename``.  This default title can be overridden by the embedded rst, but\n  ## it helps to prettify the generated index if no title is found.\n  ##\n  ## The ``RstParseOptions``, ``FindFileHandler`` and ``MsgHandler`` types\n  ## are defined in the `packages/docutils/rst module <rst.html>`_.\n  ## ``options`` selects the behaviour of the rst parser.\n  ##\n  ## ``findFile`` is a proc used by the rst ``include`` directive among others.\n  ## The purpose of this proc is to mangle or filter paths. It receives paths\n  ## specified in the rst document and has to return a valid path to existing\n  ## files or the empty string otherwise.  If you pass ``nil``, a default proc\n  ## will be used which given a path returns the input path only if the file\n  ## exists. One use for this proc is to transform relative paths found in the\n  ## document to absolute path, useful if the rst file and the resources it\n  ## references are not in the same directory as the current working directory.\n  ##\n  ## The ``msgHandler`` is a proc used for user error reporting. It will be\n  ## called with the filename, line, col, and type of any error found during\n  ## parsing. If you pass ``nil``, a default message handler will be used which\n  ## writes the messages to the standard output.\n  ##\n  ## Example:\n  ##\n  ## .. code-block:: nim\n  ##\n  ##   import packages/docutils/rstgen\n  ##\n  ##   var gen: RstGenerator\n  ##   gen.initRstGenerator(outHtml, defaultConfig(), \"filename\", {})\n  g.config = config\n  g.target = target\n  g.tocPart = @[]\n  g.filename = filename\n  g.filenames = filenames\n  g.splitAfter = 20\n  g.theIndex = \"\"\n  g.findFile = findFile\n  g.currentSection = \"\"\n  g.id = 0\n  g.escMode = emText\n  let fileParts = filename.splitFile\n  if fileParts.ext == \".nim\":\n    g.currentSection = \"Module \" & fileParts.name\n  g.seenIndexTerms = initTable[string, int]()\n  g.msgHandler = msgHandler\n\n  let s = config.getOrDefault\"split.item.toc\"\n  if s != \"\": g.splitAfter = parseInt(s)\n  for i in low(g.meta)..high(g.meta): g.meta[i] = \"\"\n\nproc writeIndexFile*(g: var RstGenerator, outfile: string) =\n  ## Writes the current index buffer to the specified output file.\n  ##\n  ## You previously need to add entries to the index with the `setIndexTerm()\n  ## <#setIndexTerm,RstGenerator,string,string,string,string,string>`_ proc.\n  ## If the index is empty the file won't be created.\n  if g.theIndex.len > 0: writeFile(outfile, g.theIndex)\n\nproc addHtmlChar(dest: var string, c: char) =\n  # Escapes HTML characters. Note that single quote ' is not escaped as\n  # &apos; -- unlike XML (for standards pre HTML5 it was even forbidden).\n  case c\n  of '&': add(dest, \"&amp;\")\n  of '<': add(dest, \"&lt;\")\n  of '>': add(dest, \"&gt;\")\n  of '\\\"': add(dest, \"&quot;\")\n  else: add(dest, c)\n\nproc addTexChar(dest: var string, c: char, escMode: EscapeMode) =\n  ## Escapes 10 special Latex characters and sometimes ` and [, ].\n  ## TODO: @ is always a normal symbol (besides the header), am I wrong?\n  ## All escapes that need to work in text and code blocks (`emText` mode)\n  ## should start from \\ (to be compatible with fancyvrb/fvextra).\n  case c\n  of '_', '$', '&', '#', '%': add(dest, \"\\\\\" & c)\n  # \\~ and \\^ have a special meaning unless they are followed by {}\n  of '~', '^': add(dest, \"\\\\\" & c & \"{}\")\n  # Latex loves to substitute ` to opening quote, even in texttt mode!\n  of '`': add(dest, \"\\\\textasciigrave{}\")\n  # add {} to avoid gobbling up space by \\textbackslash\n  of '\\\\': add(dest, \"\\\\textbackslash{}\")\n  # Using { and } in URL in Latex: https://tex.stackexchange.com/a/469175\n  of '{':\n    add(dest, if escMode == emUrl: \"\\\\%7B\" else: \"\\\\{\")\n  of '}':\n    add(dest, if escMode == emUrl: \"\\\\%7D\" else: \"\\\\}\")\n  of ']':\n    # escape ] inside an optional argument in e.g. \\section[static[T]]{..\n    add(dest, if escMode == emOption: \"\\\\text{]}\" else: \"]\")\n  else: add(dest, c)\n\nproc escChar*(target: OutputTarget, dest: var string,\n              c: char, escMode: EscapeMode) {.inline.} =\n  case target\n  of outHtml:  addHtmlChar(dest, c)\n  of outLatex: addTexChar(dest, c, escMode)\n\nproc addSplitter(target: OutputTarget; dest: var string) {.inline.} =\n  case target\n  of outHtml: add(dest, \"<wbr />\")\n  of outLatex: add(dest, \"\\\\-\")\n\nproc nextSplitPoint*(s: string, start: int): int =\n  result = start\n  while result < len(s) + 0:\n    case s[result]\n    of '_': return\n    of 'a'..'z':\n      if result + 1 < len(s) + 0:\n        if s[result + 1] in {'A'..'Z'}: return\n    else: discard\n    inc(result)\n  dec(result)                 # last valid index\n\nproc esc*(target: OutputTarget, s: string, splitAfter = -1, escMode = emText): string =\n  ## Escapes the HTML.\n  result = \"\"\n  if splitAfter >= 0:\n    var partLen = 0\n    var j = 0\n    while j < len(s):\n      var k = nextSplitPoint(s, j)\n      #if (splitter != \" \") or (partLen + k - j + 1 > splitAfter):\n      partLen = 0\n      addSplitter(target, result)\n      for i in countup(j, k): escChar(target, result, s[i], escMode)\n      inc(partLen, k - j + 1)\n      j = k + 1\n  else:\n    for i in countup(0, len(s) - 1): escChar(target, result, s[i], escMode)\n\n\nproc disp(target: OutputTarget, xml, tex: string): string =\n  if target != outLatex: result = xml\n  else: result = tex\n\nproc dispF(target: OutputTarget, xml, tex: string,\n           args: varargs[string]): string =\n  if target != outLatex: result = xml % args\n  else: result = tex % args\n\nproc dispA(target: OutputTarget, dest: var string,\n           xml, tex: string, args: varargs[string]) =\n  if target != outLatex: addf(dest, xml, args)\n  else: addf(dest, tex, args)\n\nproc `or`(x, y: string): string {.inline.} =\n  result = if x.len == 0: y else: x\n\nproc renderRstToOut*(d: var RstGenerator, n: PRstNode, result: var string)\n  ## Writes into ``result`` the rst ast ``n`` using the ``d`` configuration.\n  ##\n  ## Before using this proc you need to initialise a ``RstGenerator`` with\n  ## ``initRstGenerator`` and parse a rst file with ``rstParse`` from the\n  ## `packages/docutils/rst module <rst.html>`_. Example:\n  ##\n  ## .. code-block:: nim\n  ##\n  ##   # ...configure gen and rst vars...\n  ##   var generatedHtml = \"\"\n  ##   renderRstToOut(gen, rst, generatedHtml)\n  ##   echo generatedHtml\n\nproc renderAux(d: PDoc, n: PRstNode, result: var string) =\n  for i in countup(0, len(n)-1): renderRstToOut(d, n.sons[i], result)\n\ntemplate idS(txt: string): string =\n  if txt == \"\": \"\"\n  else:\n    case d.target\n    of outHtml:\n      \" id=\\\"\" & txt & \"\\\"\"\n    of outLatex:\n      \"\\\\label{\" & txt & \"}\\\\hypertarget{\" & txt & \"}{}\"\n        # we add \\label for page number references via \\pageref, while\n        # \\hypertarget is for clickable links via \\hyperlink.\n\nproc renderAux(d: PDoc, n: PRstNode, html, tex: string, result: var string) =\n  # formats sons of `n` as substitution variable $1 inside strings `html` and\n  # `tex`, internal target (anchor) is provided as substitute $2.\n  var tmp = \"\"\n  for i in countup(0, len(n)-1): renderRstToOut(d, n.sons[i], tmp)\n  case d.target\n  of outHtml:  result.addf(html, [tmp, n.anchor.idS])\n  of outLatex: result.addf(tex,  [tmp, n.anchor.idS])\n\n# ---------------- index handling --------------------------------------------\n\nproc quoteIndexColumn(text: string): string =\n  ## Returns a safe version of `text` for serialization to the ``.idx`` file.\n  ##\n  ## The returned version can be put without worries in a line based tab\n  ## separated column text file. The following character sequence replacements\n  ## will be performed for that goal:\n  ##\n  ## * ``\"\\\\\"`` => ``\"\\\\\\\\\"``\n  ## * ``\"\\n\"`` => ``\"\\\\n\"``\n  ## * ``\"\\t\"`` => ``\"\\\\t\"``\n  result = newStringOfCap(text.len + 3)\n  for c in text:\n    case c\n    of '\\\\': result.add \"\\\\\"\n    of '\\L': result.add \"\\\\n\"\n    of '\\C': discard\n    of '\\t': result.add \"\\\\t\"\n    else: result.add c\n\nproc unquoteIndexColumn(text: string): string =\n  ## Returns the unquoted version generated by ``quoteIndexColumn``.\n  result = text.multiReplace((\"\\\\t\", \"\\t\"), (\"\\\\n\", \"\\n\"), (\"\\\\\\\\\", \"\\\\\"))\n\nproc setIndexTerm*(d: var RstGenerator, htmlFile, id, term: string,\n                   linkTitle, linkDesc = \"\") =\n  ## Adds a `term` to the index using the specified hyperlink identifier.\n  ##\n  ## A new entry will be added to the index using the format\n  ## ``term<tab>file#id``. The file part will come from the `htmlFile`\n  ## parameter.\n  ##\n  ## The `id` will be appended with a hash character only if its length is not\n  ## zero, otherwise no specific anchor will be generated. In general you\n  ## should only pass an empty `id` value for the title of standalone rst\n  ## documents (they are special for the `mergeIndexes() <#mergeIndexes,string>`_\n  ## proc, see `Index (idx) file format <docgen.html#index-idx-file-format>`_\n  ## for more information). Unlike other index terms, title entries are\n  ## inserted at the beginning of the accumulated buffer to maintain a logical\n  ## order of entries.\n  ##\n  ## If `linkTitle` or `linkDesc` are not the empty string, two additional\n  ## columns with their contents will be added.\n  ##\n  ## The index won't be written to disk unless you call `writeIndexFile()\n  ## <#writeIndexFile,RstGenerator,string>`_. The purpose of the index is\n  ## documented in the `docgen tools guide\n  ## <docgen.html#related-options-index-switch>`_.\n  var\n    entry = term\n    isTitle = false\n  entry.add('\\t')\n  entry.add(htmlFile)\n  if id.len > 0:\n    entry.add('#')\n    entry.add(id)\n  else:\n    isTitle = true\n  if linkTitle.len > 0 or linkDesc.len > 0:\n    entry.add('\\t' & linkTitle.quoteIndexColumn)\n    entry.add('\\t' & linkDesc.quoteIndexColumn)\n  entry.add(\"\\n\")\n\n  if isTitle: d.theIndex.insert(entry)\n  else: d.theIndex.add(entry)\n\nproc hash(n: PRstNode): int =\n  if n.kind == rnLeaf:\n    result = hash(n.text)\n  elif n.len > 0:\n    result = hash(n.sons[0])\n    for i in 1 ..< len(n):\n      result = result !& hash(n.sons[i])\n    result = !$result\n\nproc renderIndexTerm*(d: PDoc, n: PRstNode, result: var string) =\n  ## Renders the string decorated within \\`foobar\\`\\:idx\\: markers.\n  ##\n  ## Additionally adds the enclosed text to the index as a term. Since we are\n  ## interested in different instances of the same term to have different\n  ## entries, a table is used to keep track of the amount of times a term has\n  ## previously appeared to give a different identifier value for each.\n  let refname = n.rstnodeToRefname\n  if d.seenIndexTerms.hasKey(refname):\n    d.seenIndexTerms[refname] = d.seenIndexTerms.getOrDefault(refname) + 1\n  else:\n    d.seenIndexTerms[refname] = 1\n  let id = refname & '_' & $d.seenIndexTerms.getOrDefault(refname)\n\n  var term = \"\"\n  renderAux(d, n, term)\n  setIndexTerm(d, changeFileExt(extractFilename(d.filename), HtmlExt), id, term, d.currentSection)\n  dispA(d.target, result, \"<span id=\\\"$1\\\">$2</span>\", \"\\\\nimindexterm{$1}{$2}\",\n        [id, term])\n\ntype\n  IndexEntry = object\n    keyword: string\n    link: string\n    linkTitle: string ## contains a prettier text for the href\n    linkDesc: string ## the title attribute of the final href\n\n  IndexedDocs = Table[IndexEntry, seq[IndexEntry]] ## \\\n    ## Contains the index sequences for doc types.\n    ##\n    ## The key is a *fake* IndexEntry which will contain the title of the\n    ## document in the `keyword` field and `link` will contain the html\n    ## filename for the document. `linkTitle` and `linkDesc` will be empty.\n    ##\n    ## The value indexed by this IndexEntry is a sequence with the real index\n    ## entries found in the ``.idx`` file.\n\nproc cmp(a, b: IndexEntry): int =\n  ## Sorts two ``IndexEntry`` first by `keyword` field, then by `link`.\n  result = cmpIgnoreStyle(a.keyword, b.keyword)\n  if result == 0:\n    result = cmpIgnoreStyle(a.link, b.link)\n\nproc hash(x: IndexEntry): Hash =\n  ## Returns the hash for the combined fields of the type.\n  ##\n  ## The hash is computed as the chained hash of the individual string hashes.\n  result = x.keyword.hash !& x.link.hash\n  result = result !& x.linkTitle.hash\n  result = result !& x.linkDesc.hash\n  result = !$result\n\nwhen defined(gcDestructors):\n  template `<-`(a, b: var IndexEntry) = a = move(b)\nelse:\n  proc `<-`(a: var IndexEntry, b: IndexEntry) =\n    shallowCopy a.keyword, b.keyword\n    shallowCopy a.link, b.link\n    shallowCopy a.linkTitle, b.linkTitle\n    shallowCopy a.linkDesc, b.linkDesc\n\nproc sortIndex(a: var openArray[IndexEntry]) =\n  # we use shellsort here; fast and simple\n  let n = len(a)\n  var h = 1\n  while true:\n    h = 3 * h + 1\n    if h > n: break\n  while true:\n    h = h div 3\n    for i in countup(h, n - 1):\n      var v: IndexEntry\n      v <- a[i]\n      var j = i\n      while cmp(a[j-h], v) >= 0:\n        a[j] <- a[j-h]\n        j = j-h\n        if j < h: break\n      a[j] <- v\n    if h == 1: break\n\nproc escapeLink(s: string): string =\n  ## This proc is mostly copied from uri/encodeUrl except that\n  ## these chars are also left unencoded: '#', '/'.\n  result = newStringOfCap(s.len + s.len shr 2)\n  for c in items(s):\n    case c\n    of 'a'..'z', 'A'..'Z', '0'..'9', '-', '.', '_', '~': # same as that in uri/encodeUrl\n      add(result, c)\n    of '#', '/': # example.com/foo/#bar (don't escape the '/' and '#' in such links)\n      add(result, c)\n    else:\n      add(result, \"%\")\n      add(result, toHex(ord(c), 2))\n\nproc generateSymbolIndex(symbols: seq[IndexEntry]): string =\n  result = \"<dl>\"\n  var i = 0\n  while i < symbols.len:\n    let keyword = symbols[i].keyword\n    let cleanedKeyword = keyword.escapeLink\n    result.addf(\"<dt><a name=\\\"$2\\\" href=\\\"#$2\\\"><span>$1:</span></a></dt><dd><ul class=\\\"simple\\\">\\n\",\n                [keyword, cleanedKeyword])\n    var j = i\n    while j < symbols.len and keyword == symbols[j].keyword:\n      let\n        url = symbols[j].link.escapeLink\n        text = if symbols[j].linkTitle.len > 0: symbols[j].linkTitle else: url\n        desc = if symbols[j].linkDesc.len > 0: symbols[j].linkDesc else: \"\"\n      if desc.len > 0:\n        result.addf(\"\"\"<li><a class=\"reference external\"\n          title=\"$3\" data-doc-search-tag=\"$2\" href=\"$1\">$2</a></li>\n          \"\"\", [url, text, desc])\n      else:\n        result.addf(\"\"\"<li><a class=\"reference external\"\n          data-doc-search-tag=\"$2\" href=\"$1\">$2</a></li>\n          \"\"\", [url, text])\n      inc j\n    result.add(\"</ul></dd>\\n\")\n    i = j\n  result.add(\"</dl>\")\n\nproc isDocumentationTitle(hyperlink: string): bool =\n  ## Returns true if the hyperlink is actually a documentation title.\n  ##\n  ## Documentation titles lack the hash. See `mergeIndexes()\n  ## <#mergeIndexes,string>`_ for a more detailed explanation.\n  result = hyperlink.find('#') < 0\n\nproc stripTocLevel(s: string): tuple[level: int, text: string] =\n  ## Returns the *level* of the toc along with the text without it.\n  for c in 0 ..< s.len:\n    result.level = c\n    if s[c] != ' ': break\n  result.text = s[result.level ..< s.len]\n\nproc indentToLevel(level: var int, newLevel: int): string =\n  ## Returns the sequence of <ul>|</ul> characters to switch to `newLevel`.\n  ##\n  ## The amount of lists added/removed will be based on the `level` variable,\n  ## which will be reset to `newLevel` at the end of the proc.\n  result = \"\"\n  if level == newLevel:\n    return\n  if newLevel > level:\n    result = repeat(\"<li><ul>\", newLevel - level)\n  else:\n    result = repeat(\"</ul></li>\", level - newLevel)\n  level = newLevel\n\nproc generateDocumentationToc(entries: seq[IndexEntry]): string =\n  ## Returns the sequence of index entries in an HTML hierarchical list.\n  result = \"\"\n  # Build a list of levels and extracted titles to make processing easier.\n  var\n    titleRef: string\n    titleTag: string\n    levels: seq[tuple[level: int, text: string]]\n    L = 0\n    level = 1\n  levels.newSeq(entries.len)\n  for entry in entries:\n    let (rawLevel, rawText) = stripTocLevel(entry.linkTitle or entry.keyword)\n    if rawLevel < 1:\n      # This is a normal symbol, push it *inside* one level from the last one.\n      levels[L].level = level + 1\n      # Also, ignore the linkTitle and use directly the keyword.\n      levels[L].text = entry.keyword\n    else:\n      # The level did change, update the level indicator.\n      level = rawLevel\n      levels[L].level = rawLevel\n      levels[L].text = rawText\n    inc L\n\n  # Now generate hierarchical lists based on the precalculated levels.\n  result = \"<ul>\\n\"\n  level = 1\n  L = 0\n  while L < entries.len:\n    let link = entries[L].link\n    if link.isDocumentationTitle:\n      titleRef = link\n      titleTag = levels[L].text\n    else:\n      result.add(level.indentToLevel(levels[L].level))\n      result.addf(\"\"\"<li><a class=\"reference\" data-doc-search-tag=\"$1: $2\" href=\"$3\">\n        $3</a></li>\n        \"\"\", [titleTag, levels[L].text, link, levels[L].text])\n    inc L\n  result.add(level.indentToLevel(1) & \"</ul>\\n\")\n\nproc generateDocumentationIndex(docs: IndexedDocs): string =\n  ## Returns all the documentation TOCs in an HTML hierarchical list.\n  result = \"\"\n\n  # Sort the titles to generate their toc in alphabetical order.\n  var titles = toSeq(keys[IndexEntry, seq[IndexEntry]](docs))\n  sort(titles, cmp)\n\n  for title in titles:\n    let tocList = generateDocumentationToc(docs.getOrDefault(title))\n    result.add(\"<ul><li><a href=\\\"\" &\n      title.link & \"\\\">\" & title.keyword & \"</a>\\n\" & tocList & \"</li></ul>\\n\")\n\nproc generateDocumentationJumps(docs: IndexedDocs): string =\n  ## Returns a plain list of hyperlinks to documentation TOCs in HTML.\n  result = \"Documents: \"\n\n  # Sort the titles to generate their toc in alphabetical order.\n  var titles = toSeq(keys[IndexEntry, seq[IndexEntry]](docs))\n  sort(titles, cmp)\n\n  var chunks: seq[string] = @[]\n  for title in titles:\n    chunks.add(\"<a href=\\\"\" & title.link & \"\\\">\" & title.keyword & \"</a>\")\n\n  result.add(chunks.join(\", \") & \".<br/>\")\n\nproc generateModuleJumps(modules: seq[string]): string =\n  ## Returns a plain list of hyperlinks to the list of modules.\n  result = \"Modules: \"\n\n  var chunks: seq[string] = @[]\n  for name in modules:\n    chunks.add(\"<a href=\\\"$1.html\\\">$2</a>\" % [name, name.prettyLink])\n\n  result.add(chunks.join(\", \") & \".<br/>\")\n\nproc readIndexDir(dir: string):\n    tuple[modules: seq[string], symbols: seq[IndexEntry], docs: IndexedDocs] =\n  ## Walks `dir` reading ``.idx`` files converting them in IndexEntry items.\n  ##\n  ## Returns the list of found module names, the list of free symbol entries\n  ## and the different documentation indexes. The list of modules is sorted.\n  ## See the documentation of ``mergeIndexes`` for details.\n  result.modules = @[]\n  result.docs = initTable[IndexEntry, seq[IndexEntry]](32)\n  newSeq(result.symbols, 15_000)\n  setLen(result.symbols, 0)\n  var L = 0\n  # Scan index files and build the list of symbols.\n  for path in walkDirRec(dir):\n    if path.endsWith(IndexExt):\n      var\n        fileEntries: seq[IndexEntry]\n        title: IndexEntry\n        f = 0\n      newSeq(fileEntries, 500)\n      setLen(fileEntries, 0)\n      for line in lines(path):\n        let s = line.find('\\t')\n        if s < 0: continue\n        setLen(fileEntries, f+1)\n        fileEntries[f].keyword = line.substr(0, s-1)\n        fileEntries[f].link = line.substr(s+1)\n        # See if we detect a title, a link without a `#foobar` trailing part.\n        if title.keyword.len == 0 and fileEntries[f].link.isDocumentationTitle:\n          title.keyword = fileEntries[f].keyword\n          title.link = fileEntries[f].link\n\n        if fileEntries[f].link.find('\\t') > 0:\n          let extraCols = fileEntries[f].link.split('\\t')\n          fileEntries[f].link = extraCols[0]\n          assert extraCols.len == 3\n          fileEntries[f].linkTitle = extraCols[1].unquoteIndexColumn\n          fileEntries[f].linkDesc = extraCols[2].unquoteIndexColumn\n        else:\n          fileEntries[f].linkTitle = \"\"\n          fileEntries[f].linkDesc = \"\"\n        inc f\n      # Depending on type add this to the list of symbols or table of APIs.\n      if title.keyword.len == 0:\n        for i in 0 ..< f:\n          # Don't add to symbols TOC entries (they start with a whitespace).\n          let toc = fileEntries[i].linkTitle\n          if toc.len > 0 and toc[0] == ' ':\n            continue\n          # Ok, non TOC entry, add it.\n          setLen(result.symbols, L + 1)\n          result.symbols[L] = fileEntries[i]\n          inc L\n        if fileEntries.len > 0:\n          var x = fileEntries[0].link\n          let i = find(x, '#')\n          if i > 0:\n            x.setLen(i)\n          if i != 0:\n            # don't add entries starting with '#'\n            result.modules.add(x.changeFileExt(\"\"))\n      else:\n        # Generate the symbolic anchor for index quickjumps.\n        title.linkTitle = \"doc_toc_\" & $result.docs.len\n        result.docs[title] = fileEntries\n\n  sort(result.modules, system.cmp)\n\nproc mergeIndexes*(dir: string): string =\n  ## Merges all index files in `dir` and returns the generated index as HTML.\n  ##\n  ## This proc will first scan `dir` for index files with the ``.idx``\n  ## extension previously created by commands like ``nim doc|rst2html``\n  ## which use the ``--index:on`` switch. These index files are the result of\n  ## calls to `setIndexTerm()\n  ## <#setIndexTerm,RstGenerator,string,string,string,string,string>`_\n  ## and `writeIndexFile() <#writeIndexFile,RstGenerator,string>`_, so they are\n  ## simple tab separated files.\n  ##\n  ## As convention this proc will split index files into two categories:\n  ## documentation and API. API indices will be all joined together into a\n  ## single big sorted index, making the bulk of the final index. This is good\n  ## for API documentation because many symbols are repeated in different\n  ## modules. On the other hand, documentation indices are essentially table of\n  ## contents plus a few special markers. These documents will be rendered in a\n  ## separate section which tries to maintain the order and hierarchy of the\n  ## symbols in the index file.\n  ##\n  ## To differentiate between a documentation and API file a convention is\n  ## used: indices which contain one entry without the HTML hash character (#)\n  ## will be considered `documentation`, since this hash-less entry is the\n  ## explicit title of the document.  Indices without this explicit entry will\n  ## be considered `generated API` extracted out of a source ``.nim`` file.\n  ##\n  ## Returns the merged and sorted indices into a single HTML block which can\n  ## be further embedded into nimdoc templates.\n  var (modules, symbols, docs) = readIndexDir(dir)\n\n  result = \"\"\n  # Generate a quick jump list of documents.\n  if docs.len > 0:\n    result.add(generateDocumentationJumps(docs))\n    result.add(\"<p />\")\n\n  # Generate hyperlinks to all the linked modules.\n  if modules.len > 0:\n    result.add(generateModuleJumps(modules))\n    result.add(\"<p />\")\n\n  when false:\n    # Generate the HTML block with API documents.\n    if docs.len > 0:\n      result.add(\"<h2>Documentation files</h2>\\n\")\n      result.add(generateDocumentationIndex(docs))\n\n  # Generate the HTML block with symbols.\n  if symbols.len > 0:\n    sortIndex(symbols)\n    result.add(\"<h2>API symbols</h2>\\n\")\n    result.add(generateSymbolIndex(symbols))\n\n\n# ----------------------------------------------------------------------------\n\nproc stripTocHtml(s: string): string =\n  ## Ugly quick hack to remove HTML tags from TOC titles.\n  ##\n  ## A TocEntry.header field already contains rendered HTML tags. Instead of\n  ## implementing a proper version of renderRstToOut() which recursively\n  ## renders an rst tree to plain text, we simply remove text found between\n  ## angled brackets. Given the limited possibilities of rst inside TOC titles\n  ## this should be enough.\n  result = s\n  var first = result.find('<')\n  while first >= 0:\n    let last = result.find('>', first)\n    if last < 0:\n      # Abort, since we didn't found a closing angled bracket.\n      return\n    result.delete(first, last)\n    first = result.find('<', first)\n\nproc renderHeadline(d: PDoc, n: PRstNode, result: var string) =\n  var tmp = \"\"\n  for i in countup(0, len(n) - 1): renderRstToOut(d, n.sons[i], tmp)\n  d.currentSection = tmp\n  # Find the last higher level section for unique reference name\n  var sectionPrefix = \"\"\n  for i in countdown(d.tocPart.high, 0):\n    let n2 = d.tocPart[i].n\n    if n2.level < n.level:\n      sectionPrefix = rstnodeToRefname(n2) & \"-\"\n      break\n  var refname = sectionPrefix & rstnodeToRefname(n)\n  var tocName = esc(d.target, renderRstToText(n), escMode = emOption)\n    # for Latex: simple text without commands that may break TOC/hyperref\n  if d.hasToc:\n    var length = len(d.tocPart)\n    setLen(d.tocPart, length + 1)\n    d.tocPart[length].refname = refname\n    d.tocPart[length].n = n\n    d.tocPart[length].header = tmp\n\n    dispA(d.target, result, \"\\n<h$1><a class=\\\"toc-backref\\\"\" &\n      \"$2 href=\\\"#$5\\\">$3</a></h$1>\", \"\\\\rsth$4[$6]{$3}$2\\n\",\n      [$n.level, refname.idS, tmp,\n       $chr(n.level - 1 + ord('A')), refname, tocName])\n  else:\n    dispA(d.target, result, \"\\n<h$1$2>$3</h$1>\",\n                            \"\\\\rsth$4[$5]{$3}$2\\n\", [\n        $n.level, refname.idS, tmp,\n        $chr(n.level - 1 + ord('A')), tocName])\n\n  # Generate index entry using spaces to indicate TOC level for the output HTML.\n  assert n.level >= 0\n  let\n    htmlFileRelPath = if d.outDir.len == 0:\n                        # /foo/bar/zoo.nim -> zoo.html\n                        changeFileExt(extractFilename(d.filename), HtmlExt)\n                      else: # d is initialized in docgen.nim\n                        # outDir   = /foo              -\\\n                        # destFile = /foo/bar/zoo.html -|-> bar/zoo.html\n                        d.destFile.relativePath(d.outDir, '/')\n  setIndexTerm(d, htmlFileRelPath, refname, tmp.stripTocHtml,\n    spaces(max(0, n.level)) & tmp)\n\nproc renderOverline(d: PDoc, n: PRstNode, result: var string) =\n  if n.level == 0 and d.meta[metaTitle].len == 0:\n    for i in countup(0, len(n)-1):\n      renderRstToOut(d, n.sons[i], d.meta[metaTitle])\n    d.currentSection = d.meta[metaTitle]\n  elif n.level == 0 and d.meta[metaSubtitle].len == 0:\n    for i in countup(0, len(n)-1):\n      renderRstToOut(d, n.sons[i], d.meta[metaSubtitle])\n    d.currentSection = d.meta[metaSubtitle]\n  else:\n    var tmp = \"\"\n    for i in countup(0, len(n) - 1): renderRstToOut(d, n.sons[i], tmp)\n    d.currentSection = tmp\n    var tocName = esc(d.target, renderRstToText(n), escMode=emOption)\n    dispA(d.target, result, \"<h$1$2><center>$3</center></h$1>\",\n                   \"\\\\rstov$4[$5]{$3}$2\\n\", [$n.level,\n        rstnodeToRefname(n).idS, tmp, $chr(n.level - 1 + ord('A')), tocName])\n\n\nproc safeProtocol(linkStr: var string) =\n  var protocol = \"\"\n  if scanf(linkStr, \"$w:\", protocol):\n    # if it has a protocol at all, ensure that it's not 'javascript:' or worse:\n    if cmpIgnoreCase(protocol, \"http\") == 0 or cmpIgnoreCase(protocol, \"https\") == 0 or\n        cmpIgnoreCase(protocol, \"ftp\") == 0:\n      discard \"it's fine\"\n    else:\n      linkStr = \"\"\n\nproc renderTocEntry(d: PDoc, e: TocEntry, result: var string) =\n  dispA(d.target, result,\n    \"<li><a class=\\\"reference\\\" id=\\\"$1_toc\\\" href=\\\"#$1\\\">$2</a></li>\\n\",\n    \"\\\\item\\\\label{$1_toc} $2\\\\ref{$1}\\n\", [e.refname, e.header])\n\nproc renderTocEntries*(d: var RstGenerator, j: var int, lvl: int,\n                       result: var string) =\n  var tmp = \"\"\n  while j <= high(d.tocPart):\n    var a = abs(d.tocPart[j].n.level)\n    if a == lvl:\n      renderTocEntry(d, d.tocPart[j], tmp)\n      inc(j)\n    elif a > lvl:\n      renderTocEntries(d, j, a, tmp)\n    else:\n      break\n  if lvl > 1:\n    dispA(d.target, result, \"<ul class=\\\"simple\\\">$1</ul>\",\n                            \"\\\\begin{enumerate}$1\\\\end{enumerate}\", [tmp])\n  else:\n    result.add(tmp)\n\nproc renderImage(d: PDoc, n: PRstNode, result: var string) =\n  let\n    arg = getArgument(n)\n  var\n    options = \"\"\n\n  var s = esc(d.target, getFieldValue(n, \"scale\").strip())\n  if s.len > 0:\n    dispA(d.target, options, \" scale=\\\"$1\\\"\", \" scale=$1\", [s])\n\n  s = esc(d.target, getFieldValue(n, \"height\").strip())\n  if s.len > 0:\n    dispA(d.target, options, \" height=\\\"$1\\\"\", \" height=$1\", [s])\n\n  s = esc(d.target, getFieldValue(n, \"width\").strip())\n  if s.len > 0:\n    dispA(d.target, options, \" width=\\\"$1\\\"\", \" width=$1\", [s])\n\n  s = esc(d.target, getFieldValue(n, \"alt\").strip())\n  if s.len > 0:\n    dispA(d.target, options, \" alt=\\\"$1\\\"\", \"\", [s])\n\n  s = esc(d.target, getFieldValue(n, \"align\").strip())\n  if s.len > 0:\n    dispA(d.target, options, \" align=\\\"$1\\\"\", \"\", [s])\n\n  if options.len > 0: options = dispF(d.target, \"$1\", \"[$1]\", [options])\n\n  var htmlOut = \"\"\n  if arg.endsWith(\".mp4\") or arg.endsWith(\".ogg\") or\n     arg.endsWith(\".webm\"):\n    htmlOut = \"\"\"\n      <video$3 src=\"$1\"$2 autoPlay='true' loop='true' muted='true'>\n      Sorry, your browser doesn't support embedded videos\n      </video>\n    \"\"\"\n  else:\n    htmlOut = \"<img$3 src=\\\"$1\\\"$2/>\"\n\n  # support for `:target:` links for images:\n  var target = esc(d.target, getFieldValue(n, \"target\").strip(), escMode=emUrl)\n  safeProtocol(target)\n\n  if target.len > 0:\n    # `htmlOut` needs to be of the following format for link to work for images:\n    # <a class=\"reference external\" href=\"target\"><img src=\\\"$1\\\"$2/></a>\n    var htmlOutWithLink = \"\"\n    dispA(d.target, htmlOutWithLink,\n      \"<a class=\\\"reference external\\\" href=\\\"$2\\\">$1</a>\",\n      \"\\\\href{$2}{$1}\", [htmlOut, target])\n    htmlOut = htmlOutWithLink\n\n  dispA(d.target, result, htmlOut, \"$3\\\\includegraphics$2{$1}\",\n        [esc(d.target, arg), options, n.anchor.idS])\n  if len(n) >= 3: renderRstToOut(d, n.sons[2], result)\n\nproc renderSmiley(d: PDoc, n: PRstNode, result: var string) =\n  dispA(d.target, result,\n    \"\"\"<img src=\"$1\" width=\"15\"\n        height=\"17\" hspace=\"2\" vspace=\"2\" class=\"smiley\" />\"\"\",\n    \"\\\\includegraphics{$1}\",\n    [d.config.getOrDefault\"doc.smiley_format\" % n.text])\n\nproc getField1Int(d: PDoc, n: PRstNode, fieldName: string): int =\n  template err(msg: string) =\n    rstMessage(d.filenames, d.msgHandler, n.info, meInvalidField, msg)\n  let value = n.getFieldValue\n  var number: int\n  let nChars = parseInt(value, number)\n  if nChars == 0:\n    if value.len == 0:\n      err(\"field $1 requires an argument\" % [fieldName])\n    else:\n      err(\"field $1 requires an integer, but '$2' was given\" %\n          [fieldName, value])\n  elif nChars < value.len:\n    err(\"extra arguments were given to $1: '$2'\" %\n        [fieldName, value[nChars..^1]])\n  else:\n    result = number\n\nproc parseCodeBlockField(d: PDoc, n: PRstNode, params: var CodeBlockParams) =\n  ## Parses useful fields which can appear before a code block.\n  ##\n  ## This supports the special ``default-language`` internal string generated\n  ## by the ``rst`` module to communicate a specific default language.\n  case n.getArgument.toLowerAscii\n  of \"number-lines\":\n    params.numberLines = true\n    # See if the field has a parameter specifying a different line than 1.\n    params.startLine = getField1Int(d, n, \"number-lines\")\n  of \"file\", \"filename\":\n    # The ``file`` option is a Nim extension to the official spec, it acts\n    # like it would for other directives like ``raw`` or ``cvs-table``. This\n    # field is dealt with in ``rst.nim`` which replaces the existing block with\n    # the referenced file, so we only need to ignore it here to avoid incorrect\n    # warning messages.\n    params.filename = n.getFieldValue.strip\n  of \"test\":\n    params.testCmd = n.getFieldValue.strip\n    if params.testCmd.len == 0:\n      # factor with D20210224T221756. Note that `$docCmd` should appear before `$file`\n      # but after all other options, but currently `$options` merges both options and `$file` so it's tricky.\n      params.testCmd = \"$nim r --backend:$backend --lib:$libpath $docCmd $options\"\n    else:\n      # consider whether `$docCmd` should be appended here too\n      params.testCmd = unescape(params.testCmd)\n  of \"status\", \"exitcode\":\n    params.status = getField1Int(d, n, n.getArgument)\n  of \"default-language\":\n    params.langStr = n.getFieldValue.strip\n    params.lang = params.langStr.getSourceLanguage\n  else:\n    rstMessage(d.filenames, d.msgHandler, n.info, mwUnsupportedField,\n               n.getArgument)\n\nproc parseCodeBlockParams(d: PDoc, n: PRstNode): CodeBlockParams =\n  ## Iterates over all code block fields and returns processed params.\n  ##\n  ## Also processes the argument of the directive as the default language. This\n  ## is done last so as to override any internal communication field variables.\n  result.init\n  if n.isNil:\n    return\n  assert n.kind in {rnCodeBlock, rnInlineCode}\n\n  # Parse the field list for rendering parameters if there are any.\n  if not n.sons[1].isNil:\n    for son in n.sons[1].sons: d.parseCodeBlockField(son, result)\n\n  # Parse the argument and override the language.\n  result.langStr = strip(getArgument(n))\n  if result.langStr != \"\":\n    result.lang = getSourceLanguage(result.langStr)\n\nproc buildLinesHtmlTable(d: PDoc; params: CodeBlockParams, code: string,\n                         idStr: string):\n    tuple[beginTable, endTable: string] =\n  ## Returns the necessary tags to start/end a code block in HTML.\n  ##\n  ## If the numberLines has not been used, the tags will default to a simple\n  ## <pre> pair. Otherwise it will build a table and insert an initial column\n  ## with all the line numbers, which requires you to pass the `code` to detect\n  ## how many lines have to be generated (and starting at which point!).\n  inc d.listingCounter\n  let id = $d.listingCounter\n  if not params.numberLines:\n    result = (d.config.getOrDefault\"doc.listing_start\" %\n                [id, sourceLanguageToStr[params.lang], idStr],\n              d.config.getOrDefault\"doc.listing_end\" % id)\n    return\n\n  var codeLines = code.strip.countLines\n  assert codeLines > 0\n  result.beginTable = \"\"\"<table$1 class=\"line-nums-table\">\"\"\" % [idStr] &\n      \"\"\"<tbody><tr><td class=\"blob-line-nums\"><pre class=\"line-nums\">\"\"\"\n  var line = params.startLine\n  while codeLines > 0:\n    result.beginTable.add($line & \"\\n\")\n    line.inc\n    codeLines.dec\n  result.beginTable.add(\"</pre></td><td>\" & (\n      d.config.getOrDefault\"doc.listing_start\" %\n        [id, sourceLanguageToStr[params.lang], idStr]))\n  result.endTable = (d.config.getOrDefault\"doc.listing_end\" % id) &\n      \"</td></tr></tbody></table>\" & (\n      d.config.getOrDefault\"doc.listing_button\" % id)\n\nproc renderCodeLang*(result: var string, lang: SourceLanguage, code: string,\n                     target: OutputTarget) =\n  var g: GeneralTokenizer\n  initGeneralTokenizer(g, code)\n  while true:\n    getNextToken(g, lang)\n    case g.kind\n    of gtEof: break\n    of gtNone, gtWhitespace:\n      add(result, substr(code, g.start, g.length + g.start - 1))\n    else:\n      dispA(target, result, \"<span class=\\\"$2\\\">$1</span>\", \"\\\\span$2{$1}\", [\n        esc(target, substr(code, g.start, g.length+g.start-1)),\n        tokenClassToStr[g.kind]])\n  deinitGeneralTokenizer(g)\n\nproc renderNimCode*(result: var string, code: string, target: OutputTarget) =\n  renderCodeLang(result, langNim, code, target)\n\nproc renderCode(d: PDoc, n: PRstNode, result: var string) =\n  ## Renders a code (code block or inline code), appending it to `result`.\n  ##\n  ## If the code block uses the ``number-lines`` option, a table will be\n  ## generated with two columns, the first being a list of numbers and the\n  ## second the code block itself. The code block can use syntax highlighting,\n  ## which depends on the directive argument specified by the rst input, and\n  ## may also come from the parser through the internal ``default-language``\n  ## option to differentiate between a plain code block and Nim's code block\n  ## extension.\n  assert n.kind in {rnCodeBlock, rnInlineCode}\n  var params = d.parseCodeBlockParams(n)\n  if n.sons[2] == nil: return\n  var m = n.sons[2].sons[0]\n  assert m.kind == rnLeaf\n\n  if params.testCmd.len > 0 and d.onTestSnippet != nil:\n    d.onTestSnippet(d, params.filename, params.testCmd, params.status, m.text)\n\n  var blockStart, blockEnd: string\n  case d.target\n  of outHtml:\n    if n.kind == rnCodeBlock:\n      (blockStart, blockEnd) = buildLinesHtmlTable(d, params, m.text,\n                                                   n.anchor.idS)\n    else:  # rnInlineCode\n      blockStart = \"<tt class=\\\"docutils literal\\\"><span class=\\\"pre\\\">\"\n      blockEnd = \"</span></tt>\"\n  of outLatex:\n    if n.kind == rnCodeBlock:\n      blockStart = \"\\n\\n\" & n.anchor.idS & \"\\\\begin{rstpre}\\n\"\n      blockEnd = \"\\n\\\\end{rstpre}\\n\\n\"\n    else:  # rnInlineCode\n      blockStart = \"\\\\rstcode{\"\n      blockEnd = \"}\"\n  dispA(d.target, result, blockStart, blockStart, [])\n  if params.lang == langNone:\n    if len(params.langStr) > 0:\n      rstMessage(d.filenames, d.msgHandler, n.info, mwUnsupportedLanguage,\n                 params.langStr)\n    for letter in m.text: escChar(d.target, result, letter, emText)\n  else:\n    renderCodeLang(result, params.lang, m.text, d.target)\n  dispA(d.target, result, blockEnd, blockEnd)\n\nproc renderContainer(d: PDoc, n: PRstNode, result: var string) =\n  var tmp = \"\"\n  renderRstToOut(d, n.sons[2], tmp)\n  var arg = esc(d.target, strip(getArgument(n)))\n  if arg == \"\":\n    dispA(d.target, result, \"<div>$1</div>\", \"$1\", [tmp])\n  else:\n    dispA(d.target, result, \"<div class=\\\"$1\\\">$2</div>\", \"$2\", [arg, tmp])\n\nproc texColumns(n: PRstNode): string =\n  let nColumns = if n.sons.len > 0: len(n.sons[0]) else: 1\n  result = \"L\".repeat(nColumns)\n\nproc renderField(d: PDoc, n: PRstNode, result: var string) =\n  var b = false\n  if d.target == outLatex:\n    var fieldname = addNodes(n.sons[0])\n    var fieldval = esc(d.target, strip(addNodes(n.sons[1])))\n    if cmpIgnoreStyle(fieldname, \"author\") == 0 or\n       cmpIgnoreStyle(fieldname, \"authors\") == 0:\n      if d.meta[metaAuthor].len == 0:\n        d.meta[metaAuthor] = fieldval\n        b = true\n    elif cmpIgnoreStyle(fieldname, \"version\") == 0:\n      if d.meta[metaVersion].len == 0:\n        d.meta[metaVersion] = fieldval\n        b = true\n  if not b:\n    renderAux(d, n, \"<tr>$1</tr>\\n\", \"$1\", result)\n\nproc renderEnumList(d: PDoc, n: PRstNode, result: var string) =\n  var\n    specifier = \"\"\n    specStart = \"\"\n    i1 = 0\n    pre = \"\"\n    i2 = n.labelFmt.len - 1\n    post = \"\"\n  if n.labelFmt[0] == '(':\n    i1 = 1\n    pre = \"(\"\n  if n.labelFmt[^1] == ')' or n.labelFmt[^1] == '.':\n    i2 = n.labelFmt.len - 2\n    post = $n.labelFmt[^1]\n  let enumR = i1 .. i2  # enumerator range without surrounding (, ), .\n  if d.target == outLatex:\n    result.add (\"\\n%\" & n.labelFmt & \"\\n\")\n    # use enumerate parameters from package enumitem\n    if n.labelFmt[i1].isDigit:\n      var labelDef = \"\"\n      if pre != \"\" or post != \"\":\n        labelDef = \"label=\" & pre & \"\\\\arabic*\" & post & \",\"\n      if n.labelFmt[enumR] != \"1\":\n        specStart = \"start=$1\" % [n.labelFmt[enumR]]\n      if labelDef != \"\" or specStart != \"\":\n        specifier = \"[$1$2]\" % [labelDef, specStart]\n    else:\n      let (first, labelDef) =\n        if n.labelFmt[i1].isUpperAscii: ('A', \"label=\" & pre & \"\\\\Alph*\" & post)\n        else: ('a', \"label=\" & pre & \"\\\\alph*\" & post)\n      if n.labelFmt[i1] != first:\n        specStart = \",start=\" & $(ord(n.labelFmt[i1]) - ord(first) + 1)\n      specifier = \"[$1$2]\" % [labelDef, specStart]\n  else:  # HTML\n    # TODO: implement enumerator formatting using pre and post ( and ) for HTML\n    if n.labelFmt[i1].isDigit:\n      if n.labelFmt[enumR] != \"1\":\n        specStart = \" start=\\\"$1\\\"\" % [n.labelFmt[enumR]]\n      specifier = \"class=\\\"simple\\\"\" & specStart\n    else:\n      let (first, labelDef) =\n        if n.labelFmt[i1].isUpperAscii: ('A', \"class=\\\"upperalpha simple\\\"\")\n        else: ('a', \"class=\\\"loweralpha simple\\\"\")\n      if n.labelFmt[i1] != first:\n        specStart = \" start=\\\"$1\\\"\" % [ $(ord(n.labelFmt[i1]) - ord(first) + 1) ]\n      specifier = labelDef & specStart\n  renderAux(d, n, \"<ol$2 \" & specifier & \">$1</ol>\\n\",\n            \"\\\\begin{enumerate}\" & specifier & \"$2$1\\\\end{enumerate}\\n\",\n            result)\n\nproc renderAdmonition(d: PDoc, n: PRstNode, result: var string) =\n  var\n    htmlCls = \"admonition_warning\"\n    texSz = \"\\\\large\"\n    texColor = \"orange\"\n  case n.adType\n  of \"hint\", \"note\", \"tip\":\n    htmlCls = \"admonition-info\"; texSz = \"\\\\normalsize\"; texColor = \"green\"\n  of \"attention\", \"admonition\", \"important\", \"warning\", \"caution\":\n    htmlCls = \"admonition-warning\"; texSz = \"\\\\large\"; texColor = \"orange\"\n  of \"danger\", \"error\":\n    htmlCls = \"admonition-error\"; texSz = \"\\\\Large\"; texColor = \"red\"\n  else: discard\n  let txt = n.adType.capitalizeAscii()\n  let htmlHead = \"<div class=\\\"admonition \" & htmlCls & \"\\\">\"\n  renderAux(d, n,\n      htmlHead & \"<span$2 class=\\\"\" & htmlCls & \"-text\\\"><b>\" & txt &\n        \":</b></span>\\n\" & \"$1</div>\\n\",\n      \"\\n\\n\\\\begin{rstadmonition}[borderline west={0.2em}{0pt}{\" &\n        texColor & \"}]$2\\n\" &\n        \"{\" & texSz & \"\\\\color{\" & texColor & \"}{\\\\textbf{\" & txt & \":}}} \" &\n        \"$1\\n\\\\end{rstadmonition}\\n\",\n      result)\n\nproc renderHyperlink(d: PDoc, text, link: PRstNode, result: var string, external: bool) =\n  var linkStr = \"\"\n  block:\n    let mode = d.escMode\n    d.escMode = emUrl\n    renderRstToOut(d, link, linkStr)\n    d.escMode = mode\n  safeProtocol(linkStr)\n  var textStr = \"\"\n  renderRstToOut(d, text, textStr)\n  if external:\n    dispA(d.target, result,\n      \"<a class=\\\"reference external\\\" href=\\\"$2\\\">$1</a>\",\n      \"\\\\href{$2}{$1}\", [textStr, linkStr])\n  else:\n    dispA(d.target, result,\n      \"<a class=\\\"reference internal\\\" href=\\\"#$2\\\">$1</a>\",\n      \"\\\\hyperlink{$2}{$1} (p.~\\\\pageref{$2})\", [textStr, linkStr])\n\nproc renderRstToOut(d: PDoc, n: PRstNode, result: var string) =\n  if n == nil: return\n  case n.kind\n  of rnInner: renderAux(d, n, result)\n  of rnHeadline, rnMarkdownHeadline: renderHeadline(d, n, result)\n  of rnOverline: renderOverline(d, n, result)\n  of rnTransition: renderAux(d, n, \"<hr$2 />\\n\", \"\\n\\n\\\\vspace{0.6em}\\\\hrule$2\\n\", result)\n  of rnParagraph: renderAux(d, n, \"<p$2>$1</p>\\n\", \"\\n\\n$2\\n$1\\n\\n\", result)\n  of rnBulletList:\n    renderAux(d, n, \"<ul$2 class=\\\"simple\\\">$1</ul>\\n\",\n                    \"\\\\begin{itemize}\\n$2\\n$1\\\\end{itemize}\\n\", result)\n  of rnBulletItem, rnEnumItem:\n    renderAux(d, n, \"<li$2>$1</li>\\n\", \"\\\\item $2$1\\n\", result)\n  of rnEnumList: renderEnumList(d, n, result)\n  of rnDefList:\n    renderAux(d, n, \"<dl$2 class=\\\"docutils\\\">$1</dl>\\n\",\n                    \"\\\\begin{description}\\n$2\\n$1\\\\end{description}\\n\", result)\n  of rnDefItem: renderAux(d, n, result)\n  of rnDefName: renderAux(d, n, \"<dt$2>$1</dt>\\n\", \"$2\\\\item[$1]\\\\  \", result)\n  of rnDefBody: renderAux(d, n, \"<dd$2>$1</dd>\\n\", \"$2\\n$1\\n\", result)\n  of rnFieldList:\n    var tmp = \"\"\n    for i in countup(0, len(n) - 1):\n      renderRstToOut(d, n.sons[i], tmp)\n    if tmp.len != 0:\n      dispA(d.target, result,\n          \"<table$2 class=\\\"docinfo\\\" frame=\\\"void\\\" rules=\\\"none\\\">\" &\n          \"<col class=\\\"docinfo-name\\\" />\" &\n          \"<col class=\\\"docinfo-content\\\" />\" &\n          \"<tbody valign=\\\"top\\\">$1\" &\n          \"</tbody></table>\",\n          \"\\\\begin{description}\\n$2\\n$1\\\\end{description}\\n\",\n          [tmp, n.anchor.idS])\n  of rnField: renderField(d, n, result)\n  of rnFieldName:\n    renderAux(d, n, \"<th class=\\\"docinfo-name\\\">$1:</th>\",\n                    \"\\\\item[$1:]\", result)\n  of rnFieldBody:\n    renderAux(d, n, \"<td>$1</td>\", \" $1\\n\", result)\n  of rnIndex:\n    renderRstToOut(d, n.sons[2], result)\n  of rnOptionList:\n    renderAux(d, n, \"<div$2 class=\\\"option-list\\\">$1</div>\",\n        \"\\\\begin{rstoptlist}$2\\n$1\\\\end{rstoptlist}\", result)\n  of rnOptionListItem:\n    var addclass = if n.order mod 2 == 1: \" odd\" else: \"\"\n    renderAux(d, n,\n        \"<div class=\\\"option-list-item\" & addclass & \"\\\">$1</div>\\n\",\n        \"$1\", result)\n  of rnOptionGroup:\n    renderAux(d, n,\n        \"<div class=\\\"option-list-label\\\"><tt><span class=\\\"option\\\">\" &\n        \"$1</span></tt></div>\",\n        \"\\\\item[\\\\rstcodeitem{\\\\spanoption{$1}}]\", result)\n  of rnDescription:\n    renderAux(d, n, \"<div class=\\\"option-list-description\\\">$1</div>\",\n        \" $1\\n\", result)\n  of rnOption, rnOptionString, rnOptionArgument:\n    doAssert false, \"renderRstToOut\"\n  of rnLiteralBlock:\n    renderAux(d, n, \"<pre$2>$1</pre>\\n\",\n                    \"\\n\\n$2\\\\begin{rstpre}\\n$1\\n\\\\end{rstpre}\\n\\n\", result)\n  of rnQuotedLiteralBlock:\n    doAssert false, \"renderRstToOut\"\n  of rnLineBlock:\n    if n.sons.len == 1 and n.sons[0].lineIndent == \"\\n\":\n      # whole line block is one empty line, no need to add extra spacing\n      renderAux(d, n, \"<p$2>$1</p> \", \"\\n\\n$2\\n$1\", result)\n    else:  # add extra spacing around the line block for Latex\n      renderAux(d, n, \"<p$2>$1</p>\",\n        \"\\n\\\\vspace{0.5em}$2\\n$1\\\\vspace{0.5em}\\n\", result)\n  of rnLineBlockItem:\n    if n.lineIndent.len == 0:  # normal case - no additional indentation\n      renderAux(d, n, \"$1<br/>\", \"\\\\noindent $1\\n\\n\", result)\n    elif n.lineIndent == \"\\n\":  # add one empty line\n      renderAux(d, n, \"<br/>\", \"\\\\vspace{1em}\\n\", result)\n    else:  # additional indentation w.r.t. '| '\n      let indent = $(0.5 * (n.lineIndent.len - 1).toFloat) & \"em\"\n      renderAux(d, n,\n        \"<span style=\\\"margin-left: \" & indent & \"\\\">$1</span><br/>\",\n        \"\\\\noindent\\\\hspace{\" & indent & \"}$1\\n\\n\", result)\n  of rnBlockQuote:\n    renderAux(d, n, \"<blockquote$2><p>$1</p></blockquote>\\n\",\n                    \"\\\\begin{quote}\\n$2\\n$1\\\\end{quote}\\n\", result)\n  of rnAdmonition: renderAdmonition(d, n, result)\n  of rnTable, rnGridTable, rnMarkdownTable:\n    renderAux(d, n,\n      \"<table$2 border=\\\"1\\\" class=\\\"docutils\\\">$1</table>\",\n      \"\\n$2\\n\\\\begin{rsttab}{\" &\n        texColumns(n) & \"}\\n\\\\hline\\n$1\\\\end{rsttab}\", result)\n  of rnTableRow:\n    if len(n) >= 1:\n      if d.target == outLatex:\n        #var tmp = \"\"\n        renderRstToOut(d, n.sons[0], result)\n        for i in countup(1, len(n) - 1):\n          result.add(\" & \")\n          renderRstToOut(d, n.sons[i], result)\n        result.add(\"\\\\\\\\\\n\\\\hline\\n\")\n      else:\n        result.add(\"<tr>\")\n        renderAux(d, n, result)\n        result.add(\"</tr>\\n\")\n  of rnTableDataCell:\n    renderAux(d, n, \"<td>$1</td>\", \"$1\", result)\n  of rnTableHeaderCell:\n    renderAux(d, n, \"<th>$1</th>\", \"\\\\textbf{$1}\", result)\n  of rnFootnoteGroup:\n    renderAux(d, n,\n      \"<hr class=\\\"footnote\\\">\" &\n          \"<div class=\\\"footnote-group\\\">\\n$1</div>\\n\",\n      \"\\n\\n\\\\noindent\\\\rule{0.25\\\\linewidth}{.4pt}\\n\" &\n          \"\\\\begin{rstfootnote}\\n$1\\\\end{rstfootnote}\\n\\n\",\n      result)\n  of rnFootnote, rnCitation:\n    var mark = \"\"\n    renderAux(d, n.sons[0], mark)\n    var body = \"\"\n    renderRstToOut(d, n.sons[1], body)\n    dispA(d.target, result,\n      \"<div$2><div class=\\\"footnote-label\\\">\" &\n          \"<sup><strong><a href=\\\"#$4\\\">[$3]</a></strong></sup>\" &\n          \"</div> &ensp; $1\\n</div>\\n\",\n      \"\\\\item[\\\\textsuperscript{[$3]}]$2 $1\\n\",\n      [body, n.anchor.idS, mark, n.anchor])\n  of rnRef:\n    renderHyperlink(d, text=n.sons[0], link=n.sons[0], result, external=false)\n  of rnStandaloneHyperlink:\n    renderHyperlink(d, text=n.sons[0], link=n.sons[0], result, external=true)\n  of rnInternalRef:\n    renderHyperlink(d, text=n.sons[0], link=n.sons[1], result, external=false)\n  of rnHyperlink:\n    renderHyperlink(d, text=n.sons[0], link=n.sons[1], result, external=true)\n  of rnFootnoteRef:\n    var tmp = \"[\"\n    renderAux(d, n.sons[0], tmp)\n    tmp.add \"]\"\n    dispA(d.target, result,\n      \"<sup><strong><a class=\\\"reference internal\\\" href=\\\"#$2\\\">\" &\n          \"$1</a></strong></sup>\",\n      \"\\\\textsuperscript{\\\\hyperlink{$2}{\\\\textbf{$1}}}\",\n      [tmp, n.sons[1].text])\n  of rnDirArg, rnRaw: renderAux(d, n, result)\n  of rnRawHtml:\n    if d.target != outLatex and not lastSon(n).isNil:\n      result.add addNodes(lastSon(n))\n  of rnRawLatex:\n    if d.target == outLatex and not lastSon(n).isNil:\n      result.add addNodes(lastSon(n))\n\n  of rnImage, rnFigure: renderImage(d, n, result)\n  of rnCodeBlock, rnInlineCode: renderCode(d, n, result)\n  of rnContainer: renderContainer(d, n, result)\n  of rnSubstitutionReferences, rnSubstitutionDef:\n    renderAux(d, n, \"|$1|\", \"|$1|\", result)\n  of rnDirective:\n    renderAux(d, n, \"\", \"\", result)\n  of rnUnknownRole, rnCodeFragment:\n    var tmp0 = \"\"\n    var tmp1 = \"\"\n    renderRstToOut(d, n.sons[0], tmp0)\n    renderRstToOut(d, n.sons[1], tmp1)\n    var class = tmp1\n    # don't allow missing role break latex compilation:\n    if d.target == outLatex and n.kind == rnUnknownRole: class = \"Other\"\n    if n.kind == rnCodeFragment:\n      dispA(d.target, result,\n            \"<tt class=\\\"docutils literal\\\"><span class=\\\"pre $2\\\">\" &\n              \"$1</span></tt>\",\n            \"\\\\rstcode{\\\\span$2{$1}}\", [tmp0, class])\n    else:  # rnUnknownRole, not necessarily code/monospace font\n      dispA(d.target, result, \"<span class=\\\"$2\\\">$1</span>\", \"\\\\span$2{$1}\",\n            [tmp0, class])\n  of rnSub: renderAux(d, n, \"<sub>$1</sub>\", \"\\\\rstsub{$1}\", result)\n  of rnSup: renderAux(d, n, \"<sup>$1</sup>\", \"\\\\rstsup{$1}\", result)\n  of rnEmphasis: renderAux(d, n, \"<em>$1</em>\", \"\\\\emph{$1}\", result)\n  of rnStrongEmphasis:\n    renderAux(d, n, \"<strong>$1</strong>\", \"\\\\textbf{$1}\", result)\n  of rnTripleEmphasis:\n    renderAux(d, n, \"<strong><em>$1</em></strong>\",\n                    \"\\\\textbf{emph{$1}}\", result)\n  of rnIdx:\n    renderIndexTerm(d, n, result)\n  of rnInlineLiteral, rnInterpretedText:\n    renderAux(d, n,\n      \"<tt class=\\\"docutils literal\\\"><span class=\\\"pre\\\">$1</span></tt>\",\n      \"\\\\rstcode{$1}\", result)\n  of rnInlineTarget:\n    var tmp = \"\"\n    renderAux(d, n, tmp)\n    dispA(d.target, result,\n      \"<span class=\\\"target\\\" id=\\\"$2\\\">$1</span>\",\n      \"\\\\label{$2}\\\\hypertarget{$2}{$1}\",\n      [tmp, rstnodeToRefname(n)])\n  of rnSmiley: renderSmiley(d, n, result)\n  of rnLeaf: result.add(esc(d.target, n.text, escMode=d.escMode))\n  of rnContents: d.hasToc = true\n  of rnDefaultRole: discard\n  of rnTitle:\n    d.meta[metaTitle] = \"\"\n    renderRstToOut(d, n.sons[0], d.meta[metaTitle])\n\n# -----------------------------------------------------------------------------\n\nproc getVarIdx(varnames: openArray[string], id: string): int =\n  for i in countup(0, high(varnames)):\n    if cmpIgnoreStyle(varnames[i], id) == 0:\n      return i\n  result = -1\n\nproc formatNamedVars*(frmt: string, varnames: openArray[string],\n                      varvalues: openArray[string]): string =\n  var i = 0\n  var L = len(frmt)\n  result = \"\"\n  var num = 0\n  while i < L:\n    if frmt[i] == '$':\n      inc(i)                  # skip '$'\n      case frmt[i]\n      of '#':\n        add(result, varvalues[num])\n        inc(num)\n        inc(i)\n      of '$':\n        add(result, \"$\")\n        inc(i)\n      of '0'..'9':\n        var j = 0\n        while true:\n          j = (j * 10) + ord(frmt[i]) - ord('0')\n          inc(i)\n          if i > L-1 or frmt[i] notin {'0'..'9'}: break\n        if j > high(varvalues) + 1:\n          raise newException(ValueError, \"invalid index: \" & $j)\n        num = j\n        add(result, varvalues[j - 1])\n      of 'A'..'Z', 'a'..'z', '\\x80'..'\\xFF':\n        var id = \"\"\n        while true:\n          add(id, frmt[i])\n          inc(i)\n          if frmt[i] notin {'A'..'Z', '_', 'a'..'z', '\\x80'..'\\xFF'}: break\n        var idx = getVarIdx(varnames, id)\n        if idx >= 0:\n          add(result, varvalues[idx])\n        else:\n          raise newException(ValueError, \"unknown substitution var: \" & id)\n      of '{':\n        var id = \"\"\n        inc(i)\n        while frmt[i] != '}':\n          if frmt[i] == '\\0':\n            raise newException(ValueError, \"'}' expected\")\n          add(id, frmt[i])\n          inc(i)\n        inc(i)                # skip }\n                              # search for the variable:\n        var idx = getVarIdx(varnames, id)\n        if idx >= 0: add(result, varvalues[idx])\n        else:\n          raise newException(ValueError, \"unknown substitution var: \" & id)\n      else:\n        raise newException(ValueError, \"unknown substitution: $\" & $frmt[i])\n    var start = i\n    while i < L:\n      if frmt[i] != '$': inc(i)\n      else: break\n    if i-1 >= start: add(result, substr(frmt, start, i - 1))\n\n\nproc defaultConfig*(): StringTableRef =\n  ## Returns a default configuration for embedded HTML generation.\n  ##\n  ## The returned ``StringTableRef`` contains the parameters used by the HTML\n  ## engine to build the final output. For information on what these parameters\n  ## are and their purpose, please look up the file ``config/nimdoc.cfg``\n  ## bundled with the compiler.\n  ##\n  ## The only difference between the contents of that file and the values\n  ## provided by this proc is the ``doc.file`` variable. The ``doc.file``\n  ## variable of the configuration file contains HTML to build standalone\n  ## pages, while this proc returns just the content for procs like\n  ## ``rstToHtml`` to generate the bare minimum HTML.\n  result = newStringTable(modeStyleInsensitive)\n\n  template setConfigVar(key, val) =\n    result[key] = val\n\n  # If you need to modify these values, it might be worth updating the template\n  # file in config/nimdoc.cfg.\n  setConfigVar(\"split.item.toc\", \"20\")\n  setConfigVar(\"doc.section\", \"\"\"\n<div class=\"section\" id=\"$sectionID\">\n<h1><a class=\"toc-backref\" href=\"#$sectionTitleID\">$sectionTitle</a></h1>\n<dl class=\"item\">\n$content\n</dl></div>\n\"\"\")\n  setConfigVar(\"doc.section.toc\", \"\"\"\n<li>\n  <a class=\"reference\" href=\"#$sectionID\" id=\"$sectionTitleID\">$sectionTitle</a>\n  <ul class=\"simple\">\n    $content\n  </ul>\n</li>\n\"\"\")\n  setConfigVar(\"doc.item\", \"\"\"\n<dt id=\"$itemID\"><a name=\"$itemSymOrIDEnc\"></a><pre>$header</pre></dt>\n<dd>\n$desc\n</dd>\n\"\"\")\n  setConfigVar(\"doc.item.toc\", \"\"\"\n  <li><a class=\"reference\" href=\"#$itemSymOrIDEnc\"\n    title=\"$header_plain\">$name</a></li>\n\"\"\")\n  setConfigVar(\"doc.toc\", \"\"\"\n<div class=\"navigation\" id=\"navigation\">\n<ul class=\"simple\">\n$content\n</ul>\n</div>\"\"\")\n  setConfigVar(\"doc.body_toc\", \"\"\"\n$tableofcontents\n<div class=\"content\" id=\"content\">\n$moduledesc\n$content\n</div>\n\"\"\")\n  setConfigVar(\"doc.listing_start\", \"<pre$3 class = \\\"listing\\\">\")\n  setConfigVar(\"doc.listing_end\", \"</pre>\")\n  setConfigVar(\"doc.listing_button\", \"</pre>\")\n  setConfigVar(\"doc.body_no_toc\", \"$moduledesc $content\")\n  setConfigVar(\"doc.file\", \"$content\")\n  setConfigVar(\"doc.smiley_format\", \"/images/smilies/$1.gif\")\n\n# ---------- forum ---------------------------------------------------------\n\nproc rstToHtml*(s: string, options: RstParseOptions,\n                config: StringTableRef,\n                msgHandler: MsgHandler = rst.defaultMsgHandler): string =\n  ## Converts an input rst string into embeddable HTML.\n  ##\n  ## This convenience proc parses any input string using rst markup (it doesn't\n  ## have to be a full document!) and returns an embeddable piece of HTML. The\n  ## proc is meant to be used in *online* environments without access to a\n  ## meaningful filesystem, and therefore rst ``include`` like directives won't\n  ## work. For an explanation of the ``config`` parameter see the\n  ## ``initRstGenerator`` proc. Example:\n  ##\n  ## .. code-block:: nim\n  ##   import packages/docutils/rstgen, strtabs\n  ##\n  ##   echo rstToHtml(\"*Hello* **world**!\", {},\n  ##     newStringTable(modeStyleInsensitive))\n  ##   # --> <em>Hello</em> <strong>world</strong>!\n  ##\n  ## If you need to allow the rst ``include`` directive or tweak the generated\n  ## output you have to create your own ``RstGenerator`` with\n  ## ``initRstGenerator`` and related procs.\n\n  proc myFindFile(filename: string): string =\n    # we don't find any files in online mode:\n    result = \"\"\n\n  const filen = \"input\"\n  let (rst, filenames, _) = rstParse(s, filen,\n                                     line=LineRstInit, column=ColRstInit,\n                                     options, myFindFile, msgHandler)\n  var d: RstGenerator\n  initRstGenerator(d, outHtml, config, filen, myFindFile, msgHandler, filenames)\n  result = \"\"\n  renderRstToOut(d, rst, result)\n  strbasics.strip(result)\n\n\nproc rstToLatex*(rstSource: string; options: RstParseOptions): string {.inline, since: (1, 3).} =\n  ## Convenience proc for `renderRstToOut` and `initRstGenerator`.\n  runnableExamples: doAssert rstToLatex(\"*Hello* **world**\", {}) == \"\"\"\\emph{Hello} \\textbf{world}\"\"\"\n  if rstSource.len == 0: return\n  let (rst, filenames, _) = rstParse(rstSource, \"\",\n                                     line=LineRstInit, column=ColRstInit,\n                                     options)\n  var rstGenera: RstGenerator\n  rstGenera.initRstGenerator(outLatex, defaultConfig(), \"input\", filenames=filenames)\n  rstGenera.renderRstToOut(rst, result)\n  strbasics.strip(result)\n", "discard \"\"\"\noutputsub: \"\"\n\"\"\"\n\n# tests for rstgen module.\n\nimport ../../lib/packages/docutils/rstgen\nimport ../../lib/packages/docutils/rst\nimport unittest, strutils, strtabs\nimport std/private/miscdollars\n\nproc toHtml(input: string,\n            rstOptions: RstParseOptions = {roPreferMarkdown, roSupportMarkdown, roNimFile},\n            error: ref string = nil,\n            warnings: ref seq[string] = nil): string =\n  ## If `error` is nil then no errors should be generated.\n  ## The same goes for `warnings`.\n  proc testMsgHandler(filename: string, line, col: int, msgkind: MsgKind,\n                      arg: string) =\n    let mc = msgkind.whichMsgClass\n    let a = $msgkind % arg\n    var message: string\n    toLocation(message, filename, line, col + ColRstOffset)\n    message.add \" $1: $2\" % [$mc, a]\n    if mc == mcError:\n      if error == nil:\n        raise newException(EParseError, \"[unexpected error] \" & message)\n      error[] = message\n      # we check only first error because subsequent ones may be meaningless\n      raise newException(EParseError, \"\")\n    else:\n      doAssert warnings != nil, \"unexpected RST warning '\" & message & \"'\"\n      warnings[].add message\n  try:\n    result = rstToHtml(input, rstOptions, defaultConfig(),\n                       msgHandler=testMsgHandler)\n  except EParseError as e:\n    if e.msg != \"\":\n      result = e.msg\n\n# inline code tags (for parsing originated from highlite.nim)\nproc id(str: string): string = \"\"\"<span class=\"Identifier\">\"\"\"  & str & \"</span>\"\nproc op(str: string): string = \"\"\"<span class=\"Operator\">\"\"\"    & str & \"</span>\"\nproc pu(str: string): string = \"\"\"<span class=\"Punctuation\">\"\"\" & str & \"</span>\"\nproc optionListLabel(opt: string): string =\n  \"\"\"<div class=\"option-list-label\"><tt><span class=\"option\">\"\"\" &\n  opt &\n  \"</span></tt></div>\"\n\nsuite \"YAML syntax highlighting\":\n  test \"Basics\":\n    let input = \"\"\".. code-block:: yaml\n    %YAML 1.2\n    ---\n    a string: string\n    a list:\n      - item 1\n      - item 2\n    a map:\n    ? key\n    : value\n    ...\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Directive\">%YAML 1.2</span>\n<span class=\"Keyword\">---</span>\n<span class=\"StringLit\">a string</span><span class=\"Punctuation\">:</span> <span class=\"StringLit\">string</span>\n<span class=\"StringLit\">a list</span><span class=\"Punctuation\">:</span>\n  <span class=\"Punctuation\">-</span> <span class=\"StringLit\">item 1</span>\n  <span class=\"Punctuation\">-</span> <span class=\"StringLit\">item 2</span>\n<span class=\"StringLit\">a map</span><span class=\"Punctuation\">:</span>\n<span class=\"Punctuation\">?</span> <span class=\"StringLit\">key</span>\n<span class=\"Punctuation\">:</span> <span class=\"StringLit\">value</span>\n<span class=\"Keyword\">...</span></pre>\"\"\"\n\n  test \"Block scalars\":\n    let input = \"\"\".. code-block:: yaml\n    a literal block scalar: |\n      some text\n      # not a comment\n     # a comment, since less indented\n      # another comment\n    a folded block scalar: >2\n       some text\n      # not a comment since indented as specified\n     # a comment\n    another literal block scalar:\n      |+ # comment after header\n     allowed, since more indented than parent\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"StringLit\">a literal block scalar</span><span class=\"Punctuation\">:</span> <span class=\"Command\">|</span><span class=\"Command\"></span><span class=\"LongStringLit\">\n  some text\n  # not a comment\n </span><span class=\"Comment\"># a comment, since less indented</span>\n  <span class=\"Comment\"># another comment</span>\n<span class=\"StringLit\">a folded block scalar</span><span class=\"Punctuation\">:</span> <span class=\"Command\">&gt;2</span><span class=\"Command\"></span><span class=\"LongStringLit\">\n   some text\n  # not a comment since indented as specified\n </span><span class=\"Comment\"># a comment</span>\n<span class=\"StringLit\">another literal block scalar</span><span class=\"Punctuation\">:</span>\n  <span class=\"Command\">|+</span> <span class=\"Comment\"># comment after header</span><span class=\"LongStringLit\">\n allowed, since more indented than parent</span></pre>\"\"\"\n\n  test \"Directives\":\n    let input = \"\"\".. code-block:: yaml\n    %YAML 1.2\n    ---\n    %not a directive\n    ...\n    %a directive\n    ...\n    a string\n    % not a directive\n    ...\n    %TAG ! !foo:\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Directive\">%YAML 1.2</span>\n<span class=\"Keyword\">---</span>\n<span class=\"StringLit\">%not a directive</span>\n<span class=\"Keyword\">...</span>\n<span class=\"Directive\">%a directive</span>\n<span class=\"Keyword\">...</span>\n<span class=\"StringLit\">a string</span>\n<span class=\"StringLit\">% not a directive</span>\n<span class=\"Keyword\">...</span>\n<span class=\"Directive\">%TAG ! !foo:</span></pre>\"\"\"\n\n  test \"Flow Style and Numbers\":\n    let input = \"\"\".. code-block:: yaml\n    {\n      \"quoted string\": 42,\n      'single quoted string': false,\n      [ list, \"with\", 'entries' ]: 73.32e-73,\n      more numbers: [-783, 11e78],\n      not numbers: [ 42e, 0023, +32.37, 8 ball]\n    }\"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Punctuation\">{</span>\n  <span class=\"StringLit\">&quot;</span><span class=\"StringLit\">quoted string&quot;</span><span class=\"Punctuation\">:</span> <span class=\"DecNumber\">42</span><span class=\"Punctuation\">,</span>\n  <span class=\"StringLit\">'single quoted string'</span><span class=\"Punctuation\">:</span> <span class=\"StringLit\">false</span><span class=\"Punctuation\">,</span>\n  <span class=\"Punctuation\">[</span> <span class=\"StringLit\">list</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">&quot;</span><span class=\"StringLit\">with&quot;</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">'entries'</span> <span class=\"Punctuation\">]</span><span class=\"Punctuation\">:</span> <span class=\"FloatNumber\">73.32e-73</span><span class=\"Punctuation\">,</span>\n  <span class=\"StringLit\">more numbers</span><span class=\"Punctuation\">:</span> <span class=\"Punctuation\">[</span><span class=\"DecNumber\">-783</span><span class=\"Punctuation\">,</span> <span class=\"FloatNumber\">11e78</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">,</span>\n  <span class=\"StringLit\">not numbers</span><span class=\"Punctuation\">:</span> <span class=\"Punctuation\">[</span> <span class=\"StringLit\">42e</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">0023</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">+32.37</span><span class=\"Punctuation\">,</span> <span class=\"StringLit\">8 ball</span><span class=\"Punctuation\">]</span>\n<span class=\"Punctuation\">}</span></pre>\"\"\"\n\n  test \"Directives: warnings\":\n    let input = dedent\"\"\"\n      .. non-existent-warning: Paragraph.\n\n      .. another.wrong:warning::: Paragraph.\n      \"\"\"\n    var warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    check output == \"\"\n    doAssert warnings[].len == 2\n    check \"(1, 24) Warning: RST style:\" in warnings[0]\n    check \"double colon :: may be missing at end of 'non-existent-warning'\" in warnings[0]\n    check \"(3, 25) Warning: RST style:\" in warnings[1]\n    check \"RST style: too many colons for a directive (should be ::)\" in warnings[1]\n\n  test \"not a directive\":\n    let input = \"..warning:: I am not a warning.\"\n    check input.toHtml == input\n\n  test \"Anchors, Aliases, Tags\":\n    let input = \"\"\".. code-block:: yaml\n    --- !!map\n    !!str string: !<tag:yaml.org,2002:int> 42\n    ? &anchor !!seq []:\n    : !localtag foo\n    alias: *anchor\n    \"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Keyword\">---</span> <span class=\"TagStart\">!!map</span>\n<span class=\"TagStart\">!!str</span> <span class=\"StringLit\">string</span><span class=\"Punctuation\">:</span> <span class=\"TagStart\">!&lt;tag:yaml.org,2002:int&gt;</span> <span class=\"DecNumber\">42</span>\n<span class=\"Punctuation\">?</span> <span class=\"Label\">&amp;anchor</span> <span class=\"TagStart\">!!seq</span> <span class=\"Punctuation\">[</span><span class=\"Punctuation\">]</span><span class=\"Punctuation\">:</span>\n<span class=\"Punctuation\">:</span> <span class=\"TagStart\">!localtag</span> <span class=\"StringLit\">foo</span>\n<span class=\"StringLit\">alias</span><span class=\"Punctuation\">:</span> <span class=\"Reference\">*anchor</span></pre>\"\"\"\n\n  test \"Edge cases\":\n    let input = \"\"\".. code-block:: yaml\n    ...\n     %a string:\n      a:string:not:a:map\n    ...\n    not a list:\n      -2\n      -3\n      -4\n    example.com/not/a#comment:\n      ?not a map key\n    \"\"\"\n    let output = input.toHtml({})\n    doAssert output == \"\"\"<pre class = \"listing\"><span class=\"Keyword\">...</span>\n <span class=\"StringLit\">%a string</span><span class=\"Punctuation\">:</span>\n  <span class=\"StringLit\">a:string:not:a:map</span>\n<span class=\"Keyword\">...</span>\n<span class=\"StringLit\">not a list</span><span class=\"Punctuation\">:</span>\n  <span class=\"DecNumber\">-2</span>\n  <span class=\"DecNumber\">-3</span>\n  <span class=\"DecNumber\">-4</span>\n<span class=\"StringLit\">example.com/not/a#comment</span><span class=\"Punctuation\">:</span>\n  <span class=\"StringLit\">?not a map key</span></pre>\"\"\"\n\n\nsuite \"RST/Markdown general\":\n  test \"RST emphasis\":\n    doAssert rstToHtml(\"*Hello* **world**!\", {},\n      newStringTable(modeStyleInsensitive)) ==\n      \"<em>Hello</em> <strong>world</strong>!\"\n\n  test \"Markdown links\":\n    check(\"(( [Nim](https://nim-lang.org/) ))\".toHtml ==\n        \"\"\"(( <a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a> ))\"\"\")\n    check(\"(([Nim](https://nim-lang.org/)))\".toHtml ==\n        \"\"\"((<a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a>))\"\"\")\n    check(\"[[Nim](https://nim-lang.org/)]\".toHtml ==\n        \"\"\"[<a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a>]\"\"\")\n\n  test \"Markdown tables\":\n    let input1 = \"\"\"\n| A1 header    | A2 \\| not fooled\n| :---         | ----:       |\n| C1           | C2 **bold** | ignored |\n| D1 `code \\|` | D2          | also ignored\n| E1 \\| text   |\n|              | F2 without pipe\nnot in table\"\"\"\n    let output1 = input1.toHtml\n    #[\n    TODO: `\\|` inside a table cell should render as `|`\n        `|` outside a table cell should render as `\\|`\n    consistently with markdown, see https://stackoverflow.com/a/66557930/1426932\n    ]#\n    check(output1 == \"\"\"\n<table border=\"1\" class=\"docutils\"><tr><th>A1 header</th><th>A2 | not fooled</th></tr>\n<tr><td>C1</td><td>C2 <strong>bold</strong></td></tr>\n<tr><td>D1 <tt class=\"docutils literal\"><span class=\"pre\">\"\"\" & id\"code\" & \" \" & op\"\\|\" & \"\"\"</span></tt></td><td>D2</td></tr>\n<tr><td>E1 | text</td><td></td></tr>\n<tr><td></td><td>F2 without pipe</td></tr>\n</table><p>not in table</p>\"\"\")\n    let input2 = \"\"\"\n| A1 header | A2 |\n| --- | --- |\"\"\"\n    let output2 = input2.toHtml\n    doAssert output2 == \"\"\"<table border=\"1\" class=\"docutils\"><tr><th>A1 header</th><th>A2</th></tr>\n</table>\"\"\"\n\n  test \"RST tables\":\n    let input1 = \"\"\"\nTest 2 column/4 rows table:\n====   ===\nH0     H1\n====   ===\nA0     A1\n====   ===\nA2     A3\n====   ===\nA4     A5\n====   === \"\"\"\n    let output1 = rstToLatex(input1, {})\n    doAssert \"{LL}\" in output1  # 2 columns\n    doAssert count(output1, \"\\\\\\\\\") == 4  # 4 rows\n    for cell in [\"H0\", \"H1\", \"A0\", \"A1\", \"A2\", \"A3\", \"A4\", \"A5\"]:\n      doAssert cell in output1\n\n    let input2 = \"\"\"\nNow test 3 columns / 2 rows, and also borders containing 4 =, 3 =, 1 = signs:\n\n====   ===  =\nH0     H1   H\n====   ===  =\nA0     A1   X\n       Ax   Y\n====   ===  = \"\"\"\n    let output2 = rstToLatex(input2, {})\n    doAssert \"{LLL}\" in output2  # 3 columns\n    doAssert count(output2, \"\\\\\\\\\") == 2  # 2 rows\n    for cell in [\"H0\", \"H1\", \"H\", \"A0\", \"A1\", \"X\", \"Ax\", \"Y\"]:\n      doAssert cell in output2\n\n\n  test \"RST adornments\":\n    let input1 = \"\"\"\nCheck that a few punctuation symbols are not parsed as adornments:\n:word1: word2 .... word3 \"\"\"\n    let output1 = input1.toHtml\n    discard output1\n\n  test \"RST sections\":\n    let input1 = \"\"\"\nLong chapter name\n'''''''''''''''''''\n\"\"\"\n    let output1 = input1.toHtml\n    doAssert \"Long chapter name\" in output1 and \"<h1\" in output1\n\n    let input2 = \"\"\"\nShort chapter name:\n\nChA\n===\n\"\"\"\n    let output2 = input2.toHtml\n    doAssert \"ChA\" in output2 and \"<h1\" in output2\n\n    let input3 = \"\"\"\nVery short chapter name:\n\nX\n~\n\"\"\"\n    let output3 = input3.toHtml\n    doAssert \"X\" in output3 and \"<h1\" in output3\n\n    let input4 = \"\"\"\nCheck that short underline is not enough to make section:\n\nWrong chapter\n------------\n\n\"\"\"\n    var error4 = new string\n    let output4 = input4.toHtml(error = error4)\n    check(error4[] == \"input(3, 1) Error: new section expected (underline \" &\n            \"\\'------------\\' is too short)\")\n\n    let input5 = \"\"\"\nCheck that punctuation after adornment and indent are not detected as adornment.\n\nSome chapter\n--------------\n\n  \"punctuation symbols\" \"\"\"\n    let output5 = input5.toHtml\n    doAssert \"&quot;punctuation symbols&quot;\" in output5 and \"<h1\" in output5\n\n    # check that EOF after adornment does not prevent it parsing as heading\n    let input6 = dedent \"\"\"\n      Some chapter\n      ------------\"\"\"\n    let output6 = input6.toHtml\n    doAssert \"<h1 id=\\\"some-chapter\\\">Some chapter</h1>\" in output6\n\n    # check that overline and underline match\n    let input7 = dedent \"\"\"\n      ------------\n      Some chapter\n      -----------\n      \"\"\"\n    var error7 = new string\n    let output7 = input7.toHtml(error=error7)\n    check(error7[] == \"input(1, 1) Error: new section expected (underline \" &\n            \"\\'-----------\\' does not match overline \\'------------\\')\")\n\n    let input8 = dedent \"\"\"\n      -----------\n          Overflow\n      -----------\n      \"\"\"\n    var error8 = new string\n    let output8 = input8.toHtml(error=error8)\n    check(error8[] == \"input(1, 1) Error: new section expected (overline \" &\n            \"\\'-----------\\' is too short)\")\n\n    # check that hierarchy of title styles works\n    let input9good = dedent \"\"\"\n      Level1\n      ======\n\n      Level2\n      ------\n\n      Level3\n      ~~~~~~\n\n      L1\n      ==\n\n      Another2\n      --------\n\n      More3\n      ~~~~~\n\n      \"\"\"\n    let output9good = input9good.toHtml\n    doAssert \"<h1 id=\\\"level1\\\">Level1</h1>\" in output9good\n    doAssert \"<h2 id=\\\"level2\\\">Level2</h2>\" in output9good\n    doAssert \"<h3 id=\\\"level3\\\">Level3</h3>\" in output9good\n    doAssert \"<h1 id=\\\"l1\\\">L1</h1>\" in output9good\n    doAssert \"<h2 id=\\\"another2\\\">Another2</h2>\" in output9good\n    doAssert \"<h3 id=\\\"more3\\\">More3</h3>\" in output9good\n\n    # check that swap causes an exception\n    let input9Bad = dedent \"\"\"\n      Level1\n      ======\n\n      Level2\n      ------\n\n      Level3\n      ~~~~~~\n\n      L1\n      ==\n\n      More\n      ~~~~\n\n      Another\n      -------\n\n      \"\"\"\n    var error9Bad = new string\n    let output9Bad = input9bad.toHtml(error=error9Bad)\n    check(error9Bad[] == \"input(15, 1) Error: new section expected (section \" &\n            \"level inconsistent: underline ~~~~~ unexpectedly found, while \" &\n            \"the following intermediate section level(s) are missing on \" &\n            \"lines 12..15: underline -----)\")\n\n  test \"RST sections overline\":\n    # the same as input9good but with overline headings\n    # first overline heading has a special meaning: document title\n    let input = dedent \"\"\"\n      ======\n      Title0\n      ======\n\n      +++++++++\n      SubTitle0\n      +++++++++\n\n      ------\n      Level1\n      ------\n\n      Level2\n      ------\n\n      ~~~~~~\n      Level3\n      ~~~~~~\n\n      --\n      L1\n      --\n\n      Another2\n      --------\n\n      ~~~~~\n      More3\n      ~~~~~\n\n      \"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames = files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"Title0\"\n    doAssert rstGenera.meta[metaSubTitle] == \"SubTitle0\"\n    doAssert \"<h1 id=\\\"level1\\\"><center>Level1</center></h1>\" in output\n    doAssert \"<h2 id=\\\"level2\\\">Level2</h2>\" in output\n    doAssert \"<h3 id=\\\"level3\\\"><center>Level3</center></h3>\" in output\n    doAssert \"<h1 id=\\\"l1\\\"><center>L1</center></h1>\" in output\n    doAssert \"<h2 id=\\\"another2\\\">Another2</h2>\" in output\n    doAssert \"<h3 id=\\\"more3\\\"><center>More3</center></h3>\" in output\n\n  test \"RST sections overline 2\":\n    # check that a paragraph prevents interpreting overlines as document titles\n    let input = dedent \"\"\"\n      Paragraph\n\n      ======\n      Title0\n      ======\n\n      +++++++++\n      SubTitle0\n      +++++++++\n      \"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames=files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"\"\n    doAssert rstGenera.meta[metaSubTitle] == \"\"\n    doAssert \"<h1 id=\\\"title0\\\"><center>Title0</center></h1>\" in output\n    doAssert \"<h2 id=\\\"subtitle0\\\"><center>SubTitle0</center></h2>\" in output\n\n  test \"RST+Markdown sections\":\n    # check that RST and Markdown headings don't interfere\n    let input = dedent \"\"\"\n      ======\n      Title0\n      ======\n\n      MySection1a\n      +++++++++++\n\n      # MySection1b\n\n      MySection1c\n      +++++++++++\n\n      ##### MySection5a\n\n      MySection2a\n      -----------\n      \"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {roSupportMarkdown})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames=files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"Title0\"\n    doAssert rstGenera.meta[metaSubTitle] == \"\"\n    doAssert output ==\n             \"\\n<h1 id=\\\"mysection1a\\\">MySection1a</h1>\" & # RST\n             \"\\n<h1 id=\\\"mysection1b\\\">MySection1b</h1>\" & # Markdown\n             \"\\n<h1 id=\\\"mysection1c\\\">MySection1c</h1>\" & # RST\n             \"\\n<h5 id=\\\"mysection5a\\\">MySection5a</h5>\" & # Markdown\n             \"\\n<h2 id=\\\"mysection2a\\\">MySection2a</h2>\"   # RST\n\n  test \"RST inline text\":\n    let input1 = \"GC_step\"\n    let output1 = input1.toHtml\n    doAssert output1 == \"GC_step\"\n\n  test \"RST links\":\n    let input1 = \"\"\"\nWant to learn about `my favorite programming language`_?\n\n.. _my favorite programming language: https://nim-lang.org\"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<a\" in output1 and \"href=\\\"https://nim-lang.org\\\"\" in output1\n\n  test \"RST transitions\":\n    let input1 = \"\"\"\ncontext1\n\n~~~~\n\ncontext2\n\"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<hr\" in output1\n\n    let input2 = \"\"\"\nThis is too short to be a transition:\n\n---\n\ncontext2\n\"\"\"\n    var error2 = new string\n    let output2 = input2.toHtml(error=error2)\n    check(error2[] == \"input(3, 1) Error: new section expected (overline \" &\n            \"\\'---\\' is too short)\")\n\n  test \"RST literal block\":\n    let input1 = \"\"\"\nTest literal block\n\n::\n\n  check \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<pre>\" in output1\n\n  test \"Markdown code block\":\n    let input1 = \"\"\"\n```\nlet x = 1\n``` \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<pre\" in output1 and \"class=\\\"Keyword\\\"\" notin output1\n\n    let input2 = \"\"\"\nParse the block with language specifier:\n```Nim\nlet x = 1\n``` \"\"\"\n    let output2 = input2.toHtml\n    doAssert \"<pre\" in output2 and \"class=\\\"Keyword\\\"\" in output2\n\n  test \"interpreted text\":\n    check(\"\"\"`foo.bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"foo\" & op\".\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`foo\\`\\`bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"foo\" & pu\"`\" & pu\"`\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`foo\\`bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"foo\" & pu\"`\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`\\`bar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      pu\"`\" & id\"bar\" & \"</span></tt>\")\n    check(\"\"\"`a\\b\\x\\\\ar`\"\"\".toHtml ==\n      \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">\"\"\" &\n      id\"a\" & op\"\"\"\\\"\"\" & id\"b\" & op\"\"\"\\\"\"\" & id\"x\" & op\"\"\"\\\\\"\"\" & id\"ar\" &\n      \"</span></tt>\")\n\n  test \"inline literal\":\n    check \"\"\"``foo.bar``\"\"\".toHtml == \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">foo.bar</span></tt>\"\"\"\n    check \"\"\"``foo\\bar``\"\"\".toHtml == \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">foo\\bar</span></tt>\"\"\"\n    check \"\"\"``f\\`o\\\\o\\b`ar``\"\"\".toHtml == \"\"\"<tt class=\"docutils literal\"><span class=\"pre\">f\\`o\\\\o\\b`ar</span></tt>\"\"\"\n\n  test \"default-role\":\n    # nim(default) -> literal -> nim -> code(=literal)\n    let input = dedent\"\"\"\n      Par1 `value1`.\n\n      .. default-role:: literal\n\n      Par2 `value2`.\n\n      .. default-role:: nim\n\n      Par3 `value3`.\n\n      .. default-role:: code\n\n      Par4 `value4`.\"\"\"\n    let p1 = \"\"\"Par1 <tt class=\"docutils literal\"><span class=\"pre\">\"\"\" & id\"value1\" & \"</span></tt>.\"\n    let p2 = \"\"\"<p>Par2 <tt class=\"docutils literal\"><span class=\"pre\">value2</span></tt>.</p>\"\"\"\n    let p3 = \"\"\"<p>Par3 <tt class=\"docutils literal\"><span class=\"pre\">\"\"\" & id\"value3\" & \"</span></tt>.</p>\"\n    let p4 = \"\"\"<p>Par4 <tt class=\"docutils literal\"><span class=\"pre\">value4</span></tt>.</p>\"\"\"\n    let expected = p1 & p2 & \"\\n\" & p3 & \"\\n\" & p4\n    check(input.toHtml == expected)\n\n  test \"role directive\":\n    let input = dedent\"\"\"\n      .. role:: y(code)\n         :language: yaml\n\n      .. role:: brainhelp(code)\n         :language: brainhelp\n    \"\"\"\n    var warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    check(warnings[].len == 1 and \"language 'brainhelp' not supported\" in warnings[0])\n\n  test \"RST comments\":\n    let input1 = \"\"\"\n\nCheck that comment disappears:\n\n..\n  some comment \"\"\"\n    let output1 = input1.toHtml\n    doAssert output1 == \"Check that comment disappears:\"\n\n  test \"RST line blocks + headings\":\n    let input = \"\"\"\n=====\nTest1\n=====\n\n|\n|\n| line block\n| other line\n\n\"\"\"\n    var rstGenera: RstGenerator\n    var output: string\n    let (rst, files, _) = rstParse(input, \"\", 1, 1, {})\n    rstGenera.initRstGenerator(outHtml, defaultConfig(), \"input\", filenames=files)\n    rstGenera.renderRstToOut(rst, output)\n    doAssert rstGenera.meta[metaTitle] == \"Test1\"\n      # check that title was not overwritten to '|'\n    doAssert output == \"<p><br/><br/>line block<br/>other line<br/></p>\"\n    let output1l = rstToLatex(input, {})\n    doAssert \"line block\\n\\n\" in output1l\n    doAssert \"other line\\n\\n\" in output1l\n    doAssert output1l.count(\"\\\\vspace\") == 2 + 2  # +2 surrounding paddings\n\n  test \"RST line blocks\":\n    let input2 = dedent\"\"\"\n      Paragraph1\n\n      |\n\n      Paragraph2\"\"\"\n\n    let output2 = input2.toHtml\n    doAssert \"Paragraph1<p><br/></p> <p>Paragraph2</p>\" == output2\n\n    let input3 = dedent\"\"\"\n      | xxx\n      |   yyy\n      |     zzz\"\"\"\n\n    let output3 = input3.toHtml\n    doAssert \"xxx<br/>\" in output3\n    doAssert \"<span style=\\\"margin-left: 1.0em\\\">yyy</span><br/>\" in output3\n    doAssert \"<span style=\\\"margin-left: 2.0em\\\">zzz</span><br/>\" in output3\n\n    # check that '|   ' with a few spaces is still parsed as new line\n    let input4 = dedent\"\"\"\n      | xxx\n      |\n      |     zzz\"\"\"\n\n    let output4 = input4.toHtml\n    doAssert \"xxx<br/><br/>\" in output4\n    doAssert \"<span style=\\\"margin-left: 2.0em\\\">zzz</span><br/>\" in output4\n\n  test \"RST enumerated lists\":\n    let input1 = dedent \"\"\"\n      1. line1\n         1\n      2. line2\n         2\n\n      3. line3\n         3\n\n\n      4. line4\n         4\n\n\n\n      5. line5\n         5\n      \"\"\"\n    let output1 = input1.toHtml\n    for i in 1..5:\n      doAssert ($i & \". line\" & $i) notin output1\n      doAssert (\"<li>line\" & $i & \" \" & $i & \"</li>\") in output1\n\n    let input2 = dedent \"\"\"\n      3. line3\n\n      4. line4\n\n\n      5. line5\n\n\n\n      7. line7\n\n\n\n\n      8. line8\n      \"\"\"\n    let output2 = input2.toHtml\n    for i in [3, 4, 5, 7, 8]:\n      doAssert ($i & \". line\" & $i) notin output2\n      doAssert (\"<li>line\" & $i & \"</li>\") in output2\n\n    # check that nested enumerated lists work\n    let input3 = dedent \"\"\"\n      1.  a) string1\n      2. string2\n      \"\"\"\n    let output3 = input3.toHtml\n    doAssert count(output3, \"<ol \") == 2\n    doAssert count(output3, \"</ol>\") == 2\n    doAssert \"<li>string1</li>\" in output3 and \"<li>string2</li>\" in output3\n\n    let input4 = dedent \"\"\"\n      Check that enumeration specifiers are respected\n\n      9. string1\n      10. string2\n      12. string3\n\n      b) string4\n      c) string5\n      e) string6\n      \"\"\"\n    let output4 = input4.toHtml\n    doAssert count(output4, \"<ol \") == 4\n    doAssert count(output4, \"</ol>\") == 4\n    for enumerator in [9, 12]:\n      doAssert \"start=\\\"$1\\\"\" % [$enumerator] in output4\n    for enumerator in [2, 5]:  # 2=b, 5=e\n      doAssert \"start=\\\"$1\\\"\" % [$enumerator] in output4\n\n    let input5 = dedent \"\"\"\n      Check that auto-numbered enumeration lists work.\n\n      #. string1\n\n      #. string2\n\n      #. string3\n\n      #) string5\n      #) string6\n      \"\"\"\n    let output5 = input5.toHtml\n    doAssert count(output5, \"<ol \") == 2\n    doAssert count(output5, \"</ol>\") == 2\n    doAssert count(output5, \"<li>\") == 5\n\n    let input5a = dedent \"\"\"\n      Auto-numbered RST list can start with 1 even when Markdown support is on.\n\n      1. string1\n      #. string2\n      #. string3\n      \"\"\"\n    let output5a = input5a.toHtml\n    doAssert count(output5a, \"<ol \") == 1\n    doAssert count(output5a, \"</ol>\") == 1\n    doAssert count(output5a, \"<li>\") == 3\n\n    let input6 = dedent \"\"\"\n      ... And for alphabetic enumerators too!\n\n      b. string1\n      #. string2\n      #. string3\n      \"\"\"\n    let output6 = input6.toHtml\n    doAssert count(output6, \"<ol \") == 1\n    doAssert count(output6, \"</ol>\") == 1\n    doAssert count(output6, \"<li>\") == 3\n    doAssert \"start=\\\"2\\\"\" in output6 and \"class=\\\"loweralpha simple\\\"\" in output6\n\n    let input7 = dedent \"\"\"\n      ... And for uppercase alphabetic enumerators.\n\n      C. string1\n      #. string2\n      #. string3\n      \"\"\"\n    let output7 = input7.toHtml\n    doAssert count(output7, \"<ol \") == 1\n    doAssert count(output7, \"</ol>\") == 1\n    doAssert count(output7, \"<li>\") == 3\n    doAssert \"start=\\\"3\\\"\" in output7 and \"class=\\\"upperalpha simple\\\"\" in output7\n\n    # check that it's not recognized as enum.list without indentation on 2nd line\n    let input8 = dedent \"\"\"\n      Paragraph.\n\n      A. stringA\n      B. stringB\n      C. string1\n      string2\n      \"\"\"\n    var warnings8 = new seq[string]\n    let output8 = input8.toHtml(warnings = warnings8)\n    check(warnings8[].len == 1)\n    check(\"input(6, 1) Warning: RST style: \\n\" &\n          \"not enough indentation on line 6\" in warnings8[0])\n    doAssert output8 == \"Paragraph.<ol class=\\\"upperalpha simple\\\">\" &\n        \"<li>stringA</li>\\n<li>stringB</li>\\n</ol>\\n<p>C. string1 string2 </p>\"\n\n  test \"Markdown enumerated lists\":\n    let input1 = dedent \"\"\"\n      Below are 2 enumerated lists: Markdown-style (5 items) and RST (1 item)\n      1. line1\n      1. line2\n      1. line3\n      1. line4\n\n      1. line5\n\n      #. lineA\n      \"\"\"\n    let output1 = input1.toHtml\n    for i in 1..5:\n      doAssert ($i & \". line\" & $i) notin output1\n      doAssert (\"<li>line\" & $i & \"</li>\") in output1\n    doAssert count(output1, \"<ol \") == 2\n    doAssert count(output1, \"</ol>\") == 2\n\n  test \"RST bullet lists\":\n    let input1 = dedent \"\"\"\n      * line1\n        1\n      * line2\n        2\n\n      * line3\n        3\n\n\n      * line4\n        4\n\n\n\n      * line5\n        5\n      \"\"\"\n    let output1 = input1.toHtml\n    for i in 1..5:\n      doAssert (\"<li>line\" & $i & \" \" & $i & \"</li>\") in output1\n    doAssert count(output1, \"<ul \") == 1\n    doAssert count(output1, \"</ul>\") == 1\n\n  test \"Nim RST footnotes and citations\":\n    # check that auto-label footnote enumerated properly after a manual one\n    let input1 = dedent \"\"\"\n      .. [1] Body1.\n      .. [#note] Body2\n\n      Ref. [#note]_\n      \"\"\"\n    let output1 = input1.toHtml\n    doAssert output1.count(\">[1]</a>\") == 1\n    doAssert output1.count(\">[2]</a>\") == 2\n    doAssert \"href=\\\"#footnote-note\\\"\" in output1\n    doAssert \">[-1]\" notin output1\n    doAssert \"Body1.\" in output1\n    doAssert \"Body2\" in output1\n\n    # check that there are NO footnotes/citations, only comments:\n    let input2 = dedent \"\"\"\n      .. [1 #] Body1.\n      .. [# note] Body2.\n      .. [wrong citation] That gives you a comment.\n\n      .. [not&allowed] That gives you a comment.\n\n      Not references[#note]_[1 #]_ [wrong citation]_ and [not&allowed]_.\n      \"\"\"\n    let output2 = input2.toHtml\n    doAssert output2 == \"Not references[#note]_[1 #]_ [wrong citation]_ and [not&amp;allowed]_.\"\n\n    # check that auto-symbol footnotes work:\n    let input3 = dedent \"\"\"\n      Ref. [*]_ and [*]_ and [*]_.\n\n      .. [*] Body1\n      .. [*] Body2.\n\n\n      .. [*] Body3.\n      .. [*] Body4\n\n      And [*]_.\n      \"\"\"\n    let output3 = input3.toHtml\n    # both references and footnotes. Footnotes have link to themselves.\n    doAssert output3.count(\"href=\\\"#footnotesym-1\\\">[*]</a>\") == 2\n    doAssert output3.count(\"href=\\\"#footnotesym-2\\\">[**]</a>\") == 2\n    doAssert output3.count(\"href=\\\"#footnotesym-3\\\">[***]</a>\") == 2\n    doAssert output3.count(\"href=\\\"#footnotesym-4\\\">[^]</a>\") == 2\n    # footnote group\n    doAssert output3.count(\"<hr class=\\\"footnote\\\">\" &\n                           \"<div class=\\\"footnote-group\\\">\") == 1\n    # footnotes\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-1\\\">[*]</a></strong></sup></div>\") == 1\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-2\\\">[**]</a></strong></sup></div>\") == 1\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-3\\\">[***]</a></strong></sup></div>\") == 1\n    doAssert output3.count(\"<div class=\\\"footnote-label\\\"><sup><strong>\" &\n               \"<a href=\\\"#footnotesym-4\\\">[^]</a></strong></sup></div>\") == 1\n    for i in 1 .. 4: doAssert (\"Body\" & $i) in output3\n\n    # check manual, auto-number and auto-label footnote enumeration\n    let input4 = dedent \"\"\"\n      .. [3] Manual1.\n      .. [#] Auto-number1.\n      .. [#mylabel] Auto-label1.\n      .. [#note] Auto-label2.\n      .. [#] Auto-number2.\n\n      Ref. [#note]_ and [#]_ and [#]_.\n      \"\"\"\n    let output4 = input4.toHtml\n    doAssert \">[-1]\" notin output1\n    let order = @[\n        \"footnote-3\", \"[3]\", \"Manual1.\",\n        \"footnoteauto-1\", \"[1]\", \"Auto-number1\",\n        \"footnote-mylabel\", \"[2]\", \"Auto-label1\",\n        \"footnote-note\", \"[4]\", \"Auto-label2\",\n        \"footnoteauto-2\", \"[5]\", \"Auto-number2\",\n        ]\n    for i in 0 .. order.len-2:\n      let pos1 = output4.find(order[i])\n      let pos2 = output4.find(order[i+1])\n      doAssert pos1 >= 0\n      doAssert pos2 >= 0\n      doAssert pos1 < pos2\n\n    # forgot [#]_\n    let input5 = dedent \"\"\"\n      .. [3] Manual1.\n      .. [#] Auto-number1.\n      .. [#note] Auto-label2.\n\n      Ref. [#note]_\n      \"\"\"\n    var error5 = new string\n    let output5 = input5.toHtml(error=error5)\n    check(error5[] == \"input(1, 1) Error: mismatch in number of footnotes \" &\n            \"and their refs: 1 (lines 2) != 0 (lines ) for auto-numbered \" &\n            \"footnotes\")\n\n    # extra [*]_\n    let input6 = dedent \"\"\"\n      Ref. [*]_\n\n      .. [*] Auto-Symbol.\n\n      Ref. [*]_\n      \"\"\"\n    var error6 = new string\n    let output6 = input6.toHtml(error=error6)\n    check(error6[] == \"input(1, 1) Error: mismatch in number of footnotes \" &\n            \"and their refs: 1 (lines 3) != 2 (lines 2, 6) for auto-symbol \" &\n            \"footnotes\")\n\n    let input7 = dedent \"\"\"\n      .. [Some:CITATION-2020] Citation.\n\n      Ref. [some:citation-2020]_.\n      \"\"\"\n    let output7 = input7.toHtml\n    doAssert output7.count(\"href=\\\"#citation-somecoloncitationminus2020\\\"\") == 2\n    doAssert output7.count(\"[Some:CITATION-2020]\") == 1\n    doAssert output7.count(\"[some:citation-2020]\") == 1\n    doAssert output3.count(\"<hr class=\\\"footnote\\\">\" &\n                           \"<div class=\\\"footnote-group\\\">\") == 1\n\n    let input8 = dedent \"\"\"\n      .. [Some] Citation.\n\n      Ref. [som]_.\n      \"\"\"\n    var warnings8 = new seq[string]\n    let output8 = input8.toHtml(warnings=warnings8)\n    check(warnings8[] == @[\"input(3, 7) Warning: broken link 'citation-som'\"])\n\n    # check that footnote group does not break parsing of other directives:\n    let input9 = dedent \"\"\"\n      .. [Some] Citation.\n\n      .. _`internal anchor`:\n\n      .. [Another] Citation.\n      .. just comment.\n      .. [Third] Citation.\n\n      Paragraph1.\n\n      Paragraph2 ref `internal anchor`_.\n      \"\"\"\n    let output9 = input9.toHtml\n    #doAssert \"id=\\\"internal-anchor\\\"\" in output9\n    #doAssert \"internal anchor\" notin output9\n    doAssert output9.count(\"<hr class=\\\"footnote\\\">\" &\n                           \"<div class=\\\"footnote-group\\\">\") == 1\n    doAssert output9.count(\"<div class=\\\"footnote-label\\\">\") == 3\n    doAssert \"just comment\" notin output9\n\n    # check that nested citations/footnotes work\n    let input10 = dedent \"\"\"\n      Paragraph1 [#]_.\n\n      .. [First] Citation.\n\n         .. [#] Footnote.\n\n            .. [Third] Citation.\n      \"\"\"\n    let output10 = input10.toHtml\n    doAssert output10.count(\"<hr class=\\\"footnote\\\">\" &\n                            \"<div class=\\\"footnote-group\\\">\") == 3\n    doAssert output10.count(\"<div class=\\\"footnote-label\\\">\") == 3\n    doAssert \"<a href=\\\"#citation-first\\\">[First]</a>\" in output10\n    doAssert \"<a href=\\\"#footnoteauto-1\\\">[1]</a>\" in output10\n    doAssert \"<a href=\\\"#citation-third\\\">[Third]</a>\" in output10\n\n    let input11 = \".. [note]\\n\"  # should not crash\n    let output11 = input11.toHtml\n    doAssert \"<a href=\\\"#citation-note\\\">[note]</a>\" in output11\n\n    # check that references to auto-numbered footnotes work\n    let input12 = dedent \"\"\"\n      Ref. [#]_ and [#]_ STOP.\n\n      .. [#] Body1.\n      .. [#] Body3\n      .. [2] Body2.\n      \"\"\"\n    let output12 = input12.toHtml\n    let orderAuto = @[\n        \"#footnoteauto-1\", \"[1]\",\n        \"#footnoteauto-2\", \"[3]\",\n        \"STOP.\",\n        \"Body1.\", \"Body3\", \"Body2.\"\n        ]\n    for i in 0 .. orderAuto.len-2:\n      let pos1 = output12.find(orderAuto[i])\n      let pos2 = output12.find(orderAuto[i+1])\n      doAssert pos1 >= 0\n      doAssert pos2 >= 0\n      doAssert pos1 < pos2\n\n  test \"Nim (RST extension) code-block\":\n    # check that presence of fields doesn't consume the following text as\n    # its code (which is a literal block)\n    let input0 = dedent \"\"\"\n      .. code-block:: nim\n         :number-lines: 0\n\n      Paragraph1\"\"\"\n    let output0 = input0.toHtml\n    doAssert \"<p>Paragraph1</p>\" in output0\n\n  test \"Nim code-block :number-lines:\":\n    let input = dedent \"\"\"\n      .. code-block:: nim\n         :number-lines: 55\n\n         x\n         y\n      \"\"\"\n    check \"<pre class=\\\"line-nums\\\">55\\n56\\n</pre>\" in input.toHtml\n\n  test \"Nim code-block indentation\":\n    let input = dedent \"\"\"\n      .. code-block:: nim\n        :number-lines: 55\n\n       x\n      \"\"\"\n    let output = input.toHtml\n    check \"<pre class=\\\"line-nums\\\">55\\n</pre>\" in output\n    check \"<span class=\\\"Identifier\\\">x</span>\" in output\n\n  test \"Nim code-block indentation\":\n    let input = dedent \"\"\"\n      .. code-block:: nim\n        :number-lines: 55\n         let a = 1\n      \"\"\"\n    var error = new string\n    let output = input.toHtml(error=error)\n    check(error[] == \"input(2, 3) Error: invalid field: \" &\n                     \"extra arguments were given to number-lines: ' let a = 1'\")\n    check \"\" == output\n\n  test \"code-block warning\":\n    let input = dedent \"\"\"\n      .. code:: Nim\n         :unsupportedField: anything\n\n      .. code:: unsupportedLang\n\n         anything\n\n      ```anotherLang\n      someCode\n      ```\n      \"\"\"\n    let warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    check(warnings[] == @[\n        \"input(2, 4) Warning: field 'unsupportedField' not supported\",\n        \"input(4, 11) Warning: language 'unsupportedLang' not supported\",\n        \"input(8, 4) Warning: language 'anotherLang' not supported\"\n        ])\n    check(output == \"<pre class = \\\"listing\\\">anything</pre>\" &\n                    \"<p><pre class = \\\"listing\\\">\\nsomeCode\\n</pre> </p>\")\n\n  test \"RST admonitions\":\n    # check that all admonitions are implemented\n    let input0 = dedent \"\"\"\n      .. admonition:: endOf admonition\n      .. attention:: endOf attention\n      .. caution:: endOf caution\n      .. danger:: endOf danger\n      .. error:: endOf error\n      .. hint:: endOf hint\n      .. important:: endOf important\n      .. note:: endOf note\n      .. tip:: endOf tip\n      .. warning:: endOf warning\n    \"\"\"\n    let output0 = input0.toHtml\n    for a in [\"admonition\", \"attention\", \"caution\", \"danger\", \"error\", \"hint\",\n        \"important\", \"note\", \"tip\", \"warning\" ]:\n      doAssert \"endOf \" & a & \"</div>\" in output0\n\n    # Test that admonition does not swallow up the next paragraph.\n    let input1 = dedent \"\"\"\n      .. error:: endOfError\n\n      Test paragraph.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"endOfError</div>\" in output1\n    doAssert \"<p>Test paragraph. </p>\" in output1\n    doAssert \"class=\\\"admonition admonition-error\\\"\" in output1\n\n    # Test that second line is parsed as continuation of the first line.\n    let input2 = dedent \"\"\"\n      .. error:: endOfError\n        Test2p.\n\n      Test paragraph.\n    \"\"\"\n    let output2 = input2.toHtml\n    doAssert \"endOfError Test2p.</div>\" in output2\n    doAssert \"<p>Test paragraph. </p>\" in output2\n    doAssert \"class=\\\"admonition admonition-error\\\"\" in output2\n\n    let input3 = dedent \"\"\"\n      .. note:: endOfNote\n    \"\"\"\n    let output3 = input3.toHtml\n    doAssert \"endOfNote</div>\" in output3\n    doAssert \"class=\\\"admonition admonition-info\\\"\" in output3\n\n  test \"RST internal links\":\n    let input1 = dedent \"\"\"\n      Start.\n\n      .. _target000:\n\n      Paragraph.\n\n      .. _target001:\n\n      * bullet list\n      * Y\n\n      .. _target002:\n\n      1. enumeration list\n      2. Y\n\n      .. _target003:\n\n      term 1\n        Definition list 1.\n\n      .. _target004:\n\n      | line block\n\n      .. _target005:\n\n      :a: field list value\n\n      .. _target006:\n\n      -a  option description\n\n      .. _target007:\n\n      ::\n\n        Literal block\n\n      .. _target008:\n\n      Doctest blocks are not implemented.\n\n      .. _target009:\n\n          block quote\n\n      .. _target010:\n\n      =====  =====  =======\n        A      B    A and B\n      =====  =====  =======\n      False  False  False\n      =====  =====  =======\n\n      .. _target100:\n\n      .. CAUTION:: admonition\n\n      .. _target101:\n\n      .. code:: nim\n\n         const pi = 3.14\n\n      .. _target102:\n\n      .. code-block::\n\n         const pi = 3.14\n\n      Paragraph2.\n\n      .. _target202:\n\n      ----\n\n      That was a transition.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<p id=\\\"target000\\\"\"     in output1\n    doAssert \"<ul id=\\\"target001\\\"\"    in output1\n    doAssert \"<ol id=\\\"target002\\\"\"    in output1\n    doAssert \"<dl id=\\\"target003\\\"\"    in output1\n    doAssert \"<p id=\\\"target004\\\"\"     in output1\n    doAssert \"<table id=\\\"target005\\\"\" in output1  # field list\n    doAssert \"<div id=\\\"target006\\\"\"   in output1  # option list\n    doAssert \"<pre id=\\\"target007\\\"\"   in output1\n    doAssert \"<blockquote id=\\\"target009\\\"\" in output1\n    doAssert \"<table id=\\\"target010\\\"\" in output1  # just table\n    doAssert \"<span id=\\\"target100\\\"\"  in output1\n    doAssert \"<pre id=\\\"target101\\\"\"   in output1  # code\n    doAssert \"<pre id=\\\"target102\\\"\"   in output1  # code-block\n    doAssert \"<hr id=\\\"target202\\\"\"    in output1\n\n  test \"RST internal links for sections\":\n    let input1 = dedent \"\"\"\n      .. _target101:\n      .. _target102:\n\n      Section xyz\n      -----------\n\n      Ref. target101_\n    \"\"\"\n    let output1 = input1.toHtml\n    # \"target101\" should be erased and changed to \"section-xyz\":\n    doAssert \"href=\\\"#target101\\\"\" notin output1\n    doAssert \"id=\\\"target101\\\"\"    notin output1\n    doAssert \"href=\\\"#target102\\\"\" notin output1\n    doAssert \"id=\\\"target102\\\"\"    notin output1\n    doAssert \"id=\\\"section-xyz\\\"\"     in output1\n    doAssert \"href=\\\"#section-xyz\\\"\"  in output1\n\n    let input2 = dedent \"\"\"\n      .. _target300:\n\n      Section xyz\n      ===========\n\n      .. _target301:\n\n      SubsectionA\n      -----------\n\n      Ref. target300_ and target301_.\n\n      .. _target103:\n\n      .. [cit2020] note.\n\n      Ref. target103_.\n\n    \"\"\"\n    let output2 = input2.toHtml\n    # \"target101\" should be erased and changed to \"section-xyz\":\n    doAssert \"href=\\\"#target300\\\"\" notin output2\n    doAssert \"id=\\\"target300\\\"\"    notin output2\n    doAssert \"href=\\\"#target301\\\"\" notin output2\n    doAssert \"id=\\\"target301\\\"\"    notin output2\n    doAssert \"<h1 id=\\\"section-xyz\\\"\" in output2\n    doAssert \"<h2 id=\\\"subsectiona\\\"\" in output2\n    # links should preserve their original names but point to section labels:\n    doAssert \"href=\\\"#section-xyz\\\">target300\" in output2\n    doAssert \"href=\\\"#subsectiona\\\">target301\" in output2\n    doAssert \"href=\\\"#citation-cit2020\\\">target103\" in output2\n\n    let output2l = rstToLatex(input2, {})\n    doAssert \"\\\\label{section-xyz}\\\\hypertarget{section-xyz}{}\" in output2l\n    doAssert \"\\\\hyperlink{section-xyz}{target300}\"  in output2l\n    doAssert \"\\\\hyperlink{subsectiona}{target301}\"  in output2l\n\n  test \"RST internal links (inline)\":\n    let input1 = dedent \"\"\"\n      Paragraph with _`some definition`.\n\n      Ref. `some definition`_.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"<span class=\\\"target\\\" \" &\n        \"id=\\\"some-definition\\\">some definition</span>\" in output1\n    doAssert \"Ref. <a class=\\\"reference internal\\\" \" &\n        \"href=\\\"#some-definition\\\">some definition</a>\" in output1\n\n  test \"RST references (additional symbols)\":\n    # check that ., _, -, +, : are allowed symbols in references without ` `\n    let input1 = dedent \"\"\"\n      sec.1\n      -----\n\n      2-other:sec+c_2\n      ^^^^^^^^^^^^^^^\n\n      .. _link.1_2021:\n\n      Paragraph\n\n      Ref. sec.1_! and 2-other:sec+c_2_;and link.1_2021_.\n    \"\"\"\n    let output1 = input1.toHtml\n    doAssert \"id=\\\"secdot1\\\"\" in output1\n    doAssert \"id=\\\"Z2minusothercolonsecplusc-2\\\"\" in output1\n    doAssert \"id=\\\"linkdot1-2021\\\"\" in output1\n    let ref1 = \"<a class=\\\"reference internal\\\" href=\\\"#secdot1\\\">sec.1</a>\"\n    let ref2 = \"<a class=\\\"reference internal\\\" href=\\\"#Z2minusothercolonsecplusc-2\\\">2-other:sec+c_2</a>\"\n    let ref3 = \"<a class=\\\"reference internal\\\" href=\\\"#linkdot1-2021\\\">link.1_2021</a>\"\n    let refline = \"Ref. \" & ref1 & \"! and \" & ref2 & \";and \" & ref3 & \".\"\n    doAssert refline in output1\n\n  test \"Option lists 1\":\n    # check that \"* b\" is not consumed by previous bullet item because of\n    # incorrect indentation handling in option lists\n    let input = dedent \"\"\"\n      * a\n        -m   desc\n        -n   very long\n             desc\n      * b\"\"\"\n    let output = input.toHtml\n    check(output.count(\"<ul\") == 1)\n    check(output.count(\"<li>\") == 2)\n    check(output.count(\"<div class=\\\"option-list\\\"\") == 1)\n    check(optionListLabel(\"-m\") &\n          \"\"\"<div class=\"option-list-description\">desc</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-n\") &\n          \"\"\"<div class=\"option-list-description\">very long desc</div></div>\"\"\" in\n          output)\n\n  test \"Option lists 2\":\n    # check that 2nd option list is not united with the 1st\n    let input = dedent \"\"\"\n      * a\n        -m   desc\n        -n   very long\n             desc\n      -d  option\"\"\"\n    let output = input.toHtml\n    check(output.count(\"<ul\") == 1)\n    check output.count(\"<div class=\\\"option-list\\\"\") == 2\n    check(optionListLabel(\"-m\") &\n          \"\"\"<div class=\"option-list-description\">desc</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-n\") &\n          \"\"\"<div class=\"option-list-description\">very long desc</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-d\") &\n          \"\"\"<div class=\"option-list-description\">option</div></div>\"\"\" in\n          output)\n    check \"<p>option</p>\" notin output\n\n  test \"Option list 3 (double /)\":\n    let input = dedent \"\"\"\n      * a\n        //compile  compile1\n        //doc      doc1\n                   cont\n      -d  option\"\"\"\n    let output = input.toHtml\n    check(output.count(\"<ul\") == 1)\n    check output.count(\"<div class=\\\"option-list\\\"\") == 2\n    check(optionListLabel(\"compile\") &\n          \"\"\"<div class=\"option-list-description\">compile1</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"doc\") &\n          \"\"\"<div class=\"option-list-description\">doc1 cont</div></div>\"\"\" in\n          output)\n    check(optionListLabel(\"-d\") &\n          \"\"\"<div class=\"option-list-description\">option</div></div>\"\"\" in\n          output)\n    check \"<p>option</p>\" notin output\n\n  test \"Roles: subscript prefix/postfix\":\n    let expected = \"See <sub>some text</sub>.\"\n    check \"See :subscript:`some text`.\".toHtml == expected\n    check \"See `some text`:subscript:.\".toHtml == expected\n\n  test \"Roles: correct parsing from beginning of line\":\n    let expected = \"<sup>3</sup>He is an isotope of helium.\"\n    check \"\"\":superscript:`3`\\ He is an isotope of helium.\"\"\".toHtml == expected\n    check \"\"\":sup:`3`\\ He is an isotope of helium.\"\"\".toHtml == expected\n    check \"\"\"`3`:sup:\\ He is an isotope of helium.\"\"\".toHtml == expected\n    check \"\"\"`3`:superscript:\\ He is an isotope of helium.\"\"\".toHtml == expected\n\n  test \"Roles: warnings\":\n    let input = dedent\"\"\"\n      See function :py:func:`spam`.\n\n      See also `egg`:py:class:.\n      \"\"\"\n    var warnings = new seq[string]\n    let output = input.toHtml(warnings=warnings)\n    doAssert warnings[].len == 2\n    check \"(1, 14) Warning: \" in warnings[0]\n    check \"language 'py:func' not supported\" in warnings[0]\n    check \"(3, 15) Warning: \" in warnings[1]\n    check \"language 'py:class' not supported\" in warnings[1]\n    check(\"\"\"<p>See function <span class=\"py:func\">spam</span>.</p>\"\"\" & \"\\n\" &\n          \"\"\"<p>See also <span class=\"py:class\">egg</span>. </p>\"\"\" ==\n          output)\n\n  test \"(not) Roles: check escaping 1\":\n    let expected = \"\"\"See :subscript:<tt class=\"docutils literal\">\"\"\" &\n                   \"\"\"<span class=\"pre\">\"\"\" & id\"some\" & \" \" & id\"text\" &\n                   \"</span></tt>.\"\n    check \"\"\"See \\:subscript:`some text`.\"\"\".toHtml == expected\n    check \"\"\"See :subscript\\:`some text`.\"\"\".toHtml == expected\n\n  test \"(not) Roles: check escaping 2\":\n    check(\"\"\"See :subscript:\\`some text\\`.\"\"\".toHtml ==\n          \"See :subscript:`some text`.\")\n\n  test \"Field list\":\n    check(\":field: text\".toHtml ==\n            \"\"\"<table class=\"docinfo\" frame=\"void\" rules=\"none\">\"\"\" &\n            \"\"\"<col class=\"docinfo-name\" /><col class=\"docinfo-content\" />\"\"\" &\n            \"\"\"<tbody valign=\"top\"><tr><th class=\"docinfo-name\">field:</th>\"\"\" &\n            \"\"\"<td>text</td></tr>\"\"\" & \"\\n</tbody></table>\")\n\n  test \"Field list: body after newline\":\n    let output = dedent \"\"\"\n      :field:\n        text1\"\"\".toHtml\n    check \"<table class=\\\"docinfo\\\"\" in output\n    check \">field:</th>\" in output\n    check \"<td>text1</td>\" in output\n\n  test \"Field list (incorrect)\":\n    check \":field:text\".toHtml == \":field:text\"\n\nsuite \"RST/Code highlight\":\n  test \"Basic Python code highlight\":\n    let pythonCode = \"\"\"\n    .. code-block:: python\n\n      def f_name(arg=42):\n          print(f\"{arg}\")\n\n    \"\"\"\n\n    let expected = \"\"\"<blockquote><p><span class=\"Keyword\">def</span> f_name<span class=\"Punctuation\">(</span><span class=\"Punctuation\">arg</span><span class=\"Operator\">=</span><span class=\"DecNumber\">42</span><span class=\"Punctuation\">)</span><span class=\"Punctuation\">:</span>\n    print<span class=\"Punctuation\">(</span><span class=\"RawData\">f&quot;{arg}&quot;</span><span class=\"Punctuation\">)</span></p></blockquote>\"\"\"\n\n    check strip(rstToHtml(pythonCode, {}, newStringTable(modeCaseSensitive))) ==\n      strip(expected)\n\n\nsuite \"invalid targets\":\n  test \"invalid image target\":\n    let input1 = dedent \"\"\".. image:: /images/myimage.jpg\n      :target: https://bar.com\n      :alt: Alt text for the image\"\"\"\n    let output1 = input1.toHtml\n    check output1 == \"\"\"<a class=\"reference external\" href=\"https://bar.com\"><img src=\"/images/myimage.jpg\" alt=\"Alt text for the image\"/></a>\"\"\"\n\n    let input2 = dedent \"\"\".. image:: /images/myimage.jpg\n      :target: javascript://bar.com\n      :alt: Alt text for the image\"\"\"\n    let output2 = input2.toHtml\n    check output2 == \"\"\"<img src=\"/images/myimage.jpg\" alt=\"Alt text for the image\"/>\"\"\"\n\n    let input3 = dedent \"\"\".. image:: /images/myimage.jpg\n      :target: bar.com\n      :alt: Alt text for the image\"\"\"\n    let output3 = input3.toHtml\n    check output3 == \"\"\"<a class=\"reference external\" href=\"bar.com\"><img src=\"/images/myimage.jpg\" alt=\"Alt text for the image\"/></a>\"\"\"\n\n  test \"invalid links\":\n    check(\"(([Nim](https://nim-lang.org/)))\".toHtml ==\n        \"\"\"((<a class=\"reference external\" href=\"https://nim-lang.org/\">Nim</a>))\"\"\")\n    check(\"(([Nim](javascript://nim-lang.org/)))\".toHtml ==\n        \"\"\"((<a class=\"reference external\" href=\"\">Nim</a>))\"\"\")\n"], "filenames": ["lib/packages/docutils/rstgen.nim", "tests/stdlib/trstgen.nim"], "buggy_code_start_loc": [43, 401], "buggy_code_end_loc": [1189, 1550], "fixing_code_start_loc": [43, 401], "fixing_code_end_loc": [1203, 1578], "type": "CWE-79", "message": "An issue was discovered in Nim before 1.6.2. The RST module of the Nim language stdlib, as used in NimForum and other products, permits the javascript: URI scheme and thus can lead to XSS in some applications. (Nim versions 1.6.2 and later are fixed; there may be backports of the fix to some earlier versions. NimForum 2.2.0 is fixed.)", "other": {"cve": {"id": "CVE-2021-46872", "sourceIdentifier": "cve@mitre.org", "published": "2023-01-13T06:15:10.940", "lastModified": "2023-01-23T20:19:06.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in Nim before 1.6.2. The RST module of the Nim language stdlib, as used in NimForum and other products, permits the javascript: URI scheme and thus can lead to XSS in some applications. (Nim versions 1.6.2 and later are fixed; there may be backports of the fix to some earlier versions. NimForum 2.2.0 is fixed.)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nim-lang:nim:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.2", "matchCriteriaId": "1693ADAF-84A1-4F3D-8C13-C6495A1D91D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nim-lang:nimforum:*:*:*:*:*:nim:*:*", "versionEndExcluding": "2.2.0", "matchCriteriaId": "FE0421BD-56F6-4822-B2F4-B7B31071BC57"}]}]}], "references": [{"url": "https://forum.nim-lang.org/t/8852", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/nim-lang/Nim/commit/46275126b89218e64844eee169e8ced05dd0e2d7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nim-lang/Nim/compare/v1.6.0...v1.6.2", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/nim-lang/Nim/pull/19134", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nim-lang/nimforum", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nim-lang/Nim/commit/46275126b89218e64844eee169e8ced05dd0e2d7"}}