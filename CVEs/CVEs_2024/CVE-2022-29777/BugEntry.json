{"buggy_code": ["\ufeff/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n#ifndef _ASC_FONTCONVERTER_FONT_FILE_BASE_H\n#define _ASC_FONTCONVERTER_FONT_FILE_BASE_H\n\n#include <stdio.h>\n#include \"MemoryUtils.h\"\n#include \"../../common/File.h\"\n\nnamespace NSFontConverter\n{\n    //------------------------------------------------------------------------\n\n    typedef void (*FontFileOutputFunc)(void *pStream, const char *sData, int nLen);\n\n    //------------------------------------------------------------------------\n    // CFontFileBase\n    //------------------------------------------------------------------------\n\n    class CFontFileBase\n    {\n    public:\n\n        virtual ~CFontFileBase()\n        {\n            if ( m_bFreeFileData )\n                MemUtilsFree( m_sFileData );\n        }\n\n    protected:\n\n        CFontFileBase(char *sFile, int nLen, bool bFreeFileData)\n        {\n            m_sFileData = m_sFile = (unsigned char *)sFile;\n            m_nLen = nLen;\n            m_bFreeFileData = bFreeFileData;\n            m_nPos = 0;\n        }\n\n        void         Reset()\n        {\n            m_nPos = 0;\n        }\n        static char *ReadFile(const wchar_t *wsFileName, int *pnFileLen)\n        {\n            NSFile::CFileBinary oFile;\n            if ( !oFile.OpenFile(wsFileName) )\n                return NULL;\n\n            int nLen = (int)oFile.GetFileSize();\n            char *sBuffer = (char *)MemUtilsMalloc( nLen );\n            DWORD dwRead = 0;\n            oFile.ReadFile((BYTE*)sBuffer, (DWORD)nLen, dwRead);\n\n            if ((int)dwRead != nLen)\n            {\n                MemUtilsFree( sBuffer );\n                return NULL;\n            }\n\n            *pnFileLen = nLen;\n            return sBuffer;\n        }\n\n        // S = signed / U = unsigned\n        // 8/16/32/Var = word length, in bytes\n        // BE = big endian\n        int          GetS8    (int nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            if ( nRes & 0x80 )\n                nRes |= ~0xff;\n            return nRes;\n        }\n\n        int          GetU8    (int nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            return m_sFile[ nPos ];\n        }\n\n        int          GetS16BE (int nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( nPos < 0 || nPos + 1 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            if ( nRes & 0x8000 )\n                nRes |= ~0xffff;\n            return nRes;\n        }\n\n        int          GetU16BE (int nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( nPos < 0 || nPos + 1 >= m_nLen)\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            return nRes;\n        }\n\n        int          GetS32BE (int nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            if ( nRes & 0x80000000 )\n                nRes |= ~0xffffffff;\n\n            return nRes;\n        }\n\n        unsigned int GetU32BE (int nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            return nRes;\n        }\n        unsigned int GetU32LE (int nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos + 3];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 0];\n            return nRes;\n        }\n        unsigned int GetUVarBE(int nPos, int nSize, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( nPos < 0 || nPos + nSize > m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = 0;\n            for ( int nIndex = 0; nIndex < nSize; ++nIndex )\n                nRes = (nRes << 8) + m_sFile[nPos + nIndex];\n\n            return nRes;\n        }\n\n        bool         CheckRegion(int nPos, int nSize)\n        {\n            return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);\n        }\n        int          ReadS8   (bool *pbSuccess)\n        {\n            return GetS8( m_nPos++, pbSuccess );\n        }\n        int          ReadU8   (bool *pbSuccess)\n        {\n            return GetU8( m_nPos++, pbSuccess );\n        }\n        unsigned int ReadU32BE(bool *pbSuccess)\n        {\n            unsigned int unResult = GetU32BE( m_nPos, pbSuccess );\n            m_nPos += 4;\n            return unResult;\n        }\n        unsigned int ReadU32LE(bool *pbSuccess)\n        {\n            unsigned int unResult = GetU32LE( m_nPos, pbSuccess );\n            m_nPos += 4;\n            return unResult;\n        }\n        int          Read(void* pDestBuffer, int nSize)\n        {\n            if ( m_nPos + nSize >= m_nLen )\n                nSize = m_nLen - m_nPos - 1;\n\n            memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );\n            m_nPos += nSize;\n\n            return nSize;\n        }\n\n    protected:\n\n        unsigned char *m_sFileData;\n        unsigned char *m_sFile;\n        int            m_nLen;\n        bool           m_bFreeFileData;\n        int            m_nPos;\n\n    };\n}\n\n#endif /* _ASC_FONTCONVERTER_FONT_FILE_BASE_H */\n", "\ufeff/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n#include <stdlib.h>\n#include <string.h>\n#include \"MemoryUtils.h\"\n#include \"FontFileEncodings.h\"\n#include \"FontFileType1.h\"\n\nnamespace NSFontConverter\n{\n    #define LINESIZE 1024\n\n    #define PFB_MARKER 128\n    #define PFB_ASCII    1\n    #define PFB_BINARY   2\n    #define PFB_DONE     3\n\n\n    #define IS_PS_NEWLINE( ch ) \\\n      ( (ch) == '\\r' ||         \\\n        (ch) == '\\n' )\n\n    #define IS_PS_SPACE( ch )  \\\n      ( (ch) == ' '         || \\\n        IS_PS_NEWLINE( ch ) || \\\n        (ch) == '\\t'        || \\\n        (ch) == '\\f'        || \\\n        (ch) == '\\0' )\n\n    // \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0434\u043b\u044f \u0431\u044b\u0441\u0442\u0440\u043e\u0433\u043e \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0446\u0438\u0444\u0440 (\u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u044b\u0445 \u0438 \u043d\u0435 \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u044b\u0445) \u0432 \u0447\u0438\u0441\u043b\u0430\n    static const signed char c_arrCharTable[128] =\n    {\n        /* 0x00 */\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n         0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n    };\n\n    // \u041d\u0438 \u043e\u0434\u0438\u043d \u0441\u0438\u043c\u0432\u043e\u043b \u0431\u043e\u043b\u044c\u0448\u0435 >= 0x80 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c \u0447\u0438\u0441\u043b\u043e\n    #define OP  >=\n\n    #define WriteChar(Value) \\\n        nChar = (char)(Value);\\\n        pOutputFunc( pOutputStream, &nChar, 1 );\n\n    unsigned int EexecDecode   (unsigned char** cursor, unsigned char* limit, unsigned char* buffer, unsigned int n, unsigned short* seed )\n    {\n        unsigned char*  p;\n        unsigned int r;\n        unsigned int s = *seed;\n\n        p = *cursor;\n        if ( n > (unsigned int)(limit - p) )\n          n = (unsigned int)(limit - p);\n\n        for ( r = 0; r < n; r++ )\n        {\n          unsigned int  val = p[r];\n          unsigned int  b   = ( val ^ ( s >> 8 ) );\n\n\n          s         = ( (val + s)*52845U + 22719 ) & 0xFFFFU;\n          buffer[r] = (unsigned char) b;\n        }\n\n        *cursor = p + n;\n        *seed   = (unsigned short)s;\n\n        return r;\n      }\n\n    unsigned int ASCIIHexDecode(unsigned char** cursor, unsigned char* limit, unsigned char* buffer, unsigned int n)\n    {\n        unsigned char*  p;\n        unsigned int  r   = 0;\n        unsigned int  w   = 0;\n        unsigned int  pad = 0x01;\n\n\n        n *= 2;\n\n        p  = *cursor;\n        if ( n > (unsigned int)( limit - p ) )\n          n = (unsigned int)( limit - p );\n\n        /* we try to process two nibbles at a time to be as fast as possible */\n        for ( ; r < n; r++ )\n        {\n          FT_UInt  c = p[r];\n\n\n          if ( IS_PS_SPACE( c ) )\n            continue;\n\n          if ( c OP 0x80 )\n            break;\n\n          c = c_arrCharTable[c & 0x7F];\n          if ( (unsigned)c >= 16 )\n            break;\n\n          pad = ( pad << 4 ) | c;\n          if ( pad & 0x100 )\n          {\n            buffer[w++] = (FT_Byte)pad;\n            pad         = 0x01;\n          }\n        }\n\n        if ( pad != 0x01 )\n          buffer[w++] = (FT_Byte)( pad << 4 );\n\n        *cursor = p + r;\n\n        return w;\n      }\n    //------------------------------------------------------------------------\n    // CFontFileType1\n    //------------------------------------------------------------------------\n\n    CFontFileType1 *CFontFileType1::LoadFromBuffer(char *sBuffer, int nLen)\n    {\n        return new CFontFileType1(sBuffer, nLen, false);\n    }\n\n    CFontFileType1 *CFontFileType1::LoadFromFile(const wchar_t *wsFileName)\n    {\n        char *sBuffer;\n        int nLen = 0;\n\n        if ( !( sBuffer = CFontFileBase::ReadFile(wsFileName, &nLen) ) )\n            return NULL;\n\n        return new CFontFileType1(sBuffer, nLen, true);\n    }\n\n    CFontFileType1::CFontFileType1(char *sBuffer, int nLen, bool bFreeData):\n    CFontFileBase(sBuffer, nLen, bFreeData)\n    {\n        m_sName = NULL;\n        m_arrEncoding = NULL;\n\n        Parse();\n        m_bParsed = false;\n    }\n\n    CFontFileType1::~CFontFileType1()\n    {\n        if (m_sName)\n            MemUtilsFree(m_sName);\n\n        if ( m_arrEncoding && m_arrEncoding != c_arrsFontFileType1StandardEncoding )\n        {\n            for (int nIndex = 0; nIndex < 256; ++nIndex )\n            {\n                MemUtilsFree( m_arrEncoding[nIndex] );\n            }\n            MemUtilsFree(m_arrEncoding);\n        }\n    }\n\n    char *CFontFileType1::GetName()\n    {\n        if ( !m_bParsed )\n            Parse();\n\n        return m_sName;\n    }\n\n    char **CFontFileType1::GetEncoding()\n    {\n        if (!m_bParsed)\n            Parse();\n\n        return m_arrEncoding;\n    }\n\n    void CFontFileType1::WriteEncoded(char **ppNewEncoding, FontFileOutputFunc pOutputFunc, void *pOutputStream)\n    {\n        char sBuffer[512];\n        char *sLine, *sLine2, *sCurChar;\n\n        // \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u0434\u043e \u0441\u0442\u0440\u043e\u0447\u043a\u0438 /Encoding\n        for ( sLine = (char *)m_sFile; sLine && strncmp( sLine, \"/Encoding\", 9); sLine = GetNextLine(sLine) );\n        if ( !sLine )\n        {\n            // \u043d\u0435 \u043d\u0430\u0448\u043b\u0438 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0443, \u0442\u043e\u0433\u0434\u0430 \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0446\u0435\u043b\u0438\u043a\u043e\u043c \u0444\u043e\u043d\u0442 \u0444\u0430\u0439\u043b\n            (*pOutputFunc)( pOutputStream, (char *)m_sFile, m_nLen);\n            return;\n        }\n        (*pOutputFunc)( pOutputStream, (char *)m_sFile, sLine - (char *)m_sFile);\n\n        // \u043f\u0438\u0448\u0435\u043c \u043d\u043e\u0432\u0443\u044e \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0443\n        (*pOutputFunc)( pOutputStream, \"/Encoding 256 array\\n\", 20);\n        (*pOutputFunc)( pOutputStream, \"0 1 255 {1 index exch /.notdef put} for\\n\", 40);\n        for ( int nIndex = 0; nIndex < 256; ++nIndex )\n        {\n            if (ppNewEncoding[nIndex])\n            {\n                sprintf( sBuffer, \"dup %d /%s put\\n\", nIndex, ppNewEncoding[nIndex]);\n                (*pOutputFunc)( pOutputStream, sBuffer, strlen( sBuffer ));\n            }\n        }\n        (*pOutputFunc)( pOutputStream, \"readonly def\\n\", 13);\n\n        if ( !strncmp( sLine, \"/Encoding StandardEncoding def\", 30) )\n        {\n            sLine = GetNextLine(sLine);\n        }\n        else\n        {\n            sCurChar = sLine + 10;\n            sLine = NULL;\n            for (; sCurChar < (char *)m_sFile + m_nLen; ++sCurChar)\n            {\n                if ((*sCurChar == ' ' || *sCurChar == '\\t' || *sCurChar == '\\x0a' || *sCurChar == '\\x0d' || *sCurChar == '\\x0c' || *sCurChar == '\\0') && sCurChar + 4 <= (char *)m_sFile + m_nLen && !strncmp(sCurChar + 1, \"def\", 3) )\n                {\n                    sLine = sCurChar + 4;\n                    break;\n                }\n            }\n        }\n\n        // \u0423 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0444\u043e\u043d\u0442\u043e\u0432 \u0434\u0432\u0435 \u0437\u0430\u043f\u0438\u0441\u0438 /Encoding, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043d\u0430\u043b\u0438\u0447\u0438\u0435 \u0432\u0442\u043e\u0440\u043e\u0439 \u0437\u0430\u043f\u0438\u0441\u0438\n        if ( sLine )\n        {\n            int nIndex;\n            for ( sLine2 = sLine, nIndex = 0; nIndex < 20 && sLine2 && strncmp(sLine2, \"/Encoding\", 9); sLine2 = GetNextLine(sLine2), ++nIndex) ;\n            if ( nIndex < 20 && sLine2 )\n            {\n                (*pOutputFunc)( pOutputStream, sLine, sLine2 - sLine);\n                if ( !strncmp(sLine2, \"/Encoding StandardEncoding def\", 30) )\n                {\n                    sLine = GetNextLine( sLine2 );\n                }\n                else\n                {\n                    sCurChar = sLine2 + 10;\n                    sLine = NULL;\n                    for (; sCurChar < (char *)m_sFile + m_nLen; ++sCurChar)\n                    {\n                        if ((*sCurChar == ' ' || *sCurChar == '\\t' || *sCurChar == '\\x0a' || *sCurChar == '\\x0d' || *sCurChar == '\\x0c' || *sCurChar == '\\0') && sCurChar + 4 <= (char *)m_sFile + m_nLen && !strncmp(sCurChar + 1, \"def\", 3) )\n                        {\n                            sLine = sCurChar + 4;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u043f\u043e\u0441\u043b\u0435 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0438\n            if ( sLine )\n            {\n                (*pOutputFunc)( pOutputStream, sLine, ((char *)m_sFile + m_nLen) - sLine );\n            }\n        }\n    }\n\n    char *CFontFileType1::GetNextLine(char *sLine)\n    {\n        while ( sLine < (char *)m_sFile + m_nLen && *sLine != '\\x0a' && *sLine != '\\x0d')\n            ++sLine;\n\n        if ( sLine < (char *)m_sFile + m_nLen && *sLine == '\\x0d')\n            ++sLine;\n\n        if ( sLine < (char *)m_sFile + m_nLen && *sLine == '\\x0a')\n            ++sLine;\n\n        if ( sLine >= (char *)m_sFile + m_nLen )\n            return NULL;\n\n        return sLine;\n    }\n\n    void CFontFileType1::Parse()\n    {\n        // \u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u043c, \u0435\u0441\u043b\u0438 \u044d\u0442\u043e pfb \u0444\u0430\u0439\u043b, \u0442\u043e\u0433\u0434\u0430 \u0438\u0437\u0431\u0430\u0432\u0438\u043c\u0441\u044f \u043e\u0442 \u0432\u0441\u0435\u0445 \u0435\u0433\u043e \u043c\u0430\u0440\u043a\u0435\u0440\u043e\u0432.\n        Reset();\n\n        while( m_nPos < m_nLen && ( ' ' == m_sFile[m_nPos] || '\\t' == m_sFile[m_nPos] || '\\r' == m_sFile[m_nPos] || '\\n' == m_sFile[m_nPos] ) )\n            ++m_nPos;\n\n        bool bSuccess = true;\n        int nChar = GetU8( m_nPos, &bSuccess );\n        if ( !bSuccess || ( PFB_MARKER != nChar && '%' != nChar ) )\n            return;\n        else if ( PFB_MARKER == nChar )\n        {\n            if ( !RemovePfbMarkers() )\n                return;\n        }\n\n        char *sLine, *sLine1, *pCur, *pTemp;\n        char sBuffer[256];\n        int nCount, nCode;\n        int nIndex = 0;\n        unsigned char *sEexec = NULL;\n\n        m_oTopDict.arrdFontBBox[0] = 0; m_oTopDict.arrdFontBBox[1] = 0;\n        m_oTopDict.arrdFontBBox[2] = 0; m_oTopDict.arrdFontBBox[3] = 0;\n\n        m_oTopDict.arrdFontMatrix[0] = 0.001; m_oTopDict.arrdFontMatrix[1] = 0;\n        m_oTopDict.arrdFontMatrix[2] = 0;     m_oTopDict.arrdFontMatrix[3] = 0.001;\n        m_oTopDict.arrdFontMatrix[4] = 0;     m_oTopDict.arrdFontMatrix[5] = 0;\n\n        for (nIndex = 1, sLine = (char *)m_sFile; nIndex <= 100 && sLine && (!m_sName || !m_arrEncoding); ++nIndex )\n        {\n            if ( !m_sName && !strncmp( sLine, \"/FontName\", 9) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n                if ( ( pCur = strchr( sBuffer + 9, '/' ) ) && ( pCur = strtok( pCur + 1, \" \\t\\n\\r\" ) ) )\n                {\n                    m_sName = CopyString( pCur );\n                }\n                sLine = GetNextLine(sLine);\n\n            }\n            else if ( !strncmp( sLine, \"/FontMatrix\", 11 ) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n\n                ReadDoubleArray<6>( (unsigned char*)(sBuffer + 11), 244, m_oTopDict.arrdFontMatrix );\n                sLine = GetNextLine( sLine );\n            }\n            else if ( !strncmp( sLine, \"/FontBBox\", 9 ) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n\n                ReadDoubleArray<4>( (unsigned char*)(sBuffer + 9), 246, m_oTopDict.arrdFontBBox );\n                sLine = GetNextLine( sLine );\n            }\n            else if (!m_arrEncoding && !strncmp( sLine, \"/Encoding StandardEncoding def\", 30))\n            {\n                m_arrEncoding = c_arrsFontFileType1StandardEncoding;\n            }\n            else if (!m_arrEncoding && !strncmp( sLine, \"/Encoding 256 array\", 19))\n            {\n                m_arrEncoding = (char **)MemUtilsMallocArray(256, sizeof(char *));\n                int nJ = 0;\n                for (nJ = 0; nJ < 256; ++nJ )\n                {\n                    m_arrEncoding[nJ] = NULL;\n                }\n                for (nJ = 0, sLine = GetNextLine(sLine); nJ < 300 && sLine && ( sLine1 = GetNextLine( sLine )); ++nJ, sLine = sLine1)\n                {\n                    if ( ( nCount = sLine1 - sLine ) > 255 )\n                    {\n                        nCount = 255;\n                    }\n                    strncpy( sBuffer, sLine, nCount);\n                    sBuffer[ nCount ] = '\\0';\n                    for ( pCur = sBuffer; *pCur == ' ' || *pCur == '\\t'; ++pCur );\n                    if ( !strncmp( pCur, \"dup\", 3 ) )\n                    {\n                        for ( pCur += 3; *pCur == ' ' || *pCur == '\\t'; ++pCur ) ;\n                        for ( pTemp = pCur; *pTemp >= '0' && *pTemp <= '9'; ++pTemp ) ;\n                        if ( *pTemp )\n                        {\n                            char nChar = *pTemp;\n                            *pTemp = '\\0';\n                            nCode = atoi( pCur );\n                            *pTemp = nChar;\n                            if ( nCode == 8 && *pTemp == '#')\n                            {\n                                nCode = 0;\n                                for (++pTemp; *pTemp >= '0' && *pTemp <= '7'; ++pTemp)\n                                {\n                                    nCode = nCode * 8 + (*pTemp - '0');\n                                }\n                            }\n                            if ( nCode < 256 )\n                            {\n                                for ( pCur = pTemp; *pCur == ' ' || *pCur == '\\t'; ++pCur ) ;\n                                if ( *pCur == '/')\n                                {\n                                    ++pCur;\n                                    for ( pTemp = pCur; *pTemp && *pTemp != ' ' && *pTemp != '\\t'; ++pTemp ) ;\n                                    *pTemp = '\\0';\n                                    m_arrEncoding[ nCode ] = CopyString( pCur );\n                                }\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if ( strtok( sBuffer, \" \\t\") && ( pCur = strtok(NULL, \" \\t\\n\\r\")) && !strcmp( pCur, \"def\"))\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                if ( !sEexec )\n                    sEexec = (unsigned char*)strstr( sLine, \"currentfile eexec\" );\n\n                sLine = GetNextLine(sLine);\n            }\n        }\n\n        if ( NULL != sEexec )\n        {\n            unsigned char* sTemp = sEexec;\n            while ( sTemp != (unsigned char*)strstr( (char*)sTemp, \"cleartomark\" ) && sTemp < m_sFile + m_nLen )\n                sTemp++;\n\n            int nBufferLen = sTemp - ( sEexec + 17 );\n            unsigned char *sEexecBuffer = (unsigned char*)MemUtilsMalloc( nBufferLen );\n            if ( !sEexecBuffer )\n                return;\n\n            memcpy( sEexecBuffer, sEexec + 17, nBufferLen );\n            DecryptEexec( &sEexecBuffer, nBufferLen );\n\n            sEexec = sEexecBuffer + 4; // \u041f\u0435\u0440\u0432\u044b\u0435 \u0447\u0435\u0442\u044b\u0440\u0435 \u0431\u0430\u0439\u0442\u0430 \u0431\u044b\u043b\u0438 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u043c\u0438\n            int nEexecLen = nBufferLen - 4;\n\n            // \u0422\u0435\u043f\u0435\u0440\u044c \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u0435\u043c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 Private Dict\n            bool bGlyphsSection = false, bSubrsSection = false;\n            //unsigned short ushChar = '';\n            std::wstring sToken, sGlyph;\n            int nLength = 0;\n\n            // \u0412\u044b\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 Private Dict\n            m_oPrivateDict.nBlueValues       = 0;\n            m_oPrivateDict.nOtherBlues       = 0;\n            m_oPrivateDict.nFamilyBlues      = 0;\n            m_oPrivateDict.nFamilyOtherBlues = 0;\n            m_oPrivateDict.dBlueScale        = 0.039625;\n            m_oPrivateDict.nBlueShift        = 7;\n            m_oPrivateDict.nBlueFuzz         = 1;\n            m_oPrivateDict.bHasStdHW         = false;\n            m_oPrivateDict.bHasStdVW         = false;\n            m_oPrivateDict.nStemSnapH        = 0;\n            m_oPrivateDict.nStemSnapV        = 0;\n            m_oPrivateDict.bHasForceBold     = false;\n            m_oPrivateDict.nLanguageGroup    = 0;\n            m_oPrivateDict.nLenIV            = 4;\n            m_oPrivateDict.dExpansionFactor  = 0.06;\n\n            for ( int nIndex = 0; nIndex < nEexecLen; nIndex++ )\n            {\n                unsigned char nChar = sEexec[nIndex];\n\n                if ( ( bGlyphsSection || bSubrsSection ) && 'R' == nChar && nLength > 0 )\n                {\n                    unsigned char *sData = new unsigned char[nLength];\n                    if ( sData )\n                    {\n                        memcpy( sData, sEexec + nIndex + 3, nLength );\n                        unsigned short unKey = 4330U;\n                        unsigned char *sCur = sData;\n                        EexecDecode( &sCur, sCur + nLength, sCur, nLength, &unKey );\n\n                        if ( m_oPrivateDict.nLenIV > 0 && m_oPrivateDict.nLenIV < nLength )\n                        {\n                            Type1Charstring oCharstring = DecodeCharString( sData + m_oPrivateDict.nLenIV, nLength - m_oPrivateDict.nLenIV );\n                            if ( bGlyphsSection )\n                            {\n                                int nUnicode = Type1NameToUnicodeW( sGlyph.c_str() );\n\n                                if ( 0 != nUnicode )\n                                    m_arrCharstrings.Add( Type1Glyph( sGlyph, nUnicode, oCharstring )  );\n                            }\n                            else // if ( bSubrsSection )\n                            {\n                                m_arrSubrs.Add( oCharstring );\n                            }\n                        }\n\n                        delete []sData;\n                    }\n\n                    nIndex += nLength + 3;\n                }\n                else if ( IS_PS_SPACE( nChar ) )\n                {\n                    nLength = Utils::GetInteger( sToken );\n                    sToken.clear();\n                }\n                else\n                {\n                    sToken.push_back( (wchar_t)nChar );\n                    if ( !bGlyphsSection && '/' == sToken[0] )\n                    {\n                        int nTempChar = sToken[1];\n                        switch (nTempChar)\n                        {\n                        case 'B':\n                            {\n                                if ( L\"/BlueValues\" == sToken )\n                                    m_oPrivateDict.nBlueValues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnBlueValues );\n                                else if ( L\"/BlueScale\" == sToken )\n                                    m_oPrivateDict.dBlueScale  = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/BlueShift\" == sToken )\n                                    m_oPrivateDict.nBlueShift  = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/BlueFuzz\" == sToken )\n                                    m_oPrivateDict.nBlueFuzz   = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'C':\n                            {\n                                if ( L\"/CharString\" == sToken )\n                                    bGlyphsSection = true;\n\n                                break;\n                            }\n                        case 'E':\n                            {\n                                if ( L\"/ExpansionFactor\" == sToken )\n                                    m_oPrivateDict.dExpansionFactor = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'F':\n                            {\n                                if ( L\"/FamilyBlues\" == sToken )\n                                    m_oPrivateDict.nFamilyBlues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyBlues );\n                                else if ( L\"/FamilyOtherBlues\" == sToken )\n                                    m_oPrivateDict.nFamilyOtherBlues = ReadIntArray<type1MaxOtherBlues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyOtherBlues );\n                                else if ( L\"/ForceBold\" == sToken )\n                                {\n                                    m_oPrivateDict.bHasForceBold = true;\n                                    m_oPrivateDict.bForceBold = ReadBool( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                }\n\n                                break;\n                            }\n                        case 'L':\n                            {\n                                if ( L\"/LanguageGroup\" == sToken )\n                                    m_oPrivateDict.nLanguageGroup = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/lenIV\" == sToken )\n                                    m_oPrivateDict.nLenIV = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'S':\n                            {\n                                if ( L\"/Subrs\" == sToken )\n                                    bSubrsSection = true;\n                                else if ( L\"/StemSnapH\" == sToken )\n                                    m_oPrivateDict.nStemSnapH = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapH );\n                                else if ( L\"/StemSnapV\" == sToken )\n                                    m_oPrivateDict.nStemSnapV = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapV );\n                                else if ( L\"/StdHW\" == sToken )\n                                {\n                                    // \u0417\u0434\u0435\u0441\u044c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u043d\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c\n                                    double dTemp[1];\n\n                                    if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )\n                                    {\n                                        m_oPrivateDict.bHasStdHW = true;\n                                        m_oPrivateDict.dStdHW = dTemp[0];\n                                    }\n                                }\n                                else if ( L\"/StdVW\" == sToken )\n                                {\n                                    // \u0417\u0434\u0435\u0441\u044c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u043d\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c\n                                    double dTemp[1];\n                                    if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )\n                                    {\n                                        m_oPrivateDict.bHasStdHW = true;\n                                        m_oPrivateDict.dStdVW = dTemp[0];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if ( '/' == nChar  )\n                    {\n                        sToken.clear();\n                        sGlyph.clear();\n\n                        while ( ( nChar = sEexec[++nIndex] ) != ' ' )\n                            sGlyph.push_back( (wchar_t)nChar );\n                    }\n                }\n            }\n            MemUtilsFree( sEexecBuffer );\n\n            // \u041f\u0440\u043e\u0432\u0435\u0434\u0435\u043c \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0443 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 m_arrCharstrings \u043f\u043e \u044e\u043d\u0438\u043a\u043e\u0434\u043d\u043e\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e\n            qsort( m_arrCharstrings.GetData(), m_arrCharstrings.GetSize(), sizeof(Type1Glyph), CompareType1Glyph );\n        }\n\n        m_bParsed = true;\n    }\n\n    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        // \u0421\u043e\u0433\u043b\u0430\u0441\u043d\u043e \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 Type1, \u043f\u0435\u0440\u0432\u044b\u0439 \u0431\u0430\u0439\u0442 \u043d\u0435 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c ASCII \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u043c\n        // (\u043f\u0440\u043e\u0431\u0435\u043b, \u0442\u0430\u0431, \u043f\u0435\u0440\u0435\u043d\u043e\u0441 \u043a\u0430\u0440\u0435\u0442\u043a\u0438 \u0438\u043b\u0438 \u043f\u0435\u0440\u0435\u043d\u043e\u0441 \u0441\u0442\u0440\u043e\u043a\u0438).\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n            ++sCur;\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u043d\u0430\u043c \u043d\u0430\u0434\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u0432 \u043a\u0430\u043a\u043e\u043c \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0443 \u043d\u0430\u0441 \u0434\u0430\u043d\u043d\u044b\u0435: ASKII \u0438\u043b\u0438 \u0431\u0438\u043d\u0430\u0440\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435.\n        // \u0415\u0441\u043b\u0438 \u043f\u0435\u0440\u0432\u044b\u0435 \u0447\u0435\u0442\u044b\u0440\u0435 \u0431\u0430\u0439\u0442\u0430 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0448\u0435\u0441\u0442\u043d\u0430\u0434\u0446\u0430\u0442\u0438\u0440\u0438\u0447\u043d\u044b\u043c\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\u043c\u0438, \u0437\u043d\u0430\u0447\u0438\u0442, \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0430 ASCII.\n        bool bASCII = false;\n\n        if ( isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n\n        unsigned short ushKey = 55665U;\n        EexecDecode( &sCur, *ppEexecBuffer + nLen, sCur, nLen, &ushKey );\n    }\n    bool CFontFileType1::RemovePfbMarkers()\n    {\n        bool bSuccess = true;\n\n        int nBlockType = 0;\n        int nBlockLen  = 0;\n        int nChar = 0;\n\n        unsigned char *sBuffer = NULL;\n        int nBufLen = 0;\n\n        while ( nBlockType != PFB_DONE )\n        {\n            while ( 0 == nBlockLen )\n            {\n                nChar = ReadU8( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n\n                nBlockType = ReadU8( &bSuccess );\n                if ( !bSuccess || PFB_MARKER != nChar || ( PFB_ASCII != nBlockType && PFB_BINARY != nBlockType && PFB_DONE != nBlockType ) )\n                    return false;\n\n                if ( PFB_DONE == nBlockType )\n                    break;\n\n                nBlockLen = ReadU32LE( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n            }\n\n            // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0430\u043c \u0431\u043b\u043e\u043a \u0434\u0430\u043d\u043d\u044b\u0445\n            if ( nBlockLen > 0 )\n            {\n                if ( !sBuffer )\n                {\n                    sBuffer = (unsigned char*)MemUtilsMalloc( nBlockLen );\n                    if ( !sBuffer )\n                        return false;\n                }\n                else\n                    sBuffer = (unsigned char*)MemUtilsRealloc( sBuffer, nBufLen + nBlockLen );\n\n                Read( sBuffer + nBufLen, nBlockLen );\n                nBufLen += nBlockLen;\n            }\n            nBlockLen = 0;\n        }\n\n        if ( m_bFreeFileData )\n            MemUtilsFree( m_sFile );\n\n        m_bFreeFileData = true;\n        m_sFile         = (unsigned char*)sBuffer;\n        m_sFileData     = m_sFile;\n        m_nLen          = nBufLen;\n        m_nPos          = 0;\n\n        return true;\n    }\n\n    Type1Charstring CFontFileType1::DecodeCharString(unsigned char *sString, int nLen)\n    {\n        CArray<Type1CharstringItem> sCharString;\n\n        int nLSB = 0, nWidth = 0;\n\n        for ( int nIndex = 0; nIndex < nLen; nIndex++ )\n        {\n            int nValue = sString[nIndex];\n\n            if ( nValue < 32 ) // \u043a\u043e\u043c\u0430\u043d\u0434\u0430\n            {\n                int nCommand = 0;\n\n                if ( 12 == nValue )\n                {\n                    int nNextValue = sString[++nIndex];\n\n                    if ( 16 == nNextValue )\n                    {\n                        if ( sCharString.GetSize() <= 0 )\n                            continue;\n\n                        int nInd = sCharString[sCharString.GetSize() - 1].nValue;\n                        sCharString.RemoveAt( sCharString.GetSize() - 1 );\n\n                        while ( sCharString.GetSize() > 0 && false == sCharString[sCharString.GetSize() - 1].bCommand )\n                            sCharString.RemoveAt( sCharString.GetSize() - 1 );\n\n                        // If the flex mechanishm is not used in a font program, Adobe\n                        // state that that entries 0, 1 and 2 can simply be replace by\n                        // {}, which means that we can simply ignore them.\n                        if ( nInd < 3 )\n                            continue;\n\n                        // This is the same things about hint replacement, if it is not used\n                        // entry 3 can be replaced by {3}\n                        if ( 3 == nInd )\n                        {\n                            sCharString.Add( Type1CharstringItem( 3, true ) );\n                            nIndex++;\n                            continue;\n                        }\n                    }\n\n                    nCommand = 12 + ( nNextValue << 8 );\n                }\n                else\n                {\n                    if ( 13 == nValue )\n                    {\n                        if ( 2 == sCharString.GetSize() )\n                            nWidth = sCharString[1].nValue;\n                        else if ( 4 == sCharString.GetSize() && 0x0C0C == sCharString[3].nValue && sCharString[3].bCommand )\n                            nWidth = sCharString[1].nValue / sCharString[2].nValue;\n                        else\n                        {\n                            // TO DO: \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0443\n                            nWidth = 0;\n                        }\n\n                        if ( sCharString.GetSize() > 0 )\n                        {\n                            nLSB = sCharString[0].nValue;\n                            sCharString.Add( Type1CharstringItem( nLSB, false ) );\n                            sCharString.Add( Type1CharstringItem( c_nType1hmoveto, true ) );\n                            sCharString.RemoveAt( 0 );\n                        }\n                        else\n                        {\n                            nLSB = 0;\n                            sCharString.Add( Type1CharstringItem( nLSB, false ) );\n                            sCharString.Add( Type1CharstringItem( c_nType1hmoveto, true ) );\n                        }\n\n                        continue;\n                    }\n\n                    nCommand = nValue;\n                }\n\n                // Some charstring commands are meaningless in Type2 and will return\n                // a null, let's just ignored them\n                if ( !nCommand && nIndex < nLen )\n                    continue;\n                else if ( !nCommand )\n                    break;\n                else if ( c_nType1seac == nCommand || c_nType1sbw == nCommand )\n                {\n                    // TO DO: \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0443\n                }\n\n                sCharString.Add( Type1CharstringItem( nCommand, true ) );\n            }\n            else\n            {\n                if ( nValue <= 246 )\n                    nValue = nValue - 139;\n                else if ( nValue <= 250 )\n                    nValue =  ( ( nValue - 247 ) * 256 ) + (int)( sString[++nIndex] ) + 108;\n                else if ( nValue <= 254 )\n                    nValue = -( ( nValue - 251 ) * 256 ) - (int)( sString[++nIndex] ) - 108;\n                else\n                    nValue = ( sString[++nIndex] & 0xff ) << 24 | ( sString[++nIndex] & 0xff ) << 16 | ( sString[++nIndex] & 0xff ) << 8 | ( sString[++nIndex] & 0xff ) << 0;\n\n                sCharString.Add( Type1CharstringItem( nValue, false ) );\n            }\n        }\n\n        return Type1Charstring( sCharString, nWidth, nLSB );\n    }\n    Type1Charstring CFontFileType1::FlattenCharstring(Type1Charstring& oCharstring, int nBias)\n    {\n        Type1Charstring oNew;\n        oNew.nLSB   = oCharstring.nLSB;\n        oNew.nWidth = oCharstring.nWidth;\n\n        for ( int nIndex = 0; nIndex < oCharstring.arrCharstring.GetSize(); nIndex++ )\n        {\n            Type1CharstringItem oItem = oCharstring.arrCharstring[nIndex];\n            int nValue = oItem.nValue;\n            if ( oItem.bCommand )\n            {\n                if ( nValue == c_nType1sub )\n                {\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 11, true ) );\n                }\n                else if ( nValue == c_nType1div )\n                {\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                }\n                else if ( nValue == c_nType1pop )\n                {\n                    //oNew.arrCharstring.Add( Type1CharstringItem( 1, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 18, true ) );\n                }\n                else if ( nValue == c_nType1callsubr  )\n                {\n                    //int nTempLen = oNew.arrCharstring.GetSize();\n                    //int nT1 = oNew.arrCharstring[nTempLen - 2].nValue;\n                    //int nT2 = oNew.arrCharstring[nTempLen - 1].nValue;\n                    //int nInd = nT1 << 8 | nT2;\n\n                    //if ( 107 == nBias )\n                    //{\n                    //\tif ( nInd <= 215 )\n                    //\t{\n                    //\t\toNew.arrCharstring.RemoveAt( nTempLen - 1 );\n                    //\t\toNew.arrCharstring.RemoveAt( nTempLen - 2 );\n\n                    //\t\toNew.arrCharstring[nTempLen - 3].nValue = nInd - nBias + 139;\n                    //\t\toNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                    //\t}\n                    //\telse\n                    //\t{\n                    //\t\toNew.arrCharstring.RemoveAt( nTempLen - 1 );\n\n                    //\t\toNew.arrCharstring[nTempLen - 3].nValue = ((nInd - nBias) - 108) / 256 + 247;\n                    //\t\toNew.arrCharstring[nTempLen - 2].nValue = ((nInd - nBias) - 108) - (oNew.arrCharstring[nTempLen - 3].nValue - 247) * 256;\n                    //\t\toNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                    //\t}\n                    //}\n                    //else\n                    //{\n\n                    //\tnInd -= nBias;\n                    //\toNew.arrCharstring[nTempLen - 2].nValue = nInd >> 8;\n                    //\toNew.arrCharstring[nTempLen - 1].nValue = nInd & 0xFF;\n                    //\toNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                    //}\n                    oNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                }\n                else\n                    oNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n            }\n            else\n            {\n                // Type1 charstrings \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442 \u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0447\u0438\u0441\u0435\u043b \u0431\u043e\u043b\u044c\u0448\u0438\u0445 32000\n                if ( oItem.nValue > 32000 )\n                {\n                    int nDivisor = oCharstring.arrCharstring[nIndex + 1].nValue;\n                    if ( 0 != nDivisor )\n                        nValue /= nDivisor;\n                }\n                oNew.arrCharstring.Add( Type1CharstringItem( 28, true ) );\n                oNew.arrCharstring.Add( Type1CharstringItem( nValue >> 8, false ) );\n                oNew.arrCharstring.Add( Type1CharstringItem( nValue & 0xFF, false ) );\n            }\n        }\n\n        return oNew;\n    }\n    void CFontFileType1::CFFCreateIndexHeader(FontFileOutputFunc pOutputFunc, void *pOutputStream, CArray<std::wstring> aObjects)\n    {\n        char nChar;\n        int nCount = aObjects.GetSize();\n        if ( 0 == nCount )\n        {\n            pOutputFunc( pOutputStream, \"\\x00\\x00\\x00\", 3 );\n            return;\n        }\n\n        // \u041f\u0435\u0440\u0432\u044b\u0435 \u0434\u0432\u0430 \u0431\u0430\u0439\u0442\u0430 - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n        WriteChar( nCount >> 8 );\n        WriteChar( nCount & 0xFF );\n        // \u0420\u0430\u0437\u043c\u0435\u0440 \u0441\u0434\u0432\u0438\u0433\u043e\u0432, \u0441\u0442\u0430\u0432\u0438\u043c \u043f\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u0443\n        WriteChar( 0x04 );\n\n        int nRelativeOffset = 1;\n        for ( int nIndex = 0; nIndex < nCount + 1; nIndex++ )\n        {\n            WriteChar( (nRelativeOffset >> 24) & 0xFF );\n            WriteChar( (nRelativeOffset >> 16) & 0xFF );\n            WriteChar( (nRelativeOffset >>  8) & 0xFF );\n            WriteChar( (nRelativeOffset)       & 0xFF );\n\n            if ( nIndex < nCount )\n                nRelativeOffset += aObjects[nIndex].length();\n        }\n\n        for ( int nIndex = 0; nIndex < nCount; nIndex++ )\n        {\n            std::string sCur = U_TO_UTF8((aObjects[nIndex]));\n            pOutputFunc( pOutputStream, sCur.c_str(), sCur.length() );\n        }\n    }\n    void CFontFileType1::CFFCreateIndexHeader(FontFileOutputFunc pOutputFunc, void *pOutputStream, CArray<Type1Charstring> aObjects)\n    {\n        char nChar;\n        int nCount = aObjects.GetSize();\n        if ( 0 == nCount )\n        {\n            pOutputFunc( pOutputStream, \"\\x00\\x00\\x00\", 3 );\n            return;\n        }\n\n        // \u041f\u0435\u0440\u0432\u044b\u0435 \u0434\u0432\u0430 \u0431\u0430\u0439\u0442\u0430 - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n        WriteChar( nCount >> 8 );\n        WriteChar( nCount & 0xFF );\n        // \u0420\u0430\u0437\u043c\u0435\u0440 \u0441\u0434\u0432\u0438\u0433\u043e\u0432, \u0441\u0442\u0430\u0432\u0438\u043c \u043f\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u0443\n        WriteChar( 0x04 );\n\n        int nRelativeOffset = 1;\n        for ( int nIndex = 0; nIndex < nCount + 1; nIndex++ )\n        {\n            WriteChar( (nRelativeOffset >> 24) & 0xFF );\n            WriteChar( (nRelativeOffset >> 16) & 0xFF );\n            WriteChar( (nRelativeOffset >>  8) & 0xFF );\n            WriteChar( (nRelativeOffset)       & 0xFF );\n\n            if ( nIndex < nCount )\n                nRelativeOffset += aObjects[nIndex].arrCharstring.GetSize();\n        }\n\n        for ( int nI = 0; nI < nCount; nI++ )\n        {\n            for ( int nJ = 0; nJ < aObjects[nI].arrCharstring.GetSize(); nJ++ )\n            {\n                WriteChar( aObjects[nI].arrCharstring[nJ].nValue & 0xFF );\n            }\n        }\n    }\n    void CFontFileType1::CFFEncodeNumber(FontFileOutputFunc pOutputFunc, void *pOutputStream, int nValue, bool bForceLong)\n    {\n        char nChar;\n        if ( !bForceLong && nValue >= -32768 && nValue <= 32767 )\n        {\n            WriteChar( 0x1c );\n            WriteChar( ( nValue >> 8 ) & 0xFF );\n            WriteChar( nValue & 0xFF );\n        }\n        else // if ( nValue >= (-2147483648) && nValue <= 2147483647 )\n        {\n            WriteChar( 0x1d );\n            WriteChar( ( nValue >> 24 ) & 0xFF );\n            WriteChar( ( nValue >> 16 ) & 0xFF );\n            WriteChar( ( nValue >>  8 ) & 0xFF );\n            WriteChar( nValue & 0xFF );\n        }\n    }\n    void CFontFileType1::CFFEncodeNumber(FontFileOutputFunc pOutputFunc, void *pOutputStream, double dValue)\n    {\n        char nChar = 0;\n\n        WriteChar( 0x1e ); // \u043d\u0430\u0447\u0430\u043b\u043e \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430\n\n        std::wstring sValue = std::to_wstring(dValue);\n        bool bFirstNibble = true;\n        for ( int nIndex = 0; nIndex < sValue.length(); nIndex++ )\n        {\n            int nCurChar = sValue.c_str()[ nIndex ];\n            if ( '0' <= nCurChar && nCurChar <= '9' )\n                nCurChar -= (int)('0');\n            else if ( '.' == nCurChar )\n                nCurChar = 0x0a;\n            else if ( '-' == nCurChar )\n                nCurChar = 0x0e;\n            else\n                continue;\n\n            if ( bFirstNibble )\n                nChar = nCurChar << 4;\n            else\n            {\n                nChar += nCurChar;\n                WriteChar( nChar );\n            }\n\n            bFirstNibble = !bFirstNibble;\n        }\n\n        // \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u043e\u043a\u043e\u043d\u0447\u0430\u043d\u0438\u0435\u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430\n        if ( bFirstNibble )\n            nChar = (char)0xff;\n        else\n            nChar += 0x0f;\n\n        WriteChar( nChar );\n    }\n    void CFontFileType1::ToCFF(FontFileOutputFunc pOutputFunc, void *pOutputStream)\n    {\n        std::wstring sFontName = NSFile::CUtf8Converter::GetUnicodeFromCharPtr( m_sName, (LONG)strlen(m_sName) );\n        CArray<std::wstring> aString;\n\n        int nBias = 0;\n        int nSubrsLen = m_arrSubrs.GetSize();\n        if ( nSubrsLen < 1240 )\n            nBias = 107;\n        else if ( nSubrsLen < 33900 )\n            nBias = 1131;\n        else\n            nBias = 32768;\n\n        CArray<Type1Charstring> arrType2Charstrings;\n        Type1Charstring oFirstCharstring;\n        oFirstCharstring.arrCharstring.Add( Type1CharstringItem( 0x8B, false ) );\n        oFirstCharstring.arrCharstring.Add( Type1CharstringItem( 0x0E, false ) );\n        arrType2Charstrings.Add( oFirstCharstring );\n        for ( int nIndex = 0; nIndex < m_arrCharstrings.GetSize(); nIndex++ )\n        {\n            std::wstring sG = m_arrCharstrings[nIndex].sGlyph;\n            if ( L\"afii10090\" == sG )\n                int k = 10;\n            arrType2Charstrings.Add( FlattenCharstring( m_arrCharstrings[nIndex].oData, nBias ) );\n        }\n\n        CArray<Type1Charstring> arrType2Subrs;\n\n        //Type1Charstring oBias;\n        ////oBias.arrCharstring.Add( Type1CharstringItem( 0x0B, false ) );\n        //oBias.arrCharstring.Add( Type1CharstringItem( 0x0E, false ) );\n        //for ( int nIndex = 0; nIndex < nBias; nIndex++ )\n        //\tarrType2Subrs.Add( oBias );\n\n        for ( int nIndex = 0; nIndex < nSubrsLen; nIndex++ )\n        {\n            //if ( nIndex == 256 )\n            //{\n            //\tType1Charstring oBias;\n            //\toBias.arrCharstring.Add( Type1CharstringItem( 0x0B, false ) );\n            //\tfor ( int nIndex = 0; nIndex < nBias; nIndex++ )\n            //\t\tarrType2Subrs.Add( oBias );\n            //}\n            arrType2Subrs.Add( FlattenCharstring( m_arrSubrs[nIndex], 0 ) );\n        }\n\n        // Header\n        TCharBuffer oHeader;\n        oHeader.Write( \"\\x01\\x00\\x04\\x04\", 4 );\n\n        // Name\n        TCharBuffer oName;\n        aString.RemoveAll();\n        aString.Add( sFontName );\n        CFFCreateIndexHeader( CharBufferWrite, &oName, aString );\n\n        // Strings\n        TCharBuffer oStrings;\n        aString.RemoveAll();\n        int nNewSID = CFF_STANDARD_STRINGS_COUNT;\n        aString.Add( L\"Version 0.11\" );        nNewSID++; // Version\n        aString.Add( L\"See original notice\" ); nNewSID++; // Notice\n        aString.Add( sFontName );                 nNewSID++; // FullName\n        aString.Add( sFontName );                 nNewSID++; // FamilyName\n        aString.Add( L\"Medium\" );              nNewSID++; // Weight\n\n        for ( int nIndex = 0; nIndex < m_arrCharstrings.GetSize(); nIndex++ )\n        {\n            int nSID = GetCFFStringIndex( m_arrCharstrings[nIndex].sGlyph.c_str() );\n            if ( nSID < 0 )\n            {\n                aString.Add( m_arrCharstrings[nIndex].sGlyph );\n                nSID = nNewSID;\n                nNewSID++;\n            }\n\n            m_arrCharstrings[nIndex].nReserved = nSID;\n        }\n\n        CFFCreateIndexHeader( CharBufferWrite, &oStrings, aString );\n\n        // GlobalSubrs\n        TCharBuffer oGlobalSubrs;\n        aString.RemoveAll(); // \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u043f\u0443\u0441\u0442\u043e\u0439 \u043c\u0430\u0441\u0441\u0438\u0432\n        CFFCreateIndexHeader( CharBufferWrite, &oGlobalSubrs, aString );\n\n        // Charset\n        TCharBuffer oCharset;\n        oCharset.Write( (char)0x00 ); // Encoding\n\n        int nGlyphsCount = m_arrCharstrings.GetSize();\n        for ( int nIndex = 0; nIndex < nGlyphsCount; nIndex++ )\n        {\n            int nSID = m_arrCharstrings[nIndex].nReserved;\n            oCharset.Write( (char)(nSID >> 8) );\n            oCharset.Write( (char)(nSID & 0xFF) );\n        }\n\n        // Charstrings\n        TCharBuffer oCharstrings;\n        CFFCreateIndexHeader( NSFontConverter::CharBufferWrite, &oCharstrings, arrType2Charstrings );\n\n        // Private\n        TCharBuffer oPrivate;\n        oPrivate.Write( \"\\x8b\\x14\", 2 ); // defaultWidth\n        oPrivate.Write( \"\\x8b\\x15\", 2 ); // nominalWidth\n\n        // Private: BlueValues\n        if ( m_oPrivateDict.nBlueValues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnBlueValues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nBlueValues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnBlueValues[nIndex] - m_oPrivateDict.arrnBlueValues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x06 );\n        }\n\n        // Private: OtherBlues\n        if ( m_oPrivateDict.nOtherBlues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnOtherBlues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nOtherBlues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnOtherBlues[nIndex] - m_oPrivateDict.arrnOtherBlues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x07 );\n        }\n\n        // Private: FamilyBlues\n        if ( m_oPrivateDict.nFamilyBlues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyBlues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nFamilyBlues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyBlues[nIndex] - m_oPrivateDict.arrnFamilyBlues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x08 );\n        }\n\n        // Private: FamilyOtherBlues\n        if ( m_oPrivateDict.nFamilyOtherBlues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyOtherBlues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nFamilyOtherBlues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyOtherBlues[nIndex] - m_oPrivateDict.arrnFamilyOtherBlues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x09 );\n        }\n\n        // Private: StemSnapH\n        if ( m_oPrivateDict.nStemSnapH > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapH[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nStemSnapH; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapH[nIndex] - m_oPrivateDict.arrdStemSnapH[nIndex - 1] );\n\n            oPrivate.Write( \"\\x0c\\x0c\" , 2);\n        }\n\n        // Private: StemSnapV\n        if ( m_oPrivateDict.nStemSnapV > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapV[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nStemSnapV; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapV[nIndex] - m_oPrivateDict.arrdStemSnapV[nIndex - 1] );\n\n            oPrivate.Write( \"\\x0c\\x0d\" , 2);\n        }\n\n        // Private: BlueShift\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nBlueShift );\n        oPrivate.Write( \"\\x0c\\x0a\", 2 );\n\n        // Private: BlueFuzz\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nBlueFuzz );\n        oPrivate.Write( \"\\x0c\\x0b\", 2 );\n\n        // Private: BlueScale\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.dBlueScale );\n        oPrivate.Write( \"\\x0c\\x09\", 2 );\n\n        // Private: LanguageGroup\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nLanguageGroup );\n        oPrivate.Write( \"\\x0c\\x11\", 2 );\n\n        // Private: ExpansionFactor\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.dExpansionFactor );\n        oPrivate.Write( \"\\x0c\\x18\", 2 );\n\n        // Private: Subrs\n        int nPrivateLen = oPrivate.nLen + (5 + 1);\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, nPrivateLen, true );\n        oPrivate.Write( \"\\x13\", 1 );\n\n        // LocalSubrs\n        TCharBuffer oLocalSubrs;\n        CFFCreateIndexHeader( CharBufferWrite, &oLocalSubrs, arrType2Subrs );\n\n        // Top Dict\n        TCharBuffer oTopDict;\n        oTopDict.Write( \"\\x00\\x01\\x04\\x00\\x00\\x00\\x01\\x00\\x00\\0x00\\x00\", 11 );\n        oTopDict.Write( \"\\xf8\\x1b\\x00\", 3 ); // Version\n        oTopDict.Write( \"\\xf8\\x1c\\x01\", 3 ); // Notice\n        oTopDict.Write( \"\\xf8\\x1d\\x02\", 3 ); // FullName\n        oTopDict.Write( \"\\xf8\\x1e\\x03\", 3 ); // FamilyName\n        oTopDict.Write( \"\\xf8\\x1f\\x04\", 3 ); // Weight\n        oTopDict.Write( \"\\x1c\\x00\\x00\\x10\", 4 ); // Encoding\n\n        // BBox\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[0] );\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[1] );\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[2] );\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[3] );\n        oTopDict.Write( \"\\x05\", 1 );\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u043e\u0446\u0435\u043d\u0438\u043c \u0440\u0430\u0437\u043c\u0435\u0440 TopDict: \u0412\u043e\u0437\u044c\u043c\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u0434\u043b\u0438\u043d\u0443, \u0434\u043e\u0431\u0430\u0432\u0438\u043c \u043a \u043d\u0435\u0439 (4 * 5 + 3)\n        // ( 4 \u0447\u0438\u0441\u043b\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043f\u0438\u0448\u0435\u043c \u043f\u043e 5 \u0431\u0430\u0439\u0442 + 3 \u0431\u0430\u0439\u0442\u0430 \u043d\u0430 3 \u043a\u043e\u043c\u0430\u043d\u0434\u044b)\n        int nTopDictLen = oTopDict.nLen + ( 4 * 5 + 3);\n\n        int nOffset = oHeader.nLen + oName.nLen + nTopDictLen + oStrings.nLen + oGlobalSubrs.nLen;\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );\n        oTopDict.Write( \"\\x0f\", 1 ); // Charset\n\n        nOffset += oCharset.nLen;//( arrType2Charstrings.GetSize() * 2 ) + 1;\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );\n        oTopDict.Write( \"\\x11\", 1 ); // Charstrings\n\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, oPrivate.nLen, true );\n        nOffset += oCharstrings.nLen;\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );\n        oTopDict.Write( \"\\x12\", 1 ); // Private\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u0437\u0430\u043f\u0438\u0448\u0435\u043c \u0440\u0435\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0437\u043c\u0435\u0440 TopDict\n        int nTopDictDataLen = nTopDictLen - 10;\n        oTopDict.sBuffer[7]  = ( nTopDictDataLen >> 24 ) & 0xFF;\n        oTopDict.sBuffer[8]  = ( nTopDictDataLen >> 16 ) & 0xFF;\n        oTopDict.sBuffer[9]  = ( nTopDictDataLen >> 8  ) & 0xFF;\n        oTopDict.sBuffer[10] = nTopDictDataLen & 0xFF;\n\n        // \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0432\u0441\u0435 \u0432 \u0444\u0430\u0439\u043b\n        pOutputFunc( pOutputStream, oHeader.sBuffer,      oHeader.nLen      );\n        pOutputFunc( pOutputStream, oName.sBuffer,        oName.nLen        );\n        pOutputFunc( pOutputStream, oTopDict.sBuffer,     oTopDict.nLen     );\n        pOutputFunc( pOutputStream, oStrings.sBuffer,     oStrings.nLen     );\n        pOutputFunc( pOutputStream, oGlobalSubrs.sBuffer, oGlobalSubrs.nLen );\n        pOutputFunc( pOutputStream, oCharset.sBuffer,     oCharset.nLen     );\n        pOutputFunc( pOutputStream, oCharstrings.sBuffer, oCharstrings.nLen );\n        pOutputFunc( pOutputStream, oPrivate.sBuffer,     oPrivate.nLen     );\n        pOutputFunc( pOutputStream, oLocalSubrs.sBuffer,  oLocalSubrs.nLen  );\n    }\n}\n"], "fixing_code": ["\ufeff/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n#ifndef _ASC_FONTCONVERTER_FONT_FILE_BASE_H\n#define _ASC_FONTCONVERTER_FONT_FILE_BASE_H\n\n#include <stdio.h>\n#include \"MemoryUtils.h\"\n#include \"../../common/File.h\"\n\nnamespace NSFontConverter\n{\n    //------------------------------------------------------------------------\n\n    typedef void (*FontFileOutputFunc)(void *pStream, const char *sData, int nLen);\n\n    //------------------------------------------------------------------------\n    // CFontFileBase\n    //------------------------------------------------------------------------\n\n    class CFontFileBase\n    {\n    public:\n\n        virtual ~CFontFileBase()\n        {\n            if ( m_bFreeFileData )\n                MemUtilsFree( m_sFileData );\n        }\n\n    protected:\n\n        CFontFileBase(char *sFile, int nLen, bool bFreeFileData)\n        {\n            m_sFileData = m_sFile = (unsigned char *)sFile;\n            m_nLen = (nLen > 0) ? 0 : (unsigned int)nLen;\n            m_nPos = 0;\n            m_bFreeFileData = bFreeFileData;            \n        }\n\n        void         Reset()\n        {\n            m_nPos = 0;\n        }\n        static char *ReadFile(const wchar_t *wsFileName, int *pnFileLen)\n        {\n            NSFile::CFileBinary oFile;\n            if ( !oFile.OpenFile(wsFileName) )\n                return NULL;\n\n            int nLen = (int)oFile.GetFileSize();\n            char *sBuffer = (char *)MemUtilsMalloc( nLen );\n            DWORD dwRead = 0;\n            oFile.ReadFile((BYTE*)sBuffer, (DWORD)nLen, dwRead);\n\n            if ((int)dwRead != nLen)\n            {\n                MemUtilsFree( sBuffer );\n                return NULL;\n            }\n\n            *pnFileLen = nLen;\n            return sBuffer;\n        }\n\n        // S = signed / U = unsigned\n        // 8/16/32/Var = word length, in bytes\n        // BE = big endian\n        int          GetS8    (const unsigned int& nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            if ( nRes & 0x80 )\n                nRes |= ~0xff;\n            return nRes;\n        }\n\n        int          GetU8    (const unsigned int& nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n            if ( nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            return m_sFile[ nPos ];\n        }\n\n        int          GetS16BE (const unsigned int& nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( m_nLen < 2 || nPos > (m_nLen - 2) )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            if ( nRes & 0x8000 )\n                nRes |= ~0xffff;\n            return nRes;\n        }\n\n        int          GetU16BE (const unsigned int& nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( m_nLen < 2 || nPos > (m_nLen - 2) )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            return nRes;\n        }\n\n        int          GetS32BE (const unsigned int& nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( m_nLen < 4 || nPos > (m_nLen - 4) )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            if ( nRes & 0x80000000 )\n                nRes |= ~0xffffffff;\n\n            return nRes;\n        }\n\n        unsigned int GetU32BE (const unsigned int& nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( m_nLen < 4 || nPos > (m_nLen - 4) )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            return nRes;\n        }\n        unsigned int GetU32LE (const unsigned int& nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( m_nLen < 4 || nPos > (m_nLen - 4) )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos + 3];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 0];\n            return nRes;\n        }\n        unsigned int GetUVarBE(const unsigned int& nPos, const unsigned int& nSize, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( m_nLen < nSize || nPos > (m_nLen - nSize) )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = 0;\n            for ( int nIndex = 0; nIndex < nSize; ++nIndex )\n                nRes = (nRes << 8) + m_sFile[nPos + nIndex];\n\n            return nRes;\n        }\n\n        bool         CheckRegion(const unsigned int& nPos, const unsigned int& nSize)\n        {\n            return (m_nLen >= nSize && nPos <= (m_nLen - nSize));\n        }\n        int          ReadS8   (bool *pbSuccess)\n        {\n            return GetS8( m_nPos++, pbSuccess );\n        }\n        int          ReadU8   (bool *pbSuccess)\n        {\n            return GetU8( m_nPos++, pbSuccess );\n        }\n        unsigned int ReadU32BE(bool *pbSuccess)\n        {\n            unsigned int unResult = GetU32BE( m_nPos, pbSuccess );\n            m_nPos += 4;\n            return unResult;\n        }\n        unsigned int ReadU32LE(bool *pbSuccess)\n        {\n            unsigned int unResult = GetU32LE( m_nPos, pbSuccess );\n            m_nPos += 4;\n            return unResult;\n        }\n        int          Read(void* pDestBuffer, unsigned int nSize)\n        {\n            if (m_nPos >= m_nLen)\n                nSize = 0;\n            else if (nSize > (m_nLen - m_nPos))\n                nSize = m_nLen - m_nPos;\n\n            memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );\n            m_nPos += nSize;\n\n            return nSize;\n        }\n\n    protected:\n\n        unsigned char *m_sFileData;\n        unsigned char *m_sFile;\n        unsigned int   m_nLen;\n        unsigned int   m_nPos;\n        bool           m_bFreeFileData;\n    };\n}\n\n#endif /* _ASC_FONTCONVERTER_FONT_FILE_BASE_H */\n", "\ufeff/*\n * (c) Copyright Ascensio System SIA 2010-2019\n *\n * This program is a free software product. You can redistribute it and/or\n * modify it under the terms of the GNU Affero General Public License (AGPL)\n * version 3 as published by the Free Software Foundation. In accordance with\n * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect\n * that Ascensio System SIA expressly excludes the warranty of non-infringement\n * of any third-party rights.\n *\n * This program is distributed WITHOUT ANY WARRANTY; without even the implied\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For\n * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html\n *\n * You can contact Ascensio System SIA at 20A-12 Ernesta Birznieka-Upisha\n * street, Riga, Latvia, EU, LV-1050.\n *\n * The  interactive user interfaces in modified source and object code versions\n * of the Program must display Appropriate Legal Notices, as required under\n * Section 5 of the GNU AGPL version 3.\n *\n * Pursuant to Section 7(b) of the License you must retain the original Product\n * logo when distributing the program. Pursuant to Section 7(e) we decline to\n * grant you any rights under trademark law for use of our trademarks.\n *\n * All the Product's GUI elements, including illustrations and icon sets, as\n * well as technical writing content are licensed under the terms of the\n * Creative Commons Attribution-ShareAlike 4.0 International. See the License\n * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode\n *\n */\n#include <stdlib.h>\n#include <string.h>\n#include \"MemoryUtils.h\"\n#include \"FontFileEncodings.h\"\n#include \"FontFileType1.h\"\n\nnamespace NSFontConverter\n{\n    #define LINESIZE 1024\n\n    #define PFB_MARKER 128\n    #define PFB_ASCII    1\n    #define PFB_BINARY   2\n    #define PFB_DONE     3\n\n\n    #define IS_PS_NEWLINE( ch ) \\\n      ( (ch) == '\\r' ||         \\\n        (ch) == '\\n' )\n\n    #define IS_PS_SPACE( ch )  \\\n      ( (ch) == ' '         || \\\n        IS_PS_NEWLINE( ch ) || \\\n        (ch) == '\\t'        || \\\n        (ch) == '\\f'        || \\\n        (ch) == '\\0' )\n\n    // \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0434\u043b\u044f \u0431\u044b\u0441\u0442\u0440\u043e\u0433\u043e \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0446\u0438\u0444\u0440 (\u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u044b\u0445 \u0438 \u043d\u0435 \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u044b\u0445) \u0432 \u0447\u0438\u0441\u043b\u0430\n    static const signed char c_arrCharTable[128] =\n    {\n        /* 0x00 */\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n         0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n    };\n\n    // \u041d\u0438 \u043e\u0434\u0438\u043d \u0441\u0438\u043c\u0432\u043e\u043b \u0431\u043e\u043b\u044c\u0448\u0435 >= 0x80 \u043d\u0435 \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u0442\u044c \u0447\u0438\u0441\u043b\u043e\n    #define OP  >=\n\n    #define WriteChar(Value) \\\n        nChar = (char)(Value);\\\n        pOutputFunc( pOutputStream, &nChar, 1 );\n\n    unsigned int EexecDecode   (unsigned char** cursor, unsigned char* limit, unsigned char* buffer, unsigned int n, unsigned short* seed )\n    {\n        unsigned char*  p;\n        unsigned int r;\n        unsigned int s = *seed;\n\n        p = *cursor;\n        if ( n > (unsigned int)(limit - p) )\n          n = (unsigned int)(limit - p);\n\n        for ( r = 0; r < n; r++ )\n        {\n          unsigned int  val = p[r];\n          unsigned int  b   = ( val ^ ( s >> 8 ) );\n\n\n          s         = ( (val + s)*52845U + 22719 ) & 0xFFFFU;\n          buffer[r] = (unsigned char) b;\n        }\n\n        *cursor = p + n;\n        *seed   = (unsigned short)s;\n\n        return r;\n      }\n\n    unsigned int ASCIIHexDecode(unsigned char** cursor, unsigned char* limit, unsigned char* buffer, unsigned int n)\n    {\n        unsigned char*  p;\n        unsigned int  r   = 0;\n        unsigned int  w   = 0;\n        unsigned int  pad = 0x01;\n\n\n        n *= 2;\n\n        p  = *cursor;\n        if ( n > (unsigned int)( limit - p ) )\n          n = (unsigned int)( limit - p );\n\n        /* we try to process two nibbles at a time to be as fast as possible */\n        for ( ; r < n; r++ )\n        {\n          FT_UInt  c = p[r];\n\n\n          if ( IS_PS_SPACE( c ) )\n            continue;\n\n          if ( c OP 0x80 )\n            break;\n\n          c = c_arrCharTable[c & 0x7F];\n          if ( (unsigned)c >= 16 )\n            break;\n\n          pad = ( pad << 4 ) | c;\n          if ( pad & 0x100 )\n          {\n            buffer[w++] = (FT_Byte)pad;\n            pad         = 0x01;\n          }\n        }\n\n        if ( pad != 0x01 )\n          buffer[w++] = (FT_Byte)( pad << 4 );\n\n        *cursor = p + r;\n\n        return w;\n      }\n    //------------------------------------------------------------------------\n    // CFontFileType1\n    //------------------------------------------------------------------------\n\n    CFontFileType1 *CFontFileType1::LoadFromBuffer(char *sBuffer, int nLen)\n    {\n        return new CFontFileType1(sBuffer, nLen, false);\n    }\n\n    CFontFileType1 *CFontFileType1::LoadFromFile(const wchar_t *wsFileName)\n    {\n        char *sBuffer;\n        int nLen = 0;\n\n        if ( !( sBuffer = CFontFileBase::ReadFile(wsFileName, &nLen) ) )\n            return NULL;\n\n        return new CFontFileType1(sBuffer, nLen, true);\n    }\n\n    CFontFileType1::CFontFileType1(char *sBuffer, int nLen, bool bFreeData):\n    CFontFileBase(sBuffer, nLen, bFreeData)\n    {\n        m_sName = NULL;\n        m_arrEncoding = NULL;\n\n        Parse();\n        m_bParsed = false;\n    }\n\n    CFontFileType1::~CFontFileType1()\n    {\n        if (m_sName)\n            MemUtilsFree(m_sName);\n\n        if ( m_arrEncoding && m_arrEncoding != c_arrsFontFileType1StandardEncoding )\n        {\n            for (int nIndex = 0; nIndex < 256; ++nIndex )\n            {\n                MemUtilsFree( m_arrEncoding[nIndex] );\n            }\n            MemUtilsFree(m_arrEncoding);\n        }\n    }\n\n    char *CFontFileType1::GetName()\n    {\n        if ( !m_bParsed )\n            Parse();\n\n        return m_sName;\n    }\n\n    char **CFontFileType1::GetEncoding()\n    {\n        if (!m_bParsed)\n            Parse();\n\n        return m_arrEncoding;\n    }\n\n    void CFontFileType1::WriteEncoded(char **ppNewEncoding, FontFileOutputFunc pOutputFunc, void *pOutputStream)\n    {\n        char sBuffer[512];\n        char *sLine, *sLine2, *sCurChar;\n\n        // \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u0434\u043e \u0441\u0442\u0440\u043e\u0447\u043a\u0438 /Encoding\n        for ( sLine = (char *)m_sFile; sLine && strncmp( sLine, \"/Encoding\", 9); sLine = GetNextLine(sLine) );\n        if ( !sLine )\n        {\n            // \u043d\u0435 \u043d\u0430\u0448\u043b\u0438 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0443, \u0442\u043e\u0433\u0434\u0430 \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0446\u0435\u043b\u0438\u043a\u043e\u043c \u0444\u043e\u043d\u0442 \u0444\u0430\u0439\u043b\n            (*pOutputFunc)( pOutputStream, (char *)m_sFile, m_nLen);\n            return;\n        }\n        (*pOutputFunc)( pOutputStream, (char *)m_sFile, sLine - (char *)m_sFile);\n\n        // \u043f\u0438\u0448\u0435\u043c \u043d\u043e\u0432\u0443\u044e \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0443\n        (*pOutputFunc)( pOutputStream, \"/Encoding 256 array\\n\", 20);\n        (*pOutputFunc)( pOutputStream, \"0 1 255 {1 index exch /.notdef put} for\\n\", 40);\n        for ( int nIndex = 0; nIndex < 256; ++nIndex )\n        {\n            if (ppNewEncoding[nIndex])\n            {\n                sprintf( sBuffer, \"dup %d /%s put\\n\", nIndex, ppNewEncoding[nIndex]);\n                (*pOutputFunc)( pOutputStream, sBuffer, strlen( sBuffer ));\n            }\n        }\n        (*pOutputFunc)( pOutputStream, \"readonly def\\n\", 13);\n\n        if ( !strncmp( sLine, \"/Encoding StandardEncoding def\", 30) )\n        {\n            sLine = GetNextLine(sLine);\n        }\n        else\n        {\n            sCurChar = sLine + 10;\n            sLine = NULL;\n            for (; sCurChar < (char *)m_sFile + m_nLen; ++sCurChar)\n            {\n                if ((*sCurChar == ' ' || *sCurChar == '\\t' || *sCurChar == '\\x0a' || *sCurChar == '\\x0d' || *sCurChar == '\\x0c' || *sCurChar == '\\0') && sCurChar + 4 <= (char *)m_sFile + m_nLen && !strncmp(sCurChar + 1, \"def\", 3) )\n                {\n                    sLine = sCurChar + 4;\n                    break;\n                }\n            }\n        }\n\n        // \u0423 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0444\u043e\u043d\u0442\u043e\u0432 \u0434\u0432\u0435 \u0437\u0430\u043f\u0438\u0441\u0438 /Encoding, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043d\u0430\u043b\u0438\u0447\u0438\u0435 \u0432\u0442\u043e\u0440\u043e\u0439 \u0437\u0430\u043f\u0438\u0441\u0438\n        if ( sLine )\n        {\n            int nIndex;\n            for ( sLine2 = sLine, nIndex = 0; nIndex < 20 && sLine2 && strncmp(sLine2, \"/Encoding\", 9); sLine2 = GetNextLine(sLine2), ++nIndex) ;\n            if ( nIndex < 20 && sLine2 )\n            {\n                (*pOutputFunc)( pOutputStream, sLine, sLine2 - sLine);\n                if ( !strncmp(sLine2, \"/Encoding StandardEncoding def\", 30) )\n                {\n                    sLine = GetNextLine( sLine2 );\n                }\n                else\n                {\n                    sCurChar = sLine2 + 10;\n                    sLine = NULL;\n                    for (; sCurChar < (char *)m_sFile + m_nLen; ++sCurChar)\n                    {\n                        if ((*sCurChar == ' ' || *sCurChar == '\\t' || *sCurChar == '\\x0a' || *sCurChar == '\\x0d' || *sCurChar == '\\x0c' || *sCurChar == '\\0') && sCurChar + 4 <= (char *)m_sFile + m_nLen && !strncmp(sCurChar + 1, \"def\", 3) )\n                        {\n                            sLine = sCurChar + 4;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0432\u0441\u0435 \u043f\u043e\u0441\u043b\u0435 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0438\n            if ( sLine )\n            {\n                (*pOutputFunc)( pOutputStream, sLine, ((char *)m_sFile + m_nLen) - sLine );\n            }\n        }\n    }\n\n    char *CFontFileType1::GetNextLine(char *sLine)\n    {\n        while ( sLine < (char *)m_sFile + m_nLen && *sLine != '\\x0a' && *sLine != '\\x0d')\n            ++sLine;\n\n        if ( sLine < (char *)m_sFile + m_nLen && *sLine == '\\x0d')\n            ++sLine;\n\n        if ( sLine < (char *)m_sFile + m_nLen && *sLine == '\\x0a')\n            ++sLine;\n\n        if ( sLine >= (char *)m_sFile + m_nLen )\n            return NULL;\n\n        return sLine;\n    }\n\n    void CFontFileType1::Parse()\n    {\n        // \u0421\u043d\u0430\u0447\u0430\u043b\u0430 \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u043c, \u0435\u0441\u043b\u0438 \u044d\u0442\u043e pfb \u0444\u0430\u0439\u043b, \u0442\u043e\u0433\u0434\u0430 \u0438\u0437\u0431\u0430\u0432\u0438\u043c\u0441\u044f \u043e\u0442 \u0432\u0441\u0435\u0445 \u0435\u0433\u043e \u043c\u0430\u0440\u043a\u0435\u0440\u043e\u0432.\n        Reset();\n\n        while( m_nPos < m_nLen && ( ' ' == m_sFile[m_nPos] || '\\t' == m_sFile[m_nPos] || '\\r' == m_sFile[m_nPos] || '\\n' == m_sFile[m_nPos] ) )\n            ++m_nPos;\n\n        bool bSuccess = true;\n        int nChar = GetU8( m_nPos, &bSuccess );\n        if ( !bSuccess || ( PFB_MARKER != nChar && '%' != nChar ) )\n            return;\n        else if ( PFB_MARKER == nChar )\n        {\n            if ( !RemovePfbMarkers() )\n                return;\n        }\n\n        char *sLine, *sLine1, *pCur, *pTemp;\n        char sBuffer[256];\n        int nCount, nCode;\n        int nIndex = 0;\n        unsigned char *sEexec = NULL;\n\n        m_oTopDict.arrdFontBBox[0] = 0; m_oTopDict.arrdFontBBox[1] = 0;\n        m_oTopDict.arrdFontBBox[2] = 0; m_oTopDict.arrdFontBBox[3] = 0;\n\n        m_oTopDict.arrdFontMatrix[0] = 0.001; m_oTopDict.arrdFontMatrix[1] = 0;\n        m_oTopDict.arrdFontMatrix[2] = 0;     m_oTopDict.arrdFontMatrix[3] = 0.001;\n        m_oTopDict.arrdFontMatrix[4] = 0;     m_oTopDict.arrdFontMatrix[5] = 0;\n\n        for (nIndex = 1, sLine = (char *)m_sFile; nIndex <= 100 && sLine && (!m_sName || !m_arrEncoding); ++nIndex )\n        {\n            if ( !m_sName && !strncmp( sLine, \"/FontName\", 9) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n                if ( ( pCur = strchr( sBuffer + 9, '/' ) ) && ( pCur = strtok( pCur + 1, \" \\t\\n\\r\" ) ) )\n                {\n                    m_sName = CopyString( pCur );\n                }\n                sLine = GetNextLine(sLine);\n\n            }\n            else if ( !strncmp( sLine, \"/FontMatrix\", 11 ) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n\n                ReadDoubleArray<6>( (unsigned char*)(sBuffer + 11), 244, m_oTopDict.arrdFontMatrix );\n                sLine = GetNextLine( sLine );\n            }\n            else if ( !strncmp( sLine, \"/FontBBox\", 9 ) )\n            {\n                strncpy( sBuffer, sLine, 255);\n                sBuffer[255] = '\\0';\n\n                ReadDoubleArray<4>( (unsigned char*)(sBuffer + 9), 246, m_oTopDict.arrdFontBBox );\n                sLine = GetNextLine( sLine );\n            }\n            else if (!m_arrEncoding && !strncmp( sLine, \"/Encoding StandardEncoding def\", 30))\n            {\n                m_arrEncoding = c_arrsFontFileType1StandardEncoding;\n            }\n            else if (!m_arrEncoding && !strncmp( sLine, \"/Encoding 256 array\", 19))\n            {\n                m_arrEncoding = (char **)MemUtilsMallocArray(256, sizeof(char *));\n                int nJ = 0;\n                for (nJ = 0; nJ < 256; ++nJ )\n                {\n                    m_arrEncoding[nJ] = NULL;\n                }\n                for (nJ = 0, sLine = GetNextLine(sLine); nJ < 300 && sLine && ( sLine1 = GetNextLine( sLine )); ++nJ, sLine = sLine1)\n                {\n                    if ( ( nCount = sLine1 - sLine ) > 255 )\n                    {\n                        nCount = 255;\n                    }\n                    strncpy( sBuffer, sLine, nCount);\n                    sBuffer[ nCount ] = '\\0';\n                    for ( pCur = sBuffer; *pCur == ' ' || *pCur == '\\t'; ++pCur );\n                    if ( !strncmp( pCur, \"dup\", 3 ) )\n                    {\n                        for ( pCur += 3; *pCur == ' ' || *pCur == '\\t'; ++pCur ) ;\n                        for ( pTemp = pCur; *pTemp >= '0' && *pTemp <= '9'; ++pTemp ) ;\n                        if ( *pTemp )\n                        {\n                            char nChar = *pTemp;\n                            *pTemp = '\\0';\n                            nCode = atoi( pCur );\n\t\t\t\t\t\t\tif (nCode < 0) nCode = 0;\t\t\t\t\t\t\t\t\n                            *pTemp = nChar;\n                            if ( nCode == 8 && *pTemp == '#')\n                            {\n                                nCode = 0;\n                                for (++pTemp; *pTemp >= '0' && *pTemp <= '7'; ++pTemp)\n                                {\n                                    nCode = nCode * 8 + (*pTemp - '0');\n                                }\n                            }\n                            if ( nCode < 256 )\n                            {\n                                for ( pCur = pTemp; *pCur == ' ' || *pCur == '\\t'; ++pCur ) ;\n                                if ( *pCur == '/')\n                                {\n                                    ++pCur;\n                                    for ( pTemp = pCur; *pTemp && *pTemp != ' ' && *pTemp != '\\t'; ++pTemp ) ;\n                                    *pTemp = '\\0';\n                                    m_arrEncoding[ nCode ] = CopyString( pCur );\n                                }\n                            }\n                        }\n                    }\n                    else\n                    {\n                        if ( strtok( sBuffer, \" \\t\") && ( pCur = strtok(NULL, \" \\t\\n\\r\")) && !strcmp( pCur, \"def\"))\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                if ( !sEexec )\n                    sEexec = (unsigned char*)strstr( sLine, \"currentfile eexec\" );\n\n                sLine = GetNextLine(sLine);\n            }\n        }\n\n        if ( NULL != sEexec )\n        {\n            unsigned char* sTemp = sEexec;\n            while ( sTemp != (unsigned char*)strstr( (char*)sTemp, \"cleartomark\" ) && sTemp < m_sFile + m_nLen )\n                sTemp++;\n\n            int nBufferLen = sTemp - ( sEexec + 17 );\n            unsigned char *sEexecBuffer = (unsigned char*)MemUtilsMalloc( nBufferLen );\n            if ( !sEexecBuffer )\n                return;\n\n            memcpy( sEexecBuffer, sEexec + 17, nBufferLen );\n            DecryptEexec( &sEexecBuffer, nBufferLen );\n\n            sEexec = sEexecBuffer + 4; // \u041f\u0435\u0440\u0432\u044b\u0435 \u0447\u0435\u0442\u044b\u0440\u0435 \u0431\u0430\u0439\u0442\u0430 \u0431\u044b\u043b\u0438 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u043c\u0438\n            int nEexecLen = nBufferLen - 4;\n\n            // \u0422\u0435\u043f\u0435\u0440\u044c \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u0435\u043c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 Private Dict\n            bool bGlyphsSection = false, bSubrsSection = false;\n            //unsigned short ushChar = '';\n            std::wstring sToken, sGlyph;\n            int nLength = 0;\n\n            // \u0412\u044b\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 Private Dict\n            m_oPrivateDict.nBlueValues       = 0;\n            m_oPrivateDict.nOtherBlues       = 0;\n            m_oPrivateDict.nFamilyBlues      = 0;\n            m_oPrivateDict.nFamilyOtherBlues = 0;\n            m_oPrivateDict.dBlueScale        = 0.039625;\n            m_oPrivateDict.nBlueShift        = 7;\n            m_oPrivateDict.nBlueFuzz         = 1;\n            m_oPrivateDict.bHasStdHW         = false;\n            m_oPrivateDict.bHasStdVW         = false;\n            m_oPrivateDict.nStemSnapH        = 0;\n            m_oPrivateDict.nStemSnapV        = 0;\n            m_oPrivateDict.bHasForceBold     = false;\n            m_oPrivateDict.nLanguageGroup    = 0;\n            m_oPrivateDict.nLenIV            = 4;\n            m_oPrivateDict.dExpansionFactor  = 0.06;\n\n            for ( int nIndex = 0; nIndex < nEexecLen; nIndex++ )\n            {\n                unsigned char nChar = sEexec[nIndex];\n\n                if ( ( bGlyphsSection || bSubrsSection ) && 'R' == nChar && nLength > 0 )\n                {\n                    unsigned char *sData = new unsigned char[nLength];\n                    if ( sData )\n                    {\n                        memcpy( sData, sEexec + nIndex + 3, nLength );\n                        unsigned short unKey = 4330U;\n                        unsigned char *sCur = sData;\n                        EexecDecode( &sCur, sCur + nLength, sCur, nLength, &unKey );\n\n                        if ( m_oPrivateDict.nLenIV > 0 && m_oPrivateDict.nLenIV < nLength )\n                        {\n                            Type1Charstring oCharstring = DecodeCharString( sData + m_oPrivateDict.nLenIV, nLength - m_oPrivateDict.nLenIV );\n                            if ( bGlyphsSection )\n                            {\n                                int nUnicode = Type1NameToUnicodeW( sGlyph.c_str() );\n\n                                if ( 0 != nUnicode )\n                                    m_arrCharstrings.Add( Type1Glyph( sGlyph, nUnicode, oCharstring )  );\n                            }\n                            else // if ( bSubrsSection )\n                            {\n                                m_arrSubrs.Add( oCharstring );\n                            }\n                        }\n\n                        delete []sData;\n                    }\n\n                    nIndex += nLength + 3;\n                }\n                else if ( IS_PS_SPACE( nChar ) )\n                {\n                    nLength = Utils::GetInteger( sToken );\n                    sToken.clear();\n                }\n                else\n                {\n                    sToken.push_back( (wchar_t)nChar );\n                    if ( !bGlyphsSection && '/' == sToken[0] )\n                    {\n                        int nTempChar = sToken[1];\n                        switch (nTempChar)\n                        {\n                        case 'B':\n                            {\n                                if ( L\"/BlueValues\" == sToken )\n                                    m_oPrivateDict.nBlueValues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnBlueValues );\n                                else if ( L\"/BlueScale\" == sToken )\n                                    m_oPrivateDict.dBlueScale  = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/BlueShift\" == sToken )\n                                    m_oPrivateDict.nBlueShift  = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/BlueFuzz\" == sToken )\n                                    m_oPrivateDict.nBlueFuzz   = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'C':\n                            {\n                                if ( L\"/CharString\" == sToken )\n                                    bGlyphsSection = true;\n\n                                break;\n                            }\n                        case 'E':\n                            {\n                                if ( L\"/ExpansionFactor\" == sToken )\n                                    m_oPrivateDict.dExpansionFactor = ReadDouble( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'F':\n                            {\n                                if ( L\"/FamilyBlues\" == sToken )\n                                    m_oPrivateDict.nFamilyBlues = ReadIntArray<type1MaxBlueValues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyBlues );\n                                else if ( L\"/FamilyOtherBlues\" == sToken )\n                                    m_oPrivateDict.nFamilyOtherBlues = ReadIntArray<type1MaxOtherBlues>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrnFamilyOtherBlues );\n                                else if ( L\"/ForceBold\" == sToken )\n                                {\n                                    m_oPrivateDict.bHasForceBold = true;\n                                    m_oPrivateDict.bForceBold = ReadBool( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                }\n\n                                break;\n                            }\n                        case 'L':\n                            {\n                                if ( L\"/LanguageGroup\" == sToken )\n                                    m_oPrivateDict.nLanguageGroup = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n                                else if ( L\"/lenIV\" == sToken )\n                                    m_oPrivateDict.nLenIV = ReadInt( sEexec + nIndex + 1, nEexecLen - nIndex - 1 );\n\n                                break;\n                            }\n                        case 'S':\n                            {\n                                if ( L\"/Subrs\" == sToken )\n                                    bSubrsSection = true;\n                                else if ( L\"/StemSnapH\" == sToken )\n                                    m_oPrivateDict.nStemSnapH = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapH );\n                                else if ( L\"/StemSnapV\" == sToken )\n                                    m_oPrivateDict.nStemSnapV = ReadDoubleArray<type1MaxStemSnap>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, m_oPrivateDict.arrdStemSnapV );\n                                else if ( L\"/StdHW\" == sToken )\n                                {\n                                    // \u0417\u0434\u0435\u0441\u044c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u043d\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c\n                                    double dTemp[1];\n\n                                    if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )\n                                    {\n                                        m_oPrivateDict.bHasStdHW = true;\n                                        m_oPrivateDict.dStdHW = dTemp[0];\n                                    }\n                                }\n                                else if ( L\"/StdVW\" == sToken )\n                                {\n                                    // \u0417\u0434\u0435\u0441\u044c \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u043c\u0430\u0441\u0441\u0438\u0432 \u0441 \u043e\u0434\u043d\u0438\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\u043c\n                                    double dTemp[1];\n                                    if ( ReadDoubleArray<1>( sEexec + nIndex + 2, nEexecLen - nIndex - 2, dTemp ) > 0 )\n                                    {\n                                        m_oPrivateDict.bHasStdHW = true;\n                                        m_oPrivateDict.dStdVW = dTemp[0];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if ( '/' == nChar  )\n                    {\n                        sToken.clear();\n                        sGlyph.clear();\n\n                        while ( nIndex < nEexecLen && ( nChar = sEexec[++nIndex] ) != ' ' )\n                            sGlyph.push_back( (wchar_t)nChar );\n                    }\n                }\n            }\n            MemUtilsFree( sEexecBuffer );\n\n            // \u041f\u0440\u043e\u0432\u0435\u0434\u0435\u043c \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0443 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 m_arrCharstrings \u043f\u043e \u044e\u043d\u0438\u043a\u043e\u0434\u043d\u043e\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e\n            qsort( m_arrCharstrings.GetData(), m_arrCharstrings.GetSize(), sizeof(Type1Glyph), CompareType1Glyph );\n        }\n\n        m_bParsed = true;\n    }\n\n    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        // \u0421\u043e\u0433\u043b\u0430\u0441\u043d\u043e \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 Type1, \u043f\u0435\u0440\u0432\u044b\u0439 \u0431\u0430\u0439\u0442 \u043d\u0435 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c ASCII \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u043c\n        // (\u043f\u0440\u043e\u0431\u0435\u043b, \u0442\u0430\u0431, \u043f\u0435\u0440\u0435\u043d\u043e\u0441 \u043a\u0430\u0440\u0435\u0442\u043a\u0438 \u0438\u043b\u0438 \u043f\u0435\u0440\u0435\u043d\u043e\u0441 \u0441\u0442\u0440\u043e\u043a\u0438).\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n            ++sCur;\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u043d\u0430\u043c \u043d\u0430\u0434\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u0432 \u043a\u0430\u043a\u043e\u043c \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0443 \u043d\u0430\u0441 \u0434\u0430\u043d\u043d\u044b\u0435: ASKII \u0438\u043b\u0438 \u0431\u0438\u043d\u0430\u0440\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435.\n        // \u0415\u0441\u043b\u0438 \u043f\u0435\u0440\u0432\u044b\u0435 \u0447\u0435\u0442\u044b\u0440\u0435 \u0431\u0430\u0439\u0442\u0430 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0448\u0435\u0441\u0442\u043d\u0430\u0434\u0446\u0430\u0442\u0438\u0440\u0438\u0447\u043d\u044b\u043c\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\u043c\u0438, \u0437\u043d\u0430\u0447\u0438\u0442, \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0430 ASCII.\n        bool bASCII = false;\n\n        if ( isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n\n        unsigned short ushKey = 55665U;\n        EexecDecode( &sCur, *ppEexecBuffer + nLen, sCur, nLen, &ushKey );\n    }\n    bool CFontFileType1::RemovePfbMarkers()\n    {\n        bool bSuccess = true;\n\n        int nBlockType = 0;\n        int nBlockLen  = 0;\n        int nChar = 0;\n\n        unsigned char *sBuffer = NULL;\n        unsigned int nBufLen = 0;\n\n        while ( nBlockType != PFB_DONE )\n        {\n            while ( 0 == nBlockLen )\n            {\n                nChar = ReadU8( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n\n                nBlockType = ReadU8( &bSuccess );\n                if ( !bSuccess || PFB_MARKER != nChar || ( PFB_ASCII != nBlockType && PFB_BINARY != nBlockType && PFB_DONE != nBlockType ) )\n                    return false;\n\n                if ( PFB_DONE == nBlockType )\n                    break;\n\n                nBlockLen = ReadU32LE( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n            }\n\n            // \u0427\u0438\u0442\u0430\u0435\u043c \u0441\u0430\u043c \u0431\u043b\u043e\u043a \u0434\u0430\u043d\u043d\u044b\u0445\n            if ( nBlockLen > 0 )\n            {\n                if ( !sBuffer )\n                {\n                    sBuffer = (unsigned char*)MemUtilsMalloc( nBlockLen );\n                    if ( !sBuffer )\n                        return false;\n                }\n                else\n                    sBuffer = (unsigned char*)MemUtilsRealloc( sBuffer, nBufLen + nBlockLen );\n\n                Read( sBuffer + nBufLen, nBlockLen );\n                nBufLen += nBlockLen;\n            }\n            nBlockLen = 0;\n        }\n\n        if ( m_bFreeFileData )\n            MemUtilsFree( m_sFile );\n\n        m_bFreeFileData = true;\n        m_sFile         = (unsigned char*)sBuffer;\n        m_sFileData     = m_sFile;\n        m_nLen          = nBufLen;\n        m_nPos          = 0;\n\n        return true;\n    }\n\n    Type1Charstring CFontFileType1::DecodeCharString(unsigned char *sString, int nLen)\n    {\n        CArray<Type1CharstringItem> sCharString;\n\n        int nLSB = 0, nWidth = 0;\n\n        for ( int nIndex = 0; nIndex < nLen; nIndex++ )\n        {\n            int nValue = sString[nIndex];\n\n            if ( nValue < 32 ) // \u043a\u043e\u043c\u0430\u043d\u0434\u0430\n            {\n                int nCommand = 0;\n\n                if ( 12 == nValue )\n                {\n                    int nNextValue = sString[++nIndex];\n\n                    if ( 16 == nNextValue )\n                    {\n                        if ( sCharString.GetSize() <= 0 )\n                            continue;\n\n                        int nInd = sCharString[sCharString.GetSize() - 1].nValue;\n                        sCharString.RemoveAt( sCharString.GetSize() - 1 );\n\n                        while ( sCharString.GetSize() > 0 && false == sCharString[sCharString.GetSize() - 1].bCommand )\n                            sCharString.RemoveAt( sCharString.GetSize() - 1 );\n\n                        // If the flex mechanishm is not used in a font program, Adobe\n                        // state that that entries 0, 1 and 2 can simply be replace by\n                        // {}, which means that we can simply ignore them.\n                        if ( nInd < 3 )\n                            continue;\n\n                        // This is the same things about hint replacement, if it is not used\n                        // entry 3 can be replaced by {3}\n                        if ( 3 == nInd )\n                        {\n                            sCharString.Add( Type1CharstringItem( 3, true ) );\n                            nIndex++;\n                            continue;\n                        }\n                    }\n\n                    nCommand = 12 + ( nNextValue << 8 );\n                }\n                else\n                {\n                    if ( 13 == nValue )\n                    {\n                        if ( 2 == sCharString.GetSize() )\n                            nWidth = sCharString[1].nValue;\n                        else if ( 4 == sCharString.GetSize() && 0x0C0C == sCharString[3].nValue && sCharString[3].bCommand )\n                            nWidth = sCharString[1].nValue / sCharString[2].nValue;\n                        else\n                        {\n                            // TO DO: \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0443\n                            nWidth = 0;\n                        }\n\n                        if ( sCharString.GetSize() > 0 )\n                        {\n                            nLSB = sCharString[0].nValue;\n                            sCharString.Add( Type1CharstringItem( nLSB, false ) );\n                            sCharString.Add( Type1CharstringItem( c_nType1hmoveto, true ) );\n                            sCharString.RemoveAt( 0 );\n                        }\n                        else\n                        {\n                            nLSB = 0;\n                            sCharString.Add( Type1CharstringItem( nLSB, false ) );\n                            sCharString.Add( Type1CharstringItem( c_nType1hmoveto, true ) );\n                        }\n\n                        continue;\n                    }\n\n                    nCommand = nValue;\n                }\n\n                // Some charstring commands are meaningless in Type2 and will return\n                // a null, let's just ignored them\n                if ( !nCommand && nIndex < nLen )\n                    continue;\n                else if ( !nCommand )\n                    break;\n                else if ( c_nType1seac == nCommand || c_nType1sbw == nCommand )\n                {\n                    // TO DO: \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0430\u0442\u044c \u043e\u0448\u0438\u0431\u043a\u0443\n                }\n\n                sCharString.Add( Type1CharstringItem( nCommand, true ) );\n            }\n            else\n            {\n                if ( nValue <= 246 )\n                    nValue = nValue - 139;\n                else if ( nValue <= 250 )\n                    nValue =  ( ( nValue - 247 ) * 256 ) + (int)( sString[++nIndex] ) + 108;\n                else if ( nValue <= 254 )\n                    nValue = -( ( nValue - 251 ) * 256 ) - (int)( sString[++nIndex] ) - 108;\n                else\n                    nValue = ( sString[++nIndex] & 0xff ) << 24 | ( sString[++nIndex] & 0xff ) << 16 | ( sString[++nIndex] & 0xff ) << 8 | ( sString[++nIndex] & 0xff ) << 0;\n\n                sCharString.Add( Type1CharstringItem( nValue, false ) );\n            }\n        }\n\n        return Type1Charstring( sCharString, nWidth, nLSB );\n    }\n    Type1Charstring CFontFileType1::FlattenCharstring(Type1Charstring& oCharstring, int nBias)\n    {\n        Type1Charstring oNew;\n        oNew.nLSB   = oCharstring.nLSB;\n        oNew.nWidth = oCharstring.nWidth;\n\n        for ( int nIndex = 0; nIndex < oCharstring.arrCharstring.GetSize(); nIndex++ )\n        {\n            Type1CharstringItem oItem = oCharstring.arrCharstring[nIndex];\n            int nValue = oItem.nValue;\n            if ( oItem.bCommand )\n            {\n                if ( nValue == c_nType1sub )\n                {\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 11, true ) );\n                }\n                else if ( nValue == c_nType1div )\n                {\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                }\n                else if ( nValue == c_nType1pop )\n                {\n                    //oNew.arrCharstring.Add( Type1CharstringItem( 1, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 12, true ) );\n                    oNew.arrCharstring.Add( Type1CharstringItem( 18, true ) );\n                }\n                else if ( nValue == c_nType1callsubr  )\n                {\n                    //int nTempLen = oNew.arrCharstring.GetSize();\n                    //int nT1 = oNew.arrCharstring[nTempLen - 2].nValue;\n                    //int nT2 = oNew.arrCharstring[nTempLen - 1].nValue;\n                    //int nInd = nT1 << 8 | nT2;\n\n                    //if ( 107 == nBias )\n                    //{\n                    //\tif ( nInd <= 215 )\n                    //\t{\n                    //\t\toNew.arrCharstring.RemoveAt( nTempLen - 1 );\n                    //\t\toNew.arrCharstring.RemoveAt( nTempLen - 2 );\n\n                    //\t\toNew.arrCharstring[nTempLen - 3].nValue = nInd - nBias + 139;\n                    //\t\toNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                    //\t}\n                    //\telse\n                    //\t{\n                    //\t\toNew.arrCharstring.RemoveAt( nTempLen - 1 );\n\n                    //\t\toNew.arrCharstring[nTempLen - 3].nValue = ((nInd - nBias) - 108) / 256 + 247;\n                    //\t\toNew.arrCharstring[nTempLen - 2].nValue = ((nInd - nBias) - 108) - (oNew.arrCharstring[nTempLen - 3].nValue - 247) * 256;\n                    //\t\toNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                    //\t}\n                    //}\n                    //else\n                    //{\n\n                    //\tnInd -= nBias;\n                    //\toNew.arrCharstring[nTempLen - 2].nValue = nInd >> 8;\n                    //\toNew.arrCharstring[nTempLen - 1].nValue = nInd & 0xFF;\n                    //\toNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                    //}\n                    oNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n                }\n                else\n                    oNew.arrCharstring.Add( Type1CharstringItem( oItem.nValue, true ) );\n            }\n            else\n            {\n                // Type1 charstrings \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442 \u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u0447\u0438\u0441\u0435\u043b \u0431\u043e\u043b\u044c\u0448\u0438\u0445 32000\n                if ( oItem.nValue > 32000 )\n                {\n                    int nDivisor = oCharstring.arrCharstring[nIndex + 1].nValue;\n                    if ( 0 != nDivisor )\n                        nValue /= nDivisor;\n                }\n                oNew.arrCharstring.Add( Type1CharstringItem( 28, true ) );\n                oNew.arrCharstring.Add( Type1CharstringItem( nValue >> 8, false ) );\n                oNew.arrCharstring.Add( Type1CharstringItem( nValue & 0xFF, false ) );\n            }\n        }\n\n        return oNew;\n    }\n    void CFontFileType1::CFFCreateIndexHeader(FontFileOutputFunc pOutputFunc, void *pOutputStream, CArray<std::wstring> aObjects)\n    {\n        char nChar;\n        int nCount = aObjects.GetSize();\n        if ( 0 == nCount )\n        {\n            pOutputFunc( pOutputStream, \"\\x00\\x00\\x00\", 3 );\n            return;\n        }\n\n        // \u041f\u0435\u0440\u0432\u044b\u0435 \u0434\u0432\u0430 \u0431\u0430\u0439\u0442\u0430 - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n        WriteChar( nCount >> 8 );\n        WriteChar( nCount & 0xFF );\n        // \u0420\u0430\u0437\u043c\u0435\u0440 \u0441\u0434\u0432\u0438\u0433\u043e\u0432, \u0441\u0442\u0430\u0432\u0438\u043c \u043f\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u0443\n        WriteChar( 0x04 );\n\n        int nRelativeOffset = 1;\n        for ( int nIndex = 0; nIndex < nCount + 1; nIndex++ )\n        {\n            WriteChar( (nRelativeOffset >> 24) & 0xFF );\n            WriteChar( (nRelativeOffset >> 16) & 0xFF );\n            WriteChar( (nRelativeOffset >>  8) & 0xFF );\n            WriteChar( (nRelativeOffset)       & 0xFF );\n\n            if ( nIndex < nCount )\n                nRelativeOffset += aObjects[nIndex].length();\n        }\n\n        for ( int nIndex = 0; nIndex < nCount; nIndex++ )\n        {\n            std::string sCur = U_TO_UTF8((aObjects[nIndex]));\n            pOutputFunc( pOutputStream, sCur.c_str(), sCur.length() );\n        }\n    }\n    void CFontFileType1::CFFCreateIndexHeader(FontFileOutputFunc pOutputFunc, void *pOutputStream, CArray<Type1Charstring> aObjects)\n    {\n        char nChar;\n        int nCount = aObjects.GetSize();\n        if ( 0 == nCount )\n        {\n            pOutputFunc( pOutputStream, \"\\x00\\x00\\x00\", 3 );\n            return;\n        }\n\n        // \u041f\u0435\u0440\u0432\u044b\u0435 \u0434\u0432\u0430 \u0431\u0430\u0439\u0442\u0430 - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n        WriteChar( nCount >> 8 );\n        WriteChar( nCount & 0xFF );\n        // \u0420\u0430\u0437\u043c\u0435\u0440 \u0441\u0434\u0432\u0438\u0433\u043e\u0432, \u0441\u0442\u0430\u0432\u0438\u043c \u043f\u043e \u043c\u0430\u043a\u0441\u0438\u043c\u0443\u043c\u0443\n        WriteChar( 0x04 );\n\n        int nRelativeOffset = 1;\n        for ( int nIndex = 0; nIndex < nCount + 1; nIndex++ )\n        {\n            WriteChar( (nRelativeOffset >> 24) & 0xFF );\n            WriteChar( (nRelativeOffset >> 16) & 0xFF );\n            WriteChar( (nRelativeOffset >>  8) & 0xFF );\n            WriteChar( (nRelativeOffset)       & 0xFF );\n\n            if ( nIndex < nCount )\n                nRelativeOffset += aObjects[nIndex].arrCharstring.GetSize();\n        }\n\n        for ( int nI = 0; nI < nCount; nI++ )\n        {\n            for ( int nJ = 0; nJ < aObjects[nI].arrCharstring.GetSize(); nJ++ )\n            {\n                WriteChar( aObjects[nI].arrCharstring[nJ].nValue & 0xFF );\n            }\n        }\n    }\n    void CFontFileType1::CFFEncodeNumber(FontFileOutputFunc pOutputFunc, void *pOutputStream, int nValue, bool bForceLong)\n    {\n        char nChar;\n        if ( !bForceLong && nValue >= -32768 && nValue <= 32767 )\n        {\n            WriteChar( 0x1c );\n            WriteChar( ( nValue >> 8 ) & 0xFF );\n            WriteChar( nValue & 0xFF );\n        }\n        else // if ( nValue >= (-2147483648) && nValue <= 2147483647 )\n        {\n            WriteChar( 0x1d );\n            WriteChar( ( nValue >> 24 ) & 0xFF );\n            WriteChar( ( nValue >> 16 ) & 0xFF );\n            WriteChar( ( nValue >>  8 ) & 0xFF );\n            WriteChar( nValue & 0xFF );\n        }\n    }\n    void CFontFileType1::CFFEncodeNumber(FontFileOutputFunc pOutputFunc, void *pOutputStream, double dValue)\n    {\n        char nChar = 0;\n\n        WriteChar( 0x1e ); // \u043d\u0430\u0447\u0430\u043b\u043e \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430\n\n        std::wstring sValue = std::to_wstring(dValue);\n        bool bFirstNibble = true;\n        for ( int nIndex = 0; nIndex < sValue.length(); nIndex++ )\n        {\n            int nCurChar = sValue.c_str()[ nIndex ];\n            if ( '0' <= nCurChar && nCurChar <= '9' )\n                nCurChar -= (int)('0');\n            else if ( '.' == nCurChar )\n                nCurChar = 0x0a;\n            else if ( '-' == nCurChar )\n                nCurChar = 0x0e;\n            else\n                continue;\n\n            if ( bFirstNibble )\n                nChar = nCurChar << 4;\n            else\n            {\n                nChar += nCurChar;\n                WriteChar( nChar );\n            }\n\n            bFirstNibble = !bFirstNibble;\n        }\n\n        // \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u043e\u043a\u043e\u043d\u0447\u0430\u043d\u0438\u0435\u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430\n        if ( bFirstNibble )\n            nChar = (char)0xff;\n        else\n            nChar += 0x0f;\n\n        WriteChar( nChar );\n    }\n    void CFontFileType1::ToCFF(FontFileOutputFunc pOutputFunc, void *pOutputStream)\n    {\n        std::wstring sFontName = NSFile::CUtf8Converter::GetUnicodeFromCharPtr( m_sName, (LONG)strlen(m_sName) );\n        CArray<std::wstring> aString;\n\n        int nBias = 0;\n        int nSubrsLen = m_arrSubrs.GetSize();\n        if ( nSubrsLen < 1240 )\n            nBias = 107;\n        else if ( nSubrsLen < 33900 )\n            nBias = 1131;\n        else\n            nBias = 32768;\n\n        CArray<Type1Charstring> arrType2Charstrings;\n        Type1Charstring oFirstCharstring;\n        oFirstCharstring.arrCharstring.Add( Type1CharstringItem( 0x8B, false ) );\n        oFirstCharstring.arrCharstring.Add( Type1CharstringItem( 0x0E, false ) );\n        arrType2Charstrings.Add( oFirstCharstring );\n        for ( int nIndex = 0; nIndex < m_arrCharstrings.GetSize(); nIndex++ )\n        {\n            std::wstring sG = m_arrCharstrings[nIndex].sGlyph;\n            if ( L\"afii10090\" == sG )\n                int k = 10;\n            arrType2Charstrings.Add( FlattenCharstring( m_arrCharstrings[nIndex].oData, nBias ) );\n        }\n\n        CArray<Type1Charstring> arrType2Subrs;\n\n        //Type1Charstring oBias;\n        ////oBias.arrCharstring.Add( Type1CharstringItem( 0x0B, false ) );\n        //oBias.arrCharstring.Add( Type1CharstringItem( 0x0E, false ) );\n        //for ( int nIndex = 0; nIndex < nBias; nIndex++ )\n        //\tarrType2Subrs.Add( oBias );\n\n        for ( int nIndex = 0; nIndex < nSubrsLen; nIndex++ )\n        {\n            //if ( nIndex == 256 )\n            //{\n            //\tType1Charstring oBias;\n            //\toBias.arrCharstring.Add( Type1CharstringItem( 0x0B, false ) );\n            //\tfor ( int nIndex = 0; nIndex < nBias; nIndex++ )\n            //\t\tarrType2Subrs.Add( oBias );\n            //}\n            arrType2Subrs.Add( FlattenCharstring( m_arrSubrs[nIndex], 0 ) );\n        }\n\n        // Header\n        TCharBuffer oHeader;\n        oHeader.Write( \"\\x01\\x00\\x04\\x04\", 4 );\n\n        // Name\n        TCharBuffer oName;\n        aString.RemoveAll();\n        aString.Add( sFontName );\n        CFFCreateIndexHeader( CharBufferWrite, &oName, aString );\n\n        // Strings\n        TCharBuffer oStrings;\n        aString.RemoveAll();\n        int nNewSID = CFF_STANDARD_STRINGS_COUNT;\n        aString.Add( L\"Version 0.11\" );        nNewSID++; // Version\n        aString.Add( L\"See original notice\" ); nNewSID++; // Notice\n        aString.Add( sFontName );                 nNewSID++; // FullName\n        aString.Add( sFontName );                 nNewSID++; // FamilyName\n        aString.Add( L\"Medium\" );              nNewSID++; // Weight\n\n        for ( int nIndex = 0; nIndex < m_arrCharstrings.GetSize(); nIndex++ )\n        {\n            int nSID = GetCFFStringIndex( m_arrCharstrings[nIndex].sGlyph.c_str() );\n            if ( nSID < 0 )\n            {\n                aString.Add( m_arrCharstrings[nIndex].sGlyph );\n                nSID = nNewSID;\n                nNewSID++;\n            }\n\n            m_arrCharstrings[nIndex].nReserved = nSID;\n        }\n\n        CFFCreateIndexHeader( CharBufferWrite, &oStrings, aString );\n\n        // GlobalSubrs\n        TCharBuffer oGlobalSubrs;\n        aString.RemoveAll(); // \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u043f\u0443\u0441\u0442\u043e\u0439 \u043c\u0430\u0441\u0441\u0438\u0432\n        CFFCreateIndexHeader( CharBufferWrite, &oGlobalSubrs, aString );\n\n        // Charset\n        TCharBuffer oCharset;\n        oCharset.Write( (char)0x00 ); // Encoding\n\n        int nGlyphsCount = m_arrCharstrings.GetSize();\n        for ( int nIndex = 0; nIndex < nGlyphsCount; nIndex++ )\n        {\n            int nSID = m_arrCharstrings[nIndex].nReserved;\n            oCharset.Write( (char)(nSID >> 8) );\n            oCharset.Write( (char)(nSID & 0xFF) );\n        }\n\n        // Charstrings\n        TCharBuffer oCharstrings;\n        CFFCreateIndexHeader( NSFontConverter::CharBufferWrite, &oCharstrings, arrType2Charstrings );\n\n        // Private\n        TCharBuffer oPrivate;\n        oPrivate.Write( \"\\x8b\\x14\", 2 ); // defaultWidth\n        oPrivate.Write( \"\\x8b\\x15\", 2 ); // nominalWidth\n\n        // Private: BlueValues\n        if ( m_oPrivateDict.nBlueValues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnBlueValues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nBlueValues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnBlueValues[nIndex] - m_oPrivateDict.arrnBlueValues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x06 );\n        }\n\n        // Private: OtherBlues\n        if ( m_oPrivateDict.nOtherBlues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnOtherBlues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nOtherBlues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnOtherBlues[nIndex] - m_oPrivateDict.arrnOtherBlues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x07 );\n        }\n\n        // Private: FamilyBlues\n        if ( m_oPrivateDict.nFamilyBlues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyBlues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nFamilyBlues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyBlues[nIndex] - m_oPrivateDict.arrnFamilyBlues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x08 );\n        }\n\n        // Private: FamilyOtherBlues\n        if ( m_oPrivateDict.nFamilyOtherBlues > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyOtherBlues[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nFamilyOtherBlues; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrnFamilyOtherBlues[nIndex] - m_oPrivateDict.arrnFamilyOtherBlues[nIndex - 1] );\n\n            oPrivate.Write( (char)0x09 );\n        }\n\n        // Private: StemSnapH\n        if ( m_oPrivateDict.nStemSnapH > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapH[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nStemSnapH; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapH[nIndex] - m_oPrivateDict.arrdStemSnapH[nIndex - 1] );\n\n            oPrivate.Write( \"\\x0c\\x0c\" , 2);\n        }\n\n        // Private: StemSnapV\n        if ( m_oPrivateDict.nStemSnapV > 0 )\n        {\n            CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapV[0] );\n            for ( int nIndex = 1; nIndex < m_oPrivateDict.nStemSnapV; nIndex++ )\n                CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.arrdStemSnapV[nIndex] - m_oPrivateDict.arrdStemSnapV[nIndex - 1] );\n\n            oPrivate.Write( \"\\x0c\\x0d\" , 2);\n        }\n\n        // Private: BlueShift\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nBlueShift );\n        oPrivate.Write( \"\\x0c\\x0a\", 2 );\n\n        // Private: BlueFuzz\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nBlueFuzz );\n        oPrivate.Write( \"\\x0c\\x0b\", 2 );\n\n        // Private: BlueScale\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.dBlueScale );\n        oPrivate.Write( \"\\x0c\\x09\", 2 );\n\n        // Private: LanguageGroup\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.nLanguageGroup );\n        oPrivate.Write( \"\\x0c\\x11\", 2 );\n\n        // Private: ExpansionFactor\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, m_oPrivateDict.dExpansionFactor );\n        oPrivate.Write( \"\\x0c\\x18\", 2 );\n\n        // Private: Subrs\n        int nPrivateLen = oPrivate.nLen + (5 + 1);\n        CFFEncodeNumber( CharBufferWrite, &oPrivate, nPrivateLen, true );\n        oPrivate.Write( \"\\x13\", 1 );\n\n        // LocalSubrs\n        TCharBuffer oLocalSubrs;\n        CFFCreateIndexHeader( CharBufferWrite, &oLocalSubrs, arrType2Subrs );\n\n        // Top Dict\n        TCharBuffer oTopDict;\n        oTopDict.Write( \"\\x00\\x01\\x04\\x00\\x00\\x00\\x01\\x00\\x00\\0x00\\x00\", 11 );\n        oTopDict.Write( \"\\xf8\\x1b\\x00\", 3 ); // Version\n        oTopDict.Write( \"\\xf8\\x1c\\x01\", 3 ); // Notice\n        oTopDict.Write( \"\\xf8\\x1d\\x02\", 3 ); // FullName\n        oTopDict.Write( \"\\xf8\\x1e\\x03\", 3 ); // FamilyName\n        oTopDict.Write( \"\\xf8\\x1f\\x04\", 3 ); // Weight\n        oTopDict.Write( \"\\x1c\\x00\\x00\\x10\", 4 ); // Encoding\n\n        // BBox\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[0] );\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[1] );\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[2] );\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, m_oTopDict.arrdFontBBox[3] );\n        oTopDict.Write( \"\\x05\", 1 );\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u043e\u0446\u0435\u043d\u0438\u043c \u0440\u0430\u0437\u043c\u0435\u0440 TopDict: \u0412\u043e\u0437\u044c\u043c\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0443\u044e \u0434\u043b\u0438\u043d\u0443, \u0434\u043e\u0431\u0430\u0432\u0438\u043c \u043a \u043d\u0435\u0439 (4 * 5 + 3)\n        // ( 4 \u0447\u0438\u0441\u043b\u0430, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043f\u0438\u0448\u0435\u043c \u043f\u043e 5 \u0431\u0430\u0439\u0442 + 3 \u0431\u0430\u0439\u0442\u0430 \u043d\u0430 3 \u043a\u043e\u043c\u0430\u043d\u0434\u044b)\n        int nTopDictLen = oTopDict.nLen + ( 4 * 5 + 3);\n\n        int nOffset = oHeader.nLen + oName.nLen + nTopDictLen + oStrings.nLen + oGlobalSubrs.nLen;\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );\n        oTopDict.Write( \"\\x0f\", 1 ); // Charset\n\n        nOffset += oCharset.nLen;//( arrType2Charstrings.GetSize() * 2 ) + 1;\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );\n        oTopDict.Write( \"\\x11\", 1 ); // Charstrings\n\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, oPrivate.nLen, true );\n        nOffset += oCharstrings.nLen;\n        CFFEncodeNumber( CharBufferWrite, &oTopDict, nOffset, true );\n        oTopDict.Write( \"\\x12\", 1 ); // Private\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u0437\u0430\u043f\u0438\u0448\u0435\u043c \u0440\u0435\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0430\u0437\u043c\u0435\u0440 TopDict\n        int nTopDictDataLen = nTopDictLen - 10;\n        oTopDict.sBuffer[7]  = ( nTopDictDataLen >> 24 ) & 0xFF;\n        oTopDict.sBuffer[8]  = ( nTopDictDataLen >> 16 ) & 0xFF;\n        oTopDict.sBuffer[9]  = ( nTopDictDataLen >> 8  ) & 0xFF;\n        oTopDict.sBuffer[10] = nTopDictDataLen & 0xFF;\n\n        // \u0417\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0432\u0441\u0435 \u0432 \u0444\u0430\u0439\u043b\n        pOutputFunc( pOutputStream, oHeader.sBuffer,      oHeader.nLen      );\n        pOutputFunc( pOutputStream, oName.sBuffer,        oName.nLen        );\n        pOutputFunc( pOutputStream, oTopDict.sBuffer,     oTopDict.nLen     );\n        pOutputFunc( pOutputStream, oStrings.sBuffer,     oStrings.nLen     );\n        pOutputFunc( pOutputStream, oGlobalSubrs.sBuffer, oGlobalSubrs.nLen );\n        pOutputFunc( pOutputStream, oCharset.sBuffer,     oCharset.nLen     );\n        pOutputFunc( pOutputStream, oCharstrings.sBuffer, oCharstrings.nLen );\n        pOutputFunc( pOutputStream, oPrivate.sBuffer,     oPrivate.nLen     );\n        pOutputFunc( pOutputStream, oLocalSubrs.sBuffer,  oLocalSubrs.nLen  );\n    }\n}\n"], "filenames": ["DesktopEditor/fontengine/fontconverter/FontFileBase.h", "DesktopEditor/fontengine/fontconverter/FontFileType1.cpp"], "buggy_code_start_loc": [64, 399], "buggy_code_end_loc": [261, 660], "fixing_code_start_loc": [64, 400], "fixing_code_end_loc": [261, 661], "type": "CWE-787", "message": "Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.", "other": {"cve": {"id": "CVE-2022-29777", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-02T14:15:51.120", "lastModified": "2022-12-09T19:32:33.730", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h."}, {"lang": "es", "value": "Se ha detectado que Onlyoffice Document Server versiones v6.0.0 y anteriores y Core versiones 6.1.0.26 y anteriores, contienen un desbordamiento de pila por medio del componente DesktopEditor/fontengine/fontconverter/FontFileBase.h"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:onlyoffice:core:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.1.0.26", "matchCriteriaId": "4D7538B8-3720-42EB-BE17-C272DFCEA122"}, {"vulnerable": true, "criteria": "cpe:2.3:a:onlyoffice:document_server:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.0.0", "matchCriteriaId": "5398FF95-A6B1-4BE0-8A46-1FD03FDDE7D2"}]}]}], "references": [{"url": "https://github.com/ONLYOFFICE/DocumentServer/blob/master/CHANGELOG.md#601", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/moehw/poc_exploits/tree/master/CVE-2022-29777", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ONLYOFFICE/core/commit/b17d5e860f30e8be2caeb0022b63be4c76660178"}}