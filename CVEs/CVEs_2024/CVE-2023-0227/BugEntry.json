{"buggy_code": ["# -*- coding: utf-8 -*-\n#       ____________\n#   ___/       |    \\_____________ _                 _ ___\n#  /        ___/    |    _ __ _  _| |   ___  __ _ __| |   \\\n# /    \\___/  ______/   | '_ \\ || | |__/ _ \\/ _` / _` |    \\\n# \\            \u25ef |      | .__/\\_, |____\\___/\\__,_\\__,_|    /\n#  \\_______\\    /_______|_|   |__/________________________/\n#           \\  /\n#            \\/\n\nimport json\nimport os\nimport re\nimport time\nfrom enum import IntFlag\n\nfrom ..datatypes.data import *\nfrom ..datatypes.enums import *\nfrom ..datatypes.exceptions import *\nfrom ..datatypes.pyfile import PyFile\nfrom ..log_factory import LogFactory\nfrom ..network.request_factory import get_url\nfrom ..utils import fs, seconds\nfrom ..utils.old.packagetools import parse_names\n\n# contains function names mapped to their permissions\n# unlisted functions are for admins only\nperm_map = {}\n\n# contains function names mapped to their legacy name\nlegacy_map = {}\n\n\n# decorator only called on init, never initialized, so has no effect on runtime\ndef permission(bits):\n    class Wrapper:\n        def __new__(cls, func, *args, **kwargs):\n            perm_map[func.__name__] = bits\n            return func\n\n    return Wrapper\n\n\ndef legacy(legacy_name):\n    class Wrapper:\n        def __new__(cls, func, *args, **kwargs):\n            legacy_map[func.__name__] = legacy_name\n            return func\n\n    return Wrapper\n\n\nurlmatcher = re.compile(\n    r\"(?:https?|ftps?|xdcc|sftp):(?://|\\\\\\\\)+[\\w\\-._~:/?#\\[\\]@!$&'()*+,;=]*|magnet:\\?.+\",\n    re.IGNORECASE,\n)\n\n\nclass Perms(IntFlag):\n    ANY = 0  #: requires no permission, but login\n    ADD = 1  #: can add packages\n    DELETE = 2  #: can delete packages\n    STATUS = 4  #: see and change server status\n    LIST = 16  #: see queue and collector\n    MODIFY = 32  #: modify some attribute of downloads\n    DOWNLOAD = 64  #: can download from webinterface\n    SETTINGS = 128  #: can access settings\n    ACCOUNTS = 256  #: can access accounts\n    LOGS = 512  #: can see server logs\n\n\nclass Role(IntFlag):\n    ADMIN = 0  #: admin has all permissions implicit\n    USER = 1\n\n\ndef has_permission(userperms, perms):\n    # bitwise or perms before if needed\n    return perms == (userperms & perms)\n\n\n# API VERSION\n__version__ = 1\n\n\nclass Api:\n    \"\"\"\n    **pyLoads API**\n\n    This is accessible either internal via core.api or via thrift backend.\n\n    see Thrift specification file remote/thriftbackend/pyload.thrift\\\n    for information about data structures and what methods are usable with rpc.\n\n    Most methods requires specific permissions, please look at the source code if you need to know.\\\n    These can be configured via webinterface.\n    Admin user have all permissions, and are the only ones who can access the methods with no specific permission.\n    \"\"\"\n\n    def __new__(cls, core):\n        obj = super(Api, cls).__new__(cls)\n\n        # add methods specified by the @legacy decorator\n        # also set legacy method permissions according to the @permissions decorator\n        for func_name, legacy_name in legacy_map.items():\n            func = getattr(obj, func_name)\n            setattr(obj, legacy_name, func)\n\n            permissions = perm_map.get(func_name)\n            if permissions is not None:\n                perm_map[legacy_name] = permissions\n\n        return obj\n\n    def __init__(self, core):\n        self.pyload = core\n        self._ = core._\n\n    def _convert_py_file(self, p):\n        f = FileData(\n            p[\"id\"],\n            p[\"url\"],\n            p[\"name\"],\n            p[\"plugin\"],\n            p[\"size\"],\n            p[\"format_size\"],\n            p[\"status\"],\n            p[\"statusmsg\"],\n            p[\"package\"],\n            p[\"error\"],\n            p[\"order\"],\n        )\n        return f\n\n    def _convert_config_format(self, c):\n        sections = {}\n        for section_name, sub in c.items():\n            section = ConfigSection(section_name, sub[\"desc\"])\n            items = []\n            for key, data in sub.items():\n                if key in (\"desc\", \"outline\"):\n                    continue\n                item = ConfigItem()\n                item.name = key\n                item.description = data[\"desc\"]\n                item.value = str(data[\"value\"])\n                item.type = data[\"type\"]\n                items.append(item)\n            section.items = items\n            sections[section_name] = section\n            if \"outline\" in sub:\n                section.outline = sub[\"outline\"]\n        return sections\n\n    @legacy(\"getConfigValue\")\n    @permission(Perms.SETTINGS)\n    def get_config_value(self, category, option, section=\"core\"):\n        \"\"\"\n        Retrieve config value.\n\n        :param category: name of category, or plugin\n        :param option: config option\n        :param section: 'plugin' or 'core'\n        :return: config value\n        \"\"\"\n        if section == \"core\":\n            value = self.pyload.config[category][option]\n        else:\n            value = self.pyload.config.get_plugin(category, option)\n        return value\n\n    @legacy(\"setConfigValue\")\n    @permission(Perms.SETTINGS)\n    def set_config_value(self, category, option, value, section=\"core\"):\n        \"\"\"\n        Set new config value.\n\n        :param category:\n        :param option:\n        :param value: new config value\n        :param section: 'plugin' or 'core\n        \"\"\"\n        self.pyload.addon_manager.dispatch_event(\n            \"config_changed\", category, option, value, section\n        )\n\n        if section == \"core\":\n            self.pyload.config[category][option] = value\n\n            if option in (\n                \"limit_speed\",\n                \"max_speed\",\n            ):  #: not so nice to update the limit\n                self.pyload.request_factory.update_bucket()\n\n        elif section == \"plugin\":\n            self.pyload.config.set_plugin(category, option, value)\n\n    @legacy(\"getConfig\")\n    @permission(Perms.SETTINGS)\n    def get_config(self):\n        \"\"\"\n        Retrieves complete config of core.\n\n        :return: list of `ConfigSection`\n        \"\"\"\n        return self._convert_config_format(self.pyload.config.config)\n\n    @legacy(\"getConfigDict\")\n    def get_config_dict(self):\n        \"\"\"\n        Retrieves complete config in dict format, not for RPC.\n\n        :return: dict\n        \"\"\"\n        return self.pyload.config.config\n\n    @legacy(\"getPluginConfig\")\n    @permission(Perms.SETTINGS)\n    def get_plugin_config(self):\n        \"\"\"\n        Retrieves complete config for all plugins.\n\n        :return: list of `ConfigSection`\n        \"\"\"\n        return self._convert_config_format(self.pyload.config.plugin)\n\n    @legacy(\"getPluginConfigDict\")\n    def get_plugin_config_dict(self):\n        \"\"\"\n        Plugin config as dict, not for RPC.\n\n        :return: dict\n        \"\"\"\n        return self.pyload.config.plugin\n\n    @legacy(\"pauseServer\")\n    @permission(Perms.STATUS)\n    def pause_server(self):\n        \"\"\"\n        Pause server: Tt wont start any new downloads, but nothing gets aborted.\n        \"\"\"\n        self.pyload.thread_manager.pause = True\n\n    @legacy(\"unpauseServer\")\n    @permission(Perms.STATUS)\n    def unpause_server(self):\n        \"\"\"\n        Unpause server: New Downloads will be started.\n        \"\"\"\n        self.pyload.thread_manager.pause = False\n\n    @legacy(\"togglePause\")\n    @permission(Perms.STATUS)\n    def toggle_pause(self):\n        \"\"\"\n        Toggle pause state.\n\n        :return: new pause state\n        \"\"\"\n        self.pyload.thread_manager.pause ^= True\n        return self.pyload.thread_manager.pause\n\n    @legacy(\"toggleReconnect\")\n    @permission(Perms.STATUS)\n    def toggle_reconnect(self):\n        \"\"\"\n        Toggle reconnect activation.\n\n        :return: new reconnect state\n        \"\"\"\n        self.pyload.config.toggle(\"reconnect\", \"enabled\")\n        return self.pyload.config.get(\"reconnect\", \"enabled\")\n\n    @legacy(\"statusServer\")\n    @permission(Perms.LIST)\n    def status_server(self):\n        \"\"\"\n        Some general information about the current status of pyLoad.\n\n        :return: `ServerStatus`\n        \"\"\"\n        server_status = ServerStatus(\n            self.pyload.thread_manager.pause,\n            len(self.pyload.thread_manager.processing_ids()),\n            self.pyload.files.get_queue_count(),\n            self.pyload.files.get_file_count(),\n            0,\n            not self.pyload.thread_manager.pause and self.is_time_download(),\n            self.pyload.config.get(\"reconnect\", \"enabled\") and self.is_time_reconnect(),\n            self.is_captcha_waiting(),\n        )\n\n        for pyfile in [\n            x.active\n            for x in self.pyload.thread_manager.threads\n            if x.active and isinstance(x.active, PyFile)\n        ]:\n            server_status.speed += pyfile.get_speed()  #: bytes/s\n\n        return server_status\n\n    @legacy(\"freeSpace\")\n    @permission(Perms.STATUS)\n    def free_space(self):\n        \"\"\"\n        Available free space at download directory in bytes.\n        \"\"\"\n        return fs.free_space(self.pyload.config.get(\"general\", \"storage_folder\"))\n\n    @legacy(\"getServerVersion\")\n    @permission(Perms.ANY)\n    def get_server_version(self):\n        \"\"\"\n        pyLoad Core version.\n        \"\"\"\n        return self.pyload.version\n\n    def kill(self):\n        \"\"\"\n        Clean way to quit pyLoad.\n        \"\"\"\n        self.pyload._do_exit = True\n\n    def restart(self):\n        \"\"\"\n        Restart pyload core.\n        \"\"\"\n        self.pyload._do_restart = True\n\n    @legacy(\"getLog\")\n    @permission(Perms.LOGS)\n    def get_log(self, offset=0):\n        \"\"\"\n        Returns most recent log entries.\n\n        :param offset: line offset\n        :return: List of log entries\n        \"\"\"\n        filelog_folder = self.pyload.config.get(\"log\", \"filelog_folder\")\n        if not filelog_folder:\n            filelog_folder = os.path.join(self.pyload.userdir, \"logs\")\n\n        path = os.path.join(filelog_folder, \"pyload\" + LogFactory.FILE_EXTENSION)\n        try:\n            with open(path) as fh:\n                lines = fh.readlines()\n            if offset >= len(lines):\n                return []\n            return lines[offset:]\n        except Exception:\n            return [\"No log available\"]\n\n    @legacy(\"isTimeDownload\")\n    @permission(Perms.STATUS)\n    def is_time_download(self):\n        \"\"\"\n        Checks if pyload will start new downloads according to time in config.\n\n        :return: bool\n        \"\"\"\n        start = self.pyload.config.get(\"download\", \"start_time\").split(\":\")\n        end = self.pyload.config.get(\"download\", \"end_time\").split(\":\")\n        return seconds.compare(start, end)\n\n    @legacy(\"isTimeReconnect\")\n    @permission(Perms.STATUS)\n    def is_time_reconnect(self):\n        \"\"\"\n        Checks if pyload will try to make a reconnect.\n\n        :return: bool\n        \"\"\"\n        start = self.pyload.config.get(\"reconnect\", \"start_time\").split(\":\")\n        end = self.pyload.config.get(\"reconnect\", \"end_time\").split(\":\")\n        return seconds.compare(start, end) and self.pyload.config.get(\n            \"reconnect\", \"enabled\"\n        )\n\n    @legacy(\"statusDownloads\")\n    @permission(Perms.LIST)\n    def status_downloads(self):\n        \"\"\"\n        Status off all currently running downloads.\n\n        :return: list of `DownloadStatus`\n        \"\"\"\n        data = []\n        for pyfile in self.pyload.thread_manager.get_active_files():\n            if not isinstance(pyfile, PyFile):\n                continue\n\n            data.append(\n                DownloadInfo(\n                    pyfile.id,\n                    pyfile.name,\n                    pyfile.get_speed(),\n                    pyfile.get_eta(),\n                    pyfile.format_eta(),\n                    pyfile.get_bytes_left(),\n                    pyfile.get_size(),\n                    pyfile.format_size(),\n                    pyfile.get_percent(),\n                    pyfile.status,\n                    pyfile.get_status_name(),\n                    pyfile.format_wait(),\n                    pyfile.wait_until,\n                    pyfile.packageid,\n                    pyfile.package().name,\n                    pyfile.pluginname,\n                )\n            )\n\n        return data\n\n    @legacy(\"addPackage\")\n    @permission(Perms.ADD)\n    def add_package(self, name, links, dest=Destination.QUEUE):\n        \"\"\"\n        Adds a package, with links to desired destination.\n\n        :param name: name of the new package\n        :param links: list of urls\n        :param dest: `Destination`\n        :return: package id of the new package\n        \"\"\"\n        if self.pyload.config.get(\"general\", \"folder_per_package\"):\n            folder = name\n        else:\n            folder = \"\"\n\n        folder = (\n            folder.replace(\"http://\", \"\")\n            .replace(\"https://\", \"\")\n            .replace(\":\", \"\")\n            .replace(\"/\", \"_\")\n            .replace(\"\\\\\", \"_\")\n        )\n\n        package_id = self.pyload.files.add_package(name, folder, Destination(dest))\n\n        self.pyload.files.add_links(links, package_id)\n\n        self.pyload.log.info(\n            self._(\"Added package {name} containing {count:d} links\").format(\n                name=name, count=len(links)\n            )\n        )\n\n        self.pyload.files.save()\n\n        return package_id\n\n    @legacy(\"parseURLs\")\n    @permission(Perms.ADD)\n    def parse_urls(self, html=None, url=None):\n        \"\"\"\n        Parses html content or any arbitaty text for links and returns result of\n        `check_urls`\n\n        :param html: html source\n        :return:\n        \"\"\"\n        urls = []\n\n        if html:\n            urls += urlmatcher.findall(html)\n\n        if url:\n            page = get_url(url)\n            urls += urlmatcher.findall(page)\n\n        # remove duplicates\n        return self.check_urls(set(urls))\n\n    @legacy(\"checkURLs\")\n    @permission(Perms.ADD)\n    def check_urls(self, urls):\n        \"\"\"\n        Gets urls and returns pluginname mapped to list of matches urls.\n\n        :param urls:\n        :return: {plugin: urls}\n        \"\"\"\n        data = self.pyload.plugin_manager.parse_urls(urls)\n        plugins = {}\n\n        for url, plugin in data:\n            if plugin in plugins:\n                plugins[plugin].append(url)\n            else:\n                plugins[plugin] = [url]\n\n        return plugins\n\n    @legacy(\"checkOnlineStatus\")\n    @permission(Perms.ADD)\n    def check_online_status(self, urls):\n        \"\"\"\n        initiates online status check.\n\n        :param urls:\n        :return: initial set of data as `OnlineCheck` instance containing the result id\n        \"\"\"\n        data = self.pyload.plugin_manager.parse_urls(urls)\n\n        rid = self.pyload.thread_manager.create_result_thread(data, False)\n\n        tmp = [\n            (url, (url, OnlineStatus(url, pluginname, \"unknown\", 3, 0)))\n            for url, pluginname in data\n        ]\n        data = parse_names(tmp)\n        result = {}\n\n        for k, v in data.items():\n            for url, status in v:\n                status.packagename = k\n                result[url] = status\n\n        return OnlineCheck(rid, result)\n\n    @legacy(\"checkOnlineStatusContainer\")\n    @permission(Perms.ADD)\n    def check_online_status_container(self, urls, container, data):\n        \"\"\"\n        checks online status of urls and a submited container file.\n\n        :param urls: list of urls\n        :param container: container file name\n        :param data: file content\n        :return: online check\n        \"\"\"\n        with open(\n            os.path.join(\n                self.pyload.config.get(\"general\", \"storage_folder\"), \"tmp_\" + container\n            ),\n            \"wb\",\n        ) as th:\n            th.write(data)\n\n        return self.check_online_status(urls + [th.name])\n\n    @legacy(\"pollResults\")\n    @permission(Perms.ADD)\n    def poll_results(self, rid):\n        \"\"\"\n        Polls the result available for ResultID.\n\n        :param rid: `ResultID`\n        :return: `OnlineCheck`, if rid is -1 then no more data available\n        \"\"\"\n        result = self.pyload.thread_manager.get_info_result(rid)\n\n        if \"ALL_INFO_FETCHED\" in result:\n            del result[\"ALL_INFO_FETCHED\"]\n            return OnlineCheck(-1, result)\n        else:\n            return OnlineCheck(rid, result)\n\n    @legacy(\"generatePackages\")\n    @permission(Perms.ADD)\n    def generate_packages(self, links):\n        \"\"\"\n        Parses links, generates packages names from urls.\n\n        :param links: list of urls\n        :return: package names mapped to urls\n        \"\"\"\n        result = parse_names((x, x) for x in links)\n        return result\n\n    @legacy(\"generateAndAddPackages\")\n    @permission(Perms.ADD)\n    def generate_and_add_packages(self, links, dest=Destination.COLLECTOR):\n        \"\"\"\n        Generates and add packages.\n\n        :param links: list of urls\n        :param dest: `Destination`\n        :return: list of package ids\n        \"\"\"\n        return [\n            self.add_package(name, urls, dest)\n            for name, urls in self.generate_packages(links).items()\n        ]\n\n    @legacy(\"checkAndAddPackages\")\n    @permission(Perms.ADD)\n    def check_and_add_packages(self, links, dest=Destination.COLLECTOR):\n        \"\"\"\n        Checks online status, retrieves names, and will add packages.\n        Because of this packages are not added immediatly, only for internal use.\n\n        :param links: list of urls\n        :param dest: `Destination`\n        :return: None\n        \"\"\"\n        data = self.pyload.plugin_manager.parse_urls(links)\n        self.pyload.thread_manager.create_result_thread(data, True)\n\n    @legacy(\"getPackageData\")\n    @permission(Perms.LIST)\n    def get_package_data(self, package_id):\n        \"\"\"\n        Returns complete information about package, and included files.\n\n        :param package_id: package id\n        :return: `PackageData` with .links attribute\n        \"\"\"\n        data = self.pyload.files.get_package_data(int(package_id))\n\n        if not data:\n            raise PackageDoesNotExists(package_id)\n\n        pdata = PackageData(\n            data[\"id\"],\n            data[\"name\"],\n            data[\"folder\"],\n            data[\"site\"],\n            data[\"password\"],\n            data[\"queue\"],\n            data[\"order\"],\n            links=[self._convert_py_file(x) for x in data[\"links\"].values()],\n        )\n\n        return pdata\n\n    @legacy(\"getPackageInfo\")\n    @permission(Perms.LIST)\n    def get_package_info(self, package_id):\n        \"\"\"\n        Returns information about package, without detailed information about containing\n        files.\n\n        :param package_id: package id\n        :return: `PackageData` with .fid attribute\n        \"\"\"\n        data = self.pyload.files.get_package_data(int(package_id))\n\n        if not data:\n            raise PackageDoesNotExists(package_id)\n\n        pdata = PackageData(\n            data[\"id\"],\n            data[\"name\"],\n            data[\"folder\"],\n            data[\"site\"],\n            data[\"password\"],\n            data[\"queue\"],\n            data[\"order\"],\n            fids=[int(x) for x in data[\"links\"]],\n        )\n\n        return pdata\n\n    @legacy(\"getFileData\")\n    @permission(Perms.LIST)\n    def get_file_data(self, file_id):\n        \"\"\"\n        Get complete information about a specific file.\n\n        :param file_id: file id\n        :return: `FileData`\n        \"\"\"\n        info = self.pyload.files.get_file_data(int(file_id))\n        if not info:\n            raise FileDoesNotExists(file_id)\n\n        fileinfo = list(info.values())[0]\n        fdata = self._convert_py_file(fileinfo)\n        return fdata\n\n    @legacy(\"deleteFiles\")\n    @permission(Perms.DELETE)\n    def delete_files(self, file_ids):\n        \"\"\"\n        Deletes several file entries from pyload.\n\n        :param file_ids: list of file ids\n        \"\"\"\n        for id in file_ids:\n            self.pyload.files.delete_link(int(id))\n\n        self.pyload.files.save()\n\n    @legacy(\"deletePackages\")\n    @permission(Perms.DELETE)\n    def delete_packages(self, package_ids):\n        \"\"\"\n        Deletes packages and containing links.\n\n        :param package_ids: list of package ids\n        \"\"\"\n        for id in package_ids:\n            self.pyload.files.delete_package(int(id))\n\n        self.pyload.files.save()\n\n    @legacy(\"getQueue\")\n    @permission(Perms.LIST)\n    def get_queue(self):\n        \"\"\"\n        Returns info about queue and packages, **not** about files, see `get_queue_data` \\\n        or `get_package_data` instead.\n\n        :return: list of `PackageInfo`\n        \"\"\"\n        return [\n            PackageData(\n                pack[\"id\"],\n                pack[\"name\"],\n                pack[\"folder\"],\n                pack[\"site\"],\n                pack[\"password\"],\n                pack[\"queue\"],\n                pack[\"order\"],\n                pack[\"linksdone\"],\n                pack[\"sizedone\"],\n                pack[\"sizetotal\"],\n                pack[\"linkstotal\"],\n            )\n            for pack in self.pyload.files.get_info_data(Destination.QUEUE).values()\n        ]\n\n    @legacy(\"getQueueData\")\n    @permission(Perms.LIST)\n    def get_queue_data(self):\n        \"\"\"\n        Return complete data about everything in queue, this is very expensive use it\n        sparely.\n        See `get_queue` for alternative.\n\n        :return: list of `PackageData`\n        \"\"\"\n        return [\n            PackageData(\n                pack[\"id\"],\n                pack[\"name\"],\n                pack[\"folder\"],\n                pack[\"site\"],\n                pack[\"password\"],\n                pack[\"queue\"],\n                pack[\"order\"],\n                pack[\"linksdone\"],\n                pack[\"sizedone\"],\n                pack[\"sizetotal\"],\n                links=[self._convert_py_file(x) for x in pack[\"links\"].values()],\n            )\n            for pack in self.pyload.files.get_complete_data(Destination.QUEUE).values()\n        ]\n\n    @legacy(\"getCollector\")\n    @permission(Perms.LIST)\n    def get_collector(self):\n        \"\"\"\n        same as `get_queue` for collector.\n\n        :return: list of `PackageInfo`\n        \"\"\"\n        return [\n            PackageData(\n                pack[\"id\"],\n                pack[\"name\"],\n                pack[\"folder\"],\n                pack[\"site\"],\n                pack[\"password\"],\n                pack[\"queue\"],\n                pack[\"order\"],\n                pack[\"linksdone\"],\n                pack[\"sizedone\"],\n                pack[\"sizetotal\"],\n                pack[\"linkstotal\"],\n            )\n            for pack in self.pyload.files.get_info_data(Destination.COLLECTOR).values()\n        ]\n\n    @legacy(\"getCollectorData\")\n    @permission(Perms.LIST)\n    def get_collector_data(self):\n        \"\"\"\n        same as `get_queue_data` for collector.\n\n        :return: list of `PackageInfo`\n        \"\"\"\n        return [\n            PackageData(\n                pack[\"id\"],\n                pack[\"name\"],\n                pack[\"folder\"],\n                pack[\"site\"],\n                pack[\"password\"],\n                pack[\"queue\"],\n                pack[\"order\"],\n                pack[\"linksdone\"],\n                pack[\"sizedone\"],\n                pack[\"sizetotal\"],\n                links=[self._convert_py_file(x) for x in pack[\"links\"].values()],\n            )\n            for pack in self.pyload.files.get_complete_data(\n                Destination.COLLECTOR\n            ).values()\n        ]\n\n    @legacy(\"addFiles\")\n    @permission(Perms.ADD)\n    def add_files(self, package_id, links):\n        \"\"\"\n        Adds files to specific package.\n\n        :param package_id: package id\n        :param links: list of urls\n        \"\"\"\n        self.pyload.files.add_links(links, int(package_id))\n\n        self.pyload.log.info(\n            self._(\"Added {count:d} links to package #{package:d} \").format(\n                count=len(links), package=package_id\n            )\n        )\n        self.pyload.files.save()\n\n    @legacy(\"pushToQueue\")\n    @permission(Perms.MODIFY)\n    def push_to_queue(self, package_id):\n        \"\"\"\n        Moves package from Collector to Queue.\n\n        :param package_id: package id\n        \"\"\"\n        self.pyload.files.set_package_location(package_id, Destination.QUEUE)\n\n    @legacy(\"pullFromQueue\")\n    @permission(Perms.MODIFY)\n    def pull_from_queue(self, package_id):\n        \"\"\"\n        Moves package from Queue to Collector.\n\n        :param package_id: package id\n        \"\"\"\n        self.pyload.files.set_package_location(package_id, Destination.COLLECTOR)\n\n    @legacy(\"restartPackage\")\n    @permission(Perms.MODIFY)\n    def restart_package(self, package_id):\n        \"\"\"\n        Restarts a package, resets every containing files.\n\n        :param package_id: package id\n        \"\"\"\n        self.pyload.files.restart_package(int(package_id))\n\n    @legacy(\"restartFile\")\n    @permission(Perms.MODIFY)\n    def restart_file(self, file_id):\n        \"\"\"\n        Resets file status, so it will be downloaded again.\n\n        :param file_id:  file id\n        \"\"\"\n        self.pyload.files.restart_file(int(file_id))\n\n    @legacy(\"recheckPackage\")\n    @permission(Perms.MODIFY)\n    def recheck_package(self, package_id):\n        \"\"\"\n        Probes online status of all files in a package, also a default action when\n        package is added.\n\n        :param package_id:\n        :return:\n        \"\"\"\n        self.pyload.files.recheck_package(int(package_id))\n\n    @legacy(\"stopAllDownloads\")\n    @permission(Perms.MODIFY)\n    def stop_all_downloads(self):\n        \"\"\"\n        Aborts all running downloads.\n        \"\"\"\n        pyfiles = list(self.pyload.files.cache.values())\n        for pyfile in pyfiles:\n            pyfile.abort_download()\n\n    @legacy(\"stopDownloads\")\n    @permission(Perms.MODIFY)\n    def stop_downloads(self, file_ids):\n        \"\"\"\n        Aborts specific downloads.\n\n        :param file_ids: list of file ids\n        :return:\n        \"\"\"\n        pyfiles = list(self.pyload.files.cache.values())\n        for pyfile in pyfiles:\n            if pyfile.id in file_ids:\n                pyfile.abort_download()\n\n    @legacy(\"setPackageName\")\n    @permission(Perms.MODIFY)\n    def set_package_name(self, package_id, name):\n        \"\"\"\n        Renames a package.\n\n        :param package_id: package id\n        :param name: new package name\n        \"\"\"\n        pack = self.pyload.files.get_package(package_id)\n        pack.name = name\n        pack.sync()\n\n    @legacy(\"movePackage\")\n    @permission(Perms.MODIFY)\n    def move_package(self, destination, package_id):\n        \"\"\"\n        Set a new package location.\n\n        :param destination: `Destination`\n        :param package_id: package id\n        \"\"\"\n        try:\n            dest = Destination(destination)\n        except ValueError:\n            pass\n        else:\n            self.pyload.files.set_package_location(package_id, dest)\n\n    @legacy(\"moveFiles\")\n    @permission(Perms.MODIFY)\n    def move_files(self, file_ids, package_id):\n        \"\"\"\n        Move multiple files to another package.\n\n        :param file_ids: list of file ids\n        :param package_id: destination package\n        :return:\n        \"\"\"\n        # TODO: implement\n        pass\n\n    @legacy(\"uploadContainer\")\n    @permission(Perms.ADD)\n    def upload_container(self, filename, data):\n        \"\"\"\n        Uploads and adds a container file to pyLoad.\n\n        :param filename: filename, extension is important so it can correctly decrypted\n        :param data: file content\n        \"\"\"\n        with open(\n            os.path.join(\n                self.pyload.config.get(\"general\", \"storage_folder\"), \"tmp_\" + filename\n            ),\n            \"wb\",\n        ) as th:\n            th.write(data)\n\n        self.add_package(th.name, [th.name], Destination.COLLECTOR)\n\n    @legacy(\"orderPackage\")\n    @permission(Perms.MODIFY)\n    def order_package(self, package_id, position):\n        \"\"\"\n        Gives a package a new position.\n\n        :param package_id: package id\n        :param position:\n        \"\"\"\n        self.pyload.files.reorder_package(package_id, position)\n\n    @legacy(\"orderFile\")\n    @permission(Perms.MODIFY)\n    def order_file(self, file_id, position):\n        \"\"\"\n        Gives a new position to a file within its package.\n\n        :param file_id: file id\n        :param position:\n        \"\"\"\n        self.pyload.files.reorder_file(file_id, position)\n\n    @legacy(\"setPackageData\")\n    @permission(Perms.MODIFY)\n    def set_package_data(self, package_id, data):\n        \"\"\"\n        Allows to modify several package attributes.\n\n        :param package_id: package id\n        :param data: dict that maps attribute to desired value\n        \"\"\"\n        p = self.pyload.files.get_package(package_id)\n        if not p:\n            raise PackageDoesNotExists(package_id)\n\n        for key, value in data.items():\n            if key == \"id\":\n                continue\n            setattr(p, key, value)\n\n        p.sync()\n        self.pyload.files.save()\n\n    @legacy(\"deleteFinished\")\n    @permission(Perms.DELETE)\n    def delete_finished(self):\n        \"\"\"\n        Deletes all finished files and completely finished packages.\n\n        :return: list of deleted package ids\n        \"\"\"\n        return self.pyload.files.delete_finished_links()\n\n    @legacy(\"restartFailed\")\n    @permission(Perms.MODIFY)\n    def restart_failed(self):\n        \"\"\"\n        Restarts all failed failes.\n        \"\"\"\n        self.pyload.files.restart_failed()\n\n    @legacy(\"getPackageOrder\")\n    @permission(Perms.LIST)\n    def get_package_order(self, destination):\n        \"\"\"\n        Returns information about package order.\n\n        :param destination: `Destination`\n        :return: dict mapping order to package id\n        \"\"\"\n        packages = self.pyload.files.get_info_data(Destination(destination))\n        order = {}\n\n        for package_id in packages:\n            pack = self.pyload.files.get_package_data(int(package_id))\n            while pack[\"order\"] in order.keys():  #: just in case\n                pack[\"order\"] += 1\n            order[pack[\"order\"]] = pack[\"id\"]\n        return order\n\n    @legacy(\"getFileOrder\")\n    @permission(Perms.LIST)\n    def get_file_order(self, package_id):\n        \"\"\"\n        Information about file order within package.\n\n        :param package_id:\n        :return: dict mapping order to file id\n        \"\"\"\n        raw_data = self.pyload.files.get_package_data(int(package_id))\n        order = {}\n        for id, pyfile in raw_data[\"links\"].items():\n            while pyfile[\"order\"] in order.keys():  #: just in case\n                pyfile[\"order\"] += 1\n            order[pyfile[\"order\"]] = pyfile[\"id\"]\n        return order\n\n    @legacy(\"isCaptchaWaiting\")\n    @permission(Perms.STATUS)\n    def is_captcha_waiting(self):\n        \"\"\"\n        Indicates wether a captcha task is available.\n\n        :return: bool\n        \"\"\"\n        self.pyload.last_client_connected = time.time()\n        task = self.pyload.captcha_manager.get_task()\n        return task is not None\n\n    @legacy(\"getCaptchaTask\")\n    @permission(Perms.STATUS)\n    def get_captcha_task(self, exclusive=False):\n        \"\"\"\n        Returns a captcha task.\n\n        :param exclusive: unused\n        :return: `CaptchaTask`\n        \"\"\"\n        self.pyload.last_client_connected = time.time()\n        task = self.pyload.captcha_manager.get_task()\n        if task:\n            task.set_waiting_for_user(exclusive=exclusive)\n            data, type, result = task.get_captcha()\n            t = CaptchaTask(int(task.id), json.dumps(data), type, result)\n            return t\n        else:\n            return CaptchaTask(-1)\n\n    @legacy(\"getCaptchaTaskStatus\")\n    @permission(Perms.STATUS)\n    def get_captcha_task_status(self, tid):\n        \"\"\"\n        Get information about captcha task.\n\n        :param tid: task id\n        :return: string\n        \"\"\"\n        self.pyload.last_client_connected = time.time()\n        t = self.pyload.captcha_manager.get_task_by_id(tid)\n        return t.get_status() if t else \"\"\n\n    @legacy(\"setCaptchaResult\")\n    @permission(Perms.STATUS)\n    def set_captcha_result(self, tid, result):\n        \"\"\"\n        Set result for a captcha task.\n\n        :param tid: task id\n        :param result: captcha result\n        \"\"\"\n        self.pyload.last_client_connected = time.time()\n        task = self.pyload.captcha_manager.get_task_by_id(tid)\n        if task:\n            task.set_result(result)\n            self.pyload.captcha_manager.remove_task(task)\n\n    @legacy(\"getEvents\")\n    @permission(Perms.STATUS)\n    def get_events(self, uuid):\n        \"\"\"\n        Lists occured events, may be affected to changes in future.\n\n        :param uuid:\n        :return: list of `Events`\n        \"\"\"\n        events = self.pyload.event_manager.get_events(uuid)\n        new_events = []\n\n        def conv_dest(d):\n            return (Destination.QUEUE if d == \"queue\" else Destination.COLLECTOR).value\n\n        for e in events:\n            event = EventInfo()\n            event.eventname = e[0]\n            if e[0] in (\"update\", \"remove\", \"insert\"):\n                event.id = e[3]\n                event.type = (\n                    ElementType.PACKAGE if e[2] == \"pack\" else ElementType.FILE\n                ).value\n                event.destination = conv_dest(e[1])\n            elif e[0] == \"order\":\n                if e[1]:\n                    event.id = e[1]\n                    event.type = (\n                        ElementType.PACKAGE if e[2] == \"pack\" else ElementType.FILE\n                    )\n                    event.destination = conv_dest(e[3])\n            elif e[0] == \"reload\":\n                event.destination = conv_dest(e[1])\n            new_events.append(event)\n        return new_events\n\n    @legacy(\"getAccounts\")\n    @permission(Perms.ACCOUNTS)\n    def get_accounts(self, refresh):\n        \"\"\"\n        Get information about all entered accounts.\n\n        :param refresh: reload account info\n        :return: list of `AccountInfo`\n        \"\"\"\n        accs = self.pyload.account_manager.get_account_infos(False, refresh)\n        accounts = []\n        for group in accs.values():\n            accounts.extend(\n                [\n                    AccountInfo(\n                        acc[\"validuntil\"],\n                        acc[\"login\"],\n                        acc[\"options\"],\n                        acc[\"valid\"],\n                        acc[\"trafficleft\"],\n                        acc[\"maxtraffic\"],\n                        acc[\"premium\"],\n                        acc[\"type\"],\n                    )\n                    for acc in group\n                ]\n            )\n        return accounts\n\n    @legacy(\"getAccountTypes\")\n    @permission(Perms.ANY)\n    def get_account_types(self):\n        \"\"\"\n        All available account types.\n\n        :return: list\n        \"\"\"\n        return list(self.pyload.account_manager.accounts.keys())\n\n    @legacy(\"updateAccount\")\n    @permission(Perms.ACCOUNTS)\n    def update_account(self, plugin, account, password=None, options={}):\n        \"\"\"\n        Changes pw/options for specific account.\n        \"\"\"\n        self.pyload.account_manager.update_account(plugin, account, password, options)\n\n    @legacy(\"removeAccount\")\n    @permission(Perms.ACCOUNTS)\n    def remove_account(self, plugin, account):\n        \"\"\"\n        Remove account from pyload.\n\n        :param plugin: pluginname\n        :param account: accountname\n        \"\"\"\n        self.pyload.account_manager.remove_account(plugin, account)\n\n    @permission(Perms.ANY)\n    def login(self, username, password):\n        \"\"\"\n        Login into pyLoad, this **must** be called when using rpc before any methods can\n        be used.\n\n        :param username:\n        :param password:\n        :return: bool indicating login was successful\n        \"\"\"\n        return True if self.check_auth(username, password) else False\n\n    @legacy(\"checkAuth\")\n    def check_auth(self, username, password):\n        \"\"\"\n        Check authentication and returns details.\n\n        :param username:\n        :param password:\n        :return: dict with info, empty when login is incorrect\n        \"\"\"\n        return self.pyload.db.check_auth(username, password)\n\n    @legacy(\"isAuthorized\")\n    def is_authorized(self, func, userdata):\n        \"\"\"\n        checks if the user is authorized for specific method.\n\n        :param func: function name\n        :param userdata: dictionary of user data\n        :return: boolean\n        \"\"\"\n        if userdata[\"role\"] == Role.ADMIN:\n            return True\n        elif func in perm_map and has_permission(\n            userdata[\"permission\"], perm_map[func]\n        ):\n            return True\n        else:\n            return False\n\n    @permission(Perms.SETTINGS)\n    def get_userdir(self):\n        return os.path.realpath(self.pyload.userdir)\n\n    @permission(Perms.SETTINGS)\n    def get_cachedir(self):\n        return os.path.realpath(self.pyload.tempdir)\n\n    #: Old API\n    @permission(Perms.ANY)\n    def getUserData(self, username, password):\n        \"\"\"\n        similar to `check_auth` but returns UserData thrift type.\n        \"\"\"\n        user = self.check_auth(username, password)\n        if user:\n            return OldUserData(\n                user[\"name\"],\n                user[\"email\"],\n                user[\"role\"],\n                user[\"permission\"],\n                user[\"template\"],\n            )\n        else:\n            return OldUserData()\n\n    @permission(Perms.ANY)\n    def get_userdata(self, username, password):\n        \"\"\"\n        similar to `check_auth` but returns UserData thrift type.\n        \"\"\"\n        user = self.check_auth(username, password)\n        if user:\n            return UserData(\n                user[\"id\"],\n                user[\"name\"],\n                user[\"email\"],\n                user[\"role\"],\n                user[\"permission\"],\n                user[\"template\"],\n            )\n        else:\n            return UserData()\n\n    #: Old API\n    def getAllUserData(self):\n        \"\"\"\n        returns all known user and info.\n        \"\"\"\n        res = {}\n        for id, data in self.pyload.db.get_all_user_data().items():\n            res[data[\"name\"]] = OldUserData(\n                data[\"name\"],\n                data[\"email\"],\n                data[\"role\"],\n                data[\"permission\"],\n                data[\"template\"],\n            )\n\n        return res\n\n    def get_all_userdata(self):\n        \"\"\"\n        returns all known user and info.\n        \"\"\"\n        res = {}\n        for id, data in self.pyload.db.get_all_user_data().items():\n            res[id] = UserData(\n                id,\n                data[\"name\"],\n                data[\"email\"],\n                data[\"role\"],\n                data[\"permission\"],\n                data[\"template\"],\n            )\n        return res\n\n    @legacy(\"getServices\")\n    @permission(Perms.STATUS)\n    def get_services(self):\n        \"\"\"\n        A dict of available services, these can be defined by addon plugins.\n\n        :return: dict with this style: {\"plugin\": {\"method\": \"description\"}}\n        \"\"\"\n        data = {}\n        for plugin, funcs in self.pyload.addon_manager.methods.items():\n            data[plugin] = funcs\n\n        return data\n\n    @legacy(\"hasService\")\n    @permission(Perms.STATUS)\n    def has_service(self, plugin, func):\n        \"\"\"\n        Checks whether a service is available.\n\n        :param plugin:\n        :param func:\n        :return: bool\n        \"\"\"\n        cont = self.pyload.addon_manager.methods\n        return plugin in cont and func in cont[plugin]\n\n    @permission(Perms.STATUS)\n    def call(self, info):\n        \"\"\"\n        Calls a service (a method in addon plugin).\n\n        :param info: `ServiceCall`\n        :return: result\n        :raises: ServiceDoesNotExists, when its not available\n        :raises: ServiceException, when a exception was raised\n        \"\"\"\n        plugin = info.plugin\n        func = info.func\n        args = info.arguments\n        parse = info.parse_arguments\n\n        if not self.has_service(plugin, func):\n            raise ServiceDoesNotExists(plugin, func)\n\n        try:\n            ret = self.pyload.addon_manager.call_rpc(plugin, func, args, parse)\n            return str(ret)\n        except Exception as exc:\n            raise ServiceException(exc)\n\n    @legacy(\"getAllInfo\")\n    @permission(Perms.STATUS)\n    def get_all_info(self):\n        \"\"\"\n        Returns all information stored by addon plugins. Values are always strings.\n\n        :return: {\"plugin\": {\"name\": value } }\n        \"\"\"\n        return self.pyload.addon_manager.get_all_info()\n\n    @legacy(\"getInfoByPlugin\")\n    @permission(Perms.STATUS)\n    def get_info_by_plugin(self, plugin):\n        \"\"\"\n        Returns information stored by a specific plugin.\n\n        :param plugin: pluginname\n        :return: dict of attr names mapped to value {\"name\": value}\n        \"\"\"\n        return self.pyload.addon_manager.get_info(plugin)\n\n    def add_user(self, user, newpw, role=0, perms=0):\n        \"\"\"\n        creates new user login.\n        \"\"\"\n        return self.pyload.db.add_user(user, newpw, role, perms)\n\n    def remove_user(self, user):\n        \"\"\"\n        deletes a user login.\n        \"\"\"\n        return self.pyload.db.remove_user(user)\n\n    @legacy(\"changePassword\")\n    def change_password(self, user, oldpw, newpw):\n        \"\"\"\n        changes password for specific user.\n        \"\"\"\n        return self.pyload.db.change_password(user, oldpw, newpw)\n\n    @legacy(\"setUserPermission\")\n    def set_user_permission(self, user, permission, role):\n        self.pyload.db.set_permission(user, permission)\n        self.pyload.db.set_role(user, role)\n", "# -*- coding: utf-8 -*-\n\nimport hashlib\nimport os\n\nfrom ..utils.struct.style import style\n\n\n# TODO: rewrite using scrypt or argon2_cffi\ndef _salted_password(password, salt):\n    dk = hashlib.pbkdf2_hmac(\"sha256\", password.encode(), bytes.fromhex(salt), 100000)\n    return salt + dk.hex()\n\n\ndef _gensalt():\n    return os.urandom(16).hex()\n\n\ndef _check_password(hashed, clear):\n    salt = hashed[:32]\n    to_compare = _salted_password(clear, salt)\n\n    return hashed == to_compare\n\n\nclass UserDatabaseMethods:\n    @style.queue\n    def check_auth(self, user, password):\n        self.c.execute(\n            \"SELECT id, name, password, role, permission, template, email FROM users WHERE name=?\",\n            (user,),\n        )\n        r = self.c.fetchone()\n        if not r:\n            return {}\n\n        stored_password = r[2]\n        if not _check_password(stored_password, password):\n            return {}\n\n        return {\n            \"id\": r[0],\n            \"name\": r[1],\n            \"role\": r[3],\n            \"permission\": r[4],\n            \"template\": r[5],\n            \"email\": r[6],\n        }\n\n    @style.queue\n    def add_user(self, user, password, role=0, perms=0, reset=False):\n        salt_pw = _salted_password(password, _gensalt())\n\n        self.c.execute(\"SELECT name FROM users WHERE name=?\", (user,))\n        if self.c.fetchone() is not None:\n            if reset:\n                self.c.execute(\n                    \"UPDATE users SET password=?, role=?, permission=? WHERE name=?\",\n                    (salt_pw, role, perms, user),\n                )\n                return True\n            else:\n                return False\n        else:\n            self.c.execute(\n                \"INSERT INTO users (name, password, role, permission) VALUES (?, ?, ?, ?)\",\n                (user, salt_pw, role, perms),\n            )\n            return True\n\n    @style.queue\n    def change_password(self, user, old_password, new_password):\n        self.c.execute(\"SELECT id, name, password FROM users WHERE name=?\", (user,))\n        r = self.c.fetchone()\n        if not r:\n            return False\n\n        stored_password = r[2]\n        if not _check_password(stored_password, old_password):\n            return False\n\n        newpw = _salted_password(new_password, _gensalt())\n\n        self.c.execute(\"UPDATE users SET password=? WHERE name=?\", (newpw, user))\n        return True\n\n    @style.async_\n    def set_permission(self, user, perms):\n        self.c.execute(\"UPDATE users SET permission=? WHERE name=?\", (perms, user))\n\n    @style.async_\n    def set_role(self, user, role):\n        self.c.execute(\"UPDATE users SET role=? WHERE name=?\", (role, user))\n\n    @style.queue\n    def list_users(self):\n        self.c.execute(\"SELECT name FROM users\")\n        users = []\n        for row in self.c:\n            users.append(row[0])\n        return users\n\n    @style.queue\n    def get_all_user_data(self):\n        self.c.execute(\"SELECT id, name, permission, role, template, email FROM users\")\n        user = {}\n        for r in self.c:\n            user[r[0]] = {\n                \"name\": r[1],\n                \"permission\": r[2],\n                \"role\": r[3],\n                \"template\": r[4],\n                \"email\": r[5],\n            }\n\n        return user\n\n    @style.queue\n    def remove_user(self, user):\n        self.c.execute(\"DELETE FROM users WHERE name=?\", (user,))\n", "# -*- coding: utf-8 -*-\n\nfrom functools import wraps\nfrom urllib.parse import urljoin, urlparse\n\nimport flask\nimport flask_themes2\n\nfrom pyload.core.api import Perms, Role, has_permission\n\n\nclass JSONEncoder(flask.json.JSONEncoder):\n    def default(self, obj):\n        try:\n            return dict(obj)\n        except TypeError:\n            pass\n        return super().default(obj)\n\n\n#: Checks if location belongs to same host address\ndef is_safe_url(location):\n    ref_url = urlparse(flask.request.host_url)\n    test_url = urlparse(urljoin(flask.request.host_url, location))\n    return ref_url.netloc == test_url.netloc\n\n\ndef get_redirect_url(fallback=None):\n    login_url = urljoin(flask.request.url_root, flask.url_for('app.login'))\n    for location in flask.request.values.get(\"next\"), flask.request.referrer:\n        if not location:\n            continue\n        if location in (flask.request.url, login_url):  # don't redirect to same location\n            continue\n        if is_safe_url(location):\n            return location\n    return fallback\n\n\ndef render_base(messages):\n    return render_template(\"base.html\", messages=messages)\n\n\ndef clear_session(session=flask.session, permanent=True):\n    session.permanent = bool(permanent)\n    session.clear()\n    # session.modified = True\n\n\ndef current_theme_id():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    return api.get_config_value(\"webui\", \"theme\").lower()\n\n\n#: tries to serve the file from the static directory of the current theme otherwise fallback to builtin one\ndef static_file_url(filename):\n    themeid = current_theme_id()\n    try:\n        url = flask_themes2.static_file_url(themeid, filename)\n    except KeyError:\n        url = flask.url_for(\"static\", filename=filename)\n    return url\n\n\ndef theme_template(filename):\n    return flask.url_for(\"app.render\", filename=filename)\n\n\n#: tries to render the template of the current theme otherwise fallback to builtin template\ndef render_template(template, **context):\n    themeid = current_theme_id()\n    return flask_themes2.render_theme_template(themeid, template, **context)\n\n\ndef parse_permissions(session=flask.session):\n    perms = {x.name: False for x in Perms}\n    perms[\"ADMIN\"] = False\n    perms[\"is_admin\"] = False\n\n    if not session.get(\"authenticated\", False):\n        return perms\n\n    perms[\"ANY\"] = True\n    if session.get(\"role\") == Role.ADMIN:\n        for key in perms.keys():\n            perms[key] = True\n\n    elif session.get(\"perms\"):\n        p = session.get(\"perms\")\n        perms.update(get_permission(p))\n\n    return perms\n\n\ndef permlist():\n    return [x.name for x in Perms if x.name != \"ANY\"]\n\n\ndef get_permission(userperms):\n    \"\"\"\n    Returns a dict with permission key.\n\n    :param userperms: permission bits\n    \"\"\"\n    return {\n        name: has_permission(userperms, getattr(Perms, name).value)\n        for name in permlist()\n    }\n\n\ndef set_permission(perms):\n    \"\"\"\n    generates permission bits from dictionary.\n\n    :param perms: dict\n    \"\"\"\n    permission = 0\n    for name in permlist():\n        if name.startswith(\"_\"):\n            continue\n\n        if name in perms and perms[name]:\n            permission |= getattr(Perms, name)\n\n    return permission\n\n\ndef set_session(user_info, session=flask.session, permanent=True):\n    session.permanent = bool(permanent)\n    session.update(\n        {\n            \"authenticated\": True,\n            \"id\": user_info[\"id\"],\n            \"name\": user_info[\"name\"],\n            \"role\": user_info[\"role\"],\n            \"perms\": user_info[\"permission\"],\n            \"template\": user_info[\"template\"],\n        }\n    )\n    # session.modified = True\n    return session\n\n\n# TODO: Recheck...\ndef parse_userdata(session=flask.session):\n    return {\n        \"name\": session.get(\"name\", \"Anonymous\"),\n        \"is_admin\": session.get(\"role\", 1) == 0,\n        \"is_authenticated\": session.get(\"authenticated\", False),\n    }\n\n\ndef apiver_check(func):\n    # if no apiver is provided assumes latest\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        api = flask.current_app.config[\"PYLOAD_API\"]\n        core_apiver = api.__version__\n        if int(kwargs.get(\"apiver\", core_apiver).strip(\"v\")) < core_apiver:\n            return \"Obsolete API\", 404\n        return func(*args, **kwargs)\n\n    return wrapper\n\n\ndef is_authenticated(session=flask.session):\n    return session.get(\"name\") and session.get(\n        \"authenticated\"\n    )  # NOTE: why checks name?\n\n\ndef login_required(perm):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            s = flask.session\n            #: already authenticated?\n            if is_authenticated(s):\n                perms = parse_permissions(s)\n                if perm not in perms or not perms[perm]:\n                    response = \"Forbidden\", 403\n                else:\n                    response = func(*args, **kwargs)\n\n            elif flask.request.headers.get(\"X-Requested-With\") == \"XMLHttpRequest\":\n                response = \"Forbidden\", 403\n\n            else:\n                location = flask.url_for(\n                    \"app.login\",\n                    next=flask.request.url\n                )\n                response = flask.redirect(location)\n\n            return response\n\n        return wrapper\n\n    return decorator\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n#       ____________\n#   ___/       |    \\_____________ _                 _ ___\n#  /        ___/    |    _ __ _  _| |   ___  __ _ __| |   \\\n# /    \\___/  ______/   | '_ \\ || | |__/ _ \\/ _` / _` |    \\\n# \\            \u25ef |      | .__/\\_, |____\\___/\\__,_\\__,_|    /\n#  \\_______\\    /_______|_|   |__/________________________/\n#           \\  /\n#            \\/\n\nimport json\nimport os\nimport re\nimport time\nfrom enum import IntFlag\n\nfrom ..datatypes.data import *\nfrom ..datatypes.enums import *\nfrom ..datatypes.exceptions import *\nfrom ..datatypes.pyfile import PyFile\nfrom ..log_factory import LogFactory\nfrom ..network.request_factory import get_url\nfrom ..utils import fs, seconds\nfrom ..utils.old.packagetools import parse_names\n\n# contains function names mapped to their permissions\n# unlisted functions are for admins only\nperm_map = {}\n\n# contains function names mapped to their legacy name\nlegacy_map = {}\n\n\n# decorator only called on init, never initialized, so has no effect on runtime\ndef permission(bits):\n    class Wrapper:\n        def __new__(cls, func, *args, **kwargs):\n            perm_map[func.__name__] = bits\n            return func\n\n    return Wrapper\n\n\ndef legacy(legacy_name):\n    class Wrapper:\n        def __new__(cls, func, *args, **kwargs):\n            legacy_map[func.__name__] = legacy_name\n            return func\n\n    return Wrapper\n\n\nurlmatcher = re.compile(\n    r\"(?:https?|ftps?|xdcc|sftp):(?://|\\\\\\\\)+[\\w\\-._~:/?#\\[\\]@!$&'()*+,;=]*|magnet:\\?.+\",\n    re.IGNORECASE,\n)\n\n\nclass Perms(IntFlag):\n    ANY = 0  #: requires no permission, but login\n    ADD = 1  #: can add packages\n    DELETE = 2  #: can delete packages\n    STATUS = 4  #: see and change server status\n    LIST = 16  #: see queue and collector\n    MODIFY = 32  #: modify some attribute of downloads\n    DOWNLOAD = 64  #: can download from webinterface\n    SETTINGS = 128  #: can access settings\n    ACCOUNTS = 256  #: can access accounts\n    LOGS = 512  #: can see server logs\n\n\nclass Role(IntFlag):\n    ADMIN = 0  #: admin has all permissions implicit\n    USER = 1\n\n\ndef has_permission(userperms, perms):\n    # bitwise or perms before if needed\n    return perms == (userperms & perms)\n\n\n# API VERSION\n__version__ = 1\n\n\nclass Api:\n    \"\"\"\n    **pyLoads API**\n\n    This is accessible either internal via core.api or via thrift backend.\n\n    see Thrift specification file remote/thriftbackend/pyload.thrift\\\n    for information about data structures and what methods are usable with rpc.\n\n    Most methods requires specific permissions, please look at the source code if you need to know.\\\n    These can be configured via webinterface.\n    Admin user have all permissions, and are the only ones who can access the methods with no specific permission.\n    \"\"\"\n\n    def __new__(cls, core):\n        obj = super(Api, cls).__new__(cls)\n\n        # add methods specified by the @legacy decorator\n        # also set legacy method permissions according to the @permissions decorator\n        for func_name, legacy_name in legacy_map.items():\n            func = getattr(obj, func_name)\n            setattr(obj, legacy_name, func)\n\n            permissions = perm_map.get(func_name)\n            if permissions is not None:\n                perm_map[legacy_name] = permissions\n\n        return obj\n\n    def __init__(self, core):\n        self.pyload = core\n        self._ = core._\n\n    def _convert_py_file(self, p):\n        f = FileData(\n            p[\"id\"],\n            p[\"url\"],\n            p[\"name\"],\n            p[\"plugin\"],\n            p[\"size\"],\n            p[\"format_size\"],\n            p[\"status\"],\n            p[\"statusmsg\"],\n            p[\"package\"],\n            p[\"error\"],\n            p[\"order\"],\n        )\n        return f\n\n    def _convert_config_format(self, c):\n        sections = {}\n        for section_name, sub in c.items():\n            section = ConfigSection(section_name, sub[\"desc\"])\n            items = []\n            for key, data in sub.items():\n                if key in (\"desc\", \"outline\"):\n                    continue\n                item = ConfigItem()\n                item.name = key\n                item.description = data[\"desc\"]\n                item.value = str(data[\"value\"])\n                item.type = data[\"type\"]\n                items.append(item)\n            section.items = items\n            sections[section_name] = section\n            if \"outline\" in sub:\n                section.outline = sub[\"outline\"]\n        return sections\n\n    @legacy(\"getConfigValue\")\n    @permission(Perms.SETTINGS)\n    def get_config_value(self, category, option, section=\"core\"):\n        \"\"\"\n        Retrieve config value.\n\n        :param category: name of category, or plugin\n        :param option: config option\n        :param section: 'plugin' or 'core'\n        :return: config value\n        \"\"\"\n        if section == \"core\":\n            value = self.pyload.config[category][option]\n        else:\n            value = self.pyload.config.get_plugin(category, option)\n        return value\n\n    @legacy(\"setConfigValue\")\n    @permission(Perms.SETTINGS)\n    def set_config_value(self, category, option, value, section=\"core\"):\n        \"\"\"\n        Set new config value.\n\n        :param category:\n        :param option:\n        :param value: new config value\n        :param section: 'plugin' or 'core\n        \"\"\"\n        self.pyload.addon_manager.dispatch_event(\n            \"config_changed\", category, option, value, section\n        )\n\n        if section == \"core\":\n            self.pyload.config[category][option] = value\n\n            if option in (\n                \"limit_speed\",\n                \"max_speed\",\n            ):  #: not so nice to update the limit\n                self.pyload.request_factory.update_bucket()\n\n        elif section == \"plugin\":\n            self.pyload.config.set_plugin(category, option, value)\n\n    @legacy(\"getConfig\")\n    @permission(Perms.SETTINGS)\n    def get_config(self):\n        \"\"\"\n        Retrieves complete config of core.\n\n        :return: list of `ConfigSection`\n        \"\"\"\n        return self._convert_config_format(self.pyload.config.config)\n\n    @legacy(\"getConfigDict\")\n    def get_config_dict(self):\n        \"\"\"\n        Retrieves complete config in dict format, not for RPC.\n\n        :return: dict\n        \"\"\"\n        return self.pyload.config.config\n\n    @legacy(\"getPluginConfig\")\n    @permission(Perms.SETTINGS)\n    def get_plugin_config(self):\n        \"\"\"\n        Retrieves complete config for all plugins.\n\n        :return: list of `ConfigSection`\n        \"\"\"\n        return self._convert_config_format(self.pyload.config.plugin)\n\n    @legacy(\"getPluginConfigDict\")\n    def get_plugin_config_dict(self):\n        \"\"\"\n        Plugin config as dict, not for RPC.\n\n        :return: dict\n        \"\"\"\n        return self.pyload.config.plugin\n\n    @legacy(\"pauseServer\")\n    @permission(Perms.STATUS)\n    def pause_server(self):\n        \"\"\"\n        Pause server: Tt wont start any new downloads, but nothing gets aborted.\n        \"\"\"\n        self.pyload.thread_manager.pause = True\n\n    @legacy(\"unpauseServer\")\n    @permission(Perms.STATUS)\n    def unpause_server(self):\n        \"\"\"\n        Unpause server: New Downloads will be started.\n        \"\"\"\n        self.pyload.thread_manager.pause = False\n\n    @legacy(\"togglePause\")\n    @permission(Perms.STATUS)\n    def toggle_pause(self):\n        \"\"\"\n        Toggle pause state.\n\n        :return: new pause state\n        \"\"\"\n        self.pyload.thread_manager.pause ^= True\n        return self.pyload.thread_manager.pause\n\n    @legacy(\"toggleReconnect\")\n    @permission(Perms.STATUS)\n    def toggle_reconnect(self):\n        \"\"\"\n        Toggle reconnect activation.\n\n        :return: new reconnect state\n        \"\"\"\n        self.pyload.config.toggle(\"reconnect\", \"enabled\")\n        return self.pyload.config.get(\"reconnect\", \"enabled\")\n\n    @legacy(\"statusServer\")\n    @permission(Perms.LIST)\n    def status_server(self):\n        \"\"\"\n        Some general information about the current status of pyLoad.\n\n        :return: `ServerStatus`\n        \"\"\"\n        server_status = ServerStatus(\n            self.pyload.thread_manager.pause,\n            len(self.pyload.thread_manager.processing_ids()),\n            self.pyload.files.get_queue_count(),\n            self.pyload.files.get_file_count(),\n            0,\n            not self.pyload.thread_manager.pause and self.is_time_download(),\n            self.pyload.config.get(\"reconnect\", \"enabled\") and self.is_time_reconnect(),\n            self.is_captcha_waiting(),\n        )\n\n        for pyfile in [\n            x.active\n            for x in self.pyload.thread_manager.threads\n            if x.active and isinstance(x.active, PyFile)\n        ]:\n            server_status.speed += pyfile.get_speed()  #: bytes/s\n\n        return server_status\n\n    @legacy(\"freeSpace\")\n    @permission(Perms.STATUS)\n    def free_space(self):\n        \"\"\"\n        Available free space at download directory in bytes.\n        \"\"\"\n        return fs.free_space(self.pyload.config.get(\"general\", \"storage_folder\"))\n\n    @legacy(\"getServerVersion\")\n    @permission(Perms.ANY)\n    def get_server_version(self):\n        \"\"\"\n        pyLoad Core version.\n        \"\"\"\n        return self.pyload.version\n\n    def kill(self):\n        \"\"\"\n        Clean way to quit pyLoad.\n        \"\"\"\n        self.pyload._do_exit = True\n\n    def restart(self):\n        \"\"\"\n        Restart pyload core.\n        \"\"\"\n        self.pyload._do_restart = True\n\n    @legacy(\"getLog\")\n    @permission(Perms.LOGS)\n    def get_log(self, offset=0):\n        \"\"\"\n        Returns most recent log entries.\n\n        :param offset: line offset\n        :return: List of log entries\n        \"\"\"\n        filelog_folder = self.pyload.config.get(\"log\", \"filelog_folder\")\n        if not filelog_folder:\n            filelog_folder = os.path.join(self.pyload.userdir, \"logs\")\n\n        path = os.path.join(filelog_folder, \"pyload\" + LogFactory.FILE_EXTENSION)\n        try:\n            with open(path) as fh:\n                lines = fh.readlines()\n            if offset >= len(lines):\n                return []\n            return lines[offset:]\n        except Exception:\n            return [\"No log available\"]\n\n    @legacy(\"isTimeDownload\")\n    @permission(Perms.STATUS)\n    def is_time_download(self):\n        \"\"\"\n        Checks if pyload will start new downloads according to time in config.\n\n        :return: bool\n        \"\"\"\n        start = self.pyload.config.get(\"download\", \"start_time\").split(\":\")\n        end = self.pyload.config.get(\"download\", \"end_time\").split(\":\")\n        return seconds.compare(start, end)\n\n    @legacy(\"isTimeReconnect\")\n    @permission(Perms.STATUS)\n    def is_time_reconnect(self):\n        \"\"\"\n        Checks if pyload will try to make a reconnect.\n\n        :return: bool\n        \"\"\"\n        start = self.pyload.config.get(\"reconnect\", \"start_time\").split(\":\")\n        end = self.pyload.config.get(\"reconnect\", \"end_time\").split(\":\")\n        return seconds.compare(start, end) and self.pyload.config.get(\n            \"reconnect\", \"enabled\"\n        )\n\n    @legacy(\"statusDownloads\")\n    @permission(Perms.LIST)\n    def status_downloads(self):\n        \"\"\"\n        Status off all currently running downloads.\n\n        :return: list of `DownloadStatus`\n        \"\"\"\n        data = []\n        for pyfile in self.pyload.thread_manager.get_active_files():\n            if not isinstance(pyfile, PyFile):\n                continue\n\n            data.append(\n                DownloadInfo(\n                    pyfile.id,\n                    pyfile.name,\n                    pyfile.get_speed(),\n                    pyfile.get_eta(),\n                    pyfile.format_eta(),\n                    pyfile.get_bytes_left(),\n                    pyfile.get_size(),\n                    pyfile.format_size(),\n                    pyfile.get_percent(),\n                    pyfile.status,\n                    pyfile.get_status_name(),\n                    pyfile.format_wait(),\n                    pyfile.wait_until,\n                    pyfile.packageid,\n                    pyfile.package().name,\n                    pyfile.pluginname,\n                )\n            )\n\n        return data\n\n    @legacy(\"addPackage\")\n    @permission(Perms.ADD)\n    def add_package(self, name, links, dest=Destination.QUEUE):\n        \"\"\"\n        Adds a package, with links to desired destination.\n\n        :param name: name of the new package\n        :param links: list of urls\n        :param dest: `Destination`\n        :return: package id of the new package\n        \"\"\"\n        if self.pyload.config.get(\"general\", \"folder_per_package\"):\n            folder = name\n        else:\n            folder = \"\"\n\n        folder = (\n            folder.replace(\"http://\", \"\")\n            .replace(\"https://\", \"\")\n            .replace(\":\", \"\")\n            .replace(\"/\", \"_\")\n            .replace(\"\\\\\", \"_\")\n        )\n\n        package_id = self.pyload.files.add_package(name, folder, Destination(dest))\n\n        self.pyload.files.add_links(links, package_id)\n\n        self.pyload.log.info(\n            self._(\"Added package {name} containing {count:d} links\").format(\n                name=name, count=len(links)\n            )\n        )\n\n        self.pyload.files.save()\n\n        return package_id\n\n    @legacy(\"parseURLs\")\n    @permission(Perms.ADD)\n    def parse_urls(self, html=None, url=None):\n        \"\"\"\n        Parses html content or any arbitaty text for links and returns result of\n        `check_urls`\n\n        :param html: html source\n        :return:\n        \"\"\"\n        urls = []\n\n        if html:\n            urls += urlmatcher.findall(html)\n\n        if url:\n            page = get_url(url)\n            urls += urlmatcher.findall(page)\n\n        # remove duplicates\n        return self.check_urls(set(urls))\n\n    @legacy(\"checkURLs\")\n    @permission(Perms.ADD)\n    def check_urls(self, urls):\n        \"\"\"\n        Gets urls and returns pluginname mapped to list of matches urls.\n\n        :param urls:\n        :return: {plugin: urls}\n        \"\"\"\n        data = self.pyload.plugin_manager.parse_urls(urls)\n        plugins = {}\n\n        for url, plugin in data:\n            if plugin in plugins:\n                plugins[plugin].append(url)\n            else:\n                plugins[plugin] = [url]\n\n        return plugins\n\n    @legacy(\"checkOnlineStatus\")\n    @permission(Perms.ADD)\n    def check_online_status(self, urls):\n        \"\"\"\n        initiates online status check.\n\n        :param urls:\n        :return: initial set of data as `OnlineCheck` instance containing the result id\n        \"\"\"\n        data = self.pyload.plugin_manager.parse_urls(urls)\n\n        rid = self.pyload.thread_manager.create_result_thread(data, False)\n\n        tmp = [\n            (url, (url, OnlineStatus(url, pluginname, \"unknown\", 3, 0)))\n            for url, pluginname in data\n        ]\n        data = parse_names(tmp)\n        result = {}\n\n        for k, v in data.items():\n            for url, status in v:\n                status.packagename = k\n                result[url] = status\n\n        return OnlineCheck(rid, result)\n\n    @legacy(\"checkOnlineStatusContainer\")\n    @permission(Perms.ADD)\n    def check_online_status_container(self, urls, container, data):\n        \"\"\"\n        checks online status of urls and a submited container file.\n\n        :param urls: list of urls\n        :param container: container file name\n        :param data: file content\n        :return: online check\n        \"\"\"\n        with open(\n            os.path.join(\n                self.pyload.config.get(\"general\", \"storage_folder\"), \"tmp_\" + container\n            ),\n            \"wb\",\n        ) as th:\n            th.write(data)\n\n        return self.check_online_status(urls + [th.name])\n\n    @legacy(\"pollResults\")\n    @permission(Perms.ADD)\n    def poll_results(self, rid):\n        \"\"\"\n        Polls the result available for ResultID.\n\n        :param rid: `ResultID`\n        :return: `OnlineCheck`, if rid is -1 then no more data available\n        \"\"\"\n        result = self.pyload.thread_manager.get_info_result(rid)\n\n        if \"ALL_INFO_FETCHED\" in result:\n            del result[\"ALL_INFO_FETCHED\"]\n            return OnlineCheck(-1, result)\n        else:\n            return OnlineCheck(rid, result)\n\n    @legacy(\"generatePackages\")\n    @permission(Perms.ADD)\n    def generate_packages(self, links):\n        \"\"\"\n        Parses links, generates packages names from urls.\n\n        :param links: list of urls\n        :return: package names mapped to urls\n        \"\"\"\n        result = parse_names((x, x) for x in links)\n        return result\n\n    @legacy(\"generateAndAddPackages\")\n    @permission(Perms.ADD)\n    def generate_and_add_packages(self, links, dest=Destination.COLLECTOR):\n        \"\"\"\n        Generates and add packages.\n\n        :param links: list of urls\n        :param dest: `Destination`\n        :return: list of package ids\n        \"\"\"\n        return [\n            self.add_package(name, urls, dest)\n            for name, urls in self.generate_packages(links).items()\n        ]\n\n    @legacy(\"checkAndAddPackages\")\n    @permission(Perms.ADD)\n    def check_and_add_packages(self, links, dest=Destination.COLLECTOR):\n        \"\"\"\n        Checks online status, retrieves names, and will add packages.\n        Because of this packages are not added immediatly, only for internal use.\n\n        :param links: list of urls\n        :param dest: `Destination`\n        :return: None\n        \"\"\"\n        data = self.pyload.plugin_manager.parse_urls(links)\n        self.pyload.thread_manager.create_result_thread(data, True)\n\n    @legacy(\"getPackageData\")\n    @permission(Perms.LIST)\n    def get_package_data(self, package_id):\n        \"\"\"\n        Returns complete information about package, and included files.\n\n        :param package_id: package id\n        :return: `PackageData` with .links attribute\n        \"\"\"\n        data = self.pyload.files.get_package_data(int(package_id))\n\n        if not data:\n            raise PackageDoesNotExists(package_id)\n\n        pdata = PackageData(\n            data[\"id\"],\n            data[\"name\"],\n            data[\"folder\"],\n            data[\"site\"],\n            data[\"password\"],\n            data[\"queue\"],\n            data[\"order\"],\n            links=[self._convert_py_file(x) for x in data[\"links\"].values()],\n        )\n\n        return pdata\n\n    @legacy(\"getPackageInfo\")\n    @permission(Perms.LIST)\n    def get_package_info(self, package_id):\n        \"\"\"\n        Returns information about package, without detailed information about containing\n        files.\n\n        :param package_id: package id\n        :return: `PackageData` with .fid attribute\n        \"\"\"\n        data = self.pyload.files.get_package_data(int(package_id))\n\n        if not data:\n            raise PackageDoesNotExists(package_id)\n\n        pdata = PackageData(\n            data[\"id\"],\n            data[\"name\"],\n            data[\"folder\"],\n            data[\"site\"],\n            data[\"password\"],\n            data[\"queue\"],\n            data[\"order\"],\n            fids=[int(x) for x in data[\"links\"]],\n        )\n\n        return pdata\n\n    @legacy(\"getFileData\")\n    @permission(Perms.LIST)\n    def get_file_data(self, file_id):\n        \"\"\"\n        Get complete information about a specific file.\n\n        :param file_id: file id\n        :return: `FileData`\n        \"\"\"\n        info = self.pyload.files.get_file_data(int(file_id))\n        if not info:\n            raise FileDoesNotExists(file_id)\n\n        fileinfo = list(info.values())[0]\n        fdata = self._convert_py_file(fileinfo)\n        return fdata\n\n    @legacy(\"deleteFiles\")\n    @permission(Perms.DELETE)\n    def delete_files(self, file_ids):\n        \"\"\"\n        Deletes several file entries from pyload.\n\n        :param file_ids: list of file ids\n        \"\"\"\n        for id in file_ids:\n            self.pyload.files.delete_link(int(id))\n\n        self.pyload.files.save()\n\n    @legacy(\"deletePackages\")\n    @permission(Perms.DELETE)\n    def delete_packages(self, package_ids):\n        \"\"\"\n        Deletes packages and containing links.\n\n        :param package_ids: list of package ids\n        \"\"\"\n        for id in package_ids:\n            self.pyload.files.delete_package(int(id))\n\n        self.pyload.files.save()\n\n    @legacy(\"getQueue\")\n    @permission(Perms.LIST)\n    def get_queue(self):\n        \"\"\"\n        Returns info about queue and packages, **not** about files, see `get_queue_data` \\\n        or `get_package_data` instead.\n\n        :return: list of `PackageInfo`\n        \"\"\"\n        return [\n            PackageData(\n                pack[\"id\"],\n                pack[\"name\"],\n                pack[\"folder\"],\n                pack[\"site\"],\n                pack[\"password\"],\n                pack[\"queue\"],\n                pack[\"order\"],\n                pack[\"linksdone\"],\n                pack[\"sizedone\"],\n                pack[\"sizetotal\"],\n                pack[\"linkstotal\"],\n            )\n            for pack in self.pyload.files.get_info_data(Destination.QUEUE).values()\n        ]\n\n    @legacy(\"getQueueData\")\n    @permission(Perms.LIST)\n    def get_queue_data(self):\n        \"\"\"\n        Return complete data about everything in queue, this is very expensive use it\n        sparely.\n        See `get_queue` for alternative.\n\n        :return: list of `PackageData`\n        \"\"\"\n        return [\n            PackageData(\n                pack[\"id\"],\n                pack[\"name\"],\n                pack[\"folder\"],\n                pack[\"site\"],\n                pack[\"password\"],\n                pack[\"queue\"],\n                pack[\"order\"],\n                pack[\"linksdone\"],\n                pack[\"sizedone\"],\n                pack[\"sizetotal\"],\n                links=[self._convert_py_file(x) for x in pack[\"links\"].values()],\n            )\n            for pack in self.pyload.files.get_complete_data(Destination.QUEUE).values()\n        ]\n\n    @legacy(\"getCollector\")\n    @permission(Perms.LIST)\n    def get_collector(self):\n        \"\"\"\n        same as `get_queue` for collector.\n\n        :return: list of `PackageInfo`\n        \"\"\"\n        return [\n            PackageData(\n                pack[\"id\"],\n                pack[\"name\"],\n                pack[\"folder\"],\n                pack[\"site\"],\n                pack[\"password\"],\n                pack[\"queue\"],\n                pack[\"order\"],\n                pack[\"linksdone\"],\n                pack[\"sizedone\"],\n                pack[\"sizetotal\"],\n                pack[\"linkstotal\"],\n            )\n            for pack in self.pyload.files.get_info_data(Destination.COLLECTOR).values()\n        ]\n\n    @legacy(\"getCollectorData\")\n    @permission(Perms.LIST)\n    def get_collector_data(self):\n        \"\"\"\n        same as `get_queue_data` for collector.\n\n        :return: list of `PackageInfo`\n        \"\"\"\n        return [\n            PackageData(\n                pack[\"id\"],\n                pack[\"name\"],\n                pack[\"folder\"],\n                pack[\"site\"],\n                pack[\"password\"],\n                pack[\"queue\"],\n                pack[\"order\"],\n                pack[\"linksdone\"],\n                pack[\"sizedone\"],\n                pack[\"sizetotal\"],\n                links=[self._convert_py_file(x) for x in pack[\"links\"].values()],\n            )\n            for pack in self.pyload.files.get_complete_data(\n                Destination.COLLECTOR\n            ).values()\n        ]\n\n    @legacy(\"addFiles\")\n    @permission(Perms.ADD)\n    def add_files(self, package_id, links):\n        \"\"\"\n        Adds files to specific package.\n\n        :param package_id: package id\n        :param links: list of urls\n        \"\"\"\n        self.pyload.files.add_links(links, int(package_id))\n\n        self.pyload.log.info(\n            self._(\"Added {count:d} links to package #{package:d} \").format(\n                count=len(links), package=package_id\n            )\n        )\n        self.pyload.files.save()\n\n    @legacy(\"pushToQueue\")\n    @permission(Perms.MODIFY)\n    def push_to_queue(self, package_id):\n        \"\"\"\n        Moves package from Collector to Queue.\n\n        :param package_id: package id\n        \"\"\"\n        self.pyload.files.set_package_location(package_id, Destination.QUEUE)\n\n    @legacy(\"pullFromQueue\")\n    @permission(Perms.MODIFY)\n    def pull_from_queue(self, package_id):\n        \"\"\"\n        Moves package from Queue to Collector.\n\n        :param package_id: package id\n        \"\"\"\n        self.pyload.files.set_package_location(package_id, Destination.COLLECTOR)\n\n    @legacy(\"restartPackage\")\n    @permission(Perms.MODIFY)\n    def restart_package(self, package_id):\n        \"\"\"\n        Restarts a package, resets every containing files.\n\n        :param package_id: package id\n        \"\"\"\n        self.pyload.files.restart_package(int(package_id))\n\n    @legacy(\"restartFile\")\n    @permission(Perms.MODIFY)\n    def restart_file(self, file_id):\n        \"\"\"\n        Resets file status, so it will be downloaded again.\n\n        :param file_id:  file id\n        \"\"\"\n        self.pyload.files.restart_file(int(file_id))\n\n    @legacy(\"recheckPackage\")\n    @permission(Perms.MODIFY)\n    def recheck_package(self, package_id):\n        \"\"\"\n        Probes online status of all files in a package, also a default action when\n        package is added.\n\n        :param package_id:\n        :return:\n        \"\"\"\n        self.pyload.files.recheck_package(int(package_id))\n\n    @legacy(\"stopAllDownloads\")\n    @permission(Perms.MODIFY)\n    def stop_all_downloads(self):\n        \"\"\"\n        Aborts all running downloads.\n        \"\"\"\n        pyfiles = list(self.pyload.files.cache.values())\n        for pyfile in pyfiles:\n            pyfile.abort_download()\n\n    @legacy(\"stopDownloads\")\n    @permission(Perms.MODIFY)\n    def stop_downloads(self, file_ids):\n        \"\"\"\n        Aborts specific downloads.\n\n        :param file_ids: list of file ids\n        :return:\n        \"\"\"\n        pyfiles = list(self.pyload.files.cache.values())\n        for pyfile in pyfiles:\n            if pyfile.id in file_ids:\n                pyfile.abort_download()\n\n    @legacy(\"setPackageName\")\n    @permission(Perms.MODIFY)\n    def set_package_name(self, package_id, name):\n        \"\"\"\n        Renames a package.\n\n        :param package_id: package id\n        :param name: new package name\n        \"\"\"\n        pack = self.pyload.files.get_package(package_id)\n        pack.name = name\n        pack.sync()\n\n    @legacy(\"movePackage\")\n    @permission(Perms.MODIFY)\n    def move_package(self, destination, package_id):\n        \"\"\"\n        Set a new package location.\n\n        :param destination: `Destination`\n        :param package_id: package id\n        \"\"\"\n        try:\n            dest = Destination(destination)\n        except ValueError:\n            pass\n        else:\n            self.pyload.files.set_package_location(package_id, dest)\n\n    @legacy(\"moveFiles\")\n    @permission(Perms.MODIFY)\n    def move_files(self, file_ids, package_id):\n        \"\"\"\n        Move multiple files to another package.\n\n        :param file_ids: list of file ids\n        :param package_id: destination package\n        :return:\n        \"\"\"\n        # TODO: implement\n        pass\n\n    @legacy(\"uploadContainer\")\n    @permission(Perms.ADD)\n    def upload_container(self, filename, data):\n        \"\"\"\n        Uploads and adds a container file to pyLoad.\n\n        :param filename: filename, extension is important so it can correctly decrypted\n        :param data: file content\n        \"\"\"\n        with open(\n            os.path.join(\n                self.pyload.config.get(\"general\", \"storage_folder\"), \"tmp_\" + filename\n            ),\n            \"wb\",\n        ) as th:\n            th.write(data)\n\n        self.add_package(th.name, [th.name], Destination.COLLECTOR)\n\n    @legacy(\"orderPackage\")\n    @permission(Perms.MODIFY)\n    def order_package(self, package_id, position):\n        \"\"\"\n        Gives a package a new position.\n\n        :param package_id: package id\n        :param position:\n        \"\"\"\n        self.pyload.files.reorder_package(package_id, position)\n\n    @legacy(\"orderFile\")\n    @permission(Perms.MODIFY)\n    def order_file(self, file_id, position):\n        \"\"\"\n        Gives a new position to a file within its package.\n\n        :param file_id: file id\n        :param position:\n        \"\"\"\n        self.pyload.files.reorder_file(file_id, position)\n\n    @legacy(\"setPackageData\")\n    @permission(Perms.MODIFY)\n    def set_package_data(self, package_id, data):\n        \"\"\"\n        Allows to modify several package attributes.\n\n        :param package_id: package id\n        :param data: dict that maps attribute to desired value\n        \"\"\"\n        p = self.pyload.files.get_package(package_id)\n        if not p:\n            raise PackageDoesNotExists(package_id)\n\n        for key, value in data.items():\n            if key == \"id\":\n                continue\n            setattr(p, key, value)\n\n        p.sync()\n        self.pyload.files.save()\n\n    @legacy(\"deleteFinished\")\n    @permission(Perms.DELETE)\n    def delete_finished(self):\n        \"\"\"\n        Deletes all finished files and completely finished packages.\n\n        :return: list of deleted package ids\n        \"\"\"\n        return self.pyload.files.delete_finished_links()\n\n    @legacy(\"restartFailed\")\n    @permission(Perms.MODIFY)\n    def restart_failed(self):\n        \"\"\"\n        Restarts all failed failes.\n        \"\"\"\n        self.pyload.files.restart_failed()\n\n    @legacy(\"getPackageOrder\")\n    @permission(Perms.LIST)\n    def get_package_order(self, destination):\n        \"\"\"\n        Returns information about package order.\n\n        :param destination: `Destination`\n        :return: dict mapping order to package id\n        \"\"\"\n        packages = self.pyload.files.get_info_data(Destination(destination))\n        order = {}\n\n        for package_id in packages:\n            pack = self.pyload.files.get_package_data(int(package_id))\n            while pack[\"order\"] in order.keys():  #: just in case\n                pack[\"order\"] += 1\n            order[pack[\"order\"]] = pack[\"id\"]\n        return order\n\n    @legacy(\"getFileOrder\")\n    @permission(Perms.LIST)\n    def get_file_order(self, package_id):\n        \"\"\"\n        Information about file order within package.\n\n        :param package_id:\n        :return: dict mapping order to file id\n        \"\"\"\n        raw_data = self.pyload.files.get_package_data(int(package_id))\n        order = {}\n        for id, pyfile in raw_data[\"links\"].items():\n            while pyfile[\"order\"] in order.keys():  #: just in case\n                pyfile[\"order\"] += 1\n            order[pyfile[\"order\"]] = pyfile[\"id\"]\n        return order\n\n    @legacy(\"isCaptchaWaiting\")\n    @permission(Perms.STATUS)\n    def is_captcha_waiting(self):\n        \"\"\"\n        Indicates wether a captcha task is available.\n\n        :return: bool\n        \"\"\"\n        self.pyload.last_client_connected = time.time()\n        task = self.pyload.captcha_manager.get_task()\n        return task is not None\n\n    @legacy(\"getCaptchaTask\")\n    @permission(Perms.STATUS)\n    def get_captcha_task(self, exclusive=False):\n        \"\"\"\n        Returns a captcha task.\n\n        :param exclusive: unused\n        :return: `CaptchaTask`\n        \"\"\"\n        self.pyload.last_client_connected = time.time()\n        task = self.pyload.captcha_manager.get_task()\n        if task:\n            task.set_waiting_for_user(exclusive=exclusive)\n            data, type, result = task.get_captcha()\n            t = CaptchaTask(int(task.id), json.dumps(data), type, result)\n            return t\n        else:\n            return CaptchaTask(-1)\n\n    @legacy(\"getCaptchaTaskStatus\")\n    @permission(Perms.STATUS)\n    def get_captcha_task_status(self, tid):\n        \"\"\"\n        Get information about captcha task.\n\n        :param tid: task id\n        :return: string\n        \"\"\"\n        self.pyload.last_client_connected = time.time()\n        t = self.pyload.captcha_manager.get_task_by_id(tid)\n        return t.get_status() if t else \"\"\n\n    @legacy(\"setCaptchaResult\")\n    @permission(Perms.STATUS)\n    def set_captcha_result(self, tid, result):\n        \"\"\"\n        Set result for a captcha task.\n\n        :param tid: task id\n        :param result: captcha result\n        \"\"\"\n        self.pyload.last_client_connected = time.time()\n        task = self.pyload.captcha_manager.get_task_by_id(tid)\n        if task:\n            task.set_result(result)\n            self.pyload.captcha_manager.remove_task(task)\n\n    @legacy(\"getEvents\")\n    @permission(Perms.STATUS)\n    def get_events(self, uuid):\n        \"\"\"\n        Lists occurred events, may be affected to changes in the future.\n\n        :param uuid:\n        :return: list of `Events`\n        \"\"\"\n        events = self.pyload.event_manager.get_events(uuid)\n        new_events = []\n\n        def conv_dest(d):\n            return (Destination.QUEUE if d == \"queue\" else Destination.COLLECTOR).value\n\n        for e in events:\n            event = EventInfo()\n            event.eventname = e[0]\n            if e[0] in (\"update\", \"remove\", \"insert\"):\n                event.id = e[3]\n                event.type = (\n                    ElementType.PACKAGE if e[2] == \"pack\" else ElementType.FILE\n                ).value\n                event.destination = conv_dest(e[1])\n            elif e[0] == \"order\":\n                if e[1]:\n                    event.id = e[1]\n                    event.type = (\n                        ElementType.PACKAGE if e[2] == \"pack\" else ElementType.FILE\n                    )\n                    event.destination = conv_dest(e[3])\n            elif e[0] == \"reload\":\n                event.destination = conv_dest(e[1])\n            new_events.append(event)\n        return new_events\n\n    @legacy(\"getAccounts\")\n    @permission(Perms.ACCOUNTS)\n    def get_accounts(self, refresh):\n        \"\"\"\n        Get information about all entered accounts.\n\n        :param refresh: reload account info\n        :return: list of `AccountInfo`\n        \"\"\"\n        accs = self.pyload.account_manager.get_account_infos(False, refresh)\n        accounts = []\n        for group in accs.values():\n            accounts.extend(\n                [\n                    AccountInfo(\n                        acc[\"validuntil\"],\n                        acc[\"login\"],\n                        acc[\"options\"],\n                        acc[\"valid\"],\n                        acc[\"trafficleft\"],\n                        acc[\"maxtraffic\"],\n                        acc[\"premium\"],\n                        acc[\"type\"],\n                    )\n                    for acc in group\n                ]\n            )\n        return accounts\n\n    @legacy(\"getAccountTypes\")\n    @permission(Perms.ANY)\n    def get_account_types(self):\n        \"\"\"\n        All available account types.\n\n        :return: list\n        \"\"\"\n        return list(self.pyload.account_manager.accounts.keys())\n\n    @legacy(\"updateAccount\")\n    @permission(Perms.ACCOUNTS)\n    def update_account(self, plugin, account, password=None, options={}):\n        \"\"\"\n        Changes pw/options for specific account.\n        \"\"\"\n        self.pyload.account_manager.update_account(plugin, account, password, options)\n\n    @legacy(\"removeAccount\")\n    @permission(Perms.ACCOUNTS)\n    def remove_account(self, plugin, account):\n        \"\"\"\n        Remove account from pyload.\n\n        :param plugin: pluginname\n        :param account: accountname\n        \"\"\"\n        self.pyload.account_manager.remove_account(plugin, account)\n\n    @permission(Perms.ANY)\n    def login(self, username, password):\n        \"\"\"\n        Login into pyLoad, this **must** be called when using rpc before any methods can\n        be used.\n\n        :param username:\n        :param password:\n        :return: bool indicating login was successful\n        \"\"\"\n        return True if self.check_auth(username, password) else False\n\n    @legacy(\"checkAuth\")\n    def check_auth(self, username, password):\n        \"\"\"\n        Check authentication and returns details.\n\n        :param username:\n        :param password:\n        :return: dict with info, empty when login is incorrect\n        \"\"\"\n        return self.pyload.db.check_auth(username, password)\n\n    def user_exists(self, username):\n        \"\"\"\n        Check if a user actually exists in the database.\n\n        :param username:\n        :return: boolean\n        \"\"\"\n        return self.pyload.db.user_exists(username)\n\n    @legacy(\"isAuthorized\")\n    def is_authorized(self, func, userdata):\n        \"\"\"\n        checks if the user is authorized for specific method.\n\n        :param func: function name\n        :param userdata: dictionary of user data\n        :return: boolean\n        \"\"\"\n        if userdata[\"role\"] == Role.ADMIN:\n            return True\n        elif func in perm_map and has_permission(\n            userdata[\"permission\"], perm_map[func]\n        ):\n            return True\n        else:\n            return False\n\n    @permission(Perms.SETTINGS)\n    def get_userdir(self):\n        return os.path.realpath(self.pyload.userdir)\n\n    @permission(Perms.SETTINGS)\n    def get_cachedir(self):\n        return os.path.realpath(self.pyload.tempdir)\n\n    #: Old API\n    @permission(Perms.ANY)\n    def getUserData(self, username, password):\n        \"\"\"\n        similar to `check_auth` but returns UserData thrift type.\n        \"\"\"\n        user = self.check_auth(username, password)\n        if user:\n            return OldUserData(\n                user[\"name\"],\n                user[\"email\"],\n                user[\"role\"],\n                user[\"permission\"],\n                user[\"template\"],\n            )\n        else:\n            return OldUserData()\n\n    @permission(Perms.ANY)\n    def get_userdata(self, username, password):\n        \"\"\"\n        similar to `check_auth` but returns UserData thrift type.\n        \"\"\"\n        user = self.check_auth(username, password)\n        if user:\n            return UserData(\n                user[\"id\"],\n                user[\"name\"],\n                user[\"email\"],\n                user[\"role\"],\n                user[\"permission\"],\n                user[\"template\"],\n            )\n        else:\n            return UserData()\n\n    #: Old API\n    def getAllUserData(self):\n        \"\"\"\n        returns all known user and info.\n        \"\"\"\n        res = {}\n        for id, data in self.pyload.db.get_all_user_data().items():\n            res[data[\"name\"]] = OldUserData(\n                data[\"name\"],\n                data[\"email\"],\n                data[\"role\"],\n                data[\"permission\"],\n                data[\"template\"],\n            )\n\n        return res\n\n    def get_all_userdata(self):\n        \"\"\"\n        returns all known user and info.\n        \"\"\"\n        res = {}\n        for id, data in self.pyload.db.get_all_user_data().items():\n            res[id] = UserData(\n                id,\n                data[\"name\"],\n                data[\"email\"],\n                data[\"role\"],\n                data[\"permission\"],\n                data[\"template\"],\n            )\n        return res\n\n    @legacy(\"getServices\")\n    @permission(Perms.STATUS)\n    def get_services(self):\n        \"\"\"\n        A dict of available services, these can be defined by addon plugins.\n\n        :return: dict with this style: {\"plugin\": {\"method\": \"description\"}}\n        \"\"\"\n        data = {}\n        for plugin, funcs in self.pyload.addon_manager.methods.items():\n            data[plugin] = funcs\n\n        return data\n\n    @legacy(\"hasService\")\n    @permission(Perms.STATUS)\n    def has_service(self, plugin, func):\n        \"\"\"\n        Checks whether a service is available.\n\n        :param plugin:\n        :param func:\n        :return: bool\n        \"\"\"\n        cont = self.pyload.addon_manager.methods\n        return plugin in cont and func in cont[plugin]\n\n    @permission(Perms.STATUS)\n    def call(self, info):\n        \"\"\"\n        Calls a service (a method in addon plugin).\n\n        :param info: `ServiceCall`\n        :return: result\n        :raises: ServiceDoesNotExists, when its not available\n        :raises: ServiceException, when a exception was raised\n        \"\"\"\n        plugin = info.plugin\n        func = info.func\n        args = info.arguments\n        parse = info.parse_arguments\n\n        if not self.has_service(plugin, func):\n            raise ServiceDoesNotExists(plugin, func)\n\n        try:\n            ret = self.pyload.addon_manager.call_rpc(plugin, func, args, parse)\n            return str(ret)\n        except Exception as exc:\n            raise ServiceException(exc)\n\n    @legacy(\"getAllInfo\")\n    @permission(Perms.STATUS)\n    def get_all_info(self):\n        \"\"\"\n        Returns all information stored by addon plugins. Values are always strings.\n\n        :return: {\"plugin\": {\"name\": value } }\n        \"\"\"\n        return self.pyload.addon_manager.get_all_info()\n\n    @legacy(\"getInfoByPlugin\")\n    @permission(Perms.STATUS)\n    def get_info_by_plugin(self, plugin):\n        \"\"\"\n        Returns information stored by a specific plugin.\n\n        :param plugin: pluginname\n        :return: dict of attr names mapped to value {\"name\": value}\n        \"\"\"\n        return self.pyload.addon_manager.get_info(plugin)\n\n    def add_user(self, user, newpw, role=0, perms=0):\n        \"\"\"\n        creates new user login.\n        \"\"\"\n        return self.pyload.db.add_user(user, newpw, role, perms)\n\n    def remove_user(self, user):\n        \"\"\"\n        deletes a user login.\n        \"\"\"\n        return self.pyload.db.remove_user(user)\n\n    @legacy(\"changePassword\")\n    def change_password(self, user, oldpw, newpw):\n        \"\"\"\n        changes password for specific user.\n        \"\"\"\n        return self.pyload.db.change_password(user, oldpw, newpw)\n\n    @legacy(\"setUserPermission\")\n    def set_user_permission(self, user, permission, role):\n        self.pyload.db.set_permission(user, permission)\n        self.pyload.db.set_role(user, role)\n", "# -*- coding: utf-8 -*-\n\nimport hashlib\nimport os\n\nfrom ..utils.struct.style import style\n\n\n# TODO: rewrite using scrypt or argon2_cffi\ndef _salted_password(password, salt):\n    dk = hashlib.pbkdf2_hmac(\"sha256\", password.encode(), bytes.fromhex(salt), 100000)\n    return salt + dk.hex()\n\n\ndef _gensalt():\n    return os.urandom(16).hex()\n\n\ndef _check_password(hashed, clear):\n    salt = hashed[:32]\n    to_compare = _salted_password(clear, salt)\n\n    return hashed == to_compare\n\n\nclass UserDatabaseMethods:\n    @style.queue\n    def check_auth(self, user, password):\n        self.c.execute(\n            \"SELECT id, name, password, role, permission, template, email FROM users WHERE name=?\",\n            (user,),\n        )\n        r = self.c.fetchone()\n        if not r:\n            return {}\n\n        stored_password = r[2]\n        if not _check_password(stored_password, password):\n            return {}\n\n        return {\n            \"id\": r[0],\n            \"name\": r[1],\n            \"role\": r[3],\n            \"permission\": r[4],\n            \"template\": r[5],\n            \"email\": r[6],\n        }\n\n    @style.queue\n    def add_user(self, user, password, role=0, perms=0, reset=False):\n        salt_pw = _salted_password(password, _gensalt())\n\n        self.c.execute(\"SELECT name FROM users WHERE name=?\", (user,))\n        if self.c.fetchone() is not None:\n            if reset:\n                self.c.execute(\n                    \"UPDATE users SET password=?, role=?, permission=? WHERE name=?\",\n                    (salt_pw, role, perms, user),\n                )\n                return True\n            else:\n                return False\n        else:\n            self.c.execute(\n                \"INSERT INTO users (name, password, role, permission) VALUES (?, ?, ?, ?)\",\n                (user, salt_pw, role, perms),\n            )\n            return True\n\n    @style.queue\n    def change_password(self, user, old_password, new_password):\n        self.c.execute(\"SELECT id, name, password FROM users WHERE name=?\", (user,))\n        r = self.c.fetchone()\n        if not r:\n            return False\n\n        stored_password = r[2]\n        if not _check_password(stored_password, old_password):\n            return False\n\n        newpw = _salted_password(new_password, _gensalt())\n\n        self.c.execute(\"UPDATE users SET password=? WHERE name=?\", (newpw, user))\n        return True\n\n    @style.async_\n    def set_permission(self, user, perms):\n        self.c.execute(\"UPDATE users SET permission=? WHERE name=?\", (perms, user))\n\n    @style.async_\n    def set_role(self, user, role):\n        self.c.execute(\"UPDATE users SET role=? WHERE name=?\", (role, user))\n\n    @style.queue\n    def user_exists(self, user):\n        self.c.execute(\"SELECT name FROM users WHERE name=?\", (user,))\n        return self.c.fetchone() is not None\n\n    @style.queue\n    def list_users(self):\n        self.c.execute(\"SELECT name FROM users\")\n        users = []\n        for row in self.c:\n            users.append(row[0])\n        return users\n\n    @style.queue\n    def get_all_user_data(self):\n        self.c.execute(\"SELECT id, name, permission, role, template, email FROM users\")\n        user = {}\n        for r in self.c:\n            user[r[0]] = {\n                \"name\": r[1],\n                \"permission\": r[2],\n                \"role\": r[3],\n                \"template\": r[4],\n                \"email\": r[5],\n            }\n\n        return user\n\n    @style.queue\n    def remove_user(self, user):\n        self.c.execute(\"DELETE FROM users WHERE name=?\", (user,))\n", "# -*- coding: utf-8 -*-\n\nfrom functools import wraps\nfrom urllib.parse import urljoin, urlparse\n\nimport flask\nimport flask_themes2\n\nfrom pyload.core.api import Perms, Role, has_permission\n\n\nclass JSONEncoder(flask.json.JSONEncoder):\n    def default(self, obj):\n        try:\n            return dict(obj)\n        except TypeError:\n            pass\n        return super().default(obj)\n\n\n#: Checks if location belongs to same host address\ndef is_safe_url(location):\n    ref_url = urlparse(flask.request.host_url)\n    test_url = urlparse(urljoin(flask.request.host_url, location))\n    return ref_url.netloc == test_url.netloc\n\n\ndef get_redirect_url(fallback=None):\n    login_url = urljoin(flask.request.url_root, flask.url_for('app.login'))\n    for location in flask.request.values.get(\"next\"), flask.request.referrer:\n        if not location:\n            continue\n        if location in (flask.request.url, login_url):  # don't redirect to same location\n            continue\n        if is_safe_url(location):\n            return location\n    return fallback\n\n\ndef render_base(messages):\n    return render_template(\"base.html\", messages=messages)\n\n\ndef clear_session(session=flask.session, permanent=True):\n    session.permanent = bool(permanent)\n    session.clear()\n    # session.modified = True\n\n\ndef current_theme_id():\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    return api.get_config_value(\"webui\", \"theme\").lower()\n\n\n#: tries to serve the file from the static directory of the current theme otherwise fallback to builtin one\ndef static_file_url(filename):\n    themeid = current_theme_id()\n    try:\n        url = flask_themes2.static_file_url(themeid, filename)\n    except KeyError:\n        url = flask.url_for(\"static\", filename=filename)\n    return url\n\n\ndef theme_template(filename):\n    return flask.url_for(\"app.render\", filename=filename)\n\n\n#: tries to render the template of the current theme otherwise fallback to builtin template\ndef render_template(template, **context):\n    themeid = current_theme_id()\n    return flask_themes2.render_theme_template(themeid, template, **context)\n\n\ndef parse_permissions(session=flask.session):\n    perms = {x.name: False for x in Perms}\n    perms[\"ADMIN\"] = False\n    perms[\"is_admin\"] = False\n\n    if not session.get(\"authenticated\", False):\n        return perms\n\n    perms[\"ANY\"] = True\n    if session.get(\"role\") == Role.ADMIN:\n        for key in perms.keys():\n            perms[key] = True\n\n    elif session.get(\"perms\"):\n        p = session.get(\"perms\")\n        perms.update(get_permission(p))\n\n    return perms\n\n\ndef permlist():\n    return [x.name for x in Perms if x.name != \"ANY\"]\n\n\ndef get_permission(userperms):\n    \"\"\"\n    Returns a dict with permission key.\n\n    :param userperms: permission bits\n    \"\"\"\n    return {\n        name: has_permission(userperms, getattr(Perms, name).value)\n        for name in permlist()\n    }\n\n\ndef set_permission(perms):\n    \"\"\"\n    generates permission bits from dictionary.\n\n    :param perms: dict\n    \"\"\"\n    permission = 0\n    for name in permlist():\n        if name.startswith(\"_\"):\n            continue\n\n        if name in perms and perms[name]:\n            permission |= getattr(Perms, name)\n\n    return permission\n\n\ndef set_session(user_info, session=flask.session, permanent=True):\n    session.permanent = bool(permanent)\n    session.update(\n        {\n            \"authenticated\": True,\n            \"id\": user_info[\"id\"],\n            \"name\": user_info[\"name\"],\n            \"role\": user_info[\"role\"],\n            \"perms\": user_info[\"permission\"],\n            \"template\": user_info[\"template\"],\n        }\n    )\n    # session.modified = True\n    return session\n\n\n# TODO: Recheck...\ndef parse_userdata(session=flask.session):\n    return {\n        \"name\": session.get(\"name\", \"Anonymous\"),\n        \"is_admin\": session.get(\"role\", 1) == 0,\n        \"is_authenticated\": session.get(\"authenticated\", False),\n    }\n\n\ndef apiver_check(func):\n    # if no apiver is provided assumes latest\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        api = flask.current_app.config[\"PYLOAD_API\"]\n        core_apiver = api.__version__\n        if int(kwargs.get(\"apiver\", core_apiver).strip(\"v\")) < core_apiver:\n            return \"Obsolete API\", 404\n        return func(*args, **kwargs)\n\n    return wrapper\n\n\ndef is_authenticated(session=flask.session):\n    api = flask.current_app.config[\"PYLOAD_API\"]\n    user = session.get(\"name\")\n    authenticated = session.get(\"authenticated\")\n\n    return authenticated and api.user_exists(user)\n\n\ndef login_required(perm):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            s = flask.session\n            #: already authenticated?\n            if is_authenticated(s):\n                perms = parse_permissions(s)\n                if perm not in perms or not perms[perm]:\n                    response = \"Forbidden\", 403\n                else:\n                    response = func(*args, **kwargs)\n\n            elif flask.request.headers.get(\"X-Requested-With\") == \"XMLHttpRequest\":\n                response = \"Forbidden\", 403\n\n            else:\n                location = flask.url_for(\n                    \"app.login\",\n                    next=flask.request.url\n                )\n                response = flask.redirect(location)\n\n            return response\n\n        return wrapper\n\n    return decorator\n"], "filenames": ["src/pyload/core/api/__init__.py", "src/pyload/core/database/user_database.py", "src/pyload/webui/app/helpers.py"], "buggy_code_start_loc": [1120, 95, 167], "buggy_code_end_loc": [1232, 95, 170], "fixing_code_start_loc": [1120, 96, 167], "fixing_code_end_loc": [1242, 101, 172], "type": "CWE-613", "message": "Insufficient Session Expiration in GitHub repository pyload/pyload prior to 0.5.0b3.dev36.", "other": {"cve": {"id": "CVE-2023-0227", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-12T01:15:10.020", "lastModified": "2023-01-20T08:01:42.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Insufficient Session Expiration in GitHub repository pyload/pyload prior to 0.5.0b3.dev36."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pyload:pyload:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023-01-12", "matchCriteriaId": "270B9386-E69E-44A1-943F-8EE757354530"}]}]}], "references": [{"url": "https://github.com/pyload/pyload/commit/c035714c0596b704b11af0f8a669352f128ad2d9", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/af3101d7-fea6-463a-b7e4-a48be219e31b", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pyload/pyload/commit/c035714c0596b704b11af0f8a669352f128ad2d9"}}