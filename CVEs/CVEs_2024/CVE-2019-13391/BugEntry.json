{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%           AAA   N   N  N   N   OOO   TTTTT   AAA   TTTTT  EEEEE             %\n%          A   A  NN  N  NN  N  O   O    T    A   A    T    E                 %\n%          AAAAA  N N N  N N N  O   O    T    AAAAA    T    EEE               %\n%          A   A  N  NN  N  NN  O   O    T    A   A    T    E                 %\n%          A   A  N   N  N   N   OOO     T    A   A    T    EEEEE             %\n%                                                                             %\n%                                                                             %\n%                   MagickCore Image Annotation Methods                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% Digital Applications (www.digapp.com) contributed the stroked text algorithm.\n% It was written by Leonard Rosenthol.\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/annotate-private.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/draw-private.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/token-private.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/transform-private.h\"\n#include \"MagickCore/type.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/xwindow.h\"\n#include \"MagickCore/xwindow-private.h\"\n#if defined(MAGICKCORE_FREETYPE_DELEGATE)\n#if defined(__MINGW32__)\n#  undef interface\n#endif\n#include <ft2build.h>\n#if defined(FT_FREETYPE_H)\n#  include FT_FREETYPE_H\n#else\n#  include <freetype/freetype.h>\n#endif\n#if defined(FT_GLYPH_H)\n#  include FT_GLYPH_H\n#else\n#  include <freetype/ftglyph.h>\n#endif\n#if defined(FT_OUTLINE_H)\n#  include FT_OUTLINE_H\n#else\n#  include <freetype/ftoutln.h>\n#endif\n#if defined(FT_BBOX_H)\n#  include FT_BBOX_H\n#else\n#  include <freetype/ftbbox.h>\n#endif /* defined(FT_BBOX_H) */\n#endif\n#if defined(MAGICKCORE_RAQM_DELEGATE)\n#include <raqm.h>\n#endif\ntypedef struct _GraphemeInfo\n{\n  size_t\n    index,\n    x_offset,\n    x_advance,\n    y_offset;\n\n  size_t\n    cluster;\n} GraphemeInfo;\n\f\n/*\n  Annotate semaphores.\n*/\nstatic SemaphoreInfo\n  *annotate_semaphore = (SemaphoreInfo *) NULL;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  RenderType(Image *,const DrawInfo *,const PointInfo *,TypeMetric *,\n    ExceptionInfo *),\n  RenderPostscript(Image *,const DrawInfo *,const PointInfo *,TypeMetric *,\n    ExceptionInfo *),\n  RenderFreetype(Image *,const DrawInfo *,const char *,const PointInfo *,\n    TypeMetric *,ExceptionInfo *),\n  RenderX11(Image *,const DrawInfo *,const PointInfo *,TypeMetric *,\n    ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A n n o t a t e C o m p o n e n t G e n e s i s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AnnotateComponentGenesis() instantiates the annotate component.\n%\n%  The format of the AnnotateComponentGenesis method is:\n%\n%      MagickBooleanType AnnotateComponentGenesis(void)\n%\n*/\nMagickPrivate MagickBooleanType AnnotateComponentGenesis(void)\n{\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    annotate_semaphore=AcquireSemaphoreInfo();\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A n n o t a t e C o m p o n e n t T e r m i n u s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AnnotateComponentTerminus() destroys the annotate component.\n%\n%  The format of the AnnotateComponentTerminus method is:\n%\n%      AnnotateComponentTerminus(void)\n%\n*/\nMagickPrivate void AnnotateComponentTerminus(void)\n{\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&annotate_semaphore);\n  RelinquishSemaphoreInfo(&annotate_semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A n n o t a t e I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AnnotateImage() annotates an image with text.\n%\n%  The format of the AnnotateImage method is:\n%\n%      MagickBooleanType AnnotateImage(Image *image,DrawInfo *draw_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType AnnotateImage(Image *image,\n  const DrawInfo *draw_info,ExceptionInfo *exception)\n{\n  char\n    *p,\n    primitive[MagickPathExtent],\n    *text,\n    **textlist;\n\n  DrawInfo\n    *annotate,\n    *annotate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    number_lines;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (draw_info->text == (char *) NULL)\n    return(MagickFalse);\n  if (*draw_info->text == '\\0')\n    return(MagickTrue);\n  annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  text=annotate->text;\n  annotate->text=(char *) NULL;\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  number_lines=1;\n  for (p=text; *p != '\\0'; p++)\n    if (*p == '\\n')\n      number_lines++;\n  textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    {\n      annotate_info=DestroyDrawInfo(annotate_info);\n      annotate=DestroyDrawInfo(annotate);\n      return(MagickFalse);\n    }\n  p=text;\n  for (i=0; i < number_lines; i++)\n  {\n    char\n      *q;\n\n    textlist[i]=p;\n    for (q=p; *q != '\\0'; q++)\n      if ((*q == '\\r') || (*q == '\\n'))\n        break;\n    if (*q == '\\r')\n      {\n        *q='\\0';\n        q++;\n      }\n    *q='\\0';\n    p=q+1;\n  }\n  textlist[i]=(char *) NULL;\n  SetGeometry(image,&geometry);\n  SetGeometryInfo(&geometry_info);\n  if (annotate_info->geometry != (char *) NULL)\n    {\n      (void) ParsePageGeometry(image,annotate_info->geometry,&geometry,\n        exception);\n      (void) ParseGeometry(annotate_info->geometry,&geometry_info);\n    }\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      annotate_info=DestroyDrawInfo(annotate_info);\n      annotate=DestroyDrawInfo(annotate);\n      textlist=(char **) RelinquishMagickMemory(textlist);\n      return(MagickFalse);\n    }\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  status=MagickTrue;\n  (void) memset(&metrics,0,sizeof(metrics));\n  for (i=0; textlist[i] != (char *) NULL; i++)\n  {\n    if (*textlist[i] == '\\0')\n      continue;\n    /*\n      Position text relative to image.\n    */\n    annotate_info->affine.tx=geometry_info.xi-image->page.x;\n    annotate_info->affine.ty=geometry_info.psi-image->page.y;\n    (void) CloneString(&annotate->text,textlist[i]);\n    if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))\n      (void) GetTypeMetrics(image,annotate,&metrics,exception);\n    height=(ssize_t) (metrics.ascent-metrics.descent+\n      draw_info->interline_spacing+0.5);\n    switch (annotate->gravity)\n    {\n      case UndefinedGravity:\n      default:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case NorthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent;\n        break;\n      }\n      case NorthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case NorthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent)-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      case WestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case CenterGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case EastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+\n          annotate_info->affine.ry*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case SouthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height-annotate_info->affine.ry*\n          (number_lines-1.0)*height;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0-\n          annotate_info->affine.ry*(number_lines-1.0)*height/2.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width-\n          annotate_info->affine.ry*(number_lines-1.0)*height-1.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n    }\n    switch (annotate->align)\n    {\n      case LeftAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case CenterAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case RightAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      default:\n        break;\n    }\n    if (draw_info->undercolor.alpha != TransparentAlpha)\n      {\n        DrawInfo\n          *undercolor_info;\n\n        /*\n          Text box.\n        */\n        undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);\n        undercolor_info->fill=draw_info->undercolor;\n        undercolor_info->affine=draw_info->affine;\n        undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent;\n        undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent;\n        (void) FormatLocaleString(primitive,MagickPathExtent,\n          \"rectangle 0.0,0.0 %g,%g\",metrics.origin.x,(double) height);\n        (void) CloneString(&undercolor_info->primitive,primitive);\n        (void) DrawImage(image,undercolor_info,exception);\n        (void) DestroyDrawInfo(undercolor_info);\n      }\n    annotate_info->affine.tx=offset.x;\n    annotate_info->affine.ty=offset.y;\n    (void) FormatLocaleString(primitive,MagickPathExtent,\"stroke-width %g \"\n      \"line 0,0 %g,0\",metrics.underline_thickness,metrics.width);\n    if (annotate->decorate == OverlineDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+\n          metrics.descent-metrics.underline_position));\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n    else\n      if (annotate->decorate == UnderlineDecoration)\n        {\n          annotate_info->affine.ty-=(draw_info->affine.sy*\n            metrics.underline_position);\n          (void) CloneString(&annotate_info->primitive,primitive);\n          (void) DrawImage(image,annotate_info,exception);\n        }\n    /*\n      Annotate image with text.\n    */\n    status=RenderType(image,annotate,&offset,&metrics,exception);\n    if (status == MagickFalse)\n      break;\n    if (annotate->decorate == LineThroughDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(height+\n          metrics.underline_position+metrics.descent)/2.0);\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  annotate_info=DestroyDrawInfo(annotate_info);\n  annotate=DestroyDrawInfo(annotate);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  F o r m a t M a g i c k C a p t i o n                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatMagickCaption() formats a caption so that it fits within the image\n%  width.  It returns the number of lines in the formatted caption.\n%\n%  The format of the FormatMagickCaption method is:\n%\n%      ssize_t FormatMagickCaption(Image *image,DrawInfo *draw_info,\n%        const MagickBooleanType split,TypeMetric *metrics,char **caption,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image:  The image.\n%\n%    o draw_info: the draw info.\n%\n%    o split: when no convenient line breaks-- insert newline.\n%\n%    o metrics: Return the font metrics in this structure.\n%\n%    o caption: the caption.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ssize_t FormatMagickCaption(Image *image,DrawInfo *draw_info,\n  const MagickBooleanType split,TypeMetric *metrics,char **caption,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register char\n    *p,\n    *q,\n    *s;\n\n  register ssize_t\n    i;\n\n  size_t\n    width;\n\n  ssize_t\n    n;\n\n  q=draw_info->text;\n  s=(char *) NULL;\n  for (p=(*caption); GetUTFCode(p) != 0; p+=GetUTFOctets(p))\n  {\n    if (IsUTFSpace(GetUTFCode(p)) != MagickFalse)\n      s=p;\n    if (GetUTFCode(p) == '\\n')\n      {\n        q=draw_info->text;\n        continue;\n      }\n    for (i=0; i < (ssize_t) GetUTFOctets(p); i++)\n      *q++=(*(p+i));\n    *q='\\0';\n    status=GetTypeMetrics(image,draw_info,metrics,exception);\n    if (status == MagickFalse)\n      break;\n    width=(size_t) floor(metrics->width+draw_info->stroke_width+0.5);\n    if (width <= image->columns)\n      continue;\n    if (s != (char *) NULL)\n      {\n        *s='\\n';\n        p=s;\n      }\n    else\n      if (split != MagickFalse)\n        {\n          /*\n            No convenient line breaks-- insert newline.\n          */\n          n=p-(*caption);\n          if ((n > 0) && ((*caption)[n-1] != '\\n'))\n            {\n              char\n                *target;\n\n              target=AcquireString(*caption);\n              CopyMagickString(target,*caption,n+1);\n              ConcatenateMagickString(target,\"\\n\",strlen(*caption)+1);\n              ConcatenateMagickString(target,p,strlen(*caption)+2);\n              (void) DestroyString(*caption);\n              *caption=target;\n              p=(*caption)+n;\n            }\n        }\n    q=draw_info->text;\n    s=(char *) NULL;\n  }\n  n=0;\n  for (p=(*caption); GetUTFCode(p) != 0; p+=GetUTFOctets(p))\n    if (GetUTFCode(p) == '\\n')\n      n++;\n  return(n);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M u l t i l i n e T y p e M e t r i c s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMultilineTypeMetrics() returns the following information for the\n%  specified font and text:\n%\n%    character width\n%    character height\n%    ascender\n%    descender\n%    text width\n%    text height\n%    maximum horizontal advance\n%    bounds: x1\n%    bounds: y1\n%    bounds: x2\n%    bounds: y2\n%    origin: x\n%    origin: y\n%    underline position\n%    underline thickness\n%\n%  This method is like GetTypeMetrics() but it returns the maximum text width\n%  and height for multiple lines of text.\n%\n%  The format of the GetMultilineTypeMetrics method is:\n%\n%      MagickBooleanType GetMultilineTypeMetrics(Image *image,\n%        const DrawInfo *draw_info,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o metrics: Return the font metrics in this structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetMultilineTypeMetrics(Image *image,\n  const DrawInfo *draw_info,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  char\n    **textlist;\n\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    height,\n    count;\n\n  TypeMetric\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->text != (char *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (*draw_info->text == '\\0')\n    return(MagickFalse);\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->text=DestroyString(annotate_info->text);\n  /*\n    Convert newlines to multiple lines of text.\n  */\n  textlist=StringToStrings(draw_info->text,&count);\n  if (textlist == (char **) NULL)\n    return(MagickFalse);\n  annotate_info->render=MagickFalse;\n  annotate_info->direction=UndefinedDirection;\n  (void) memset(metrics,0,sizeof(*metrics));\n  (void) memset(&extent,0,sizeof(extent));\n  /*\n    Find the widest of the text lines.\n  */\n  annotate_info->text=textlist[0];\n  status=GetTypeMetrics(image,annotate_info,&extent,exception);\n  *metrics=extent;\n  height=(count*(size_t) (metrics->ascent-metrics->descent+\n    0.5)+(count-1)*draw_info->interline_spacing);\n  if (AcquireMagickResource(HeightResource,height) == MagickFalse)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"WidthOrHeightExceedsLimit\",\"`%s'\",image->filename);\n      status=MagickFalse;\n    }\n  else\n    {\n      for (i=1; i < (ssize_t) count; i++)\n      {\n        annotate_info->text=textlist[i];\n        status=GetTypeMetrics(image,annotate_info,&extent,exception);\n        if (status == MagickFalse)\n          break;\n        if (extent.width > metrics->width)\n          *metrics=extent;\n        if (AcquireMagickResource(WidthResource,extent.width) == MagickFalse)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n              \"WidthOrHeightExceedsLimit\",\"`%s'\",image->filename);\n            status=MagickFalse;\n            break;\n          }\n      }\n      metrics->height=(double) height;\n    }\n  /*\n    Relinquish resources.\n  */\n  annotate_info->text=(char *) NULL;\n  annotate_info=DestroyDrawInfo(annotate_info);\n  for (i=0; i < (ssize_t) count; i++)\n    textlist[i]=DestroyString(textlist[i]);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t T y p e M e t r i c s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetTypeMetrics() returns the following information for the specified font\n%  and text:\n%\n%    character width\n%    character height\n%    ascender\n%    descender\n%    text width\n%    text height\n%    maximum horizontal advance\n%    bounds: x1\n%    bounds: y1\n%    bounds: x2\n%    bounds: y2\n%    origin: x\n%    origin: y\n%    underline position\n%    underline thickness\n%\n%  The format of the GetTypeMetrics method is:\n%\n%      MagickBooleanType GetTypeMetrics(Image *image,const DrawInfo *draw_info,\n%        TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o metrics: Return the font metrics in this structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetTypeMetrics(Image *image,\n  const DrawInfo *draw_info,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->text != (char *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->render=MagickFalse;\n  annotate_info->direction=UndefinedDirection;\n  (void) memset(metrics,0,sizeof(*metrics));\n  offset.x=0.0;\n  offset.y=0.0;\n  status=RenderType(image,annotate_info,&offset,metrics,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\"Metrics: text: %s; \"\n      \"width: %g; height: %g; ascent: %g; descent: %g; max advance: %g; \"\n      \"bounds: %g,%g  %g,%g; origin: %g,%g; pixels per em: %g,%g; \"\n      \"underline position: %g; underline thickness: %g\",annotate_info->text,\n      metrics->width,metrics->height,metrics->ascent,metrics->descent,\n      metrics->max_advance,metrics->bounds.x1,metrics->bounds.y1,\n      metrics->bounds.x2,metrics->bounds.y2,metrics->origin.x,metrics->origin.y,\n      metrics->pixels_per_em.x,metrics->pixels_per_em.y,\n      metrics->underline_position,metrics->underline_thickness);\n  annotate_info=DestroyDrawInfo(annotate_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r T y p e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderType() renders text on the image.  It also returns the bounding box of\n%  the text relative to the image.\n%\n%  The format of the RenderType method is:\n%\n%      MagickBooleanType RenderType(Image *image,DrawInfo *draw_info,\n%        const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType RenderType(Image *image,const DrawInfo *draw_info,\n  const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  const TypeInfo\n    *type_info;\n\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  type_info=(const TypeInfo *) NULL;\n  if (draw_info->font != (char *) NULL)\n    {\n      if (*draw_info->font == '@')\n        {\n          status=RenderFreetype(image,draw_info,draw_info->encoding,offset,\n            metrics,exception);\n          return(status);\n        }\n      if (*draw_info->font == '-')\n        return(RenderX11(image,draw_info,offset,metrics,exception));\n      if (*draw_info->font == '^')\n        return(RenderPostscript(image,draw_info,offset,metrics,exception));\n      if (IsPathAccessible(draw_info->font) != MagickFalse)\n        {\n          status=RenderFreetype(image,draw_info,draw_info->encoding,offset,\n            metrics,exception);\n          return(status);\n        }\n      type_info=GetTypeInfo(draw_info->font,exception);\n      if (type_info == (const TypeInfo *) NULL)\n        (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n          \"UnableToReadFont\",\"`%s'\",draw_info->font);\n    }\n  if ((type_info == (const TypeInfo *) NULL) &&\n      (draw_info->family != (const char *) NULL))\n    {\n      type_info=GetTypeInfoByFamily(draw_info->family,draw_info->style,\n        draw_info->stretch,draw_info->weight,exception);\n      if (type_info == (const TypeInfo *) NULL)\n        {\n          char\n            **family;\n\n          int\n            number_families;\n\n          register ssize_t\n            i;\n\n          /*\n            Parse font family list.\n          */\n          family=StringToArgv(draw_info->family,&number_families);\n          for (i=1; i < (ssize_t) number_families; i++)\n          {\n            type_info=GetTypeInfoByFamily(family[i],draw_info->style,\n              draw_info->stretch,draw_info->weight,exception);\n            if (type_info != (const TypeInfo *) NULL)\n              break;\n          }\n          for (i=0; i < (ssize_t) number_families; i++)\n            family[i]=DestroyString(family[i]);\n          family=(char **) RelinquishMagickMemory(family);\n          if (type_info == (const TypeInfo *) NULL)\n            (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n              \"UnableToReadFont\",\"`%s'\",draw_info->family);\n        }\n    }\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Arial\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Helvetica\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Century Schoolbook\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Sans\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily((const char *) NULL,draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfo(\"*\",exception);\n  if (type_info == (const TypeInfo *) NULL)\n    {\n      status=RenderFreetype(image,draw_info,draw_info->encoding,offset,metrics,\n        exception);\n      return(status);\n    }\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->face=type_info->face;\n  if (type_info->metrics != (char *) NULL)\n    (void) CloneString(&annotate_info->metrics,type_info->metrics);\n  if (type_info->glyphs != (char *) NULL)\n    (void) CloneString(&annotate_info->font,type_info->glyphs);\n  status=RenderFreetype(image,annotate_info,type_info->encoding,offset,metrics,\n    exception);\n  annotate_info=DestroyDrawInfo(annotate_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r F r e e t y p e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderFreetype() renders text on the image with a Truetype font.  It also\n%  returns the bounding box of the text relative to the image.\n%\n%  The format of the RenderFreetype method is:\n%\n%      MagickBooleanType RenderFreetype(Image *image,DrawInfo *draw_info,\n%        const char *encoding,const PointInfo *offset,TypeMetric *metrics,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o encoding: the font encoding.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FREETYPE_DELEGATE)\n\nstatic size_t ComplexTextLayout(const Image *image,const DrawInfo *draw_info,\n  const char *text,const size_t length,const FT_Face face,const FT_Int32 flags,\n  GraphemeInfo **grapheme,ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_RAQM_DELEGATE)\n  const char\n    *features;\n\n  raqm_t\n    *rq;\n\n  raqm_glyph_t\n    *glyphs;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent;\n\n  extent=0;\n  rq=raqm_create();\n  if (rq == (raqm_t *) NULL)\n    goto cleanup;\n  if (raqm_set_text_utf8(rq,text,length) == 0)\n    goto cleanup;\n  if (raqm_set_par_direction(rq,(raqm_direction_t) draw_info->direction) == 0)\n    goto cleanup;\n  if (raqm_set_freetype_face(rq,face) == 0)\n    goto cleanup;\n  features=GetImageProperty(image,\"type:features\",exception);\n  if (features != (const char *) NULL)\n    {\n      char\n        breaker,\n        quote,\n        *token;\n\n      int\n        next,\n        status_token;\n\n      TokenInfo\n        *token_info;\n\n      next=0;\n      token_info=AcquireTokenInfo();\n      token=AcquireString(\"\");\n      status_token=Tokenizer(token_info,0,token,50,features,\"\",\",\",\"\",'\\0',\n        &breaker,&next,&quote);\n      while (status_token == 0)\n      {\n        raqm_add_font_feature(rq,token,strlen(token));\n        status_token=Tokenizer(token_info,0,token,50,features,\"\",\",\",\"\",'\\0',\n          &breaker,&next,&quote);\n      }\n      token_info=DestroyTokenInfo(token_info);\n      token=DestroyString(token);\n    }\n  if (raqm_layout(rq) == 0)\n    goto cleanup;\n  glyphs=raqm_get_glyphs(rq,&extent);\n  if (glyphs == (raqm_glyph_t *) NULL)\n    {\n      extent=0;\n      goto cleanup;\n    }\n  *grapheme=(GraphemeInfo *) AcquireQuantumMemory(extent,sizeof(**grapheme));\n  if (*grapheme == (GraphemeInfo *) NULL)\n    {\n      extent=0;\n      goto cleanup;\n    }\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    (*grapheme)[i].index=glyphs[i].index;\n    (*grapheme)[i].x_offset=glyphs[i].x_offset;\n    (*grapheme)[i].x_advance=glyphs[i].x_advance;\n    (*grapheme)[i].y_offset=glyphs[i].y_offset;\n    (*grapheme)[i].cluster=glyphs[i].cluster;\n  }\n\ncleanup:\n  raqm_destroy(rq);\n  return(extent);\n#else\n  const char\n    *p;\n\n  FT_Error\n    ft_status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    last_glyph;\n\n  /*\n    Simple layout for bi-directional text (right-to-left or left-to-right).\n  */\n  magick_unreferenced(image);\n  magick_unreferenced(exception);\n  *grapheme=(GraphemeInfo *) AcquireQuantumMemory(length+1,sizeof(**grapheme));\n  if (*grapheme == (GraphemeInfo *) NULL)\n    return(0);\n  last_glyph=0;\n  p=text;\n  for (i=0; GetUTFCode(p) != 0; p+=GetUTFOctets(p), i++)\n  {\n    (*grapheme)[i].index=(ssize_t) FT_Get_Char_Index(face,GetUTFCode(p));\n    (*grapheme)[i].x_offset=0;\n    (*grapheme)[i].y_offset=0;\n    if (((*grapheme)[i].index != 0) && (last_glyph != 0))\n      {\n        if (FT_HAS_KERNING(face))\n          {\n            FT_Vector\n              kerning;\n\n            ft_status=FT_Get_Kerning(face,(FT_UInt) last_glyph,(FT_UInt)\n              (*grapheme)[i].index,ft_kerning_default,&kerning);\n            if (ft_status == 0)\n              (*grapheme)[i-1].x_advance+=(FT_Pos) ((draw_info->direction ==\n                RightToLeftDirection ? -1.0 : 1.0)*kerning.x);\n          }\n      }\n    ft_status=FT_Load_Glyph(face,(FT_UInt) (*grapheme)[i].index,flags);\n    (*grapheme)[i].x_advance=face->glyph->advance.x;\n    (*grapheme)[i].cluster=p-text;\n    last_glyph=(*grapheme)[i].index;\n  }\n  return((size_t) i);\n#endif\n}\n\nstatic int TraceCubicBezier(FT_Vector *p,FT_Vector *q,FT_Vector *to,\n  DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"C%g,%g %g,%g %g,%g\",\n    affine.tx+p->x/64.0,affine.ty-p->y/64.0,affine.tx+q->x/64.0,affine.ty-\n    q->y/64.0,affine.tx+to->x/64.0,affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic int TraceLineTo(FT_Vector *to,DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"L%g,%g\",affine.tx+to->x/64.0,\n    affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic int TraceMoveTo(FT_Vector *to,DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"M%g,%g\",affine.tx+to->x/64.0,\n    affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic int TraceQuadraticBezier(FT_Vector *control,FT_Vector *to,\n  DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"Q%g,%g %g,%g\",affine.tx+\n    control->x/64.0,affine.ty-control->y/64.0,affine.tx+to->x/64.0,affine.ty-\n    to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,\n  const char *encoding,const PointInfo *offset,TypeMetric *metrics,\n  ExceptionInfo *exception)\n{\n#if !defined(FT_OPEN_PATHNAME)\n#define FT_OPEN_PATHNAME  ft_open_pathname\n#endif\n\n  typedef struct _GlyphInfo\n  {\n    FT_UInt\n      id;\n\n    FT_Vector\n      origin;\n\n    FT_Glyph\n      image;\n  } GlyphInfo;\n\n  const char\n    *value;\n\n  DrawInfo\n    *annotate_info;\n\n  FT_BBox\n    bounds;\n\n  FT_BitmapGlyph\n    bitmap;\n\n  FT_Encoding\n    encoding_type;\n\n  FT_Error\n    ft_status;\n\n  FT_Face\n    face;\n\n  FT_Int32\n    flags;\n\n  FT_Library\n    library;\n\n  FT_Matrix\n    affine;\n\n  FT_Open_Args\n    args;\n\n  FT_Vector\n    origin;\n\n  GlyphInfo\n    glyph,\n    last_glyph;\n\n  GraphemeInfo\n    *grapheme;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    point,\n    resolution;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    code,\n    y;\n\n  static FT_Outline_Funcs\n    OutlineMethods =\n    {\n      (FT_Outline_MoveTo_Func) TraceMoveTo,\n      (FT_Outline_LineTo_Func) TraceLineTo,\n      (FT_Outline_ConicTo_Func) TraceQuadraticBezier,\n      (FT_Outline_CubicTo_Func) TraceCubicBezier,\n      0, 0\n    };\n\n  unsigned char\n    *utf8;\n\n  /*\n    Initialize Truetype library.\n  */\n  ft_status=FT_Init_FreeType(&library);\n  if (ft_status != 0)\n    ThrowBinaryException(TypeError,\"UnableToInitializeFreetypeLibrary\",\n      image->filename);\n  args.flags=FT_OPEN_PATHNAME;\n  if (draw_info->font == (char *) NULL)\n    args.pathname=ConstantString(\"helvetica\");\n  else\n    if (*draw_info->font != '@')\n      args.pathname=ConstantString(draw_info->font);\n    else\n      args.pathname=ConstantString(draw_info->font+1);\n  face=(FT_Face) NULL;\n  ft_status=FT_Open_Face(library,&args,(long) draw_info->face,&face);\n  if (ft_status != 0)\n    {\n      (void) FT_Done_FreeType(library);\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeError,\n        \"UnableToReadFont\",\"`%s'\",args.pathname);\n      args.pathname=DestroyString(args.pathname);\n      return(MagickFalse);\n    }\n  args.pathname=DestroyString(args.pathname);\n  if ((draw_info->metrics != (char *) NULL) &&\n      (IsPathAccessible(draw_info->metrics) != MagickFalse))\n    (void) FT_Attach_File(face,draw_info->metrics);\n  encoding_type=FT_ENCODING_UNICODE;\n  ft_status=FT_Select_Charmap(face,encoding_type);\n  if ((ft_status != 0) && (face->num_charmaps != 0))\n    ft_status=FT_Set_Charmap(face,face->charmaps[0]);\n  if (encoding != (const char *) NULL)\n    {\n      if (LocaleCompare(encoding,\"AdobeCustom\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_CUSTOM;\n      if (LocaleCompare(encoding,\"AdobeExpert\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_EXPERT;\n      if (LocaleCompare(encoding,\"AdobeStandard\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_STANDARD;\n      if (LocaleCompare(encoding,\"AppleRoman\") == 0)\n        encoding_type=FT_ENCODING_APPLE_ROMAN;\n      if (LocaleCompare(encoding,\"BIG5\") == 0)\n        encoding_type=FT_ENCODING_BIG5;\n#if defined(FT_ENCODING_PRC)\n      if (LocaleCompare(encoding,\"GB2312\") == 0)\n        encoding_type=FT_ENCODING_PRC;\n#endif\n#if defined(FT_ENCODING_JOHAB)\n      if (LocaleCompare(encoding,\"Johab\") == 0)\n        encoding_type=FT_ENCODING_JOHAB;\n#endif\n#if defined(FT_ENCODING_ADOBE_LATIN_1)\n      if (LocaleCompare(encoding,\"Latin-1\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_LATIN_1;\n#endif\n#if defined(FT_ENCODING_ADOBE_LATIN_2)\n      if (LocaleCompare(encoding,\"Latin-2\") == 0)\n        encoding_type=FT_ENCODING_OLD_LATIN_2;\n#endif\n      if (LocaleCompare(encoding,\"None\") == 0)\n        encoding_type=FT_ENCODING_NONE;\n      if (LocaleCompare(encoding,\"SJIScode\") == 0)\n        encoding_type=FT_ENCODING_SJIS;\n      if (LocaleCompare(encoding,\"Symbol\") == 0)\n        encoding_type=FT_ENCODING_MS_SYMBOL;\n      if (LocaleCompare(encoding,\"Unicode\") == 0)\n        encoding_type=FT_ENCODING_UNICODE;\n      if (LocaleCompare(encoding,\"Wansung\") == 0)\n        encoding_type=FT_ENCODING_WANSUNG;\n      ft_status=FT_Select_Charmap(face,encoding_type);\n      if (ft_status != 0)\n        {\n          (void) FT_Done_Face(face);\n          (void) FT_Done_FreeType(library);\n          ThrowBinaryException(TypeError,\"UnrecognizedFontEncoding\",encoding);\n        }\n    }\n  /*\n    Set text size.\n  */\n  resolution.x=DefaultResolution;\n  resolution.y=DefaultResolution;\n  if (draw_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        geometry_flags;\n\n      geometry_flags=ParseGeometry(draw_info->density,&geometry_info);\n      resolution.x=geometry_info.rho;\n      resolution.y=geometry_info.sigma;\n      if ((geometry_flags & SigmaValue) == 0)\n        resolution.y=resolution.x;\n    }\n  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (64.0*draw_info->pointsize),\n    (FT_F26Dot6) (64.0*draw_info->pointsize),(FT_UInt) resolution.x,\n    (FT_UInt) resolution.y);\n  if (ft_status != 0)\n    {\n      (void) FT_Done_Face(face);\n      (void) FT_Done_FreeType(library);\n      ThrowBinaryException(TypeError,\"UnableToReadFont\",draw_info->font);\n    }\n  metrics->pixels_per_em.x=face->size->metrics.x_ppem;\n  metrics->pixels_per_em.y=face->size->metrics.y_ppem;\n  metrics->ascent=(double) face->size->metrics.ascender/64.0;\n  metrics->descent=(double) face->size->metrics.descender/64.0;\n  metrics->width=0;\n  metrics->origin.x=0;\n  metrics->origin.y=0;\n  metrics->height=(double) face->size->metrics.height/64.0;\n  metrics->max_advance=0.0;\n  if (face->size->metrics.max_advance > MagickEpsilon)\n    metrics->max_advance=(double) face->size->metrics.max_advance/64.0;\n  metrics->bounds.x1=0.0;\n  metrics->bounds.y1=metrics->descent;\n  metrics->bounds.x2=metrics->ascent+metrics->descent;\n  metrics->bounds.y2=metrics->ascent+metrics->descent;\n  metrics->underline_position=face->underline_position/64.0;\n  metrics->underline_thickness=face->underline_thickness/64.0;\n  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\\0'))\n    {\n      (void) FT_Done_Face(face);\n      (void) FT_Done_FreeType(library);\n      return(MagickTrue);\n    }\n  /*\n    Compute bounding box.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\"Font %s; \"\n      \"font-encoding %s; text-encoding %s; pointsize %g\",\n      draw_info->font != (char *) NULL ? draw_info->font : \"none\",\n      encoding != (char *) NULL ? encoding : \"none\",\n      draw_info->encoding != (char *) NULL ? draw_info->encoding : \"none\",\n      draw_info->pointsize);\n  flags=FT_LOAD_DEFAULT;\n  if (draw_info->render == MagickFalse)\n    flags=FT_LOAD_NO_BITMAP;\n  if (draw_info->text_antialias == MagickFalse)\n    flags|=FT_LOAD_TARGET_MONO;\n  else\n    {\n#if defined(FT_LOAD_TARGET_LIGHT)\n      flags|=FT_LOAD_TARGET_LIGHT;\n#elif defined(FT_LOAD_TARGET_LCD)\n      flags|=FT_LOAD_TARGET_LCD;\n#endif\n    }\n  value=GetImageProperty(image,\"type:hinting\",exception);\n  if ((value != (const char *) NULL) && (LocaleCompare(value,\"off\") == 0))\n    flags|=FT_LOAD_NO_HINTING;\n  glyph.id=0;\n  glyph.image=NULL;\n  last_glyph.id=0;\n  last_glyph.image=NULL;\n  origin.x=0;\n  origin.y=0;\n  affine.xx=65536L;\n  affine.yx=0L;\n  affine.xy=0L;\n  affine.yy=65536L;\n  if (draw_info->render != MagickFalse)\n    {\n      affine.xx=(FT_Fixed) (65536L*draw_info->affine.sx+0.5);\n      affine.yx=(FT_Fixed) (-65536L*draw_info->affine.rx+0.5);\n      affine.xy=(FT_Fixed) (-65536L*draw_info->affine.ry+0.5);\n      affine.yy=(FT_Fixed) (65536L*draw_info->affine.sy+0.5);\n    }\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  if (annotate_info->dash_pattern != (double *) NULL)\n    annotate_info->dash_pattern[0]=0.0;\n  (void) CloneString(&annotate_info->primitive,\"path '\");\n  status=MagickTrue;\n  if (draw_info->render != MagickFalse)\n    {\n      if (image->storage_class != DirectClass)\n        (void) SetImageStorageClass(image,DirectClass,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n    }\n  point.x=0.0;\n  point.y=0.0;\n  for (p=draw_info->text; GetUTFCode(p) != 0; p+=GetUTFOctets(p))\n    if (GetUTFCode(p) < 0)\n      break;\n  utf8=(unsigned char *) NULL;\n  if (GetUTFCode(p) == 0)\n    p=draw_info->text;\n  else\n    {\n      utf8=ConvertLatin1ToUTF8((unsigned char *) draw_info->text);\n      if (utf8 != (unsigned char *) NULL)\n        p=(char *) utf8;\n    }\n  grapheme=(GraphemeInfo *) NULL;\n  length=ComplexTextLayout(image,draw_info,p,strlen(p),face,flags,&grapheme,\n    exception);\n  code=0;\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    FT_Outline\n      outline;\n\n    /*\n      Render UTF-8 sequence.\n    */\n    glyph.id=(FT_UInt) grapheme[i].index;\n    if (glyph.id == 0)\n      glyph.id=FT_Get_Char_Index(face,' ');\n    if ((glyph.id != 0) && (last_glyph.id != 0))\n      origin.x+=(FT_Pos) (64.0*draw_info->kerning);\n    glyph.origin=origin;\n    glyph.origin.x+=(FT_Pos) grapheme[i].x_offset;\n    glyph.origin.y+=(FT_Pos) grapheme[i].y_offset;\n    glyph.image=0;\n    ft_status=FT_Load_Glyph(face,glyph.id,flags);\n    if (ft_status != 0)\n      continue;\n    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);\n    if (ft_status != 0)\n      continue;\n    outline=((FT_OutlineGlyph) glyph.image)->outline;\n    ft_status=FT_Outline_Get_BBox(&outline,&bounds);\n    if (ft_status != 0)\n      continue;\n    if ((p == draw_info->text) || (bounds.xMin < metrics->bounds.x1))\n      if (bounds.xMin != 0)\n        metrics->bounds.x1=(double) bounds.xMin;\n    if ((p == draw_info->text) || (bounds.yMin < metrics->bounds.y1))\n      if (bounds.yMin != 0)\n        metrics->bounds.y1=(double) bounds.yMin;\n    if ((p == draw_info->text) || (bounds.xMax > metrics->bounds.x2))\n      if (bounds.xMax != 0)\n        metrics->bounds.x2=(double) bounds.xMax;\n    if ((p == draw_info->text) || (bounds.yMax > metrics->bounds.y2))\n      if (bounds.yMax != 0)\n        metrics->bounds.y2=(double) bounds.yMax;\n    if (((draw_info->stroke.alpha != TransparentAlpha) ||\n         (draw_info->stroke_pattern != (Image *) NULL)) &&\n        ((status != MagickFalse) && (draw_info->render != MagickFalse)))\n      {\n        /*\n          Trace the glyph.\n        */\n        annotate_info->affine.tx=glyph.origin.x/64.0;\n        annotate_info->affine.ty=(-glyph.origin.y/64.0);\n        if ((outline.n_contours > 0) && (outline.n_points > 0))\n          ft_status=FT_Outline_Decompose(&outline,&OutlineMethods,\n            annotate_info);\n      }\n    FT_Vector_Transform(&glyph.origin,&affine);\n    (void) FT_Glyph_Transform(glyph.image,&affine,&glyph.origin);\n    ft_status=FT_Glyph_To_Bitmap(&glyph.image,ft_render_mode_normal,\n      (FT_Vector *) NULL,MagickTrue);\n    if (ft_status != 0)\n      continue;\n    bitmap=(FT_BitmapGlyph) glyph.image;\n    point.x=offset->x+bitmap->left;\n    if (bitmap->bitmap.pixel_mode == ft_pixel_mode_mono)\n      point.x=offset->x+(origin.x >> 6);\n    point.y=offset->y-bitmap->top;\n    if (draw_info->render != MagickFalse)\n      {\n        CacheView\n          *image_view;\n\n        MagickBooleanType\n          transparent_fill;\n\n        register unsigned char\n          *r;\n\n        /*\n          Rasterize the glyph.\n        */\n        transparent_fill=((draw_info->fill.alpha == TransparentAlpha) &&\n          (draw_info->fill_pattern == (Image *) NULL) &&\n          (draw_info->stroke.alpha == TransparentAlpha) &&\n          (draw_info->stroke_pattern == (Image *) NULL)) ? MagickTrue :\n          MagickFalse;\n        image_view=AcquireAuthenticCacheView(image,exception);\n        r=bitmap->bitmap.buffer;\n        for (y=0; y < (ssize_t) bitmap->bitmap.rows; y++)\n        {\n          double\n            fill_opacity;\n\n          MagickBooleanType\n            active,\n            sync;\n\n          PixelInfo\n            fill_color;\n\n          register Quantum\n            *magick_restrict q;\n\n          register ssize_t\n            x;\n\n          ssize_t\n            n,\n            x_offset,\n            y_offset;\n\n          if (status == MagickFalse)\n            continue;\n          x_offset=(ssize_t) ceil(point.x-0.5);\n          y_offset=(ssize_t) ceil(point.y+y-0.5);\n          if ((y_offset < 0) || (y_offset >= (ssize_t) image->rows))\n            continue;\n          q=(Quantum *) NULL;\n          if ((x_offset < 0) || (x_offset >= (ssize_t) image->columns))\n            active=MagickFalse;\n          else\n            {\n              q=GetCacheViewAuthenticPixels(image_view,x_offset,y_offset,\n                bitmap->bitmap.width,1,exception);\n              active=q != (Quantum *) NULL ? MagickTrue : MagickFalse;\n            }\n          n=y*bitmap->bitmap.pitch-1;\n          for (x=0; x < (ssize_t) bitmap->bitmap.width; x++)\n          {\n            n++;\n            x_offset++;\n            if ((x_offset < 0) || (x_offset >= (ssize_t) image->columns))\n              {\n                if (q != (Quantum *) NULL)\n                  q+=GetPixelChannels(image);\n                continue;\n              }\n            if (bitmap->bitmap.pixel_mode != ft_pixel_mode_mono)\n              fill_opacity=(double) (r[n])/(bitmap->bitmap.num_grays-1);\n            else\n              fill_opacity=((r[(x >> 3)+y*bitmap->bitmap.pitch] &\n                (1 << (~x & 0x07)))) == 0 ? 0.0 : 1.0;\n            if (draw_info->text_antialias == MagickFalse)\n              fill_opacity=fill_opacity >= 0.5 ? 1.0 : 0.0;\n            if (active == MagickFalse)\n              q=GetCacheViewAuthenticPixels(image_view,x_offset,y_offset,1,1,\n                exception);\n            if (q == (Quantum *) NULL)\n              continue;\n            if (transparent_fill == MagickFalse)\n              {\n                GetPixelInfo(image,&fill_color);\n                GetFillColor(draw_info,x_offset,y_offset,&fill_color,exception);\n                fill_opacity=fill_opacity*fill_color.alpha;\n                CompositePixelOver(image,&fill_color,fill_opacity,q,\n                  GetPixelAlpha(image,q),q);\n              }\n            else\n              {\n                double\n                  Sa,\n                  Da;\n\n                Da=1.0-(QuantumScale*GetPixelAlpha(image,q));\n                Sa=fill_opacity;\n                fill_opacity=(1.0-RoundToUnity(Sa+Da-Sa*Da))*QuantumRange;\n                SetPixelAlpha(image,fill_opacity,q);\n              }\n            if (active == MagickFalse)\n              {\n                sync=SyncCacheViewAuthenticPixels(image_view,exception);\n                if (sync == MagickFalse)\n                  status=MagickFalse;\n              }\n            q+=GetPixelChannels(image);\n          }\n          sync=SyncCacheViewAuthenticPixels(image_view,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        image_view=DestroyCacheView(image_view);\n        if (((draw_info->stroke.alpha != TransparentAlpha) ||\n             (draw_info->stroke_pattern != (Image *) NULL)) &&\n            (status != MagickFalse))\n          {\n            /*\n              Draw text stroke.\n            */\n            annotate_info->linejoin=RoundJoin;\n            annotate_info->affine.tx=offset->x;\n            annotate_info->affine.ty=offset->y;\n            (void) ConcatenateString(&annotate_info->primitive,\"'\");\n            if (strlen(annotate_info->primitive) > 7)\n              (void) DrawImage(image,annotate_info,exception);\n            (void) CloneString(&annotate_info->primitive,\"path '\");\n          }\n      }\n    if ((fabs(draw_info->interword_spacing) >= MagickEpsilon) &&\n        (IsUTFSpace(GetUTFCode(p+grapheme[i].cluster)) != MagickFalse) &&\n        (IsUTFSpace(code) == MagickFalse))\n      origin.x+=(FT_Pos) (64.0*draw_info->interword_spacing);\n    else\n      origin.x+=(FT_Pos) grapheme[i].x_advance;\n    metrics->origin.x=(double) origin.x;\n    metrics->origin.y=(double) origin.y;\n    if (metrics->origin.x > metrics->width)\n      metrics->width=metrics->origin.x;\n    if (last_glyph.image != 0)\n      {\n        FT_Done_Glyph(last_glyph.image);\n        last_glyph.image=0;\n      }\n    last_glyph=glyph;\n    code=GetUTFCode(p+grapheme[i].cluster);\n  }\n  if (grapheme != (GraphemeInfo *) NULL)\n    grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);\n  if (utf8 != (unsigned char *) NULL)\n    utf8=(unsigned char *) RelinquishMagickMemory(utf8);\n  if (glyph.image != 0)\n    {\n      FT_Done_Glyph(glyph.image);\n      glyph.image=0;\n    }\n  /*\n    Determine font metrics.\n  */\n  metrics->bounds.x1/=64.0;\n  metrics->bounds.y1/=64.0;\n  metrics->bounds.x2/=64.0;\n  metrics->bounds.y2/=64.0;\n  metrics->origin.x/=64.0;\n  metrics->origin.y/=64.0;\n  metrics->width/=64.0;\n  /*\n    Relinquish resources.\n  */\n  annotate_info=DestroyDrawInfo(annotate_info);\n  (void) FT_Done_Face(face);\n  (void) FT_Done_FreeType(library);\n  return(status);\n}\n#else\nstatic MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,\n  const char *magick_unused(encoding),const PointInfo *offset,\n  TypeMetric *metrics,ExceptionInfo *exception)\n{\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"'%s' (Freetype)\",\n    draw_info->font != (char *) NULL ? draw_info->font : \"none\");\n  return(RenderPostscript(image,draw_info,offset,metrics,exception));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r P o s t s c r i p t                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderPostscript() renders text on the image with a Postscript font.  It\n%  also returns the bounding box of the text relative to the image.\n%\n%  The format of the RenderPostscript method is:\n%\n%      MagickBooleanType RenderPostscript(Image *image,DrawInfo *draw_info,\n%        const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic char *EscapeParenthesis(const char *source)\n{\n  char\n    *destination;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  size_t\n    length;\n\n  assert(source != (const char *) NULL);\n  length=0;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      {\n        if (~length < 1)\n          ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n        length++;\n      }\n    length++;\n  }\n  destination=(char *) NULL;\n  if (~length >= (MagickPathExtent-1))\n    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n      sizeof(*destination));\n  if (destination == (char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n  *destination='\\0';\n  q=destination;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      *q++='\\\\';\n    *q++=(*p);\n  }\n  *q='\\0';\n  return(destination);\n}\n\nstatic MagickBooleanType RenderPostscript(Image *image,\n  const DrawInfo *draw_info,const PointInfo *offset,TypeMetric *metrics,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *text;\n\n  FILE\n    *file;\n\n  Image\n    *annotate_image;\n\n  ImageInfo\n    *annotate_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    identity;\n\n  PointInfo\n    extent,\n    point,\n    resolution;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  /*\n    Render label with a Postscript font.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\n      \"Font %s; pointsize %g\",draw_info->font != (char *) NULL ?\n      draw_info->font : \"none\",draw_info->pointsize);\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleFile(file,\"%%!PS-Adobe-3.0\\n\");\n  (void) FormatLocaleFile(file,\"/ReencodeType\\n\");\n  (void) FormatLocaleFile(file,\"{\\n\");\n  (void) FormatLocaleFile(file,\"  findfont dup length\\n\");\n  (void) FormatLocaleFile(file,\n    \"  dict begin { 1 index /FID ne {def} {pop pop} ifelse } forall\\n\");\n  (void) FormatLocaleFile(file,\n    \"  /Encoding ISOLatin1Encoding def currentdict end definefont pop\\n\");\n  (void) FormatLocaleFile(file,\"} bind def\\n\");\n  /*\n    Sample to compute bounding box.\n  */\n  identity=(fabs(draw_info->affine.sx-draw_info->affine.sy) < MagickEpsilon) &&\n    (fabs(draw_info->affine.rx) < MagickEpsilon) &&\n    (fabs(draw_info->affine.ry) < MagickEpsilon) ? MagickTrue : MagickFalse;\n  extent.x=0.0;\n  extent.y=0.0;\n  length=strlen(draw_info->text);\n  for (i=0; i <= (ssize_t) (length+2); i++)\n  {\n    point.x=fabs(draw_info->affine.sx*i*draw_info->pointsize+\n      draw_info->affine.ry*2.0*draw_info->pointsize);\n    point.y=fabs(draw_info->affine.rx*i*draw_info->pointsize+\n      draw_info->affine.sy*2.0*draw_info->pointsize);\n    if (point.x > extent.x)\n      extent.x=point.x;\n    if (point.y > extent.y)\n      extent.y=point.y;\n  }\n  (void) FormatLocaleFile(file,\"%g %g moveto\\n\",identity  != MagickFalse ? 0.0 :\n    extent.x/2.0,extent.y/2.0);\n  (void) FormatLocaleFile(file,\"%g %g scale\\n\",draw_info->pointsize,\n    draw_info->pointsize);\n  if ((draw_info->font == (char *) NULL) || (*draw_info->font == '\\0') ||\n      (strchr(draw_info->font,'/') != (char *) NULL))\n    (void) FormatLocaleFile(file,\n      \"/Times-Roman-ISO dup /Times-Roman ReencodeType findfont setfont\\n\");\n  else\n    (void) FormatLocaleFile(file,\n      \"/%s-ISO dup /%s ReencodeType findfont setfont\\n\",draw_info->font,\n      draw_info->font);\n  (void) FormatLocaleFile(file,\"[%g %g %g %g 0 0] concat\\n\",\n    draw_info->affine.sx,-draw_info->affine.rx,-draw_info->affine.ry,\n    draw_info->affine.sy);\n  text=EscapeParenthesis(draw_info->text);\n  if (identity == MagickFalse)\n    (void) FormatLocaleFile(file,\"(%s) stringwidth pop -0.5 mul -0.5 rmoveto\\n\",\n      text);\n  (void) FormatLocaleFile(file,\"(%s) show\\n\",text);\n  text=DestroyString(text);\n  (void) FormatLocaleFile(file,\"showpage\\n\");\n  (void) fclose(file);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g+0+0!\",\n    floor(extent.x+0.5),floor(extent.y+0.5));\n  annotate_info=AcquireImageInfo();\n  (void) FormatLocaleString(annotate_info->filename,MagickPathExtent,\"ps:%s\",\n    filename);\n  (void) CloneString(&annotate_info->page,geometry);\n  if (draw_info->density != (char *) NULL)\n    (void) CloneString(&annotate_info->density,draw_info->density);\n  annotate_info->antialias=draw_info->text_antialias;\n  annotate_image=ReadImage(annotate_info,exception);\n  CatchException(exception);\n  annotate_info=DestroyImageInfo(annotate_info);\n  (void) RelinquishUniqueFileResource(filename);\n  if (annotate_image == (Image *) NULL)\n    return(MagickFalse);\n  (void) NegateImage(annotate_image,MagickFalse,exception);\n  resolution.x=DefaultResolution;\n  resolution.y=DefaultResolution;\n  if (draw_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(draw_info->density,&geometry_info);\n      resolution.x=geometry_info.rho;\n      resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        resolution.y=resolution.x;\n    }\n  if (identity == MagickFalse)\n    (void) TransformImage(&annotate_image,\"0x0\",(char *) NULL,exception);\n  else\n    {\n      RectangleInfo\n        crop_info;\n\n      crop_info=GetImageBoundingBox(annotate_image,exception);\n      crop_info.height=(size_t) ((resolution.y/DefaultResolution)*\n        ExpandAffine(&draw_info->affine)*draw_info->pointsize+0.5);\n      crop_info.y=(ssize_t) ceil((resolution.y/DefaultResolution)*extent.y/8.0-\n        0.5);\n      (void) FormatLocaleString(geometry,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) crop_info.width,(double)\n        crop_info.height,(double) crop_info.x,(double) crop_info.y);\n      (void) TransformImage(&annotate_image,geometry,(char *) NULL,exception);\n    }\n  metrics->pixels_per_em.x=(resolution.y/DefaultResolution)*\n    ExpandAffine(&draw_info->affine)*draw_info->pointsize;\n  metrics->pixels_per_em.y=metrics->pixels_per_em.x;\n  metrics->ascent=metrics->pixels_per_em.x;\n  metrics->descent=metrics->pixels_per_em.y/-5.0;\n  metrics->width=(double) annotate_image->columns/\n    ExpandAffine(&draw_info->affine);\n  metrics->height=1.152*metrics->pixels_per_em.x;\n  metrics->max_advance=metrics->pixels_per_em.x;\n  metrics->bounds.x1=0.0;\n  metrics->bounds.y1=metrics->descent;\n  metrics->bounds.x2=metrics->ascent+metrics->descent;\n  metrics->bounds.y2=metrics->ascent+metrics->descent;\n  metrics->underline_position=(-2.0);\n  metrics->underline_thickness=1.0;\n  if (draw_info->render == MagickFalse)\n    {\n      annotate_image=DestroyImage(annotate_image);\n      return(MagickTrue);\n    }\n  if (draw_info->fill.alpha != TransparentAlpha)\n    {\n      CacheView\n        *annotate_view;\n\n      MagickBooleanType\n        sync;\n\n      PixelInfo\n        fill_color;\n\n      /*\n        Render fill color.\n      */\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      if (annotate_image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(annotate_image,OpaqueAlphaChannel,\n          exception);\n      fill_color=draw_info->fill;\n      annotate_view=AcquireAuthenticCacheView(annotate_image,exception);\n      for (y=0; y < (ssize_t) annotate_image->rows; y++)\n      {\n        register ssize_t\n          x;\n\n        register Quantum\n          *magick_restrict q;\n\n        q=GetCacheViewAuthenticPixels(annotate_view,0,y,annotate_image->columns,\n          1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) annotate_image->columns; x++)\n        {\n          GetFillColor(draw_info,x,y,&fill_color,exception);\n          SetPixelAlpha(annotate_image,ClampToQuantum((((double) QuantumScale*\n            GetPixelIntensity(annotate_image,q)*fill_color.alpha))),q);\n          SetPixelRed(annotate_image,fill_color.red,q);\n          SetPixelGreen(annotate_image,fill_color.green,q);\n          SetPixelBlue(annotate_image,fill_color.blue,q);\n          q+=GetPixelChannels(annotate_image);\n        }\n        sync=SyncCacheViewAuthenticPixels(annotate_view,exception);\n        if (sync == MagickFalse)\n          break;\n      }\n      annotate_view=DestroyCacheView(annotate_view);\n      (void) CompositeImage(image,annotate_image,OverCompositeOp,MagickTrue,\n        (ssize_t) ceil(offset->x-0.5),(ssize_t) ceil(offset->y-(metrics->ascent+\n        metrics->descent)-0.5),exception);\n    }\n  annotate_image=DestroyImage(annotate_image);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r X 1 1                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderX11() renders text on the image with an X11 font.  It also returns the\n%  bounding box of the text relative to the image.\n%\n%  The format of the RenderX11 method is:\n%\n%      MagickBooleanType RenderX11(Image *image,DrawInfo *draw_info,\n%        const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType RenderX11(Image *image,const DrawInfo *draw_info,\n  const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&annotate_semaphore);\n  LockSemaphoreInfo(annotate_semaphore);\n  status=XRenderImage(image,draw_info,offset,metrics,exception);\n  UnlockSemaphoreInfo(annotate_semaphore);\n  return(status);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               FFFFF   OOO   U   U  RRRR   IIIII  EEEEE  RRRR                %\n%               F      O   O  U   U  R   R    I    E      R   R               %\n%               FFF    O   O  U   U  RRRR     I    EEE    RRRR                %\n%               F      O   O  U   U  R R      I    E      R R                 %\n%               F       OOO    UUU   R  R   IIIII  EEEEE  R  R                %\n%                                                                             %\n%                                                                             %\n%                MagickCore Discrete Fourier Transform Methods                %\n%                                                                             %\n%                              Software Design                                %\n%                                Sean Burke                                   %\n%                               Fred Weinhaus                                 %\n%                                   Cristy                                    %\n%                                 July 2009                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/fourier.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#if defined(MAGICKCORE_FFTW_DELEGATE)\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n#include <complex.h>\n#endif\n#include <fftw3.h>\n#if !defined(MAGICKCORE_HAVE_CABS)\n#define cabs(z)  (sqrt(z[0]*z[0]+z[1]*z[1]))\n#endif\n#if !defined(MAGICKCORE_HAVE_CARG)\n#define carg(z)  (atan2(cimag(z),creal(z)))\n#endif\n#if !defined(MAGICKCORE_HAVE_CIMAG)\n#define cimag(z)  (z[1])\n#endif\n#if !defined(MAGICKCORE_HAVE_CREAL)\n#define creal(z)  (z[0])\n#endif\n#endif\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _FourierInfo\n{\n  PixelChannel\n    channel;\n\n  MagickBooleanType\n    modulus;\n\n  size_t\n    width,\n    height;\n\n  ssize_t\n    center;\n} FourierInfo;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C o m p l e x I m a g e s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ComplexImages() performs complex mathematics on an image sequence.\n%\n%  The format of the ComplexImages method is:\n%\n%      MagickBooleanType ComplexImages(Image *images,const ComplexOperator op,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o op: A complex operator.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n  ExceptionInfo *exception)\n{\n#define ComplexImageTag  \"Complex/Image\"\n\n  CacheView\n    *Ai_view,\n    *Ar_view,\n    *Bi_view,\n    *Br_view,\n    *Ci_view,\n    *Cr_view;\n\n  const char\n    *artifact;\n\n  const Image\n    *Ai_image,\n    *Ar_image,\n    *Bi_image,\n    *Br_image;\n\n  double\n    snr;\n\n  Image\n    *Ci_image,\n    *complex_images,\n    *Cr_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (images->next == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return(image);\n    }\n  image->depth=32UL;\n  complex_images=NewImageList();\n  AppendImageToList(&complex_images,image);\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    {\n      complex_images=DestroyImageList(complex_images);\n      return(complex_images);\n    }\n  AppendImageToList(&complex_images,image);\n  /*\n    Apply complex mathematics to image pixels.\n  */\n  artifact=GetImageArtifact(image,\"complex:snr\");\n  snr=0.0;\n  if (artifact != (const char *) NULL)\n    snr=StringToDouble(artifact,(char **) NULL);\n  Ar_image=images;\n  Ai_image=images->next;\n  Br_image=images;\n  Bi_image=images->next;\n  if ((images->next->next != (Image *) NULL) &&\n      (images->next->next->next != (Image *) NULL))\n    {\n      Br_image=images->next->next;\n      Bi_image=images->next->next->next;\n    }\n  Cr_image=complex_images;\n  Ci_image=complex_images->next;\n  Ar_view=AcquireVirtualCacheView(Ar_image,exception);\n  Ai_view=AcquireVirtualCacheView(Ai_image,exception);\n  Br_view=AcquireVirtualCacheView(Br_image,exception);\n  Bi_view=AcquireVirtualCacheView(Bi_image,exception);\n  Cr_view=AcquireAuthenticCacheView(Cr_image,exception);\n  Ci_view=AcquireAuthenticCacheView(Ci_image,exception);\n  status=MagickTrue;\n  progress=0;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(images,complex_images,images->rows,1L)\n#endif\n  for (y=0; y < (ssize_t) images->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict Ai,\n      *magick_restrict Ar,\n      *magick_restrict Bi,\n      *magick_restrict Br;\n\n    register Quantum\n      *magick_restrict Ci,\n      *magick_restrict Cr;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Ar_image->columns,1,exception);\n    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,Ai_image->columns,1,exception);\n    Br=GetCacheViewVirtualPixels(Br_view,0,y,Br_image->columns,1,exception);\n    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,Bi_image->columns,1,exception);\n    Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n    Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n    if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || \n        (Br == (const Quantum *) NULL) || (Bi == (const Quantum *) NULL) ||\n        (Cr == (Quantum *) NULL) || (Ci == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) images->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(images); i++)\n      {\n        switch (op)\n        {\n          case AddComplexOperator:\n          {\n            Cr[i]=Ar[i]+Br[i];\n            Ci[i]=Ai[i]+Bi[i];\n            break;\n          }\n          case ConjugateComplexOperator:\n          default:\n          {\n            Cr[i]=Ar[i];\n            Ci[i]=(-Bi[i]);\n            break;\n          }\n          case DivideComplexOperator:\n          {\n            double\n              gamma;\n\n            gamma=PerceptibleReciprocal(Br[i]*Br[i]+Bi[i]*Bi[i]+snr);\n            Cr[i]=gamma*(Ar[i]*Br[i]+Ai[i]*Bi[i]);\n            Ci[i]=gamma*(Ai[i]*Br[i]-Ar[i]*Bi[i]);\n            break;\n          }\n          case MagnitudePhaseComplexOperator:\n          {\n            Cr[i]=sqrt(Ar[i]*Ar[i]+Ai[i]*Ai[i]);\n            Ci[i]=atan2(Ai[i],Ar[i])/(2.0*MagickPI)+0.5;\n            break;\n          }\n          case MultiplyComplexOperator:\n          {\n            Cr[i]=QuantumScale*(Ar[i]*Br[i]-Ai[i]*Bi[i]);\n            Ci[i]=QuantumScale*(Ai[i]*Br[i]+Ar[i]*Bi[i]);\n            break;\n          }\n          case RealImaginaryComplexOperator:\n          {\n            Cr[i]=Ar[i]*cos(2.0*MagickPI*(Ai[i]-0.5));\n            Ci[i]=Ar[i]*sin(2.0*MagickPI*(Ai[i]-0.5));\n            break;\n          }\n          case SubtractComplexOperator:\n          {\n            Cr[i]=Ar[i]-Br[i];\n            Ci[i]=Ai[i]-Bi[i];\n            break;\n          }\n        }\n      }\n      Ar+=GetPixelChannels(Ar_image);\n      Ai+=GetPixelChannels(Ai_image);\n      Br+=GetPixelChannels(Br_image);\n      Bi+=GetPixelChannels(Bi_image);\n      Cr+=GetPixelChannels(Cr_image);\n      Ci+=GetPixelChannels(Ci_image);\n    }\n    if (SyncCacheViewAuthenticPixels(Ci_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (SyncCacheViewAuthenticPixels(Cr_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,ComplexImageTag,progress,images->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  Cr_view=DestroyCacheView(Cr_view);\n  Ci_view=DestroyCacheView(Ci_view);\n  Br_view=DestroyCacheView(Br_view);\n  Bi_view=DestroyCacheView(Bi_view);\n  Ar_view=DestroyCacheView(Ar_view);\n  Ai_view=DestroyCacheView(Ai_view);\n  if (status == MagickFalse)\n    complex_images=DestroyImageList(complex_images);\n  return(complex_images);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     F o r w a r d F o u r i e r T r a n s f o r m I m a g e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ForwardFourierTransformImage() implements the discrete Fourier transform\n%  (DFT) of the image either as a magnitude / phase or real / imaginary image\n%  pair.\n%\n%  The format of the ForwadFourierTransformImage method is:\n%\n%      Image *ForwardFourierTransformImage(const Image *image,\n%        const MagickBooleanType modulus,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o modulus: if true, return as transform as a magnitude / phase pair\n%      otherwise a real / imaginary image pair.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FFTW_DELEGATE)\n\nstatic MagickBooleanType RollFourier(const size_t width,const size_t height,\n  const ssize_t x_offset,const ssize_t y_offset,double *roll_pixels)\n{\n  double\n    *source_pixels;\n\n  MemoryInfo\n    *source_info;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    u,\n    v,\n    y;\n\n  /*\n    Move zero frequency (DC, average color) from (0,0) to (width/2,height/2).\n  */\n  source_info=AcquireVirtualMemory(width,height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    return(MagickFalse);\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  i=0L;\n  for (y=0L; y < (ssize_t) height; y++)\n  {\n    if (y_offset < 0L)\n      v=((y+y_offset) < 0L) ? y+y_offset+(ssize_t) height : y+y_offset;\n    else\n      v=((y+y_offset) > ((ssize_t) height-1L)) ? y+y_offset-(ssize_t) height :\n        y+y_offset;\n    for (x=0L; x < (ssize_t) width; x++)\n    {\n      if (x_offset < 0L)\n        u=((x+x_offset) < 0L) ? x+x_offset+(ssize_t) width : x+x_offset;\n      else\n        u=((x+x_offset) > ((ssize_t) width-1L)) ? x+x_offset-(ssize_t) width :\n          x+x_offset;\n      source_pixels[v*width+u]=roll_pixels[i++];\n    }\n  }\n  (void) memcpy(roll_pixels,source_pixels,height*width*\n    sizeof(*source_pixels));\n  source_info=RelinquishVirtualMemory(source_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ForwardQuadrantSwap(const size_t width,\n  const size_t height,double *source_pixels,double *forward_pixels)\n{\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Swap quadrants.\n  */\n  center=(ssize_t) (width/2L)+1L;\n  status=RollFourier((size_t) center,height,0L,(ssize_t) height/2L,\n    source_pixels);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[y*width+x+width/2L]=source_pixels[y*center+x];\n  for (y=1; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[(height-y)*width+width/2L-x-1L]=\n        source_pixels[y*center+x+1L];\n  for (x=0L; x < (ssize_t) (width/2L); x++)\n    forward_pixels[width/2L-x-1L]=source_pixels[x+1L];\n  return(MagickTrue);\n}\n\nstatic void CorrectPhaseLHS(const size_t width,const size_t height,\n  double *fourier_pixels)\n{\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      fourier_pixels[y*width+x]*=(-1.0);\n}\n\nstatic MagickBooleanType ForwardFourier(const FourierInfo *fourier_info,\n  Image *image,double *magnitude,double *phase,ExceptionInfo *exception)\n{\n  CacheView\n    *magnitude_view,\n    *phase_view;\n\n  double\n    *magnitude_pixels,\n    *phase_pixels;\n\n  Image\n    *magnitude_image,\n    *phase_image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *magnitude_info,\n    *phase_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    i,\n    y;\n\n  magnitude_image=GetFirstImageInList(image);\n  phase_image=GetNextImageInList(image);\n  if (phase_image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  /*\n    Create \"Fourier Transform\" image from constituent arrays.\n  */\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*phase_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL))\n    {\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (magnitude_info != (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  (void) memset(magnitude_pixels,0,fourier_info->width*\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  (void) memset(phase_pixels,0,fourier_info->width*\n    fourier_info->height*sizeof(*phase_pixels));\n  status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,\n    magnitude,magnitude_pixels);\n  if (status != MagickFalse)\n    status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,phase,\n      phase_pixels);\n  CorrectPhaseLHS(fourier_info->width,fourier_info->height,phase_pixels);\n  if (fourier_info->modulus != MagickFalse)\n    {\n      i=0L;\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->width; x++)\n        {\n          phase_pixels[i]/=(2.0*MagickPI);\n          phase_pixels[i]+=0.5;\n          i++;\n        }\n    }\n  magnitude_view=AcquireAuthenticCacheView(magnitude_image,exception);\n  i=0L;\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    q=GetCacheViewAuthenticPixels(magnitude_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          SetPixelRed(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          SetPixelGreen(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          SetPixelBlue(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          SetPixelBlack(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          SetPixelAlpha(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n      }\n      i++;\n      q+=GetPixelChannels(magnitude_image);\n    }\n    status=SyncCacheViewAuthenticPixels(magnitude_view,exception);\n    if (status == MagickFalse)\n      break;\n  }\n  magnitude_view=DestroyCacheView(magnitude_view);\n  i=0L;\n  phase_view=AcquireAuthenticCacheView(phase_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    q=GetCacheViewAuthenticPixels(phase_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          SetPixelRed(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          SetPixelGreen(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          SetPixelBlue(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          SetPixelBlack(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          SetPixelAlpha(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n      }\n      i++;\n      q+=GetPixelChannels(phase_image);\n    }\n    status=SyncCacheViewAuthenticPixels(phase_view,exception);\n    if (status == MagickFalse)\n      break;\n   }\n  phase_view=DestroyCacheView(phase_view);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  return(status);\n}\n\nstatic MagickBooleanType ForwardFourierTransform(FourierInfo *fourier_info,\n  const Image *image,double *magnitude_pixels,double *phase_pixels,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const char\n    *value;\n\n  double\n    *source_pixels;\n\n  fftw_complex\n    *forward_pixels;\n\n  fftw_plan\n    fftw_r2c_plan;\n\n  MemoryInfo\n    *forward_info,\n    *source_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Generate the forward Fourier transform.\n  */\n  source_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  memset(source_pixels,0,fourier_info->width*fourier_info->height*\n    sizeof(*source_pixels));\n  i=0L;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(image_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          source_pixels[i]=QuantumScale*GetPixelRed(image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelGreen(image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelBlue(image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelBlack(image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelAlpha(image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  forward_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    (fourier_info->height/2+1)*sizeof(*forward_pixels));\n  if (forward_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      source_info=(MemoryInfo *) RelinquishVirtualMemory(source_info);\n      return(MagickFalse);\n    }\n  forward_pixels=(fftw_complex *) GetVirtualMemoryBlob(forward_info);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp critical (MagickCore_ForwardFourierTransform)\n#endif\n  fftw_r2c_plan=fftw_plan_dft_r2c_2d(fourier_info->width,fourier_info->height,\n    source_pixels,forward_pixels,FFTW_ESTIMATE);\n  fftw_execute_dft_r2c(fftw_r2c_plan,source_pixels,forward_pixels);\n  fftw_destroy_plan(fftw_r2c_plan);\n  source_info=(MemoryInfo *) RelinquishVirtualMemory(source_info);\n  value=GetImageArtifact(image,\"fourier:normalize\");\n  if ((value == (const char *) NULL) || (LocaleCompare(value,\"forward\") == 0))\n    {\n      double\n        gamma;\n\n      /*\n        Normalize fourier transform.\n      */\n      i=0L;\n      gamma=PerceptibleReciprocal((double) fourier_info->width*\n        fourier_info->height);\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->center; x++)\n        {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n          forward_pixels[i]*=gamma;\n#else\n          forward_pixels[i][0]*=gamma;\n          forward_pixels[i][1]*=gamma;\n#endif\n          i++;\n        }\n    }\n  /*\n    Generate magnitude and phase (or real and imaginary).\n  */\n  i=0L;\n  if (fourier_info->modulus != MagickFalse)\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n        magnitude_pixels[i]=cabs(forward_pixels[i]);\n        phase_pixels[i]=carg(forward_pixels[i]);\n        i++;\n      }\n  else\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n        magnitude_pixels[i]=creal(forward_pixels[i]);\n        phase_pixels[i]=cimag(forward_pixels[i]);\n        i++;\n      }\n  forward_info=(MemoryInfo *) RelinquishVirtualMemory(forward_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ForwardFourierTransformChannel(const Image *image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  double\n    *magnitude_pixels,\n    *phase_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *magnitude_info,\n    *phase_info;\n\n  fourier_info.width=image->columns;\n  fourier_info.height=image->rows;\n  if ((image->columns != image->rows) || ((image->columns % 2) != 0) ||\n      ((image->rows % 2) != 0))\n    {\n      size_t extent=image->columns < image->rows ? image->rows : image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*phase_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL))\n    {\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (magnitude_info == (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  status=ForwardFourierTransform(&fourier_info,image,magnitude_pixels,\n    phase_pixels,exception);\n  if (status != MagickFalse)\n    status=ForwardFourier(&fourier_info,fourier_image,magnitude_pixels,\n      phase_pixels,exception);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  return(status);\n}\n#endif\n\nMagickExport Image *ForwardFourierTransformImage(const Image *image,\n  const MagickBooleanType modulus,ExceptionInfo *exception)\n{\n  Image\n    *fourier_image;\n\n  fourier_image=NewImageList();\n#if !defined(MAGICKCORE_FFTW_DELEGATE)\n  (void) modulus;\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (FFTW)\",\n    image->filename);\n#else\n  {\n    Image\n      *magnitude_image;\n\n    size_t\n      height,\n      width;\n\n    width=image->columns;\n    height=image->rows;\n    if ((image->columns != image->rows) || ((image->columns % 2) != 0) ||\n        ((image->rows % 2) != 0))\n      {\n        size_t extent=image->columns < image->rows ? image->rows :\n          image->columns;\n        width=(extent & 0x01) == 1 ? extent+1UL : extent;\n      }\n    height=width;\n    magnitude_image=CloneImage(image,width,height,MagickTrue,exception);\n    if (magnitude_image != (Image *) NULL)\n      {\n        Image\n          *phase_image;\n\n        magnitude_image->storage_class=DirectClass;\n        magnitude_image->depth=32UL;\n        phase_image=CloneImage(image,width,height,MagickTrue,exception);\n        if (phase_image == (Image *) NULL)\n          magnitude_image=DestroyImage(magnitude_image);\n        else\n          {\n            MagickBooleanType\n              is_gray,\n              status;\n\n            phase_image->storage_class=DirectClass;\n            phase_image->depth=32UL;\n            AppendImageToList(&fourier_image,magnitude_image);\n            AppendImageToList(&fourier_image,phase_image);\n            status=MagickTrue;\n            is_gray=IsImageGray(image);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp parallel sections\n#endif\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                if (is_gray != MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    GrayPixelChannel,modulus,fourier_image,exception);\n                else\n                  thread_status=ForwardFourierTransformChannel(image,\n                    RedPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (is_gray == MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    GreenPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (is_gray == MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    BluePixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (image->colorspace == CMYKColorspace)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    BlackPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    AlphaPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n            }\n            if (status == MagickFalse)\n              fourier_image=DestroyImageList(fourier_image);\n            fftw_cleanup();\n          }\n      }\n  }\n#endif\n  return(fourier_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I n v e r s e F o u r i e r T r a n s f o r m I m a g e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InverseFourierTransformImage() implements the inverse discrete Fourier\n%  transform (DFT) of the image either as a magnitude / phase or real /\n%  imaginary image pair.\n%\n%  The format of the InverseFourierTransformImage method is:\n%\n%      Image *InverseFourierTransformImage(const Image *magnitude_image,\n%        const Image *phase_image,const MagickBooleanType modulus,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o magnitude_image: the magnitude or real image.\n%\n%    o phase_image: the phase or imaginary image.\n%\n%    o modulus: if true, return transform as a magnitude / phase pair\n%      otherwise a real / imaginary image pair.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FFTW_DELEGATE)\nstatic MagickBooleanType InverseQuadrantSwap(const size_t width,\n  const size_t height,const double *source,double *destination)\n{\n  register ssize_t\n    x;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Swap quadrants.\n  */\n  center=(ssize_t) (width/2L)+1L;\n  for (y=1L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L+1L); x++)\n      destination[(height-y)*center-x+width/2L]=source[y*width+x];\n  for (y=0L; y < (ssize_t) height; y++)\n    destination[y*center]=source[y*width+width/2L];\n  for (x=0L; x < center; x++)\n    destination[x]=source[center-x-1L];\n  return(RollFourier(center,height,0L,(ssize_t) height/-2L,destination));\n}\n\nstatic MagickBooleanType InverseFourier(FourierInfo *fourier_info,\n  const Image *magnitude_image,const Image *phase_image,\n  fftw_complex *fourier_pixels,ExceptionInfo *exception)\n{\n  CacheView\n    *magnitude_view,\n    *phase_view;\n\n  double\n    *inverse_pixels,\n    *magnitude_pixels,\n    *phase_pixels;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info,\n    *magnitude_info,\n    *phase_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Inverse fourier - read image and break down into a double array.\n  */\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*phase_pixels));\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    (fourier_info->height/2+1)*sizeof(*inverse_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL) ||\n      (inverse_info == (MemoryInfo *) NULL))\n    {\n      if (magnitude_info != (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (inverse_info != (MemoryInfo *) NULL)\n        inverse_info=RelinquishVirtualMemory(inverse_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  inverse_pixels=(double *) GetVirtualMemoryBlob(inverse_info);\n  i=0L;\n  magnitude_view=AcquireVirtualCacheView(magnitude_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(magnitude_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelRed(magnitude_image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelGreen(magnitude_image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelBlue(magnitude_image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelBlack(magnitude_image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelAlpha(magnitude_image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(magnitude_image);\n    }\n  }\n  magnitude_view=DestroyCacheView(magnitude_view);\n  status=InverseQuadrantSwap(fourier_info->width,fourier_info->height,\n    magnitude_pixels,inverse_pixels);\n  (void) memcpy(magnitude_pixels,inverse_pixels,fourier_info->height*\n    fourier_info->center*sizeof(*magnitude_pixels));\n  i=0L;\n  phase_view=AcquireVirtualCacheView(phase_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(phase_view,0,y,fourier_info->width,1,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelRed(phase_image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelGreen(phase_image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelBlue(phase_image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelBlack(phase_image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelAlpha(phase_image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(phase_image);\n    }\n  }\n  if (fourier_info->modulus != MagickFalse)\n    {\n      i=0L;\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->width; x++)\n        {\n          phase_pixels[i]-=0.5;\n          phase_pixels[i]*=(2.0*MagickPI);\n          i++;\n        }\n    }\n  phase_view=DestroyCacheView(phase_view);\n  CorrectPhaseLHS(fourier_info->width,fourier_info->height,phase_pixels);\n  if (status != MagickFalse)\n    status=InverseQuadrantSwap(fourier_info->width,fourier_info->height,\n      phase_pixels,inverse_pixels);\n  (void) memcpy(phase_pixels,inverse_pixels,fourier_info->height*\n    fourier_info->center*sizeof(*phase_pixels));\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  /*\n    Merge two sets.\n  */\n  i=0L;\n  if (fourier_info->modulus != MagickFalse)\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n       for (x=0L; x < (ssize_t) fourier_info->center; x++)\n       {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n         fourier_pixels[i]=magnitude_pixels[i]*cos(phase_pixels[i])+I*\n           magnitude_pixels[i]*sin(phase_pixels[i]);\n#else\n         fourier_pixels[i][0]=magnitude_pixels[i]*cos(phase_pixels[i]);\n         fourier_pixels[i][1]=magnitude_pixels[i]*sin(phase_pixels[i]);\n#endif\n         i++;\n      }\n  else\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n        fourier_pixels[i]=magnitude_pixels[i]+I*phase_pixels[i];\n#else\n        fourier_pixels[i][0]=magnitude_pixels[i];\n        fourier_pixels[i][1]=phase_pixels[i];\n#endif\n        i++;\n      }\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  return(status);\n}\n\nstatic MagickBooleanType InverseFourierTransform(FourierInfo *fourier_info,\n  fftw_complex *fourier_pixels,Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const char\n    *value;\n\n  double\n    *source_pixels;\n\n  fftw_plan\n    fftw_c2r_plan;\n\n  MemoryInfo\n    *source_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  source_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  value=GetImageArtifact(image,\"fourier:normalize\");\n  if (LocaleCompare(value,\"inverse\") == 0)\n    {\n      double\n        gamma;\n\n      /*\n        Normalize inverse transform.\n      */\n      i=0L;\n      gamma=PerceptibleReciprocal((double) fourier_info->width*\n        fourier_info->height);\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->center; x++)\n        {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n          fourier_pixels[i]*=gamma;\n#else\n          fourier_pixels[i][0]*=gamma;\n          fourier_pixels[i][1]*=gamma;\n#endif\n          i++;\n        }\n    }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp critical (MagickCore_InverseFourierTransform)\n#endif\n  fftw_c2r_plan=fftw_plan_dft_c2r_2d(fourier_info->width,fourier_info->height,\n    fourier_pixels,source_pixels,FFTW_ESTIMATE);\n  fftw_execute_dft_c2r(fftw_c2r_plan,fourier_pixels,source_pixels);\n  fftw_destroy_plan(fftw_c2r_plan);\n  i=0L;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    if (y >= (ssize_t) image->rows)\n      break;\n    q=GetCacheViewAuthenticPixels(image_view,0L,y,fourier_info->width >\n      image->columns ? image->columns : fourier_info->width,1UL,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        switch (fourier_info->channel)\n        {\n          case RedPixelChannel:\n          default:\n          {\n            SetPixelRed(image,ClampToQuantum(QuantumRange*source_pixels[i]),q);\n            break;\n          }\n          case GreenPixelChannel:\n          {\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case BluePixelChannel:\n          {\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case BlackPixelChannel:\n          {\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case AlphaPixelChannel:\n          {\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n        }\n      i++;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  source_info=RelinquishVirtualMemory(source_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType InverseFourierTransformChannel(\n  const Image *magnitude_image,const Image *phase_image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  fftw_complex\n    *inverse_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info;\n\n  fourier_info.width=magnitude_image->columns;\n  fourier_info.height=magnitude_image->rows;\n  if ((magnitude_image->columns != magnitude_image->rows) ||\n      ((magnitude_image->columns % 2) != 0) ||\n      ((magnitude_image->rows % 2) != 0))\n    {\n      size_t extent=magnitude_image->columns < magnitude_image->rows ?\n        magnitude_image->rows : magnitude_image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*inverse_pixels));\n  if (inverse_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  inverse_pixels=(fftw_complex *) GetVirtualMemoryBlob(inverse_info);\n  status=InverseFourier(&fourier_info,magnitude_image,phase_image,\n    inverse_pixels,exception);\n  if (status != MagickFalse)\n    status=InverseFourierTransform(&fourier_info,inverse_pixels,fourier_image,\n      exception);\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  return(status);\n}\n#endif\n\nMagickExport Image *InverseFourierTransformImage(const Image *magnitude_image,\n  const Image *phase_image,const MagickBooleanType modulus,\n  ExceptionInfo *exception)\n{\n  Image\n    *fourier_image;\n\n  assert(magnitude_image != (Image *) NULL);\n  assert(magnitude_image->signature == MagickCoreSignature);\n  if (magnitude_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      magnitude_image->filename);\n  if (phase_image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",magnitude_image->filename);\n      return((Image *) NULL);\n    }\n#if !defined(MAGICKCORE_FFTW_DELEGATE)\n  fourier_image=(Image *) NULL;\n  (void) modulus;\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (FFTW)\",\n    magnitude_image->filename);\n#else\n  {\n    fourier_image=CloneImage(magnitude_image,magnitude_image->columns,\n      magnitude_image->rows,MagickTrue,exception);\n    if (fourier_image != (Image *) NULL)\n      {\n        MagickBooleanType\n          is_gray,\n          status;\n\n        status=MagickTrue;\n        is_gray=IsImageGray(magnitude_image);\n        if (is_gray != MagickFalse)\n          is_gray=IsImageGray(phase_image);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp parallel sections\n#endif\n        {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            if (is_gray != MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,GrayPixelChannel,modulus,fourier_image,exception);\n            else\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,RedPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (is_gray == MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,GreenPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (is_gray == MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,BluePixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (magnitude_image->colorspace == CMYKColorspace)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,BlackPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (magnitude_image->alpha_trait != UndefinedPixelTrait)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,AlphaPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n        }\n        if (status == MagickFalse)\n          fourier_image=DestroyImage(fourier_image);\n      }\n    fftw_cleanup();\n  }\n#endif\n  return(fourier_image);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%           AAA   N   N  N   N   OOO   TTTTT   AAA   TTTTT  EEEEE             %\n%          A   A  NN  N  NN  N  O   O    T    A   A    T    E                 %\n%          AAAAA  N N N  N N N  O   O    T    AAAAA    T    EEE               %\n%          A   A  N  NN  N  NN  O   O    T    A   A    T    E                 %\n%          A   A  N   N  N   N   OOO     T    A   A    T    EEEEE             %\n%                                                                             %\n%                                                                             %\n%                   MagickCore Image Annotation Methods                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n% Digital Applications (www.digapp.com) contributed the stroked text algorithm.\n% It was written by Leonard Rosenthol.\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/annotate.h\"\n#include \"MagickCore/annotate-private.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/draw-private.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/statistic.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/token-private.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/transform-private.h\"\n#include \"MagickCore/type.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/utility-private.h\"\n#include \"MagickCore/xwindow.h\"\n#include \"MagickCore/xwindow-private.h\"\n#if defined(MAGICKCORE_FREETYPE_DELEGATE)\n#if defined(__MINGW32__)\n#  undef interface\n#endif\n#include <ft2build.h>\n#if defined(FT_FREETYPE_H)\n#  include FT_FREETYPE_H\n#else\n#  include <freetype/freetype.h>\n#endif\n#if defined(FT_GLYPH_H)\n#  include FT_GLYPH_H\n#else\n#  include <freetype/ftglyph.h>\n#endif\n#if defined(FT_OUTLINE_H)\n#  include FT_OUTLINE_H\n#else\n#  include <freetype/ftoutln.h>\n#endif\n#if defined(FT_BBOX_H)\n#  include FT_BBOX_H\n#else\n#  include <freetype/ftbbox.h>\n#endif /* defined(FT_BBOX_H) */\n#endif\n#if defined(MAGICKCORE_RAQM_DELEGATE)\n#include <raqm.h>\n#endif\ntypedef struct _GraphemeInfo\n{\n  size_t\n    index,\n    x_offset,\n    x_advance,\n    y_offset;\n\n  size_t\n    cluster;\n} GraphemeInfo;\n\f\n/*\n  Annotate semaphores.\n*/\nstatic SemaphoreInfo\n  *annotate_semaphore = (SemaphoreInfo *) NULL;\n\f\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  RenderType(Image *,const DrawInfo *,const PointInfo *,TypeMetric *,\n    ExceptionInfo *),\n  RenderPostscript(Image *,const DrawInfo *,const PointInfo *,TypeMetric *,\n    ExceptionInfo *),\n  RenderFreetype(Image *,const DrawInfo *,const char *,const PointInfo *,\n    TypeMetric *,ExceptionInfo *),\n  RenderX11(Image *,const DrawInfo *,const PointInfo *,TypeMetric *,\n    ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A n n o t a t e C o m p o n e n t G e n e s i s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AnnotateComponentGenesis() instantiates the annotate component.\n%\n%  The format of the AnnotateComponentGenesis method is:\n%\n%      MagickBooleanType AnnotateComponentGenesis(void)\n%\n*/\nMagickPrivate MagickBooleanType AnnotateComponentGenesis(void)\n{\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    annotate_semaphore=AcquireSemaphoreInfo();\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A n n o t a t e C o m p o n e n t T e r m i n u s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AnnotateComponentTerminus() destroys the annotate component.\n%\n%  The format of the AnnotateComponentTerminus method is:\n%\n%      AnnotateComponentTerminus(void)\n%\n*/\nMagickPrivate void AnnotateComponentTerminus(void)\n{\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&annotate_semaphore);\n  RelinquishSemaphoreInfo(&annotate_semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A n n o t a t e I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AnnotateImage() annotates an image with text.\n%\n%  The format of the AnnotateImage method is:\n%\n%      MagickBooleanType AnnotateImage(Image *image,DrawInfo *draw_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType AnnotateImage(Image *image,\n  const DrawInfo *draw_info,ExceptionInfo *exception)\n{\n  char\n    *p,\n    primitive[MagickPathExtent],\n    *text,\n    **textlist;\n\n  DrawInfo\n    *annotate,\n    *annotate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  RectangleInfo\n    geometry;\n\n  register ssize_t\n    i;\n\n  TypeMetric\n    metrics;\n\n  size_t\n    height,\n    number_lines;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (draw_info->text == (char *) NULL)\n    return(MagickFalse);\n  if (*draw_info->text == '\\0')\n    return(MagickTrue);\n  annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  text=annotate->text;\n  annotate->text=(char *) NULL;\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  number_lines=1;\n  for (p=text; *p != '\\0'; p++)\n    if (*p == '\\n')\n      number_lines++;\n  textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));\n  if (textlist == (char **) NULL)\n    {\n      annotate_info=DestroyDrawInfo(annotate_info);\n      annotate=DestroyDrawInfo(annotate);\n      text=DestroyString(text);\n      return(MagickFalse);\n    }\n  p=text;\n  for (i=0; i < number_lines; i++)\n  {\n    char\n      *q;\n\n    textlist[i]=p;\n    for (q=p; *q != '\\0'; q++)\n      if ((*q == '\\r') || (*q == '\\n'))\n        break;\n    if (*q == '\\r')\n      {\n        *q='\\0';\n        q++;\n      }\n    *q='\\0';\n    p=q+1;\n  }\n  textlist[i]=(char *) NULL;\n  SetGeometry(image,&geometry);\n  SetGeometryInfo(&geometry_info);\n  if (annotate_info->geometry != (char *) NULL)\n    {\n      (void) ParsePageGeometry(image,annotate_info->geometry,&geometry,\n        exception);\n      (void) ParseGeometry(annotate_info->geometry,&geometry_info);\n    }\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      annotate_info=DestroyDrawInfo(annotate_info);\n      annotate=DestroyDrawInfo(annotate);\n      textlist=(char **) RelinquishMagickMemory(textlist);\n      text=DestroyString(text);\n      return(MagickFalse);\n    }\n  if (IsGrayColorspace(image->colorspace) != MagickFalse)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  status=MagickTrue;\n  (void) memset(&metrics,0,sizeof(metrics));\n  for (i=0; textlist[i] != (char *) NULL; i++)\n  {\n    if (*textlist[i] == '\\0')\n      continue;\n    /*\n      Position text relative to image.\n    */\n    annotate_info->affine.tx=geometry_info.xi-image->page.x;\n    annotate_info->affine.ty=geometry_info.psi-image->page.y;\n    (void) CloneString(&annotate->text,textlist[i]);\n    if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity))\n      (void) GetTypeMetrics(image,annotate,&metrics,exception);\n    height=(ssize_t) (metrics.ascent-metrics.descent+\n      draw_info->interline_spacing+0.5);\n    switch (annotate->gravity)\n    {\n      case UndefinedGravity:\n      default:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case NorthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent;\n        break;\n      }\n      case NorthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent);\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case NorthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent)-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i*\n          annotate_info->affine.sy*height+annotate_info->affine.sy*\n          metrics.ascent-annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      case WestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case CenterGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy*\n          (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case EastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width+\n          annotate_info->affine.ry*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0-1.0;\n        offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+\n          geometry.height/2.0+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width+\n          annotate_info->affine.sy*(metrics.ascent+metrics.descent-\n          (number_lines-1.0)*height)/2.0;\n        break;\n      }\n      case SouthWestGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i*\n          annotate_info->affine.ry*height-annotate_info->affine.ry*\n          (number_lines-1.0)*height;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthGravity:\n      {\n        offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+\n          geometry.width/2.0+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0-\n          annotate_info->affine.ry*(number_lines-1.0)*height/2.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n      case SouthEastGravity:\n      {\n        offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+\n          geometry.width+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width-\n          annotate_info->affine.ry*(number_lines-1.0)*height-1.0;\n        offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+\n          geometry.height+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width-\n          annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent;\n        break;\n      }\n    }\n    switch (annotate->align)\n    {\n      case LeftAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height;\n        break;\n      }\n      case CenterAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width/2.0;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width/2.0;\n        break;\n      }\n      case RightAlign:\n      {\n        offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height-\n          annotate_info->affine.sx*metrics.width;\n        offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height-\n          annotate_info->affine.rx*metrics.width;\n        break;\n      }\n      default:\n        break;\n    }\n    if (draw_info->undercolor.alpha != TransparentAlpha)\n      {\n        DrawInfo\n          *undercolor_info;\n\n        /*\n          Text box.\n        */\n        undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL);\n        undercolor_info->fill=draw_info->undercolor;\n        undercolor_info->affine=draw_info->affine;\n        undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent;\n        undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent;\n        (void) FormatLocaleString(primitive,MagickPathExtent,\n          \"rectangle 0.0,0.0 %g,%g\",metrics.origin.x,(double) height);\n        (void) CloneString(&undercolor_info->primitive,primitive);\n        (void) DrawImage(image,undercolor_info,exception);\n        (void) DestroyDrawInfo(undercolor_info);\n      }\n    annotate_info->affine.tx=offset.x;\n    annotate_info->affine.ty=offset.y;\n    (void) FormatLocaleString(primitive,MagickPathExtent,\"stroke-width %g \"\n      \"line 0,0 %g,0\",metrics.underline_thickness,metrics.width);\n    if (annotate->decorate == OverlineDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+\n          metrics.descent-metrics.underline_position));\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n    else\n      if (annotate->decorate == UnderlineDecoration)\n        {\n          annotate_info->affine.ty-=(draw_info->affine.sy*\n            metrics.underline_position);\n          (void) CloneString(&annotate_info->primitive,primitive);\n          (void) DrawImage(image,annotate_info,exception);\n        }\n    /*\n      Annotate image with text.\n    */\n    status=RenderType(image,annotate,&offset,&metrics,exception);\n    if (status == MagickFalse)\n      break;\n    if (annotate->decorate == LineThroughDecoration)\n      {\n        annotate_info->affine.ty-=(draw_info->affine.sy*(height+\n          metrics.underline_position+metrics.descent)/2.0);\n        (void) CloneString(&annotate_info->primitive,primitive);\n        (void) DrawImage(image,annotate_info,exception);\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  annotate_info=DestroyDrawInfo(annotate_info);\n  annotate=DestroyDrawInfo(annotate);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  text=DestroyString(text);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%  F o r m a t M a g i c k C a p t i o n                                      %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  FormatMagickCaption() formats a caption so that it fits within the image\n%  width.  It returns the number of lines in the formatted caption.\n%\n%  The format of the FormatMagickCaption method is:\n%\n%      ssize_t FormatMagickCaption(Image *image,DrawInfo *draw_info,\n%        const MagickBooleanType split,TypeMetric *metrics,char **caption,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image:  The image.\n%\n%    o draw_info: the draw info.\n%\n%    o split: when no convenient line breaks-- insert newline.\n%\n%    o metrics: Return the font metrics in this structure.\n%\n%    o caption: the caption.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ssize_t FormatMagickCaption(Image *image,DrawInfo *draw_info,\n  const MagickBooleanType split,TypeMetric *metrics,char **caption,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register char\n    *p,\n    *q,\n    *s;\n\n  register ssize_t\n    i;\n\n  size_t\n    width;\n\n  ssize_t\n    n;\n\n  q=draw_info->text;\n  s=(char *) NULL;\n  for (p=(*caption); GetUTFCode(p) != 0; p+=GetUTFOctets(p))\n  {\n    if (IsUTFSpace(GetUTFCode(p)) != MagickFalse)\n      s=p;\n    if (GetUTFCode(p) == '\\n')\n      {\n        q=draw_info->text;\n        continue;\n      }\n    for (i=0; i < (ssize_t) GetUTFOctets(p); i++)\n      *q++=(*(p+i));\n    *q='\\0';\n    status=GetTypeMetrics(image,draw_info,metrics,exception);\n    if (status == MagickFalse)\n      break;\n    width=(size_t) floor(metrics->width+draw_info->stroke_width+0.5);\n    if (width <= image->columns)\n      continue;\n    if (s != (char *) NULL)\n      {\n        *s='\\n';\n        p=s;\n      }\n    else\n      if (split != MagickFalse)\n        {\n          /*\n            No convenient line breaks-- insert newline.\n          */\n          n=p-(*caption);\n          if ((n > 0) && ((*caption)[n-1] != '\\n'))\n            {\n              char\n                *target;\n\n              target=AcquireString(*caption);\n              CopyMagickString(target,*caption,n+1);\n              ConcatenateMagickString(target,\"\\n\",strlen(*caption)+1);\n              ConcatenateMagickString(target,p,strlen(*caption)+2);\n              (void) DestroyString(*caption);\n              *caption=target;\n              p=(*caption)+n;\n            }\n        }\n    q=draw_info->text;\n    s=(char *) NULL;\n  }\n  n=0;\n  for (p=(*caption); GetUTFCode(p) != 0; p+=GetUTFOctets(p))\n    if (GetUTFCode(p) == '\\n')\n      n++;\n  return(n);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t M u l t i l i n e T y p e M e t r i c s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetMultilineTypeMetrics() returns the following information for the\n%  specified font and text:\n%\n%    character width\n%    character height\n%    ascender\n%    descender\n%    text width\n%    text height\n%    maximum horizontal advance\n%    bounds: x1\n%    bounds: y1\n%    bounds: x2\n%    bounds: y2\n%    origin: x\n%    origin: y\n%    underline position\n%    underline thickness\n%\n%  This method is like GetTypeMetrics() but it returns the maximum text width\n%  and height for multiple lines of text.\n%\n%  The format of the GetMultilineTypeMetrics method is:\n%\n%      MagickBooleanType GetMultilineTypeMetrics(Image *image,\n%        const DrawInfo *draw_info,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o metrics: Return the font metrics in this structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetMultilineTypeMetrics(Image *image,\n  const DrawInfo *draw_info,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  char\n    **textlist;\n\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    height,\n    count;\n\n  TypeMetric\n    extent;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->text != (char *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  if (*draw_info->text == '\\0')\n    return(MagickFalse);\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->text=DestroyString(annotate_info->text);\n  /*\n    Convert newlines to multiple lines of text.\n  */\n  textlist=StringToStrings(draw_info->text,&count);\n  if (textlist == (char **) NULL)\n    return(MagickFalse);\n  annotate_info->render=MagickFalse;\n  annotate_info->direction=UndefinedDirection;\n  (void) memset(metrics,0,sizeof(*metrics));\n  (void) memset(&extent,0,sizeof(extent));\n  /*\n    Find the widest of the text lines.\n  */\n  annotate_info->text=textlist[0];\n  status=GetTypeMetrics(image,annotate_info,&extent,exception);\n  *metrics=extent;\n  height=(count*(size_t) (metrics->ascent-metrics->descent+\n    0.5)+(count-1)*draw_info->interline_spacing);\n  if (AcquireMagickResource(HeightResource,height) == MagickFalse)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"WidthOrHeightExceedsLimit\",\"`%s'\",image->filename);\n      status=MagickFalse;\n    }\n  else\n    {\n      for (i=1; i < (ssize_t) count; i++)\n      {\n        annotate_info->text=textlist[i];\n        status=GetTypeMetrics(image,annotate_info,&extent,exception);\n        if (status == MagickFalse)\n          break;\n        if (extent.width > metrics->width)\n          *metrics=extent;\n        if (AcquireMagickResource(WidthResource,extent.width) == MagickFalse)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n              \"WidthOrHeightExceedsLimit\",\"`%s'\",image->filename);\n            status=MagickFalse;\n            break;\n          }\n      }\n      metrics->height=(double) height;\n    }\n  /*\n    Relinquish resources.\n  */\n  annotate_info->text=(char *) NULL;\n  annotate_info=DestroyDrawInfo(annotate_info);\n  for (i=0; i < (ssize_t) count; i++)\n    textlist[i]=DestroyString(textlist[i]);\n  textlist=(char **) RelinquishMagickMemory(textlist);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t T y p e M e t r i c s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetTypeMetrics() returns the following information for the specified font\n%  and text:\n%\n%    character width\n%    character height\n%    ascender\n%    descender\n%    text width\n%    text height\n%    maximum horizontal advance\n%    bounds: x1\n%    bounds: y1\n%    bounds: x2\n%    bounds: y2\n%    origin: x\n%    origin: y\n%    underline position\n%    underline thickness\n%\n%  The format of the GetTypeMetrics method is:\n%\n%      MagickBooleanType GetTypeMetrics(Image *image,const DrawInfo *draw_info,\n%        TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o metrics: Return the font metrics in this structure.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetTypeMetrics(Image *image,\n  const DrawInfo *draw_info,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    offset;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (DrawInfo *) NULL);\n  assert(draw_info->text != (char *) NULL);\n  assert(draw_info->signature == MagickCoreSignature);\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->render=MagickFalse;\n  annotate_info->direction=UndefinedDirection;\n  (void) memset(metrics,0,sizeof(*metrics));\n  offset.x=0.0;\n  offset.y=0.0;\n  status=RenderType(image,annotate_info,&offset,metrics,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\"Metrics: text: %s; \"\n      \"width: %g; height: %g; ascent: %g; descent: %g; max advance: %g; \"\n      \"bounds: %g,%g  %g,%g; origin: %g,%g; pixels per em: %g,%g; \"\n      \"underline position: %g; underline thickness: %g\",annotate_info->text,\n      metrics->width,metrics->height,metrics->ascent,metrics->descent,\n      metrics->max_advance,metrics->bounds.x1,metrics->bounds.y1,\n      metrics->bounds.x2,metrics->bounds.y2,metrics->origin.x,metrics->origin.y,\n      metrics->pixels_per_em.x,metrics->pixels_per_em.y,\n      metrics->underline_position,metrics->underline_thickness);\n  annotate_info=DestroyDrawInfo(annotate_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r T y p e                                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderType() renders text on the image.  It also returns the bounding box of\n%  the text relative to the image.\n%\n%  The format of the RenderType method is:\n%\n%      MagickBooleanType RenderType(Image *image,DrawInfo *draw_info,\n%        const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType RenderType(Image *image,const DrawInfo *draw_info,\n  const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  const TypeInfo\n    *type_info;\n\n  DrawInfo\n    *annotate_info;\n\n  MagickBooleanType\n    status;\n\n  type_info=(const TypeInfo *) NULL;\n  if (draw_info->font != (char *) NULL)\n    {\n      if (*draw_info->font == '@')\n        {\n          status=RenderFreetype(image,draw_info,draw_info->encoding,offset,\n            metrics,exception);\n          return(status);\n        }\n      if (*draw_info->font == '-')\n        return(RenderX11(image,draw_info,offset,metrics,exception));\n      if (*draw_info->font == '^')\n        return(RenderPostscript(image,draw_info,offset,metrics,exception));\n      if (IsPathAccessible(draw_info->font) != MagickFalse)\n        {\n          status=RenderFreetype(image,draw_info,draw_info->encoding,offset,\n            metrics,exception);\n          return(status);\n        }\n      type_info=GetTypeInfo(draw_info->font,exception);\n      if (type_info == (const TypeInfo *) NULL)\n        (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n          \"UnableToReadFont\",\"`%s'\",draw_info->font);\n    }\n  if ((type_info == (const TypeInfo *) NULL) &&\n      (draw_info->family != (const char *) NULL))\n    {\n      type_info=GetTypeInfoByFamily(draw_info->family,draw_info->style,\n        draw_info->stretch,draw_info->weight,exception);\n      if (type_info == (const TypeInfo *) NULL)\n        {\n          char\n            **family;\n\n          int\n            number_families;\n\n          register ssize_t\n            i;\n\n          /*\n            Parse font family list.\n          */\n          family=StringToArgv(draw_info->family,&number_families);\n          for (i=1; i < (ssize_t) number_families; i++)\n          {\n            type_info=GetTypeInfoByFamily(family[i],draw_info->style,\n              draw_info->stretch,draw_info->weight,exception);\n            if (type_info != (const TypeInfo *) NULL)\n              break;\n          }\n          for (i=0; i < (ssize_t) number_families; i++)\n            family[i]=DestroyString(family[i]);\n          family=(char **) RelinquishMagickMemory(family);\n          if (type_info == (const TypeInfo *) NULL)\n            (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning,\n              \"UnableToReadFont\",\"`%s'\",draw_info->family);\n        }\n    }\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Arial\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Helvetica\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Century Schoolbook\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily(\"Sans\",draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfoByFamily((const char *) NULL,draw_info->style,\n      draw_info->stretch,draw_info->weight,exception);\n  if (type_info == (const TypeInfo *) NULL)\n    type_info=GetTypeInfo(\"*\",exception);\n  if (type_info == (const TypeInfo *) NULL)\n    {\n      status=RenderFreetype(image,draw_info,draw_info->encoding,offset,metrics,\n        exception);\n      return(status);\n    }\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  annotate_info->face=type_info->face;\n  if (type_info->metrics != (char *) NULL)\n    (void) CloneString(&annotate_info->metrics,type_info->metrics);\n  if (type_info->glyphs != (char *) NULL)\n    (void) CloneString(&annotate_info->font,type_info->glyphs);\n  status=RenderFreetype(image,annotate_info,type_info->encoding,offset,metrics,\n    exception);\n  annotate_info=DestroyDrawInfo(annotate_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r F r e e t y p e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderFreetype() renders text on the image with a Truetype font.  It also\n%  returns the bounding box of the text relative to the image.\n%\n%  The format of the RenderFreetype method is:\n%\n%      MagickBooleanType RenderFreetype(Image *image,DrawInfo *draw_info,\n%        const char *encoding,const PointInfo *offset,TypeMetric *metrics,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o encoding: the font encoding.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FREETYPE_DELEGATE)\n\nstatic size_t ComplexTextLayout(const Image *image,const DrawInfo *draw_info,\n  const char *text,const size_t length,const FT_Face face,const FT_Int32 flags,\n  GraphemeInfo **grapheme,ExceptionInfo *exception)\n{\n#if defined(MAGICKCORE_RAQM_DELEGATE)\n  const char\n    *features;\n\n  raqm_t\n    *rq;\n\n  raqm_glyph_t\n    *glyphs;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent;\n\n  extent=0;\n  rq=raqm_create();\n  if (rq == (raqm_t *) NULL)\n    goto cleanup;\n  if (raqm_set_text_utf8(rq,text,length) == 0)\n    goto cleanup;\n  if (raqm_set_par_direction(rq,(raqm_direction_t) draw_info->direction) == 0)\n    goto cleanup;\n  if (raqm_set_freetype_face(rq,face) == 0)\n    goto cleanup;\n  features=GetImageProperty(image,\"type:features\",exception);\n  if (features != (const char *) NULL)\n    {\n      char\n        breaker,\n        quote,\n        *token;\n\n      int\n        next,\n        status_token;\n\n      TokenInfo\n        *token_info;\n\n      next=0;\n      token_info=AcquireTokenInfo();\n      token=AcquireString(\"\");\n      status_token=Tokenizer(token_info,0,token,50,features,\"\",\",\",\"\",'\\0',\n        &breaker,&next,&quote);\n      while (status_token == 0)\n      {\n        raqm_add_font_feature(rq,token,strlen(token));\n        status_token=Tokenizer(token_info,0,token,50,features,\"\",\",\",\"\",'\\0',\n          &breaker,&next,&quote);\n      }\n      token_info=DestroyTokenInfo(token_info);\n      token=DestroyString(token);\n    }\n  if (raqm_layout(rq) == 0)\n    goto cleanup;\n  glyphs=raqm_get_glyphs(rq,&extent);\n  if (glyphs == (raqm_glyph_t *) NULL)\n    {\n      extent=0;\n      goto cleanup;\n    }\n  *grapheme=(GraphemeInfo *) AcquireQuantumMemory(extent,sizeof(**grapheme));\n  if (*grapheme == (GraphemeInfo *) NULL)\n    {\n      extent=0;\n      goto cleanup;\n    }\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    (*grapheme)[i].index=glyphs[i].index;\n    (*grapheme)[i].x_offset=glyphs[i].x_offset;\n    (*grapheme)[i].x_advance=glyphs[i].x_advance;\n    (*grapheme)[i].y_offset=glyphs[i].y_offset;\n    (*grapheme)[i].cluster=glyphs[i].cluster;\n  }\n\ncleanup:\n  raqm_destroy(rq);\n  return(extent);\n#else\n  const char\n    *p;\n\n  FT_Error\n    ft_status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    last_glyph;\n\n  /*\n    Simple layout for bi-directional text (right-to-left or left-to-right).\n  */\n  magick_unreferenced(image);\n  magick_unreferenced(exception);\n  *grapheme=(GraphemeInfo *) AcquireQuantumMemory(length+1,sizeof(**grapheme));\n  if (*grapheme == (GraphemeInfo *) NULL)\n    return(0);\n  last_glyph=0;\n  p=text;\n  for (i=0; GetUTFCode(p) != 0; p+=GetUTFOctets(p), i++)\n  {\n    (*grapheme)[i].index=(ssize_t) FT_Get_Char_Index(face,GetUTFCode(p));\n    (*grapheme)[i].x_offset=0;\n    (*grapheme)[i].y_offset=0;\n    if (((*grapheme)[i].index != 0) && (last_glyph != 0))\n      {\n        if (FT_HAS_KERNING(face))\n          {\n            FT_Vector\n              kerning;\n\n            ft_status=FT_Get_Kerning(face,(FT_UInt) last_glyph,(FT_UInt)\n              (*grapheme)[i].index,ft_kerning_default,&kerning);\n            if (ft_status == 0)\n              (*grapheme)[i-1].x_advance+=(FT_Pos) ((draw_info->direction ==\n                RightToLeftDirection ? -1.0 : 1.0)*kerning.x);\n          }\n      }\n    ft_status=FT_Load_Glyph(face,(FT_UInt) (*grapheme)[i].index,flags);\n    (*grapheme)[i].x_advance=face->glyph->advance.x;\n    (*grapheme)[i].cluster=p-text;\n    last_glyph=(*grapheme)[i].index;\n  }\n  return((size_t) i);\n#endif\n}\n\nstatic int TraceCubicBezier(FT_Vector *p,FT_Vector *q,FT_Vector *to,\n  DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"C%g,%g %g,%g %g,%g\",\n    affine.tx+p->x/64.0,affine.ty-p->y/64.0,affine.tx+q->x/64.0,affine.ty-\n    q->y/64.0,affine.tx+to->x/64.0,affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic int TraceLineTo(FT_Vector *to,DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"L%g,%g\",affine.tx+to->x/64.0,\n    affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic int TraceMoveTo(FT_Vector *to,DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"M%g,%g\",affine.tx+to->x/64.0,\n    affine.ty-to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic int TraceQuadraticBezier(FT_Vector *control,FT_Vector *to,\n  DrawInfo *draw_info)\n{\n  AffineMatrix\n    affine;\n\n  char\n    path[MagickPathExtent];\n\n  affine=draw_info->affine;\n  (void) FormatLocaleString(path,MagickPathExtent,\"Q%g,%g %g,%g\",affine.tx+\n    control->x/64.0,affine.ty-control->y/64.0,affine.tx+to->x/64.0,affine.ty-\n    to->y/64.0);\n  (void) ConcatenateString(&draw_info->primitive,path);\n  return(0);\n}\n\nstatic MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,\n  const char *encoding,const PointInfo *offset,TypeMetric *metrics,\n  ExceptionInfo *exception)\n{\n#if !defined(FT_OPEN_PATHNAME)\n#define FT_OPEN_PATHNAME  ft_open_pathname\n#endif\n\n  typedef struct _GlyphInfo\n  {\n    FT_UInt\n      id;\n\n    FT_Vector\n      origin;\n\n    FT_Glyph\n      image;\n  } GlyphInfo;\n\n  const char\n    *value;\n\n  DrawInfo\n    *annotate_info;\n\n  FT_BBox\n    bounds;\n\n  FT_BitmapGlyph\n    bitmap;\n\n  FT_Encoding\n    encoding_type;\n\n  FT_Error\n    ft_status;\n\n  FT_Face\n    face;\n\n  FT_Int32\n    flags;\n\n  FT_Library\n    library;\n\n  FT_Matrix\n    affine;\n\n  FT_Open_Args\n    args;\n\n  FT_Vector\n    origin;\n\n  GlyphInfo\n    glyph,\n    last_glyph;\n\n  GraphemeInfo\n    *grapheme;\n\n  MagickBooleanType\n    status;\n\n  PointInfo\n    point,\n    resolution;\n\n  register char\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    code,\n    y;\n\n  static FT_Outline_Funcs\n    OutlineMethods =\n    {\n      (FT_Outline_MoveTo_Func) TraceMoveTo,\n      (FT_Outline_LineTo_Func) TraceLineTo,\n      (FT_Outline_ConicTo_Func) TraceQuadraticBezier,\n      (FT_Outline_CubicTo_Func) TraceCubicBezier,\n      0, 0\n    };\n\n  unsigned char\n    *utf8;\n\n  /*\n    Initialize Truetype library.\n  */\n  ft_status=FT_Init_FreeType(&library);\n  if (ft_status != 0)\n    ThrowBinaryException(TypeError,\"UnableToInitializeFreetypeLibrary\",\n      image->filename);\n  args.flags=FT_OPEN_PATHNAME;\n  if (draw_info->font == (char *) NULL)\n    args.pathname=ConstantString(\"helvetica\");\n  else\n    if (*draw_info->font != '@')\n      args.pathname=ConstantString(draw_info->font);\n    else\n      args.pathname=ConstantString(draw_info->font+1);\n  face=(FT_Face) NULL;\n  ft_status=FT_Open_Face(library,&args,(long) draw_info->face,&face);\n  if (ft_status != 0)\n    {\n      (void) FT_Done_FreeType(library);\n      (void) ThrowMagickException(exception,GetMagickModule(),TypeError,\n        \"UnableToReadFont\",\"`%s'\",args.pathname);\n      args.pathname=DestroyString(args.pathname);\n      return(MagickFalse);\n    }\n  args.pathname=DestroyString(args.pathname);\n  if ((draw_info->metrics != (char *) NULL) &&\n      (IsPathAccessible(draw_info->metrics) != MagickFalse))\n    (void) FT_Attach_File(face,draw_info->metrics);\n  encoding_type=FT_ENCODING_UNICODE;\n  ft_status=FT_Select_Charmap(face,encoding_type);\n  if ((ft_status != 0) && (face->num_charmaps != 0))\n    ft_status=FT_Set_Charmap(face,face->charmaps[0]);\n  if (encoding != (const char *) NULL)\n    {\n      if (LocaleCompare(encoding,\"AdobeCustom\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_CUSTOM;\n      if (LocaleCompare(encoding,\"AdobeExpert\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_EXPERT;\n      if (LocaleCompare(encoding,\"AdobeStandard\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_STANDARD;\n      if (LocaleCompare(encoding,\"AppleRoman\") == 0)\n        encoding_type=FT_ENCODING_APPLE_ROMAN;\n      if (LocaleCompare(encoding,\"BIG5\") == 0)\n        encoding_type=FT_ENCODING_BIG5;\n#if defined(FT_ENCODING_PRC)\n      if (LocaleCompare(encoding,\"GB2312\") == 0)\n        encoding_type=FT_ENCODING_PRC;\n#endif\n#if defined(FT_ENCODING_JOHAB)\n      if (LocaleCompare(encoding,\"Johab\") == 0)\n        encoding_type=FT_ENCODING_JOHAB;\n#endif\n#if defined(FT_ENCODING_ADOBE_LATIN_1)\n      if (LocaleCompare(encoding,\"Latin-1\") == 0)\n        encoding_type=FT_ENCODING_ADOBE_LATIN_1;\n#endif\n#if defined(FT_ENCODING_ADOBE_LATIN_2)\n      if (LocaleCompare(encoding,\"Latin-2\") == 0)\n        encoding_type=FT_ENCODING_OLD_LATIN_2;\n#endif\n      if (LocaleCompare(encoding,\"None\") == 0)\n        encoding_type=FT_ENCODING_NONE;\n      if (LocaleCompare(encoding,\"SJIScode\") == 0)\n        encoding_type=FT_ENCODING_SJIS;\n      if (LocaleCompare(encoding,\"Symbol\") == 0)\n        encoding_type=FT_ENCODING_MS_SYMBOL;\n      if (LocaleCompare(encoding,\"Unicode\") == 0)\n        encoding_type=FT_ENCODING_UNICODE;\n      if (LocaleCompare(encoding,\"Wansung\") == 0)\n        encoding_type=FT_ENCODING_WANSUNG;\n      ft_status=FT_Select_Charmap(face,encoding_type);\n      if (ft_status != 0)\n        {\n          (void) FT_Done_Face(face);\n          (void) FT_Done_FreeType(library);\n          ThrowBinaryException(TypeError,\"UnrecognizedFontEncoding\",encoding);\n        }\n    }\n  /*\n    Set text size.\n  */\n  resolution.x=DefaultResolution;\n  resolution.y=DefaultResolution;\n  if (draw_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        geometry_flags;\n\n      geometry_flags=ParseGeometry(draw_info->density,&geometry_info);\n      resolution.x=geometry_info.rho;\n      resolution.y=geometry_info.sigma;\n      if ((geometry_flags & SigmaValue) == 0)\n        resolution.y=resolution.x;\n    }\n  ft_status=FT_Set_Char_Size(face,(FT_F26Dot6) (64.0*draw_info->pointsize),\n    (FT_F26Dot6) (64.0*draw_info->pointsize),(FT_UInt) resolution.x,\n    (FT_UInt) resolution.y);\n  if (ft_status != 0)\n    {\n      (void) FT_Done_Face(face);\n      (void) FT_Done_FreeType(library);\n      ThrowBinaryException(TypeError,\"UnableToReadFont\",draw_info->font);\n    }\n  metrics->pixels_per_em.x=face->size->metrics.x_ppem;\n  metrics->pixels_per_em.y=face->size->metrics.y_ppem;\n  metrics->ascent=(double) face->size->metrics.ascender/64.0;\n  metrics->descent=(double) face->size->metrics.descender/64.0;\n  metrics->width=0;\n  metrics->origin.x=0;\n  metrics->origin.y=0;\n  metrics->height=(double) face->size->metrics.height/64.0;\n  metrics->max_advance=0.0;\n  if (face->size->metrics.max_advance > MagickEpsilon)\n    metrics->max_advance=(double) face->size->metrics.max_advance/64.0;\n  metrics->bounds.x1=0.0;\n  metrics->bounds.y1=metrics->descent;\n  metrics->bounds.x2=metrics->ascent+metrics->descent;\n  metrics->bounds.y2=metrics->ascent+metrics->descent;\n  metrics->underline_position=face->underline_position/64.0;\n  metrics->underline_thickness=face->underline_thickness/64.0;\n  if ((draw_info->text == (char *) NULL) || (*draw_info->text == '\\0'))\n    {\n      (void) FT_Done_Face(face);\n      (void) FT_Done_FreeType(library);\n      return(MagickTrue);\n    }\n  /*\n    Compute bounding box.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\"Font %s; \"\n      \"font-encoding %s; text-encoding %s; pointsize %g\",\n      draw_info->font != (char *) NULL ? draw_info->font : \"none\",\n      encoding != (char *) NULL ? encoding : \"none\",\n      draw_info->encoding != (char *) NULL ? draw_info->encoding : \"none\",\n      draw_info->pointsize);\n  flags=FT_LOAD_DEFAULT;\n  if (draw_info->render == MagickFalse)\n    flags=FT_LOAD_NO_BITMAP;\n  if (draw_info->text_antialias == MagickFalse)\n    flags|=FT_LOAD_TARGET_MONO;\n  else\n    {\n#if defined(FT_LOAD_TARGET_LIGHT)\n      flags|=FT_LOAD_TARGET_LIGHT;\n#elif defined(FT_LOAD_TARGET_LCD)\n      flags|=FT_LOAD_TARGET_LCD;\n#endif\n    }\n  value=GetImageProperty(image,\"type:hinting\",exception);\n  if ((value != (const char *) NULL) && (LocaleCompare(value,\"off\") == 0))\n    flags|=FT_LOAD_NO_HINTING;\n  glyph.id=0;\n  glyph.image=NULL;\n  last_glyph.id=0;\n  last_glyph.image=NULL;\n  origin.x=0;\n  origin.y=0;\n  affine.xx=65536L;\n  affine.yx=0L;\n  affine.xy=0L;\n  affine.yy=65536L;\n  if (draw_info->render != MagickFalse)\n    {\n      affine.xx=(FT_Fixed) (65536L*draw_info->affine.sx+0.5);\n      affine.yx=(FT_Fixed) (-65536L*draw_info->affine.rx+0.5);\n      affine.xy=(FT_Fixed) (-65536L*draw_info->affine.ry+0.5);\n      affine.yy=(FT_Fixed) (65536L*draw_info->affine.sy+0.5);\n    }\n  annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  if (annotate_info->dash_pattern != (double *) NULL)\n    annotate_info->dash_pattern[0]=0.0;\n  (void) CloneString(&annotate_info->primitive,\"path '\");\n  status=MagickTrue;\n  if (draw_info->render != MagickFalse)\n    {\n      if (image->storage_class != DirectClass)\n        (void) SetImageStorageClass(image,DirectClass,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n    }\n  point.x=0.0;\n  point.y=0.0;\n  for (p=draw_info->text; GetUTFCode(p) != 0; p+=GetUTFOctets(p))\n    if (GetUTFCode(p) < 0)\n      break;\n  utf8=(unsigned char *) NULL;\n  if (GetUTFCode(p) == 0)\n    p=draw_info->text;\n  else\n    {\n      utf8=ConvertLatin1ToUTF8((unsigned char *) draw_info->text);\n      if (utf8 != (unsigned char *) NULL)\n        p=(char *) utf8;\n    }\n  grapheme=(GraphemeInfo *) NULL;\n  length=ComplexTextLayout(image,draw_info,p,strlen(p),face,flags,&grapheme,\n    exception);\n  code=0;\n  for (i=0; i < (ssize_t) length; i++)\n  {\n    FT_Outline\n      outline;\n\n    /*\n      Render UTF-8 sequence.\n    */\n    glyph.id=(FT_UInt) grapheme[i].index;\n    if (glyph.id == 0)\n      glyph.id=FT_Get_Char_Index(face,' ');\n    if ((glyph.id != 0) && (last_glyph.id != 0))\n      origin.x+=(FT_Pos) (64.0*draw_info->kerning);\n    glyph.origin=origin;\n    glyph.origin.x+=(FT_Pos) grapheme[i].x_offset;\n    glyph.origin.y+=(FT_Pos) grapheme[i].y_offset;\n    glyph.image=0;\n    ft_status=FT_Load_Glyph(face,glyph.id,flags);\n    if (ft_status != 0)\n      continue;\n    ft_status=FT_Get_Glyph(face->glyph,&glyph.image);\n    if (ft_status != 0)\n      continue;\n    outline=((FT_OutlineGlyph) glyph.image)->outline;\n    ft_status=FT_Outline_Get_BBox(&outline,&bounds);\n    if (ft_status != 0)\n      continue;\n    if ((p == draw_info->text) || (bounds.xMin < metrics->bounds.x1))\n      if (bounds.xMin != 0)\n        metrics->bounds.x1=(double) bounds.xMin;\n    if ((p == draw_info->text) || (bounds.yMin < metrics->bounds.y1))\n      if (bounds.yMin != 0)\n        metrics->bounds.y1=(double) bounds.yMin;\n    if ((p == draw_info->text) || (bounds.xMax > metrics->bounds.x2))\n      if (bounds.xMax != 0)\n        metrics->bounds.x2=(double) bounds.xMax;\n    if ((p == draw_info->text) || (bounds.yMax > metrics->bounds.y2))\n      if (bounds.yMax != 0)\n        metrics->bounds.y2=(double) bounds.yMax;\n    if (((draw_info->stroke.alpha != TransparentAlpha) ||\n         (draw_info->stroke_pattern != (Image *) NULL)) &&\n        ((status != MagickFalse) && (draw_info->render != MagickFalse)))\n      {\n        /*\n          Trace the glyph.\n        */\n        annotate_info->affine.tx=glyph.origin.x/64.0;\n        annotate_info->affine.ty=(-glyph.origin.y/64.0);\n        if ((outline.n_contours > 0) && (outline.n_points > 0))\n          ft_status=FT_Outline_Decompose(&outline,&OutlineMethods,\n            annotate_info);\n      }\n    FT_Vector_Transform(&glyph.origin,&affine);\n    (void) FT_Glyph_Transform(glyph.image,&affine,&glyph.origin);\n    ft_status=FT_Glyph_To_Bitmap(&glyph.image,ft_render_mode_normal,\n      (FT_Vector *) NULL,MagickTrue);\n    if (ft_status != 0)\n      continue;\n    bitmap=(FT_BitmapGlyph) glyph.image;\n    point.x=offset->x+bitmap->left;\n    if (bitmap->bitmap.pixel_mode == ft_pixel_mode_mono)\n      point.x=offset->x+(origin.x >> 6);\n    point.y=offset->y-bitmap->top;\n    if (draw_info->render != MagickFalse)\n      {\n        CacheView\n          *image_view;\n\n        MagickBooleanType\n          transparent_fill;\n\n        register unsigned char\n          *r;\n\n        /*\n          Rasterize the glyph.\n        */\n        transparent_fill=((draw_info->fill.alpha == TransparentAlpha) &&\n          (draw_info->fill_pattern == (Image *) NULL) &&\n          (draw_info->stroke.alpha == TransparentAlpha) &&\n          (draw_info->stroke_pattern == (Image *) NULL)) ? MagickTrue :\n          MagickFalse;\n        image_view=AcquireAuthenticCacheView(image,exception);\n        r=bitmap->bitmap.buffer;\n        for (y=0; y < (ssize_t) bitmap->bitmap.rows; y++)\n        {\n          double\n            fill_opacity;\n\n          MagickBooleanType\n            active,\n            sync;\n\n          PixelInfo\n            fill_color;\n\n          register Quantum\n            *magick_restrict q;\n\n          register ssize_t\n            x;\n\n          ssize_t\n            n,\n            x_offset,\n            y_offset;\n\n          if (status == MagickFalse)\n            continue;\n          x_offset=(ssize_t) ceil(point.x-0.5);\n          y_offset=(ssize_t) ceil(point.y+y-0.5);\n          if ((y_offset < 0) || (y_offset >= (ssize_t) image->rows))\n            continue;\n          q=(Quantum *) NULL;\n          if ((x_offset < 0) || (x_offset >= (ssize_t) image->columns))\n            active=MagickFalse;\n          else\n            {\n              q=GetCacheViewAuthenticPixels(image_view,x_offset,y_offset,\n                bitmap->bitmap.width,1,exception);\n              active=q != (Quantum *) NULL ? MagickTrue : MagickFalse;\n            }\n          n=y*bitmap->bitmap.pitch-1;\n          for (x=0; x < (ssize_t) bitmap->bitmap.width; x++)\n          {\n            n++;\n            x_offset++;\n            if ((x_offset < 0) || (x_offset >= (ssize_t) image->columns))\n              {\n                if (q != (Quantum *) NULL)\n                  q+=GetPixelChannels(image);\n                continue;\n              }\n            if (bitmap->bitmap.pixel_mode != ft_pixel_mode_mono)\n              fill_opacity=(double) (r[n])/(bitmap->bitmap.num_grays-1);\n            else\n              fill_opacity=((r[(x >> 3)+y*bitmap->bitmap.pitch] &\n                (1 << (~x & 0x07)))) == 0 ? 0.0 : 1.0;\n            if (draw_info->text_antialias == MagickFalse)\n              fill_opacity=fill_opacity >= 0.5 ? 1.0 : 0.0;\n            if (active == MagickFalse)\n              q=GetCacheViewAuthenticPixels(image_view,x_offset,y_offset,1,1,\n                exception);\n            if (q == (Quantum *) NULL)\n              continue;\n            if (transparent_fill == MagickFalse)\n              {\n                GetPixelInfo(image,&fill_color);\n                GetFillColor(draw_info,x_offset,y_offset,&fill_color,exception);\n                fill_opacity=fill_opacity*fill_color.alpha;\n                CompositePixelOver(image,&fill_color,fill_opacity,q,\n                  GetPixelAlpha(image,q),q);\n              }\n            else\n              {\n                double\n                  Sa,\n                  Da;\n\n                Da=1.0-(QuantumScale*GetPixelAlpha(image,q));\n                Sa=fill_opacity;\n                fill_opacity=(1.0-RoundToUnity(Sa+Da-Sa*Da))*QuantumRange;\n                SetPixelAlpha(image,fill_opacity,q);\n              }\n            if (active == MagickFalse)\n              {\n                sync=SyncCacheViewAuthenticPixels(image_view,exception);\n                if (sync == MagickFalse)\n                  status=MagickFalse;\n              }\n            q+=GetPixelChannels(image);\n          }\n          sync=SyncCacheViewAuthenticPixels(image_view,exception);\n          if (sync == MagickFalse)\n            status=MagickFalse;\n        }\n        image_view=DestroyCacheView(image_view);\n        if (((draw_info->stroke.alpha != TransparentAlpha) ||\n             (draw_info->stroke_pattern != (Image *) NULL)) &&\n            (status != MagickFalse))\n          {\n            /*\n              Draw text stroke.\n            */\n            annotate_info->linejoin=RoundJoin;\n            annotate_info->affine.tx=offset->x;\n            annotate_info->affine.ty=offset->y;\n            (void) ConcatenateString(&annotate_info->primitive,\"'\");\n            if (strlen(annotate_info->primitive) > 7)\n              (void) DrawImage(image,annotate_info,exception);\n            (void) CloneString(&annotate_info->primitive,\"path '\");\n          }\n      }\n    if ((fabs(draw_info->interword_spacing) >= MagickEpsilon) &&\n        (IsUTFSpace(GetUTFCode(p+grapheme[i].cluster)) != MagickFalse) &&\n        (IsUTFSpace(code) == MagickFalse))\n      origin.x+=(FT_Pos) (64.0*draw_info->interword_spacing);\n    else\n      origin.x+=(FT_Pos) grapheme[i].x_advance;\n    metrics->origin.x=(double) origin.x;\n    metrics->origin.y=(double) origin.y;\n    if (metrics->origin.x > metrics->width)\n      metrics->width=metrics->origin.x;\n    if (last_glyph.image != 0)\n      {\n        FT_Done_Glyph(last_glyph.image);\n        last_glyph.image=0;\n      }\n    last_glyph=glyph;\n    code=GetUTFCode(p+grapheme[i].cluster);\n  }\n  if (grapheme != (GraphemeInfo *) NULL)\n    grapheme=(GraphemeInfo *) RelinquishMagickMemory(grapheme);\n  if (utf8 != (unsigned char *) NULL)\n    utf8=(unsigned char *) RelinquishMagickMemory(utf8);\n  if (glyph.image != 0)\n    {\n      FT_Done_Glyph(glyph.image);\n      glyph.image=0;\n    }\n  /*\n    Determine font metrics.\n  */\n  metrics->bounds.x1/=64.0;\n  metrics->bounds.y1/=64.0;\n  metrics->bounds.x2/=64.0;\n  metrics->bounds.y2/=64.0;\n  metrics->origin.x/=64.0;\n  metrics->origin.y/=64.0;\n  metrics->width/=64.0;\n  /*\n    Relinquish resources.\n  */\n  annotate_info=DestroyDrawInfo(annotate_info);\n  (void) FT_Done_Face(face);\n  (void) FT_Done_FreeType(library);\n  return(status);\n}\n#else\nstatic MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,\n  const char *magick_unused(encoding),const PointInfo *offset,\n  TypeMetric *metrics,ExceptionInfo *exception)\n{\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"'%s' (Freetype)\",\n    draw_info->font != (char *) NULL ? draw_info->font : \"none\");\n  return(RenderPostscript(image,draw_info,offset,metrics,exception));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r P o s t s c r i p t                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderPostscript() renders text on the image with a Postscript font.  It\n%  also returns the bounding box of the text relative to the image.\n%\n%  The format of the RenderPostscript method is:\n%\n%      MagickBooleanType RenderPostscript(Image *image,DrawInfo *draw_info,\n%        const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic char *EscapeParenthesis(const char *source)\n{\n  char\n    *destination;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  size_t\n    length;\n\n  assert(source != (const char *) NULL);\n  length=0;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      {\n        if (~length < 1)\n          ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n        length++;\n      }\n    length++;\n  }\n  destination=(char *) NULL;\n  if (~length >= (MagickPathExtent-1))\n    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n      sizeof(*destination));\n  if (destination == (char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n  *destination='\\0';\n  q=destination;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      *q++='\\\\';\n    *q++=(*p);\n  }\n  *q='\\0';\n  return(destination);\n}\n\nstatic MagickBooleanType RenderPostscript(Image *image,\n  const DrawInfo *draw_info,const PointInfo *offset,TypeMetric *metrics,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    geometry[MagickPathExtent],\n    *text;\n\n  FILE\n    *file;\n\n  Image\n    *annotate_image;\n\n  ImageInfo\n    *annotate_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    identity;\n\n  PointInfo\n    extent,\n    point,\n    resolution;\n\n  register ssize_t\n    i;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  /*\n    Render label with a Postscript font.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(AnnotateEvent,GetMagickModule(),\n      \"Font %s; pointsize %g\",draw_info->font != (char *) NULL ?\n      draw_info->font : \"none\",draw_info->pointsize);\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleFile(file,\"%%!PS-Adobe-3.0\\n\");\n  (void) FormatLocaleFile(file,\"/ReencodeType\\n\");\n  (void) FormatLocaleFile(file,\"{\\n\");\n  (void) FormatLocaleFile(file,\"  findfont dup length\\n\");\n  (void) FormatLocaleFile(file,\n    \"  dict begin { 1 index /FID ne {def} {pop pop} ifelse } forall\\n\");\n  (void) FormatLocaleFile(file,\n    \"  /Encoding ISOLatin1Encoding def currentdict end definefont pop\\n\");\n  (void) FormatLocaleFile(file,\"} bind def\\n\");\n  /*\n    Sample to compute bounding box.\n  */\n  identity=(fabs(draw_info->affine.sx-draw_info->affine.sy) < MagickEpsilon) &&\n    (fabs(draw_info->affine.rx) < MagickEpsilon) &&\n    (fabs(draw_info->affine.ry) < MagickEpsilon) ? MagickTrue : MagickFalse;\n  extent.x=0.0;\n  extent.y=0.0;\n  length=strlen(draw_info->text);\n  for (i=0; i <= (ssize_t) (length+2); i++)\n  {\n    point.x=fabs(draw_info->affine.sx*i*draw_info->pointsize+\n      draw_info->affine.ry*2.0*draw_info->pointsize);\n    point.y=fabs(draw_info->affine.rx*i*draw_info->pointsize+\n      draw_info->affine.sy*2.0*draw_info->pointsize);\n    if (point.x > extent.x)\n      extent.x=point.x;\n    if (point.y > extent.y)\n      extent.y=point.y;\n  }\n  (void) FormatLocaleFile(file,\"%g %g moveto\\n\",identity  != MagickFalse ? 0.0 :\n    extent.x/2.0,extent.y/2.0);\n  (void) FormatLocaleFile(file,\"%g %g scale\\n\",draw_info->pointsize,\n    draw_info->pointsize);\n  if ((draw_info->font == (char *) NULL) || (*draw_info->font == '\\0') ||\n      (strchr(draw_info->font,'/') != (char *) NULL))\n    (void) FormatLocaleFile(file,\n      \"/Times-Roman-ISO dup /Times-Roman ReencodeType findfont setfont\\n\");\n  else\n    (void) FormatLocaleFile(file,\n      \"/%s-ISO dup /%s ReencodeType findfont setfont\\n\",draw_info->font,\n      draw_info->font);\n  (void) FormatLocaleFile(file,\"[%g %g %g %g 0 0] concat\\n\",\n    draw_info->affine.sx,-draw_info->affine.rx,-draw_info->affine.ry,\n    draw_info->affine.sy);\n  text=EscapeParenthesis(draw_info->text);\n  if (identity == MagickFalse)\n    (void) FormatLocaleFile(file,\"(%s) stringwidth pop -0.5 mul -0.5 rmoveto\\n\",\n      text);\n  (void) FormatLocaleFile(file,\"(%s) show\\n\",text);\n  text=DestroyString(text);\n  (void) FormatLocaleFile(file,\"showpage\\n\");\n  (void) fclose(file);\n  (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g+0+0!\",\n    floor(extent.x+0.5),floor(extent.y+0.5));\n  annotate_info=AcquireImageInfo();\n  (void) FormatLocaleString(annotate_info->filename,MagickPathExtent,\"ps:%s\",\n    filename);\n  (void) CloneString(&annotate_info->page,geometry);\n  if (draw_info->density != (char *) NULL)\n    (void) CloneString(&annotate_info->density,draw_info->density);\n  annotate_info->antialias=draw_info->text_antialias;\n  annotate_image=ReadImage(annotate_info,exception);\n  CatchException(exception);\n  annotate_info=DestroyImageInfo(annotate_info);\n  (void) RelinquishUniqueFileResource(filename);\n  if (annotate_image == (Image *) NULL)\n    return(MagickFalse);\n  (void) NegateImage(annotate_image,MagickFalse,exception);\n  resolution.x=DefaultResolution;\n  resolution.y=DefaultResolution;\n  if (draw_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(draw_info->density,&geometry_info);\n      resolution.x=geometry_info.rho;\n      resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        resolution.y=resolution.x;\n    }\n  if (identity == MagickFalse)\n    (void) TransformImage(&annotate_image,\"0x0\",(char *) NULL,exception);\n  else\n    {\n      RectangleInfo\n        crop_info;\n\n      crop_info=GetImageBoundingBox(annotate_image,exception);\n      crop_info.height=(size_t) ((resolution.y/DefaultResolution)*\n        ExpandAffine(&draw_info->affine)*draw_info->pointsize+0.5);\n      crop_info.y=(ssize_t) ceil((resolution.y/DefaultResolution)*extent.y/8.0-\n        0.5);\n      (void) FormatLocaleString(geometry,MagickPathExtent,\n        \"%.20gx%.20g%+.20g%+.20g\",(double) crop_info.width,(double)\n        crop_info.height,(double) crop_info.x,(double) crop_info.y);\n      (void) TransformImage(&annotate_image,geometry,(char *) NULL,exception);\n    }\n  metrics->pixels_per_em.x=(resolution.y/DefaultResolution)*\n    ExpandAffine(&draw_info->affine)*draw_info->pointsize;\n  metrics->pixels_per_em.y=metrics->pixels_per_em.x;\n  metrics->ascent=metrics->pixels_per_em.x;\n  metrics->descent=metrics->pixels_per_em.y/-5.0;\n  metrics->width=(double) annotate_image->columns/\n    ExpandAffine(&draw_info->affine);\n  metrics->height=1.152*metrics->pixels_per_em.x;\n  metrics->max_advance=metrics->pixels_per_em.x;\n  metrics->bounds.x1=0.0;\n  metrics->bounds.y1=metrics->descent;\n  metrics->bounds.x2=metrics->ascent+metrics->descent;\n  metrics->bounds.y2=metrics->ascent+metrics->descent;\n  metrics->underline_position=(-2.0);\n  metrics->underline_thickness=1.0;\n  if (draw_info->render == MagickFalse)\n    {\n      annotate_image=DestroyImage(annotate_image);\n      return(MagickTrue);\n    }\n  if (draw_info->fill.alpha != TransparentAlpha)\n    {\n      CacheView\n        *annotate_view;\n\n      MagickBooleanType\n        sync;\n\n      PixelInfo\n        fill_color;\n\n      /*\n        Render fill color.\n      */\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      if (annotate_image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(annotate_image,OpaqueAlphaChannel,\n          exception);\n      fill_color=draw_info->fill;\n      annotate_view=AcquireAuthenticCacheView(annotate_image,exception);\n      for (y=0; y < (ssize_t) annotate_image->rows; y++)\n      {\n        register ssize_t\n          x;\n\n        register Quantum\n          *magick_restrict q;\n\n        q=GetCacheViewAuthenticPixels(annotate_view,0,y,annotate_image->columns,\n          1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) annotate_image->columns; x++)\n        {\n          GetFillColor(draw_info,x,y,&fill_color,exception);\n          SetPixelAlpha(annotate_image,ClampToQuantum((((double) QuantumScale*\n            GetPixelIntensity(annotate_image,q)*fill_color.alpha))),q);\n          SetPixelRed(annotate_image,fill_color.red,q);\n          SetPixelGreen(annotate_image,fill_color.green,q);\n          SetPixelBlue(annotate_image,fill_color.blue,q);\n          q+=GetPixelChannels(annotate_image);\n        }\n        sync=SyncCacheViewAuthenticPixels(annotate_view,exception);\n        if (sync == MagickFalse)\n          break;\n      }\n      annotate_view=DestroyCacheView(annotate_view);\n      (void) CompositeImage(image,annotate_image,OverCompositeOp,MagickTrue,\n        (ssize_t) ceil(offset->x-0.5),(ssize_t) ceil(offset->y-(metrics->ascent+\n        metrics->descent)-0.5),exception);\n    }\n  annotate_image=DestroyImage(annotate_image);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e n d e r X 1 1                                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RenderX11() renders text on the image with an X11 font.  It also returns the\n%  bounding box of the text relative to the image.\n%\n%  The format of the RenderX11 method is:\n%\n%      MagickBooleanType RenderX11(Image *image,DrawInfo *draw_info,\n%        const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o draw_info: the draw info.\n%\n%    o offset: (x,y) location of text relative to image.\n%\n%    o metrics: bounding box of text.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType RenderX11(Image *image,const DrawInfo *draw_info,\n  const PointInfo *offset,TypeMetric *metrics,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  if (annotate_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&annotate_semaphore);\n  LockSemaphoreInfo(annotate_semaphore);\n  status=XRenderImage(image,draw_info,offset,metrics,exception);\n  UnlockSemaphoreInfo(annotate_semaphore);\n  return(status);\n}\n", "/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               FFFFF   OOO   U   U  RRRR   IIIII  EEEEE  RRRR                %\n%               F      O   O  U   U  R   R    I    E      R   R               %\n%               FFF    O   O  U   U  RRRR     I    EEE    RRRR                %\n%               F      O   O  U   U  R R      I    E      R R                 %\n%               F       OOO    UUU   R  R   IIIII  EEEEE  R  R                %\n%                                                                             %\n%                                                                             %\n%                MagickCore Discrete Fourier Transform Methods                %\n%                                                                             %\n%                              Software Design                                %\n%                                Sean Burke                                   %\n%                               Fred Weinhaus                                 %\n%                                   Cristy                                    %\n%                                 July 2009                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/fourier.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#if defined(MAGICKCORE_FFTW_DELEGATE)\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n#include <complex.h>\n#endif\n#include <fftw3.h>\n#if !defined(MAGICKCORE_HAVE_CABS)\n#define cabs(z)  (sqrt(z[0]*z[0]+z[1]*z[1]))\n#endif\n#if !defined(MAGICKCORE_HAVE_CARG)\n#define carg(z)  (atan2(cimag(z),creal(z)))\n#endif\n#if !defined(MAGICKCORE_HAVE_CIMAG)\n#define cimag(z)  (z[1])\n#endif\n#if !defined(MAGICKCORE_HAVE_CREAL)\n#define creal(z)  (z[0])\n#endif\n#endif\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _FourierInfo\n{\n  PixelChannel\n    channel;\n\n  MagickBooleanType\n    modulus;\n\n  size_t\n    width,\n    height;\n\n  ssize_t\n    center;\n} FourierInfo;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C o m p l e x I m a g e s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ComplexImages() performs complex mathematics on an image sequence.\n%\n%  The format of the ComplexImages method is:\n%\n%      MagickBooleanType ComplexImages(Image *images,const ComplexOperator op,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o op: A complex operator.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n  ExceptionInfo *exception)\n{\n#define ComplexImageTag  \"Complex/Image\"\n\n  CacheView\n    *Ai_view,\n    *Ar_view,\n    *Bi_view,\n    *Br_view,\n    *Ci_view,\n    *Cr_view;\n\n  const char\n    *artifact;\n\n  const Image\n    *Ai_image,\n    *Ar_image,\n    *Bi_image,\n    *Br_image;\n\n  double\n    snr;\n\n  Image\n    *Ci_image,\n    *complex_images,\n    *Cr_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (images->next == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return(image);\n    }\n  image->depth=32UL;\n  complex_images=NewImageList();\n  AppendImageToList(&complex_images,image);\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    {\n      complex_images=DestroyImageList(complex_images);\n      return(complex_images);\n    }\n  AppendImageToList(&complex_images,image);\n  /*\n    Apply complex mathematics to image pixels.\n  */\n  artifact=GetImageArtifact(image,\"complex:snr\");\n  snr=0.0;\n  if (artifact != (const char *) NULL)\n    snr=StringToDouble(artifact,(char **) NULL);\n  Ar_image=images;\n  Ai_image=images->next;\n  Br_image=images;\n  Bi_image=images->next;\n  if ((images->next->next != (Image *) NULL) &&\n      (images->next->next->next != (Image *) NULL))\n    {\n      Br_image=images->next->next;\n      Bi_image=images->next->next->next;\n    }\n  Cr_image=complex_images;\n  Ci_image=complex_images->next;\n  Ar_view=AcquireVirtualCacheView(Ar_image,exception);\n  Ai_view=AcquireVirtualCacheView(Ai_image,exception);\n  Br_view=AcquireVirtualCacheView(Br_image,exception);\n  Bi_view=AcquireVirtualCacheView(Bi_image,exception);\n  Cr_view=AcquireAuthenticCacheView(Cr_image,exception);\n  Ci_view=AcquireAuthenticCacheView(Ci_image,exception);\n  status=MagickTrue;\n  progress=0;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(images,complex_images,images->rows,1L)\n#endif\n  for (y=0; y < (ssize_t) images->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict Ai,\n      *magick_restrict Ar,\n      *magick_restrict Bi,\n      *magick_restrict Br;\n\n    register Quantum\n      *magick_restrict Ci,\n      *magick_restrict Cr;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,\n      MagickMax(Ar_image->columns,Cr_image->columns),1,exception);\n    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,\n      MagickMax(Ai_image->columns,Ci_image->columns),1,exception);\n    Br=GetCacheViewVirtualPixels(Br_view,0,y,\n      MagickMax(Br_image->columns,Cr_image->columns),1,exception);\n    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,\n      MagickMax(Bi_image->columns,Ci_image->columns),1,exception);\n    Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n    Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n    if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || \n        (Br == (const Quantum *) NULL) || (Bi == (const Quantum *) NULL) ||\n        (Cr == (Quantum *) NULL) || (Ci == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) images->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(images); i++)\n      {\n        switch (op)\n        {\n          case AddComplexOperator:\n          {\n            Cr[i]=Ar[i]+Br[i];\n            Ci[i]=Ai[i]+Bi[i];\n            break;\n          }\n          case ConjugateComplexOperator:\n          default:\n          {\n            Cr[i]=Ar[i];\n            Ci[i]=(-Bi[i]);\n            break;\n          }\n          case DivideComplexOperator:\n          {\n            double\n              gamma;\n\n            gamma=PerceptibleReciprocal(Br[i]*Br[i]+Bi[i]*Bi[i]+snr);\n            Cr[i]=gamma*(Ar[i]*Br[i]+Ai[i]*Bi[i]);\n            Ci[i]=gamma*(Ai[i]*Br[i]-Ar[i]*Bi[i]);\n            break;\n          }\n          case MagnitudePhaseComplexOperator:\n          {\n            Cr[i]=sqrt(Ar[i]*Ar[i]+Ai[i]*Ai[i]);\n            Ci[i]=atan2(Ai[i],Ar[i])/(2.0*MagickPI)+0.5;\n            break;\n          }\n          case MultiplyComplexOperator:\n          {\n            Cr[i]=QuantumScale*(Ar[i]*Br[i]-Ai[i]*Bi[i]);\n            Ci[i]=QuantumScale*(Ai[i]*Br[i]+Ar[i]*Bi[i]);\n            break;\n          }\n          case RealImaginaryComplexOperator:\n          {\n            Cr[i]=Ar[i]*cos(2.0*MagickPI*(Ai[i]-0.5));\n            Ci[i]=Ar[i]*sin(2.0*MagickPI*(Ai[i]-0.5));\n            break;\n          }\n          case SubtractComplexOperator:\n          {\n            Cr[i]=Ar[i]-Br[i];\n            Ci[i]=Ai[i]-Bi[i];\n            break;\n          }\n        }\n      }\n      Ar+=GetPixelChannels(Ar_image);\n      Ai+=GetPixelChannels(Ai_image);\n      Br+=GetPixelChannels(Br_image);\n      Bi+=GetPixelChannels(Bi_image);\n      Cr+=GetPixelChannels(Cr_image);\n      Ci+=GetPixelChannels(Ci_image);\n    }\n    if (SyncCacheViewAuthenticPixels(Ci_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (SyncCacheViewAuthenticPixels(Cr_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,ComplexImageTag,progress,images->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  Cr_view=DestroyCacheView(Cr_view);\n  Ci_view=DestroyCacheView(Ci_view);\n  Br_view=DestroyCacheView(Br_view);\n  Bi_view=DestroyCacheView(Bi_view);\n  Ar_view=DestroyCacheView(Ar_view);\n  Ai_view=DestroyCacheView(Ai_view);\n  if (status == MagickFalse)\n    complex_images=DestroyImageList(complex_images);\n  return(complex_images);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     F o r w a r d F o u r i e r T r a n s f o r m I m a g e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ForwardFourierTransformImage() implements the discrete Fourier transform\n%  (DFT) of the image either as a magnitude / phase or real / imaginary image\n%  pair.\n%\n%  The format of the ForwadFourierTransformImage method is:\n%\n%      Image *ForwardFourierTransformImage(const Image *image,\n%        const MagickBooleanType modulus,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o modulus: if true, return as transform as a magnitude / phase pair\n%      otherwise a real / imaginary image pair.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FFTW_DELEGATE)\n\nstatic MagickBooleanType RollFourier(const size_t width,const size_t height,\n  const ssize_t x_offset,const ssize_t y_offset,double *roll_pixels)\n{\n  double\n    *source_pixels;\n\n  MemoryInfo\n    *source_info;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    u,\n    v,\n    y;\n\n  /*\n    Move zero frequency (DC, average color) from (0,0) to (width/2,height/2).\n  */\n  source_info=AcquireVirtualMemory(width,height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    return(MagickFalse);\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  i=0L;\n  for (y=0L; y < (ssize_t) height; y++)\n  {\n    if (y_offset < 0L)\n      v=((y+y_offset) < 0L) ? y+y_offset+(ssize_t) height : y+y_offset;\n    else\n      v=((y+y_offset) > ((ssize_t) height-1L)) ? y+y_offset-(ssize_t) height :\n        y+y_offset;\n    for (x=0L; x < (ssize_t) width; x++)\n    {\n      if (x_offset < 0L)\n        u=((x+x_offset) < 0L) ? x+x_offset+(ssize_t) width : x+x_offset;\n      else\n        u=((x+x_offset) > ((ssize_t) width-1L)) ? x+x_offset-(ssize_t) width :\n          x+x_offset;\n      source_pixels[v*width+u]=roll_pixels[i++];\n    }\n  }\n  (void) memcpy(roll_pixels,source_pixels,height*width*\n    sizeof(*source_pixels));\n  source_info=RelinquishVirtualMemory(source_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ForwardQuadrantSwap(const size_t width,\n  const size_t height,double *source_pixels,double *forward_pixels)\n{\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Swap quadrants.\n  */\n  center=(ssize_t) (width/2L)+1L;\n  status=RollFourier((size_t) center,height,0L,(ssize_t) height/2L,\n    source_pixels);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[y*width+x+width/2L]=source_pixels[y*center+x];\n  for (y=1; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[(height-y)*width+width/2L-x-1L]=\n        source_pixels[y*center+x+1L];\n  for (x=0L; x < (ssize_t) (width/2L); x++)\n    forward_pixels[width/2L-x-1L]=source_pixels[x+1L];\n  return(MagickTrue);\n}\n\nstatic void CorrectPhaseLHS(const size_t width,const size_t height,\n  double *fourier_pixels)\n{\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      fourier_pixels[y*width+x]*=(-1.0);\n}\n\nstatic MagickBooleanType ForwardFourier(const FourierInfo *fourier_info,\n  Image *image,double *magnitude,double *phase,ExceptionInfo *exception)\n{\n  CacheView\n    *magnitude_view,\n    *phase_view;\n\n  double\n    *magnitude_pixels,\n    *phase_pixels;\n\n  Image\n    *magnitude_image,\n    *phase_image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *magnitude_info,\n    *phase_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    i,\n    y;\n\n  magnitude_image=GetFirstImageInList(image);\n  phase_image=GetNextImageInList(image);\n  if (phase_image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  /*\n    Create \"Fourier Transform\" image from constituent arrays.\n  */\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*phase_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL))\n    {\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (magnitude_info != (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  (void) memset(magnitude_pixels,0,fourier_info->width*\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  (void) memset(phase_pixels,0,fourier_info->width*\n    fourier_info->height*sizeof(*phase_pixels));\n  status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,\n    magnitude,magnitude_pixels);\n  if (status != MagickFalse)\n    status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,phase,\n      phase_pixels);\n  CorrectPhaseLHS(fourier_info->width,fourier_info->height,phase_pixels);\n  if (fourier_info->modulus != MagickFalse)\n    {\n      i=0L;\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->width; x++)\n        {\n          phase_pixels[i]/=(2.0*MagickPI);\n          phase_pixels[i]+=0.5;\n          i++;\n        }\n    }\n  magnitude_view=AcquireAuthenticCacheView(magnitude_image,exception);\n  i=0L;\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    q=GetCacheViewAuthenticPixels(magnitude_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          SetPixelRed(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          SetPixelGreen(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          SetPixelBlue(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          SetPixelBlack(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          SetPixelAlpha(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n      }\n      i++;\n      q+=GetPixelChannels(magnitude_image);\n    }\n    status=SyncCacheViewAuthenticPixels(magnitude_view,exception);\n    if (status == MagickFalse)\n      break;\n  }\n  magnitude_view=DestroyCacheView(magnitude_view);\n  i=0L;\n  phase_view=AcquireAuthenticCacheView(phase_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    q=GetCacheViewAuthenticPixels(phase_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          SetPixelRed(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          SetPixelGreen(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          SetPixelBlue(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          SetPixelBlack(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          SetPixelAlpha(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n      }\n      i++;\n      q+=GetPixelChannels(phase_image);\n    }\n    status=SyncCacheViewAuthenticPixels(phase_view,exception);\n    if (status == MagickFalse)\n      break;\n   }\n  phase_view=DestroyCacheView(phase_view);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  return(status);\n}\n\nstatic MagickBooleanType ForwardFourierTransform(FourierInfo *fourier_info,\n  const Image *image,double *magnitude_pixels,double *phase_pixels,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const char\n    *value;\n\n  double\n    *source_pixels;\n\n  fftw_complex\n    *forward_pixels;\n\n  fftw_plan\n    fftw_r2c_plan;\n\n  MemoryInfo\n    *forward_info,\n    *source_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Generate the forward Fourier transform.\n  */\n  source_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  memset(source_pixels,0,fourier_info->width*fourier_info->height*\n    sizeof(*source_pixels));\n  i=0L;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(image_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          source_pixels[i]=QuantumScale*GetPixelRed(image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelGreen(image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelBlue(image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelBlack(image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelAlpha(image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  forward_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    (fourier_info->height/2+1)*sizeof(*forward_pixels));\n  if (forward_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      source_info=(MemoryInfo *) RelinquishVirtualMemory(source_info);\n      return(MagickFalse);\n    }\n  forward_pixels=(fftw_complex *) GetVirtualMemoryBlob(forward_info);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp critical (MagickCore_ForwardFourierTransform)\n#endif\n  fftw_r2c_plan=fftw_plan_dft_r2c_2d(fourier_info->width,fourier_info->height,\n    source_pixels,forward_pixels,FFTW_ESTIMATE);\n  fftw_execute_dft_r2c(fftw_r2c_plan,source_pixels,forward_pixels);\n  fftw_destroy_plan(fftw_r2c_plan);\n  source_info=(MemoryInfo *) RelinquishVirtualMemory(source_info);\n  value=GetImageArtifact(image,\"fourier:normalize\");\n  if ((value == (const char *) NULL) || (LocaleCompare(value,\"forward\") == 0))\n    {\n      double\n        gamma;\n\n      /*\n        Normalize fourier transform.\n      */\n      i=0L;\n      gamma=PerceptibleReciprocal((double) fourier_info->width*\n        fourier_info->height);\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->center; x++)\n        {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n          forward_pixels[i]*=gamma;\n#else\n          forward_pixels[i][0]*=gamma;\n          forward_pixels[i][1]*=gamma;\n#endif\n          i++;\n        }\n    }\n  /*\n    Generate magnitude and phase (or real and imaginary).\n  */\n  i=0L;\n  if (fourier_info->modulus != MagickFalse)\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n        magnitude_pixels[i]=cabs(forward_pixels[i]);\n        phase_pixels[i]=carg(forward_pixels[i]);\n        i++;\n      }\n  else\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n        magnitude_pixels[i]=creal(forward_pixels[i]);\n        phase_pixels[i]=cimag(forward_pixels[i]);\n        i++;\n      }\n  forward_info=(MemoryInfo *) RelinquishVirtualMemory(forward_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ForwardFourierTransformChannel(const Image *image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  double\n    *magnitude_pixels,\n    *phase_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *magnitude_info,\n    *phase_info;\n\n  fourier_info.width=image->columns;\n  fourier_info.height=image->rows;\n  if ((image->columns != image->rows) || ((image->columns % 2) != 0) ||\n      ((image->rows % 2) != 0))\n    {\n      size_t extent=image->columns < image->rows ? image->rows : image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*phase_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL))\n    {\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (magnitude_info == (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  status=ForwardFourierTransform(&fourier_info,image,magnitude_pixels,\n    phase_pixels,exception);\n  if (status != MagickFalse)\n    status=ForwardFourier(&fourier_info,fourier_image,magnitude_pixels,\n      phase_pixels,exception);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  return(status);\n}\n#endif\n\nMagickExport Image *ForwardFourierTransformImage(const Image *image,\n  const MagickBooleanType modulus,ExceptionInfo *exception)\n{\n  Image\n    *fourier_image;\n\n  fourier_image=NewImageList();\n#if !defined(MAGICKCORE_FFTW_DELEGATE)\n  (void) modulus;\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (FFTW)\",\n    image->filename);\n#else\n  {\n    Image\n      *magnitude_image;\n\n    size_t\n      height,\n      width;\n\n    width=image->columns;\n    height=image->rows;\n    if ((image->columns != image->rows) || ((image->columns % 2) != 0) ||\n        ((image->rows % 2) != 0))\n      {\n        size_t extent=image->columns < image->rows ? image->rows :\n          image->columns;\n        width=(extent & 0x01) == 1 ? extent+1UL : extent;\n      }\n    height=width;\n    magnitude_image=CloneImage(image,width,height,MagickTrue,exception);\n    if (magnitude_image != (Image *) NULL)\n      {\n        Image\n          *phase_image;\n\n        magnitude_image->storage_class=DirectClass;\n        magnitude_image->depth=32UL;\n        phase_image=CloneImage(image,width,height,MagickTrue,exception);\n        if (phase_image == (Image *) NULL)\n          magnitude_image=DestroyImage(magnitude_image);\n        else\n          {\n            MagickBooleanType\n              is_gray,\n              status;\n\n            phase_image->storage_class=DirectClass;\n            phase_image->depth=32UL;\n            AppendImageToList(&fourier_image,magnitude_image);\n            AppendImageToList(&fourier_image,phase_image);\n            status=MagickTrue;\n            is_gray=IsImageGray(image);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp parallel sections\n#endif\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                if (is_gray != MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    GrayPixelChannel,modulus,fourier_image,exception);\n                else\n                  thread_status=ForwardFourierTransformChannel(image,\n                    RedPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (is_gray == MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    GreenPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (is_gray == MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    BluePixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (image->colorspace == CMYKColorspace)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    BlackPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    AlphaPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n            }\n            if (status == MagickFalse)\n              fourier_image=DestroyImageList(fourier_image);\n            fftw_cleanup();\n          }\n      }\n  }\n#endif\n  return(fourier_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I n v e r s e F o u r i e r T r a n s f o r m I m a g e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InverseFourierTransformImage() implements the inverse discrete Fourier\n%  transform (DFT) of the image either as a magnitude / phase or real /\n%  imaginary image pair.\n%\n%  The format of the InverseFourierTransformImage method is:\n%\n%      Image *InverseFourierTransformImage(const Image *magnitude_image,\n%        const Image *phase_image,const MagickBooleanType modulus,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o magnitude_image: the magnitude or real image.\n%\n%    o phase_image: the phase or imaginary image.\n%\n%    o modulus: if true, return transform as a magnitude / phase pair\n%      otherwise a real / imaginary image pair.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FFTW_DELEGATE)\nstatic MagickBooleanType InverseQuadrantSwap(const size_t width,\n  const size_t height,const double *source,double *destination)\n{\n  register ssize_t\n    x;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Swap quadrants.\n  */\n  center=(ssize_t) (width/2L)+1L;\n  for (y=1L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L+1L); x++)\n      destination[(height-y)*center-x+width/2L]=source[y*width+x];\n  for (y=0L; y < (ssize_t) height; y++)\n    destination[y*center]=source[y*width+width/2L];\n  for (x=0L; x < center; x++)\n    destination[x]=source[center-x-1L];\n  return(RollFourier(center,height,0L,(ssize_t) height/-2L,destination));\n}\n\nstatic MagickBooleanType InverseFourier(FourierInfo *fourier_info,\n  const Image *magnitude_image,const Image *phase_image,\n  fftw_complex *fourier_pixels,ExceptionInfo *exception)\n{\n  CacheView\n    *magnitude_view,\n    *phase_view;\n\n  double\n    *inverse_pixels,\n    *magnitude_pixels,\n    *phase_pixels;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info,\n    *magnitude_info,\n    *phase_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Inverse fourier - read image and break down into a double array.\n  */\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*phase_pixels));\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    (fourier_info->height/2+1)*sizeof(*inverse_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL) ||\n      (inverse_info == (MemoryInfo *) NULL))\n    {\n      if (magnitude_info != (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (inverse_info != (MemoryInfo *) NULL)\n        inverse_info=RelinquishVirtualMemory(inverse_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  inverse_pixels=(double *) GetVirtualMemoryBlob(inverse_info);\n  i=0L;\n  magnitude_view=AcquireVirtualCacheView(magnitude_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(magnitude_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelRed(magnitude_image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelGreen(magnitude_image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelBlue(magnitude_image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelBlack(magnitude_image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelAlpha(magnitude_image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(magnitude_image);\n    }\n  }\n  magnitude_view=DestroyCacheView(magnitude_view);\n  status=InverseQuadrantSwap(fourier_info->width,fourier_info->height,\n    magnitude_pixels,inverse_pixels);\n  (void) memcpy(magnitude_pixels,inverse_pixels,fourier_info->height*\n    fourier_info->center*sizeof(*magnitude_pixels));\n  i=0L;\n  phase_view=AcquireVirtualCacheView(phase_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(phase_view,0,y,fourier_info->width,1,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelRed(phase_image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelGreen(phase_image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelBlue(phase_image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelBlack(phase_image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelAlpha(phase_image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(phase_image);\n    }\n  }\n  if (fourier_info->modulus != MagickFalse)\n    {\n      i=0L;\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->width; x++)\n        {\n          phase_pixels[i]-=0.5;\n          phase_pixels[i]*=(2.0*MagickPI);\n          i++;\n        }\n    }\n  phase_view=DestroyCacheView(phase_view);\n  CorrectPhaseLHS(fourier_info->width,fourier_info->height,phase_pixels);\n  if (status != MagickFalse)\n    status=InverseQuadrantSwap(fourier_info->width,fourier_info->height,\n      phase_pixels,inverse_pixels);\n  (void) memcpy(phase_pixels,inverse_pixels,fourier_info->height*\n    fourier_info->center*sizeof(*phase_pixels));\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  /*\n    Merge two sets.\n  */\n  i=0L;\n  if (fourier_info->modulus != MagickFalse)\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n       for (x=0L; x < (ssize_t) fourier_info->center; x++)\n       {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n         fourier_pixels[i]=magnitude_pixels[i]*cos(phase_pixels[i])+I*\n           magnitude_pixels[i]*sin(phase_pixels[i]);\n#else\n         fourier_pixels[i][0]=magnitude_pixels[i]*cos(phase_pixels[i]);\n         fourier_pixels[i][1]=magnitude_pixels[i]*sin(phase_pixels[i]);\n#endif\n         i++;\n      }\n  else\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n        fourier_pixels[i]=magnitude_pixels[i]+I*phase_pixels[i];\n#else\n        fourier_pixels[i][0]=magnitude_pixels[i];\n        fourier_pixels[i][1]=phase_pixels[i];\n#endif\n        i++;\n      }\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  return(status);\n}\n\nstatic MagickBooleanType InverseFourierTransform(FourierInfo *fourier_info,\n  fftw_complex *fourier_pixels,Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const char\n    *value;\n\n  double\n    *source_pixels;\n\n  fftw_plan\n    fftw_c2r_plan;\n\n  MemoryInfo\n    *source_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  source_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  value=GetImageArtifact(image,\"fourier:normalize\");\n  if (LocaleCompare(value,\"inverse\") == 0)\n    {\n      double\n        gamma;\n\n      /*\n        Normalize inverse transform.\n      */\n      i=0L;\n      gamma=PerceptibleReciprocal((double) fourier_info->width*\n        fourier_info->height);\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->center; x++)\n        {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n          fourier_pixels[i]*=gamma;\n#else\n          fourier_pixels[i][0]*=gamma;\n          fourier_pixels[i][1]*=gamma;\n#endif\n          i++;\n        }\n    }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp critical (MagickCore_InverseFourierTransform)\n#endif\n  fftw_c2r_plan=fftw_plan_dft_c2r_2d(fourier_info->width,fourier_info->height,\n    fourier_pixels,source_pixels,FFTW_ESTIMATE);\n  fftw_execute_dft_c2r(fftw_c2r_plan,fourier_pixels,source_pixels);\n  fftw_destroy_plan(fftw_c2r_plan);\n  i=0L;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    if (y >= (ssize_t) image->rows)\n      break;\n    q=GetCacheViewAuthenticPixels(image_view,0L,y,fourier_info->width >\n      image->columns ? image->columns : fourier_info->width,1UL,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        switch (fourier_info->channel)\n        {\n          case RedPixelChannel:\n          default:\n          {\n            SetPixelRed(image,ClampToQuantum(QuantumRange*source_pixels[i]),q);\n            break;\n          }\n          case GreenPixelChannel:\n          {\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case BluePixelChannel:\n          {\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case BlackPixelChannel:\n          {\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case AlphaPixelChannel:\n          {\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n        }\n      i++;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  source_info=RelinquishVirtualMemory(source_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType InverseFourierTransformChannel(\n  const Image *magnitude_image,const Image *phase_image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  fftw_complex\n    *inverse_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info;\n\n  fourier_info.width=magnitude_image->columns;\n  fourier_info.height=magnitude_image->rows;\n  if ((magnitude_image->columns != magnitude_image->rows) ||\n      ((magnitude_image->columns % 2) != 0) ||\n      ((magnitude_image->rows % 2) != 0))\n    {\n      size_t extent=magnitude_image->columns < magnitude_image->rows ?\n        magnitude_image->rows : magnitude_image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*inverse_pixels));\n  if (inverse_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  inverse_pixels=(fftw_complex *) GetVirtualMemoryBlob(inverse_info);\n  status=InverseFourier(&fourier_info,magnitude_image,phase_image,\n    inverse_pixels,exception);\n  if (status != MagickFalse)\n    status=InverseFourierTransform(&fourier_info,inverse_pixels,fourier_image,\n      exception);\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  return(status);\n}\n#endif\n\nMagickExport Image *InverseFourierTransformImage(const Image *magnitude_image,\n  const Image *phase_image,const MagickBooleanType modulus,\n  ExceptionInfo *exception)\n{\n  Image\n    *fourier_image;\n\n  assert(magnitude_image != (Image *) NULL);\n  assert(magnitude_image->signature == MagickCoreSignature);\n  if (magnitude_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      magnitude_image->filename);\n  if (phase_image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",magnitude_image->filename);\n      return((Image *) NULL);\n    }\n#if !defined(MAGICKCORE_FFTW_DELEGATE)\n  fourier_image=(Image *) NULL;\n  (void) modulus;\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (FFTW)\",\n    magnitude_image->filename);\n#else\n  {\n    fourier_image=CloneImage(magnitude_image,magnitude_image->columns,\n      magnitude_image->rows,MagickTrue,exception);\n    if (fourier_image != (Image *) NULL)\n      {\n        MagickBooleanType\n          is_gray,\n          status;\n\n        status=MagickTrue;\n        is_gray=IsImageGray(magnitude_image);\n        if (is_gray != MagickFalse)\n          is_gray=IsImageGray(phase_image);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp parallel sections\n#endif\n        {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            if (is_gray != MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,GrayPixelChannel,modulus,fourier_image,exception);\n            else\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,RedPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (is_gray == MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,GreenPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (is_gray == MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,BluePixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (magnitude_image->colorspace == CMYKColorspace)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,BlackPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (magnitude_image->alpha_trait != UndefinedPixelTrait)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,AlphaPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n        }\n        if (status == MagickFalse)\n          fourier_image=DestroyImage(fourier_image);\n      }\n    fftw_cleanup();\n  }\n#endif\n  return(fourier_image);\n}\n"], "filenames": ["MagickCore/annotate.c", "MagickCore/fourier.c"], "buggy_code_start_loc": [285, 251], "buggy_code_end_loc": [537, 255], "fixing_code_start_loc": [286, 251], "fixing_code_end_loc": [541, 259], "type": "CWE-125", "message": "In ImageMagick 7.0.8-50 Q16, ComplexImages in MagickCore/fourier.c has a heap-based buffer over-read because of incorrect calls to GetCacheViewVirtualPixels.", "other": {"cve": {"id": "CVE-2019-13391", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-07T22:15:10.503", "lastModified": "2020-09-08T00:15:20.617", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In ImageMagick 7.0.8-50 Q16, ComplexImages in MagickCore/fourier.c has a heap-based buffer over-read because of incorrect calls to GetCacheViewVirtualPixels."}, {"lang": "es", "value": "En ImageMagick versi\u00f3n 7.0.8-50 Q16, la funci\u00f3n ComplexImages en el archivo MagickCore/fourier.c, presenta una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria debido a llamadas incorrectas a GetCacheViewVirtualPixels."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-50:q16:*:*:*:*:*:*", "matchCriteriaId": "25CCEA99-8329-46C6-9625-4FE15F24CF69"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org"}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/7c2c5ba5b8e3a0b2b82f56c71dfab74ed4006df7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1588", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/f6ffc702c6eecd963587273a429dcd608c648984", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/09/msg00007.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4192-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/7c2c5ba5b8e3a0b2b82f56c71dfab74ed4006df7"}}