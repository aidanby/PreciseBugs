{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n *  Copyright (C) 1992 obz under the linux copyright\n *\n *  Dynamic diacritical handling - aeb@cwi.nl - Dec 1993\n *  Dynamic keymap and string allocation - aeb@cwi.nl - May 1994\n *  Restrict VT switching via ioctl() - grif@cs.ucr.edu - Dec 1995\n *  Some code moved for less code duplication - Andi Kleen - Mar 1997\n *  Check put/get_user, cleanups - acme@conectiva.com.br - Jun 2001\n */\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/sched/signal.h>\n#include <linux/tty.h>\n#include <linux/timer.h>\n#include <linux/kernel.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/kd.h>\n#include <linux/vt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/major.h>\n#include <linux/fs.h>\n#include <linux/console.h>\n#include <linux/consolemap.h>\n#include <linux/signal.h>\n#include <linux/suspend.h>\n#include <linux/timex.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include <linux/nospec.h>\n\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/kbd_diacr.h>\n#include <linux/selection.h>\n\nbool vt_dont_switch;\n\nstatic inline bool vt_in_use(unsigned int i)\n{\n\tconst struct vc_data *vc = vc_cons[i].d;\n\n\t/*\n\t * console_lock must be held to prevent the vc from being deallocated\n\t * while we're checking whether it's in-use.\n\t */\n\tWARN_CONSOLE_UNLOCKED();\n\n\treturn vc && kref_read(&vc->port.kref) > 1;\n}\n\nstatic inline bool vt_busy(int i)\n{\n\tif (vt_in_use(i))\n\t\treturn true;\n\tif (i == fg_console)\n\t\treturn true;\n\tif (vc_is_sel(vc_cons[i].d))\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * Console (vt and kd) routines, as defined by USL SVR4 manual, and by\n * experimentation and study of X386 SYSV handling.\n *\n * One point of difference: SYSV vt's are /dev/vtX, which X >= 0, and\n * /dev/console is a separate ttyp. Under Linux, /dev/tty0 is /dev/console,\n * and the vc start at /dev/ttyX, X >= 1. We maintain that here, so we will\n * always treat our set of vt as numbered 1..MAX_NR_CONSOLES (corresponding to\n * ttys 0..MAX_NR_CONSOLES-1). Explicitly naming VT 0 is illegal, but using\n * /dev/tty0 (fg_console) as a target is legal, since an implicit aliasing\n * to the current console is done by the main ioctl code.\n */\n\n#ifdef CONFIG_X86\n#include <asm/syscalls.h>\n#endif\n\nstatic void complete_change_console(struct vc_data *vc);\n\n/*\n *\tUser space VT_EVENT handlers\n */\n\nstruct vt_event_wait {\n\tstruct list_head list;\n\tstruct vt_event event;\n\tint done;\n};\n\nstatic LIST_HEAD(vt_events);\nstatic DEFINE_SPINLOCK(vt_event_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(vt_event_waitqueue);\n\n/**\n *\tvt_event_post\n *\t@event: the event that occurred\n *\t@old: old console\n *\t@new: new console\n *\n *\tPost an VT event to interested VT handlers\n */\n\nvoid vt_event_post(unsigned int event, unsigned int old, unsigned int new)\n{\n\tstruct list_head *pos, *head;\n\tunsigned long flags;\n\tint wake = 0;\n\n\tspin_lock_irqsave(&vt_event_lock, flags);\n\thead = &vt_events;\n\n\tlist_for_each(pos, head) {\n\t\tstruct vt_event_wait *ve = list_entry(pos,\n\t\t\t\t\t\tstruct vt_event_wait, list);\n\t\tif (!(ve->event.event & event))\n\t\t\tcontinue;\n\t\tve->event.event = event;\n\t\t/* kernel view is consoles 0..n-1, user space view is\n\t\t   console 1..n with 0 meaning current, so we must bias */\n\t\tve->event.oldev = old + 1;\n\t\tve->event.newev = new + 1;\n\t\twake = 1;\n\t\tve->done = 1;\n\t}\n\tspin_unlock_irqrestore(&vt_event_lock, flags);\n\tif (wake)\n\t\twake_up_interruptible(&vt_event_waitqueue);\n}\n\nstatic void __vt_event_queue(struct vt_event_wait *vw)\n{\n\tunsigned long flags;\n\t/* Prepare the event */\n\tINIT_LIST_HEAD(&vw->list);\n\tvw->done = 0;\n\t/* Queue our event */\n\tspin_lock_irqsave(&vt_event_lock, flags);\n\tlist_add(&vw->list, &vt_events);\n\tspin_unlock_irqrestore(&vt_event_lock, flags);\n}\n\nstatic void __vt_event_wait(struct vt_event_wait *vw)\n{\n\t/* Wait for it to pass */\n\twait_event_interruptible(vt_event_waitqueue, vw->done);\n}\n\nstatic void __vt_event_dequeue(struct vt_event_wait *vw)\n{\n\tunsigned long flags;\n\n\t/* Dequeue it */\n\tspin_lock_irqsave(&vt_event_lock, flags);\n\tlist_del(&vw->list);\n\tspin_unlock_irqrestore(&vt_event_lock, flags);\n}\n\n/**\n *\tvt_event_wait\t\t-\twait for an event\n *\t@vw: our event\n *\n *\tWaits for an event to occur which completes our vt_event_wait\n *\tstructure. On return the structure has wv->done set to 1 for success\n *\tor 0 if some event such as a signal ended the wait.\n */\n\nstatic void vt_event_wait(struct vt_event_wait *vw)\n{\n\t__vt_event_queue(vw);\n\t__vt_event_wait(vw);\n\t__vt_event_dequeue(vw);\n}\n\n/**\n *\tvt_event_wait_ioctl\t-\tevent ioctl handler\n *\t@event: argument to ioctl (the event)\n *\n *\tImplement the VT_WAITEVENT ioctl using the VT event interface\n */\n\nstatic int vt_event_wait_ioctl(struct vt_event __user *event)\n{\n\tstruct vt_event_wait vw;\n\n\tif (copy_from_user(&vw.event, event, sizeof(struct vt_event)))\n\t\treturn -EFAULT;\n\t/* Highest supported event for now */\n\tif (vw.event.event & ~VT_MAX_EVENT)\n\t\treturn -EINVAL;\n\n\tvt_event_wait(&vw);\n\t/* If it occurred report it */\n\tif (vw.done) {\n\t\tif (copy_to_user(event, &vw.event, sizeof(struct vt_event)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -EINTR;\n}\n\n/**\n *\tvt_waitactive\t-\tactive console wait\n *\t@n: new console\n *\n *\tHelper for event waits. Used to implement the legacy\n *\tevent waiting ioctls in terms of events\n */\n\nint vt_waitactive(int n)\n{\n\tstruct vt_event_wait vw;\n\tdo {\n\t\tvw.event.event = VT_EVENT_SWITCH;\n\t\t__vt_event_queue(&vw);\n\t\tif (n == fg_console + 1) {\n\t\t\t__vt_event_dequeue(&vw);\n\t\t\tbreak;\n\t\t}\n\t\t__vt_event_wait(&vw);\n\t\t__vt_event_dequeue(&vw);\n\t\tif (vw.done == 0)\n\t\t\treturn -EINTR;\n\t} while (vw.event.newev != n);\n\treturn 0;\n}\n\n/*\n * these are the valid i/o ports we're allowed to change. they map all the\n * video ports\n */\n#define GPFIRST 0x3b4\n#define GPLAST 0x3df\n#define GPNUM (GPLAST - GPFIRST + 1)\n\n/*\n * currently, setting the mode from KD_TEXT to KD_GRAPHICS doesn't do a whole\n * lot. i'm not sure if it should do any restoration of modes or what...\n *\n * XXX It should at least call into the driver, fbdev's definitely need to\n * restore their engine state. --BenH\n */\nstatic int vt_kdsetmode(struct vc_data *vc, unsigned long mode)\n{\n\tswitch (mode) {\n\tcase KD_GRAPHICS:\n\t\tbreak;\n\tcase KD_TEXT0:\n\tcase KD_TEXT1:\n\t\tmode = KD_TEXT;\n\t\tfallthrough;\n\tcase KD_TEXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/* FIXME: this needs the console lock extending */\n\tif (vc->vc_mode == mode)\n\t\treturn 0;\n\n\tvc->vc_mode = mode;\n\tif (vc->vc_num != fg_console)\n\t\treturn 0;\n\n\t/* explicitly blank/unblank the screen if switching modes */\n\tconsole_lock();\n\tif (mode == KD_TEXT)\n\t\tdo_unblank_screen(1);\n\telse\n\t\tdo_blank_screen(1);\n\tconsole_unlock();\n\n\treturn 0;\n}\n\nstatic int vt_k_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg, bool perm)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tvoid __user *up = (void __user *)arg;\n\tunsigned int console = vc->vc_num;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase KIOCSOUND:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * The use of PIT_TICK_RATE is historic, it used to be\n\t\t * the platform-dependent CLOCK_TICK_RATE between 2.6.12\n\t\t * and 2.6.36, which was a minor but unfortunate ABI\n\t\t * change. kd_mksound is locked by the input layer.\n\t\t */\n\t\tif (arg)\n\t\t\targ = PIT_TICK_RATE / arg;\n\t\tkd_mksound(arg, 0);\n\t\tbreak;\n\n\tcase KDMKTONE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t{\n\t\tunsigned int ticks, count;\n\n\t\t/*\n\t\t * Generate the tone for the appropriate number of ticks.\n\t\t * If the time is zero, turn off sound ourselves.\n\t\t */\n\t\tticks = msecs_to_jiffies((arg >> 16) & 0xffff);\n\t\tcount = ticks ? (arg & 0xffff) : 0;\n\t\tif (count)\n\t\t\tcount = PIT_TICK_RATE / count;\n\t\tkd_mksound(count, ticks);\n\t\tbreak;\n\t}\n\n\tcase KDGKBTYPE:\n\t\t/*\n\t\t * this is na\u00efve.\n\t\t */\n\t\treturn put_user(KB_101, (char __user *)arg);\n\n\t\t/*\n\t\t * These cannot be implemented on any machine that implements\n\t\t * ioperm() in user level (such as Alpha PCs) or not at all.\n\t\t *\n\t\t * XXX: you should never use these, just call ioperm directly..\n\t\t */\n#ifdef CONFIG_X86\n\tcase KDADDIO:\n\tcase KDDELIO:\n\t\t/*\n\t\t * KDADDIO and KDDELIO may be able to add ports beyond what\n\t\t * we reject here, but to be safe...\n\t\t *\n\t\t * These are locked internally via sys_ioperm\n\t\t */\n\t\tif (arg < GPFIRST || arg > GPLAST)\n\t\t\treturn -EINVAL;\n\n\t\treturn ksys_ioperm(arg, 1, (cmd == KDADDIO)) ? -ENXIO : 0;\n\n\tcase KDENABIO:\n\tcase KDDISABIO:\n\t\treturn ksys_ioperm(GPFIRST, GPNUM,\n\t\t\t\t  (cmd == KDENABIO)) ? -ENXIO : 0;\n#endif\n\n\t/* Linux m68k/i386 interface for setting the keyboard delay/repeat rate */\n\n\tcase KDKBDREP:\n\t{\n\t\tstruct kbd_repeat kbrep;\n\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&kbrep, up, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\n\t\tret = kbd_rate(&kbrep);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(up, &kbrep, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tcase KDSETMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\treturn vt_kdsetmode(vc, arg);\n\n\tcase KDGETMODE:\n\t\treturn put_user(vc->vc_mode, (int __user *)arg);\n\n\tcase KDMAPDISP:\n\tcase KDUNMAPDISP:\n\t\t/*\n\t\t * these work like a combination of mmap and KDENABIO.\n\t\t * this could be easily finished.\n\t\t */\n\t\treturn -EINVAL;\n\n\tcase KDSKBMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tret = vt_do_kdskbmode(console, arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttty_ldisc_flush(tty);\n\t\tbreak;\n\n\tcase KDGKBMODE:\n\t\treturn put_user(vt_do_kdgkbmode(console), (int __user *)arg);\n\n\t/* this could be folded into KDSKBMODE, but for compatibility\n\t   reasons it is not so easy to fold KDGKBMETA into KDGKBMODE */\n\tcase KDSKBMETA:\n\t\treturn vt_do_kdskbmeta(console, arg);\n\n\tcase KDGKBMETA:\n\t\t/* FIXME: should review whether this is worth locking */\n\t\treturn put_user(vt_do_kdgkbmeta(console), (int __user *)arg);\n\n\tcase KDGETKEYCODE:\n\tcase KDSETKEYCODE:\n\t\tif(!capable(CAP_SYS_TTY_CONFIG))\n\t\t\tperm = 0;\n\t\treturn vt_do_kbkeycode_ioctl(cmd, up, perm);\n\n\tcase KDGKBENT:\n\tcase KDSKBENT:\n\t\treturn vt_do_kdsk_ioctl(cmd, up, perm, console);\n\n\tcase KDGKBSENT:\n\tcase KDSKBSENT:\n\t\treturn vt_do_kdgkb_ioctl(cmd, up, perm);\n\n\t/* Diacritical processing. Handled in keyboard.c as it has\n\t   to operate on the keyboard locks and structures */\n\tcase KDGKBDIACR:\n\tcase KDGKBDIACRUC:\n\tcase KDSKBDIACR:\n\tcase KDSKBDIACRUC:\n\t\treturn vt_do_diacrit(cmd, up, perm);\n\n\t/* the ioctls below read/set the flags usually shown in the leds */\n\t/* don't use them - they will go away without warning */\n\tcase KDGKBLED:\n\tcase KDSKBLED:\n\tcase KDGETLED:\n\tcase KDSETLED:\n\t\treturn vt_do_kdskled(console, cmd, arg, perm);\n\n\t/*\n\t * A process can indicate its willingness to accept signals\n\t * generated by pressing an appropriate key combination.\n\t * Thus, one can have a daemon that e.g. spawns a new console\n\t * upon a keypress and then changes to it.\n\t * See also the kbrequest field of inittab(5).\n\t */\n\tcase KDSIGACCEPT:\n\t\tif (!perm || !capable(CAP_KILL))\n\t\t\treturn -EPERM;\n\t\tif (!valid_signal(arg) || arg < 1 || arg == SIGKILL)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irq(&vt_spawn_con.lock);\n\t\tput_pid(vt_spawn_con.pid);\n\t\tvt_spawn_con.pid = get_pid(task_pid(current));\n\t\tvt_spawn_con.sig = arg;\n\t\tspin_unlock_irq(&vt_spawn_con.lock);\n\t\tbreak;\n\n\tcase KDFONTOP: {\n\t\tstruct console_font_op op;\n\n\t\tif (copy_from_user(&op, up, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tif (!perm && op.op != KD_FONT_OP_GET)\n\t\t\treturn -EPERM;\n\t\tret = con_font_op(vc, &op);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(up, &op, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int do_unimap_ioctl(int cmd, struct unimapdesc __user *user_ud,\n\t\tbool perm, struct vc_data *vc)\n{\n\tstruct unimapdesc tmp;\n\n\tif (copy_from_user(&tmp, user_ud, sizeof tmp))\n\t\treturn -EFAULT;\n\tswitch (cmd) {\n\tcase PIO_UNIMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_unimap(vc, tmp.entry_ct, tmp.entries);\n\tcase GIO_UNIMAP:\n\t\tif (!perm && fg_console != vc->vc_num)\n\t\t\treturn -EPERM;\n\t\treturn con_get_unimap(vc, tmp.entry_ct, &(user_ud->entry_ct),\n\t\t\t\ttmp.entries);\n\t}\n\treturn 0;\n}\n\nstatic int vt_io_ioctl(struct vc_data *vc, unsigned int cmd, void __user *up,\n\t\tbool perm)\n{\n\tswitch (cmd) {\n\tcase PIO_CMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_cmap(up);\n\n\tcase GIO_CMAP:\n\t\treturn con_get_cmap(up);\n\n\tcase PIO_SCRNMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_trans_old(up);\n\n\tcase GIO_SCRNMAP:\n\t\treturn con_get_trans_old(up);\n\n\tcase PIO_UNISCRNMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_trans_new(up);\n\n\tcase GIO_UNISCRNMAP:\n\t\treturn con_get_trans_new(up);\n\n\tcase PIO_UNIMAPCLR:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tcon_clear_unimap(vc);\n\t\tbreak;\n\n\tcase PIO_UNIMAP:\n\tcase GIO_UNIMAP:\n\t\treturn do_unimap_ioctl(cmd, up, perm, vc);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic int vt_reldisp(struct vc_data *vc, unsigned int swtch)\n{\n\tint newvt, ret;\n\n\tif (vc->vt_mode.mode != VT_PROCESS)\n\t\treturn -EINVAL;\n\n\t/* Switched-to response */\n\tif (vc->vt_newvt < 0) {\n\t\t /* If it's just an ACK, ignore it */\n\t\treturn swtch == VT_ACKACQ ? 0 : -EINVAL;\n\t}\n\n\t/* Switching-from response */\n\tif (swtch == 0) {\n\t\t/* Switch disallowed, so forget we were trying to do it. */\n\t\tvc->vt_newvt = -1;\n\t\treturn 0;\n\t}\n\n\t/* The current vt has been released, so complete the switch. */\n\tnewvt = vc->vt_newvt;\n\tvc->vt_newvt = -1;\n\tret = vc_allocate(newvt);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * When we actually do the console switch, make sure we are atomic with\n\t * respect to other console switches..\n\t */\n\tcomplete_change_console(vc_cons[newvt].d);\n\n\treturn 0;\n}\n\nstatic int vt_setactivate(struct vt_setactivate __user *sa)\n{\n\tstruct vt_setactivate vsa;\n\tstruct vc_data *nvc;\n\tint ret;\n\n\tif (copy_from_user(&vsa, sa, sizeof(vsa)))\n\t\treturn -EFAULT;\n\tif (vsa.console == 0 || vsa.console > MAX_NR_CONSOLES)\n\t\treturn -ENXIO;\n\n\tvsa.console = array_index_nospec(vsa.console, MAX_NR_CONSOLES + 1);\n\tvsa.console--;\n\tconsole_lock();\n\tret = vc_allocate(vsa.console);\n\tif (ret) {\n\t\tconsole_unlock();\n\t\treturn ret;\n\t}\n\n\t/*\n\t * This is safe providing we don't drop the console sem between\n\t * vc_allocate and finishing referencing nvc.\n\t */\n\tnvc = vc_cons[vsa.console].d;\n\tnvc->vt_mode = vsa.mode;\n\tnvc->vt_mode.frsig = 0;\n\tput_pid(nvc->vt_pid);\n\tnvc->vt_pid = get_pid(task_pid(current));\n\tconsole_unlock();\n\n\t/* Commence switch and lock */\n\t/* Review set_console locks */\n\tset_console(vsa.console);\n\n\treturn 0;\n}\n\n/* deallocate a single console, if possible (leave 0) */\nstatic int vt_disallocate(unsigned int vc_num)\n{\n\tstruct vc_data *vc = NULL;\n\tint ret = 0;\n\n\tconsole_lock();\n\tif (vt_busy(vc_num))\n\t\tret = -EBUSY;\n\telse if (vc_num)\n\t\tvc = vc_deallocate(vc_num);\n\tconsole_unlock();\n\n\tif (vc && vc_num >= MIN_NR_CONSOLES)\n\t\ttty_port_put(&vc->port);\n\n\treturn ret;\n}\n\n/* deallocate all unused consoles, but leave 0 */\nstatic void vt_disallocate_all(void)\n{\n\tstruct vc_data *vc[MAX_NR_CONSOLES];\n\tint i;\n\n\tconsole_lock();\n\tfor (i = 1; i < MAX_NR_CONSOLES; i++)\n\t\tif (!vt_busy(i))\n\t\t\tvc[i] = vc_deallocate(i);\n\t\telse\n\t\t\tvc[i] = NULL;\n\tconsole_unlock();\n\n\tfor (i = 1; i < MAX_NR_CONSOLES; i++) {\n\t\tif (vc[i] && i >= MIN_NR_CONSOLES)\n\t\t\ttty_port_put(&vc[i]->port);\n\t}\n}\n\nstatic int vt_resizex(struct vc_data *vc, struct vt_consize __user *cs)\n{\n\tstruct vt_consize v;\n\tint i;\n\n\tif (copy_from_user(&v, cs, sizeof(struct vt_consize)))\n\t\treturn -EFAULT;\n\n\t/* FIXME: Should check the copies properly */\n\tif (!v.v_vlin)\n\t\tv.v_vlin = vc->vc_scan_lines;\n\n\tif (v.v_clin) {\n\t\tint rows = v.v_vlin / v.v_clin;\n\t\tif (v.v_rows != rows) {\n\t\t\tif (v.v_rows) /* Parameters don't add up */\n\t\t\t\treturn -EINVAL;\n\t\t\tv.v_rows = rows;\n\t\t}\n\t}\n\n\tif (v.v_vcol && v.v_ccol) {\n\t\tint cols = v.v_vcol / v.v_ccol;\n\t\tif (v.v_cols != cols) {\n\t\t\tif (v.v_cols)\n\t\t\t\treturn -EINVAL;\n\t\t\tv.v_cols = cols;\n\t\t}\n\t}\n\n\tif (v.v_clin > 32)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\tstruct vc_data *vcp;\n\n\t\tif (!vc_cons[i].d)\n\t\t\tcontinue;\n\t\tconsole_lock();\n\t\tvcp = vc_cons[i].d;\n\t\tif (vcp) {\n\t\t\tint ret;\n\t\t\tint save_scan_lines = vcp->vc_scan_lines;\n\t\t\tint save_cell_height = vcp->vc_cell_height;\n\n\t\t\tif (v.v_vlin)\n\t\t\t\tvcp->vc_scan_lines = v.v_vlin;\n\t\t\tif (v.v_clin)\n\t\t\t\tvcp->vc_cell_height = v.v_clin;\n\t\t\tvcp->vc_resize_user = 1;\n\t\t\tret = vc_resize(vcp, v.v_cols, v.v_rows);\n\t\t\tif (ret) {\n\t\t\t\tvcp->vc_scan_lines = save_scan_lines;\n\t\t\t\tvcp->vc_cell_height = save_cell_height;\n\t\t\t\tconsole_unlock();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tconsole_unlock();\n\t}\n\n\treturn 0;\n}\n\n/*\n * We handle the console-specific ioctl's here.  We allow the\n * capability to modify any console, not just the fg_console.\n */\nint vt_ioctl(struct tty_struct *tty,\n\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tvoid __user *up = (void __user *)arg;\n\tint i, perm;\n\tint ret;\n\n\t/*\n\t * To have permissions to do most of the vt ioctls, we either have\n\t * to be the owner of the tty, or have CAP_SYS_TTY_CONFIG.\n\t */\n\tperm = 0;\n\tif (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))\n\t\tperm = 1;\n\n\tret = vt_k_ioctl(tty, cmd, arg, perm);\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\tret = vt_io_ioctl(vc, cmd, up, perm);\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\tswitch (cmd) {\n\tcase TIOCLINUX:\n\t\treturn tioclinux(tty, arg);\n\tcase VT_SETMODE:\n\t{\n\t\tstruct vt_mode tmp;\n\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&tmp, up, sizeof(struct vt_mode)))\n\t\t\treturn -EFAULT;\n\t\tif (tmp.mode != VT_AUTO && tmp.mode != VT_PROCESS)\n\t\t\treturn -EINVAL;\n\n\t\tconsole_lock();\n\t\tvc->vt_mode = tmp;\n\t\t/* the frsig is ignored, so we set it to 0 */\n\t\tvc->vt_mode.frsig = 0;\n\t\tput_pid(vc->vt_pid);\n\t\tvc->vt_pid = get_pid(task_pid(current));\n\t\t/* no switch is required -- saw@shade.msu.ru */\n\t\tvc->vt_newvt = -1;\n\t\tconsole_unlock();\n\t\tbreak;\n\t}\n\n\tcase VT_GETMODE:\n\t{\n\t\tstruct vt_mode tmp;\n\t\tint rc;\n\n\t\tconsole_lock();\n\t\tmemcpy(&tmp, &vc->vt_mode, sizeof(struct vt_mode));\n\t\tconsole_unlock();\n\n\t\trc = copy_to_user(up, &tmp, sizeof(struct vt_mode));\n\t\tif (rc)\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Returns global vt state. Note that VT 0 is always open, since\n\t * it's an alias for the current VT, and people can't use it here.\n\t * We cannot return state for more than 16 VTs, since v_state is short.\n\t */\n\tcase VT_GETSTATE:\n\t{\n\t\tstruct vt_stat __user *vtstat = up;\n\t\tunsigned short state, mask;\n\n\t\tif (put_user(fg_console + 1, &vtstat->v_active))\n\t\t\treturn -EFAULT;\n\n\t\tstate = 1;\t/* /dev/tty0 is always open */\n\t\tconsole_lock(); /* required by vt_in_use() */\n\t\tfor (i = 0, mask = 2; i < MAX_NR_CONSOLES && mask;\n\t\t\t\t++i, mask <<= 1)\n\t\t\tif (vt_in_use(i))\n\t\t\t\tstate |= mask;\n\t\tconsole_unlock();\n\t\treturn put_user(state, &vtstat->v_state);\n\t}\n\n\t/*\n\t * Returns the first available (non-opened) console.\n\t */\n\tcase VT_OPENQRY:\n\t\tconsole_lock(); /* required by vt_in_use() */\n\t\tfor (i = 0; i < MAX_NR_CONSOLES; ++i)\n\t\t\tif (!vt_in_use(i))\n\t\t\t\tbreak;\n\t\tconsole_unlock();\n\t\ti = i < MAX_NR_CONSOLES ? (i+1) : -1;\n\t\treturn put_user(i, (int __user *)arg);\n\n\t/*\n\t * ioctl(fd, VT_ACTIVATE, num) will cause us to switch to vt # num,\n\t * with num >= 1 (switches to vt 0, our console, are not allowed, just\n\t * to preserve sanity).\n\t */\n\tcase VT_ACTIVATE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (arg == 0 || arg > MAX_NR_CONSOLES)\n\t\t\treturn -ENXIO;\n\n\t\targ--;\n\t\tconsole_lock();\n\t\tret = vc_allocate(arg);\n\t\tconsole_unlock();\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tset_console(arg);\n\t\tbreak;\n\n\tcase VT_SETACTIVATE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\treturn vt_setactivate(up);\n\n\t/*\n\t * wait until the specified VT has been activated\n\t */\n\tcase VT_WAITACTIVE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (arg == 0 || arg > MAX_NR_CONSOLES)\n\t\t\treturn -ENXIO;\n\t\treturn vt_waitactive(arg);\n\n\t/*\n\t * If a vt is under process control, the kernel will not switch to it\n\t * immediately, but postpone the operation until the process calls this\n\t * ioctl, allowing the switch to complete.\n\t *\n\t * According to the X sources this is the behavior:\n\t *\t0:\tpending switch-from not OK\n\t *\t1:\tpending switch-from OK\n\t *\t2:\tcompleted switch-to OK\n\t */\n\tcase VT_RELDISP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\tconsole_lock();\n\t\tret = vt_reldisp(vc, arg);\n\t\tconsole_unlock();\n\n\t\treturn ret;\n\n\n\t /*\n\t  * Disallocate memory associated to VT (but leave VT1)\n\t  */\n\t case VT_DISALLOCATE:\n\t\tif (arg > MAX_NR_CONSOLES)\n\t\t\treturn -ENXIO;\n\n\t\tif (arg == 0)\n\t\t\tvt_disallocate_all();\n\t\telse\n\t\t\treturn vt_disallocate(--arg);\n\t\tbreak;\n\n\tcase VT_RESIZE:\n\t{\n\t\tstruct vt_sizes __user *vtsizes = up;\n\t\tstruct vc_data *vc;\n\t\tushort ll,cc;\n\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (get_user(ll, &vtsizes->v_rows) ||\n\t\t    get_user(cc, &vtsizes->v_cols))\n\t\t\treturn -EFAULT;\n\n\t\tconsole_lock();\n\t\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\t\tvc = vc_cons[i].d;\n\n\t\t\tif (vc) {\n\t\t\t\tvc->vc_resize_user = 1;\n\t\t\t\t/* FIXME: review v tty lock */\n\t\t\t\tvc_resize(vc_cons[i].d, cc, ll);\n\t\t\t}\n\t\t}\n\t\tconsole_unlock();\n\t\tbreak;\n\t}\n\n\tcase VT_RESIZEX:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\treturn vt_resizex(vc, up);\n\n\tcase VT_LOCKSWITCH:\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\t\tvt_dont_switch = true;\n\t\tbreak;\n\tcase VT_UNLOCKSWITCH:\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\t\tvt_dont_switch = false;\n\t\tbreak;\n\tcase VT_GETHIFONTMASK:\n\t\treturn put_user(vc->vc_hi_font_mask,\n\t\t\t\t\t(unsigned short __user *)arg);\n\tcase VT_WAITEVENT:\n\t\treturn vt_event_wait_ioctl((struct vt_event __user *)arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nvoid reset_vc(struct vc_data *vc)\n{\n\tvc->vc_mode = KD_TEXT;\n\tvt_reset_unicode(vc->vc_num);\n\tvc->vt_mode.mode = VT_AUTO;\n\tvc->vt_mode.waitv = 0;\n\tvc->vt_mode.relsig = 0;\n\tvc->vt_mode.acqsig = 0;\n\tvc->vt_mode.frsig = 0;\n\tput_pid(vc->vt_pid);\n\tvc->vt_pid = NULL;\n\tvc->vt_newvt = -1;\n\treset_palette(vc);\n}\n\nvoid vc_SAK(struct work_struct *work)\n{\n\tstruct vc *vc_con =\n\t\tcontainer_of(work, struct vc, SAK_work);\n\tstruct vc_data *vc;\n\tstruct tty_struct *tty;\n\n\tconsole_lock();\n\tvc = vc_con->d;\n\tif (vc) {\n\t\t/* FIXME: review tty ref counting */\n\t\ttty = vc->port.tty;\n\t\t/*\n\t\t * SAK should also work in all raw modes and reset\n\t\t * them properly.\n\t\t */\n\t\tif (tty)\n\t\t\t__do_SAK(tty);\n\t\treset_vc(vc);\n\t}\n\tconsole_unlock();\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_console_font_op {\n\tcompat_uint_t op;        /* operation code KD_FONT_OP_* */\n\tcompat_uint_t flags;     /* KD_FONT_FLAG_* */\n\tcompat_uint_t width, height;     /* font size */\n\tcompat_uint_t charcount;\n\tcompat_caddr_t data;    /* font data with height fixed to 32 */\n};\n\nstatic inline int\ncompat_kdfontop_ioctl(struct compat_console_font_op __user *fontop,\n\t\t\t int perm, struct console_font_op *op, struct vc_data *vc)\n{\n\tint i;\n\n\tif (copy_from_user(op, fontop, sizeof(struct compat_console_font_op)))\n\t\treturn -EFAULT;\n\tif (!perm && op->op != KD_FONT_OP_GET)\n\t\treturn -EPERM;\n\top->data = compat_ptr(((struct compat_console_font_op *)op)->data);\n\ti = con_font_op(vc, op);\n\tif (i)\n\t\treturn i;\n\t((struct compat_console_font_op *)op)->data = (unsigned long)op->data;\n\tif (copy_to_user(fontop, op, sizeof(struct compat_console_font_op)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstruct compat_unimapdesc {\n\tunsigned short entry_ct;\n\tcompat_caddr_t entries;\n};\n\nstatic inline int\ncompat_unimap_ioctl(unsigned int cmd, struct compat_unimapdesc __user *user_ud,\n\t\t\t int perm, struct vc_data *vc)\n{\n\tstruct compat_unimapdesc tmp;\n\tstruct unipair __user *tmp_entries;\n\n\tif (copy_from_user(&tmp, user_ud, sizeof tmp))\n\t\treturn -EFAULT;\n\ttmp_entries = compat_ptr(tmp.entries);\n\tswitch (cmd) {\n\tcase PIO_UNIMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_unimap(vc, tmp.entry_ct, tmp_entries);\n\tcase GIO_UNIMAP:\n\t\tif (!perm && fg_console != vc->vc_num)\n\t\t\treturn -EPERM;\n\t\treturn con_get_unimap(vc, tmp.entry_ct, &(user_ud->entry_ct), tmp_entries);\n\t}\n\treturn 0;\n}\n\nlong vt_compat_ioctl(struct tty_struct *tty,\n\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tstruct console_font_op op;\t/* used in multiple places here */\n\tvoid __user *up = compat_ptr(arg);\n\tint perm;\n\n\t/*\n\t * To have permissions to do most of the vt ioctls, we either have\n\t * to be the owner of the tty, or have CAP_SYS_TTY_CONFIG.\n\t */\n\tperm = 0;\n\tif (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))\n\t\tperm = 1;\n\n\tswitch (cmd) {\n\t/*\n\t * these need special handlers for incompatible data structures\n\t */\n\n\tcase KDFONTOP:\n\t\treturn compat_kdfontop_ioctl(up, perm, &op, vc);\n\n\tcase PIO_UNIMAP:\n\tcase GIO_UNIMAP:\n\t\treturn compat_unimap_ioctl(cmd, up, perm, vc);\n\n\t/*\n\t * all these treat 'arg' as an integer\n\t */\n\tcase KIOCSOUND:\n\tcase KDMKTONE:\n#ifdef CONFIG_X86\n\tcase KDADDIO:\n\tcase KDDELIO:\n#endif\n\tcase KDSETMODE:\n\tcase KDMAPDISP:\n\tcase KDUNMAPDISP:\n\tcase KDSKBMODE:\n\tcase KDSKBMETA:\n\tcase KDSKBLED:\n\tcase KDSETLED:\n\tcase KDSIGACCEPT:\n\tcase VT_ACTIVATE:\n\tcase VT_WAITACTIVE:\n\tcase VT_RELDISP:\n\tcase VT_DISALLOCATE:\n\tcase VT_RESIZE:\n\tcase VT_RESIZEX:\n\t\treturn vt_ioctl(tty, cmd, arg);\n\n\t/*\n\t * the rest has a compatible data structure behind arg,\n\t * but we have to convert it to a proper 64 bit pointer.\n\t */\n\tdefault:\n\t\treturn vt_ioctl(tty, cmd, (unsigned long)up);\n\t}\n}\n\n\n#endif /* CONFIG_COMPAT */\n\n\n/*\n * Performs the back end of a vt switch. Called under the console\n * semaphore.\n */\nstatic void complete_change_console(struct vc_data *vc)\n{\n\tunsigned char old_vc_mode;\n\tint old = fg_console;\n\n\tlast_console = fg_console;\n\n\t/*\n\t * If we're switching, we could be going from KD_GRAPHICS to\n\t * KD_TEXT mode or vice versa, which means we need to blank or\n\t * unblank the screen later.\n\t */\n\told_vc_mode = vc_cons[fg_console].d->vc_mode;\n\tswitch_screen(vc);\n\n\t/*\n\t * This can't appear below a successful kill_pid().  If it did,\n\t * then the *blank_screen operation could occur while X, having\n\t * received acqsig, is waking up on another processor.  This\n\t * condition can lead to overlapping accesses to the VGA range\n\t * and the framebuffer (causing system lockups).\n\t *\n\t * To account for this we duplicate this code below only if the\n\t * controlling process is gone and we've called reset_vc.\n\t */\n\tif (old_vc_mode != vc->vc_mode) {\n\t\tif (vc->vc_mode == KD_TEXT)\n\t\t\tdo_unblank_screen(1);\n\t\telse\n\t\t\tdo_blank_screen(1);\n\t}\n\n\t/*\n\t * If this new console is under process control, send it a signal\n\t * telling it that it has acquired. Also check if it has died and\n\t * clean up (similar to logic employed in change_console())\n\t */\n\tif (vc->vt_mode.mode == VT_PROCESS) {\n\t\t/*\n\t\t * Send the signal as privileged - kill_pid() will\n\t\t * tell us if the process has gone or something else\n\t\t * is awry\n\t\t */\n\t\tif (kill_pid(vc->vt_pid, vc->vt_mode.acqsig, 1) != 0) {\n\t\t/*\n\t\t * The controlling process has died, so we revert back to\n\t\t * normal operation. In this case, we'll also change back\n\t\t * to KD_TEXT mode. I'm not sure if this is strictly correct\n\t\t * but it saves the agony when the X server dies and the screen\n\t\t * remains blanked due to KD_GRAPHICS! It would be nice to do\n\t\t * this outside of VT_PROCESS but there is no single process\n\t\t * to account for and tracking tty count may be undesirable.\n\t\t */\n\t\t\treset_vc(vc);\n\n\t\t\tif (old_vc_mode != vc->vc_mode) {\n\t\t\t\tif (vc->vc_mode == KD_TEXT)\n\t\t\t\t\tdo_unblank_screen(1);\n\t\t\t\telse\n\t\t\t\t\tdo_blank_screen(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Wake anyone waiting for their VT to activate\n\t */\n\tvt_event_post(VT_EVENT_SWITCH, old, vc->vc_num);\n\treturn;\n}\n\n/*\n * Performs the front-end of a vt switch\n */\nvoid change_console(struct vc_data *new_vc)\n{\n\tstruct vc_data *vc;\n\n\tif (!new_vc || new_vc->vc_num == fg_console || vt_dont_switch)\n\t\treturn;\n\n\t/*\n\t * If this vt is in process mode, then we need to handshake with\n\t * that process before switching. Essentially, we store where that\n\t * vt wants to switch to and wait for it to tell us when it's done\n\t * (via VT_RELDISP ioctl).\n\t *\n\t * We also check to see if the controlling process still exists.\n\t * If it doesn't, we reset this vt to auto mode and continue.\n\t * This is a cheap way to track process control. The worst thing\n\t * that can happen is: we send a signal to a process, it dies, and\n\t * the switch gets \"lost\" waiting for a response; hopefully, the\n\t * user will try again, we'll detect the process is gone (unless\n\t * the user waits just the right amount of time :-) and revert the\n\t * vt to auto control.\n\t */\n\tvc = vc_cons[fg_console].d;\n\tif (vc->vt_mode.mode == VT_PROCESS) {\n\t\t/*\n\t\t * Send the signal as privileged - kill_pid() will\n\t\t * tell us if the process has gone or something else\n\t\t * is awry.\n\t\t *\n\t\t * We need to set vt_newvt *before* sending the signal or we\n\t\t * have a race.\n\t\t */\n\t\tvc->vt_newvt = new_vc->vc_num;\n\t\tif (kill_pid(vc->vt_pid, vc->vt_mode.relsig, 1) == 0) {\n\t\t\t/*\n\t\t\t * It worked. Mark the vt to switch to and\n\t\t\t * return. The process needs to send us a\n\t\t\t * VT_RELDISP ioctl to complete the switch.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * The controlling process has died, so we revert back to\n\t\t * normal operation. In this case, we'll also change back\n\t\t * to KD_TEXT mode. I'm not sure if this is strictly correct\n\t\t * but it saves the agony when the X server dies and the screen\n\t\t * remains blanked due to KD_GRAPHICS! It would be nice to do\n\t\t * this outside of VT_PROCESS but there is no single process\n\t\t * to account for and tracking tty count may be undesirable.\n\t\t */\n\t\treset_vc(vc);\n\n\t\t/*\n\t\t * Fall through to normal (VT_AUTO) handling of the switch...\n\t\t */\n\t}\n\n\t/*\n\t * Ignore all switches in KD_GRAPHICS+VT_AUTO mode\n\t */\n\tif (vc->vc_mode == KD_GRAPHICS)\n\t\treturn;\n\n\tcomplete_change_console(new_vc);\n}\n\n/* Perform a kernel triggered VT switch for suspend/resume */\n\nstatic int disable_vt_switch;\n\nint vt_move_to_console(unsigned int vt, int alloc)\n{\n\tint prev;\n\n\tconsole_lock();\n\t/* Graphics mode - up to X */\n\tif (disable_vt_switch) {\n\t\tconsole_unlock();\n\t\treturn 0;\n\t}\n\tprev = fg_console;\n\n\tif (alloc && vc_allocate(vt)) {\n\t\t/* we can't have a free VC for now. Too bad,\n\t\t * we don't want to mess the screen for now. */\n\t\tconsole_unlock();\n\t\treturn -ENOSPC;\n\t}\n\n\tif (set_console(vt)) {\n\t\t/*\n\t\t * We're unable to switch to the SUSPEND_CONSOLE.\n\t\t * Let the calling function know so it can decide\n\t\t * what to do.\n\t\t */\n\t\tconsole_unlock();\n\t\treturn -EIO;\n\t}\n\tconsole_unlock();\n\tif (vt_waitactive(vt + 1)) {\n\t\tpr_debug(\"Suspend: Can't switch VCs.\");\n\t\treturn -EINTR;\n\t}\n\treturn prev;\n}\n\n/*\n * Normally during a suspend, we allocate a new console and switch to it.\n * When we resume, we switch back to the original console.  This switch\n * can be slow, so on systems where the framebuffer can handle restoration\n * of video registers anyways, there's little point in doing the console\n * switch.  This function allows you to disable it by passing it '0'.\n */\nvoid pm_set_vt_switch(int do_switch)\n{\n\tconsole_lock();\n\tdisable_vt_switch = !do_switch;\n\tconsole_unlock();\n}\nEXPORT_SYMBOL(pm_set_vt_switch);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n *  Copyright (C) 1992 obz under the linux copyright\n *\n *  Dynamic diacritical handling - aeb@cwi.nl - Dec 1993\n *  Dynamic keymap and string allocation - aeb@cwi.nl - May 1994\n *  Restrict VT switching via ioctl() - grif@cs.ucr.edu - Dec 1995\n *  Some code moved for less code duplication - Andi Kleen - Mar 1997\n *  Check put/get_user, cleanups - acme@conectiva.com.br - Jun 2001\n */\n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/sched/signal.h>\n#include <linux/tty.h>\n#include <linux/timer.h>\n#include <linux/kernel.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/kd.h>\n#include <linux/vt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/major.h>\n#include <linux/fs.h>\n#include <linux/console.h>\n#include <linux/consolemap.h>\n#include <linux/signal.h>\n#include <linux/suspend.h>\n#include <linux/timex.h>\n\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include <linux/nospec.h>\n\n#include <linux/kbd_kern.h>\n#include <linux/vt_kern.h>\n#include <linux/kbd_diacr.h>\n#include <linux/selection.h>\n\nbool vt_dont_switch;\n\nstatic inline bool vt_in_use(unsigned int i)\n{\n\tconst struct vc_data *vc = vc_cons[i].d;\n\n\t/*\n\t * console_lock must be held to prevent the vc from being deallocated\n\t * while we're checking whether it's in-use.\n\t */\n\tWARN_CONSOLE_UNLOCKED();\n\n\treturn vc && kref_read(&vc->port.kref) > 1;\n}\n\nstatic inline bool vt_busy(int i)\n{\n\tif (vt_in_use(i))\n\t\treturn true;\n\tif (i == fg_console)\n\t\treturn true;\n\tif (vc_is_sel(vc_cons[i].d))\n\t\treturn true;\n\n\treturn false;\n}\n\n/*\n * Console (vt and kd) routines, as defined by USL SVR4 manual, and by\n * experimentation and study of X386 SYSV handling.\n *\n * One point of difference: SYSV vt's are /dev/vtX, which X >= 0, and\n * /dev/console is a separate ttyp. Under Linux, /dev/tty0 is /dev/console,\n * and the vc start at /dev/ttyX, X >= 1. We maintain that here, so we will\n * always treat our set of vt as numbered 1..MAX_NR_CONSOLES (corresponding to\n * ttys 0..MAX_NR_CONSOLES-1). Explicitly naming VT 0 is illegal, but using\n * /dev/tty0 (fg_console) as a target is legal, since an implicit aliasing\n * to the current console is done by the main ioctl code.\n */\n\n#ifdef CONFIG_X86\n#include <asm/syscalls.h>\n#endif\n\nstatic void complete_change_console(struct vc_data *vc);\n\n/*\n *\tUser space VT_EVENT handlers\n */\n\nstruct vt_event_wait {\n\tstruct list_head list;\n\tstruct vt_event event;\n\tint done;\n};\n\nstatic LIST_HEAD(vt_events);\nstatic DEFINE_SPINLOCK(vt_event_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(vt_event_waitqueue);\n\n/**\n *\tvt_event_post\n *\t@event: the event that occurred\n *\t@old: old console\n *\t@new: new console\n *\n *\tPost an VT event to interested VT handlers\n */\n\nvoid vt_event_post(unsigned int event, unsigned int old, unsigned int new)\n{\n\tstruct list_head *pos, *head;\n\tunsigned long flags;\n\tint wake = 0;\n\n\tspin_lock_irqsave(&vt_event_lock, flags);\n\thead = &vt_events;\n\n\tlist_for_each(pos, head) {\n\t\tstruct vt_event_wait *ve = list_entry(pos,\n\t\t\t\t\t\tstruct vt_event_wait, list);\n\t\tif (!(ve->event.event & event))\n\t\t\tcontinue;\n\t\tve->event.event = event;\n\t\t/* kernel view is consoles 0..n-1, user space view is\n\t\t   console 1..n with 0 meaning current, so we must bias */\n\t\tve->event.oldev = old + 1;\n\t\tve->event.newev = new + 1;\n\t\twake = 1;\n\t\tve->done = 1;\n\t}\n\tspin_unlock_irqrestore(&vt_event_lock, flags);\n\tif (wake)\n\t\twake_up_interruptible(&vt_event_waitqueue);\n}\n\nstatic void __vt_event_queue(struct vt_event_wait *vw)\n{\n\tunsigned long flags;\n\t/* Prepare the event */\n\tINIT_LIST_HEAD(&vw->list);\n\tvw->done = 0;\n\t/* Queue our event */\n\tspin_lock_irqsave(&vt_event_lock, flags);\n\tlist_add(&vw->list, &vt_events);\n\tspin_unlock_irqrestore(&vt_event_lock, flags);\n}\n\nstatic void __vt_event_wait(struct vt_event_wait *vw)\n{\n\t/* Wait for it to pass */\n\twait_event_interruptible(vt_event_waitqueue, vw->done);\n}\n\nstatic void __vt_event_dequeue(struct vt_event_wait *vw)\n{\n\tunsigned long flags;\n\n\t/* Dequeue it */\n\tspin_lock_irqsave(&vt_event_lock, flags);\n\tlist_del(&vw->list);\n\tspin_unlock_irqrestore(&vt_event_lock, flags);\n}\n\n/**\n *\tvt_event_wait\t\t-\twait for an event\n *\t@vw: our event\n *\n *\tWaits for an event to occur which completes our vt_event_wait\n *\tstructure. On return the structure has wv->done set to 1 for success\n *\tor 0 if some event such as a signal ended the wait.\n */\n\nstatic void vt_event_wait(struct vt_event_wait *vw)\n{\n\t__vt_event_queue(vw);\n\t__vt_event_wait(vw);\n\t__vt_event_dequeue(vw);\n}\n\n/**\n *\tvt_event_wait_ioctl\t-\tevent ioctl handler\n *\t@event: argument to ioctl (the event)\n *\n *\tImplement the VT_WAITEVENT ioctl using the VT event interface\n */\n\nstatic int vt_event_wait_ioctl(struct vt_event __user *event)\n{\n\tstruct vt_event_wait vw;\n\n\tif (copy_from_user(&vw.event, event, sizeof(struct vt_event)))\n\t\treturn -EFAULT;\n\t/* Highest supported event for now */\n\tif (vw.event.event & ~VT_MAX_EVENT)\n\t\treturn -EINVAL;\n\n\tvt_event_wait(&vw);\n\t/* If it occurred report it */\n\tif (vw.done) {\n\t\tif (copy_to_user(event, &vw.event, sizeof(struct vt_event)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -EINTR;\n}\n\n/**\n *\tvt_waitactive\t-\tactive console wait\n *\t@n: new console\n *\n *\tHelper for event waits. Used to implement the legacy\n *\tevent waiting ioctls in terms of events\n */\n\nint vt_waitactive(int n)\n{\n\tstruct vt_event_wait vw;\n\tdo {\n\t\tvw.event.event = VT_EVENT_SWITCH;\n\t\t__vt_event_queue(&vw);\n\t\tif (n == fg_console + 1) {\n\t\t\t__vt_event_dequeue(&vw);\n\t\t\tbreak;\n\t\t}\n\t\t__vt_event_wait(&vw);\n\t\t__vt_event_dequeue(&vw);\n\t\tif (vw.done == 0)\n\t\t\treturn -EINTR;\n\t} while (vw.event.newev != n);\n\treturn 0;\n}\n\n/*\n * these are the valid i/o ports we're allowed to change. they map all the\n * video ports\n */\n#define GPFIRST 0x3b4\n#define GPLAST 0x3df\n#define GPNUM (GPLAST - GPFIRST + 1)\n\n/*\n * currently, setting the mode from KD_TEXT to KD_GRAPHICS doesn't do a whole\n * lot. i'm not sure if it should do any restoration of modes or what...\n *\n * XXX It should at least call into the driver, fbdev's definitely need to\n * restore their engine state. --BenH\n *\n * Called with the console lock held.\n */\nstatic int vt_kdsetmode(struct vc_data *vc, unsigned long mode)\n{\n\tswitch (mode) {\n\tcase KD_GRAPHICS:\n\t\tbreak;\n\tcase KD_TEXT0:\n\tcase KD_TEXT1:\n\t\tmode = KD_TEXT;\n\t\tfallthrough;\n\tcase KD_TEXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (vc->vc_mode == mode)\n\t\treturn 0;\n\n\tvc->vc_mode = mode;\n\tif (vc->vc_num != fg_console)\n\t\treturn 0;\n\n\t/* explicitly blank/unblank the screen if switching modes */\n\tif (mode == KD_TEXT)\n\t\tdo_unblank_screen(1);\n\telse\n\t\tdo_blank_screen(1);\n\n\treturn 0;\n}\n\nstatic int vt_k_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg, bool perm)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tvoid __user *up = (void __user *)arg;\n\tunsigned int console = vc->vc_num;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase KIOCSOUND:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * The use of PIT_TICK_RATE is historic, it used to be\n\t\t * the platform-dependent CLOCK_TICK_RATE between 2.6.12\n\t\t * and 2.6.36, which was a minor but unfortunate ABI\n\t\t * change. kd_mksound is locked by the input layer.\n\t\t */\n\t\tif (arg)\n\t\t\targ = PIT_TICK_RATE / arg;\n\t\tkd_mksound(arg, 0);\n\t\tbreak;\n\n\tcase KDMKTONE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t{\n\t\tunsigned int ticks, count;\n\n\t\t/*\n\t\t * Generate the tone for the appropriate number of ticks.\n\t\t * If the time is zero, turn off sound ourselves.\n\t\t */\n\t\tticks = msecs_to_jiffies((arg >> 16) & 0xffff);\n\t\tcount = ticks ? (arg & 0xffff) : 0;\n\t\tif (count)\n\t\t\tcount = PIT_TICK_RATE / count;\n\t\tkd_mksound(count, ticks);\n\t\tbreak;\n\t}\n\n\tcase KDGKBTYPE:\n\t\t/*\n\t\t * this is na\u00efve.\n\t\t */\n\t\treturn put_user(KB_101, (char __user *)arg);\n\n\t\t/*\n\t\t * These cannot be implemented on any machine that implements\n\t\t * ioperm() in user level (such as Alpha PCs) or not at all.\n\t\t *\n\t\t * XXX: you should never use these, just call ioperm directly..\n\t\t */\n#ifdef CONFIG_X86\n\tcase KDADDIO:\n\tcase KDDELIO:\n\t\t/*\n\t\t * KDADDIO and KDDELIO may be able to add ports beyond what\n\t\t * we reject here, but to be safe...\n\t\t *\n\t\t * These are locked internally via sys_ioperm\n\t\t */\n\t\tif (arg < GPFIRST || arg > GPLAST)\n\t\t\treturn -EINVAL;\n\n\t\treturn ksys_ioperm(arg, 1, (cmd == KDADDIO)) ? -ENXIO : 0;\n\n\tcase KDENABIO:\n\tcase KDDISABIO:\n\t\treturn ksys_ioperm(GPFIRST, GPNUM,\n\t\t\t\t  (cmd == KDENABIO)) ? -ENXIO : 0;\n#endif\n\n\t/* Linux m68k/i386 interface for setting the keyboard delay/repeat rate */\n\n\tcase KDKBDREP:\n\t{\n\t\tstruct kbd_repeat kbrep;\n\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&kbrep, up, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\n\t\tret = kbd_rate(&kbrep);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(up, &kbrep, sizeof(struct kbd_repeat)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tcase KDSETMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\tconsole_lock();\n\t\tret = vt_kdsetmode(vc, arg);\n\t\tconsole_unlock();\n\t\treturn ret;\n\n\tcase KDGETMODE:\n\t\treturn put_user(vc->vc_mode, (int __user *)arg);\n\n\tcase KDMAPDISP:\n\tcase KDUNMAPDISP:\n\t\t/*\n\t\t * these work like a combination of mmap and KDENABIO.\n\t\t * this could be easily finished.\n\t\t */\n\t\treturn -EINVAL;\n\n\tcase KDSKBMODE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tret = vt_do_kdskbmode(console, arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttty_ldisc_flush(tty);\n\t\tbreak;\n\n\tcase KDGKBMODE:\n\t\treturn put_user(vt_do_kdgkbmode(console), (int __user *)arg);\n\n\t/* this could be folded into KDSKBMODE, but for compatibility\n\t   reasons it is not so easy to fold KDGKBMETA into KDGKBMODE */\n\tcase KDSKBMETA:\n\t\treturn vt_do_kdskbmeta(console, arg);\n\n\tcase KDGKBMETA:\n\t\t/* FIXME: should review whether this is worth locking */\n\t\treturn put_user(vt_do_kdgkbmeta(console), (int __user *)arg);\n\n\tcase KDGETKEYCODE:\n\tcase KDSETKEYCODE:\n\t\tif(!capable(CAP_SYS_TTY_CONFIG))\n\t\t\tperm = 0;\n\t\treturn vt_do_kbkeycode_ioctl(cmd, up, perm);\n\n\tcase KDGKBENT:\n\tcase KDSKBENT:\n\t\treturn vt_do_kdsk_ioctl(cmd, up, perm, console);\n\n\tcase KDGKBSENT:\n\tcase KDSKBSENT:\n\t\treturn vt_do_kdgkb_ioctl(cmd, up, perm);\n\n\t/* Diacritical processing. Handled in keyboard.c as it has\n\t   to operate on the keyboard locks and structures */\n\tcase KDGKBDIACR:\n\tcase KDGKBDIACRUC:\n\tcase KDSKBDIACR:\n\tcase KDSKBDIACRUC:\n\t\treturn vt_do_diacrit(cmd, up, perm);\n\n\t/* the ioctls below read/set the flags usually shown in the leds */\n\t/* don't use them - they will go away without warning */\n\tcase KDGKBLED:\n\tcase KDSKBLED:\n\tcase KDGETLED:\n\tcase KDSETLED:\n\t\treturn vt_do_kdskled(console, cmd, arg, perm);\n\n\t/*\n\t * A process can indicate its willingness to accept signals\n\t * generated by pressing an appropriate key combination.\n\t * Thus, one can have a daemon that e.g. spawns a new console\n\t * upon a keypress and then changes to it.\n\t * See also the kbrequest field of inittab(5).\n\t */\n\tcase KDSIGACCEPT:\n\t\tif (!perm || !capable(CAP_KILL))\n\t\t\treturn -EPERM;\n\t\tif (!valid_signal(arg) || arg < 1 || arg == SIGKILL)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irq(&vt_spawn_con.lock);\n\t\tput_pid(vt_spawn_con.pid);\n\t\tvt_spawn_con.pid = get_pid(task_pid(current));\n\t\tvt_spawn_con.sig = arg;\n\t\tspin_unlock_irq(&vt_spawn_con.lock);\n\t\tbreak;\n\n\tcase KDFONTOP: {\n\t\tstruct console_font_op op;\n\n\t\tif (copy_from_user(&op, up, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tif (!perm && op.op != KD_FONT_OP_GET)\n\t\t\treturn -EPERM;\n\t\tret = con_font_op(vc, &op);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (copy_to_user(up, &op, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int do_unimap_ioctl(int cmd, struct unimapdesc __user *user_ud,\n\t\tbool perm, struct vc_data *vc)\n{\n\tstruct unimapdesc tmp;\n\n\tif (copy_from_user(&tmp, user_ud, sizeof tmp))\n\t\treturn -EFAULT;\n\tswitch (cmd) {\n\tcase PIO_UNIMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_unimap(vc, tmp.entry_ct, tmp.entries);\n\tcase GIO_UNIMAP:\n\t\tif (!perm && fg_console != vc->vc_num)\n\t\t\treturn -EPERM;\n\t\treturn con_get_unimap(vc, tmp.entry_ct, &(user_ud->entry_ct),\n\t\t\t\ttmp.entries);\n\t}\n\treturn 0;\n}\n\nstatic int vt_io_ioctl(struct vc_data *vc, unsigned int cmd, void __user *up,\n\t\tbool perm)\n{\n\tswitch (cmd) {\n\tcase PIO_CMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_cmap(up);\n\n\tcase GIO_CMAP:\n\t\treturn con_get_cmap(up);\n\n\tcase PIO_SCRNMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_trans_old(up);\n\n\tcase GIO_SCRNMAP:\n\t\treturn con_get_trans_old(up);\n\n\tcase PIO_UNISCRNMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_trans_new(up);\n\n\tcase GIO_UNISCRNMAP:\n\t\treturn con_get_trans_new(up);\n\n\tcase PIO_UNIMAPCLR:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tcon_clear_unimap(vc);\n\t\tbreak;\n\n\tcase PIO_UNIMAP:\n\tcase GIO_UNIMAP:\n\t\treturn do_unimap_ioctl(cmd, up, perm, vc);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nstatic int vt_reldisp(struct vc_data *vc, unsigned int swtch)\n{\n\tint newvt, ret;\n\n\tif (vc->vt_mode.mode != VT_PROCESS)\n\t\treturn -EINVAL;\n\n\t/* Switched-to response */\n\tif (vc->vt_newvt < 0) {\n\t\t /* If it's just an ACK, ignore it */\n\t\treturn swtch == VT_ACKACQ ? 0 : -EINVAL;\n\t}\n\n\t/* Switching-from response */\n\tif (swtch == 0) {\n\t\t/* Switch disallowed, so forget we were trying to do it. */\n\t\tvc->vt_newvt = -1;\n\t\treturn 0;\n\t}\n\n\t/* The current vt has been released, so complete the switch. */\n\tnewvt = vc->vt_newvt;\n\tvc->vt_newvt = -1;\n\tret = vc_allocate(newvt);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * When we actually do the console switch, make sure we are atomic with\n\t * respect to other console switches..\n\t */\n\tcomplete_change_console(vc_cons[newvt].d);\n\n\treturn 0;\n}\n\nstatic int vt_setactivate(struct vt_setactivate __user *sa)\n{\n\tstruct vt_setactivate vsa;\n\tstruct vc_data *nvc;\n\tint ret;\n\n\tif (copy_from_user(&vsa, sa, sizeof(vsa)))\n\t\treturn -EFAULT;\n\tif (vsa.console == 0 || vsa.console > MAX_NR_CONSOLES)\n\t\treturn -ENXIO;\n\n\tvsa.console = array_index_nospec(vsa.console, MAX_NR_CONSOLES + 1);\n\tvsa.console--;\n\tconsole_lock();\n\tret = vc_allocate(vsa.console);\n\tif (ret) {\n\t\tconsole_unlock();\n\t\treturn ret;\n\t}\n\n\t/*\n\t * This is safe providing we don't drop the console sem between\n\t * vc_allocate and finishing referencing nvc.\n\t */\n\tnvc = vc_cons[vsa.console].d;\n\tnvc->vt_mode = vsa.mode;\n\tnvc->vt_mode.frsig = 0;\n\tput_pid(nvc->vt_pid);\n\tnvc->vt_pid = get_pid(task_pid(current));\n\tconsole_unlock();\n\n\t/* Commence switch and lock */\n\t/* Review set_console locks */\n\tset_console(vsa.console);\n\n\treturn 0;\n}\n\n/* deallocate a single console, if possible (leave 0) */\nstatic int vt_disallocate(unsigned int vc_num)\n{\n\tstruct vc_data *vc = NULL;\n\tint ret = 0;\n\n\tconsole_lock();\n\tif (vt_busy(vc_num))\n\t\tret = -EBUSY;\n\telse if (vc_num)\n\t\tvc = vc_deallocate(vc_num);\n\tconsole_unlock();\n\n\tif (vc && vc_num >= MIN_NR_CONSOLES)\n\t\ttty_port_put(&vc->port);\n\n\treturn ret;\n}\n\n/* deallocate all unused consoles, but leave 0 */\nstatic void vt_disallocate_all(void)\n{\n\tstruct vc_data *vc[MAX_NR_CONSOLES];\n\tint i;\n\n\tconsole_lock();\n\tfor (i = 1; i < MAX_NR_CONSOLES; i++)\n\t\tif (!vt_busy(i))\n\t\t\tvc[i] = vc_deallocate(i);\n\t\telse\n\t\t\tvc[i] = NULL;\n\tconsole_unlock();\n\n\tfor (i = 1; i < MAX_NR_CONSOLES; i++) {\n\t\tif (vc[i] && i >= MIN_NR_CONSOLES)\n\t\t\ttty_port_put(&vc[i]->port);\n\t}\n}\n\nstatic int vt_resizex(struct vc_data *vc, struct vt_consize __user *cs)\n{\n\tstruct vt_consize v;\n\tint i;\n\n\tif (copy_from_user(&v, cs, sizeof(struct vt_consize)))\n\t\treturn -EFAULT;\n\n\t/* FIXME: Should check the copies properly */\n\tif (!v.v_vlin)\n\t\tv.v_vlin = vc->vc_scan_lines;\n\n\tif (v.v_clin) {\n\t\tint rows = v.v_vlin / v.v_clin;\n\t\tif (v.v_rows != rows) {\n\t\t\tif (v.v_rows) /* Parameters don't add up */\n\t\t\t\treturn -EINVAL;\n\t\t\tv.v_rows = rows;\n\t\t}\n\t}\n\n\tif (v.v_vcol && v.v_ccol) {\n\t\tint cols = v.v_vcol / v.v_ccol;\n\t\tif (v.v_cols != cols) {\n\t\t\tif (v.v_cols)\n\t\t\t\treturn -EINVAL;\n\t\t\tv.v_cols = cols;\n\t\t}\n\t}\n\n\tif (v.v_clin > 32)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\tstruct vc_data *vcp;\n\n\t\tif (!vc_cons[i].d)\n\t\t\tcontinue;\n\t\tconsole_lock();\n\t\tvcp = vc_cons[i].d;\n\t\tif (vcp) {\n\t\t\tint ret;\n\t\t\tint save_scan_lines = vcp->vc_scan_lines;\n\t\t\tint save_cell_height = vcp->vc_cell_height;\n\n\t\t\tif (v.v_vlin)\n\t\t\t\tvcp->vc_scan_lines = v.v_vlin;\n\t\t\tif (v.v_clin)\n\t\t\t\tvcp->vc_cell_height = v.v_clin;\n\t\t\tvcp->vc_resize_user = 1;\n\t\t\tret = vc_resize(vcp, v.v_cols, v.v_rows);\n\t\t\tif (ret) {\n\t\t\t\tvcp->vc_scan_lines = save_scan_lines;\n\t\t\t\tvcp->vc_cell_height = save_cell_height;\n\t\t\t\tconsole_unlock();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tconsole_unlock();\n\t}\n\n\treturn 0;\n}\n\n/*\n * We handle the console-specific ioctl's here.  We allow the\n * capability to modify any console, not just the fg_console.\n */\nint vt_ioctl(struct tty_struct *tty,\n\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tvoid __user *up = (void __user *)arg;\n\tint i, perm;\n\tint ret;\n\n\t/*\n\t * To have permissions to do most of the vt ioctls, we either have\n\t * to be the owner of the tty, or have CAP_SYS_TTY_CONFIG.\n\t */\n\tperm = 0;\n\tif (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))\n\t\tperm = 1;\n\n\tret = vt_k_ioctl(tty, cmd, arg, perm);\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\tret = vt_io_ioctl(vc, cmd, up, perm);\n\tif (ret != -ENOIOCTLCMD)\n\t\treturn ret;\n\n\tswitch (cmd) {\n\tcase TIOCLINUX:\n\t\treturn tioclinux(tty, arg);\n\tcase VT_SETMODE:\n\t{\n\t\tstruct vt_mode tmp;\n\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&tmp, up, sizeof(struct vt_mode)))\n\t\t\treturn -EFAULT;\n\t\tif (tmp.mode != VT_AUTO && tmp.mode != VT_PROCESS)\n\t\t\treturn -EINVAL;\n\n\t\tconsole_lock();\n\t\tvc->vt_mode = tmp;\n\t\t/* the frsig is ignored, so we set it to 0 */\n\t\tvc->vt_mode.frsig = 0;\n\t\tput_pid(vc->vt_pid);\n\t\tvc->vt_pid = get_pid(task_pid(current));\n\t\t/* no switch is required -- saw@shade.msu.ru */\n\t\tvc->vt_newvt = -1;\n\t\tconsole_unlock();\n\t\tbreak;\n\t}\n\n\tcase VT_GETMODE:\n\t{\n\t\tstruct vt_mode tmp;\n\t\tint rc;\n\n\t\tconsole_lock();\n\t\tmemcpy(&tmp, &vc->vt_mode, sizeof(struct vt_mode));\n\t\tconsole_unlock();\n\n\t\trc = copy_to_user(up, &tmp, sizeof(struct vt_mode));\n\t\tif (rc)\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Returns global vt state. Note that VT 0 is always open, since\n\t * it's an alias for the current VT, and people can't use it here.\n\t * We cannot return state for more than 16 VTs, since v_state is short.\n\t */\n\tcase VT_GETSTATE:\n\t{\n\t\tstruct vt_stat __user *vtstat = up;\n\t\tunsigned short state, mask;\n\n\t\tif (put_user(fg_console + 1, &vtstat->v_active))\n\t\t\treturn -EFAULT;\n\n\t\tstate = 1;\t/* /dev/tty0 is always open */\n\t\tconsole_lock(); /* required by vt_in_use() */\n\t\tfor (i = 0, mask = 2; i < MAX_NR_CONSOLES && mask;\n\t\t\t\t++i, mask <<= 1)\n\t\t\tif (vt_in_use(i))\n\t\t\t\tstate |= mask;\n\t\tconsole_unlock();\n\t\treturn put_user(state, &vtstat->v_state);\n\t}\n\n\t/*\n\t * Returns the first available (non-opened) console.\n\t */\n\tcase VT_OPENQRY:\n\t\tconsole_lock(); /* required by vt_in_use() */\n\t\tfor (i = 0; i < MAX_NR_CONSOLES; ++i)\n\t\t\tif (!vt_in_use(i))\n\t\t\t\tbreak;\n\t\tconsole_unlock();\n\t\ti = i < MAX_NR_CONSOLES ? (i+1) : -1;\n\t\treturn put_user(i, (int __user *)arg);\n\n\t/*\n\t * ioctl(fd, VT_ACTIVATE, num) will cause us to switch to vt # num,\n\t * with num >= 1 (switches to vt 0, our console, are not allowed, just\n\t * to preserve sanity).\n\t */\n\tcase VT_ACTIVATE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (arg == 0 || arg > MAX_NR_CONSOLES)\n\t\t\treturn -ENXIO;\n\n\t\targ--;\n\t\tconsole_lock();\n\t\tret = vc_allocate(arg);\n\t\tconsole_unlock();\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tset_console(arg);\n\t\tbreak;\n\n\tcase VT_SETACTIVATE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\treturn vt_setactivate(up);\n\n\t/*\n\t * wait until the specified VT has been activated\n\t */\n\tcase VT_WAITACTIVE:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (arg == 0 || arg > MAX_NR_CONSOLES)\n\t\t\treturn -ENXIO;\n\t\treturn vt_waitactive(arg);\n\n\t/*\n\t * If a vt is under process control, the kernel will not switch to it\n\t * immediately, but postpone the operation until the process calls this\n\t * ioctl, allowing the switch to complete.\n\t *\n\t * According to the X sources this is the behavior:\n\t *\t0:\tpending switch-from not OK\n\t *\t1:\tpending switch-from OK\n\t *\t2:\tcompleted switch-to OK\n\t */\n\tcase VT_RELDISP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\tconsole_lock();\n\t\tret = vt_reldisp(vc, arg);\n\t\tconsole_unlock();\n\n\t\treturn ret;\n\n\n\t /*\n\t  * Disallocate memory associated to VT (but leave VT1)\n\t  */\n\t case VT_DISALLOCATE:\n\t\tif (arg > MAX_NR_CONSOLES)\n\t\t\treturn -ENXIO;\n\n\t\tif (arg == 0)\n\t\t\tvt_disallocate_all();\n\t\telse\n\t\t\treturn vt_disallocate(--arg);\n\t\tbreak;\n\n\tcase VT_RESIZE:\n\t{\n\t\tstruct vt_sizes __user *vtsizes = up;\n\t\tstruct vc_data *vc;\n\t\tushort ll,cc;\n\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\tif (get_user(ll, &vtsizes->v_rows) ||\n\t\t    get_user(cc, &vtsizes->v_cols))\n\t\t\treturn -EFAULT;\n\n\t\tconsole_lock();\n\t\tfor (i = 0; i < MAX_NR_CONSOLES; i++) {\n\t\t\tvc = vc_cons[i].d;\n\n\t\t\tif (vc) {\n\t\t\t\tvc->vc_resize_user = 1;\n\t\t\t\t/* FIXME: review v tty lock */\n\t\t\t\tvc_resize(vc_cons[i].d, cc, ll);\n\t\t\t}\n\t\t}\n\t\tconsole_unlock();\n\t\tbreak;\n\t}\n\n\tcase VT_RESIZEX:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\n\t\treturn vt_resizex(vc, up);\n\n\tcase VT_LOCKSWITCH:\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\t\tvt_dont_switch = true;\n\t\tbreak;\n\tcase VT_UNLOCKSWITCH:\n\t\tif (!capable(CAP_SYS_TTY_CONFIG))\n\t\t\treturn -EPERM;\n\t\tvt_dont_switch = false;\n\t\tbreak;\n\tcase VT_GETHIFONTMASK:\n\t\treturn put_user(vc->vc_hi_font_mask,\n\t\t\t\t\t(unsigned short __user *)arg);\n\tcase VT_WAITEVENT:\n\t\treturn vt_event_wait_ioctl((struct vt_event __user *)arg);\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\n\treturn 0;\n}\n\nvoid reset_vc(struct vc_data *vc)\n{\n\tvc->vc_mode = KD_TEXT;\n\tvt_reset_unicode(vc->vc_num);\n\tvc->vt_mode.mode = VT_AUTO;\n\tvc->vt_mode.waitv = 0;\n\tvc->vt_mode.relsig = 0;\n\tvc->vt_mode.acqsig = 0;\n\tvc->vt_mode.frsig = 0;\n\tput_pid(vc->vt_pid);\n\tvc->vt_pid = NULL;\n\tvc->vt_newvt = -1;\n\treset_palette(vc);\n}\n\nvoid vc_SAK(struct work_struct *work)\n{\n\tstruct vc *vc_con =\n\t\tcontainer_of(work, struct vc, SAK_work);\n\tstruct vc_data *vc;\n\tstruct tty_struct *tty;\n\n\tconsole_lock();\n\tvc = vc_con->d;\n\tif (vc) {\n\t\t/* FIXME: review tty ref counting */\n\t\ttty = vc->port.tty;\n\t\t/*\n\t\t * SAK should also work in all raw modes and reset\n\t\t * them properly.\n\t\t */\n\t\tif (tty)\n\t\t\t__do_SAK(tty);\n\t\treset_vc(vc);\n\t}\n\tconsole_unlock();\n}\n\n#ifdef CONFIG_COMPAT\n\nstruct compat_console_font_op {\n\tcompat_uint_t op;        /* operation code KD_FONT_OP_* */\n\tcompat_uint_t flags;     /* KD_FONT_FLAG_* */\n\tcompat_uint_t width, height;     /* font size */\n\tcompat_uint_t charcount;\n\tcompat_caddr_t data;    /* font data with height fixed to 32 */\n};\n\nstatic inline int\ncompat_kdfontop_ioctl(struct compat_console_font_op __user *fontop,\n\t\t\t int perm, struct console_font_op *op, struct vc_data *vc)\n{\n\tint i;\n\n\tif (copy_from_user(op, fontop, sizeof(struct compat_console_font_op)))\n\t\treturn -EFAULT;\n\tif (!perm && op->op != KD_FONT_OP_GET)\n\t\treturn -EPERM;\n\top->data = compat_ptr(((struct compat_console_font_op *)op)->data);\n\ti = con_font_op(vc, op);\n\tif (i)\n\t\treturn i;\n\t((struct compat_console_font_op *)op)->data = (unsigned long)op->data;\n\tif (copy_to_user(fontop, op, sizeof(struct compat_console_font_op)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstruct compat_unimapdesc {\n\tunsigned short entry_ct;\n\tcompat_caddr_t entries;\n};\n\nstatic inline int\ncompat_unimap_ioctl(unsigned int cmd, struct compat_unimapdesc __user *user_ud,\n\t\t\t int perm, struct vc_data *vc)\n{\n\tstruct compat_unimapdesc tmp;\n\tstruct unipair __user *tmp_entries;\n\n\tif (copy_from_user(&tmp, user_ud, sizeof tmp))\n\t\treturn -EFAULT;\n\ttmp_entries = compat_ptr(tmp.entries);\n\tswitch (cmd) {\n\tcase PIO_UNIMAP:\n\t\tif (!perm)\n\t\t\treturn -EPERM;\n\t\treturn con_set_unimap(vc, tmp.entry_ct, tmp_entries);\n\tcase GIO_UNIMAP:\n\t\tif (!perm && fg_console != vc->vc_num)\n\t\t\treturn -EPERM;\n\t\treturn con_get_unimap(vc, tmp.entry_ct, &(user_ud->entry_ct), tmp_entries);\n\t}\n\treturn 0;\n}\n\nlong vt_compat_ioctl(struct tty_struct *tty,\n\t     unsigned int cmd, unsigned long arg)\n{\n\tstruct vc_data *vc = tty->driver_data;\n\tstruct console_font_op op;\t/* used in multiple places here */\n\tvoid __user *up = compat_ptr(arg);\n\tint perm;\n\n\t/*\n\t * To have permissions to do most of the vt ioctls, we either have\n\t * to be the owner of the tty, or have CAP_SYS_TTY_CONFIG.\n\t */\n\tperm = 0;\n\tif (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))\n\t\tperm = 1;\n\n\tswitch (cmd) {\n\t/*\n\t * these need special handlers for incompatible data structures\n\t */\n\n\tcase KDFONTOP:\n\t\treturn compat_kdfontop_ioctl(up, perm, &op, vc);\n\n\tcase PIO_UNIMAP:\n\tcase GIO_UNIMAP:\n\t\treturn compat_unimap_ioctl(cmd, up, perm, vc);\n\n\t/*\n\t * all these treat 'arg' as an integer\n\t */\n\tcase KIOCSOUND:\n\tcase KDMKTONE:\n#ifdef CONFIG_X86\n\tcase KDADDIO:\n\tcase KDDELIO:\n#endif\n\tcase KDSETMODE:\n\tcase KDMAPDISP:\n\tcase KDUNMAPDISP:\n\tcase KDSKBMODE:\n\tcase KDSKBMETA:\n\tcase KDSKBLED:\n\tcase KDSETLED:\n\tcase KDSIGACCEPT:\n\tcase VT_ACTIVATE:\n\tcase VT_WAITACTIVE:\n\tcase VT_RELDISP:\n\tcase VT_DISALLOCATE:\n\tcase VT_RESIZE:\n\tcase VT_RESIZEX:\n\t\treturn vt_ioctl(tty, cmd, arg);\n\n\t/*\n\t * the rest has a compatible data structure behind arg,\n\t * but we have to convert it to a proper 64 bit pointer.\n\t */\n\tdefault:\n\t\treturn vt_ioctl(tty, cmd, (unsigned long)up);\n\t}\n}\n\n\n#endif /* CONFIG_COMPAT */\n\n\n/*\n * Performs the back end of a vt switch. Called under the console\n * semaphore.\n */\nstatic void complete_change_console(struct vc_data *vc)\n{\n\tunsigned char old_vc_mode;\n\tint old = fg_console;\n\n\tlast_console = fg_console;\n\n\t/*\n\t * If we're switching, we could be going from KD_GRAPHICS to\n\t * KD_TEXT mode or vice versa, which means we need to blank or\n\t * unblank the screen later.\n\t */\n\told_vc_mode = vc_cons[fg_console].d->vc_mode;\n\tswitch_screen(vc);\n\n\t/*\n\t * This can't appear below a successful kill_pid().  If it did,\n\t * then the *blank_screen operation could occur while X, having\n\t * received acqsig, is waking up on another processor.  This\n\t * condition can lead to overlapping accesses to the VGA range\n\t * and the framebuffer (causing system lockups).\n\t *\n\t * To account for this we duplicate this code below only if the\n\t * controlling process is gone and we've called reset_vc.\n\t */\n\tif (old_vc_mode != vc->vc_mode) {\n\t\tif (vc->vc_mode == KD_TEXT)\n\t\t\tdo_unblank_screen(1);\n\t\telse\n\t\t\tdo_blank_screen(1);\n\t}\n\n\t/*\n\t * If this new console is under process control, send it a signal\n\t * telling it that it has acquired. Also check if it has died and\n\t * clean up (similar to logic employed in change_console())\n\t */\n\tif (vc->vt_mode.mode == VT_PROCESS) {\n\t\t/*\n\t\t * Send the signal as privileged - kill_pid() will\n\t\t * tell us if the process has gone or something else\n\t\t * is awry\n\t\t */\n\t\tif (kill_pid(vc->vt_pid, vc->vt_mode.acqsig, 1) != 0) {\n\t\t/*\n\t\t * The controlling process has died, so we revert back to\n\t\t * normal operation. In this case, we'll also change back\n\t\t * to KD_TEXT mode. I'm not sure if this is strictly correct\n\t\t * but it saves the agony when the X server dies and the screen\n\t\t * remains blanked due to KD_GRAPHICS! It would be nice to do\n\t\t * this outside of VT_PROCESS but there is no single process\n\t\t * to account for and tracking tty count may be undesirable.\n\t\t */\n\t\t\treset_vc(vc);\n\n\t\t\tif (old_vc_mode != vc->vc_mode) {\n\t\t\t\tif (vc->vc_mode == KD_TEXT)\n\t\t\t\t\tdo_unblank_screen(1);\n\t\t\t\telse\n\t\t\t\t\tdo_blank_screen(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Wake anyone waiting for their VT to activate\n\t */\n\tvt_event_post(VT_EVENT_SWITCH, old, vc->vc_num);\n\treturn;\n}\n\n/*\n * Performs the front-end of a vt switch\n */\nvoid change_console(struct vc_data *new_vc)\n{\n\tstruct vc_data *vc;\n\n\tif (!new_vc || new_vc->vc_num == fg_console || vt_dont_switch)\n\t\treturn;\n\n\t/*\n\t * If this vt is in process mode, then we need to handshake with\n\t * that process before switching. Essentially, we store where that\n\t * vt wants to switch to and wait for it to tell us when it's done\n\t * (via VT_RELDISP ioctl).\n\t *\n\t * We also check to see if the controlling process still exists.\n\t * If it doesn't, we reset this vt to auto mode and continue.\n\t * This is a cheap way to track process control. The worst thing\n\t * that can happen is: we send a signal to a process, it dies, and\n\t * the switch gets \"lost\" waiting for a response; hopefully, the\n\t * user will try again, we'll detect the process is gone (unless\n\t * the user waits just the right amount of time :-) and revert the\n\t * vt to auto control.\n\t */\n\tvc = vc_cons[fg_console].d;\n\tif (vc->vt_mode.mode == VT_PROCESS) {\n\t\t/*\n\t\t * Send the signal as privileged - kill_pid() will\n\t\t * tell us if the process has gone or something else\n\t\t * is awry.\n\t\t *\n\t\t * We need to set vt_newvt *before* sending the signal or we\n\t\t * have a race.\n\t\t */\n\t\tvc->vt_newvt = new_vc->vc_num;\n\t\tif (kill_pid(vc->vt_pid, vc->vt_mode.relsig, 1) == 0) {\n\t\t\t/*\n\t\t\t * It worked. Mark the vt to switch to and\n\t\t\t * return. The process needs to send us a\n\t\t\t * VT_RELDISP ioctl to complete the switch.\n\t\t\t */\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * The controlling process has died, so we revert back to\n\t\t * normal operation. In this case, we'll also change back\n\t\t * to KD_TEXT mode. I'm not sure if this is strictly correct\n\t\t * but it saves the agony when the X server dies and the screen\n\t\t * remains blanked due to KD_GRAPHICS! It would be nice to do\n\t\t * this outside of VT_PROCESS but there is no single process\n\t\t * to account for and tracking tty count may be undesirable.\n\t\t */\n\t\treset_vc(vc);\n\n\t\t/*\n\t\t * Fall through to normal (VT_AUTO) handling of the switch...\n\t\t */\n\t}\n\n\t/*\n\t * Ignore all switches in KD_GRAPHICS+VT_AUTO mode\n\t */\n\tif (vc->vc_mode == KD_GRAPHICS)\n\t\treturn;\n\n\tcomplete_change_console(new_vc);\n}\n\n/* Perform a kernel triggered VT switch for suspend/resume */\n\nstatic int disable_vt_switch;\n\nint vt_move_to_console(unsigned int vt, int alloc)\n{\n\tint prev;\n\n\tconsole_lock();\n\t/* Graphics mode - up to X */\n\tif (disable_vt_switch) {\n\t\tconsole_unlock();\n\t\treturn 0;\n\t}\n\tprev = fg_console;\n\n\tif (alloc && vc_allocate(vt)) {\n\t\t/* we can't have a free VC for now. Too bad,\n\t\t * we don't want to mess the screen for now. */\n\t\tconsole_unlock();\n\t\treturn -ENOSPC;\n\t}\n\n\tif (set_console(vt)) {\n\t\t/*\n\t\t * We're unable to switch to the SUSPEND_CONSOLE.\n\t\t * Let the calling function know so it can decide\n\t\t * what to do.\n\t\t */\n\t\tconsole_unlock();\n\t\treturn -EIO;\n\t}\n\tconsole_unlock();\n\tif (vt_waitactive(vt + 1)) {\n\t\tpr_debug(\"Suspend: Can't switch VCs.\");\n\t\treturn -EINTR;\n\t}\n\treturn prev;\n}\n\n/*\n * Normally during a suspend, we allocate a new console and switch to it.\n * When we resume, we switch back to the original console.  This switch\n * can be slow, so on systems where the framebuffer can handle restoration\n * of video registers anyways, there's little point in doing the console\n * switch.  This function allows you to disable it by passing it '0'.\n */\nvoid pm_set_vt_switch(int do_switch)\n{\n\tconsole_lock();\n\tdisable_vt_switch = !do_switch;\n\tconsole_unlock();\n}\nEXPORT_SYMBOL(pm_set_vt_switch);\n"], "filenames": ["drivers/tty/vt/vt_ioctl.c"], "buggy_code_start_loc": [248], "buggy_code_end_loc": [382], "fixing_code_start_loc": [249], "fixing_code_end_loc": [384], "type": "CWE-125", "message": "A race problem was seen in the vt_k_ioctl in drivers/tty/vt/vt_ioctl.c in the Linux kernel, which may cause an out of bounds read in vt as the write access to vc_mode is not protected by lock-in vt_ioctl (KDSETMDE). The highest threat from this vulnerability is to data confidentiality.", "other": {"cve": {"id": "CVE-2021-3753", "sourceIdentifier": "secalert@redhat.com", "published": "2022-02-16T19:15:08.647", "lastModified": "2022-12-07T01:58:12.130", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A race problem was seen in the vt_k_ioctl in drivers/tty/vt/vt_ioctl.c in the Linux kernel, which may cause an out of bounds read in vt as the write access to vc_mode is not protected by lock-in vt_ioctl (KDSETMDE). The highest threat from this vulnerability is to data confidentiality."}, {"lang": "es", "value": "Se observ\u00f3 un problema de carrera en el la funci\u00f3n vt_k_ioctl en el archivo drivers/tty/vt/vt_ioctl.c en el kernel de Linux, que puede causar una lectura fuera de l\u00edmites en vt ya que el acceso de escritura a vc_mode no est\u00e1 protegido por el bloqueo de vt_ioctl (KDSETMDE). La mayor amenaza de esta vulnerabilidad es para la confidencialidad de los datos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}, {"lang": "en", "value": "CWE-362"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.15", "matchCriteriaId": "037A6DFB-B41D-4CC7-86C1-A201809B79C4"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "85DF4B3F-4BBC-42B7-B729-096934523D63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:bootstrap_os:-:*:*:*:*:*:*:*", "matchCriteriaId": "95BA156C-C977-4F0C-8DFB-3FAE9CC8C02D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1999589", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/2287a51ba822384834dafc1c798453375d1107c7", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221028-0003/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2021/09/01/4", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/2287a51ba822384834dafc1c798453375d1107c7"}}