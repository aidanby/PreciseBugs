{"buggy_code": ["/* Authentication token and access key management\n *\n * Copyright (C) 2004, 2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n *\n * See Documentation/security/keys/core.rst for information on keys/keyrings.\n */\n\n#ifndef _LINUX_KEY_H\n#define _LINUX_KEY_H\n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include <linux/rcupdate.h>\n#include <linux/sysctl.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n#include <linux/assoc_array.h>\n#include <linux/refcount.h>\n\n#ifdef __KERNEL__\n#include <linux/uidgid.h>\n\n/* key handle serial number */\ntypedef int32_t key_serial_t;\n\n/* key handle permissions mask */\ntypedef uint32_t key_perm_t;\n\nstruct key;\n\n#ifdef CONFIG_KEYS\n\n#undef KEY_DEBUGGING\n\n#define KEY_POS_VIEW\t0x01000000\t/* possessor can view a key's attributes */\n#define KEY_POS_READ\t0x02000000\t/* possessor can read key payload / view keyring */\n#define KEY_POS_WRITE\t0x04000000\t/* possessor can update key payload / add link to keyring */\n#define KEY_POS_SEARCH\t0x08000000\t/* possessor can find a key in search / search a keyring */\n#define KEY_POS_LINK\t0x10000000\t/* possessor can create a link to a key/keyring */\n#define KEY_POS_SETATTR\t0x20000000\t/* possessor can set key attributes */\n#define KEY_POS_ALL\t0x3f000000\n\n#define KEY_USR_VIEW\t0x00010000\t/* user permissions... */\n#define KEY_USR_READ\t0x00020000\n#define KEY_USR_WRITE\t0x00040000\n#define KEY_USR_SEARCH\t0x00080000\n#define KEY_USR_LINK\t0x00100000\n#define KEY_USR_SETATTR\t0x00200000\n#define KEY_USR_ALL\t0x003f0000\n\n#define KEY_GRP_VIEW\t0x00000100\t/* group permissions... */\n#define KEY_GRP_READ\t0x00000200\n#define KEY_GRP_WRITE\t0x00000400\n#define KEY_GRP_SEARCH\t0x00000800\n#define KEY_GRP_LINK\t0x00001000\n#define KEY_GRP_SETATTR\t0x00002000\n#define KEY_GRP_ALL\t0x00003f00\n\n#define KEY_OTH_VIEW\t0x00000001\t/* third party permissions... */\n#define KEY_OTH_READ\t0x00000002\n#define KEY_OTH_WRITE\t0x00000004\n#define KEY_OTH_SEARCH\t0x00000008\n#define KEY_OTH_LINK\t0x00000010\n#define KEY_OTH_SETATTR\t0x00000020\n#define KEY_OTH_ALL\t0x0000003f\n\n#define KEY_PERM_UNDEF\t0xffffffff\n\nstruct seq_file;\nstruct user_struct;\nstruct signal_struct;\nstruct cred;\n\nstruct key_type;\nstruct key_owner;\nstruct keyring_list;\nstruct keyring_name;\n\nstruct keyring_index_key {\n\tstruct key_type\t\t*type;\n\tconst char\t\t*description;\n\tsize_t\t\t\tdesc_len;\n};\n\nunion key_payload {\n\tvoid __rcu\t\t*rcu_data0;\n\tvoid\t\t\t*data[4];\n};\n\n/*****************************************************************************/\n/*\n * key reference with possession attribute handling\n *\n * NOTE! key_ref_t is a typedef'd pointer to a type that is not actually\n * defined. This is because we abuse the bottom bit of the reference to carry a\n * flag to indicate whether the calling process possesses that key in one of\n * its keyrings.\n *\n * the key_ref_t has been made a separate type so that the compiler can reject\n * attempts to dereference it without proper conversion.\n *\n * the three functions are used to assemble and disassemble references\n */\ntypedef struct __key_reference_with_attributes *key_ref_t;\n\nstatic inline key_ref_t make_key_ref(const struct key *key,\n\t\t\t\t     bool possession)\n{\n\treturn (key_ref_t) ((unsigned long) key | possession);\n}\n\nstatic inline struct key *key_ref_to_ptr(const key_ref_t key_ref)\n{\n\treturn (struct key *) ((unsigned long) key_ref & ~1UL);\n}\n\nstatic inline bool is_key_possessed(const key_ref_t key_ref)\n{\n\treturn (unsigned long) key_ref & 1UL;\n}\n\ntypedef int (*key_restrict_link_func_t)(struct key *dest_keyring,\n\t\t\t\t\tconst struct key_type *type,\n\t\t\t\t\tconst union key_payload *payload,\n\t\t\t\t\tstruct key *restriction_key);\n\nstruct key_restriction {\n\tkey_restrict_link_func_t check;\n\tstruct key *key;\n\tstruct key_type *keytype;\n};\n\n/*****************************************************************************/\n/*\n * authentication token / access credential / keyring\n * - types of key include:\n *   - keyrings\n *   - disk encryption IDs\n *   - Kerberos TGTs and tickets\n */\nstruct key {\n\trefcount_t\t\tusage;\t\t/* number of references */\n\tkey_serial_t\t\tserial;\t\t/* key serial number */\n\tunion {\n\t\tstruct list_head graveyard_link;\n\t\tstruct rb_node\tserial_node;\n\t};\n\tstruct rw_semaphore\tsem;\t\t/* change vs change sem */\n\tstruct key_user\t\t*user;\t\t/* owner of this key */\n\tvoid\t\t\t*security;\t/* security data for this key */\n\tunion {\n\t\ttime_t\t\texpiry;\t\t/* time at which key expires (or 0) */\n\t\ttime_t\t\trevoked_at;\t/* time at which key was revoked */\n\t};\n\ttime_t\t\t\tlast_used_at;\t/* last time used for LRU keyring discard */\n\tkuid_t\t\t\tuid;\n\tkgid_t\t\t\tgid;\n\tkey_perm_t\t\tperm;\t\t/* access permissions */\n\tunsigned short\t\tquotalen;\t/* length added to quota */\n\tunsigned short\t\tdatalen;\t/* payload data length\n\t\t\t\t\t\t * - may not match RCU dereferenced payload\n\t\t\t\t\t\t * - payload should contain own length\n\t\t\t\t\t\t */\n\n#ifdef KEY_DEBUGGING\n\tunsigned\t\tmagic;\n#define KEY_DEBUG_MAGIC\t\t0x18273645u\n#endif\n\n\tunsigned long\t\tflags;\t\t/* status flags (change with bitops) */\n#define KEY_FLAG_INSTANTIATED\t0\t/* set if key has been instantiated */\n#define KEY_FLAG_DEAD\t\t1\t/* set if key type has been deleted */\n#define KEY_FLAG_REVOKED\t2\t/* set if key had been revoked */\n#define KEY_FLAG_IN_QUOTA\t3\t/* set if key consumes quota */\n#define KEY_FLAG_USER_CONSTRUCT\t4\t/* set if key is being constructed in userspace */\n#define KEY_FLAG_NEGATIVE\t5\t/* set if key is negative */\n#define KEY_FLAG_ROOT_CAN_CLEAR\t6\t/* set if key can be cleared by root without permission */\n#define KEY_FLAG_INVALIDATED\t7\t/* set if key has been invalidated */\n#define KEY_FLAG_BUILTIN\t8\t/* set if key is built in to the kernel */\n#define KEY_FLAG_ROOT_CAN_INVAL\t9\t/* set if key can be invalidated by root without permission */\n#define KEY_FLAG_KEEP\t\t10\t/* set if key should not be removed */\n#define KEY_FLAG_UID_KEYRING\t11\t/* set if key is a user or user session keyring */\n\n\t/* the key type and key description string\n\t * - the desc is used to match a key against search criteria\n\t * - it should be a printable string\n\t * - eg: for krb5 AFS, this might be \"afs@REDHAT.COM\"\n\t */\n\tunion {\n\t\tstruct keyring_index_key index_key;\n\t\tstruct {\n\t\t\tstruct key_type\t*type;\t\t/* type of key */\n\t\t\tchar\t\t*description;\n\t\t};\n\t};\n\n\t/* key data\n\t * - this is used to hold the data actually used in cryptography or\n\t *   whatever\n\t */\n\tunion {\n\t\tunion key_payload payload;\n\t\tstruct {\n\t\t\t/* Keyring bits */\n\t\t\tstruct list_head name_link;\n\t\t\tstruct assoc_array keys;\n\t\t};\n\t\tint reject_error;\n\t};\n\n\t/* This is set on a keyring to restrict the addition of a link to a key\n\t * to it.  If this structure isn't provided then it is assumed that the\n\t * keyring is open to any addition.  It is ignored for non-keyring\n\t * keys. Only set this value using keyring_restrict(), keyring_alloc(),\n\t * or key_alloc().\n\t *\n\t * This is intended for use with rings of trusted keys whereby addition\n\t * to the keyring needs to be controlled.  KEY_ALLOC_BYPASS_RESTRICTION\n\t * overrides this, allowing the kernel to add extra keys without\n\t * restriction.\n\t */\n\tstruct key_restriction *restrict_link;\n};\n\nextern struct key *key_alloc(struct key_type *type,\n\t\t\t     const char *desc,\n\t\t\t     kuid_t uid, kgid_t gid,\n\t\t\t     const struct cred *cred,\n\t\t\t     key_perm_t perm,\n\t\t\t     unsigned long flags,\n\t\t\t     struct key_restriction *restrict_link);\n\n\n#define KEY_ALLOC_IN_QUOTA\t\t0x0000\t/* add to quota, reject if would overrun */\n#define KEY_ALLOC_QUOTA_OVERRUN\t\t0x0001\t/* add to quota, permit even if overrun */\n#define KEY_ALLOC_NOT_IN_QUOTA\t\t0x0002\t/* not in quota */\n#define KEY_ALLOC_BUILT_IN\t\t0x0004\t/* Key is built into kernel */\n#define KEY_ALLOC_BYPASS_RESTRICTION\t0x0008\t/* Override the check on restricted keyrings */\n#define KEY_ALLOC_UID_KEYRING\t\t0x0010\t/* allocating a user or user session keyring */\n\nextern void key_revoke(struct key *key);\nextern void key_invalidate(struct key *key);\nextern void key_put(struct key *key);\n\nstatic inline struct key *__key_get(struct key *key)\n{\n\trefcount_inc(&key->usage);\n\treturn key;\n}\n\nstatic inline struct key *key_get(struct key *key)\n{\n\treturn key ? __key_get(key) : key;\n}\n\nstatic inline void key_ref_put(key_ref_t key_ref)\n{\n\tkey_put(key_ref_to_ptr(key_ref));\n}\n\nextern struct key *request_key(struct key_type *type,\n\t\t\t       const char *description,\n\t\t\t       const char *callout_info);\n\nextern struct key *request_key_with_auxdata(struct key_type *type,\n\t\t\t\t\t    const char *description,\n\t\t\t\t\t    const void *callout_info,\n\t\t\t\t\t    size_t callout_len,\n\t\t\t\t\t    void *aux);\n\nextern struct key *request_key_async(struct key_type *type,\n\t\t\t\t     const char *description,\n\t\t\t\t     const void *callout_info,\n\t\t\t\t     size_t callout_len);\n\nextern struct key *request_key_async_with_auxdata(struct key_type *type,\n\t\t\t\t\t\t  const char *description,\n\t\t\t\t\t\t  const void *callout_info,\n\t\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t\t  void *aux);\n\nextern int wait_for_key_construction(struct key *key, bool intr);\n\nextern int key_validate(const struct key *key);\n\nextern key_ref_t key_create_or_update(key_ref_t keyring,\n\t\t\t\t      const char *type,\n\t\t\t\t      const char *description,\n\t\t\t\t      const void *payload,\n\t\t\t\t      size_t plen,\n\t\t\t\t      key_perm_t perm,\n\t\t\t\t      unsigned long flags);\n\nextern int key_update(key_ref_t key,\n\t\t      const void *payload,\n\t\t      size_t plen);\n\nextern int key_link(struct key *keyring,\n\t\t    struct key *key);\n\nextern int key_unlink(struct key *keyring,\n\t\t      struct key *key);\n\nextern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t\t const struct cred *cred,\n\t\t\t\t key_perm_t perm,\n\t\t\t\t unsigned long flags,\n\t\t\t\t struct key_restriction *restrict_link,\n\t\t\t\t struct key *dest);\n\nextern int restrict_link_reject(struct key *keyring,\n\t\t\t\tconst struct key_type *type,\n\t\t\t\tconst union key_payload *payload,\n\t\t\t\tstruct key *restriction_key);\n\nextern int keyring_clear(struct key *keyring);\n\nextern key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t\tstruct key_type *type,\n\t\t\t\tconst char *description);\n\nextern int keyring_add_key(struct key *keyring,\n\t\t\t   struct key *key);\n\nextern int keyring_restrict(key_ref_t keyring, const char *type,\n\t\t\t    const char *restriction);\n\nextern struct key *key_lookup(key_serial_t id);\n\nstatic inline key_serial_t key_serial(const struct key *key)\n{\n\treturn key ? key->serial : 0;\n}\n\nextern void key_set_timeout(struct key *, unsigned);\n\n/*\n * The permissions required on a key that we're looking up.\n */\n#define\tKEY_NEED_VIEW\t0x01\t/* Require permission to view attributes */\n#define\tKEY_NEED_READ\t0x02\t/* Require permission to read content */\n#define\tKEY_NEED_WRITE\t0x04\t/* Require permission to update / modify */\n#define\tKEY_NEED_SEARCH\t0x08\t/* Require permission to search (keyring) or find (key) */\n#define\tKEY_NEED_LINK\t0x10\t/* Require permission to link */\n#define\tKEY_NEED_SETATTR 0x20\t/* Require permission to change attributes */\n#define\tKEY_NEED_ALL\t0x3f\t/* All the above permissions */\n\n/**\n * key_is_instantiated - Determine if a key has been positively instantiated\n * @key: The key to check.\n *\n * Return true if the specified key has been positively instantiated, false\n * otherwise.\n */\nstatic inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}\n\n#define dereference_key_rcu(KEY)\t\t\t\t\t\\\n\t(rcu_dereference((KEY)->payload.rcu_data0))\n\n#define dereference_key_locked(KEY)\t\t\t\t\t\\\n\t(rcu_dereference_protected((KEY)->payload.rcu_data0,\t\t\\\n\t\t\t\t   rwsem_is_locked(&((struct key *)(KEY))->sem)))\n\n#define rcu_assign_keypointer(KEY, PAYLOAD)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\trcu_assign_pointer((KEY)->payload.rcu_data0, (PAYLOAD));\t\\\n} while (0)\n\n#ifdef CONFIG_SYSCTL\nextern struct ctl_table key_sysctls[];\n#endif\n/*\n * the userspace interface\n */\nextern int install_thread_keyring_to_cred(struct cred *cred);\nextern void key_fsuid_changed(struct task_struct *tsk);\nextern void key_fsgid_changed(struct task_struct *tsk);\nextern void key_init(void);\n\n#else /* CONFIG_KEYS */\n\n#define key_validate(k)\t\t\t0\n#define key_serial(k)\t\t\t0\n#define key_get(k) \t\t\t({ NULL; })\n#define key_revoke(k)\t\t\tdo { } while(0)\n#define key_invalidate(k)\t\tdo { } while(0)\n#define key_put(k)\t\t\tdo { } while(0)\n#define key_ref_put(k)\t\t\tdo { } while(0)\n#define make_key_ref(k, p)\t\tNULL\n#define key_ref_to_ptr(k)\t\tNULL\n#define is_key_possessed(k)\t\t0\n#define key_fsuid_changed(t)\t\tdo { } while(0)\n#define key_fsgid_changed(t)\t\tdo { } while(0)\n#define key_init()\t\t\tdo { } while(0)\n\n#endif /* CONFIG_KEYS */\n#endif /* __KERNEL__ */\n#endif /* _LINUX_KEY_H */\n", "/* Key type used to cache DNS lookups made by the kernel\n *\n * See Documentation/networking/dns_resolver.txt\n *\n *   Copyright (c) 2007 Igor Mammedov\n *   Author(s): Igor Mammedov (niallain@gmail.com)\n *              Steve French (sfrench@us.ibm.com)\n *              Wang Lei (wang840925@gmail.com)\n *\t\tDavid Howells (dhowells@redhat.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/keyctl.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <keys/dns_resolver-type.h>\n#include <keys/user-type.h>\n#include \"internal.h\"\n\nMODULE_DESCRIPTION(\"DNS Resolver\");\nMODULE_AUTHOR(\"Wang Lei\");\nMODULE_LICENSE(\"GPL\");\n\nunsigned int dns_resolver_debug;\nmodule_param_named(debug, dns_resolver_debug, uint, S_IWUSR | S_IRUGO);\nMODULE_PARM_DESC(debug, \"DNS Resolver debugging mask\");\n\nconst struct cred *dns_resolver_cache;\n\n#define\tDNS_ERRORNO_OPTION\t\"dnserror\"\n\n/*\n * Preparse instantiation data for a dns_resolver key.\n *\n * The data must be a NUL-terminated string, with the NUL char accounted in\n * datalen.\n *\n * If the data contains a '#' characters, then we take the clause after each\n * one to be an option of the form 'key=value'.  The actual data of interest is\n * the string leading up to the first '#'.  For instance:\n *\n *        \"ip1,ip2,...#foo=bar\"\n */\nstatic int\ndns_resolver_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tunsigned long derrno;\n\tint ret;\n\tint datalen = prep->datalen, result_len = 0;\n\tconst char *data = prep->data, *end, *opt;\n\n\tkenter(\"'%*.*s',%u\", datalen, datalen, data, datalen);\n\n\tif (datalen <= 1 || !data || data[datalen - 1] != '\\0')\n\t\treturn -EINVAL;\n\tdatalen--;\n\n\t/* deal with any options embedded in the data */\n\tend = data + datalen;\n\topt = memchr(data, '#', datalen);\n\tif (!opt) {\n\t\t/* no options: the entire data is the result */\n\t\tkdebug(\"no options\");\n\t\tresult_len = datalen;\n\t} else {\n\t\tconst char *next_opt;\n\n\t\tresult_len = opt - data;\n\t\topt++;\n\t\tkdebug(\"options: '%s'\", opt);\n\t\tdo {\n\t\t\tconst char *eq;\n\t\t\tint opt_len, opt_nlen, opt_vlen, tmp;\n\n\t\t\tnext_opt = memchr(opt, '#', end - opt) ?: end;\n\t\t\topt_len = next_opt - opt;\n\t\t\tif (!opt_len) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"Empty option to dns_resolver key\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\teq = memchr(opt, '=', opt_len) ?: end;\n\t\t\topt_nlen = eq - opt;\n\t\t\teq++;\n\t\t\topt_vlen = next_opt - eq; /* will be -1 if no value */\n\n\t\t\ttmp = opt_vlen >= 0 ? opt_vlen : 0;\n\t\t\tkdebug(\"option '%*.*s' val '%*.*s'\",\n\t\t\t       opt_nlen, opt_nlen, opt, tmp, tmp, eq);\n\n\t\t\t/* see if it's an error number representing a DNS error\n\t\t\t * that's to be recorded as the result in this key */\n\t\t\tif (opt_nlen == sizeof(DNS_ERRORNO_OPTION) - 1 &&\n\t\t\t    memcmp(opt, DNS_ERRORNO_OPTION, opt_nlen) == 0) {\n\t\t\t\tkdebug(\"dns error number option\");\n\t\t\t\tif (opt_vlen <= 0)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tret = kstrtoul(eq, 10, &derrno);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tif (derrno < 1 || derrno > 511)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tkdebug(\"dns error no. = %lu\", derrno);\n\t\t\t\tprep->payload.data[dns_key_error] = ERR_PTR(-derrno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\tbad_option_value:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"Option '%*.*s' to dns_resolver key:\"\n\t\t\t       \" bad/missing value\\n\",\n\t\t\t       opt_nlen, opt_nlen, opt);\n\t\t\treturn -EINVAL;\n\t\t} while (opt = next_opt + 1, opt < end);\n\t}\n\n\t/* don't cache the result if we're caching an error saying there's no\n\t * result */\n\tif (prep->payload.data[dns_key_error]) {\n\t\tkleave(\" = 0 [h_error %ld]\", PTR_ERR(prep->payload.data[dns_key_error]));\n\t\treturn 0;\n\t}\n\n\tkdebug(\"store result\");\n\tprep->quotalen = result_len;\n\n\tupayload = kmalloc(sizeof(*upayload) + result_len + 1, GFP_KERNEL);\n\tif (!upayload) {\n\t\tkleave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\tupayload->datalen = result_len;\n\tmemcpy(upayload->data, data, result_len);\n\tupayload->data[result_len] = '\\0';\n\n\tprep->payload.data[dns_key_data] = upayload;\n\tkleave(\" = 0\");\n\treturn 0;\n}\n\n/*\n * Clean up the preparse data\n */\nstatic void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n{\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tkfree(prep->payload.data[dns_key_data]);\n}\n\n/*\n * The description is of the form \"[<type>:]<domain_name>\"\n *\n * The domain name may be a simple name or an absolute domain name (which\n * should end with a period).  The domain name is case-independent.\n */\nstatic bool dns_resolver_cmp(const struct key *key,\n\t\t\t     const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\n\tkenter(\"%s,%s\", src, dsp);\n\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\n\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Preparse the match criterion.\n */\nstatic int dns_resolver_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = dns_resolver_cmp;\n\treturn 0;\n}\n\n/*\n * Describe a DNS key\n */\nstatic void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key)) {\n\t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}\n\n/*\n * read the DNS data\n * - the key's semaphore is read-locked\n */\nstatic long dns_resolver_read(const struct key *key,\n\t\t\t      char __user *buffer, size_t buflen)\n{\n\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\n\tif (err)\n\t\treturn err;\n\n\treturn user_read(key, buffer, buflen);\n}\n\nstruct key_type key_type_dns_resolver = {\n\t.name\t\t= \"dns_resolver\",\n\t.preparse\t= dns_resolver_preparse,\n\t.free_preparse\t= dns_resolver_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.match_preparse\t= dns_resolver_match_preparse,\n\t.revoke\t\t= user_revoke,\n\t.destroy\t= user_destroy,\n\t.describe\t= dns_resolver_describe,\n\t.read\t\t= dns_resolver_read,\n};\n\nstatic int __init init_dns_resolver(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\t/* create an override credential set with a special thread keyring in\n\t * which DNS requests are cached\n\t *\n\t * this is used to prevent malicious redirections from being installed\n\t * with add_key().\n\t */\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".dns_resolver\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&key_type_dns_resolver);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t/* instruct request_key() to use this special keyring as a cache for\n\t * the results it looks up */\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\tdns_resolver_cache = cred;\n\n\tkdebug(\"DNS resolver keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}\n\nstatic void __exit exit_dns_resolver(void)\n{\n\tkey_revoke(dns_resolver_cache->thread_keyring);\n\tunregister_key_type(&key_type_dns_resolver);\n\tput_cred(dns_resolver_cache);\n}\n\nmodule_init(init_dns_resolver)\nmodule_exit(exit_dns_resolver)\nMODULE_LICENSE(\"GPL\");\n\n", "/* Large capacity key type\n *\n * Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.\n * Copyright (C) 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) \"big_key: \"fmt\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/shmem_fs.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/random.h>\n#include <keys/user-type.h>\n#include <keys/big_key-type.h>\n#include <crypto/aead.h>\n\n/*\n * Layout of key payload words.\n */\nenum {\n\tbig_key_data,\n\tbig_key_path,\n\tbig_key_path_2nd_part,\n\tbig_key_len,\n};\n\n/*\n * Crypto operation with big_key data\n */\nenum big_key_op {\n\tBIG_KEY_ENC,\n\tBIG_KEY_DEC,\n};\n\n/*\n * If the data is under this limit, there's no point creating a shm file to\n * hold it as the permanently resident metadata for the shmem fs will be at\n * least as large as the data.\n */\n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\n/*\n * Key size for big_key data encryption\n */\n#define ENC_KEY_SIZE 32\n\n/*\n * Authentication tag length\n */\n#define ENC_AUTHTAG_SIZE 16\n\n/*\n * big_key defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n\t/* no ->update(); don't add it without changing big_key_crypt() nonce */\n};\n\n/*\n * Crypto names for big_key data authenticated encryption\n */\nstatic const char big_key_alg_name[] = \"gcm(aes)\";\n\n/*\n * Crypto algorithms for big_key data authenticated encryption\n */\nstatic struct crypto_aead *big_key_aead;\n\n/*\n * Since changing the key affects the entire object, we need a mutex.\n */\nstatic DEFINE_MUTEX(big_key_aead_lock);\n\n/*\n * Encrypt/decrypt big_key data\n */\nstatic int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)\n{\n\tint ret;\n\tstruct scatterlist sgio;\n\tstruct aead_request *aead_req;\n\t/* We always use a zero nonce. The reason we can get away with this is\n\t * because we're using a different randomly generated key for every\n\t * different encryption. Notably, too, key_type_big_key doesn't define\n\t * an .update function, so there's no chance we'll wind up reusing the\n\t * key to encrypt updated data. Simply put: one key, one encryption.\n\t */\n\tu8 zero_nonce[crypto_aead_ivsize(big_key_aead)];\n\n\taead_req = aead_request_alloc(big_key_aead, GFP_KERNEL);\n\tif (!aead_req)\n\t\treturn -ENOMEM;\n\n\tmemset(zero_nonce, 0, sizeof(zero_nonce));\n\tsg_init_one(&sgio, data, datalen + (op == BIG_KEY_ENC ? ENC_AUTHTAG_SIZE : 0));\n\taead_request_set_crypt(aead_req, &sgio, &sgio, datalen, zero_nonce);\n\taead_request_set_callback(aead_req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\n\taead_request_set_ad(aead_req, 0);\n\n\tmutex_lock(&big_key_aead_lock);\n\tif (crypto_aead_setkey(big_key_aead, key, ENC_KEY_SIZE)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\tif (op == BIG_KEY_ENC)\n\t\tret = crypto_aead_encrypt(aead_req);\n\telse\n\t\tret = crypto_aead_decrypt(aead_req);\nerror:\n\tmutex_unlock(&big_key_aead_lock);\n\taead_request_free(aead_req);\n\treturn ret;\n}\n\n/*\n * Preparse a big key\n */\nint big_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct path *path = (struct path *)&prep->payload.data[big_key_path];\n\tstruct file *file;\n\tu8 *enckey;\n\tu8 *data = NULL;\n\tssize_t written;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 1024 * 1024 || !prep->data)\n\t\tgoto error;\n\n\t/* Set an arbitrary quota */\n\tprep->quotalen = 16;\n\n\tprep->payload.data[big_key_len] = (void *)(unsigned long)datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\t/* Create a shmem file to store the data in.  This will permit the data\n\t\t * to be swapped out if needed.\n\t\t *\n\t\t * File content is stored encrypted with randomly generated key.\n\t\t */\n\t\tsize_t enclen = datalen + ENC_AUTHTAG_SIZE;\n\t\tloff_t pos = 0;\n\n\t\tdata = kmalloc(enclen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(data, prep->data, datalen);\n\n\t\t/* generate random key */\n\t\tenckey = kmalloc(ENC_KEY_SIZE, GFP_KERNEL);\n\t\tif (!enckey) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tret = get_random_bytes_wait(enckey, ENC_KEY_SIZE);\n\t\tif (unlikely(ret))\n\t\t\tgoto err_enckey;\n\n\t\t/* encrypt aligned data */\n\t\tret = big_key_crypt(BIG_KEY_ENC, data, datalen, enckey);\n\t\tif (ret)\n\t\t\tgoto err_enckey;\n\n\t\t/* save aligned data to file */\n\t\tfile = shmem_kernel_file_setup(\"\", enclen, 0);\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto err_enckey;\n\t\t}\n\n\t\twritten = kernel_write(file, data, enclen, &pos);\n\t\tif (written != enclen) {\n\t\t\tret = written;\n\t\t\tif (written >= 0)\n\t\t\t\tret = -ENOMEM;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\t/* Pin the mount and dentry to the key so that we can open it again\n\t\t * later\n\t\t */\n\t\tprep->payload.data[big_key_data] = enckey;\n\t\t*path = file->f_path;\n\t\tpath_get(path);\n\t\tfput(file);\n\t\tkzfree(data);\n\t} else {\n\t\t/* Just store the data in a buffer */\n\t\tvoid *data = kmalloc(datalen, GFP_KERNEL);\n\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tprep->payload.data[big_key_data] = data;\n\t\tmemcpy(data, prep->data, prep->datalen);\n\t}\n\treturn 0;\n\nerr_fput:\n\tfput(file);\nerr_enckey:\n\tkzfree(enckey);\nerror:\n\tkzfree(data);\n\treturn ret;\n}\n\n/*\n * Clear preparsement.\n */\nvoid big_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tif (prep->datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&prep->payload.data[big_key_path];\n\n\t\tpath_put(path);\n\t}\n\tkzfree(prep->payload.data[big_key_data]);\n}\n\n/*\n * dispose of the links from a revoked keyring\n * - called with the key sem write-locked\n */\nvoid big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\tif (key_is_instantiated(key) &&\n\t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}\n\n/*\n * dispose of the data dangling from the corpse of a big_key key\n */\nvoid big_key_destroy(struct key *key)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\t\tpath_put(path);\n\t\tpath->mnt = NULL;\n\t\tpath->dentry = NULL;\n\t}\n\tkzfree(key->payload.data[big_key_data]);\n\tkey->payload.data[big_key_data] = NULL;\n}\n\n/*\n * describe the big_key key\n */\nvoid big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}\n\n/*\n * read the key data\n * - the key's semaphore is read-locked\n */\nlong big_key_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\tlong ret;\n\n\tif (!buffer || buflen < datalen)\n\t\treturn datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\t\tstruct file *file;\n\t\tu8 *data;\n\t\tu8 *enckey = (u8 *)key->payload.data[big_key_data];\n\t\tsize_t enclen = datalen + ENC_AUTHTAG_SIZE;\n\t\tloff_t pos = 0;\n\n\t\tdata = kmalloc(enclen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tfile = dentry_open(path, O_RDONLY, current_cred());\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* read file to kernel and decrypt */\n\t\tret = kernel_read(file, data, enclen, &pos);\n\t\tif (ret >= 0 && ret != enclen) {\n\t\t\tret = -EIO;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\tret = big_key_crypt(BIG_KEY_DEC, data, enclen, enckey);\n\t\tif (ret)\n\t\t\tgoto err_fput;\n\n\t\tret = datalen;\n\n\t\t/* copy decrypted data to user */\n\t\tif (copy_to_user(buffer, data, datalen) != 0)\n\t\t\tret = -EFAULT;\n\nerr_fput:\n\t\tfput(file);\nerror:\n\t\tkzfree(data);\n\t} else {\n\t\tret = datalen;\n\t\tif (copy_to_user(buffer, key->payload.data[big_key_data],\n\t\t\t\t datalen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Register key type\n */\nstatic int __init big_key_init(void)\n{\n\tint ret;\n\n\t/* init block cipher */\n\tbig_key_aead = crypto_alloc_aead(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_aead)) {\n\t\tret = PTR_ERR(big_key_aead);\n\t\tpr_err(\"Can't alloc crypto: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = crypto_aead_setauthsize(big_key_aead, ENC_AUTHTAG_SIZE);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't set crypto auth tag len: %d\\n\", ret);\n\t\tgoto free_aead;\n\t}\n\n\tret = register_key_type(&key_type_big_key);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't register type: %d\\n\", ret);\n\t\tgoto free_aead;\n\t}\n\n\treturn 0;\n\nfree_aead:\n\tcrypto_free_aead(big_key_aead);\n\treturn ret;\n}\n\nlate_initcall(big_key_init);\n", "/*\n * Copyright (C) 2010 IBM Corporation\n * Copyright (C) 2010 Politecnico di Torino, Italy\n *                    TORSEC group -- http://security.polito.it\n *\n * Authors:\n * Mimi Zohar <zohar@us.ibm.com>\n * Roberto Sassu <roberto.sassu@polito.it>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * See Documentation/security/keys/trusted-encrypted.rst\n */\n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <keys/encrypted-type.h>\n#include <linux/key-type.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/scatterlist.h>\n#include <linux/ctype.h>\n#include <crypto/aes.h>\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <crypto/sha.h>\n#include <crypto/skcipher.h>\n\n#include \"encrypted.h\"\n#include \"ecryptfs_format.h\"\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\nstatic const char hash_alg[] = \"sha256\";\nstatic const char hmac_alg[] = \"hmac(sha256)\";\nstatic const char blkcipher_alg[] = \"cbc(aes)\";\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\nstatic int blksize;\n\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_ECRYPTFS_DESC_LEN 16\n#define HASH_SIZE SHA256_DIGEST_SIZE\n#define MAX_DATA_SIZE 4096\n#define MIN_DATA_SIZE  20\n\nstatic struct crypto_shash *hash_tfm;\n\nenum {\n\tOpt_err = -1, Opt_new, Opt_load, Opt_update\n};\n\nenum {\n\tOpt_error = -1, Opt_default, Opt_ecryptfs\n};\n\nstatic const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_error, NULL}\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};\n\nstatic int aes_get_sizes(void)\n{\n\tstruct crypto_skcipher *tfm;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to alloc_cipher (%ld)\\n\",\n\t\t       PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tivsize = crypto_skcipher_ivsize(tfm);\n\tblksize = crypto_skcipher_blocksize(tfm);\n\tcrypto_free_skcipher(tfm);\n\treturn 0;\n}\n\n/*\n * valid_ecryptfs_desc - verify the description of a new/loaded encrypted key\n *\n * The description of a encrypted key with format 'ecryptfs' must contain\n * exactly 16 hexadecimal characters.\n *\n */\nstatic int valid_ecryptfs_desc(const char *ecryptfs_desc)\n{\n\tint i;\n\n\tif (strlen(ecryptfs_desc) != KEY_ECRYPTFS_DESC_LEN) {\n\t\tpr_err(\"encrypted_key: key description must be %d hexadecimal \"\n\t\t       \"characters long\\n\", KEY_ECRYPTFS_DESC_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < KEY_ECRYPTFS_DESC_LEN; i++) {\n\t\tif (!isxdigit(ecryptfs_desc[i])) {\n\t\t\tpr_err(\"encrypted_key: key description must contain \"\n\t\t\t       \"only hexadecimal characters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * valid_master_desc - verify the 'key-type:desc' of a new/updated master-key\n *\n * key-type:= \"trusted:\" | \"user:\"\n * desc:= master-key description\n *\n * Verify that 'key-type' is valid and that 'desc' exists. On key update,\n * only the master key description is permitted to change, not the key-type.\n * The key-type remains constant.\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/*\n * datablob_parse - parse the keyctl data\n *\n * datablob format:\n * new [<format>] <master-key name> <decrypted data length>\n * load [<format>] <master-key name> <decrypted data length>\n *     <encrypted iv + data>\n * update <new-master-key name>\n *\n * Tokenizes a copy of the keyctl data, returning a pointer to each token,\n * which is null terminated.\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\n/*\n * datablob_format - format as an ascii string, before copying to userspace\n */\nstatic char *datablob_format(struct encrypted_key_payload *epayload,\n\t\t\t     size_t asciiblob_len)\n{\n\tchar *ascii_buf, *bufp;\n\tu8 *iv = epayload->iv;\n\tint len;\n\tint i;\n\n\tascii_buf = kmalloc(asciiblob_len + 1, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\tgoto out;\n\n\tascii_buf[asciiblob_len] = '\\0';\n\n\t/* copy datablob master_desc and datalen strings */\n\tlen = sprintf(ascii_buf, \"%s %s %s \", epayload->format,\n\t\t      epayload->master_desc, epayload->datalen);\n\n\t/* convert the hex encoded iv, encrypted-data and HMAC to ascii */\n\tbufp = &ascii_buf[len];\n\tfor (i = 0; i < (asciiblob_len - len) / 2; i++)\n\t\tbufp = hex_byte_pack(bufp, iv[i]);\nout:\n\treturn ascii_buf;\n}\n\n/*\n * request_user_key - request the user key\n *\n * Use a user provided key to encrypt/decrypt an encrypted-key.\n */\nstatic struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload_locked(ukey);\n\tif (!upayload) {\n\t\t/* key was revoked before we acquired its semaphore */\n\t\tup_read(&ukey->sem);\n\t\tkey_put(ukey);\n\t\tukey = ERR_PTR(-EKEYREVOKED);\n\t\tgoto error;\n\t}\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}\n\nstatic int calc_hash(struct crypto_shash *tfm, u8 *digest,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tint err;\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\terr = crypto_shash_digest(desc, buf, buflen, digest);\n\tshash_desc_zero(desc);\n\treturn err;\n}\n\nstatic int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct crypto_shash *tfm;\n\tint err;\n\n\ttfm = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: can't alloc %s transform: %ld\\n\",\n\t\t       hmac_alg, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = crypto_shash_setkey(tfm, key, keylen);\n\tif (!err)\n\t\terr = calc_hash(tfm, digest, buf, buflen);\n\tcrypto_free_shash(tfm);\n\treturn err;\n}\n\nenum derived_key_type { ENC_KEY, AUTH_KEY };\n\n/* Derive authentication/encryption key from trusted key */\nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(hash_tfm, derived_key, derived_buf, derived_buf_len);\n\tkzfree(derived_buf);\n\treturn ret;\n}\n\nstatic struct skcipher_request *init_skcipher_req(const u8 *key,\n\t\t\t\t\t\t  unsigned int key_len)\n{\n\tstruct skcipher_request *req;\n\tstruct crypto_skcipher *tfm;\n\tint ret;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(tfm));\n\t\treturn ERR_CAST(tfm);\n\t}\n\n\tret = crypto_skcipher_setkey(tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_err(\"encrypted_key: failed to allocate request for %s\\n\",\n\t\t       blkcipher_alg);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\treturn req;\n}\n\nstatic struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}\n\n/* Before returning data to userspace, encrypt decrypted data. */\nstatic int derived_key_encrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[2];\n\tstruct scatterlist sg_out[1];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\n\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_page(&sg_in[1], ZERO_PAGE(0), AES_BLOCK_SIZE, 0);\n\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_encrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to encrypt (%d)\\n\", ret);\n\telse\n\t\tdump_encrypted_data(epayload, encrypted_datalen);\nout:\n\treturn ret;\n}\n\nstatic int datablob_hmac_append(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *master_key, size_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 *digest;\n\tint ret;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdigest = epayload->format + epayload->datablob_len;\n\tret = calc_hmac(digest, derived_key, sizeof derived_key,\n\t\t\tepayload->format, epayload->datablob_len);\n\tif (!ret)\n\t\tdump_hmac(NULL, digest, HASH_SIZE);\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n\n/* verify HMAC before decrypting encrypted key */\nstatic int datablob_hmac_verify(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *format, const u8 *master_key,\n\t\t\t\tsize_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 digest[HASH_SIZE];\n\tint ret;\n\tchar *p;\n\tunsigned short len;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = epayload->datablob_len;\n\tif (!format) {\n\t\tp = epayload->master_desc;\n\t\tlen -= strlen(epayload->format) + 1;\n\t} else\n\t\tp = epayload->format;\n\n\tret = calc_hmac(digest, derived_key, sizeof derived_key, p, len);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_memneq(digest, epayload->format + epayload->datablob_len,\n\t\t\t    sizeof(digest));\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tdump_hmac(\"datablob\",\n\t\t\t  epayload->format + epayload->datablob_len,\n\t\t\t  HASH_SIZE);\n\t\tdump_hmac(\"calc\", digest, HASH_SIZE);\n\t}\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n\nstatic int derived_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[1];\n\tstruct scatterlist sg_out[2];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tu8 *pad;\n\tint ret;\n\n\t/* Throwaway buffer to hold the unused zero padding at the end */\n\tpad = kmalloc(AES_BLOCK_SIZE, GFP_KERNEL);\n\tif (!pad)\n\t\treturn -ENOMEM;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_encrypted_data(epayload, encrypted_datalen);\n\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, epayload->encrypted_data, encrypted_datalen);\n\tsg_set_buf(&sg_out[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_out[1], pad, AES_BLOCK_SIZE);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_decrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\nout:\n\tkfree(pad);\n\treturn ret;\n}\n\n/* Allocate memory for decrypted key and datablob. */\nstatic struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\",\n\t\t\t       ECRYPTFS_MAX_KEY_BYTES);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}\n\nstatic int encrypted_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t\t const char *format, const char *hex_encoded_iv)\n{\n\tstruct key *mkey;\n\tu8 derived_key[HASH_SIZE];\n\tconst u8 *master_key;\n\tu8 *hmac;\n\tconst char *hex_encoded_data;\n\tunsigned int encrypted_datalen;\n\tsize_t master_keylen;\n\tsize_t asciilen;\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\n\tif (strlen(hex_encoded_iv) != asciilen)\n\t\treturn -EINVAL;\n\n\thex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\n\tret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tret = hex2bin(epayload->encrypted_data, hex_encoded_data,\n\t\t      encrypted_datalen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\thmac = epayload->format + epayload->datablob_len;\n\tret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\n\t\t      HASH_SIZE);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: bad hmac (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to decrypt key (%d)\\n\", ret);\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n\nstatic void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}\n\n/*\n * encrypted_init - initialize an encrypted key\n *\n * For a new key, use a random number for both the iv and data\n * itself.  For an old key, decrypt the hex encoded data.\n */\nstatic int encrypted_init(struct encrypted_key_payload *epayload,\n\t\t\t  const char *key_desc, const char *format,\n\t\t\t  const char *master_desc, const char *datalen,\n\t\t\t  const char *hex_encoded_iv)\n{\n\tint ret = 0;\n\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tret = valid_ecryptfs_desc(key_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\n\t\t\t\t       key_desc);\n\t}\n\n\t__ekey_init(epayload, format, master_desc, datalen);\n\tif (!hex_encoded_iv) {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\n\t\tget_random_bytes(epayload->decrypted_data,\n\t\t\t\t epayload->decrypted_datalen);\n\t} else\n\t\tret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\n\treturn ret;\n}\n\n/*\n * encrypted_instantiate - instantiate an encrypted key\n *\n * Decrypt an existing encrypted datablob or create a new encrypted key\n * based on a kernel random number.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int encrypted_instantiate(struct key *key,\n\t\t\t\t struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tchar *datablob = NULL;\n\tconst char *format = NULL;\n\tchar *master_desc = NULL;\n\tchar *decrypted_datalen = NULL;\n\tchar *hex_encoded_iv = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tdatablob[datalen] = 0;\n\tmemcpy(datablob, prep->data, datalen);\n\tret = datablob_parse(datablob, &format, &master_desc,\n\t\t\t     &decrypted_datalen, &hex_encoded_iv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tepayload = encrypted_key_alloc(key, format, master_desc,\n\t\t\t\t       decrypted_datalen);\n\tif (IS_ERR(epayload)) {\n\t\tret = PTR_ERR(epayload);\n\t\tgoto out;\n\t}\n\tret = encrypted_init(epayload, key->description, format, master_desc,\n\t\t\t     decrypted_datalen, hex_encoded_iv);\n\tif (ret < 0) {\n\t\tkzfree(epayload);\n\t\tgoto out;\n\t}\n\n\trcu_assign_keypointer(key, epayload);\nout:\n\tkzfree(datablob);\n\treturn ret;\n}\n\nstatic void encrypted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct encrypted_key_payload *epayload;\n\n\tepayload = container_of(rcu, struct encrypted_key_payload, rcu);\n\tkzfree(epayload);\n}\n\n/*\n * encrypted_update - update the master key description\n *\n * Change the master key description for an existing encrypted key.\n * The next read will return an encrypted datablob using the new\n * master key description.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkzfree(buf);\n\treturn ret;\n}\n\n/*\n * encrypted_read - format and copy the encrypted data to userspace\n *\n * The resulting datablob format is:\n * <master-key name> <decrypted data length> <encrypted iv> <encrypted data>\n *\n * On success, return to userspace the encrypted key datablob size.\n */\nstatic long encrypted_read(const struct key *key, char __user *buffer,\n\t\t\t   size_t buflen)\n{\n\tstruct encrypted_key_payload *epayload;\n\tstruct key *mkey;\n\tconst u8 *master_key;\n\tsize_t master_keylen;\n\tchar derived_key[HASH_SIZE];\n\tchar *ascii_buf;\n\tsize_t asciiblob_len;\n\tint ret;\n\n\tepayload = dereference_key_locked(key);\n\n\t/* returns the hex encoded iv, encrypted-data, and hmac as ascii */\n\tasciiblob_len = epayload->datablob_len + ivsize + 1\n\t    + roundup(epayload->decrypted_datalen, blksize)\n\t    + (HASH_SIZE * 2);\n\n\tif (!buffer || buflen < asciiblob_len)\n\t\treturn asciiblob_len;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = datablob_hmac_append(epayload, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tascii_buf = datablob_format(epayload, asciiblob_len);\n\tif (!ascii_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\n\tif (copy_to_user(buffer, ascii_buf, asciiblob_len) != 0)\n\t\tret = -EFAULT;\n\tkzfree(ascii_buf);\n\n\treturn asciiblob_len;\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n\n/*\n * encrypted_destroy - clear and free the key's payload\n */\nstatic void encrypted_destroy(struct key *key)\n{\n\tkzfree(key->payload.data[0]);\n}\n\nstruct key_type key_type_encrypted = {\n\t.name = \"encrypted\",\n\t.instantiate = encrypted_instantiate,\n\t.update = encrypted_update,\n\t.destroy = encrypted_destroy,\n\t.describe = user_describe,\n\t.read = encrypted_read,\n};\nEXPORT_SYMBOL_GPL(key_type_encrypted);\n\nstatic int __init init_encrypted(void)\n{\n\tint ret;\n\n\thash_tfm = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hash_tfm)) {\n\t\tpr_err(\"encrypted_key: can't allocate %s transform: %ld\\n\",\n\t\t       hash_alg, PTR_ERR(hash_tfm));\n\t\treturn PTR_ERR(hash_tfm);\n\t}\n\n\tret = aes_get_sizes();\n\tif (ret < 0)\n\t\tgoto out;\n\tret = register_key_type(&key_type_encrypted);\n\tif (ret < 0)\n\t\tgoto out;\n\treturn 0;\nout:\n\tcrypto_free_shash(hash_tfm);\n\treturn ret;\n\n}\n\nstatic void __exit cleanup_encrypted(void)\n{\n\tcrypto_free_shash(hash_tfm);\n\tunregister_key_type(&key_type_encrypted);\n}\n\nlate_initcall(init_encrypted);\nmodule_exit(cleanup_encrypted);\n\nMODULE_LICENSE(\"GPL\");\n", "/* Key garbage collector\n *\n * Copyright (C) 2009-2011 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <keys/keyring-type.h>\n#include \"internal.h\"\n\n/*\n * Delay between key revocation/expiry in seconds\n */\nunsigned key_gc_delay = 5 * 60;\n\n/*\n * Reaper for unused keys.\n */\nstatic void key_garbage_collector(struct work_struct *work);\nDECLARE_WORK(key_gc_work, key_garbage_collector);\n\n/*\n * Reaper for links from keyrings to dead keys.\n */\nstatic void key_gc_timer_func(unsigned long);\nstatic DEFINE_TIMER(key_gc_timer, key_gc_timer_func, 0, 0);\n\nstatic time_t key_gc_next_run = LONG_MAX;\nstatic struct key_type *key_gc_dead_keytype;\n\nstatic unsigned long key_gc_flags;\n#define KEY_GC_KEY_EXPIRED\t0\t/* A key expired and needs unlinking */\n#define KEY_GC_REAP_KEYTYPE\t1\t/* A keytype is being unregistered */\n#define KEY_GC_REAPING_KEYTYPE\t2\t/* Cleared when keytype reaped */\n\n\n/*\n * Any key whose type gets unregistered will be re-typed to this if it can't be\n * immediately unlinked.\n */\nstruct key_type key_type_dead = {\n\t.name = \".dead\",\n};\n\n/*\n * Schedule a garbage collection run.\n * - time precision isn't particularly important\n */\nvoid key_schedule_gc(time_t gc_at)\n{\n\tunsigned long expires;\n\ttime_t now = current_kernel_time().tv_sec;\n\n\tkenter(\"%ld\", gc_at - now);\n\n\tif (gc_at <= now || test_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags)) {\n\t\tkdebug(\"IMMEDIATE\");\n\t\tschedule_work(&key_gc_work);\n\t} else if (gc_at < key_gc_next_run) {\n\t\tkdebug(\"DEFERRED\");\n\t\tkey_gc_next_run = gc_at;\n\t\texpires = jiffies + (gc_at - now) * HZ;\n\t\tmod_timer(&key_gc_timer, expires);\n\t}\n}\n\n/*\n * Schedule a dead links collection run.\n */\nvoid key_schedule_gc_links(void)\n{\n\tset_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags);\n\tschedule_work(&key_gc_work);\n}\n\n/*\n * Some key's cleanup time was met after it expired, so we need to get the\n * reaper to go through a cycle finding expired keys.\n */\nstatic void key_gc_timer_func(unsigned long data)\n{\n\tkenter(\"\");\n\tkey_gc_next_run = LONG_MAX;\n\tkey_schedule_gc_links();\n}\n\n/*\n * Reap keys of dead type.\n *\n * We use three flags to make sure we see three complete cycles of the garbage\n * collector: the first to mark keys of that type as being dead, the second to\n * collect dead links and the third to clean up the dead keys.  We have to be\n * careful as there may already be a cycle in progress.\n *\n * The caller must be holding key_types_sem.\n */\nvoid key_gc_keytype(struct key_type *ktype)\n{\n\tkenter(\"%s\", ktype->name);\n\n\tkey_gc_dead_keytype = ktype;\n\tset_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\tsmp_mb();\n\tset_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags);\n\n\tkdebug(\"schedule\");\n\tschedule_work(&key_gc_work);\n\n\tkdebug(\"sleep\");\n\twait_on_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\tkey_gc_dead_keytype = NULL;\n\tkleave(\"\");\n}\n\n/*\n * Garbage collect a list of unreferenced, detached keys\n */\nstatic noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t/* Throw away the key data if the key is instantiated */\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}\n\n/*\n * Garbage collector for unused keys.\n *\n * This is done in process context so that we don't have to disable interrupts\n * all over the place.  key_put() schedules this rather than trying to do the\n * cleanup itself, which means key_put() doesn't have to sleep.\n */\nstatic void key_garbage_collector(struct work_struct *work)\n{\n\tstatic LIST_HEAD(graveyard);\n\tstatic u8 gc_state;\t\t/* Internal persistent state */\n#define KEY_GC_REAP_AGAIN\t0x01\t/* - Need another cycle */\n#define KEY_GC_REAPING_LINKS\t0x02\t/* - We need to reap links */\n#define KEY_GC_SET_TIMER\t0x04\t/* - We need to restart the timer */\n#define KEY_GC_REAPING_DEAD_1\t0x10\t/* - We need to mark dead keys */\n#define KEY_GC_REAPING_DEAD_2\t0x20\t/* - We need to reap dead key links */\n#define KEY_GC_REAPING_DEAD_3\t0x40\t/* - We need to reap dead keys */\n#define KEY_GC_FOUND_DEAD_KEY\t0x80\t/* - We found at least one dead key */\n\n\tstruct rb_node *cursor;\n\tstruct key *key;\n\ttime_t new_timer, limit;\n\n\tkenter(\"[%lx,%x]\", key_gc_flags, gc_state);\n\n\tlimit = current_kernel_time().tv_sec;\n\tif (limit > key_gc_delay)\n\t\tlimit -= key_gc_delay;\n\telse\n\t\tlimit = key_gc_delay;\n\n\t/* Work out what we're going to be doing in this pass */\n\tgc_state &= KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2;\n\tgc_state <<= 1;\n\tif (test_and_clear_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_LINKS | KEY_GC_SET_TIMER;\n\n\tif (test_and_clear_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_DEAD_1;\n\tkdebug(\"new pass %x\", gc_state);\n\n\tnew_timer = LONG_MAX;\n\n\t/* As only this function is permitted to remove things from the key\n\t * serial tree, if cursor is non-NULL then it will always point to a\n\t * valid node in the tree - even if lock got dropped.\n\t */\n\tspin_lock(&key_serial_lock);\n\tcursor = rb_first(&key_serial_tree);\n\ncontinue_scanning:\n\twhile (cursor) {\n\t\tkey = rb_entry(cursor, struct key, serial_node);\n\t\tcursor = rb_next(cursor);\n\n\t\tif (refcount_read(&key->usage) == 0)\n\t\t\tgoto found_unreferenced_key;\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_1)) {\n\t\t\tif (key->type == key_gc_dead_keytype) {\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\t\t\t\tset_bit(KEY_FLAG_DEAD, &key->flags);\n\t\t\t\tkey->perm = 0;\n\t\t\t\tgoto skip_dead_key;\n\t\t\t} else if (key->type == &key_type_keyring &&\n\t\t\t\t   key->restrict_link) {\n\t\t\t\tgoto found_restricted_keyring;\n\t\t\t}\n\t\t}\n\n\t\tif (gc_state & KEY_GC_SET_TIMER) {\n\t\t\tif (key->expiry > limit && key->expiry < new_timer) {\n\t\t\t\tkdebug(\"will expire %x in %ld\",\n\t\t\t\t       key_serial(key), key->expiry - limit);\n\t\t\t\tnew_timer = key->expiry;\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\n\t\tif ((gc_state & KEY_GC_REAPING_LINKS) ||\n\t\t    unlikely(gc_state & KEY_GC_REAPING_DEAD_2)) {\n\t\t\tif (key->type == &key_type_keyring)\n\t\t\t\tgoto found_keyring;\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgoto destroy_dead_key;\n\n\tskip_dead_key:\n\t\tif (spin_is_contended(&key_serial_lock) || need_resched())\n\t\t\tgoto contended;\n\t}\n\ncontended:\n\tspin_unlock(&key_serial_lock);\n\nmaybe_resched:\n\tif (cursor) {\n\t\tcond_resched();\n\t\tspin_lock(&key_serial_lock);\n\t\tgoto continue_scanning;\n\t}\n\n\t/* We've completed the pass.  Set the timer if we need to and queue a\n\t * new cycle if necessary.  We keep executing cycles until we find one\n\t * where we didn't reap any keys.\n\t */\n\tkdebug(\"pass complete\");\n\n\tif (gc_state & KEY_GC_SET_TIMER && new_timer != (time_t)LONG_MAX) {\n\t\tnew_timer += key_gc_delay;\n\t\tkey_schedule_gc(new_timer);\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2) ||\n\t    !list_empty(&graveyard)) {\n\t\t/* Make sure that all pending keyring payload destructions are\n\t\t * fulfilled and that people aren't now looking at dead or\n\t\t * dying keys that they don't have a reference upon or a link\n\t\t * to.\n\t\t */\n\t\tkdebug(\"gc sync\");\n\t\tsynchronize_rcu();\n\t}\n\n\tif (!list_empty(&graveyard)) {\n\t\tkdebug(\"gc keys\");\n\t\tkey_gc_unused_keys(&graveyard);\n\t}\n\n\tif (unlikely(gc_state & (KEY_GC_REAPING_DEAD_1 |\n\t\t\t\t KEY_GC_REAPING_DEAD_2))) {\n\t\tif (!(gc_state & KEY_GC_FOUND_DEAD_KEY)) {\n\t\t\t/* No remaining dead keys: short circuit the remaining\n\t\t\t * keytype reap cycles.\n\t\t\t */\n\t\t\tkdebug(\"dead short\");\n\t\t\tgc_state &= ~(KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2);\n\t\t\tgc_state |= KEY_GC_REAPING_DEAD_3;\n\t\t} else {\n\t\t\tgc_state |= KEY_GC_REAP_AGAIN;\n\t\t}\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3)) {\n\t\tkdebug(\"dead wake\");\n\t\tsmp_mb();\n\t\tclear_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\t\twake_up_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE);\n\t}\n\n\tif (gc_state & KEY_GC_REAP_AGAIN)\n\t\tschedule_work(&key_gc_work);\n\tkleave(\" [end %x]\", gc_state);\n\treturn;\n\n\t/* We found an unreferenced key - once we've removed it from the tree,\n\t * we can safely drop the lock.\n\t */\nfound_unreferenced_key:\n\tkdebug(\"unrefd key %d\", key->serial);\n\trb_erase(&key->serial_node, &key_serial_tree);\n\tspin_unlock(&key_serial_lock);\n\n\tlist_add_tail(&key->graveyard_link, &graveyard);\n\tgc_state |= KEY_GC_REAP_AGAIN;\n\tgoto maybe_resched;\n\n\t/* We found a restricted keyring and need to update the restriction if\n\t * it is associated with the dead key type.\n\t */\nfound_restricted_keyring:\n\tspin_unlock(&key_serial_lock);\n\tkeyring_restriction_gc(key, key_gc_dead_keytype);\n\tgoto maybe_resched;\n\n\t/* We found a keyring and we need to check the payload for links to\n\t * dead or expired keys.  We don't flag another reap immediately as we\n\t * have to wait for the old payload to be destroyed by RCU before we\n\t * can reap the keys to which it refers.\n\t */\nfound_keyring:\n\tspin_unlock(&key_serial_lock);\n\tkeyring_gc(key, limit);\n\tgoto maybe_resched;\n\n\t/* We found a dead key that is still referenced.  Reset its type and\n\t * destroy its payload with its semaphore held.\n\t */\ndestroy_dead_key:\n\tspin_unlock(&key_serial_lock);\n\tkdebug(\"destroy key %d\", key->serial);\n\tdown_write(&key->sem);\n\tkey->type = &key_type_dead;\n\tif (key_gc_dead_keytype->destroy)\n\t\tkey_gc_dead_keytype->destroy(key);\n\tmemset(&key->payload, KEY_DESTROY, sizeof(key->payload));\n\tup_write(&key->sem);\n\tgoto maybe_resched;\n}\n", "/* Basic authentication token and access key management\n *\n * Copyright (C) 2004-2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/poison.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include \"internal.h\"\n\nstruct kmem_cache *key_jar;\nstruct rb_root\t\tkey_serial_tree; /* tree of keys indexed by serial */\nDEFINE_SPINLOCK(key_serial_lock);\n\nstruct rb_root\tkey_user_tree; /* tree of quota records indexed by UID */\nDEFINE_SPINLOCK(key_user_lock);\n\nunsigned int key_quota_root_maxkeys = 1000000;\t/* root's key count quota */\nunsigned int key_quota_root_maxbytes = 25000000; /* root's key space quota */\nunsigned int key_quota_maxkeys = 200;\t\t/* general key count quota */\nunsigned int key_quota_maxbytes = 20000;\t/* general key space quota */\n\nstatic LIST_HEAD(key_types_list);\nstatic DECLARE_RWSEM(key_types_sem);\n\n/* We serialise key instantiation and link */\nDEFINE_MUTEX(key_construction_mutex);\n\n#ifdef KEY_DEBUGGING\nvoid __key_check(const struct key *key)\n{\n\tprintk(\"__key_check: key %p {%08x} should be {%08x}\\n\",\n\t       key, key->magic, KEY_DEBUG_MAGIC);\n\tBUG();\n}\n#endif\n\n/*\n * Get the key quota record for a user, allocating a new record if one doesn't\n * already exist.\n */\nstruct key_user *key_user_lookup(kuid_t uid)\n{\n\tstruct key_user *candidate = NULL, *user;\n\tstruct rb_node *parent, **p;\n\ntry_again:\n\tparent = NULL;\n\tp = &key_user_tree.rb_node;\n\tspin_lock(&key_user_lock);\n\n\t/* search the tree for a user record with a matching UID */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tuser = rb_entry(parent, struct key_user, node);\n\n\t\tif (uid_lt(uid, user->uid))\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (uid_gt(uid, user->uid))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\n\t/* if we get here, we failed to find a match in the tree */\n\tif (!candidate) {\n\t\t/* allocate a candidate user record if we don't already have\n\t\t * one */\n\t\tspin_unlock(&key_user_lock);\n\n\t\tuser = NULL;\n\t\tcandidate = kmalloc(sizeof(struct key_user), GFP_KERNEL);\n\t\tif (unlikely(!candidate))\n\t\t\tgoto out;\n\n\t\t/* the allocation may have scheduled, so we need to repeat the\n\t\t * search lest someone else added the record whilst we were\n\t\t * asleep */\n\t\tgoto try_again;\n\t}\n\n\t/* if we get here, then the user record still hadn't appeared on the\n\t * second pass - so we use the candidate record */\n\trefcount_set(&candidate->usage, 1);\n\tatomic_set(&candidate->nkeys, 0);\n\tatomic_set(&candidate->nikeys, 0);\n\tcandidate->uid = uid;\n\tcandidate->qnkeys = 0;\n\tcandidate->qnbytes = 0;\n\tspin_lock_init(&candidate->lock);\n\tmutex_init(&candidate->cons_lock);\n\n\trb_link_node(&candidate->node, parent, p);\n\trb_insert_color(&candidate->node, &key_user_tree);\n\tspin_unlock(&key_user_lock);\n\tuser = candidate;\n\tgoto out;\n\n\t/* okay - we found a user record for this UID */\nfound:\n\trefcount_inc(&user->usage);\n\tspin_unlock(&key_user_lock);\n\tkfree(candidate);\nout:\n\treturn user;\n}\n\n/*\n * Dispose of a user structure\n */\nvoid key_user_put(struct key_user *user)\n{\n\tif (refcount_dec_and_lock(&user->usage, &key_user_lock)) {\n\t\trb_erase(&user->node, &key_user_tree);\n\t\tspin_unlock(&key_user_lock);\n\n\t\tkfree(user);\n\t}\n}\n\n/*\n * Allocate a serial number for a key.  These are assigned randomly to avoid\n * security issues through covert channel problems.\n */\nstatic inline void key_alloc_serial(struct key *key)\n{\n\tstruct rb_node *parent, **p;\n\tstruct key *xkey;\n\n\t/* propose a random serial number and look for a hole for it in the\n\t * serial number tree */\n\tdo {\n\t\tget_random_bytes(&key->serial, sizeof(key->serial));\n\n\t\tkey->serial >>= 1; /* negative numbers are not permitted */\n\t} while (key->serial < 3);\n\n\tspin_lock(&key_serial_lock);\n\nattempt_insertion:\n\tparent = NULL;\n\tp = &key_serial_tree.rb_node;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\n\t\tif (key->serial < xkey->serial)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (key->serial > xkey->serial)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto serial_exists;\n\t}\n\n\t/* we've found a suitable hole - arrange for this key to occupy it */\n\trb_link_node(&key->serial_node, parent, p);\n\trb_insert_color(&key->serial_node, &key_serial_tree);\n\n\tspin_unlock(&key_serial_lock);\n\treturn;\n\n\t/* we found a key with the proposed serial number - walk the tree from\n\t * that point looking for the next unused serial number */\nserial_exists:\n\tfor (;;) {\n\t\tkey->serial++;\n\t\tif (key->serial < 3) {\n\t\t\tkey->serial = 3;\n\t\t\tgoto attempt_insertion;\n\t\t}\n\n\t\tparent = rb_next(parent);\n\t\tif (!parent)\n\t\t\tgoto attempt_insertion;\n\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\t\tif (key->serial < xkey->serial)\n\t\t\tgoto attempt_insertion;\n\t}\n}\n\n/**\n * key_alloc - Allocate a key of the specified type.\n * @type: The type of key to allocate.\n * @desc: The key description to allow the key to be searched out.\n * @uid: The owner of the new key.\n * @gid: The group ID for the new key's group permissions.\n * @cred: The credentials specifying UID namespace.\n * @perm: The permissions mask of the new key.\n * @flags: Flags specifying quota properties.\n * @restrict_link: Optional link restriction for new keyrings.\n *\n * Allocate a key of the specified type with the attributes given.  The key is\n * returned in an uninstantiated state and the caller needs to instantiate the\n * key before returning.\n *\n * The restrict_link structure (if not NULL) will be freed when the\n * keyring is destroyed, so it must be dynamically allocated.\n *\n * The user's key count quota is updated to reflect the creation of the key and\n * the user's key data quota has the default for the key type reserved.  The\n * instantiation function should amend this as necessary.  If insufficient\n * quota is available, -EDQUOT will be returned.\n *\n * The LSM security modules can prevent a key being created, in which case\n * -EACCES will be returned.\n *\n * Returns a pointer to the new key if successful and an error code otherwise.\n *\n * Note that the caller needs to ensure the key type isn't uninstantiated.\n * Internally this can be done by locking key_types_sem.  Externally, this can\n * be done by either never unregistering the key type, or making sure\n * key_alloc() calls don't race with module unloading.\n */\nstruct key *key_alloc(struct key_type *type, const char *desc,\n\t\t      kuid_t uid, kgid_t gid, const struct cred *cred,\n\t\t      key_perm_t perm, unsigned long flags,\n\t\t      struct key_restriction *restrict_link)\n{\n\tstruct key_user *user = NULL;\n\tstruct key *key;\n\tsize_t desclen, quotalen;\n\tint ret;\n\n\tkey = ERR_PTR(-EINVAL);\n\tif (!desc || !*desc)\n\t\tgoto error;\n\n\tif (type->vet_description) {\n\t\tret = type->vet_description(desc);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdesclen = strlen(desc);\n\tquotalen = desclen + 1 + type->def_datalen;\n\n\t/* get hold of the key tracking for this user */\n\tuser = key_user_lookup(uid);\n\tif (!user)\n\t\tgoto no_memory_1;\n\n\t/* check that the user's quota permits allocation of another key and\n\t * its description */\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&user->lock);\n\t\tif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\n\t\t\tif (user->qnkeys + 1 >= maxkeys ||\n\t\t\t    user->qnbytes + quotalen >= maxbytes ||\n\t\t\t    user->qnbytes + quotalen < user->qnbytes)\n\t\t\t\tgoto no_quota;\n\t\t}\n\n\t\tuser->qnkeys++;\n\t\tuser->qnbytes += quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\n\t/* allocate and initialise the key and its description */\n\tkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\n\tif (!key)\n\t\tgoto no_memory_2;\n\n\tkey->index_key.desc_len = desclen;\n\tkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\n\tif (!key->index_key.description)\n\t\tgoto no_memory_3;\n\n\trefcount_set(&key->usage, 1);\n\tinit_rwsem(&key->sem);\n\tlockdep_set_class(&key->sem, &type->lock_class);\n\tkey->index_key.type = type;\n\tkey->user = user;\n\tkey->quotalen = quotalen;\n\tkey->datalen = type->def_datalen;\n\tkey->uid = uid;\n\tkey->gid = gid;\n\tkey->perm = perm;\n\tkey->restrict_link = restrict_link;\n\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\n\t\tkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\n\tif (flags & KEY_ALLOC_BUILT_IN)\n\t\tkey->flags |= 1 << KEY_FLAG_BUILTIN;\n\tif (flags & KEY_ALLOC_UID_KEYRING)\n\t\tkey->flags |= 1 << KEY_FLAG_UID_KEYRING;\n\n#ifdef KEY_DEBUGGING\n\tkey->magic = KEY_DEBUG_MAGIC;\n#endif\n\n\t/* let the security module know about the key */\n\tret = security_key_alloc(key, cred, flags);\n\tif (ret < 0)\n\t\tgoto security_error;\n\n\t/* publish the key by giving it a serial number */\n\tatomic_inc(&user->nkeys);\n\tkey_alloc_serial(key);\n\nerror:\n\treturn key;\n\nsecurity_error:\n\tkfree(key->description);\n\tkmem_cache_free(key_jar, key);\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\n\tkey = ERR_PTR(ret);\n\tgoto error;\n\nno_memory_3:\n\tkmem_cache_free(key_jar, key);\nno_memory_2:\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\nno_memory_1:\n\tkey = ERR_PTR(-ENOMEM);\n\tgoto error;\n\nno_quota:\n\tspin_unlock(&user->lock);\n\tkey_user_put(user);\n\tkey = ERR_PTR(-EDQUOT);\n\tgoto error;\n}\nEXPORT_SYMBOL(key_alloc);\n\n/**\n * key_payload_reserve - Adjust data quota reservation for the key's payload\n * @key: The key to make the reservation for.\n * @datalen: The amount of data payload the caller now wants.\n *\n * Adjust the amount of the owning user's key data quota that a key reserves.\n * If the amount is increased, then -EDQUOT may be returned if there isn't\n * enough free quota available.\n *\n * If successful, 0 is returned.\n */\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(key_payload_reserve);\n\n/*\n * Instantiate a key and link it into the target keyring atomically.  Must be\n * called with the target keyring's semaphore writelocked.  The target key's\n * semaphore need not be locked as instantiation is serialised by\n * key_construction_mutex.\n */\nstatic int __key_instantiate_and_link(struct key *key,\n\t\t\t\t      struct key_preparsed_payload *prep,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *authkey,\n\t\t\t\t      struct assoc_array_edit **_edit)\n{\n\tint ret, awaken;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* instantiate the key */\n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t/* mark the key as being instantiated */\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t/* and link it into the destination keyring */\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\n\t\t\t\t__key_link(key, _edit);\n\t\t\t}\n\n\t\t\t/* disable the authorisation key */\n\t\t\tif (authkey)\n\t\t\t\tkey_revoke(authkey);\n\n\t\t\tif (prep->expiry != TIME_T_MAX) {\n\t\t\t\tkey->expiry = prep->expiry;\n\t\t\t\tkey_schedule_gc(prep->expiry + key_gc_delay);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret;\n}\n\n/**\n * key_instantiate_and_link - Instantiate a key and link it into the keyring.\n * @key: The key to instantiate.\n * @data: The data to use to instantiate the keyring.\n * @datalen: The length of @data.\n * @keyring: Keyring to create a link in on success (or NULL).\n * @authkey: The authorisation token permitting instantiation.\n *\n * Instantiate a key that's in the uninstantiated state using the provided data\n * and, if successful, link it in to the destination keyring if one is\n * supplied.\n *\n * If successful, 0 is returned, the authorisation token is revoked and anyone\n * waiting for the key is woken up.  If the key was already instantiated,\n * -EBUSY will be returned.\n */\nint key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tif (keyring->restrict_link && keyring->restrict_link->check) {\n\t\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\t\tret = keyres->check(keyring, key->type, &prep.payload,\n\t\t\t\t\t    keyres->key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\nerror_link_end:\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(key_instantiate_and_link);\n\n/**\n * key_reject_and_link - Negatively instantiate a key and link it into the keyring.\n * @key: The key to instantiate.\n * @timeout: The timeout on the negative key.\n * @error: The error to return when the key is hit.\n * @keyring: Keyring to create a link in on success (or NULL).\n * @authkey: The authorisation token permitting instantiation.\n *\n * Negatively instantiate a key that's in the uninstantiated state and, if\n * successful, set its timeout and stored error and link it in to the\n * destination keyring if one is supplied.  The key and any links to the key\n * will be automatically garbage collected after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return the stored error code (typically ENOKEY) until the negative\n * key expires.\n *\n * If successful, 0 is returned, the authorisation token is revoked and anyone\n * waiting for the key is woken up.  If the key was already instantiated,\n * -EBUSY will be returned.\n */\nint key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* mark the key as being negatively instantiated */\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\n\t\tret = 0;\n\n\t\t/* and link it into the destination keyring */\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\n\t\t/* disable the authorisation key */\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\tif (keyring && link_ret == 0)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret == 0 ? link_ret : ret;\n}\nEXPORT_SYMBOL(key_reject_and_link);\n\n/**\n * key_put - Discard a reference to a key.\n * @key: The key to discard a reference from.\n *\n * Discard a reference to a key, and when all the references are gone, we\n * schedule the cleanup task to come and pull it out of the tree in process\n * context at some later time.\n */\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}\nEXPORT_SYMBOL(key_put);\n\n/*\n * Find a key by its serial number.\n */\nstruct key *key_lookup(key_serial_t id)\n{\n\tstruct rb_node *n;\n\tstruct key *key;\n\n\tspin_lock(&key_serial_lock);\n\n\t/* search the tree for the specified key */\n\tn = key_serial_tree.rb_node;\n\twhile (n) {\n\t\tkey = rb_entry(n, struct key, serial_node);\n\n\t\tif (id < key->serial)\n\t\t\tn = n->rb_left;\n\t\telse if (id > key->serial)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\nnot_found:\n\tkey = ERR_PTR(-ENOKEY);\n\tgoto error;\n\nfound:\n\t/* A key is allowed to be looked up only if someone still owns a\n\t * reference to it - otherwise it's awaiting the gc.\n\t */\n\tif (!refcount_inc_not_zero(&key->usage))\n\t\tgoto not_found;\n\nerror:\n\tspin_unlock(&key_serial_lock);\n\treturn key;\n}\n\n/*\n * Find and lock the specified key type against removal.\n *\n * We return with the sem read-locked if successful.  If the type wasn't\n * available -ENOKEY is returned instead.\n */\nstruct key_type *key_type_lookup(const char *type)\n{\n\tstruct key_type *ktype;\n\n\tdown_read(&key_types_sem);\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tlist_for_each_entry(ktype, &key_types_list, link) {\n\t\tif (strcmp(ktype->name, type) == 0)\n\t\t\tgoto found_kernel_type;\n\t}\n\n\tup_read(&key_types_sem);\n\tktype = ERR_PTR(-ENOKEY);\n\nfound_kernel_type:\n\treturn ktype;\n}\n\nvoid key_set_timeout(struct key *key, unsigned timeout)\n{\n\tstruct timespec now;\n\ttime_t expiry = 0;\n\n\t/* make the changes with the locks held to prevent races */\n\tdown_write(&key->sem);\n\n\tif (timeout > 0) {\n\t\tnow = current_kernel_time();\n\t\texpiry = now.tv_sec + timeout;\n\t}\n\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL_GPL(key_set_timeout);\n\n/*\n * Unlock a key type locked by key_type_lookup().\n */\nvoid key_type_put(struct key_type *ktype)\n{\n\tup_read(&key_types_sem);\n}\n\n/*\n * Attempt to update an existing key.\n *\n * The key is given to us with an incremented refcount that we need to discard\n * if we get an error.\n */\nstatic inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\t/* need write permission on the key to update it */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\t/* updating a negative key instantiates it */\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\n\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}\n\n/**\n * key_create_or_update - Update or create and instantiate a key.\n * @keyring_ref: A pointer to the destination keyring with possession flag.\n * @type: The type of key.\n * @description: The searchable description for the key.\n * @payload: The data to use to instantiate or update the key.\n * @plen: The length of @payload.\n * @perm: The permissions mask for a new key.\n * @flags: The quota flags for a new key.\n *\n * Search the destination keyring for a key of the same description and if one\n * is found, update it, otherwise create and instantiate a new one and create a\n * link to it from that keyring.\n *\n * If perm is KEY_PERM_UNDEF then an appropriate key permissions mask will be\n * concocted.\n *\n * Returns a pointer to the new key if successful, -ENODEV if the key type\n * wasn't available, -ENOTDIR if the keyring wasn't a keyring, -EACCES if the\n * caller isn't permitted to modify the keyring or the LSM did not permit\n * creation of the key.\n *\n * On success, the possession flag from the keyring ref will be tacked on to\n * the key ref before it is returned.\n */\nkey_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\tstruct key_restriction *restrict_link = NULL;\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n\t}\n\n\tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->instantiate ||\n\t    (!index_key.description && !index_key.type->preparse))\n\t\tgoto error_put_type;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tkey_ref = ERR_PTR(-EPERM);\n\tif (!(flags & KEY_ALLOC_BYPASS_RESTRICTION))\n\t\trestrict_link = keyring->restrict_link;\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\tif (restrict_link && restrict_link->check) {\n\t\tret = restrict_link->check(keyring, index_key.type,\n\t\t\t\t\t   &prep.payload, restrict_link->key);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\t/* if we're going to allocate a new key, we're going to have\n\t * to modify the keyring */\n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t/* if it's possible to update this type of key, search for an existing\n\t * key of the same type and description in the destination keyring and\n\t * update that instead if possible\n\t */\n\tif (index_key.type->update) {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref)\n\t\t\tgoto found_matching_key;\n\t}\n\n\t/* if the client doesn't provide, decide on the permissions we want */\n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t/* allocate a new key */\n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags, NULL);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t/* instantiate it and link it into the target keyring */\n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t/* we found a matching key, so we're going to try to update it\n\t * - we can drop the locks first as we have the key pinned\n\t */\n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey_ref = __key_update(key_ref, &prep);\n\tgoto error_free_prep;\n}\nEXPORT_SYMBOL(key_create_or_update);\n\n/**\n * key_update - Update a key's contents.\n * @key_ref: The pointer (plus possession flag) to the key.\n * @payload: The data to be used to update the key.\n * @plen: The length of @payload.\n *\n * Attempt to update the contents of a key with the given payload data.  The\n * caller must be granted Write permission on the key.  Negative keys can be\n * instantiated by this method.\n *\n * Returns 0 on success, -EACCES if not permitted and -EOPNOTSUPP if the key\n * type does not support updating.  The key type may return other errors.\n */\nint key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tkey_check(key);\n\n\t/* the key must be writable */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attempt to update it if supported */\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\t/* updating a negative key instantiates it */\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_update);\n\n/**\n * key_revoke - Revoke a key.\n * @key: The key to be revoked.\n *\n * Mark a key as being revoked and ask the type to free up its resources.  The\n * revocation timeout is set and the key and all its links will be\n * automatically garbage collected after key_gc_delay amount of time if they\n * are not manually dealt with first.\n */\nvoid key_revoke(struct key *key)\n{\n\tstruct timespec now;\n\ttime_t time;\n\n\tkey_check(key);\n\n\t/* make sure no one's trying to change or use the key when we mark it\n\t * - we tell lockdep that we might nest because we might be revoking an\n\t *   authorisation key whilst holding the sem on a key we've just\n\t *   instantiated\n\t */\n\tdown_write_nested(&key->sem, 1);\n\tif (!test_and_set_bit(KEY_FLAG_REVOKED, &key->flags) &&\n\t    key->type->revoke)\n\t\tkey->type->revoke(key);\n\n\t/* set the death time to no more than the expiry time */\n\tnow = current_kernel_time();\n\ttime = now.tv_sec;\n\tif (key->revoked_at == 0 || key->revoked_at > time) {\n\t\tkey->revoked_at = time;\n\t\tkey_schedule_gc(key->revoked_at + key_gc_delay);\n\t}\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL(key_revoke);\n\n/**\n * key_invalidate - Invalidate a key.\n * @key: The key to be invalidated.\n *\n * Mark a key as being invalidated and have it cleaned up immediately.  The key\n * is ignored by all searches and other operations from this point.\n */\nvoid key_invalidate(struct key *key)\n{\n\tkenter(\"%d\", key_serial(key));\n\n\tkey_check(key);\n\n\tif (!test_bit(KEY_FLAG_INVALIDATED, &key->flags)) {\n\t\tdown_write_nested(&key->sem, 1);\n\t\tif (!test_and_set_bit(KEY_FLAG_INVALIDATED, &key->flags))\n\t\t\tkey_schedule_gc_links();\n\t\tup_write(&key->sem);\n\t}\n}\nEXPORT_SYMBOL(key_invalidate);\n\n/**\n * generic_key_instantiate - Simple instantiation of a key from preparsed data\n * @key: The key to be instantiated\n * @prep: The preparsed data to load.\n *\n * Instantiate a key from preparsed data.  We assume we can just copy the data\n * in directly and clear the old pointers.\n *\n * This can be pointed to directly by the key type instantiate op pointer.\n */\nint generic_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tret = key_payload_reserve(key, prep->quotalen);\n\tif (ret == 0) {\n\t\trcu_assign_keypointer(key, prep->payload.data[0]);\n\t\tkey->payload.data[1] = prep->payload.data[1];\n\t\tkey->payload.data[2] = prep->payload.data[2];\n\t\tkey->payload.data[3] = prep->payload.data[3];\n\t\tprep->payload.data[0] = NULL;\n\t\tprep->payload.data[1] = NULL;\n\t\tprep->payload.data[2] = NULL;\n\t\tprep->payload.data[3] = NULL;\n\t}\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(generic_key_instantiate);\n\n/**\n * register_key_type - Register a type of key.\n * @ktype: The new key type.\n *\n * Register a new key type.\n *\n * Returns 0 on success or -EEXIST if a type of this name already exists.\n */\nint register_key_type(struct key_type *ktype)\n{\n\tstruct key_type *p;\n\tint ret;\n\n\tmemset(&ktype->lock_class, 0, sizeof(ktype->lock_class));\n\n\tret = -EEXIST;\n\tdown_write(&key_types_sem);\n\n\t/* disallow key types with the same name */\n\tlist_for_each_entry(p, &key_types_list, link) {\n\t\tif (strcmp(p->name, ktype->name) == 0)\n\t\t\tgoto out;\n\t}\n\n\t/* store the type */\n\tlist_add(&ktype->link, &key_types_list);\n\n\tpr_notice(\"Key type %s registered\\n\", ktype->name);\n\tret = 0;\n\nout:\n\tup_write(&key_types_sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(register_key_type);\n\n/**\n * unregister_key_type - Unregister a type of key.\n * @ktype: The key type.\n *\n * Unregister a key type and mark all the extant keys of this type as dead.\n * Those keys of this type are then destroyed to get rid of their payloads and\n * they and their links will be garbage collected as soon as possible.\n */\nvoid unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}\nEXPORT_SYMBOL(unregister_key_type);\n\n/*\n * Initialise the key management state.\n */\nvoid __init key_init(void)\n{\n\t/* allocate a slab in which we can store keys */\n\tkey_jar = kmem_cache_create(\"key_jar\", sizeof(struct key),\n\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\n\t/* add the special key types */\n\tlist_add_tail(&key_type_keyring.link, &key_types_list);\n\tlist_add_tail(&key_type_dead.link, &key_types_list);\n\tlist_add_tail(&key_type_user.link, &key_types_list);\n\tlist_add_tail(&key_type_logon.link, &key_types_list);\n\n\t/* record the root user tracking */\n\trb_link_node(&root_key_user.node,\n\t\t     NULL,\n\t\t     &key_user_tree.rb_node);\n\n\trb_insert_color(&root_key_user.node,\n\t\t\t&key_user_tree);\n}\n", "/* Userspace key control operations\n *\n * Copyright (C) 2004-5 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n#define KEY_MAX_DESC_SIZE 4096\n\nstatic int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}\n\n/*\n * Extract the description of a new key from userspace and either add it as a\n * new key to the specified keyring or update a matching key in that keyring.\n *\n * If the description is NULL or an empty string, the key type is asked to\n * generate one from the payload.\n *\n * The keyring must be writable so that we can attach the key to it.\n *\n * If successful, the new key's serial number is returned, otherwise an error\n * code is returned.\n */\nSYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}\n\n/*\n * Search the process keyrings and keyring trees linked from those for a\n * matching key.  Keyrings must have appropriate Search permission to be\n * searched.\n *\n * If a key is found, it will be attached to the destination keyring if there's\n * one specified and the serial number of the key will be returned.\n *\n * If no key is found, /sbin/request-key will be invoked if _callout_info is\n * non-NULL in an attempt to create a key.  The _callout_info string will be\n * passed to /sbin/request-key to aid with completing the request.  If the\n * _callout_info string is \"\" then it will be changed to \"-\".\n */\nSYSCALL_DEFINE4(request_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst char __user *, _callout_info,\n\t\tkey_serial_t, destringid)\n{\n\tstruct key_type *ktype;\n\tstruct key *key;\n\tkey_ref_t dest_ref;\n\tsize_t callout_len;\n\tchar type[32], *description, *callout_info;\n\tlong ret;\n\n\t/* pull the type into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* pull the description into kernel space */\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* pull the callout info into kernel space */\n\tcallout_info = NULL;\n\tcallout_len = 0;\n\tif (_callout_info) {\n\t\tcallout_info = strndup_user(_callout_info, PAGE_SIZE);\n\t\tif (IS_ERR(callout_info)) {\n\t\t\tret = PTR_ERR(callout_info);\n\t\t\tgoto error2;\n\t\t}\n\t\tcallout_len = strlen(callout_info);\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey = request_key_and_link(ktype, description, callout_info,\n\t\t\t\t   callout_len, NULL, key_ref_to_ptr(dest_ref),\n\t\t\t\t   KEY_ALLOC_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error5;\n\t}\n\n\t/* wait for the key to finish being constructed */\n\tret = wait_for_key_construction(key, 1);\n\tif (ret < 0)\n\t\tgoto error6;\n\n\tret = key->serial;\n\nerror6:\n \tkey_put(key);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkfree(callout_info);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n/*\n * Get the ID of the specified process keyring.\n *\n * The requested keyring must have search permission to be found.\n *\n * If successful, the ID of the requested keyring will be returned.\n */\nlong keyctl_get_keyring_ID(key_serial_t id, int create)\n{\n\tkey_ref_t key_ref;\n\tunsigned long lflags;\n\tlong ret;\n\n\tlflags = create ? KEY_LOOKUP_CREATE : 0;\n\tkey_ref = lookup_user_key(id, lflags, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Join a (named) session keyring.\n *\n * Create and join an anonymous session keyring or join a named session\n * keyring, creating it if necessary.  A named session keyring must have Search\n * permission for it to be joined.  Session keyrings without this permit will\n * be skipped over.  It is not permitted for userspace to create or join\n * keyrings whose name begin with a dot.\n *\n * If successful, the ID of the joined session keyring will be returned.\n */\nlong keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}\n\n/*\n * Update a key's data payload from the given data.\n *\n * The key must grant the caller Write permission and the key type must support\n * updating for this to work.  A negative key can be positively instantiated\n * with this call.\n *\n * If successful, 0 will be returned.  If the key type does not support\n * updating, then -EOPNOTSUPP will be returned.\n */\nlong keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkzfree(payload);\nerror:\n\treturn ret;\n}\n\n/*\n * Revoke a key.\n *\n * The key must be grant the caller Write or Setattr permission for this to\n * work.  The key type should give up its quota claim when revoked.  The key\n * and any links to the key will be automatically garbage collected after a\n * certain amount of time (/proc/sys/kernel/keys/gc_delay).\n *\n * Keys with KEY_FLAG_KEEP set should not be revoked.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_revoke_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tif (ret != -EACCES)\n\t\t\tgoto error;\n\t\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\t\tif (IS_ERR(key_ref)) {\n\t\t\tret = PTR_ERR(key_ref);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_revoke(key);\n\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Invalidate a key.\n *\n * The key must be grant the caller Invalidate permission for this to work.\n * The key and any links to the key will be automatically garbage collected\n * immediately.\n *\n * Keys with KEY_FLAG_KEEP set should not be invalidated.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_invalidate_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkenter(\"%d\", id);\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* Root is permitted to invalidate certain special keys */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkey_ref = lookup_user_key(id, 0, 0);\n\t\t\tif (IS_ERR(key_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_INVAL,\n\t\t\t\t     &key_ref_to_ptr(key_ref)->flags))\n\t\t\t\tgoto invalidate;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\ninvalidate:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_invalidate(key);\nerror_put:\n\tkey_ref_put(key_ref);\nerror:\n\tkleave(\" = %ld\", ret);\n\treturn ret;\n}\n\n/*\n * Clear the specified keyring, creating an empty process keyring if one of the\n * special keyring IDs is used.\n *\n * The keyring must grant the caller Write permission and not have\n * KEY_FLAG_KEEP set for this to work.  If successful, 0 will be returned.\n */\nlong keyctl_keyring_clear(key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref;\n\tstruct key *keyring;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\n\t\t/* Root is permitted to invalidate certain special keyrings */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkeyring_ref = lookup_user_key(ringid, 0, 0);\n\t\t\tif (IS_ERR(keyring_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_CLEAR,\n\t\t\t\t     &key_ref_to_ptr(keyring_ref)->flags))\n\t\t\t\tgoto clear;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\nclear:\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = keyring_clear(keyring);\nerror_put:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Create a link from a keyring to a key if there's no matching key in the\n * keyring, otherwise replace the link to the matching key with a link to the\n * new key.\n *\n * The key must grant the caller Link permission and the the keyring must grant\n * the caller Write permission.  Furthermore, if an additional link is created,\n * the keyring's quota will be extended.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_keyring_link(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_NEED_LINK);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_link(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Unlink a key from a keyring.\n *\n * The keyring must grant the caller Write permission for this to work; the key\n * itself need not grant the caller anything.  If the last link to a key is\n * removed then that key will be scheduled for destruction.\n *\n * Keys or keyrings with KEY_FLAG_KEEP set should not be unlinked.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tstruct key *keyring, *key;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_FOR_UNLINK, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags) &&\n\t    test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = key_unlink(keyring, key);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Return a description of a key to userspace.\n *\n * The key must grant the caller View permission for this to work.\n *\n * If there's a buffer, we place up to buflen bytes of data into it formatted\n * in the following way:\n *\n *\ttype;uid;gid;perm;description<NUL>\n *\n * If successful, we return the amount of description available, irrespective\n * of how much we may have copied into the buffer.\n */\nlong keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\t/* viewing a key under construction is permitted if we have the\n\t\t * authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\n\t/* calculate how much information we're going to return */\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\n\t/* consider returning the data */\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Search the specified keyring and any keyrings it links to for a matching\n * key.  Only keyrings that grant the caller Search permission will be searched\n * (this includes the starting keyring).  Only keys with Search permission can\n * be found.\n *\n * If successful, the found key will be linked to the destination keyring if\n * supplied and the key has Link permission, and the found key ID will be\n * returned.\n */\nlong keyctl_keyring_search(key_serial_t ringid,\n\t\t\t   const char __user *_type,\n\t\t\t   const char __user *_description,\n\t\t\t   key_serial_t destringid)\n{\n\tstruct key_type *ktype;\n\tkey_ref_t keyring_ref, key_ref, dest_ref;\n\tchar type[32], *description;\n\tlong ret;\n\n\t/* pull the type and description into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* get the keyring at which to begin the search */\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error2;\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey_ref = keyring_search(keyring_ref, ktype, description);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* treat lack or presence of a negative key the same */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOKEY;\n\t\tgoto error5;\n\t}\n\n\t/* link the resulting key to the destination keyring if we can */\n\tif (dest_ref) {\n\t\tret = key_permission(key_ref, KEY_NEED_LINK);\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\n\t\tret = key_link(key_ref_to_ptr(dest_ref), key_ref_to_ptr(key_ref));\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\nerror6:\n\tkey_ref_put(key_ref);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkey_ref_put(keyring_ref);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n/*\n * Read a key's payload.\n *\n * The key must either grant the caller Read permission, or it must grant the\n * caller Search permission when searched for from the process keyrings.\n *\n * If successful, we place up to buflen bytes of data into the buffer, if one\n * is provided, and return the amount of data that is available in the key,\n * irrespective of how much we copied into the buffer.\n */\nlong keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tret = -ENOKEY;\n\t\tgoto error2;\n\t}\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n/*\n * Change the ownership of a key\n *\n * The key must grant the caller Setattr permission for this to work, though\n * the key need not be fully instantiated yet.  For the UID to be changed, or\n * for the GID to be changed to a group the caller is not a member of, the\n * caller must have sysadmin capability.  If either uid or gid is -1 then that\n * attribute is not changed.\n *\n * If the UID is to be changed, the new user must have sufficient quota to\n * accept the key.  The quota deduction will be removed from the old user to\n * the new user should the attribute be changed.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)\n{\n\tstruct key_user *newowner, *zapowner = NULL;\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\tret = -EINVAL;\n\tif ((user != (uid_t) -1) && !uid_valid(uid))\n\t\tgoto error;\n\tif ((group != (gid_t) -1) && !gid_valid(gid))\n\t\tgoto error;\n\n\tret = 0;\n\tif (user == (uid_t) -1 && group == (gid_t) -1)\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chown races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/* only the sysadmin can chown a key to some other UID */\n\t\tif (user != (uid_t) -1 && !uid_eq(key->uid, uid))\n\t\t\tgoto error_put;\n\n\t\t/* only the sysadmin can set the key's GID to a group other\n\t\t * than one of those that the current process subscribes to */\n\t\tif (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))\n\t\t\tgoto error_put;\n\t}\n\n\t/* change the UID */\n\tif (user != (uid_t) -1 && !uid_eq(uid, key->uid)) {\n\t\tret = -ENOMEM;\n\t\tnewowner = key_user_lookup(uid);\n\t\tif (!newowner)\n\t\t\tgoto error_put;\n\n\t\t/* transfer the quota burden to the new user */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\t\tspin_lock(&newowner->lock);\n\t\t\tif (newowner->qnkeys + 1 >= maxkeys ||\n\t\t\t    newowner->qnbytes + key->quotalen >= maxbytes ||\n\t\t\t    newowner->qnbytes + key->quotalen <\n\t\t\t    newowner->qnbytes)\n\t\t\t\tgoto quota_overrun;\n\n\t\t\tnewowner->qnkeys++;\n\t\t\tnewowner->qnbytes += key->quotalen;\n\t\t\tspin_unlock(&newowner->lock);\n\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tatomic_inc(&newowner->nkeys);\n\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\t\tatomic_inc(&newowner->nikeys);\n\t\t}\n\n\t\tzapowner = key->user;\n\t\tkey->user = newowner;\n\t\tkey->uid = uid;\n\t}\n\n\t/* change the GID */\n\tif (group != (gid_t) -1)\n\t\tkey->gid = gid;\n\n\tret = 0;\n\nerror_put:\n\tup_write(&key->sem);\n\tkey_put(key);\n\tif (zapowner)\n\t\tkey_user_put(zapowner);\nerror:\n\treturn ret;\n\nquota_overrun:\n\tspin_unlock(&newowner->lock);\n\tzapowner = newowner;\n\tret = -EDQUOT;\n\tgoto error_put;\n}\n\n/*\n * Change the permission mask on a key.\n *\n * The key must grant the caller Setattr permission for this to work, though\n * the key need not be fully instantiated yet.  If the caller does not have\n * sysadmin capability, it may only change the permission on keys that it owns.\n */\nlong keyctl_setperm_key(key_serial_t id, key_perm_t perm)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chmod races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\t/* if we're not the sysadmin, we can only change a key that we own */\n\tif (capable(CAP_SYS_ADMIN) || uid_eq(key->uid, current_fsuid())) {\n\t\tkey->perm = perm;\n\t\tret = 0;\n\t}\n\n\tup_write(&key->sem);\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n/*\n * Get the destination keyring for instantiation and check that the caller has\n * Write permission on it.\n */\nstatic long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}\n\n/*\n * Change the request_key authorisation key on the current process.\n */\nstatic int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}\n\n/*\n * Instantiate a key with the specified payload and link the key into the\n * destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t/* find the destination keyring amongst those belonging to the\n\t * requesting task */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\nerror:\n\treturn ret;\n}\n\n/*\n * Instantiate a key with the specified payload and link the key into the\n * destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key(key_serial_t id,\n\t\t\t    const void __user *_payload,\n\t\t\t    size_t plen,\n\t\t\t    key_serial_t ringid)\n{\n\tif (_payload && plen) {\n\t\tstruct iovec iov;\n\t\tstruct iov_iter from;\n\t\tint ret;\n\n\t\tret = import_single_range(WRITE, (void __user *)_payload, plen,\n\t\t\t\t\t  &iov, &from);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\treturn keyctl_instantiate_key_common(id, &from, ringid);\n\t}\n\n\treturn keyctl_instantiate_key_common(id, NULL, ringid);\n}\n\n/*\n * Instantiate a key with the specified multipart payload and link the key into\n * the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key_iov(key_serial_t id,\n\t\t\t\tconst struct iovec __user *_payload_iov,\n\t\t\t\tunsigned ioc,\n\t\t\t\tkey_serial_t ringid)\n{\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tstruct iov_iter from;\n\tlong ret;\n\n\tif (!_payload_iov)\n\t\tioc = 0;\n\n\tret = import_iovec(WRITE, _payload_iov, ioc,\n\t\t\t\t    ARRAY_SIZE(iovstack), &iov, &from);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = keyctl_instantiate_key_common(id, &from, ringid);\n\tkfree(iov);\n\treturn ret;\n}\n\n/*\n * Negatively instantiate the key with the given timeout (in seconds) and link\n * the key into the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * The key and any links to the key will be automatically garbage collected\n * after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return -ENOKEY until the negative key expires.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_negate_key(key_serial_t id, unsigned timeout, key_serial_t ringid)\n{\n\treturn keyctl_reject_key(id, timeout, ENOKEY, ringid);\n}\n\n/*\n * Negatively instantiate the key with the given timeout (in seconds) and error\n * code and link the key into the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * The key and any links to the key will be automatically garbage collected\n * after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return the specified error code until the negative key expires.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n\t\t       key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter(\"%d,%u,%u,%d\", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n\t\t\t\t  dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Read or set the default keyring in which request_key() will cache keys and\n * return the old setting.\n *\n * If a thread or process keyring is specified then it will be created if it\n * doesn't yet exist.  The old setting will be returned if successful.\n */\nlong keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\n\told_setting = current_cred_xxx(jit_keyring);\n\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n/*\n * Set or clear the timeout on a key.\n *\n * Either the key must grant the caller Setattr permission or else the caller\n * must hold an instantiation authorisation token for the key.\n *\n * The timeout is either 0 to clear the timeout, or a number of seconds from\n * the current time.  The key and any links to the key will be automatically\n * garbage collected after the timeout expires.\n *\n * Keys with KEY_FLAG_KEEP set should not be timed out.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_set_timeout(key_serial_t id, unsigned timeout)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\t/* setting the timeout on a key under construction is permitted\n\t\t * if we have the authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(id);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(id,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_set_timeout(key, timeout);\n\tkey_put(key);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Assume (or clear) the authority to instantiate the specified key.\n *\n * This sets the authoritative token currently in force for key instantiation.\n * This must be done for a key to be instantiated.  It has the effect of making\n * available all the keys from the caller of the request_key() that created a\n * key to request_key() calls made by the caller of this function.\n *\n * The caller must have the instantiation key in their process keyrings with a\n * Search permission grant available to the caller.\n *\n * If the ID given is 0, then the setting will be cleared and 0 returned.\n *\n * If the ID given has a matching an authorisation key, then that key will be\n * set and its ID will be returned.  The authorisation key can be read to get\n * the callout information passed to request_key().\n */\nlong keyctl_assume_authority(key_serial_t id)\n{\n\tstruct key *authkey;\n\tlong ret;\n\n\t/* special key IDs aren't permitted */\n\tret = -EINVAL;\n\tif (id < 0)\n\t\tgoto error;\n\n\t/* we divest ourselves of authority if given an ID of 0 */\n\tif (id == 0) {\n\t\tret = keyctl_change_reqkey_auth(NULL);\n\t\tgoto error;\n\t}\n\n\t/* attempt to assume the authority temporarily granted to us whilst we\n\t * instantiate the specified key\n\t * - the authorisation key must be in the current task's keyrings\n\t *   somewhere\n\t */\n\tauthkey = key_get_instantiation_authkey(id);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error;\n\t}\n\n\tret = keyctl_change_reqkey_auth(authkey);\n\tif (ret == 0)\n\t\tret = authkey->serial;\n\tkey_put(authkey);\nerror:\n\treturn ret;\n}\n\n/*\n * Get a key's the LSM security label.\n *\n * The key must grant the caller View permission for this to work.\n *\n * If there's a buffer, then up to buflen bytes of data will be placed into it.\n *\n * If successful, the amount of information available will be returned,\n * irrespective of how much was copied (including the terminal NUL).\n */\nlong keyctl_get_security(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *context;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) != -EACCES)\n\t\t\treturn PTR_ERR(key_ref);\n\n\t\t/* viewing a key under construction is also permitted if we\n\t\t * have the authorisation token handy */\n\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\tif (IS_ERR(instkey))\n\t\t\treturn PTR_ERR(instkey);\n\t\tkey_put(instkey);\n\n\t\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, 0);\n\t\tif (IS_ERR(key_ref))\n\t\t\treturn PTR_ERR(key_ref);\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = security_key_getsecurity(key, &context);\n\tif (ret == 0) {\n\t\t/* if no information was returned, give userspace an empty\n\t\t * string */\n\t\tret = 1;\n\t\tif (buffer && buflen > 0 &&\n\t\t    copy_to_user(buffer, \"\", 1) != 0)\n\t\t\tret = -EFAULT;\n\t} else if (ret > 0) {\n\t\t/* return as much data as there's room for */\n\t\tif (buffer && buflen > 0) {\n\t\t\tif (buflen > ret)\n\t\t\t\tbuflen = ret;\n\n\t\t\tif (copy_to_user(buffer, context, buflen) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(context);\n\t}\n\n\tkey_ref_put(key_ref);\n\treturn ret;\n}\n\n/*\n * Attempt to install the calling process's session keyring on the process's\n * parent process.\n *\n * The keyring must exist and must grant the caller LINK permission, and the\n * parent process must be single-threaded and must have the same effective\n * ownership as this process and mustn't be SUID/SGID.\n *\n * The keyring will be emplaced on the parent when it next resumes userspace.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_session_to_parent(void)\n{\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct callback_head *newwork, *oldwork;\n\tkey_ref_t keyring_r;\n\tstruct cred *cred;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_NEED_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\tret = -ENOMEM;\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tnewwork = &cred->rcu;\n\n\tcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tinit_task_work(newwork, key_change_session_keyring);\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tret = -EPERM;\n\toldwork = NULL;\n\tparent = me->real_parent;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto unlock;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto unlock;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->session_keyring == pcred->session_keyring) {\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (!uid_eq(pcred->uid,\t mycred->euid) ||\n\t    !uid_eq(pcred->euid, mycred->euid) ||\n\t    !uid_eq(pcred->suid, mycred->euid) ||\n\t    !gid_eq(pcred->gid,\t mycred->egid) ||\n\t    !gid_eq(pcred->egid, mycred->egid) ||\n\t    !gid_eq(pcred->sgid, mycred->egid))\n\t\tgoto unlock;\n\n\t/* the keyrings must have the same UID */\n\tif ((pcred->session_keyring &&\n\t     !uid_eq(pcred->session_keyring->uid, mycred->euid)) ||\n\t    !uid_eq(mycred->session_keyring->uid, mycred->euid))\n\t\tgoto unlock;\n\n\t/* cancel an already pending keyring replacement */\n\toldwork = task_work_cancel(parent, key_change_session_keyring);\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tret = task_work_add(parent, newwork, true);\n\tif (!ret)\n\t\tnewwork = NULL;\nunlock:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldwork)\n\t\tput_cred(container_of(oldwork, struct cred, rcu));\n\tif (newwork)\n\t\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n}\n\n/*\n * Apply a restriction to a given keyring.\n *\n * The caller must have Setattr permission to change keyring restrictions.\n *\n * The requested type name may be a NULL pointer to reject all attempts\n * to link to the keyring. If _type is non-NULL, _restriction can be\n * NULL or a pointer to a string describing the restriction. If _type is\n * NULL, _restriction must also be NULL.\n *\n * Returns 0 if successful.\n */\nlong keyctl_restrict_keyring(key_serial_t id, const char __user *_type,\n\t\t\t     const char __user *_restriction)\n{\n\tkey_ref_t key_ref;\n\tbool link_reject = !_type;\n\tchar type[32];\n\tchar *restriction = NULL;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref))\n\t\treturn PTR_ERR(key_ref);\n\n\tif (_type) {\n\t\tret = key_get_type_from_user(type, _type, sizeof(type));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (_restriction) {\n\t\tif (!_type) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestriction = strndup_user(_restriction, PAGE_SIZE);\n\t\tif (IS_ERR(restriction)) {\n\t\t\tret = PTR_ERR(restriction);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = keyring_restrict(key_ref, link_reject ? NULL : type, restriction);\n\tkfree(restriction);\n\nerror:\n\tkey_ref_put(key_ref);\n\n\treturn ret;\n}\n\n/*\n * The key control system call\n */\nSYSCALL_DEFINE5(keyctl, int, option, unsigned long, arg2, unsigned long, arg3,\n\t\tunsigned long, arg4, unsigned long, arg5)\n{\n\tswitch (option) {\n\tcase KEYCTL_GET_KEYRING_ID:\n\t\treturn keyctl_get_keyring_ID((key_serial_t) arg2,\n\t\t\t\t\t     (int) arg3);\n\n\tcase KEYCTL_JOIN_SESSION_KEYRING:\n\t\treturn keyctl_join_session_keyring((const char __user *) arg2);\n\n\tcase KEYCTL_UPDATE:\n\t\treturn keyctl_update_key((key_serial_t) arg2,\n\t\t\t\t\t (const void __user *) arg3,\n\t\t\t\t\t (size_t) arg4);\n\n\tcase KEYCTL_REVOKE:\n\t\treturn keyctl_revoke_key((key_serial_t) arg2);\n\n\tcase KEYCTL_DESCRIBE:\n\t\treturn keyctl_describe_key((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (unsigned) arg4);\n\n\tcase KEYCTL_CLEAR:\n\t\treturn keyctl_keyring_clear((key_serial_t) arg2);\n\n\tcase KEYCTL_LINK:\n\t\treturn keyctl_keyring_link((key_serial_t) arg2,\n\t\t\t\t\t   (key_serial_t) arg3);\n\n\tcase KEYCTL_UNLINK:\n\t\treturn keyctl_keyring_unlink((key_serial_t) arg2,\n\t\t\t\t\t     (key_serial_t) arg3);\n\n\tcase KEYCTL_SEARCH:\n\t\treturn keyctl_keyring_search((key_serial_t) arg2,\n\t\t\t\t\t     (const char __user *) arg3,\n\t\t\t\t\t     (const char __user *) arg4,\n\t\t\t\t\t     (key_serial_t) arg5);\n\n\tcase KEYCTL_READ:\n\t\treturn keyctl_read_key((key_serial_t) arg2,\n\t\t\t\t       (char __user *) arg3,\n\t\t\t\t       (size_t) arg4);\n\n\tcase KEYCTL_CHOWN:\n\t\treturn keyctl_chown_key((key_serial_t) arg2,\n\t\t\t\t\t(uid_t) arg3,\n\t\t\t\t\t(gid_t) arg4);\n\n\tcase KEYCTL_SETPERM:\n\t\treturn keyctl_setperm_key((key_serial_t) arg2,\n\t\t\t\t\t  (key_perm_t) arg3);\n\n\tcase KEYCTL_INSTANTIATE:\n\t\treturn keyctl_instantiate_key((key_serial_t) arg2,\n\t\t\t\t\t      (const void __user *) arg3,\n\t\t\t\t\t      (size_t) arg4,\n\t\t\t\t\t      (key_serial_t) arg5);\n\n\tcase KEYCTL_NEGATE:\n\t\treturn keyctl_negate_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (key_serial_t) arg4);\n\n\tcase KEYCTL_SET_REQKEY_KEYRING:\n\t\treturn keyctl_set_reqkey_keyring(arg2);\n\n\tcase KEYCTL_SET_TIMEOUT:\n\t\treturn keyctl_set_timeout((key_serial_t) arg2,\n\t\t\t\t\t  (unsigned) arg3);\n\n\tcase KEYCTL_ASSUME_AUTHORITY:\n\t\treturn keyctl_assume_authority((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_SECURITY:\n\t\treturn keyctl_get_security((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (size_t) arg4);\n\n\tcase KEYCTL_SESSION_TO_PARENT:\n\t\treturn keyctl_session_to_parent();\n\n\tcase KEYCTL_REJECT:\n\t\treturn keyctl_reject_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (unsigned) arg4,\n\t\t\t\t\t (key_serial_t) arg5);\n\n\tcase KEYCTL_INSTANTIATE_IOV:\n\t\treturn keyctl_instantiate_key_iov(\n\t\t\t(key_serial_t) arg2,\n\t\t\t(const struct iovec __user *) arg3,\n\t\t\t(unsigned) arg4,\n\t\t\t(key_serial_t) arg5);\n\n\tcase KEYCTL_INVALIDATE:\n\t\treturn keyctl_invalidate_key((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_PERSISTENT:\n\t\treturn keyctl_get_persistent((uid_t)arg2, (key_serial_t)arg3);\n\n\tcase KEYCTL_DH_COMPUTE:\n\t\treturn keyctl_dh_compute((struct keyctl_dh_params __user *) arg2,\n\t\t\t\t\t (char __user *) arg3, (size_t) arg4,\n\t\t\t\t\t (struct keyctl_kdf_params __user *) arg5);\n\n\tcase KEYCTL_RESTRICT_KEYRING:\n\t\treturn keyctl_restrict_keyring((key_serial_t) arg2,\n\t\t\t\t\t       (const char __user *) arg3,\n\t\t\t\t\t       (const char __user *) arg4);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n", "/* Keyring handling\n *\n * Copyright (C) 2004-2005, 2008, 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/keyring-type.h>\n#include <keys/user-type.h>\n#include <linux/assoc_array_priv.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n/*\n * When plumbing the depths of the key tree, this sets a hard limit\n * set on how deep we're willing to go.\n */\n#define KEYRING_SEARCH_MAX_DEPTH 6\n\n/*\n * We keep all named keyrings in a hash to speed looking them up.\n */\n#define KEYRING_NAME_HASH_SIZE\t(1 << 5)\n\n/*\n * We mark pointers we pass to the associative array with bit 1 set if\n * they're keyrings and clear otherwise.\n */\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)\n{\n\treturn (unsigned long)x & KEYRING_PTR_SUBTYPE;\n}\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}\nstatic inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}\n\nstatic struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];\nstatic DEFINE_RWLOCK(keyring_name_lock);\n\nstatic inline unsigned keyring_hash(const char *desc)\n{\n\tunsigned bucket = 0;\n\n\tfor (; *desc; desc++)\n\t\tbucket += (unsigned char)*desc;\n\n\treturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\n}\n\n/*\n * The keyring key type definition.  Keyrings are simply keys of this type and\n * can be treated as ordinary keys in addition to having their own special\n * operations.\n */\nstatic int keyring_preparse(struct key_preparsed_payload *prep);\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep);\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m);\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen);\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nEXPORT_SYMBOL(key_type_keyring);\n\n/*\n * Semaphore to serialise link/link calls to prevent two link calls in parallel\n * introducing a cycle.\n */\nstatic DECLARE_RWSEM(keyring_serialise_link_sem);\n\n/*\n * Publish the name of a keyring so that it can be found by name (if it has\n * one).\n */\nstatic void keyring_publish_name(struct key *keyring)\n{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->name_link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}\n\n/*\n * Preparse a keyring payload\n */\nstatic int keyring_preparse(struct key_preparsed_payload *prep)\n{\n\treturn prep->datalen != 0 ? -EINVAL : 0;\n}\n\n/*\n * Free a preparse of a user defined key payload\n */\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep)\n{\n}\n\n/*\n * Initialise a keyring.\n *\n * Returns 0 on success, -EINVAL if given any data.\n */\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tassoc_array_init(&keyring->keys);\n\t/* make the keyring available by name if it has one */\n\tkeyring_publish_name(keyring);\n\treturn 0;\n}\n\n/*\n * Multiply 64-bits by 32-bits to 96-bits and fold back to 64-bit.  Ideally we'd\n * fold the carry back too, but that requires inline asm.\n */\nstatic u64 mult_64x32_and_fold(u64 x, u32 y)\n{\n\tu64 hi = (u64)(u32)(x >> 32) * y;\n\tu64 lo = (u64)(u32)(x) * y;\n\treturn lo + ((u64)(u32)hi << 32) + (u32)(hi >> 32);\n}\n\n/*\n * Hash a key type and description.\n */\nstatic unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t/* Fold the hash down to 32 bits if need be. */\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t/* Squidge all the keyrings into a separate part of the tree to\n\t * ordinary keys by making sure the lowest level segment in the hash is\n\t * zero for keyrings and non-zero otherwise.\n\t */\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}\n\n/*\n * Build the next index key chunk.\n *\n * On 32-bit systems the index key is laid out as:\n *\n *\t0\t4\t5\t9...\n *\thash\tdesclen\ttypeptr\tdesc[]\n *\n * On 64-bit systems:\n *\n *\t0\t8\t9\t17...\n *\thash\tdesclen\ttypeptr\tdesc[]\n *\n * We return it one word-sized chunk at a time.\n */\nstatic unsigned long keyring_get_key_chunk(const void *data, int level)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tunsigned long chunk = 0;\n\tlong offset = 0;\n\tint desc_len = index_key->desc_len, n = sizeof(chunk);\n\n\tlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\tswitch (level) {\n\tcase 0:\n\t\treturn hash_key_type_and_desc(index_key);\n\tcase 1:\n\t\treturn ((unsigned long)index_key->type << 8) | desc_len;\n\tcase 2:\n\t\tif (desc_len == 0)\n\t\t\treturn (u8)((unsigned long)index_key->type >>\n\t\t\t\t    (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\tn--;\n\t\toffset = 1;\n\tdefault:\n\t\toffset += sizeof(chunk) - 1;\n\t\toffset += (level - 3) * sizeof(chunk);\n\t\tif (offset >= desc_len)\n\t\t\treturn 0;\n\t\tdesc_len -= offset;\n\t\tif (desc_len > n)\n\t\t\tdesc_len = n;\n\t\toffset += desc_len;\n\t\tdo {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= ((u8*)index_key->description)[--offset];\n\t\t} while (--desc_len > 0);\n\n\t\tif (level == 2) {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= (u8)((unsigned long)index_key->type >>\n\t\t\t\t      (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\t}\n\t\treturn chunk;\n\t}\n}\n\nstatic unsigned long keyring_get_object_key_chunk(const void *object, int level)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\treturn keyring_get_key_chunk(&key->index_key, level);\n}\n\nstatic bool keyring_compare_object(const void *object, const void *data)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\treturn key->index_key.type == index_key->type &&\n\t\tkey->index_key.desc_len == index_key->desc_len &&\n\t\tmemcmp(key->index_key.description, index_key->description,\n\t\t       index_key->desc_len) == 0;\n}\n\n/*\n * Compare the index keys of a pair of objects and determine the bit position\n * at which they differ - if they differ.\n */\nstatic int keyring_diff_objects(const void *object, const void *data)\n{\n\tconst struct key *key_a = keyring_ptr_to_key(object);\n\tconst struct keyring_index_key *a = &key_a->index_key;\n\tconst struct keyring_index_key *b = data;\n\tunsigned long seg_a, seg_b;\n\tint level, i;\n\n\tlevel = 0;\n\tseg_a = hash_key_type_and_desc(a);\n\tseg_b = hash_key_type_and_desc(b);\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The number of bits contributed by the hash is controlled by a\n\t * constant in the assoc_array headers.  Everything else thereafter we\n\t * can deal with as being machine word-size dependent.\n\t */\n\tlevel += ASSOC_ARRAY_KEY_CHUNK_SIZE / 8;\n\tseg_a = a->desc_len;\n\tseg_b = b->desc_len;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The next bit may not work on big endian */\n\tlevel++;\n\tseg_a = (unsigned long)a->type;\n\tseg_b = (unsigned long)b->type;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\tlevel += sizeof(unsigned long);\n\tif (a->desc_len == 0)\n\t\tgoto same;\n\n\ti = 0;\n\tif (((unsigned long)a->description | (unsigned long)b->description) &\n\t    (sizeof(unsigned long) - 1)) {\n\t\tdo {\n\t\t\tseg_a = *(unsigned long *)(a->description + i);\n\t\t\tseg_b = *(unsigned long *)(b->description + i);\n\t\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\t\tgoto differ_plus_i;\n\t\t\ti += sizeof(unsigned long);\n\t\t} while (i < (a->desc_len & (sizeof(unsigned long) - 1)));\n\t}\n\n\tfor (; i < a->desc_len; i++) {\n\t\tseg_a = *(unsigned char *)(a->description + i);\n\t\tseg_b = *(unsigned char *)(b->description + i);\n\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\tgoto differ_plus_i;\n\t}\n\nsame:\n\treturn -1;\n\ndiffer_plus_i:\n\tlevel += i;\ndiffer:\n\ti = level * 8 + __ffs(seg_a ^ seg_b);\n\treturn i;\n}\n\n/*\n * Free an object after stripping the keyring flag off of the pointer.\n */\nstatic void keyring_free_object(void *object)\n{\n\tkey_put(keyring_ptr_to_key(object));\n}\n\n/*\n * Operations for keyring management by the index-tree routines.\n */\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\n/*\n * Clean up a keyring when it is destroyed.  Unpublish its name if it had one\n * and dispose of its data.\n *\n * The garbage collector detects the final key_put(), removes the keyring from\n * the serial number tree and then does RCU synchronisation before coming here,\n * so we shouldn't need to worry about code poking around here with the RCU\n * readlock held by this time.\n */\nstatic void keyring_destroy(struct key *keyring)\n{\n\tif (keyring->description) {\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (keyring->name_link.next != NULL &&\n\t\t    !list_empty(&keyring->name_link))\n\t\t\tlist_del(&keyring->name_link);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n\n\tif (keyring->restrict_link) {\n\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\tkey_put(keyres->key);\n\t\tkfree(keyres);\n\t}\n\n\tassoc_array_destroy(&keyring->keys, &keyring_assoc_array_ops);\n}\n\n/*\n * Describe a keyring for /proc.\n */\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}\n\nstruct keyring_read_iterator_context {\n\tsize_t\t\t\tbuflen;\n\tsize_t\t\t\tcount;\n\tkey_serial_t __user\t*buffer;\n};\n\nstatic int keyring_read_iterator(const void *object, void *data)\n{\n\tstruct keyring_read_iterator_context *ctx = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tint ret;\n\n\tkenter(\"{%s,%d},,{%zu/%zu}\",\n\t       key->type->name, key->serial, ctx->count, ctx->buflen);\n\n\tif (ctx->count >= ctx->buflen)\n\t\treturn 1;\n\n\tret = put_user(key->serial, ctx->buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\tctx->buffer++;\n\tctx->count += sizeof(key->serial);\n\treturn 0;\n}\n\n/*\n * Read a list of key IDs from the keyring's contents in binary form\n *\n * The keyring's semaphore is read-locked by the caller.  This prevents someone\n * from modifying it under us - which could cause us to read key IDs multiple\n * times.\n */\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen)\n{\n\tstruct keyring_read_iterator_context ctx;\n\tunsigned long nr_keys;\n\tint ret;\n\n\tkenter(\"{%d},,%zu\", key_serial(keyring), buflen);\n\n\tif (buflen & (sizeof(key_serial_t) - 1))\n\t\treturn -EINVAL;\n\n\tnr_keys = keyring->keys.nr_leaves_on_tree;\n\tif (nr_keys == 0)\n\t\treturn 0;\n\n\t/* Calculate how much data we could return */\n\tif (!buffer || !buflen)\n\t\treturn nr_keys * sizeof(key_serial_t);\n\n\t/* Copy the IDs of the subscribed keys into the buffer */\n\tctx.buffer = (key_serial_t __user *)buffer;\n\tctx.buflen = buflen;\n\tctx.count = 0;\n\tret = assoc_array_iterate(&keyring->keys, keyring_read_iterator, &ctx);\n\tif (ret < 0) {\n\t\tkleave(\" = %d [iterate]\", ret);\n\t\treturn ret;\n\t}\n\n\tkleave(\" = %zu [ok]\", ctx.count);\n\treturn ctx.count;\n}\n\n/*\n * Allocate a keyring and link into the destination keyring.\n */\nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}\nEXPORT_SYMBOL(keyring_alloc);\n\n/**\n * restrict_link_reject - Give -EPERM to restrict link\n * @keyring: The keyring being added to.\n * @type: The type of key being added.\n * @payload: The payload of the key intended to be added.\n * @data: Additional data for evaluating restriction.\n *\n * Reject the addition of any links to a keyring.  It can be overridden by\n * passing KEY_ALLOC_BYPASS_RESTRICTION to key_instantiate_and_link() when\n * adding a key to a keyring.\n *\n * This is meant to be stored in a key_restriction structure which is passed\n * in the restrict_link parameter to keyring_alloc().\n */\nint restrict_link_reject(struct key *keyring,\n\t\t\t const struct key_type *type,\n\t\t\t const union key_payload *payload,\n\t\t\t struct key *restriction_key)\n{\n\treturn -EPERM;\n}\n\n/*\n * By default, we keys found by getting an exact match on their descriptions.\n */\nbool key_default_cmp(const struct key *key,\n\t\t     const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}\n\n/*\n * Iteration function to consider each key found.\n */\nstatic int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = key->flags;\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* ignore keys not of this type */\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\n\t/* skip invalidated, revoked and expired keys */\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* keys that don't match */\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\n\t/* key must have search permissions */\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\t/* we set a different error code if we pass a negative key */\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\tsmp_rmb();\n\t\t\tctx->result = ERR_PTR(key->reject_error);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* Found */\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}\n\n/*\n * Search inside a keyring for a key.  We can search by walking to it\n * directly based on its index-key or we can iterate over the entire\n * tree looking for it, based on the match function.\n */\nstatic int search_keyring(struct key *keyring, struct keyring_search_context *ctx)\n{\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_DIRECT) {\n\t\tconst void *object;\n\n\t\tobject = assoc_array_find(&keyring->keys,\n\t\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t\t  &ctx->index_key);\n\t\treturn object ? ctx->iterator(object, ctx) : 0;\n\t}\n\treturn assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);\n}\n\n/*\n * Search a tree of keyrings that point to other keyrings up to the maximum\n * depth.\n */\nstatic bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);\n\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\n\t/* Check to see if this top-level keyring is what we are looking for\n\t * and whether it is valid or not.\n\t */\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\n\t/* Start processing a new keyring */\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t/* Search through the keys in this keyring before its searching its\n\t * subtrees.\n\t */\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t/* Then manually iterate through the keyrings nested in this one.\n\t *\n\t * Start from the root node of the index tree.  Because of the way the\n\t * hash function has been set up, keyrings cluster on the leftmost\n\t * branch of the root node (root slot 0) or in the root node itself.\n\t * Non-keyrings avoid the leftmost branch of the root entirely (root\n\t * slots 1-15).\n\t */\n\tptr = READ_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t/* If the root is a shortcut, either the keyring only contains\n\t\t * keyring pointers (everything clusters behind root slot 0) or\n\t\t * doesn't contain any keyring pointers.\n\t\t */\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t/* Descend to a more distal node in this keyring's content tree and go\n\t * through that.\n\t */\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\t/* Go through the slots in a node */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t/* Search a nested keyring */\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t/* We've dealt with all the slots in the current node, so now we need\n\t * to ascend to the parent and continue processing there.\n\t */\n\tptr = READ_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\n\t/* If we've ascended to the root (zero backpointer), we must have just\n\t * finished processing the leftmost branch rather than the root slots -\n\t * so there can't be any more keyrings for us to find.\n\t */\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t/* The keyring we're looking at was disqualified or didn't contain a\n\t * matching key.\n\t */\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t/* Resume the processing of a keyring higher up in the tree */\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t/* We found a viable match */\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now.tv_sec;\n\t\tkeyring->last_used_at = ctx->now.tv_sec;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now.tv_sec;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}\n\n/**\n * keyring_search_aux - Search a keyring tree for a key matching some criteria\n * @keyring_ref: A pointer to the keyring with possession indicator.\n * @ctx: The keyring search context.\n *\n * Search the supplied keyring tree for a key that matches the criteria given.\n * The root keyring and any linked keyrings must grant Search permission to the\n * caller to be searchable and keys can only be found if they too grant Search\n * to the caller. The possession flag on the root keyring pointer controls use\n * of the possessor bits in permissions checking of the entire tree.  In\n * addition, the LSM gets to forbid keyring searches and key matches.\n *\n * The search is performed as a breadth-then-depth search up to the prescribed\n * limit (KEYRING_SEARCH_MAX_DEPTH).\n *\n * Keys are matched to the type provided and are then filtered by the match\n * function, which is given the description to use in any way it sees fit.  The\n * match function may use any attributes of a key that it wishes to to\n * determine the match.  Normally the match function from the key type would be\n * used.\n *\n * RCU can be used to prevent the keyring key lists from disappearing without\n * the need to take lots of locks.\n *\n * Returns a pointer to the found key and increments the key usage count if\n * successful; -EAGAIN if no matching keys were found, or if expired or revoked\n * keys were found; -ENOKEY if only negative keys were found; -ENOTDIR if the\n * specified keyring wasn't a keyring.\n *\n * In the case of a successful return, the possession attribute from\n * @keyring_ref is propagated to the returned key reference.\n */\nkey_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t     struct keyring_search_context *ctx)\n{\n\tstruct key *keyring;\n\tlong err;\n\n\tctx->iterator = keyring_search_iterator;\n\tctx->possessed = is_key_possessed(keyring_ref);\n\tctx->result = ERR_PTR(-EAGAIN);\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\n\t\terr = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\trcu_read_lock();\n\tctx->now = current_kernel_time();\n\tif (search_nested_keyrings(keyring, ctx))\n\t\t__key_get(key_ref_to_ptr(ctx->result));\n\trcu_read_unlock();\n\treturn ctx->result;\n}\n\n/**\n * keyring_search - Search the supplied keyring tree for a matching key\n * @keyring: The root of the keyring tree to be searched.\n * @type: The type of keyring we want to find.\n * @description: The name of the keyring we want to find.\n *\n * As keyring_search_aux() above, but using the current task's credentials and\n * type's default matching function and preferred search method.\n */\nkey_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}\nEXPORT_SYMBOL(keyring_search);\n\nstatic struct key_restriction *keyring_restriction_alloc(\n\tkey_restrict_link_func_t check)\n{\n\tstruct key_restriction *keyres =\n\t\tkzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\n\tif (!keyres)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkeyres->check = check;\n\n\treturn keyres;\n}\n\n/*\n * Semaphore to serialise restriction setup to prevent reference count\n * cycles through restriction key pointers.\n */\nstatic DECLARE_RWSEM(keyring_serialise_restrict_sem);\n\n/*\n * Check for restriction cycles that would prevent keyring garbage collection.\n * keyring_serialise_restrict_sem must be held.\n */\nstatic bool keyring_detect_restriction_cycle(const struct key *dest_keyring,\n\t\t\t\t\t     struct key_restriction *keyres)\n{\n\twhile (keyres && keyres->key &&\n\t       keyres->key->type == &key_type_keyring) {\n\t\tif (keyres->key == dest_keyring)\n\t\t\treturn true;\n\n\t\tkeyres = keyres->key->restrict_link;\n\t}\n\n\treturn false;\n}\n\n/**\n * keyring_restrict - Look up and apply a restriction to a keyring\n *\n * @keyring: The keyring to be restricted\n * @restriction: The restriction options to apply to the keyring\n */\nint keyring_restrict(key_ref_t keyring_ref, const char *type,\n\t\t     const char *restriction)\n{\n\tstruct key *keyring;\n\tstruct key_type *restrict_type = NULL;\n\tstruct key_restriction *restrict_link;\n\tint ret = 0;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tif (!type) {\n\t\trestrict_link = keyring_restriction_alloc(restrict_link_reject);\n\t} else {\n\t\trestrict_type = key_type_lookup(type);\n\n\t\tif (IS_ERR(restrict_type))\n\t\t\treturn PTR_ERR(restrict_type);\n\n\t\tif (!restrict_type->lookup_restriction) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestrict_link = restrict_type->lookup_restriction(restriction);\n\t}\n\n\tif (IS_ERR(restrict_link)) {\n\t\tret = PTR_ERR(restrict_link);\n\t\tgoto error;\n\t}\n\n\tdown_write(&keyring->sem);\n\tdown_write(&keyring_serialise_restrict_sem);\n\n\tif (keyring->restrict_link)\n\t\tret = -EEXIST;\n\telse if (keyring_detect_restriction_cycle(keyring, restrict_link))\n\t\tret = -EDEADLK;\n\telse\n\t\tkeyring->restrict_link = restrict_link;\n\n\tup_write(&keyring_serialise_restrict_sem);\n\tup_write(&keyring->sem);\n\n\tif (ret < 0) {\n\t\tkey_put(restrict_link->key);\n\t\tkfree(restrict_link);\n\t}\n\nerror:\n\tif (restrict_type)\n\t\tkey_type_put(restrict_type);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(keyring_restrict);\n\n/*\n * Search the given keyring for a key that might be updated.\n *\n * The caller must guarantee that the keyring is a keyring and that the\n * permission is granted to modify the keyring as no check is made here.  The\n * caller must also hold a lock on the keyring semaphore.\n *\n * Returns a pointer to the found key with usage count incremented if\n * successful and returns NULL if not found.  Revoked and invalidated keys are\n * skipped over.\n *\n * If successful, the possession indicator is propagated from the keyring ref\n * to the returned key reference.\n */\nkey_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}\n\n/*\n * Find a keyring with the specified name.\n *\n * Only keyrings that have nonzero refcount, are not revoked, and are owned by a\n * user in the current user namespace are considered.  If @uid_keyring is %true,\n * the keyring additionally must have been allocated as a user or user session\n * keyring; otherwise, it must grant Search permission directly to the caller.\n *\n * Returns a pointer to the keyring with the keyring's refcount having being\n * incremented on success.  -ENOKEY is returned if a key could not be found.\n */\nstruct key *find_keyring_by_name(const char *name, bool uid_keyring)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\n\tif (keyring_name_hash[bucket].next) {\n\t\t/* search this hash bucket for a keyring with a matching name\n\t\t * that's readable and that hasn't been revoked */\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (uid_keyring) {\n\t\t\t\tif (!test_bit(KEY_FLAG_UID_KEYRING,\n\t\t\t\t\t      &keyring->flags))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) */\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}\n\nstatic int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* We might get a keyring with matching index-key that is nonetheless a\n\t * different keyring. */\n\tif (key != ctx->match_data.raw_data)\n\t\treturn 0;\n\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}\n\n/*\n * See if a cycle will will be created by inserting acyclic tree B in acyclic\n * tree A at the topmost level (ie: as a direct child of A).\n *\n * Since we are adding B to A at the top level, checking for cycles should just\n * be a matter of seeing if node A is somewhere in tree B.\n */\nstatic int keyring_detect_cycle(struct key *A, struct key *B)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key\t\t= A->index_key,\n\t\t.match_data.raw_data\t= A,\n\t\t.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.iterator\t\t= keyring_detect_cycle_iterator,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_NO_UPDATE_TIME |\n\t\t\t\t\t   KEYRING_SEARCH_NO_CHECK_PERM |\n\t\t\t\t\t   KEYRING_SEARCH_DETECT_TOO_DEEP),\n\t};\n\n\trcu_read_lock();\n\tsearch_nested_keyrings(B, &ctx);\n\trcu_read_unlock();\n\treturn PTR_ERR(ctx.result) == -EAGAIN ? 0 : PTR_ERR(ctx.result);\n}\n\n/*\n * Preallocate memory so that a key can be linked into to a keyring.\n */\nint __key_link_begin(struct key *keyring,\n\t\t     const struct keyring_index_key *index_key,\n\t\t     struct assoc_array_edit **_edit)\n\t__acquires(&keyring->sem)\n\t__acquires(&keyring_serialise_link_sem)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"%d,%s,%s,\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tBUG_ON(index_key->desc_len == 0);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error_krsem;\n\n\t/* serialise link/link calls to prevent parallel calls causing a cycle\n\t * when linking two keyring in opposite orders */\n\tif (index_key->type == &key_type_keyring)\n\t\tdown_write(&keyring_serialise_link_sem);\n\n\t/* Create an edit script that will insert/replace the key in the\n\t * keyring tree.\n\t */\n\tedit = assoc_array_insert(&keyring->keys,\n\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t  index_key,\n\t\t\t\t  NULL);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error_sem;\n\t}\n\n\t/* If we're not replacing a link in-place then we're going to need some\n\t * extra quota.\n\t */\n\tif (!edit->dead_leaf) {\n\t\tret = key_payload_reserve(keyring,\n\t\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto error_cancel;\n\t}\n\n\t*_edit = edit;\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_cancel:\n\tassoc_array_cancel_edit(edit);\nerror_sem:\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\nerror_krsem:\n\tup_write(&keyring->sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Check already instantiated keys aren't going to be a problem.\n *\n * The caller must have called __key_link_begin(). Don't need to call this for\n * keys that were created since __key_link_begin() was called.\n */\nint __key_link_check_live_key(struct key *keyring, struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\t/* check that we aren't going to create a cycle by linking one\n\t\t * keyring to another */\n\t\treturn keyring_detect_cycle(keyring, key);\n\treturn 0;\n}\n\n/*\n * Link a key into to a keyring.\n *\n * Must be called with __key_link_begin() having being called.  Discards any\n * already extant link to matching key if there is one, so that each keyring\n * holds at most one link to any given key of a particular type+description\n * combination.\n */\nvoid __key_link(struct key *key, struct assoc_array_edit **_edit)\n{\n\t__key_get(key);\n\tassoc_array_insert_set_object(*_edit, keyring_key_to_ptr(key));\n\tassoc_array_apply_edit(*_edit);\n\t*_edit = NULL;\n}\n\n/*\n * Finish linking a key into to a keyring.\n *\n * Must be called with __key_link_begin() having being called.\n */\nvoid __key_link_end(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key,\n\t\t    struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\n\tif (edit) {\n\t\tif (!edit->dead_leaf) {\n\t\t\tkey_payload_reserve(keyring,\n\t\t\t\tkeyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\t}\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}\n\n/*\n * Check addition of keys to restricted keyrings.\n */\nstatic int __key_link_check_restriction(struct key *keyring, struct key *key)\n{\n\tif (!keyring->restrict_link || !keyring->restrict_link->check)\n\t\treturn 0;\n\treturn keyring->restrict_link->check(keyring, key->type, &key->payload,\n\t\t\t\t\t     keyring->restrict_link->key);\n}\n\n/**\n * key_link - Link a key to a keyring\n * @keyring: The keyring to make the link in.\n * @key: The key to link to.\n *\n * Make a link in a keyring to a key, such that the keyring holds a reference\n * on that key and the key can potentially be found by searching that keyring.\n *\n * This function will write-lock the keyring's semaphore and will consume some\n * of the user's key data quota to hold the link.\n *\n * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring,\n * -EKEYREVOKED if the keyring has been revoked, -ENFILE if the keyring is\n * full, -EDQUOT if there is insufficient key data quota remaining to add\n * another link or -ENOMEM if there's insufficient memory.\n *\n * It is assumed that the caller has checked that it is permitted for a link to\n * be made (the keyring should have Write permission and the key Link\n * permission).\n */\nint key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\t\tret = __key_link_check_restriction(keyring, key);\n\t\tif (ret == 0)\n\t\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}\nEXPORT_SYMBOL(key_link);\n\n/**\n * key_unlink - Unlink the first link to a key from a keyring.\n * @keyring: The keyring to remove the link from.\n * @key: The key the link is to.\n *\n * Remove a link from a keyring to a key.\n *\n * This function will write-lock the keyring's semaphore.\n *\n * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring, -ENOENT if\n * the key isn't linked to by the keyring or -ENOMEM if there's insufficient\n * memory.\n *\n * It is assumed that the caller has checked that it is permitted for a link to\n * be removed (the keyring should have Write permission; no permissions are\n * required on the key).\n */\nint key_unlink(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  &key->index_key);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error;\n\t}\n\tret = -ENOENT;\n\tif (edit == NULL)\n\t\tgoto error;\n\n\tassoc_array_apply_edit(edit);\n\tkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\n\tret = 0;\n\nerror:\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_unlink);\n\n/**\n * keyring_clear - Clear a keyring\n * @keyring: The keyring to clear.\n *\n * Clear the contents of the specified keyring.\n *\n * Returns 0 if successful or -ENOTDIR if the keyring isn't a keyring.\n */\nint keyring_clear(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t} else {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t\tret = 0;\n\t}\n\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(keyring_clear);\n\n/*\n * Dispose of the links from a revoked keyring.\n *\n * This is called with the key sem write-locked.\n */\nstatic void keyring_revoke(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (!IS_ERR(edit)) {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t}\n}\n\nstatic bool keyring_gc_select_iterator(void *object, void *iterator_data)\n{\n\tstruct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tif (key_is_dead(key, *limit))\n\t\treturn false;\n\tkey_get(key);\n\treturn true;\n}\n\nstatic int keyring_gc_check_iterator(const void *object, void *iterator_data)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tkey_check(key);\n\treturn key_is_dead(key, *limit);\n}\n\n/*\n * Garbage collect pointers from a keyring.\n *\n * Not called with any locks held.  The keyring's key struct will not be\n * deallocated under us as only our caller may deallocate it.\n */\nvoid keyring_gc(struct key *keyring, time_t limit)\n{\n\tint result;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto dont_gc;\n\n\t/* scan the keyring looking for dead keys */\n\trcu_read_lock();\n\tresult = assoc_array_iterate(&keyring->keys,\n\t\t\t\t     keyring_gc_check_iterator, &limit);\n\trcu_read_unlock();\n\tif (result == true)\n\t\tgoto do_gc;\n\ndont_gc:\n\tkleave(\" [no gc]\");\n\treturn;\n\ndo_gc:\n\tdown_write(&keyring->sem);\n\tassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\n\t\t       keyring_gc_select_iterator, &limit);\n\tup_write(&keyring->sem);\n\tkleave(\" [gc]\");\n}\n\n/*\n * Garbage collect restriction pointers from a keyring.\n *\n * Keyring restrictions are associated with a key type, and must be cleaned\n * up if the key type is unregistered. The restriction is altered to always\n * reject additional keys so a keyring cannot be opened up by unregistering\n * a key type.\n *\n * Not called with any keyring locks held. The keyring's key struct will not\n * be deallocated under us as only our caller may deallocate it.\n *\n * The caller is required to hold key_types_sem and dead_type->sem. This is\n * fulfilled by key_gc_keytype() holding the locks on behalf of\n * key_garbage_collector(), which it invokes on a workqueue.\n */\nvoid keyring_restriction_gc(struct key *keyring, struct key_type *dead_type)\n{\n\tstruct key_restriction *keyres;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\t/*\n\t * keyring->restrict_link is only assigned at key allocation time\n\t * or with the key type locked, so the only values that could be\n\t * concurrently assigned to keyring->restrict_link are for key\n\t * types other than dead_type. Given this, it's ok to check\n\t * the key type before acquiring keyring->sem.\n\t */\n\tif (!dead_type || !keyring->restrict_link ||\n\t    keyring->restrict_link->keytype != dead_type) {\n\t\tkleave(\" [no restriction gc]\");\n\t\treturn;\n\t}\n\n\t/* Lock the keyring to ensure that a link is not in progress */\n\tdown_write(&keyring->sem);\n\n\tkeyres = keyring->restrict_link;\n\n\tkeyres->check = restrict_link_reject;\n\n\tkey_put(keyres->key);\n\tkeyres->key = NULL;\n\tkeyres->keytype = NULL;\n\n\tup_write(&keyring->sem);\n\n\tkleave(\" [restriction gc]\");\n}\n", "/* procfs files for key database enumeration\n *\n * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <asm/errno.h>\n#include \"internal.h\"\n\nstatic int proc_keys_open(struct inode *inode, struct file *file);\nstatic void *proc_keys_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos);\nstatic void proc_keys_stop(struct seq_file *p, void *v);\nstatic int proc_keys_show(struct seq_file *m, void *v);\n\nstatic const struct seq_operations proc_keys_ops = {\n\t.start\t= proc_keys_start,\n\t.next\t= proc_keys_next,\n\t.stop\t= proc_keys_stop,\n\t.show\t= proc_keys_show,\n};\n\nstatic const struct file_operations proc_keys_fops = {\n\t.open\t\t= proc_keys_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic int proc_key_users_open(struct inode *inode, struct file *file);\nstatic void *proc_key_users_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos);\nstatic void proc_key_users_stop(struct seq_file *p, void *v);\nstatic int proc_key_users_show(struct seq_file *m, void *v);\n\nstatic const struct seq_operations proc_key_users_ops = {\n\t.start\t= proc_key_users_start,\n\t.next\t= proc_key_users_next,\n\t.stop\t= proc_key_users_stop,\n\t.show\t= proc_key_users_show,\n};\n\nstatic const struct file_operations proc_key_users_fops = {\n\t.open\t\t= proc_key_users_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\n/*\n * Declare the /proc files.\n */\nstatic int __init key_proc_init(void)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create(\"keys\", 0, NULL, &proc_keys_fops);\n\tif (!p)\n\t\tpanic(\"Cannot create /proc/keys\\n\");\n\n\tp = proc_create(\"key-users\", 0, NULL, &proc_key_users_fops);\n\tif (!p)\n\t\tpanic(\"Cannot create /proc/key-users\\n\");\n\n\treturn 0;\n}\n\n__initcall(key_proc_init);\n\n/*\n * Implement \"/proc/keys\" to provide a list of the keys on the system that\n * grant View permission to the caller.\n */\nstatic struct rb_node *key_serial_next(struct seq_file *p, struct rb_node *n)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\n\tn = rb_next(n);\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (kuid_has_mapping(user_ns, key->user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}\n\nstatic int proc_keys_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_keys_ops);\n}\n\nstatic struct key *find_ge_key(struct seq_file *p, key_serial_t id)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\tstruct rb_node *n = key_serial_tree.rb_node;\n\tstruct key *minkey = NULL;\n\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (id < key->serial) {\n\t\t\tif (!minkey || minkey->serial > key->serial)\n\t\t\t\tminkey = key;\n\t\t\tn = n->rb_left;\n\t\t} else if (id > key->serial) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tminkey = key;\n\t\t\tbreak;\n\t\t}\n\t\tkey = NULL;\n\t}\n\n\tif (!minkey)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tif (kuid_has_mapping(user_ns, minkey->user->uid))\n\t\t\treturn minkey;\n\t\tn = rb_next(&minkey->serial_node);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tminkey = rb_entry(n, struct key, serial_node);\n\t}\n}\n\nstatic void *proc_keys_start(struct seq_file *p, loff_t *_pos)\n\t__acquires(key_serial_lock)\n{\n\tkey_serial_t pos = *_pos;\n\tstruct key *key;\n\n\tspin_lock(&key_serial_lock);\n\n\tif (*_pos > INT_MAX)\n\t\treturn NULL;\n\tkey = find_ge_key(p, pos);\n\tif (!key)\n\t\treturn NULL;\n\t*_pos = key->serial;\n\treturn &key->serial_node;\n}\n\nstatic inline key_serial_t key_node_serial(struct rb_node *n)\n{\n\tstruct key *key = rb_entry(n, struct key, serial_node);\n\treturn key->serial;\n}\n\nstatic void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos)\n{\n\tstruct rb_node *n;\n\n\tn = key_serial_next(p, v);\n\tif (n)\n\t\t*_pos = key_node_serial(n);\n\treturn n;\n}\n\nstatic void proc_keys_stop(struct seq_file *p, void *v)\n\t__releases(key_serial_lock)\n{\n\tspin_unlock(&key_serial_lock);\n}\n\nstatic int proc_keys_show(struct seq_file *m, void *v)\n{\n\tstruct rb_node *_p = v;\n\tstruct key *key = rb_entry(_p, struct key, serial_node);\n\tstruct timespec now;\n\tunsigned long timo;\n\tkey_ref_t key_ref, skey_ref;\n\tchar xbuf[16];\n\tint rc;\n\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= key->type,\n\t\t.index_key.description\t= key->description,\n\t\t.cred\t\t\t= m->file->f_cred,\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.raw_data\t= key,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\n\tkey_ref = make_key_ref(key, 0);\n\n\t/* determine if the key is possessed by this process (a test we can\n\t * skip if the key does not indicate the possessor can view it\n\t */\n\tif (key->perm & KEY_POS_VIEW) {\n\t\tskey_ref = search_my_process_keyrings(&ctx);\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_ref_put(skey_ref);\n\t\t\tkey_ref = make_key_ref(key, 1);\n\t\t}\n\t}\n\n\t/* check whether the current task is allowed to view the key */\n\trc = key_task_permission(key_ref, ctx.cred, KEY_NEED_VIEW);\n\tif (rc < 0)\n\t\treturn 0;\n\n\tnow = current_kernel_time();\n\n\trcu_read_lock();\n\n\t/* come up with a suitable timeout value */\n\tif (key->expiry == 0) {\n\t\tmemcpy(xbuf, \"perm\", 5);\n\t} else if (now.tv_sec >= key->expiry) {\n\t\tmemcpy(xbuf, \"expd\", 5);\n\t} else {\n\t\ttimo = key->expiry - now.tv_sec;\n\n\t\tif (timo < 60)\n\t\t\tsprintf(xbuf, \"%lus\", timo);\n\t\telse if (timo < 60*60)\n\t\t\tsprintf(xbuf, \"%lum\", timo / 60);\n\t\telse if (timo < 60*60*24)\n\t\t\tsprintf(xbuf, \"%luh\", timo / (60*60));\n\t\telse if (timo < 60*60*24*7)\n\t\t\tsprintf(xbuf, \"%lud\", timo / (60*60*24));\n\t\telse\n\t\t\tsprintf(xbuf, \"%luw\", timo / (60*60*24*7));\n\t}\n\n#define showflag(KEY, LETTER, FLAG) \\\n\t(test_bit(FLAG,\t&(KEY)->flags) ? LETTER : '-')\n\n\tseq_printf(m, \"%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s \",\n\t\t   key->serial,\n\t\t   showflag(key, 'I', KEY_FLAG_INSTANTIATED),\n\t\t   showflag(key, 'R', KEY_FLAG_REVOKED),\n\t\t   showflag(key, 'D', KEY_FLAG_DEAD),\n\t\t   showflag(key, 'Q', KEY_FLAG_IN_QUOTA),\n\t\t   showflag(key, 'U', KEY_FLAG_USER_CONSTRUCT),\n\t\t   showflag(key, 'N', KEY_FLAG_NEGATIVE),\n\t\t   showflag(key, 'i', KEY_FLAG_INVALIDATED),\n\t\t   refcount_read(&key->usage),\n\t\t   xbuf,\n\t\t   key->perm,\n\t\t   from_kuid_munged(seq_user_ns(m), key->uid),\n\t\t   from_kgid_munged(seq_user_ns(m), key->gid),\n\t\t   key->type->name);\n\n#undef showflag\n\n\tif (key->type->describe)\n\t\tkey->type->describe(key, m);\n\tseq_putc(m, '\\n');\n\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic struct rb_node *__key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\twhile (n) {\n\t\tstruct key_user *user = rb_entry(n, struct key_user, node);\n\t\tif (kuid_has_mapping(user_ns, user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}\n\nstatic struct rb_node *key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\treturn __key_user_next(user_ns, rb_next(n));\n}\n\nstatic struct rb_node *key_user_first(struct user_namespace *user_ns, struct rb_root *r)\n{\n\tstruct rb_node *n = rb_first(r);\n\treturn __key_user_next(user_ns, n);\n}\n\n/*\n * Implement \"/proc/key-users\" to provides a list of the key users and their\n * quotas.\n */\nstatic int proc_key_users_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_key_users_ops);\n}\n\nstatic void *proc_key_users_start(struct seq_file *p, loff_t *_pos)\n\t__acquires(key_user_lock)\n{\n\tstruct rb_node *_p;\n\tloff_t pos = *_pos;\n\n\tspin_lock(&key_user_lock);\n\n\t_p = key_user_first(seq_user_ns(p), &key_user_tree);\n\twhile (pos > 0 && _p) {\n\t\tpos--;\n\t\t_p = key_user_next(seq_user_ns(p), _p);\n\t}\n\n\treturn _p;\n}\n\nstatic void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos)\n{\n\t(*_pos)++;\n\treturn key_user_next(seq_user_ns(p), (struct rb_node *)v);\n}\n\nstatic void proc_key_users_stop(struct seq_file *p, void *v)\n\t__releases(key_user_lock)\n{\n\tspin_unlock(&key_user_lock);\n}\n\nstatic int proc_key_users_show(struct seq_file *m, void *v)\n{\n\tstruct rb_node *_p = v;\n\tstruct key_user *user = rb_entry(_p, struct key_user, node);\n\tunsigned maxkeys = uid_eq(user->uid, GLOBAL_ROOT_UID) ?\n\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\tunsigned maxbytes = uid_eq(user->uid, GLOBAL_ROOT_UID) ?\n\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\tseq_printf(m, \"%5u: %5d %d/%d %d/%d %d/%d\\n\",\n\t\t   from_kuid_munged(seq_user_ns(m), user->uid),\n\t\t   refcount_read(&user->usage),\n\t\t   atomic_read(&user->nkeys),\n\t\t   atomic_read(&user->nikeys),\n\t\t   user->qnkeys,\n\t\t   maxkeys,\n\t\t   user->qnbytes,\n\t\t   maxbytes);\n\n\treturn 0;\n}\n", "/* Manage a process's keyrings\n *\n * Copyright (C) 2004-2005, 2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/user.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/user_namespace.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n/* Session keyring create vs join semaphore */\nstatic DEFINE_MUTEX(key_session_mutex);\n\n/* User keyring creation semaphore */\nstatic DEFINE_MUTEX(key_user_keyring_mutex);\n\n/* The root user's tracking struct */\nstruct key_user root_key_user = {\n\t.usage\t\t= REFCOUNT_INIT(3),\n\t.cons_lock\t= __MUTEX_INITIALIZER(root_key_user.cons_lock),\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(root_key_user.lock),\n\t.nkeys\t\t= ATOMIC_INIT(2),\n\t.nikeys\t\t= ATOMIC_INIT(2),\n\t.uid\t\t= GLOBAL_ROOT_UID,\n};\n\n/*\n * Install the user and user session keyrings for the current process's UID.\n */\nint install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\n\tkenter(\"%p{%u}\", user, uid);\n\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user->uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_UID_KEYRING |\n\t\t\t\t\t\t\tKEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_UID_KEYRING |\n\t\t\t\t\t\t  KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Install a thread keyring to the given credentials struct if it didn't have\n * one already.  This is allowed to overrun the quota.\n *\n * Return: 0 if a thread keyring is now present; -errno on failure.\n */\nint install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->thread_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}\n\n/*\n * Install a thread keyring to the current task if it didn't have one already.\n *\n * Return: 0 if a thread keyring is now present; -errno on failure.\n */\nstatic int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Install a process keyring to the given credentials struct if it didn't have\n * one already.  This is allowed to overrun the quota.\n *\n * Return: 0 if a process keyring is now present; -errno on failure.\n */\nint install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}\n\n/*\n * Install a process keyring to the current task if it didn't have one already.\n *\n * Return: 0 if a process keyring is now present; -errno on failure.\n */\nstatic int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Install the given keyring as the session keyring of the given credentials\n * struct, replacing the existing one if any.  If the given keyring is NULL,\n * then install a new anonymous session keyring.\n *\n * Return: 0 on success; -errno on failure.\n */\nint install_session_keyring_to_cred(struct cred *cred, struct key *keyring)\n{\n\tunsigned long flags;\n\tstruct key *old;\n\n\tmight_sleep();\n\n\t/* create an empty session keyring */\n\tif (!keyring) {\n\t\tflags = KEY_ALLOC_QUOTA_OVERRUN;\n\t\tif (cred->session_keyring)\n\t\t\tflags = KEY_ALLOC_IN_QUOTA;\n\n\t\tkeyring = keyring_alloc(\"_ses\", cred->uid, cred->gid, cred,\n\t\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\t\tflags, NULL, NULL);\n\t\tif (IS_ERR(keyring))\n\t\t\treturn PTR_ERR(keyring);\n\t} else {\n\t\t__key_get(keyring);\n\t}\n\n\t/* install the keyring */\n\told = cred->session_keyring;\n\trcu_assign_pointer(cred->session_keyring, keyring);\n\n\tif (old)\n\t\tkey_put(old);\n\n\treturn 0;\n}\n\n/*\n * Install the given keyring as the session keyring of the current task,\n * replacing the existing one if any.  If the given keyring is NULL, then\n * install a new anonymous session keyring.\n *\n * Return: 0 on success; -errno on failure.\n */\nstatic int install_session_keyring(struct key *keyring)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Handle the fsuid changing.\n */\nvoid key_fsuid_changed(struct task_struct *tsk)\n{\n\t/* update the ownership of the thread keyring */\n\tBUG_ON(!tsk->cred);\n\tif (tsk->cred->thread_keyring) {\n\t\tdown_write(&tsk->cred->thread_keyring->sem);\n\t\ttsk->cred->thread_keyring->uid = tsk->cred->fsuid;\n\t\tup_write(&tsk->cred->thread_keyring->sem);\n\t}\n}\n\n/*\n * Handle the fsgid changing.\n */\nvoid key_fsgid_changed(struct task_struct *tsk)\n{\n\t/* update the ownership of the thread keyring */\n\tBUG_ON(!tsk->cred);\n\tif (tsk->cred->thread_keyring) {\n\t\tdown_write(&tsk->cred->thread_keyring->sem);\n\t\ttsk->cred->thread_keyring->gid = tsk->cred->fsgid;\n\t\tup_write(&tsk->cred->thread_keyring->sem);\n\t}\n}\n\n/*\n * Search the process keyrings attached to the supplied cred for the first\n * matching key.\n *\n * The search criteria are the type and the match function.  The description is\n * given to the match function as a parameter, but doesn't otherwise influence\n * the search.  Typically the match function will compare the description\n * parameter to the key's description.\n *\n * This can only search keyrings that grant Search permission to the supplied\n * credentials.  Keyrings linked to searched keyrings will also be searched if\n * they grant Search permission too.  Keys can only be found if they grant\n * Search permission to the credentials.\n *\n * Returns a pointer to the key with the key usage count incremented if\n * successful, -EAGAIN if we didn't find any matching key or -ENOKEY if we only\n * matched negative keys.\n *\n * In the case of a successful return, the possession attribute is set on the\n * returned key reference.\n */\nkey_ref_t search_my_process_keyrings(struct keyring_search_context *ctx)\n{\n\tkey_ref_t key_ref, ret, err;\n\n\t/* we want to return -EAGAIN or -ENOKEY if any of the keyrings were\n\t * searchable, but we failed to find a key or we found a negative key;\n\t * otherwise we want to return a sample error (probably -EACCES) if\n\t * none of the keyrings were searchable\n\t *\n\t * in terms of priority: success > -ENOKEY > -EAGAIN > other error\n\t */\n\tkey_ref = NULL;\n\tret = NULL;\n\terr = ERR_PTR(-EAGAIN);\n\n\t/* search the thread keyring first */\n\tif (ctx->cred->thread_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->thread_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the process keyring second */\n\tif (ctx->cred->process_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->process_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the session keyring */\n\tif (ctx->cred->session_keyring) {\n\t\trcu_read_lock();\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(rcu_dereference(ctx->cred->session_keyring), 1),\n\t\t\tctx);\n\t\trcu_read_unlock();\n\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* or search the user-session keyring */\n\telse if (ctx->cred->user->session_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->user->session_keyring, 1),\n\t\t\tctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tkey_ref = ret ? ret : err;\n\nfound:\n\treturn key_ref;\n}\n\n/*\n * Search the process keyrings attached to the supplied cred for the first\n * matching key in the manner of search_my_process_keyrings(), but also search\n * the keys attached to the assumed authorisation key using its credentials if\n * one is available.\n *\n * Return same as search_my_process_keyrings().\n */\nkey_ref_t search_process_keyrings(struct keyring_search_context *ctx)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\n\tmight_sleep();\n\n\tkey_ref = search_my_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\n\t/* if this process has an instantiation authorisation key, then we also\n\t * search the keyrings of the process mentioned there\n\t * - we don't permit access to request_key auth keys via this method\n\t */\n\tif (ctx->cred->request_key_auth &&\n\t    ctx->cred == current_cred() &&\n\t    ctx->index_key.type != &key_type_request_key_auth\n\t    ) {\n\t\tconst struct cred *cred = ctx->cred;\n\n\t\t/* defend against the auth key being revoked */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\tif (key_validate(ctx->cred->request_key_auth) == 0) {\n\t\t\trka = ctx->cred->request_key_auth->payload.data[0];\n\n\t\t\tctx->cred = rka->cred;\n\t\t\tkey_ref = search_process_keyrings(ctx);\n\t\t\tctx->cred = cred;\n\n\t\t\tup_read(&cred->request_key_auth->sem);\n\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\n\nfound:\n\treturn key_ref;\n}\n\n/*\n * See if the key we're looking at is the target key.\n */\nbool lookup_user_key_possessed(const struct key *key,\n\t\t\t       const struct key_match_data *match_data)\n{\n\treturn key == match_data->raw_data;\n}\n\n/*\n * Look up a key ID given us by userspace with a given permissions mask to get\n * the key it refers to.\n *\n * Flags can be passed to request that special keyrings be created if referred\n * to directly, to permit partially constructed keys to be found and to skip\n * validity and permission checks on the found key.\n *\n * Returns a pointer to the key with an incremented usage count if successful;\n * -EINVAL if the key ID is invalid; -ENOKEY if the key ID does not correspond\n * to a key or the best found key was a negative key; -EKEYREVOKED or\n * -EKEYEXPIRED if the best found key was revoked or expired; -EACCES if the\n * found key doesn't grant the requested permit or the LSM denied access to it;\n * or -ENOMEM if a special keyring couldn't be created.\n *\n * In the case of a successful return, the possession attribute is set on the\n * returned key reference.\n */\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    !test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = current_kernel_time().tv_sec;\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}\n\n/*\n * Join the named keyring as the session keyring if possible else attempt to\n * create a new one of that name and join that.\n *\n * If the name is NULL, an empty anonymous keyring will be installed as the\n * session keyring.\n *\n * Named session keyrings are joined with a semaphore held to prevent the\n * keyrings from going away whilst the attempt is made to going them and also\n * to prevent a race in creating compatible session keyrings.\n */\nlong join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\t/* if no name is provided, install an anonymous keyring */\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\n\t/* allow the user to join or create a named keyring */\n\tmutex_lock(&key_session_mutex);\n\n\t/* look for an existing keyring of this name */\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\t/* not found - try and create a new one */\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error2;\n\t} else if (keyring == new->session_keyring) {\n\t\tret = 0;\n\t\tgoto error3;\n\t}\n\n\t/* we've got a keyring - now to install it */\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error3;\n\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\n\nerror3:\n\tkey_put(keyring);\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n/*\n * Replace a process's session keyring on behalf of one of its children when\n * the target  process is about to resume userspace execution.\n */\nvoid key_change_session_keyring(struct callback_head *twork)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = container_of(twork, struct cred, rcu);\n\n\tif (unlikely(current->flags & PF_EXITING)) {\n\t\tput_cred(new);\n\t\treturn;\n\t}\n\n\tnew->  uid\t= old->  uid;\n\tnew-> euid\t= old-> euid;\n\tnew-> suid\t= old-> suid;\n\tnew->fsuid\t= old->fsuid;\n\tnew->  gid\t= old->  gid;\n\tnew-> egid\t= old-> egid;\n\tnew-> sgid\t= old-> sgid;\n\tnew->fsgid\t= old->fsgid;\n\tnew->user\t= get_uid(old->user);\n\tnew->user_ns\t= get_user_ns(old->user_ns);\n\tnew->group_info\t= get_group_info(old->group_info);\n\n\tnew->securebits\t= old->securebits;\n\tnew->cap_inheritable\t= old->cap_inheritable;\n\tnew->cap_permitted\t= old->cap_permitted;\n\tnew->cap_effective\t= old->cap_effective;\n\tnew->cap_ambient\t= old->cap_ambient;\n\tnew->cap_bset\t\t= old->cap_bset;\n\n\tnew->jit_keyring\t= old->jit_keyring;\n\tnew->thread_keyring\t= key_get(old->thread_keyring);\n\tnew->process_keyring\t= key_get(old->process_keyring);\n\n\tsecurity_transfer_creds(new, old);\n\n\tcommit_creds(new);\n}\n\n/*\n * Make sure that root's user and user-session keyrings exist.\n */\nstatic int __init init_root_keyring(void)\n{\n\treturn install_user_keyrings();\n}\n\nlate_initcall(init_root_keyring);\n", "/* Request a key from userspace\n *\n * Copyright (C) 2004-2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * See Documentation/security/keys/request-key.rst\n */\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kmod.h>\n#include <linux/err.h>\n#include <linux/keyctl.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\n#define key_negative_timeout\t60\t/* default timeout on a negative key's existence */\n\n/**\n * complete_request_key - Complete the construction of a key.\n * @cons: The key construction record.\n * @error: The success or failute of the construction.\n *\n * Complete the attempt to construct a key.  The key will be negated\n * if an error is indicated.  The authorisation key will be revoked\n * unconditionally.\n */\nvoid complete_request_key(struct key_construction *cons, int error)\n{\n\tkenter(\"{%d,%d},%d\", cons->key->serial, cons->authkey->serial, error);\n\n\tif (error < 0)\n\t\tkey_negate_and_link(cons->key, key_negative_timeout, NULL,\n\t\t\t\t    cons->authkey);\n\telse\n\t\tkey_revoke(cons->authkey);\n\n\tkey_put(cons->key);\n\tkey_put(cons->authkey);\n\tkfree(cons);\n}\nEXPORT_SYMBOL(complete_request_key);\n\n/*\n * Initialise a usermode helper that is going to have a specific session\n * keyring.\n *\n * This is called in context of freshly forked kthread before kernel_execve(),\n * so we can simply install the desired session_keyring at this point.\n */\nstatic int umh_keys_init(struct subprocess_info *info, struct cred *cred)\n{\n\tstruct key *keyring = info->data;\n\n\treturn install_session_keyring_to_cred(cred, keyring);\n}\n\n/*\n * Clean up a usermode helper with session keyring.\n */\nstatic void umh_keys_cleanup(struct subprocess_info *info)\n{\n\tstruct key *keyring = info->data;\n\tkey_put(keyring);\n}\n\n/*\n * Call a usermode helper with a specific session keyring.\n */\nstatic int call_usermodehelper_keys(const char *path, char **argv, char **envp,\n\t\t\t\t\tstruct key *session_keyring, int wait)\n{\n\tstruct subprocess_info *info;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t  umh_keys_init, umh_keys_cleanup,\n\t\t\t\t\t  session_keyring);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tkey_get(session_keyring);\n\treturn call_usermodehelper_exec(info, wait);\n}\n\n/*\n * Request userspace finish the construction of a key\n * - execute \"/sbin/request-key <op> <key> <uid> <gid> <keyring> <keyring> <keyring>\"\n */\nstatic int call_sbin_request_key(struct key_construction *cons,\n\t\t\t\t const char *op,\n\t\t\t\t void *aux)\n{\n\tstatic char const request_key[] = \"/sbin/request-key\";\n\tconst struct cred *cred = current_cred();\n\tkey_serial_t prkey, sskey;\n\tstruct key *key = cons->key, *authkey = cons->authkey, *keyring,\n\t\t*session;\n\tchar *argv[9], *envp[3], uid_str[12], gid_str[12];\n\tchar key_str[12], keyring_str[3][12];\n\tchar desc[20];\n\tint ret, i;\n\n\tkenter(\"{%d},{%d},%s\", key->serial, authkey->serial, op);\n\n\tret = install_user_keyrings();\n\tif (ret < 0)\n\t\tgoto error_alloc;\n\n\t/* allocate a new session keyring */\n\tsprintf(desc, \"_req.%u\", key->serial);\n\n\tcred = get_current_cred();\n\tkeyring = keyring_alloc(desc, cred->fsuid, cred->fsgid, cred,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN, NULL, NULL);\n\tput_cred(cred);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error_alloc;\n\t}\n\n\t/* attach the auth key to the session keyring */\n\tret = key_link(keyring, authkey);\n\tif (ret < 0)\n\t\tgoto error_link;\n\n\t/* record the UID and GID */\n\tsprintf(uid_str, \"%d\", from_kuid(&init_user_ns, cred->fsuid));\n\tsprintf(gid_str, \"%d\", from_kgid(&init_user_ns, cred->fsgid));\n\n\t/* we say which key is under construction */\n\tsprintf(key_str, \"%d\", key->serial);\n\n\t/* we specify the process's default keyrings */\n\tsprintf(keyring_str[0], \"%d\",\n\t\tcred->thread_keyring ? cred->thread_keyring->serial : 0);\n\n\tprkey = 0;\n\tif (cred->process_keyring)\n\t\tprkey = cred->process_keyring->serial;\n\tsprintf(keyring_str[1], \"%d\", prkey);\n\n\trcu_read_lock();\n\tsession = rcu_dereference(cred->session_keyring);\n\tif (!session)\n\t\tsession = cred->user->session_keyring;\n\tsskey = session->serial;\n\trcu_read_unlock();\n\n\tsprintf(keyring_str[2], \"%d\", sskey);\n\n\t/* set up a minimal environment */\n\ti = 0;\n\tenvp[i++] = \"HOME=/\";\n\tenvp[i++] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[i] = NULL;\n\n\t/* set up the argument list */\n\ti = 0;\n\targv[i++] = (char *)request_key;\n\targv[i++] = (char *) op;\n\targv[i++] = key_str;\n\targv[i++] = uid_str;\n\targv[i++] = gid_str;\n\targv[i++] = keyring_str[0];\n\targv[i++] = keyring_str[1];\n\targv[i++] = keyring_str[2];\n\targv[i] = NULL;\n\n\t/* do it */\n\tret = call_usermodehelper_keys(request_key, argv, envp, keyring,\n\t\t\t\t       UMH_WAIT_PROC);\n\tkdebug(\"usermode -> 0x%x\", ret);\n\tif (ret >= 0) {\n\t\t/* ret is the exit/wait code */\n\t\tif (test_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags) ||\n\t\t    key_validate(key) < 0)\n\t\t\tret = -ENOKEY;\n\t\telse\n\t\t\t/* ignore any errors from userspace if the key was\n\t\t\t * instantiated */\n\t\t\tret = 0;\n\t}\n\nerror_link:\n\tkey_put(keyring);\n\nerror_alloc:\n\tcomplete_request_key(cons, ret);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Call out to userspace for key construction.\n *\n * Program failure is ignored in favour of key status.\n */\nstatic int construct_key(struct key *key, const void *callout_info,\n\t\t\t size_t callout_len, void *aux,\n\t\t\t struct key *dest_keyring)\n{\n\tstruct key_construction *cons;\n\trequest_key_actor_t actor;\n\tstruct key *authkey;\n\tint ret;\n\n\tkenter(\"%d,%p,%zu,%p\", key->serial, callout_info, callout_len, aux);\n\n\tcons = kmalloc(sizeof(*cons), GFP_KERNEL);\n\tif (!cons)\n\t\treturn -ENOMEM;\n\n\t/* allocate an authorisation key */\n\tauthkey = request_key_auth_new(key, callout_info, callout_len,\n\t\t\t\t       dest_keyring);\n\tif (IS_ERR(authkey)) {\n\t\tkfree(cons);\n\t\tret = PTR_ERR(authkey);\n\t\tauthkey = NULL;\n\t} else {\n\t\tcons->authkey = key_get(authkey);\n\t\tcons->key = key_get(key);\n\n\t\t/* make the call */\n\t\tactor = call_sbin_request_key;\n\t\tif (key->type->request_key)\n\t\t\tactor = key->type->request_key;\n\n\t\tret = actor(cons, \"create\", aux);\n\n\t\t/* check that the actor called complete_request_key() prior to\n\t\t * returning an error */\n\t\tWARN_ON(ret < 0 &&\n\t\t\t!test_bit(KEY_FLAG_REVOKED, &authkey->flags));\n\t\tkey_put(authkey);\n\t}\n\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Get the appropriate destination keyring for the request.\n *\n * The keyring selected is returned with an extra reference upon it which the\n * caller must release.\n */\nstatic void construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\n\tkenter(\"%p\", dest_keyring);\n\n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n\t\t/* the caller supplied one */\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\t/* use a default keyring; falling through the cases until we\n\t\t * find one that we actually have */\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n}\n\n/*\n * Allocate a new key in under-construction state and attempt to link it in to\n * the requested keyring.\n *\n * May return a key that's already under construction instead if there was a\n * race between two thread calling request_key().\n */\nstatic int construct_alloc_key(struct keyring_search_context *ctx,\n\t\t\t       struct key *dest_keyring,\n\t\t\t       unsigned long flags,\n\t\t\t       struct key_user *user,\n\t\t\t       struct key **_key)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct key *key;\n\tkey_perm_t perm;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,,,\",\n\t       ctx->index_key.type->name, ctx->index_key.description);\n\n\t*_key = NULL;\n\tmutex_lock(&user->cons_lock);\n\n\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\tperm |= KEY_USR_VIEW;\n\tif (ctx->index_key.type->read)\n\t\tperm |= KEY_POS_READ;\n\tif (ctx->index_key.type == &key_type_keyring ||\n\t    ctx->index_key.type->update)\n\t\tperm |= KEY_POS_WRITE;\n\n\tkey = key_alloc(ctx->index_key.type, ctx->index_key.description,\n\t\t\tctx->cred->fsuid, ctx->cred->fsgid, ctx->cred,\n\t\t\tperm, flags, NULL);\n\tif (IS_ERR(key))\n\t\tgoto alloc_failed;\n\n\tset_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags);\n\n\tif (dest_keyring) {\n\t\tret = __key_link_begin(dest_keyring, &ctx->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_prealloc_failed;\n\t}\n\n\t/* attach the key to the destination keyring under lock, but we do need\n\t * to do another check just in case someone beat us to it whilst we\n\t * waited for locks */\n\tmutex_lock(&key_construction_mutex);\n\n\tkey_ref = search_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto key_already_present;\n\n\tif (dest_keyring)\n\t\t__key_link(key, &edit);\n\n\tmutex_unlock(&key_construction_mutex);\n\tif (dest_keyring)\n\t\t__key_link_end(dest_keyring, &ctx->index_key, edit);\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = 0 [%d]\", key_serial(key));\n\treturn 0;\n\n\t/* the key is now present - we tell the caller that we found it by\n\t * returning -EINPROGRESS  */\nkey_already_present:\n\tkey_put(key);\n\tmutex_unlock(&key_construction_mutex);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (dest_keyring) {\n\t\tret = __key_link_check_live_key(dest_keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(dest_keyring, &ctx->index_key, edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_check_failed;\n\t}\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = -EINPROGRESS [%d]\", key_serial(key));\n\treturn -EINPROGRESS;\n\nlink_check_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkey_put(key);\n\tkleave(\" = %d [linkcheck]\", ret);\n\treturn ret;\n\nlink_prealloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkey_put(key);\n\tkleave(\" = %d [prelink]\", ret);\n\treturn ret;\n\nalloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkleave(\" = %ld\", PTR_ERR(key));\n\treturn PTR_ERR(key);\n}\n\n/*\n * Commence key construction.\n */\nstatic struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\"\");\n\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconstruct_get_dest_keyring(&dest_keyring);\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto couldnt_alloc_key;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\ncouldnt_alloc_key:\n\tkey_put(dest_keyring);\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n/**\n * request_key_and_link - Request a key and cache it in a keyring.\n * @type: The type of key we want.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n * @dest_keyring: Where to cache the key.\n * @flags: Flags to key_alloc().\n *\n * A key matching the specified criteria is searched for in the process's\n * keyrings and returned with its usage count incremented if found.  Otherwise,\n * if callout_info is not NULL, a key will be allocated and some service\n * (probably in userspace) will be asked to instantiate it.\n *\n * If successfully found or created, the key will be linked to the destination\n * keyring if one is provided.\n *\n * Returns a pointer to the key if successful; -EACCES, -ENOKEY, -EKEYREVOKED\n * or -EKEYEXPIRED if an inaccessible, negative, revoked or expired key was\n * found; -ENOKEY if no key was found and no @callout_info was given; -EDQUOT\n * if insufficient key quota was available to create a new key; or -ENOMEM if\n * insufficient memory was available.\n *\n * If the returned key was created, then it may still be under construction,\n * and wait_for_key_construction() should be used to wait for that to complete.\n */\nstruct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_DO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_SKIP_EXPIRED),\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* search all the process keyrings for a key */\n\tkey_ref = search_process_keyrings(&ctx);\n\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tconstruct_get_dest_keyring(&dest_keyring);\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tkey_put(dest_keyring);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\t/* the search failed, but the keyrings were searchable, so we\n\t\t * should consult userspace if we can */\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\n\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}\n\n/**\n * wait_for_key_construction - Wait for construction of a key to complete\n * @key: The key being waited for.\n * @intr: Whether to wait interruptibly.\n *\n * Wait for a key to finish being constructed.\n *\n * Returns 0 if successful; -ERESTARTSYS if the wait was interrupted; -ENOKEY\n * if the key was negated; or -EKEYREVOKED or -EKEYEXPIRED if the key was\n * revoked or expired.\n */\nint wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->reject_error;\n\t}\n\treturn key_validate(key);\n}\nEXPORT_SYMBOL(wait_for_key_construction);\n\n/**\n * request_key - Request a key and wait for construction\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found, new keys are always allocated in the user's quota,\n * the callout_info must be a NUL-terminated string and no auxiliary data can\n * be passed.\n *\n * Furthermore, it then works as wait_for_key_construction() to wait for the\n * completion of keys undergoing construction with a non-interruptible wait.\n */\nstruct key *request_key(struct key_type *type,\n\t\t\tconst char *description,\n\t\t\tconst char *callout_info)\n{\n\tstruct key *key;\n\tsize_t callout_len = 0;\n\tint ret;\n\n\tif (callout_info)\n\t\tcallout_len = strlen(callout_info);\n\tkey = request_key_and_link(type, description, callout_info, callout_len,\n\t\t\t\t   NULL, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key);\n\n/**\n * request_key_with_auxdata - Request a key with auxiliary data for the upcaller\n * @type: The type of key we want.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found and new keys are always allocated in the user's quota.\n *\n * Furthermore, it then works as wait_for_key_construction() to wait for the\n * completion of keys undergoing construction with a non-interruptible wait.\n */\nstruct key *request_key_with_auxdata(struct key_type *type,\n\t\t\t\t     const char *description,\n\t\t\t\t     const void *callout_info,\n\t\t\t\t     size_t callout_len,\n\t\t\t\t     void *aux)\n{\n\tstruct key *key;\n\tint ret;\n\n\tkey = request_key_and_link(type, description, callout_info, callout_len,\n\t\t\t\t   aux, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key_with_auxdata);\n\n/*\n * request_key_async - Request a key (allow async construction)\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found, new keys are always allocated in the user's quota and\n * no auxiliary data can be passed.\n *\n * The caller should call wait_for_key_construction() to wait for the\n * completion of the returned key if it is still undergoing construction.\n */\nstruct key *request_key_async(struct key_type *type,\n\t\t\t      const char *description,\n\t\t\t      const void *callout_info,\n\t\t\t      size_t callout_len)\n{\n\treturn request_key_and_link(type, description, callout_info,\n\t\t\t\t    callout_len, NULL, NULL,\n\t\t\t\t    KEY_ALLOC_IN_QUOTA);\n}\nEXPORT_SYMBOL(request_key_async);\n\n/*\n * request a key with auxiliary data for the upcaller (allow async construction)\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found and new keys are always allocated in the user's quota.\n *\n * The caller should call wait_for_key_construction() to wait for the\n * completion of the returned key if it is still undergoing construction.\n */\nstruct key *request_key_async_with_auxdata(struct key_type *type,\n\t\t\t\t\t   const char *description,\n\t\t\t\t\t   const void *callout_info,\n\t\t\t\t\t   size_t callout_len,\n\t\t\t\t\t   void *aux)\n{\n\treturn request_key_and_link(type, description, callout_info,\n\t\t\t\t    callout_len, aux, NULL, KEY_ALLOC_IN_QUOTA);\n}\nEXPORT_SYMBOL(request_key_async_with_auxdata);\n", "/* Request key authorisation token key definition.\n *\n * Copyright (C) 2005 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * See Documentation/security/keys/request-key.rst\n */\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <keys/user-type.h>\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *);\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *);\nstatic int request_key_auth_instantiate(struct key *,\n\t\t\t\t\tstruct key_preparsed_payload *);\nstatic void request_key_auth_describe(const struct key *, struct seq_file *);\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstatic long request_key_auth_read(const struct key *, char __user *, size_t);\n\n/*\n * The request-key authorisation key type definition.\n */\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *prep)\n{\n\treturn 0;\n}\n\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *prep)\n{\n}\n\n/*\n * Instantiate a request-key authorisation key.\n */\nstatic int request_key_auth_instantiate(struct key *key,\n\t\t\t\t\tstruct key_preparsed_payload *prep)\n{\n\tkey->payload.data[0] = (struct request_key_auth *)prep->data;\n\treturn 0;\n}\n\n/*\n * Describe an authorisation token.\n */\nstatic void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}\n\n/*\n * Read the callout_info data (retrieves the callout information).\n * - the key's semaphore is read-locked\n */\nstatic long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Handle revocation of an authorisation token key.\n *\n * Called with the key sem write-locked.\n */\nstatic void request_key_auth_revoke(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tkenter(\"{%d}\", key->serial);\n\n\tif (rka->cred) {\n\t\tput_cred(rka->cred);\n\t\trka->cred = NULL;\n\t}\n}\n\nstatic void free_request_key_auth(struct request_key_auth *rka)\n{\n\tif (!rka)\n\t\treturn;\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tif (rka->cred)\n\t\tput_cred(rka->cred);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n}\n\n/*\n * Destroy an instantiation authorisation token key.\n */\nstatic void request_key_auth_destroy(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tkenter(\"{%d}\", key->serial);\n\n\tfree_request_key_auth(rka);\n}\n\n/*\n * Create an authorisation token for /sbin/request-key or whoever to gain\n * access to the caller's security data.\n */\nstruct key *request_key_auth_new(struct key *target, const void *callout_info,\n\t\t\t\t size_t callout_len, struct key *dest_keyring)\n{\n\tstruct request_key_auth *rka, *irka;\n\tconst struct cred *cred = current->cred;\n\tstruct key *authkey = NULL;\n\tchar desc[20];\n\tint ret = -ENOMEM;\n\n\tkenter(\"%d,\", target->serial);\n\n\t/* allocate a auth record */\n\trka = kzalloc(sizeof(*rka), GFP_KERNEL);\n\tif (!rka)\n\t\tgoto error;\n\trka->callout_info = kmemdup(callout_info, callout_len, GFP_KERNEL);\n\tif (!rka->callout_info)\n\t\tgoto error_free_rka;\n\trka->callout_len = callout_len;\n\n\t/* see if the calling process is already servicing the key request of\n\t * another process */\n\tif (cred->request_key_auth) {\n\t\t/* it is - use that instantiation context here too */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\t/* if the auth key has been revoked, then the key we're\n\t\t * servicing is already instantiated */\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &cred->request_key_auth->flags)) {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t\tret = -EKEYREVOKED;\n\t\t\tgoto error_free_rka;\n\t\t}\n\n\t\tirka = cred->request_key_auth->payload.data[0];\n\t\trka->cred = get_cred(irka->cred);\n\t\trka->pid = irka->pid;\n\n\t\tup_read(&cred->request_key_auth->sem);\n\t}\n\telse {\n\t\t/* it isn't - use this process as the context */\n\t\trka->cred = get_cred(cred);\n\t\trka->pid = current->pid;\n\t}\n\n\trka->target_key = key_get(target);\n\trka->dest_keyring = key_get(dest_keyring);\n\n\t/* allocate the auth key */\n\tsprintf(desc, \"%x\", target->serial);\n\n\tauthkey = key_alloc(&key_type_request_key_auth, desc,\n\t\t\t    cred->fsuid, cred->fsgid, cred,\n\t\t\t    KEY_POS_VIEW | KEY_POS_READ | KEY_POS_SEARCH |\n\t\t\t    KEY_USR_VIEW, KEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error_free_rka;\n\t}\n\n\t/* construct the auth key */\n\tret = key_instantiate_and_link(authkey, rka, 0, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto error_put_authkey;\n\n\tkleave(\" = {%d,%d}\", authkey->serial, refcount_read(&authkey->usage));\n\treturn authkey;\n\nerror_put_authkey:\n\tkey_put(authkey);\nerror_free_rka:\n\tfree_request_key_auth(rka);\nerror:\n\tkleave(\"= %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n/*\n * Search the current process's keyrings for the authorisation key for\n * instantiation of a key.\n */\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}\n", "/*\n * Copyright (C) 2010 IBM Corporation\n *\n * Author:\n * David Safford <safford@us.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * See Documentation/security/keys/trusted-encrypted.rst\n */\n\n#include <crypto/hash_info.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <linux/key-type.h>\n#include <linux/rcupdate.h>\n#include <linux/crypto.h>\n#include <crypto/hash.h>\n#include <crypto/sha.h>\n#include <linux/capability.h>\n#include <linux/tpm.h>\n#include <linux/tpm_command.h>\n\n#include \"trusted.h\"\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic const char hash_alg[] = \"sha1\";\n\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}\n\nstatic int TSS_sha1(const unsigned char *data, unsigned int datalen,\n\t\t    unsigned char *digest)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);\n\tkzfree(sdesc);\n\treturn ret;\n}\n\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}\n\n/*\n * calculate authorization info fields to send to TPM\n */\nstatic int TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned char h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}\n\n/*\n * verify the AUTH1_COMMAND (Seal) result from TPM\n */\nstatic int TSS_checkhmac1(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key,\n\t\t\t  unsigned int keylen, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce;\n\tunsigned char *continueflag;\n\tunsigned char *authdata;\n\tunsigned char testhmac[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH1_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata = buffer + bufsize - SHA1_DIGEST_SIZE;\n\tcontinueflag = authdata - 1;\n\tenonce = continueflag - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac, key, keylen, SHA1_DIGEST_SIZE, paramdigest,\n\t\t\t  TPM_NONCE_SIZE, enonce, TPM_NONCE_SIZE, ononce,\n\t\t\t  1, continueflag, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}\n\n/*\n * verify the AUTH2_COMMAND (unseal) result from TPM\n */\nstatic int TSS_checkhmac2(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key1,\n\t\t\t  unsigned int keylen1,\n\t\t\t  const unsigned char *key2,\n\t\t\t  unsigned int keylen2, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce1;\n\tunsigned char *continueflag1;\n\tunsigned char *authdata1;\n\tunsigned char *enonce2;\n\tunsigned char *continueflag2;\n\tunsigned char *authdata2;\n\tunsigned char testhmac1[SHA1_DIGEST_SIZE];\n\tunsigned char testhmac2[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH2_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata1 = buffer + bufsize - (SHA1_DIGEST_SIZE + 1\n\t\t\t+ SHA1_DIGEST_SIZE + SHA1_DIGEST_SIZE);\n\tauthdata2 = buffer + bufsize - (SHA1_DIGEST_SIZE);\n\tcontinueflag1 = authdata1 - 1;\n\tcontinueflag2 = authdata2 - 1;\n\tenonce1 = continueflag1 - TPM_NONCE_SIZE;\n\tenonce2 = continueflag2 - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen2);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac1, key1, keylen1, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce1,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag1, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac1, authdata1, SHA1_DIGEST_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = TSS_rawhmac(testhmac2, key2, keylen2, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce2,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag2, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}\n\n/*\n * For key specific tpm requests, we will generate and send our\n * own TPM command packets using the drivers send function.\n */\nstatic int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}\n\n/*\n * Lock a trusted key, by extending a selected PCR.\n *\n * Prevents a trusted key that is sealed to PCRs from being accessed.\n * This uses the tpm driver's extend function.\n */\nstatic int pcrlock(const int pcrnum)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\n\tif (ret != SHA1_DIGEST_SIZE)\n\t\treturn ret;\n\treturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\n}\n\n/*\n * Create an object specific authorisation protocol (OSAP) session\n */\nstatic int osap(struct tpm_buf *tb, struct osapsess *s,\n\t\tconst unsigned char *key, uint16_t type, uint32_t handle)\n{\n\tunsigned char enonce[TPM_NONCE_SIZE];\n\tunsigned char ononce[TPM_NONCE_SIZE];\n\tint ret;\n\n\tret = tpm_get_random(TPM_ANY_NUM, ononce, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\treturn ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OSAP_SIZE);\n\tstore32(tb, TPM_ORD_OSAP);\n\tstore16(tb, type);\n\tstore32(tb, handle);\n\tstorebytes(tb, ononce, TPM_NONCE_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts->handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(s->enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]),\n\t       TPM_NONCE_SIZE);\n\tmemcpy(enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t\t  TPM_NONCE_SIZE]), TPM_NONCE_SIZE);\n\treturn TSS_rawhmac(s->secret, key, SHA1_DIGEST_SIZE, TPM_NONCE_SIZE,\n\t\t\t   enonce, TPM_NONCE_SIZE, ononce, 0, 0);\n}\n\n/*\n * Create an object independent authorisation protocol (oiap) session\n */\nstatic int oiap(struct tpm_buf *tb, uint32_t *handle, unsigned char *nonce)\n{\n\tint ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OIAP_SIZE);\n\tstore32(tb, TPM_ORD_OIAP);\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(nonce, &tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)],\n\t       TPM_NONCE_SIZE);\n\treturn 0;\n}\n\nstruct tpm_digests {\n\tunsigned char encauth[SHA1_DIGEST_SIZE];\n\tunsigned char pubauth[SHA1_DIGEST_SIZE];\n\tunsigned char xorwork[SHA1_DIGEST_SIZE * 2];\n\tunsigned char xorhash[SHA1_DIGEST_SIZE];\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n};\n\n/*\n * Have the TPM seal(encrypt) the trusted key, possibly based on\n * Platform Configuration Registers (PCRs). AUTH1 for sealing key.\n */\nstatic int tpm_seal(struct tpm_buf *tb, uint16_t keytype,\n\t\t    uint32_t keyhandle, const unsigned char *keyauth,\n\t\t    const unsigned char *data, uint32_t datalen,\n\t\t    unsigned char *blob, uint32_t *bloblen,\n\t\t    const unsigned char *blobauth,\n\t\t    const unsigned char *pcrinfo, uint32_t pcrinfosize)\n{\n\tstruct osapsess sess;\n\tstruct tpm_digests *td;\n\tunsigned char cont;\n\tuint32_t ordinal;\n\tuint32_t pcrsize;\n\tuint32_t datsize;\n\tint sealinfosize;\n\tint encdatasize;\n\tint storedsize;\n\tint ret;\n\tint i;\n\n\t/* alloc some work space for all the hashes */\n\ttd = kmalloc(sizeof *td, GFP_KERNEL);\n\tif (!td)\n\t\treturn -ENOMEM;\n\n\t/* get session for sealing key */\n\tret = osap(tb, &sess, keyauth, keytype, keyhandle);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_sess(&sess);\n\n\t/* calculate encrypted authorization value */\n\tmemcpy(td->xorwork, sess.secret, SHA1_DIGEST_SIZE);\n\tmemcpy(td->xorwork + SHA1_DIGEST_SIZE, sess.enonce, SHA1_DIGEST_SIZE);\n\tret = TSS_sha1(td->xorwork, SHA1_DIGEST_SIZE * 2, td->xorhash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = tpm_get_random(TPM_ANY_NUM, td->nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\tgoto out;\n\tordinal = htonl(TPM_ORD_SEAL);\n\tdatsize = htonl(datalen);\n\tpcrsize = htonl(pcrinfosize);\n\tcont = 0;\n\n\t/* encrypt data authorization key */\n\tfor (i = 0; i < SHA1_DIGEST_SIZE; ++i)\n\t\ttd->encauth[i] = td->xorhash[i] ^ blobauth[i];\n\n\t/* calculate authorization HMAC value */\n\tif (pcrinfosize == 0) {\n\t\t/* no pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   sizeof(uint32_t), &datsize, datalen, data, 0,\n\t\t\t\t   0);\n\t} else {\n\t\t/* pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   pcrinfosize, pcrinfo, sizeof(uint32_t),\n\t\t\t\t   &datsize, datalen, data, 0, 0);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* build and send the TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH1_COMMAND);\n\tstore32(tb, TPM_SEAL_SIZE + pcrinfosize + datalen);\n\tstore32(tb, TPM_ORD_SEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, td->encauth, SHA1_DIGEST_SIZE);\n\tstore32(tb, pcrinfosize);\n\tstorebytes(tb, pcrinfo, pcrinfosize);\n\tstore32(tb, datalen);\n\tstorebytes(tb, data, datalen);\n\tstore32(tb, sess.handle);\n\tstorebytes(tb, td->nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, td->pubauth, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* calculate the size of the returned Blob */\n\tsealinfosize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t));\n\tencdatasize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t     sizeof(uint32_t) + sealinfosize);\n\tstoredsize = sizeof(uint32_t) + sizeof(uint32_t) + sealinfosize +\n\t    sizeof(uint32_t) + encdatasize;\n\n\t/* check the HMAC in the response */\n\tret = TSS_checkhmac1(tb->data, ordinal, td->nonceodd, sess.secret,\n\t\t\t     SHA1_DIGEST_SIZE, storedsize, TPM_DATA_OFFSET, 0,\n\t\t\t     0);\n\n\t/* copy the returned blob to caller */\n\tif (!ret) {\n\t\tmemcpy(blob, tb->data + TPM_DATA_OFFSET, storedsize);\n\t\t*bloblen = storedsize;\n\t}\nout:\n\tkzfree(td);\n\treturn ret;\n}\n\n/*\n * use the AUTH2_COMMAND form of unseal, to authorize both key and blob\n */\nstatic int tpm_unseal(struct tpm_buf *tb,\n\t\t      uint32_t keyhandle, const unsigned char *keyauth,\n\t\t      const unsigned char *blob, int bloblen,\n\t\t      const unsigned char *blobauth,\n\t\t      unsigned char *data, unsigned int *datalen)\n{\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char enonce1[TPM_NONCE_SIZE];\n\tunsigned char enonce2[TPM_NONCE_SIZE];\n\tunsigned char authdata1[SHA1_DIGEST_SIZE];\n\tunsigned char authdata2[SHA1_DIGEST_SIZE];\n\tuint32_t authhandle1 = 0;\n\tuint32_t authhandle2 = 0;\n\tunsigned char cont = 0;\n\tuint32_t ordinal;\n\tuint32_t keyhndl;\n\tint ret;\n\n\t/* sessions for unsealing key and data */\n\tret = oiap(tb, &authhandle1, enonce1);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = oiap(tb, &authhandle2, enonce2);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tordinal = htonl(TPM_ORD_UNSEAL);\n\tkeyhndl = htonl(SRKHANDLE);\n\tret = tpm_get_random(TPM_ANY_NUM, nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE) {\n\t\tpr_info(\"trusted_key: tpm_get_random failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = TSS_authhmac(authdata1, keyauth, TPM_NONCE_SIZE,\n\t\t\t   enonce1, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = TSS_authhmac(authdata2, blobauth, TPM_NONCE_SIZE,\n\t\t\t   enonce2, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* build and send TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH2_COMMAND);\n\tstore32(tb, TPM_UNSEAL_SIZE + bloblen);\n\tstore32(tb, TPM_ORD_UNSEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, blob, bloblen);\n\tstore32(tb, authhandle1);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata1, SHA1_DIGEST_SIZE);\n\tstore32(tb, authhandle2);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata2, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: authhmac failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*datalen = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tret = TSS_checkhmac2(tb->data, ordinal, nonceodd,\n\t\t\t     keyauth, SHA1_DIGEST_SIZE,\n\t\t\t     blobauth, SHA1_DIGEST_SIZE,\n\t\t\t     sizeof(uint32_t), TPM_DATA_OFFSET,\n\t\t\t     *datalen, TPM_DATA_OFFSET + sizeof(uint32_t), 0,\n\t\t\t     0);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: TSS_checkhmac2 failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(data, tb->data + TPM_DATA_OFFSET + sizeof(uint32_t), *datalen);\n\treturn 0;\n}\n\n/*\n * Have the TPM seal(encrypt) the symmetric key\n */\nstatic int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\t/* include migratable flag at end of sealed key */\n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkseal failed (%d)\\n\", ret);\n\n\tkzfree(tb);\n\treturn ret;\n}\n\n/*\n * Have the TPM unseal(decrypt) the symmetric key\n */\nstatic int key_unseal(struct trusted_key_payload *p,\n\t\t      struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = tpm_unseal(tb, o->keyhandle, o->keyauth, p->blob, p->blob_len,\n\t\t\t o->blobauth, p->key, &p->key_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkunseal failed (%d)\\n\", ret);\n\telse\n\t\t/* pull migratable flag out of sealed key */\n\t\tp->migratable = p->key[--p->key_len];\n\n\tkzfree(tb);\n\treturn ret;\n}\n\nenum {\n\tOpt_err = -1,\n\tOpt_new, Opt_load, Opt_update,\n\tOpt_keyhandle, Opt_keyauth, Opt_blobauth,\n\tOpt_pcrinfo, Opt_pcrlock, Opt_migratable,\n\tOpt_hash,\n\tOpt_policydigest,\n\tOpt_policyhandle,\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};\n\n/* can have zero or more token= options */\nstatic int getoptions(char *c, struct trusted_key_payload *pay,\n\t\t      struct trusted_key_options *opt)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p = c;\n\tint token;\n\tint res;\n\tunsigned long handle;\n\tunsigned long lock;\n\tunsigned long token_mask = 0;\n\tunsigned int digest_len;\n\tint i;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\topt->hash = tpm2 ? HASH_ALGO_SHA256 : HASH_ALGO_SHA1;\n\n\twhile ((p = strsep(&c, \" \\t\"))) {\n\t\tif (*p == '\\0' || *p == ' ' || *p == '\\t')\n\t\t\tcontinue;\n\t\ttoken = match_token(p, key_tokens, args);\n\t\tif (test_and_set_bit(token, &token_mask))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (token) {\n\t\tcase Opt_pcrinfo:\n\t\t\topt->pcrinfo_len = strlen(args[0].from) / 2;\n\t\t\tif (opt->pcrinfo_len > MAX_PCRINFO_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->pcrinfo, args[0].from,\n\t\t\t\t      opt->pcrinfo_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_keyhandle:\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->keytype = SEAL_keytype;\n\t\t\topt->keyhandle = handle;\n\t\t\tbreak;\n\t\tcase Opt_keyauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->keyauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_blobauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->blobauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_migratable:\n\t\t\tif (*args[0].from == '0')\n\t\t\t\tpay->migratable = 0;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_pcrlock:\n\t\t\tres = kstrtoul(args[0].from, 10, &lock);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->pcrlock = lock;\n\t\t\tbreak;\n\t\tcase Opt_hash:\n\t\t\tif (test_bit(Opt_policydigest, &token_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tfor (i = 0; i < HASH_ALGO__LAST; i++) {\n\t\t\t\tif (!strcmp(args[0].from, hash_algo_name[i])) {\n\t\t\t\t\topt->hash = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == HASH_ALGO__LAST)\n\t\t\t\treturn -EINVAL;\n\t\t\tif  (!tpm2 && i != HASH_ALGO_SHA1) {\n\t\t\t\tpr_info(\"trusted_key: TPM 1.x only supports SHA-1.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_policydigest:\n\t\t\tdigest_len = hash_digest_size[opt->hash];\n\t\t\tif (!tpm2 || strlen(args[0].from) != (2 * digest_len))\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->policydigest, args[0].from,\n\t\t\t\t      digest_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policydigest_len = digest_len;\n\t\t\tbreak;\n\t\tcase Opt_policyhandle:\n\t\t\tif (!tpm2)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policyhandle = handle;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * datablob_parse - parse the keyctl data and fill in the\n * \t\t    payload and options structures\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int datablob_parse(char *datablob, struct trusted_key_payload *p,\n\t\t\t  struct trusted_key_options *o)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t/* main command */\n\tc = strsep(&datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t/* first argument is key size */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t/* first argument is sealed blob */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\t/* all arguments are options */\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn NULL;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t/* set any non-zero defaults */\n\t\toptions->keytype = SRK_keytype;\n\n\t\tif (!tpm2)\n\t\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}\n\nstatic struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof *p);\n\tif (ret < 0)\n\t\treturn p;\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (p)\n\t\tp->migratable = 1; /* migratable by default */\n\treturn p;\n}\n\n/*\n * trusted_instantiate - create a new trusted key\n *\n * Unseal an existing trusted blob or, for a new key, get a\n * random key, then seal and create a trusted key-type key,\n * adding it to the specified keyring.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int trusted_instantiate(struct key *key,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *payload = NULL;\n\tstruct trusted_key_options *options = NULL;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tint key_cmd;\n\tsize_t key_len;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\n\toptions = trusted_options_alloc();\n\tif (!options) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpayload = trusted_payload_alloc(key);\n\tif (!payload) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey_cmd = datablob_parse(datablob, payload, options);\n\tif (key_cmd < 0) {\n\t\tret = key_cmd;\n\t\tgoto out;\n\t}\n\n\tif (!options->keyhandle) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdump_payload(payload);\n\tdump_options(options);\n\n\tswitch (key_cmd) {\n\tcase Opt_load:\n\t\tif (tpm2)\n\t\t\tret = tpm_unseal_trusted(TPM_ANY_NUM, payload, options);\n\t\telse\n\t\t\tret = key_unseal(payload, options);\n\t\tdump_payload(payload);\n\t\tdump_options(options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_unseal failed (%d)\\n\", ret);\n\t\tbreak;\n\tcase Opt_new:\n\t\tkey_len = payload->key_len;\n\t\tret = tpm_get_random(TPM_ANY_NUM, payload->key, key_len);\n\t\tif (ret != key_len) {\n\t\t\tpr_info(\"trusted_key: key_create failed (%d)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (tpm2)\n\t\t\tret = tpm_seal_trusted(TPM_ANY_NUM, payload, options);\n\t\telse\n\t\t\tret = key_seal(payload, options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!ret && options->pcrlock)\n\t\tret = pcrlock(options->pcrlock);\nout:\n\tkzfree(datablob);\n\tkzfree(options);\n\tif (!ret)\n\t\trcu_assign_keypointer(key, payload);\n\telse\n\t\tkzfree(payload);\n\treturn ret;\n}\n\nstatic void trusted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct trusted_key_payload *p;\n\n\tp = container_of(rcu, struct trusted_key_payload, rcu);\n\tkzfree(p);\n}\n\n/*\n * trusted_update - reseal an existing key with new PCR values\n */\nstatic int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\t/* copy old key values, and reseal with new pcrs */\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}\n\n/*\n * trusted_read - copy the sealed blob data to userspace in hex.\n * On success, return to userspace the trusted key datablob size.\n */\nstatic long trusted_read(const struct key *key, char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tconst struct trusted_key_payload *p;\n\tchar *ascii_buf;\n\tchar *bufp;\n\tint i;\n\n\tp = dereference_key_locked(key);\n\tif (!p)\n\t\treturn -EINVAL;\n\tif (!buffer || buflen <= 0)\n\t\treturn 2 * p->blob_len;\n\tascii_buf = kmalloc(2 * p->blob_len, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\treturn -ENOMEM;\n\n\tbufp = ascii_buf;\n\tfor (i = 0; i < p->blob_len; i++)\n\t\tbufp = hex_byte_pack(bufp, p->blob[i]);\n\tif ((copy_to_user(buffer, ascii_buf, 2 * p->blob_len)) != 0) {\n\t\tkzfree(ascii_buf);\n\t\treturn -EFAULT;\n\t}\n\tkzfree(ascii_buf);\n\treturn 2 * p->blob_len;\n}\n\n/*\n * trusted_destroy - clear and free the key's payload\n */\nstatic void trusted_destroy(struct key *key)\n{\n\tkzfree(key->payload.data[0]);\n}\n\nstruct key_type key_type_trusted = {\n\t.name = \"trusted\",\n\t.instantiate = trusted_instantiate,\n\t.update = trusted_update,\n\t.destroy = trusted_destroy,\n\t.describe = user_describe,\n\t.read = trusted_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_trusted);\n\nstatic void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}\n\nstatic int __init trusted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}\n\nstatic int __init init_trusted(void)\n{\n\tint ret;\n\n\tret = trusted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = register_key_type(&key_type_trusted);\n\tif (ret < 0)\n\t\ttrusted_shash_release();\n\treturn ret;\n}\n\nstatic void __exit cleanup_trusted(void)\n{\n\ttrusted_shash_release();\n\tunregister_key_type(&key_type_trusted);\n}\n\nlate_initcall(init_trusted);\nmodule_exit(cleanup_trusted);\n\nMODULE_LICENSE(\"GPL\");\n", "/* user_defined.c: user defined key type\n *\n * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\nstatic int logon_vet_description(const char *desc);\n\n/*\n * user defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_user = {\n\t.name\t\t\t= \"user\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.read\t\t\t= user_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_user);\n\n/*\n * This key type is essentially the same as key_type_user, but it does\n * not define a .read op. This is suitable for storing username and\n * password pairs in the keyring that you do not want to be readable\n * from userspace.\n */\nstruct key_type key_type_logon = {\n\t.name\t\t\t= \"logon\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.vet_description\t= logon_vet_description,\n};\nEXPORT_SYMBOL_GPL(key_type_logon);\n\n/*\n * Preparse a user defined key payload\n */\nint user_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tsize_t datalen = prep->datalen;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\treturn -ENOMEM;\n\n\t/* attach the data */\n\tprep->quotalen = datalen;\n\tprep->payload.data[0] = upayload;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(user_preparse);\n\n/*\n * Free a preparse of a user defined key payload\n */\nvoid user_free_preparse(struct key_preparsed_payload *prep)\n{\n\tkzfree(prep->payload.data[0]);\n}\nEXPORT_SYMBOL_GPL(user_free_preparse);\n\nstatic void user_free_payload_rcu(struct rcu_head *head)\n{\n\tstruct user_key_payload *payload;\n\n\tpayload = container_of(head, struct user_key_payload, rcu);\n\tkzfree(payload);\n}\n\n/*\n * update a user defined key\n * - the key's semaphore is write-locked\n */\nint user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\n\t/* check the quota and attach the new data */\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attach the new data, displacing the old */\n\tkey->expiry = prep->expiry;\n\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(user_update);\n\n/*\n * dispose of the links from a revoked keyring\n * - called with the key sem write-locked\n */\nvoid user_revoke(struct key *key)\n{\n\tstruct user_key_payload *upayload = user_key_payload_locked(key);\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\n\tif (upayload) {\n\t\trcu_assign_keypointer(key, NULL);\n\t\tcall_rcu(&upayload->rcu, user_free_payload_rcu);\n\t}\n}\n\nEXPORT_SYMBOL(user_revoke);\n\n/*\n * dispose of the data dangling from the corpse of a user key\n */\nvoid user_destroy(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data[0];\n\n\tkzfree(upayload);\n}\n\nEXPORT_SYMBOL_GPL(user_destroy);\n\n/*\n * describe the user key\n */\nvoid user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}\n\nEXPORT_SYMBOL_GPL(user_describe);\n\n/*\n * read the key data\n * - the key's semaphore is read-locked\n */\nlong user_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tconst struct user_key_payload *upayload;\n\tlong ret;\n\n\tupayload = user_key_payload_locked(key);\n\tret = upayload->datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > upayload->datalen)\n\t\t\tbuflen = upayload->datalen;\n\n\t\tif (copy_to_user(buffer, upayload->data, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(user_read);\n\n/* Vet the description for a \"logon\" key */\nstatic int logon_vet_description(const char *desc)\n{\n\tchar *p;\n\n\t/* require a \"qualified\" description string */\n\tp = strchr(desc, ':');\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t/* also reject description with ':' as first char */\n\tif (p == desc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n"], "fixing_code": ["/* Authentication token and access key management\n *\n * Copyright (C) 2004, 2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n *\n * See Documentation/security/keys/core.rst for information on keys/keyrings.\n */\n\n#ifndef _LINUX_KEY_H\n#define _LINUX_KEY_H\n\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/rbtree.h>\n#include <linux/rcupdate.h>\n#include <linux/sysctl.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n#include <linux/assoc_array.h>\n#include <linux/refcount.h>\n\n#ifdef __KERNEL__\n#include <linux/uidgid.h>\n\n/* key handle serial number */\ntypedef int32_t key_serial_t;\n\n/* key handle permissions mask */\ntypedef uint32_t key_perm_t;\n\nstruct key;\n\n#ifdef CONFIG_KEYS\n\n#undef KEY_DEBUGGING\n\n#define KEY_POS_VIEW\t0x01000000\t/* possessor can view a key's attributes */\n#define KEY_POS_READ\t0x02000000\t/* possessor can read key payload / view keyring */\n#define KEY_POS_WRITE\t0x04000000\t/* possessor can update key payload / add link to keyring */\n#define KEY_POS_SEARCH\t0x08000000\t/* possessor can find a key in search / search a keyring */\n#define KEY_POS_LINK\t0x10000000\t/* possessor can create a link to a key/keyring */\n#define KEY_POS_SETATTR\t0x20000000\t/* possessor can set key attributes */\n#define KEY_POS_ALL\t0x3f000000\n\n#define KEY_USR_VIEW\t0x00010000\t/* user permissions... */\n#define KEY_USR_READ\t0x00020000\n#define KEY_USR_WRITE\t0x00040000\n#define KEY_USR_SEARCH\t0x00080000\n#define KEY_USR_LINK\t0x00100000\n#define KEY_USR_SETATTR\t0x00200000\n#define KEY_USR_ALL\t0x003f0000\n\n#define KEY_GRP_VIEW\t0x00000100\t/* group permissions... */\n#define KEY_GRP_READ\t0x00000200\n#define KEY_GRP_WRITE\t0x00000400\n#define KEY_GRP_SEARCH\t0x00000800\n#define KEY_GRP_LINK\t0x00001000\n#define KEY_GRP_SETATTR\t0x00002000\n#define KEY_GRP_ALL\t0x00003f00\n\n#define KEY_OTH_VIEW\t0x00000001\t/* third party permissions... */\n#define KEY_OTH_READ\t0x00000002\n#define KEY_OTH_WRITE\t0x00000004\n#define KEY_OTH_SEARCH\t0x00000008\n#define KEY_OTH_LINK\t0x00000010\n#define KEY_OTH_SETATTR\t0x00000020\n#define KEY_OTH_ALL\t0x0000003f\n\n#define KEY_PERM_UNDEF\t0xffffffff\n\nstruct seq_file;\nstruct user_struct;\nstruct signal_struct;\nstruct cred;\n\nstruct key_type;\nstruct key_owner;\nstruct keyring_list;\nstruct keyring_name;\n\nstruct keyring_index_key {\n\tstruct key_type\t\t*type;\n\tconst char\t\t*description;\n\tsize_t\t\t\tdesc_len;\n};\n\nunion key_payload {\n\tvoid __rcu\t\t*rcu_data0;\n\tvoid\t\t\t*data[4];\n};\n\n/*****************************************************************************/\n/*\n * key reference with possession attribute handling\n *\n * NOTE! key_ref_t is a typedef'd pointer to a type that is not actually\n * defined. This is because we abuse the bottom bit of the reference to carry a\n * flag to indicate whether the calling process possesses that key in one of\n * its keyrings.\n *\n * the key_ref_t has been made a separate type so that the compiler can reject\n * attempts to dereference it without proper conversion.\n *\n * the three functions are used to assemble and disassemble references\n */\ntypedef struct __key_reference_with_attributes *key_ref_t;\n\nstatic inline key_ref_t make_key_ref(const struct key *key,\n\t\t\t\t     bool possession)\n{\n\treturn (key_ref_t) ((unsigned long) key | possession);\n}\n\nstatic inline struct key *key_ref_to_ptr(const key_ref_t key_ref)\n{\n\treturn (struct key *) ((unsigned long) key_ref & ~1UL);\n}\n\nstatic inline bool is_key_possessed(const key_ref_t key_ref)\n{\n\treturn (unsigned long) key_ref & 1UL;\n}\n\ntypedef int (*key_restrict_link_func_t)(struct key *dest_keyring,\n\t\t\t\t\tconst struct key_type *type,\n\t\t\t\t\tconst union key_payload *payload,\n\t\t\t\t\tstruct key *restriction_key);\n\nstruct key_restriction {\n\tkey_restrict_link_func_t check;\n\tstruct key *key;\n\tstruct key_type *keytype;\n};\n\nenum key_state {\n\tKEY_IS_UNINSTANTIATED,\n\tKEY_IS_POSITIVE,\t\t/* Positively instantiated */\n};\n\n/*****************************************************************************/\n/*\n * authentication token / access credential / keyring\n * - types of key include:\n *   - keyrings\n *   - disk encryption IDs\n *   - Kerberos TGTs and tickets\n */\nstruct key {\n\trefcount_t\t\tusage;\t\t/* number of references */\n\tkey_serial_t\t\tserial;\t\t/* key serial number */\n\tunion {\n\t\tstruct list_head graveyard_link;\n\t\tstruct rb_node\tserial_node;\n\t};\n\tstruct rw_semaphore\tsem;\t\t/* change vs change sem */\n\tstruct key_user\t\t*user;\t\t/* owner of this key */\n\tvoid\t\t\t*security;\t/* security data for this key */\n\tunion {\n\t\ttime_t\t\texpiry;\t\t/* time at which key expires (or 0) */\n\t\ttime_t\t\trevoked_at;\t/* time at which key was revoked */\n\t};\n\ttime_t\t\t\tlast_used_at;\t/* last time used for LRU keyring discard */\n\tkuid_t\t\t\tuid;\n\tkgid_t\t\t\tgid;\n\tkey_perm_t\t\tperm;\t\t/* access permissions */\n\tunsigned short\t\tquotalen;\t/* length added to quota */\n\tunsigned short\t\tdatalen;\t/* payload data length\n\t\t\t\t\t\t * - may not match RCU dereferenced payload\n\t\t\t\t\t\t * - payload should contain own length\n\t\t\t\t\t\t */\n\tshort\t\t\tstate;\t\t/* Key state (+) or rejection error (-) */\n\n#ifdef KEY_DEBUGGING\n\tunsigned\t\tmagic;\n#define KEY_DEBUG_MAGIC\t\t0x18273645u\n#endif\n\n\tunsigned long\t\tflags;\t\t/* status flags (change with bitops) */\n#define KEY_FLAG_DEAD\t\t0\t/* set if key type has been deleted */\n#define KEY_FLAG_REVOKED\t1\t/* set if key had been revoked */\n#define KEY_FLAG_IN_QUOTA\t2\t/* set if key consumes quota */\n#define KEY_FLAG_USER_CONSTRUCT\t3\t/* set if key is being constructed in userspace */\n#define KEY_FLAG_ROOT_CAN_CLEAR\t4\t/* set if key can be cleared by root without permission */\n#define KEY_FLAG_INVALIDATED\t5\t/* set if key has been invalidated */\n#define KEY_FLAG_BUILTIN\t6\t/* set if key is built in to the kernel */\n#define KEY_FLAG_ROOT_CAN_INVAL\t7\t/* set if key can be invalidated by root without permission */\n#define KEY_FLAG_KEEP\t\t8\t/* set if key should not be removed */\n#define KEY_FLAG_UID_KEYRING\t9\t/* set if key is a user or user session keyring */\n\n\t/* the key type and key description string\n\t * - the desc is used to match a key against search criteria\n\t * - it should be a printable string\n\t * - eg: for krb5 AFS, this might be \"afs@REDHAT.COM\"\n\t */\n\tunion {\n\t\tstruct keyring_index_key index_key;\n\t\tstruct {\n\t\t\tstruct key_type\t*type;\t\t/* type of key */\n\t\t\tchar\t\t*description;\n\t\t};\n\t};\n\n\t/* key data\n\t * - this is used to hold the data actually used in cryptography or\n\t *   whatever\n\t */\n\tunion {\n\t\tunion key_payload payload;\n\t\tstruct {\n\t\t\t/* Keyring bits */\n\t\t\tstruct list_head name_link;\n\t\t\tstruct assoc_array keys;\n\t\t};\n\t};\n\n\t/* This is set on a keyring to restrict the addition of a link to a key\n\t * to it.  If this structure isn't provided then it is assumed that the\n\t * keyring is open to any addition.  It is ignored for non-keyring\n\t * keys. Only set this value using keyring_restrict(), keyring_alloc(),\n\t * or key_alloc().\n\t *\n\t * This is intended for use with rings of trusted keys whereby addition\n\t * to the keyring needs to be controlled.  KEY_ALLOC_BYPASS_RESTRICTION\n\t * overrides this, allowing the kernel to add extra keys without\n\t * restriction.\n\t */\n\tstruct key_restriction *restrict_link;\n};\n\nextern struct key *key_alloc(struct key_type *type,\n\t\t\t     const char *desc,\n\t\t\t     kuid_t uid, kgid_t gid,\n\t\t\t     const struct cred *cred,\n\t\t\t     key_perm_t perm,\n\t\t\t     unsigned long flags,\n\t\t\t     struct key_restriction *restrict_link);\n\n\n#define KEY_ALLOC_IN_QUOTA\t\t0x0000\t/* add to quota, reject if would overrun */\n#define KEY_ALLOC_QUOTA_OVERRUN\t\t0x0001\t/* add to quota, permit even if overrun */\n#define KEY_ALLOC_NOT_IN_QUOTA\t\t0x0002\t/* not in quota */\n#define KEY_ALLOC_BUILT_IN\t\t0x0004\t/* Key is built into kernel */\n#define KEY_ALLOC_BYPASS_RESTRICTION\t0x0008\t/* Override the check on restricted keyrings */\n#define KEY_ALLOC_UID_KEYRING\t\t0x0010\t/* allocating a user or user session keyring */\n\nextern void key_revoke(struct key *key);\nextern void key_invalidate(struct key *key);\nextern void key_put(struct key *key);\n\nstatic inline struct key *__key_get(struct key *key)\n{\n\trefcount_inc(&key->usage);\n\treturn key;\n}\n\nstatic inline struct key *key_get(struct key *key)\n{\n\treturn key ? __key_get(key) : key;\n}\n\nstatic inline void key_ref_put(key_ref_t key_ref)\n{\n\tkey_put(key_ref_to_ptr(key_ref));\n}\n\nextern struct key *request_key(struct key_type *type,\n\t\t\t       const char *description,\n\t\t\t       const char *callout_info);\n\nextern struct key *request_key_with_auxdata(struct key_type *type,\n\t\t\t\t\t    const char *description,\n\t\t\t\t\t    const void *callout_info,\n\t\t\t\t\t    size_t callout_len,\n\t\t\t\t\t    void *aux);\n\nextern struct key *request_key_async(struct key_type *type,\n\t\t\t\t     const char *description,\n\t\t\t\t     const void *callout_info,\n\t\t\t\t     size_t callout_len);\n\nextern struct key *request_key_async_with_auxdata(struct key_type *type,\n\t\t\t\t\t\t  const char *description,\n\t\t\t\t\t\t  const void *callout_info,\n\t\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t\t  void *aux);\n\nextern int wait_for_key_construction(struct key *key, bool intr);\n\nextern int key_validate(const struct key *key);\n\nextern key_ref_t key_create_or_update(key_ref_t keyring,\n\t\t\t\t      const char *type,\n\t\t\t\t      const char *description,\n\t\t\t\t      const void *payload,\n\t\t\t\t      size_t plen,\n\t\t\t\t      key_perm_t perm,\n\t\t\t\t      unsigned long flags);\n\nextern int key_update(key_ref_t key,\n\t\t      const void *payload,\n\t\t      size_t plen);\n\nextern int key_link(struct key *keyring,\n\t\t    struct key *key);\n\nextern int key_unlink(struct key *keyring,\n\t\t      struct key *key);\n\nextern struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t\t const struct cred *cred,\n\t\t\t\t key_perm_t perm,\n\t\t\t\t unsigned long flags,\n\t\t\t\t struct key_restriction *restrict_link,\n\t\t\t\t struct key *dest);\n\nextern int restrict_link_reject(struct key *keyring,\n\t\t\t\tconst struct key_type *type,\n\t\t\t\tconst union key_payload *payload,\n\t\t\t\tstruct key *restriction_key);\n\nextern int keyring_clear(struct key *keyring);\n\nextern key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t\tstruct key_type *type,\n\t\t\t\tconst char *description);\n\nextern int keyring_add_key(struct key *keyring,\n\t\t\t   struct key *key);\n\nextern int keyring_restrict(key_ref_t keyring, const char *type,\n\t\t\t    const char *restriction);\n\nextern struct key *key_lookup(key_serial_t id);\n\nstatic inline key_serial_t key_serial(const struct key *key)\n{\n\treturn key ? key->serial : 0;\n}\n\nextern void key_set_timeout(struct key *, unsigned);\n\n/*\n * The permissions required on a key that we're looking up.\n */\n#define\tKEY_NEED_VIEW\t0x01\t/* Require permission to view attributes */\n#define\tKEY_NEED_READ\t0x02\t/* Require permission to read content */\n#define\tKEY_NEED_WRITE\t0x04\t/* Require permission to update / modify */\n#define\tKEY_NEED_SEARCH\t0x08\t/* Require permission to search (keyring) or find (key) */\n#define\tKEY_NEED_LINK\t0x10\t/* Require permission to link */\n#define\tKEY_NEED_SETATTR 0x20\t/* Require permission to change attributes */\n#define\tKEY_NEED_ALL\t0x3f\t/* All the above permissions */\n\nstatic inline short key_read_state(const struct key *key)\n{\n\t/* Barrier versus mark_key_instantiated(). */\n\treturn smp_load_acquire(&key->state);\n}\n\n/**\n * key_is_positive - Determine if a key has been positively instantiated\n * @key: The key to check.\n *\n * Return true if the specified key has been positively instantiated, false\n * otherwise.\n */\nstatic inline bool key_is_positive(const struct key *key)\n{\n\treturn key_read_state(key) == KEY_IS_POSITIVE;\n}\n\nstatic inline bool key_is_negative(const struct key *key)\n{\n\treturn key_read_state(key) < 0;\n}\n\n#define dereference_key_rcu(KEY)\t\t\t\t\t\\\n\t(rcu_dereference((KEY)->payload.rcu_data0))\n\n#define dereference_key_locked(KEY)\t\t\t\t\t\\\n\t(rcu_dereference_protected((KEY)->payload.rcu_data0,\t\t\\\n\t\t\t\t   rwsem_is_locked(&((struct key *)(KEY))->sem)))\n\n#define rcu_assign_keypointer(KEY, PAYLOAD)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\trcu_assign_pointer((KEY)->payload.rcu_data0, (PAYLOAD));\t\\\n} while (0)\n\n#ifdef CONFIG_SYSCTL\nextern struct ctl_table key_sysctls[];\n#endif\n/*\n * the userspace interface\n */\nextern int install_thread_keyring_to_cred(struct cred *cred);\nextern void key_fsuid_changed(struct task_struct *tsk);\nextern void key_fsgid_changed(struct task_struct *tsk);\nextern void key_init(void);\n\n#else /* CONFIG_KEYS */\n\n#define key_validate(k)\t\t\t0\n#define key_serial(k)\t\t\t0\n#define key_get(k) \t\t\t({ NULL; })\n#define key_revoke(k)\t\t\tdo { } while(0)\n#define key_invalidate(k)\t\tdo { } while(0)\n#define key_put(k)\t\t\tdo { } while(0)\n#define key_ref_put(k)\t\t\tdo { } while(0)\n#define make_key_ref(k, p)\t\tNULL\n#define key_ref_to_ptr(k)\t\tNULL\n#define is_key_possessed(k)\t\t0\n#define key_fsuid_changed(t)\t\tdo { } while(0)\n#define key_fsgid_changed(t)\t\tdo { } while(0)\n#define key_init()\t\t\tdo { } while(0)\n\n#endif /* CONFIG_KEYS */\n#endif /* __KERNEL__ */\n#endif /* _LINUX_KEY_H */\n", "/* Key type used to cache DNS lookups made by the kernel\n *\n * See Documentation/networking/dns_resolver.txt\n *\n *   Copyright (c) 2007 Igor Mammedov\n *   Author(s): Igor Mammedov (niallain@gmail.com)\n *              Steve French (sfrench@us.ibm.com)\n *              Wang Lei (wang840925@gmail.com)\n *\t\tDavid Howells (dhowells@redhat.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <linux/keyctl.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <keys/dns_resolver-type.h>\n#include <keys/user-type.h>\n#include \"internal.h\"\n\nMODULE_DESCRIPTION(\"DNS Resolver\");\nMODULE_AUTHOR(\"Wang Lei\");\nMODULE_LICENSE(\"GPL\");\n\nunsigned int dns_resolver_debug;\nmodule_param_named(debug, dns_resolver_debug, uint, S_IWUSR | S_IRUGO);\nMODULE_PARM_DESC(debug, \"DNS Resolver debugging mask\");\n\nconst struct cred *dns_resolver_cache;\n\n#define\tDNS_ERRORNO_OPTION\t\"dnserror\"\n\n/*\n * Preparse instantiation data for a dns_resolver key.\n *\n * The data must be a NUL-terminated string, with the NUL char accounted in\n * datalen.\n *\n * If the data contains a '#' characters, then we take the clause after each\n * one to be an option of the form 'key=value'.  The actual data of interest is\n * the string leading up to the first '#'.  For instance:\n *\n *        \"ip1,ip2,...#foo=bar\"\n */\nstatic int\ndns_resolver_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tunsigned long derrno;\n\tint ret;\n\tint datalen = prep->datalen, result_len = 0;\n\tconst char *data = prep->data, *end, *opt;\n\n\tkenter(\"'%*.*s',%u\", datalen, datalen, data, datalen);\n\n\tif (datalen <= 1 || !data || data[datalen - 1] != '\\0')\n\t\treturn -EINVAL;\n\tdatalen--;\n\n\t/* deal with any options embedded in the data */\n\tend = data + datalen;\n\topt = memchr(data, '#', datalen);\n\tif (!opt) {\n\t\t/* no options: the entire data is the result */\n\t\tkdebug(\"no options\");\n\t\tresult_len = datalen;\n\t} else {\n\t\tconst char *next_opt;\n\n\t\tresult_len = opt - data;\n\t\topt++;\n\t\tkdebug(\"options: '%s'\", opt);\n\t\tdo {\n\t\t\tconst char *eq;\n\t\t\tint opt_len, opt_nlen, opt_vlen, tmp;\n\n\t\t\tnext_opt = memchr(opt, '#', end - opt) ?: end;\n\t\t\topt_len = next_opt - opt;\n\t\t\tif (!opt_len) {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"Empty option to dns_resolver key\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\teq = memchr(opt, '=', opt_len) ?: end;\n\t\t\topt_nlen = eq - opt;\n\t\t\teq++;\n\t\t\topt_vlen = next_opt - eq; /* will be -1 if no value */\n\n\t\t\ttmp = opt_vlen >= 0 ? opt_vlen : 0;\n\t\t\tkdebug(\"option '%*.*s' val '%*.*s'\",\n\t\t\t       opt_nlen, opt_nlen, opt, tmp, tmp, eq);\n\n\t\t\t/* see if it's an error number representing a DNS error\n\t\t\t * that's to be recorded as the result in this key */\n\t\t\tif (opt_nlen == sizeof(DNS_ERRORNO_OPTION) - 1 &&\n\t\t\t    memcmp(opt, DNS_ERRORNO_OPTION, opt_nlen) == 0) {\n\t\t\t\tkdebug(\"dns error number option\");\n\t\t\t\tif (opt_vlen <= 0)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tret = kstrtoul(eq, 10, &derrno);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tif (derrno < 1 || derrno > 511)\n\t\t\t\t\tgoto bad_option_value;\n\n\t\t\t\tkdebug(\"dns error no. = %lu\", derrno);\n\t\t\t\tprep->payload.data[dns_key_error] = ERR_PTR(-derrno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\tbad_option_value:\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"Option '%*.*s' to dns_resolver key:\"\n\t\t\t       \" bad/missing value\\n\",\n\t\t\t       opt_nlen, opt_nlen, opt);\n\t\t\treturn -EINVAL;\n\t\t} while (opt = next_opt + 1, opt < end);\n\t}\n\n\t/* don't cache the result if we're caching an error saying there's no\n\t * result */\n\tif (prep->payload.data[dns_key_error]) {\n\t\tkleave(\" = 0 [h_error %ld]\", PTR_ERR(prep->payload.data[dns_key_error]));\n\t\treturn 0;\n\t}\n\n\tkdebug(\"store result\");\n\tprep->quotalen = result_len;\n\n\tupayload = kmalloc(sizeof(*upayload) + result_len + 1, GFP_KERNEL);\n\tif (!upayload) {\n\t\tkleave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\tupayload->datalen = result_len;\n\tmemcpy(upayload->data, data, result_len);\n\tupayload->data[result_len] = '\\0';\n\n\tprep->payload.data[dns_key_data] = upayload;\n\tkleave(\" = 0\");\n\treturn 0;\n}\n\n/*\n * Clean up the preparse data\n */\nstatic void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n{\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tkfree(prep->payload.data[dns_key_data]);\n}\n\n/*\n * The description is of the form \"[<type>:]<domain_name>\"\n *\n * The domain name may be a simple name or an absolute domain name (which\n * should end with a period).  The domain name is case-independent.\n */\nstatic bool dns_resolver_cmp(const struct key *key,\n\t\t\t     const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\n\tkenter(\"%s,%s\", src, dsp);\n\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\n\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Preparse the match criterion.\n */\nstatic int dns_resolver_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = dns_resolver_cmp;\n\treturn 0;\n}\n\n/*\n * Describe a DNS key\n */\nstatic void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key)) {\n\t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}\n\n/*\n * read the DNS data\n * - the key's semaphore is read-locked\n */\nstatic long dns_resolver_read(const struct key *key,\n\t\t\t      char __user *buffer, size_t buflen)\n{\n\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\n\tif (err)\n\t\treturn err;\n\n\treturn user_read(key, buffer, buflen);\n}\n\nstruct key_type key_type_dns_resolver = {\n\t.name\t\t= \"dns_resolver\",\n\t.preparse\t= dns_resolver_preparse,\n\t.free_preparse\t= dns_resolver_free_preparse,\n\t.instantiate\t= generic_key_instantiate,\n\t.match_preparse\t= dns_resolver_match_preparse,\n\t.revoke\t\t= user_revoke,\n\t.destroy\t= user_destroy,\n\t.describe\t= dns_resolver_describe,\n\t.read\t\t= dns_resolver_read,\n};\n\nstatic int __init init_dns_resolver(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\n\t/* create an override credential set with a special thread keyring in\n\t * which DNS requests are cached\n\t *\n\t * this is used to prevent malicious redirections from being installed\n\t * with add_key().\n\t */\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tkeyring = keyring_alloc(\".dns_resolver\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\n\tret = register_key_type(&key_type_dns_resolver);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\n\t/* instruct request_key() to use this special keyring as a cache for\n\t * the results it looks up */\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\tdns_resolver_cache = cred;\n\n\tkdebug(\"DNS resolver keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\n\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}\n\nstatic void __exit exit_dns_resolver(void)\n{\n\tkey_revoke(dns_resolver_cache->thread_keyring);\n\tunregister_key_type(&key_type_dns_resolver);\n\tput_cred(dns_resolver_cache);\n}\n\nmodule_init(init_dns_resolver)\nmodule_exit(exit_dns_resolver)\nMODULE_LICENSE(\"GPL\");\n\n", "/* Large capacity key type\n *\n * Copyright (C) 2017 Jason A. Donenfeld <Jason@zx2c4.com>. All Rights Reserved.\n * Copyright (C) 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) \"big_key: \"fmt\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/shmem_fs.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/random.h>\n#include <keys/user-type.h>\n#include <keys/big_key-type.h>\n#include <crypto/aead.h>\n\n/*\n * Layout of key payload words.\n */\nenum {\n\tbig_key_data,\n\tbig_key_path,\n\tbig_key_path_2nd_part,\n\tbig_key_len,\n};\n\n/*\n * Crypto operation with big_key data\n */\nenum big_key_op {\n\tBIG_KEY_ENC,\n\tBIG_KEY_DEC,\n};\n\n/*\n * If the data is under this limit, there's no point creating a shm file to\n * hold it as the permanently resident metadata for the shmem fs will be at\n * least as large as the data.\n */\n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\n/*\n * Key size for big_key data encryption\n */\n#define ENC_KEY_SIZE 32\n\n/*\n * Authentication tag length\n */\n#define ENC_AUTHTAG_SIZE 16\n\n/*\n * big_key defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n\t/* no ->update(); don't add it without changing big_key_crypt() nonce */\n};\n\n/*\n * Crypto names for big_key data authenticated encryption\n */\nstatic const char big_key_alg_name[] = \"gcm(aes)\";\n\n/*\n * Crypto algorithms for big_key data authenticated encryption\n */\nstatic struct crypto_aead *big_key_aead;\n\n/*\n * Since changing the key affects the entire object, we need a mutex.\n */\nstatic DEFINE_MUTEX(big_key_aead_lock);\n\n/*\n * Encrypt/decrypt big_key data\n */\nstatic int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)\n{\n\tint ret;\n\tstruct scatterlist sgio;\n\tstruct aead_request *aead_req;\n\t/* We always use a zero nonce. The reason we can get away with this is\n\t * because we're using a different randomly generated key for every\n\t * different encryption. Notably, too, key_type_big_key doesn't define\n\t * an .update function, so there's no chance we'll wind up reusing the\n\t * key to encrypt updated data. Simply put: one key, one encryption.\n\t */\n\tu8 zero_nonce[crypto_aead_ivsize(big_key_aead)];\n\n\taead_req = aead_request_alloc(big_key_aead, GFP_KERNEL);\n\tif (!aead_req)\n\t\treturn -ENOMEM;\n\n\tmemset(zero_nonce, 0, sizeof(zero_nonce));\n\tsg_init_one(&sgio, data, datalen + (op == BIG_KEY_ENC ? ENC_AUTHTAG_SIZE : 0));\n\taead_request_set_crypt(aead_req, &sgio, &sgio, datalen, zero_nonce);\n\taead_request_set_callback(aead_req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\n\taead_request_set_ad(aead_req, 0);\n\n\tmutex_lock(&big_key_aead_lock);\n\tif (crypto_aead_setkey(big_key_aead, key, ENC_KEY_SIZE)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\tif (op == BIG_KEY_ENC)\n\t\tret = crypto_aead_encrypt(aead_req);\n\telse\n\t\tret = crypto_aead_decrypt(aead_req);\nerror:\n\tmutex_unlock(&big_key_aead_lock);\n\taead_request_free(aead_req);\n\treturn ret;\n}\n\n/*\n * Preparse a big key\n */\nint big_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct path *path = (struct path *)&prep->payload.data[big_key_path];\n\tstruct file *file;\n\tu8 *enckey;\n\tu8 *data = NULL;\n\tssize_t written;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 1024 * 1024 || !prep->data)\n\t\tgoto error;\n\n\t/* Set an arbitrary quota */\n\tprep->quotalen = 16;\n\n\tprep->payload.data[big_key_len] = (void *)(unsigned long)datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\t/* Create a shmem file to store the data in.  This will permit the data\n\t\t * to be swapped out if needed.\n\t\t *\n\t\t * File content is stored encrypted with randomly generated key.\n\t\t */\n\t\tsize_t enclen = datalen + ENC_AUTHTAG_SIZE;\n\t\tloff_t pos = 0;\n\n\t\tdata = kmalloc(enclen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(data, prep->data, datalen);\n\n\t\t/* generate random key */\n\t\tenckey = kmalloc(ENC_KEY_SIZE, GFP_KERNEL);\n\t\tif (!enckey) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tret = get_random_bytes_wait(enckey, ENC_KEY_SIZE);\n\t\tif (unlikely(ret))\n\t\t\tgoto err_enckey;\n\n\t\t/* encrypt aligned data */\n\t\tret = big_key_crypt(BIG_KEY_ENC, data, datalen, enckey);\n\t\tif (ret)\n\t\t\tgoto err_enckey;\n\n\t\t/* save aligned data to file */\n\t\tfile = shmem_kernel_file_setup(\"\", enclen, 0);\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto err_enckey;\n\t\t}\n\n\t\twritten = kernel_write(file, data, enclen, &pos);\n\t\tif (written != enclen) {\n\t\t\tret = written;\n\t\t\tif (written >= 0)\n\t\t\t\tret = -ENOMEM;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\t/* Pin the mount and dentry to the key so that we can open it again\n\t\t * later\n\t\t */\n\t\tprep->payload.data[big_key_data] = enckey;\n\t\t*path = file->f_path;\n\t\tpath_get(path);\n\t\tfput(file);\n\t\tkzfree(data);\n\t} else {\n\t\t/* Just store the data in a buffer */\n\t\tvoid *data = kmalloc(datalen, GFP_KERNEL);\n\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tprep->payload.data[big_key_data] = data;\n\t\tmemcpy(data, prep->data, prep->datalen);\n\t}\n\treturn 0;\n\nerr_fput:\n\tfput(file);\nerr_enckey:\n\tkzfree(enckey);\nerror:\n\tkzfree(data);\n\treturn ret;\n}\n\n/*\n * Clear preparsement.\n */\nvoid big_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tif (prep->datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&prep->payload.data[big_key_path];\n\n\t\tpath_put(path);\n\t}\n\tkzfree(prep->payload.data[big_key_data]);\n}\n\n/*\n * dispose of the links from a revoked keyring\n * - called with the key sem write-locked\n */\nvoid big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\tif (key_is_positive(key) &&\n\t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}\n\n/*\n * dispose of the data dangling from the corpse of a big_key key\n */\nvoid big_key_destroy(struct key *key)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\t\tpath_put(path);\n\t\tpath->mnt = NULL;\n\t\tpath->dentry = NULL;\n\t}\n\tkzfree(key->payload.data[big_key_data]);\n\tkey->payload.data[big_key_data] = NULL;\n}\n\n/*\n * describe the big_key key\n */\nvoid big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}\n\n/*\n * read the key data\n * - the key's semaphore is read-locked\n */\nlong big_key_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\tlong ret;\n\n\tif (!buffer || buflen < datalen)\n\t\treturn datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\t\tstruct file *file;\n\t\tu8 *data;\n\t\tu8 *enckey = (u8 *)key->payload.data[big_key_data];\n\t\tsize_t enclen = datalen + ENC_AUTHTAG_SIZE;\n\t\tloff_t pos = 0;\n\n\t\tdata = kmalloc(enclen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tfile = dentry_open(path, O_RDONLY, current_cred());\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* read file to kernel and decrypt */\n\t\tret = kernel_read(file, data, enclen, &pos);\n\t\tif (ret >= 0 && ret != enclen) {\n\t\t\tret = -EIO;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\tret = big_key_crypt(BIG_KEY_DEC, data, enclen, enckey);\n\t\tif (ret)\n\t\t\tgoto err_fput;\n\n\t\tret = datalen;\n\n\t\t/* copy decrypted data to user */\n\t\tif (copy_to_user(buffer, data, datalen) != 0)\n\t\t\tret = -EFAULT;\n\nerr_fput:\n\t\tfput(file);\nerror:\n\t\tkzfree(data);\n\t} else {\n\t\tret = datalen;\n\t\tif (copy_to_user(buffer, key->payload.data[big_key_data],\n\t\t\t\t datalen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Register key type\n */\nstatic int __init big_key_init(void)\n{\n\tint ret;\n\n\t/* init block cipher */\n\tbig_key_aead = crypto_alloc_aead(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_aead)) {\n\t\tret = PTR_ERR(big_key_aead);\n\t\tpr_err(\"Can't alloc crypto: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = crypto_aead_setauthsize(big_key_aead, ENC_AUTHTAG_SIZE);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't set crypto auth tag len: %d\\n\", ret);\n\t\tgoto free_aead;\n\t}\n\n\tret = register_key_type(&key_type_big_key);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't register type: %d\\n\", ret);\n\t\tgoto free_aead;\n\t}\n\n\treturn 0;\n\nfree_aead:\n\tcrypto_free_aead(big_key_aead);\n\treturn ret;\n}\n\nlate_initcall(big_key_init);\n", "/*\n * Copyright (C) 2010 IBM Corporation\n * Copyright (C) 2010 Politecnico di Torino, Italy\n *                    TORSEC group -- http://security.polito.it\n *\n * Authors:\n * Mimi Zohar <zohar@us.ibm.com>\n * Roberto Sassu <roberto.sassu@polito.it>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * See Documentation/security/keys/trusted-encrypted.rst\n */\n\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <keys/encrypted-type.h>\n#include <linux/key-type.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/scatterlist.h>\n#include <linux/ctype.h>\n#include <crypto/aes.h>\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <crypto/sha.h>\n#include <crypto/skcipher.h>\n\n#include \"encrypted.h\"\n#include \"ecryptfs_format.h\"\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\nstatic const char hash_alg[] = \"sha256\";\nstatic const char hmac_alg[] = \"hmac(sha256)\";\nstatic const char blkcipher_alg[] = \"cbc(aes)\";\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\nstatic int blksize;\n\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_ECRYPTFS_DESC_LEN 16\n#define HASH_SIZE SHA256_DIGEST_SIZE\n#define MAX_DATA_SIZE 4096\n#define MIN_DATA_SIZE  20\n\nstatic struct crypto_shash *hash_tfm;\n\nenum {\n\tOpt_err = -1, Opt_new, Opt_load, Opt_update\n};\n\nenum {\n\tOpt_error = -1, Opt_default, Opt_ecryptfs\n};\n\nstatic const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_error, NULL}\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};\n\nstatic int aes_get_sizes(void)\n{\n\tstruct crypto_skcipher *tfm;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to alloc_cipher (%ld)\\n\",\n\t\t       PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tivsize = crypto_skcipher_ivsize(tfm);\n\tblksize = crypto_skcipher_blocksize(tfm);\n\tcrypto_free_skcipher(tfm);\n\treturn 0;\n}\n\n/*\n * valid_ecryptfs_desc - verify the description of a new/loaded encrypted key\n *\n * The description of a encrypted key with format 'ecryptfs' must contain\n * exactly 16 hexadecimal characters.\n *\n */\nstatic int valid_ecryptfs_desc(const char *ecryptfs_desc)\n{\n\tint i;\n\n\tif (strlen(ecryptfs_desc) != KEY_ECRYPTFS_DESC_LEN) {\n\t\tpr_err(\"encrypted_key: key description must be %d hexadecimal \"\n\t\t       \"characters long\\n\", KEY_ECRYPTFS_DESC_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < KEY_ECRYPTFS_DESC_LEN; i++) {\n\t\tif (!isxdigit(ecryptfs_desc[i])) {\n\t\t\tpr_err(\"encrypted_key: key description must contain \"\n\t\t\t       \"only hexadecimal characters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/*\n * valid_master_desc - verify the 'key-type:desc' of a new/updated master-key\n *\n * key-type:= \"trusted:\" | \"user:\"\n * desc:= master-key description\n *\n * Verify that 'key-type' is valid and that 'desc' exists. On key update,\n * only the master key description is permitted to change, not the key-type.\n * The key-type remains constant.\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/*\n * datablob_parse - parse the keyctl data\n *\n * datablob format:\n * new [<format>] <master-key name> <decrypted data length>\n * load [<format>] <master-key name> <decrypted data length>\n *     <encrypted iv + data>\n * update <new-master-key name>\n *\n * Tokenizes a copy of the keyctl data, returning a pointer to each token,\n * which is null terminated.\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}\n\n/*\n * datablob_format - format as an ascii string, before copying to userspace\n */\nstatic char *datablob_format(struct encrypted_key_payload *epayload,\n\t\t\t     size_t asciiblob_len)\n{\n\tchar *ascii_buf, *bufp;\n\tu8 *iv = epayload->iv;\n\tint len;\n\tint i;\n\n\tascii_buf = kmalloc(asciiblob_len + 1, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\tgoto out;\n\n\tascii_buf[asciiblob_len] = '\\0';\n\n\t/* copy datablob master_desc and datalen strings */\n\tlen = sprintf(ascii_buf, \"%s %s %s \", epayload->format,\n\t\t      epayload->master_desc, epayload->datalen);\n\n\t/* convert the hex encoded iv, encrypted-data and HMAC to ascii */\n\tbufp = &ascii_buf[len];\n\tfor (i = 0; i < (asciiblob_len - len) / 2; i++)\n\t\tbufp = hex_byte_pack(bufp, iv[i]);\nout:\n\treturn ascii_buf;\n}\n\n/*\n * request_user_key - request the user key\n *\n * Use a user provided key to encrypt/decrypt an encrypted-key.\n */\nstatic struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload_locked(ukey);\n\tif (!upayload) {\n\t\t/* key was revoked before we acquired its semaphore */\n\t\tup_read(&ukey->sem);\n\t\tkey_put(ukey);\n\t\tukey = ERR_PTR(-EKEYREVOKED);\n\t\tgoto error;\n\t}\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}\n\nstatic int calc_hash(struct crypto_shash *tfm, u8 *digest,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tint err;\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\terr = crypto_shash_digest(desc, buf, buflen, digest);\n\tshash_desc_zero(desc);\n\treturn err;\n}\n\nstatic int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct crypto_shash *tfm;\n\tint err;\n\n\ttfm = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: can't alloc %s transform: %ld\\n\",\n\t\t       hmac_alg, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = crypto_shash_setkey(tfm, key, keylen);\n\tif (!err)\n\t\terr = calc_hash(tfm, digest, buf, buflen);\n\tcrypto_free_shash(tfm);\n\treturn err;\n}\n\nenum derived_key_type { ENC_KEY, AUTH_KEY };\n\n/* Derive authentication/encryption key from trusted key */\nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(hash_tfm, derived_key, derived_buf, derived_buf_len);\n\tkzfree(derived_buf);\n\treturn ret;\n}\n\nstatic struct skcipher_request *init_skcipher_req(const u8 *key,\n\t\t\t\t\t\t  unsigned int key_len)\n{\n\tstruct skcipher_request *req;\n\tstruct crypto_skcipher *tfm;\n\tint ret;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(tfm));\n\t\treturn ERR_CAST(tfm);\n\t}\n\n\tret = crypto_skcipher_setkey(tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_err(\"encrypted_key: failed to allocate request for %s\\n\",\n\t\t       blkcipher_alg);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\treturn req;\n}\n\nstatic struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}\n\n/* Before returning data to userspace, encrypt decrypted data. */\nstatic int derived_key_encrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[2];\n\tstruct scatterlist sg_out[1];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\n\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_page(&sg_in[1], ZERO_PAGE(0), AES_BLOCK_SIZE, 0);\n\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_encrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to encrypt (%d)\\n\", ret);\n\telse\n\t\tdump_encrypted_data(epayload, encrypted_datalen);\nout:\n\treturn ret;\n}\n\nstatic int datablob_hmac_append(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *master_key, size_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 *digest;\n\tint ret;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdigest = epayload->format + epayload->datablob_len;\n\tret = calc_hmac(digest, derived_key, sizeof derived_key,\n\t\t\tepayload->format, epayload->datablob_len);\n\tif (!ret)\n\t\tdump_hmac(NULL, digest, HASH_SIZE);\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n\n/* verify HMAC before decrypting encrypted key */\nstatic int datablob_hmac_verify(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *format, const u8 *master_key,\n\t\t\t\tsize_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 digest[HASH_SIZE];\n\tint ret;\n\tchar *p;\n\tunsigned short len;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = epayload->datablob_len;\n\tif (!format) {\n\t\tp = epayload->master_desc;\n\t\tlen -= strlen(epayload->format) + 1;\n\t} else\n\t\tp = epayload->format;\n\n\tret = calc_hmac(digest, derived_key, sizeof derived_key, p, len);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_memneq(digest, epayload->format + epayload->datablob_len,\n\t\t\t    sizeof(digest));\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tdump_hmac(\"datablob\",\n\t\t\t  epayload->format + epayload->datablob_len,\n\t\t\t  HASH_SIZE);\n\t\tdump_hmac(\"calc\", digest, HASH_SIZE);\n\t}\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n\nstatic int derived_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[1];\n\tstruct scatterlist sg_out[2];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tu8 *pad;\n\tint ret;\n\n\t/* Throwaway buffer to hold the unused zero padding at the end */\n\tpad = kmalloc(AES_BLOCK_SIZE, GFP_KERNEL);\n\tif (!pad)\n\t\treturn -ENOMEM;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_encrypted_data(epayload, encrypted_datalen);\n\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, epayload->encrypted_data, encrypted_datalen);\n\tsg_set_buf(&sg_out[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_out[1], pad, AES_BLOCK_SIZE);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_decrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\nout:\n\tkfree(pad);\n\treturn ret;\n}\n\n/* Allocate memory for decrypted key and datablob. */\nstatic struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\",\n\t\t\t       ECRYPTFS_MAX_KEY_BYTES);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}\n\nstatic int encrypted_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t\t const char *format, const char *hex_encoded_iv)\n{\n\tstruct key *mkey;\n\tu8 derived_key[HASH_SIZE];\n\tconst u8 *master_key;\n\tu8 *hmac;\n\tconst char *hex_encoded_data;\n\tunsigned int encrypted_datalen;\n\tsize_t master_keylen;\n\tsize_t asciilen;\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\n\tif (strlen(hex_encoded_iv) != asciilen)\n\t\treturn -EINVAL;\n\n\thex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\n\tret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tret = hex2bin(epayload->encrypted_data, hex_encoded_data,\n\t\t      encrypted_datalen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\thmac = epayload->format + epayload->datablob_len;\n\tret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\n\t\t      HASH_SIZE);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: bad hmac (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to decrypt key (%d)\\n\", ret);\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n\nstatic void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}\n\n/*\n * encrypted_init - initialize an encrypted key\n *\n * For a new key, use a random number for both the iv and data\n * itself.  For an old key, decrypt the hex encoded data.\n */\nstatic int encrypted_init(struct encrypted_key_payload *epayload,\n\t\t\t  const char *key_desc, const char *format,\n\t\t\t  const char *master_desc, const char *datalen,\n\t\t\t  const char *hex_encoded_iv)\n{\n\tint ret = 0;\n\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tret = valid_ecryptfs_desc(key_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\n\t\t\t\t       key_desc);\n\t}\n\n\t__ekey_init(epayload, format, master_desc, datalen);\n\tif (!hex_encoded_iv) {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\n\t\tget_random_bytes(epayload->decrypted_data,\n\t\t\t\t epayload->decrypted_datalen);\n\t} else\n\t\tret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\n\treturn ret;\n}\n\n/*\n * encrypted_instantiate - instantiate an encrypted key\n *\n * Decrypt an existing encrypted datablob or create a new encrypted key\n * based on a kernel random number.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int encrypted_instantiate(struct key *key,\n\t\t\t\t struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tchar *datablob = NULL;\n\tconst char *format = NULL;\n\tchar *master_desc = NULL;\n\tchar *decrypted_datalen = NULL;\n\tchar *hex_encoded_iv = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tdatablob[datalen] = 0;\n\tmemcpy(datablob, prep->data, datalen);\n\tret = datablob_parse(datablob, &format, &master_desc,\n\t\t\t     &decrypted_datalen, &hex_encoded_iv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tepayload = encrypted_key_alloc(key, format, master_desc,\n\t\t\t\t       decrypted_datalen);\n\tif (IS_ERR(epayload)) {\n\t\tret = PTR_ERR(epayload);\n\t\tgoto out;\n\t}\n\tret = encrypted_init(epayload, key->description, format, master_desc,\n\t\t\t     decrypted_datalen, hex_encoded_iv);\n\tif (ret < 0) {\n\t\tkzfree(epayload);\n\t\tgoto out;\n\t}\n\n\trcu_assign_keypointer(key, epayload);\nout:\n\tkzfree(datablob);\n\treturn ret;\n}\n\nstatic void encrypted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct encrypted_key_payload *epayload;\n\n\tepayload = container_of(rcu, struct encrypted_key_payload, rcu);\n\tkzfree(epayload);\n}\n\n/*\n * encrypted_update - update the master key description\n *\n * Change the master key description for an existing encrypted key.\n * The next read will return an encrypted datablob using the new\n * master key description.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (key_is_negative(key))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkzfree(buf);\n\treturn ret;\n}\n\n/*\n * encrypted_read - format and copy the encrypted data to userspace\n *\n * The resulting datablob format is:\n * <master-key name> <decrypted data length> <encrypted iv> <encrypted data>\n *\n * On success, return to userspace the encrypted key datablob size.\n */\nstatic long encrypted_read(const struct key *key, char __user *buffer,\n\t\t\t   size_t buflen)\n{\n\tstruct encrypted_key_payload *epayload;\n\tstruct key *mkey;\n\tconst u8 *master_key;\n\tsize_t master_keylen;\n\tchar derived_key[HASH_SIZE];\n\tchar *ascii_buf;\n\tsize_t asciiblob_len;\n\tint ret;\n\n\tepayload = dereference_key_locked(key);\n\n\t/* returns the hex encoded iv, encrypted-data, and hmac as ascii */\n\tasciiblob_len = epayload->datablob_len + ivsize + 1\n\t    + roundup(epayload->decrypted_datalen, blksize)\n\t    + (HASH_SIZE * 2);\n\n\tif (!buffer || buflen < asciiblob_len)\n\t\treturn asciiblob_len;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = datablob_hmac_append(epayload, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tascii_buf = datablob_format(epayload, asciiblob_len);\n\tif (!ascii_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\n\tif (copy_to_user(buffer, ascii_buf, asciiblob_len) != 0)\n\t\tret = -EFAULT;\n\tkzfree(ascii_buf);\n\n\treturn asciiblob_len;\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}\n\n/*\n * encrypted_destroy - clear and free the key's payload\n */\nstatic void encrypted_destroy(struct key *key)\n{\n\tkzfree(key->payload.data[0]);\n}\n\nstruct key_type key_type_encrypted = {\n\t.name = \"encrypted\",\n\t.instantiate = encrypted_instantiate,\n\t.update = encrypted_update,\n\t.destroy = encrypted_destroy,\n\t.describe = user_describe,\n\t.read = encrypted_read,\n};\nEXPORT_SYMBOL_GPL(key_type_encrypted);\n\nstatic int __init init_encrypted(void)\n{\n\tint ret;\n\n\thash_tfm = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hash_tfm)) {\n\t\tpr_err(\"encrypted_key: can't allocate %s transform: %ld\\n\",\n\t\t       hash_alg, PTR_ERR(hash_tfm));\n\t\treturn PTR_ERR(hash_tfm);\n\t}\n\n\tret = aes_get_sizes();\n\tif (ret < 0)\n\t\tgoto out;\n\tret = register_key_type(&key_type_encrypted);\n\tif (ret < 0)\n\t\tgoto out;\n\treturn 0;\nout:\n\tcrypto_free_shash(hash_tfm);\n\treturn ret;\n\n}\n\nstatic void __exit cleanup_encrypted(void)\n{\n\tcrypto_free_shash(hash_tfm);\n\tunregister_key_type(&key_type_encrypted);\n}\n\nlate_initcall(init_encrypted);\nmodule_exit(cleanup_encrypted);\n\nMODULE_LICENSE(\"GPL\");\n", "/* Key garbage collector\n *\n * Copyright (C) 2009-2011 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public Licence\n * as published by the Free Software Foundation; either version\n * 2 of the Licence, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <keys/keyring-type.h>\n#include \"internal.h\"\n\n/*\n * Delay between key revocation/expiry in seconds\n */\nunsigned key_gc_delay = 5 * 60;\n\n/*\n * Reaper for unused keys.\n */\nstatic void key_garbage_collector(struct work_struct *work);\nDECLARE_WORK(key_gc_work, key_garbage_collector);\n\n/*\n * Reaper for links from keyrings to dead keys.\n */\nstatic void key_gc_timer_func(unsigned long);\nstatic DEFINE_TIMER(key_gc_timer, key_gc_timer_func, 0, 0);\n\nstatic time_t key_gc_next_run = LONG_MAX;\nstatic struct key_type *key_gc_dead_keytype;\n\nstatic unsigned long key_gc_flags;\n#define KEY_GC_KEY_EXPIRED\t0\t/* A key expired and needs unlinking */\n#define KEY_GC_REAP_KEYTYPE\t1\t/* A keytype is being unregistered */\n#define KEY_GC_REAPING_KEYTYPE\t2\t/* Cleared when keytype reaped */\n\n\n/*\n * Any key whose type gets unregistered will be re-typed to this if it can't be\n * immediately unlinked.\n */\nstruct key_type key_type_dead = {\n\t.name = \".dead\",\n};\n\n/*\n * Schedule a garbage collection run.\n * - time precision isn't particularly important\n */\nvoid key_schedule_gc(time_t gc_at)\n{\n\tunsigned long expires;\n\ttime_t now = current_kernel_time().tv_sec;\n\n\tkenter(\"%ld\", gc_at - now);\n\n\tif (gc_at <= now || test_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags)) {\n\t\tkdebug(\"IMMEDIATE\");\n\t\tschedule_work(&key_gc_work);\n\t} else if (gc_at < key_gc_next_run) {\n\t\tkdebug(\"DEFERRED\");\n\t\tkey_gc_next_run = gc_at;\n\t\texpires = jiffies + (gc_at - now) * HZ;\n\t\tmod_timer(&key_gc_timer, expires);\n\t}\n}\n\n/*\n * Schedule a dead links collection run.\n */\nvoid key_schedule_gc_links(void)\n{\n\tset_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags);\n\tschedule_work(&key_gc_work);\n}\n\n/*\n * Some key's cleanup time was met after it expired, so we need to get the\n * reaper to go through a cycle finding expired keys.\n */\nstatic void key_gc_timer_func(unsigned long data)\n{\n\tkenter(\"\");\n\tkey_gc_next_run = LONG_MAX;\n\tkey_schedule_gc_links();\n}\n\n/*\n * Reap keys of dead type.\n *\n * We use three flags to make sure we see three complete cycles of the garbage\n * collector: the first to mark keys of that type as being dead, the second to\n * collect dead links and the third to clean up the dead keys.  We have to be\n * careful as there may already be a cycle in progress.\n *\n * The caller must be holding key_types_sem.\n */\nvoid key_gc_keytype(struct key_type *ktype)\n{\n\tkenter(\"%s\", ktype->name);\n\n\tkey_gc_dead_keytype = ktype;\n\tset_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\tsmp_mb();\n\tset_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags);\n\n\tkdebug(\"schedule\");\n\tschedule_work(&key_gc_work);\n\n\tkdebug(\"sleep\");\n\twait_on_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE,\n\t\t    TASK_UNINTERRUPTIBLE);\n\n\tkey_gc_dead_keytype = NULL;\n\tkleave(\"\");\n}\n\n/*\n * Garbage collect a list of unreferenced, detached keys\n */\nstatic noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tshort state = key->state;\n\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t/* Throw away the key data if the key is instantiated */\n\t\tif (state == KEY_IS_POSITIVE && key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (state != KEY_IS_UNINSTANTIATED)\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}\n\n/*\n * Garbage collector for unused keys.\n *\n * This is done in process context so that we don't have to disable interrupts\n * all over the place.  key_put() schedules this rather than trying to do the\n * cleanup itself, which means key_put() doesn't have to sleep.\n */\nstatic void key_garbage_collector(struct work_struct *work)\n{\n\tstatic LIST_HEAD(graveyard);\n\tstatic u8 gc_state;\t\t/* Internal persistent state */\n#define KEY_GC_REAP_AGAIN\t0x01\t/* - Need another cycle */\n#define KEY_GC_REAPING_LINKS\t0x02\t/* - We need to reap links */\n#define KEY_GC_SET_TIMER\t0x04\t/* - We need to restart the timer */\n#define KEY_GC_REAPING_DEAD_1\t0x10\t/* - We need to mark dead keys */\n#define KEY_GC_REAPING_DEAD_2\t0x20\t/* - We need to reap dead key links */\n#define KEY_GC_REAPING_DEAD_3\t0x40\t/* - We need to reap dead keys */\n#define KEY_GC_FOUND_DEAD_KEY\t0x80\t/* - We found at least one dead key */\n\n\tstruct rb_node *cursor;\n\tstruct key *key;\n\ttime_t new_timer, limit;\n\n\tkenter(\"[%lx,%x]\", key_gc_flags, gc_state);\n\n\tlimit = current_kernel_time().tv_sec;\n\tif (limit > key_gc_delay)\n\t\tlimit -= key_gc_delay;\n\telse\n\t\tlimit = key_gc_delay;\n\n\t/* Work out what we're going to be doing in this pass */\n\tgc_state &= KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2;\n\tgc_state <<= 1;\n\tif (test_and_clear_bit(KEY_GC_KEY_EXPIRED, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_LINKS | KEY_GC_SET_TIMER;\n\n\tif (test_and_clear_bit(KEY_GC_REAP_KEYTYPE, &key_gc_flags))\n\t\tgc_state |= KEY_GC_REAPING_DEAD_1;\n\tkdebug(\"new pass %x\", gc_state);\n\n\tnew_timer = LONG_MAX;\n\n\t/* As only this function is permitted to remove things from the key\n\t * serial tree, if cursor is non-NULL then it will always point to a\n\t * valid node in the tree - even if lock got dropped.\n\t */\n\tspin_lock(&key_serial_lock);\n\tcursor = rb_first(&key_serial_tree);\n\ncontinue_scanning:\n\twhile (cursor) {\n\t\tkey = rb_entry(cursor, struct key, serial_node);\n\t\tcursor = rb_next(cursor);\n\n\t\tif (refcount_read(&key->usage) == 0)\n\t\t\tgoto found_unreferenced_key;\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_1)) {\n\t\t\tif (key->type == key_gc_dead_keytype) {\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\t\t\t\tset_bit(KEY_FLAG_DEAD, &key->flags);\n\t\t\t\tkey->perm = 0;\n\t\t\t\tgoto skip_dead_key;\n\t\t\t} else if (key->type == &key_type_keyring &&\n\t\t\t\t   key->restrict_link) {\n\t\t\t\tgoto found_restricted_keyring;\n\t\t\t}\n\t\t}\n\n\t\tif (gc_state & KEY_GC_SET_TIMER) {\n\t\t\tif (key->expiry > limit && key->expiry < new_timer) {\n\t\t\t\tkdebug(\"will expire %x in %ld\",\n\t\t\t\t       key_serial(key), key->expiry - limit);\n\t\t\t\tnew_timer = key->expiry;\n\t\t\t}\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgc_state |= KEY_GC_FOUND_DEAD_KEY;\n\n\t\tif ((gc_state & KEY_GC_REAPING_LINKS) ||\n\t\t    unlikely(gc_state & KEY_GC_REAPING_DEAD_2)) {\n\t\t\tif (key->type == &key_type_keyring)\n\t\t\t\tgoto found_keyring;\n\t\t}\n\n\t\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3))\n\t\t\tif (key->type == key_gc_dead_keytype)\n\t\t\t\tgoto destroy_dead_key;\n\n\tskip_dead_key:\n\t\tif (spin_is_contended(&key_serial_lock) || need_resched())\n\t\t\tgoto contended;\n\t}\n\ncontended:\n\tspin_unlock(&key_serial_lock);\n\nmaybe_resched:\n\tif (cursor) {\n\t\tcond_resched();\n\t\tspin_lock(&key_serial_lock);\n\t\tgoto continue_scanning;\n\t}\n\n\t/* We've completed the pass.  Set the timer if we need to and queue a\n\t * new cycle if necessary.  We keep executing cycles until we find one\n\t * where we didn't reap any keys.\n\t */\n\tkdebug(\"pass complete\");\n\n\tif (gc_state & KEY_GC_SET_TIMER && new_timer != (time_t)LONG_MAX) {\n\t\tnew_timer += key_gc_delay;\n\t\tkey_schedule_gc(new_timer);\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_2) ||\n\t    !list_empty(&graveyard)) {\n\t\t/* Make sure that all pending keyring payload destructions are\n\t\t * fulfilled and that people aren't now looking at dead or\n\t\t * dying keys that they don't have a reference upon or a link\n\t\t * to.\n\t\t */\n\t\tkdebug(\"gc sync\");\n\t\tsynchronize_rcu();\n\t}\n\n\tif (!list_empty(&graveyard)) {\n\t\tkdebug(\"gc keys\");\n\t\tkey_gc_unused_keys(&graveyard);\n\t}\n\n\tif (unlikely(gc_state & (KEY_GC_REAPING_DEAD_1 |\n\t\t\t\t KEY_GC_REAPING_DEAD_2))) {\n\t\tif (!(gc_state & KEY_GC_FOUND_DEAD_KEY)) {\n\t\t\t/* No remaining dead keys: short circuit the remaining\n\t\t\t * keytype reap cycles.\n\t\t\t */\n\t\t\tkdebug(\"dead short\");\n\t\t\tgc_state &= ~(KEY_GC_REAPING_DEAD_1 | KEY_GC_REAPING_DEAD_2);\n\t\t\tgc_state |= KEY_GC_REAPING_DEAD_3;\n\t\t} else {\n\t\t\tgc_state |= KEY_GC_REAP_AGAIN;\n\t\t}\n\t}\n\n\tif (unlikely(gc_state & KEY_GC_REAPING_DEAD_3)) {\n\t\tkdebug(\"dead wake\");\n\t\tsmp_mb();\n\t\tclear_bit(KEY_GC_REAPING_KEYTYPE, &key_gc_flags);\n\t\twake_up_bit(&key_gc_flags, KEY_GC_REAPING_KEYTYPE);\n\t}\n\n\tif (gc_state & KEY_GC_REAP_AGAIN)\n\t\tschedule_work(&key_gc_work);\n\tkleave(\" [end %x]\", gc_state);\n\treturn;\n\n\t/* We found an unreferenced key - once we've removed it from the tree,\n\t * we can safely drop the lock.\n\t */\nfound_unreferenced_key:\n\tkdebug(\"unrefd key %d\", key->serial);\n\trb_erase(&key->serial_node, &key_serial_tree);\n\tspin_unlock(&key_serial_lock);\n\n\tlist_add_tail(&key->graveyard_link, &graveyard);\n\tgc_state |= KEY_GC_REAP_AGAIN;\n\tgoto maybe_resched;\n\n\t/* We found a restricted keyring and need to update the restriction if\n\t * it is associated with the dead key type.\n\t */\nfound_restricted_keyring:\n\tspin_unlock(&key_serial_lock);\n\tkeyring_restriction_gc(key, key_gc_dead_keytype);\n\tgoto maybe_resched;\n\n\t/* We found a keyring and we need to check the payload for links to\n\t * dead or expired keys.  We don't flag another reap immediately as we\n\t * have to wait for the old payload to be destroyed by RCU before we\n\t * can reap the keys to which it refers.\n\t */\nfound_keyring:\n\tspin_unlock(&key_serial_lock);\n\tkeyring_gc(key, limit);\n\tgoto maybe_resched;\n\n\t/* We found a dead key that is still referenced.  Reset its type and\n\t * destroy its payload with its semaphore held.\n\t */\ndestroy_dead_key:\n\tspin_unlock(&key_serial_lock);\n\tkdebug(\"destroy key %d\", key->serial);\n\tdown_write(&key->sem);\n\tkey->type = &key_type_dead;\n\tif (key_gc_dead_keytype->destroy)\n\t\tkey_gc_dead_keytype->destroy(key);\n\tmemset(&key->payload, KEY_DESTROY, sizeof(key->payload));\n\tup_write(&key->sem);\n\tgoto maybe_resched;\n}\n", "/* Basic authentication token and access key management\n *\n * Copyright (C) 2004-2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/poison.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/random.h>\n#include <linux/err.h>\n#include \"internal.h\"\n\nstruct kmem_cache *key_jar;\nstruct rb_root\t\tkey_serial_tree; /* tree of keys indexed by serial */\nDEFINE_SPINLOCK(key_serial_lock);\n\nstruct rb_root\tkey_user_tree; /* tree of quota records indexed by UID */\nDEFINE_SPINLOCK(key_user_lock);\n\nunsigned int key_quota_root_maxkeys = 1000000;\t/* root's key count quota */\nunsigned int key_quota_root_maxbytes = 25000000; /* root's key space quota */\nunsigned int key_quota_maxkeys = 200;\t\t/* general key count quota */\nunsigned int key_quota_maxbytes = 20000;\t/* general key space quota */\n\nstatic LIST_HEAD(key_types_list);\nstatic DECLARE_RWSEM(key_types_sem);\n\n/* We serialise key instantiation and link */\nDEFINE_MUTEX(key_construction_mutex);\n\n#ifdef KEY_DEBUGGING\nvoid __key_check(const struct key *key)\n{\n\tprintk(\"__key_check: key %p {%08x} should be {%08x}\\n\",\n\t       key, key->magic, KEY_DEBUG_MAGIC);\n\tBUG();\n}\n#endif\n\n/*\n * Get the key quota record for a user, allocating a new record if one doesn't\n * already exist.\n */\nstruct key_user *key_user_lookup(kuid_t uid)\n{\n\tstruct key_user *candidate = NULL, *user;\n\tstruct rb_node *parent, **p;\n\ntry_again:\n\tparent = NULL;\n\tp = &key_user_tree.rb_node;\n\tspin_lock(&key_user_lock);\n\n\t/* search the tree for a user record with a matching UID */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tuser = rb_entry(parent, struct key_user, node);\n\n\t\tif (uid_lt(uid, user->uid))\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (uid_gt(uid, user->uid))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\n\t/* if we get here, we failed to find a match in the tree */\n\tif (!candidate) {\n\t\t/* allocate a candidate user record if we don't already have\n\t\t * one */\n\t\tspin_unlock(&key_user_lock);\n\n\t\tuser = NULL;\n\t\tcandidate = kmalloc(sizeof(struct key_user), GFP_KERNEL);\n\t\tif (unlikely(!candidate))\n\t\t\tgoto out;\n\n\t\t/* the allocation may have scheduled, so we need to repeat the\n\t\t * search lest someone else added the record whilst we were\n\t\t * asleep */\n\t\tgoto try_again;\n\t}\n\n\t/* if we get here, then the user record still hadn't appeared on the\n\t * second pass - so we use the candidate record */\n\trefcount_set(&candidate->usage, 1);\n\tatomic_set(&candidate->nkeys, 0);\n\tatomic_set(&candidate->nikeys, 0);\n\tcandidate->uid = uid;\n\tcandidate->qnkeys = 0;\n\tcandidate->qnbytes = 0;\n\tspin_lock_init(&candidate->lock);\n\tmutex_init(&candidate->cons_lock);\n\n\trb_link_node(&candidate->node, parent, p);\n\trb_insert_color(&candidate->node, &key_user_tree);\n\tspin_unlock(&key_user_lock);\n\tuser = candidate;\n\tgoto out;\n\n\t/* okay - we found a user record for this UID */\nfound:\n\trefcount_inc(&user->usage);\n\tspin_unlock(&key_user_lock);\n\tkfree(candidate);\nout:\n\treturn user;\n}\n\n/*\n * Dispose of a user structure\n */\nvoid key_user_put(struct key_user *user)\n{\n\tif (refcount_dec_and_lock(&user->usage, &key_user_lock)) {\n\t\trb_erase(&user->node, &key_user_tree);\n\t\tspin_unlock(&key_user_lock);\n\n\t\tkfree(user);\n\t}\n}\n\n/*\n * Allocate a serial number for a key.  These are assigned randomly to avoid\n * security issues through covert channel problems.\n */\nstatic inline void key_alloc_serial(struct key *key)\n{\n\tstruct rb_node *parent, **p;\n\tstruct key *xkey;\n\n\t/* propose a random serial number and look for a hole for it in the\n\t * serial number tree */\n\tdo {\n\t\tget_random_bytes(&key->serial, sizeof(key->serial));\n\n\t\tkey->serial >>= 1; /* negative numbers are not permitted */\n\t} while (key->serial < 3);\n\n\tspin_lock(&key_serial_lock);\n\nattempt_insertion:\n\tparent = NULL;\n\tp = &key_serial_tree.rb_node;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\n\t\tif (key->serial < xkey->serial)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (key->serial > xkey->serial)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto serial_exists;\n\t}\n\n\t/* we've found a suitable hole - arrange for this key to occupy it */\n\trb_link_node(&key->serial_node, parent, p);\n\trb_insert_color(&key->serial_node, &key_serial_tree);\n\n\tspin_unlock(&key_serial_lock);\n\treturn;\n\n\t/* we found a key with the proposed serial number - walk the tree from\n\t * that point looking for the next unused serial number */\nserial_exists:\n\tfor (;;) {\n\t\tkey->serial++;\n\t\tif (key->serial < 3) {\n\t\t\tkey->serial = 3;\n\t\t\tgoto attempt_insertion;\n\t\t}\n\n\t\tparent = rb_next(parent);\n\t\tif (!parent)\n\t\t\tgoto attempt_insertion;\n\n\t\txkey = rb_entry(parent, struct key, serial_node);\n\t\tif (key->serial < xkey->serial)\n\t\t\tgoto attempt_insertion;\n\t}\n}\n\n/**\n * key_alloc - Allocate a key of the specified type.\n * @type: The type of key to allocate.\n * @desc: The key description to allow the key to be searched out.\n * @uid: The owner of the new key.\n * @gid: The group ID for the new key's group permissions.\n * @cred: The credentials specifying UID namespace.\n * @perm: The permissions mask of the new key.\n * @flags: Flags specifying quota properties.\n * @restrict_link: Optional link restriction for new keyrings.\n *\n * Allocate a key of the specified type with the attributes given.  The key is\n * returned in an uninstantiated state and the caller needs to instantiate the\n * key before returning.\n *\n * The restrict_link structure (if not NULL) will be freed when the\n * keyring is destroyed, so it must be dynamically allocated.\n *\n * The user's key count quota is updated to reflect the creation of the key and\n * the user's key data quota has the default for the key type reserved.  The\n * instantiation function should amend this as necessary.  If insufficient\n * quota is available, -EDQUOT will be returned.\n *\n * The LSM security modules can prevent a key being created, in which case\n * -EACCES will be returned.\n *\n * Returns a pointer to the new key if successful and an error code otherwise.\n *\n * Note that the caller needs to ensure the key type isn't uninstantiated.\n * Internally this can be done by locking key_types_sem.  Externally, this can\n * be done by either never unregistering the key type, or making sure\n * key_alloc() calls don't race with module unloading.\n */\nstruct key *key_alloc(struct key_type *type, const char *desc,\n\t\t      kuid_t uid, kgid_t gid, const struct cred *cred,\n\t\t      key_perm_t perm, unsigned long flags,\n\t\t      struct key_restriction *restrict_link)\n{\n\tstruct key_user *user = NULL;\n\tstruct key *key;\n\tsize_t desclen, quotalen;\n\tint ret;\n\n\tkey = ERR_PTR(-EINVAL);\n\tif (!desc || !*desc)\n\t\tgoto error;\n\n\tif (type->vet_description) {\n\t\tret = type->vet_description(desc);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdesclen = strlen(desc);\n\tquotalen = desclen + 1 + type->def_datalen;\n\n\t/* get hold of the key tracking for this user */\n\tuser = key_user_lookup(uid);\n\tif (!user)\n\t\tgoto no_memory_1;\n\n\t/* check that the user's quota permits allocation of another key and\n\t * its description */\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&user->lock);\n\t\tif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\n\t\t\tif (user->qnkeys + 1 >= maxkeys ||\n\t\t\t    user->qnbytes + quotalen >= maxbytes ||\n\t\t\t    user->qnbytes + quotalen < user->qnbytes)\n\t\t\t\tgoto no_quota;\n\t\t}\n\n\t\tuser->qnkeys++;\n\t\tuser->qnbytes += quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\n\t/* allocate and initialise the key and its description */\n\tkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\n\tif (!key)\n\t\tgoto no_memory_2;\n\n\tkey->index_key.desc_len = desclen;\n\tkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\n\tif (!key->index_key.description)\n\t\tgoto no_memory_3;\n\n\trefcount_set(&key->usage, 1);\n\tinit_rwsem(&key->sem);\n\tlockdep_set_class(&key->sem, &type->lock_class);\n\tkey->index_key.type = type;\n\tkey->user = user;\n\tkey->quotalen = quotalen;\n\tkey->datalen = type->def_datalen;\n\tkey->uid = uid;\n\tkey->gid = gid;\n\tkey->perm = perm;\n\tkey->restrict_link = restrict_link;\n\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\n\t\tkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\n\tif (flags & KEY_ALLOC_BUILT_IN)\n\t\tkey->flags |= 1 << KEY_FLAG_BUILTIN;\n\tif (flags & KEY_ALLOC_UID_KEYRING)\n\t\tkey->flags |= 1 << KEY_FLAG_UID_KEYRING;\n\n#ifdef KEY_DEBUGGING\n\tkey->magic = KEY_DEBUG_MAGIC;\n#endif\n\n\t/* let the security module know about the key */\n\tret = security_key_alloc(key, cred, flags);\n\tif (ret < 0)\n\t\tgoto security_error;\n\n\t/* publish the key by giving it a serial number */\n\tatomic_inc(&user->nkeys);\n\tkey_alloc_serial(key);\n\nerror:\n\treturn key;\n\nsecurity_error:\n\tkfree(key->description);\n\tkmem_cache_free(key_jar, key);\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\n\tkey = ERR_PTR(ret);\n\tgoto error;\n\nno_memory_3:\n\tkmem_cache_free(key_jar, key);\nno_memory_2:\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\nno_memory_1:\n\tkey = ERR_PTR(-ENOMEM);\n\tgoto error;\n\nno_quota:\n\tspin_unlock(&user->lock);\n\tkey_user_put(user);\n\tkey = ERR_PTR(-EDQUOT);\n\tgoto error;\n}\nEXPORT_SYMBOL(key_alloc);\n\n/**\n * key_payload_reserve - Adjust data quota reservation for the key's payload\n * @key: The key to make the reservation for.\n * @datalen: The amount of data payload the caller now wants.\n *\n * Adjust the amount of the owning user's key data quota that a key reserves.\n * If the amount is increased, then -EDQUOT may be returned if there isn't\n * enough free quota available.\n *\n * If successful, 0 is returned.\n */\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(key_payload_reserve);\n\n/*\n * Change the key state to being instantiated.\n */\nstatic void mark_key_instantiated(struct key *key, int reject_error)\n{\n\t/* Commit the payload before setting the state; barrier versus\n\t * key_read_state().\n\t */\n\tsmp_store_release(&key->state,\n\t\t\t  (reject_error < 0) ? reject_error : KEY_IS_POSITIVE);\n}\n\n/*\n * Instantiate a key and link it into the target keyring atomically.  Must be\n * called with the target keyring's semaphore writelocked.  The target key's\n * semaphore need not be locked as instantiation is serialised by\n * key_construction_mutex.\n */\nstatic int __key_instantiate_and_link(struct key *key,\n\t\t\t\t      struct key_preparsed_payload *prep,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *authkey,\n\t\t\t\t      struct assoc_array_edit **_edit)\n{\n\tint ret, awaken;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\t/* instantiate the key */\n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t/* mark the key as being instantiated */\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tmark_key_instantiated(key, 0);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t/* and link it into the destination keyring */\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\n\t\t\t\t__key_link(key, _edit);\n\t\t\t}\n\n\t\t\t/* disable the authorisation key */\n\t\t\tif (authkey)\n\t\t\t\tkey_revoke(authkey);\n\n\t\t\tif (prep->expiry != TIME_T_MAX) {\n\t\t\t\tkey->expiry = prep->expiry;\n\t\t\t\tkey_schedule_gc(prep->expiry + key_gc_delay);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret;\n}\n\n/**\n * key_instantiate_and_link - Instantiate a key and link it into the keyring.\n * @key: The key to instantiate.\n * @data: The data to use to instantiate the keyring.\n * @datalen: The length of @data.\n * @keyring: Keyring to create a link in on success (or NULL).\n * @authkey: The authorisation token permitting instantiation.\n *\n * Instantiate a key that's in the uninstantiated state using the provided data\n * and, if successful, link it in to the destination keyring if one is\n * supplied.\n *\n * If successful, 0 is returned, the authorisation token is revoked and anyone\n * waiting for the key is woken up.  If the key was already instantiated,\n * -EBUSY will be returned.\n */\nint key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tif (keyring->restrict_link && keyring->restrict_link->check) {\n\t\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\t\tret = keyres->check(keyring, key->type, &prep.payload,\n\t\t\t\t\t    keyres->key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\nerror_link_end:\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\n\nEXPORT_SYMBOL(key_instantiate_and_link);\n\n/**\n * key_reject_and_link - Negatively instantiate a key and link it into the keyring.\n * @key: The key to instantiate.\n * @timeout: The timeout on the negative key.\n * @error: The error to return when the key is hit.\n * @keyring: Keyring to create a link in on success (or NULL).\n * @authkey: The authorisation token permitting instantiation.\n *\n * Negatively instantiate a key that's in the uninstantiated state and, if\n * successful, set its timeout and stored error and link it in to the\n * destination keyring if one is supplied.  The key and any links to the key\n * will be automatically garbage collected after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return the stored error code (typically ENOKEY) until the negative\n * key expires.\n *\n * If successful, 0 is returned, the authorisation token is revoked and anyone\n * waiting for the key is woken up.  If the key was already instantiated,\n * -EBUSY will be returned.\n */\nint key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\t/* mark the key as being negatively instantiated */\n\t\tatomic_inc(&key->user->nikeys);\n\t\tmark_key_instantiated(key, -error);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\n\t\tret = 0;\n\n\t\t/* and link it into the destination keyring */\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\n\t\t/* disable the authorisation key */\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\tif (keyring && link_ret == 0)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret == 0 ? link_ret : ret;\n}\nEXPORT_SYMBOL(key_reject_and_link);\n\n/**\n * key_put - Discard a reference to a key.\n * @key: The key to discard a reference from.\n *\n * Discard a reference to a key, and when all the references are gone, we\n * schedule the cleanup task to come and pull it out of the tree in process\n * context at some later time.\n */\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}\nEXPORT_SYMBOL(key_put);\n\n/*\n * Find a key by its serial number.\n */\nstruct key *key_lookup(key_serial_t id)\n{\n\tstruct rb_node *n;\n\tstruct key *key;\n\n\tspin_lock(&key_serial_lock);\n\n\t/* search the tree for the specified key */\n\tn = key_serial_tree.rb_node;\n\twhile (n) {\n\t\tkey = rb_entry(n, struct key, serial_node);\n\n\t\tif (id < key->serial)\n\t\t\tn = n->rb_left;\n\t\telse if (id > key->serial)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\nnot_found:\n\tkey = ERR_PTR(-ENOKEY);\n\tgoto error;\n\nfound:\n\t/* A key is allowed to be looked up only if someone still owns a\n\t * reference to it - otherwise it's awaiting the gc.\n\t */\n\tif (!refcount_inc_not_zero(&key->usage))\n\t\tgoto not_found;\n\nerror:\n\tspin_unlock(&key_serial_lock);\n\treturn key;\n}\n\n/*\n * Find and lock the specified key type against removal.\n *\n * We return with the sem read-locked if successful.  If the type wasn't\n * available -ENOKEY is returned instead.\n */\nstruct key_type *key_type_lookup(const char *type)\n{\n\tstruct key_type *ktype;\n\n\tdown_read(&key_types_sem);\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tlist_for_each_entry(ktype, &key_types_list, link) {\n\t\tif (strcmp(ktype->name, type) == 0)\n\t\t\tgoto found_kernel_type;\n\t}\n\n\tup_read(&key_types_sem);\n\tktype = ERR_PTR(-ENOKEY);\n\nfound_kernel_type:\n\treturn ktype;\n}\n\nvoid key_set_timeout(struct key *key, unsigned timeout)\n{\n\tstruct timespec now;\n\ttime_t expiry = 0;\n\n\t/* make the changes with the locks held to prevent races */\n\tdown_write(&key->sem);\n\n\tif (timeout > 0) {\n\t\tnow = current_kernel_time();\n\t\texpiry = now.tv_sec + timeout;\n\t}\n\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL_GPL(key_set_timeout);\n\n/*\n * Unlock a key type locked by key_type_lookup().\n */\nvoid key_type_put(struct key_type *ktype)\n{\n\tup_read(&key_types_sem);\n}\n\n/*\n * Attempt to update an existing key.\n *\n * The key is given to us with an incremented refcount that we need to discard\n * if we get an error.\n */\nstatic inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\t/* need write permission on the key to update it */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\t/* Updating a negative key positively instantiates it */\n\t\tmark_key_instantiated(key, 0);\n\n\tup_write(&key->sem);\n\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\n\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}\n\n/**\n * key_create_or_update - Update or create and instantiate a key.\n * @keyring_ref: A pointer to the destination keyring with possession flag.\n * @type: The type of key.\n * @description: The searchable description for the key.\n * @payload: The data to use to instantiate or update the key.\n * @plen: The length of @payload.\n * @perm: The permissions mask for a new key.\n * @flags: The quota flags for a new key.\n *\n * Search the destination keyring for a key of the same description and if one\n * is found, update it, otherwise create and instantiate a new one and create a\n * link to it from that keyring.\n *\n * If perm is KEY_PERM_UNDEF then an appropriate key permissions mask will be\n * concocted.\n *\n * Returns a pointer to the new key if successful, -ENODEV if the key type\n * wasn't available, -ENOTDIR if the keyring wasn't a keyring, -EACCES if the\n * caller isn't permitted to modify the keyring or the LSM did not permit\n * creation of the key.\n *\n * On success, the possession flag from the keyring ref will be tacked on to\n * the key ref before it is returned.\n */\nkey_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\tstruct key_restriction *restrict_link = NULL;\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n\t}\n\n\tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->instantiate ||\n\t    (!index_key.description && !index_key.type->preparse))\n\t\tgoto error_put_type;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tkey_ref = ERR_PTR(-EPERM);\n\tif (!(flags & KEY_ALLOC_BYPASS_RESTRICTION))\n\t\trestrict_link = keyring->restrict_link;\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\tif (restrict_link && restrict_link->check) {\n\t\tret = restrict_link->check(keyring, index_key.type,\n\t\t\t\t\t   &prep.payload, restrict_link->key);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\t/* if we're going to allocate a new key, we're going to have\n\t * to modify the keyring */\n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t/* if it's possible to update this type of key, search for an existing\n\t * key of the same type and description in the destination keyring and\n\t * update that instead if possible\n\t */\n\tif (index_key.type->update) {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref)\n\t\t\tgoto found_matching_key;\n\t}\n\n\t/* if the client doesn't provide, decide on the permissions we want */\n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t/* allocate a new key */\n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags, NULL);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t/* instantiate it and link it into the target keyring */\n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t/* we found a matching key, so we're going to try to update it\n\t * - we can drop the locks first as we have the key pinned\n\t */\n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey_ref = __key_update(key_ref, &prep);\n\tgoto error_free_prep;\n}\nEXPORT_SYMBOL(key_create_or_update);\n\n/**\n * key_update - Update a key's contents.\n * @key_ref: The pointer (plus possession flag) to the key.\n * @payload: The data to be used to update the key.\n * @plen: The length of @payload.\n *\n * Attempt to update the contents of a key with the given payload data.  The\n * caller must be granted Write permission on the key.  Negative keys can be\n * instantiated by this method.\n *\n * Returns 0 on success, -EACCES if not permitted and -EOPNOTSUPP if the key\n * type does not support updating.  The key type may return other errors.\n */\nint key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tkey_check(key);\n\n\t/* the key must be writable */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attempt to update it if supported */\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\t/* Updating a negative key positively instantiates it */\n\t\tmark_key_instantiated(key, 0);\n\n\tup_write(&key->sem);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_update);\n\n/**\n * key_revoke - Revoke a key.\n * @key: The key to be revoked.\n *\n * Mark a key as being revoked and ask the type to free up its resources.  The\n * revocation timeout is set and the key and all its links will be\n * automatically garbage collected after key_gc_delay amount of time if they\n * are not manually dealt with first.\n */\nvoid key_revoke(struct key *key)\n{\n\tstruct timespec now;\n\ttime_t time;\n\n\tkey_check(key);\n\n\t/* make sure no one's trying to change or use the key when we mark it\n\t * - we tell lockdep that we might nest because we might be revoking an\n\t *   authorisation key whilst holding the sem on a key we've just\n\t *   instantiated\n\t */\n\tdown_write_nested(&key->sem, 1);\n\tif (!test_and_set_bit(KEY_FLAG_REVOKED, &key->flags) &&\n\t    key->type->revoke)\n\t\tkey->type->revoke(key);\n\n\t/* set the death time to no more than the expiry time */\n\tnow = current_kernel_time();\n\ttime = now.tv_sec;\n\tif (key->revoked_at == 0 || key->revoked_at > time) {\n\t\tkey->revoked_at = time;\n\t\tkey_schedule_gc(key->revoked_at + key_gc_delay);\n\t}\n\n\tup_write(&key->sem);\n}\nEXPORT_SYMBOL(key_revoke);\n\n/**\n * key_invalidate - Invalidate a key.\n * @key: The key to be invalidated.\n *\n * Mark a key as being invalidated and have it cleaned up immediately.  The key\n * is ignored by all searches and other operations from this point.\n */\nvoid key_invalidate(struct key *key)\n{\n\tkenter(\"%d\", key_serial(key));\n\n\tkey_check(key);\n\n\tif (!test_bit(KEY_FLAG_INVALIDATED, &key->flags)) {\n\t\tdown_write_nested(&key->sem, 1);\n\t\tif (!test_and_set_bit(KEY_FLAG_INVALIDATED, &key->flags))\n\t\t\tkey_schedule_gc_links();\n\t\tup_write(&key->sem);\n\t}\n}\nEXPORT_SYMBOL(key_invalidate);\n\n/**\n * generic_key_instantiate - Simple instantiation of a key from preparsed data\n * @key: The key to be instantiated\n * @prep: The preparsed data to load.\n *\n * Instantiate a key from preparsed data.  We assume we can just copy the data\n * in directly and clear the old pointers.\n *\n * This can be pointed to directly by the key type instantiate op pointer.\n */\nint generic_key_instantiate(struct key *key, struct key_preparsed_payload *prep)\n{\n\tint ret;\n\n\tpr_devel(\"==>%s()\\n\", __func__);\n\n\tret = key_payload_reserve(key, prep->quotalen);\n\tif (ret == 0) {\n\t\trcu_assign_keypointer(key, prep->payload.data[0]);\n\t\tkey->payload.data[1] = prep->payload.data[1];\n\t\tkey->payload.data[2] = prep->payload.data[2];\n\t\tkey->payload.data[3] = prep->payload.data[3];\n\t\tprep->payload.data[0] = NULL;\n\t\tprep->payload.data[1] = NULL;\n\t\tprep->payload.data[2] = NULL;\n\t\tprep->payload.data[3] = NULL;\n\t}\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}\nEXPORT_SYMBOL(generic_key_instantiate);\n\n/**\n * register_key_type - Register a type of key.\n * @ktype: The new key type.\n *\n * Register a new key type.\n *\n * Returns 0 on success or -EEXIST if a type of this name already exists.\n */\nint register_key_type(struct key_type *ktype)\n{\n\tstruct key_type *p;\n\tint ret;\n\n\tmemset(&ktype->lock_class, 0, sizeof(ktype->lock_class));\n\n\tret = -EEXIST;\n\tdown_write(&key_types_sem);\n\n\t/* disallow key types with the same name */\n\tlist_for_each_entry(p, &key_types_list, link) {\n\t\tif (strcmp(p->name, ktype->name) == 0)\n\t\t\tgoto out;\n\t}\n\n\t/* store the type */\n\tlist_add(&ktype->link, &key_types_list);\n\n\tpr_notice(\"Key type %s registered\\n\", ktype->name);\n\tret = 0;\n\nout:\n\tup_write(&key_types_sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(register_key_type);\n\n/**\n * unregister_key_type - Unregister a type of key.\n * @ktype: The key type.\n *\n * Unregister a key type and mark all the extant keys of this type as dead.\n * Those keys of this type are then destroyed to get rid of their payloads and\n * they and their links will be garbage collected as soon as possible.\n */\nvoid unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}\nEXPORT_SYMBOL(unregister_key_type);\n\n/*\n * Initialise the key management state.\n */\nvoid __init key_init(void)\n{\n\t/* allocate a slab in which we can store keys */\n\tkey_jar = kmem_cache_create(\"key_jar\", sizeof(struct key),\n\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\n\t/* add the special key types */\n\tlist_add_tail(&key_type_keyring.link, &key_types_list);\n\tlist_add_tail(&key_type_dead.link, &key_types_list);\n\tlist_add_tail(&key_type_user.link, &key_types_list);\n\tlist_add_tail(&key_type_logon.link, &key_types_list);\n\n\t/* record the root user tracking */\n\trb_link_node(&root_key_user.node,\n\t\t     NULL,\n\t\t     &key_user_tree.rb_node);\n\n\trb_insert_color(&root_key_user.node,\n\t\t\t&key_user_tree);\n}\n", "/* Userspace key control operations\n *\n * Copyright (C) 2004-5 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/task.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/key.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n#define KEY_MAX_DESC_SIZE 4096\n\nstatic int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}\n\n/*\n * Extract the description of a new key from userspace and either add it as a\n * new key to the specified keyring or update a matching key in that keyring.\n *\n * If the description is NULL or an empty string, the key type is asked to\n * generate one from the payload.\n *\n * The keyring must be writable so that we can attach the key to it.\n *\n * If successful, the new key's serial number is returned, otherwise an error\n * code is returned.\n */\nSYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* draw all the data into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\n\t/* find the target keyring (which must be writable) */\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\n\t/* create or update the requested key and add it to the target\n\t * keyring */\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\n\tkey_ref_put(keyring_ref);\n error3:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}\n\n/*\n * Search the process keyrings and keyring trees linked from those for a\n * matching key.  Keyrings must have appropriate Search permission to be\n * searched.\n *\n * If a key is found, it will be attached to the destination keyring if there's\n * one specified and the serial number of the key will be returned.\n *\n * If no key is found, /sbin/request-key will be invoked if _callout_info is\n * non-NULL in an attempt to create a key.  The _callout_info string will be\n * passed to /sbin/request-key to aid with completing the request.  If the\n * _callout_info string is \"\" then it will be changed to \"-\".\n */\nSYSCALL_DEFINE4(request_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst char __user *, _callout_info,\n\t\tkey_serial_t, destringid)\n{\n\tstruct key_type *ktype;\n\tstruct key *key;\n\tkey_ref_t dest_ref;\n\tsize_t callout_len;\n\tchar type[32], *description, *callout_info;\n\tlong ret;\n\n\t/* pull the type into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* pull the description into kernel space */\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* pull the callout info into kernel space */\n\tcallout_info = NULL;\n\tcallout_len = 0;\n\tif (_callout_info) {\n\t\tcallout_info = strndup_user(_callout_info, PAGE_SIZE);\n\t\tif (IS_ERR(callout_info)) {\n\t\t\tret = PTR_ERR(callout_info);\n\t\t\tgoto error2;\n\t\t}\n\t\tcallout_len = strlen(callout_info);\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey = request_key_and_link(ktype, description, callout_info,\n\t\t\t\t   callout_len, NULL, key_ref_to_ptr(dest_ref),\n\t\t\t\t   KEY_ALLOC_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error5;\n\t}\n\n\t/* wait for the key to finish being constructed */\n\tret = wait_for_key_construction(key, 1);\n\tif (ret < 0)\n\t\tgoto error6;\n\n\tret = key->serial;\n\nerror6:\n \tkey_put(key);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkfree(callout_info);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n/*\n * Get the ID of the specified process keyring.\n *\n * The requested keyring must have search permission to be found.\n *\n * If successful, the ID of the requested keyring will be returned.\n */\nlong keyctl_get_keyring_ID(key_serial_t id, int create)\n{\n\tkey_ref_t key_ref;\n\tunsigned long lflags;\n\tlong ret;\n\n\tlflags = create ? KEY_LOOKUP_CREATE : 0;\n\tkey_ref = lookup_user_key(id, lflags, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Join a (named) session keyring.\n *\n * Create and join an anonymous session keyring or join a named session\n * keyring, creating it if necessary.  A named session keyring must have Search\n * permission for it to be joined.  Session keyrings without this permit will\n * be skipped over.  It is not permitted for userspace to create or join\n * keyrings whose name begin with a dot.\n *\n * If successful, the ID of the joined session keyring will be returned.\n */\nlong keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}\n\n/*\n * Update a key's data payload from the given data.\n *\n * The key must grant the caller Write permission and the key type must support\n * updating for this to work.  A negative key can be positively instantiated\n * with this call.\n *\n * If successful, 0 will be returned.  If the key type does not support\n * updating, then -EOPNOTSUPP will be returned.\n */\nlong keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkzfree(payload);\nerror:\n\treturn ret;\n}\n\n/*\n * Revoke a key.\n *\n * The key must be grant the caller Write or Setattr permission for this to\n * work.  The key type should give up its quota claim when revoked.  The key\n * and any links to the key will be automatically garbage collected after a\n * certain amount of time (/proc/sys/kernel/keys/gc_delay).\n *\n * Keys with KEY_FLAG_KEEP set should not be revoked.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_revoke_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tif (ret != -EACCES)\n\t\t\tgoto error;\n\t\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\t\tif (IS_ERR(key_ref)) {\n\t\t\tret = PTR_ERR(key_ref);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_revoke(key);\n\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Invalidate a key.\n *\n * The key must be grant the caller Invalidate permission for this to work.\n * The key and any links to the key will be automatically garbage collected\n * immediately.\n *\n * Keys with KEY_FLAG_KEEP set should not be invalidated.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_invalidate_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkenter(\"%d\", id);\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* Root is permitted to invalidate certain special keys */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkey_ref = lookup_user_key(id, 0, 0);\n\t\t\tif (IS_ERR(key_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_INVAL,\n\t\t\t\t     &key_ref_to_ptr(key_ref)->flags))\n\t\t\t\tgoto invalidate;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\ninvalidate:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_invalidate(key);\nerror_put:\n\tkey_ref_put(key_ref);\nerror:\n\tkleave(\" = %ld\", ret);\n\treturn ret;\n}\n\n/*\n * Clear the specified keyring, creating an empty process keyring if one of the\n * special keyring IDs is used.\n *\n * The keyring must grant the caller Write permission and not have\n * KEY_FLAG_KEEP set for this to work.  If successful, 0 will be returned.\n */\nlong keyctl_keyring_clear(key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref;\n\tstruct key *keyring;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\n\t\t/* Root is permitted to invalidate certain special keyrings */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkeyring_ref = lookup_user_key(ringid, 0, 0);\n\t\t\tif (IS_ERR(keyring_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_CLEAR,\n\t\t\t\t     &key_ref_to_ptr(keyring_ref)->flags))\n\t\t\t\tgoto clear;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\nclear:\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = keyring_clear(keyring);\nerror_put:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Create a link from a keyring to a key if there's no matching key in the\n * keyring, otherwise replace the link to the matching key with a link to the\n * new key.\n *\n * The key must grant the caller Link permission and the the keyring must grant\n * the caller Write permission.  Furthermore, if an additional link is created,\n * the keyring's quota will be extended.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_keyring_link(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_NEED_LINK);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_link(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Unlink a key from a keyring.\n *\n * The keyring must grant the caller Write permission for this to work; the key\n * itself need not grant the caller anything.  If the last link to a key is\n * removed then that key will be scheduled for destruction.\n *\n * Keys or keyrings with KEY_FLAG_KEEP set should not be unlinked.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tstruct key *keyring, *key;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_FOR_UNLINK, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags) &&\n\t    test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = key_unlink(keyring, key);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Return a description of a key to userspace.\n *\n * The key must grant the caller View permission for this to work.\n *\n * If there's a buffer, we place up to buflen bytes of data into it formatted\n * in the following way:\n *\n *\ttype;uid;gid;perm;description<NUL>\n *\n * If successful, we return the amount of description available, irrespective\n * of how much we may have copied into the buffer.\n */\nlong keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\t/* viewing a key under construction is permitted if we have the\n\t\t * authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\n\t/* calculate how much information we're going to return */\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\n\t/* consider returning the data */\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}\n\n/*\n * Search the specified keyring and any keyrings it links to for a matching\n * key.  Only keyrings that grant the caller Search permission will be searched\n * (this includes the starting keyring).  Only keys with Search permission can\n * be found.\n *\n * If successful, the found key will be linked to the destination keyring if\n * supplied and the key has Link permission, and the found key ID will be\n * returned.\n */\nlong keyctl_keyring_search(key_serial_t ringid,\n\t\t\t   const char __user *_type,\n\t\t\t   const char __user *_description,\n\t\t\t   key_serial_t destringid)\n{\n\tstruct key_type *ktype;\n\tkey_ref_t keyring_ref, key_ref, dest_ref;\n\tchar type[32], *description;\n\tlong ret;\n\n\t/* pull the type and description into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* get the keyring at which to begin the search */\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error2;\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey_ref = keyring_search(keyring_ref, ktype, description);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* treat lack or presence of a negative key the same */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOKEY;\n\t\tgoto error5;\n\t}\n\n\t/* link the resulting key to the destination keyring if we can */\n\tif (dest_ref) {\n\t\tret = key_permission(key_ref, KEY_NEED_LINK);\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\n\t\tret = key_link(key_ref_to_ptr(dest_ref), key_ref_to_ptr(key_ref));\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\nerror6:\n\tkey_ref_put(key_ref);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkey_ref_put(keyring_ref);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}\n\n/*\n * Read a key's payload.\n *\n * The key must either grant the caller Read permission, or it must grant the\n * caller Search permission when searched for from the process keyrings.\n *\n * If successful, we place up to buflen bytes of data into the buffer, if one\n * is provided, and return the amount of data that is available in the key,\n * irrespective of how much we copied into the buffer.\n */\nlong keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\tgoto error2; /* Negatively instantiated */\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n/*\n * Change the ownership of a key\n *\n * The key must grant the caller Setattr permission for this to work, though\n * the key need not be fully instantiated yet.  For the UID to be changed, or\n * for the GID to be changed to a group the caller is not a member of, the\n * caller must have sysadmin capability.  If either uid or gid is -1 then that\n * attribute is not changed.\n *\n * If the UID is to be changed, the new user must have sufficient quota to\n * accept the key.  The quota deduction will be removed from the old user to\n * the new user should the attribute be changed.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)\n{\n\tstruct key_user *newowner, *zapowner = NULL;\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\tret = -EINVAL;\n\tif ((user != (uid_t) -1) && !uid_valid(uid))\n\t\tgoto error;\n\tif ((group != (gid_t) -1) && !gid_valid(gid))\n\t\tgoto error;\n\n\tret = 0;\n\tif (user == (uid_t) -1 && group == (gid_t) -1)\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chown races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/* only the sysadmin can chown a key to some other UID */\n\t\tif (user != (uid_t) -1 && !uid_eq(key->uid, uid))\n\t\t\tgoto error_put;\n\n\t\t/* only the sysadmin can set the key's GID to a group other\n\t\t * than one of those that the current process subscribes to */\n\t\tif (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))\n\t\t\tgoto error_put;\n\t}\n\n\t/* change the UID */\n\tif (user != (uid_t) -1 && !uid_eq(uid, key->uid)) {\n\t\tret = -ENOMEM;\n\t\tnewowner = key_user_lookup(uid);\n\t\tif (!newowner)\n\t\t\tgoto error_put;\n\n\t\t/* transfer the quota burden to the new user */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\t\tspin_lock(&newowner->lock);\n\t\t\tif (newowner->qnkeys + 1 >= maxkeys ||\n\t\t\t    newowner->qnbytes + key->quotalen >= maxbytes ||\n\t\t\t    newowner->qnbytes + key->quotalen <\n\t\t\t    newowner->qnbytes)\n\t\t\t\tgoto quota_overrun;\n\n\t\t\tnewowner->qnkeys++;\n\t\t\tnewowner->qnbytes += key->quotalen;\n\t\t\tspin_unlock(&newowner->lock);\n\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tatomic_inc(&newowner->nkeys);\n\n\t\tif (key->state != KEY_IS_UNINSTANTIATED) {\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\t\tatomic_inc(&newowner->nikeys);\n\t\t}\n\n\t\tzapowner = key->user;\n\t\tkey->user = newowner;\n\t\tkey->uid = uid;\n\t}\n\n\t/* change the GID */\n\tif (group != (gid_t) -1)\n\t\tkey->gid = gid;\n\n\tret = 0;\n\nerror_put:\n\tup_write(&key->sem);\n\tkey_put(key);\n\tif (zapowner)\n\t\tkey_user_put(zapowner);\nerror:\n\treturn ret;\n\nquota_overrun:\n\tspin_unlock(&newowner->lock);\n\tzapowner = newowner;\n\tret = -EDQUOT;\n\tgoto error_put;\n}\n\n/*\n * Change the permission mask on a key.\n *\n * The key must grant the caller Setattr permission for this to work, though\n * the key need not be fully instantiated yet.  If the caller does not have\n * sysadmin capability, it may only change the permission on keys that it owns.\n */\nlong keyctl_setperm_key(key_serial_t id, key_perm_t perm)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chmod races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\t/* if we're not the sysadmin, we can only change a key that we own */\n\tif (capable(CAP_SYS_ADMIN) || uid_eq(key->uid, current_fsuid())) {\n\t\tkey->perm = perm;\n\t\tret = 0;\n\t}\n\n\tup_write(&key->sem);\n\tkey_put(key);\nerror:\n\treturn ret;\n}\n\n/*\n * Get the destination keyring for instantiation and check that the caller has\n * Write permission on it.\n */\nstatic long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}\n\n/*\n * Change the request_key authorisation key on the current process.\n */\nstatic int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}\n\n/*\n * Instantiate a key with the specified payload and link the key into the\n * destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t/* find the destination keyring amongst those belonging to the\n\t * requesting task */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\nerror:\n\treturn ret;\n}\n\n/*\n * Instantiate a key with the specified payload and link the key into the\n * destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key(key_serial_t id,\n\t\t\t    const void __user *_payload,\n\t\t\t    size_t plen,\n\t\t\t    key_serial_t ringid)\n{\n\tif (_payload && plen) {\n\t\tstruct iovec iov;\n\t\tstruct iov_iter from;\n\t\tint ret;\n\n\t\tret = import_single_range(WRITE, (void __user *)_payload, plen,\n\t\t\t\t\t  &iov, &from);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\treturn keyctl_instantiate_key_common(id, &from, ringid);\n\t}\n\n\treturn keyctl_instantiate_key_common(id, NULL, ringid);\n}\n\n/*\n * Instantiate a key with the specified multipart payload and link the key into\n * the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_instantiate_key_iov(key_serial_t id,\n\t\t\t\tconst struct iovec __user *_payload_iov,\n\t\t\t\tunsigned ioc,\n\t\t\t\tkey_serial_t ringid)\n{\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tstruct iov_iter from;\n\tlong ret;\n\n\tif (!_payload_iov)\n\t\tioc = 0;\n\n\tret = import_iovec(WRITE, _payload_iov, ioc,\n\t\t\t\t    ARRAY_SIZE(iovstack), &iov, &from);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = keyctl_instantiate_key_common(id, &from, ringid);\n\tkfree(iov);\n\treturn ret;\n}\n\n/*\n * Negatively instantiate the key with the given timeout (in seconds) and link\n * the key into the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * The key and any links to the key will be automatically garbage collected\n * after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return -ENOKEY until the negative key expires.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_negate_key(key_serial_t id, unsigned timeout, key_serial_t ringid)\n{\n\treturn keyctl_reject_key(id, timeout, ENOKEY, ringid);\n}\n\n/*\n * Negatively instantiate the key with the given timeout (in seconds) and error\n * code and link the key into the destination keyring if one is given.\n *\n * The caller must have the appropriate instantiation permit set for this to\n * work (see keyctl_assume_authority).  No other permissions are required.\n *\n * The key and any links to the key will be automatically garbage collected\n * after the timeout expires.\n *\n * Negative keys are used to rate limit repeated request_key() calls by causing\n * them to return the specified error code until the negative key expires.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n\t\t       key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter(\"%d,%u,%u,%d\", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n\t\t\t\t  dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Read or set the default keyring in which request_key() will cache keys and\n * return the old setting.\n *\n * If a thread or process keyring is specified then it will be created if it\n * doesn't yet exist.  The old setting will be returned if successful.\n */\nlong keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\n\told_setting = current_cred_xxx(jit_keyring);\n\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n/*\n * Set or clear the timeout on a key.\n *\n * Either the key must grant the caller Setattr permission or else the caller\n * must hold an instantiation authorisation token for the key.\n *\n * The timeout is either 0 to clear the timeout, or a number of seconds from\n * the current time.  The key and any links to the key will be automatically\n * garbage collected after the timeout expires.\n *\n * Keys with KEY_FLAG_KEEP set should not be timed out.\n *\n * If successful, 0 is returned.\n */\nlong keyctl_set_timeout(key_serial_t id, unsigned timeout)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\t/* setting the timeout on a key under construction is permitted\n\t\t * if we have the authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(id);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(id,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_set_timeout(key, timeout);\n\tkey_put(key);\n\nerror:\n\treturn ret;\n}\n\n/*\n * Assume (or clear) the authority to instantiate the specified key.\n *\n * This sets the authoritative token currently in force for key instantiation.\n * This must be done for a key to be instantiated.  It has the effect of making\n * available all the keys from the caller of the request_key() that created a\n * key to request_key() calls made by the caller of this function.\n *\n * The caller must have the instantiation key in their process keyrings with a\n * Search permission grant available to the caller.\n *\n * If the ID given is 0, then the setting will be cleared and 0 returned.\n *\n * If the ID given has a matching an authorisation key, then that key will be\n * set and its ID will be returned.  The authorisation key can be read to get\n * the callout information passed to request_key().\n */\nlong keyctl_assume_authority(key_serial_t id)\n{\n\tstruct key *authkey;\n\tlong ret;\n\n\t/* special key IDs aren't permitted */\n\tret = -EINVAL;\n\tif (id < 0)\n\t\tgoto error;\n\n\t/* we divest ourselves of authority if given an ID of 0 */\n\tif (id == 0) {\n\t\tret = keyctl_change_reqkey_auth(NULL);\n\t\tgoto error;\n\t}\n\n\t/* attempt to assume the authority temporarily granted to us whilst we\n\t * instantiate the specified key\n\t * - the authorisation key must be in the current task's keyrings\n\t *   somewhere\n\t */\n\tauthkey = key_get_instantiation_authkey(id);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error;\n\t}\n\n\tret = keyctl_change_reqkey_auth(authkey);\n\tif (ret == 0)\n\t\tret = authkey->serial;\n\tkey_put(authkey);\nerror:\n\treturn ret;\n}\n\n/*\n * Get a key's the LSM security label.\n *\n * The key must grant the caller View permission for this to work.\n *\n * If there's a buffer, then up to buflen bytes of data will be placed into it.\n *\n * If successful, the amount of information available will be returned,\n * irrespective of how much was copied (including the terminal NUL).\n */\nlong keyctl_get_security(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *context;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) != -EACCES)\n\t\t\treturn PTR_ERR(key_ref);\n\n\t\t/* viewing a key under construction is also permitted if we\n\t\t * have the authorisation token handy */\n\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\tif (IS_ERR(instkey))\n\t\t\treturn PTR_ERR(instkey);\n\t\tkey_put(instkey);\n\n\t\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, 0);\n\t\tif (IS_ERR(key_ref))\n\t\t\treturn PTR_ERR(key_ref);\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = security_key_getsecurity(key, &context);\n\tif (ret == 0) {\n\t\t/* if no information was returned, give userspace an empty\n\t\t * string */\n\t\tret = 1;\n\t\tif (buffer && buflen > 0 &&\n\t\t    copy_to_user(buffer, \"\", 1) != 0)\n\t\t\tret = -EFAULT;\n\t} else if (ret > 0) {\n\t\t/* return as much data as there's room for */\n\t\tif (buffer && buflen > 0) {\n\t\t\tif (buflen > ret)\n\t\t\t\tbuflen = ret;\n\n\t\t\tif (copy_to_user(buffer, context, buflen) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(context);\n\t}\n\n\tkey_ref_put(key_ref);\n\treturn ret;\n}\n\n/*\n * Attempt to install the calling process's session keyring on the process's\n * parent process.\n *\n * The keyring must exist and must grant the caller LINK permission, and the\n * parent process must be single-threaded and must have the same effective\n * ownership as this process and mustn't be SUID/SGID.\n *\n * The keyring will be emplaced on the parent when it next resumes userspace.\n *\n * If successful, 0 will be returned.\n */\nlong keyctl_session_to_parent(void)\n{\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct callback_head *newwork, *oldwork;\n\tkey_ref_t keyring_r;\n\tstruct cred *cred;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_NEED_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\tret = -ENOMEM;\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tnewwork = &cred->rcu;\n\n\tcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tinit_task_work(newwork, key_change_session_keyring);\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tret = -EPERM;\n\toldwork = NULL;\n\tparent = me->real_parent;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto unlock;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto unlock;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->session_keyring == pcred->session_keyring) {\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (!uid_eq(pcred->uid,\t mycred->euid) ||\n\t    !uid_eq(pcred->euid, mycred->euid) ||\n\t    !uid_eq(pcred->suid, mycred->euid) ||\n\t    !gid_eq(pcred->gid,\t mycred->egid) ||\n\t    !gid_eq(pcred->egid, mycred->egid) ||\n\t    !gid_eq(pcred->sgid, mycred->egid))\n\t\tgoto unlock;\n\n\t/* the keyrings must have the same UID */\n\tif ((pcred->session_keyring &&\n\t     !uid_eq(pcred->session_keyring->uid, mycred->euid)) ||\n\t    !uid_eq(mycred->session_keyring->uid, mycred->euid))\n\t\tgoto unlock;\n\n\t/* cancel an already pending keyring replacement */\n\toldwork = task_work_cancel(parent, key_change_session_keyring);\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tret = task_work_add(parent, newwork, true);\n\tif (!ret)\n\t\tnewwork = NULL;\nunlock:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldwork)\n\t\tput_cred(container_of(oldwork, struct cred, rcu));\n\tif (newwork)\n\t\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n}\n\n/*\n * Apply a restriction to a given keyring.\n *\n * The caller must have Setattr permission to change keyring restrictions.\n *\n * The requested type name may be a NULL pointer to reject all attempts\n * to link to the keyring. If _type is non-NULL, _restriction can be\n * NULL or a pointer to a string describing the restriction. If _type is\n * NULL, _restriction must also be NULL.\n *\n * Returns 0 if successful.\n */\nlong keyctl_restrict_keyring(key_serial_t id, const char __user *_type,\n\t\t\t     const char __user *_restriction)\n{\n\tkey_ref_t key_ref;\n\tbool link_reject = !_type;\n\tchar type[32];\n\tchar *restriction = NULL;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref))\n\t\treturn PTR_ERR(key_ref);\n\n\tif (_type) {\n\t\tret = key_get_type_from_user(type, _type, sizeof(type));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (_restriction) {\n\t\tif (!_type) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestriction = strndup_user(_restriction, PAGE_SIZE);\n\t\tif (IS_ERR(restriction)) {\n\t\t\tret = PTR_ERR(restriction);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = keyring_restrict(key_ref, link_reject ? NULL : type, restriction);\n\tkfree(restriction);\n\nerror:\n\tkey_ref_put(key_ref);\n\n\treturn ret;\n}\n\n/*\n * The key control system call\n */\nSYSCALL_DEFINE5(keyctl, int, option, unsigned long, arg2, unsigned long, arg3,\n\t\tunsigned long, arg4, unsigned long, arg5)\n{\n\tswitch (option) {\n\tcase KEYCTL_GET_KEYRING_ID:\n\t\treturn keyctl_get_keyring_ID((key_serial_t) arg2,\n\t\t\t\t\t     (int) arg3);\n\n\tcase KEYCTL_JOIN_SESSION_KEYRING:\n\t\treturn keyctl_join_session_keyring((const char __user *) arg2);\n\n\tcase KEYCTL_UPDATE:\n\t\treturn keyctl_update_key((key_serial_t) arg2,\n\t\t\t\t\t (const void __user *) arg3,\n\t\t\t\t\t (size_t) arg4);\n\n\tcase KEYCTL_REVOKE:\n\t\treturn keyctl_revoke_key((key_serial_t) arg2);\n\n\tcase KEYCTL_DESCRIBE:\n\t\treturn keyctl_describe_key((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (unsigned) arg4);\n\n\tcase KEYCTL_CLEAR:\n\t\treturn keyctl_keyring_clear((key_serial_t) arg2);\n\n\tcase KEYCTL_LINK:\n\t\treturn keyctl_keyring_link((key_serial_t) arg2,\n\t\t\t\t\t   (key_serial_t) arg3);\n\n\tcase KEYCTL_UNLINK:\n\t\treturn keyctl_keyring_unlink((key_serial_t) arg2,\n\t\t\t\t\t     (key_serial_t) arg3);\n\n\tcase KEYCTL_SEARCH:\n\t\treturn keyctl_keyring_search((key_serial_t) arg2,\n\t\t\t\t\t     (const char __user *) arg3,\n\t\t\t\t\t     (const char __user *) arg4,\n\t\t\t\t\t     (key_serial_t) arg5);\n\n\tcase KEYCTL_READ:\n\t\treturn keyctl_read_key((key_serial_t) arg2,\n\t\t\t\t       (char __user *) arg3,\n\t\t\t\t       (size_t) arg4);\n\n\tcase KEYCTL_CHOWN:\n\t\treturn keyctl_chown_key((key_serial_t) arg2,\n\t\t\t\t\t(uid_t) arg3,\n\t\t\t\t\t(gid_t) arg4);\n\n\tcase KEYCTL_SETPERM:\n\t\treturn keyctl_setperm_key((key_serial_t) arg2,\n\t\t\t\t\t  (key_perm_t) arg3);\n\n\tcase KEYCTL_INSTANTIATE:\n\t\treturn keyctl_instantiate_key((key_serial_t) arg2,\n\t\t\t\t\t      (const void __user *) arg3,\n\t\t\t\t\t      (size_t) arg4,\n\t\t\t\t\t      (key_serial_t) arg5);\n\n\tcase KEYCTL_NEGATE:\n\t\treturn keyctl_negate_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (key_serial_t) arg4);\n\n\tcase KEYCTL_SET_REQKEY_KEYRING:\n\t\treturn keyctl_set_reqkey_keyring(arg2);\n\n\tcase KEYCTL_SET_TIMEOUT:\n\t\treturn keyctl_set_timeout((key_serial_t) arg2,\n\t\t\t\t\t  (unsigned) arg3);\n\n\tcase KEYCTL_ASSUME_AUTHORITY:\n\t\treturn keyctl_assume_authority((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_SECURITY:\n\t\treturn keyctl_get_security((key_serial_t) arg2,\n\t\t\t\t\t   (char __user *) arg3,\n\t\t\t\t\t   (size_t) arg4);\n\n\tcase KEYCTL_SESSION_TO_PARENT:\n\t\treturn keyctl_session_to_parent();\n\n\tcase KEYCTL_REJECT:\n\t\treturn keyctl_reject_key((key_serial_t) arg2,\n\t\t\t\t\t (unsigned) arg3,\n\t\t\t\t\t (unsigned) arg4,\n\t\t\t\t\t (key_serial_t) arg5);\n\n\tcase KEYCTL_INSTANTIATE_IOV:\n\t\treturn keyctl_instantiate_key_iov(\n\t\t\t(key_serial_t) arg2,\n\t\t\t(const struct iovec __user *) arg3,\n\t\t\t(unsigned) arg4,\n\t\t\t(key_serial_t) arg5);\n\n\tcase KEYCTL_INVALIDATE:\n\t\treturn keyctl_invalidate_key((key_serial_t) arg2);\n\n\tcase KEYCTL_GET_PERSISTENT:\n\t\treturn keyctl_get_persistent((uid_t)arg2, (key_serial_t)arg3);\n\n\tcase KEYCTL_DH_COMPUTE:\n\t\treturn keyctl_dh_compute((struct keyctl_dh_params __user *) arg2,\n\t\t\t\t\t (char __user *) arg3, (size_t) arg4,\n\t\t\t\t\t (struct keyctl_kdf_params __user *) arg5);\n\n\tcase KEYCTL_RESTRICT_KEYRING:\n\t\treturn keyctl_restrict_keyring((key_serial_t) arg2,\n\t\t\t\t\t       (const char __user *) arg3,\n\t\t\t\t\t       (const char __user *) arg4);\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n", "/* Keyring handling\n *\n * Copyright (C) 2004-2005, 2008, 2013 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/keyring-type.h>\n#include <keys/user-type.h>\n#include <linux/assoc_array_priv.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n/*\n * When plumbing the depths of the key tree, this sets a hard limit\n * set on how deep we're willing to go.\n */\n#define KEYRING_SEARCH_MAX_DEPTH 6\n\n/*\n * We keep all named keyrings in a hash to speed looking them up.\n */\n#define KEYRING_NAME_HASH_SIZE\t(1 << 5)\n\n/*\n * We mark pointers we pass to the associative array with bit 1 set if\n * they're keyrings and clear otherwise.\n */\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)\n{\n\treturn (unsigned long)x & KEYRING_PTR_SUBTYPE;\n}\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}\nstatic inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}\n\nstatic struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];\nstatic DEFINE_RWLOCK(keyring_name_lock);\n\nstatic inline unsigned keyring_hash(const char *desc)\n{\n\tunsigned bucket = 0;\n\n\tfor (; *desc; desc++)\n\t\tbucket += (unsigned char)*desc;\n\n\treturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\n}\n\n/*\n * The keyring key type definition.  Keyrings are simply keys of this type and\n * can be treated as ordinary keys in addition to having their own special\n * operations.\n */\nstatic int keyring_preparse(struct key_preparsed_payload *prep);\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep);\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m);\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen);\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nEXPORT_SYMBOL(key_type_keyring);\n\n/*\n * Semaphore to serialise link/link calls to prevent two link calls in parallel\n * introducing a cycle.\n */\nstatic DECLARE_RWSEM(keyring_serialise_link_sem);\n\n/*\n * Publish the name of a keyring so that it can be found by name (if it has\n * one).\n */\nstatic void keyring_publish_name(struct key *keyring)\n{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->name_link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}\n\n/*\n * Preparse a keyring payload\n */\nstatic int keyring_preparse(struct key_preparsed_payload *prep)\n{\n\treturn prep->datalen != 0 ? -EINVAL : 0;\n}\n\n/*\n * Free a preparse of a user defined key payload\n */\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep)\n{\n}\n\n/*\n * Initialise a keyring.\n *\n * Returns 0 on success, -EINVAL if given any data.\n */\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tassoc_array_init(&keyring->keys);\n\t/* make the keyring available by name if it has one */\n\tkeyring_publish_name(keyring);\n\treturn 0;\n}\n\n/*\n * Multiply 64-bits by 32-bits to 96-bits and fold back to 64-bit.  Ideally we'd\n * fold the carry back too, but that requires inline asm.\n */\nstatic u64 mult_64x32_and_fold(u64 x, u32 y)\n{\n\tu64 hi = (u64)(u32)(x >> 32) * y;\n\tu64 lo = (u64)(u32)(x) * y;\n\treturn lo + ((u64)(u32)hi << 32) + (u32)(hi >> 32);\n}\n\n/*\n * Hash a key type and description.\n */\nstatic unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t/* Fold the hash down to 32 bits if need be. */\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t/* Squidge all the keyrings into a separate part of the tree to\n\t * ordinary keys by making sure the lowest level segment in the hash is\n\t * zero for keyrings and non-zero otherwise.\n\t */\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}\n\n/*\n * Build the next index key chunk.\n *\n * On 32-bit systems the index key is laid out as:\n *\n *\t0\t4\t5\t9...\n *\thash\tdesclen\ttypeptr\tdesc[]\n *\n * On 64-bit systems:\n *\n *\t0\t8\t9\t17...\n *\thash\tdesclen\ttypeptr\tdesc[]\n *\n * We return it one word-sized chunk at a time.\n */\nstatic unsigned long keyring_get_key_chunk(const void *data, int level)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tunsigned long chunk = 0;\n\tlong offset = 0;\n\tint desc_len = index_key->desc_len, n = sizeof(chunk);\n\n\tlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\tswitch (level) {\n\tcase 0:\n\t\treturn hash_key_type_and_desc(index_key);\n\tcase 1:\n\t\treturn ((unsigned long)index_key->type << 8) | desc_len;\n\tcase 2:\n\t\tif (desc_len == 0)\n\t\t\treturn (u8)((unsigned long)index_key->type >>\n\t\t\t\t    (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\tn--;\n\t\toffset = 1;\n\tdefault:\n\t\toffset += sizeof(chunk) - 1;\n\t\toffset += (level - 3) * sizeof(chunk);\n\t\tif (offset >= desc_len)\n\t\t\treturn 0;\n\t\tdesc_len -= offset;\n\t\tif (desc_len > n)\n\t\t\tdesc_len = n;\n\t\toffset += desc_len;\n\t\tdo {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= ((u8*)index_key->description)[--offset];\n\t\t} while (--desc_len > 0);\n\n\t\tif (level == 2) {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= (u8)((unsigned long)index_key->type >>\n\t\t\t\t      (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\t}\n\t\treturn chunk;\n\t}\n}\n\nstatic unsigned long keyring_get_object_key_chunk(const void *object, int level)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\treturn keyring_get_key_chunk(&key->index_key, level);\n}\n\nstatic bool keyring_compare_object(const void *object, const void *data)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\treturn key->index_key.type == index_key->type &&\n\t\tkey->index_key.desc_len == index_key->desc_len &&\n\t\tmemcmp(key->index_key.description, index_key->description,\n\t\t       index_key->desc_len) == 0;\n}\n\n/*\n * Compare the index keys of a pair of objects and determine the bit position\n * at which they differ - if they differ.\n */\nstatic int keyring_diff_objects(const void *object, const void *data)\n{\n\tconst struct key *key_a = keyring_ptr_to_key(object);\n\tconst struct keyring_index_key *a = &key_a->index_key;\n\tconst struct keyring_index_key *b = data;\n\tunsigned long seg_a, seg_b;\n\tint level, i;\n\n\tlevel = 0;\n\tseg_a = hash_key_type_and_desc(a);\n\tseg_b = hash_key_type_and_desc(b);\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The number of bits contributed by the hash is controlled by a\n\t * constant in the assoc_array headers.  Everything else thereafter we\n\t * can deal with as being machine word-size dependent.\n\t */\n\tlevel += ASSOC_ARRAY_KEY_CHUNK_SIZE / 8;\n\tseg_a = a->desc_len;\n\tseg_b = b->desc_len;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The next bit may not work on big endian */\n\tlevel++;\n\tseg_a = (unsigned long)a->type;\n\tseg_b = (unsigned long)b->type;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\tlevel += sizeof(unsigned long);\n\tif (a->desc_len == 0)\n\t\tgoto same;\n\n\ti = 0;\n\tif (((unsigned long)a->description | (unsigned long)b->description) &\n\t    (sizeof(unsigned long) - 1)) {\n\t\tdo {\n\t\t\tseg_a = *(unsigned long *)(a->description + i);\n\t\t\tseg_b = *(unsigned long *)(b->description + i);\n\t\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\t\tgoto differ_plus_i;\n\t\t\ti += sizeof(unsigned long);\n\t\t} while (i < (a->desc_len & (sizeof(unsigned long) - 1)));\n\t}\n\n\tfor (; i < a->desc_len; i++) {\n\t\tseg_a = *(unsigned char *)(a->description + i);\n\t\tseg_b = *(unsigned char *)(b->description + i);\n\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\tgoto differ_plus_i;\n\t}\n\nsame:\n\treturn -1;\n\ndiffer_plus_i:\n\tlevel += i;\ndiffer:\n\ti = level * 8 + __ffs(seg_a ^ seg_b);\n\treturn i;\n}\n\n/*\n * Free an object after stripping the keyring flag off of the pointer.\n */\nstatic void keyring_free_object(void *object)\n{\n\tkey_put(keyring_ptr_to_key(object));\n}\n\n/*\n * Operations for keyring management by the index-tree routines.\n */\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\n/*\n * Clean up a keyring when it is destroyed.  Unpublish its name if it had one\n * and dispose of its data.\n *\n * The garbage collector detects the final key_put(), removes the keyring from\n * the serial number tree and then does RCU synchronisation before coming here,\n * so we shouldn't need to worry about code poking around here with the RCU\n * readlock held by this time.\n */\nstatic void keyring_destroy(struct key *keyring)\n{\n\tif (keyring->description) {\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (keyring->name_link.next != NULL &&\n\t\t    !list_empty(&keyring->name_link))\n\t\t\tlist_del(&keyring->name_link);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n\n\tif (keyring->restrict_link) {\n\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\tkey_put(keyres->key);\n\t\tkfree(keyres);\n\t}\n\n\tassoc_array_destroy(&keyring->keys, &keyring_assoc_array_ops);\n}\n\n/*\n * Describe a keyring for /proc.\n */\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\n\tif (key_is_positive(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}\n\nstruct keyring_read_iterator_context {\n\tsize_t\t\t\tbuflen;\n\tsize_t\t\t\tcount;\n\tkey_serial_t __user\t*buffer;\n};\n\nstatic int keyring_read_iterator(const void *object, void *data)\n{\n\tstruct keyring_read_iterator_context *ctx = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tint ret;\n\n\tkenter(\"{%s,%d},,{%zu/%zu}\",\n\t       key->type->name, key->serial, ctx->count, ctx->buflen);\n\n\tif (ctx->count >= ctx->buflen)\n\t\treturn 1;\n\n\tret = put_user(key->serial, ctx->buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\tctx->buffer++;\n\tctx->count += sizeof(key->serial);\n\treturn 0;\n}\n\n/*\n * Read a list of key IDs from the keyring's contents in binary form\n *\n * The keyring's semaphore is read-locked by the caller.  This prevents someone\n * from modifying it under us - which could cause us to read key IDs multiple\n * times.\n */\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen)\n{\n\tstruct keyring_read_iterator_context ctx;\n\tunsigned long nr_keys;\n\tint ret;\n\n\tkenter(\"{%d},,%zu\", key_serial(keyring), buflen);\n\n\tif (buflen & (sizeof(key_serial_t) - 1))\n\t\treturn -EINVAL;\n\n\tnr_keys = keyring->keys.nr_leaves_on_tree;\n\tif (nr_keys == 0)\n\t\treturn 0;\n\n\t/* Calculate how much data we could return */\n\tif (!buffer || !buflen)\n\t\treturn nr_keys * sizeof(key_serial_t);\n\n\t/* Copy the IDs of the subscribed keys into the buffer */\n\tctx.buffer = (key_serial_t __user *)buffer;\n\tctx.buflen = buflen;\n\tctx.count = 0;\n\tret = assoc_array_iterate(&keyring->keys, keyring_read_iterator, &ctx);\n\tif (ret < 0) {\n\t\tkleave(\" = %d [iterate]\", ret);\n\t\treturn ret;\n\t}\n\n\tkleave(\" = %zu [ok]\", ctx.count);\n\treturn ctx.count;\n}\n\n/*\n * Allocate a keyring and link into the destination keyring.\n */\nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}\nEXPORT_SYMBOL(keyring_alloc);\n\n/**\n * restrict_link_reject - Give -EPERM to restrict link\n * @keyring: The keyring being added to.\n * @type: The type of key being added.\n * @payload: The payload of the key intended to be added.\n * @data: Additional data for evaluating restriction.\n *\n * Reject the addition of any links to a keyring.  It can be overridden by\n * passing KEY_ALLOC_BYPASS_RESTRICTION to key_instantiate_and_link() when\n * adding a key to a keyring.\n *\n * This is meant to be stored in a key_restriction structure which is passed\n * in the restrict_link parameter to keyring_alloc().\n */\nint restrict_link_reject(struct key *keyring,\n\t\t\t const struct key_type *type,\n\t\t\t const union key_payload *payload,\n\t\t\t struct key *restriction_key)\n{\n\treturn -EPERM;\n}\n\n/*\n * By default, we keys found by getting an exact match on their descriptions.\n */\nbool key_default_cmp(const struct key *key,\n\t\t     const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}\n\n/*\n * Iteration function to consider each key found.\n */\nstatic int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = READ_ONCE(key->flags);\n\tshort state = READ_ONCE(key->state);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* ignore keys not of this type */\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\n\t/* skip invalidated, revoked and expired keys */\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* keys that don't match */\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\n\t/* key must have search permissions */\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\t/* we set a different error code if we pass a negative key */\n\t\tif (state < 0) {\n\t\t\tctx->result = ERR_PTR(state);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* Found */\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}\n\n/*\n * Search inside a keyring for a key.  We can search by walking to it\n * directly based on its index-key or we can iterate over the entire\n * tree looking for it, based on the match function.\n */\nstatic int search_keyring(struct key *keyring, struct keyring_search_context *ctx)\n{\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_DIRECT) {\n\t\tconst void *object;\n\n\t\tobject = assoc_array_find(&keyring->keys,\n\t\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t\t  &ctx->index_key);\n\t\treturn object ? ctx->iterator(object, ctx) : 0;\n\t}\n\treturn assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);\n}\n\n/*\n * Search a tree of keyrings that point to other keyrings up to the maximum\n * depth.\n */\nstatic bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);\n\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\n\t/* Check to see if this top-level keyring is what we are looking for\n\t * and whether it is valid or not.\n\t */\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\n\t/* Start processing a new keyring */\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t/* Search through the keys in this keyring before its searching its\n\t * subtrees.\n\t */\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t/* Then manually iterate through the keyrings nested in this one.\n\t *\n\t * Start from the root node of the index tree.  Because of the way the\n\t * hash function has been set up, keyrings cluster on the leftmost\n\t * branch of the root node (root slot 0) or in the root node itself.\n\t * Non-keyrings avoid the leftmost branch of the root entirely (root\n\t * slots 1-15).\n\t */\n\tptr = READ_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t/* If the root is a shortcut, either the keyring only contains\n\t\t * keyring pointers (everything clusters behind root slot 0) or\n\t\t * doesn't contain any keyring pointers.\n\t\t */\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t/* Descend to a more distal node in this keyring's content tree and go\n\t * through that.\n\t */\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\t/* Go through the slots in a node */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t/* Search a nested keyring */\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t/* We've dealt with all the slots in the current node, so now we need\n\t * to ascend to the parent and continue processing there.\n\t */\n\tptr = READ_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\n\t/* If we've ascended to the root (zero backpointer), we must have just\n\t * finished processing the leftmost branch rather than the root slots -\n\t * so there can't be any more keyrings for us to find.\n\t */\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t/* The keyring we're looking at was disqualified or didn't contain a\n\t * matching key.\n\t */\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t/* Resume the processing of a keyring higher up in the tree */\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t/* We found a viable match */\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now.tv_sec;\n\t\tkeyring->last_used_at = ctx->now.tv_sec;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now.tv_sec;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}\n\n/**\n * keyring_search_aux - Search a keyring tree for a key matching some criteria\n * @keyring_ref: A pointer to the keyring with possession indicator.\n * @ctx: The keyring search context.\n *\n * Search the supplied keyring tree for a key that matches the criteria given.\n * The root keyring and any linked keyrings must grant Search permission to the\n * caller to be searchable and keys can only be found if they too grant Search\n * to the caller. The possession flag on the root keyring pointer controls use\n * of the possessor bits in permissions checking of the entire tree.  In\n * addition, the LSM gets to forbid keyring searches and key matches.\n *\n * The search is performed as a breadth-then-depth search up to the prescribed\n * limit (KEYRING_SEARCH_MAX_DEPTH).\n *\n * Keys are matched to the type provided and are then filtered by the match\n * function, which is given the description to use in any way it sees fit.  The\n * match function may use any attributes of a key that it wishes to to\n * determine the match.  Normally the match function from the key type would be\n * used.\n *\n * RCU can be used to prevent the keyring key lists from disappearing without\n * the need to take lots of locks.\n *\n * Returns a pointer to the found key and increments the key usage count if\n * successful; -EAGAIN if no matching keys were found, or if expired or revoked\n * keys were found; -ENOKEY if only negative keys were found; -ENOTDIR if the\n * specified keyring wasn't a keyring.\n *\n * In the case of a successful return, the possession attribute from\n * @keyring_ref is propagated to the returned key reference.\n */\nkey_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t     struct keyring_search_context *ctx)\n{\n\tstruct key *keyring;\n\tlong err;\n\n\tctx->iterator = keyring_search_iterator;\n\tctx->possessed = is_key_possessed(keyring_ref);\n\tctx->result = ERR_PTR(-EAGAIN);\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\n\t\terr = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\trcu_read_lock();\n\tctx->now = current_kernel_time();\n\tif (search_nested_keyrings(keyring, ctx))\n\t\t__key_get(key_ref_to_ptr(ctx->result));\n\trcu_read_unlock();\n\treturn ctx->result;\n}\n\n/**\n * keyring_search - Search the supplied keyring tree for a matching key\n * @keyring: The root of the keyring tree to be searched.\n * @type: The type of keyring we want to find.\n * @description: The name of the keyring we want to find.\n *\n * As keyring_search_aux() above, but using the current task's credentials and\n * type's default matching function and preferred search method.\n */\nkey_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}\nEXPORT_SYMBOL(keyring_search);\n\nstatic struct key_restriction *keyring_restriction_alloc(\n\tkey_restrict_link_func_t check)\n{\n\tstruct key_restriction *keyres =\n\t\tkzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\n\tif (!keyres)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkeyres->check = check;\n\n\treturn keyres;\n}\n\n/*\n * Semaphore to serialise restriction setup to prevent reference count\n * cycles through restriction key pointers.\n */\nstatic DECLARE_RWSEM(keyring_serialise_restrict_sem);\n\n/*\n * Check for restriction cycles that would prevent keyring garbage collection.\n * keyring_serialise_restrict_sem must be held.\n */\nstatic bool keyring_detect_restriction_cycle(const struct key *dest_keyring,\n\t\t\t\t\t     struct key_restriction *keyres)\n{\n\twhile (keyres && keyres->key &&\n\t       keyres->key->type == &key_type_keyring) {\n\t\tif (keyres->key == dest_keyring)\n\t\t\treturn true;\n\n\t\tkeyres = keyres->key->restrict_link;\n\t}\n\n\treturn false;\n}\n\n/**\n * keyring_restrict - Look up and apply a restriction to a keyring\n *\n * @keyring: The keyring to be restricted\n * @restriction: The restriction options to apply to the keyring\n */\nint keyring_restrict(key_ref_t keyring_ref, const char *type,\n\t\t     const char *restriction)\n{\n\tstruct key *keyring;\n\tstruct key_type *restrict_type = NULL;\n\tstruct key_restriction *restrict_link;\n\tint ret = 0;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tif (!type) {\n\t\trestrict_link = keyring_restriction_alloc(restrict_link_reject);\n\t} else {\n\t\trestrict_type = key_type_lookup(type);\n\n\t\tif (IS_ERR(restrict_type))\n\t\t\treturn PTR_ERR(restrict_type);\n\n\t\tif (!restrict_type->lookup_restriction) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestrict_link = restrict_type->lookup_restriction(restriction);\n\t}\n\n\tif (IS_ERR(restrict_link)) {\n\t\tret = PTR_ERR(restrict_link);\n\t\tgoto error;\n\t}\n\n\tdown_write(&keyring->sem);\n\tdown_write(&keyring_serialise_restrict_sem);\n\n\tif (keyring->restrict_link)\n\t\tret = -EEXIST;\n\telse if (keyring_detect_restriction_cycle(keyring, restrict_link))\n\t\tret = -EDEADLK;\n\telse\n\t\tkeyring->restrict_link = restrict_link;\n\n\tup_write(&keyring_serialise_restrict_sem);\n\tup_write(&keyring->sem);\n\n\tif (ret < 0) {\n\t\tkey_put(restrict_link->key);\n\t\tkfree(restrict_link);\n\t}\n\nerror:\n\tif (restrict_type)\n\t\tkey_type_put(restrict_type);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(keyring_restrict);\n\n/*\n * Search the given keyring for a key that might be updated.\n *\n * The caller must guarantee that the keyring is a keyring and that the\n * permission is granted to modify the keyring as no check is made here.  The\n * caller must also hold a lock on the keyring semaphore.\n *\n * Returns a pointer to the found key with usage count incremented if\n * successful and returns NULL if not found.  Revoked and invalidated keys are\n * skipped over.\n *\n * If successful, the possession indicator is propagated from the keyring ref\n * to the returned key reference.\n */\nkey_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}\n\n/*\n * Find a keyring with the specified name.\n *\n * Only keyrings that have nonzero refcount, are not revoked, and are owned by a\n * user in the current user namespace are considered.  If @uid_keyring is %true,\n * the keyring additionally must have been allocated as a user or user session\n * keyring; otherwise, it must grant Search permission directly to the caller.\n *\n * Returns a pointer to the keyring with the keyring's refcount having being\n * incremented on success.  -ENOKEY is returned if a key could not be found.\n */\nstruct key *find_keyring_by_name(const char *name, bool uid_keyring)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\n\tif (keyring_name_hash[bucket].next) {\n\t\t/* search this hash bucket for a keyring with a matching name\n\t\t * that's readable and that hasn't been revoked */\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (uid_keyring) {\n\t\t\t\tif (!test_bit(KEY_FLAG_UID_KEYRING,\n\t\t\t\t\t      &keyring->flags))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) */\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}\n\nstatic int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* We might get a keyring with matching index-key that is nonetheless a\n\t * different keyring. */\n\tif (key != ctx->match_data.raw_data)\n\t\treturn 0;\n\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}\n\n/*\n * See if a cycle will will be created by inserting acyclic tree B in acyclic\n * tree A at the topmost level (ie: as a direct child of A).\n *\n * Since we are adding B to A at the top level, checking for cycles should just\n * be a matter of seeing if node A is somewhere in tree B.\n */\nstatic int keyring_detect_cycle(struct key *A, struct key *B)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key\t\t= A->index_key,\n\t\t.match_data.raw_data\t= A,\n\t\t.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.iterator\t\t= keyring_detect_cycle_iterator,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_NO_UPDATE_TIME |\n\t\t\t\t\t   KEYRING_SEARCH_NO_CHECK_PERM |\n\t\t\t\t\t   KEYRING_SEARCH_DETECT_TOO_DEEP),\n\t};\n\n\trcu_read_lock();\n\tsearch_nested_keyrings(B, &ctx);\n\trcu_read_unlock();\n\treturn PTR_ERR(ctx.result) == -EAGAIN ? 0 : PTR_ERR(ctx.result);\n}\n\n/*\n * Preallocate memory so that a key can be linked into to a keyring.\n */\nint __key_link_begin(struct key *keyring,\n\t\t     const struct keyring_index_key *index_key,\n\t\t     struct assoc_array_edit **_edit)\n\t__acquires(&keyring->sem)\n\t__acquires(&keyring_serialise_link_sem)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"%d,%s,%s,\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tBUG_ON(index_key->desc_len == 0);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error_krsem;\n\n\t/* serialise link/link calls to prevent parallel calls causing a cycle\n\t * when linking two keyring in opposite orders */\n\tif (index_key->type == &key_type_keyring)\n\t\tdown_write(&keyring_serialise_link_sem);\n\n\t/* Create an edit script that will insert/replace the key in the\n\t * keyring tree.\n\t */\n\tedit = assoc_array_insert(&keyring->keys,\n\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t  index_key,\n\t\t\t\t  NULL);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error_sem;\n\t}\n\n\t/* If we're not replacing a link in-place then we're going to need some\n\t * extra quota.\n\t */\n\tif (!edit->dead_leaf) {\n\t\tret = key_payload_reserve(keyring,\n\t\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto error_cancel;\n\t}\n\n\t*_edit = edit;\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_cancel:\n\tassoc_array_cancel_edit(edit);\nerror_sem:\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\nerror_krsem:\n\tup_write(&keyring->sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Check already instantiated keys aren't going to be a problem.\n *\n * The caller must have called __key_link_begin(). Don't need to call this for\n * keys that were created since __key_link_begin() was called.\n */\nint __key_link_check_live_key(struct key *keyring, struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\t/* check that we aren't going to create a cycle by linking one\n\t\t * keyring to another */\n\t\treturn keyring_detect_cycle(keyring, key);\n\treturn 0;\n}\n\n/*\n * Link a key into to a keyring.\n *\n * Must be called with __key_link_begin() having being called.  Discards any\n * already extant link to matching key if there is one, so that each keyring\n * holds at most one link to any given key of a particular type+description\n * combination.\n */\nvoid __key_link(struct key *key, struct assoc_array_edit **_edit)\n{\n\t__key_get(key);\n\tassoc_array_insert_set_object(*_edit, keyring_key_to_ptr(key));\n\tassoc_array_apply_edit(*_edit);\n\t*_edit = NULL;\n}\n\n/*\n * Finish linking a key into to a keyring.\n *\n * Must be called with __key_link_begin() having being called.\n */\nvoid __key_link_end(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key,\n\t\t    struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\n\tif (edit) {\n\t\tif (!edit->dead_leaf) {\n\t\t\tkey_payload_reserve(keyring,\n\t\t\t\tkeyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\t}\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}\n\n/*\n * Check addition of keys to restricted keyrings.\n */\nstatic int __key_link_check_restriction(struct key *keyring, struct key *key)\n{\n\tif (!keyring->restrict_link || !keyring->restrict_link->check)\n\t\treturn 0;\n\treturn keyring->restrict_link->check(keyring, key->type, &key->payload,\n\t\t\t\t\t     keyring->restrict_link->key);\n}\n\n/**\n * key_link - Link a key to a keyring\n * @keyring: The keyring to make the link in.\n * @key: The key to link to.\n *\n * Make a link in a keyring to a key, such that the keyring holds a reference\n * on that key and the key can potentially be found by searching that keyring.\n *\n * This function will write-lock the keyring's semaphore and will consume some\n * of the user's key data quota to hold the link.\n *\n * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring,\n * -EKEYREVOKED if the keyring has been revoked, -ENFILE if the keyring is\n * full, -EDQUOT if there is insufficient key data quota remaining to add\n * another link or -ENOMEM if there's insufficient memory.\n *\n * It is assumed that the caller has checked that it is permitted for a link to\n * be made (the keyring should have Write permission and the key Link\n * permission).\n */\nint key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\t\tret = __key_link_check_restriction(keyring, key);\n\t\tif (ret == 0)\n\t\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}\nEXPORT_SYMBOL(key_link);\n\n/**\n * key_unlink - Unlink the first link to a key from a keyring.\n * @keyring: The keyring to remove the link from.\n * @key: The key the link is to.\n *\n * Remove a link from a keyring to a key.\n *\n * This function will write-lock the keyring's semaphore.\n *\n * Returns 0 if successful, -ENOTDIR if the keyring isn't a keyring, -ENOENT if\n * the key isn't linked to by the keyring or -ENOMEM if there's insufficient\n * memory.\n *\n * It is assumed that the caller has checked that it is permitted for a link to\n * be removed (the keyring should have Write permission; no permissions are\n * required on the key).\n */\nint key_unlink(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  &key->index_key);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error;\n\t}\n\tret = -ENOENT;\n\tif (edit == NULL)\n\t\tgoto error;\n\n\tassoc_array_apply_edit(edit);\n\tkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\n\tret = 0;\n\nerror:\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(key_unlink);\n\n/**\n * keyring_clear - Clear a keyring\n * @keyring: The keyring to clear.\n *\n * Clear the contents of the specified keyring.\n *\n * Returns 0 if successful or -ENOTDIR if the keyring isn't a keyring.\n */\nint keyring_clear(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t} else {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t\tret = 0;\n\t}\n\n\tup_write(&keyring->sem);\n\treturn ret;\n}\nEXPORT_SYMBOL(keyring_clear);\n\n/*\n * Dispose of the links from a revoked keyring.\n *\n * This is called with the key sem write-locked.\n */\nstatic void keyring_revoke(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (!IS_ERR(edit)) {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t}\n}\n\nstatic bool keyring_gc_select_iterator(void *object, void *iterator_data)\n{\n\tstruct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tif (key_is_dead(key, *limit))\n\t\treturn false;\n\tkey_get(key);\n\treturn true;\n}\n\nstatic int keyring_gc_check_iterator(const void *object, void *iterator_data)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tkey_check(key);\n\treturn key_is_dead(key, *limit);\n}\n\n/*\n * Garbage collect pointers from a keyring.\n *\n * Not called with any locks held.  The keyring's key struct will not be\n * deallocated under us as only our caller may deallocate it.\n */\nvoid keyring_gc(struct key *keyring, time_t limit)\n{\n\tint result;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto dont_gc;\n\n\t/* scan the keyring looking for dead keys */\n\trcu_read_lock();\n\tresult = assoc_array_iterate(&keyring->keys,\n\t\t\t\t     keyring_gc_check_iterator, &limit);\n\trcu_read_unlock();\n\tif (result == true)\n\t\tgoto do_gc;\n\ndont_gc:\n\tkleave(\" [no gc]\");\n\treturn;\n\ndo_gc:\n\tdown_write(&keyring->sem);\n\tassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\n\t\t       keyring_gc_select_iterator, &limit);\n\tup_write(&keyring->sem);\n\tkleave(\" [gc]\");\n}\n\n/*\n * Garbage collect restriction pointers from a keyring.\n *\n * Keyring restrictions are associated with a key type, and must be cleaned\n * up if the key type is unregistered. The restriction is altered to always\n * reject additional keys so a keyring cannot be opened up by unregistering\n * a key type.\n *\n * Not called with any keyring locks held. The keyring's key struct will not\n * be deallocated under us as only our caller may deallocate it.\n *\n * The caller is required to hold key_types_sem and dead_type->sem. This is\n * fulfilled by key_gc_keytype() holding the locks on behalf of\n * key_garbage_collector(), which it invokes on a workqueue.\n */\nvoid keyring_restriction_gc(struct key *keyring, struct key_type *dead_type)\n{\n\tstruct key_restriction *keyres;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\t/*\n\t * keyring->restrict_link is only assigned at key allocation time\n\t * or with the key type locked, so the only values that could be\n\t * concurrently assigned to keyring->restrict_link are for key\n\t * types other than dead_type. Given this, it's ok to check\n\t * the key type before acquiring keyring->sem.\n\t */\n\tif (!dead_type || !keyring->restrict_link ||\n\t    keyring->restrict_link->keytype != dead_type) {\n\t\tkleave(\" [no restriction gc]\");\n\t\treturn;\n\t}\n\n\t/* Lock the keyring to ensure that a link is not in progress */\n\tdown_write(&keyring->sem);\n\n\tkeyres = keyring->restrict_link;\n\n\tkeyres->check = restrict_link_reject;\n\n\tkey_put(keyres->key);\n\tkeyres->key = NULL;\n\tkeyres->keytype = NULL;\n\n\tup_write(&keyring->sem);\n\n\tkleave(\" [restriction gc]\");\n}\n", "/* procfs files for key database enumeration\n *\n * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <asm/errno.h>\n#include \"internal.h\"\n\nstatic int proc_keys_open(struct inode *inode, struct file *file);\nstatic void *proc_keys_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos);\nstatic void proc_keys_stop(struct seq_file *p, void *v);\nstatic int proc_keys_show(struct seq_file *m, void *v);\n\nstatic const struct seq_operations proc_keys_ops = {\n\t.start\t= proc_keys_start,\n\t.next\t= proc_keys_next,\n\t.stop\t= proc_keys_stop,\n\t.show\t= proc_keys_show,\n};\n\nstatic const struct file_operations proc_keys_fops = {\n\t.open\t\t= proc_keys_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic int proc_key_users_open(struct inode *inode, struct file *file);\nstatic void *proc_key_users_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos);\nstatic void proc_key_users_stop(struct seq_file *p, void *v);\nstatic int proc_key_users_show(struct seq_file *m, void *v);\n\nstatic const struct seq_operations proc_key_users_ops = {\n\t.start\t= proc_key_users_start,\n\t.next\t= proc_key_users_next,\n\t.stop\t= proc_key_users_stop,\n\t.show\t= proc_key_users_show,\n};\n\nstatic const struct file_operations proc_key_users_fops = {\n\t.open\t\t= proc_key_users_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\n/*\n * Declare the /proc files.\n */\nstatic int __init key_proc_init(void)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create(\"keys\", 0, NULL, &proc_keys_fops);\n\tif (!p)\n\t\tpanic(\"Cannot create /proc/keys\\n\");\n\n\tp = proc_create(\"key-users\", 0, NULL, &proc_key_users_fops);\n\tif (!p)\n\t\tpanic(\"Cannot create /proc/key-users\\n\");\n\n\treturn 0;\n}\n\n__initcall(key_proc_init);\n\n/*\n * Implement \"/proc/keys\" to provide a list of the keys on the system that\n * grant View permission to the caller.\n */\nstatic struct rb_node *key_serial_next(struct seq_file *p, struct rb_node *n)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\n\tn = rb_next(n);\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (kuid_has_mapping(user_ns, key->user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}\n\nstatic int proc_keys_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_keys_ops);\n}\n\nstatic struct key *find_ge_key(struct seq_file *p, key_serial_t id)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\tstruct rb_node *n = key_serial_tree.rb_node;\n\tstruct key *minkey = NULL;\n\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (id < key->serial) {\n\t\t\tif (!minkey || minkey->serial > key->serial)\n\t\t\t\tminkey = key;\n\t\t\tn = n->rb_left;\n\t\t} else if (id > key->serial) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tminkey = key;\n\t\t\tbreak;\n\t\t}\n\t\tkey = NULL;\n\t}\n\n\tif (!minkey)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tif (kuid_has_mapping(user_ns, minkey->user->uid))\n\t\t\treturn minkey;\n\t\tn = rb_next(&minkey->serial_node);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tminkey = rb_entry(n, struct key, serial_node);\n\t}\n}\n\nstatic void *proc_keys_start(struct seq_file *p, loff_t *_pos)\n\t__acquires(key_serial_lock)\n{\n\tkey_serial_t pos = *_pos;\n\tstruct key *key;\n\n\tspin_lock(&key_serial_lock);\n\n\tif (*_pos > INT_MAX)\n\t\treturn NULL;\n\tkey = find_ge_key(p, pos);\n\tif (!key)\n\t\treturn NULL;\n\t*_pos = key->serial;\n\treturn &key->serial_node;\n}\n\nstatic inline key_serial_t key_node_serial(struct rb_node *n)\n{\n\tstruct key *key = rb_entry(n, struct key, serial_node);\n\treturn key->serial;\n}\n\nstatic void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos)\n{\n\tstruct rb_node *n;\n\n\tn = key_serial_next(p, v);\n\tif (n)\n\t\t*_pos = key_node_serial(n);\n\treturn n;\n}\n\nstatic void proc_keys_stop(struct seq_file *p, void *v)\n\t__releases(key_serial_lock)\n{\n\tspin_unlock(&key_serial_lock);\n}\n\nstatic int proc_keys_show(struct seq_file *m, void *v)\n{\n\tstruct rb_node *_p = v;\n\tstruct key *key = rb_entry(_p, struct key, serial_node);\n\tstruct timespec now;\n\tunsigned long timo;\n\tkey_ref_t key_ref, skey_ref;\n\tchar xbuf[16];\n\tshort state;\n\tint rc;\n\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= key->type,\n\t\t.index_key.description\t= key->description,\n\t\t.cred\t\t\t= m->file->f_cred,\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.raw_data\t= key,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\n\tkey_ref = make_key_ref(key, 0);\n\n\t/* determine if the key is possessed by this process (a test we can\n\t * skip if the key does not indicate the possessor can view it\n\t */\n\tif (key->perm & KEY_POS_VIEW) {\n\t\tskey_ref = search_my_process_keyrings(&ctx);\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_ref_put(skey_ref);\n\t\t\tkey_ref = make_key_ref(key, 1);\n\t\t}\n\t}\n\n\t/* check whether the current task is allowed to view the key */\n\trc = key_task_permission(key_ref, ctx.cred, KEY_NEED_VIEW);\n\tif (rc < 0)\n\t\treturn 0;\n\n\tnow = current_kernel_time();\n\n\trcu_read_lock();\n\n\t/* come up with a suitable timeout value */\n\tif (key->expiry == 0) {\n\t\tmemcpy(xbuf, \"perm\", 5);\n\t} else if (now.tv_sec >= key->expiry) {\n\t\tmemcpy(xbuf, \"expd\", 5);\n\t} else {\n\t\ttimo = key->expiry - now.tv_sec;\n\n\t\tif (timo < 60)\n\t\t\tsprintf(xbuf, \"%lus\", timo);\n\t\telse if (timo < 60*60)\n\t\t\tsprintf(xbuf, \"%lum\", timo / 60);\n\t\telse if (timo < 60*60*24)\n\t\t\tsprintf(xbuf, \"%luh\", timo / (60*60));\n\t\telse if (timo < 60*60*24*7)\n\t\t\tsprintf(xbuf, \"%lud\", timo / (60*60*24));\n\t\telse\n\t\t\tsprintf(xbuf, \"%luw\", timo / (60*60*24*7));\n\t}\n\n\tstate = key_read_state(key);\n\n#define showflag(KEY, LETTER, FLAG) \\\n\t(test_bit(FLAG,\t&(KEY)->flags) ? LETTER : '-')\n\n\tseq_printf(m, \"%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s \",\n\t\t   key->serial,\n\t\t   state != KEY_IS_UNINSTANTIATED ? 'I' : '-',\n\t\t   showflag(key, 'R', KEY_FLAG_REVOKED),\n\t\t   showflag(key, 'D', KEY_FLAG_DEAD),\n\t\t   showflag(key, 'Q', KEY_FLAG_IN_QUOTA),\n\t\t   showflag(key, 'U', KEY_FLAG_USER_CONSTRUCT),\n\t\t   state < 0 ? 'N' : '-',\n\t\t   showflag(key, 'i', KEY_FLAG_INVALIDATED),\n\t\t   refcount_read(&key->usage),\n\t\t   xbuf,\n\t\t   key->perm,\n\t\t   from_kuid_munged(seq_user_ns(m), key->uid),\n\t\t   from_kgid_munged(seq_user_ns(m), key->gid),\n\t\t   key->type->name);\n\n#undef showflag\n\n\tif (key->type->describe)\n\t\tkey->type->describe(key, m);\n\tseq_putc(m, '\\n');\n\n\trcu_read_unlock();\n\treturn 0;\n}\n\nstatic struct rb_node *__key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\twhile (n) {\n\t\tstruct key_user *user = rb_entry(n, struct key_user, node);\n\t\tif (kuid_has_mapping(user_ns, user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}\n\nstatic struct rb_node *key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\treturn __key_user_next(user_ns, rb_next(n));\n}\n\nstatic struct rb_node *key_user_first(struct user_namespace *user_ns, struct rb_root *r)\n{\n\tstruct rb_node *n = rb_first(r);\n\treturn __key_user_next(user_ns, n);\n}\n\n/*\n * Implement \"/proc/key-users\" to provides a list of the key users and their\n * quotas.\n */\nstatic int proc_key_users_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_key_users_ops);\n}\n\nstatic void *proc_key_users_start(struct seq_file *p, loff_t *_pos)\n\t__acquires(key_user_lock)\n{\n\tstruct rb_node *_p;\n\tloff_t pos = *_pos;\n\n\tspin_lock(&key_user_lock);\n\n\t_p = key_user_first(seq_user_ns(p), &key_user_tree);\n\twhile (pos > 0 && _p) {\n\t\tpos--;\n\t\t_p = key_user_next(seq_user_ns(p), _p);\n\t}\n\n\treturn _p;\n}\n\nstatic void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos)\n{\n\t(*_pos)++;\n\treturn key_user_next(seq_user_ns(p), (struct rb_node *)v);\n}\n\nstatic void proc_key_users_stop(struct seq_file *p, void *v)\n\t__releases(key_user_lock)\n{\n\tspin_unlock(&key_user_lock);\n}\n\nstatic int proc_key_users_show(struct seq_file *m, void *v)\n{\n\tstruct rb_node *_p = v;\n\tstruct key_user *user = rb_entry(_p, struct key_user, node);\n\tunsigned maxkeys = uid_eq(user->uid, GLOBAL_ROOT_UID) ?\n\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\tunsigned maxbytes = uid_eq(user->uid, GLOBAL_ROOT_UID) ?\n\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\tseq_printf(m, \"%5u: %5d %d/%d %d/%d %d/%d\\n\",\n\t\t   from_kuid_munged(seq_user_ns(m), user->uid),\n\t\t   refcount_read(&user->usage),\n\t\t   atomic_read(&user->nkeys),\n\t\t   atomic_read(&user->nikeys),\n\t\t   user->qnkeys,\n\t\t   maxkeys,\n\t\t   user->qnbytes,\n\t\t   maxbytes);\n\n\treturn 0;\n}\n", "/* Manage a process's keyrings\n *\n * Copyright (C) 2004-2005, 2008 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/sched/user.h>\n#include <linux/keyctl.h>\n#include <linux/fs.h>\n#include <linux/err.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/user_namespace.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\n/* Session keyring create vs join semaphore */\nstatic DEFINE_MUTEX(key_session_mutex);\n\n/* User keyring creation semaphore */\nstatic DEFINE_MUTEX(key_user_keyring_mutex);\n\n/* The root user's tracking struct */\nstruct key_user root_key_user = {\n\t.usage\t\t= REFCOUNT_INIT(3),\n\t.cons_lock\t= __MUTEX_INITIALIZER(root_key_user.cons_lock),\n\t.lock\t\t= __SPIN_LOCK_UNLOCKED(root_key_user.lock),\n\t.nkeys\t\t= ATOMIC_INIT(2),\n\t.nikeys\t\t= ATOMIC_INIT(2),\n\t.uid\t\t= GLOBAL_ROOT_UID,\n};\n\n/*\n * Install the user and user session keyrings for the current process's UID.\n */\nint install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\n\tkenter(\"%p{%u}\", user, uid);\n\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\n\tif (!user->uid_keyring) {\n\t\t/* get the UID-specific keyring\n\t\t * - there may be one in existence already as it may have been\n\t\t *   pinned by a session, but the user_struct pointing to it\n\t\t *   may have been destroyed by setuid */\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_UID_KEYRING |\n\t\t\t\t\t\t\tKEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* get a default session keyring (which might also exist\n\t\t * already) */\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_UID_KEYRING |\n\t\t\t\t\t\t  KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\n\t\t\t/* we install a link from the user session keyring to\n\t\t\t * the user keyring */\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\n\t\t/* install the keyrings */\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Install a thread keyring to the given credentials struct if it didn't have\n * one already.  This is allowed to overrun the quota.\n *\n * Return: 0 if a thread keyring is now present; -errno on failure.\n */\nint install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->thread_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}\n\n/*\n * Install a thread keyring to the current task if it didn't have one already.\n *\n * Return: 0 if a thread keyring is now present; -errno on failure.\n */\nstatic int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Install a process keyring to the given credentials struct if it didn't have\n * one already.  This is allowed to overrun the quota.\n *\n * Return: 0 if a process keyring is now present; -errno on failure.\n */\nint install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}\n\n/*\n * Install a process keyring to the current task if it didn't have one already.\n *\n * Return: 0 if a process keyring is now present; -errno on failure.\n */\nstatic int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Install the given keyring as the session keyring of the given credentials\n * struct, replacing the existing one if any.  If the given keyring is NULL,\n * then install a new anonymous session keyring.\n *\n * Return: 0 on success; -errno on failure.\n */\nint install_session_keyring_to_cred(struct cred *cred, struct key *keyring)\n{\n\tunsigned long flags;\n\tstruct key *old;\n\n\tmight_sleep();\n\n\t/* create an empty session keyring */\n\tif (!keyring) {\n\t\tflags = KEY_ALLOC_QUOTA_OVERRUN;\n\t\tif (cred->session_keyring)\n\t\t\tflags = KEY_ALLOC_IN_QUOTA;\n\n\t\tkeyring = keyring_alloc(\"_ses\", cred->uid, cred->gid, cred,\n\t\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\t\tflags, NULL, NULL);\n\t\tif (IS_ERR(keyring))\n\t\t\treturn PTR_ERR(keyring);\n\t} else {\n\t\t__key_get(keyring);\n\t}\n\n\t/* install the keyring */\n\told = cred->session_keyring;\n\trcu_assign_pointer(cred->session_keyring, keyring);\n\n\tif (old)\n\t\tkey_put(old);\n\n\treturn 0;\n}\n\n/*\n * Install the given keyring as the session keyring of the current task,\n * replacing the existing one if any.  If the given keyring is NULL, then\n * install a new anonymous session keyring.\n *\n * Return: 0 on success; -errno on failure.\n */\nstatic int install_session_keyring(struct key *keyring)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}\n\n/*\n * Handle the fsuid changing.\n */\nvoid key_fsuid_changed(struct task_struct *tsk)\n{\n\t/* update the ownership of the thread keyring */\n\tBUG_ON(!tsk->cred);\n\tif (tsk->cred->thread_keyring) {\n\t\tdown_write(&tsk->cred->thread_keyring->sem);\n\t\ttsk->cred->thread_keyring->uid = tsk->cred->fsuid;\n\t\tup_write(&tsk->cred->thread_keyring->sem);\n\t}\n}\n\n/*\n * Handle the fsgid changing.\n */\nvoid key_fsgid_changed(struct task_struct *tsk)\n{\n\t/* update the ownership of the thread keyring */\n\tBUG_ON(!tsk->cred);\n\tif (tsk->cred->thread_keyring) {\n\t\tdown_write(&tsk->cred->thread_keyring->sem);\n\t\ttsk->cred->thread_keyring->gid = tsk->cred->fsgid;\n\t\tup_write(&tsk->cred->thread_keyring->sem);\n\t}\n}\n\n/*\n * Search the process keyrings attached to the supplied cred for the first\n * matching key.\n *\n * The search criteria are the type and the match function.  The description is\n * given to the match function as a parameter, but doesn't otherwise influence\n * the search.  Typically the match function will compare the description\n * parameter to the key's description.\n *\n * This can only search keyrings that grant Search permission to the supplied\n * credentials.  Keyrings linked to searched keyrings will also be searched if\n * they grant Search permission too.  Keys can only be found if they grant\n * Search permission to the credentials.\n *\n * Returns a pointer to the key with the key usage count incremented if\n * successful, -EAGAIN if we didn't find any matching key or -ENOKEY if we only\n * matched negative keys.\n *\n * In the case of a successful return, the possession attribute is set on the\n * returned key reference.\n */\nkey_ref_t search_my_process_keyrings(struct keyring_search_context *ctx)\n{\n\tkey_ref_t key_ref, ret, err;\n\n\t/* we want to return -EAGAIN or -ENOKEY if any of the keyrings were\n\t * searchable, but we failed to find a key or we found a negative key;\n\t * otherwise we want to return a sample error (probably -EACCES) if\n\t * none of the keyrings were searchable\n\t *\n\t * in terms of priority: success > -ENOKEY > -EAGAIN > other error\n\t */\n\tkey_ref = NULL;\n\tret = NULL;\n\terr = ERR_PTR(-EAGAIN);\n\n\t/* search the thread keyring first */\n\tif (ctx->cred->thread_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->thread_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the process keyring second */\n\tif (ctx->cred->process_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->process_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the session keyring */\n\tif (ctx->cred->session_keyring) {\n\t\trcu_read_lock();\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(rcu_dereference(ctx->cred->session_keyring), 1),\n\t\t\tctx);\n\t\trcu_read_unlock();\n\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* or search the user-session keyring */\n\telse if (ctx->cred->user->session_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->user->session_keyring, 1),\n\t\t\tctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tkey_ref = ret ? ret : err;\n\nfound:\n\treturn key_ref;\n}\n\n/*\n * Search the process keyrings attached to the supplied cred for the first\n * matching key in the manner of search_my_process_keyrings(), but also search\n * the keys attached to the assumed authorisation key using its credentials if\n * one is available.\n *\n * Return same as search_my_process_keyrings().\n */\nkey_ref_t search_process_keyrings(struct keyring_search_context *ctx)\n{\n\tstruct request_key_auth *rka;\n\tkey_ref_t key_ref, ret = ERR_PTR(-EACCES), err;\n\n\tmight_sleep();\n\n\tkey_ref = search_my_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto found;\n\terr = key_ref;\n\n\t/* if this process has an instantiation authorisation key, then we also\n\t * search the keyrings of the process mentioned there\n\t * - we don't permit access to request_key auth keys via this method\n\t */\n\tif (ctx->cred->request_key_auth &&\n\t    ctx->cred == current_cred() &&\n\t    ctx->index_key.type != &key_type_request_key_auth\n\t    ) {\n\t\tconst struct cred *cred = ctx->cred;\n\n\t\t/* defend against the auth key being revoked */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\tif (key_validate(ctx->cred->request_key_auth) == 0) {\n\t\t\trka = ctx->cred->request_key_auth->payload.data[0];\n\n\t\t\tctx->cred = rka->cred;\n\t\t\tkey_ref = search_process_keyrings(ctx);\n\t\t\tctx->cred = cred;\n\n\t\t\tup_read(&cred->request_key_auth->sem);\n\n\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\tgoto found;\n\n\t\t\tret = key_ref;\n\t\t} else {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tif (err == ERR_PTR(-ENOKEY) || ret == ERR_PTR(-ENOKEY))\n\t\tkey_ref = ERR_PTR(-ENOKEY);\n\telse if (err == ERR_PTR(-EACCES))\n\t\tkey_ref = ret;\n\telse\n\t\tkey_ref = err;\n\nfound:\n\treturn key_ref;\n}\n\n/*\n * See if the key we're looking at is the target key.\n */\nbool lookup_user_key_possessed(const struct key *key,\n\t\t\t       const struct key_match_data *match_data)\n{\n\treturn key == match_data->raw_data;\n}\n\n/*\n * Look up a key ID given us by userspace with a given permissions mask to get\n * the key it refers to.\n *\n * Flags can be passed to request that special keyrings be created if referred\n * to directly, to permit partially constructed keys to be found and to skip\n * validity and permission checks on the found key.\n *\n * Returns a pointer to the key with an incremented usage count if successful;\n * -EINVAL if the key ID is invalid; -ENOKEY if the key ID does not correspond\n * to a key or the best found key was a negative key; -EKEYREVOKED or\n * -EKEYEXPIRED if the best found key was revoked or expired; -EACCES if the\n * found key doesn't grant the requested permit or the LSM denied access to it;\n * or -ENOMEM if a special keyring couldn't be created.\n *\n * In the case of a successful return, the possession attribute is set on the\n * returned key reference.\n */\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = current_kernel_time().tv_sec;\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}\n\n/*\n * Join the named keyring as the session keyring if possible else attempt to\n * create a new one of that name and join that.\n *\n * If the name is NULL, an empty anonymous keyring will be installed as the\n * session keyring.\n *\n * Named session keyrings are joined with a semaphore held to prevent the\n * keyrings from going away whilst the attempt is made to going them and also\n * to prevent a race in creating compatible session keyrings.\n */\nlong join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\n\t/* if no name is provided, install an anonymous keyring */\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\n\t/* allow the user to join or create a named keyring */\n\tmutex_lock(&key_session_mutex);\n\n\t/* look for an existing keyring of this name */\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\t/* not found - try and create a new one */\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error2;\n\t} else if (keyring == new->session_keyring) {\n\t\tret = 0;\n\t\tgoto error3;\n\t}\n\n\t/* we've got a keyring - now to install it */\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error3;\n\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\n\nerror3:\n\tkey_put(keyring);\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n/*\n * Replace a process's session keyring on behalf of one of its children when\n * the target  process is about to resume userspace execution.\n */\nvoid key_change_session_keyring(struct callback_head *twork)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = container_of(twork, struct cred, rcu);\n\n\tif (unlikely(current->flags & PF_EXITING)) {\n\t\tput_cred(new);\n\t\treturn;\n\t}\n\n\tnew->  uid\t= old->  uid;\n\tnew-> euid\t= old-> euid;\n\tnew-> suid\t= old-> suid;\n\tnew->fsuid\t= old->fsuid;\n\tnew->  gid\t= old->  gid;\n\tnew-> egid\t= old-> egid;\n\tnew-> sgid\t= old-> sgid;\n\tnew->fsgid\t= old->fsgid;\n\tnew->user\t= get_uid(old->user);\n\tnew->user_ns\t= get_user_ns(old->user_ns);\n\tnew->group_info\t= get_group_info(old->group_info);\n\n\tnew->securebits\t= old->securebits;\n\tnew->cap_inheritable\t= old->cap_inheritable;\n\tnew->cap_permitted\t= old->cap_permitted;\n\tnew->cap_effective\t= old->cap_effective;\n\tnew->cap_ambient\t= old->cap_ambient;\n\tnew->cap_bset\t\t= old->cap_bset;\n\n\tnew->jit_keyring\t= old->jit_keyring;\n\tnew->thread_keyring\t= key_get(old->thread_keyring);\n\tnew->process_keyring\t= key_get(old->process_keyring);\n\n\tsecurity_transfer_creds(new, old);\n\n\tcommit_creds(new);\n}\n\n/*\n * Make sure that root's user and user-session keyrings exist.\n */\nstatic int __init init_root_keyring(void)\n{\n\treturn install_user_keyrings();\n}\n\nlate_initcall(init_root_keyring);\n", "/* Request a key from userspace\n *\n * Copyright (C) 2004-2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * See Documentation/security/keys/request-key.rst\n */\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kmod.h>\n#include <linux/err.h>\n#include <linux/keyctl.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\n#define key_negative_timeout\t60\t/* default timeout on a negative key's existence */\n\n/**\n * complete_request_key - Complete the construction of a key.\n * @cons: The key construction record.\n * @error: The success or failute of the construction.\n *\n * Complete the attempt to construct a key.  The key will be negated\n * if an error is indicated.  The authorisation key will be revoked\n * unconditionally.\n */\nvoid complete_request_key(struct key_construction *cons, int error)\n{\n\tkenter(\"{%d,%d},%d\", cons->key->serial, cons->authkey->serial, error);\n\n\tif (error < 0)\n\t\tkey_negate_and_link(cons->key, key_negative_timeout, NULL,\n\t\t\t\t    cons->authkey);\n\telse\n\t\tkey_revoke(cons->authkey);\n\n\tkey_put(cons->key);\n\tkey_put(cons->authkey);\n\tkfree(cons);\n}\nEXPORT_SYMBOL(complete_request_key);\n\n/*\n * Initialise a usermode helper that is going to have a specific session\n * keyring.\n *\n * This is called in context of freshly forked kthread before kernel_execve(),\n * so we can simply install the desired session_keyring at this point.\n */\nstatic int umh_keys_init(struct subprocess_info *info, struct cred *cred)\n{\n\tstruct key *keyring = info->data;\n\n\treturn install_session_keyring_to_cred(cred, keyring);\n}\n\n/*\n * Clean up a usermode helper with session keyring.\n */\nstatic void umh_keys_cleanup(struct subprocess_info *info)\n{\n\tstruct key *keyring = info->data;\n\tkey_put(keyring);\n}\n\n/*\n * Call a usermode helper with a specific session keyring.\n */\nstatic int call_usermodehelper_keys(const char *path, char **argv, char **envp,\n\t\t\t\t\tstruct key *session_keyring, int wait)\n{\n\tstruct subprocess_info *info;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t  umh_keys_init, umh_keys_cleanup,\n\t\t\t\t\t  session_keyring);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tkey_get(session_keyring);\n\treturn call_usermodehelper_exec(info, wait);\n}\n\n/*\n * Request userspace finish the construction of a key\n * - execute \"/sbin/request-key <op> <key> <uid> <gid> <keyring> <keyring> <keyring>\"\n */\nstatic int call_sbin_request_key(struct key_construction *cons,\n\t\t\t\t const char *op,\n\t\t\t\t void *aux)\n{\n\tstatic char const request_key[] = \"/sbin/request-key\";\n\tconst struct cred *cred = current_cred();\n\tkey_serial_t prkey, sskey;\n\tstruct key *key = cons->key, *authkey = cons->authkey, *keyring,\n\t\t*session;\n\tchar *argv[9], *envp[3], uid_str[12], gid_str[12];\n\tchar key_str[12], keyring_str[3][12];\n\tchar desc[20];\n\tint ret, i;\n\n\tkenter(\"{%d},{%d},%s\", key->serial, authkey->serial, op);\n\n\tret = install_user_keyrings();\n\tif (ret < 0)\n\t\tgoto error_alloc;\n\n\t/* allocate a new session keyring */\n\tsprintf(desc, \"_req.%u\", key->serial);\n\n\tcred = get_current_cred();\n\tkeyring = keyring_alloc(desc, cred->fsuid, cred->fsgid, cred,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN, NULL, NULL);\n\tput_cred(cred);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error_alloc;\n\t}\n\n\t/* attach the auth key to the session keyring */\n\tret = key_link(keyring, authkey);\n\tif (ret < 0)\n\t\tgoto error_link;\n\n\t/* record the UID and GID */\n\tsprintf(uid_str, \"%d\", from_kuid(&init_user_ns, cred->fsuid));\n\tsprintf(gid_str, \"%d\", from_kgid(&init_user_ns, cred->fsgid));\n\n\t/* we say which key is under construction */\n\tsprintf(key_str, \"%d\", key->serial);\n\n\t/* we specify the process's default keyrings */\n\tsprintf(keyring_str[0], \"%d\",\n\t\tcred->thread_keyring ? cred->thread_keyring->serial : 0);\n\n\tprkey = 0;\n\tif (cred->process_keyring)\n\t\tprkey = cred->process_keyring->serial;\n\tsprintf(keyring_str[1], \"%d\", prkey);\n\n\trcu_read_lock();\n\tsession = rcu_dereference(cred->session_keyring);\n\tif (!session)\n\t\tsession = cred->user->session_keyring;\n\tsskey = session->serial;\n\trcu_read_unlock();\n\n\tsprintf(keyring_str[2], \"%d\", sskey);\n\n\t/* set up a minimal environment */\n\ti = 0;\n\tenvp[i++] = \"HOME=/\";\n\tenvp[i++] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[i] = NULL;\n\n\t/* set up the argument list */\n\ti = 0;\n\targv[i++] = (char *)request_key;\n\targv[i++] = (char *) op;\n\targv[i++] = key_str;\n\targv[i++] = uid_str;\n\targv[i++] = gid_str;\n\targv[i++] = keyring_str[0];\n\targv[i++] = keyring_str[1];\n\targv[i++] = keyring_str[2];\n\targv[i] = NULL;\n\n\t/* do it */\n\tret = call_usermodehelper_keys(request_key, argv, envp, keyring,\n\t\t\t\t       UMH_WAIT_PROC);\n\tkdebug(\"usermode -> 0x%x\", ret);\n\tif (ret >= 0) {\n\t\t/* ret is the exit/wait code */\n\t\tif (test_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags) ||\n\t\t    key_validate(key) < 0)\n\t\t\tret = -ENOKEY;\n\t\telse\n\t\t\t/* ignore any errors from userspace if the key was\n\t\t\t * instantiated */\n\t\t\tret = 0;\n\t}\n\nerror_link:\n\tkey_put(keyring);\n\nerror_alloc:\n\tcomplete_request_key(cons, ret);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Call out to userspace for key construction.\n *\n * Program failure is ignored in favour of key status.\n */\nstatic int construct_key(struct key *key, const void *callout_info,\n\t\t\t size_t callout_len, void *aux,\n\t\t\t struct key *dest_keyring)\n{\n\tstruct key_construction *cons;\n\trequest_key_actor_t actor;\n\tstruct key *authkey;\n\tint ret;\n\n\tkenter(\"%d,%p,%zu,%p\", key->serial, callout_info, callout_len, aux);\n\n\tcons = kmalloc(sizeof(*cons), GFP_KERNEL);\n\tif (!cons)\n\t\treturn -ENOMEM;\n\n\t/* allocate an authorisation key */\n\tauthkey = request_key_auth_new(key, callout_info, callout_len,\n\t\t\t\t       dest_keyring);\n\tif (IS_ERR(authkey)) {\n\t\tkfree(cons);\n\t\tret = PTR_ERR(authkey);\n\t\tauthkey = NULL;\n\t} else {\n\t\tcons->authkey = key_get(authkey);\n\t\tcons->key = key_get(key);\n\n\t\t/* make the call */\n\t\tactor = call_sbin_request_key;\n\t\tif (key->type->request_key)\n\t\t\tactor = key->type->request_key;\n\n\t\tret = actor(cons, \"create\", aux);\n\n\t\t/* check that the actor called complete_request_key() prior to\n\t\t * returning an error */\n\t\tWARN_ON(ret < 0 &&\n\t\t\t!test_bit(KEY_FLAG_REVOKED, &authkey->flags));\n\t\tkey_put(authkey);\n\t}\n\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Get the appropriate destination keyring for the request.\n *\n * The keyring selected is returned with an extra reference upon it which the\n * caller must release.\n */\nstatic void construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\n\tkenter(\"%p\", dest_keyring);\n\n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n\t\t/* the caller supplied one */\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\t/* use a default keyring; falling through the cases until we\n\t\t * find one that we actually have */\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n}\n\n/*\n * Allocate a new key in under-construction state and attempt to link it in to\n * the requested keyring.\n *\n * May return a key that's already under construction instead if there was a\n * race between two thread calling request_key().\n */\nstatic int construct_alloc_key(struct keyring_search_context *ctx,\n\t\t\t       struct key *dest_keyring,\n\t\t\t       unsigned long flags,\n\t\t\t       struct key_user *user,\n\t\t\t       struct key **_key)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct key *key;\n\tkey_perm_t perm;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,,,\",\n\t       ctx->index_key.type->name, ctx->index_key.description);\n\n\t*_key = NULL;\n\tmutex_lock(&user->cons_lock);\n\n\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\tperm |= KEY_USR_VIEW;\n\tif (ctx->index_key.type->read)\n\t\tperm |= KEY_POS_READ;\n\tif (ctx->index_key.type == &key_type_keyring ||\n\t    ctx->index_key.type->update)\n\t\tperm |= KEY_POS_WRITE;\n\n\tkey = key_alloc(ctx->index_key.type, ctx->index_key.description,\n\t\t\tctx->cred->fsuid, ctx->cred->fsgid, ctx->cred,\n\t\t\tperm, flags, NULL);\n\tif (IS_ERR(key))\n\t\tgoto alloc_failed;\n\n\tset_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags);\n\n\tif (dest_keyring) {\n\t\tret = __key_link_begin(dest_keyring, &ctx->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_prealloc_failed;\n\t}\n\n\t/* attach the key to the destination keyring under lock, but we do need\n\t * to do another check just in case someone beat us to it whilst we\n\t * waited for locks */\n\tmutex_lock(&key_construction_mutex);\n\n\tkey_ref = search_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto key_already_present;\n\n\tif (dest_keyring)\n\t\t__key_link(key, &edit);\n\n\tmutex_unlock(&key_construction_mutex);\n\tif (dest_keyring)\n\t\t__key_link_end(dest_keyring, &ctx->index_key, edit);\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = 0 [%d]\", key_serial(key));\n\treturn 0;\n\n\t/* the key is now present - we tell the caller that we found it by\n\t * returning -EINPROGRESS  */\nkey_already_present:\n\tkey_put(key);\n\tmutex_unlock(&key_construction_mutex);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (dest_keyring) {\n\t\tret = __key_link_check_live_key(dest_keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(dest_keyring, &ctx->index_key, edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_check_failed;\n\t}\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = -EINPROGRESS [%d]\", key_serial(key));\n\treturn -EINPROGRESS;\n\nlink_check_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkey_put(key);\n\tkleave(\" = %d [linkcheck]\", ret);\n\treturn ret;\n\nlink_prealloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkey_put(key);\n\tkleave(\" = %d [prelink]\", ret);\n\treturn ret;\n\nalloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkleave(\" = %ld\", PTR_ERR(key));\n\treturn PTR_ERR(key);\n}\n\n/*\n * Commence key construction.\n */\nstatic struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\"\");\n\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconstruct_get_dest_keyring(&dest_keyring);\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto couldnt_alloc_key;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\ncouldnt_alloc_key:\n\tkey_put(dest_keyring);\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n/**\n * request_key_and_link - Request a key and cache it in a keyring.\n * @type: The type of key we want.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n * @dest_keyring: Where to cache the key.\n * @flags: Flags to key_alloc().\n *\n * A key matching the specified criteria is searched for in the process's\n * keyrings and returned with its usage count incremented if found.  Otherwise,\n * if callout_info is not NULL, a key will be allocated and some service\n * (probably in userspace) will be asked to instantiate it.\n *\n * If successfully found or created, the key will be linked to the destination\n * keyring if one is provided.\n *\n * Returns a pointer to the key if successful; -EACCES, -ENOKEY, -EKEYREVOKED\n * or -EKEYEXPIRED if an inaccessible, negative, revoked or expired key was\n * found; -ENOKEY if no key was found and no @callout_info was given; -EDQUOT\n * if insufficient key quota was available to create a new key; or -ENOMEM if\n * insufficient memory was available.\n *\n * If the returned key was created, then it may still be under construction,\n * and wait_for_key_construction() should be used to wait for that to complete.\n */\nstruct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_DO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_SKIP_EXPIRED),\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* search all the process keyrings for a key */\n\tkey_ref = search_process_keyrings(&ctx);\n\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tconstruct_get_dest_keyring(&dest_keyring);\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tkey_put(dest_keyring);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\t/* the search failed, but the keyrings were searchable, so we\n\t\t * should consult userspace if we can */\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\n\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}\n\n/**\n * wait_for_key_construction - Wait for construction of a key to complete\n * @key: The key being waited for.\n * @intr: Whether to wait interruptibly.\n *\n * Wait for a key to finish being constructed.\n *\n * Returns 0 if successful; -ERESTARTSYS if the wait was interrupted; -ENOKEY\n * if the key was negated; or -EKEYREVOKED or -EKEYEXPIRED if the key was\n * revoked or expired.\n */\nint wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn key_validate(key);\n}\nEXPORT_SYMBOL(wait_for_key_construction);\n\n/**\n * request_key - Request a key and wait for construction\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found, new keys are always allocated in the user's quota,\n * the callout_info must be a NUL-terminated string and no auxiliary data can\n * be passed.\n *\n * Furthermore, it then works as wait_for_key_construction() to wait for the\n * completion of keys undergoing construction with a non-interruptible wait.\n */\nstruct key *request_key(struct key_type *type,\n\t\t\tconst char *description,\n\t\t\tconst char *callout_info)\n{\n\tstruct key *key;\n\tsize_t callout_len = 0;\n\tint ret;\n\n\tif (callout_info)\n\t\tcallout_len = strlen(callout_info);\n\tkey = request_key_and_link(type, description, callout_info, callout_len,\n\t\t\t\t   NULL, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key);\n\n/**\n * request_key_with_auxdata - Request a key with auxiliary data for the upcaller\n * @type: The type of key we want.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found and new keys are always allocated in the user's quota.\n *\n * Furthermore, it then works as wait_for_key_construction() to wait for the\n * completion of keys undergoing construction with a non-interruptible wait.\n */\nstruct key *request_key_with_auxdata(struct key_type *type,\n\t\t\t\t     const char *description,\n\t\t\t\t     const void *callout_info,\n\t\t\t\t     size_t callout_len,\n\t\t\t\t     void *aux)\n{\n\tstruct key *key;\n\tint ret;\n\n\tkey = request_key_and_link(type, description, callout_info, callout_len,\n\t\t\t\t   aux, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key_with_auxdata);\n\n/*\n * request_key_async - Request a key (allow async construction)\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found, new keys are always allocated in the user's quota and\n * no auxiliary data can be passed.\n *\n * The caller should call wait_for_key_construction() to wait for the\n * completion of the returned key if it is still undergoing construction.\n */\nstruct key *request_key_async(struct key_type *type,\n\t\t\t      const char *description,\n\t\t\t      const void *callout_info,\n\t\t\t      size_t callout_len)\n{\n\treturn request_key_and_link(type, description, callout_info,\n\t\t\t\t    callout_len, NULL, NULL,\n\t\t\t\t    KEY_ALLOC_IN_QUOTA);\n}\nEXPORT_SYMBOL(request_key_async);\n\n/*\n * request a key with auxiliary data for the upcaller (allow async construction)\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found and new keys are always allocated in the user's quota.\n *\n * The caller should call wait_for_key_construction() to wait for the\n * completion of the returned key if it is still undergoing construction.\n */\nstruct key *request_key_async_with_auxdata(struct key_type *type,\n\t\t\t\t\t   const char *description,\n\t\t\t\t\t   const void *callout_info,\n\t\t\t\t\t   size_t callout_len,\n\t\t\t\t\t   void *aux)\n{\n\treturn request_key_and_link(type, description, callout_info,\n\t\t\t\t    callout_len, aux, NULL, KEY_ALLOC_IN_QUOTA);\n}\nEXPORT_SYMBOL(request_key_async_with_auxdata);\n", "/* Request key authorisation token key definition.\n *\n * Copyright (C) 2005 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * See Documentation/security/keys/request-key.rst\n */\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <keys/user-type.h>\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *);\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *);\nstatic int request_key_auth_instantiate(struct key *,\n\t\t\t\t\tstruct key_preparsed_payload *);\nstatic void request_key_auth_describe(const struct key *, struct seq_file *);\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstatic long request_key_auth_read(const struct key *, char __user *, size_t);\n\n/*\n * The request-key authorisation key type definition.\n */\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstatic int request_key_auth_preparse(struct key_preparsed_payload *prep)\n{\n\treturn 0;\n}\n\nstatic void request_key_auth_free_preparse(struct key_preparsed_payload *prep)\n{\n}\n\n/*\n * Instantiate a request-key authorisation key.\n */\nstatic int request_key_auth_instantiate(struct key *key,\n\t\t\t\t\tstruct key_preparsed_payload *prep)\n{\n\tkey->payload.data[0] = (struct request_key_auth *)prep->data;\n\treturn 0;\n}\n\n/*\n * Describe an authorisation token.\n */\nstatic void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}\n\n/*\n * Read the callout_info data (retrieves the callout information).\n * - the key's semaphore is read-locked\n */\nstatic long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Handle revocation of an authorisation token key.\n *\n * Called with the key sem write-locked.\n */\nstatic void request_key_auth_revoke(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tkenter(\"{%d}\", key->serial);\n\n\tif (rka->cred) {\n\t\tput_cred(rka->cred);\n\t\trka->cred = NULL;\n\t}\n}\n\nstatic void free_request_key_auth(struct request_key_auth *rka)\n{\n\tif (!rka)\n\t\treturn;\n\tkey_put(rka->target_key);\n\tkey_put(rka->dest_keyring);\n\tif (rka->cred)\n\t\tput_cred(rka->cred);\n\tkfree(rka->callout_info);\n\tkfree(rka);\n}\n\n/*\n * Destroy an instantiation authorisation token key.\n */\nstatic void request_key_auth_destroy(struct key *key)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tkenter(\"{%d}\", key->serial);\n\n\tfree_request_key_auth(rka);\n}\n\n/*\n * Create an authorisation token for /sbin/request-key or whoever to gain\n * access to the caller's security data.\n */\nstruct key *request_key_auth_new(struct key *target, const void *callout_info,\n\t\t\t\t size_t callout_len, struct key *dest_keyring)\n{\n\tstruct request_key_auth *rka, *irka;\n\tconst struct cred *cred = current->cred;\n\tstruct key *authkey = NULL;\n\tchar desc[20];\n\tint ret = -ENOMEM;\n\n\tkenter(\"%d,\", target->serial);\n\n\t/* allocate a auth record */\n\trka = kzalloc(sizeof(*rka), GFP_KERNEL);\n\tif (!rka)\n\t\tgoto error;\n\trka->callout_info = kmemdup(callout_info, callout_len, GFP_KERNEL);\n\tif (!rka->callout_info)\n\t\tgoto error_free_rka;\n\trka->callout_len = callout_len;\n\n\t/* see if the calling process is already servicing the key request of\n\t * another process */\n\tif (cred->request_key_auth) {\n\t\t/* it is - use that instantiation context here too */\n\t\tdown_read(&cred->request_key_auth->sem);\n\n\t\t/* if the auth key has been revoked, then the key we're\n\t\t * servicing is already instantiated */\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &cred->request_key_auth->flags)) {\n\t\t\tup_read(&cred->request_key_auth->sem);\n\t\t\tret = -EKEYREVOKED;\n\t\t\tgoto error_free_rka;\n\t\t}\n\n\t\tirka = cred->request_key_auth->payload.data[0];\n\t\trka->cred = get_cred(irka->cred);\n\t\trka->pid = irka->pid;\n\n\t\tup_read(&cred->request_key_auth->sem);\n\t}\n\telse {\n\t\t/* it isn't - use this process as the context */\n\t\trka->cred = get_cred(cred);\n\t\trka->pid = current->pid;\n\t}\n\n\trka->target_key = key_get(target);\n\trka->dest_keyring = key_get(dest_keyring);\n\n\t/* allocate the auth key */\n\tsprintf(desc, \"%x\", target->serial);\n\n\tauthkey = key_alloc(&key_type_request_key_auth, desc,\n\t\t\t    cred->fsuid, cred->fsgid, cred,\n\t\t\t    KEY_POS_VIEW | KEY_POS_READ | KEY_POS_SEARCH |\n\t\t\t    KEY_USR_VIEW, KEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error_free_rka;\n\t}\n\n\t/* construct the auth key */\n\tret = key_instantiate_and_link(authkey, rka, 0, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto error_put_authkey;\n\n\tkleave(\" = {%d,%d}\", authkey->serial, refcount_read(&authkey->usage));\n\treturn authkey;\n\nerror_put_authkey:\n\tkey_put(authkey);\nerror_free_rka:\n\tfree_request_key_auth(rka);\nerror:\n\tkleave(\"= %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n/*\n * Search the current process's keyrings for the authorisation key for\n * instantiation of a key.\n */\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}\n", "/*\n * Copyright (C) 2010 IBM Corporation\n *\n * Author:\n * David Safford <safford@us.ibm.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 2 of the License.\n *\n * See Documentation/security/keys/trusted-encrypted.rst\n */\n\n#include <crypto/hash_info.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <keys/trusted-type.h>\n#include <linux/key-type.h>\n#include <linux/rcupdate.h>\n#include <linux/crypto.h>\n#include <crypto/hash.h>\n#include <crypto/sha.h>\n#include <linux/capability.h>\n#include <linux/tpm.h>\n#include <linux/tpm_command.h>\n\n#include \"trusted.h\"\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic const char hash_alg[] = \"sha1\";\n\nstruct sdesc {\n\tstruct shash_desc shash;\n\tchar ctx[];\n};\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}\n\nstatic int TSS_sha1(const unsigned char *data, unsigned int datalen,\n\t\t    unsigned char *digest)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);\n\tkzfree(sdesc);\n\treturn ret;\n}\n\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}\n\n/*\n * calculate authorization info fields to send to TPM\n */\nstatic int TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned char h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}\n\n/*\n * verify the AUTH1_COMMAND (Seal) result from TPM\n */\nstatic int TSS_checkhmac1(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key,\n\t\t\t  unsigned int keylen, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce;\n\tunsigned char *continueflag;\n\tunsigned char *authdata;\n\tunsigned char testhmac[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH1_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata = buffer + bufsize - SHA1_DIGEST_SIZE;\n\tcontinueflag = authdata - 1;\n\tenonce = continueflag - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac, key, keylen, SHA1_DIGEST_SIZE, paramdigest,\n\t\t\t  TPM_NONCE_SIZE, enonce, TPM_NONCE_SIZE, ononce,\n\t\t\t  1, continueflag, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}\n\n/*\n * verify the AUTH2_COMMAND (unseal) result from TPM\n */\nstatic int TSS_checkhmac2(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key1,\n\t\t\t  unsigned int keylen1,\n\t\t\t  const unsigned char *key2,\n\t\t\t  unsigned int keylen2, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce1;\n\tunsigned char *continueflag1;\n\tunsigned char *authdata1;\n\tunsigned char *enonce2;\n\tunsigned char *continueflag2;\n\tunsigned char *authdata2;\n\tunsigned char testhmac1[SHA1_DIGEST_SIZE];\n\tunsigned char testhmac2[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH2_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata1 = buffer + bufsize - (SHA1_DIGEST_SIZE + 1\n\t\t\t+ SHA1_DIGEST_SIZE + SHA1_DIGEST_SIZE);\n\tauthdata2 = buffer + bufsize - (SHA1_DIGEST_SIZE);\n\tcontinueflag1 = authdata1 - 1;\n\tcontinueflag2 = authdata2 - 1;\n\tenonce1 = continueflag1 - TPM_NONCE_SIZE;\n\tenonce2 = continueflag2 - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen2);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac1, key1, keylen1, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce1,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag1, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac1, authdata1, SHA1_DIGEST_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = TSS_rawhmac(testhmac2, key2, keylen2, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce2,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag2, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}\n\n/*\n * For key specific tpm requests, we will generate and send our\n * own TPM command packets using the drivers send function.\n */\nstatic int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}\n\n/*\n * Lock a trusted key, by extending a selected PCR.\n *\n * Prevents a trusted key that is sealed to PCRs from being accessed.\n * This uses the tpm driver's extend function.\n */\nstatic int pcrlock(const int pcrnum)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\n\tif (ret != SHA1_DIGEST_SIZE)\n\t\treturn ret;\n\treturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\n}\n\n/*\n * Create an object specific authorisation protocol (OSAP) session\n */\nstatic int osap(struct tpm_buf *tb, struct osapsess *s,\n\t\tconst unsigned char *key, uint16_t type, uint32_t handle)\n{\n\tunsigned char enonce[TPM_NONCE_SIZE];\n\tunsigned char ononce[TPM_NONCE_SIZE];\n\tint ret;\n\n\tret = tpm_get_random(TPM_ANY_NUM, ononce, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\treturn ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OSAP_SIZE);\n\tstore32(tb, TPM_ORD_OSAP);\n\tstore16(tb, type);\n\tstore32(tb, handle);\n\tstorebytes(tb, ononce, TPM_NONCE_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts->handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(s->enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]),\n\t       TPM_NONCE_SIZE);\n\tmemcpy(enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t\t  TPM_NONCE_SIZE]), TPM_NONCE_SIZE);\n\treturn TSS_rawhmac(s->secret, key, SHA1_DIGEST_SIZE, TPM_NONCE_SIZE,\n\t\t\t   enonce, TPM_NONCE_SIZE, ononce, 0, 0);\n}\n\n/*\n * Create an object independent authorisation protocol (oiap) session\n */\nstatic int oiap(struct tpm_buf *tb, uint32_t *handle, unsigned char *nonce)\n{\n\tint ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OIAP_SIZE);\n\tstore32(tb, TPM_ORD_OIAP);\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(nonce, &tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)],\n\t       TPM_NONCE_SIZE);\n\treturn 0;\n}\n\nstruct tpm_digests {\n\tunsigned char encauth[SHA1_DIGEST_SIZE];\n\tunsigned char pubauth[SHA1_DIGEST_SIZE];\n\tunsigned char xorwork[SHA1_DIGEST_SIZE * 2];\n\tunsigned char xorhash[SHA1_DIGEST_SIZE];\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n};\n\n/*\n * Have the TPM seal(encrypt) the trusted key, possibly based on\n * Platform Configuration Registers (PCRs). AUTH1 for sealing key.\n */\nstatic int tpm_seal(struct tpm_buf *tb, uint16_t keytype,\n\t\t    uint32_t keyhandle, const unsigned char *keyauth,\n\t\t    const unsigned char *data, uint32_t datalen,\n\t\t    unsigned char *blob, uint32_t *bloblen,\n\t\t    const unsigned char *blobauth,\n\t\t    const unsigned char *pcrinfo, uint32_t pcrinfosize)\n{\n\tstruct osapsess sess;\n\tstruct tpm_digests *td;\n\tunsigned char cont;\n\tuint32_t ordinal;\n\tuint32_t pcrsize;\n\tuint32_t datsize;\n\tint sealinfosize;\n\tint encdatasize;\n\tint storedsize;\n\tint ret;\n\tint i;\n\n\t/* alloc some work space for all the hashes */\n\ttd = kmalloc(sizeof *td, GFP_KERNEL);\n\tif (!td)\n\t\treturn -ENOMEM;\n\n\t/* get session for sealing key */\n\tret = osap(tb, &sess, keyauth, keytype, keyhandle);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_sess(&sess);\n\n\t/* calculate encrypted authorization value */\n\tmemcpy(td->xorwork, sess.secret, SHA1_DIGEST_SIZE);\n\tmemcpy(td->xorwork + SHA1_DIGEST_SIZE, sess.enonce, SHA1_DIGEST_SIZE);\n\tret = TSS_sha1(td->xorwork, SHA1_DIGEST_SIZE * 2, td->xorhash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = tpm_get_random(TPM_ANY_NUM, td->nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\tgoto out;\n\tordinal = htonl(TPM_ORD_SEAL);\n\tdatsize = htonl(datalen);\n\tpcrsize = htonl(pcrinfosize);\n\tcont = 0;\n\n\t/* encrypt data authorization key */\n\tfor (i = 0; i < SHA1_DIGEST_SIZE; ++i)\n\t\ttd->encauth[i] = td->xorhash[i] ^ blobauth[i];\n\n\t/* calculate authorization HMAC value */\n\tif (pcrinfosize == 0) {\n\t\t/* no pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   sizeof(uint32_t), &datsize, datalen, data, 0,\n\t\t\t\t   0);\n\t} else {\n\t\t/* pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   pcrinfosize, pcrinfo, sizeof(uint32_t),\n\t\t\t\t   &datsize, datalen, data, 0, 0);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* build and send the TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH1_COMMAND);\n\tstore32(tb, TPM_SEAL_SIZE + pcrinfosize + datalen);\n\tstore32(tb, TPM_ORD_SEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, td->encauth, SHA1_DIGEST_SIZE);\n\tstore32(tb, pcrinfosize);\n\tstorebytes(tb, pcrinfo, pcrinfosize);\n\tstore32(tb, datalen);\n\tstorebytes(tb, data, datalen);\n\tstore32(tb, sess.handle);\n\tstorebytes(tb, td->nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, td->pubauth, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* calculate the size of the returned Blob */\n\tsealinfosize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t));\n\tencdatasize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t     sizeof(uint32_t) + sealinfosize);\n\tstoredsize = sizeof(uint32_t) + sizeof(uint32_t) + sealinfosize +\n\t    sizeof(uint32_t) + encdatasize;\n\n\t/* check the HMAC in the response */\n\tret = TSS_checkhmac1(tb->data, ordinal, td->nonceodd, sess.secret,\n\t\t\t     SHA1_DIGEST_SIZE, storedsize, TPM_DATA_OFFSET, 0,\n\t\t\t     0);\n\n\t/* copy the returned blob to caller */\n\tif (!ret) {\n\t\tmemcpy(blob, tb->data + TPM_DATA_OFFSET, storedsize);\n\t\t*bloblen = storedsize;\n\t}\nout:\n\tkzfree(td);\n\treturn ret;\n}\n\n/*\n * use the AUTH2_COMMAND form of unseal, to authorize both key and blob\n */\nstatic int tpm_unseal(struct tpm_buf *tb,\n\t\t      uint32_t keyhandle, const unsigned char *keyauth,\n\t\t      const unsigned char *blob, int bloblen,\n\t\t      const unsigned char *blobauth,\n\t\t      unsigned char *data, unsigned int *datalen)\n{\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char enonce1[TPM_NONCE_SIZE];\n\tunsigned char enonce2[TPM_NONCE_SIZE];\n\tunsigned char authdata1[SHA1_DIGEST_SIZE];\n\tunsigned char authdata2[SHA1_DIGEST_SIZE];\n\tuint32_t authhandle1 = 0;\n\tuint32_t authhandle2 = 0;\n\tunsigned char cont = 0;\n\tuint32_t ordinal;\n\tuint32_t keyhndl;\n\tint ret;\n\n\t/* sessions for unsealing key and data */\n\tret = oiap(tb, &authhandle1, enonce1);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = oiap(tb, &authhandle2, enonce2);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tordinal = htonl(TPM_ORD_UNSEAL);\n\tkeyhndl = htonl(SRKHANDLE);\n\tret = tpm_get_random(TPM_ANY_NUM, nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE) {\n\t\tpr_info(\"trusted_key: tpm_get_random failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = TSS_authhmac(authdata1, keyauth, TPM_NONCE_SIZE,\n\t\t\t   enonce1, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = TSS_authhmac(authdata2, blobauth, TPM_NONCE_SIZE,\n\t\t\t   enonce2, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* build and send TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH2_COMMAND);\n\tstore32(tb, TPM_UNSEAL_SIZE + bloblen);\n\tstore32(tb, TPM_ORD_UNSEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, blob, bloblen);\n\tstore32(tb, authhandle1);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata1, SHA1_DIGEST_SIZE);\n\tstore32(tb, authhandle2);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata2, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: authhmac failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*datalen = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tret = TSS_checkhmac2(tb->data, ordinal, nonceodd,\n\t\t\t     keyauth, SHA1_DIGEST_SIZE,\n\t\t\t     blobauth, SHA1_DIGEST_SIZE,\n\t\t\t     sizeof(uint32_t), TPM_DATA_OFFSET,\n\t\t\t     *datalen, TPM_DATA_OFFSET + sizeof(uint32_t), 0,\n\t\t\t     0);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: TSS_checkhmac2 failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(data, tb->data + TPM_DATA_OFFSET + sizeof(uint32_t), *datalen);\n\treturn 0;\n}\n\n/*\n * Have the TPM seal(encrypt) the symmetric key\n */\nstatic int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\t/* include migratable flag at end of sealed key */\n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkseal failed (%d)\\n\", ret);\n\n\tkzfree(tb);\n\treturn ret;\n}\n\n/*\n * Have the TPM unseal(decrypt) the symmetric key\n */\nstatic int key_unseal(struct trusted_key_payload *p,\n\t\t      struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = tpm_unseal(tb, o->keyhandle, o->keyauth, p->blob, p->blob_len,\n\t\t\t o->blobauth, p->key, &p->key_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkunseal failed (%d)\\n\", ret);\n\telse\n\t\t/* pull migratable flag out of sealed key */\n\t\tp->migratable = p->key[--p->key_len];\n\n\tkzfree(tb);\n\treturn ret;\n}\n\nenum {\n\tOpt_err = -1,\n\tOpt_new, Opt_load, Opt_update,\n\tOpt_keyhandle, Opt_keyauth, Opt_blobauth,\n\tOpt_pcrinfo, Opt_pcrlock, Opt_migratable,\n\tOpt_hash,\n\tOpt_policydigest,\n\tOpt_policyhandle,\n};\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};\n\n/* can have zero or more token= options */\nstatic int getoptions(char *c, struct trusted_key_payload *pay,\n\t\t      struct trusted_key_options *opt)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p = c;\n\tint token;\n\tint res;\n\tunsigned long handle;\n\tunsigned long lock;\n\tunsigned long token_mask = 0;\n\tunsigned int digest_len;\n\tint i;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\topt->hash = tpm2 ? HASH_ALGO_SHA256 : HASH_ALGO_SHA1;\n\n\twhile ((p = strsep(&c, \" \\t\"))) {\n\t\tif (*p == '\\0' || *p == ' ' || *p == '\\t')\n\t\t\tcontinue;\n\t\ttoken = match_token(p, key_tokens, args);\n\t\tif (test_and_set_bit(token, &token_mask))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (token) {\n\t\tcase Opt_pcrinfo:\n\t\t\topt->pcrinfo_len = strlen(args[0].from) / 2;\n\t\t\tif (opt->pcrinfo_len > MAX_PCRINFO_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->pcrinfo, args[0].from,\n\t\t\t\t      opt->pcrinfo_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_keyhandle:\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->keytype = SEAL_keytype;\n\t\t\topt->keyhandle = handle;\n\t\t\tbreak;\n\t\tcase Opt_keyauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->keyauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_blobauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->blobauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_migratable:\n\t\t\tif (*args[0].from == '0')\n\t\t\t\tpay->migratable = 0;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_pcrlock:\n\t\t\tres = kstrtoul(args[0].from, 10, &lock);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->pcrlock = lock;\n\t\t\tbreak;\n\t\tcase Opt_hash:\n\t\t\tif (test_bit(Opt_policydigest, &token_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tfor (i = 0; i < HASH_ALGO__LAST; i++) {\n\t\t\t\tif (!strcmp(args[0].from, hash_algo_name[i])) {\n\t\t\t\t\topt->hash = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == HASH_ALGO__LAST)\n\t\t\t\treturn -EINVAL;\n\t\t\tif  (!tpm2 && i != HASH_ALGO_SHA1) {\n\t\t\t\tpr_info(\"trusted_key: TPM 1.x only supports SHA-1.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_policydigest:\n\t\t\tdigest_len = hash_digest_size[opt->hash];\n\t\t\tif (!tpm2 || strlen(args[0].from) != (2 * digest_len))\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->policydigest, args[0].from,\n\t\t\t\t      digest_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policydigest_len = digest_len;\n\t\t\tbreak;\n\t\tcase Opt_policyhandle:\n\t\t\tif (!tpm2)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policyhandle = handle;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * datablob_parse - parse the keyctl data and fill in the\n * \t\t    payload and options structures\n *\n * On success returns 0, otherwise -EINVAL.\n */\nstatic int datablob_parse(char *datablob, struct trusted_key_payload *p,\n\t\t\t  struct trusted_key_options *o)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t/* main command */\n\tc = strsep(&datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t/* first argument is key size */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t/* first argument is sealed blob */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\t/* all arguments are options */\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn NULL;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t/* set any non-zero defaults */\n\t\toptions->keytype = SRK_keytype;\n\n\t\tif (!tpm2)\n\t\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}\n\nstatic struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof *p);\n\tif (ret < 0)\n\t\treturn p;\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (p)\n\t\tp->migratable = 1; /* migratable by default */\n\treturn p;\n}\n\n/*\n * trusted_instantiate - create a new trusted key\n *\n * Unseal an existing trusted blob or, for a new key, get a\n * random key, then seal and create a trusted key-type key,\n * adding it to the specified keyring.\n *\n * On success, return 0. Otherwise return errno.\n */\nstatic int trusted_instantiate(struct key *key,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *payload = NULL;\n\tstruct trusted_key_options *options = NULL;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tint key_cmd;\n\tsize_t key_len;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\n\toptions = trusted_options_alloc();\n\tif (!options) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpayload = trusted_payload_alloc(key);\n\tif (!payload) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey_cmd = datablob_parse(datablob, payload, options);\n\tif (key_cmd < 0) {\n\t\tret = key_cmd;\n\t\tgoto out;\n\t}\n\n\tif (!options->keyhandle) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdump_payload(payload);\n\tdump_options(options);\n\n\tswitch (key_cmd) {\n\tcase Opt_load:\n\t\tif (tpm2)\n\t\t\tret = tpm_unseal_trusted(TPM_ANY_NUM, payload, options);\n\t\telse\n\t\t\tret = key_unseal(payload, options);\n\t\tdump_payload(payload);\n\t\tdump_options(options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_unseal failed (%d)\\n\", ret);\n\t\tbreak;\n\tcase Opt_new:\n\t\tkey_len = payload->key_len;\n\t\tret = tpm_get_random(TPM_ANY_NUM, payload->key, key_len);\n\t\tif (ret != key_len) {\n\t\t\tpr_info(\"trusted_key: key_create failed (%d)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (tpm2)\n\t\t\tret = tpm_seal_trusted(TPM_ANY_NUM, payload, options);\n\t\telse\n\t\t\tret = key_seal(payload, options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!ret && options->pcrlock)\n\t\tret = pcrlock(options->pcrlock);\nout:\n\tkzfree(datablob);\n\tkzfree(options);\n\tif (!ret)\n\t\trcu_assign_keypointer(key, payload);\n\telse\n\t\tkzfree(payload);\n\treturn ret;\n}\n\nstatic void trusted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct trusted_key_payload *p;\n\n\tp = container_of(rcu, struct trusted_key_payload, rcu);\n\tkzfree(p);\n}\n\n/*\n * trusted_update - reseal an existing key with new PCR values\n */\nstatic int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\n\tif (key_is_negative(key))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\t/* copy old key values, and reseal with new pcrs */\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}\n\n/*\n * trusted_read - copy the sealed blob data to userspace in hex.\n * On success, return to userspace the trusted key datablob size.\n */\nstatic long trusted_read(const struct key *key, char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tconst struct trusted_key_payload *p;\n\tchar *ascii_buf;\n\tchar *bufp;\n\tint i;\n\n\tp = dereference_key_locked(key);\n\tif (!p)\n\t\treturn -EINVAL;\n\tif (!buffer || buflen <= 0)\n\t\treturn 2 * p->blob_len;\n\tascii_buf = kmalloc(2 * p->blob_len, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\treturn -ENOMEM;\n\n\tbufp = ascii_buf;\n\tfor (i = 0; i < p->blob_len; i++)\n\t\tbufp = hex_byte_pack(bufp, p->blob[i]);\n\tif ((copy_to_user(buffer, ascii_buf, 2 * p->blob_len)) != 0) {\n\t\tkzfree(ascii_buf);\n\t\treturn -EFAULT;\n\t}\n\tkzfree(ascii_buf);\n\treturn 2 * p->blob_len;\n}\n\n/*\n * trusted_destroy - clear and free the key's payload\n */\nstatic void trusted_destroy(struct key *key)\n{\n\tkzfree(key->payload.data[0]);\n}\n\nstruct key_type key_type_trusted = {\n\t.name = \"trusted\",\n\t.instantiate = trusted_instantiate,\n\t.update = trusted_update,\n\t.destroy = trusted_destroy,\n\t.describe = user_describe,\n\t.read = trusted_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_trusted);\n\nstatic void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}\n\nstatic int __init trusted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}\n\nstatic int __init init_trusted(void)\n{\n\tint ret;\n\n\tret = trusted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = register_key_type(&key_type_trusted);\n\tif (ret < 0)\n\t\ttrusted_shash_release();\n\treturn ret;\n}\n\nstatic void __exit cleanup_trusted(void)\n{\n\ttrusted_shash_release();\n\tunregister_key_type(&key_type_trusted);\n}\n\nlate_initcall(init_trusted);\nmodule_exit(cleanup_trusted);\n\nMODULE_LICENSE(\"GPL\");\n", "/* user_defined.c: user defined key type\n *\n * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <keys/user-type.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n\nstatic int logon_vet_description(const char *desc);\n\n/*\n * user defined keys take an arbitrary string as the description and an\n * arbitrary blob of data as the payload\n */\nstruct key_type key_type_user = {\n\t.name\t\t\t= \"user\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.read\t\t\t= user_read,\n};\n\nEXPORT_SYMBOL_GPL(key_type_user);\n\n/*\n * This key type is essentially the same as key_type_user, but it does\n * not define a .read op. This is suitable for storing username and\n * password pairs in the keyring that you do not want to be readable\n * from userspace.\n */\nstruct key_type key_type_logon = {\n\t.name\t\t\t= \"logon\",\n\t.preparse\t\t= user_preparse,\n\t.free_preparse\t\t= user_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.update\t\t\t= user_update,\n\t.revoke\t\t\t= user_revoke,\n\t.destroy\t\t= user_destroy,\n\t.describe\t\t= user_describe,\n\t.vet_description\t= logon_vet_description,\n};\nEXPORT_SYMBOL_GPL(key_type_logon);\n\n/*\n * Preparse a user defined key payload\n */\nint user_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload;\n\tsize_t datalen = prep->datalen;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\treturn -ENOMEM;\n\n\t/* attach the data */\n\tprep->quotalen = datalen;\n\tprep->payload.data[0] = upayload;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(user_preparse);\n\n/*\n * Free a preparse of a user defined key payload\n */\nvoid user_free_preparse(struct key_preparsed_payload *prep)\n{\n\tkzfree(prep->payload.data[0]);\n}\nEXPORT_SYMBOL_GPL(user_free_preparse);\n\nstatic void user_free_payload_rcu(struct rcu_head *head)\n{\n\tstruct user_key_payload *payload;\n\n\tpayload = container_of(head, struct user_key_payload, rcu);\n\tkzfree(payload);\n}\n\n/*\n * update a user defined key\n * - the key's semaphore is write-locked\n */\nint user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\n\t/* check the quota and attach the new data */\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attach the new data, displacing the old */\n\tkey->expiry = prep->expiry;\n\tif (key_is_positive(key))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(user_update);\n\n/*\n * dispose of the links from a revoked keyring\n * - called with the key sem write-locked\n */\nvoid user_revoke(struct key *key)\n{\n\tstruct user_key_payload *upayload = user_key_payload_locked(key);\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\n\tif (upayload) {\n\t\trcu_assign_keypointer(key, NULL);\n\t\tcall_rcu(&upayload->rcu, user_free_payload_rcu);\n\t}\n}\n\nEXPORT_SYMBOL(user_revoke);\n\n/*\n * dispose of the data dangling from the corpse of a user key\n */\nvoid user_destroy(struct key *key)\n{\n\tstruct user_key_payload *upayload = key->payload.data[0];\n\n\tkzfree(upayload);\n}\n\nEXPORT_SYMBOL_GPL(user_destroy);\n\n/*\n * describe the user key\n */\nvoid user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}\n\nEXPORT_SYMBOL_GPL(user_describe);\n\n/*\n * read the key data\n * - the key's semaphore is read-locked\n */\nlong user_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tconst struct user_key_payload *upayload;\n\tlong ret;\n\n\tupayload = user_key_payload_locked(key);\n\tret = upayload->datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > upayload->datalen)\n\t\t\tbuflen = upayload->datalen;\n\n\t\tif (copy_to_user(buffer, upayload->data, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}\n\nEXPORT_SYMBOL_GPL(user_read);\n\n/* Vet the description for a \"logon\" key */\nstatic int logon_vet_description(const char *desc)\n{\n\tchar *p;\n\n\t/* require a \"qualified\" description string */\n\tp = strchr(desc, ':');\n\tif (!p)\n\t\treturn -EINVAL;\n\n\t/* also reject description with ':' as first char */\n\tif (p == desc)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n"], "filenames": ["include/linux/key.h", "net/dns_resolver/dns_key.c", "security/keys/big_key.c", "security/keys/encrypted-keys/encrypted.c", "security/keys/gc.c", "security/keys/key.c", "security/keys/keyctl.c", "security/keys/keyring.c", "security/keys/proc.c", "security/keys/process_keys.c", "security/keys/request_key.c", "security/keys/request_key_auth.c", "security/keys/trusted.c", "security/keys/user_defined.c"], "buggy_code_start_loc": [138, 227, 250, 857, 131, 404, 769, 417, 184, 733, 598, 76, 1069, 117], "buggy_code_end_loc": [367, 228, 283, 858, 155, 991, 905, 603, 250, 734, 602, 77, 1070, 166], "fixing_code_start_loc": [139, 227, 250, 857, 132, 405, 769, 417, 185, 733, 598, 76, 1069, 117], "fixing_code_end_loc": [380, 228, 283, 858, 155, 1000, 904, 603, 253, 734, 601, 77, 1070, 166], "type": "CWE-20", "message": "The KEYS subsystem in the Linux kernel before 4.13.10 does not correctly synchronize the actions of updating versus finding a key in the \"negative\" state to avoid a race condition, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls.", "other": {"cve": {"id": "CVE-2017-15951", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-28T02:29:00.217", "lastModified": "2023-01-19T15:45:25.270", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The KEYS subsystem in the Linux kernel before 4.13.10 does not correctly synchronize the actions of updating versus finding a key in the \"negative\" state to avoid a race condition, which allows local users to cause a denial of service or possibly have unspecified other impact via crafted system calls."}, {"lang": "es", "value": "El subsistema KEYS en el kernel de Linux en versiones anteriores a la 4.13.10 no sincroniza correctamente las acciones de actualizaci\u00f3n con las de detecci\u00f3n de una clave en el estado \"negative\" para evitar una condici\u00f3n de carrera, lo que permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (DoS) o, posiblemente, cause otro impacto no especificado mediante llamadas al sistema manipuladas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.4", "versionEndExcluding": "4.4.95", "matchCriteriaId": "4397FA2C-1EE8-4F42-9823-2D85B8C20976"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.59", "matchCriteriaId": "D6690C73-23A3-4475-97D0-8CB96812E2FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.13.10", "matchCriteriaId": "86038BA0-0886-479E-AD71-D78363937D66"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=363b02dab09b3226f3bd1420dad9c72b79a42a76", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.13.10", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/101621", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76"}}