{"buggy_code": ["# frozen_string_literal: true\n\nrequire_relative 'multipart_boundary'\n\nmodule HTTParty\n  class Request\n    class Body\n      NEWLINE = \"\\r\\n\"\n      private_constant :NEWLINE\n\n      def initialize(params, query_string_normalizer: nil, force_multipart: false)\n        @params = params\n        @query_string_normalizer = query_string_normalizer\n        @force_multipart = force_multipart\n      end\n\n      def call\n        if params.respond_to?(:to_hash)\n          multipart? ? generate_multipart : normalize_query(params)\n        else\n          params\n        end\n      end\n\n      def boundary\n        @boundary ||= MultipartBoundary.generate\n      end\n\n      def multipart?\n        params.respond_to?(:to_hash) && (force_multipart || has_file?(params))\n      end\n\n      private\n\n      def generate_multipart\n        normalized_params = params.flat_map { |key, value| HashConversions.normalize_keys(key, value) }\n\n        multipart = normalized_params.inject(''.dup) do |memo, (key, value)|\n          memo << \"--#{boundary}#{NEWLINE}\"\n          memo << %(Content-Disposition: form-data; name=\"#{key}\")\n          # value.path is used to support ActionDispatch::Http::UploadedFile\n          # https://github.com/jnunemaker/httparty/pull/585\n          memo << %(; filename=\"#{file_name(value)}\") if file?(value)\n          memo << NEWLINE\n          memo << \"Content-Type: #{content_type(value)}#{NEWLINE}\" if file?(value)\n          memo << NEWLINE\n          memo << content_body(value)\n          memo << NEWLINE\n        end\n\n        multipart << \"--#{boundary}--#{NEWLINE}\"\n      end\n\n      def has_file?(value)\n        if value.respond_to?(:to_hash)\n          value.to_hash.any? { |_, v| has_file?(v) }\n        elsif value.respond_to?(:to_ary)\n          value.to_ary.any? { |v| has_file?(v) }\n        else\n          file?(value)\n        end\n      end\n\n      def file?(object)\n        object.respond_to?(:path) && object.respond_to?(:read)\n      end\n\n      def normalize_query(query)\n        if query_string_normalizer\n          query_string_normalizer.call(query)\n        else\n          HashConversions.to_params(query)\n        end\n      end\n\n      def content_body(object)\n        if file?(object)\n          object = (file = object).read\n          file.rewind if file.respond_to?(:rewind)\n        end\n\n        object.to_s\n      end\n\n      def content_type(object)\n        return object.content_type if object.respond_to?(:content_type)\n        mime = MiniMime.lookup_by_filename(object.path)\n        mime ? mime.content_type : 'application/octet-stream'\n      end\n\n      def file_name(object)\n        object.respond_to?(:original_filename) ? object.original_filename : File.basename(object.path)\n      end\n\n      attr_reader :params, :query_string_normalizer, :force_multipart\n    end\n  end\nend\n", "require 'spec_helper'\nrequire 'tempfile'\n\nRSpec.describe HTTParty::Request::Body do\n  describe '#call' do\n    let(:options) { {} }\n\n    subject { described_class.new(params, **options).call }\n\n    context 'when params is string' do\n      let(:params) { 'name=Bob%20Jones' }\n\n      it { is_expected.to eq params }\n    end\n\n    context 'when params is hash' do\n      let(:params) { { people: [\"Bob Jones\", \"Mike Smith\"] } }\n      let(:converted_params) { \"people%5B%5D=Bob%20Jones&people%5B%5D=Mike%20Smith\"}\n\n      it { is_expected.to eq converted_params }\n\n      context 'when params has file' do\n        before do\n          allow(HTTParty::Request::MultipartBoundary)\n            .to receive(:generate).and_return(\"------------------------c772861a5109d5ef\")\n        end\n\n        let(:file) { File.open('spec/fixtures/tiny.gif') }\n        let(:params) do\n          {\n            user: {\n              avatar: file,\n              first_name: 'John',\n              last_name: 'Doe',\n              enabled: true\n            }\n          }\n        end\n        let(:expected_file_name) { 'tiny.gif' }\n        let(:expected_file_contents) { \"GIF89a\\u0001\\u0000\\u0001\\u0000\\u0000\\xFF\\u0000,\\u0000\\u0000\\u0000\\u0000\\u0001\\u0000\\u0001\\u0000\\u0000\\u0002\\u0000;\" }\n        let(:expected_content_type) { 'image/gif' }\n        let(:multipart_params) do\n          \"--------------------------c772861a5109d5ef\\r\\n\" \\\n          \"Content-Disposition: form-data; name=\\\"user[avatar]\\\"; filename=\\\"#{expected_file_name}\\\"\\r\\n\" \\\n          \"Content-Type: #{expected_content_type}\\r\\n\" \\\n          \"\\r\\n\" \\\n          \"#{expected_file_contents}\\r\\n\" \\\n          \"--------------------------c772861a5109d5ef\\r\\n\" \\\n          \"Content-Disposition: form-data; name=\\\"user[first_name]\\\"\\r\\n\" \\\n          \"\\r\\n\" \\\n          \"John\\r\\n\" \\\n          \"--------------------------c772861a5109d5ef\\r\\n\" \\\n          \"Content-Disposition: form-data; name=\\\"user[last_name]\\\"\\r\\n\" \\\n          \"\\r\\n\" \\\n          \"Doe\\r\\n\" \\\n          \"--------------------------c772861a5109d5ef\\r\\n\" \\\n          \"Content-Disposition: form-data; name=\\\"user[enabled]\\\"\\r\\n\" \\\n          \"\\r\\n\" \\\n          \"true\\r\\n\" \\\n          \"--------------------------c772861a5109d5ef--\\r\\n\"\n        end\n\n        it { is_expected.to eq multipart_params }\n\n        it { expect { subject }.not_to change { file.pos } }\n\n        context 'when passing multipart as an option' do\n          let(:options) { { force_multipart: true } }\n          let(:params) do\n            {\n              user: {\n                first_name: 'John',\n                last_name: 'Doe',\n                enabled: true\n              }\n            }\n          end\n          let(:multipart_params) do\n            \"--------------------------c772861a5109d5ef\\r\\n\" \\\n            \"Content-Disposition: form-data; name=\\\"user[first_name]\\\"\\r\\n\" \\\n            \"\\r\\n\" \\\n            \"John\\r\\n\" \\\n            \"--------------------------c772861a5109d5ef\\r\\n\" \\\n            \"Content-Disposition: form-data; name=\\\"user[last_name]\\\"\\r\\n\" \\\n            \"\\r\\n\" \\\n            \"Doe\\r\\n\" \\\n            \"--------------------------c772861a5109d5ef\\r\\n\" \\\n            \"Content-Disposition: form-data; name=\\\"user[enabled]\\\"\\r\\n\" \\\n            \"\\r\\n\" \\\n            \"true\\r\\n\" \\\n            \"--------------------------c772861a5109d5ef--\\r\\n\"\n          end\n\n          it { is_expected.to eq multipart_params }\n\n        end\n\n        context 'file object responds to original_filename' do\n          let(:some_temp_file) { Tempfile.new(['some_temp_file','.gif']) }\n          let(:expected_file_name) { \"some_temp_file.gif\" }\n          let(:expected_file_contents) { \"Hello\" }\n          let(:file) { double(:mocked_action_dispatch, path: some_temp_file.path, original_filename: 'some_temp_file.gif', read: expected_file_contents) }\n\n          before { some_temp_file.write('Hello') }\n\n          it { is_expected.to eq multipart_params }\n        end\n      end\n    end\n  end\n\n  describe '#multipart?' do\n    let(:force_multipart) { false }\n    let(:file) { File.open('spec/fixtures/tiny.gif') }\n\n    subject { described_class.new(params, force_multipart: force_multipart).multipart? }\n\n    context 'when params does not respond to to_hash' do\n      let(:params) { 'name=Bob%20Jones' }\n\n      it { is_expected.to be false }\n    end\n\n    context 'when params responds to to_hash' do\n      class HashLike\n        def initialize(hash)\n          @hash = hash\n        end\n\n        def to_hash\n          @hash\n        end\n      end\n\n      class ArrayLike\n        def initialize(ary)\n          @ary = ary\n        end\n\n        def to_ary\n          @ary\n        end\n      end\n\n      context 'when force_multipart is true' do\n        let(:params) { { name: 'Bob Jones' } }\n        let(:force_multipart) { true }\n\n        it { is_expected.to be true }\n      end\n\n      context 'when it does not contain a file' do\n        let(:hash_like_param) { HashLike.new(first: 'Bob', last: ArrayLike.new(['Jones'])) }\n        let(:params) { { name: ArrayLike.new([hash_like_param]) } }\n\n        it { is_expected.to eq false }\n      end\n\n      context 'when it contains file' do\n        let(:hash_like_param) { HashLike.new(first: 'Bob', last: 'Jones', file: ArrayLike.new([file])) }\n        let(:params) { { name: ArrayLike.new([hash_like_param]) } }\n\n        it { is_expected.to be true }\n      end\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nrequire_relative 'multipart_boundary'\n\nmodule HTTParty\n  class Request\n    class Body\n      NEWLINE = \"\\r\\n\"\n      private_constant :NEWLINE\n\n      def initialize(params, query_string_normalizer: nil, force_multipart: false)\n        @params = params\n        @query_string_normalizer = query_string_normalizer\n        @force_multipart = force_multipart\n      end\n\n      def call\n        if params.respond_to?(:to_hash)\n          multipart? ? generate_multipart : normalize_query(params)\n        else\n          params\n        end\n      end\n\n      def boundary\n        @boundary ||= MultipartBoundary.generate\n      end\n\n      def multipart?\n        params.respond_to?(:to_hash) && (force_multipart || has_file?(params))\n      end\n\n      private\n\n      # https://html.spec.whatwg.org/#multipart-form-data\n      MULTIPART_FORM_DATA_REPLACEMENT_TABLE = {\n        '\"'  => '%22',\n        \"\\r\" => '%0D',\n        \"\\n\" => '%0A'\n      }.freeze\n\n      def generate_multipart\n        normalized_params = params.flat_map { |key, value| HashConversions.normalize_keys(key, value) }\n\n        multipart = normalized_params.inject(''.dup) do |memo, (key, value)|\n          memo << \"--#{boundary}#{NEWLINE}\"\n          memo << %(Content-Disposition: form-data; name=\"#{key}\")\n          # value.path is used to support ActionDispatch::Http::UploadedFile\n          # https://github.com/jnunemaker/httparty/pull/585\n          memo << %(; filename=\"#{file_name(value).gsub(/[\"\\r\\n]/, MULTIPART_FORM_DATA_REPLACEMENT_TABLE)}\") if file?(value)\n          memo << NEWLINE\n          memo << \"Content-Type: #{content_type(value)}#{NEWLINE}\" if file?(value)\n          memo << NEWLINE\n          memo << content_body(value)\n          memo << NEWLINE\n        end\n\n        multipart << \"--#{boundary}--#{NEWLINE}\"\n      end\n\n      def has_file?(value)\n        if value.respond_to?(:to_hash)\n          value.to_hash.any? { |_, v| has_file?(v) }\n        elsif value.respond_to?(:to_ary)\n          value.to_ary.any? { |v| has_file?(v) }\n        else\n          file?(value)\n        end\n      end\n\n      def file?(object)\n        object.respond_to?(:path) && object.respond_to?(:read)\n      end\n\n      def normalize_query(query)\n        if query_string_normalizer\n          query_string_normalizer.call(query)\n        else\n          HashConversions.to_params(query)\n        end\n      end\n\n      def content_body(object)\n        if file?(object)\n          object = (file = object).read\n          file.rewind if file.respond_to?(:rewind)\n        end\n\n        object.to_s\n      end\n\n      def content_type(object)\n        return object.content_type if object.respond_to?(:content_type)\n        mime = MiniMime.lookup_by_filename(object.path)\n        mime ? mime.content_type : 'application/octet-stream'\n      end\n\n      def file_name(object)\n        object.respond_to?(:original_filename) ? object.original_filename : File.basename(object.path)\n      end\n\n      attr_reader :params, :query_string_normalizer, :force_multipart\n    end\n  end\nend\n", "require 'spec_helper'\nrequire 'tempfile'\n\nRSpec.describe HTTParty::Request::Body do\n  describe '#call' do\n    let(:options) { {} }\n\n    subject { described_class.new(params, **options).call }\n\n    context 'when params is string' do\n      let(:params) { 'name=Bob%20Jones' }\n\n      it { is_expected.to eq params }\n    end\n\n    context 'when params is hash' do\n      let(:params) { { people: [\"Bob Jones\", \"Mike Smith\"] } }\n      let(:converted_params) { \"people%5B%5D=Bob%20Jones&people%5B%5D=Mike%20Smith\"}\n\n      it { is_expected.to eq converted_params }\n\n      context 'when params has file' do\n        before do\n          allow(HTTParty::Request::MultipartBoundary)\n            .to receive(:generate).and_return(\"------------------------c772861a5109d5ef\")\n        end\n\n        let(:file) { File.open('spec/fixtures/tiny.gif') }\n        let(:params) do\n          {\n            user: {\n              avatar: file,\n              first_name: 'John',\n              last_name: 'Doe',\n              enabled: true\n            }\n          }\n        end\n        let(:expected_file_name) { 'tiny.gif' }\n        let(:expected_file_contents) { \"GIF89a\\u0001\\u0000\\u0001\\u0000\\u0000\\xFF\\u0000,\\u0000\\u0000\\u0000\\u0000\\u0001\\u0000\\u0001\\u0000\\u0000\\u0002\\u0000;\" }\n        let(:expected_content_type) { 'image/gif' }\n        let(:multipart_params) do\n          \"--------------------------c772861a5109d5ef\\r\\n\" \\\n          \"Content-Disposition: form-data; name=\\\"user[avatar]\\\"; filename=\\\"#{expected_file_name}\\\"\\r\\n\" \\\n          \"Content-Type: #{expected_content_type}\\r\\n\" \\\n          \"\\r\\n\" \\\n          \"#{expected_file_contents}\\r\\n\" \\\n          \"--------------------------c772861a5109d5ef\\r\\n\" \\\n          \"Content-Disposition: form-data; name=\\\"user[first_name]\\\"\\r\\n\" \\\n          \"\\r\\n\" \\\n          \"John\\r\\n\" \\\n          \"--------------------------c772861a5109d5ef\\r\\n\" \\\n          \"Content-Disposition: form-data; name=\\\"user[last_name]\\\"\\r\\n\" \\\n          \"\\r\\n\" \\\n          \"Doe\\r\\n\" \\\n          \"--------------------------c772861a5109d5ef\\r\\n\" \\\n          \"Content-Disposition: form-data; name=\\\"user[enabled]\\\"\\r\\n\" \\\n          \"\\r\\n\" \\\n          \"true\\r\\n\" \\\n          \"--------------------------c772861a5109d5ef--\\r\\n\"\n        end\n\n        it { is_expected.to eq multipart_params }\n\n        it { expect { subject }.not_to change { file.pos } }\n\n        context 'when passing multipart as an option' do\n          let(:options) { { force_multipart: true } }\n          let(:params) do\n            {\n              user: {\n                first_name: 'John',\n                last_name: 'Doe',\n                enabled: true\n              }\n            }\n          end\n          let(:multipart_params) do\n            \"--------------------------c772861a5109d5ef\\r\\n\" \\\n            \"Content-Disposition: form-data; name=\\\"user[first_name]\\\"\\r\\n\" \\\n            \"\\r\\n\" \\\n            \"John\\r\\n\" \\\n            \"--------------------------c772861a5109d5ef\\r\\n\" \\\n            \"Content-Disposition: form-data; name=\\\"user[last_name]\\\"\\r\\n\" \\\n            \"\\r\\n\" \\\n            \"Doe\\r\\n\" \\\n            \"--------------------------c772861a5109d5ef\\r\\n\" \\\n            \"Content-Disposition: form-data; name=\\\"user[enabled]\\\"\\r\\n\" \\\n            \"\\r\\n\" \\\n            \"true\\r\\n\" \\\n            \"--------------------------c772861a5109d5ef--\\r\\n\"\n          end\n\n          it { is_expected.to eq multipart_params }\n\n        end\n\n        context 'file object responds to original_filename' do\n          let(:some_temp_file) { Tempfile.new(['some_temp_file','.gif']) }\n          let(:expected_file_name) { \"some_temp_file.gif\" }\n          let(:expected_file_contents) { \"Hello\" }\n          let(:file) { double(:mocked_action_dispatch, path: some_temp_file.path, original_filename: 'some_temp_file.gif', read: expected_file_contents) }\n\n          before { some_temp_file.write('Hello') }\n\n          it { is_expected.to eq multipart_params }\n        end\n\n        context 'when file name contains [ \" \\r \\n ]' do\n          let(:options) { { force_multipart: true } }\n          let(:some_temp_file) { Tempfile.new(['basefile', '.txt']) }\n          let(:file_content) { 'test' }\n          let(:raw_filename) { \"dummy=tampering.sh\\\"; \\r\\ndummy=a.txt\" }\n          let(:expected_file_name) { 'dummy=tampering.sh%22; %0D%0Adummy=a.txt' }\n          let(:file) { double(:mocked_action_dispatch, path: some_temp_file.path, original_filename: raw_filename, read: file_content) }\n          let(:params) do\n            {\n              user: {\n                attachment_file: file,\n                enabled: true\n              }\n            }\n          end\n          let(:multipart_params) do\n            \"--------------------------c772861a5109d5ef\\r\\n\" \\\n            \"Content-Disposition: form-data; name=\\\"user[attachment_file]\\\"; filename=\\\"#{expected_file_name}\\\"\\r\\n\" \\\n            \"Content-Type: text/plain\\r\\n\" \\\n            \"\\r\\n\" \\\n            \"test\\r\\n\" \\\n            \"--------------------------c772861a5109d5ef\\r\\n\" \\\n            \"Content-Disposition: form-data; name=\\\"user[enabled]\\\"\\r\\n\" \\\n            \"\\r\\n\" \\\n            \"true\\r\\n\" \\\n            \"--------------------------c772861a5109d5ef--\\r\\n\"\n          end\n\n          it { is_expected.to eq multipart_params }\n\n        end\n      end\n    end\n  end\n\n  describe '#multipart?' do\n    let(:force_multipart) { false }\n    let(:file) { File.open('spec/fixtures/tiny.gif') }\n\n    subject { described_class.new(params, force_multipart: force_multipart).multipart? }\n\n    context 'when params does not respond to to_hash' do\n      let(:params) { 'name=Bob%20Jones' }\n\n      it { is_expected.to be false }\n    end\n\n    context 'when params responds to to_hash' do\n      class HashLike\n        def initialize(hash)\n          @hash = hash\n        end\n\n        def to_hash\n          @hash\n        end\n      end\n\n      class ArrayLike\n        def initialize(ary)\n          @ary = ary\n        end\n\n        def to_ary\n          @ary\n        end\n      end\n\n      context 'when force_multipart is true' do\n        let(:params) { { name: 'Bob Jones' } }\n        let(:force_multipart) { true }\n\n        it { is_expected.to be true }\n      end\n\n      context 'when it does not contain a file' do\n        let(:hash_like_param) { HashLike.new(first: 'Bob', last: ArrayLike.new(['Jones'])) }\n        let(:params) { { name: ArrayLike.new([hash_like_param]) } }\n\n        it { is_expected.to eq false }\n      end\n\n      context 'when it contains file' do\n        let(:hash_like_param) { HashLike.new(first: 'Bob', last: 'Jones', file: ArrayLike.new([file])) }\n        let(:params) { { name: ArrayLike.new([hash_like_param]) } }\n\n        it { is_expected.to be true }\n      end\n    end\n  end\nend\n"], "filenames": ["lib/httparty/request/body.rb", "spec/httparty/request/body_spec.rb"], "buggy_code_start_loc": [34, 107], "buggy_code_end_loc": [44, 107], "fixing_code_start_loc": [35, 108], "fixing_code_end_loc": [51, 140], "type": "CWE-668", "message": "httparty before 0.21.0 is vulnerable to an assumed-immutable web parameter vulnerability. A remote and unauthenticated attacker can provide a crafted filename parameter during multipart/form-data uploads which could result in attacker controlled filenames being written.\n\n", "other": {"cve": {"id": "CVE-2024-22049", "sourceIdentifier": "disclosure@vulncheck.com", "published": "2024-01-04T21:15:10.013", "lastModified": "2024-01-23T19:15:08.283", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "httparty before 0.21.0 is vulnerable to an assumed-immutable web parameter vulnerability. A remote and unauthenticated attacker can provide a crafted filename parameter during multipart/form-data uploads which could result in attacker controlled filenames being written.\n\n"}, {"lang": "es", "value": "httparty anterior a 0.21.0 es afectado por una vulnerabilidad de par\u00e1metro web supuestamente inmutable. Un atacante remoto y no autenticado puede proporcionar un par\u00e1metro de filename manipulado durante las cargas de datos de multipart/form-data, lo que podr\u00eda dar lugar a que se escriban nombres de archivos controlados por el atacante."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "disclosure@vulncheck.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-472"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:john_nunemaker:httparty:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.21.0", "matchCriteriaId": "7AB0E617-C4C9-43D8-BC21-30529152AD78"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-5pq7-52mg-hr42", "source": "disclosure@vulncheck.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/jnunemaker/httparty/blob/4416141d37fd71bdba4f37589ec265f55aa446ce/lib/httparty/request/body.rb#L43", "source": "disclosure@vulncheck.com", "tags": ["Exploit"]}, {"url": "https://github.com/jnunemaker/httparty/commit/cdb45a678c43e44570b4e73f84b1abeb5ec22b8e", "source": "disclosure@vulncheck.com", "tags": ["Patch"]}, {"url": "https://github.com/jnunemaker/httparty/security/advisories/GHSA-5pq7-52mg-hr42", "source": "disclosure@vulncheck.com", "tags": ["Exploit", "Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/01/msg00011.html", "source": "disclosure@vulncheck.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4LDGAVPR4KB72V4GGQCWODEAI72QZI3V/", "source": "disclosure@vulncheck.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IOWECZPJY6JZIA5FSBJR77KCRDXWDZDA/", "source": "disclosure@vulncheck.com"}, {"url": "https://vulncheck.com/advisories/vc-advisory-GHSA-5pq7-52mg-hr42", "source": "disclosure@vulncheck.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jnunemaker/httparty/commit/cdb45a678c43e44570b4e73f84b1abeb5ec22b8e"}}