{"buggy_code": ["/*\n * Functions related to io context handling\n */\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/bootmem.h>\t/* for max_pfn/max_low_pfn */\n\n#include \"blk.h\"\n\n/*\n * For io context allocations\n */\nstatic struct kmem_cache *iocontext_cachep;\n\nstatic void cfq_dtor(struct io_context *ioc)\n{\n\tif (!hlist_empty(&ioc->cic_list)) {\n\t\tstruct cfq_io_context *cic;\n\n\t\tcic = list_entry(ioc->cic_list.first, struct cfq_io_context,\n\t\t\t\t\t\t\t\tcic_list);\n\t\tcic->dtor(ioc);\n\t}\n}\n\n/*\n * IO Context helper functions. put_io_context() returns 1 if there are no\n * more users of this io context, 0 otherwise.\n */\nint put_io_context(struct io_context *ioc)\n{\n\tif (ioc == NULL)\n\t\treturn 1;\n\n\tBUG_ON(atomic_long_read(&ioc->refcount) == 0);\n\n\tif (atomic_long_dec_and_test(&ioc->refcount)) {\n\t\trcu_read_lock();\n\t\tif (ioc->aic && ioc->aic->dtor)\n\t\t\tioc->aic->dtor(ioc->aic);\n\t\tcfq_dtor(ioc);\n\t\trcu_read_unlock();\n\n\t\tkmem_cache_free(iocontext_cachep, ioc);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(put_io_context);\n\nstatic void cfq_exit(struct io_context *ioc)\n{\n\trcu_read_lock();\n\n\tif (!hlist_empty(&ioc->cic_list)) {\n\t\tstruct cfq_io_context *cic;\n\n\t\tcic = list_entry(ioc->cic_list.first, struct cfq_io_context,\n\t\t\t\t\t\t\t\tcic_list);\n\t\tcic->exit(ioc);\n\t}\n\trcu_read_unlock();\n}\n\n/* Called by the exitting task */\nvoid exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\n\t\tput_io_context(ioc);\n\t}\n}\n\nstruct io_context *alloc_io_context(gfp_t gfp_flags, int node)\n{\n\tstruct io_context *ret;\n\n\tret = kmem_cache_alloc_node(iocontext_cachep, gfp_flags, node);\n\tif (ret) {\n\t\tatomic_long_set(&ret->refcount, 1);\n\t\tatomic_set(&ret->nr_tasks, 1);\n\t\tspin_lock_init(&ret->lock);\n\t\tret->ioprio_changed = 0;\n\t\tret->ioprio = 0;\n\t\tret->last_waited = jiffies; /* doesn't matter... */\n\t\tret->nr_batch_requests = 0; /* because this is 0 */\n\t\tret->aic = NULL;\n\t\tINIT_RADIX_TREE(&ret->radix_root, GFP_ATOMIC | __GFP_HIGH);\n\t\tINIT_HLIST_HEAD(&ret->cic_list);\n\t\tret->ioc_data = NULL;\n\t}\n\n\treturn ret;\n}\n\n/*\n * If the current task has no IO context then create one and initialise it.\n * Otherwise, return its existing IO context.\n *\n * This returned IO context doesn't have a specifically elevated refcount,\n * but since the current task itself holds a reference, the context can be\n * used in general code, so long as it stays within `current` context.\n */\nstruct io_context *current_io_context(gfp_t gfp_flags, int node)\n{\n\tstruct task_struct *tsk = current;\n\tstruct io_context *ret;\n\n\tret = tsk->io_context;\n\tif (likely(ret))\n\t\treturn ret;\n\n\tret = alloc_io_context(gfp_flags, node);\n\tif (ret) {\n\t\t/* make sure set_task_ioprio() sees the settings above */\n\t\tsmp_wmb();\n\t\ttsk->io_context = ret;\n\t}\n\n\treturn ret;\n}\n\n/*\n * If the current task has no IO context then create one and initialise it.\n * If it does have a context, take a ref on it.\n *\n * This is always called in the context of the task which submitted the I/O.\n */\nstruct io_context *get_io_context(gfp_t gfp_flags, int node)\n{\n\tstruct io_context *ret = NULL;\n\n\t/*\n\t * Check for unlikely race with exiting task. ioc ref count is\n\t * zero when ioc is being detached.\n\t */\n\tdo {\n\t\tret = current_io_context(gfp_flags, node);\n\t\tif (unlikely(!ret))\n\t\t\tbreak;\n\t} while (!atomic_long_inc_not_zero(&ret->refcount));\n\n\treturn ret;\n}\nEXPORT_SYMBOL(get_io_context);\n\nvoid copy_io_context(struct io_context **pdst, struct io_context **psrc)\n{\n\tstruct io_context *src = *psrc;\n\tstruct io_context *dst = *pdst;\n\n\tif (src) {\n\t\tBUG_ON(atomic_long_read(&src->refcount) == 0);\n\t\tatomic_long_inc(&src->refcount);\n\t\tput_io_context(dst);\n\t\t*pdst = src;\n\t}\n}\nEXPORT_SYMBOL(copy_io_context);\n\nstatic int __init blk_ioc_init(void)\n{\n\tiocontext_cachep = kmem_cache_create(\"blkdev_ioc\",\n\t\t\tsizeof(struct io_context), 0, SLAB_PANIC, NULL);\n\treturn 0;\n}\nsubsys_initcall(blk_ioc_init);\n"], "fixing_code": ["/*\n * Functions related to io context handling\n */\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/bio.h>\n#include <linux/blkdev.h>\n#include <linux/bootmem.h>\t/* for max_pfn/max_low_pfn */\n\n#include \"blk.h\"\n\n/*\n * For io context allocations\n */\nstatic struct kmem_cache *iocontext_cachep;\n\nstatic void cfq_dtor(struct io_context *ioc)\n{\n\tif (!hlist_empty(&ioc->cic_list)) {\n\t\tstruct cfq_io_context *cic;\n\n\t\tcic = list_entry(ioc->cic_list.first, struct cfq_io_context,\n\t\t\t\t\t\t\t\tcic_list);\n\t\tcic->dtor(ioc);\n\t}\n}\n\n/*\n * IO Context helper functions. put_io_context() returns 1 if there are no\n * more users of this io context, 0 otherwise.\n */\nint put_io_context(struct io_context *ioc)\n{\n\tif (ioc == NULL)\n\t\treturn 1;\n\n\tBUG_ON(atomic_long_read(&ioc->refcount) == 0);\n\n\tif (atomic_long_dec_and_test(&ioc->refcount)) {\n\t\trcu_read_lock();\n\t\tif (ioc->aic && ioc->aic->dtor)\n\t\t\tioc->aic->dtor(ioc->aic);\n\t\tcfq_dtor(ioc);\n\t\trcu_read_unlock();\n\n\t\tkmem_cache_free(iocontext_cachep, ioc);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(put_io_context);\n\nstatic void cfq_exit(struct io_context *ioc)\n{\n\trcu_read_lock();\n\n\tif (!hlist_empty(&ioc->cic_list)) {\n\t\tstruct cfq_io_context *cic;\n\n\t\tcic = list_entry(ioc->cic_list.first, struct cfq_io_context,\n\t\t\t\t\t\t\t\tcic_list);\n\t\tcic->exit(ioc);\n\t}\n\trcu_read_unlock();\n}\n\n/* Called by the exitting task */\nvoid exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\n\t}\n\tput_io_context(ioc);\n}\n\nstruct io_context *alloc_io_context(gfp_t gfp_flags, int node)\n{\n\tstruct io_context *ret;\n\n\tret = kmem_cache_alloc_node(iocontext_cachep, gfp_flags, node);\n\tif (ret) {\n\t\tatomic_long_set(&ret->refcount, 1);\n\t\tatomic_set(&ret->nr_tasks, 1);\n\t\tspin_lock_init(&ret->lock);\n\t\tret->ioprio_changed = 0;\n\t\tret->ioprio = 0;\n\t\tret->last_waited = jiffies; /* doesn't matter... */\n\t\tret->nr_batch_requests = 0; /* because this is 0 */\n\t\tret->aic = NULL;\n\t\tINIT_RADIX_TREE(&ret->radix_root, GFP_ATOMIC | __GFP_HIGH);\n\t\tINIT_HLIST_HEAD(&ret->cic_list);\n\t\tret->ioc_data = NULL;\n\t}\n\n\treturn ret;\n}\n\n/*\n * If the current task has no IO context then create one and initialise it.\n * Otherwise, return its existing IO context.\n *\n * This returned IO context doesn't have a specifically elevated refcount,\n * but since the current task itself holds a reference, the context can be\n * used in general code, so long as it stays within `current` context.\n */\nstruct io_context *current_io_context(gfp_t gfp_flags, int node)\n{\n\tstruct task_struct *tsk = current;\n\tstruct io_context *ret;\n\n\tret = tsk->io_context;\n\tif (likely(ret))\n\t\treturn ret;\n\n\tret = alloc_io_context(gfp_flags, node);\n\tif (ret) {\n\t\t/* make sure set_task_ioprio() sees the settings above */\n\t\tsmp_wmb();\n\t\ttsk->io_context = ret;\n\t}\n\n\treturn ret;\n}\n\n/*\n * If the current task has no IO context then create one and initialise it.\n * If it does have a context, take a ref on it.\n *\n * This is always called in the context of the task which submitted the I/O.\n */\nstruct io_context *get_io_context(gfp_t gfp_flags, int node)\n{\n\tstruct io_context *ret = NULL;\n\n\t/*\n\t * Check for unlikely race with exiting task. ioc ref count is\n\t * zero when ioc is being detached.\n\t */\n\tdo {\n\t\tret = current_io_context(gfp_flags, node);\n\t\tif (unlikely(!ret))\n\t\t\tbreak;\n\t} while (!atomic_long_inc_not_zero(&ret->refcount));\n\n\treturn ret;\n}\nEXPORT_SYMBOL(get_io_context);\n\nvoid copy_io_context(struct io_context **pdst, struct io_context **psrc)\n{\n\tstruct io_context *src = *psrc;\n\tstruct io_context *dst = *pdst;\n\n\tif (src) {\n\t\tBUG_ON(atomic_long_read(&src->refcount) == 0);\n\t\tatomic_long_inc(&src->refcount);\n\t\tput_io_context(dst);\n\t\t*pdst = src;\n\t}\n}\nEXPORT_SYMBOL(copy_io_context);\n\nstatic int __init blk_ioc_init(void)\n{\n\tiocontext_cachep = kmem_cache_create(\"blkdev_ioc\",\n\t\t\tsizeof(struct io_context), 0, SLAB_PANIC, NULL);\n\treturn 0;\n}\nsubsys_initcall(blk_ioc_init);\n"], "filenames": ["block/blk-ioc.c"], "buggy_code_start_loc": [83], "buggy_code_end_loc": [84], "fixing_code_start_loc": [82], "fixing_code_end_loc": [85], "type": "CWE-400", "message": "The I/O implementation for block devices in the Linux kernel before 2.6.33 does not properly handle the CLONE_IO feature, which allows local users to cause a denial of service (I/O instability) by starting multiple processes that share an I/O context.", "other": {"cve": {"id": "CVE-2012-0879", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-17T11:00:36.850", "lastModified": "2023-02-13T00:23:05.023", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The I/O implementation for block devices in the Linux kernel before 2.6.33 does not properly handle the CLONE_IO feature, which allows local users to cause a denial of service (I/O instability) by starting multiple processes that share an I/O context."}, {"lang": "es", "value": "La implementaci\u00f3n I/O para dispositivos de bloque en el n\u00facleo de Linux anteriores a v2.6.33 no maneja adecuadamente la caracter\u00edstica CLONE_IO, lo cual permite a usuarios locales causar una denegaci\u00f3n de servicio (inestabilidad I/O) arrancando m\u00faltiples procesos que comparten un contexto I/O."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.33", "matchCriteriaId": "A01490AB-675E-4BA1-916D-F2A0D6CB27FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:-:*:*:*", "matchCriteriaId": "01EDA41C-6B2E-49AF-B503-EB3882265C11"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "036E8A89-7A16-411F-9D31-676313BB7244"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp1:*:*:*:*:*:*", "matchCriteriaId": "60FBDD82-691C-4D9D-B71B-F9AFF6931B53"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:11:sp2:*:*:*:*:*:*", "matchCriteriaId": "00720D8C-3FF3-4B1C-B74B-91F01A544399"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_high_availability_extension:11:sp1:*:*:*:*:*:*", "matchCriteriaId": "EB74DEB4-2BD1-4A65-AFDA-C331BC20C178"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp1:*:*:*:*:*:*", "matchCriteriaId": "EE26596F-F10E-44EF-88CA-0080646E91B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp1:*:*:*:vmware:*:*", "matchCriteriaId": "A6B7CDCA-6F39-4113-B5D3-3AA9D7F3D809"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:11:sp2:*:*:*:*:*:*", "matchCriteriaId": "F084E6C1-8DB0-4D1F-B8EB-5D2CD9AD6E87"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=61cc74fbb87af6aa551a06a370590c9bc07e29d9", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=b69f2292063d2caf37ca9aec7d63ded203701bf3", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2012-05/msg00013.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://marc.info/?l=bugtraq&m=139447903326211&w=2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-0481.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2012-0531.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2012/dsa-2469", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/02/23/5", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securitytracker.com/id?1027086", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-1408-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-1410-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-1411-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=796829", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/61cc74fbb87af6aa551a06a370590c9bc07e29d9", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/b69f2292063d2caf37ca9aec7d63ded203701bf3", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/61cc74fbb87af6aa551a06a370590c9bc07e29d9"}}