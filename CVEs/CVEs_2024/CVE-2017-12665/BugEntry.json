{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        PPPP   IIIII   CCCC  TTTTT                           %\n%                        P   P    I    C        T                             %\n%                        PPPP     I    C        T                             %\n%                        P        I    C        T                             %\n%                        P      IIIII   CCCC    T                             %\n%                                                                             %\n%                                                                             %\n%               Read/Write Apple Macintosh QuickDraw/PICT Format              %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  ImageMagick Macintosh PICT Methods.\n*/\n#define ReadPixmap(pixmap) \\\n{ \\\n  pixmap.version=(short) ReadBlobMSBShort(image); \\\n  pixmap.pack_type=(short) ReadBlobMSBShort(image); \\\n  pixmap.pack_size=ReadBlobMSBLong(image); \\\n  pixmap.horizontal_resolution=1UL*ReadBlobMSBShort(image); \\\n  (void) ReadBlobMSBShort(image); \\\n  pixmap.vertical_resolution=1UL*ReadBlobMSBShort(image); \\\n  (void) ReadBlobMSBShort(image); \\\n  pixmap.pixel_type=(short) ReadBlobMSBShort(image); \\\n  pixmap.bits_per_pixel=(short) ReadBlobMSBShort(image); \\\n  pixmap.component_count=(short) ReadBlobMSBShort(image); \\\n  pixmap.component_size=(short) ReadBlobMSBShort(image); \\\n  pixmap.plane_bytes=ReadBlobMSBLong(image); \\\n  pixmap.table=ReadBlobMSBLong(image); \\\n  pixmap.reserved=ReadBlobMSBLong(image); \\\n  if ((EOFBlob(image) != MagickFalse) || (pixmap.bits_per_pixel <= 0) || \\\n      (pixmap.bits_per_pixel > 32) || (pixmap.component_count <= 0) || \\\n      (pixmap.component_count > 4) || (pixmap.component_size <= 0)) \\\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); \\\n}\n\ntypedef struct _PICTCode\n{\n  const char\n    *name;\n\n  ssize_t\n    length;\n\n  const char\n    *description;\n} PICTCode;\n\ntypedef struct _PICTPixmap\n{\n  short\n    version,\n    pack_type;\n\n  size_t\n    pack_size,\n    horizontal_resolution,\n    vertical_resolution;\n\n  short\n    pixel_type,\n    bits_per_pixel,\n    component_count,\n    component_size;\n\n  size_t\n    plane_bytes,\n    table,\n    reserved;\n} PICTPixmap;\n\ntypedef struct _PICTRectangle\n{\n  short\n    top,\n    left,\n    bottom,\n    right;\n} PICTRectangle;\n\nstatic const PICTCode\n  codes[] =\n  {\n    /* 0x00 */ { \"NOP\", 0, \"nop\" },\n    /* 0x01 */ { \"Clip\", 0, \"clip\" },\n    /* 0x02 */ { \"BkPat\", 8, \"background pattern\" },\n    /* 0x03 */ { \"TxFont\", 2, \"text font (word)\" },\n    /* 0x04 */ { \"TxFace\", 1, \"text face (byte)\" },\n    /* 0x05 */ { \"TxMode\", 2, \"text mode (word)\" },\n    /* 0x06 */ { \"SpExtra\", 4, \"space extra (fixed point)\" },\n    /* 0x07 */ { \"PnSize\", 4, \"pen size (point)\" },\n    /* 0x08 */ { \"PnMode\", 2, \"pen mode (word)\" },\n    /* 0x09 */ { \"PnPat\", 8, \"pen pattern\" },\n    /* 0x0a */ { \"FillPat\", 8, \"fill pattern\" },\n    /* 0x0b */ { \"OvSize\", 4, \"oval size (point)\" },\n    /* 0x0c */ { \"Origin\", 4, \"dh, dv (word)\" },\n    /* 0x0d */ { \"TxSize\", 2, \"text size (word)\" },\n    /* 0x0e */ { \"FgColor\", 4, \"foreground color (ssize_tword)\" },\n    /* 0x0f */ { \"BkColor\", 4, \"background color (ssize_tword)\" },\n    /* 0x10 */ { \"TxRatio\", 8, \"numerator (point), denominator (point)\" },\n    /* 0x11 */ { \"Version\", 1, \"version (byte)\" },\n    /* 0x12 */ { \"BkPixPat\", 0, \"color background pattern\" },\n    /* 0x13 */ { \"PnPixPat\", 0, \"color pen pattern\" },\n    /* 0x14 */ { \"FillPixPat\", 0, \"color fill pattern\" },\n    /* 0x15 */ { \"PnLocHFrac\", 2, \"fractional pen position\" },\n    /* 0x16 */ { \"ChExtra\", 2, \"extra for each character\" },\n    /* 0x17 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x18 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x19 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x1a */ { \"RGBFgCol\", 6, \"RGB foreColor\" },\n    /* 0x1b */ { \"RGBBkCol\", 6, \"RGB backColor\" },\n    /* 0x1c */ { \"HiliteMode\", 0, \"hilite mode flag\" },\n    /* 0x1d */ { \"HiliteColor\", 6, \"RGB hilite color\" },\n    /* 0x1e */ { \"DefHilite\", 0, \"Use default hilite color\" },\n    /* 0x1f */ { \"OpColor\", 6, \"RGB OpColor for arithmetic modes\" },\n    /* 0x20 */ { \"Line\", 8, \"pnLoc (point), newPt (point)\" },\n    /* 0x21 */ { \"LineFrom\", 4, \"newPt (point)\" },\n    /* 0x22 */ { \"ShortLine\", 6, \"pnLoc (point, dh, dv (-128 .. 127))\" },\n    /* 0x23 */ { \"ShortLineFrom\", 2, \"dh, dv (-128 .. 127)\" },\n    /* 0x24 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x25 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x26 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x27 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x28 */ { \"LongText\", 0, \"txLoc (point), count (0..255), text\" },\n    /* 0x29 */ { \"DHText\", 0, \"dh (0..255), count (0..255), text\" },\n    /* 0x2a */ { \"DVText\", 0, \"dv (0..255), count (0..255), text\" },\n    /* 0x2b */ { \"DHDVText\", 0, \"dh, dv (0..255), count (0..255), text\" },\n    /* 0x2c */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x2d */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x2e */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x2f */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x30 */ { \"frameRect\", 8, \"rect\" },\n    /* 0x31 */ { \"paintRect\", 8, \"rect\" },\n    /* 0x32 */ { \"eraseRect\", 8, \"rect\" },\n    /* 0x33 */ { \"invertRect\", 8, \"rect\" },\n    /* 0x34 */ { \"fillRect\", 8, \"rect\" },\n    /* 0x35 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x36 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x37 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x38 */ { \"frameSameRect\", 0, \"rect\" },\n    /* 0x39 */ { \"paintSameRect\", 0, \"rect\" },\n    /* 0x3a */ { \"eraseSameRect\", 0, \"rect\" },\n    /* 0x3b */ { \"invertSameRect\", 0, \"rect\" },\n    /* 0x3c */ { \"fillSameRect\", 0, \"rect\" },\n    /* 0x3d */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x3e */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x3f */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x40 */ { \"frameRRect\", 8, \"rect\" },\n    /* 0x41 */ { \"paintRRect\", 8, \"rect\" },\n    /* 0x42 */ { \"eraseRRect\", 8, \"rect\" },\n    /* 0x43 */ { \"invertRRect\", 8, \"rect\" },\n    /* 0x44 */ { \"fillRRrect\", 8, \"rect\" },\n    /* 0x45 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x46 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x47 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x48 */ { \"frameSameRRect\", 0, \"rect\" },\n    /* 0x49 */ { \"paintSameRRect\", 0, \"rect\" },\n    /* 0x4a */ { \"eraseSameRRect\", 0, \"rect\" },\n    /* 0x4b */ { \"invertSameRRect\", 0, \"rect\" },\n    /* 0x4c */ { \"fillSameRRect\", 0, \"rect\" },\n    /* 0x4d */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x4e */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x4f */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x50 */ { \"frameOval\", 8, \"rect\" },\n    /* 0x51 */ { \"paintOval\", 8, \"rect\" },\n    /* 0x52 */ { \"eraseOval\", 8, \"rect\" },\n    /* 0x53 */ { \"invertOval\", 8, \"rect\" },\n    /* 0x54 */ { \"fillOval\", 8, \"rect\" },\n    /* 0x55 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x56 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x57 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x58 */ { \"frameSameOval\", 0, \"rect\" },\n    /* 0x59 */ { \"paintSameOval\", 0, \"rect\" },\n    /* 0x5a */ { \"eraseSameOval\", 0, \"rect\" },\n    /* 0x5b */ { \"invertSameOval\", 0, \"rect\" },\n    /* 0x5c */ { \"fillSameOval\", 0, \"rect\" },\n    /* 0x5d */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x5e */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x5f */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x60 */ { \"frameArc\", 12, \"rect, startAngle, arcAngle\" },\n    /* 0x61 */ { \"paintArc\", 12, \"rect, startAngle, arcAngle\" },\n    /* 0x62 */ { \"eraseArc\", 12, \"rect, startAngle, arcAngle\" },\n    /* 0x63 */ { \"invertArc\", 12, \"rect, startAngle, arcAngle\" },\n    /* 0x64 */ { \"fillArc\", 12, \"rect, startAngle, arcAngle\" },\n    /* 0x65 */ { \"reserved\", 12, \"reserved for Apple use\" },\n    /* 0x66 */ { \"reserved\", 12, \"reserved for Apple use\" },\n    /* 0x67 */ { \"reserved\", 12, \"reserved for Apple use\" },\n    /* 0x68 */ { \"frameSameArc\", 4, \"rect, startAngle, arcAngle\" },\n    /* 0x69 */ { \"paintSameArc\", 4, \"rect, startAngle, arcAngle\" },\n    /* 0x6a */ { \"eraseSameArc\", 4, \"rect, startAngle, arcAngle\" },\n    /* 0x6b */ { \"invertSameArc\", 4, \"rect, startAngle, arcAngle\" },\n    /* 0x6c */ { \"fillSameArc\", 4, \"rect, startAngle, arcAngle\" },\n    /* 0x6d */ { \"reserved\", 4, \"reserved for Apple use\" },\n    /* 0x6e */ { \"reserved\", 4, \"reserved for Apple use\" },\n    /* 0x6f */ { \"reserved\", 4, \"reserved for Apple use\" },\n    /* 0x70 */ { \"framePoly\", 0, \"poly\" },\n    /* 0x71 */ { \"paintPoly\", 0, \"poly\" },\n    /* 0x72 */ { \"erasePoly\", 0, \"poly\" },\n    /* 0x73 */ { \"invertPoly\", 0, \"poly\" },\n    /* 0x74 */ { \"fillPoly\", 0, \"poly\" },\n    /* 0x75 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x76 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x77 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x78 */ { \"frameSamePoly\", 0, \"poly (NYI)\" },\n    /* 0x79 */ { \"paintSamePoly\", 0, \"poly (NYI)\" },\n    /* 0x7a */ { \"eraseSamePoly\", 0, \"poly (NYI)\" },\n    /* 0x7b */ { \"invertSamePoly\", 0, \"poly (NYI)\" },\n    /* 0x7c */ { \"fillSamePoly\", 0, \"poly (NYI)\" },\n    /* 0x7d */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x7e */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x7f */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x80 */ { \"frameRgn\", 0, \"region\" },\n    /* 0x81 */ { \"paintRgn\", 0, \"region\" },\n    /* 0x82 */ { \"eraseRgn\", 0, \"region\" },\n    /* 0x83 */ { \"invertRgn\", 0, \"region\" },\n    /* 0x84 */ { \"fillRgn\", 0, \"region\" },\n    /* 0x85 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x86 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x87 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x88 */ { \"frameSameRgn\", 0, \"region (NYI)\" },\n    /* 0x89 */ { \"paintSameRgn\", 0, \"region (NYI)\" },\n    /* 0x8a */ { \"eraseSameRgn\", 0, \"region (NYI)\" },\n    /* 0x8b */ { \"invertSameRgn\", 0, \"region (NYI)\" },\n    /* 0x8c */ { \"fillSameRgn\", 0, \"region (NYI)\" },\n    /* 0x8d */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x8e */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x8f */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x90 */ { \"BitsRect\", 0, \"copybits, rect clipped\" },\n    /* 0x91 */ { \"BitsRgn\", 0, \"copybits, rgn clipped\" },\n    /* 0x92 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x93 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x94 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x95 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x96 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x97 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x98 */ { \"PackBitsRect\", 0, \"packed copybits, rect clipped\" },\n    /* 0x99 */ { \"PackBitsRgn\", 0, \"packed copybits, rgn clipped\" },\n    /* 0x9a */ { \"DirectBitsRect\", 0, \"PixMap, srcRect, dstRect, mode, PixData\" },\n    /* 0x9b */ { \"DirectBitsRgn\", 0, \"PixMap, srcRect, dstRect, mode, maskRgn, PixData\" },\n    /* 0x9c */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x9d */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x9e */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x9f */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0xa0 */ { \"ShortComment\", 2, \"kind (word)\" },\n    /* 0xa1 */ { \"LongComment\", 0, \"kind (word), size (word), data\" }\n  };\n\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePICTImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage decompresses an image via Macintosh pack bits decoding for\n%  Macintosh PICT images.\n%\n%  The format of the DecodeImage method is:\n%\n%      unsigned char *DecodeImage(Image *blob,Image *image,\n%        size_t bytes_per_line,const int bits_per_pixel,\n%        unsigned size_t extent)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o blob,image: the address of a structure of type Image.\n%\n%    o bytes_per_line: This integer identifies the number of bytes in a\n%      scanline.\n%\n%    o bits_per_pixel: the number of bits in a pixel.\n%\n%    o extent: the number of pixels allocated.\n%\n*/\n\nstatic unsigned char *ExpandBuffer(unsigned char *pixels,\n  MagickSizeType *bytes_per_line,const unsigned int bits_per_pixel)\n{\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  static unsigned char\n    scanline[8*256];\n\n  p=pixels;\n  q=scanline;\n  switch (bits_per_pixel)\n  {\n    case 8:\n    case 16:\n    case 32:\n      return(pixels);\n    case 4:\n    {\n      for (i=0; i < (ssize_t) *bytes_per_line; i++)\n      {\n        *q++=(*p >> 4) & 0xff;\n        *q++=(*p & 15);\n        p++;\n      }\n      *bytes_per_line*=2;\n      break;\n    }\n    case 2:\n    {\n      for (i=0; i < (ssize_t) *bytes_per_line; i++)\n      {\n        *q++=(*p >> 6) & 0x03;\n        *q++=(*p >> 4) & 0x03;\n        *q++=(*p >> 2) & 0x03;\n        *q++=(*p & 3);\n        p++;\n      }\n      *bytes_per_line*=4;\n      break;\n    }\n    case 1:\n    {\n      for (i=0; i < (ssize_t) *bytes_per_line; i++)\n      {\n        *q++=(*p >> 7) & 0x01;\n        *q++=(*p >> 6) & 0x01;\n        *q++=(*p >> 5) & 0x01;\n        *q++=(*p >> 4) & 0x01;\n        *q++=(*p >> 3) & 0x01;\n        *q++=(*p >> 2) & 0x01;\n        *q++=(*p >> 1) & 0x01;\n        *q++=(*p & 0x01);\n        p++;\n      }\n      *bytes_per_line*=8;\n      break;\n    }\n    default:\n      break;\n  }\n  return(scanline);\n}\n\nstatic unsigned char *DecodeImage(Image *blob,Image *image,\n  size_t bytes_per_line,const unsigned int bits_per_pixel,size_t *extent,\n  ExceptionInfo *exception)\n{\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    bytes_per_pixel,\n    length,\n    row_bytes,\n    scanline_length,\n    width;\n\n  ssize_t\n    count,\n    j,\n    y;\n\n  unsigned char\n    *pixels,\n    *scanline;\n\n  /*\n    Determine pixel buffer size.\n  */\n  if (bits_per_pixel <= 8)\n    bytes_per_line&=0x7fff;\n  width=image->columns;\n  bytes_per_pixel=1;\n  if (bits_per_pixel == 16)\n    {\n      bytes_per_pixel=2;\n      width*=2;\n    }\n  else\n    if (bits_per_pixel == 32)\n      width*=image->alpha_trait ? 4 : 3;\n  if (bytes_per_line == 0)\n    bytes_per_line=width;\n  row_bytes=(size_t) (image->columns | 0x8000);\n  if (image->storage_class == DirectClass)\n    row_bytes=(size_t) ((4*image->columns) | 0x8000);\n  /*\n    Allocate pixel and scanline buffer.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->rows,row_bytes*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    return((unsigned char *) NULL);\n  *extent=row_bytes*image->rows*sizeof(*pixels);\n  (void) ResetMagickMemory(pixels,0,*extent);\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,2*\n    sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    return((unsigned char *) NULL);\n  if (bytes_per_line < 8)\n    {\n      /*\n        Pixels are already uncompressed.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=pixels+y*width*GetPixelChannels(image);;\n        number_pixels=bytes_per_line;\n        count=ReadBlob(blob,(size_t) number_pixels,scanline);\n        if (count != (ssize_t) number_pixels)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",\n              image->filename);\n            break;\n          }\n        p=ExpandBuffer(scanline,&number_pixels,bits_per_pixel);\n        if ((q+number_pixels) > (pixels+(*extent)))\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",\n              image->filename);\n            break;\n          }\n        (void) CopyMagickMemory(q,p,(size_t) number_pixels);\n      }\n      scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      return(pixels);\n    }\n  /*\n    Uncompress RLE pixels into uncompressed pixel buffer.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=pixels+y*width;\n    if (bytes_per_line > 200)\n      scanline_length=ReadBlobMSBShort(blob);\n    else\n      scanline_length=1UL*ReadBlobByte(blob);\n    if (scanline_length >= row_bytes)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",image->filename);\n        break;\n      }\n    count=ReadBlob(blob,scanline_length,scanline);\n    if (count != (ssize_t) scanline_length)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",image->filename);\n        break;\n      }\n    for (j=0; j < (ssize_t) scanline_length; )\n      if ((scanline[j] & 0x80) == 0)\n        {\n          length=(size_t) ((scanline[j] & 0xff)+1);\n          number_pixels=length*bytes_per_pixel;\n          p=ExpandBuffer(scanline+j+1,&number_pixels,bits_per_pixel);\n          if ((q-pixels+number_pixels) <= *extent)\n            (void) CopyMagickMemory(q,p,(size_t) number_pixels);\n          q+=number_pixels;\n          j+=(ssize_t) (length*bytes_per_pixel+1);\n        }\n      else\n        {\n          length=(size_t) (((scanline[j] ^ 0xff) & 0xff)+2);\n          number_pixels=bytes_per_pixel;\n          p=ExpandBuffer(scanline+j+1,&number_pixels,bits_per_pixel);\n          for (i=0; i < (ssize_t) length; i++)\n          {\n            if ((q-pixels+number_pixels) <= *extent)\n              (void) CopyMagickMemory(q,p,(size_t) number_pixels);\n            q+=number_pixels;\n          }\n          j+=(ssize_t) bytes_per_pixel+1;\n        }\n  }\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   E n c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EncodeImage compresses an image via Macintosh pack bits encoding\n%  for Macintosh PICT images.\n%\n%  The format of the EncodeImage method is:\n%\n%      size_t EncodeImage(Image *image,const unsigned char *scanline,\n%        const size_t bytes_per_line,unsigned char *pixels)\n%\n%  A description of each parameter follows:\n%\n%    o image: the address of a structure of type Image.\n%\n%    o scanline: A pointer to an array of characters to pack.\n%\n%    o bytes_per_line: the number of bytes in a scanline.\n%\n%    o pixels: A pointer to an array of characters where the packed\n%      characters are stored.\n%\n*/\nstatic size_t EncodeImage(Image *image,const unsigned char *scanline,\n  const size_t bytes_per_line,unsigned char *pixels)\n{\n#define MaxCount  128\n#define MaxPackbitsRunlength  128\n\n  register const unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    repeat_count,\n    runlength;\n\n  unsigned char\n    index;\n\n  /*\n    Pack scanline.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(scanline != (unsigned char *) NULL);\n  assert(pixels != (unsigned char *) NULL);\n  count=0;\n  runlength=0;\n  p=scanline+(bytes_per_line-1);\n  q=pixels;\n  index=(*p);\n  for (i=(ssize_t) bytes_per_line-1; i >= 0; i--)\n  {\n    if (index == *p)\n      runlength++;\n    else\n      {\n        if (runlength < 3)\n          while (runlength > 0)\n          {\n            *q++=(unsigned char) index;\n            runlength--;\n            count++;\n            if (count == MaxCount)\n              {\n                *q++=(unsigned char) (MaxCount-1);\n                count-=MaxCount;\n              }\n          }\n        else\n          {\n            if (count > 0)\n              *q++=(unsigned char) (count-1);\n            count=0;\n            while (runlength > 0)\n            {\n              repeat_count=runlength;\n              if (repeat_count > MaxPackbitsRunlength)\n                repeat_count=MaxPackbitsRunlength;\n              *q++=(unsigned char) index;\n              *q++=(unsigned char) (257-repeat_count);\n              runlength-=repeat_count;\n            }\n          }\n        runlength=1;\n      }\n    index=(*p);\n    p--;\n  }\n  if (runlength < 3)\n    while (runlength > 0)\n    {\n      *q++=(unsigned char) index;\n      runlength--;\n      count++;\n      if (count == MaxCount)\n        {\n          *q++=(unsigned char) (MaxCount-1);\n          count-=MaxCount;\n        }\n    }\n  else\n    {\n      if (count > 0)\n        *q++=(unsigned char) (count-1);\n      count=0;\n      while (runlength > 0)\n      {\n        repeat_count=runlength;\n        if (repeat_count > MaxPackbitsRunlength)\n          repeat_count=MaxPackbitsRunlength;\n        *q++=(unsigned char) index;\n        *q++=(unsigned char) (257-repeat_count);\n        runlength-=repeat_count;\n      }\n    }\n  if (count > 0)\n    *q++=(unsigned char) (count-1);\n  /*\n    Write the number of and the packed length.\n  */\n  length=(size_t) (q-pixels);\n  if (bytes_per_line > 200)\n    {\n      (void) WriteBlobMSBShort(image,(unsigned short) length);\n      length+=2;\n    }\n  else\n    {\n      (void) WriteBlobByte(image,(unsigned char) length);\n      length++;\n    }\n  while (q != pixels)\n  {\n    q--;\n    (void) WriteBlobByte(image,*q);\n  }\n  return(length);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P I C T                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPICT()() returns MagickTrue if the image format type, identified by the\n%  magick string, is PICT.\n%\n%  The format of the ReadPICTImage method is:\n%\n%      MagickBooleanType IsPICT(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPICT(const unsigned char *magick,const size_t length)\n{\n  if (length < 12)\n    return(MagickFalse);\n  /*\n    Embedded OLE2 macintosh have \"PICT\" instead of 512 platform header.\n  */\n  if (memcmp(magick,\"PICT\",4) == 0)\n    return(MagickTrue);\n  if (length < 528)\n    return(MagickFalse);\n  if (memcmp(magick+522,\"\\000\\021\\002\\377\\014\\000\",6) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n#if !defined(macintosh)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P I C T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPICTImage() reads an Apple Macintosh QuickDraw/PICT image file\n%  and returns it.  It allocates the memory necessary for the new Image\n%  structure and returns a pointer to the new image.\n%\n%  The format of the ReadPICTImage method is:\n%\n%      Image *ReadPICTImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType ReadRectangle(Image *image,PICTRectangle *rectangle)\n{\n  rectangle->top=(short) ReadBlobMSBShort(image);\n  rectangle->left=(short) ReadBlobMSBShort(image);\n  rectangle->bottom=(short) ReadBlobMSBShort(image);\n  rectangle->right=(short) ReadBlobMSBShort(image);\n  if ((EOFBlob(image) != MagickFalse) || (rectangle->left > rectangle->right) ||\n      (rectangle->top > rectangle->bottom))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  version=ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=1UL*(frame.right-frame.left);\n  image->rows=1UL*(frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n              Clipping rectangle.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length != 0x000a)\n              {\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=1UL*(frame.right-frame.left);\n            image->rows=1UL*(frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            (void) SetImageBackgroundColor(image,exception);\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=1L*ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (pattern != 1)\n              ThrowReaderException(CorruptImageError,\"UnknownPatternType\");\n            length=ReadBlobMSBShort(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            ReadPixmap(pixmap);\n            image->depth=1UL*pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n            (void) ReadBlobMSBLong(image);\n            flags=1L*ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            for (i=0; i <= (ssize_t) length; i++)\n              (void) ReadBlobMSBLong(image);\n            width=1UL*(frame.bottom-frame.top);\n            height=1UL*(frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (j=0; j < (int) height; j++)\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n              Skip polygon or region.\n            */\n            length=ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) (length-2); i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            Image\n              *tile_image;\n\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=1L*ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,1UL*(frame.right-frame.left),\n              1UL*(frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              return((Image *) NULL);\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                ReadPixmap(pixmap);\n                tile_image->depth=1UL*pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  image->alpha_trait=tile_image->alpha_trait;\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=1L*ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  {\n                    tile_image=DestroyImage(tile_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (ReadRectangle(image,&source) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                  Skip region.\n                */\n                length=ReadBlobMSBShort(image);\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1,&extent,\n                exception);\n            else\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1U*\n                pixmap.bits_per_pixel,&extent,exception);\n            if (pixels == (unsigned char *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  tile_image=DestroyImage(tile_image);\n                  ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=ConstrainColormapIndex(tile_image,*p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(*p++);\n                        j=(*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,y,tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if (jpeg == MagickFalse)\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,destination.left,destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n            */\n            type=ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length == 0)\n              break;\n            (void) ReadBlobMSBLong(image);\n            length-=4;\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              ThrowReaderException(ResourceLimitError,\"UnableToReadImageData\");\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        FILE\n          *file;\n\n        Image\n          *tile_image;\n\n        ImageInfo\n          *read_info;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(read_info->filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",image->filename);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=ReadBlobMSBLong(image);\n        if (length > 154)\n          {\n            for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              (void) fputc(c,file);\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          frame.left,frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n          Skip reserved.\n        */\n        length=ReadBlobMSBShort(image);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n          Skip reserved.\n        */\n        length=(size_t) ((code >> 7) & 0xff);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P I C T I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPICTImage() adds attributes for the PICT image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPICTImage method is:\n%\n%      size_t RegisterPICTImage(void)\n%\n*/\nModuleExport size_t RegisterPICTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PICT\",\"PCT\",\"Apple Macintosh QuickDraw/PICT\");\n  entry->decoder=(DecodeImageHandler *) ReadPICTImage;\n  entry->encoder=(EncodeImageHandler *) WritePICTImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->magick=(IsImageFormatHandler *) IsPICT;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PICT\",\"PICT\",\"Apple Macintosh QuickDraw/PICT\");\n  entry->decoder=(DecodeImageHandler *) ReadPICTImage;\n  entry->encoder=(EncodeImageHandler *) WritePICTImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->magick=(IsImageFormatHandler *) IsPICT;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P I C T I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPICTImage() removes format registrations made by the\n%  PICT module from the list of supported formats.\n%\n%  The format of the UnregisterPICTImage method is:\n%\n%      UnregisterPICTImage(void)\n%\n*/\nModuleExport void UnregisterPICTImage(void)\n{\n  (void) UnregisterMagickInfo(\"PCT\");\n  (void) UnregisterMagickInfo(\"PICT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P I C T I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePICTImage() writes an image to a file in the Apple Macintosh\n%  QuickDraw/PICT image format.\n%\n%  The format of the WritePICTImage method is:\n%\n%      MagickBooleanType WritePICTImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePICTImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define MaxCount  128\n#define PictCropRegionOp  0x01\n#define PictEndOfPictureOp  0xff\n#define PictJPEGOp  0x8200\n#define PictInfoOp  0x0C00\n#define PictInfoSize  512\n#define PictPixmapOp  0x9A\n#define PictPICTOp  0x98\n#define PictVersion  0x11\n\n  const StringInfo\n    *profile;\n\n  double\n    x_resolution,\n    y_resolution;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  PICTPixmap\n    pixmap;\n\n  PICTRectangle\n    bounds,\n    crop_rectangle,\n    destination_rectangle,\n    frame_rectangle,\n    size_rectangle,\n    source_rectangle;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    bytes_per_line,\n    count,\n    row_bytes,\n    storage_class;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *packed_scanline,\n    *scanline;\n\n  unsigned short\n    base_address,\n    transfer_mode;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Initialize image info.\n  */\n  size_rectangle.top=0;\n  size_rectangle.left=0;\n  size_rectangle.bottom=(short) image->rows;\n  size_rectangle.right=(short) image->columns;\n  frame_rectangle=size_rectangle;\n  crop_rectangle=size_rectangle;\n  source_rectangle=size_rectangle;\n  destination_rectangle=size_rectangle;\n  base_address=0xff;\n  row_bytes=image->columns;\n  bounds.top=0;\n  bounds.left=0;\n  bounds.bottom=(short) image->rows;\n  bounds.right=(short) image->columns;\n  pixmap.version=0;\n  pixmap.pack_type=0;\n  pixmap.pack_size=0;\n  pixmap.pixel_type=0;\n  pixmap.bits_per_pixel=8;\n  pixmap.component_count=1;\n  pixmap.component_size=8;\n  pixmap.plane_bytes=0;\n  pixmap.table=0;\n  pixmap.reserved=0;\n  transfer_mode=0;\n  x_resolution=image->resolution.x != 0.0 ? image->resolution.x :\n    DefaultResolution;\n  y_resolution=image->resolution.y != 0.0 ? image->resolution.y :\n    DefaultResolution;\n  storage_class=image->storage_class;\n  if (image_info->compression == JPEGCompression)\n    storage_class=DirectClass;\n  if (storage_class == DirectClass)\n    {\n      pixmap.component_count=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n      pixmap.pixel_type=16;\n      pixmap.bits_per_pixel=32;\n      pixmap.pack_type=0x04;\n      transfer_mode=0x40;\n      row_bytes=4*image->columns;\n    }\n  /*\n    Allocate memory.\n  */\n  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.right);\n  (void) WriteBlobMSBShort(image,PictVersion);\n  (void) WriteBlobMSBShort(image,0x02ff);  /* version #2 */\n  (void) WriteBlobMSBShort(image,PictInfoOp);\n  (void) WriteBlobMSBLong(image,0xFFFE0000UL);\n  /*\n    Write full size of the file, resolution, frame bounding box, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.right);\n  (void) WriteBlobMSBLong(image,0x00000000L);\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0x1f2);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobString(image,\"8BIM\");\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    }\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,4);\n      (void) WriteBlobMSBLong(image,0x00000002UL);\n    }\n  /*\n    Write crop region opcode and crop bounding box.\n  */\n  (void) WriteBlobMSBShort(image,PictCropRegionOp);\n  (void) WriteBlobMSBShort(image,0xa);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.right);\n  if (image_info->compression == JPEGCompression)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *jpeg_info;\n\n      size_t\n        length;\n\n      unsigned char\n        *blob;\n\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image == (Image *) NULL)\n        {\n          (void) CloseBlob(image);\n          return(MagickFalse);\n        }\n      jpeg_info=CloneImageInfo(image_info);\n      (void) CopyMagickString(jpeg_info->magick,\"JPEG\",MagickPathExtent);\n      length=0;\n      blob=(unsigned char *) ImageToBlob(jpeg_info,jpeg_image,&length,\n        exception);\n      jpeg_info=DestroyImageInfo(jpeg_info);\n      if (blob == (unsigned char *) NULL)\n        return(MagickFalse);\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) WriteBlobMSBShort(image,PictJPEGOp);\n      (void) WriteBlobMSBLong(image,(unsigned int) length+154);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x40000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00400000UL);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00566A70UL);\n      (void) WriteBlobMSBLong(image,0x65670000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000001UL);\n      (void) WriteBlobMSBLong(image,0x00016170UL);\n      (void) WriteBlobMSBLong(image,0x706C0000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x87AC0001UL);\n      (void) WriteBlobMSBLong(image,0x0B466F74UL);\n      (void) WriteBlobMSBLong(image,0x6F202D20UL);\n      (void) WriteBlobMSBLong(image,0x4A504547UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x0018FFFFUL);\n      (void) WriteBlob(image,length,blob);\n      if ((length & 0x01) != 0)\n        (void) WriteBlobByte(image,'\\0');\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n  /*\n    Write picture opcode, row bytes, and picture bounding box, and version.\n  */\n  if (storage_class == PseudoClass)\n    (void) WriteBlobMSBShort(image,PictPICTOp);\n  else\n    {\n      (void) WriteBlobMSBShort(image,PictPixmapOp);\n      (void) WriteBlobMSBLong(image,(size_t) base_address);\n    }\n  (void) WriteBlobMSBShort(image,(unsigned short) (row_bytes | 0x8000));\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.right);\n  /*\n    Write pack type, pack size, resolution, pixel type, and pixel size.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.version);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pack_type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.pack_size);\n  (void) WriteBlobMSBShort(image,(unsigned short) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pixel_type);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.bits_per_pixel);\n  /*\n    Write component count, size, plane bytes, table size, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_count);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_size);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.plane_bytes);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.table);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.reserved);\n  if (storage_class == PseudoClass)\n    {\n      /*\n        Write image colormap.\n      */\n      (void) WriteBlobMSBLong(image,0x00000000L);  /* color seed */\n      (void) WriteBlobMSBShort(image,0L);  /* color flags */\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->colors-1));\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        (void) WriteBlobMSBShort(image,(unsigned short) i);\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].red));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].green));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].blue));\n      }\n    }\n  /*\n    Write source and destination rectangle.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) transfer_mode);\n  /*\n    Write picture data.\n  */\n  count=0;\n  if (storage_class == PseudoClass)\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        scanline[x]=(unsigned char) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n      count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n        packed_scanline);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  else\n    if (image_info->compression == JPEGCompression)\n      {\n        (void) ResetMagickMemory(scanline,0,row_bytes);\n        for (y=0; y < (ssize_t) image->rows; y++)\n          count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n            packed_scanline);\n      }\n    else\n      {\n        register unsigned char\n          *blue,\n          *green,\n          *opacity,\n          *red;\n\n        red=scanline;\n        green=scanline+image->columns;\n        blue=scanline+2*image->columns;\n        opacity=scanline+3*image->columns;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          red=scanline;\n          green=scanline+image->columns;\n          blue=scanline+2*image->columns;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              opacity=scanline;\n              red=scanline+image->columns;\n              green=scanline+2*image->columns;\n              blue=scanline+3*image->columns;\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *red++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *green++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *blue++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *opacity++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n          }\n          count+=EncodeImage(image,scanline,bytes_per_line,packed_scanline);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n  if ((count & 0x01) != 0)\n    (void) WriteBlobByte(image,'\\0');\n  (void) WriteBlobMSBShort(image,PictEndOfPictureOp);\n  offset=TellBlob(image);\n  offset=SeekBlob(image,512,SEEK_SET);\n  (void) WriteBlobMSBShort(image,(unsigned short) offset);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  packed_scanline=(unsigned char *) RelinquishMagickMemory(packed_scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                        PPPP   IIIII   CCCC  TTTTT                           %\n%                        P   P    I    C        T                             %\n%                        PPPP     I    C        T                             %\n%                        P        I    C        T                             %\n%                        P      IIIII   CCCC    T                             %\n%                                                                             %\n%                                                                             %\n%               Read/Write Apple Macintosh QuickDraw/PICT Format              %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2017 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://www.imagemagick.org/script/license.php                           %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/static.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n  ImageMagick Macintosh PICT Methods.\n*/\n#define ReadPixmap(pixmap) \\\n{ \\\n  pixmap.version=(short) ReadBlobMSBShort(image); \\\n  pixmap.pack_type=(short) ReadBlobMSBShort(image); \\\n  pixmap.pack_size=ReadBlobMSBLong(image); \\\n  pixmap.horizontal_resolution=1UL*ReadBlobMSBShort(image); \\\n  (void) ReadBlobMSBShort(image); \\\n  pixmap.vertical_resolution=1UL*ReadBlobMSBShort(image); \\\n  (void) ReadBlobMSBShort(image); \\\n  pixmap.pixel_type=(short) ReadBlobMSBShort(image); \\\n  pixmap.bits_per_pixel=(short) ReadBlobMSBShort(image); \\\n  pixmap.component_count=(short) ReadBlobMSBShort(image); \\\n  pixmap.component_size=(short) ReadBlobMSBShort(image); \\\n  pixmap.plane_bytes=ReadBlobMSBLong(image); \\\n  pixmap.table=ReadBlobMSBLong(image); \\\n  pixmap.reserved=ReadBlobMSBLong(image); \\\n  if ((EOFBlob(image) != MagickFalse) || (pixmap.bits_per_pixel <= 0) || \\\n      (pixmap.bits_per_pixel > 32) || (pixmap.component_count <= 0) || \\\n      (pixmap.component_count > 4) || (pixmap.component_size <= 0)) \\\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\"); \\\n}\n\ntypedef struct _PICTCode\n{\n  const char\n    *name;\n\n  ssize_t\n    length;\n\n  const char\n    *description;\n} PICTCode;\n\ntypedef struct _PICTPixmap\n{\n  short\n    version,\n    pack_type;\n\n  size_t\n    pack_size,\n    horizontal_resolution,\n    vertical_resolution;\n\n  short\n    pixel_type,\n    bits_per_pixel,\n    component_count,\n    component_size;\n\n  size_t\n    plane_bytes,\n    table,\n    reserved;\n} PICTPixmap;\n\ntypedef struct _PICTRectangle\n{\n  short\n    top,\n    left,\n    bottom,\n    right;\n} PICTRectangle;\n\nstatic const PICTCode\n  codes[] =\n  {\n    /* 0x00 */ { \"NOP\", 0, \"nop\" },\n    /* 0x01 */ { \"Clip\", 0, \"clip\" },\n    /* 0x02 */ { \"BkPat\", 8, \"background pattern\" },\n    /* 0x03 */ { \"TxFont\", 2, \"text font (word)\" },\n    /* 0x04 */ { \"TxFace\", 1, \"text face (byte)\" },\n    /* 0x05 */ { \"TxMode\", 2, \"text mode (word)\" },\n    /* 0x06 */ { \"SpExtra\", 4, \"space extra (fixed point)\" },\n    /* 0x07 */ { \"PnSize\", 4, \"pen size (point)\" },\n    /* 0x08 */ { \"PnMode\", 2, \"pen mode (word)\" },\n    /* 0x09 */ { \"PnPat\", 8, \"pen pattern\" },\n    /* 0x0a */ { \"FillPat\", 8, \"fill pattern\" },\n    /* 0x0b */ { \"OvSize\", 4, \"oval size (point)\" },\n    /* 0x0c */ { \"Origin\", 4, \"dh, dv (word)\" },\n    /* 0x0d */ { \"TxSize\", 2, \"text size (word)\" },\n    /* 0x0e */ { \"FgColor\", 4, \"foreground color (ssize_tword)\" },\n    /* 0x0f */ { \"BkColor\", 4, \"background color (ssize_tword)\" },\n    /* 0x10 */ { \"TxRatio\", 8, \"numerator (point), denominator (point)\" },\n    /* 0x11 */ { \"Version\", 1, \"version (byte)\" },\n    /* 0x12 */ { \"BkPixPat\", 0, \"color background pattern\" },\n    /* 0x13 */ { \"PnPixPat\", 0, \"color pen pattern\" },\n    /* 0x14 */ { \"FillPixPat\", 0, \"color fill pattern\" },\n    /* 0x15 */ { \"PnLocHFrac\", 2, \"fractional pen position\" },\n    /* 0x16 */ { \"ChExtra\", 2, \"extra for each character\" },\n    /* 0x17 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x18 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x19 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x1a */ { \"RGBFgCol\", 6, \"RGB foreColor\" },\n    /* 0x1b */ { \"RGBBkCol\", 6, \"RGB backColor\" },\n    /* 0x1c */ { \"HiliteMode\", 0, \"hilite mode flag\" },\n    /* 0x1d */ { \"HiliteColor\", 6, \"RGB hilite color\" },\n    /* 0x1e */ { \"DefHilite\", 0, \"Use default hilite color\" },\n    /* 0x1f */ { \"OpColor\", 6, \"RGB OpColor for arithmetic modes\" },\n    /* 0x20 */ { \"Line\", 8, \"pnLoc (point), newPt (point)\" },\n    /* 0x21 */ { \"LineFrom\", 4, \"newPt (point)\" },\n    /* 0x22 */ { \"ShortLine\", 6, \"pnLoc (point, dh, dv (-128 .. 127))\" },\n    /* 0x23 */ { \"ShortLineFrom\", 2, \"dh, dv (-128 .. 127)\" },\n    /* 0x24 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x25 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x26 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x27 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x28 */ { \"LongText\", 0, \"txLoc (point), count (0..255), text\" },\n    /* 0x29 */ { \"DHText\", 0, \"dh (0..255), count (0..255), text\" },\n    /* 0x2a */ { \"DVText\", 0, \"dv (0..255), count (0..255), text\" },\n    /* 0x2b */ { \"DHDVText\", 0, \"dh, dv (0..255), count (0..255), text\" },\n    /* 0x2c */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x2d */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x2e */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x2f */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x30 */ { \"frameRect\", 8, \"rect\" },\n    /* 0x31 */ { \"paintRect\", 8, \"rect\" },\n    /* 0x32 */ { \"eraseRect\", 8, \"rect\" },\n    /* 0x33 */ { \"invertRect\", 8, \"rect\" },\n    /* 0x34 */ { \"fillRect\", 8, \"rect\" },\n    /* 0x35 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x36 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x37 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x38 */ { \"frameSameRect\", 0, \"rect\" },\n    /* 0x39 */ { \"paintSameRect\", 0, \"rect\" },\n    /* 0x3a */ { \"eraseSameRect\", 0, \"rect\" },\n    /* 0x3b */ { \"invertSameRect\", 0, \"rect\" },\n    /* 0x3c */ { \"fillSameRect\", 0, \"rect\" },\n    /* 0x3d */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x3e */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x3f */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x40 */ { \"frameRRect\", 8, \"rect\" },\n    /* 0x41 */ { \"paintRRect\", 8, \"rect\" },\n    /* 0x42 */ { \"eraseRRect\", 8, \"rect\" },\n    /* 0x43 */ { \"invertRRect\", 8, \"rect\" },\n    /* 0x44 */ { \"fillRRrect\", 8, \"rect\" },\n    /* 0x45 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x46 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x47 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x48 */ { \"frameSameRRect\", 0, \"rect\" },\n    /* 0x49 */ { \"paintSameRRect\", 0, \"rect\" },\n    /* 0x4a */ { \"eraseSameRRect\", 0, \"rect\" },\n    /* 0x4b */ { \"invertSameRRect\", 0, \"rect\" },\n    /* 0x4c */ { \"fillSameRRect\", 0, \"rect\" },\n    /* 0x4d */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x4e */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x4f */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x50 */ { \"frameOval\", 8, \"rect\" },\n    /* 0x51 */ { \"paintOval\", 8, \"rect\" },\n    /* 0x52 */ { \"eraseOval\", 8, \"rect\" },\n    /* 0x53 */ { \"invertOval\", 8, \"rect\" },\n    /* 0x54 */ { \"fillOval\", 8, \"rect\" },\n    /* 0x55 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x56 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x57 */ { \"reserved\", 8, \"reserved for Apple use\" },\n    /* 0x58 */ { \"frameSameOval\", 0, \"rect\" },\n    /* 0x59 */ { \"paintSameOval\", 0, \"rect\" },\n    /* 0x5a */ { \"eraseSameOval\", 0, \"rect\" },\n    /* 0x5b */ { \"invertSameOval\", 0, \"rect\" },\n    /* 0x5c */ { \"fillSameOval\", 0, \"rect\" },\n    /* 0x5d */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x5e */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x5f */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x60 */ { \"frameArc\", 12, \"rect, startAngle, arcAngle\" },\n    /* 0x61 */ { \"paintArc\", 12, \"rect, startAngle, arcAngle\" },\n    /* 0x62 */ { \"eraseArc\", 12, \"rect, startAngle, arcAngle\" },\n    /* 0x63 */ { \"invertArc\", 12, \"rect, startAngle, arcAngle\" },\n    /* 0x64 */ { \"fillArc\", 12, \"rect, startAngle, arcAngle\" },\n    /* 0x65 */ { \"reserved\", 12, \"reserved for Apple use\" },\n    /* 0x66 */ { \"reserved\", 12, \"reserved for Apple use\" },\n    /* 0x67 */ { \"reserved\", 12, \"reserved for Apple use\" },\n    /* 0x68 */ { \"frameSameArc\", 4, \"rect, startAngle, arcAngle\" },\n    /* 0x69 */ { \"paintSameArc\", 4, \"rect, startAngle, arcAngle\" },\n    /* 0x6a */ { \"eraseSameArc\", 4, \"rect, startAngle, arcAngle\" },\n    /* 0x6b */ { \"invertSameArc\", 4, \"rect, startAngle, arcAngle\" },\n    /* 0x6c */ { \"fillSameArc\", 4, \"rect, startAngle, arcAngle\" },\n    /* 0x6d */ { \"reserved\", 4, \"reserved for Apple use\" },\n    /* 0x6e */ { \"reserved\", 4, \"reserved for Apple use\" },\n    /* 0x6f */ { \"reserved\", 4, \"reserved for Apple use\" },\n    /* 0x70 */ { \"framePoly\", 0, \"poly\" },\n    /* 0x71 */ { \"paintPoly\", 0, \"poly\" },\n    /* 0x72 */ { \"erasePoly\", 0, \"poly\" },\n    /* 0x73 */ { \"invertPoly\", 0, \"poly\" },\n    /* 0x74 */ { \"fillPoly\", 0, \"poly\" },\n    /* 0x75 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x76 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x77 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x78 */ { \"frameSamePoly\", 0, \"poly (NYI)\" },\n    /* 0x79 */ { \"paintSamePoly\", 0, \"poly (NYI)\" },\n    /* 0x7a */ { \"eraseSamePoly\", 0, \"poly (NYI)\" },\n    /* 0x7b */ { \"invertSamePoly\", 0, \"poly (NYI)\" },\n    /* 0x7c */ { \"fillSamePoly\", 0, \"poly (NYI)\" },\n    /* 0x7d */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x7e */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x7f */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x80 */ { \"frameRgn\", 0, \"region\" },\n    /* 0x81 */ { \"paintRgn\", 0, \"region\" },\n    /* 0x82 */ { \"eraseRgn\", 0, \"region\" },\n    /* 0x83 */ { \"invertRgn\", 0, \"region\" },\n    /* 0x84 */ { \"fillRgn\", 0, \"region\" },\n    /* 0x85 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x86 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x87 */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x88 */ { \"frameSameRgn\", 0, \"region (NYI)\" },\n    /* 0x89 */ { \"paintSameRgn\", 0, \"region (NYI)\" },\n    /* 0x8a */ { \"eraseSameRgn\", 0, \"region (NYI)\" },\n    /* 0x8b */ { \"invertSameRgn\", 0, \"region (NYI)\" },\n    /* 0x8c */ { \"fillSameRgn\", 0, \"region (NYI)\" },\n    /* 0x8d */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x8e */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x8f */ { \"reserved\", 0, \"reserved for Apple use\" },\n    /* 0x90 */ { \"BitsRect\", 0, \"copybits, rect clipped\" },\n    /* 0x91 */ { \"BitsRgn\", 0, \"copybits, rgn clipped\" },\n    /* 0x92 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x93 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x94 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x95 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x96 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x97 */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x98 */ { \"PackBitsRect\", 0, \"packed copybits, rect clipped\" },\n    /* 0x99 */ { \"PackBitsRgn\", 0, \"packed copybits, rgn clipped\" },\n    /* 0x9a */ { \"DirectBitsRect\", 0, \"PixMap, srcRect, dstRect, mode, PixData\" },\n    /* 0x9b */ { \"DirectBitsRgn\", 0, \"PixMap, srcRect, dstRect, mode, maskRgn, PixData\" },\n    /* 0x9c */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x9d */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x9e */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0x9f */ { \"reserved\", -1, \"reserved for Apple use\" },\n    /* 0xa0 */ { \"ShortComment\", 2, \"kind (word)\" },\n    /* 0xa1 */ { \"LongComment\", 0, \"kind (word), size (word), data\" }\n  };\n\n/*\n  Forward declarations.\n*/\nstatic MagickBooleanType\n  WritePICTImage(const ImageInfo *,Image *,ExceptionInfo *);\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DecodeImage decompresses an image via Macintosh pack bits decoding for\n%  Macintosh PICT images.\n%\n%  The format of the DecodeImage method is:\n%\n%      unsigned char *DecodeImage(Image *blob,Image *image,\n%        size_t bytes_per_line,const int bits_per_pixel,\n%        unsigned size_t extent)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o blob,image: the address of a structure of type Image.\n%\n%    o bytes_per_line: This integer identifies the number of bytes in a\n%      scanline.\n%\n%    o bits_per_pixel: the number of bits in a pixel.\n%\n%    o extent: the number of pixels allocated.\n%\n*/\n\nstatic unsigned char *ExpandBuffer(unsigned char *pixels,\n  MagickSizeType *bytes_per_line,const unsigned int bits_per_pixel)\n{\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  static unsigned char\n    scanline[8*256];\n\n  p=pixels;\n  q=scanline;\n  switch (bits_per_pixel)\n  {\n    case 8:\n    case 16:\n    case 32:\n      return(pixels);\n    case 4:\n    {\n      for (i=0; i < (ssize_t) *bytes_per_line; i++)\n      {\n        *q++=(*p >> 4) & 0xff;\n        *q++=(*p & 15);\n        p++;\n      }\n      *bytes_per_line*=2;\n      break;\n    }\n    case 2:\n    {\n      for (i=0; i < (ssize_t) *bytes_per_line; i++)\n      {\n        *q++=(*p >> 6) & 0x03;\n        *q++=(*p >> 4) & 0x03;\n        *q++=(*p >> 2) & 0x03;\n        *q++=(*p & 3);\n        p++;\n      }\n      *bytes_per_line*=4;\n      break;\n    }\n    case 1:\n    {\n      for (i=0; i < (ssize_t) *bytes_per_line; i++)\n      {\n        *q++=(*p >> 7) & 0x01;\n        *q++=(*p >> 6) & 0x01;\n        *q++=(*p >> 5) & 0x01;\n        *q++=(*p >> 4) & 0x01;\n        *q++=(*p >> 3) & 0x01;\n        *q++=(*p >> 2) & 0x01;\n        *q++=(*p >> 1) & 0x01;\n        *q++=(*p & 0x01);\n        p++;\n      }\n      *bytes_per_line*=8;\n      break;\n    }\n    default:\n      break;\n  }\n  return(scanline);\n}\n\nstatic unsigned char *DecodeImage(Image *blob,Image *image,\n  size_t bytes_per_line,const unsigned int bits_per_pixel,size_t *extent,\n  ExceptionInfo *exception)\n{\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    bytes_per_pixel,\n    length,\n    row_bytes,\n    scanline_length,\n    width;\n\n  ssize_t\n    count,\n    j,\n    y;\n\n  unsigned char\n    *pixels,\n    *scanline;\n\n  /*\n    Determine pixel buffer size.\n  */\n  if (bits_per_pixel <= 8)\n    bytes_per_line&=0x7fff;\n  width=image->columns;\n  bytes_per_pixel=1;\n  if (bits_per_pixel == 16)\n    {\n      bytes_per_pixel=2;\n      width*=2;\n    }\n  else\n    if (bits_per_pixel == 32)\n      width*=image->alpha_trait ? 4 : 3;\n  if (bytes_per_line == 0)\n    bytes_per_line=width;\n  row_bytes=(size_t) (image->columns | 0x8000);\n  if (image->storage_class == DirectClass)\n    row_bytes=(size_t) ((4*image->columns) | 0x8000);\n  /*\n    Allocate pixel and scanline buffer.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->rows,row_bytes*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    return((unsigned char *) NULL);\n  *extent=row_bytes*image->rows*sizeof(*pixels);\n  (void) ResetMagickMemory(pixels,0,*extent);\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,2*\n    sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    return((unsigned char *) NULL);\n  if (bytes_per_line < 8)\n    {\n      /*\n        Pixels are already uncompressed.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=pixels+y*width*GetPixelChannels(image);;\n        number_pixels=bytes_per_line;\n        count=ReadBlob(blob,(size_t) number_pixels,scanline);\n        if (count != (ssize_t) number_pixels)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",\n              image->filename);\n            break;\n          }\n        p=ExpandBuffer(scanline,&number_pixels,bits_per_pixel);\n        if ((q+number_pixels) > (pixels+(*extent)))\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",\n              image->filename);\n            break;\n          }\n        (void) CopyMagickMemory(q,p,(size_t) number_pixels);\n      }\n      scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      return(pixels);\n    }\n  /*\n    Uncompress RLE pixels into uncompressed pixel buffer.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=pixels+y*width;\n    if (bytes_per_line > 200)\n      scanline_length=ReadBlobMSBShort(blob);\n    else\n      scanline_length=1UL*ReadBlobByte(blob);\n    if (scanline_length >= row_bytes)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",image->filename);\n        break;\n      }\n    count=ReadBlob(blob,scanline_length,scanline);\n    if (count != (ssize_t) scanline_length)\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageError,\"UnableToUncompressImage\",\"`%s'\",image->filename);\n        break;\n      }\n    for (j=0; j < (ssize_t) scanline_length; )\n      if ((scanline[j] & 0x80) == 0)\n        {\n          length=(size_t) ((scanline[j] & 0xff)+1);\n          number_pixels=length*bytes_per_pixel;\n          p=ExpandBuffer(scanline+j+1,&number_pixels,bits_per_pixel);\n          if ((q-pixels+number_pixels) <= *extent)\n            (void) CopyMagickMemory(q,p,(size_t) number_pixels);\n          q+=number_pixels;\n          j+=(ssize_t) (length*bytes_per_pixel+1);\n        }\n      else\n        {\n          length=(size_t) (((scanline[j] ^ 0xff) & 0xff)+2);\n          number_pixels=bytes_per_pixel;\n          p=ExpandBuffer(scanline+j+1,&number_pixels,bits_per_pixel);\n          for (i=0; i < (ssize_t) length; i++)\n          {\n            if ((q-pixels+number_pixels) <= *extent)\n              (void) CopyMagickMemory(q,p,(size_t) number_pixels);\n            q+=number_pixels;\n          }\n          j+=(ssize_t) bytes_per_pixel+1;\n        }\n  }\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   E n c o d e I m a g e                                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  EncodeImage compresses an image via Macintosh pack bits encoding\n%  for Macintosh PICT images.\n%\n%  The format of the EncodeImage method is:\n%\n%      size_t EncodeImage(Image *image,const unsigned char *scanline,\n%        const size_t bytes_per_line,unsigned char *pixels)\n%\n%  A description of each parameter follows:\n%\n%    o image: the address of a structure of type Image.\n%\n%    o scanline: A pointer to an array of characters to pack.\n%\n%    o bytes_per_line: the number of bytes in a scanline.\n%\n%    o pixels: A pointer to an array of characters where the packed\n%      characters are stored.\n%\n*/\nstatic size_t EncodeImage(Image *image,const unsigned char *scanline,\n  const size_t bytes_per_line,unsigned char *pixels)\n{\n#define MaxCount  128\n#define MaxPackbitsRunlength  128\n\n  register const unsigned char\n    *p;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    repeat_count,\n    runlength;\n\n  unsigned char\n    index;\n\n  /*\n    Pack scanline.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(scanline != (unsigned char *) NULL);\n  assert(pixels != (unsigned char *) NULL);\n  count=0;\n  runlength=0;\n  p=scanline+(bytes_per_line-1);\n  q=pixels;\n  index=(*p);\n  for (i=(ssize_t) bytes_per_line-1; i >= 0; i--)\n  {\n    if (index == *p)\n      runlength++;\n    else\n      {\n        if (runlength < 3)\n          while (runlength > 0)\n          {\n            *q++=(unsigned char) index;\n            runlength--;\n            count++;\n            if (count == MaxCount)\n              {\n                *q++=(unsigned char) (MaxCount-1);\n                count-=MaxCount;\n              }\n          }\n        else\n          {\n            if (count > 0)\n              *q++=(unsigned char) (count-1);\n            count=0;\n            while (runlength > 0)\n            {\n              repeat_count=runlength;\n              if (repeat_count > MaxPackbitsRunlength)\n                repeat_count=MaxPackbitsRunlength;\n              *q++=(unsigned char) index;\n              *q++=(unsigned char) (257-repeat_count);\n              runlength-=repeat_count;\n            }\n          }\n        runlength=1;\n      }\n    index=(*p);\n    p--;\n  }\n  if (runlength < 3)\n    while (runlength > 0)\n    {\n      *q++=(unsigned char) index;\n      runlength--;\n      count++;\n      if (count == MaxCount)\n        {\n          *q++=(unsigned char) (MaxCount-1);\n          count-=MaxCount;\n        }\n    }\n  else\n    {\n      if (count > 0)\n        *q++=(unsigned char) (count-1);\n      count=0;\n      while (runlength > 0)\n      {\n        repeat_count=runlength;\n        if (repeat_count > MaxPackbitsRunlength)\n          repeat_count=MaxPackbitsRunlength;\n        *q++=(unsigned char) index;\n        *q++=(unsigned char) (257-repeat_count);\n        runlength-=repeat_count;\n      }\n    }\n  if (count > 0)\n    *q++=(unsigned char) (count-1);\n  /*\n    Write the number of and the packed length.\n  */\n  length=(size_t) (q-pixels);\n  if (bytes_per_line > 200)\n    {\n      (void) WriteBlobMSBShort(image,(unsigned short) length);\n      length+=2;\n    }\n  else\n    {\n      (void) WriteBlobByte(image,(unsigned char) length);\n      length++;\n    }\n  while (q != pixels)\n  {\n    q--;\n    (void) WriteBlobByte(image,*q);\n  }\n  return(length);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s P I C T                                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsPICT()() returns MagickTrue if the image format type, identified by the\n%  magick string, is PICT.\n%\n%  The format of the ReadPICTImage method is:\n%\n%      MagickBooleanType IsPICT(const unsigned char *magick,const size_t length)\n%\n%  A description of each parameter follows:\n%\n%    o magick: compare image format pattern against these bytes.\n%\n%    o length: Specifies the length of the magick string.\n%\n*/\nstatic MagickBooleanType IsPICT(const unsigned char *magick,const size_t length)\n{\n  if (length < 12)\n    return(MagickFalse);\n  /*\n    Embedded OLE2 macintosh have \"PICT\" instead of 512 platform header.\n  */\n  if (memcmp(magick,\"PICT\",4) == 0)\n    return(MagickTrue);\n  if (length < 528)\n    return(MagickFalse);\n  if (memcmp(magick+522,\"\\000\\021\\002\\377\\014\\000\",6) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n#if !defined(macintosh)\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e a d P I C T I m a g e                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPICTImage() reads an Apple Macintosh QuickDraw/PICT image file\n%  and returns it.  It allocates the memory necessary for the new Image\n%  structure and returns a pointer to the new image.\n%\n%  The format of the ReadPICTImage method is:\n%\n%      Image *ReadPICTImage(const ImageInfo *image_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image_info: the image info.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType ReadRectangle(Image *image,PICTRectangle *rectangle)\n{\n  rectangle->top=(short) ReadBlobMSBShort(image);\n  rectangle->left=(short) ReadBlobMSBShort(image);\n  rectangle->bottom=(short) ReadBlobMSBShort(image);\n  rectangle->right=(short) ReadBlobMSBShort(image);\n  if ((EOFBlob(image) != MagickFalse) || (rectangle->left > rectangle->right) ||\n      (rectangle->top > rectangle->bottom))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  version=ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=1UL*(frame.right-frame.left);\n  image->rows=1UL*(frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n              Clipping rectangle.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length != 0x000a)\n              {\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=1UL*(frame.right-frame.left);\n            image->rows=1UL*(frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            (void) SetImageBackgroundColor(image,exception);\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=1L*ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (pattern != 1)\n              ThrowReaderException(CorruptImageError,\"UnknownPatternType\");\n            length=ReadBlobMSBShort(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            ReadPixmap(pixmap);\n            image->depth=1UL*pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n            (void) ReadBlobMSBLong(image);\n            flags=1L*ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            for (i=0; i <= (ssize_t) length; i++)\n              (void) ReadBlobMSBLong(image);\n            width=1UL*(frame.bottom-frame.top);\n            height=1UL*(frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (j=0; j < (int) height; j++)\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n              Skip polygon or region.\n            */\n            length=ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) (length-2); i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            Image\n              *tile_image;\n\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=1L*ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,1UL*(frame.right-frame.left),\n              1UL*(frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              return((Image *) NULL);\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                ReadPixmap(pixmap);\n                tile_image->depth=1UL*pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  image->alpha_trait=tile_image->alpha_trait;\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=1L*ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  {\n                    tile_image=DestroyImage(tile_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (ReadRectangle(image,&source) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                  Skip region.\n                */\n                length=ReadBlobMSBShort(image);\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1,&extent,\n                exception);\n            else\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1U*\n                pixmap.bits_per_pixel,&extent,exception);\n            if (pixels == (unsigned char *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  tile_image=DestroyImage(tile_image);\n                  ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=ConstrainColormapIndex(tile_image,*p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(*p++);\n                        j=(*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,y,tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if (jpeg == MagickFalse)\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,destination.left,destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n            */\n            type=ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length == 0)\n              break;\n            (void) ReadBlobMSBLong(image);\n            length-=4;\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              ThrowReaderException(ResourceLimitError,\"UnableToReadImageData\");\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        FILE\n          *file;\n\n        Image\n          *tile_image;\n\n        ImageInfo\n          *read_info;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(read_info->filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",image->filename);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=ReadBlobMSBLong(image);\n        if (length > 154)\n          {\n            for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              (void) fputc(c,file);\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          frame.left,frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n          Skip reserved.\n        */\n        length=ReadBlobMSBShort(image);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n          Skip reserved.\n        */\n        length=(size_t) ((code >> 7) & 0xff);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n#endif\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e g i s t e r P I C T I m a g e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RegisterPICTImage() adds attributes for the PICT image format to\n%  the list of supported formats.  The attributes include the image format\n%  tag, a method to read and/or write the format, whether the format\n%  supports the saving of more than one frame to the same file or blob,\n%  whether the format supports native in-memory I/O, and a brief\n%  description of the format.\n%\n%  The format of the RegisterPICTImage method is:\n%\n%      size_t RegisterPICTImage(void)\n%\n*/\nModuleExport size_t RegisterPICTImage(void)\n{\n  MagickInfo\n    *entry;\n\n  entry=AcquireMagickInfo(\"PICT\",\"PCT\",\"Apple Macintosh QuickDraw/PICT\");\n  entry->decoder=(DecodeImageHandler *) ReadPICTImage;\n  entry->encoder=(EncodeImageHandler *) WritePICTImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->magick=(IsImageFormatHandler *) IsPICT;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PICT\",\"PICT\",\"Apple Macintosh QuickDraw/PICT\");\n  entry->decoder=(DecodeImageHandler *) ReadPICTImage;\n  entry->encoder=(EncodeImageHandler *) WritePICTImage;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->magick=(IsImageFormatHandler *) IsPICT;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   U n r e g i s t e r P I C T I m a g e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  UnregisterPICTImage() removes format registrations made by the\n%  PICT module from the list of supported formats.\n%\n%  The format of the UnregisterPICTImage method is:\n%\n%      UnregisterPICTImage(void)\n%\n*/\nModuleExport void UnregisterPICTImage(void)\n{\n  (void) UnregisterMagickInfo(\"PCT\");\n  (void) UnregisterMagickInfo(\"PICT\");\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   W r i t e P I C T I m a g e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePICTImage() writes an image to a file in the Apple Macintosh\n%  QuickDraw/PICT image format.\n%\n%  The format of the WritePICTImage method is:\n%\n%      MagickBooleanType WritePICTImage(const ImageInfo *image_info,\n%        Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows.\n%\n%    o image_info: the image info.\n%\n%    o image:  The image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePICTImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define MaxCount  128\n#define PictCropRegionOp  0x01\n#define PictEndOfPictureOp  0xff\n#define PictJPEGOp  0x8200\n#define PictInfoOp  0x0C00\n#define PictInfoSize  512\n#define PictPixmapOp  0x9A\n#define PictPICTOp  0x98\n#define PictVersion  0x11\n\n  const StringInfo\n    *profile;\n\n  double\n    x_resolution,\n    y_resolution;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  PICTPixmap\n    pixmap;\n\n  PICTRectangle\n    bounds,\n    crop_rectangle,\n    destination_rectangle,\n    frame_rectangle,\n    size_rectangle,\n    source_rectangle;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    bytes_per_line,\n    count,\n    row_bytes,\n    storage_class;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *packed_scanline,\n    *scanline;\n\n  unsigned short\n    base_address,\n    transfer_mode;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Initialize image info.\n  */\n  size_rectangle.top=0;\n  size_rectangle.left=0;\n  size_rectangle.bottom=(short) image->rows;\n  size_rectangle.right=(short) image->columns;\n  frame_rectangle=size_rectangle;\n  crop_rectangle=size_rectangle;\n  source_rectangle=size_rectangle;\n  destination_rectangle=size_rectangle;\n  base_address=0xff;\n  row_bytes=image->columns;\n  bounds.top=0;\n  bounds.left=0;\n  bounds.bottom=(short) image->rows;\n  bounds.right=(short) image->columns;\n  pixmap.version=0;\n  pixmap.pack_type=0;\n  pixmap.pack_size=0;\n  pixmap.pixel_type=0;\n  pixmap.bits_per_pixel=8;\n  pixmap.component_count=1;\n  pixmap.component_size=8;\n  pixmap.plane_bytes=0;\n  pixmap.table=0;\n  pixmap.reserved=0;\n  transfer_mode=0;\n  x_resolution=image->resolution.x != 0.0 ? image->resolution.x :\n    DefaultResolution;\n  y_resolution=image->resolution.y != 0.0 ? image->resolution.y :\n    DefaultResolution;\n  storage_class=image->storage_class;\n  if (image_info->compression == JPEGCompression)\n    storage_class=DirectClass;\n  if (storage_class == DirectClass)\n    {\n      pixmap.component_count=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n      pixmap.pixel_type=16;\n      pixmap.bits_per_pixel=32;\n      pixmap.pack_type=0x04;\n      transfer_mode=0x40;\n      row_bytes=4*image->columns;\n    }\n  /*\n    Allocate memory.\n  */\n  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    {\n      if (scanline != (unsigned char *) NULL)\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      if (packed_scanline != (unsigned char *) NULL)\n        packed_scanline=(unsigned char *) RelinquishMagickMemory(\n          packed_scanline);\n      if (buffer != (unsigned char *) NULL)\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.right);\n  (void) WriteBlobMSBShort(image,PictVersion);\n  (void) WriteBlobMSBShort(image,0x02ff);  /* version #2 */\n  (void) WriteBlobMSBShort(image,PictInfoOp);\n  (void) WriteBlobMSBLong(image,0xFFFE0000UL);\n  /*\n    Write full size of the file, resolution, frame bounding box, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.right);\n  (void) WriteBlobMSBLong(image,0x00000000L);\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0x1f2);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobString(image,\"8BIM\");\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    }\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,4);\n      (void) WriteBlobMSBLong(image,0x00000002UL);\n    }\n  /*\n    Write crop region opcode and crop bounding box.\n  */\n  (void) WriteBlobMSBShort(image,PictCropRegionOp);\n  (void) WriteBlobMSBShort(image,0xa);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.right);\n  if (image_info->compression == JPEGCompression)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *jpeg_info;\n\n      size_t\n        length;\n\n      unsigned char\n        *blob;\n\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image == (Image *) NULL)\n        {\n          (void) CloseBlob(image);\n          return(MagickFalse);\n        }\n      jpeg_info=CloneImageInfo(image_info);\n      (void) CopyMagickString(jpeg_info->magick,\"JPEG\",MagickPathExtent);\n      length=0;\n      blob=(unsigned char *) ImageToBlob(jpeg_info,jpeg_image,&length,\n        exception);\n      jpeg_info=DestroyImageInfo(jpeg_info);\n      if (blob == (unsigned char *) NULL)\n        return(MagickFalse);\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) WriteBlobMSBShort(image,PictJPEGOp);\n      (void) WriteBlobMSBLong(image,(unsigned int) length+154);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x40000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00400000UL);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00566A70UL);\n      (void) WriteBlobMSBLong(image,0x65670000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000001UL);\n      (void) WriteBlobMSBLong(image,0x00016170UL);\n      (void) WriteBlobMSBLong(image,0x706C0000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x87AC0001UL);\n      (void) WriteBlobMSBLong(image,0x0B466F74UL);\n      (void) WriteBlobMSBLong(image,0x6F202D20UL);\n      (void) WriteBlobMSBLong(image,0x4A504547UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x0018FFFFUL);\n      (void) WriteBlob(image,length,blob);\n      if ((length & 0x01) != 0)\n        (void) WriteBlobByte(image,'\\0');\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n  /*\n    Write picture opcode, row bytes, and picture bounding box, and version.\n  */\n  if (storage_class == PseudoClass)\n    (void) WriteBlobMSBShort(image,PictPICTOp);\n  else\n    {\n      (void) WriteBlobMSBShort(image,PictPixmapOp);\n      (void) WriteBlobMSBLong(image,(size_t) base_address);\n    }\n  (void) WriteBlobMSBShort(image,(unsigned short) (row_bytes | 0x8000));\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.right);\n  /*\n    Write pack type, pack size, resolution, pixel type, and pixel size.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.version);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pack_type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.pack_size);\n  (void) WriteBlobMSBShort(image,(unsigned short) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pixel_type);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.bits_per_pixel);\n  /*\n    Write component count, size, plane bytes, table size, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_count);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_size);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.plane_bytes);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.table);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.reserved);\n  if (storage_class == PseudoClass)\n    {\n      /*\n        Write image colormap.\n      */\n      (void) WriteBlobMSBLong(image,0x00000000L);  /* color seed */\n      (void) WriteBlobMSBShort(image,0L);  /* color flags */\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->colors-1));\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        (void) WriteBlobMSBShort(image,(unsigned short) i);\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].red));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].green));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].blue));\n      }\n    }\n  /*\n    Write source and destination rectangle.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) transfer_mode);\n  /*\n    Write picture data.\n  */\n  count=0;\n  if (storage_class == PseudoClass)\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        scanline[x]=(unsigned char) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n      count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n        packed_scanline);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  else\n    if (image_info->compression == JPEGCompression)\n      {\n        (void) ResetMagickMemory(scanline,0,row_bytes);\n        for (y=0; y < (ssize_t) image->rows; y++)\n          count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n            packed_scanline);\n      }\n    else\n      {\n        register unsigned char\n          *blue,\n          *green,\n          *opacity,\n          *red;\n\n        red=scanline;\n        green=scanline+image->columns;\n        blue=scanline+2*image->columns;\n        opacity=scanline+3*image->columns;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          red=scanline;\n          green=scanline+image->columns;\n          blue=scanline+2*image->columns;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              opacity=scanline;\n              red=scanline+image->columns;\n              green=scanline+2*image->columns;\n              blue=scanline+3*image->columns;\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *red++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *green++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *blue++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *opacity++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n          }\n          count+=EncodeImage(image,scanline,bytes_per_line,packed_scanline);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n  if ((count & 0x01) != 0)\n    (void) WriteBlobByte(image,'\\0');\n  (void) WriteBlobMSBShort(image,PictEndOfPictureOp);\n  offset=TellBlob(image);\n  offset=SeekBlob(image,512,SEEK_SET);\n  (void) WriteBlobMSBShort(image,(unsigned short) offset);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  packed_scanline=(unsigned char *) RelinquishMagickMemory(packed_scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n"], "filenames": ["coders/pict.c"], "buggy_code_start_loc": [1756], "buggy_code_end_loc": [1757], "fixing_code_start_loc": [1756], "fixing_code_end_loc": [1766], "type": "CWE-772", "message": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePICTImage in coders/pict.c.", "other": {"cve": {"id": "CVE-2017-12665", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-07T21:29:00.297", "lastModified": "2020-10-14T17:52:04.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePICTImage in coders/pict.c."}, {"lang": "es", "value": "ImageMagick 7.0.6-2 tiene una vulnerabilidad de filtrado de memoria en WritePICTImage en coders/pict.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-772"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.6-2:*:*:*:*:*:*:*", "matchCriteriaId": "7E47D35D-B2EB-4957-A0C8-7DE54233997F"}]}]}], "references": [{"url": "https://github.com/ImageMagick/ImageMagick/commit/c1b09bbec148f6ae11d0b686fdb89ac6dc0ab14e", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/577", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/c1b09bbec148f6ae11d0b686fdb89ac6dc0ab14e"}}