{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * The input core\n *\n * Copyright (c) 1999-2002 Vojtech Pavlik\n */\n\n\n#define pr_fmt(fmt) KBUILD_BASENAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/idr.h>\n#include <linux/input/mt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/major.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/poll.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include \"input-compat.h\"\n#include \"input-poller.h\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"Input core\");\nMODULE_LICENSE(\"GPL\");\n\n#define INPUT_MAX_CHAR_DEVICES\t\t1024\n#define INPUT_FIRST_DYNAMIC_DEV\t\t256\nstatic DEFINE_IDA(input_ida);\n\nstatic LIST_HEAD(input_dev_list);\nstatic LIST_HEAD(input_handler_list);\n\n/*\n * input_mutex protects access to both input_dev_list and input_handler_list.\n * This also causes input_[un]register_device and input_[un]register_handler\n * be mutually exclusive which simplifies locking in drivers implementing\n * input handlers.\n */\nstatic DEFINE_MUTEX(input_mutex);\n\nstatic const struct input_value input_value_sync = { EV_SYN, SYN_REPORT, 1 };\n\nstatic inline int is_event_supported(unsigned int code,\n\t\t\t\t     unsigned long *bm, unsigned int max)\n{\n\treturn code <= max && test_bit(code, bm);\n}\n\nstatic int input_defuzz_abs_event(int value, int old_val, int fuzz)\n{\n\tif (fuzz) {\n\t\tif (value > old_val - fuzz / 2 && value < old_val + fuzz / 2)\n\t\t\treturn old_val;\n\n\t\tif (value > old_val - fuzz && value < old_val + fuzz)\n\t\t\treturn (old_val * 3 + value) / 4;\n\n\t\tif (value > old_val - fuzz * 2 && value < old_val + fuzz * 2)\n\t\t\treturn (old_val + value) / 2;\n\t}\n\n\treturn value;\n}\n\nstatic void input_start_autorepeat(struct input_dev *dev, int code)\n{\n\tif (test_bit(EV_REP, dev->evbit) &&\n\t    dev->rep[REP_PERIOD] && dev->rep[REP_DELAY] &&\n\t    dev->timer.function) {\n\t\tdev->repeat_key = code;\n\t\tmod_timer(&dev->timer,\n\t\t\t  jiffies + msecs_to_jiffies(dev->rep[REP_DELAY]));\n\t}\n}\n\nstatic void input_stop_autorepeat(struct input_dev *dev)\n{\n\tdel_timer(&dev->timer);\n}\n\n/*\n * Pass event first through all filters and then, if event has not been\n * filtered out, through all open handles. This function is called with\n * dev->event_lock held and interrupts disabled.\n */\nstatic unsigned int input_to_handler(struct input_handle *handle,\n\t\t\tstruct input_value *vals, unsigned int count)\n{\n\tstruct input_handler *handler = handle->handler;\n\tstruct input_value *end = vals;\n\tstruct input_value *v;\n\n\tif (handler->filter) {\n\t\tfor (v = vals; v != vals + count; v++) {\n\t\t\tif (handler->filter(handle, v->type, v->code, v->value))\n\t\t\t\tcontinue;\n\t\t\tif (end != v)\n\t\t\t\t*end = *v;\n\t\t\tend++;\n\t\t}\n\t\tcount = end - vals;\n\t}\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (handler->events)\n\t\thandler->events(handle, vals, count);\n\telse if (handler->event)\n\t\tfor (v = vals; v != vals + count; v++)\n\t\t\thandler->event(handle, v->type, v->code, v->value);\n\n\treturn count;\n}\n\n/*\n * Pass values first through all filters and then, if event has not been\n * filtered out, through all open handles. This function is called with\n * dev->event_lock held and interrupts disabled.\n */\nstatic void input_pass_values(struct input_dev *dev,\n\t\t\t      struct input_value *vals, unsigned int count)\n{\n\tstruct input_handle *handle;\n\tstruct input_value *v;\n\n\tif (!count)\n\t\treturn;\n\n\trcu_read_lock();\n\n\thandle = rcu_dereference(dev->grab);\n\tif (handle) {\n\t\tcount = input_to_handler(handle, vals, count);\n\t} else {\n\t\tlist_for_each_entry_rcu(handle, &dev->h_list, d_node)\n\t\t\tif (handle->open) {\n\t\t\t\tcount = input_to_handler(handle, vals, count);\n\t\t\t\tif (!count)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\t/* trigger auto repeat for key events */\n\tif (test_bit(EV_REP, dev->evbit) && test_bit(EV_KEY, dev->evbit)) {\n\t\tfor (v = vals; v != vals + count; v++) {\n\t\t\tif (v->type == EV_KEY && v->value != 2) {\n\t\t\t\tif (v->value)\n\t\t\t\t\tinput_start_autorepeat(dev, v->code);\n\t\t\t\telse\n\t\t\t\t\tinput_stop_autorepeat(dev);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void input_pass_event(struct input_dev *dev,\n\t\t\t     unsigned int type, unsigned int code, int value)\n{\n\tstruct input_value vals[] = { { type, code, value } };\n\n\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n}\n\n/*\n * Generate software autorepeat event. Note that we take\n * dev->event_lock here to avoid racing with input_event\n * which may cause keys get \"stuck\".\n */\nstatic void input_repeat_key(struct timer_list *t)\n{\n\tstruct input_dev *dev = from_timer(dev, t, timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\tif (test_bit(dev->repeat_key, dev->key) &&\n\t    is_event_supported(dev->repeat_key, dev->keybit, KEY_MAX)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, dev->repeat_key, 2 },\n\t\t\tinput_value_sync\n\t\t};\n\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\n\t\tif (dev->rep[REP_PERIOD])\n\t\t\tmod_timer(&dev->timer, jiffies +\n\t\t\t\t\tmsecs_to_jiffies(dev->rep[REP_PERIOD]));\n\t}\n\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\n#define INPUT_IGNORE_EVENT\t0\n#define INPUT_PASS_TO_HANDLERS\t1\n#define INPUT_PASS_TO_DEVICE\t2\n#define INPUT_SLOT\t\t4\n#define INPUT_FLUSH\t\t8\n#define INPUT_PASS_TO_ALL\t(INPUT_PASS_TO_HANDLERS | INPUT_PASS_TO_DEVICE)\n\nstatic int input_handle_abs_event(struct input_dev *dev,\n\t\t\t\t  unsigned int code, int *pval)\n{\n\tstruct input_mt *mt = dev->mt;\n\tbool is_mt_event;\n\tint *pold;\n\n\tif (code == ABS_MT_SLOT) {\n\t\t/*\n\t\t * \"Stage\" the event; we'll flush it later, when we\n\t\t * get actual touch data.\n\t\t */\n\t\tif (mt && *pval >= 0 && *pval < mt->num_slots)\n\t\t\tmt->slot = *pval;\n\n\t\treturn INPUT_IGNORE_EVENT;\n\t}\n\n\tis_mt_event = input_is_mt_value(code);\n\n\tif (!is_mt_event) {\n\t\tpold = &dev->absinfo[code].value;\n\t} else if (mt) {\n\t\tpold = &mt->slots[mt->slot].abs[code - ABS_MT_FIRST];\n\t} else {\n\t\t/*\n\t\t * Bypass filtering for multi-touch events when\n\t\t * not employing slots.\n\t\t */\n\t\tpold = NULL;\n\t}\n\n\tif (pold) {\n\t\t*pval = input_defuzz_abs_event(*pval, *pold,\n\t\t\t\t\t\tdev->absinfo[code].fuzz);\n\t\tif (*pold == *pval)\n\t\t\treturn INPUT_IGNORE_EVENT;\n\n\t\t*pold = *pval;\n\t}\n\n\t/* Flush pending \"slot\" event */\n\tif (is_mt_event && mt && mt->slot != input_abs_get_val(dev, ABS_MT_SLOT)) {\n\t\tinput_abs_set_val(dev, ABS_MT_SLOT, mt->slot);\n\t\treturn INPUT_PASS_TO_HANDLERS | INPUT_SLOT;\n\t}\n\n\treturn INPUT_PASS_TO_HANDLERS;\n}\n\nstatic int input_get_disposition(struct input_dev *dev,\n\t\t\t  unsigned int type, unsigned int code, int *pval)\n{\n\tint disposition = INPUT_IGNORE_EVENT;\n\tint value = *pval;\n\n\tswitch (type) {\n\n\tcase EV_SYN:\n\t\tswitch (code) {\n\t\tcase SYN_CONFIG:\n\t\t\tdisposition = INPUT_PASS_TO_ALL;\n\t\t\tbreak;\n\n\t\tcase SYN_REPORT:\n\t\t\tdisposition = INPUT_PASS_TO_HANDLERS | INPUT_FLUSH;\n\t\t\tbreak;\n\t\tcase SYN_MT_REPORT:\n\t\t\tdisposition = INPUT_PASS_TO_HANDLERS;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase EV_KEY:\n\t\tif (is_event_supported(code, dev->keybit, KEY_MAX)) {\n\n\t\t\t/* auto-repeat bypasses state updates */\n\t\t\tif (value == 2) {\n\t\t\t\tdisposition = INPUT_PASS_TO_HANDLERS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!!test_bit(code, dev->key) != !!value) {\n\n\t\t\t\t__change_bit(code, dev->key);\n\t\t\t\tdisposition = INPUT_PASS_TO_HANDLERS;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase EV_SW:\n\t\tif (is_event_supported(code, dev->swbit, SW_MAX) &&\n\t\t    !!test_bit(code, dev->sw) != !!value) {\n\n\t\t\t__change_bit(code, dev->sw);\n\t\t\tdisposition = INPUT_PASS_TO_HANDLERS;\n\t\t}\n\t\tbreak;\n\n\tcase EV_ABS:\n\t\tif (is_event_supported(code, dev->absbit, ABS_MAX))\n\t\t\tdisposition = input_handle_abs_event(dev, code, &value);\n\n\t\tbreak;\n\n\tcase EV_REL:\n\t\tif (is_event_supported(code, dev->relbit, REL_MAX) && value)\n\t\t\tdisposition = INPUT_PASS_TO_HANDLERS;\n\n\t\tbreak;\n\n\tcase EV_MSC:\n\t\tif (is_event_supported(code, dev->mscbit, MSC_MAX))\n\t\t\tdisposition = INPUT_PASS_TO_ALL;\n\n\t\tbreak;\n\n\tcase EV_LED:\n\t\tif (is_event_supported(code, dev->ledbit, LED_MAX) &&\n\t\t    !!test_bit(code, dev->led) != !!value) {\n\n\t\t\t__change_bit(code, dev->led);\n\t\t\tdisposition = INPUT_PASS_TO_ALL;\n\t\t}\n\t\tbreak;\n\n\tcase EV_SND:\n\t\tif (is_event_supported(code, dev->sndbit, SND_MAX)) {\n\n\t\t\tif (!!test_bit(code, dev->snd) != !!value)\n\t\t\t\t__change_bit(code, dev->snd);\n\t\t\tdisposition = INPUT_PASS_TO_ALL;\n\t\t}\n\t\tbreak;\n\n\tcase EV_REP:\n\t\tif (code <= REP_MAX && value >= 0 && dev->rep[code] != value) {\n\t\t\tdev->rep[code] = value;\n\t\t\tdisposition = INPUT_PASS_TO_ALL;\n\t\t}\n\t\tbreak;\n\n\tcase EV_FF:\n\t\tif (value >= 0)\n\t\t\tdisposition = INPUT_PASS_TO_ALL;\n\t\tbreak;\n\n\tcase EV_PWR:\n\t\tdisposition = INPUT_PASS_TO_ALL;\n\t\tbreak;\n\t}\n\n\t*pval = value;\n\treturn disposition;\n}\n\nstatic void input_handle_event(struct input_dev *dev,\n\t\t\t       unsigned int type, unsigned int code, int value)\n{\n\tint disposition = input_get_disposition(dev, type, code, &value);\n\n\tif (disposition != INPUT_IGNORE_EVENT && type != EV_SYN)\n\t\tadd_input_randomness(type, code, value);\n\n\tif ((disposition & INPUT_PASS_TO_DEVICE) && dev->event)\n\t\tdev->event(dev, type, code, value);\n\n\tif (!dev->vals)\n\t\treturn;\n\n\tif (disposition & INPUT_PASS_TO_HANDLERS) {\n\t\tstruct input_value *v;\n\n\t\tif (disposition & INPUT_SLOT) {\n\t\t\tv = &dev->vals[dev->num_vals++];\n\t\t\tv->type = EV_ABS;\n\t\t\tv->code = ABS_MT_SLOT;\n\t\t\tv->value = dev->mt->slot;\n\t\t}\n\n\t\tv = &dev->vals[dev->num_vals++];\n\t\tv->type = type;\n\t\tv->code = code;\n\t\tv->value = value;\n\t}\n\n\tif (disposition & INPUT_FLUSH) {\n\t\tif (dev->num_vals >= 2)\n\t\t\tinput_pass_values(dev, dev->vals, dev->num_vals);\n\t\tdev->num_vals = 0;\n\t\t/*\n\t\t * Reset the timestamp on flush so we won't end up\n\t\t * with a stale one. Note we only need to reset the\n\t\t * monolithic one as we use its presence when deciding\n\t\t * whether to generate a synthetic timestamp.\n\t\t */\n\t\tdev->timestamp[INPUT_CLK_MONO] = ktime_set(0, 0);\n\t} else if (dev->num_vals >= dev->max_vals - 2) {\n\t\tdev->vals[dev->num_vals++] = input_value_sync;\n\t\tinput_pass_values(dev, dev->vals, dev->num_vals);\n\t\tdev->num_vals = 0;\n\t}\n\n}\n\n/**\n * input_event() - report new input event\n * @dev: device that generated the event\n * @type: type of the event\n * @code: event code\n * @value: value of the event\n *\n * This function should be used by drivers implementing various input\n * devices to report input events. See also input_inject_event().\n *\n * NOTE: input_event() may be safely used right after input device was\n * allocated with input_allocate_device(), even before it is registered\n * with input_register_device(), but the event will not reach any of the\n * input handlers. Such early invocation of input_event() may be used\n * to 'seed' initial state of a switch or initial position of absolute\n * axis, etc.\n */\nvoid input_event(struct input_dev *dev,\n\t\t unsigned int type, unsigned int code, int value)\n{\n\tunsigned long flags;\n\n\tif (is_event_supported(type, dev->evbit, EV_MAX)) {\n\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\tinput_handle_event(dev, type, code, value);\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n}\nEXPORT_SYMBOL(input_event);\n\n/**\n * input_inject_event() - send input event from input handler\n * @handle: input handle to send event through\n * @type: type of the event\n * @code: event code\n * @value: value of the event\n *\n * Similar to input_event() but will ignore event if device is\n * \"grabbed\" and handle injecting event is not the one that owns\n * the device.\n */\nvoid input_inject_event(struct input_handle *handle,\n\t\t\tunsigned int type, unsigned int code, int value)\n{\n\tstruct input_dev *dev = handle->dev;\n\tstruct input_handle *grab;\n\tunsigned long flags;\n\n\tif (is_event_supported(type, dev->evbit, EV_MAX)) {\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\t\trcu_read_lock();\n\t\tgrab = rcu_dereference(dev->grab);\n\t\tif (!grab || grab == handle)\n\t\t\tinput_handle_event(dev, type, code, value);\n\t\trcu_read_unlock();\n\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n}\nEXPORT_SYMBOL(input_inject_event);\n\n/**\n * input_alloc_absinfo - allocates array of input_absinfo structs\n * @dev: the input device emitting absolute events\n *\n * If the absinfo struct the caller asked for is already allocated, this\n * functions will not do anything.\n */\nvoid input_alloc_absinfo(struct input_dev *dev)\n{\n\tif (dev->absinfo)\n\t\treturn;\n\n\tdev->absinfo = kcalloc(ABS_CNT, sizeof(*dev->absinfo), GFP_KERNEL);\n\tif (!dev->absinfo) {\n\t\tdev_err(dev->dev.parent ?: &dev->dev,\n\t\t\t\"%s: unable to allocate memory\\n\", __func__);\n\t\t/*\n\t\t * We will handle this allocation failure in\n\t\t * input_register_device() when we refuse to register input\n\t\t * device with ABS bits but without absinfo.\n\t\t */\n\t}\n}\nEXPORT_SYMBOL(input_alloc_absinfo);\n\nvoid input_set_abs_params(struct input_dev *dev, unsigned int axis,\n\t\t\t  int min, int max, int fuzz, int flat)\n{\n\tstruct input_absinfo *absinfo;\n\n\tinput_alloc_absinfo(dev);\n\tif (!dev->absinfo)\n\t\treturn;\n\n\tabsinfo = &dev->absinfo[axis];\n\tabsinfo->minimum = min;\n\tabsinfo->maximum = max;\n\tabsinfo->fuzz = fuzz;\n\tabsinfo->flat = flat;\n\n\t__set_bit(EV_ABS, dev->evbit);\n\t__set_bit(axis, dev->absbit);\n}\nEXPORT_SYMBOL(input_set_abs_params);\n\n\n/**\n * input_grab_device - grabs device for exclusive use\n * @handle: input handle that wants to own the device\n *\n * When a device is grabbed by an input handle all events generated by\n * the device are delivered only to this handle. Also events injected\n * by other input handles are ignored while device is grabbed.\n */\nint input_grab_device(struct input_handle *handle)\n{\n\tstruct input_dev *dev = handle->dev;\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&dev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (dev->grab) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\trcu_assign_pointer(dev->grab, handle);\n\n out:\n\tmutex_unlock(&dev->mutex);\n\treturn retval;\n}\nEXPORT_SYMBOL(input_grab_device);\n\nstatic void __input_release_device(struct input_handle *handle)\n{\n\tstruct input_dev *dev = handle->dev;\n\tstruct input_handle *grabber;\n\n\tgrabber = rcu_dereference_protected(dev->grab,\n\t\t\t\t\t    lockdep_is_held(&dev->mutex));\n\tif (grabber == handle) {\n\t\trcu_assign_pointer(dev->grab, NULL);\n\t\t/* Make sure input_pass_event() notices that grab is gone */\n\t\tsynchronize_rcu();\n\n\t\tlist_for_each_entry(handle, &dev->h_list, d_node)\n\t\t\tif (handle->open && handle->handler->start)\n\t\t\t\thandle->handler->start(handle);\n\t}\n}\n\n/**\n * input_release_device - release previously grabbed device\n * @handle: input handle that owns the device\n *\n * Releases previously grabbed device so that other input handles can\n * start receiving input events. Upon release all handlers attached\n * to the device have their start() method called so they have a change\n * to synchronize device state with the rest of the system.\n */\nvoid input_release_device(struct input_handle *handle)\n{\n\tstruct input_dev *dev = handle->dev;\n\n\tmutex_lock(&dev->mutex);\n\t__input_release_device(handle);\n\tmutex_unlock(&dev->mutex);\n}\nEXPORT_SYMBOL(input_release_device);\n\n/**\n * input_open_device - open input device\n * @handle: handle through which device is being accessed\n *\n * This function should be called by input handlers when they\n * want to start receive events from given input device.\n */\nint input_open_device(struct input_handle *handle)\n{\n\tstruct input_dev *dev = handle->dev;\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&dev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (dev->going_away) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\thandle->open++;\n\n\tif (dev->users++) {\n\t\t/*\n\t\t * Device is already opened, so we can exit immediately and\n\t\t * report success.\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (dev->open) {\n\t\tretval = dev->open(dev);\n\t\tif (retval) {\n\t\t\tdev->users--;\n\t\t\thandle->open--;\n\t\t\t/*\n\t\t\t * Make sure we are not delivering any more events\n\t\t\t * through this handle\n\t\t\t */\n\t\t\tsynchronize_rcu();\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (dev->poller)\n\t\tinput_dev_poller_start(dev->poller);\n\n out:\n\tmutex_unlock(&dev->mutex);\n\treturn retval;\n}\nEXPORT_SYMBOL(input_open_device);\n\nint input_flush_device(struct input_handle *handle, struct file *file)\n{\n\tstruct input_dev *dev = handle->dev;\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&dev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (dev->flush)\n\t\tretval = dev->flush(dev, file);\n\n\tmutex_unlock(&dev->mutex);\n\treturn retval;\n}\nEXPORT_SYMBOL(input_flush_device);\n\n/**\n * input_close_device - close input device\n * @handle: handle through which device is being accessed\n *\n * This function should be called by input handlers when they\n * want to stop receive events from given input device.\n */\nvoid input_close_device(struct input_handle *handle)\n{\n\tstruct input_dev *dev = handle->dev;\n\n\tmutex_lock(&dev->mutex);\n\n\t__input_release_device(handle);\n\n\tif (!--dev->users) {\n\t\tif (dev->poller)\n\t\t\tinput_dev_poller_stop(dev->poller);\n\n\t\tif (dev->close)\n\t\t\tdev->close(dev);\n\t}\n\n\tif (!--handle->open) {\n\t\t/*\n\t\t * synchronize_rcu() makes sure that input_pass_event()\n\t\t * completed and that no more input events are delivered\n\t\t * through this handle\n\t\t */\n\t\tsynchronize_rcu();\n\t}\n\n\tmutex_unlock(&dev->mutex);\n}\nEXPORT_SYMBOL(input_close_device);\n\n/*\n * Simulate keyup events for all keys that are marked as pressed.\n * The function must be called with dev->event_lock held.\n */\nstatic void input_dev_release_keys(struct input_dev *dev)\n{\n\tbool need_sync = false;\n\tint code;\n\n\tif (is_event_supported(EV_KEY, dev->evbit, EV_MAX)) {\n\t\tfor_each_set_bit(code, dev->key, KEY_CNT) {\n\t\t\tinput_pass_event(dev, EV_KEY, code, 0);\n\t\t\tneed_sync = true;\n\t\t}\n\n\t\tif (need_sync)\n\t\t\tinput_pass_event(dev, EV_SYN, SYN_REPORT, 1);\n\n\t\tmemset(dev->key, 0, sizeof(dev->key));\n\t}\n}\n\n/*\n * Prepare device for unregistering\n */\nstatic void input_disconnect_device(struct input_dev *dev)\n{\n\tstruct input_handle *handle;\n\n\t/*\n\t * Mark device as going away. Note that we take dev->mutex here\n\t * not to protect access to dev->going_away but rather to ensure\n\t * that there are no threads in the middle of input_open_device()\n\t */\n\tmutex_lock(&dev->mutex);\n\tdev->going_away = true;\n\tmutex_unlock(&dev->mutex);\n\n\tspin_lock_irq(&dev->event_lock);\n\n\t/*\n\t * Simulate keyup events for all pressed keys so that handlers\n\t * are not left with \"stuck\" keys. The driver may continue\n\t * generate events even after we done here but they will not\n\t * reach any handlers.\n\t */\n\tinput_dev_release_keys(dev);\n\n\tlist_for_each_entry(handle, &dev->h_list, d_node)\n\t\thandle->open = 0;\n\n\tspin_unlock_irq(&dev->event_lock);\n}\n\n/**\n * input_scancode_to_scalar() - converts scancode in &struct input_keymap_entry\n * @ke: keymap entry containing scancode to be converted.\n * @scancode: pointer to the location where converted scancode should\n *\tbe stored.\n *\n * This function is used to convert scancode stored in &struct keymap_entry\n * into scalar form understood by legacy keymap handling methods. These\n * methods expect scancodes to be represented as 'unsigned int'.\n */\nint input_scancode_to_scalar(const struct input_keymap_entry *ke,\n\t\t\t     unsigned int *scancode)\n{\n\tswitch (ke->len) {\n\tcase 1:\n\t\t*scancode = *((u8 *)ke->scancode);\n\t\tbreak;\n\n\tcase 2:\n\t\t*scancode = *((u16 *)ke->scancode);\n\t\tbreak;\n\n\tcase 4:\n\t\t*scancode = *((u32 *)ke->scancode);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(input_scancode_to_scalar);\n\n/*\n * Those routines handle the default case where no [gs]etkeycode() is\n * defined. In this case, an array indexed by the scancode is used.\n */\n\nstatic unsigned int input_fetch_keycode(struct input_dev *dev,\n\t\t\t\t\tunsigned int index)\n{\n\tswitch (dev->keycodesize) {\n\tcase 1:\n\t\treturn ((u8 *)dev->keycode)[index];\n\n\tcase 2:\n\t\treturn ((u16 *)dev->keycode)[index];\n\n\tdefault:\n\t\treturn ((u32 *)dev->keycode)[index];\n\t}\n}\n\nstatic int input_default_getkeycode(struct input_dev *dev,\n\t\t\t\t    struct input_keymap_entry *ke)\n{\n\tunsigned int index;\n\tint error;\n\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX)\n\t\tindex = ke->index;\n\telse {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\n\tke->keycode = input_fetch_keycode(dev, index);\n\tke->index = index;\n\tke->len = sizeof(index);\n\tmemcpy(ke->scancode, &index, sizeof(index));\n\n\treturn 0;\n}\n\nstatic int input_default_setkeycode(struct input_dev *dev,\n\t\t\t\t    const struct input_keymap_entry *ke,\n\t\t\t\t    unsigned int *old_keycode)\n{\n\tunsigned int index;\n\tint error;\n\tint i;\n\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\n\tif (dev->keycodesize < sizeof(ke->keycode) &&\n\t\t\t(ke->keycode >> (dev->keycodesize * 8)))\n\t\treturn -EINVAL;\n\n\tswitch (dev->keycodesize) {\n\t\tcase 1: {\n\t\t\tu8 *k = (u8 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tu16 *k = (u16 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tu32 *k = (u32 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t__clear_bit(*old_keycode, dev->keybit);\n\t__set_bit(ke->keycode, dev->keybit);\n\n\tfor (i = 0; i < dev->keycodemax; i++) {\n\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n\t\t\t__set_bit(*old_keycode, dev->keybit);\n\t\t\tbreak; /* Setting the bit twice is useless, so break */\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * input_get_keycode - retrieve keycode currently mapped to a given scancode\n * @dev: input device which keymap is being queried\n * @ke: keymap entry\n *\n * This function should be called by anyone interested in retrieving current\n * keymap. Presently evdev handlers use it.\n */\nint input_get_keycode(struct input_dev *dev, struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->getkeycode(dev, ke);\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(input_get_keycode);\n\n/**\n * input_set_keycode - attribute a keycode to a given scancode\n * @dev: input device which keymap is being updated\n * @ke: new keymap entry\n *\n * This function should be called by anyone needing to update current\n * keymap. Presently keyboard and evdev handlers use it.\n */\nint input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\n\t/* Make sure KEY_RESERVED did not get enabled. */\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\n\t/*\n\t * Simulate keyup event if keycode is not present\n\t * in the keymap anymore\n\t */\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(input_set_keycode);\n\nbool input_match_device_id(const struct input_dev *dev,\n\t\t\t   const struct input_device_id *id)\n{\n\tif (id->flags & INPUT_DEVICE_ID_MATCH_BUS)\n\t\tif (id->bustype != dev->id.bustype)\n\t\t\treturn false;\n\n\tif (id->flags & INPUT_DEVICE_ID_MATCH_VENDOR)\n\t\tif (id->vendor != dev->id.vendor)\n\t\t\treturn false;\n\n\tif (id->flags & INPUT_DEVICE_ID_MATCH_PRODUCT)\n\t\tif (id->product != dev->id.product)\n\t\t\treturn false;\n\n\tif (id->flags & INPUT_DEVICE_ID_MATCH_VERSION)\n\t\tif (id->version != dev->id.version)\n\t\t\treturn false;\n\n\tif (!bitmap_subset(id->evbit, dev->evbit, EV_MAX) ||\n\t    !bitmap_subset(id->keybit, dev->keybit, KEY_MAX) ||\n\t    !bitmap_subset(id->relbit, dev->relbit, REL_MAX) ||\n\t    !bitmap_subset(id->absbit, dev->absbit, ABS_MAX) ||\n\t    !bitmap_subset(id->mscbit, dev->mscbit, MSC_MAX) ||\n\t    !bitmap_subset(id->ledbit, dev->ledbit, LED_MAX) ||\n\t    !bitmap_subset(id->sndbit, dev->sndbit, SND_MAX) ||\n\t    !bitmap_subset(id->ffbit, dev->ffbit, FF_MAX) ||\n\t    !bitmap_subset(id->swbit, dev->swbit, SW_MAX) ||\n\t    !bitmap_subset(id->propbit, dev->propbit, INPUT_PROP_MAX)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(input_match_device_id);\n\nstatic const struct input_device_id *input_match_device(struct input_handler *handler,\n\t\t\t\t\t\t\tstruct input_dev *dev)\n{\n\tconst struct input_device_id *id;\n\n\tfor (id = handler->id_table; id->flags || id->driver_info; id++) {\n\t\tif (input_match_device_id(dev, id) &&\n\t\t    (!handler->match || handler->match(handler, dev))) {\n\t\t\treturn id;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n{\n\tconst struct input_device_id *id;\n\tint error;\n\n\tid = input_match_device(handler, dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\terror = handler->connect(handler, dev, id);\n\tif (error && error != -ENODEV)\n\t\tpr_err(\"failed to attach handler %s to device %s, error: %d\\n\",\n\t\t       handler->name, kobject_name(&dev->dev.kobj), error);\n\n\treturn error;\n}\n\n#ifdef CONFIG_COMPAT\n\nstatic int input_bits_to_string(char *buf, int buf_size,\n\t\t\t\tunsigned long bits, bool skip_empty)\n{\n\tint len = 0;\n\n\tif (in_compat_syscall()) {\n\t\tu32 dword = bits >> 32;\n\t\tif (dword || !skip_empty)\n\t\t\tlen += snprintf(buf, buf_size, \"%x \", dword);\n\n\t\tdword = bits & 0xffffffffUL;\n\t\tif (dword || !skip_empty || len)\n\t\t\tlen += snprintf(buf + len, max(buf_size - len, 0),\n\t\t\t\t\t\"%x\", dword);\n\t} else {\n\t\tif (bits || !skip_empty)\n\t\t\tlen += snprintf(buf, buf_size, \"%lx\", bits);\n\t}\n\n\treturn len;\n}\n\n#else /* !CONFIG_COMPAT */\n\nstatic int input_bits_to_string(char *buf, int buf_size,\n\t\t\t\tunsigned long bits, bool skip_empty)\n{\n\treturn bits || !skip_empty ?\n\t\tsnprintf(buf, buf_size, \"%lx\", bits) : 0;\n}\n\n#endif\n\n#ifdef CONFIG_PROC_FS\n\nstatic struct proc_dir_entry *proc_bus_input_dir;\nstatic DECLARE_WAIT_QUEUE_HEAD(input_devices_poll_wait);\nstatic int input_devices_state;\n\nstatic inline void input_wakeup_procfs_readers(void)\n{\n\tinput_devices_state++;\n\twake_up(&input_devices_poll_wait);\n}\n\nstatic __poll_t input_proc_devices_poll(struct file *file, poll_table *wait)\n{\n\tpoll_wait(file, &input_devices_poll_wait, wait);\n\tif (file->f_version != input_devices_state) {\n\t\tfile->f_version = input_devices_state;\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn 0;\n}\n\nunion input_seq_state {\n\tstruct {\n\t\tunsigned short pos;\n\t\tbool mutex_acquired;\n\t};\n\tvoid *p;\n};\n\nstatic void *input_devices_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tunion input_seq_state *state = (union input_seq_state *)&seq->private;\n\tint error;\n\n\t/* We need to fit into seq->private pointer */\n\tBUILD_BUG_ON(sizeof(union input_seq_state) != sizeof(seq->private));\n\n\terror = mutex_lock_interruptible(&input_mutex);\n\tif (error) {\n\t\tstate->mutex_acquired = false;\n\t\treturn ERR_PTR(error);\n\t}\n\n\tstate->mutex_acquired = true;\n\n\treturn seq_list_start(&input_dev_list, *pos);\n}\n\nstatic void *input_devices_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &input_dev_list, pos);\n}\n\nstatic void input_seq_stop(struct seq_file *seq, void *v)\n{\n\tunion input_seq_state *state = (union input_seq_state *)&seq->private;\n\n\tif (state->mutex_acquired)\n\t\tmutex_unlock(&input_mutex);\n}\n\nstatic void input_seq_print_bitmap(struct seq_file *seq, const char *name,\n\t\t\t\t   unsigned long *bitmap, int max)\n{\n\tint i;\n\tbool skip_empty = true;\n\tchar buf[18];\n\n\tseq_printf(seq, \"B: %s=\", name);\n\n\tfor (i = BITS_TO_LONGS(max) - 1; i >= 0; i--) {\n\t\tif (input_bits_to_string(buf, sizeof(buf),\n\t\t\t\t\t bitmap[i], skip_empty)) {\n\t\t\tskip_empty = false;\n\t\t\tseq_printf(seq, \"%s%s\", buf, i > 0 ? \" \" : \"\");\n\t\t}\n\t}\n\n\t/*\n\t * If no output was produced print a single 0.\n\t */\n\tif (skip_empty)\n\t\tseq_putc(seq, '0');\n\n\tseq_putc(seq, '\\n');\n}\n\nstatic int input_devices_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct input_dev *dev = container_of(v, struct input_dev, node);\n\tconst char *path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n\tstruct input_handle *handle;\n\n\tseq_printf(seq, \"I: Bus=%04x Vendor=%04x Product=%04x Version=%04x\\n\",\n\t\t   dev->id.bustype, dev->id.vendor, dev->id.product, dev->id.version);\n\n\tseq_printf(seq, \"N: Name=\\\"%s\\\"\\n\", dev->name ? dev->name : \"\");\n\tseq_printf(seq, \"P: Phys=%s\\n\", dev->phys ? dev->phys : \"\");\n\tseq_printf(seq, \"S: Sysfs=%s\\n\", path ? path : \"\");\n\tseq_printf(seq, \"U: Uniq=%s\\n\", dev->uniq ? dev->uniq : \"\");\n\tseq_puts(seq, \"H: Handlers=\");\n\n\tlist_for_each_entry(handle, &dev->h_list, d_node)\n\t\tseq_printf(seq, \"%s \", handle->name);\n\tseq_putc(seq, '\\n');\n\n\tinput_seq_print_bitmap(seq, \"PROP\", dev->propbit, INPUT_PROP_MAX);\n\n\tinput_seq_print_bitmap(seq, \"EV\", dev->evbit, EV_MAX);\n\tif (test_bit(EV_KEY, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"KEY\", dev->keybit, KEY_MAX);\n\tif (test_bit(EV_REL, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"REL\", dev->relbit, REL_MAX);\n\tif (test_bit(EV_ABS, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"ABS\", dev->absbit, ABS_MAX);\n\tif (test_bit(EV_MSC, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"MSC\", dev->mscbit, MSC_MAX);\n\tif (test_bit(EV_LED, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"LED\", dev->ledbit, LED_MAX);\n\tif (test_bit(EV_SND, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"SND\", dev->sndbit, SND_MAX);\n\tif (test_bit(EV_FF, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"FF\", dev->ffbit, FF_MAX);\n\tif (test_bit(EV_SW, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"SW\", dev->swbit, SW_MAX);\n\n\tseq_putc(seq, '\\n');\n\n\tkfree(path);\n\treturn 0;\n}\n\nstatic const struct seq_operations input_devices_seq_ops = {\n\t.start\t= input_devices_seq_start,\n\t.next\t= input_devices_seq_next,\n\t.stop\t= input_seq_stop,\n\t.show\t= input_devices_seq_show,\n};\n\nstatic int input_proc_devices_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &input_devices_seq_ops);\n}\n\nstatic const struct file_operations input_devices_fileops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= input_proc_devices_open,\n\t.poll\t\t= input_proc_devices_poll,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic void *input_handlers_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tunion input_seq_state *state = (union input_seq_state *)&seq->private;\n\tint error;\n\n\t/* We need to fit into seq->private pointer */\n\tBUILD_BUG_ON(sizeof(union input_seq_state) != sizeof(seq->private));\n\n\terror = mutex_lock_interruptible(&input_mutex);\n\tif (error) {\n\t\tstate->mutex_acquired = false;\n\t\treturn ERR_PTR(error);\n\t}\n\n\tstate->mutex_acquired = true;\n\tstate->pos = *pos;\n\n\treturn seq_list_start(&input_handler_list, *pos);\n}\n\nstatic void *input_handlers_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tunion input_seq_state *state = (union input_seq_state *)&seq->private;\n\n\tstate->pos = *pos + 1;\n\treturn seq_list_next(v, &input_handler_list, pos);\n}\n\nstatic int input_handlers_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct input_handler *handler = container_of(v, struct input_handler, node);\n\tunion input_seq_state *state = (union input_seq_state *)&seq->private;\n\n\tseq_printf(seq, \"N: Number=%u Name=%s\", state->pos, handler->name);\n\tif (handler->filter)\n\t\tseq_puts(seq, \" (filter)\");\n\tif (handler->legacy_minors)\n\t\tseq_printf(seq, \" Minor=%d\", handler->minor);\n\tseq_putc(seq, '\\n');\n\n\treturn 0;\n}\n\nstatic const struct seq_operations input_handlers_seq_ops = {\n\t.start\t= input_handlers_seq_start,\n\t.next\t= input_handlers_seq_next,\n\t.stop\t= input_seq_stop,\n\t.show\t= input_handlers_seq_show,\n};\n\nstatic int input_proc_handlers_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &input_handlers_seq_ops);\n}\n\nstatic const struct file_operations input_handlers_fileops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= input_proc_handlers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic int __init input_proc_init(void)\n{\n\tstruct proc_dir_entry *entry;\n\n\tproc_bus_input_dir = proc_mkdir(\"bus/input\", NULL);\n\tif (!proc_bus_input_dir)\n\t\treturn -ENOMEM;\n\n\tentry = proc_create(\"devices\", 0, proc_bus_input_dir,\n\t\t\t    &input_devices_fileops);\n\tif (!entry)\n\t\tgoto fail1;\n\n\tentry = proc_create(\"handlers\", 0, proc_bus_input_dir,\n\t\t\t    &input_handlers_fileops);\n\tif (!entry)\n\t\tgoto fail2;\n\n\treturn 0;\n\n fail2:\tremove_proc_entry(\"devices\", proc_bus_input_dir);\n fail1: remove_proc_entry(\"bus/input\", NULL);\n\treturn -ENOMEM;\n}\n\nstatic void input_proc_exit(void)\n{\n\tremove_proc_entry(\"devices\", proc_bus_input_dir);\n\tremove_proc_entry(\"handlers\", proc_bus_input_dir);\n\tremove_proc_entry(\"bus/input\", NULL);\n}\n\n#else /* !CONFIG_PROC_FS */\nstatic inline void input_wakeup_procfs_readers(void) { }\nstatic inline int input_proc_init(void) { return 0; }\nstatic inline void input_proc_exit(void) { }\n#endif\n\n#define INPUT_DEV_STRING_ATTR_SHOW(name)\t\t\t\t\\\nstatic ssize_t input_dev_show_##name(struct device *dev,\t\t\\\n\t\t\t\t     struct device_attribute *attr,\t\\\n\t\t\t\t     char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct input_dev *input_dev = to_input_dev(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\t\t\t\\\n\t\t\t input_dev->name ? input_dev->name : \"\");\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(name, S_IRUGO, input_dev_show_##name, NULL)\n\nINPUT_DEV_STRING_ATTR_SHOW(name);\nINPUT_DEV_STRING_ATTR_SHOW(phys);\nINPUT_DEV_STRING_ATTR_SHOW(uniq);\n\nstatic int input_print_modalias_bits(char *buf, int size,\n\t\t\t\t     char name, unsigned long *bm,\n\t\t\t\t     unsigned int min_bit, unsigned int max_bit)\n{\n\tint len = 0, i;\n\n\tlen += snprintf(buf, max(size, 0), \"%c\", name);\n\tfor (i = min_bit; i < max_bit; i++)\n\t\tif (bm[BIT_WORD(i)] & BIT_MASK(i))\n\t\t\tlen += snprintf(buf + len, max(size - len, 0), \"%X,\", i);\n\treturn len;\n}\n\nstatic int input_print_modalias(char *buf, int size, struct input_dev *id,\n\t\t\t\tint add_cr)\n{\n\tint len;\n\n\tlen = snprintf(buf, max(size, 0),\n\t\t       \"input:b%04Xv%04Xp%04Xe%04X-\",\n\t\t       id->id.bustype, id->id.vendor,\n\t\t       id->id.product, id->id.version);\n\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'e', id->evbit, 0, EV_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'k', id->keybit, KEY_MIN_INTERESTING, KEY_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'r', id->relbit, 0, REL_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'a', id->absbit, 0, ABS_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'm', id->mscbit, 0, MSC_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'l', id->ledbit, 0, LED_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t's', id->sndbit, 0, SND_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'f', id->ffbit, 0, FF_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'w', id->swbit, 0, SW_MAX);\n\n\tif (add_cr)\n\t\tlen += snprintf(buf + len, max(size - len, 0), \"\\n\");\n\n\treturn len;\n}\n\nstatic ssize_t input_dev_show_modalias(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct input_dev *id = to_input_dev(dev);\n\tssize_t len;\n\n\tlen = input_print_modalias(buf, PAGE_SIZE, id, 1);\n\n\treturn min_t(int, len, PAGE_SIZE);\n}\nstatic DEVICE_ATTR(modalias, S_IRUGO, input_dev_show_modalias, NULL);\n\nstatic int input_print_bitmap(char *buf, int buf_size, unsigned long *bitmap,\n\t\t\t      int max, int add_cr);\n\nstatic ssize_t input_dev_show_properties(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct input_dev *input_dev = to_input_dev(dev);\n\tint len = input_print_bitmap(buf, PAGE_SIZE, input_dev->propbit,\n\t\t\t\t     INPUT_PROP_MAX, true);\n\treturn min_t(int, len, PAGE_SIZE);\n}\nstatic DEVICE_ATTR(properties, S_IRUGO, input_dev_show_properties, NULL);\n\nstatic struct attribute *input_dev_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_phys.attr,\n\t&dev_attr_uniq.attr,\n\t&dev_attr_modalias.attr,\n\t&dev_attr_properties.attr,\n\tNULL\n};\n\nstatic const struct attribute_group input_dev_attr_group = {\n\t.attrs\t= input_dev_attrs,\n};\n\n#define INPUT_DEV_ID_ATTR(name)\t\t\t\t\t\t\\\nstatic ssize_t input_dev_show_id_##name(struct device *dev,\t\t\\\n\t\t\t\t\tstruct device_attribute *attr,\t\\\n\t\t\t\t\tchar *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct input_dev *input_dev = to_input_dev(dev);\t\t\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%04x\\n\", input_dev->id.name);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(name, S_IRUGO, input_dev_show_id_##name, NULL)\n\nINPUT_DEV_ID_ATTR(bustype);\nINPUT_DEV_ID_ATTR(vendor);\nINPUT_DEV_ID_ATTR(product);\nINPUT_DEV_ID_ATTR(version);\n\nstatic struct attribute *input_dev_id_attrs[] = {\n\t&dev_attr_bustype.attr,\n\t&dev_attr_vendor.attr,\n\t&dev_attr_product.attr,\n\t&dev_attr_version.attr,\n\tNULL\n};\n\nstatic const struct attribute_group input_dev_id_attr_group = {\n\t.name\t= \"id\",\n\t.attrs\t= input_dev_id_attrs,\n};\n\nstatic int input_print_bitmap(char *buf, int buf_size, unsigned long *bitmap,\n\t\t\t      int max, int add_cr)\n{\n\tint i;\n\tint len = 0;\n\tbool skip_empty = true;\n\n\tfor (i = BITS_TO_LONGS(max) - 1; i >= 0; i--) {\n\t\tlen += input_bits_to_string(buf + len, max(buf_size - len, 0),\n\t\t\t\t\t    bitmap[i], skip_empty);\n\t\tif (len) {\n\t\t\tskip_empty = false;\n\t\t\tif (i > 0)\n\t\t\t\tlen += snprintf(buf + len, max(buf_size - len, 0), \" \");\n\t\t}\n\t}\n\n\t/*\n\t * If no output was produced print a single 0.\n\t */\n\tif (len == 0)\n\t\tlen = snprintf(buf, buf_size, \"%d\", 0);\n\n\tif (add_cr)\n\t\tlen += snprintf(buf + len, max(buf_size - len, 0), \"\\n\");\n\n\treturn len;\n}\n\n#define INPUT_DEV_CAP_ATTR(ev, bm)\t\t\t\t\t\\\nstatic ssize_t input_dev_show_cap_##bm(struct device *dev,\t\t\\\n\t\t\t\t       struct device_attribute *attr,\t\\\n\t\t\t\t       char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct input_dev *input_dev = to_input_dev(dev);\t\t\\\n\tint len = input_print_bitmap(buf, PAGE_SIZE,\t\t\t\\\n\t\t\t\t     input_dev->bm##bit, ev##_MAX,\t\\\n\t\t\t\t     true);\t\t\t\t\\\n\treturn min_t(int, len, PAGE_SIZE);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(bm, S_IRUGO, input_dev_show_cap_##bm, NULL)\n\nINPUT_DEV_CAP_ATTR(EV, ev);\nINPUT_DEV_CAP_ATTR(KEY, key);\nINPUT_DEV_CAP_ATTR(REL, rel);\nINPUT_DEV_CAP_ATTR(ABS, abs);\nINPUT_DEV_CAP_ATTR(MSC, msc);\nINPUT_DEV_CAP_ATTR(LED, led);\nINPUT_DEV_CAP_ATTR(SND, snd);\nINPUT_DEV_CAP_ATTR(FF, ff);\nINPUT_DEV_CAP_ATTR(SW, sw);\n\nstatic struct attribute *input_dev_caps_attrs[] = {\n\t&dev_attr_ev.attr,\n\t&dev_attr_key.attr,\n\t&dev_attr_rel.attr,\n\t&dev_attr_abs.attr,\n\t&dev_attr_msc.attr,\n\t&dev_attr_led.attr,\n\t&dev_attr_snd.attr,\n\t&dev_attr_ff.attr,\n\t&dev_attr_sw.attr,\n\tNULL\n};\n\nstatic const struct attribute_group input_dev_caps_attr_group = {\n\t.name\t= \"capabilities\",\n\t.attrs\t= input_dev_caps_attrs,\n};\n\nstatic const struct attribute_group *input_dev_attr_groups[] = {\n\t&input_dev_attr_group,\n\t&input_dev_id_attr_group,\n\t&input_dev_caps_attr_group,\n\t&input_poller_attribute_group,\n\tNULL\n};\n\nstatic void input_dev_release(struct device *device)\n{\n\tstruct input_dev *dev = to_input_dev(device);\n\n\tinput_ff_destroy(dev);\n\tinput_mt_destroy_slots(dev);\n\tkfree(dev->poller);\n\tkfree(dev->absinfo);\n\tkfree(dev->vals);\n\tkfree(dev);\n\n\tmodule_put(THIS_MODULE);\n}\n\n/*\n * Input uevent interface - loading event handlers based on\n * device bitfields.\n */\nstatic int input_add_uevent_bm_var(struct kobj_uevent_env *env,\n\t\t\t\t   const char *name, unsigned long *bitmap, int max)\n{\n\tint len;\n\n\tif (add_uevent_var(env, \"%s\", name))\n\t\treturn -ENOMEM;\n\n\tlen = input_print_bitmap(&env->buf[env->buflen - 1],\n\t\t\t\t sizeof(env->buf) - env->buflen,\n\t\t\t\t bitmap, max, false);\n\tif (len >= (sizeof(env->buf) - env->buflen))\n\t\treturn -ENOMEM;\n\n\tenv->buflen += len;\n\treturn 0;\n}\n\nstatic int input_add_uevent_modalias_var(struct kobj_uevent_env *env,\n\t\t\t\t\t struct input_dev *dev)\n{\n\tint len;\n\n\tif (add_uevent_var(env, \"MODALIAS=\"))\n\t\treturn -ENOMEM;\n\n\tlen = input_print_modalias(&env->buf[env->buflen - 1],\n\t\t\t\t   sizeof(env->buf) - env->buflen,\n\t\t\t\t   dev, 0);\n\tif (len >= (sizeof(env->buf) - env->buflen))\n\t\treturn -ENOMEM;\n\n\tenv->buflen += len;\n\treturn 0;\n}\n\n#define INPUT_ADD_HOTPLUG_VAR(fmt, val...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint err = add_uevent_var(env, fmt, val);\t\t\\\n\t\tif (err)\t\t\t\t\t\t\\\n\t\t\treturn err;\t\t\t\t\t\\\n\t} while (0)\n\n#define INPUT_ADD_HOTPLUG_BM_VAR(name, bm, max)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint err = input_add_uevent_bm_var(env, name, bm, max);\t\\\n\t\tif (err)\t\t\t\t\t\t\\\n\t\t\treturn err;\t\t\t\t\t\\\n\t} while (0)\n\n#define INPUT_ADD_HOTPLUG_MODALIAS_VAR(dev)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint err = input_add_uevent_modalias_var(env, dev);\t\\\n\t\tif (err)\t\t\t\t\t\t\\\n\t\t\treturn err;\t\t\t\t\t\\\n\t} while (0)\n\nstatic int input_dev_uevent(struct device *device, struct kobj_uevent_env *env)\n{\n\tstruct input_dev *dev = to_input_dev(device);\n\n\tINPUT_ADD_HOTPLUG_VAR(\"PRODUCT=%x/%x/%x/%x\",\n\t\t\t\tdev->id.bustype, dev->id.vendor,\n\t\t\t\tdev->id.product, dev->id.version);\n\tif (dev->name)\n\t\tINPUT_ADD_HOTPLUG_VAR(\"NAME=\\\"%s\\\"\", dev->name);\n\tif (dev->phys)\n\t\tINPUT_ADD_HOTPLUG_VAR(\"PHYS=\\\"%s\\\"\", dev->phys);\n\tif (dev->uniq)\n\t\tINPUT_ADD_HOTPLUG_VAR(\"UNIQ=\\\"%s\\\"\", dev->uniq);\n\n\tINPUT_ADD_HOTPLUG_BM_VAR(\"PROP=\", dev->propbit, INPUT_PROP_MAX);\n\n\tINPUT_ADD_HOTPLUG_BM_VAR(\"EV=\", dev->evbit, EV_MAX);\n\tif (test_bit(EV_KEY, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"KEY=\", dev->keybit, KEY_MAX);\n\tif (test_bit(EV_REL, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"REL=\", dev->relbit, REL_MAX);\n\tif (test_bit(EV_ABS, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"ABS=\", dev->absbit, ABS_MAX);\n\tif (test_bit(EV_MSC, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"MSC=\", dev->mscbit, MSC_MAX);\n\tif (test_bit(EV_LED, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"LED=\", dev->ledbit, LED_MAX);\n\tif (test_bit(EV_SND, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"SND=\", dev->sndbit, SND_MAX);\n\tif (test_bit(EV_FF, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"FF=\", dev->ffbit, FF_MAX);\n\tif (test_bit(EV_SW, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"SW=\", dev->swbit, SW_MAX);\n\n\tINPUT_ADD_HOTPLUG_MODALIAS_VAR(dev);\n\n\treturn 0;\n}\n\n#define INPUT_DO_TOGGLE(dev, type, bits, on)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint i;\t\t\t\t\t\t\t\\\n\t\tbool active;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (!test_bit(EV_##type, dev->evbit))\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor_each_set_bit(i, dev->bits##bit, type##_CNT) {\t\\\n\t\t\tactive = test_bit(i, dev->bits);\t\t\\\n\t\t\tif (!active && !on)\t\t\t\t\\\n\t\t\t\tcontinue;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t\tdev->event(dev, EV_##type, i, on ? active : 0);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic void input_dev_toggle(struct input_dev *dev, bool activate)\n{\n\tif (!dev->event)\n\t\treturn;\n\n\tINPUT_DO_TOGGLE(dev, LED, led, activate);\n\tINPUT_DO_TOGGLE(dev, SND, snd, activate);\n\n\tif (activate && test_bit(EV_REP, dev->evbit)) {\n\t\tdev->event(dev, EV_REP, REP_PERIOD, dev->rep[REP_PERIOD]);\n\t\tdev->event(dev, EV_REP, REP_DELAY, dev->rep[REP_DELAY]);\n\t}\n}\n\n/**\n * input_reset_device() - reset/restore the state of input device\n * @dev: input device whose state needs to be reset\n *\n * This function tries to reset the state of an opened input device and\n * bring internal state and state if the hardware in sync with each other.\n * We mark all keys as released, restore LED state, repeat rate, etc.\n */\nvoid input_reset_device(struct input_dev *dev)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&dev->mutex);\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\tinput_dev_toggle(dev, true);\n\tinput_dev_release_keys(dev);\n\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\tmutex_unlock(&dev->mutex);\n}\nEXPORT_SYMBOL(input_reset_device);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int input_dev_suspend(struct device *dev)\n{\n\tstruct input_dev *input_dev = to_input_dev(dev);\n\n\tspin_lock_irq(&input_dev->event_lock);\n\n\t/*\n\t * Keys that are pressed now are unlikely to be\n\t * still pressed when we resume.\n\t */\n\tinput_dev_release_keys(input_dev);\n\n\t/* Turn off LEDs and sounds, if any are active. */\n\tinput_dev_toggle(input_dev, false);\n\n\tspin_unlock_irq(&input_dev->event_lock);\n\n\treturn 0;\n}\n\nstatic int input_dev_resume(struct device *dev)\n{\n\tstruct input_dev *input_dev = to_input_dev(dev);\n\n\tspin_lock_irq(&input_dev->event_lock);\n\n\t/* Restore state of LEDs and sounds, if any were active. */\n\tinput_dev_toggle(input_dev, true);\n\n\tspin_unlock_irq(&input_dev->event_lock);\n\n\treturn 0;\n}\n\nstatic int input_dev_freeze(struct device *dev)\n{\n\tstruct input_dev *input_dev = to_input_dev(dev);\n\n\tspin_lock_irq(&input_dev->event_lock);\n\n\t/*\n\t * Keys that are pressed now are unlikely to be\n\t * still pressed when we resume.\n\t */\n\tinput_dev_release_keys(input_dev);\n\n\tspin_unlock_irq(&input_dev->event_lock);\n\n\treturn 0;\n}\n\nstatic int input_dev_poweroff(struct device *dev)\n{\n\tstruct input_dev *input_dev = to_input_dev(dev);\n\n\tspin_lock_irq(&input_dev->event_lock);\n\n\t/* Turn off LEDs and sounds, if any are active. */\n\tinput_dev_toggle(input_dev, false);\n\n\tspin_unlock_irq(&input_dev->event_lock);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops input_dev_pm_ops = {\n\t.suspend\t= input_dev_suspend,\n\t.resume\t\t= input_dev_resume,\n\t.freeze\t\t= input_dev_freeze,\n\t.poweroff\t= input_dev_poweroff,\n\t.restore\t= input_dev_resume,\n};\n#endif /* CONFIG_PM */\n\nstatic const struct device_type input_dev_type = {\n\t.groups\t\t= input_dev_attr_groups,\n\t.release\t= input_dev_release,\n\t.uevent\t\t= input_dev_uevent,\n#ifdef CONFIG_PM_SLEEP\n\t.pm\t\t= &input_dev_pm_ops,\n#endif\n};\n\nstatic char *input_devnode(struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"input/%s\", dev_name(dev));\n}\n\nstruct class input_class = {\n\t.name\t\t= \"input\",\n\t.devnode\t= input_devnode,\n};\nEXPORT_SYMBOL_GPL(input_class);\n\n/**\n * input_allocate_device - allocate memory for new input device\n *\n * Returns prepared struct input_dev or %NULL.\n *\n * NOTE: Use input_free_device() to free devices that have not been\n * registered; input_unregister_device() should be used for already\n * registered devices.\n */\nstruct input_dev *input_allocate_device(void)\n{\n\tstatic atomic_t input_no = ATOMIC_INIT(-1);\n\tstruct input_dev *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev) {\n\t\tdev->dev.type = &input_dev_type;\n\t\tdev->dev.class = &input_class;\n\t\tdevice_initialize(&dev->dev);\n\t\tmutex_init(&dev->mutex);\n\t\tspin_lock_init(&dev->event_lock);\n\t\ttimer_setup(&dev->timer, NULL, 0);\n\t\tINIT_LIST_HEAD(&dev->h_list);\n\t\tINIT_LIST_HEAD(&dev->node);\n\n\t\tdev_set_name(&dev->dev, \"input%lu\",\n\t\t\t     (unsigned long)atomic_inc_return(&input_no));\n\n\t\t__module_get(THIS_MODULE);\n\t}\n\n\treturn dev;\n}\nEXPORT_SYMBOL(input_allocate_device);\n\nstruct input_devres {\n\tstruct input_dev *input;\n};\n\nstatic int devm_input_device_match(struct device *dev, void *res, void *data)\n{\n\tstruct input_devres *devres = res;\n\n\treturn devres->input == data;\n}\n\nstatic void devm_input_device_release(struct device *dev, void *res)\n{\n\tstruct input_devres *devres = res;\n\tstruct input_dev *input = devres->input;\n\n\tdev_dbg(dev, \"%s: dropping reference to %s\\n\",\n\t\t__func__, dev_name(&input->dev));\n\tinput_put_device(input);\n}\n\n/**\n * devm_input_allocate_device - allocate managed input device\n * @dev: device owning the input device being created\n *\n * Returns prepared struct input_dev or %NULL.\n *\n * Managed input devices do not need to be explicitly unregistered or\n * freed as it will be done automatically when owner device unbinds from\n * its driver (or binding fails). Once managed input device is allocated,\n * it is ready to be set up and registered in the same fashion as regular\n * input device. There are no special devm_input_device_[un]register()\n * variants, regular ones work with both managed and unmanaged devices,\n * should you need them. In most cases however, managed input device need\n * not be explicitly unregistered or freed.\n *\n * NOTE: the owner device is set up as parent of input device and users\n * should not override it.\n */\nstruct input_dev *devm_input_allocate_device(struct device *dev)\n{\n\tstruct input_dev *input;\n\tstruct input_devres *devres;\n\n\tdevres = devres_alloc(devm_input_device_release,\n\t\t\t      sizeof(*devres), GFP_KERNEL);\n\tif (!devres)\n\t\treturn NULL;\n\n\tinput = input_allocate_device();\n\tif (!input) {\n\t\tdevres_free(devres);\n\t\treturn NULL;\n\t}\n\n\tinput->dev.parent = dev;\n\tinput->devres_managed = true;\n\n\tdevres->input = input;\n\tdevres_add(dev, devres);\n\n\treturn input;\n}\nEXPORT_SYMBOL(devm_input_allocate_device);\n\n/**\n * input_free_device - free memory occupied by input_dev structure\n * @dev: input device to free\n *\n * This function should only be used if input_register_device()\n * was not called yet or if it failed. Once device was registered\n * use input_unregister_device() and memory will be freed once last\n * reference to the device is dropped.\n *\n * Device should be allocated by input_allocate_device().\n *\n * NOTE: If there are references to the input device then memory\n * will not be freed until last reference is dropped.\n */\nvoid input_free_device(struct input_dev *dev)\n{\n\tif (dev) {\n\t\tif (dev->devres_managed)\n\t\t\tWARN_ON(devres_destroy(dev->dev.parent,\n\t\t\t\t\t\tdevm_input_device_release,\n\t\t\t\t\t\tdevm_input_device_match,\n\t\t\t\t\t\tdev));\n\t\tinput_put_device(dev);\n\t}\n}\nEXPORT_SYMBOL(input_free_device);\n\n/**\n * input_set_timestamp - set timestamp for input events\n * @dev: input device to set timestamp for\n * @timestamp: the time at which the event has occurred\n *   in CLOCK_MONOTONIC\n *\n * This function is intended to provide to the input system a more\n * accurate time of when an event actually occurred. The driver should\n * call this function as soon as a timestamp is acquired ensuring\n * clock conversions in input_set_timestamp are done correctly.\n *\n * The system entering suspend state between timestamp acquisition and\n * calling input_set_timestamp can result in inaccurate conversions.\n */\nvoid input_set_timestamp(struct input_dev *dev, ktime_t timestamp)\n{\n\tdev->timestamp[INPUT_CLK_MONO] = timestamp;\n\tdev->timestamp[INPUT_CLK_REAL] = ktime_mono_to_real(timestamp);\n\tdev->timestamp[INPUT_CLK_BOOT] = ktime_mono_to_any(timestamp,\n\t\t\t\t\t\t\t   TK_OFFS_BOOT);\n}\nEXPORT_SYMBOL(input_set_timestamp);\n\n/**\n * input_get_timestamp - get timestamp for input events\n * @dev: input device to get timestamp from\n *\n * A valid timestamp is a timestamp of non-zero value.\n */\nktime_t *input_get_timestamp(struct input_dev *dev)\n{\n\tconst ktime_t invalid_timestamp = ktime_set(0, 0);\n\n\tif (!ktime_compare(dev->timestamp[INPUT_CLK_MONO], invalid_timestamp))\n\t\tinput_set_timestamp(dev, ktime_get());\n\n\treturn dev->timestamp;\n}\nEXPORT_SYMBOL(input_get_timestamp);\n\n/**\n * input_set_capability - mark device as capable of a certain event\n * @dev: device that is capable of emitting or accepting event\n * @type: type of the event (EV_KEY, EV_REL, etc...)\n * @code: event code\n *\n * In addition to setting up corresponding bit in appropriate capability\n * bitmap the function also adjusts dev->evbit.\n */\nvoid input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code)\n{\n\tswitch (type) {\n\tcase EV_KEY:\n\t\t__set_bit(code, dev->keybit);\n\t\tbreak;\n\n\tcase EV_REL:\n\t\t__set_bit(code, dev->relbit);\n\t\tbreak;\n\n\tcase EV_ABS:\n\t\tinput_alloc_absinfo(dev);\n\t\tif (!dev->absinfo)\n\t\t\treturn;\n\n\t\t__set_bit(code, dev->absbit);\n\t\tbreak;\n\n\tcase EV_MSC:\n\t\t__set_bit(code, dev->mscbit);\n\t\tbreak;\n\n\tcase EV_SW:\n\t\t__set_bit(code, dev->swbit);\n\t\tbreak;\n\n\tcase EV_LED:\n\t\t__set_bit(code, dev->ledbit);\n\t\tbreak;\n\n\tcase EV_SND:\n\t\t__set_bit(code, dev->sndbit);\n\t\tbreak;\n\n\tcase EV_FF:\n\t\t__set_bit(code, dev->ffbit);\n\t\tbreak;\n\n\tcase EV_PWR:\n\t\t/* do nothing */\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"%s: unknown type %u (code %u)\\n\", __func__, type, code);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\t__set_bit(type, dev->evbit);\n}\nEXPORT_SYMBOL(input_set_capability);\n\nstatic unsigned int input_estimate_events_per_packet(struct input_dev *dev)\n{\n\tint mt_slots;\n\tint i;\n\tunsigned int events;\n\n\tif (dev->mt) {\n\t\tmt_slots = dev->mt->num_slots;\n\t} else if (test_bit(ABS_MT_TRACKING_ID, dev->absbit)) {\n\t\tmt_slots = dev->absinfo[ABS_MT_TRACKING_ID].maximum -\n\t\t\t   dev->absinfo[ABS_MT_TRACKING_ID].minimum + 1,\n\t\tmt_slots = clamp(mt_slots, 2, 32);\n\t} else if (test_bit(ABS_MT_POSITION_X, dev->absbit)) {\n\t\tmt_slots = 2;\n\t} else {\n\t\tmt_slots = 0;\n\t}\n\n\tevents = mt_slots + 1; /* count SYN_MT_REPORT and SYN_REPORT */\n\n\tif (test_bit(EV_ABS, dev->evbit))\n\t\tfor_each_set_bit(i, dev->absbit, ABS_CNT)\n\t\t\tevents += input_is_mt_axis(i) ? mt_slots : 1;\n\n\tif (test_bit(EV_REL, dev->evbit))\n\t\tevents += bitmap_weight(dev->relbit, REL_CNT);\n\n\t/* Make room for KEY and MSC events */\n\tevents += 7;\n\n\treturn events;\n}\n\n#define INPUT_CLEANSE_BITMASK(dev, type, bits)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!test_bit(EV_##type, dev->evbit))\t\t\t\\\n\t\t\tmemset(dev->bits##bit, 0,\t\t\t\\\n\t\t\t\tsizeof(dev->bits##bit));\t\t\\\n\t} while (0)\n\nstatic void input_cleanse_bitmasks(struct input_dev *dev)\n{\n\tINPUT_CLEANSE_BITMASK(dev, KEY, key);\n\tINPUT_CLEANSE_BITMASK(dev, REL, rel);\n\tINPUT_CLEANSE_BITMASK(dev, ABS, abs);\n\tINPUT_CLEANSE_BITMASK(dev, MSC, msc);\n\tINPUT_CLEANSE_BITMASK(dev, LED, led);\n\tINPUT_CLEANSE_BITMASK(dev, SND, snd);\n\tINPUT_CLEANSE_BITMASK(dev, FF, ff);\n\tINPUT_CLEANSE_BITMASK(dev, SW, sw);\n}\n\nstatic void __input_unregister_device(struct input_dev *dev)\n{\n\tstruct input_handle *handle, *next;\n\n\tinput_disconnect_device(dev);\n\n\tmutex_lock(&input_mutex);\n\n\tlist_for_each_entry_safe(handle, next, &dev->h_list, d_node)\n\t\thandle->handler->disconnect(handle);\n\tWARN_ON(!list_empty(&dev->h_list));\n\n\tdel_timer_sync(&dev->timer);\n\tlist_del_init(&dev->node);\n\n\tinput_wakeup_procfs_readers();\n\n\tmutex_unlock(&input_mutex);\n\n\tdevice_del(&dev->dev);\n}\n\nstatic void devm_input_device_unregister(struct device *dev, void *res)\n{\n\tstruct input_devres *devres = res;\n\tstruct input_dev *input = devres->input;\n\n\tdev_dbg(dev, \"%s: unregistering device %s\\n\",\n\t\t__func__, dev_name(&input->dev));\n\t__input_unregister_device(input);\n}\n\n/**\n * input_enable_softrepeat - enable software autorepeat\n * @dev: input device\n * @delay: repeat delay\n * @period: repeat period\n *\n * Enable software autorepeat on the input device.\n */\nvoid input_enable_softrepeat(struct input_dev *dev, int delay, int period)\n{\n\tdev->timer.function = input_repeat_key;\n\tdev->rep[REP_DELAY] = delay;\n\tdev->rep[REP_PERIOD] = period;\n}\nEXPORT_SYMBOL(input_enable_softrepeat);\n\n/**\n * input_register_device - register device with input core\n * @dev: device to be registered\n *\n * This function registers device with input core. The device must be\n * allocated with input_allocate_device() and all it's capabilities\n * set up before registering.\n * If function fails the device must be freed with input_free_device().\n * Once device has been successfully registered it can be unregistered\n * with input_unregister_device(); input_free_device() should not be\n * called in this case.\n *\n * Note that this function is also used to register managed input devices\n * (ones allocated with devm_input_allocate_device()). Such managed input\n * devices need not be explicitly unregistered or freed, their tear down\n * is controlled by the devres infrastructure. It is also worth noting\n * that tear down of managed input devices is internally a 2-step process:\n * registered managed input device is first unregistered, but stays in\n * memory and can still handle input_event() calls (although events will\n * not be delivered anywhere). The freeing of managed input device will\n * happen later, when devres stack is unwound to the point where device\n * allocation was made.\n */\nint input_register_device(struct input_dev *dev)\n{\n\tstruct input_devres *devres = NULL;\n\tstruct input_handler *handler;\n\tunsigned int packet_size;\n\tconst char *path;\n\tint error;\n\n\tif (test_bit(EV_ABS, dev->evbit) && !dev->absinfo) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Absolute device without dev->absinfo, refusing to register\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->devres_managed) {\n\t\tdevres = devres_alloc(devm_input_device_unregister,\n\t\t\t\t      sizeof(*devres), GFP_KERNEL);\n\t\tif (!devres)\n\t\t\treturn -ENOMEM;\n\n\t\tdevres->input = dev;\n\t}\n\n\t/* Every input device generates EV_SYN/SYN_REPORT events. */\n\t__set_bit(EV_SYN, dev->evbit);\n\n\t/* KEY_RESERVED is not supposed to be transmitted to userspace. */\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\n\t/* Make sure that bitmasks not mentioned in dev->evbit are clean. */\n\tinput_cleanse_bitmasks(dev);\n\n\tpacket_size = input_estimate_events_per_packet(dev);\n\tif (dev->hint_events_per_packet < packet_size)\n\t\tdev->hint_events_per_packet = packet_size;\n\n\tdev->max_vals = dev->hint_events_per_packet + 2;\n\tdev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);\n\tif (!dev->vals) {\n\t\terror = -ENOMEM;\n\t\tgoto err_devres_free;\n\t}\n\n\t/*\n\t * If delay and period are pre-set by the driver, then autorepeating\n\t * is handled by the driver itself and we don't do it in input.c.\n\t */\n\tif (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD])\n\t\tinput_enable_softrepeat(dev, 250, 33);\n\n\tif (!dev->getkeycode)\n\t\tdev->getkeycode = input_default_getkeycode;\n\n\tif (!dev->setkeycode)\n\t\tdev->setkeycode = input_default_setkeycode;\n\n\tif (dev->poller)\n\t\tinput_dev_poller_finalize(dev->poller);\n\n\terror = device_add(&dev->dev);\n\tif (error)\n\t\tgoto err_free_vals;\n\n\tpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n\tpr_info(\"%s as %s\\n\",\n\t\tdev->name ? dev->name : \"Unspecified device\",\n\t\tpath ? path : \"N/A\");\n\tkfree(path);\n\n\terror = mutex_lock_interruptible(&input_mutex);\n\tif (error)\n\t\tgoto err_device_del;\n\n\tlist_add_tail(&dev->node, &input_dev_list);\n\n\tlist_for_each_entry(handler, &input_handler_list, node)\n\t\tinput_attach_handler(dev, handler);\n\n\tinput_wakeup_procfs_readers();\n\n\tmutex_unlock(&input_mutex);\n\n\tif (dev->devres_managed) {\n\t\tdev_dbg(dev->dev.parent, \"%s: registering %s with devres.\\n\",\n\t\t\t__func__, dev_name(&dev->dev));\n\t\tdevres_add(dev->dev.parent, devres);\n\t}\n\treturn 0;\n\nerr_device_del:\n\tdevice_del(&dev->dev);\nerr_free_vals:\n\tkfree(dev->vals);\n\tdev->vals = NULL;\nerr_devres_free:\n\tdevres_free(devres);\n\treturn error;\n}\nEXPORT_SYMBOL(input_register_device);\n\n/**\n * input_unregister_device - unregister previously registered device\n * @dev: device to be unregistered\n *\n * This function unregisters an input device. Once device is unregistered\n * the caller should not try to access it as it may get freed at any moment.\n */\nvoid input_unregister_device(struct input_dev *dev)\n{\n\tif (dev->devres_managed) {\n\t\tWARN_ON(devres_destroy(dev->dev.parent,\n\t\t\t\t\tdevm_input_device_unregister,\n\t\t\t\t\tdevm_input_device_match,\n\t\t\t\t\tdev));\n\t\t__input_unregister_device(dev);\n\t\t/*\n\t\t * We do not do input_put_device() here because it will be done\n\t\t * when 2nd devres fires up.\n\t\t */\n\t} else {\n\t\t__input_unregister_device(dev);\n\t\tinput_put_device(dev);\n\t}\n}\nEXPORT_SYMBOL(input_unregister_device);\n\n/**\n * input_register_handler - register a new input handler\n * @handler: handler to be registered\n *\n * This function registers a new input handler (interface) for input\n * devices in the system and attaches it to all input devices that\n * are compatible with the handler.\n */\nint input_register_handler(struct input_handler *handler)\n{\n\tstruct input_dev *dev;\n\tint error;\n\n\terror = mutex_lock_interruptible(&input_mutex);\n\tif (error)\n\t\treturn error;\n\n\tINIT_LIST_HEAD(&handler->h_list);\n\n\tlist_add_tail(&handler->node, &input_handler_list);\n\n\tlist_for_each_entry(dev, &input_dev_list, node)\n\t\tinput_attach_handler(dev, handler);\n\n\tinput_wakeup_procfs_readers();\n\n\tmutex_unlock(&input_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(input_register_handler);\n\n/**\n * input_unregister_handler - unregisters an input handler\n * @handler: handler to be unregistered\n *\n * This function disconnects a handler from its input devices and\n * removes it from lists of known handlers.\n */\nvoid input_unregister_handler(struct input_handler *handler)\n{\n\tstruct input_handle *handle, *next;\n\n\tmutex_lock(&input_mutex);\n\n\tlist_for_each_entry_safe(handle, next, &handler->h_list, h_node)\n\t\thandler->disconnect(handle);\n\tWARN_ON(!list_empty(&handler->h_list));\n\n\tlist_del_init(&handler->node);\n\n\tinput_wakeup_procfs_readers();\n\n\tmutex_unlock(&input_mutex);\n}\nEXPORT_SYMBOL(input_unregister_handler);\n\n/**\n * input_handler_for_each_handle - handle iterator\n * @handler: input handler to iterate\n * @data: data for the callback\n * @fn: function to be called for each handle\n *\n * Iterate over @bus's list of devices, and call @fn for each, passing\n * it @data and stop when @fn returns a non-zero value. The function is\n * using RCU to traverse the list and therefore may be using in atomic\n * contexts. The @fn callback is invoked from RCU critical section and\n * thus must not sleep.\n */\nint input_handler_for_each_handle(struct input_handler *handler, void *data,\n\t\t\t\t  int (*fn)(struct input_handle *, void *))\n{\n\tstruct input_handle *handle;\n\tint retval = 0;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(handle, &handler->h_list, h_node) {\n\t\tretval = fn(handle, data);\n\t\tif (retval)\n\t\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\n\treturn retval;\n}\nEXPORT_SYMBOL(input_handler_for_each_handle);\n\n/**\n * input_register_handle - register a new input handle\n * @handle: handle to register\n *\n * This function puts a new input handle onto device's\n * and handler's lists so that events can flow through\n * it once it is opened using input_open_device().\n *\n * This function is supposed to be called from handler's\n * connect() method.\n */\nint input_register_handle(struct input_handle *handle)\n{\n\tstruct input_handler *handler = handle->handler;\n\tstruct input_dev *dev = handle->dev;\n\tint error;\n\n\t/*\n\t * We take dev->mutex here to prevent race with\n\t * input_release_device().\n\t */\n\terror = mutex_lock_interruptible(&dev->mutex);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Filters go to the head of the list, normal handlers\n\t * to the tail.\n\t */\n\tif (handler->filter)\n\t\tlist_add_rcu(&handle->d_node, &dev->h_list);\n\telse\n\t\tlist_add_tail_rcu(&handle->d_node, &dev->h_list);\n\n\tmutex_unlock(&dev->mutex);\n\n\t/*\n\t * Since we are supposed to be called from ->connect()\n\t * which is mutually exclusive with ->disconnect()\n\t * we can't be racing with input_unregister_handle()\n\t * and so separate lock is not needed here.\n\t */\n\tlist_add_tail_rcu(&handle->h_node, &handler->h_list);\n\n\tif (handler->start)\n\t\thandler->start(handle);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(input_register_handle);\n\n/**\n * input_unregister_handle - unregister an input handle\n * @handle: handle to unregister\n *\n * This function removes input handle from device's\n * and handler's lists.\n *\n * This function is supposed to be called from handler's\n * disconnect() method.\n */\nvoid input_unregister_handle(struct input_handle *handle)\n{\n\tstruct input_dev *dev = handle->dev;\n\n\tlist_del_rcu(&handle->h_node);\n\n\t/*\n\t * Take dev->mutex to prevent race with input_release_device().\n\t */\n\tmutex_lock(&dev->mutex);\n\tlist_del_rcu(&handle->d_node);\n\tmutex_unlock(&dev->mutex);\n\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL(input_unregister_handle);\n\n/**\n * input_get_new_minor - allocates a new input minor number\n * @legacy_base: beginning or the legacy range to be searched\n * @legacy_num: size of legacy range\n * @allow_dynamic: whether we can also take ID from the dynamic range\n *\n * This function allocates a new device minor for from input major namespace.\n * Caller can request legacy minor by specifying @legacy_base and @legacy_num\n * parameters and whether ID can be allocated from dynamic range if there are\n * no free IDs in legacy range.\n */\nint input_get_new_minor(int legacy_base, unsigned int legacy_num,\n\t\t\tbool allow_dynamic)\n{\n\t/*\n\t * This function should be called from input handler's ->connect()\n\t * methods, which are serialized with input_mutex, so no additional\n\t * locking is needed here.\n\t */\n\tif (legacy_base >= 0) {\n\t\tint minor = ida_simple_get(&input_ida,\n\t\t\t\t\t   legacy_base,\n\t\t\t\t\t   legacy_base + legacy_num,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (minor >= 0 || !allow_dynamic)\n\t\t\treturn minor;\n\t}\n\n\treturn ida_simple_get(&input_ida,\n\t\t\t      INPUT_FIRST_DYNAMIC_DEV, INPUT_MAX_CHAR_DEVICES,\n\t\t\t      GFP_KERNEL);\n}\nEXPORT_SYMBOL(input_get_new_minor);\n\n/**\n * input_free_minor - release previously allocated minor\n * @minor: minor to be released\n *\n * This function releases previously allocated input minor so that it can be\n * reused later.\n */\nvoid input_free_minor(unsigned int minor)\n{\n\tida_simple_remove(&input_ida, minor);\n}\nEXPORT_SYMBOL(input_free_minor);\n\nstatic int __init input_init(void)\n{\n\tint err;\n\n\terr = class_register(&input_class);\n\tif (err) {\n\t\tpr_err(\"unable to register input_dev class\\n\");\n\t\treturn err;\n\t}\n\n\terr = input_proc_init();\n\tif (err)\n\t\tgoto fail1;\n\n\terr = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),\n\t\t\t\t     INPUT_MAX_CHAR_DEVICES, \"input\");\n\tif (err) {\n\t\tpr_err(\"unable to register char major %d\", INPUT_MAJOR);\n\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\n fail2:\tinput_proc_exit();\n fail1:\tclass_unregister(&input_class);\n\treturn err;\n}\n\nstatic void __exit input_exit(void)\n{\n\tinput_proc_exit();\n\tunregister_chrdev_region(MKDEV(INPUT_MAJOR, 0),\n\t\t\t\t INPUT_MAX_CHAR_DEVICES);\n\tclass_unregister(&input_class);\n}\n\nsubsys_initcall(input_init);\nmodule_exit(input_exit);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * The input core\n *\n * Copyright (c) 1999-2002 Vojtech Pavlik\n */\n\n\n#define pr_fmt(fmt) KBUILD_BASENAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/idr.h>\n#include <linux/input/mt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/major.h>\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/poll.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include \"input-compat.h\"\n#include \"input-poller.h\"\n\nMODULE_AUTHOR(\"Vojtech Pavlik <vojtech@suse.cz>\");\nMODULE_DESCRIPTION(\"Input core\");\nMODULE_LICENSE(\"GPL\");\n\n#define INPUT_MAX_CHAR_DEVICES\t\t1024\n#define INPUT_FIRST_DYNAMIC_DEV\t\t256\nstatic DEFINE_IDA(input_ida);\n\nstatic LIST_HEAD(input_dev_list);\nstatic LIST_HEAD(input_handler_list);\n\n/*\n * input_mutex protects access to both input_dev_list and input_handler_list.\n * This also causes input_[un]register_device and input_[un]register_handler\n * be mutually exclusive which simplifies locking in drivers implementing\n * input handlers.\n */\nstatic DEFINE_MUTEX(input_mutex);\n\nstatic const struct input_value input_value_sync = { EV_SYN, SYN_REPORT, 1 };\n\nstatic inline int is_event_supported(unsigned int code,\n\t\t\t\t     unsigned long *bm, unsigned int max)\n{\n\treturn code <= max && test_bit(code, bm);\n}\n\nstatic int input_defuzz_abs_event(int value, int old_val, int fuzz)\n{\n\tif (fuzz) {\n\t\tif (value > old_val - fuzz / 2 && value < old_val + fuzz / 2)\n\t\t\treturn old_val;\n\n\t\tif (value > old_val - fuzz && value < old_val + fuzz)\n\t\t\treturn (old_val * 3 + value) / 4;\n\n\t\tif (value > old_val - fuzz * 2 && value < old_val + fuzz * 2)\n\t\t\treturn (old_val + value) / 2;\n\t}\n\n\treturn value;\n}\n\nstatic void input_start_autorepeat(struct input_dev *dev, int code)\n{\n\tif (test_bit(EV_REP, dev->evbit) &&\n\t    dev->rep[REP_PERIOD] && dev->rep[REP_DELAY] &&\n\t    dev->timer.function) {\n\t\tdev->repeat_key = code;\n\t\tmod_timer(&dev->timer,\n\t\t\t  jiffies + msecs_to_jiffies(dev->rep[REP_DELAY]));\n\t}\n}\n\nstatic void input_stop_autorepeat(struct input_dev *dev)\n{\n\tdel_timer(&dev->timer);\n}\n\n/*\n * Pass event first through all filters and then, if event has not been\n * filtered out, through all open handles. This function is called with\n * dev->event_lock held and interrupts disabled.\n */\nstatic unsigned int input_to_handler(struct input_handle *handle,\n\t\t\tstruct input_value *vals, unsigned int count)\n{\n\tstruct input_handler *handler = handle->handler;\n\tstruct input_value *end = vals;\n\tstruct input_value *v;\n\n\tif (handler->filter) {\n\t\tfor (v = vals; v != vals + count; v++) {\n\t\t\tif (handler->filter(handle, v->type, v->code, v->value))\n\t\t\t\tcontinue;\n\t\t\tif (end != v)\n\t\t\t\t*end = *v;\n\t\t\tend++;\n\t\t}\n\t\tcount = end - vals;\n\t}\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (handler->events)\n\t\thandler->events(handle, vals, count);\n\telse if (handler->event)\n\t\tfor (v = vals; v != vals + count; v++)\n\t\t\thandler->event(handle, v->type, v->code, v->value);\n\n\treturn count;\n}\n\n/*\n * Pass values first through all filters and then, if event has not been\n * filtered out, through all open handles. This function is called with\n * dev->event_lock held and interrupts disabled.\n */\nstatic void input_pass_values(struct input_dev *dev,\n\t\t\t      struct input_value *vals, unsigned int count)\n{\n\tstruct input_handle *handle;\n\tstruct input_value *v;\n\n\tif (!count)\n\t\treturn;\n\n\trcu_read_lock();\n\n\thandle = rcu_dereference(dev->grab);\n\tif (handle) {\n\t\tcount = input_to_handler(handle, vals, count);\n\t} else {\n\t\tlist_for_each_entry_rcu(handle, &dev->h_list, d_node)\n\t\t\tif (handle->open) {\n\t\t\t\tcount = input_to_handler(handle, vals, count);\n\t\t\t\tif (!count)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\t/* trigger auto repeat for key events */\n\tif (test_bit(EV_REP, dev->evbit) && test_bit(EV_KEY, dev->evbit)) {\n\t\tfor (v = vals; v != vals + count; v++) {\n\t\t\tif (v->type == EV_KEY && v->value != 2) {\n\t\t\t\tif (v->value)\n\t\t\t\t\tinput_start_autorepeat(dev, v->code);\n\t\t\t\telse\n\t\t\t\t\tinput_stop_autorepeat(dev);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void input_pass_event(struct input_dev *dev,\n\t\t\t     unsigned int type, unsigned int code, int value)\n{\n\tstruct input_value vals[] = { { type, code, value } };\n\n\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n}\n\n/*\n * Generate software autorepeat event. Note that we take\n * dev->event_lock here to avoid racing with input_event\n * which may cause keys get \"stuck\".\n */\nstatic void input_repeat_key(struct timer_list *t)\n{\n\tstruct input_dev *dev = from_timer(dev, t, timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\tif (test_bit(dev->repeat_key, dev->key) &&\n\t    is_event_supported(dev->repeat_key, dev->keybit, KEY_MAX)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, dev->repeat_key, 2 },\n\t\t\tinput_value_sync\n\t\t};\n\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\n\t\tif (dev->rep[REP_PERIOD])\n\t\t\tmod_timer(&dev->timer, jiffies +\n\t\t\t\t\tmsecs_to_jiffies(dev->rep[REP_PERIOD]));\n\t}\n\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n}\n\n#define INPUT_IGNORE_EVENT\t0\n#define INPUT_PASS_TO_HANDLERS\t1\n#define INPUT_PASS_TO_DEVICE\t2\n#define INPUT_SLOT\t\t4\n#define INPUT_FLUSH\t\t8\n#define INPUT_PASS_TO_ALL\t(INPUT_PASS_TO_HANDLERS | INPUT_PASS_TO_DEVICE)\n\nstatic int input_handle_abs_event(struct input_dev *dev,\n\t\t\t\t  unsigned int code, int *pval)\n{\n\tstruct input_mt *mt = dev->mt;\n\tbool is_mt_event;\n\tint *pold;\n\n\tif (code == ABS_MT_SLOT) {\n\t\t/*\n\t\t * \"Stage\" the event; we'll flush it later, when we\n\t\t * get actual touch data.\n\t\t */\n\t\tif (mt && *pval >= 0 && *pval < mt->num_slots)\n\t\t\tmt->slot = *pval;\n\n\t\treturn INPUT_IGNORE_EVENT;\n\t}\n\n\tis_mt_event = input_is_mt_value(code);\n\n\tif (!is_mt_event) {\n\t\tpold = &dev->absinfo[code].value;\n\t} else if (mt) {\n\t\tpold = &mt->slots[mt->slot].abs[code - ABS_MT_FIRST];\n\t} else {\n\t\t/*\n\t\t * Bypass filtering for multi-touch events when\n\t\t * not employing slots.\n\t\t */\n\t\tpold = NULL;\n\t}\n\n\tif (pold) {\n\t\t*pval = input_defuzz_abs_event(*pval, *pold,\n\t\t\t\t\t\tdev->absinfo[code].fuzz);\n\t\tif (*pold == *pval)\n\t\t\treturn INPUT_IGNORE_EVENT;\n\n\t\t*pold = *pval;\n\t}\n\n\t/* Flush pending \"slot\" event */\n\tif (is_mt_event && mt && mt->slot != input_abs_get_val(dev, ABS_MT_SLOT)) {\n\t\tinput_abs_set_val(dev, ABS_MT_SLOT, mt->slot);\n\t\treturn INPUT_PASS_TO_HANDLERS | INPUT_SLOT;\n\t}\n\n\treturn INPUT_PASS_TO_HANDLERS;\n}\n\nstatic int input_get_disposition(struct input_dev *dev,\n\t\t\t  unsigned int type, unsigned int code, int *pval)\n{\n\tint disposition = INPUT_IGNORE_EVENT;\n\tint value = *pval;\n\n\tswitch (type) {\n\n\tcase EV_SYN:\n\t\tswitch (code) {\n\t\tcase SYN_CONFIG:\n\t\t\tdisposition = INPUT_PASS_TO_ALL;\n\t\t\tbreak;\n\n\t\tcase SYN_REPORT:\n\t\t\tdisposition = INPUT_PASS_TO_HANDLERS | INPUT_FLUSH;\n\t\t\tbreak;\n\t\tcase SYN_MT_REPORT:\n\t\t\tdisposition = INPUT_PASS_TO_HANDLERS;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase EV_KEY:\n\t\tif (is_event_supported(code, dev->keybit, KEY_MAX)) {\n\n\t\t\t/* auto-repeat bypasses state updates */\n\t\t\tif (value == 2) {\n\t\t\t\tdisposition = INPUT_PASS_TO_HANDLERS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!!test_bit(code, dev->key) != !!value) {\n\n\t\t\t\t__change_bit(code, dev->key);\n\t\t\t\tdisposition = INPUT_PASS_TO_HANDLERS;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase EV_SW:\n\t\tif (is_event_supported(code, dev->swbit, SW_MAX) &&\n\t\t    !!test_bit(code, dev->sw) != !!value) {\n\n\t\t\t__change_bit(code, dev->sw);\n\t\t\tdisposition = INPUT_PASS_TO_HANDLERS;\n\t\t}\n\t\tbreak;\n\n\tcase EV_ABS:\n\t\tif (is_event_supported(code, dev->absbit, ABS_MAX))\n\t\t\tdisposition = input_handle_abs_event(dev, code, &value);\n\n\t\tbreak;\n\n\tcase EV_REL:\n\t\tif (is_event_supported(code, dev->relbit, REL_MAX) && value)\n\t\t\tdisposition = INPUT_PASS_TO_HANDLERS;\n\n\t\tbreak;\n\n\tcase EV_MSC:\n\t\tif (is_event_supported(code, dev->mscbit, MSC_MAX))\n\t\t\tdisposition = INPUT_PASS_TO_ALL;\n\n\t\tbreak;\n\n\tcase EV_LED:\n\t\tif (is_event_supported(code, dev->ledbit, LED_MAX) &&\n\t\t    !!test_bit(code, dev->led) != !!value) {\n\n\t\t\t__change_bit(code, dev->led);\n\t\t\tdisposition = INPUT_PASS_TO_ALL;\n\t\t}\n\t\tbreak;\n\n\tcase EV_SND:\n\t\tif (is_event_supported(code, dev->sndbit, SND_MAX)) {\n\n\t\t\tif (!!test_bit(code, dev->snd) != !!value)\n\t\t\t\t__change_bit(code, dev->snd);\n\t\t\tdisposition = INPUT_PASS_TO_ALL;\n\t\t}\n\t\tbreak;\n\n\tcase EV_REP:\n\t\tif (code <= REP_MAX && value >= 0 && dev->rep[code] != value) {\n\t\t\tdev->rep[code] = value;\n\t\t\tdisposition = INPUT_PASS_TO_ALL;\n\t\t}\n\t\tbreak;\n\n\tcase EV_FF:\n\t\tif (value >= 0)\n\t\t\tdisposition = INPUT_PASS_TO_ALL;\n\t\tbreak;\n\n\tcase EV_PWR:\n\t\tdisposition = INPUT_PASS_TO_ALL;\n\t\tbreak;\n\t}\n\n\t*pval = value;\n\treturn disposition;\n}\n\nstatic void input_handle_event(struct input_dev *dev,\n\t\t\t       unsigned int type, unsigned int code, int value)\n{\n\tint disposition = input_get_disposition(dev, type, code, &value);\n\n\tif (disposition != INPUT_IGNORE_EVENT && type != EV_SYN)\n\t\tadd_input_randomness(type, code, value);\n\n\tif ((disposition & INPUT_PASS_TO_DEVICE) && dev->event)\n\t\tdev->event(dev, type, code, value);\n\n\tif (!dev->vals)\n\t\treturn;\n\n\tif (disposition & INPUT_PASS_TO_HANDLERS) {\n\t\tstruct input_value *v;\n\n\t\tif (disposition & INPUT_SLOT) {\n\t\t\tv = &dev->vals[dev->num_vals++];\n\t\t\tv->type = EV_ABS;\n\t\t\tv->code = ABS_MT_SLOT;\n\t\t\tv->value = dev->mt->slot;\n\t\t}\n\n\t\tv = &dev->vals[dev->num_vals++];\n\t\tv->type = type;\n\t\tv->code = code;\n\t\tv->value = value;\n\t}\n\n\tif (disposition & INPUT_FLUSH) {\n\t\tif (dev->num_vals >= 2)\n\t\t\tinput_pass_values(dev, dev->vals, dev->num_vals);\n\t\tdev->num_vals = 0;\n\t\t/*\n\t\t * Reset the timestamp on flush so we won't end up\n\t\t * with a stale one. Note we only need to reset the\n\t\t * monolithic one as we use its presence when deciding\n\t\t * whether to generate a synthetic timestamp.\n\t\t */\n\t\tdev->timestamp[INPUT_CLK_MONO] = ktime_set(0, 0);\n\t} else if (dev->num_vals >= dev->max_vals - 2) {\n\t\tdev->vals[dev->num_vals++] = input_value_sync;\n\t\tinput_pass_values(dev, dev->vals, dev->num_vals);\n\t\tdev->num_vals = 0;\n\t}\n\n}\n\n/**\n * input_event() - report new input event\n * @dev: device that generated the event\n * @type: type of the event\n * @code: event code\n * @value: value of the event\n *\n * This function should be used by drivers implementing various input\n * devices to report input events. See also input_inject_event().\n *\n * NOTE: input_event() may be safely used right after input device was\n * allocated with input_allocate_device(), even before it is registered\n * with input_register_device(), but the event will not reach any of the\n * input handlers. Such early invocation of input_event() may be used\n * to 'seed' initial state of a switch or initial position of absolute\n * axis, etc.\n */\nvoid input_event(struct input_dev *dev,\n\t\t unsigned int type, unsigned int code, int value)\n{\n\tunsigned long flags;\n\n\tif (is_event_supported(type, dev->evbit, EV_MAX)) {\n\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\t\tinput_handle_event(dev, type, code, value);\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n}\nEXPORT_SYMBOL(input_event);\n\n/**\n * input_inject_event() - send input event from input handler\n * @handle: input handle to send event through\n * @type: type of the event\n * @code: event code\n * @value: value of the event\n *\n * Similar to input_event() but will ignore event if device is\n * \"grabbed\" and handle injecting event is not the one that owns\n * the device.\n */\nvoid input_inject_event(struct input_handle *handle,\n\t\t\tunsigned int type, unsigned int code, int value)\n{\n\tstruct input_dev *dev = handle->dev;\n\tstruct input_handle *grab;\n\tunsigned long flags;\n\n\tif (is_event_supported(type, dev->evbit, EV_MAX)) {\n\t\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\t\trcu_read_lock();\n\t\tgrab = rcu_dereference(dev->grab);\n\t\tif (!grab || grab == handle)\n\t\t\tinput_handle_event(dev, type, code, value);\n\t\trcu_read_unlock();\n\n\t\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\t}\n}\nEXPORT_SYMBOL(input_inject_event);\n\n/**\n * input_alloc_absinfo - allocates array of input_absinfo structs\n * @dev: the input device emitting absolute events\n *\n * If the absinfo struct the caller asked for is already allocated, this\n * functions will not do anything.\n */\nvoid input_alloc_absinfo(struct input_dev *dev)\n{\n\tif (dev->absinfo)\n\t\treturn;\n\n\tdev->absinfo = kcalloc(ABS_CNT, sizeof(*dev->absinfo), GFP_KERNEL);\n\tif (!dev->absinfo) {\n\t\tdev_err(dev->dev.parent ?: &dev->dev,\n\t\t\t\"%s: unable to allocate memory\\n\", __func__);\n\t\t/*\n\t\t * We will handle this allocation failure in\n\t\t * input_register_device() when we refuse to register input\n\t\t * device with ABS bits but without absinfo.\n\t\t */\n\t}\n}\nEXPORT_SYMBOL(input_alloc_absinfo);\n\nvoid input_set_abs_params(struct input_dev *dev, unsigned int axis,\n\t\t\t  int min, int max, int fuzz, int flat)\n{\n\tstruct input_absinfo *absinfo;\n\n\tinput_alloc_absinfo(dev);\n\tif (!dev->absinfo)\n\t\treturn;\n\n\tabsinfo = &dev->absinfo[axis];\n\tabsinfo->minimum = min;\n\tabsinfo->maximum = max;\n\tabsinfo->fuzz = fuzz;\n\tabsinfo->flat = flat;\n\n\t__set_bit(EV_ABS, dev->evbit);\n\t__set_bit(axis, dev->absbit);\n}\nEXPORT_SYMBOL(input_set_abs_params);\n\n\n/**\n * input_grab_device - grabs device for exclusive use\n * @handle: input handle that wants to own the device\n *\n * When a device is grabbed by an input handle all events generated by\n * the device are delivered only to this handle. Also events injected\n * by other input handles are ignored while device is grabbed.\n */\nint input_grab_device(struct input_handle *handle)\n{\n\tstruct input_dev *dev = handle->dev;\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&dev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (dev->grab) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\trcu_assign_pointer(dev->grab, handle);\n\n out:\n\tmutex_unlock(&dev->mutex);\n\treturn retval;\n}\nEXPORT_SYMBOL(input_grab_device);\n\nstatic void __input_release_device(struct input_handle *handle)\n{\n\tstruct input_dev *dev = handle->dev;\n\tstruct input_handle *grabber;\n\n\tgrabber = rcu_dereference_protected(dev->grab,\n\t\t\t\t\t    lockdep_is_held(&dev->mutex));\n\tif (grabber == handle) {\n\t\trcu_assign_pointer(dev->grab, NULL);\n\t\t/* Make sure input_pass_event() notices that grab is gone */\n\t\tsynchronize_rcu();\n\n\t\tlist_for_each_entry(handle, &dev->h_list, d_node)\n\t\t\tif (handle->open && handle->handler->start)\n\t\t\t\thandle->handler->start(handle);\n\t}\n}\n\n/**\n * input_release_device - release previously grabbed device\n * @handle: input handle that owns the device\n *\n * Releases previously grabbed device so that other input handles can\n * start receiving input events. Upon release all handlers attached\n * to the device have their start() method called so they have a change\n * to synchronize device state with the rest of the system.\n */\nvoid input_release_device(struct input_handle *handle)\n{\n\tstruct input_dev *dev = handle->dev;\n\n\tmutex_lock(&dev->mutex);\n\t__input_release_device(handle);\n\tmutex_unlock(&dev->mutex);\n}\nEXPORT_SYMBOL(input_release_device);\n\n/**\n * input_open_device - open input device\n * @handle: handle through which device is being accessed\n *\n * This function should be called by input handlers when they\n * want to start receive events from given input device.\n */\nint input_open_device(struct input_handle *handle)\n{\n\tstruct input_dev *dev = handle->dev;\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&dev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (dev->going_away) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\thandle->open++;\n\n\tif (dev->users++) {\n\t\t/*\n\t\t * Device is already opened, so we can exit immediately and\n\t\t * report success.\n\t\t */\n\t\tgoto out;\n\t}\n\n\tif (dev->open) {\n\t\tretval = dev->open(dev);\n\t\tif (retval) {\n\t\t\tdev->users--;\n\t\t\thandle->open--;\n\t\t\t/*\n\t\t\t * Make sure we are not delivering any more events\n\t\t\t * through this handle\n\t\t\t */\n\t\t\tsynchronize_rcu();\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (dev->poller)\n\t\tinput_dev_poller_start(dev->poller);\n\n out:\n\tmutex_unlock(&dev->mutex);\n\treturn retval;\n}\nEXPORT_SYMBOL(input_open_device);\n\nint input_flush_device(struct input_handle *handle, struct file *file)\n{\n\tstruct input_dev *dev = handle->dev;\n\tint retval;\n\n\tretval = mutex_lock_interruptible(&dev->mutex);\n\tif (retval)\n\t\treturn retval;\n\n\tif (dev->flush)\n\t\tretval = dev->flush(dev, file);\n\n\tmutex_unlock(&dev->mutex);\n\treturn retval;\n}\nEXPORT_SYMBOL(input_flush_device);\n\n/**\n * input_close_device - close input device\n * @handle: handle through which device is being accessed\n *\n * This function should be called by input handlers when they\n * want to stop receive events from given input device.\n */\nvoid input_close_device(struct input_handle *handle)\n{\n\tstruct input_dev *dev = handle->dev;\n\n\tmutex_lock(&dev->mutex);\n\n\t__input_release_device(handle);\n\n\tif (!--dev->users) {\n\t\tif (dev->poller)\n\t\t\tinput_dev_poller_stop(dev->poller);\n\n\t\tif (dev->close)\n\t\t\tdev->close(dev);\n\t}\n\n\tif (!--handle->open) {\n\t\t/*\n\t\t * synchronize_rcu() makes sure that input_pass_event()\n\t\t * completed and that no more input events are delivered\n\t\t * through this handle\n\t\t */\n\t\tsynchronize_rcu();\n\t}\n\n\tmutex_unlock(&dev->mutex);\n}\nEXPORT_SYMBOL(input_close_device);\n\n/*\n * Simulate keyup events for all keys that are marked as pressed.\n * The function must be called with dev->event_lock held.\n */\nstatic void input_dev_release_keys(struct input_dev *dev)\n{\n\tbool need_sync = false;\n\tint code;\n\n\tif (is_event_supported(EV_KEY, dev->evbit, EV_MAX)) {\n\t\tfor_each_set_bit(code, dev->key, KEY_CNT) {\n\t\t\tinput_pass_event(dev, EV_KEY, code, 0);\n\t\t\tneed_sync = true;\n\t\t}\n\n\t\tif (need_sync)\n\t\t\tinput_pass_event(dev, EV_SYN, SYN_REPORT, 1);\n\n\t\tmemset(dev->key, 0, sizeof(dev->key));\n\t}\n}\n\n/*\n * Prepare device for unregistering\n */\nstatic void input_disconnect_device(struct input_dev *dev)\n{\n\tstruct input_handle *handle;\n\n\t/*\n\t * Mark device as going away. Note that we take dev->mutex here\n\t * not to protect access to dev->going_away but rather to ensure\n\t * that there are no threads in the middle of input_open_device()\n\t */\n\tmutex_lock(&dev->mutex);\n\tdev->going_away = true;\n\tmutex_unlock(&dev->mutex);\n\n\tspin_lock_irq(&dev->event_lock);\n\n\t/*\n\t * Simulate keyup events for all pressed keys so that handlers\n\t * are not left with \"stuck\" keys. The driver may continue\n\t * generate events even after we done here but they will not\n\t * reach any handlers.\n\t */\n\tinput_dev_release_keys(dev);\n\n\tlist_for_each_entry(handle, &dev->h_list, d_node)\n\t\thandle->open = 0;\n\n\tspin_unlock_irq(&dev->event_lock);\n}\n\n/**\n * input_scancode_to_scalar() - converts scancode in &struct input_keymap_entry\n * @ke: keymap entry containing scancode to be converted.\n * @scancode: pointer to the location where converted scancode should\n *\tbe stored.\n *\n * This function is used to convert scancode stored in &struct keymap_entry\n * into scalar form understood by legacy keymap handling methods. These\n * methods expect scancodes to be represented as 'unsigned int'.\n */\nint input_scancode_to_scalar(const struct input_keymap_entry *ke,\n\t\t\t     unsigned int *scancode)\n{\n\tswitch (ke->len) {\n\tcase 1:\n\t\t*scancode = *((u8 *)ke->scancode);\n\t\tbreak;\n\n\tcase 2:\n\t\t*scancode = *((u16 *)ke->scancode);\n\t\tbreak;\n\n\tcase 4:\n\t\t*scancode = *((u32 *)ke->scancode);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(input_scancode_to_scalar);\n\n/*\n * Those routines handle the default case where no [gs]etkeycode() is\n * defined. In this case, an array indexed by the scancode is used.\n */\n\nstatic unsigned int input_fetch_keycode(struct input_dev *dev,\n\t\t\t\t\tunsigned int index)\n{\n\tswitch (dev->keycodesize) {\n\tcase 1:\n\t\treturn ((u8 *)dev->keycode)[index];\n\n\tcase 2:\n\t\treturn ((u16 *)dev->keycode)[index];\n\n\tdefault:\n\t\treturn ((u32 *)dev->keycode)[index];\n\t}\n}\n\nstatic int input_default_getkeycode(struct input_dev *dev,\n\t\t\t\t    struct input_keymap_entry *ke)\n{\n\tunsigned int index;\n\tint error;\n\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX)\n\t\tindex = ke->index;\n\telse {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\n\tke->keycode = input_fetch_keycode(dev, index);\n\tke->index = index;\n\tke->len = sizeof(index);\n\tmemcpy(ke->scancode, &index, sizeof(index));\n\n\treturn 0;\n}\n\nstatic int input_default_setkeycode(struct input_dev *dev,\n\t\t\t\t    const struct input_keymap_entry *ke,\n\t\t\t\t    unsigned int *old_keycode)\n{\n\tunsigned int index;\n\tint error;\n\tint i;\n\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\n\tif (dev->keycodesize < sizeof(ke->keycode) &&\n\t\t\t(ke->keycode >> (dev->keycodesize * 8)))\n\t\treturn -EINVAL;\n\n\tswitch (dev->keycodesize) {\n\t\tcase 1: {\n\t\t\tu8 *k = (u8 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tu16 *k = (u16 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tu32 *k = (u32 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*old_keycode <= KEY_MAX) {\n\t\t__clear_bit(*old_keycode, dev->keybit);\n\t\tfor (i = 0; i < dev->keycodemax; i++) {\n\t\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n\t\t\t\t__set_bit(*old_keycode, dev->keybit);\n\t\t\t\t/* Setting the bit twice is useless, so break */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t__set_bit(ke->keycode, dev->keybit);\n\treturn 0;\n}\n\n/**\n * input_get_keycode - retrieve keycode currently mapped to a given scancode\n * @dev: input device which keymap is being queried\n * @ke: keymap entry\n *\n * This function should be called by anyone interested in retrieving current\n * keymap. Presently evdev handlers use it.\n */\nint input_get_keycode(struct input_dev *dev, struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->getkeycode(dev, ke);\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(input_get_keycode);\n\n/**\n * input_set_keycode - attribute a keycode to a given scancode\n * @dev: input device which keymap is being updated\n * @ke: new keymap entry\n *\n * This function should be called by anyone needing to update current\n * keymap. Presently keyboard and evdev handlers use it.\n */\nint input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\n\t/* Make sure KEY_RESERVED did not get enabled. */\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\n\t/*\n\t * Simulate keyup event if keycode is not present\n\t * in the keymap anymore\n\t */\n\tif (old_keycode > KEY_MAX) {\n\t\tdev_warn(dev->dev.parent ?: &dev->dev,\n\t\t\t \"%s: got too big old keycode %#x\\n\",\n\t\t\t __func__, old_keycode);\n\t} else if (test_bit(EV_KEY, dev->evbit) &&\n\t\t   !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t\t   __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(input_set_keycode);\n\nbool input_match_device_id(const struct input_dev *dev,\n\t\t\t   const struct input_device_id *id)\n{\n\tif (id->flags & INPUT_DEVICE_ID_MATCH_BUS)\n\t\tif (id->bustype != dev->id.bustype)\n\t\t\treturn false;\n\n\tif (id->flags & INPUT_DEVICE_ID_MATCH_VENDOR)\n\t\tif (id->vendor != dev->id.vendor)\n\t\t\treturn false;\n\n\tif (id->flags & INPUT_DEVICE_ID_MATCH_PRODUCT)\n\t\tif (id->product != dev->id.product)\n\t\t\treturn false;\n\n\tif (id->flags & INPUT_DEVICE_ID_MATCH_VERSION)\n\t\tif (id->version != dev->id.version)\n\t\t\treturn false;\n\n\tif (!bitmap_subset(id->evbit, dev->evbit, EV_MAX) ||\n\t    !bitmap_subset(id->keybit, dev->keybit, KEY_MAX) ||\n\t    !bitmap_subset(id->relbit, dev->relbit, REL_MAX) ||\n\t    !bitmap_subset(id->absbit, dev->absbit, ABS_MAX) ||\n\t    !bitmap_subset(id->mscbit, dev->mscbit, MSC_MAX) ||\n\t    !bitmap_subset(id->ledbit, dev->ledbit, LED_MAX) ||\n\t    !bitmap_subset(id->sndbit, dev->sndbit, SND_MAX) ||\n\t    !bitmap_subset(id->ffbit, dev->ffbit, FF_MAX) ||\n\t    !bitmap_subset(id->swbit, dev->swbit, SW_MAX) ||\n\t    !bitmap_subset(id->propbit, dev->propbit, INPUT_PROP_MAX)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL(input_match_device_id);\n\nstatic const struct input_device_id *input_match_device(struct input_handler *handler,\n\t\t\t\t\t\t\tstruct input_dev *dev)\n{\n\tconst struct input_device_id *id;\n\n\tfor (id = handler->id_table; id->flags || id->driver_info; id++) {\n\t\tif (input_match_device_id(dev, id) &&\n\t\t    (!handler->match || handler->match(handler, dev))) {\n\t\t\treturn id;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\n{\n\tconst struct input_device_id *id;\n\tint error;\n\n\tid = input_match_device(handler, dev);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\terror = handler->connect(handler, dev, id);\n\tif (error && error != -ENODEV)\n\t\tpr_err(\"failed to attach handler %s to device %s, error: %d\\n\",\n\t\t       handler->name, kobject_name(&dev->dev.kobj), error);\n\n\treturn error;\n}\n\n#ifdef CONFIG_COMPAT\n\nstatic int input_bits_to_string(char *buf, int buf_size,\n\t\t\t\tunsigned long bits, bool skip_empty)\n{\n\tint len = 0;\n\n\tif (in_compat_syscall()) {\n\t\tu32 dword = bits >> 32;\n\t\tif (dword || !skip_empty)\n\t\t\tlen += snprintf(buf, buf_size, \"%x \", dword);\n\n\t\tdword = bits & 0xffffffffUL;\n\t\tif (dword || !skip_empty || len)\n\t\t\tlen += snprintf(buf + len, max(buf_size - len, 0),\n\t\t\t\t\t\"%x\", dword);\n\t} else {\n\t\tif (bits || !skip_empty)\n\t\t\tlen += snprintf(buf, buf_size, \"%lx\", bits);\n\t}\n\n\treturn len;\n}\n\n#else /* !CONFIG_COMPAT */\n\nstatic int input_bits_to_string(char *buf, int buf_size,\n\t\t\t\tunsigned long bits, bool skip_empty)\n{\n\treturn bits || !skip_empty ?\n\t\tsnprintf(buf, buf_size, \"%lx\", bits) : 0;\n}\n\n#endif\n\n#ifdef CONFIG_PROC_FS\n\nstatic struct proc_dir_entry *proc_bus_input_dir;\nstatic DECLARE_WAIT_QUEUE_HEAD(input_devices_poll_wait);\nstatic int input_devices_state;\n\nstatic inline void input_wakeup_procfs_readers(void)\n{\n\tinput_devices_state++;\n\twake_up(&input_devices_poll_wait);\n}\n\nstatic __poll_t input_proc_devices_poll(struct file *file, poll_table *wait)\n{\n\tpoll_wait(file, &input_devices_poll_wait, wait);\n\tif (file->f_version != input_devices_state) {\n\t\tfile->f_version = input_devices_state;\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\t}\n\n\treturn 0;\n}\n\nunion input_seq_state {\n\tstruct {\n\t\tunsigned short pos;\n\t\tbool mutex_acquired;\n\t};\n\tvoid *p;\n};\n\nstatic void *input_devices_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tunion input_seq_state *state = (union input_seq_state *)&seq->private;\n\tint error;\n\n\t/* We need to fit into seq->private pointer */\n\tBUILD_BUG_ON(sizeof(union input_seq_state) != sizeof(seq->private));\n\n\terror = mutex_lock_interruptible(&input_mutex);\n\tif (error) {\n\t\tstate->mutex_acquired = false;\n\t\treturn ERR_PTR(error);\n\t}\n\n\tstate->mutex_acquired = true;\n\n\treturn seq_list_start(&input_dev_list, *pos);\n}\n\nstatic void *input_devices_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &input_dev_list, pos);\n}\n\nstatic void input_seq_stop(struct seq_file *seq, void *v)\n{\n\tunion input_seq_state *state = (union input_seq_state *)&seq->private;\n\n\tif (state->mutex_acquired)\n\t\tmutex_unlock(&input_mutex);\n}\n\nstatic void input_seq_print_bitmap(struct seq_file *seq, const char *name,\n\t\t\t\t   unsigned long *bitmap, int max)\n{\n\tint i;\n\tbool skip_empty = true;\n\tchar buf[18];\n\n\tseq_printf(seq, \"B: %s=\", name);\n\n\tfor (i = BITS_TO_LONGS(max) - 1; i >= 0; i--) {\n\t\tif (input_bits_to_string(buf, sizeof(buf),\n\t\t\t\t\t bitmap[i], skip_empty)) {\n\t\t\tskip_empty = false;\n\t\t\tseq_printf(seq, \"%s%s\", buf, i > 0 ? \" \" : \"\");\n\t\t}\n\t}\n\n\t/*\n\t * If no output was produced print a single 0.\n\t */\n\tif (skip_empty)\n\t\tseq_putc(seq, '0');\n\n\tseq_putc(seq, '\\n');\n}\n\nstatic int input_devices_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct input_dev *dev = container_of(v, struct input_dev, node);\n\tconst char *path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n\tstruct input_handle *handle;\n\n\tseq_printf(seq, \"I: Bus=%04x Vendor=%04x Product=%04x Version=%04x\\n\",\n\t\t   dev->id.bustype, dev->id.vendor, dev->id.product, dev->id.version);\n\n\tseq_printf(seq, \"N: Name=\\\"%s\\\"\\n\", dev->name ? dev->name : \"\");\n\tseq_printf(seq, \"P: Phys=%s\\n\", dev->phys ? dev->phys : \"\");\n\tseq_printf(seq, \"S: Sysfs=%s\\n\", path ? path : \"\");\n\tseq_printf(seq, \"U: Uniq=%s\\n\", dev->uniq ? dev->uniq : \"\");\n\tseq_puts(seq, \"H: Handlers=\");\n\n\tlist_for_each_entry(handle, &dev->h_list, d_node)\n\t\tseq_printf(seq, \"%s \", handle->name);\n\tseq_putc(seq, '\\n');\n\n\tinput_seq_print_bitmap(seq, \"PROP\", dev->propbit, INPUT_PROP_MAX);\n\n\tinput_seq_print_bitmap(seq, \"EV\", dev->evbit, EV_MAX);\n\tif (test_bit(EV_KEY, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"KEY\", dev->keybit, KEY_MAX);\n\tif (test_bit(EV_REL, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"REL\", dev->relbit, REL_MAX);\n\tif (test_bit(EV_ABS, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"ABS\", dev->absbit, ABS_MAX);\n\tif (test_bit(EV_MSC, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"MSC\", dev->mscbit, MSC_MAX);\n\tif (test_bit(EV_LED, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"LED\", dev->ledbit, LED_MAX);\n\tif (test_bit(EV_SND, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"SND\", dev->sndbit, SND_MAX);\n\tif (test_bit(EV_FF, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"FF\", dev->ffbit, FF_MAX);\n\tif (test_bit(EV_SW, dev->evbit))\n\t\tinput_seq_print_bitmap(seq, \"SW\", dev->swbit, SW_MAX);\n\n\tseq_putc(seq, '\\n');\n\n\tkfree(path);\n\treturn 0;\n}\n\nstatic const struct seq_operations input_devices_seq_ops = {\n\t.start\t= input_devices_seq_start,\n\t.next\t= input_devices_seq_next,\n\t.stop\t= input_seq_stop,\n\t.show\t= input_devices_seq_show,\n};\n\nstatic int input_proc_devices_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &input_devices_seq_ops);\n}\n\nstatic const struct file_operations input_devices_fileops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= input_proc_devices_open,\n\t.poll\t\t= input_proc_devices_poll,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic void *input_handlers_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tunion input_seq_state *state = (union input_seq_state *)&seq->private;\n\tint error;\n\n\t/* We need to fit into seq->private pointer */\n\tBUILD_BUG_ON(sizeof(union input_seq_state) != sizeof(seq->private));\n\n\terror = mutex_lock_interruptible(&input_mutex);\n\tif (error) {\n\t\tstate->mutex_acquired = false;\n\t\treturn ERR_PTR(error);\n\t}\n\n\tstate->mutex_acquired = true;\n\tstate->pos = *pos;\n\n\treturn seq_list_start(&input_handler_list, *pos);\n}\n\nstatic void *input_handlers_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tunion input_seq_state *state = (union input_seq_state *)&seq->private;\n\n\tstate->pos = *pos + 1;\n\treturn seq_list_next(v, &input_handler_list, pos);\n}\n\nstatic int input_handlers_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct input_handler *handler = container_of(v, struct input_handler, node);\n\tunion input_seq_state *state = (union input_seq_state *)&seq->private;\n\n\tseq_printf(seq, \"N: Number=%u Name=%s\", state->pos, handler->name);\n\tif (handler->filter)\n\t\tseq_puts(seq, \" (filter)\");\n\tif (handler->legacy_minors)\n\t\tseq_printf(seq, \" Minor=%d\", handler->minor);\n\tseq_putc(seq, '\\n');\n\n\treturn 0;\n}\n\nstatic const struct seq_operations input_handlers_seq_ops = {\n\t.start\t= input_handlers_seq_start,\n\t.next\t= input_handlers_seq_next,\n\t.stop\t= input_seq_stop,\n\t.show\t= input_handlers_seq_show,\n};\n\nstatic int input_proc_handlers_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &input_handlers_seq_ops);\n}\n\nstatic const struct file_operations input_handlers_fileops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= input_proc_handlers_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic int __init input_proc_init(void)\n{\n\tstruct proc_dir_entry *entry;\n\n\tproc_bus_input_dir = proc_mkdir(\"bus/input\", NULL);\n\tif (!proc_bus_input_dir)\n\t\treturn -ENOMEM;\n\n\tentry = proc_create(\"devices\", 0, proc_bus_input_dir,\n\t\t\t    &input_devices_fileops);\n\tif (!entry)\n\t\tgoto fail1;\n\n\tentry = proc_create(\"handlers\", 0, proc_bus_input_dir,\n\t\t\t    &input_handlers_fileops);\n\tif (!entry)\n\t\tgoto fail2;\n\n\treturn 0;\n\n fail2:\tremove_proc_entry(\"devices\", proc_bus_input_dir);\n fail1: remove_proc_entry(\"bus/input\", NULL);\n\treturn -ENOMEM;\n}\n\nstatic void input_proc_exit(void)\n{\n\tremove_proc_entry(\"devices\", proc_bus_input_dir);\n\tremove_proc_entry(\"handlers\", proc_bus_input_dir);\n\tremove_proc_entry(\"bus/input\", NULL);\n}\n\n#else /* !CONFIG_PROC_FS */\nstatic inline void input_wakeup_procfs_readers(void) { }\nstatic inline int input_proc_init(void) { return 0; }\nstatic inline void input_proc_exit(void) { }\n#endif\n\n#define INPUT_DEV_STRING_ATTR_SHOW(name)\t\t\t\t\\\nstatic ssize_t input_dev_show_##name(struct device *dev,\t\t\\\n\t\t\t\t     struct device_attribute *attr,\t\\\n\t\t\t\t     char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct input_dev *input_dev = to_input_dev(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\t\t\t\\\n\t\t\t input_dev->name ? input_dev->name : \"\");\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(name, S_IRUGO, input_dev_show_##name, NULL)\n\nINPUT_DEV_STRING_ATTR_SHOW(name);\nINPUT_DEV_STRING_ATTR_SHOW(phys);\nINPUT_DEV_STRING_ATTR_SHOW(uniq);\n\nstatic int input_print_modalias_bits(char *buf, int size,\n\t\t\t\t     char name, unsigned long *bm,\n\t\t\t\t     unsigned int min_bit, unsigned int max_bit)\n{\n\tint len = 0, i;\n\n\tlen += snprintf(buf, max(size, 0), \"%c\", name);\n\tfor (i = min_bit; i < max_bit; i++)\n\t\tif (bm[BIT_WORD(i)] & BIT_MASK(i))\n\t\t\tlen += snprintf(buf + len, max(size - len, 0), \"%X,\", i);\n\treturn len;\n}\n\nstatic int input_print_modalias(char *buf, int size, struct input_dev *id,\n\t\t\t\tint add_cr)\n{\n\tint len;\n\n\tlen = snprintf(buf, max(size, 0),\n\t\t       \"input:b%04Xv%04Xp%04Xe%04X-\",\n\t\t       id->id.bustype, id->id.vendor,\n\t\t       id->id.product, id->id.version);\n\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'e', id->evbit, 0, EV_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'k', id->keybit, KEY_MIN_INTERESTING, KEY_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'r', id->relbit, 0, REL_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'a', id->absbit, 0, ABS_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'm', id->mscbit, 0, MSC_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'l', id->ledbit, 0, LED_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t's', id->sndbit, 0, SND_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'f', id->ffbit, 0, FF_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'w', id->swbit, 0, SW_MAX);\n\n\tif (add_cr)\n\t\tlen += snprintf(buf + len, max(size - len, 0), \"\\n\");\n\n\treturn len;\n}\n\nstatic ssize_t input_dev_show_modalias(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct input_dev *id = to_input_dev(dev);\n\tssize_t len;\n\n\tlen = input_print_modalias(buf, PAGE_SIZE, id, 1);\n\n\treturn min_t(int, len, PAGE_SIZE);\n}\nstatic DEVICE_ATTR(modalias, S_IRUGO, input_dev_show_modalias, NULL);\n\nstatic int input_print_bitmap(char *buf, int buf_size, unsigned long *bitmap,\n\t\t\t      int max, int add_cr);\n\nstatic ssize_t input_dev_show_properties(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct input_dev *input_dev = to_input_dev(dev);\n\tint len = input_print_bitmap(buf, PAGE_SIZE, input_dev->propbit,\n\t\t\t\t     INPUT_PROP_MAX, true);\n\treturn min_t(int, len, PAGE_SIZE);\n}\nstatic DEVICE_ATTR(properties, S_IRUGO, input_dev_show_properties, NULL);\n\nstatic struct attribute *input_dev_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_phys.attr,\n\t&dev_attr_uniq.attr,\n\t&dev_attr_modalias.attr,\n\t&dev_attr_properties.attr,\n\tNULL\n};\n\nstatic const struct attribute_group input_dev_attr_group = {\n\t.attrs\t= input_dev_attrs,\n};\n\n#define INPUT_DEV_ID_ATTR(name)\t\t\t\t\t\t\\\nstatic ssize_t input_dev_show_id_##name(struct device *dev,\t\t\\\n\t\t\t\t\tstruct device_attribute *attr,\t\\\n\t\t\t\t\tchar *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct input_dev *input_dev = to_input_dev(dev);\t\t\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%04x\\n\", input_dev->id.name);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(name, S_IRUGO, input_dev_show_id_##name, NULL)\n\nINPUT_DEV_ID_ATTR(bustype);\nINPUT_DEV_ID_ATTR(vendor);\nINPUT_DEV_ID_ATTR(product);\nINPUT_DEV_ID_ATTR(version);\n\nstatic struct attribute *input_dev_id_attrs[] = {\n\t&dev_attr_bustype.attr,\n\t&dev_attr_vendor.attr,\n\t&dev_attr_product.attr,\n\t&dev_attr_version.attr,\n\tNULL\n};\n\nstatic const struct attribute_group input_dev_id_attr_group = {\n\t.name\t= \"id\",\n\t.attrs\t= input_dev_id_attrs,\n};\n\nstatic int input_print_bitmap(char *buf, int buf_size, unsigned long *bitmap,\n\t\t\t      int max, int add_cr)\n{\n\tint i;\n\tint len = 0;\n\tbool skip_empty = true;\n\n\tfor (i = BITS_TO_LONGS(max) - 1; i >= 0; i--) {\n\t\tlen += input_bits_to_string(buf + len, max(buf_size - len, 0),\n\t\t\t\t\t    bitmap[i], skip_empty);\n\t\tif (len) {\n\t\t\tskip_empty = false;\n\t\t\tif (i > 0)\n\t\t\t\tlen += snprintf(buf + len, max(buf_size - len, 0), \" \");\n\t\t}\n\t}\n\n\t/*\n\t * If no output was produced print a single 0.\n\t */\n\tif (len == 0)\n\t\tlen = snprintf(buf, buf_size, \"%d\", 0);\n\n\tif (add_cr)\n\t\tlen += snprintf(buf + len, max(buf_size - len, 0), \"\\n\");\n\n\treturn len;\n}\n\n#define INPUT_DEV_CAP_ATTR(ev, bm)\t\t\t\t\t\\\nstatic ssize_t input_dev_show_cap_##bm(struct device *dev,\t\t\\\n\t\t\t\t       struct device_attribute *attr,\t\\\n\t\t\t\t       char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct input_dev *input_dev = to_input_dev(dev);\t\t\\\n\tint len = input_print_bitmap(buf, PAGE_SIZE,\t\t\t\\\n\t\t\t\t     input_dev->bm##bit, ev##_MAX,\t\\\n\t\t\t\t     true);\t\t\t\t\\\n\treturn min_t(int, len, PAGE_SIZE);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR(bm, S_IRUGO, input_dev_show_cap_##bm, NULL)\n\nINPUT_DEV_CAP_ATTR(EV, ev);\nINPUT_DEV_CAP_ATTR(KEY, key);\nINPUT_DEV_CAP_ATTR(REL, rel);\nINPUT_DEV_CAP_ATTR(ABS, abs);\nINPUT_DEV_CAP_ATTR(MSC, msc);\nINPUT_DEV_CAP_ATTR(LED, led);\nINPUT_DEV_CAP_ATTR(SND, snd);\nINPUT_DEV_CAP_ATTR(FF, ff);\nINPUT_DEV_CAP_ATTR(SW, sw);\n\nstatic struct attribute *input_dev_caps_attrs[] = {\n\t&dev_attr_ev.attr,\n\t&dev_attr_key.attr,\n\t&dev_attr_rel.attr,\n\t&dev_attr_abs.attr,\n\t&dev_attr_msc.attr,\n\t&dev_attr_led.attr,\n\t&dev_attr_snd.attr,\n\t&dev_attr_ff.attr,\n\t&dev_attr_sw.attr,\n\tNULL\n};\n\nstatic const struct attribute_group input_dev_caps_attr_group = {\n\t.name\t= \"capabilities\",\n\t.attrs\t= input_dev_caps_attrs,\n};\n\nstatic const struct attribute_group *input_dev_attr_groups[] = {\n\t&input_dev_attr_group,\n\t&input_dev_id_attr_group,\n\t&input_dev_caps_attr_group,\n\t&input_poller_attribute_group,\n\tNULL\n};\n\nstatic void input_dev_release(struct device *device)\n{\n\tstruct input_dev *dev = to_input_dev(device);\n\n\tinput_ff_destroy(dev);\n\tinput_mt_destroy_slots(dev);\n\tkfree(dev->poller);\n\tkfree(dev->absinfo);\n\tkfree(dev->vals);\n\tkfree(dev);\n\n\tmodule_put(THIS_MODULE);\n}\n\n/*\n * Input uevent interface - loading event handlers based on\n * device bitfields.\n */\nstatic int input_add_uevent_bm_var(struct kobj_uevent_env *env,\n\t\t\t\t   const char *name, unsigned long *bitmap, int max)\n{\n\tint len;\n\n\tif (add_uevent_var(env, \"%s\", name))\n\t\treturn -ENOMEM;\n\n\tlen = input_print_bitmap(&env->buf[env->buflen - 1],\n\t\t\t\t sizeof(env->buf) - env->buflen,\n\t\t\t\t bitmap, max, false);\n\tif (len >= (sizeof(env->buf) - env->buflen))\n\t\treturn -ENOMEM;\n\n\tenv->buflen += len;\n\treturn 0;\n}\n\nstatic int input_add_uevent_modalias_var(struct kobj_uevent_env *env,\n\t\t\t\t\t struct input_dev *dev)\n{\n\tint len;\n\n\tif (add_uevent_var(env, \"MODALIAS=\"))\n\t\treturn -ENOMEM;\n\n\tlen = input_print_modalias(&env->buf[env->buflen - 1],\n\t\t\t\t   sizeof(env->buf) - env->buflen,\n\t\t\t\t   dev, 0);\n\tif (len >= (sizeof(env->buf) - env->buflen))\n\t\treturn -ENOMEM;\n\n\tenv->buflen += len;\n\treturn 0;\n}\n\n#define INPUT_ADD_HOTPLUG_VAR(fmt, val...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint err = add_uevent_var(env, fmt, val);\t\t\\\n\t\tif (err)\t\t\t\t\t\t\\\n\t\t\treturn err;\t\t\t\t\t\\\n\t} while (0)\n\n#define INPUT_ADD_HOTPLUG_BM_VAR(name, bm, max)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint err = input_add_uevent_bm_var(env, name, bm, max);\t\\\n\t\tif (err)\t\t\t\t\t\t\\\n\t\t\treturn err;\t\t\t\t\t\\\n\t} while (0)\n\n#define INPUT_ADD_HOTPLUG_MODALIAS_VAR(dev)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint err = input_add_uevent_modalias_var(env, dev);\t\\\n\t\tif (err)\t\t\t\t\t\t\\\n\t\t\treturn err;\t\t\t\t\t\\\n\t} while (0)\n\nstatic int input_dev_uevent(struct device *device, struct kobj_uevent_env *env)\n{\n\tstruct input_dev *dev = to_input_dev(device);\n\n\tINPUT_ADD_HOTPLUG_VAR(\"PRODUCT=%x/%x/%x/%x\",\n\t\t\t\tdev->id.bustype, dev->id.vendor,\n\t\t\t\tdev->id.product, dev->id.version);\n\tif (dev->name)\n\t\tINPUT_ADD_HOTPLUG_VAR(\"NAME=\\\"%s\\\"\", dev->name);\n\tif (dev->phys)\n\t\tINPUT_ADD_HOTPLUG_VAR(\"PHYS=\\\"%s\\\"\", dev->phys);\n\tif (dev->uniq)\n\t\tINPUT_ADD_HOTPLUG_VAR(\"UNIQ=\\\"%s\\\"\", dev->uniq);\n\n\tINPUT_ADD_HOTPLUG_BM_VAR(\"PROP=\", dev->propbit, INPUT_PROP_MAX);\n\n\tINPUT_ADD_HOTPLUG_BM_VAR(\"EV=\", dev->evbit, EV_MAX);\n\tif (test_bit(EV_KEY, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"KEY=\", dev->keybit, KEY_MAX);\n\tif (test_bit(EV_REL, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"REL=\", dev->relbit, REL_MAX);\n\tif (test_bit(EV_ABS, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"ABS=\", dev->absbit, ABS_MAX);\n\tif (test_bit(EV_MSC, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"MSC=\", dev->mscbit, MSC_MAX);\n\tif (test_bit(EV_LED, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"LED=\", dev->ledbit, LED_MAX);\n\tif (test_bit(EV_SND, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"SND=\", dev->sndbit, SND_MAX);\n\tif (test_bit(EV_FF, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"FF=\", dev->ffbit, FF_MAX);\n\tif (test_bit(EV_SW, dev->evbit))\n\t\tINPUT_ADD_HOTPLUG_BM_VAR(\"SW=\", dev->swbit, SW_MAX);\n\n\tINPUT_ADD_HOTPLUG_MODALIAS_VAR(dev);\n\n\treturn 0;\n}\n\n#define INPUT_DO_TOGGLE(dev, type, bits, on)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tint i;\t\t\t\t\t\t\t\\\n\t\tbool active;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tif (!test_bit(EV_##type, dev->evbit))\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor_each_set_bit(i, dev->bits##bit, type##_CNT) {\t\\\n\t\t\tactive = test_bit(i, dev->bits);\t\t\\\n\t\t\tif (!active && !on)\t\t\t\t\\\n\t\t\t\tcontinue;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t\tdev->event(dev, EV_##type, i, on ? active : 0);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic void input_dev_toggle(struct input_dev *dev, bool activate)\n{\n\tif (!dev->event)\n\t\treturn;\n\n\tINPUT_DO_TOGGLE(dev, LED, led, activate);\n\tINPUT_DO_TOGGLE(dev, SND, snd, activate);\n\n\tif (activate && test_bit(EV_REP, dev->evbit)) {\n\t\tdev->event(dev, EV_REP, REP_PERIOD, dev->rep[REP_PERIOD]);\n\t\tdev->event(dev, EV_REP, REP_DELAY, dev->rep[REP_DELAY]);\n\t}\n}\n\n/**\n * input_reset_device() - reset/restore the state of input device\n * @dev: input device whose state needs to be reset\n *\n * This function tries to reset the state of an opened input device and\n * bring internal state and state if the hardware in sync with each other.\n * We mark all keys as released, restore LED state, repeat rate, etc.\n */\nvoid input_reset_device(struct input_dev *dev)\n{\n\tunsigned long flags;\n\n\tmutex_lock(&dev->mutex);\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\tinput_dev_toggle(dev, true);\n\tinput_dev_release_keys(dev);\n\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\tmutex_unlock(&dev->mutex);\n}\nEXPORT_SYMBOL(input_reset_device);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int input_dev_suspend(struct device *dev)\n{\n\tstruct input_dev *input_dev = to_input_dev(dev);\n\n\tspin_lock_irq(&input_dev->event_lock);\n\n\t/*\n\t * Keys that are pressed now are unlikely to be\n\t * still pressed when we resume.\n\t */\n\tinput_dev_release_keys(input_dev);\n\n\t/* Turn off LEDs and sounds, if any are active. */\n\tinput_dev_toggle(input_dev, false);\n\n\tspin_unlock_irq(&input_dev->event_lock);\n\n\treturn 0;\n}\n\nstatic int input_dev_resume(struct device *dev)\n{\n\tstruct input_dev *input_dev = to_input_dev(dev);\n\n\tspin_lock_irq(&input_dev->event_lock);\n\n\t/* Restore state of LEDs and sounds, if any were active. */\n\tinput_dev_toggle(input_dev, true);\n\n\tspin_unlock_irq(&input_dev->event_lock);\n\n\treturn 0;\n}\n\nstatic int input_dev_freeze(struct device *dev)\n{\n\tstruct input_dev *input_dev = to_input_dev(dev);\n\n\tspin_lock_irq(&input_dev->event_lock);\n\n\t/*\n\t * Keys that are pressed now are unlikely to be\n\t * still pressed when we resume.\n\t */\n\tinput_dev_release_keys(input_dev);\n\n\tspin_unlock_irq(&input_dev->event_lock);\n\n\treturn 0;\n}\n\nstatic int input_dev_poweroff(struct device *dev)\n{\n\tstruct input_dev *input_dev = to_input_dev(dev);\n\n\tspin_lock_irq(&input_dev->event_lock);\n\n\t/* Turn off LEDs and sounds, if any are active. */\n\tinput_dev_toggle(input_dev, false);\n\n\tspin_unlock_irq(&input_dev->event_lock);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops input_dev_pm_ops = {\n\t.suspend\t= input_dev_suspend,\n\t.resume\t\t= input_dev_resume,\n\t.freeze\t\t= input_dev_freeze,\n\t.poweroff\t= input_dev_poweroff,\n\t.restore\t= input_dev_resume,\n};\n#endif /* CONFIG_PM */\n\nstatic const struct device_type input_dev_type = {\n\t.groups\t\t= input_dev_attr_groups,\n\t.release\t= input_dev_release,\n\t.uevent\t\t= input_dev_uevent,\n#ifdef CONFIG_PM_SLEEP\n\t.pm\t\t= &input_dev_pm_ops,\n#endif\n};\n\nstatic char *input_devnode(struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"input/%s\", dev_name(dev));\n}\n\nstruct class input_class = {\n\t.name\t\t= \"input\",\n\t.devnode\t= input_devnode,\n};\nEXPORT_SYMBOL_GPL(input_class);\n\n/**\n * input_allocate_device - allocate memory for new input device\n *\n * Returns prepared struct input_dev or %NULL.\n *\n * NOTE: Use input_free_device() to free devices that have not been\n * registered; input_unregister_device() should be used for already\n * registered devices.\n */\nstruct input_dev *input_allocate_device(void)\n{\n\tstatic atomic_t input_no = ATOMIC_INIT(-1);\n\tstruct input_dev *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev) {\n\t\tdev->dev.type = &input_dev_type;\n\t\tdev->dev.class = &input_class;\n\t\tdevice_initialize(&dev->dev);\n\t\tmutex_init(&dev->mutex);\n\t\tspin_lock_init(&dev->event_lock);\n\t\ttimer_setup(&dev->timer, NULL, 0);\n\t\tINIT_LIST_HEAD(&dev->h_list);\n\t\tINIT_LIST_HEAD(&dev->node);\n\n\t\tdev_set_name(&dev->dev, \"input%lu\",\n\t\t\t     (unsigned long)atomic_inc_return(&input_no));\n\n\t\t__module_get(THIS_MODULE);\n\t}\n\n\treturn dev;\n}\nEXPORT_SYMBOL(input_allocate_device);\n\nstruct input_devres {\n\tstruct input_dev *input;\n};\n\nstatic int devm_input_device_match(struct device *dev, void *res, void *data)\n{\n\tstruct input_devres *devres = res;\n\n\treturn devres->input == data;\n}\n\nstatic void devm_input_device_release(struct device *dev, void *res)\n{\n\tstruct input_devres *devres = res;\n\tstruct input_dev *input = devres->input;\n\n\tdev_dbg(dev, \"%s: dropping reference to %s\\n\",\n\t\t__func__, dev_name(&input->dev));\n\tinput_put_device(input);\n}\n\n/**\n * devm_input_allocate_device - allocate managed input device\n * @dev: device owning the input device being created\n *\n * Returns prepared struct input_dev or %NULL.\n *\n * Managed input devices do not need to be explicitly unregistered or\n * freed as it will be done automatically when owner device unbinds from\n * its driver (or binding fails). Once managed input device is allocated,\n * it is ready to be set up and registered in the same fashion as regular\n * input device. There are no special devm_input_device_[un]register()\n * variants, regular ones work with both managed and unmanaged devices,\n * should you need them. In most cases however, managed input device need\n * not be explicitly unregistered or freed.\n *\n * NOTE: the owner device is set up as parent of input device and users\n * should not override it.\n */\nstruct input_dev *devm_input_allocate_device(struct device *dev)\n{\n\tstruct input_dev *input;\n\tstruct input_devres *devres;\n\n\tdevres = devres_alloc(devm_input_device_release,\n\t\t\t      sizeof(*devres), GFP_KERNEL);\n\tif (!devres)\n\t\treturn NULL;\n\n\tinput = input_allocate_device();\n\tif (!input) {\n\t\tdevres_free(devres);\n\t\treturn NULL;\n\t}\n\n\tinput->dev.parent = dev;\n\tinput->devres_managed = true;\n\n\tdevres->input = input;\n\tdevres_add(dev, devres);\n\n\treturn input;\n}\nEXPORT_SYMBOL(devm_input_allocate_device);\n\n/**\n * input_free_device - free memory occupied by input_dev structure\n * @dev: input device to free\n *\n * This function should only be used if input_register_device()\n * was not called yet or if it failed. Once device was registered\n * use input_unregister_device() and memory will be freed once last\n * reference to the device is dropped.\n *\n * Device should be allocated by input_allocate_device().\n *\n * NOTE: If there are references to the input device then memory\n * will not be freed until last reference is dropped.\n */\nvoid input_free_device(struct input_dev *dev)\n{\n\tif (dev) {\n\t\tif (dev->devres_managed)\n\t\t\tWARN_ON(devres_destroy(dev->dev.parent,\n\t\t\t\t\t\tdevm_input_device_release,\n\t\t\t\t\t\tdevm_input_device_match,\n\t\t\t\t\t\tdev));\n\t\tinput_put_device(dev);\n\t}\n}\nEXPORT_SYMBOL(input_free_device);\n\n/**\n * input_set_timestamp - set timestamp for input events\n * @dev: input device to set timestamp for\n * @timestamp: the time at which the event has occurred\n *   in CLOCK_MONOTONIC\n *\n * This function is intended to provide to the input system a more\n * accurate time of when an event actually occurred. The driver should\n * call this function as soon as a timestamp is acquired ensuring\n * clock conversions in input_set_timestamp are done correctly.\n *\n * The system entering suspend state between timestamp acquisition and\n * calling input_set_timestamp can result in inaccurate conversions.\n */\nvoid input_set_timestamp(struct input_dev *dev, ktime_t timestamp)\n{\n\tdev->timestamp[INPUT_CLK_MONO] = timestamp;\n\tdev->timestamp[INPUT_CLK_REAL] = ktime_mono_to_real(timestamp);\n\tdev->timestamp[INPUT_CLK_BOOT] = ktime_mono_to_any(timestamp,\n\t\t\t\t\t\t\t   TK_OFFS_BOOT);\n}\nEXPORT_SYMBOL(input_set_timestamp);\n\n/**\n * input_get_timestamp - get timestamp for input events\n * @dev: input device to get timestamp from\n *\n * A valid timestamp is a timestamp of non-zero value.\n */\nktime_t *input_get_timestamp(struct input_dev *dev)\n{\n\tconst ktime_t invalid_timestamp = ktime_set(0, 0);\n\n\tif (!ktime_compare(dev->timestamp[INPUT_CLK_MONO], invalid_timestamp))\n\t\tinput_set_timestamp(dev, ktime_get());\n\n\treturn dev->timestamp;\n}\nEXPORT_SYMBOL(input_get_timestamp);\n\n/**\n * input_set_capability - mark device as capable of a certain event\n * @dev: device that is capable of emitting or accepting event\n * @type: type of the event (EV_KEY, EV_REL, etc...)\n * @code: event code\n *\n * In addition to setting up corresponding bit in appropriate capability\n * bitmap the function also adjusts dev->evbit.\n */\nvoid input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code)\n{\n\tswitch (type) {\n\tcase EV_KEY:\n\t\t__set_bit(code, dev->keybit);\n\t\tbreak;\n\n\tcase EV_REL:\n\t\t__set_bit(code, dev->relbit);\n\t\tbreak;\n\n\tcase EV_ABS:\n\t\tinput_alloc_absinfo(dev);\n\t\tif (!dev->absinfo)\n\t\t\treturn;\n\n\t\t__set_bit(code, dev->absbit);\n\t\tbreak;\n\n\tcase EV_MSC:\n\t\t__set_bit(code, dev->mscbit);\n\t\tbreak;\n\n\tcase EV_SW:\n\t\t__set_bit(code, dev->swbit);\n\t\tbreak;\n\n\tcase EV_LED:\n\t\t__set_bit(code, dev->ledbit);\n\t\tbreak;\n\n\tcase EV_SND:\n\t\t__set_bit(code, dev->sndbit);\n\t\tbreak;\n\n\tcase EV_FF:\n\t\t__set_bit(code, dev->ffbit);\n\t\tbreak;\n\n\tcase EV_PWR:\n\t\t/* do nothing */\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"%s: unknown type %u (code %u)\\n\", __func__, type, code);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\t__set_bit(type, dev->evbit);\n}\nEXPORT_SYMBOL(input_set_capability);\n\nstatic unsigned int input_estimate_events_per_packet(struct input_dev *dev)\n{\n\tint mt_slots;\n\tint i;\n\tunsigned int events;\n\n\tif (dev->mt) {\n\t\tmt_slots = dev->mt->num_slots;\n\t} else if (test_bit(ABS_MT_TRACKING_ID, dev->absbit)) {\n\t\tmt_slots = dev->absinfo[ABS_MT_TRACKING_ID].maximum -\n\t\t\t   dev->absinfo[ABS_MT_TRACKING_ID].minimum + 1,\n\t\tmt_slots = clamp(mt_slots, 2, 32);\n\t} else if (test_bit(ABS_MT_POSITION_X, dev->absbit)) {\n\t\tmt_slots = 2;\n\t} else {\n\t\tmt_slots = 0;\n\t}\n\n\tevents = mt_slots + 1; /* count SYN_MT_REPORT and SYN_REPORT */\n\n\tif (test_bit(EV_ABS, dev->evbit))\n\t\tfor_each_set_bit(i, dev->absbit, ABS_CNT)\n\t\t\tevents += input_is_mt_axis(i) ? mt_slots : 1;\n\n\tif (test_bit(EV_REL, dev->evbit))\n\t\tevents += bitmap_weight(dev->relbit, REL_CNT);\n\n\t/* Make room for KEY and MSC events */\n\tevents += 7;\n\n\treturn events;\n}\n\n#define INPUT_CLEANSE_BITMASK(dev, type, bits)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!test_bit(EV_##type, dev->evbit))\t\t\t\\\n\t\t\tmemset(dev->bits##bit, 0,\t\t\t\\\n\t\t\t\tsizeof(dev->bits##bit));\t\t\\\n\t} while (0)\n\nstatic void input_cleanse_bitmasks(struct input_dev *dev)\n{\n\tINPUT_CLEANSE_BITMASK(dev, KEY, key);\n\tINPUT_CLEANSE_BITMASK(dev, REL, rel);\n\tINPUT_CLEANSE_BITMASK(dev, ABS, abs);\n\tINPUT_CLEANSE_BITMASK(dev, MSC, msc);\n\tINPUT_CLEANSE_BITMASK(dev, LED, led);\n\tINPUT_CLEANSE_BITMASK(dev, SND, snd);\n\tINPUT_CLEANSE_BITMASK(dev, FF, ff);\n\tINPUT_CLEANSE_BITMASK(dev, SW, sw);\n}\n\nstatic void __input_unregister_device(struct input_dev *dev)\n{\n\tstruct input_handle *handle, *next;\n\n\tinput_disconnect_device(dev);\n\n\tmutex_lock(&input_mutex);\n\n\tlist_for_each_entry_safe(handle, next, &dev->h_list, d_node)\n\t\thandle->handler->disconnect(handle);\n\tWARN_ON(!list_empty(&dev->h_list));\n\n\tdel_timer_sync(&dev->timer);\n\tlist_del_init(&dev->node);\n\n\tinput_wakeup_procfs_readers();\n\n\tmutex_unlock(&input_mutex);\n\n\tdevice_del(&dev->dev);\n}\n\nstatic void devm_input_device_unregister(struct device *dev, void *res)\n{\n\tstruct input_devres *devres = res;\n\tstruct input_dev *input = devres->input;\n\n\tdev_dbg(dev, \"%s: unregistering device %s\\n\",\n\t\t__func__, dev_name(&input->dev));\n\t__input_unregister_device(input);\n}\n\n/**\n * input_enable_softrepeat - enable software autorepeat\n * @dev: input device\n * @delay: repeat delay\n * @period: repeat period\n *\n * Enable software autorepeat on the input device.\n */\nvoid input_enable_softrepeat(struct input_dev *dev, int delay, int period)\n{\n\tdev->timer.function = input_repeat_key;\n\tdev->rep[REP_DELAY] = delay;\n\tdev->rep[REP_PERIOD] = period;\n}\nEXPORT_SYMBOL(input_enable_softrepeat);\n\n/**\n * input_register_device - register device with input core\n * @dev: device to be registered\n *\n * This function registers device with input core. The device must be\n * allocated with input_allocate_device() and all it's capabilities\n * set up before registering.\n * If function fails the device must be freed with input_free_device().\n * Once device has been successfully registered it can be unregistered\n * with input_unregister_device(); input_free_device() should not be\n * called in this case.\n *\n * Note that this function is also used to register managed input devices\n * (ones allocated with devm_input_allocate_device()). Such managed input\n * devices need not be explicitly unregistered or freed, their tear down\n * is controlled by the devres infrastructure. It is also worth noting\n * that tear down of managed input devices is internally a 2-step process:\n * registered managed input device is first unregistered, but stays in\n * memory and can still handle input_event() calls (although events will\n * not be delivered anywhere). The freeing of managed input device will\n * happen later, when devres stack is unwound to the point where device\n * allocation was made.\n */\nint input_register_device(struct input_dev *dev)\n{\n\tstruct input_devres *devres = NULL;\n\tstruct input_handler *handler;\n\tunsigned int packet_size;\n\tconst char *path;\n\tint error;\n\n\tif (test_bit(EV_ABS, dev->evbit) && !dev->absinfo) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Absolute device without dev->absinfo, refusing to register\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev->devres_managed) {\n\t\tdevres = devres_alloc(devm_input_device_unregister,\n\t\t\t\t      sizeof(*devres), GFP_KERNEL);\n\t\tif (!devres)\n\t\t\treturn -ENOMEM;\n\n\t\tdevres->input = dev;\n\t}\n\n\t/* Every input device generates EV_SYN/SYN_REPORT events. */\n\t__set_bit(EV_SYN, dev->evbit);\n\n\t/* KEY_RESERVED is not supposed to be transmitted to userspace. */\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\n\t/* Make sure that bitmasks not mentioned in dev->evbit are clean. */\n\tinput_cleanse_bitmasks(dev);\n\n\tpacket_size = input_estimate_events_per_packet(dev);\n\tif (dev->hint_events_per_packet < packet_size)\n\t\tdev->hint_events_per_packet = packet_size;\n\n\tdev->max_vals = dev->hint_events_per_packet + 2;\n\tdev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);\n\tif (!dev->vals) {\n\t\terror = -ENOMEM;\n\t\tgoto err_devres_free;\n\t}\n\n\t/*\n\t * If delay and period are pre-set by the driver, then autorepeating\n\t * is handled by the driver itself and we don't do it in input.c.\n\t */\n\tif (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD])\n\t\tinput_enable_softrepeat(dev, 250, 33);\n\n\tif (!dev->getkeycode)\n\t\tdev->getkeycode = input_default_getkeycode;\n\n\tif (!dev->setkeycode)\n\t\tdev->setkeycode = input_default_setkeycode;\n\n\tif (dev->poller)\n\t\tinput_dev_poller_finalize(dev->poller);\n\n\terror = device_add(&dev->dev);\n\tif (error)\n\t\tgoto err_free_vals;\n\n\tpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n\tpr_info(\"%s as %s\\n\",\n\t\tdev->name ? dev->name : \"Unspecified device\",\n\t\tpath ? path : \"N/A\");\n\tkfree(path);\n\n\terror = mutex_lock_interruptible(&input_mutex);\n\tif (error)\n\t\tgoto err_device_del;\n\n\tlist_add_tail(&dev->node, &input_dev_list);\n\n\tlist_for_each_entry(handler, &input_handler_list, node)\n\t\tinput_attach_handler(dev, handler);\n\n\tinput_wakeup_procfs_readers();\n\n\tmutex_unlock(&input_mutex);\n\n\tif (dev->devres_managed) {\n\t\tdev_dbg(dev->dev.parent, \"%s: registering %s with devres.\\n\",\n\t\t\t__func__, dev_name(&dev->dev));\n\t\tdevres_add(dev->dev.parent, devres);\n\t}\n\treturn 0;\n\nerr_device_del:\n\tdevice_del(&dev->dev);\nerr_free_vals:\n\tkfree(dev->vals);\n\tdev->vals = NULL;\nerr_devres_free:\n\tdevres_free(devres);\n\treturn error;\n}\nEXPORT_SYMBOL(input_register_device);\n\n/**\n * input_unregister_device - unregister previously registered device\n * @dev: device to be unregistered\n *\n * This function unregisters an input device. Once device is unregistered\n * the caller should not try to access it as it may get freed at any moment.\n */\nvoid input_unregister_device(struct input_dev *dev)\n{\n\tif (dev->devres_managed) {\n\t\tWARN_ON(devres_destroy(dev->dev.parent,\n\t\t\t\t\tdevm_input_device_unregister,\n\t\t\t\t\tdevm_input_device_match,\n\t\t\t\t\tdev));\n\t\t__input_unregister_device(dev);\n\t\t/*\n\t\t * We do not do input_put_device() here because it will be done\n\t\t * when 2nd devres fires up.\n\t\t */\n\t} else {\n\t\t__input_unregister_device(dev);\n\t\tinput_put_device(dev);\n\t}\n}\nEXPORT_SYMBOL(input_unregister_device);\n\n/**\n * input_register_handler - register a new input handler\n * @handler: handler to be registered\n *\n * This function registers a new input handler (interface) for input\n * devices in the system and attaches it to all input devices that\n * are compatible with the handler.\n */\nint input_register_handler(struct input_handler *handler)\n{\n\tstruct input_dev *dev;\n\tint error;\n\n\terror = mutex_lock_interruptible(&input_mutex);\n\tif (error)\n\t\treturn error;\n\n\tINIT_LIST_HEAD(&handler->h_list);\n\n\tlist_add_tail(&handler->node, &input_handler_list);\n\n\tlist_for_each_entry(dev, &input_dev_list, node)\n\t\tinput_attach_handler(dev, handler);\n\n\tinput_wakeup_procfs_readers();\n\n\tmutex_unlock(&input_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL(input_register_handler);\n\n/**\n * input_unregister_handler - unregisters an input handler\n * @handler: handler to be unregistered\n *\n * This function disconnects a handler from its input devices and\n * removes it from lists of known handlers.\n */\nvoid input_unregister_handler(struct input_handler *handler)\n{\n\tstruct input_handle *handle, *next;\n\n\tmutex_lock(&input_mutex);\n\n\tlist_for_each_entry_safe(handle, next, &handler->h_list, h_node)\n\t\thandler->disconnect(handle);\n\tWARN_ON(!list_empty(&handler->h_list));\n\n\tlist_del_init(&handler->node);\n\n\tinput_wakeup_procfs_readers();\n\n\tmutex_unlock(&input_mutex);\n}\nEXPORT_SYMBOL(input_unregister_handler);\n\n/**\n * input_handler_for_each_handle - handle iterator\n * @handler: input handler to iterate\n * @data: data for the callback\n * @fn: function to be called for each handle\n *\n * Iterate over @bus's list of devices, and call @fn for each, passing\n * it @data and stop when @fn returns a non-zero value. The function is\n * using RCU to traverse the list and therefore may be using in atomic\n * contexts. The @fn callback is invoked from RCU critical section and\n * thus must not sleep.\n */\nint input_handler_for_each_handle(struct input_handler *handler, void *data,\n\t\t\t\t  int (*fn)(struct input_handle *, void *))\n{\n\tstruct input_handle *handle;\n\tint retval = 0;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(handle, &handler->h_list, h_node) {\n\t\tretval = fn(handle, data);\n\t\tif (retval)\n\t\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n\n\treturn retval;\n}\nEXPORT_SYMBOL(input_handler_for_each_handle);\n\n/**\n * input_register_handle - register a new input handle\n * @handle: handle to register\n *\n * This function puts a new input handle onto device's\n * and handler's lists so that events can flow through\n * it once it is opened using input_open_device().\n *\n * This function is supposed to be called from handler's\n * connect() method.\n */\nint input_register_handle(struct input_handle *handle)\n{\n\tstruct input_handler *handler = handle->handler;\n\tstruct input_dev *dev = handle->dev;\n\tint error;\n\n\t/*\n\t * We take dev->mutex here to prevent race with\n\t * input_release_device().\n\t */\n\terror = mutex_lock_interruptible(&dev->mutex);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Filters go to the head of the list, normal handlers\n\t * to the tail.\n\t */\n\tif (handler->filter)\n\t\tlist_add_rcu(&handle->d_node, &dev->h_list);\n\telse\n\t\tlist_add_tail_rcu(&handle->d_node, &dev->h_list);\n\n\tmutex_unlock(&dev->mutex);\n\n\t/*\n\t * Since we are supposed to be called from ->connect()\n\t * which is mutually exclusive with ->disconnect()\n\t * we can't be racing with input_unregister_handle()\n\t * and so separate lock is not needed here.\n\t */\n\tlist_add_tail_rcu(&handle->h_node, &handler->h_list);\n\n\tif (handler->start)\n\t\thandler->start(handle);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(input_register_handle);\n\n/**\n * input_unregister_handle - unregister an input handle\n * @handle: handle to unregister\n *\n * This function removes input handle from device's\n * and handler's lists.\n *\n * This function is supposed to be called from handler's\n * disconnect() method.\n */\nvoid input_unregister_handle(struct input_handle *handle)\n{\n\tstruct input_dev *dev = handle->dev;\n\n\tlist_del_rcu(&handle->h_node);\n\n\t/*\n\t * Take dev->mutex to prevent race with input_release_device().\n\t */\n\tmutex_lock(&dev->mutex);\n\tlist_del_rcu(&handle->d_node);\n\tmutex_unlock(&dev->mutex);\n\n\tsynchronize_rcu();\n}\nEXPORT_SYMBOL(input_unregister_handle);\n\n/**\n * input_get_new_minor - allocates a new input minor number\n * @legacy_base: beginning or the legacy range to be searched\n * @legacy_num: size of legacy range\n * @allow_dynamic: whether we can also take ID from the dynamic range\n *\n * This function allocates a new device minor for from input major namespace.\n * Caller can request legacy minor by specifying @legacy_base and @legacy_num\n * parameters and whether ID can be allocated from dynamic range if there are\n * no free IDs in legacy range.\n */\nint input_get_new_minor(int legacy_base, unsigned int legacy_num,\n\t\t\tbool allow_dynamic)\n{\n\t/*\n\t * This function should be called from input handler's ->connect()\n\t * methods, which are serialized with input_mutex, so no additional\n\t * locking is needed here.\n\t */\n\tif (legacy_base >= 0) {\n\t\tint minor = ida_simple_get(&input_ida,\n\t\t\t\t\t   legacy_base,\n\t\t\t\t\t   legacy_base + legacy_num,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (minor >= 0 || !allow_dynamic)\n\t\t\treturn minor;\n\t}\n\n\treturn ida_simple_get(&input_ida,\n\t\t\t      INPUT_FIRST_DYNAMIC_DEV, INPUT_MAX_CHAR_DEVICES,\n\t\t\t      GFP_KERNEL);\n}\nEXPORT_SYMBOL(input_get_new_minor);\n\n/**\n * input_free_minor - release previously allocated minor\n * @minor: minor to be released\n *\n * This function releases previously allocated input minor so that it can be\n * reused later.\n */\nvoid input_free_minor(unsigned int minor)\n{\n\tida_simple_remove(&input_ida, minor);\n}\nEXPORT_SYMBOL(input_free_minor);\n\nstatic int __init input_init(void)\n{\n\tint err;\n\n\terr = class_register(&input_class);\n\tif (err) {\n\t\tpr_err(\"unable to register input_dev class\\n\");\n\t\treturn err;\n\t}\n\n\terr = input_proc_init();\n\tif (err)\n\t\tgoto fail1;\n\n\terr = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),\n\t\t\t\t     INPUT_MAX_CHAR_DEVICES, \"input\");\n\tif (err) {\n\t\tpr_err(\"unable to register char major %d\", INPUT_MAJOR);\n\t\tgoto fail2;\n\t}\n\n\treturn 0;\n\n fail2:\tinput_proc_exit();\n fail1:\tclass_unregister(&input_class);\n\treturn err;\n}\n\nstatic void __exit input_exit(void)\n{\n\tinput_proc_exit();\n\tunregister_chrdev_region(MKDEV(INPUT_MAJOR, 0),\n\t\t\t\t INPUT_MAX_CHAR_DEVICES);\n\tclass_unregister(&input_class);\n}\n\nsubsys_initcall(input_init);\nmodule_exit(input_exit);\n"], "filenames": ["drivers/input/input.c"], "buggy_code_start_loc": [881], "buggy_code_end_loc": [949], "fixing_code_start_loc": [881], "fixing_code_end_loc": [955], "type": "CWE-787", "message": "In the Linux kernel before 5.4.12, drivers/input/input.c has out-of-bounds writes via a crafted keycode table, as demonstrated by input_set_keycode, aka CID-cb222aed03d7.", "other": {"cve": {"id": "CVE-2019-20636", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-08T14:15:12.600", "lastModified": "2020-06-10T13:15:10.823", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 5.4.12, drivers/input/input.c has out-of-bounds writes via a crafted keycode table, as demonstrated by input_set_keycode, aka CID-cb222aed03d7."}, {"lang": "es", "value": "En el kernel de Linux versiones anteriores a 5.4.12, el archivo drivers/input/input.c presenta escrituras fuera de l\u00edmites por medio de una tabla de c\u00f3digos clave dise\u00f1ada, como es demostrado en la funci\u00f3n input_set_keycode, tambi\u00e9n se conoce como CID-cb222aed03d7."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.4.12", "matchCriteriaId": "DE51CB48-9127-43B3-B48C-877FE4A131D5"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.4.12", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=cb222aed03d798fc074be55e59d9a112338ee784", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/cb222aed03d798fc074be55e59d9a112338ee784", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00011.html", "source": "cve@mitre.org"}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00013.html", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20200430-0004/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/cb222aed03d798fc074be55e59d9a112338ee784"}}