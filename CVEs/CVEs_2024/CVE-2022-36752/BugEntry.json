{"buggy_code": ["// anti-copyright Lucy Phipps 2022\n// vi: sw=2 tw=80\n#define VERSION \"v1.0.4\"\n#include <errno.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <setjmp.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#if CHAR_BIT != 8\n#error \"char isn't 8-bit\"\n#endif\n#if __STDC_VERSION__ < 201112L && !defined NOFOPENX\n#define NOFOPENX\n#endif\n#ifdef NOFOPENX\n#include <fcntl.h>\n#include <sys/stat.h>\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n#endif\n#ifdef _WIN32\n#define _CRT_NONSTDC_NO_WARNINGS\n#include <fcntl.h>\n#include <io.h>\n#else\n#include <unistd.h>\n#define setmode(x, y) 0\n#endif\n#include \"png.h\"\n#include \"webp/decode.h\"\n#include \"webp/encode.h\"\nstatic int help(void) {\n  fputs(\"PNG2WebP \" VERSION \"\\n\\\n\\n\\\nUsage:\\n\\\npng2webp [-refv-] INFILE ...\\n\\\npng2webp -p[refv-] [{INFILE|-} [OUTFILE|-]]\\n\\\n\\n\\\n-p: Work with a single file, allowing Piping from stdin or to stdout,\\n\\\n    or using a different output filename to the input.\\n\\\n    `INFILE` and `OUTFILE` default to stdin and stdout respectively,\\n\\\n    or explicitly as \\\"-\\\".\\n\\\n    Will show this message if stdin/stdout is used and is a terminal.\\n\\\n-r: Convert from WebP to PNG instead.\\n\\\n-e: Keep RGB data on pixels where alpha is 0. Always enabled for `-r`.\\n\\\n-f: Force overwrite of output files (has no effect on stdout).\\n\\\n-v: Be verbose.\\n\\\n--: Explicitly stop parsing options.\\n\",\n    stderr);\n  return -1;\n}\nstatic bool exact = 0, force = 0, verbose = 0;\n#define PF(x, ...) fprintf(stderr, x \"\\n\", __VA_ARGS__)\n#define PFV(...) \\\n  if(verbose) PF(__VA_ARGS__)\n#define IP (ip ? ip : \"<stdin>\")\n#define OP (op ? op : \"<stdout>\")\nstatic FILE *openr(char *ip) {\n  PFV(\"Decoding %s ...\", IP);\n  if(!ip) return stdin;\n  FILE *fp;\n#ifdef NOFOPENX\n  int fd = open(ip, O_RDONLY | O_BINARY);\n  if(fd == -1) {\n    PF(\"ERROR opening %s for %s: %s\", ip, \"reading\", strerror(errno));\n    return 0;\n  }\n  if(!(fp = fdopen(fd, \"rb\"))) {\n    PF(\"ERROR opening %s for %s: %s\", ip, \"reading\", strerror(errno));\n    close(fd);\n    return 0;\n  }\n#else\n  if(!(fp = fopen(ip, \"rb\"))) {\n    PF(\"ERROR opening %s for %s: %s\", ip, \"reading\", strerror(errno));\n    return 0;\n  }\n#endif\n  return fp;\n}\nstatic FILE *openw(char *op) {\n  PFV(\"Encoding %s ...\", OP);\n  if(!op) return stdout;\n  FILE *fp;\n#define EO(x) \\\n  if(!(x)) { \\\n    PF(\"ERROR opening %s for %s: %s\", op, force ? \"writing\" : \"creation\", \\\n      strerror(errno)); \\\n    return 0; \\\n  }\n#ifdef NOFOPENX\n  int fd = open(op, O_WRONLY | O_CREAT | O_TRUNC | (!force * O_EXCL) | O_BINARY,\n#ifdef _WIN32\n    S_IREAD | S_IWRITE\n#else\n    S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH\n#endif\n  );\n  EO(fd != -1)\n  if(!(fp = fdopen(fd, \"wb\"))) {\n    PF(\"ERROR opening %s for %s: %s\", op, force ? \"writing\" : \"creation\",\n      strerror(errno));\n    close(fd);\n    remove(op);\n    return 0;\n  }\n#else\n  EO(fp = fopen(op, force ? \"wb\" : \"wbx\"))\n#endif\n  return fp;\n}\nstatic size_t pnglen;\nstatic void pngread(png_struct *p, uint8_t *d, size_t s) {\n  if(!fread(d, s, 1, png_get_io_ptr(p))) png_error(p, \"I/O error\");\n  pnglen += s;\n}\nstatic void pngwrite(png_struct *p, uint8_t *d, size_t s) {\n  if(!fwrite(d, s, 1, png_get_io_ptr(p))) png_error(p, \"I/O error\");\n  pnglen += s;\n}\nstatic void pngflush(png_struct *p) {\n#ifdef DOFLUSH\n  fflush(png_get_io_ptr(p));\n#else\n  (void)p;\n#endif\n}\nstatic void pngrerr(png_struct *p, const char *s) {\n  PF(\"ERROR reading %s: %s\", (char *)png_get_error_ptr(p), s);\n  png_longjmp(p, 1);\n}\nstatic void pngwerr(png_struct *p, const char *s) {\n  PF(\"ERROR writing %s: %s\", (char *)png_get_error_ptr(p), s);\n  png_longjmp(p, 1);\n}\nstatic void pngwarn(png_struct *p, const char *s) {\n  PF(\"Warning: %s: %s\", (char *)png_get_error_ptr(p), s);\n}\nstatic int webpwrite(const uint8_t *d, size_t s, const WebPPicture *p) {\n  return (int)fwrite(d, s, 1, p->custom_ptr);\n}\n#define E(x, ...) \\\n  if(!(x)) { \\\n    PF(\"ERROR \" __VA_ARGS__); \\\n    return 1; \\\n  }\nstatic bool p2w(char *ip, char *op) {\n  FILE *fp = openr(ip);\n  if(!fp) return 1;\n  uint32_t *b = 0;\n  png_info *n = 0;\n  char *k[] = {\"Out of memory\",\n    \"???\", // oom flushing bitstream, unused in libwebp\n    \"???\", // null param\n    \"Broken config, file a bug report\",\n    \"???\", // image too big (already checked)\n    \"???\", \"???\", // lossy\n    \"I/O error\",\n    \"???\", // lossy\n    \"???\"}; // canceled\n  png_struct *p =\n    png_create_read_struct(PNG_LIBPNG_VER_STRING, ip, pngrerr, pngwarn);\n  if(!p) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto p2w_close;\n  }\n  n = png_create_info_struct(p);\n  if(!n) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto p2w_close;\n  }\n  if(setjmp(png_jmpbuf(p))) {\n  p2w_close:\n    fclose(fp);\n    png_destroy_read_struct(&p, &n, 0);\n  p2w_free:\n    free(b);\n    return 1;\n  }\n  pnglen = 0;\n  png_set_read_fn(p, fp, pngread);\n  png_read_info(p, n);\n  uint32_t width, height;\n  int bitdepth, colortype;\n  png_get_IHDR(p, n, &width, &height, &bitdepth, &colortype, 0, 0, 0);\n  if(width > 16383 || height > 16383) {\n    PF(\"ERROR reading %s: Image too big (%\" PRIu32 \" x %\" PRIu32\n       \", max. 16383 x 16383 px)\",\n      IP, width, height);\n    goto p2w_close;\n  }\n  if((unsigned)bitdepth > 8)\n    PF(\"Warning: %s is 16-bit, will be downsampled to 8-bit\", IP);\n  bool trns = png_get_valid(p, n, PNG_INFO_tRNS);\n#ifdef FIXEDGAMMA\n#define GAMMA ((uint32_t)gamma) / 1e5\n  int32_t gamma = 45455;\n  if(png_get_valid(p, n, PNG_INFO_sRGB) || png_get_gAMA_fixed(p, n, &gamma))\n    png_set_gamma_fixed(p, 22e4, gamma);\n#else\n#define GAMMA gamma\n  double gamma = 1 / 2.2;\n  if(png_get_valid(p, n, PNG_INFO_sRGB) || png_get_gAMA(p, n, &gamma))\n    png_set_gamma(p, 2.2, gamma);\n#endif\n#define S(x) png_set_##x(p)\n  S(scale_16);\n  S(expand);\n  S(gray_to_rgb);\n  S(packing);\n  if(*(uint8_t *)&(uint16_t){1}) {\n    S(bgr);\n    png_set_add_alpha(p, 255, PNG_FILLER_AFTER);\n  } else {\n    // TODO: test somehow\n    S(swap_alpha);\n    png_set_add_alpha(p, 255, PNG_FILLER_BEFORE);\n  }\n  int passes = S(interlace_handling);\n  png_read_update_info(p, n);\n#ifndef NDEBUG\n  size_t rowbytes = png_get_rowbytes(p, n);\n  if(rowbytes != (size_t)4 * width) {\n    PF(\"ERROR reading %s: rowbytes is %zu, should be %zu\", IP, rowbytes,\n      (size_t)4 * width);\n    goto p2w_close;\n  }\n#endif\n  b = malloc(width * height * 4);\n  if(!b) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto p2w_close;\n  }\n  for(unsigned x = (unsigned)passes; x; x--) {\n    uint8_t *w = (uint8_t *)b;\n    for(unsigned y = height; y; y--) {\n      png_read_row(p, w, 0);\n      w += width * 4;\n    }\n  }\n  png_read_end(p, 0);\n  png_destroy_read_struct(&p, &n, 0);\n  fclose(fp);\n  char *f[] = {\n    \"greyscale\", \"???\", \"RGB\", \"paletted\", \"greyscale + alpha\", \"???\", \"RGBA\"};\n  PFV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32\n      \"\\nSize: %zu bytes (%.15g bpp)\\nFormat: %u-bit %s%s%s\\nGamma: %.5g\",\n    IP, width, height, pnglen, (double)pnglen * 8 / (width * height), bitdepth,\n    f[(unsigned)colortype], trns ? \", with transparency\" : \"\",\n    (unsigned)passes > 1 ? \", interlaced\" : \"\", GAMMA);\n  WebPConfig c;\n  if(!WebPConfigPreset(&c, WEBP_PRESET_ICON, 100)) {\n    PF(\"ERROR writing %s: %s\", OP, k[3]);\n    goto p2w_free;\n  }\n  if(!(fp = openw(op))) goto p2w_free;\n  c.lossless = 1;\n  c.method = 6;\n#ifndef NOTHREADS\n  c.thread_level = 1; // doesn't seem to affect output\n#endif\n  c.exact = exact;\n  WebPAuxStats s;\n  WebPPicture o = {1, .width = (int)width, (int)height, .argb = b,\n    .argb_stride = (int)width, .writer = webpwrite, .custom_ptr = fp,\n    .stats = verbose ? &s : 0};\n  // progress_hook only reports 1, 5, 90, 100 for lossless\n  trns = (trns || (colortype & PNG_COLOR_MASK_ALPHA)) &&\n    WebPPictureHasTransparency(&o);\n  if(!WebPEncode(&c, &o)) {\n    PF(\"ERROR writing %s: %s\", OP, k[o.error_code - 1]);\n    fclose(fp);\n  p2w_rm:\n    if(op) remove(op);\n    goto p2w_free;\n  }\n  if(fclose(fp)) {\n    PF(\"ERROR closing %s: %s\", OP, strerror(errno));\n    goto p2w_rm;\n  }\n  free(b);\n#define F s.lossless_features\n#define C s.palette_size\n  PFV(\"Info: %s:\\nDimensions: %u x %u\\nSize: %u bytes (%.15g bpp)\\n\\\nHeader size: %u, image data size: %u\\nUses alpha: %s\\n\\\nPrecision bits: histogram=%u transform=%u cache=%u\\n\\\nLossless features:%s%s%s%s\\nColors: %s%u\",\n    OP, o.width, o.height, s.lossless_size,\n    (unsigned)s.lossless_size * 8. / (unsigned)(o.width * o.height),\n    s.lossless_hdr_size, s.lossless_data_size, trns ? \"yes\" : \"no\",\n    s.histogram_bits, s.transform_bits, s.cache_bits,\n    F ? F & 1 ? \" prediction\" : \"\" : \" none\", F && F & 2 ? \" cross-color\" : \"\",\n    F && F & 4 ? \" subtract-green\" : \"\", F && F & 8 ? \" palette\" : \"\",\n    C ? \"\" : \">\", C ? C : 256);\n  return 0;\n}\nstatic bool w2p(char *ip, char *op) {\n  FILE *fp = openr(ip);\n  if(!fp) return 1;\n  bool openwdone = 0;\n  uint8_t *x = 0, *b = 0;\n  png_struct *p = 0;\n  png_info *n = 0;\n  uint8_t i[12];\n  char *k[] = {\"Out of memory\", \"Broken config, file a bug report\",\n    \"Invalid WebP\", \"???\", \"???\", \"???\", \"I/O error\"};\n  // unsupported feature, suspended, canceled\n  if(!fread(i, 12, 1, fp)) {\n    PF(\"ERROR reading %s: %s\", IP, k[6]);\n    goto w2p_close;\n  }\n  if(memcmp(i, (char[4]){\"RIFF\"}, 4) || memcmp(i + 8, (char[4]){\"WEBP\"}, 4)) {\n    PF(\"ERROR reading %s: %s\", IP, k[2]);\n    goto w2p_close;\n  }\n  size_t l = ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;\n  // ^ RIFF header size\n  x = malloc(l);\n  if(!x) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto w2p_close;\n  }\n  memcpy(x, i, 12); // should optimize out\n  if(!fread(x + 12, l - 12, 1, fp)) {\n    PF(\"ERROR reading %s: %s\", IP, k[6]);\n    goto w2p_close;\n  }\n  fclose(fp);\n#if defined LOSSYISERROR || defined NOTHREADS\n  WebPBitstreamFeatures I;\n#else\n  WebPDecoderConfig c = {.options.use_threads = 1};\n#define I c.input\n#endif\n  VP8StatusCode r = WebPGetFeatures(x, l, &I);\n  if(r) {\n    PF(\"ERROR reading %s: %s\", IP, k[r - 1]);\n    goto w2p_free;\n  }\n#define V I.format\n#define W ((uint32_t)I.width)\n#define H ((uint32_t)I.height)\n#define A I.has_alpha\n#ifdef LOSSYISERROR\n#define FMTSTR\n#define FMTARG\n#define ANMSTR \"%s\"\n#define ANMARG , \"animat\"\n#else\n  char *f[] = {\"undefined/mixed\", \"lossy\", \"lossless\"};\n#define FMTSTR \"\\nFormat: %s\"\n#define FMTARG , f[V]\n#define ANMSTR \"animat\"\n#define ANMARG\n#endif\n  PFV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32\n      \"\\nSize: %zu bytes (%.15g bpp)\\nUses alpha: %s\" FMTSTR,\n    IP, W, H, l, (double)l * 8 / (W * H), A ? \"yes\" : \"no\" FMTARG);\n  if(I.has_animation) {\n    PF(\"ERROR reading %s: Unsupported feature: \" ANMSTR \"ion\", IP ANMARG);\n    goto w2p_free;\n  }\n#ifdef LOSSYISERROR\n  if(V != 2) {\n    PF(\"ERROR reading %s: Unsupported feature: %sion\", IP, \"lossy compress\");\n    goto w2p_free;\n  }\n#endif\n#define B ((unsigned)(3 + A))\n  b = malloc(W * H * B);\n  if(!b) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto w2p_free;\n  }\n#if defined LOSSYISERROR || defined NOTHREADS\n  if(!(A ? WebPDecodeRGBAInto : WebPDecodeRGBInto)(\n       x, l, b, W * H * B, (int)(W * B))) {\n    PF(\"ERROR reading %s: %s\", IP, k[2]);\n    goto w2p_free;\n  }\n#else\n  c.output.colorspace = A ? MODE_RGBA : MODE_RGB;\n  c.output.is_external_memory = 1;\n#define D c.output.u.RGBA\n  D.rgba = b;\n  D.stride = (int)(W * B);\n  D.size = W * H * B;\n  r = WebPDecode(x, l, &c);\n  if(r) {\n    PF(\"ERROR reading %s: %s\", IP, k[r - 1]);\n    goto w2p_free;\n  }\n#endif\n  free(x);\n  x = 0;\n  if(!(fp = openw(op))) goto w2p_free;\n  openwdone = !!op;\n  p = png_create_write_struct(PNG_LIBPNG_VER_STRING, op, pngwerr, pngwarn);\n  if(!p) {\n    PF(\"ERROR writing %s: %s\", OP, *k);\n    goto w2p_close;\n  }\n  n = png_create_info_struct(p);\n  if(!n) {\n    PF(\"ERROR writing %s: %s\", OP, *k);\n    goto w2p_close;\n  }\n  if(setjmp(png_jmpbuf(p))) {\n  w2p_close:\n    fclose(fp);\n  w2p_free:\n    if(openwdone) remove(op);\n    free(x);\n    free(b);\n    png_destroy_write_struct(&p, &n);\n    return 1;\n  }\n  pnglen = 0;\n  png_set_write_fn(p, fp, pngwrite, pngflush);\n  png_set_filter(p, 0, PNG_ALL_FILTERS);\n  png_set_compression_level(p, 9);\n  // png_set_compression_memlevel(p, 9);\n  png_set_IHDR(p, n, W, H, 8, A ? 6 : 2, 0, 0, 0);\n  png_write_info(p, n);\n  uint8_t *w = b;\n  for(unsigned y = H; y; y--) {\n    png_write_row(p, w);\n    w += W * B;\n  }\n  png_write_end(p, n);\n  png_destroy_write_struct(&p, &n);\n  p = 0;\n  n = 0;\n  free(b);\n  b = 0;\n  if(fclose(fp)) {\n    PF(\"ERROR closing %s: %s\", OP, strerror(errno));\n    goto w2p_free;\n  }\n  PFV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32\n      \"\\nSize: %zu bytes (%.15g bpp)\\nFormat: %u-bit %s%s%s\\nGamma: %.5g\",\n    OP, W, H, pnglen, (double)pnglen * 8 / (W * H), 8, A ? \"RGBA\" : \"RGB\", \"\",\n    \"\", 1 / 2.2);\n  return 0;\n}\nint main(int argc, char **argv) {\n  { // should optimize out\n    uint32_t endian;\n    memcpy(&endian, (char[4]){\"\\xAA\\xBB\\xCC\\xDD\"}, 4);\n    E(endian == 0xAABBCCDD || endian == 0xDDCCBBAA,\n      \"32-bit mixed-endianness (%X) not supported\", endian)\n  }\n  bool pipe = 0, usestdin = 0, usestdout = 0, reverse = 0;\n#ifdef USEGETOPT\n  for(int c; (c = getopt(argc, argv, \":prefv\")) != -1;)\n    switch(c)\n#else\n  while(--argc && **++argv == '-' && argv[0][1])\n    while(*++*argv)\n      switch(**argv)\n#endif\n    {\n      case 'p': pipe = 1; break;\n      case 'r': reverse = 1; break;\n      case 'e': exact = 1; break;\n      case 'f': force = 1; break;\n      case 'v': verbose = 1; break;\n#ifndef USEGETOPT\n      case '-':\n\tif(argv[0][1]) return help();\n\targc--;\n\targv++;\n\tgoto endflagloop;\n#endif\n      default: return help();\n    }\n#ifdef USEGETOPT\n  argc -= optind;\n  argv += optind;\n#else\nendflagloop:\n#endif\n#define URGC (unsigned)argc\n#define PIPEARG(x) (*argv[x] == '-' && !argv[x][1])\n  if(pipe) {\n    if(URGC > 2 || ((usestdin = (!argc || PIPEARG(0))) && isatty(0)) ||\n      ((usestdout = (URGC < 2 || PIPEARG(1))) && isatty(1)))\n      return help();\n    if(usestdin) setmode(0, O_BINARY);\n    if(usestdout) setmode(1, O_BINARY);\n    return (reverse ? w2p : p2w)(usestdin ? 0 : *argv, usestdout ? 0 : argv[1]);\n  }\n  if(!argc) return help();\n  bool ret = 0;\n  if(reverse)\n    for(; argc; argc--, argv++) {\n      size_t len = strlen(*argv);\n      if(len > 4) {\n\tuint32_t ext, extmatch;\n\tmemcpy(&ext, *argv + len - 4, 4);\n\tmemcpy(&extmatch, (char[4]){\"webp\"}, 4);\n\tif(argv[0][len - 5] == '.' && (ext | 0x20202020) == extmatch) len -= 5;\n      }\n      {\n#if defined __STDC_NO_VLA__ && !defined NOVLA\n#define NOVLA\n#endif\n#ifdef NOVLA\n\tchar *op = malloc(len + 5);\n\tE(op, \"adding .%s extension to %s: Out of memory\", \"png\", *argv)\n#else\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wvla\"\n\tchar op[len + 5];\n#pragma GCC diagnostic pop\n#endif\n\tmemcpy(op, *argv, len); // the only real memcpy\n\tmemcpy(op + len, \".png\", 5);\n\tret = w2p(*argv, op) || ret;\n#ifdef NOVLA\n\tfree(op);\n#endif\n      }\n    }\n  else\n    for(; argc; argc--, argv++) {\n      size_t len = strlen(*argv);\n      if(len > 3) {\n\tuint32_t ext, extmask, extmatch;\n\tmemcpy(&ext, *argv + len - 4, 4);\n\tmemcpy(&extmask, (char[4]){\"\\0   \"}, 4);\n\tmemcpy(&extmatch, (char[4]){\".png\"}, 4);\n\tif((ext | extmask) == extmatch) len -= 4;\n      }\n      {\n#ifdef NOVLA\n\tchar *op = malloc(len + 6);\n\tE(op, \"adding .%s extension to %s: Out of memory\", \"webp\", *argv)\n#else\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wvla\"\n\tchar op[len + 6];\n#pragma GCC diagnostic pop\n#endif\n\tmemcpy(op, *argv, len); // the only real memcpy\n\tmemcpy(op + len, \".webp\", 6);\n\tret = p2w(*argv, op) || ret;\n#ifdef NOVLA\n\tfree(op);\n#endif\n      }\n    }\n  return ret;\n}\n"], "fixing_code": ["// anti-copyright Lucy Phipps 2022\n// vi: sw=2 tw=80\n#define VERSION \"v1.0.5\"\n#include <errno.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <setjmp.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#if CHAR_BIT != 8\n#error \"char isn't 8-bit\"\n#endif\n#if __STDC_VERSION__ < 201112L && !defined NOFOPENX\n#define NOFOPENX\n#endif\n#ifdef NOFOPENX\n#include <fcntl.h>\n#include <sys/stat.h>\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n#endif\n#ifdef _WIN32\n#define _CRT_NONSTDC_NO_WARNINGS\n#include <fcntl.h>\n#include <io.h>\n#else\n#include <unistd.h>\n#define setmode(x, y) 0\n#endif\n#include \"png.h\"\n#include \"webp/decode.h\"\n#include \"webp/encode.h\"\nstatic int help(void) {\n  fputs(\"PNG2WebP \" VERSION \"\\n\\\n\\n\\\nUsage:\\n\\\npng2webp [-refv-] INFILE ...\\n\\\npng2webp -p[refv-] [{INFILE|-} [OUTFILE|-]]\\n\\\n\\n\\\n-p: Work with a single file, allowing Piping from stdin or to stdout,\\n\\\n    or using a different output filename to the input.\\n\\\n    `INFILE` and `OUTFILE` default to stdin and stdout respectively,\\n\\\n    or explicitly as \\\"-\\\".\\n\\\n    Will show this message if stdin/stdout is used and is a terminal.\\n\\\n-r: Convert from WebP to PNG instead.\\n\\\n-e: Keep RGB data on pixels where alpha is 0. Always enabled for `-r`.\\n\\\n-f: Force overwrite of output files (has no effect on stdout).\\n\\\n-v: Be verbose.\\n\\\n--: Explicitly stop parsing options.\\n\",\n    stderr);\n  return -1;\n}\nstatic bool exact = 0, force = 0, verbose = 0;\n#define PF(x, ...) fprintf(stderr, x \"\\n\", __VA_ARGS__)\n#define PFV(...) \\\n  if(verbose) PF(__VA_ARGS__)\n#define IP (ip ? ip : \"<stdin>\")\n#define OP (op ? op : \"<stdout>\")\nstatic FILE *openr(char *ip) {\n  PFV(\"Decoding %s ...\", IP);\n  if(!ip) return stdin;\n  FILE *fp;\n#ifdef NOFOPENX\n  int fd = open(ip, O_RDONLY | O_BINARY);\n  if(fd == -1) {\n    PF(\"ERROR opening %s for %s: %s\", ip, \"reading\", strerror(errno));\n    return 0;\n  }\n  if(!(fp = fdopen(fd, \"rb\"))) {\n    PF(\"ERROR opening %s for %s: %s\", ip, \"reading\", strerror(errno));\n    close(fd);\n    return 0;\n  }\n#else\n  if(!(fp = fopen(ip, \"rb\"))) {\n    PF(\"ERROR opening %s for %s: %s\", ip, \"reading\", strerror(errno));\n    return 0;\n  }\n#endif\n  return fp;\n}\nstatic FILE *openw(char *op) {\n  PFV(\"Encoding %s ...\", OP);\n  if(!op) return stdout;\n  FILE *fp;\n#define EO(x) \\\n  if(!(x)) { \\\n    PF(\"ERROR opening %s for %s: %s\", op, force ? \"writing\" : \"creation\", \\\n      strerror(errno)); \\\n    return 0; \\\n  }\n#ifdef NOFOPENX\n  int fd = open(op, O_WRONLY | O_CREAT | O_TRUNC | (!force * O_EXCL) | O_BINARY,\n#ifdef _WIN32\n    S_IREAD | S_IWRITE\n#else\n    S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH\n#endif\n  );\n  EO(fd != -1)\n  if(!(fp = fdopen(fd, \"wb\"))) {\n    PF(\"ERROR opening %s for %s: %s\", op, force ? \"writing\" : \"creation\",\n      strerror(errno));\n    close(fd);\n    remove(op);\n    return 0;\n  }\n#else\n  EO(fp = fopen(op, force ? \"wb\" : \"wbx\"))\n#endif\n  return fp;\n}\nstatic size_t pnglen;\nstatic void pngread(png_struct *p, uint8_t *d, size_t s) {\n  if(!fread(d, s, 1, png_get_io_ptr(p))) png_error(p, \"I/O error\");\n  pnglen += s;\n}\nstatic void pngwrite(png_struct *p, uint8_t *d, size_t s) {\n  if(!fwrite(d, s, 1, png_get_io_ptr(p))) png_error(p, \"I/O error\");\n  pnglen += s;\n}\nstatic void pngflush(png_struct *p) {\n#ifdef DOFLUSH\n  fflush(png_get_io_ptr(p));\n#else\n  (void)p;\n#endif\n}\nstatic void pngrerr(png_struct *p, const char *s) {\n  PF(\"ERROR reading %s: %s\", (char *)png_get_error_ptr(p), s);\n  png_longjmp(p, 1);\n}\nstatic void pngwerr(png_struct *p, const char *s) {\n  PF(\"ERROR writing %s: %s\", (char *)png_get_error_ptr(p), s);\n  png_longjmp(p, 1);\n}\nstatic void pngwarn(png_struct *p, const char *s) {\n  PF(\"Warning: %s: %s\", (char *)png_get_error_ptr(p), s);\n}\nstatic int webpwrite(const uint8_t *d, size_t s, const WebPPicture *p) {\n  return (int)fwrite(d, s, 1, p->custom_ptr);\n}\n#define E(x, ...) \\\n  if(!(x)) { \\\n    PF(\"ERROR \" __VA_ARGS__); \\\n    return 1; \\\n  }\nstatic bool p2w(char *ip, char *op) {\n  FILE *fp = openr(ip);\n  if(!fp) return 1;\n  uint32_t *b = 0;\n  png_info *n = 0;\n  char *k[] = {\"Out of memory\",\n    \"???\", // oom flushing bitstream, unused in libwebp\n    \"???\", // null param\n    \"Broken config, file a bug report\",\n    \"???\", // image too big (already checked)\n    \"???\", \"???\", // lossy\n    \"I/O error\",\n    \"???\", // lossy\n    \"???\"}; // canceled\n  png_struct *p =\n    png_create_read_struct(PNG_LIBPNG_VER_STRING, ip, pngrerr, pngwarn);\n  if(!p) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto p2w_close;\n  }\n  n = png_create_info_struct(p);\n  if(!n) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto p2w_close;\n  }\n  if(setjmp(png_jmpbuf(p))) {\n  p2w_close:\n    fclose(fp);\n    png_destroy_read_struct(&p, &n, 0);\n  p2w_free:\n    free(b);\n    return 1;\n  }\n  pnglen = 0;\n  png_set_read_fn(p, fp, pngread);\n  png_read_info(p, n);\n  uint32_t width, height;\n  int bitdepth, colortype;\n  png_get_IHDR(p, n, &width, &height, &bitdepth, &colortype, 0, 0, 0);\n  if(width > 16383 || height > 16383) {\n    PF(\"ERROR reading %s: Image too big (%\" PRIu32 \" x %\" PRIu32\n       \", max. 16383 x 16383 px)\",\n      IP, width, height);\n    goto p2w_close;\n  }\n  if((unsigned)bitdepth > 8)\n    PF(\"Warning: %s is 16-bit, will be downsampled to 8-bit\", IP);\n  bool trns = png_get_valid(p, n, PNG_INFO_tRNS);\n#ifdef FIXEDGAMMA\n#define GAMMA ((uint32_t)gamma) / 1e5\n  int32_t gamma = 45455;\n  if(png_get_valid(p, n, PNG_INFO_sRGB) || png_get_gAMA_fixed(p, n, &gamma))\n    png_set_gamma_fixed(p, 22e4, gamma);\n#else\n#define GAMMA gamma\n  double gamma = 1 / 2.2;\n  if(png_get_valid(p, n, PNG_INFO_sRGB) || png_get_gAMA(p, n, &gamma))\n    png_set_gamma(p, 2.2, gamma);\n#endif\n#define S(x) png_set_##x(p)\n  S(scale_16);\n  S(expand);\n  S(gray_to_rgb);\n  S(packing);\n  if(*(uint8_t *)&(uint16_t){1}) {\n    S(bgr);\n    png_set_add_alpha(p, 255, PNG_FILLER_AFTER);\n  } else {\n    // TODO: test somehow\n    S(swap_alpha);\n    png_set_add_alpha(p, 255, PNG_FILLER_BEFORE);\n  }\n  int passes = S(interlace_handling);\n  png_read_update_info(p, n);\n#ifndef NDEBUG\n  size_t rowbytes = png_get_rowbytes(p, n);\n  if(rowbytes != (size_t)4 * width) {\n    PF(\"ERROR reading %s: rowbytes is %zu, should be %zu\", IP, rowbytes,\n      (size_t)4 * width);\n    goto p2w_close;\n  }\n#endif\n  b = malloc(width * height * 4);\n  if(!b) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto p2w_close;\n  }\n  for(unsigned x = (unsigned)passes; x; x--) {\n    uint8_t *w = (uint8_t *)b;\n    for(unsigned y = height; y; y--) {\n      png_read_row(p, w, 0);\n      w += width * 4;\n    }\n  }\n  png_read_end(p, 0);\n  png_destroy_read_struct(&p, &n, 0);\n  fclose(fp);\n  char *f[] = {\n    \"greyscale\", \"???\", \"RGB\", \"paletted\", \"greyscale + alpha\", \"???\", \"RGBA\"};\n  PFV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32\n      \"\\nSize: %zu bytes (%.15g bpp)\\nFormat: %u-bit %s%s%s\\nGamma: %.5g\",\n    IP, width, height, pnglen, (double)pnglen * 8 / (width * height), bitdepth,\n    f[(unsigned)colortype], trns ? \", with transparency\" : \"\",\n    (unsigned)passes > 1 ? \", interlaced\" : \"\", GAMMA);\n  WebPConfig c;\n  if(!WebPConfigPreset(&c, WEBP_PRESET_ICON, 100)) {\n    PF(\"ERROR writing %s: %s\", OP, k[3]);\n    goto p2w_free;\n  }\n  if(!(fp = openw(op))) goto p2w_free;\n  c.lossless = 1;\n  c.method = 6;\n#ifndef NOTHREADS\n  c.thread_level = 1; // doesn't seem to affect output\n#endif\n  c.exact = exact;\n  WebPAuxStats s;\n  WebPPicture o = {1, .width = (int)width, (int)height, .argb = b,\n    .argb_stride = (int)width, .writer = webpwrite, .custom_ptr = fp,\n    .stats = verbose ? &s : 0};\n  // progress_hook only reports 1, 5, 90, 100 for lossless\n  trns = (trns || (colortype & PNG_COLOR_MASK_ALPHA)) &&\n    WebPPictureHasTransparency(&o);\n  if(!WebPEncode(&c, &o)) {\n    PF(\"ERROR writing %s: %s\", OP, k[o.error_code - 1]);\n    fclose(fp);\n  p2w_rm:\n    if(op) remove(op);\n    goto p2w_free;\n  }\n  if(fclose(fp)) {\n    PF(\"ERROR closing %s: %s\", OP, strerror(errno));\n    goto p2w_rm;\n  }\n  free(b);\n#define F s.lossless_features\n#define C s.palette_size\n  PFV(\"Info: %s:\\nDimensions: %u x %u\\nSize: %u bytes (%.15g bpp)\\n\\\nHeader size: %u, image data size: %u\\nUses alpha: %s\\n\\\nPrecision bits: histogram=%u transform=%u cache=%u\\n\\\nLossless features:%s%s%s%s\\nColors: %s%u\",\n    OP, o.width, o.height, s.lossless_size,\n    (unsigned)s.lossless_size * 8. / (unsigned)(o.width * o.height),\n    s.lossless_hdr_size, s.lossless_data_size, trns ? \"yes\" : \"no\",\n    s.histogram_bits, s.transform_bits, s.cache_bits,\n    F ? F & 1 ? \" prediction\" : \"\" : \" none\", F && F & 2 ? \" cross-color\" : \"\",\n    F && F & 4 ? \" subtract-green\" : \"\", F && F & 8 ? \" palette\" : \"\",\n    C ? \"\" : \">\", C ? C : 256);\n  return 0;\n}\nstatic bool w2p(char *ip, char *op) {\n  FILE *fp = openr(ip);\n  if(!fp) return 1;\n  bool openwdone = 0;\n  uint8_t *x = 0, *b = 0;\n  png_struct *p = 0;\n  png_info *n = 0;\n  uint8_t i[12];\n  char *k[] = {\"Out of memory\", \"Broken config, file a bug report\",\n    \"Invalid WebP\", \"???\", \"???\", \"???\", \"I/O error\"};\n  // unsupported feature, suspended, canceled\n  if(!fread(i, 12, 1, fp)) {\n    PF(\"ERROR reading %s: %s\", IP, k[6]);\n    goto w2p_close;\n  }\n  if(memcmp(i, (char[4]){\"RIFF\"}, 4) || memcmp(i + 8, (char[4]){\"WEBP\"}, 4)) {\n    PF(\"ERROR reading %s: %s\", IP, k[2]);\n    goto w2p_close;\n  }\n  size_t l = ((uint32_t)(i[4] | (i[5] << 8) | (i[6] << 16) | (i[7] << 24))) + 8;\n  // ^ RIFF header size\n  if(l <= 12\n#ifdef SSIZE_MAX\n    || l - 12 > SSIZE_MAX\n#endif\n  ) {\n    PF(\"ERROR reading %s: %s\", IP, k[2]);\n    goto w2p_close;\n  }\n  x = malloc(l);\n  if(!x) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto w2p_close;\n  }\n  memcpy(x, i, 12); // should optimize out\n  if(!fread(x + 12, l - 12, 1, fp)) {\n    PF(\"ERROR reading %s: %s\", IP, k[6]);\n    goto w2p_close;\n  }\n  fclose(fp);\n#if defined LOSSYISERROR || defined NOTHREADS\n  WebPBitstreamFeatures I;\n#else\n  WebPDecoderConfig c = {.options.use_threads = 1};\n#define I c.input\n#endif\n  VP8StatusCode r = WebPGetFeatures(x, l, &I);\n  if(r) {\n    PF(\"ERROR reading %s: %s\", IP, k[r - 1]);\n    goto w2p_free;\n  }\n#define V I.format\n#define W ((uint32_t)I.width)\n#define H ((uint32_t)I.height)\n#define A I.has_alpha\n#ifdef LOSSYISERROR\n#define FMTSTR\n#define FMTARG\n#define ANMSTR \"%s\"\n#define ANMARG , \"animat\"\n#else\n  char *f[] = {\"undefined/mixed\", \"lossy\", \"lossless\"};\n#define FMTSTR \"\\nFormat: %s\"\n#define FMTARG , f[V]\n#define ANMSTR \"animat\"\n#define ANMARG\n#endif\n  PFV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32\n      \"\\nSize: %zu bytes (%.15g bpp)\\nUses alpha: %s\" FMTSTR,\n    IP, W, H, l, (double)l * 8 / (W * H), A ? \"yes\" : \"no\" FMTARG);\n  if(I.has_animation) {\n    PF(\"ERROR reading %s: Unsupported feature: \" ANMSTR \"ion\", IP ANMARG);\n    goto w2p_free;\n  }\n#ifdef LOSSYISERROR\n  if(V != 2) {\n    PF(\"ERROR reading %s: Unsupported feature: %sion\", IP, \"lossy compress\");\n    goto w2p_free;\n  }\n#endif\n#define B ((unsigned)(3 + A))\n  b = malloc(W * H * B);\n  if(!b) {\n    PF(\"ERROR reading %s: %s\", IP, *k);\n    goto w2p_free;\n  }\n#if defined LOSSYISERROR || defined NOTHREADS\n  if(!(A ? WebPDecodeRGBAInto : WebPDecodeRGBInto)(\n       x, l, b, W * H * B, (int)(W * B))) {\n    PF(\"ERROR reading %s: %s\", IP, k[2]);\n    goto w2p_free;\n  }\n#else\n  c.output.colorspace = A ? MODE_RGBA : MODE_RGB;\n  c.output.is_external_memory = 1;\n#define D c.output.u.RGBA\n  D.rgba = b;\n  D.stride = (int)(W * B);\n  D.size = W * H * B;\n  r = WebPDecode(x, l, &c);\n  if(r) {\n    PF(\"ERROR reading %s: %s\", IP, k[r - 1]);\n    goto w2p_free;\n  }\n#endif\n  free(x);\n  x = 0;\n  if(!(fp = openw(op))) goto w2p_free;\n  openwdone = !!op;\n  p = png_create_write_struct(PNG_LIBPNG_VER_STRING, op, pngwerr, pngwarn);\n  if(!p) {\n    PF(\"ERROR writing %s: %s\", OP, *k);\n    goto w2p_close;\n  }\n  n = png_create_info_struct(p);\n  if(!n) {\n    PF(\"ERROR writing %s: %s\", OP, *k);\n    goto w2p_close;\n  }\n  if(setjmp(png_jmpbuf(p))) {\n  w2p_close:\n    fclose(fp);\n  w2p_free:\n    if(openwdone) remove(op);\n    free(x);\n    free(b);\n    png_destroy_write_struct(&p, &n);\n    return 1;\n  }\n  pnglen = 0;\n  png_set_write_fn(p, fp, pngwrite, pngflush);\n  png_set_filter(p, 0, PNG_ALL_FILTERS);\n  png_set_compression_level(p, 9);\n  // png_set_compression_memlevel(p, 9);\n  png_set_IHDR(p, n, W, H, 8, A ? 6 : 2, 0, 0, 0);\n  png_write_info(p, n);\n  uint8_t *w = b;\n  for(unsigned y = H; y; y--) {\n    png_write_row(p, w);\n    w += W * B;\n  }\n  png_write_end(p, n);\n  png_destroy_write_struct(&p, &n);\n  p = 0;\n  n = 0;\n  free(b);\n  b = 0;\n  if(fclose(fp)) {\n    PF(\"ERROR closing %s: %s\", OP, strerror(errno));\n    goto w2p_free;\n  }\n  PFV(\"Info: %s:\\nDimensions: %\" PRIu32 \" x %\" PRIu32\n      \"\\nSize: %zu bytes (%.15g bpp)\\nFormat: %u-bit %s%s%s\\nGamma: %.5g\",\n    OP, W, H, pnglen, (double)pnglen * 8 / (W * H), 8, A ? \"RGBA\" : \"RGB\", \"\",\n    \"\", 1 / 2.2);\n  return 0;\n}\nint main(int argc, char **argv) {\n  { // should optimize out\n    uint32_t endian;\n    memcpy(&endian, (char[4]){\"\\xAA\\xBB\\xCC\\xDD\"}, 4);\n    E(endian == 0xAABBCCDD || endian == 0xDDCCBBAA,\n      \"32-bit mixed-endianness (%X) not supported\", endian)\n  }\n  bool pipe = 0, usestdin = 0, usestdout = 0, reverse = 0;\n#ifdef USEGETOPT\n  for(int c; (c = getopt(argc, argv, \":prefv\")) != -1;)\n    switch(c)\n#else\n  while(--argc && **++argv == '-' && argv[0][1])\n    while(*++*argv)\n      switch(**argv)\n#endif\n    {\n      case 'p': pipe = 1; break;\n      case 'r': reverse = 1; break;\n      case 'e': exact = 1; break;\n      case 'f': force = 1; break;\n      case 'v': verbose = 1; break;\n#ifndef USEGETOPT\n      case '-':\n\tif(argv[0][1]) return help();\n\targc--;\n\targv++;\n\tgoto endflagloop;\n#endif\n      default: return help();\n    }\n#ifdef USEGETOPT\n  argc -= optind;\n  argv += optind;\n#else\nendflagloop:\n#endif\n#define URGC (unsigned)argc\n#define PIPEARG(x) (*argv[x] == '-' && !argv[x][1])\n  if(pipe) {\n    if(URGC > 2 || ((usestdin = (!argc || PIPEARG(0))) && isatty(0)) ||\n      ((usestdout = (URGC < 2 || PIPEARG(1))) && isatty(1)))\n      return help();\n    if(usestdin) setmode(0, O_BINARY);\n    if(usestdout) setmode(1, O_BINARY);\n    return (reverse ? w2p : p2w)(usestdin ? 0 : *argv, usestdout ? 0 : argv[1]);\n  }\n  if(!argc) return help();\n  bool ret = 0;\n  if(reverse)\n    for(; argc; argc--, argv++) {\n      size_t len = strlen(*argv);\n      if(len > 4) {\n\tuint32_t ext, extmatch;\n\tmemcpy(&ext, *argv + len - 4, 4);\n\tmemcpy(&extmatch, (char[4]){\"webp\"}, 4);\n\tif(argv[0][len - 5] == '.' && (ext | 0x20202020) == extmatch) len -= 5;\n      }\n      {\n#if defined __STDC_NO_VLA__ && !defined NOVLA\n#define NOVLA\n#endif\n#ifdef NOVLA\n\tchar *op = malloc(len + 5);\n\tE(op, \"adding .%s extension to %s: Out of memory\", \"png\", *argv)\n#else\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wvla\"\n\tchar op[len + 5];\n#pragma GCC diagnostic pop\n#endif\n\tmemcpy(op, *argv, len); // the only real memcpy\n\tmemcpy(op + len, \".png\", 5);\n\tret = w2p(*argv, op) || ret;\n#ifdef NOVLA\n\tfree(op);\n#endif\n      }\n    }\n  else\n    for(; argc; argc--, argv++) {\n      size_t len = strlen(*argv);\n      if(len > 3) {\n\tuint32_t ext, extmask, extmatch;\n\tmemcpy(&ext, *argv + len - 4, 4);\n\tmemcpy(&extmask, (char[4]){\"\\0   \"}, 4);\n\tmemcpy(&extmatch, (char[4]){\".png\"}, 4);\n\tif((ext | extmask) == extmatch) len -= 4;\n      }\n      {\n#ifdef NOVLA\n\tchar *op = malloc(len + 6);\n\tE(op, \"adding .%s extension to %s: Out of memory\", \"webp\", *argv)\n#else\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wvla\"\n\tchar op[len + 6];\n#pragma GCC diagnostic pop\n#endif\n\tmemcpy(op, *argv, len); // the only real memcpy\n\tmemcpy(op + len, \".webp\", 6);\n\tret = p2w(*argv, op) || ret;\n#ifdef NOVLA\n\tfree(op);\n#endif\n      }\n    }\n  return ret;\n}\n"], "filenames": ["png2webp.c"], "buggy_code_start_loc": [3], "buggy_code_end_loc": [321], "fixing_code_start_loc": [3], "fixing_code_end_loc": [330], "type": "CWE-787", "message": "png2webp v1.0.4 was discovered to contain an out-of-bounds write via the function w2p. This vulnerability is exploitable via a crafted png file.", "other": {"cve": {"id": "CVE-2022-36752", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-28T23:15:07.987", "lastModified": "2022-08-04T11:24:42.783", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "png2webp v1.0.4 was discovered to contain an out-of-bounds write via the function w2p. This vulnerability is exploitable via a crafted png file."}, {"lang": "es", "value": "Se ha detectado que png2webp versi\u00f3n v1.0.4, contiene una escritura fuera de l\u00edmites por medio de la funci\u00f3n w2p. Esta vulnerabilidad puede aprovecharse por medio de un archivo png dise\u00f1ado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:png2webp_project:png2webp:1.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "1089A890-5F12-4382-BB11-A23704D03131"}]}]}], "references": [{"url": "https://github.com/landfillbaby/png2webp/commit/8f21ad79b0cd98fc22d5b49734543101946abbff", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/landfillbaby/png2webp/issues/3", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/landfillbaby/png2webp/commit/8f21ad79b0cd98fc22d5b49734543101946abbff"}}