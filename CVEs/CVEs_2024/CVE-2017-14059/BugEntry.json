{"buggy_code": ["/*\n * Phantom Cine demuxer\n * Copyright (c) 2010-2011 Peter Ross <pross@xvid.org>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Phantom Cine demuxer\n * @author Peter Ross <pross@xvid.org>\n */\n\n#include \"libavutil/intreadwrite.h\"\n#include \"libavcodec/bmp.h\"\n#include \"libavutil/intfloat.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n\ntypedef struct {\n    uint64_t pts;\n} CineDemuxContext;\n\n/** Compression */\nenum {\n    CC_RGB   = 0,  /**< Gray */\n    CC_LEAD  = 1,  /**< LEAD (M)JPEG */\n    CC_UNINT = 2   /**< Uninterpolated color image (CFA field indicates color ordering)  */\n};\n\n/** Color Filter Array */\nenum {\n    CFA_NONE      = 0,  /**< GRAY */\n    CFA_VRI       = 1,  /**< GBRG/RGGB */\n    CFA_VRIV6     = 2,  /**< BGGR/GRBG */\n    CFA_BAYER     = 3,  /**< GB/RG */\n    CFA_BAYERFLIP = 4,  /**< RG/GB */\n};\n\n#define CFA_TLGRAY  0x80000000U\n#define CFA_TRGRAY  0x40000000U\n#define CFA_BLGRAY  0x20000000U\n#define CFA_BRGRAY  0x10000000U\n\nstatic int cine_read_probe(AVProbeData *p)\n{\n    int HeaderSize;\n    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type\n        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize\n        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression\n        AV_RL16(p->buf + 6) <= 1 &&              // Version\n        AV_RL32(p->buf + 20) &&                  // ImageCount\n        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader\n        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup\n        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets\n        return AVPROBE_SCORE_MAX;\n    return 0;\n}\n\nstatic int set_metadata_int(AVDictionary **dict, const char *key, int value, int allow_zero)\n{\n    if (value || allow_zero) {\n        return av_dict_set_int(dict, key, value, 0);\n    }\n    return 0;\n}\n\nstatic int set_metadata_float(AVDictionary **dict, const char *key, float value, int allow_zero)\n{\n    if (value != 0 || allow_zero) {\n        char tmp[64];\n        snprintf(tmp, sizeof(tmp), \"%f\", value);\n        return av_dict_set(dict, key, tmp, 0);\n    }\n    return 0;\n}\n\nstatic int cine_read_header(AVFormatContext *avctx)\n{\n    AVIOContext *pb = avctx->pb;\n    AVStream *st;\n    unsigned int version, compression, offImageHeader, offSetup, offImageOffsets, biBitCount, length, CFA;\n    int vflip;\n    char *description;\n    uint64_t i;\n\n    st = avformat_new_stream(avctx, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = AV_CODEC_ID_RAWVIDEO;\n    st->codecpar->codec_tag  = 0;\n\n    /* CINEFILEHEADER structure */\n    avio_skip(pb, 4); // Type, Headersize\n\n    compression = avio_rl16(pb);\n    version     = avio_rl16(pb);\n    if (version != 1) {\n        avpriv_request_sample(avctx, \"unknown version %i\", version);\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 12); // FirstMovieImage, TotalImageCount, FirstImageNumber\n\n    st->duration    = avio_rl32(pb);\n    offImageHeader  = avio_rl32(pb);\n    offSetup        = avio_rl32(pb);\n    offImageOffsets = avio_rl32(pb);\n\n    avio_skip(pb, 8); // TriggerTime\n\n    /* BITMAPINFOHEADER structure */\n    avio_seek(pb, offImageHeader, SEEK_SET);\n    avio_skip(pb, 4); //biSize\n    st->codecpar->width      = avio_rl32(pb);\n    st->codecpar->height     = avio_rl32(pb);\n\n    if (avio_rl16(pb) != 1) // biPlanes\n        return AVERROR_INVALIDDATA;\n\n    biBitCount = avio_rl16(pb);\n    if (biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48) {\n        avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n        return AVERROR_INVALIDDATA;\n    }\n\n    switch (avio_rl32(pb)) {\n    case BMP_RGB:\n        vflip = 0;\n        break;\n    case 0x100: /* BI_PACKED */\n        st->codecpar->codec_tag = MKTAG('B', 'I', 'T', 0);\n        vflip = 1;\n        break;\n    default:\n        avpriv_request_sample(avctx, \"unknown bitmap compression\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 4); // biSizeImage\n\n    /* parse SETUP structure */\n    avio_seek(pb, offSetup, SEEK_SET);\n    avio_skip(pb, 140); // FrameRatae16 .. descriptionOld\n    if (avio_rl16(pb) != 0x5453)\n        return AVERROR_INVALIDDATA;\n    length = avio_rl16(pb);\n    if (length < 0x163C) {\n        avpriv_request_sample(avctx, \"short SETUP header\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 616); // Binning .. bFlipH\n    if (!avio_rl32(pb) ^ vflip) {\n        st->codecpar->extradata  = av_strdup(\"BottomUp\");\n        st->codecpar->extradata_size  = 9;\n    }\n\n    avio_skip(pb, 4); // Grid\n\n    avpriv_set_pts_info(st, 64, 1, avio_rl32(pb));\n\n    avio_skip(pb, 20); // Shutter .. bEnableColor\n\n    set_metadata_int(&st->metadata, \"camera_version\", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \"firmware_version\", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \"software_version\", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \"recording_timezone\", avio_rl32(pb), 0);\n\n    CFA = avio_rl32(pb);\n\n    set_metadata_int(&st->metadata, \"brightness\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"contrast\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"gamma\", avio_rl32(pb), 1);\n\n    avio_skip(pb, 12 + 16); // Reserved1 .. AutoExpRect\n    set_metadata_float(&st->metadata, \"wbgain[0].r\", av_int2float(avio_rl32(pb)), 1);\n    set_metadata_float(&st->metadata, \"wbgain[0].b\", av_int2float(avio_rl32(pb)), 1);\n    avio_skip(pb, 36); // WBGain[1].. WBView\n\n    st->codecpar->bits_per_coded_sample = avio_rl32(pb);\n\n    if (compression == CC_RGB) {\n        if (biBitCount == 8) {\n            st->codecpar->format = AV_PIX_FMT_GRAY8;\n        } else if (biBitCount == 16) {\n            st->codecpar->format = AV_PIX_FMT_GRAY16LE;\n        } else if (biBitCount == 24) {\n            st->codecpar->format = AV_PIX_FMT_BGR24;\n        } else if (biBitCount == 48) {\n            st->codecpar->format = AV_PIX_FMT_BGR48LE;\n        } else {\n            avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (compression == CC_UNINT) {\n        switch (CFA & 0xFFFFFF) {\n        case CFA_BAYER:\n            if (biBitCount == 8) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_GBRG8;\n            } else if (biBitCount == 16) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_GBRG16LE;\n            } else {\n                avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        case CFA_BAYERFLIP:\n            if (biBitCount == 8) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_RGGB8;\n            } else if (biBitCount == 16) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_RGGB16LE;\n            } else {\n                avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        default:\n           avpriv_request_sample(avctx, \"unsupported Color Field Array (CFA) %i\", CFA & 0xFFFFFF);\n            return AVERROR_INVALIDDATA;\n        }\n    } else { //CC_LEAD\n        avpriv_request_sample(avctx, \"unsupported compression %i\", compression);\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 668); // Conv8Min ... Sensor\n\n    set_metadata_int(&st->metadata, \"shutter_ns\", avio_rl32(pb), 0);\n\n    avio_skip(pb, 24); // EDRShutterNs ... ImHeightAcq\n\n#define DESCRIPTION_SIZE 4096\n    description = av_malloc(DESCRIPTION_SIZE + 1);\n    if (!description)\n        return AVERROR(ENOMEM);\n    i = avio_get_str(pb, DESCRIPTION_SIZE, description, DESCRIPTION_SIZE + 1);\n    if (i < DESCRIPTION_SIZE)\n        avio_skip(pb, DESCRIPTION_SIZE - i);\n    if (description[0])\n        av_dict_set(&st->metadata, \"description\", description, AV_DICT_DONT_STRDUP_VAL);\n    else\n        av_free(description);\n\n    avio_skip(pb, 1176); // RisingEdge ... cmUser\n\n    set_metadata_int(&st->metadata, \"enable_crop\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_left\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_top\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_right\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_bottom\", avio_rl32(pb), 1);\n\n    /* parse image offsets */\n    avio_seek(pb, offImageOffsets, SEEK_SET);\n    for (i = 0; i < st->duration; i++)\n        av_add_index_entry(st, avio_rl64(pb), i, 0, 0, AVINDEX_KEYFRAME);\n\n    return 0;\n}\n\nstatic int cine_read_packet(AVFormatContext *avctx, AVPacket *pkt)\n{\n    CineDemuxContext *cine = avctx->priv_data;\n    AVStream *st = avctx->streams[0];\n    AVIOContext *pb = avctx->pb;\n    int n, size, ret;\n\n    if (cine->pts >= st->duration)\n        return AVERROR_EOF;\n\n    avio_seek(pb, st->index_entries[cine->pts].pos, SEEK_SET);\n    n = avio_rl32(pb);\n    if (n < 8)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, n - 8);\n    size = avio_rl32(pb);\n\n    ret = av_get_packet(pb, pkt, size);\n    if (ret < 0)\n        return ret;\n\n    pkt->pts = cine->pts++;\n    pkt->stream_index = 0;\n    pkt->flags |= AV_PKT_FLAG_KEY;\n    return 0;\n}\n\nstatic int cine_read_seek(AVFormatContext *avctx, int stream_index, int64_t timestamp, int flags)\n{\n    CineDemuxContext *cine = avctx->priv_data;\n\n    if ((flags & AVSEEK_FLAG_FRAME) || (flags & AVSEEK_FLAG_BYTE))\n        return AVERROR(ENOSYS);\n\n    if (!(avctx->pb->seekable & AVIO_SEEKABLE_NORMAL))\n        return AVERROR(EIO);\n\n    cine->pts = timestamp;\n    return 0;\n}\n\nAVInputFormat ff_cine_demuxer = {\n    .name           = \"cine\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Phantom Cine\"),\n    .priv_data_size = sizeof(CineDemuxContext),\n    .read_probe     = cine_read_probe,\n    .read_header    = cine_read_header,\n    .read_packet    = cine_read_packet,\n    .read_seek      = cine_read_seek,\n};\n"], "fixing_code": ["/*\n * Phantom Cine demuxer\n * Copyright (c) 2010-2011 Peter Ross <pross@xvid.org>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Phantom Cine demuxer\n * @author Peter Ross <pross@xvid.org>\n */\n\n#include \"libavutil/intreadwrite.h\"\n#include \"libavcodec/bmp.h\"\n#include \"libavutil/intfloat.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n\ntypedef struct {\n    uint64_t pts;\n} CineDemuxContext;\n\n/** Compression */\nenum {\n    CC_RGB   = 0,  /**< Gray */\n    CC_LEAD  = 1,  /**< LEAD (M)JPEG */\n    CC_UNINT = 2   /**< Uninterpolated color image (CFA field indicates color ordering)  */\n};\n\n/** Color Filter Array */\nenum {\n    CFA_NONE      = 0,  /**< GRAY */\n    CFA_VRI       = 1,  /**< GBRG/RGGB */\n    CFA_VRIV6     = 2,  /**< BGGR/GRBG */\n    CFA_BAYER     = 3,  /**< GB/RG */\n    CFA_BAYERFLIP = 4,  /**< RG/GB */\n};\n\n#define CFA_TLGRAY  0x80000000U\n#define CFA_TRGRAY  0x40000000U\n#define CFA_BLGRAY  0x20000000U\n#define CFA_BRGRAY  0x10000000U\n\nstatic int cine_read_probe(AVProbeData *p)\n{\n    int HeaderSize;\n    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type\n        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize\n        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression\n        AV_RL16(p->buf + 6) <= 1 &&              // Version\n        AV_RL32(p->buf + 20) &&                  // ImageCount\n        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader\n        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup\n        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets\n        return AVPROBE_SCORE_MAX;\n    return 0;\n}\n\nstatic int set_metadata_int(AVDictionary **dict, const char *key, int value, int allow_zero)\n{\n    if (value || allow_zero) {\n        return av_dict_set_int(dict, key, value, 0);\n    }\n    return 0;\n}\n\nstatic int set_metadata_float(AVDictionary **dict, const char *key, float value, int allow_zero)\n{\n    if (value != 0 || allow_zero) {\n        char tmp[64];\n        snprintf(tmp, sizeof(tmp), \"%f\", value);\n        return av_dict_set(dict, key, tmp, 0);\n    }\n    return 0;\n}\n\nstatic int cine_read_header(AVFormatContext *avctx)\n{\n    AVIOContext *pb = avctx->pb;\n    AVStream *st;\n    unsigned int version, compression, offImageHeader, offSetup, offImageOffsets, biBitCount, length, CFA;\n    int vflip;\n    char *description;\n    uint64_t i;\n\n    st = avformat_new_stream(avctx, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = AV_CODEC_ID_RAWVIDEO;\n    st->codecpar->codec_tag  = 0;\n\n    /* CINEFILEHEADER structure */\n    avio_skip(pb, 4); // Type, Headersize\n\n    compression = avio_rl16(pb);\n    version     = avio_rl16(pb);\n    if (version != 1) {\n        avpriv_request_sample(avctx, \"unknown version %i\", version);\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 12); // FirstMovieImage, TotalImageCount, FirstImageNumber\n\n    st->duration    = avio_rl32(pb);\n    offImageHeader  = avio_rl32(pb);\n    offSetup        = avio_rl32(pb);\n    offImageOffsets = avio_rl32(pb);\n\n    avio_skip(pb, 8); // TriggerTime\n\n    /* BITMAPINFOHEADER structure */\n    avio_seek(pb, offImageHeader, SEEK_SET);\n    avio_skip(pb, 4); //biSize\n    st->codecpar->width      = avio_rl32(pb);\n    st->codecpar->height     = avio_rl32(pb);\n\n    if (avio_rl16(pb) != 1) // biPlanes\n        return AVERROR_INVALIDDATA;\n\n    biBitCount = avio_rl16(pb);\n    if (biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48) {\n        avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n        return AVERROR_INVALIDDATA;\n    }\n\n    switch (avio_rl32(pb)) {\n    case BMP_RGB:\n        vflip = 0;\n        break;\n    case 0x100: /* BI_PACKED */\n        st->codecpar->codec_tag = MKTAG('B', 'I', 'T', 0);\n        vflip = 1;\n        break;\n    default:\n        avpriv_request_sample(avctx, \"unknown bitmap compression\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 4); // biSizeImage\n\n    /* parse SETUP structure */\n    avio_seek(pb, offSetup, SEEK_SET);\n    avio_skip(pb, 140); // FrameRatae16 .. descriptionOld\n    if (avio_rl16(pb) != 0x5453)\n        return AVERROR_INVALIDDATA;\n    length = avio_rl16(pb);\n    if (length < 0x163C) {\n        avpriv_request_sample(avctx, \"short SETUP header\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 616); // Binning .. bFlipH\n    if (!avio_rl32(pb) ^ vflip) {\n        st->codecpar->extradata  = av_strdup(\"BottomUp\");\n        st->codecpar->extradata_size  = 9;\n    }\n\n    avio_skip(pb, 4); // Grid\n\n    avpriv_set_pts_info(st, 64, 1, avio_rl32(pb));\n\n    avio_skip(pb, 20); // Shutter .. bEnableColor\n\n    set_metadata_int(&st->metadata, \"camera_version\", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \"firmware_version\", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \"software_version\", avio_rl32(pb), 0);\n    set_metadata_int(&st->metadata, \"recording_timezone\", avio_rl32(pb), 0);\n\n    CFA = avio_rl32(pb);\n\n    set_metadata_int(&st->metadata, \"brightness\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"contrast\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"gamma\", avio_rl32(pb), 1);\n\n    avio_skip(pb, 12 + 16); // Reserved1 .. AutoExpRect\n    set_metadata_float(&st->metadata, \"wbgain[0].r\", av_int2float(avio_rl32(pb)), 1);\n    set_metadata_float(&st->metadata, \"wbgain[0].b\", av_int2float(avio_rl32(pb)), 1);\n    avio_skip(pb, 36); // WBGain[1].. WBView\n\n    st->codecpar->bits_per_coded_sample = avio_rl32(pb);\n\n    if (compression == CC_RGB) {\n        if (biBitCount == 8) {\n            st->codecpar->format = AV_PIX_FMT_GRAY8;\n        } else if (biBitCount == 16) {\n            st->codecpar->format = AV_PIX_FMT_GRAY16LE;\n        } else if (biBitCount == 24) {\n            st->codecpar->format = AV_PIX_FMT_BGR24;\n        } else if (biBitCount == 48) {\n            st->codecpar->format = AV_PIX_FMT_BGR48LE;\n        } else {\n            avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n            return AVERROR_INVALIDDATA;\n        }\n    } else if (compression == CC_UNINT) {\n        switch (CFA & 0xFFFFFF) {\n        case CFA_BAYER:\n            if (biBitCount == 8) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_GBRG8;\n            } else if (biBitCount == 16) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_GBRG16LE;\n            } else {\n                avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        case CFA_BAYERFLIP:\n            if (biBitCount == 8) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_RGGB8;\n            } else if (biBitCount == 16) {\n                st->codecpar->format = AV_PIX_FMT_BAYER_RGGB16LE;\n            } else {\n                avpriv_request_sample(avctx, \"unsupported biBitCount %i\", biBitCount);\n                return AVERROR_INVALIDDATA;\n            }\n            break;\n        default:\n           avpriv_request_sample(avctx, \"unsupported Color Field Array (CFA) %i\", CFA & 0xFFFFFF);\n            return AVERROR_INVALIDDATA;\n        }\n    } else { //CC_LEAD\n        avpriv_request_sample(avctx, \"unsupported compression %i\", compression);\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 668); // Conv8Min ... Sensor\n\n    set_metadata_int(&st->metadata, \"shutter_ns\", avio_rl32(pb), 0);\n\n    avio_skip(pb, 24); // EDRShutterNs ... ImHeightAcq\n\n#define DESCRIPTION_SIZE 4096\n    description = av_malloc(DESCRIPTION_SIZE + 1);\n    if (!description)\n        return AVERROR(ENOMEM);\n    i = avio_get_str(pb, DESCRIPTION_SIZE, description, DESCRIPTION_SIZE + 1);\n    if (i < DESCRIPTION_SIZE)\n        avio_skip(pb, DESCRIPTION_SIZE - i);\n    if (description[0])\n        av_dict_set(&st->metadata, \"description\", description, AV_DICT_DONT_STRDUP_VAL);\n    else\n        av_free(description);\n\n    avio_skip(pb, 1176); // RisingEdge ... cmUser\n\n    set_metadata_int(&st->metadata, \"enable_crop\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_left\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_top\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_right\", avio_rl32(pb), 1);\n    set_metadata_int(&st->metadata, \"crop_bottom\", avio_rl32(pb), 1);\n\n    /* parse image offsets */\n    avio_seek(pb, offImageOffsets, SEEK_SET);\n    for (i = 0; i < st->duration; i++) {\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        av_add_index_entry(st, avio_rl64(pb), i, 0, 0, AVINDEX_KEYFRAME);\n    }\n\n    return 0;\n}\n\nstatic int cine_read_packet(AVFormatContext *avctx, AVPacket *pkt)\n{\n    CineDemuxContext *cine = avctx->priv_data;\n    AVStream *st = avctx->streams[0];\n    AVIOContext *pb = avctx->pb;\n    int n, size, ret;\n\n    if (cine->pts >= st->duration)\n        return AVERROR_EOF;\n\n    avio_seek(pb, st->index_entries[cine->pts].pos, SEEK_SET);\n    n = avio_rl32(pb);\n    if (n < 8)\n        return AVERROR_INVALIDDATA;\n    avio_skip(pb, n - 8);\n    size = avio_rl32(pb);\n\n    ret = av_get_packet(pb, pkt, size);\n    if (ret < 0)\n        return ret;\n\n    pkt->pts = cine->pts++;\n    pkt->stream_index = 0;\n    pkt->flags |= AV_PKT_FLAG_KEY;\n    return 0;\n}\n\nstatic int cine_read_seek(AVFormatContext *avctx, int stream_index, int64_t timestamp, int flags)\n{\n    CineDemuxContext *cine = avctx->priv_data;\n\n    if ((flags & AVSEEK_FLAG_FRAME) || (flags & AVSEEK_FLAG_BYTE))\n        return AVERROR(ENOSYS);\n\n    if (!(avctx->pb->seekable & AVIO_SEEKABLE_NORMAL))\n        return AVERROR(EIO);\n\n    cine->pts = timestamp;\n    return 0;\n}\n\nAVInputFormat ff_cine_demuxer = {\n    .name           = \"cine\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Phantom Cine\"),\n    .priv_data_size = sizeof(CineDemuxContext),\n    .read_probe     = cine_read_probe,\n    .read_header    = cine_read_header,\n    .read_packet    = cine_read_packet,\n    .read_seek      = cine_read_seek,\n};\n"], "filenames": ["libavformat/cinedec.c"], "buggy_code_start_loc": [270], "buggy_code_end_loc": [271], "fixing_code_start_loc": [270], "fixing_code_end_loc": [276], "type": "CWE-834", "message": "In FFmpeg 3.3.3, a DoS in cine_read_header() due to lack of an EOF check might cause huge CPU and memory consumption. When a crafted CINE file, which claims a large \"duration\" field in the header but does not contain sufficient backing data, is provided, the image-offset parsing loop would consume huge CPU and memory resources, since there is no EOF check inside the loop.", "other": {"cve": {"id": "CVE-2017-14059", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-31T15:29:00.483", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In FFmpeg 3.3.3, a DoS in cine_read_header() due to lack of an EOF check might cause huge CPU and memory consumption. When a crafted CINE file, which claims a large \"duration\" field in the header but does not contain sufficient backing data, is provided, the image-offset parsing loop would consume huge CPU and memory resources, since there is no EOF check inside the loop."}, {"lang": "es", "value": "En FFmpeg 3.3.3, se podr\u00eda realizar un ataque de denegaci\u00f3n de servicio en cine_read_header() al no haber un chequeo EOF (End Of File) que podr\u00eda acabar en un gran consumo de CPU y de memoria. Cuando se env\u00eda un archivo CINE manipulado que reclama un campo \"duration\" grande en la cabecera pero que no contiene suficientes datos de respaldo, el bucle en el an\u00e1lisis image-offset consumir\u00eda una gran cantidad de recursos de CPU y de memoria, ya que no hay ning\u00fan chequeo EOF en el bucle."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "A97A44A7-DFB8-4DA8-8A4A-DBC1FF255D9A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3996", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/100631", "source": "cve@mitre.org"}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/7e80b63ecd259d69d383623e75b318bf2bd491f6", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/7e80b63ecd259d69d383623e75b318bf2bd491f6"}}