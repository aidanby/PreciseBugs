{"buggy_code": ["\n// This file is part of node-lmdb, the Node.js binding for lmdb\n// Copyright (c) 2013-2017 Timur Krist\u00f3f\n// Licensed to you under the terms of the MIT license\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#include \"node-lmdb.h\"\n\nusing namespace v8;\nusing namespace node;\n\nTxnWrap::TxnWrap(MDB_env *env, MDB_txn *txn) {\n    this->env = env;\n    this->txn = txn;\n    this->flags = 0;\n}\n\nTxnWrap::~TxnWrap() {\n    // Close if not closed already\n    if (this->txn) {\n        mdb_txn_abort(txn);\n        this->removeFromEnvWrap();\n    }\n}\n\nvoid TxnWrap::removeFromEnvWrap() {\n    if (this->ew) {\n        if (this->ew->currentWriteTxn == this) {\n            this->ew->currentWriteTxn = nullptr;\n        }\n        else {\n            auto it = std::find(ew->readTxns.begin(), ew->readTxns.end(), this);\n            if (it != ew->readTxns.end()) {\n                ew->readTxns.erase(it);\n            }\n        }\n        \n        this->ew->Unref();\n        this->ew = nullptr;\n    }\n}\n\nNAN_METHOD(TxnWrap::ctor) {\n    Nan::HandleScope scope;\n\n    EnvWrap *ew = Nan::ObjectWrap::Unwrap<EnvWrap>(Local<Object>::Cast(info[0]));\n    int flags = 0;\n\n    if (info[1]->IsObject()) {\n        Local<Object> options = Local<Object>::Cast(info[1]);\n\n        // Get flags from options\n\n        setFlagFromValue(&flags, MDB_RDONLY, \"readOnly\", false, options);\n    }\n    \n    // Check existence of current write transaction\n    if (0 == (flags & MDB_RDONLY) && ew->currentWriteTxn != nullptr) {\n        return Nan::ThrowError(\"You have already opened a write transaction in the current process, can't open a second one.\");\n    }\n\n    MDB_txn *txn;\n    int rc = mdb_txn_begin(ew->env, nullptr, flags, &txn);\n    if (rc != 0) {\n        if (rc == EINVAL) {\n            return Nan::ThrowError(\"Invalid parameter, which on MacOS is often due to more transactions than available robust locked semaphors (see node-lmdb docs for more info)\");\n        }\n        return throwLmdbError(rc);\n    }\n\n    TxnWrap* tw = new TxnWrap(ew->env, txn);\n    tw->flags = flags;\n    tw->ew = ew;\n    tw->ew->Ref();\n    tw->Wrap(info.This());\n    \n    // Set the current write transaction\n    if (0 == (flags & MDB_RDONLY)) {\n        ew->currentWriteTxn = tw;\n    }\n    else {\n        ew->readTxns.push_back(tw);\n    }\n\n    return info.GetReturnValue().Set(info.This());\n}\n\nNAN_METHOD(TxnWrap::commit) {\n    Nan::HandleScope scope;\n\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    int rc = mdb_txn_commit(tw->txn);\n    tw->removeFromEnvWrap();\n    tw->txn = nullptr;\n\n    if (rc != 0) {\n        return throwLmdbError(rc);\n    }\n}\n\nNAN_METHOD(TxnWrap::abort) {\n    Nan::HandleScope scope;\n\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    mdb_txn_abort(tw->txn);\n    tw->removeFromEnvWrap();\n    tw->txn = nullptr;\n}\n\nNAN_METHOD(TxnWrap::reset) {\n    Nan::HandleScope scope;\n\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    mdb_txn_reset(tw->txn);\n}\n\nNAN_METHOD(TxnWrap::renew) {\n    Nan::HandleScope scope;\n\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    int rc = mdb_txn_renew(tw->txn);\n    if (rc != 0) {\n        return throwLmdbError(rc);\n    }\n}\n\nNan::NAN_METHOD_RETURN_TYPE TxnWrap::getCommon(Nan::NAN_METHOD_ARGS_TYPE info, Local<Value> (*successFunc)(MDB_val&)) {\n    Nan::HandleScope scope;\n    \n    if (info.Length() != 2 && info.Length() != 3) {\n        return Nan::ThrowError(\"Invalid number of arguments to cursor.get\");\n    }\n\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n    DbiWrap *dw = Nan::ObjectWrap::Unwrap<DbiWrap>(Local<Object>::Cast(info[0]));\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    MDB_val key, oldkey, data;\n    bool keyIsValid;\n    auto keyType = inferAndValidateKeyType(info[1], info[2], dw->keyType, keyIsValid);\n    if (!keyIsValid) {\n        // inferAndValidateKeyType already threw an error\n        return;\n    }\n    auto freeKey = argToKey(info[1], key, keyType, keyIsValid);\n    if (!keyIsValid) {\n        // argToKey already threw an error\n        return;\n    }\n\n    // Bookkeeping for old key so that we can free it even if key will point inside LMDB\n    oldkey.mv_data = key.mv_data;\n    oldkey.mv_size = key.mv_size;\n\n    int rc = mdb_get(tw->txn, dw->dbi, &key, &data);\n    \n    if (freeKey) {\n        freeKey(oldkey);\n    }\n\n    if (rc == MDB_NOTFOUND) {\n        return info.GetReturnValue().Set(Nan::Null());\n    }\n    else if (rc != 0) {\n        return throwLmdbError(rc);\n    }\n    else {\n      return info.GetReturnValue().Set(successFunc(data));\n    }\n}\n\nNAN_METHOD(TxnWrap::getString) {\n    return getCommon(info, valToString);\n}\n\nNAN_METHOD(TxnWrap::getStringUnsafe) {\n    return getCommon(info, valToStringUnsafe);\n}\n\nNAN_METHOD(TxnWrap::getBinary) {\n    return getCommon(info, valToBinary);\n}\n\nNAN_METHOD(TxnWrap::getBinaryUnsafe) {\n    return getCommon(info, valToBinaryUnsafe);\n}\n\nNAN_METHOD(TxnWrap::getNumber) {\n    return getCommon(info, valToNumber);\n}\n\nNAN_METHOD(TxnWrap::getBoolean) {\n    return getCommon(info, valToBoolean);\n}\n\nNan::NAN_METHOD_RETURN_TYPE TxnWrap::putCommon(Nan::NAN_METHOD_ARGS_TYPE info, void (*fillFunc)(Nan::NAN_METHOD_ARGS_TYPE info, MDB_val&), void (*freeData)(MDB_val&)) {\n    Nan::HandleScope scope;\n    \n    if (info.Length() != 3 && info.Length() != 4) {\n        return Nan::ThrowError(\"Invalid number of arguments to txn.put\");\n    }\n\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n    DbiWrap *dw = Nan::ObjectWrap::Unwrap<DbiWrap>(Local<Object>::Cast(info[0]));\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    int flags = 0;\n    MDB_val key, data;\n    bool keyIsValid;\n    auto keyType = inferAndValidateKeyType(info[1], info[3], dw->keyType, keyIsValid);\n    if (!keyIsValid) {\n        // inferAndValidateKeyType already threw an error\n        return;\n    }\n    auto freeKey = argToKey(info[1], key, keyType, keyIsValid);\n    if (!keyIsValid) {\n        // argToKey already threw an error\n        return;\n    }\n    \n    if (!info[3]->IsNull() && !info[3]->IsUndefined() && info[3]->IsObject()) {\n        auto options = Local<Object>::Cast(info[3]);\n        setFlagFromValue(&flags, MDB_NODUPDATA, \"noDupData\", false, options);\n        setFlagFromValue(&flags, MDB_NOOVERWRITE, \"noOverwrite\", false, options);\n        setFlagFromValue(&flags, MDB_APPEND, \"append\", false, options);\n        setFlagFromValue(&flags, MDB_APPENDDUP, \"appendDup\", false, options);\n        \n        // NOTE: does not make sense to support MDB_RESERVE, because it wouldn't save the memcpy from V8 to lmdb\n    }\n\n    // Fill key and data\n    fillFunc(info, data);\n    \n    // Keep a copy of the original key and data, so we can free them\n    MDB_val originalKey = key;\n    MDB_val originalData = data;\n\n    int rc = mdb_put(tw->txn, dw->dbi, &key, &data, flags);\n    \n    // Free original key and data (what was supplied by the user, not what points to lmdb)\n    if (freeKey) {\n        freeKey(originalKey);\n    }\n    if (freeData) {\n        freeData(originalData);\n    }\n\n    // Check result code\n    if (rc != 0) {\n        return throwLmdbError(rc);\n    }\n}\n\nNAN_METHOD(TxnWrap::putString) {\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        CustomExternalStringResource::writeTo(Local<String>::Cast(info[2]), &data);\n    }, [](MDB_val &data) -> void {\n        delete[] (uint16_t*)data.mv_data;\n    });\n}\n\nNAN_METHOD(TxnWrap::putBinary) {\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        data.mv_size = node::Buffer::Length(info[2]);\n        data.mv_data = node::Buffer::Data(info[2]);\n    }, [](MDB_val &) -> void {\n        // The data is owned by the node::Buffer so we don't need to free it.\n    });\n}\n\n// This is used by putNumber for temporary storage\n#ifdef thread_local\nstatic thread_local double numberToPut = 0.0;\n#else\nstatic double numberToPut = 0.0;\n#endif\n\nNAN_METHOD(TxnWrap::putNumber) {\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        auto numberLocal = Nan::To<v8::Number>(info[2]).ToLocalChecked();\n        numberToPut = numberLocal->Value();\n\n        data.mv_size = sizeof(double);\n        data.mv_data = &numberToPut;\n    }, nullptr);\n}\n\n// This is used by putBoolean for temporary storage\n#ifdef thread_local\nstatic thread_local bool booleanToPut = false;\n#else\nstatic bool booleanToPut = false;\n#endif\n\nNAN_METHOD(TxnWrap::putBoolean) {\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        auto booleanLocal = Nan::To<v8::Boolean>(info[2]).ToLocalChecked();\n        booleanToPut = booleanLocal->Value();\n\n        data.mv_size = sizeof(bool);\n        data.mv_data = &booleanToPut;\n    }, nullptr);\n}\n\nNAN_METHOD(TxnWrap::del) {\n    Nan::HandleScope scope;\n    \n    // Check argument count\n    auto argCount = info.Length();\n    if (argCount < 2 || argCount > 4) {\n        return Nan::ThrowError(\"Invalid number of arguments to cursor.del, should be: (a) <dbi>, <key> (b) <dbi>, <key>, <options> (c) <dbi>, <key>, <data> (d) <dbi>, <key>, <data>, <options>\");\n    }\n\n    // Unwrap native objects\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n    DbiWrap *dw = Nan::ObjectWrap::Unwrap<DbiWrap>(Local<Object>::Cast(info[0]));\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    // Take care of options object and data handle\n    Local<Value> options;\n    Local<Value> dataHandle;\n    \n    if (argCount == 4) {\n        options = info[3];\n        dataHandle = info[2];\n    }\n    else if (argCount == 3) {\n        if (info[2]->IsObject()) {\n            options = info[2];\n            dataHandle = Nan::Undefined();\n        }\n        else {\n            options = Nan::Undefined();\n            dataHandle = info[2];\n        }\n    }\n    else if (argCount == 2) {\n        options = Nan::Undefined();\n        dataHandle = Nan::Undefined();\n    }\n    else {\n        return Nan::ThrowError(\"Unknown arguments to cursor.del, this could be a node-lmdb bug!\");\n    }\n\n    MDB_val key;\n    bool keyIsValid;\n    auto keyType = inferAndValidateKeyType(info[1], options, dw->keyType, keyIsValid);\n    if (!keyIsValid) {\n        // inferAndValidateKeyType already threw an error\n        return;\n    }\n    auto freeKey = argToKey(info[1], key, keyType, keyIsValid);\n    if (!keyIsValid) {\n        // argToKey already threw an error\n        return;\n    }\n\n    // Set data if dupSort true and data given\n    MDB_val data;\n    bool freeData = false;\n    \n    if ((dw->flags & MDB_DUPSORT) && !(dataHandle->IsUndefined())) {\n        if (dataHandle->IsString()) {\n            CustomExternalStringResource::writeTo(Local<String>::Cast(dataHandle), &data);\n            freeData = true;\n        }\n        else if (node::Buffer::HasInstance(dataHandle)) {\n            data.mv_size = node::Buffer::Length(dataHandle);\n            data.mv_data = node::Buffer::Data(dataHandle);\n            freeData = true;\n        }\n        else if (dataHandle->IsNumber()) {\n            auto numberLocal = Nan::To<v8::Number>(dataHandle).ToLocalChecked();\n            data.mv_size = sizeof(double);\n            data.mv_data = new double;\n            *reinterpret_cast<double*>(data.mv_data) = numberLocal->Value();\n            freeData = true;\n        }\n        else if (dataHandle->IsBoolean()) {\n            auto booleanLocal = Nan::To<v8::Boolean>(dataHandle).ToLocalChecked();\n            data.mv_size = sizeof(double);\n            data.mv_data = new bool;\n            *reinterpret_cast<bool*>(data.mv_data) = booleanLocal->Value();\n            freeData = true;\n        }\n        else {\n            Nan::ThrowError(\"Invalid data type.\");\n        }\n    }\n\n    int rc = mdb_del(tw->txn, dw->dbi, &key, freeData ? &data : nullptr);\n\n    if (freeKey) {\n        freeKey(key);\n    }\n    \n    if (freeData) {\n        if (dataHandle->IsString()) {\n            delete[] (uint16_t*)data.mv_data;\n        }\n        else if (node::Buffer::HasInstance(dataHandle)) {\n            // I think the data is owned by the node::Buffer so we don't need to free it - need to clarify\n        }\n        else if (dataHandle->IsNumber()) {\n            delete (double*)data.mv_data;\n        }\n        else if (dataHandle->IsBoolean()) {\n            delete (bool*)data.mv_data;\n        }\n    }\n\n    if (rc != 0) {\n        return throwLmdbError(rc);\n    }\n}\n"], "fixing_code": ["\n// This file is part of node-lmdb, the Node.js binding for lmdb\n// Copyright (c) 2013-2017 Timur Krist\u00f3f\n// Licensed to you under the terms of the MIT license\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n#include \"node-lmdb.h\"\n\nusing namespace v8;\nusing namespace node;\n\nTxnWrap::TxnWrap(MDB_env *env, MDB_txn *txn) {\n    this->env = env;\n    this->txn = txn;\n    this->flags = 0;\n}\n\nTxnWrap::~TxnWrap() {\n    // Close if not closed already\n    if (this->txn) {\n        mdb_txn_abort(txn);\n        this->removeFromEnvWrap();\n    }\n}\n\nvoid TxnWrap::removeFromEnvWrap() {\n    if (this->ew) {\n        if (this->ew->currentWriteTxn == this) {\n            this->ew->currentWriteTxn = nullptr;\n        }\n        else {\n            auto it = std::find(ew->readTxns.begin(), ew->readTxns.end(), this);\n            if (it != ew->readTxns.end()) {\n                ew->readTxns.erase(it);\n            }\n        }\n        \n        this->ew->Unref();\n        this->ew = nullptr;\n    }\n}\n\nNAN_METHOD(TxnWrap::ctor) {\n    Nan::HandleScope scope;\n\n    EnvWrap *ew = Nan::ObjectWrap::Unwrap<EnvWrap>(Local<Object>::Cast(info[0]));\n    int flags = 0;\n\n    if (info[1]->IsObject()) {\n        Local<Object> options = Local<Object>::Cast(info[1]);\n\n        // Get flags from options\n\n        setFlagFromValue(&flags, MDB_RDONLY, \"readOnly\", false, options);\n    }\n    \n    // Check existence of current write transaction\n    if (0 == (flags & MDB_RDONLY) && ew->currentWriteTxn != nullptr) {\n        return Nan::ThrowError(\"You have already opened a write transaction in the current process, can't open a second one.\");\n    }\n\n    MDB_txn *txn;\n    int rc = mdb_txn_begin(ew->env, nullptr, flags, &txn);\n    if (rc != 0) {\n        if (rc == EINVAL) {\n            return Nan::ThrowError(\"Invalid parameter, which on MacOS is often due to more transactions than available robust locked semaphors (see node-lmdb docs for more info)\");\n        }\n        return throwLmdbError(rc);\n    }\n\n    TxnWrap* tw = new TxnWrap(ew->env, txn);\n    tw->flags = flags;\n    tw->ew = ew;\n    tw->ew->Ref();\n    tw->Wrap(info.This());\n    \n    // Set the current write transaction\n    if (0 == (flags & MDB_RDONLY)) {\n        ew->currentWriteTxn = tw;\n    }\n    else {\n        ew->readTxns.push_back(tw);\n    }\n\n    return info.GetReturnValue().Set(info.This());\n}\n\nNAN_METHOD(TxnWrap::commit) {\n    Nan::HandleScope scope;\n\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    int rc = mdb_txn_commit(tw->txn);\n    tw->removeFromEnvWrap();\n    tw->txn = nullptr;\n\n    if (rc != 0) {\n        return throwLmdbError(rc);\n    }\n}\n\nNAN_METHOD(TxnWrap::abort) {\n    Nan::HandleScope scope;\n\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    mdb_txn_abort(tw->txn);\n    tw->removeFromEnvWrap();\n    tw->txn = nullptr;\n}\n\nNAN_METHOD(TxnWrap::reset) {\n    Nan::HandleScope scope;\n\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    mdb_txn_reset(tw->txn);\n}\n\nNAN_METHOD(TxnWrap::renew) {\n    Nan::HandleScope scope;\n\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    int rc = mdb_txn_renew(tw->txn);\n    if (rc != 0) {\n        return throwLmdbError(rc);\n    }\n}\n\nNan::NAN_METHOD_RETURN_TYPE TxnWrap::getCommon(Nan::NAN_METHOD_ARGS_TYPE info, Local<Value> (*successFunc)(MDB_val&)) {\n    Nan::HandleScope scope;\n    \n    if (info.Length() != 2 && info.Length() != 3) {\n        return Nan::ThrowError(\"Invalid number of arguments to cursor.get\");\n    }\n\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n    DbiWrap *dw = Nan::ObjectWrap::Unwrap<DbiWrap>(Local<Object>::Cast(info[0]));\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    MDB_val key, oldkey, data;\n    bool keyIsValid;\n    auto keyType = inferAndValidateKeyType(info[1], info[2], dw->keyType, keyIsValid);\n    if (!keyIsValid) {\n        // inferAndValidateKeyType already threw an error\n        return;\n    }\n    auto freeKey = argToKey(info[1], key, keyType, keyIsValid);\n    if (!keyIsValid) {\n        // argToKey already threw an error\n        return;\n    }\n\n    // Bookkeeping for old key so that we can free it even if key will point inside LMDB\n    oldkey.mv_data = key.mv_data;\n    oldkey.mv_size = key.mv_size;\n\n    int rc = mdb_get(tw->txn, dw->dbi, &key, &data);\n    \n    if (freeKey) {\n        freeKey(oldkey);\n    }\n\n    if (rc == MDB_NOTFOUND) {\n        return info.GetReturnValue().Set(Nan::Null());\n    }\n    else if (rc != 0) {\n        return throwLmdbError(rc);\n    }\n    else {\n      return info.GetReturnValue().Set(successFunc(data));\n    }\n}\n\nNAN_METHOD(TxnWrap::getString) {\n    return getCommon(info, valToString);\n}\n\nNAN_METHOD(TxnWrap::getStringUnsafe) {\n    return getCommon(info, valToStringUnsafe);\n}\n\nNAN_METHOD(TxnWrap::getBinary) {\n    return getCommon(info, valToBinary);\n}\n\nNAN_METHOD(TxnWrap::getBinaryUnsafe) {\n    return getCommon(info, valToBinaryUnsafe);\n}\n\nNAN_METHOD(TxnWrap::getNumber) {\n    return getCommon(info, valToNumber);\n}\n\nNAN_METHOD(TxnWrap::getBoolean) {\n    return getCommon(info, valToBoolean);\n}\n\nNan::NAN_METHOD_RETURN_TYPE TxnWrap::putCommon(Nan::NAN_METHOD_ARGS_TYPE info, void (*fillFunc)(Nan::NAN_METHOD_ARGS_TYPE info, MDB_val&), void (*freeData)(MDB_val&)) {\n    Nan::HandleScope scope;\n    \n    if (info.Length() != 3 && info.Length() != 4) {\n        return Nan::ThrowError(\"Invalid number of arguments to txn.put\");\n    }\n\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n    DbiWrap *dw = Nan::ObjectWrap::Unwrap<DbiWrap>(Local<Object>::Cast(info[0]));\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    int flags = 0;\n    MDB_val key, data;\n    bool keyIsValid;\n    auto keyType = inferAndValidateKeyType(info[1], info[3], dw->keyType, keyIsValid);\n    if (!keyIsValid) {\n        // inferAndValidateKeyType already threw an error\n        return;\n    }\n    auto freeKey = argToKey(info[1], key, keyType, keyIsValid);\n    if (!keyIsValid) {\n        // argToKey already threw an error\n        return;\n    }\n    \n    if (!info[3]->IsNull() && !info[3]->IsUndefined() && info[3]->IsObject()) {\n        auto options = Local<Object>::Cast(info[3]);\n        setFlagFromValue(&flags, MDB_NODUPDATA, \"noDupData\", false, options);\n        setFlagFromValue(&flags, MDB_NOOVERWRITE, \"noOverwrite\", false, options);\n        setFlagFromValue(&flags, MDB_APPEND, \"append\", false, options);\n        setFlagFromValue(&flags, MDB_APPENDDUP, \"appendDup\", false, options);\n        \n        // NOTE: does not make sense to support MDB_RESERVE, because it wouldn't save the memcpy from V8 to lmdb\n    }\n\n    // Fill key and data\n    fillFunc(info, data);\n    \n    // Keep a copy of the original key and data, so we can free them\n    MDB_val originalKey = key;\n    MDB_val originalData = data;\n\n    int rc = mdb_put(tw->txn, dw->dbi, &key, &data, flags);\n    \n    // Free original key and data (what was supplied by the user, not what points to lmdb)\n    if (freeKey) {\n        freeKey(originalKey);\n    }\n    if (freeData) {\n        freeData(originalData);\n    }\n\n    // Check result code\n    if (rc != 0) {\n        return throwLmdbError(rc);\n    }\n}\n\nNAN_METHOD(TxnWrap::putString) {\n    if (!info[2]->IsString())\n        return Nan::ThrowError(\"Value must be a string.\");\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        CustomExternalStringResource::writeTo(Local<String>::Cast(info[2]), &data);\n    }, [](MDB_val &data) -> void {\n        delete[] (uint16_t*)data.mv_data;\n    });\n}\n\nNAN_METHOD(TxnWrap::putBinary) {\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        data.mv_size = node::Buffer::Length(info[2]);\n        data.mv_data = node::Buffer::Data(info[2]);\n    }, [](MDB_val &) -> void {\n        // The data is owned by the node::Buffer so we don't need to free it.\n    });\n}\n\n// This is used by putNumber for temporary storage\n#ifdef thread_local\nstatic thread_local double numberToPut = 0.0;\n#else\nstatic double numberToPut = 0.0;\n#endif\n\nNAN_METHOD(TxnWrap::putNumber) {\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        auto numberLocal = Nan::To<v8::Number>(info[2]).ToLocalChecked();\n        numberToPut = numberLocal->Value();\n\n        data.mv_size = sizeof(double);\n        data.mv_data = &numberToPut;\n    }, nullptr);\n}\n\n// This is used by putBoolean for temporary storage\n#ifdef thread_local\nstatic thread_local bool booleanToPut = false;\n#else\nstatic bool booleanToPut = false;\n#endif\n\nNAN_METHOD(TxnWrap::putBoolean) {\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        auto booleanLocal = Nan::To<v8::Boolean>(info[2]).ToLocalChecked();\n        booleanToPut = booleanLocal->Value();\n\n        data.mv_size = sizeof(bool);\n        data.mv_data = &booleanToPut;\n    }, nullptr);\n}\n\nNAN_METHOD(TxnWrap::del) {\n    Nan::HandleScope scope;\n    \n    // Check argument count\n    auto argCount = info.Length();\n    if (argCount < 2 || argCount > 4) {\n        return Nan::ThrowError(\"Invalid number of arguments to cursor.del, should be: (a) <dbi>, <key> (b) <dbi>, <key>, <options> (c) <dbi>, <key>, <data> (d) <dbi>, <key>, <data>, <options>\");\n    }\n\n    // Unwrap native objects\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n    DbiWrap *dw = Nan::ObjectWrap::Unwrap<DbiWrap>(Local<Object>::Cast(info[0]));\n\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n\n    // Take care of options object and data handle\n    Local<Value> options;\n    Local<Value> dataHandle;\n    \n    if (argCount == 4) {\n        options = info[3];\n        dataHandle = info[2];\n    }\n    else if (argCount == 3) {\n        if (info[2]->IsObject()) {\n            options = info[2];\n            dataHandle = Nan::Undefined();\n        }\n        else {\n            options = Nan::Undefined();\n            dataHandle = info[2];\n        }\n    }\n    else if (argCount == 2) {\n        options = Nan::Undefined();\n        dataHandle = Nan::Undefined();\n    }\n    else {\n        return Nan::ThrowError(\"Unknown arguments to cursor.del, this could be a node-lmdb bug!\");\n    }\n\n    MDB_val key;\n    bool keyIsValid;\n    auto keyType = inferAndValidateKeyType(info[1], options, dw->keyType, keyIsValid);\n    if (!keyIsValid) {\n        // inferAndValidateKeyType already threw an error\n        return;\n    }\n    auto freeKey = argToKey(info[1], key, keyType, keyIsValid);\n    if (!keyIsValid) {\n        // argToKey already threw an error\n        return;\n    }\n\n    // Set data if dupSort true and data given\n    MDB_val data;\n    bool freeData = false;\n    \n    if ((dw->flags & MDB_DUPSORT) && !(dataHandle->IsUndefined())) {\n        if (dataHandle->IsString()) {\n            CustomExternalStringResource::writeTo(Local<String>::Cast(dataHandle), &data);\n            freeData = true;\n        }\n        else if (node::Buffer::HasInstance(dataHandle)) {\n            data.mv_size = node::Buffer::Length(dataHandle);\n            data.mv_data = node::Buffer::Data(dataHandle);\n            freeData = true;\n        }\n        else if (dataHandle->IsNumber()) {\n            auto numberLocal = Nan::To<v8::Number>(dataHandle).ToLocalChecked();\n            data.mv_size = sizeof(double);\n            data.mv_data = new double;\n            *reinterpret_cast<double*>(data.mv_data) = numberLocal->Value();\n            freeData = true;\n        }\n        else if (dataHandle->IsBoolean()) {\n            auto booleanLocal = Nan::To<v8::Boolean>(dataHandle).ToLocalChecked();\n            data.mv_size = sizeof(double);\n            data.mv_data = new bool;\n            *reinterpret_cast<bool*>(data.mv_data) = booleanLocal->Value();\n            freeData = true;\n        }\n        else {\n            Nan::ThrowError(\"Invalid data type.\");\n        }\n    }\n\n    int rc = mdb_del(tw->txn, dw->dbi, &key, freeData ? &data : nullptr);\n\n    if (freeKey) {\n        freeKey(key);\n    }\n    \n    if (freeData) {\n        if (dataHandle->IsString()) {\n            delete[] (uint16_t*)data.mv_data;\n        }\n        else if (node::Buffer::HasInstance(dataHandle)) {\n            // I think the data is owned by the node::Buffer so we don't need to free it - need to clarify\n        }\n        else if (dataHandle->IsNumber()) {\n            delete (double*)data.mv_data;\n        }\n        else if (dataHandle->IsBoolean()) {\n            delete (bool*)data.mv_data;\n        }\n    }\n\n    if (rc != 0) {\n        return throwLmdbError(rc);\n    }\n}\n"], "filenames": ["src/txn.cpp"], "buggy_code_start_loc": [297], "buggy_code_end_loc": [297], "fixing_code_start_loc": [298], "fixing_code_end_loc": [300], "type": "NVD-CWE-noinfo", "message": "The package node-lmdb before 0.9.7 are vulnerable to Denial of Service (DoS) when defining a non-invokable ToString value, which will cause a crash during type check.", "other": {"cve": {"id": "CVE-2022-21164", "sourceIdentifier": "report@snyk.io", "published": "2022-03-16T16:15:10.800", "lastModified": "2022-03-28T13:08:48.147", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package node-lmdb before 0.9.7 are vulnerable to Denial of Service (DoS) when defining a non-invokable ToString value, which will cause a crash during type check."}, {"lang": "es", "value": "El paquete node-lmdb versiones anteriores a 0.9.7, es vulnerable a una denegaci\u00f3n de servicio (DoS) cuando es definido un valor ToString no invocable, lo que causar\u00e1 un fallo durante la comprobaci\u00f3n de tipo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:node-lmdb_project:node-lmdb:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.9.7", "matchCriteriaId": "0703CB99-E6BA-4905-A738-A059B303E727"}]}]}], "references": [{"url": "https://github.com/Venemo/node-lmdb/commit/97760104c0fd311206b88aecd91fa1f59fe2b85a", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-NODELMDB-2400723", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Venemo/node-lmdb/commit/97760104c0fd311206b88aecd91fa1f59fe2b85a"}}