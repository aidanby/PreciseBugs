{"buggy_code": ["<?php\n\nnamespace Backend\\Modules\\Extensions\\Engine;\n\nuse Backend\\Modules\\Locale\\Engine\\Model as BackendLocaleModel;\nuse Common\\ModulesSettings;\nuse Symfony\\Component\\Filesystem\\Filesystem;\nuse Symfony\\Component\\Finder\\Finder;\nuse Backend\\Core\\Engine\\Authentication as BackendAuthentication;\nuse Backend\\Core\\Engine\\DataGridFunctions as BackendDataGridFunctions;\nuse Backend\\Core\\Engine\\Exception;\nuse Backend\\Core\\Language\\Language as BL;\nuse Backend\\Core\\Engine\\Model as BackendModel;\n\n/**\n * In this file we store all generic functions that we will be using in the extensions module.\n */\nclass Model\n{\n    /**\n     * Overview of templates.\n     *\n     * @var string\n     */\n    const QUERY_BROWSE_TEMPLATES = 'SELECT i.id, i.label AS title\n                                  FROM themes_templates AS i\n                                  WHERE i.theme = ?\n                                  ORDER BY i.label ASC';\n\n    /**\n     * Modules which are part of the core and can not be managed.\n     *\n     * @var array\n     */\n    private static $ignoredModules = [\n        'Authentication',\n        'Dashboard',\n        'Error',\n        'Extensions',\n        'Settings',\n    ];\n\n    /**\n     * Build HTML for a template (visual representation)\n     *\n     * @param string $format The template format.\n     * @param bool $large Will the HTML be used in a large version?\n     *\n     * @return string\n     */\n    public static function buildTemplateHTML(string $format, bool $large = false): string\n    {\n        // cleanup\n        $table = self::templateSyntaxToArray($format);\n\n        // init var\n        $rows = count($table);\n        if ($rows === 0) {\n            throw new Exception('Invalid template-format.');\n        }\n        $cells = count($table[0]);\n\n        $htmlContent = [];\n\n        // loop rows\n        for ($y = 0; $y < $rows; ++$y) {\n            $htmlContent[$y] = [];\n\n            // loop cells\n            for ($x = 0; $x < $cells; ++$x) {\n                // skip if needed\n                if (!isset($table[$y][$x])) {\n                    continue;\n                }\n\n                // get value\n                $value = $table[$y][$x];\n\n                // init var\n                $colspan = 1;\n\n                // reset items in the same column\n                while ($x + $colspan < $cells && $table[$y][$x + $colspan] === $value) {\n                    $table[$y][$x + $colspan++] = null;\n                }\n\n                // init var\n                $rowspan = 1;\n                $rowMatches = true;\n\n                // loop while the rows match\n                while ($rowMatches && $y + $rowspan < $rows) {\n                    // loop columns inside spanned columns\n                    for ($i = 0; $i < $colspan; ++$i) {\n                        // check value\n                        if ($table[$y + $rowspan][$x + $i] !== $value) {\n                            // no match, so stop\n                            $rowMatches = false;\n                            break;\n                        }\n                    }\n\n                    // any rowmatches?\n                    if ($rowMatches) {\n                        // loop columns and reset value\n                        for ($i = 0; $i < $colspan; ++$i) {\n                            $table[$y + $rowspan][$x + $i] = null;\n                        }\n\n                        // increment\n                        ++$rowspan;\n                    }\n                }\n\n                $htmlContent[$y][$x] = [\n                    'title' => \\SpoonFilter::ucfirst($value),\n                    'value' => $value,\n                    'exists' => $value != '/',\n                    'rowspan' => $rowspan,\n                    'colspan' => $colspan,\n                    'large' => $large,\n                ];\n            }\n        }\n\n        $templating = BackendModel::get('template');\n        $templating->assign('table', $htmlContent);\n        $html = $templating->getContent('Extensions/Layout/Templates/Templates.html.twig');\n\n        return $html;\n    }\n\n    /**\n     * Checks the settings and optionally returns an array with warnings\n     *\n     * @return array\n     */\n    public static function checkSettings(): array\n    {\n        $warnings = [];\n        $akismetModules = self::getModulesThatRequireAkismet();\n        $googleMapsModules = self::getModulesThatRequireGoogleMaps();\n\n        // check if this action is allowed\n        if (!BackendAuthentication::isAllowedAction('Index', 'Settings')) {\n            return [];\n        }\n\n        // check if the akismet key is available if there are modules that require it\n        if (!empty($akismetModules) && BackendModel::get('fork.settings')->get('Core', 'akismet_key', null) == '') {\n            // add warning\n            $warnings[] = [\n                'message' => sprintf(\n                    BL::err('AkismetKey'),\n                    BackendModel::createUrlForAction('Index', 'Settings')\n                ),\n            ];\n        }\n\n        // check if the google maps key is available if there are modules that require it\n        if (!empty($googleMapsModules)\n            && BackendModel::get('fork.settings')->get('Core', 'google_maps_key', null) == '') {\n            // add warning\n            $warnings[] = [\n                'message' => sprintf(\n                    BL::err('GoogleMapsKey'),\n                    BackendModel::createUrlForAction('Index', 'Settings')\n                ),\n            ];\n        }\n\n        return $warnings;\n    }\n\n    /**\n     * Clear all applications cache.\n     *\n     * Note: we do not need to rebuild anything, the core will do this when noticing the cache files are missing.\n     */\n    public static function clearCache(): void\n    {\n        $finder = new Finder();\n        $filesystem = new Filesystem();\n        $files = $finder->files()\n            ->name('*.php')\n            ->name('*.js')\n            ->in(BACKEND_CACHE_PATH . '/Locale')\n            ->in(FRONTEND_CACHE_PATH . '/Navigation')\n            ->in(FRONTEND_CACHE_PATH . '/Locale');\n        foreach ($files as $file) {\n            $filesystem->remove($file->getRealPath());\n        }\n        BackendModel::getContainer()->get('cache.backend_navigation')->delete();\n    }\n\n    /**\n     * Delete a template.\n     *\n     * @param int $id The id of the template to delete.\n     *\n     * @return bool\n     */\n    public static function deleteTemplate(int $id): bool\n    {\n        $templates = self::getTemplates();\n\n        // we can't delete a template that doesn't exist\n        if (!isset($templates[$id])) {\n            return false;\n        }\n\n        // we can't delete the last template\n        if (count($templates) === 1) {\n            return false;\n        }\n\n        // we can't delete the default template\n        if ($id == BackendModel::get('fork.settings')->get('Pages', 'default_template')) {\n            return false;\n        }\n        if (self::isTemplateInUse($id)) {\n            return false;\n        }\n\n        $database = BackendModel::getContainer()->get('database');\n        $database->delete('themes_templates', 'id = ?', $id);\n        $ids = (array) $database->getColumn(\n            'SELECT i.revision_id\n             FROM pages AS i\n             WHERE i.template_id = ? AND i.status != ?',\n            [$id, 'active']\n        );\n\n        if (!empty($ids)) {\n            // delete those pages and the linked blocks\n            $database->delete('pages', 'revision_id IN(' . implode(',', $ids) . ')');\n            $database->delete('pages_blocks', 'revision_id IN(' . implode(',', $ids) . ')');\n        }\n\n        return true;\n    }\n\n    /**\n     * Does this module exist.\n     * This does not check for existence in the database but on the filesystem.\n     *\n     * @param string $module Module to check for existence.\n     *\n     * @return bool\n     */\n    public static function existsModule(string $module): bool\n    {\n        return is_dir(BACKEND_MODULES_PATH . '/' . $module);\n    }\n\n    /**\n     * Check if a template exists\n     *\n     * @param int $id The Id of the template to check for existence.\n     *\n     * @return bool\n     */\n    public static function existsTemplate(int $id): bool\n    {\n        return (bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT i.id FROM themes_templates AS i WHERE i.id = ?',\n            [$id]\n        );\n    }\n\n    /**\n     * Does this template exist.\n     * This does not check for existence in the database but on the filesystem.\n     *\n     * @param string $theme Theme to check for existence.\n     *\n     * @return bool\n     */\n    public static function existsTheme(string $theme): bool\n    {\n        return is_dir(FRONTEND_PATH . '/Themes/' . (string) $theme) || $theme === 'Core';\n    }\n\n    public static function getExtras(): array\n    {\n        $extras = (array) BackendModel::getContainer()->get('database')->getRecords(\n            'SELECT i.id, i.module, i.type, i.label, i.data\n             FROM modules_extras AS i\n             INNER JOIN modules AS m ON i.module = m.name\n             WHERE i.hidden = ?\n             ORDER BY i.module, i.sequence',\n            [false],\n            'id'\n        );\n        $itemsToRemove = [];\n\n        foreach ($extras as $id => &$row) {\n            $row['data'] = $row['data'] === null ? [] : @unserialize($row['data'], ['allowed_classes' => false]);\n            if (isset($row['data']['language']) && $row['data']['language'] != BL::getWorkingLanguage()) {\n                $itemsToRemove[] = $id;\n            }\n\n            // set URL if needed, we use '' instead of null, because otherwise the module of the current action (modules) is used.\n            if (!isset($row['data']['url'])) {\n                $row['data']['url'] = BackendModel::createUrlForAction('', $row['module']);\n            }\n\n            $name = \\SpoonFilter::ucfirst(BL::lbl($row['label']));\n            if (isset($row['data']['extra_label'])) {\n                $name = $row['data']['extra_label'];\n            }\n            if (isset($row['data']['label_variables'])) {\n                $name = vsprintf($name, $row['data']['label_variables']);\n            }\n\n            // add human readable name\n            $module = \\SpoonFilter::ucfirst(BL::lbl(\\SpoonFilter::toCamelCase($row['module'])));\n            $extraTypeLabel = \\SpoonFilter::ucfirst(BL::lbl(\\SpoonFilter::toCamelCase('ExtraType_' . $row['type'])));\n            $row['human_name'] = $extraTypeLabel . ': ' . $name;\n            $row['path'] = $extraTypeLabel . ' \u203a ' . $module . ($module !== $name ? ' \u203a ' . $name : '');\n        }\n\n        // any items to remove?\n        if (!empty($itemsToRemove)) {\n            foreach ($itemsToRemove as $id) {\n                unset($extras[$id]);\n            }\n        }\n\n        return $extras;\n    }\n\n    public static function getExtrasData(): array\n    {\n        $extras = (array) BackendModel::getContainer()->get('database')->getRecords(\n            'SELECT i.id, i.module, i.type, i.label, i.data\n             FROM modules_extras AS i\n             INNER JOIN modules AS m ON i.module = m.name\n             WHERE i.hidden = ?\n             ORDER BY i.module, i.sequence',\n            [false]\n        );\n        $values = [];\n\n        foreach ($extras as $row) {\n            $row['data'] = @unserialize($row['data'], ['allowed_classes' => false]);\n\n            // remove items that are not for the current language\n            if (isset($row['data']['language']) && $row['data']['language'] != BL::getWorkingLanguage()) {\n                continue;\n            }\n\n            // set URL if needed\n            if (!isset($row['data']['url'])) {\n                $row['data']['url'] = BackendModel::createUrlForAction(\n                    'Index',\n                    $row['module']\n                );\n            }\n\n            $name = \\SpoonFilter::ucfirst(BL::lbl($row['label']));\n            if (isset($row['data']['extra_label'])) {\n                $name = $row['data']['extra_label'];\n            }\n            if (isset($row['data']['label_variables'])) {\n                $name = vsprintf($name, $row['data']['label_variables']);\n            }\n            $moduleName = \\SpoonFilter::ucfirst(BL::lbl(\\SpoonFilter::toCamelCase($row['module'])));\n\n            if (!isset($values[$row['module']])) {\n                $values[$row['module']] = [\n                    'value' => $row['module'],\n                    'name' => $moduleName,\n                    'items' => [],\n                ];\n            }\n\n            $values[$row['module']]['items'][$row['type']][$name] = ['id' => $row['id'], 'label' => $name];\n        }\n\n        return $values;\n    }\n\n    /**\n     * Fetch the module information from the info.xml file.\n     *\n     * @param string $module\n     *\n     * @return array\n     */\n    public static function getModuleInformation(string $module): array\n    {\n        $pathInfoXml = BACKEND_MODULES_PATH . '/' . $module . '/info.xml';\n        $information = ['data' => [], 'warnings' => []];\n\n        if (is_file($pathInfoXml)) {\n            try {\n                $infoXml = @new \\SimpleXMLElement($pathInfoXml, LIBXML_NOCDATA, true);\n                $information['data'] = self::processModuleXml($infoXml);\n                if (empty($information['data'])) {\n                    $information['warnings'][] = [\n                        'message' => BL::getMessage('InformationFileIsEmpty'),\n                    ];\n                }\n            } catch (Exception $e) {\n                $information['warnings'][] = [\n                    'message' => BL::getMessage('InformationFileCouldNotBeLoaded'),\n                ];\n            }\n        } else {\n            $information['warnings'][] = [\n                'message' => BL::getMessage('InformationFileIsMissing'),\n            ];\n        }\n\n        return $information;\n    }\n\n    /**\n     * Get modules based on the directory listing in the backend application.\n     *\n     * If a module contains a info.xml it will be parsed.\n     *\n     * @return array\n     */\n    public static function getModules(): array\n    {\n        $installedModules = (array) BackendModel::getContainer()\n            ->getParameter('installed_modules');\n        $modules = BackendModel::getModulesOnFilesystem(false);\n        $manageableModules = [];\n\n        // get more information for each module\n        foreach ($modules as $moduleName) {\n            if (in_array($moduleName, self::$ignoredModules)) {\n                continue;\n            }\n\n            $module = [];\n            $module['id'] = 'module_' . $moduleName;\n            $module['raw_name'] = $moduleName;\n            $module['name'] = \\SpoonFilter::ucfirst(BL::getLabel(\\SpoonFilter::toCamelCase($moduleName)));\n            $module['description'] = '';\n            $module['version'] = '';\n            $module['installed'] = false;\n\n            if (in_array($moduleName, $installedModules)) {\n                $module['installed'] = true;\n            }\n\n            try {\n                $infoXml = @new \\SimpleXMLElement(\n                    BACKEND_MODULES_PATH . '/' . $module['raw_name'] . '/info.xml',\n                    LIBXML_NOCDATA,\n                    true\n                );\n\n                $info = self::processModuleXml($infoXml);\n\n                // set fields if they were found in the XML\n                if (isset($info['description'])) {\n                    $module['description'] = BackendDataGridFunctions::truncate($info['description'], 80);\n                }\n                if (isset($info['version'])) {\n                    $module['version'] = $info['version'];\n                }\n            } catch (\\Exception $e) {\n                // don't act upon error, we simply won't possess some info\n            }\n\n            $manageableModules[] = $module;\n        }\n\n        return $manageableModules;\n    }\n\n    /**\n     * Fetch the list of modules that require Akismet API key\n     *\n     * @return array\n     */\n    public static function getModulesThatRequireAkismet(): array\n    {\n        return self::getModulesThatRequireSetting('akismet');\n    }\n\n    /**\n     * Fetch the list of modules that require Google Maps API key\n     *\n     * @return array\n     */\n    public static function getModulesThatRequireGoogleMaps(): array\n    {\n        return self::getModulesThatRequireSetting('google_maps');\n    }\n\n    /**\n     * Fetch the list of modules that require Google Recaptcha API key\n     *\n     * @return array\n     */\n    public static function getModulesThatRequireGoogleRecaptcha(): array\n    {\n        return self::getModulesThatRequireSetting('google_recaptcha');\n    }\n\n    /**\n     * Fetch the list of modules that require a certain setting. The setting is affixed by 'requires_'\n     *\n     * @param string $setting\n     *\n     * @return array\n     */\n    private static function getModulesThatRequireSetting(string $setting): array\n    {\n        if ($setting === '') {\n            return [];\n        }\n\n        /** @var ModulesSettings $moduleSettings */\n        $moduleSettings = BackendModel::get('fork.settings');\n\n        return array_filter(\n            BackendModel::getModules(),\n            function (string $module) use ($moduleSettings, $setting): bool {\n                return $moduleSettings->get($module, 'requires_' . $setting, false);\n            }\n        );\n    }\n\n    public static function getTemplate(int $id): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecord(\n            'SELECT i.* FROM themes_templates AS i WHERE i.id = ?',\n            [$id]\n        );\n    }\n\n    public static function getTemplates(string $theme = null): array\n    {\n        $database = BackendModel::getContainer()->get('database');\n        $theme = \\SpoonFilter::getValue(\n            (string) $theme,\n            null,\n            BackendModel::get('fork.settings')->get('Core', 'theme', 'Fork')\n        );\n\n        $templates = (array) $database->getRecords(\n            'SELECT i.id, i.label, i.path, i.data\n            FROM themes_templates AS i\n            WHERE i.theme = ? AND i.active = ?\n            ORDER BY i.label ASC',\n            [$theme, true],\n            'id'\n        );\n\n        $extras = (array) self::getExtras();\n        $half = (int) ceil(count($templates) / 2);\n        $i = 0;\n\n        foreach ($templates as &$row) {\n            $row['data'] = unserialize($row['data'], ['allowed_classes' => false]);\n            $row['has_block'] = false;\n\n            // reset\n            if (isset($row['data']['default_extras_' . BL::getWorkingLanguage()])) {\n                $row['data']['default_extras'] = $row['data']['default_extras_' . BL::getWorkingLanguage()];\n            }\n\n            // any extras?\n            if (isset($row['data']['default_extras'])) {\n                foreach ($row['data']['default_extras'] as $value) {\n                    if (\\SpoonFilter::isInteger($value)\n                        && isset($extras[$value]) && $extras[$value]['type'] == 'block'\n                    ) {\n                        $row['has_block'] = true;\n                    }\n                }\n            }\n\n            // validate\n            if (!isset($row['data']['format'])) {\n                throw new Exception('Invalid template-format.');\n            }\n\n            $row['html'] = self::buildTemplateHTML($row['data']['format']);\n            $row['htmlLarge'] = self::buildTemplateHTML($row['data']['format'], true);\n            $row['json'] = json_encode($row);\n            if ($i == $half) {\n                $row['break'] = true;\n            }\n            ++$i;\n        }\n\n        return (array) $templates;\n    }\n\n    public static function getThemes(): array\n    {\n        $records = [];\n        $finder = new Finder();\n        foreach ($finder->directories()->in(FRONTEND_PATH . '/Themes')->depth(0) as $directory) {\n            $pathInfoXml = BackendModel::getContainer()->getParameter('site.path_www') . '/src/Frontend/Themes/'\n                           . $directory->getBasename() . '/info.xml';\n            if (!is_file($pathInfoXml)) {\n                throw new Exception('info.xml is missing for the theme ' . $directory->getBasename());\n            }\n            try {\n                $infoXml = @new \\SimpleXMLElement($pathInfoXml, LIBXML_NOCDATA, true);\n                $information = self::processThemeXml($infoXml);\n                if (empty($information)) {\n                    throw new Exception('Invalid info.xml');\n                }\n            } catch (Exception $e) {\n                $information['thumbnail'] = 'thumbnail.png';\n            }\n\n            $item = [];\n            $item['value'] = $directory->getBasename();\n            $item['label'] = $directory->getBasename();\n            $item['thumbnail'] = '/src/Frontend/Themes/' . $item['value'] . '/' . $information['thumbnail'];\n            $item['installed'] = self::isThemeInstalled($item['value']);\n            $item['installable'] = isset($information['templates']);\n\n            $records[$item['value']] = $item;\n        }\n\n        return (array) $records;\n    }\n\n    public static function createTemplateXmlForExport(string $theme): string\n    {\n        $charset = BackendModel::getContainer()->getParameter('kernel.charset');\n\n        // build xml\n        $xml = new \\DOMDocument('1.0', $charset);\n        $xml->preserveWhiteSpace = false;\n        $xml->formatOutput = true;\n\n        $root = $xml->createElement('templates');\n        $xml->appendChild($root);\n\n        $database = BackendModel::getContainer()->get('database');\n\n        $records = $database->getRecords(self::QUERY_BROWSE_TEMPLATES, [$theme]);\n\n        foreach ($records as $row) {\n            $template = self::getTemplate($row['id']);\n            $data = unserialize($template['data'], ['allowed_classes' => false]);\n\n            $templateElement = $xml->createElement('template');\n            $templateElement->setAttribute('label', $template['label']);\n            $templateElement->setAttribute('path', $template['path']);\n            $root->appendChild($templateElement);\n\n            $positionsElement = $xml->createElement('positions');\n            $templateElement->appendChild($positionsElement);\n\n            foreach ($data['names'] as $name) {\n                $positionElement = $xml->createElement('position');\n                $positionElement->setAttribute('name', $name);\n                $positionsElement->appendChild($positionElement);\n            }\n\n            $formatElement = $xml->createElement('format');\n            $templateElement->appendChild($formatElement);\n            $formatElement->nodeValue = $data['format'];\n        }\n\n        return $xml->saveXML();\n    }\n\n    public static function hasModuleWarnings(string $module): string\n    {\n        $moduleInformation = self::getModuleInformation($module);\n\n        return !empty($moduleInformation['warnings']);\n    }\n\n    public static function insertTemplate(array $template): int\n    {\n        return (int) BackendModel::getContainer()->get('database')->insert('themes_templates', $template);\n    }\n\n    public static function installModule(string $module): void\n    {\n        $class = 'Backend\\\\Modules\\\\' . $module . '\\\\Installer\\\\Installer';\n        $variables = [];\n\n        // run installer\n        $installer = new $class(\n            BackendModel::getContainer()->get('database'),\n            BL::getActiveLanguages(),\n            array_keys(BL::getInterfaceLanguages()),\n            false,\n            $variables\n        );\n\n        $installer->install();\n\n        // clear the cache so locale (and so much more) gets rebuilt\n        self::clearCache();\n    }\n\n    public static function installTheme(string $theme): void\n    {\n        $basePath = FRONTEND_PATH . '/Themes/' . $theme;\n        $pathInfoXml = $basePath . '/info.xml';\n        $pathTranslations = $basePath . '/locale.xml';\n        $infoXml = @new \\SimpleXMLElement($pathInfoXml, LIBXML_NOCDATA, true);\n\n        $information = self::processThemeXml($infoXml);\n        if (empty($information)) {\n            throw new Exception('Invalid info.xml');\n        }\n\n        if (is_file($pathTranslations)) {\n            $translations = @simplexml_load_file($pathTranslations);\n            if ($translations !== false) {\n                BackendLocaleModel::importXML($translations);\n            }\n        }\n\n        foreach ($information['templates'] as $template) {\n            $item = [];\n            $item['theme'] = $information['name'];\n            $item['label'] = $template['label'];\n            $item['path'] = $template['path'];\n            $item['active'] = true;\n            $item['data']['format'] = $template['format'];\n            $item['data']['image'] = $template['image'];\n\n            // build positions\n            $item['data']['names'] = [];\n            $item['data']['default_extras'] = [];\n            foreach ($template['positions'] as $position) {\n                $item['data']['names'][] = $position['name'];\n                $item['data']['default_extras'][$position['name']] = [];\n\n                // add default widgets\n                foreach ($position['widgets'] as $widget) {\n                    // fetch extra_id for this extra\n                    $extraId = (int) BackendModel::getContainer()->get('database')->getVar(\n                        'SELECT i.id\n                         FROM modules_extras AS i\n                         WHERE type = ? AND module = ? AND action = ? AND data IS NULL AND hidden = ?',\n                        ['widget', $widget['module'], $widget['action'], false]\n                    );\n\n                    // add extra to defaults\n                    if ($extraId) {\n                        $item['data']['default_extras'][$position['name']][] = $extraId;\n                    }\n                }\n\n                // add default editors\n                foreach ($position['editors'] as $editor) {\n                    $item['data']['default_extras'][$position['name']][] = 0;\n                }\n            }\n\n            $item['data'] = serialize($item['data']);\n            $item['id'] = self::insertTemplate($item);\n        }\n    }\n\n    public static function isModuleInstalled(string $module): bool\n    {\n        return (bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT 1\n             FROM modules\n             WHERE name = ?\n             LIMIT 1',\n            $module\n        );\n    }\n\n    /**\n     * Is the provided template id in use by active versions of pages?\n     *\n     * @param int $templateId The id of the template to check.\n     *\n     * @return bool\n     */\n    public static function isTemplateInUse(int $templateId): bool\n    {\n        return (bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT 1\n             FROM pages AS i\n             WHERE i.template_id = ? AND i.status = ?\n             LIMIT 1',\n            [$templateId, 'active']\n        );\n    }\n\n    public static function isThemeInstalled(string $theme): bool\n    {\n        return (bool) BackendModeL::getContainer()->get('database')->getVar(\n            'SELECT 1\n             FROM themes_templates\n             WHERE theme = ?\n             LIMIT 1',\n            [$theme]\n        );\n    }\n\n    /**\n     * Check if a directory is writable.\n     * The default is_writable function has problems due to Windows ACLs \"bug\"\n     *\n     * @param string $path The path to check.\n     *\n     * @return bool\n     */\n    public static function isWritable(string $path): bool\n    {\n        $path = rtrim((string) $path, '/');\n        $file = uniqid('', true) . '.tmp';\n        $return = @file_put_contents($path . '/' . $file, 'temporary file', FILE_APPEND);\n        if ($return === false) {\n            return false;\n        }\n        unlink($path . '/' . $file);\n\n        return true;\n    }\n\n    public static function processModuleXml(\\SimpleXMLElement $xml): array\n    {\n        $information = [];\n\n        // fetch theme node\n        $module = $xml->xpath('/module');\n        if (isset($module[0])) {\n            $module = $module[0];\n        }\n\n        // fetch general module info\n        $information['name'] = (string) $module->name;\n        $information['version'] = (string) $module->version;\n        $information['requirements'] = (array) $module->requirements;\n        $information['description'] = (string) $module->description;\n        $information['cronjobs'] = [];\n\n        // authors\n        foreach ($xml->xpath('/module/authors/author') as $author) {\n            $information['authors'][] = (array) $author;\n        }\n\n        // cronjobs\n        foreach ($xml->xpath('/module/cronjobs/cronjob') as $cronjob) {\n            $attributes = $cronjob->attributes();\n            if (!isset($attributes['action'])) {\n                continue;\n            }\n\n            // build cronjob information\n            $item = [];\n            $item['minute'] = (isset($attributes['minute'])) ? $attributes['minute'] : '*';\n            $item['hour'] = (isset($attributes['hour'])) ? $attributes['hour'] : '*';\n            $item['day-of-month'] = (isset($attributes['day-of-month'])) ? $attributes['day-of-month'] : '*';\n            $item['month'] = (isset($attributes['month'])) ? $attributes['month'] : '*';\n            $item['day-of-week'] = (isset($attributes['day-of-week'])) ? $attributes['day-of-week'] : '*';\n            $item['action'] = $attributes['action'];\n            $item['description'] = $cronjob[0];\n\n            // check if cronjob has already been run\n            $cronjobs = (array) BackendModel::get('fork.settings')->get('Core', 'cronjobs');\n            $item['active'] = in_array($information['name'] . '.' . $attributes['action'], $cronjobs);\n\n            $information['cronjobs'][] = $item;\n        }\n\n        // events\n        foreach ($xml->xpath('/module/events/event') as $event) {\n            $attributes = $event->attributes();\n\n            // build event information and add it to the list\n            $information['events'][] = [\n                'application' => (isset($attributes['application'])) ? $attributes['application'] : '',\n                'name' => (isset($attributes['name'])) ? $attributes['name'] : '',\n                'description' => $event[0],\n            ];\n        }\n\n        return $information;\n    }\n\n    public static function processThemeXml(\\SimpleXMLElement $xml): array\n    {\n        $information = [];\n\n        $theme = $xml->xpath('/theme');\n        if (isset($theme[0])) {\n            $theme = $theme[0];\n        }\n\n        // fetch general theme info\n        $information['name'] = (string) $theme->name;\n        $information['version'] = (string) $theme->version;\n        $information['requirements'] = (array) $theme->requirements;\n        $information['thumbnail'] = (string) $theme->thumbnail;\n        $information['description'] = (string) $theme->description;\n\n        // authors\n        foreach ($xml->xpath('/theme/authors/author') as $author) {\n            $information['authors'][] = (array) $author;\n        }\n\n        // meta navigation\n        $meta = $theme->metanavigation->attributes();\n        if (isset($meta['supported'])) {\n            $information['meta'] = (string) $meta['supported'] && (string) $meta['supported'] !== 'false';\n        }\n\n        // templates\n        $information['templates'] = [];\n        foreach ($xml->xpath('/theme/templates/template') as $templateXML) {\n            $template = [];\n\n            // template data\n            $template['label'] = (string) $templateXML['label'];\n            $template['path'] = (string) $templateXML['path'];\n            $template['image'] = isset($templateXML['image'])\n                ? (string) $templateXML['image'] && (string) $templateXML['image'] !== 'false' : false;\n            $template['format'] = trim(str_replace([\"\\n\", \"\\r\", ' '], '', (string) $templateXML->format));\n\n            // loop positions\n            foreach ($templateXML->positions->position as $positionXML) {\n                $position = [];\n\n                $position['name'] = (string) $positionXML['name'];\n\n                // widgets\n                $position['widgets'] = [];\n                if ($positionXML->defaults->widget) {\n                    foreach ($positionXML->defaults->widget as $widget) {\n                        $position['widgets'][] = [\n                            'module' => (string) $widget['module'],\n                            'action' => (string) $widget['action'],\n                        ];\n                    }\n                }\n\n                // editor\n                $position['editors'] = [];\n                if ($positionXML->defaults->editor) {\n                    foreach ($positionXML->defaults->editor as $editor) {\n                        $position['editors'][] = (string) trim($editor);\n                    }\n                }\n\n                $template['positions'][] = $position;\n            }\n\n            $information['templates'][] = $template;\n        }\n\n        return self::validateThemeInformation($information);\n    }\n\n    public static function templateSyntaxToArray(string $syntax): array\n    {\n        $syntax = (string) $syntax;\n        $syntax = trim(str_replace([\"\\n\", \"\\r\", ' '], '', $syntax));\n        $table = [];\n\n        // check template settings format\n        if (!static::isValidTemplateSyntaxFormat($syntax)) {\n            return $table;\n        }\n\n        // split into rows\n        $rows = explode('],[', $syntax);\n\n        foreach ($rows as $i => $row) {\n            $row = trim(str_replace(['[', ']'], '', $row));\n            $table[$i] = (array) explode(',', $row);\n        }\n\n        if (!isset($table[0])) {\n            return [];\n        }\n\n        $columns = count($table[0]);\n\n        foreach ($table as $row) {\n            if (count($row) !== $columns) {\n                return [];\n            }\n        }\n\n        return $table;\n    }\n\n    /**\n     * Validate template syntax format\n     *\n     * @param string $syntax\n     * @return bool\n     */\n    public static function isValidTemplateSyntaxFormat(string $syntax): bool\n    {\n        return \\SpoonFilter::isValidAgainstRegexp(\n            '/^\\[(\\/|[a-z0-9])+(,(\\/|[a-z0-9]+))*\\](,\\[(\\/|[a-z0-9])+(,(\\/|[a-z0-9]+))*\\])*$/i',\n            $syntax\n        );\n    }\n\n    public static function updateTemplate(array $templateData): void\n    {\n        BackendModel::getContainer()->get('database')->update(\n            'themes_templates',\n            $templateData,\n            'id = ?',\n            [(int) $templateData['id']]\n        );\n    }\n\n    /**\n     * Make sure that we have an entirely valid theme information array\n     *\n     * @param array $information Contains the parsed theme info.xml data.\n     *\n     * @return array\n     */\n    public static function validateThemeInformation(array $information): array\n    {\n        // set default thumbnail if not sets\n        if (!$information['thumbnail']) {\n            $information['thumbnail'] = 'thumbnail.png';\n        }\n\n        // check if there are templates\n        if (isset($information['templates']) && $information['templates']) {\n            foreach ($information['templates'] as $i => $template) {\n                if (!isset($template['label']) || !$template['label'] || !isset($template['path']) || !$template['path'] || !isset($template['format']) || !$template['format']) {\n                    unset($information['templates'][$i]);\n                    continue;\n                }\n\n                // if there are no positions we should continue with the next item\n                if (!isset($template['positions']) && $template['positions']) {\n                    continue;\n                }\n\n                // loop positions\n                foreach ($template['positions'] as $j => $position) {\n                    if (!isset($position['name']) || !$position['name']) {\n                        unset($information['templates'][$i]['positions'][$j]);\n                        continue;\n                    }\n\n                    // ensure widgets are well-formed\n                    if (!isset($position['widgets']) || !$position['widgets']) {\n                        $information['templates'][$i]['positions'][$j]['widgets'] = [];\n                    }\n\n                    // ensure editors are well-formed\n                    if (!isset($position['editors']) || !$position['editors']) {\n                        $information['templates'][$i]['positions'][$j]['editors'] = [];\n                    }\n\n                    // loop widgets\n                    foreach ($position['widgets'] as $k => $widget) {\n                        // check if widget is valid\n                        if (!isset($widget['module']) || !$widget['module'] || !isset($widget['action']) || !$widget['action']) {\n                            unset($information['templates'][$i]['positions'][$j]['widgets'][$k]);\n                            continue;\n                        }\n                    }\n                }\n\n                // check if there still are valid positions\n                if (!isset($information['templates'][$i]['positions']) || !$information['templates'][$i]['positions']) {\n                    return [];\n                }\n            }\n\n            // check if there still are valid templates\n            if (!isset($information['templates']) || !$information['templates']) {\n                return [];\n            }\n        }\n\n        return $information;\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Backend\\Modules\\Extensions\\Engine;\n\nuse Backend\\Modules\\Locale\\Engine\\Model as BackendLocaleModel;\nuse Common\\ModulesSettings;\nuse Symfony\\Component\\Filesystem\\Filesystem;\nuse Symfony\\Component\\Finder\\Finder;\nuse Backend\\Core\\Engine\\Authentication as BackendAuthentication;\nuse Backend\\Core\\Engine\\DataGridFunctions as BackendDataGridFunctions;\nuse Backend\\Core\\Engine\\Exception;\nuse Backend\\Core\\Language\\Language as BL;\nuse Backend\\Core\\Engine\\Model as BackendModel;\n\n/**\n * In this file we store all generic functions that we will be using in the extensions module.\n */\nclass Model\n{\n    /**\n     * Overview of templates.\n     *\n     * @var string\n     */\n    const QUERY_BROWSE_TEMPLATES = 'SELECT i.id, i.label AS title\n                                  FROM themes_templates AS i\n                                  WHERE i.theme = ?\n                                  ORDER BY i.label ASC';\n\n    /**\n     * Modules which are part of the core and can not be managed.\n     *\n     * @var array\n     */\n    private static $ignoredModules = [\n        'Authentication',\n        'Dashboard',\n        'Error',\n        'Extensions',\n        'Settings',\n    ];\n\n    /**\n     * Build HTML for a template (visual representation)\n     *\n     * @param string $format The template format.\n     * @param bool $large Will the HTML be used in a large version?\n     *\n     * @return string\n     */\n    public static function buildTemplateHTML(string $format, bool $large = false): string\n    {\n        // cleanup\n        $table = self::templateSyntaxToArray($format);\n\n        // init var\n        $rows = count($table);\n        if ($rows === 0) {\n            throw new Exception('Invalid template-format.');\n        }\n        $cells = count($table[0]);\n\n        $htmlContent = [];\n\n        // loop rows\n        for ($y = 0; $y < $rows; ++$y) {\n            $htmlContent[$y] = [];\n\n            // loop cells\n            for ($x = 0; $x < $cells; ++$x) {\n                // skip if needed\n                if (!isset($table[$y][$x])) {\n                    continue;\n                }\n\n                // get value\n                $value = $table[$y][$x];\n\n                // init var\n                $colspan = 1;\n\n                // reset items in the same column\n                while ($x + $colspan < $cells && $table[$y][$x + $colspan] === $value) {\n                    $table[$y][$x + $colspan++] = null;\n                }\n\n                // init var\n                $rowspan = 1;\n                $rowMatches = true;\n\n                // loop while the rows match\n                while ($rowMatches && $y + $rowspan < $rows) {\n                    // loop columns inside spanned columns\n                    for ($i = 0; $i < $colspan; ++$i) {\n                        // check value\n                        if ($table[$y + $rowspan][$x + $i] !== $value) {\n                            // no match, so stop\n                            $rowMatches = false;\n                            break;\n                        }\n                    }\n\n                    // any rowmatches?\n                    if ($rowMatches) {\n                        // loop columns and reset value\n                        for ($i = 0; $i < $colspan; ++$i) {\n                            $table[$y + $rowspan][$x + $i] = null;\n                        }\n\n                        // increment\n                        ++$rowspan;\n                    }\n                }\n\n                $htmlContent[$y][$x] = [\n                    'title' => \\SpoonFilter::ucfirst($value),\n                    'value' => $value,\n                    'exists' => $value != '/',\n                    'rowspan' => $rowspan,\n                    'colspan' => $colspan,\n                    'large' => $large,\n                ];\n            }\n        }\n\n        $templating = BackendModel::get('template');\n        $templating->assign('table', $htmlContent);\n        $html = $templating->getContent('Extensions/Layout/Templates/Templates.html.twig');\n\n        return $html;\n    }\n\n    /**\n     * Checks the settings and optionally returns an array with warnings\n     *\n     * @return array\n     */\n    public static function checkSettings(): array\n    {\n        $warnings = [];\n        $akismetModules = self::getModulesThatRequireAkismet();\n        $googleMapsModules = self::getModulesThatRequireGoogleMaps();\n\n        // check if this action is allowed\n        if (!BackendAuthentication::isAllowedAction('Index', 'Settings')) {\n            return [];\n        }\n\n        // check if the akismet key is available if there are modules that require it\n        if (!empty($akismetModules) && BackendModel::get('fork.settings')->get('Core', 'akismet_key', null) == '') {\n            // add warning\n            $warnings[] = [\n                'message' => sprintf(\n                    BL::err('AkismetKey'),\n                    BackendModel::createUrlForAction('Index', 'Settings')\n                ),\n            ];\n        }\n\n        // check if the google maps key is available if there are modules that require it\n        if (!empty($googleMapsModules)\n            && BackendModel::get('fork.settings')->get('Core', 'google_maps_key', null) == '') {\n            // add warning\n            $warnings[] = [\n                'message' => sprintf(\n                    BL::err('GoogleMapsKey'),\n                    BackendModel::createUrlForAction('Index', 'Settings')\n                ),\n            ];\n        }\n\n        return $warnings;\n    }\n\n    /**\n     * Clear all applications cache.\n     *\n     * Note: we do not need to rebuild anything, the core will do this when noticing the cache files are missing.\n     */\n    public static function clearCache(): void\n    {\n        $finder = new Finder();\n        $filesystem = new Filesystem();\n        $files = $finder->files()\n            ->name('*.php')\n            ->name('*.js')\n            ->in(BACKEND_CACHE_PATH . '/Locale')\n            ->in(FRONTEND_CACHE_PATH . '/Navigation')\n            ->in(FRONTEND_CACHE_PATH . '/Locale');\n        foreach ($files as $file) {\n            $filesystem->remove($file->getRealPath());\n        }\n        BackendModel::getContainer()->get('cache.backend_navigation')->delete();\n    }\n\n    /**\n     * Delete a template.\n     *\n     * @param int $id The id of the template to delete.\n     *\n     * @return bool\n     */\n    public static function deleteTemplate(int $id): bool\n    {\n        $templates = self::getTemplates();\n\n        // we can't delete a template that doesn't exist\n        if (!isset($templates[$id])) {\n            return false;\n        }\n\n        // we can't delete the last template\n        if (count($templates) === 1) {\n            return false;\n        }\n\n        // we can't delete the default template\n        if ($id == BackendModel::get('fork.settings')->get('Pages', 'default_template')) {\n            return false;\n        }\n        if (self::isTemplateInUse($id)) {\n            return false;\n        }\n\n        $database = BackendModel::getContainer()->get('database');\n        $database->delete('themes_templates', 'id = ?', $id);\n        $ids = (array) $database->getColumn(\n            'SELECT i.revision_id\n             FROM pages AS i\n             WHERE i.template_id = ? AND i.status != ?',\n            [$id, 'active']\n        );\n\n        if (!empty($ids)) {\n            // delete those pages and the linked blocks\n            $database->delete('pages', 'revision_id IN(' . implode(',', $ids) . ')');\n            $database->delete('pages_blocks', 'revision_id IN(' . implode(',', $ids) . ')');\n        }\n\n        return true;\n    }\n\n    /**\n     * Does this module exist.\n     * This does not check for existence in the database but on the filesystem.\n     *\n     * @param string $module Module to check for existence.\n     *\n     * @return bool\n     */\n    public static function existsModule(string $module): bool\n    {\n        return is_dir(BACKEND_MODULES_PATH . '/' . $module);\n    }\n\n    /**\n     * Check if a template exists\n     *\n     * @param int $id The Id of the template to check for existence.\n     *\n     * @return bool\n     */\n    public static function existsTemplate(int $id): bool\n    {\n        return (bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT i.id FROM themes_templates AS i WHERE i.id = ?',\n            [$id]\n        );\n    }\n\n    /**\n     * Does this template exist.\n     * This does not check for existence in the database but on the filesystem.\n     *\n     * @param string $theme Theme to check for existence.\n     *\n     * @return bool\n     */\n    public static function existsTheme(string $theme): bool\n    {\n        return is_dir(FRONTEND_PATH . '/Themes/' . (string) $theme) || $theme === 'Core';\n    }\n\n    public static function getExtras(): array\n    {\n        $extras = (array) BackendModel::getContainer()->get('database')->getRecords(\n            'SELECT i.id, i.module, i.type, i.label, i.data\n             FROM modules_extras AS i\n             INNER JOIN modules AS m ON i.module = m.name\n             WHERE i.hidden = ?\n             ORDER BY i.module, i.sequence',\n            [false],\n            'id'\n        );\n        $itemsToRemove = [];\n\n        foreach ($extras as $id => &$row) {\n            $row['data'] = $row['data'] === null ? [] : @unserialize($row['data'], ['allowed_classes' => false]);\n            if (isset($row['data']['language']) && $row['data']['language'] != BL::getWorkingLanguage()) {\n                $itemsToRemove[] = $id;\n            }\n\n            // set URL if needed, we use '' instead of null, because otherwise the module of the current action (modules) is used.\n            if (!isset($row['data']['url'])) {\n                $row['data']['url'] = BackendModel::createUrlForAction('', $row['module']);\n            }\n\n            $name = \\SpoonFilter::ucfirst(BL::lbl($row['label']));\n            if (isset($row['data']['extra_label'])) {\n                $name = $row['data']['extra_label'];\n            }\n            if (isset($row['data']['label_variables'])) {\n                $name = vsprintf($name, $row['data']['label_variables']);\n            }\n\n            // add human readable name\n            $module = \\SpoonFilter::ucfirst(BL::lbl(\\SpoonFilter::toCamelCase($row['module'])));\n            $extraTypeLabel = \\SpoonFilter::ucfirst(BL::lbl(\\SpoonFilter::toCamelCase('ExtraType_' . $row['type'])));\n            $row['human_name'] = $extraTypeLabel . ': ' . $name;\n            $row['path'] = $extraTypeLabel . ' \u203a ' . $module . ($module !== $name ? ' \u203a ' . $name : '');\n        }\n\n        // any items to remove?\n        if (!empty($itemsToRemove)) {\n            foreach ($itemsToRemove as $id) {\n                unset($extras[$id]);\n            }\n        }\n\n        return $extras;\n    }\n\n    public static function getExtrasData(): array\n    {\n        $extras = (array) BackendModel::getContainer()->get('database')->getRecords(\n            'SELECT i.id, i.module, i.type, i.label, i.data\n             FROM modules_extras AS i\n             INNER JOIN modules AS m ON i.module = m.name\n             WHERE i.hidden = ?\n             ORDER BY i.module, i.sequence',\n            [false]\n        );\n        $values = [];\n\n        foreach ($extras as $row) {\n            $row['data'] = @unserialize($row['data'], ['allowed_classes' => false]);\n\n            // remove items that are not for the current language\n            if (isset($row['data']['language']) && $row['data']['language'] != BL::getWorkingLanguage()) {\n                continue;\n            }\n\n            // set URL if needed\n            if (!isset($row['data']['url'])) {\n                $row['data']['url'] = BackendModel::createUrlForAction(\n                    'Index',\n                    $row['module']\n                );\n            }\n\n            $name = \\SpoonFilter::ucfirst(BL::lbl($row['label']));\n            if (isset($row['data']['extra_label'])) {\n                $name = $row['data']['extra_label'];\n            }\n            if (isset($row['data']['label_variables'])) {\n                $name = vsprintf($name, $row['data']['label_variables']);\n            }\n            $moduleName = \\SpoonFilter::ucfirst(BL::lbl(\\SpoonFilter::toCamelCase($row['module'])));\n\n            if (!isset($values[$row['module']])) {\n                $values[$row['module']] = [\n                    'value' => $row['module'],\n                    'name' => $moduleName,\n                    'items' => [],\n                ];\n            }\n\n            $values[$row['module']]['items'][$row['type']][$name] = ['id' => $row['id'], 'label' => $name];\n        }\n\n        return $values;\n    }\n\n    /**\n     * Fetch the module information from the info.xml file.\n     *\n     * @param string $module\n     *\n     * @return array\n     */\n    public static function getModuleInformation(string $module): array\n    {\n        $pathInfoXml = BACKEND_MODULES_PATH . '/' . $module . '/info.xml';\n        $information = ['data' => [], 'warnings' => []];\n\n        if (is_file($pathInfoXml)) {\n            try {\n                $infoXml = @new \\SimpleXMLElement($pathInfoXml, LIBXML_NOCDATA, true);\n                $information['data'] = self::processModuleXml($infoXml);\n                if (empty($information['data'])) {\n                    $information['warnings'][] = [\n                        'message' => BL::getMessage('InformationFileIsEmpty'),\n                    ];\n                }\n            } catch (Exception $e) {\n                $information['warnings'][] = [\n                    'message' => BL::getMessage('InformationFileCouldNotBeLoaded'),\n                ];\n            }\n        } else {\n            $information['warnings'][] = [\n                'message' => BL::getMessage('InformationFileIsMissing'),\n            ];\n        }\n\n        return $information;\n    }\n\n    /**\n     * Get modules based on the directory listing in the backend application.\n     *\n     * If a module contains a info.xml it will be parsed.\n     *\n     * @return array\n     */\n    public static function getModules(): array\n    {\n        $installedModules = (array) BackendModel::getContainer()\n            ->getParameter('installed_modules');\n        $modules = BackendModel::getModulesOnFilesystem(false);\n        $manageableModules = [];\n\n        // get more information for each module\n        foreach ($modules as $moduleName) {\n            if (in_array($moduleName, self::$ignoredModules)) {\n                continue;\n            }\n\n            $module = [];\n            $module['id'] = 'module_' . $moduleName;\n            $module['raw_name'] = $moduleName;\n            $module['name'] = \\SpoonFilter::ucfirst(BL::getLabel(\\SpoonFilter::toCamelCase($moduleName)));\n            $module['description'] = '';\n            $module['version'] = '';\n            $module['installed'] = false;\n\n            if (in_array($moduleName, $installedModules)) {\n                $module['installed'] = true;\n            }\n\n            try {\n                $infoXml = @new \\SimpleXMLElement(\n                    BACKEND_MODULES_PATH . '/' . $module['raw_name'] . '/info.xml',\n                    LIBXML_NOCDATA,\n                    true\n                );\n\n                $info = self::processModuleXml($infoXml);\n\n                // set fields if they were found in the XML\n                if (isset($info['description'])) {\n                    $module['description'] = BackendDataGridFunctions::truncate($info['description'], 80);\n                }\n                if (isset($info['version'])) {\n                    $module['version'] = $info['version'];\n                }\n            } catch (\\Exception $e) {\n                // don't act upon error, we simply won't possess some info\n            }\n\n            $manageableModules[] = $module;\n        }\n\n        return $manageableModules;\n    }\n\n    /**\n     * Fetch the list of modules that require Akismet API key\n     *\n     * @return array\n     */\n    public static function getModulesThatRequireAkismet(): array\n    {\n        return self::getModulesThatRequireSetting('akismet');\n    }\n\n    /**\n     * Fetch the list of modules that require Google Maps API key\n     *\n     * @return array\n     */\n    public static function getModulesThatRequireGoogleMaps(): array\n    {\n        return self::getModulesThatRequireSetting('google_maps');\n    }\n\n    /**\n     * Fetch the list of modules that require Google Recaptcha API key\n     *\n     * @return array\n     */\n    public static function getModulesThatRequireGoogleRecaptcha(): array\n    {\n        return self::getModulesThatRequireSetting('google_recaptcha');\n    }\n\n    /**\n     * Fetch the list of modules that require a certain setting. The setting is affixed by 'requires_'\n     *\n     * @param string $setting\n     *\n     * @return array\n     */\n    private static function getModulesThatRequireSetting(string $setting): array\n    {\n        if ($setting === '') {\n            return [];\n        }\n\n        /** @var ModulesSettings $moduleSettings */\n        $moduleSettings = BackendModel::get('fork.settings');\n\n        return array_filter(\n            BackendModel::getModules(),\n            function (string $module) use ($moduleSettings, $setting): bool {\n                return $moduleSettings->get($module, 'requires_' . $setting, false);\n            }\n        );\n    }\n\n    public static function getTemplate(int $id): array\n    {\n        return (array) BackendModel::getContainer()->get('database')->getRecord(\n            'SELECT i.* FROM themes_templates AS i WHERE i.id = ?',\n            [$id]\n        );\n    }\n\n    public static function getTemplates(string $theme = null): array\n    {\n        $database = BackendModel::getContainer()->get('database');\n        $theme = \\SpoonFilter::getValue(\n            (string) $theme,\n            null,\n            BackendModel::get('fork.settings')->get('Core', 'theme', 'Fork')\n        );\n\n        $templates = (array) $database->getRecords(\n            'SELECT i.id, i.label, i.path, i.data\n            FROM themes_templates AS i\n            WHERE i.theme = ? AND i.active = ?\n            ORDER BY i.label ASC',\n            [$theme, true],\n            'id'\n        );\n\n        $extras = (array) self::getExtras();\n        $half = (int) ceil(count($templates) / 2);\n        $i = 0;\n\n        foreach ($templates as &$row) {\n            $row['data'] = unserialize($row['data'], ['allowed_classes' => false]);\n            $row['has_block'] = false;\n\n            // reset\n            if (isset($row['data']['default_extras_' . BL::getWorkingLanguage()])) {\n                $row['data']['default_extras'] = $row['data']['default_extras_' . BL::getWorkingLanguage()];\n            }\n\n            // any extras?\n            if (isset($row['data']['default_extras'])) {\n                foreach ($row['data']['default_extras'] as $value) {\n                    if (\\SpoonFilter::isInteger($value)\n                        && isset($extras[$value]) && $extras[$value]['type'] == 'block'\n                    ) {\n                        $row['has_block'] = true;\n                    }\n                }\n            }\n\n            // validate\n            if (!isset($row['data']['format'])) {\n                throw new Exception('Invalid template-format.');\n            }\n\n            $row['html'] = self::buildTemplateHTML($row['data']['format']);\n            $row['htmlLarge'] = self::buildTemplateHTML($row['data']['format'], true);\n            $row['json'] = json_encode($row);\n            if ($i == $half) {\n                $row['break'] = true;\n            }\n            ++$i;\n        }\n\n        return (array) $templates;\n    }\n\n    public static function getThemes(): array\n    {\n        $records = [];\n        $finder = new Finder();\n        foreach ($finder->directories()->in(FRONTEND_PATH . '/Themes')->depth(0) as $directory) {\n            $pathInfoXml = BackendModel::getContainer()->getParameter('site.path_www') . '/src/Frontend/Themes/'\n                           . $directory->getBasename() . '/info.xml';\n            if (!is_file($pathInfoXml)) {\n                throw new Exception('info.xml is missing for the theme ' . $directory->getBasename());\n            }\n            try {\n                $infoXml = @new \\SimpleXMLElement($pathInfoXml, LIBXML_NOCDATA, true);\n                $information = self::processThemeXml($infoXml);\n                if (empty($information)) {\n                    throw new Exception('Invalid info.xml');\n                }\n            } catch (Exception $e) {\n                $information['thumbnail'] = 'thumbnail.png';\n            }\n\n            $item = [];\n            $item['value'] = $directory->getBasename();\n            $item['label'] = $directory->getBasename();\n            $item['thumbnail'] = '/src/Frontend/Themes/' . $item['value'] . '/' . $information['thumbnail'];\n            $item['installed'] = self::isThemeInstalled($item['value']);\n            $item['installable'] = isset($information['templates']);\n\n            $records[$item['value']] = $item;\n        }\n\n        return (array) $records;\n    }\n\n    public static function createTemplateXmlForExport(string $theme): string\n    {\n        $charset = BackendModel::getContainer()->getParameter('kernel.charset');\n\n        // build xml\n        $xml = new \\DOMDocument('1.0', $charset);\n        $xml->preserveWhiteSpace = false;\n        $xml->formatOutput = true;\n\n        $root = $xml->createElement('templates');\n        $xml->appendChild($root);\n\n        $database = BackendModel::getContainer()->get('database');\n\n        $records = $database->getRecords(self::QUERY_BROWSE_TEMPLATES, [$theme]);\n\n        foreach ($records as $row) {\n            $template = self::getTemplate($row['id']);\n            $data = unserialize($template['data'], ['allowed_classes' => false]);\n\n            $templateElement = $xml->createElement('template');\n            $templateElement->setAttribute('label', $template['label']);\n            $templateElement->setAttribute('path', $template['path']);\n            $root->appendChild($templateElement);\n\n            $positionsElement = $xml->createElement('positions');\n            $templateElement->appendChild($positionsElement);\n\n            foreach ($data['names'] as $name) {\n                $positionElement = $xml->createElement('position');\n                $positionElement->setAttribute('name', $name);\n                $positionsElement->appendChild($positionElement);\n            }\n\n            $formatElement = $xml->createElement('format');\n            $templateElement->appendChild($formatElement);\n            $formatElement->nodeValue = $data['format'];\n        }\n\n        return $xml->saveXML();\n    }\n\n    public static function hasModuleWarnings(string $module): string\n    {\n        $moduleInformation = self::getModuleInformation($module);\n\n        return !empty($moduleInformation['warnings']);\n    }\n\n    public static function insertTemplate(array $template): int\n    {\n        return (int) BackendModel::getContainer()->get('database')->insert('themes_templates', $template);\n    }\n\n    public static function installModule(string $module): void\n    {\n        $class = 'Backend\\\\Modules\\\\' . $module . '\\\\Installer\\\\Installer';\n        $variables = [];\n\n        // run installer\n        $installer = new $class(\n            BackendModel::getContainer()->get('database'),\n            BL::getActiveLanguages(),\n            array_keys(BL::getInterfaceLanguages()),\n            false,\n            $variables\n        );\n\n        $installer->install();\n\n        // clear the cache so locale (and so much more) gets rebuilt\n        self::clearCache();\n    }\n\n    public static function installTheme(string $theme): void\n    {\n        $basePath = FRONTEND_PATH . '/Themes/' . $theme;\n        $pathInfoXml = $basePath . '/info.xml';\n        $pathTranslations = $basePath . '/locale.xml';\n        $infoXml = @new \\SimpleXMLElement($pathInfoXml, LIBXML_NOCDATA, true);\n\n        $information = self::processThemeXml($infoXml);\n        if (empty($information)) {\n            throw new Exception('Invalid info.xml');\n        }\n\n        if (is_file($pathTranslations)) {\n            $translations = @simplexml_load_file($pathTranslations);\n            if ($translations !== false) {\n                BackendLocaleModel::importXML($translations);\n            }\n        }\n\n        foreach ($information['templates'] as $template) {\n            $item = [];\n            $item['theme'] = $information['name'];\n            $item['label'] = $template['label'];\n            $item['path'] = $template['path'];\n            $item['active'] = true;\n            $item['data']['format'] = $template['format'];\n            $item['data']['image'] = $template['image'];\n\n            // build positions\n            $item['data']['names'] = [];\n            $item['data']['default_extras'] = [];\n            foreach ($template['positions'] as $position) {\n                $item['data']['names'][] = $position['name'];\n                $item['data']['default_extras'][$position['name']] = [];\n\n                // add default widgets\n                foreach ($position['widgets'] as $widget) {\n                    // fetch extra_id for this extra\n                    $extraId = (int) BackendModel::getContainer()->get('database')->getVar(\n                        'SELECT i.id\n                         FROM modules_extras AS i\n                         WHERE type = ? AND module = ? AND action = ? AND data IS NULL AND hidden = ?',\n                        ['widget', $widget['module'], $widget['action'], false]\n                    );\n\n                    // add extra to defaults\n                    if ($extraId) {\n                        $item['data']['default_extras'][$position['name']][] = $extraId;\n                    }\n                }\n\n                // add default editors\n                foreach ($position['editors'] as $editor) {\n                    $item['data']['default_extras'][$position['name']][] = 0;\n                }\n            }\n\n            $item['data'] = serialize($item['data']);\n            $item['id'] = self::insertTemplate($item);\n        }\n    }\n\n    public static function isModuleInstalled(string $module): bool\n    {\n        return (bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT 1\n             FROM modules\n             WHERE name = ?\n             LIMIT 1',\n            $module\n        );\n    }\n\n    /**\n     * Is the provided template id in use by active versions of pages?\n     *\n     * @param int $templateId The id of the template to check.\n     *\n     * @return bool\n     */\n    public static function isTemplateInUse(int $templateId): bool\n    {\n        return (bool) BackendModel::getContainer()->get('database')->getVar(\n            'SELECT 1\n             FROM pages AS i\n             WHERE i.template_id = ? AND i.status = ?\n             LIMIT 1',\n            [$templateId, 'active']\n        );\n    }\n\n    public static function isThemeInstalled(string $theme): bool\n    {\n        return (bool) BackendModeL::getContainer()->get('database')->getVar(\n            'SELECT 1\n             FROM themes_templates\n             WHERE theme = ?\n             LIMIT 1',\n            [$theme]\n        );\n    }\n\n    /**\n     * Check if a directory is writable.\n     * The default is_writable function has problems due to Windows ACLs \"bug\"\n     *\n     * @param string $path The path to check.\n     *\n     * @return bool\n     */\n    public static function isWritable(string $path): bool\n    {\n        $path = rtrim((string) $path, '/');\n        $file = uniqid('', true) . '.tmp';\n        $return = @file_put_contents($path . '/' . $file, 'temporary file', FILE_APPEND);\n        if ($return === false) {\n            return false;\n        }\n        unlink($path . '/' . $file);\n\n        return true;\n    }\n\n    public static function processModuleXml(\\SimpleXMLElement $xml): array\n    {\n        $information = [];\n\n        // fetch theme node\n        $module = $xml->xpath('/module');\n        if (isset($module[0])) {\n            $module = $module[0];\n        }\n\n        // fetch general module info\n        $information['name'] = (string) $module->name;\n        $information['version'] = (string) $module->version;\n        $information['requirements'] = (array) $module->requirements;\n        $information['description'] = strip_tags((string) $module->description, '<h1><h2><h3><h4><h5><h6><p><li><a>');\n        $information['cronjobs'] = [];\n\n        // authors\n        foreach ($xml->xpath('/module/authors/author') as $author) {\n            $information['authors'][] = (array) $author;\n        }\n\n        // cronjobs\n        foreach ($xml->xpath('/module/cronjobs/cronjob') as $cronjob) {\n            $attributes = $cronjob->attributes();\n            if (!isset($attributes['action'])) {\n                continue;\n            }\n\n            // build cronjob information\n            $item = [];\n            $item['minute'] = (isset($attributes['minute'])) ? $attributes['minute'] : '*';\n            $item['hour'] = (isset($attributes['hour'])) ? $attributes['hour'] : '*';\n            $item['day-of-month'] = (isset($attributes['day-of-month'])) ? $attributes['day-of-month'] : '*';\n            $item['month'] = (isset($attributes['month'])) ? $attributes['month'] : '*';\n            $item['day-of-week'] = (isset($attributes['day-of-week'])) ? $attributes['day-of-week'] : '*';\n            $item['action'] = $attributes['action'];\n            $item['description'] = $cronjob[0];\n\n            // check if cronjob has already been run\n            $cronjobs = (array) BackendModel::get('fork.settings')->get('Core', 'cronjobs');\n            $item['active'] = in_array($information['name'] . '.' . $attributes['action'], $cronjobs);\n\n            $information['cronjobs'][] = $item;\n        }\n\n        // events\n        foreach ($xml->xpath('/module/events/event') as $event) {\n            $attributes = $event->attributes();\n\n            // build event information and add it to the list\n            $information['events'][] = [\n                'application' => (isset($attributes['application'])) ? $attributes['application'] : '',\n                'name' => (isset($attributes['name'])) ? $attributes['name'] : '',\n                'description' => $event[0],\n            ];\n        }\n\n        return $information;\n    }\n\n    public static function processThemeXml(\\SimpleXMLElement $xml): array\n    {\n        $information = [];\n\n        $theme = $xml->xpath('/theme');\n        if (isset($theme[0])) {\n            $theme = $theme[0];\n        }\n\n        // fetch general theme info\n        $information['name'] = (string) $theme->name;\n        $information['version'] = (string) $theme->version;\n        $information['requirements'] = (array) $theme->requirements;\n        $information['thumbnail'] = (string) $theme->thumbnail;\n        $information['description'] = strip_tags((string) $theme->description, '<h1><h2><h3><h4><h5><h6><p><li><a>');\n\n        // authors\n        foreach ($xml->xpath('/theme/authors/author') as $author) {\n            $information['authors'][] = (array) $author;\n        }\n\n        // meta navigation\n        $meta = $theme->metanavigation->attributes();\n        if (isset($meta['supported'])) {\n            $information['meta'] = (string) $meta['supported'] && (string) $meta['supported'] !== 'false';\n        }\n\n        // templates\n        $information['templates'] = [];\n        foreach ($xml->xpath('/theme/templates/template') as $templateXML) {\n            $template = [];\n\n            // template data\n            $template['label'] = (string) $templateXML['label'];\n            $template['path'] = (string) $templateXML['path'];\n            $template['image'] = isset($templateXML['image'])\n                ? (string) $templateXML['image'] && (string) $templateXML['image'] !== 'false' : false;\n            $template['format'] = trim(str_replace([\"\\n\", \"\\r\", ' '], '', (string) $templateXML->format));\n\n            // loop positions\n            foreach ($templateXML->positions->position as $positionXML) {\n                $position = [];\n\n                $position['name'] = (string) $positionXML['name'];\n\n                // widgets\n                $position['widgets'] = [];\n                if ($positionXML->defaults->widget) {\n                    foreach ($positionXML->defaults->widget as $widget) {\n                        $position['widgets'][] = [\n                            'module' => (string) $widget['module'],\n                            'action' => (string) $widget['action'],\n                        ];\n                    }\n                }\n\n                // editor\n                $position['editors'] = [];\n                if ($positionXML->defaults->editor) {\n                    foreach ($positionXML->defaults->editor as $editor) {\n                        $position['editors'][] = (string) trim($editor);\n                    }\n                }\n\n                $template['positions'][] = $position;\n            }\n\n            $information['templates'][] = $template;\n        }\n\n        return self::validateThemeInformation($information);\n    }\n\n    public static function templateSyntaxToArray(string $syntax): array\n    {\n        $syntax = (string) $syntax;\n        $syntax = trim(str_replace([\"\\n\", \"\\r\", ' '], '', $syntax));\n        $table = [];\n\n        // check template settings format\n        if (!static::isValidTemplateSyntaxFormat($syntax)) {\n            return $table;\n        }\n\n        // split into rows\n        $rows = explode('],[', $syntax);\n\n        foreach ($rows as $i => $row) {\n            $row = trim(str_replace(['[', ']'], '', $row));\n            $table[$i] = (array) explode(',', $row);\n        }\n\n        if (!isset($table[0])) {\n            return [];\n        }\n\n        $columns = count($table[0]);\n\n        foreach ($table as $row) {\n            if (count($row) !== $columns) {\n                return [];\n            }\n        }\n\n        return $table;\n    }\n\n    /**\n     * Validate template syntax format\n     *\n     * @param string $syntax\n     * @return bool\n     */\n    public static function isValidTemplateSyntaxFormat(string $syntax): bool\n    {\n        return \\SpoonFilter::isValidAgainstRegexp(\n            '/^\\[(\\/|[a-z0-9])+(,(\\/|[a-z0-9]+))*\\](,\\[(\\/|[a-z0-9])+(,(\\/|[a-z0-9]+))*\\])*$/i',\n            $syntax\n        );\n    }\n\n    public static function updateTemplate(array $templateData): void\n    {\n        BackendModel::getContainer()->get('database')->update(\n            'themes_templates',\n            $templateData,\n            'id = ?',\n            [(int) $templateData['id']]\n        );\n    }\n\n    /**\n     * Make sure that we have an entirely valid theme information array\n     *\n     * @param array $information Contains the parsed theme info.xml data.\n     *\n     * @return array\n     */\n    public static function validateThemeInformation(array $information): array\n    {\n        // set default thumbnail if not sets\n        if (!$information['thumbnail']) {\n            $information['thumbnail'] = 'thumbnail.png';\n        }\n\n        // check if there are templates\n        if (isset($information['templates']) && $information['templates']) {\n            foreach ($information['templates'] as $i => $template) {\n                if (!isset($template['label']) || !$template['label'] || !isset($template['path']) || !$template['path'] || !isset($template['format']) || !$template['format']) {\n                    unset($information['templates'][$i]);\n                    continue;\n                }\n\n                // if there are no positions we should continue with the next item\n                if (!isset($template['positions']) && $template['positions']) {\n                    continue;\n                }\n\n                // loop positions\n                foreach ($template['positions'] as $j => $position) {\n                    if (!isset($position['name']) || !$position['name']) {\n                        unset($information['templates'][$i]['positions'][$j]);\n                        continue;\n                    }\n\n                    // ensure widgets are well-formed\n                    if (!isset($position['widgets']) || !$position['widgets']) {\n                        $information['templates'][$i]['positions'][$j]['widgets'] = [];\n                    }\n\n                    // ensure editors are well-formed\n                    if (!isset($position['editors']) || !$position['editors']) {\n                        $information['templates'][$i]['positions'][$j]['editors'] = [];\n                    }\n\n                    // loop widgets\n                    foreach ($position['widgets'] as $k => $widget) {\n                        // check if widget is valid\n                        if (!isset($widget['module']) || !$widget['module'] || !isset($widget['action']) || !$widget['action']) {\n                            unset($information['templates'][$i]['positions'][$j]['widgets'][$k]);\n                            continue;\n                        }\n                    }\n                }\n\n                // check if there still are valid positions\n                if (!isset($information['templates'][$i]['positions']) || !$information['templates'][$i]['positions']) {\n                    return [];\n                }\n            }\n\n            // check if there still are valid templates\n            if (!isset($information['templates']) || !$information['templates']) {\n                return [];\n            }\n        }\n\n        return $information;\n    }\n}\n"], "filenames": ["src/Backend/Modules/Extensions/Engine/Model.php"], "buggy_code_start_loc": [842], "buggy_code_end_loc": [904], "fixing_code_start_loc": [842], "fixing_code_end_loc": [904], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository forkcms/forkcms prior to 5.11.1.", "other": {"cve": {"id": "CVE-2022-0145", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-24T11:15:08.117", "lastModified": "2022-03-29T15:35:00.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository forkcms/forkcms prior to 5.11.1."}, {"lang": "es", "value": "Una vulnerabilidad de tipo Cross-site Scripting (XSS) - Almacenado en el repositorio de GitHub forkcms/forkcms versiones anteriores a 5.11.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fork-cms:fork_cms:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.11.1", "matchCriteriaId": "38A5F85C-5508-4425-B245-215759FF27B1"}]}]}], "references": [{"url": "https://github.com/forkcms/forkcms/commit/981730f1a3d59b423ca903b1f4bf79b848a1766e", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/b5b8c680-3cd9-4477-bcd9-3a29657ba7ba", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/forkcms/forkcms/commit/981730f1a3d59b423ca903b1f4bf79b848a1766e"}}