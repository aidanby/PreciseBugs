{"buggy_code": ["/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at:\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage io.netty.handler.codec.http2;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpStatusClass;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http2.Http2Connection.Endpoint;\nimport io.netty.util.internal.SystemPropertyUtil;\nimport io.netty.util.internal.UnstableApi;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.util.List;\n\nimport static io.netty.handler.codec.http.HttpStatusClass.INFORMATIONAL;\nimport static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;\nimport static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;\nimport static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;\nimport static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;\nimport static io.netty.handler.codec.http2.Http2Exception.connectionError;\nimport static io.netty.handler.codec.http2.Http2Exception.streamError;\nimport static io.netty.handler.codec.http2.Http2PromisedRequestVerifier.ALWAYS_VERIFY;\nimport static io.netty.handler.codec.http2.Http2Stream.State.CLOSED;\nimport static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_REMOTE;\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\nimport static java.lang.Integer.MAX_VALUE;\nimport static java.lang.Math.min;\n\n/**\n * Provides the default implementation for processing inbound frame events and delegates to a\n * {@link Http2FrameListener}\n * <p>\n * This class will read HTTP/2 frames and delegate the events to a {@link Http2FrameListener}\n * <p>\n * This interface enforces inbound flow control functionality through\n * {@link Http2LocalFlowController}\n */\n@UnstableApi\npublic class DefaultHttp2ConnectionDecoder implements Http2ConnectionDecoder {\n    private static final boolean VALIDATE_CONTENT_LENGTH =\n            SystemPropertyUtil.getBoolean(\"io.netty.http2.validateContentLength\", true);\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultHttp2ConnectionDecoder.class);\n    private Http2FrameListener internalFrameListener = new PrefaceFrameListener();\n    private final Http2Connection connection;\n    private Http2LifecycleManager lifecycleManager;\n    private final Http2ConnectionEncoder encoder;\n    private final Http2FrameReader frameReader;\n    private Http2FrameListener listener;\n    private final Http2PromisedRequestVerifier requestVerifier;\n    private final Http2SettingsReceivedConsumer settingsReceivedConsumer;\n    private final boolean autoAckPing;\n    private final Http2Connection.PropertyKey contentLengthKey;\n\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader) {\n        this(connection, encoder, frameReader, ALWAYS_VERIFY);\n    }\n\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader,\n                                         Http2PromisedRequestVerifier requestVerifier) {\n        this(connection, encoder, frameReader, requestVerifier, true);\n    }\n\n    /**\n     * Create a new instance.\n     * @param connection The {@link Http2Connection} associated with this decoder.\n     * @param encoder The {@link Http2ConnectionEncoder} associated with this decoder.\n     * @param frameReader Responsible for reading/parsing the raw frames. As opposed to this object which applies\n     *                    h2 semantics on top of the frames.\n     * @param requestVerifier Determines if push promised streams are valid.\n     * @param autoAckSettings {@code false} to disable automatically applying and sending settings acknowledge frame.\n     *  The {@code Http2ConnectionEncoder} is expected to be an instance of {@link Http2SettingsReceivedConsumer} and\n     *  will apply the earliest received but not yet ACKed SETTINGS when writing the SETTINGS ACKs.\n     * {@code true} to enable automatically applying and sending settings acknowledge frame.\n     */\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader,\n                                         Http2PromisedRequestVerifier requestVerifier,\n                                         boolean autoAckSettings) {\n        this(connection, encoder, frameReader, requestVerifier, autoAckSettings, true);\n    }\n\n    /**\n     * Create a new instance.\n     * @param connection The {@link Http2Connection} associated with this decoder.\n     * @param encoder The {@link Http2ConnectionEncoder} associated with this decoder.\n     * @param frameReader Responsible for reading/parsing the raw frames. As opposed to this object which applies\n     *                    h2 semantics on top of the frames.\n     * @param requestVerifier Determines if push promised streams are valid.\n     * @param autoAckSettings {@code false} to disable automatically applying and sending settings acknowledge frame.\n     *                        The {@code Http2ConnectionEncoder} is expected to be an instance of\n     *                        {@link Http2SettingsReceivedConsumer} and will apply the earliest received but not yet\n     *                        ACKed SETTINGS when writing the SETTINGS ACKs. {@code true} to enable automatically\n     *                        applying and sending settings acknowledge frame.\n     * @param autoAckPing {@code false} to disable automatically sending ping acknowledge frame. {@code true} to enable\n     *                    automatically sending ping ack frame.\n     */\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader,\n                                         Http2PromisedRequestVerifier requestVerifier,\n                                         boolean autoAckSettings,\n                                         boolean autoAckPing) {\n        this.autoAckPing = autoAckPing;\n        if (autoAckSettings) {\n            settingsReceivedConsumer = null;\n        } else {\n            if (!(encoder instanceof Http2SettingsReceivedConsumer)) {\n                throw new IllegalArgumentException(\"disabling autoAckSettings requires the encoder to be a \" +\n                        Http2SettingsReceivedConsumer.class);\n            }\n            settingsReceivedConsumer = (Http2SettingsReceivedConsumer) encoder;\n        }\n        this.connection = checkNotNull(connection, \"connection\");\n        contentLengthKey = this.connection.newKey();\n        this.frameReader = checkNotNull(frameReader, \"frameReader\");\n        this.encoder = checkNotNull(encoder, \"encoder\");\n        this.requestVerifier = checkNotNull(requestVerifier, \"requestVerifier\");\n        if (connection.local().flowController() == null) {\n            connection.local().flowController(new DefaultHttp2LocalFlowController(connection));\n        }\n        connection.local().flowController().frameWriter(encoder.frameWriter());\n    }\n\n    @Override\n    public void lifecycleManager(Http2LifecycleManager lifecycleManager) {\n        this.lifecycleManager = checkNotNull(lifecycleManager, \"lifecycleManager\");\n    }\n\n    @Override\n    public Http2Connection connection() {\n        return connection;\n    }\n\n    @Override\n    public final Http2LocalFlowController flowController() {\n        return connection.local().flowController();\n    }\n\n    @Override\n    public void frameListener(Http2FrameListener listener) {\n        this.listener = checkNotNull(listener, \"listener\");\n    }\n\n    @Override\n    public Http2FrameListener frameListener() {\n        return listener;\n    }\n\n    // Visible for testing\n    Http2FrameListener internalFrameListener() {\n        return internalFrameListener;\n    }\n\n    @Override\n    public boolean prefaceReceived() {\n        return FrameReadListener.class == internalFrameListener.getClass();\n    }\n\n    @Override\n    public void decodeFrame(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Http2Exception {\n        frameReader.readFrame(ctx, in, internalFrameListener);\n    }\n\n    @Override\n    public Http2Settings localSettings() {\n        Http2Settings settings = new Http2Settings();\n        Http2FrameReader.Configuration config = frameReader.configuration();\n        Http2HeadersDecoder.Configuration headersConfig = config.headersConfiguration();\n        Http2FrameSizePolicy frameSizePolicy = config.frameSizePolicy();\n        settings.initialWindowSize(flowController().initialWindowSize());\n        settings.maxConcurrentStreams(connection.remote().maxActiveStreams());\n        settings.headerTableSize(headersConfig.maxHeaderTableSize());\n        settings.maxFrameSize(frameSizePolicy.maxFrameSize());\n        settings.maxHeaderListSize(headersConfig.maxHeaderListSize());\n        if (!connection.isServer()) {\n            // Only set the pushEnabled flag if this is a client endpoint.\n            settings.pushEnabled(connection.local().allowPushTo());\n        }\n        return settings;\n    }\n\n    @Override\n    public void close() {\n        frameReader.close();\n    }\n\n    /**\n     * Calculate the threshold in bytes which should trigger a {@code GO_AWAY} if a set of headers exceeds this amount.\n     * @param maxHeaderListSize\n     *      <a href=\"https://tools.ietf.org/html/rfc7540#section-6.5.2\">SETTINGS_MAX_HEADER_LIST_SIZE</a> for the local\n     *      endpoint.\n     * @return the threshold in bytes which should trigger a {@code GO_AWAY} if a set of headers exceeds this amount.\n     */\n    protected long calculateMaxHeaderListSizeGoAway(long maxHeaderListSize) {\n        return Http2CodecUtil.calculateMaxHeaderListSizeGoAway(maxHeaderListSize);\n    }\n\n    private int unconsumedBytes(Http2Stream stream) {\n        return flowController().unconsumedBytes(stream);\n    }\n\n    void onGoAwayRead0(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)\n            throws Http2Exception {\n        listener.onGoAwayRead(ctx, lastStreamId, errorCode, debugData);\n        connection.goAwayReceived(lastStreamId, errorCode, debugData);\n    }\n\n    void onUnknownFrame0(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,\n            ByteBuf payload) throws Http2Exception {\n        listener.onUnknownFrame(ctx, frameType, streamId, flags, payload);\n    }\n\n    // See https://tools.ietf.org/html/rfc7540#section-8.1.2.6\n    private void verifyContentLength(Http2Stream stream, int data, boolean isEnd) throws Http2Exception {\n        if (!VALIDATE_CONTENT_LENGTH) {\n            return;\n        }\n        ContentLength contentLength = stream.getProperty(contentLengthKey);\n        if (contentLength != null) {\n            try {\n                contentLength.increaseReceivedBytes(connection.isServer(), stream.id(), data, isEnd);\n            } finally {\n                if (isEnd) {\n                    stream.removeProperty(contentLengthKey);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handles all inbound frames from the network.\n     */\n    private final class FrameReadListener implements Http2FrameListener {\n        @Override\n        public int onDataRead(final ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,\n                              boolean endOfStream) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            Http2LocalFlowController flowController = flowController();\n            int readable = data.readableBytes();\n            int bytesToReturn = readable + padding;\n\n            final boolean shouldIgnore;\n            try {\n                shouldIgnore = shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"DATA\");\n            } catch (Http2Exception e) {\n                // Ignoring this frame. We still need to count the frame towards the connection flow control\n                // window, but we immediately mark all bytes as consumed.\n                flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);\n                flowController.consumeBytes(stream, bytesToReturn);\n                throw e;\n            } catch (Throwable t) {\n                throw connectionError(INTERNAL_ERROR, t, \"Unhandled error on data stream id %d\", streamId);\n            }\n\n            if (shouldIgnore) {\n                // Ignoring this frame. We still need to count the frame towards the connection flow control\n                // window, but we immediately mark all bytes as consumed.\n                flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);\n                flowController.consumeBytes(stream, bytesToReturn);\n\n                // Verify that the stream may have existed after we apply flow control.\n                verifyStreamMayHaveExisted(streamId);\n\n                // All bytes have been consumed.\n                return bytesToReturn;\n            }\n            Http2Exception error = null;\n            switch (stream.state()) {\n                case OPEN:\n                case HALF_CLOSED_LOCAL:\n                    break;\n                case HALF_CLOSED_REMOTE:\n                case CLOSED:\n                    error = streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                        stream.id(), stream.state());\n                    break;\n                default:\n                    error = streamError(stream.id(), PROTOCOL_ERROR,\n                        \"Stream %d in unexpected state: %s\", stream.id(), stream.state());\n                    break;\n            }\n\n            int unconsumedBytes = unconsumedBytes(stream);\n            try {\n                flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);\n                // Update the unconsumed bytes after flow control is applied.\n                unconsumedBytes = unconsumedBytes(stream);\n\n                // If the stream is in an invalid state to receive the frame, throw the error.\n                if (error != null) {\n                    throw error;\n                }\n\n                verifyContentLength(stream, readable, endOfStream);\n\n                // Call back the application and retrieve the number of bytes that have been\n                // immediately processed.\n                bytesToReturn = listener.onDataRead(ctx, streamId, data, padding, endOfStream);\n\n                if (endOfStream) {\n                    lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());\n                }\n\n                return bytesToReturn;\n            } catch (Http2Exception e) {\n                // If an exception happened during delivery, the listener may have returned part\n                // of the bytes before the error occurred. If that's the case, subtract that from\n                // the total processed bytes so that we don't return too many bytes.\n                int delta = unconsumedBytes - unconsumedBytes(stream);\n                bytesToReturn -= delta;\n                throw e;\n            } catch (RuntimeException e) {\n                // If an exception happened during delivery, the listener may have returned part\n                // of the bytes before the error occurred. If that's the case, subtract that from\n                // the total processed bytes so that we don't return too many bytes.\n                int delta = unconsumedBytes - unconsumedBytes(stream);\n                bytesToReturn -= delta;\n                throw e;\n            } finally {\n                // If appropriate, return the processed bytes to the flow controller.\n                flowController.consumeBytes(stream, bytesToReturn);\n            }\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int padding,\n                boolean endOfStream) throws Http2Exception {\n            onHeadersRead(ctx, streamId, headers, 0, DEFAULT_PRIORITY_WEIGHT, false, padding, endOfStream);\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n                short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            boolean allowHalfClosedRemote = false;\n            if (stream == null && !connection.streamMayHaveExisted(streamId)) {\n                stream = connection.remote().createStream(streamId, endOfStream);\n                // Allow the state to be HALF_CLOSE_REMOTE if we're creating it in that state.\n                allowHalfClosedRemote = stream.state() == HALF_CLOSED_REMOTE;\n            }\n\n            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"HEADERS\")) {\n                return;\n            }\n\n            boolean isInformational = !connection.isServer() &&\n                    HttpStatusClass.valueOf(headers.status()) == INFORMATIONAL;\n            if ((isInformational || !endOfStream) && stream.isHeadersReceived() || stream.isTrailersReceived()) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                                  \"Stream %d received too many headers EOS: %s state: %s\",\n                                  streamId, endOfStream, stream.state());\n            }\n\n            switch (stream.state()) {\n                case RESERVED_REMOTE:\n                    stream.open(endOfStream);\n                    break;\n                case OPEN:\n                case HALF_CLOSED_LOCAL:\n                    // Allowed to receive headers in these states.\n                    break;\n                case HALF_CLOSED_REMOTE:\n                    if (!allowHalfClosedRemote) {\n                        throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                                stream.id(), stream.state());\n                    }\n                    break;\n                case CLOSED:\n                    throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                            stream.id(), stream.state());\n                default:\n                    // Connection error.\n                    throw connectionError(PROTOCOL_ERROR, \"Stream %d in unexpected state: %s\", stream.id(),\n                            stream.state());\n            }\n\n            if (!stream.isHeadersReceived()) {\n                // extract the content-length header\n                List<? extends CharSequence> contentLength = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n                if (contentLength != null && !contentLength.isEmpty()) {\n                    try {\n                        long cLength = HttpUtil.normalizeAndGetContentLength(contentLength, false, true);\n                        if (cLength != -1) {\n                            headers.setLong(HttpHeaderNames.CONTENT_LENGTH, cLength);\n                            stream.setProperty(contentLengthKey, new ContentLength(cLength));\n                        }\n                    } catch (IllegalArgumentException e) {\n                        throw streamError(stream.id(), PROTOCOL_ERROR, e,\n                                \"Multiple content-length headers received\");\n                    }\n                }\n            }\n\n            stream.headersReceived(isInformational);\n            verifyContentLength(stream, 0, endOfStream);\n            encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive);\n            listener.onHeadersRead(ctx, streamId, headers, streamDependency,\n                    weight, exclusive, padding, endOfStream);\n            // If the headers completes this stream, close it.\n            if (endOfStream) {\n                lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());\n            }\n        }\n\n        @Override\n        public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDependency, short weight,\n                boolean exclusive) throws Http2Exception {\n            encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive);\n\n            listener.onPriorityRead(ctx, streamId, streamDependency, weight, exclusive);\n        }\n\n        @Override\n        public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            if (stream == null) {\n                verifyStreamMayHaveExisted(streamId);\n                return;\n            }\n\n            switch(stream.state()) {\n            case IDLE:\n                throw connectionError(PROTOCOL_ERROR, \"RST_STREAM received for IDLE stream %d\", streamId);\n            case CLOSED:\n                return; // RST_STREAM frames must be ignored for closed streams.\n            default:\n                break;\n            }\n\n            listener.onRstStreamRead(ctx, streamId, errorCode);\n\n            lifecycleManager.closeStream(stream, ctx.newSucceededFuture());\n        }\n\n        @Override\n        public void onSettingsAckRead(ChannelHandlerContext ctx) throws Http2Exception {\n            // Apply oldest outstanding local settings here. This is a synchronization point between endpoints.\n            Http2Settings settings = encoder.pollSentSettings();\n\n            if (settings != null) {\n                applyLocalSettings(settings);\n            }\n\n            listener.onSettingsAckRead(ctx);\n        }\n\n        /**\n         * Applies settings sent from the local endpoint.\n         * <p>\n         * This method is only called after the local settings have been acknowledged from the remote endpoint.\n         */\n        private void applyLocalSettings(Http2Settings settings) throws Http2Exception {\n            Boolean pushEnabled = settings.pushEnabled();\n            final Http2FrameReader.Configuration config = frameReader.configuration();\n            final Http2HeadersDecoder.Configuration headerConfig = config.headersConfiguration();\n            final Http2FrameSizePolicy frameSizePolicy = config.frameSizePolicy();\n            if (pushEnabled != null) {\n                if (connection.isServer()) {\n                    throw connectionError(PROTOCOL_ERROR, \"Server sending SETTINGS frame with ENABLE_PUSH specified\");\n                }\n                connection.local().allowPushTo(pushEnabled);\n            }\n\n            Long maxConcurrentStreams = settings.maxConcurrentStreams();\n            if (maxConcurrentStreams != null) {\n                connection.remote().maxActiveStreams((int) min(maxConcurrentStreams, MAX_VALUE));\n            }\n\n            Long headerTableSize = settings.headerTableSize();\n            if (headerTableSize != null) {\n                headerConfig.maxHeaderTableSize(headerTableSize);\n            }\n\n            Long maxHeaderListSize = settings.maxHeaderListSize();\n            if (maxHeaderListSize != null) {\n                headerConfig.maxHeaderListSize(maxHeaderListSize, calculateMaxHeaderListSizeGoAway(maxHeaderListSize));\n            }\n\n            Integer maxFrameSize = settings.maxFrameSize();\n            if (maxFrameSize != null) {\n                frameSizePolicy.maxFrameSize(maxFrameSize);\n            }\n\n            Integer initialWindowSize = settings.initialWindowSize();\n            if (initialWindowSize != null) {\n                flowController().initialWindowSize(initialWindowSize);\n            }\n        }\n\n        @Override\n        public void onSettingsRead(final ChannelHandlerContext ctx, Http2Settings settings) throws Http2Exception {\n            if (settingsReceivedConsumer == null) {\n                // Acknowledge receipt of the settings. We should do this before we process the settings to ensure our\n                // remote peer applies these settings before any subsequent frames that we may send which depend upon\n                // these new settings. See https://github.com/netty/netty/issues/6520.\n                encoder.writeSettingsAck(ctx, ctx.newPromise());\n\n                encoder.remoteSettings(settings);\n            } else {\n                settingsReceivedConsumer.consumeReceivedSettings(settings);\n            }\n\n            listener.onSettingsRead(ctx, settings);\n        }\n\n        @Override\n        public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            if (autoAckPing) {\n                // Send an ack back to the remote client.\n                encoder.writePing(ctx, true, data, ctx.newPromise());\n            }\n            listener.onPingRead(ctx, data);\n        }\n\n        @Override\n        public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            listener.onPingAckRead(ctx, data);\n        }\n\n        @Override\n        public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId,\n                Http2Headers headers, int padding) throws Http2Exception {\n            // A client cannot push.\n            if (connection().isServer()) {\n                throw connectionError(PROTOCOL_ERROR, \"A client cannot push.\");\n            }\n\n            Http2Stream parentStream = connection.stream(streamId);\n\n            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, parentStream, \"PUSH_PROMISE\")) {\n                return;\n            }\n\n            switch (parentStream.state()) {\n              case OPEN:\n              case HALF_CLOSED_LOCAL:\n                  // Allowed to receive push promise in these states.\n                  break;\n              default:\n                  // Connection error.\n                  throw connectionError(PROTOCOL_ERROR,\n                      \"Stream %d in unexpected state for receiving push promise: %s\",\n                      parentStream.id(), parentStream.state());\n            }\n\n            if (!requestVerifier.isAuthoritative(ctx, headers)) {\n                throw streamError(promisedStreamId, PROTOCOL_ERROR,\n                        \"Promised request on stream %d for promised stream %d is not authoritative\",\n                        streamId, promisedStreamId);\n            }\n            if (!requestVerifier.isCacheable(headers)) {\n                throw streamError(promisedStreamId, PROTOCOL_ERROR,\n                        \"Promised request on stream %d for promised stream %d is not known to be cacheable\",\n                        streamId, promisedStreamId);\n            }\n            if (!requestVerifier.isSafe(headers)) {\n                throw streamError(promisedStreamId, PROTOCOL_ERROR,\n                        \"Promised request on stream %d for promised stream %d is not known to be safe\",\n                        streamId, promisedStreamId);\n            }\n\n            // Reserve the push stream based with a priority based on the current stream's priority.\n            connection.remote().reservePushStream(promisedStreamId, parentStream);\n\n            listener.onPushPromiseRead(ctx, streamId, promisedStreamId, headers, padding);\n        }\n\n        @Override\n        public void onGoAwayRead(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)\n                throws Http2Exception {\n            onGoAwayRead0(ctx, lastStreamId, errorCode, debugData);\n        }\n\n        @Override\n        public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeIncrement)\n                throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            if (stream == null || stream.state() == CLOSED || streamCreatedAfterGoAwaySent(streamId)) {\n                // Ignore this frame.\n                verifyStreamMayHaveExisted(streamId);\n                return;\n            }\n\n            // Update the outbound flow control window.\n            encoder.flowController().incrementWindowSize(stream, windowSizeIncrement);\n\n            listener.onWindowUpdateRead(ctx, streamId, windowSizeIncrement);\n        }\n\n        @Override\n        public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,\n                ByteBuf payload) throws Http2Exception {\n            onUnknownFrame0(ctx, frameType, streamId, flags, payload);\n        }\n\n        /**\n         * Helper method to determine if a frame that has the semantics of headers or data should be ignored for the\n         * {@code stream} (which may be {@code null}) associated with {@code streamId}.\n         */\n        private boolean shouldIgnoreHeadersOrDataFrame(ChannelHandlerContext ctx, int streamId, Http2Stream stream,\n                String frameName) throws Http2Exception {\n            if (stream == null) {\n                if (streamCreatedAfterGoAwaySent(streamId)) {\n                    logger.info(\"{} ignoring {} frame for stream {}. Stream sent after GOAWAY sent\",\n                            ctx.channel(), frameName, streamId);\n                    return true;\n                }\n\n                // Make sure it's not an out-of-order frame, like a rogue DATA frame, for a stream that could\n                // never have existed.\n                verifyStreamMayHaveExisted(streamId);\n\n                // Its possible that this frame would result in stream ID out of order creation (PROTOCOL ERROR) and its\n                // also possible that this frame is received on a CLOSED stream (STREAM_CLOSED after a RST_STREAM is\n                // sent). We don't have enough information to know for sure, so we choose the lesser of the two errors.\n                throw streamError(streamId, STREAM_CLOSED, \"Received %s frame for an unknown stream %d\",\n                                  frameName, streamId);\n            } else if (stream.isResetSent() || streamCreatedAfterGoAwaySent(streamId)) {\n                // If we have sent a reset stream it is assumed the stream will be closed after the write completes.\n                // If we have not sent a reset, but the stream was created after a GoAway this is not supported by\n                // DefaultHttp2Connection and if a custom Http2Connection is used it is assumed the lifetime is managed\n                // elsewhere so we don't close the stream or otherwise modify the stream's state.\n\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"{} ignoring {} frame for stream {}\", ctx.channel(), frameName,\n                            stream.isResetSent() ? \"RST_STREAM sent.\" :\n                                (\"Stream created after GOAWAY sent. Last known stream by peer \" +\n                                 connection.remote().lastStreamKnownByPeer()));\n                }\n\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * Helper method for determining whether or not to ignore inbound frames. A stream is considered to be created\n         * after a {@code GOAWAY} is sent if the following conditions hold:\n         * <p/>\n         * <ul>\n         *     <li>A {@code GOAWAY} must have been sent by the local endpoint</li>\n         *     <li>The {@code streamId} must identify a legitimate stream id for the remote endpoint to be creating</li>\n         *     <li>{@code streamId} is greater than the Last Known Stream ID which was sent by the local endpoint\n         *     in the last {@code GOAWAY} frame</li>\n         * </ul>\n         * <p/>\n         */\n        private boolean streamCreatedAfterGoAwaySent(int streamId) {\n            Endpoint<?> remote = connection.remote();\n            return connection.goAwaySent() && remote.isValidStreamId(streamId) &&\n                    streamId > remote.lastStreamKnownByPeer();\n        }\n\n        private void verifyStreamMayHaveExisted(int streamId) throws Http2Exception {\n            if (!connection.streamMayHaveExisted(streamId)) {\n                throw connectionError(PROTOCOL_ERROR, \"Stream %d does not exist\", streamId);\n            }\n        }\n    }\n\n    private final class PrefaceFrameListener implements Http2FrameListener {\n        /**\n         * Verifies that the HTTP/2 connection preface has been received from the remote endpoint.\n         * It is possible that the current call to\n         * {@link Http2FrameReader#readFrame(ChannelHandlerContext, ByteBuf, Http2FrameListener)} will have multiple\n         * frames to dispatch. So it may be OK for this class to get legitimate frames for the first readFrame.\n         */\n        private void verifyPrefaceReceived() throws Http2Exception {\n            if (!prefaceReceived()) {\n                throw connectionError(PROTOCOL_ERROR, \"Received non-SETTINGS as first frame.\");\n            }\n        }\n\n        @Override\n        public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream)\n                throws Http2Exception {\n            verifyPrefaceReceived();\n            return internalFrameListener.onDataRead(ctx, streamId, data, padding, endOfStream);\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int padding,\n                boolean endOfStream) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onHeadersRead(ctx, streamId, headers, padding, endOfStream);\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n                short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onHeadersRead(ctx, streamId, headers, streamDependency, weight,\n                    exclusive, padding, endOfStream);\n        }\n\n        @Override\n        public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDependency, short weight,\n                boolean exclusive) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPriorityRead(ctx, streamId, streamDependency, weight, exclusive);\n        }\n\n        @Override\n        public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onRstStreamRead(ctx, streamId, errorCode);\n        }\n\n        @Override\n        public void onSettingsAckRead(ChannelHandlerContext ctx) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onSettingsAckRead(ctx);\n        }\n\n        @Override\n        public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) throws Http2Exception {\n            // The first settings should change the internalFrameListener to the \"real\" listener\n            // that expects the preface to be verified.\n            if (!prefaceReceived()) {\n                internalFrameListener = new FrameReadListener();\n            }\n            internalFrameListener.onSettingsRead(ctx, settings);\n        }\n\n        @Override\n        public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPingRead(ctx, data);\n        }\n\n        @Override\n        public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPingAckRead(ctx, data);\n        }\n\n        @Override\n        public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId,\n                Http2Headers headers, int padding) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPushPromiseRead(ctx, streamId, promisedStreamId, headers, padding);\n        }\n\n        @Override\n        public void onGoAwayRead(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)\n                throws Http2Exception {\n            onGoAwayRead0(ctx, lastStreamId, errorCode, debugData);\n        }\n\n        @Override\n        public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeIncrement)\n                throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onWindowUpdateRead(ctx, streamId, windowSizeIncrement);\n        }\n\n        @Override\n        public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,\n                ByteBuf payload) throws Http2Exception {\n            onUnknownFrame0(ctx, frameType, streamId, flags, payload);\n        }\n    }\n\n    private static final class ContentLength {\n        private final long expected;\n        private long seen;\n\n        ContentLength(long expected) {\n            this.expected = expected;\n        }\n\n        void increaseReceivedBytes(boolean server, int streamId, int bytes, boolean isEnd) throws Http2Exception {\n            seen += bytes;\n            // Check for overflow\n            if (seen < 0) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                        \"Received amount of data did overflow and so not match content-length header %d\", expected);\n            }\n            // Check if we received more data then what was advertised via the content-length header.\n            if (seen > expected) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                        \"Received amount of data %d does not match content-length header %d\", seen, expected);\n            }\n\n            if (isEnd) {\n                if (seen == 0 && !server) {\n                    // This may be a response to a HEAD request, let's just allow it.\n                    return;\n                }\n\n                // Check that we really saw what was told via the content-length header.\n                if (expected > seen) {\n                    throw streamError(streamId, PROTOCOL_ERROR,\n                            \"Received amount of data %d does not match content-length header %d\", seen, expected);\n                }\n            }\n        }\n    }\n}\n", "/*\n * Copyright 2016 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at:\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage io.netty.handler.codec.http2;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelOutboundHandlerAdapter;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.WriteBufferWaterMark;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpScheme;\nimport io.netty.handler.codec.http2.Http2Exception.StreamException;\nimport io.netty.handler.codec.http2.LastInboundHandler.Consumer;\nimport io.netty.util.AsciiString;\nimport io.netty.util.AttributeKey;\nimport org.hamcrest.CoreMatchers;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.ArgumentMatcher;\nimport org.mockito.Mockito;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\nimport java.net.InetSocketAddress;\nimport java.nio.channels.ClosedChannelException;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static io.netty.handler.codec.http2.Http2TestUtil.anyChannelPromise;\nimport static io.netty.handler.codec.http2.Http2TestUtil.anyHttp2Settings;\nimport static io.netty.handler.codec.http2.Http2TestUtil.assertEqualsAndRelease;\nimport static io.netty.handler.codec.http2.Http2TestUtil.bb;\nimport static io.netty.util.ReferenceCountUtil.release;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyBoolean;\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.ArgumentMatchers.anyLong;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic abstract class Http2MultiplexTest<C extends Http2FrameCodec> {\n    private final Http2Headers request = new DefaultHttp2Headers()\n            .method(HttpMethod.GET.asciiName()).scheme(HttpScheme.HTTPS.name())\n            .authority(new AsciiString(\"example.org\")).path(new AsciiString(\"/foo\"));\n\n    private EmbeddedChannel parentChannel;\n    private Http2FrameWriter frameWriter;\n    private Http2FrameInboundWriter frameInboundWriter;\n    private TestChannelInitializer childChannelInitializer;\n    private C codec;\n\n    private static final int initialRemoteStreamWindow = 1024;\n\n    protected abstract C newCodec(TestChannelInitializer childChannelInitializer,  Http2FrameWriter frameWriter);\n    protected abstract ChannelHandler newMultiplexer(TestChannelInitializer childChannelInitializer);\n\n    @Before\n    public void setUp() {\n        childChannelInitializer = new TestChannelInitializer();\n        parentChannel = new EmbeddedChannel();\n        frameInboundWriter = new Http2FrameInboundWriter(parentChannel);\n        parentChannel.connect(new InetSocketAddress(0));\n        frameWriter = Http2TestUtil.mockedFrameWriter();\n        codec = newCodec(childChannelInitializer, frameWriter);\n        parentChannel.pipeline().addLast(codec);\n        ChannelHandler multiplexer = newMultiplexer(childChannelInitializer);\n        if (multiplexer != null) {\n            parentChannel.pipeline().addLast(multiplexer);\n        }\n\n        parentChannel.runPendingTasks();\n        parentChannel.pipeline().fireChannelActive();\n\n        parentChannel.writeInbound(Http2CodecUtil.connectionPrefaceBuf());\n\n        Http2Settings settings = new Http2Settings().initialWindowSize(initialRemoteStreamWindow);\n        frameInboundWriter.writeInboundSettings(settings);\n\n        verify(frameWriter).writeSettingsAck(eqCodecCtx(), anyChannelPromise());\n\n        frameInboundWriter.writeInboundSettingsAck();\n\n        Http2SettingsFrame settingsFrame = parentChannel.readInbound();\n        assertNotNull(settingsFrame);\n        Http2SettingsAckFrame settingsAckFrame = parentChannel.readInbound();\n        assertNotNull(settingsAckFrame);\n\n        // Handshake\n        verify(frameWriter).writeSettings(eqCodecCtx(),\n                anyHttp2Settings(), anyChannelPromise());\n    }\n\n    private ChannelHandlerContext eqCodecCtx() {\n        return eq(codec.ctx);\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        if (childChannelInitializer.handler instanceof LastInboundHandler) {\n            ((LastInboundHandler) childChannelInitializer.handler).finishAndReleaseAll();\n        }\n        parentChannel.finishAndReleaseAll();\n        codec = null;\n    }\n\n    // TODO(buchgr): Flush from child channel\n    // TODO(buchgr): ChildChannel.childReadComplete()\n    // TODO(buchgr): GOAWAY Logic\n    // TODO(buchgr): Test ChannelConfig.setMaxMessagesPerRead\n\n    @Test\n    public void writeUnknownFrame() {\n        Http2StreamChannel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelActive(ChannelHandlerContext ctx) {\n                ctx.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));\n                ctx.writeAndFlush(new DefaultHttp2UnknownFrame((byte) 99, new Http2Flags()));\n                ctx.fireChannelActive();\n            }\n        });\n        assertTrue(childChannel.isActive());\n\n        parentChannel.runPendingTasks();\n\n        verify(frameWriter).writeFrame(eq(codec.ctx), eq((byte) 99), eqStreamId(childChannel), any(Http2Flags.class),\n                any(ByteBuf.class), any(ChannelPromise.class));\n    }\n\n    private Http2StreamChannel newInboundStream(int streamId, boolean endStream, final ChannelHandler childHandler) {\n        return newInboundStream(streamId, endStream, null, childHandler);\n    }\n\n    private Http2StreamChannel newInboundStream(int streamId, boolean endStream,\n                                                AtomicInteger maxReads, final ChannelHandler childHandler) {\n        final AtomicReference<Http2StreamChannel> streamChannelRef = new AtomicReference<Http2StreamChannel>();\n        childChannelInitializer.maxReads = maxReads;\n        childChannelInitializer.handler = new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelRegistered(ChannelHandlerContext ctx) {\n                assertNull(streamChannelRef.get());\n                streamChannelRef.set((Http2StreamChannel) ctx.channel());\n                ctx.pipeline().addLast(childHandler);\n                ctx.fireChannelRegistered();\n            }\n        };\n\n        frameInboundWriter.writeInboundHeaders(streamId, request, 0, endStream);\n        parentChannel.runPendingTasks();\n        Http2StreamChannel channel = streamChannelRef.get();\n        assertEquals(streamId, channel.stream().id());\n        return channel;\n    }\n\n    @Test\n    public void readUnkownFrame() {\n        LastInboundHandler handler = new LastInboundHandler();\n\n        Http2StreamChannel channel = newInboundStream(3, true, handler);\n        frameInboundWriter.writeInboundFrame((byte) 99, channel.stream().id(), new Http2Flags(), Unpooled.EMPTY_BUFFER);\n\n        // header frame and unknown frame\n        verifyFramesMultiplexedToCorrectChannel(channel, handler, 2);\n\n        Channel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter());\n        assertTrue(childChannel.isActive());\n    }\n\n    @Test\n    public void headerAndDataFramesShouldBeDelivered() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n\n        Http2StreamChannel channel = newInboundStream(3, false, inboundHandler);\n        Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(request).stream(channel.stream());\n        Http2DataFrame dataFrame1 = new DefaultHttp2DataFrame(bb(\"hello\")).stream(channel.stream());\n        Http2DataFrame dataFrame2 = new DefaultHttp2DataFrame(bb(\"world\")).stream(channel.stream());\n\n        assertTrue(inboundHandler.isChannelActive());\n        frameInboundWriter.writeInboundData(channel.stream().id(), bb(\"hello\"), 0, false);\n        frameInboundWriter.writeInboundData(channel.stream().id(), bb(\"world\"), 0, false);\n\n        assertEquals(headersFrame, inboundHandler.readInbound());\n\n        assertEqualsAndRelease(dataFrame1, inboundHandler.<Http2Frame>readInbound());\n        assertEqualsAndRelease(dataFrame2, inboundHandler.<Http2Frame>readInbound());\n\n        assertNull(inboundHandler.readInbound());\n    }\n\n    @Test\n    public void headerMultipleContentLengthValidationShouldPropagate() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        request.addLong(HttpHeaderNames.CONTENT_LENGTH, 0);\n        request.addLong(HttpHeaderNames.CONTENT_LENGTH, 1);\n        Http2StreamChannel channel = newInboundStream(3, false, inboundHandler);\n        try {\n            inboundHandler.checkException();\n            fail();\n        } catch (Exception e) {\n            assertThat(e, CoreMatchers.<Exception>instanceOf(StreamException.class));\n        }\n        assertNull(inboundHandler.readInbound());\n        assertFalse(channel.isActive());\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagate() {\n        headerContentLengthNotMatchValidationShouldPropagate(false, false, false);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateWithEndStream() {\n        headerContentLengthNotMatchValidationShouldPropagate(false, true, false);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateCloseLocal() {\n        headerContentLengthNotMatchValidationShouldPropagate(true, false, false);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateWithEndStreamCloseLocal() {\n        headerContentLengthNotMatchValidationShouldPropagate(true, true, false);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateTrailers() {\n        headerContentLengthNotMatchValidationShouldPropagate(false, false, true);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateWithEndStreamTrailers() {\n        headerContentLengthNotMatchValidationShouldPropagate(false, true, true);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateCloseLocalTrailers() {\n        headerContentLengthNotMatchValidationShouldPropagate(true, false, true);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateWithEndStreamCloseLocalTrailers() {\n        headerContentLengthNotMatchValidationShouldPropagate(true, true, true);\n    }\n\n    private void headerContentLengthNotMatchValidationShouldPropagate(\n            boolean closeLocal, boolean endStream, boolean trailer) {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        request.addLong(HttpHeaderNames.CONTENT_LENGTH, 1);\n        Http2StreamChannel channel = newInboundStream(3, false, inboundHandler);\n        assertTrue(channel.isActive());\n\n        if (closeLocal) {\n            channel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers(), true))\n                    .syncUninterruptibly();\n            assertEquals(Http2Stream.State.HALF_CLOSED_LOCAL, channel.stream().state());\n        } else {\n            assertEquals(Http2Stream.State.OPEN, channel.stream().state());\n        }\n\n        if (trailer) {\n            frameInboundWriter.writeInboundHeaders(channel.stream().id(), new DefaultHttp2Headers(), 0, endStream);\n        } else {\n            frameInboundWriter.writeInboundData(channel.stream().id(), bb(\"foo\"), 0, endStream);\n        }\n        try {\n            inboundHandler.checkException();\n            fail();\n        } catch (Exception e) {\n            assertThat(e, CoreMatchers.<Exception>instanceOf(StreamException.class));\n        }\n        Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(request).stream(channel.stream());\n        assertEquals(headersFrame, inboundHandler.readInbound());\n        assertNull(inboundHandler.readInbound());\n        assertFalse(channel.isActive());\n    }\n\n    @Test\n    public void framesShouldBeMultiplexed() {\n        LastInboundHandler handler1 = new LastInboundHandler();\n        Http2StreamChannel channel1 = newInboundStream(3, false, handler1);\n        LastInboundHandler handler2 = new LastInboundHandler();\n        Http2StreamChannel channel2 = newInboundStream(5, false, handler2);\n        LastInboundHandler handler3 = new LastInboundHandler();\n        Http2StreamChannel channel3 = newInboundStream(11, false, handler3);\n\n        verifyFramesMultiplexedToCorrectChannel(channel1, handler1, 1);\n        verifyFramesMultiplexedToCorrectChannel(channel2, handler2, 1);\n        verifyFramesMultiplexedToCorrectChannel(channel3, handler3, 1);\n\n        frameInboundWriter.writeInboundData(channel2.stream().id(), bb(\"hello\"), 0, false);\n        frameInboundWriter.writeInboundData(channel1.stream().id(), bb(\"foo\"), 0, true);\n        frameInboundWriter.writeInboundData(channel2.stream().id(), bb(\"world\"), 0, true);\n        frameInboundWriter.writeInboundData(channel3.stream().id(), bb(\"bar\"), 0, true);\n\n        verifyFramesMultiplexedToCorrectChannel(channel1, handler1, 1);\n        verifyFramesMultiplexedToCorrectChannel(channel2, handler2, 2);\n        verifyFramesMultiplexedToCorrectChannel(channel3, handler3, 1);\n    }\n\n    @Test\n    public void inboundDataFrameShouldUpdateLocalFlowController() throws Http2Exception {\n        Http2LocalFlowController flowController = Mockito.mock(Http2LocalFlowController.class);\n        codec.connection().local().flowController(flowController);\n\n        LastInboundHandler handler = new LastInboundHandler();\n        final Http2StreamChannel channel = newInboundStream(3, false, handler);\n\n        ByteBuf tenBytes = bb(\"0123456789\");\n\n        frameInboundWriter.writeInboundData(channel.stream().id(), tenBytes, 0, true);\n\n        // Verify we marked the bytes as consumed\n        verify(flowController).consumeBytes(argThat(new ArgumentMatcher<Http2Stream>() {\n            @Override\n            public boolean matches(Http2Stream http2Stream) {\n                return http2Stream.id() == channel.stream().id();\n            }\n        }), eq(10));\n\n        // headers and data frame\n        verifyFramesMultiplexedToCorrectChannel(channel, handler, 2);\n    }\n\n    @Test\n    public void unhandledHttp2FramesShouldBePropagated() {\n        Http2PingFrame pingFrame = new DefaultHttp2PingFrame(0);\n        frameInboundWriter.writeInboundPing(false, 0);\n        assertEquals(parentChannel.readInbound(), pingFrame);\n\n        DefaultHttp2GoAwayFrame goAwayFrame = new DefaultHttp2GoAwayFrame(1,\n                parentChannel.alloc().buffer().writeLong(8));\n        frameInboundWriter.writeInboundGoAway(0, goAwayFrame.errorCode(), goAwayFrame.content().retainedDuplicate());\n\n        Http2GoAwayFrame frame = parentChannel.readInbound();\n        assertEqualsAndRelease(frame, goAwayFrame);\n    }\n\n    @Test\n    public void channelReadShouldRespectAutoRead() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n        assertTrue(childChannel.config().isAutoRead());\n        Http2HeadersFrame headersFrame = inboundHandler.readInbound();\n        assertNotNull(headersFrame);\n\n        childChannel.config().setAutoRead(false);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"hello world\"), 0, false);\n        Http2DataFrame dataFrame0 = inboundHandler.readInbound();\n        assertNotNull(dataFrame0);\n        release(dataFrame0);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"foo\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar\"), 0, false);\n\n        assertNull(inboundHandler.readInbound());\n\n        childChannel.config().setAutoRead(true);\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 2);\n    }\n\n    @Test\n    public void channelReadShouldRespectAutoReadAndNotProduceNPE() throws Exception {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n        assertTrue(childChannel.config().isAutoRead());\n        Http2HeadersFrame headersFrame = inboundHandler.readInbound();\n        assertNotNull(headersFrame);\n\n        childChannel.config().setAutoRead(false);\n        childChannel.pipeline().addFirst(new ChannelInboundHandlerAdapter() {\n            private int count;\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                ctx.fireChannelRead(msg);\n                // Close channel after 2 reads so there is still something in the inboundBuffer when the close happens.\n                if (++count == 2) {\n                    ctx.close();\n                }\n            }\n        });\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"hello world\"), 0, false);\n        Http2DataFrame dataFrame0 = inboundHandler.readInbound();\n        assertNotNull(dataFrame0);\n        release(dataFrame0);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"foo\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar\"), 0, false);\n\n        assertNull(inboundHandler.readInbound());\n\n        childChannel.config().setAutoRead(true);\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 3);\n        inboundHandler.checkException();\n    }\n\n    @Test\n    public void readInChannelReadWithoutAutoRead() {\n        useReadWithoutAutoRead(false);\n    }\n\n    @Test\n    public void readInChannelReadCompleteWithoutAutoRead() {\n        useReadWithoutAutoRead(true);\n    }\n\n    private void useReadWithoutAutoRead(final boolean readComplete) {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n        assertTrue(childChannel.config().isAutoRead());\n        childChannel.config().setAutoRead(false);\n        assertFalse(childChannel.config().isAutoRead());\n\n        Http2HeadersFrame headersFrame = inboundHandler.readInbound();\n        assertNotNull(headersFrame);\n\n        // Add a handler which will request reads.\n        childChannel.pipeline().addFirst(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                ctx.fireChannelRead(msg);\n                if (!readComplete) {\n                    ctx.read();\n                }\n            }\n\n            @Override\n            public void channelReadComplete(ChannelHandlerContext ctx) {\n                ctx.fireChannelReadComplete();\n                if (readComplete) {\n                    ctx.read();\n                }\n            }\n        });\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"hello world\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"foo\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"hello world\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"foo\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar\"), 0, true);\n\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 6);\n    }\n\n    private Http2StreamChannel newOutboundStream(ChannelHandler handler) {\n        return new Http2StreamChannelBootstrap(parentChannel).handler(handler)\n                .open().syncUninterruptibly().getNow();\n    }\n\n    /**\n     * A child channel for an HTTP/2 stream in IDLE state (that is no headers sent or received),\n     * should not emit a RST_STREAM frame on close, as this is a connection error of type protocol error.\n     */\n    @Test\n    public void idleOutboundStreamShouldNotWriteResetFrameOnClose() {\n        LastInboundHandler handler = new LastInboundHandler();\n\n        Channel childChannel = newOutboundStream(handler);\n        assertTrue(childChannel.isActive());\n\n        childChannel.close();\n        parentChannel.runPendingTasks();\n\n        assertFalse(childChannel.isOpen());\n        assertFalse(childChannel.isActive());\n        assertNull(parentChannel.readOutbound());\n    }\n\n    @Test\n    public void outboundStreamShouldWriteResetFrameOnClose_headersSent() {\n        ChannelHandler handler = new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelActive(ChannelHandlerContext ctx) {\n                ctx.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));\n                ctx.fireChannelActive();\n            }\n        };\n\n        Http2StreamChannel childChannel = newOutboundStream(handler);\n        assertTrue(childChannel.isActive());\n\n        childChannel.close();\n        verify(frameWriter).writeRstStream(eqCodecCtx(),\n                eqStreamId(childChannel), eq(Http2Error.CANCEL.code()), anyChannelPromise());\n    }\n\n    @Test\n    public void outboundStreamShouldNotWriteResetFrameOnClose_IfStreamDidntExist() {\n        when(frameWriter.writeHeaders(eqCodecCtx(), anyInt(),\n                any(Http2Headers.class), anyInt(), anyBoolean(),\n                any(ChannelPromise.class))).thenAnswer(new Answer<ChannelFuture>() {\n\n            private boolean headersWritten;\n            @Override\n            public ChannelFuture answer(InvocationOnMock invocationOnMock) {\n                // We want to fail to write the first headers frame. This is what happens if the connection\n                // refuses to allocate a new stream due to having received a GOAWAY.\n                if (!headersWritten) {\n                    headersWritten = true;\n                    return ((ChannelPromise) invocationOnMock.getArgument(5)).setFailure(new Exception(\"boom\"));\n                }\n                return ((ChannelPromise) invocationOnMock.getArgument(5)).setSuccess();\n            }\n        });\n\n        Http2StreamChannel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelActive(ChannelHandlerContext ctx) {\n                ctx.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));\n                ctx.fireChannelActive();\n            }\n        });\n\n        assertFalse(childChannel.isActive());\n\n        childChannel.close();\n        parentChannel.runPendingTasks();\n        // The channel was never active so we should not generate a RST frame.\n        verify(frameWriter, never()).writeRstStream(eqCodecCtx(), eqStreamId(childChannel), anyLong(),\n                anyChannelPromise());\n\n        assertTrue(parentChannel.outboundMessages().isEmpty());\n    }\n\n    @Test\n    public void inboundRstStreamFireChannelInactive() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel channel = newInboundStream(3, false, inboundHandler);\n        assertTrue(inboundHandler.isChannelActive());\n        frameInboundWriter.writeInboundRstStream(channel.stream().id(), Http2Error.INTERNAL_ERROR.code());\n\n        assertFalse(inboundHandler.isChannelActive());\n\n        // A RST_STREAM frame should NOT be emitted, as we received a RST_STREAM.\n        verify(frameWriter, Mockito.never()).writeRstStream(eqCodecCtx(), eqStreamId(channel),\n                anyLong(), anyChannelPromise());\n    }\n\n    @Test(expected = StreamException.class)\n    public void streamExceptionTriggersChildChannelExceptionAndClose() throws Exception {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel channel = newInboundStream(3, false, inboundHandler);\n        assertTrue(channel.isActive());\n        StreamException cause = new StreamException(channel.stream().id(), Http2Error.PROTOCOL_ERROR, \"baaam!\");\n        parentChannel.pipeline().fireExceptionCaught(cause);\n\n        assertFalse(channel.isActive());\n        inboundHandler.checkException();\n    }\n\n    @Test(expected = ClosedChannelException.class)\n    public void streamClosedErrorTranslatedToClosedChannelExceptionOnWrites() throws Exception {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n\n        final Http2StreamChannel childChannel = newOutboundStream(inboundHandler);\n        assertTrue(childChannel.isActive());\n\n        Http2Headers headers = new DefaultHttp2Headers();\n        when(frameWriter.writeHeaders(eqCodecCtx(), anyInt(),\n                eq(headers), anyInt(), anyBoolean(),\n                any(ChannelPromise.class))).thenAnswer(new Answer<ChannelFuture>() {\n            @Override\n            public ChannelFuture answer(InvocationOnMock invocationOnMock) {\n                return ((ChannelPromise) invocationOnMock.getArgument(5)).setFailure(\n                        new StreamException(childChannel.stream().id(), Http2Error.STREAM_CLOSED, \"Stream Closed\"));\n            }\n        });\n        ChannelFuture future = childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));\n\n        parentChannel.flush();\n\n        assertFalse(childChannel.isActive());\n        assertFalse(childChannel.isOpen());\n\n        inboundHandler.checkException();\n\n        future.syncUninterruptibly();\n    }\n\n    @Test\n    public void creatingWritingReadingAndClosingOutboundStreamShouldWork() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newOutboundStream(inboundHandler);\n        assertTrue(childChannel.isActive());\n        assertTrue(inboundHandler.isChannelActive());\n\n        // Write to the child channel\n        Http2Headers headers = new DefaultHttp2Headers().scheme(\"https\").method(\"GET\").path(\"/foo.txt\");\n        childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(headers));\n\n        // Read from the child channel\n        frameInboundWriter.writeInboundHeaders(childChannel.stream().id(), headers, 0, false);\n\n        Http2HeadersFrame headersFrame = inboundHandler.readInbound();\n        assertNotNull(headersFrame);\n        assertEquals(headers, headersFrame.headers());\n\n        // Close the child channel.\n        childChannel.close();\n\n        parentChannel.runPendingTasks();\n        // An active outbound stream should emit a RST_STREAM frame.\n        verify(frameWriter).writeRstStream(eqCodecCtx(), eqStreamId(childChannel),\n                anyLong(), anyChannelPromise());\n\n        assertFalse(childChannel.isOpen());\n        assertFalse(childChannel.isActive());\n        assertFalse(inboundHandler.isChannelActive());\n    }\n\n    // Test failing the promise of the first headers frame of an outbound stream. In practice this error case would most\n    // likely happen due to the max concurrent streams limit being hit or the channel running out of stream identifiers.\n    //\n    @Test(expected = Http2NoMoreStreamIdsException.class)\n    public void failedOutboundStreamCreationThrowsAndClosesChannel() throws Exception {\n        LastInboundHandler handler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newOutboundStream(handler);\n        assertTrue(childChannel.isActive());\n\n        Http2Headers headers = new DefaultHttp2Headers();\n        when(frameWriter.writeHeaders(eqCodecCtx(), anyInt(),\n               eq(headers), anyInt(), anyBoolean(),\n               any(ChannelPromise.class))).thenAnswer(new Answer<ChannelFuture>() {\n           @Override\n           public ChannelFuture answer(InvocationOnMock invocationOnMock) {\n               return ((ChannelPromise) invocationOnMock.getArgument(5)).setFailure(\n                       new Http2NoMoreStreamIdsException());\n            }\n        });\n\n        ChannelFuture future = childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(headers));\n        parentChannel.flush();\n\n        assertFalse(childChannel.isActive());\n        assertFalse(childChannel.isOpen());\n\n        handler.checkException();\n\n        future.syncUninterruptibly();\n    }\n\n    @Test\n    public void channelClosedWhenCloseListenerCompletes() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n\n        assertTrue(childChannel.isOpen());\n        assertTrue(childChannel.isActive());\n\n        final AtomicBoolean channelOpen = new AtomicBoolean(true);\n        final AtomicBoolean channelActive = new AtomicBoolean(true);\n\n        // Create a promise before actually doing the close, because otherwise we would be adding a listener to a future\n        // that is already completed because we are using EmbeddedChannel which executes code in the JUnit thread.\n        ChannelPromise p = childChannel.newPromise();\n        p.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                channelOpen.set(future.channel().isOpen());\n                channelActive.set(future.channel().isActive());\n            }\n        });\n        childChannel.close(p).syncUninterruptibly();\n\n        assertFalse(channelOpen.get());\n        assertFalse(channelActive.get());\n        assertFalse(childChannel.isActive());\n    }\n\n    @Test\n    public void channelClosedWhenChannelClosePromiseCompletes() {\n         LastInboundHandler inboundHandler = new LastInboundHandler();\n         Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n\n         assertTrue(childChannel.isOpen());\n         assertTrue(childChannel.isActive());\n\n         final AtomicBoolean channelOpen = new AtomicBoolean(true);\n         final AtomicBoolean channelActive = new AtomicBoolean(true);\n\n         childChannel.closeFuture().addListener(new ChannelFutureListener() {\n             @Override\n             public void operationComplete(ChannelFuture future) {\n                 channelOpen.set(future.channel().isOpen());\n                 channelActive.set(future.channel().isActive());\n             }\n         });\n         childChannel.close().syncUninterruptibly();\n\n         assertFalse(channelOpen.get());\n         assertFalse(channelActive.get());\n         assertFalse(childChannel.isActive());\n    }\n\n    @Test\n    public void channelClosedWhenWriteFutureFails() {\n        final Queue<ChannelPromise> writePromises = new ArrayDeque<ChannelPromise>();\n\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n\n        assertTrue(childChannel.isOpen());\n        assertTrue(childChannel.isActive());\n\n        final AtomicBoolean channelOpen = new AtomicBoolean(true);\n        final AtomicBoolean channelActive = new AtomicBoolean(true);\n\n        Http2Headers headers = new DefaultHttp2Headers();\n        when(frameWriter.writeHeaders(eqCodecCtx(), anyInt(),\n                eq(headers), anyInt(), anyBoolean(),\n                any(ChannelPromise.class))).thenAnswer(new Answer<ChannelFuture>() {\n            @Override\n            public ChannelFuture answer(InvocationOnMock invocationOnMock) {\n                ChannelPromise promise = invocationOnMock.getArgument(5);\n                writePromises.offer(promise);\n                return promise;\n            }\n        });\n\n        ChannelFuture f = childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(headers));\n        assertFalse(f.isDone());\n        f.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                channelOpen.set(future.channel().isOpen());\n                channelActive.set(future.channel().isActive());\n            }\n        });\n\n        ChannelPromise first = writePromises.poll();\n        first.setFailure(new ClosedChannelException());\n        f.awaitUninterruptibly();\n\n        assertFalse(channelOpen.get());\n        assertFalse(channelActive.get());\n        assertFalse(childChannel.isActive());\n    }\n\n    @Test\n    public void channelClosedTwiceMarksPromiseAsSuccessful() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n\n        assertTrue(childChannel.isOpen());\n        assertTrue(childChannel.isActive());\n        childChannel.close().syncUninterruptibly();\n        childChannel.close().syncUninterruptibly();\n\n        assertFalse(childChannel.isOpen());\n        assertFalse(childChannel.isActive());\n    }\n\n    @Test\n    public void settingChannelOptsAndAttrs() {\n        AttributeKey<String> key = AttributeKey.newInstance(UUID.randomUUID().toString());\n\n        Channel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter());\n        childChannel.config().setAutoRead(false).setWriteSpinCount(1000);\n        childChannel.attr(key).set(\"bar\");\n        assertFalse(childChannel.config().isAutoRead());\n        assertEquals(1000, childChannel.config().getWriteSpinCount());\n        assertEquals(\"bar\", childChannel.attr(key).get());\n    }\n\n    @Test\n    public void outboundFlowControlWritability() {\n        Http2StreamChannel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter());\n        assertTrue(childChannel.isActive());\n\n        assertTrue(childChannel.isWritable());\n        childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));\n        parentChannel.flush();\n\n        // Test for initial window size\n        assertTrue(initialRemoteStreamWindow < childChannel.config().getWriteBufferHighWaterMark());\n\n        assertTrue(childChannel.isWritable());\n        childChannel.write(new DefaultHttp2DataFrame(Unpooled.buffer().writeZero(16 * 1024 * 1024)));\n        assertEquals(0, childChannel.bytesBeforeUnwritable());\n        assertFalse(childChannel.isWritable());\n    }\n\n    @Test\n    public void writabilityOfParentIsRespected() {\n        Http2StreamChannel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter());\n        childChannel.config().setWriteBufferWaterMark(new WriteBufferWaterMark(2048, 4096));\n        parentChannel.config().setWriteBufferWaterMark(new WriteBufferWaterMark(256, 512));\n        assertTrue(childChannel.isWritable());\n        assertTrue(parentChannel.isActive());\n\n        childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));\n        parentChannel.flush();\n\n        assertTrue(childChannel.isWritable());\n        childChannel.write(new DefaultHttp2DataFrame(Unpooled.buffer().writeZero(256)));\n        assertTrue(childChannel.isWritable());\n        childChannel.writeAndFlush(new DefaultHttp2DataFrame(Unpooled.buffer().writeZero(512)));\n\n        long bytesBeforeUnwritable = childChannel.bytesBeforeUnwritable();\n        assertNotEquals(0, bytesBeforeUnwritable);\n        // Add something to the ChannelOutboundBuffer of the parent to simulate queuing in the parents channel buffer\n        // and verify that this only affect the writability of the parent channel while the child stays writable\n        // until it used all of its credits.\n        parentChannel.unsafe().outboundBuffer().addMessage(\n                Unpooled.buffer().writeZero(800), 800, parentChannel.voidPromise());\n        assertFalse(parentChannel.isWritable());\n\n        assertTrue(childChannel.isWritable());\n        assertEquals(4096, childChannel.bytesBeforeUnwritable());\n\n        // Flush everything which simulate writing everything to the socket.\n        parentChannel.flush();\n        assertTrue(parentChannel.isWritable());\n        assertTrue(childChannel.isWritable());\n        assertEquals(bytesBeforeUnwritable, childChannel.bytesBeforeUnwritable());\n\n        ChannelFuture future = childChannel.writeAndFlush(new DefaultHttp2DataFrame(\n                Unpooled.buffer().writeZero((int) bytesBeforeUnwritable)));\n        assertFalse(childChannel.isWritable());\n        assertTrue(parentChannel.isWritable());\n\n        parentChannel.flush();\n        assertFalse(future.isDone());\n        assertTrue(parentChannel.isWritable());\n        assertFalse(childChannel.isWritable());\n\n        // Now write an window update frame for the stream which then should ensure we will flush the bytes that were\n        // queued in the RemoteFlowController before for the stream.\n        frameInboundWriter.writeInboundWindowUpdate(childChannel.stream().id(), (int) bytesBeforeUnwritable);\n        assertTrue(childChannel.isWritable());\n        assertTrue(future.isDone());\n    }\n\n    @Test\n    public void channelClosedWhenInactiveFired() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n\n        final AtomicBoolean channelOpen = new AtomicBoolean(false);\n        final AtomicBoolean channelActive = new AtomicBoolean(false);\n        assertTrue(childChannel.isOpen());\n        assertTrue(childChannel.isActive());\n\n        childChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                channelOpen.set(ctx.channel().isOpen());\n                channelActive.set(ctx.channel().isActive());\n\n                super.channelInactive(ctx);\n            }\n        });\n\n        childChannel.close().syncUninterruptibly();\n        assertFalse(channelOpen.get());\n        assertFalse(channelActive.get());\n    }\n\n    @Test\n    public void channelInactiveHappensAfterExceptionCaughtEvents() throws Exception {\n        final AtomicInteger count = new AtomicInteger(0);\n        final AtomicInteger exceptionCaught = new AtomicInteger(-1);\n        final AtomicInteger channelInactive = new AtomicInteger(-1);\n        final AtomicInteger channelUnregistered = new AtomicInteger(-1);\n        Http2StreamChannel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter() {\n\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n                ctx.close();\n                throw new Exception(\"exception\");\n            }\n        });\n\n        childChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n\n            @Override\n            public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                channelInactive.set(count.getAndIncrement());\n                super.channelInactive(ctx);\n            }\n\n            @Override\n            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n                exceptionCaught.set(count.getAndIncrement());\n                super.exceptionCaught(ctx, cause);\n            }\n\n            @Override\n            public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n                channelUnregistered.set(count.getAndIncrement());\n                super.channelUnregistered(ctx);\n            }\n        });\n\n        childChannel.pipeline().fireUserEventTriggered(new Object());\n        parentChannel.runPendingTasks();\n\n        // The events should have happened in this order because the inactive and deregistration events\n        // get deferred as they do in the AbstractChannel.\n        assertEquals(0, exceptionCaught.get());\n        assertEquals(1, channelInactive.get());\n        assertEquals(2, channelUnregistered.get());\n    }\n\n    @Test\n    public void callUnsafeCloseMultipleTimes() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n        childChannel.unsafe().close(childChannel.voidPromise());\n\n        ChannelPromise promise = childChannel.newPromise();\n        childChannel.unsafe().close(promise);\n        promise.syncUninterruptibly();\n        childChannel.closeFuture().syncUninterruptibly();\n    }\n\n    @Test\n    public void endOfStreamDoesNotDiscardData() {\n        AtomicInteger numReads = new AtomicInteger(1);\n        final AtomicBoolean shouldDisableAutoRead = new AtomicBoolean();\n        Consumer<ChannelHandlerContext> ctxConsumer = new Consumer<ChannelHandlerContext>() {\n            @Override\n            public void accept(ChannelHandlerContext obj) {\n                if (shouldDisableAutoRead.get()) {\n                    obj.channel().config().setAutoRead(false);\n                }\n            }\n        };\n        LastInboundHandler inboundHandler = new LastInboundHandler(ctxConsumer);\n        Http2StreamChannel childChannel = newInboundStream(3, false, numReads, inboundHandler);\n        childChannel.config().setAutoRead(false);\n\n        Http2DataFrame dataFrame1 = new DefaultHttp2DataFrame(bb(\"1\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame2 = new DefaultHttp2DataFrame(bb(\"2\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame3 = new DefaultHttp2DataFrame(bb(\"3\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame4 = new DefaultHttp2DataFrame(bb(\"4\")).stream(childChannel.stream());\n\n        assertEquals(new DefaultHttp2HeadersFrame(request).stream(childChannel.stream()), inboundHandler.readInbound());\n\n        ChannelHandler readCompleteSupressHandler = new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelReadComplete(ChannelHandlerContext ctx) {\n                // We want to simulate the parent channel calling channelRead and delay calling channelReadComplete.\n            }\n        };\n\n        parentChannel.pipeline().addFirst(readCompleteSupressHandler);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"1\"), 0, false);\n\n        assertEqualsAndRelease(dataFrame1, inboundHandler.<Http2DataFrame>readInbound());\n\n        // Deliver frames, and then a stream closed while read is inactive.\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"2\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"3\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"4\"), 0, false);\n\n        shouldDisableAutoRead.set(true);\n        childChannel.config().setAutoRead(true);\n        numReads.set(1);\n\n        frameInboundWriter.writeInboundRstStream(childChannel.stream().id(), Http2Error.NO_ERROR.code());\n\n        // Detecting EOS should flush all pending data regardless of read calls.\n        assertEqualsAndRelease(dataFrame2, inboundHandler.<Http2DataFrame>readInbound());\n        assertNull(inboundHandler.readInbound());\n\n        // As we limited the number to 1 we also need to call read() again.\n        childChannel.read();\n\n        assertEqualsAndRelease(dataFrame3, inboundHandler.<Http2DataFrame>readInbound());\n        assertEqualsAndRelease(dataFrame4, inboundHandler.<Http2DataFrame>readInbound());\n\n        Http2ResetFrame resetFrame = useUserEventForResetFrame() ? inboundHandler.<Http2ResetFrame>readUserEvent() :\n                inboundHandler.<Http2ResetFrame>readInbound();\n\n        assertEquals(childChannel.stream(), resetFrame.stream());\n        assertEquals(Http2Error.NO_ERROR.code(), resetFrame.errorCode());\n\n        assertNull(inboundHandler.readInbound());\n\n        // Now we want to call channelReadComplete and simulate the end of the read loop.\n        parentChannel.pipeline().remove(readCompleteSupressHandler);\n        parentChannel.flushInbound();\n\n        childChannel.closeFuture().syncUninterruptibly();\n    }\n\n    protected abstract boolean useUserEventForResetFrame();\n\n    protected abstract boolean ignoreWindowUpdateFrames();\n\n    @Test\n    public void windowUpdateFrames() {\n        AtomicInteger numReads = new AtomicInteger(1);\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, numReads, inboundHandler);\n\n        assertEquals(new DefaultHttp2HeadersFrame(request).stream(childChannel.stream()), inboundHandler.readInbound());\n\n        frameInboundWriter.writeInboundWindowUpdate(childChannel.stream().id(), 4);\n\n        Http2WindowUpdateFrame updateFrame = inboundHandler.readInbound();\n        if (ignoreWindowUpdateFrames()) {\n            assertNull(updateFrame);\n        } else {\n            assertEquals(new DefaultHttp2WindowUpdateFrame(4).stream(childChannel.stream()), updateFrame);\n        }\n\n        frameInboundWriter.writeInboundWindowUpdate(Http2CodecUtil.CONNECTION_STREAM_ID, 6);\n\n        assertNull(parentChannel.readInbound());\n        childChannel.close().syncUninterruptibly();\n    }\n\n    @Test\n    public void childQueueIsDrainedAndNewDataIsDispatchedInParentReadLoopAutoRead() {\n        AtomicInteger numReads = new AtomicInteger(1);\n        final AtomicInteger channelReadCompleteCount = new AtomicInteger(0);\n        final AtomicBoolean shouldDisableAutoRead = new AtomicBoolean();\n        Consumer<ChannelHandlerContext> ctxConsumer = new Consumer<ChannelHandlerContext>() {\n            @Override\n            public void accept(ChannelHandlerContext obj) {\n                channelReadCompleteCount.incrementAndGet();\n                if (shouldDisableAutoRead.get()) {\n                    obj.channel().config().setAutoRead(false);\n                }\n            }\n        };\n        LastInboundHandler inboundHandler = new LastInboundHandler(ctxConsumer);\n        Http2StreamChannel childChannel = newInboundStream(3, false, numReads, inboundHandler);\n        childChannel.config().setAutoRead(false);\n\n        Http2DataFrame dataFrame1 = new DefaultHttp2DataFrame(bb(\"1\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame2 = new DefaultHttp2DataFrame(bb(\"2\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame3 = new DefaultHttp2DataFrame(bb(\"3\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame4 = new DefaultHttp2DataFrame(bb(\"4\")).stream(childChannel.stream());\n\n        assertEquals(new DefaultHttp2HeadersFrame(request).stream(childChannel.stream()), inboundHandler.readInbound());\n\n        ChannelHandler readCompleteSupressHandler = new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelReadComplete(ChannelHandlerContext ctx) {\n                // We want to simulate the parent channel calling channelRead and delay calling channelReadComplete.\n            }\n        };\n        parentChannel.pipeline().addFirst(readCompleteSupressHandler);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"1\"), 0, false);\n\n        assertEqualsAndRelease(dataFrame1, inboundHandler.<Http2DataFrame>readInbound());\n\n        // We want one item to be in the queue, and allow the numReads to be larger than 1. This will ensure that\n        // when beginRead() is called the child channel is added to the readPending queue of the parent channel.\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"2\"), 0, false);\n\n        numReads.set(10);\n        shouldDisableAutoRead.set(true);\n        childChannel.config().setAutoRead(true);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"3\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"4\"), 0, false);\n\n        // Detecting EOS should flush all pending data regardless of read calls.\n        assertEqualsAndRelease(dataFrame2, inboundHandler.<Http2DataFrame>readInbound());\n        assertEqualsAndRelease(dataFrame3, inboundHandler.<Http2DataFrame>readInbound());\n        assertEqualsAndRelease(dataFrame4, inboundHandler.<Http2DataFrame>readInbound());\n\n        assertNull(inboundHandler.readInbound());\n\n        // Now we want to call channelReadComplete and simulate the end of the read loop.\n        parentChannel.pipeline().remove(readCompleteSupressHandler);\n        parentChannel.flushInbound();\n\n        // 3 = 1 for initialization + 1 for read when auto read was off + 1 for when auto read was back on\n        assertEquals(3, channelReadCompleteCount.get());\n    }\n\n    @Test\n    public void childQueueIsDrainedAndNewDataIsDispatchedInParentReadLoopNoAutoRead() {\n        final AtomicInteger numReads = new AtomicInteger(1);\n        final AtomicInteger channelReadCompleteCount = new AtomicInteger(0);\n        final AtomicBoolean shouldDisableAutoRead = new AtomicBoolean();\n        Consumer<ChannelHandlerContext> ctxConsumer = new Consumer<ChannelHandlerContext>() {\n            @Override\n            public void accept(ChannelHandlerContext obj) {\n                channelReadCompleteCount.incrementAndGet();\n                if (shouldDisableAutoRead.get()) {\n                    obj.channel().config().setAutoRead(false);\n                }\n            }\n        };\n        final LastInboundHandler inboundHandler = new LastInboundHandler(ctxConsumer);\n        Http2StreamChannel childChannel = newInboundStream(3, false, numReads, inboundHandler);\n        childChannel.config().setAutoRead(false);\n\n        Http2DataFrame dataFrame1 = new DefaultHttp2DataFrame(bb(\"1\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame2 = new DefaultHttp2DataFrame(bb(\"2\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame3 = new DefaultHttp2DataFrame(bb(\"3\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame4 = new DefaultHttp2DataFrame(bb(\"4\")).stream(childChannel.stream());\n\n        assertEquals(new DefaultHttp2HeadersFrame(request).stream(childChannel.stream()), inboundHandler.readInbound());\n\n        ChannelHandler readCompleteSupressHandler = new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n                // We want to simulate the parent channel calling channelRead and delay calling channelReadComplete.\n            }\n        };\n        parentChannel.pipeline().addFirst(readCompleteSupressHandler);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"1\"), 0, false);\n\n        assertEqualsAndRelease(dataFrame1, inboundHandler.<Http2Frame>readInbound());\n\n        // We want one item to be in the queue, and allow the numReads to be larger than 1. This will ensure that\n        // when beginRead() is called the child channel is added to the readPending queue of the parent channel.\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"2\"), 0, false);\n\n        numReads.set(2);\n        childChannel.read();\n\n        assertEqualsAndRelease(dataFrame2, inboundHandler.<Http2Frame>readInbound());\n\n        assertNull(inboundHandler.readInbound());\n\n        // This is the second item that was read, this should be the last until we call read() again. This should also\n        // notify of readComplete().\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"3\"), 0, false);\n\n        assertEqualsAndRelease(dataFrame3, inboundHandler.<Http2Frame>readInbound());\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"4\"), 0, false);\n        assertNull(inboundHandler.readInbound());\n\n        childChannel.read();\n\n        assertEqualsAndRelease(dataFrame4, inboundHandler.<Http2Frame>readInbound());\n\n        assertNull(inboundHandler.readInbound());\n\n        // Now we want to call channelReadComplete and simulate the end of the read loop.\n        parentChannel.pipeline().remove(readCompleteSupressHandler);\n        parentChannel.flushInbound();\n\n        // 3 = 1 for initialization + 1 for first read of 2 items + 1 for second read of 2 items +\n        // 1 for parent channel readComplete\n        assertEquals(4, channelReadCompleteCount.get());\n    }\n\n    @Test\n    public void useReadWithoutAutoReadInRead() {\n        useReadWithoutAutoReadBuffered(false);\n    }\n\n    @Test\n    public void useReadWithoutAutoReadInReadComplete() {\n        useReadWithoutAutoReadBuffered(true);\n    }\n\n    private void useReadWithoutAutoReadBuffered(final boolean triggerOnReadComplete) {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n        assertTrue(childChannel.config().isAutoRead());\n        childChannel.config().setAutoRead(false);\n        assertFalse(childChannel.config().isAutoRead());\n\n        Http2HeadersFrame headersFrame = inboundHandler.readInbound();\n        assertNotNull(headersFrame);\n\n        // Write some bytes to get the channel into the idle state with buffered data and also verify we\n        // do not dispatch it until we receive a read() call.\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"hello world\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"foo\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar\"), 0, false);\n\n        // Add a handler which will request reads.\n        childChannel.pipeline().addFirst(new ChannelInboundHandlerAdapter() {\n\n            @Override\n            public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n                super.channelReadComplete(ctx);\n                if (triggerOnReadComplete) {\n                    ctx.read();\n                    ctx.read();\n                }\n            }\n\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                ctx.fireChannelRead(msg);\n                if (!triggerOnReadComplete) {\n                    ctx.read();\n                    ctx.read();\n                }\n            }\n        });\n\n        inboundHandler.channel().read();\n\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 3);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"hello world2\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"foo2\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar2\"), 0, true);\n\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 3);\n    }\n\n    private static final class FlushSniffer extends ChannelOutboundHandlerAdapter {\n\n        private boolean didFlush;\n\n        public boolean checkFlush() {\n            boolean r = didFlush;\n            didFlush = false;\n            return r;\n        }\n\n        @Override\n        public void flush(ChannelHandlerContext ctx) throws Exception {\n            didFlush = true;\n            super.flush(ctx);\n        }\n    }\n\n    @Test\n    public void windowUpdatesAreFlushed() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        FlushSniffer flushSniffer = new FlushSniffer();\n        parentChannel.pipeline().addFirst(flushSniffer);\n\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n        assertTrue(childChannel.config().isAutoRead());\n        childChannel.config().setAutoRead(false);\n        assertFalse(childChannel.config().isAutoRead());\n\n        Http2HeadersFrame headersFrame = inboundHandler.readInbound();\n        assertNotNull(headersFrame);\n\n        assertTrue(flushSniffer.checkFlush());\n\n        // Write some bytes to get the channel into the idle state with buffered data and also verify we\n        // do not dispatch it until we receive a read() call.\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(16 * 1024), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(16 * 1024), 0, false);\n        assertTrue(flushSniffer.checkFlush());\n\n        verify(frameWriter, never()).writeWindowUpdate(eqCodecCtx(), anyInt(), anyInt(), anyChannelPromise());\n        // only the first one was read because it was legacy auto-read behavior.\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 1);\n        assertFalse(flushSniffer.checkFlush());\n\n        // Trigger a read of the second frame.\n        childChannel.read();\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 1);\n        // We expect a flush here because the StreamChannel will flush the smaller increment but the\n        // connection will collect the bytes and decide not to send a wire level frame until more are consumed.\n        assertTrue(flushSniffer.checkFlush());\n        verify(frameWriter, never()).writeWindowUpdate(eqCodecCtx(), anyInt(), anyInt(), anyChannelPromise());\n\n        // Call read one more time which should trigger the writing of the flow control update.\n        childChannel.read();\n        verify(frameWriter).writeWindowUpdate(eqCodecCtx(), eq(0), eq(32 * 1024), anyChannelPromise());\n        verify(frameWriter).writeWindowUpdate(\n            eqCodecCtx(), eq(childChannel.stream().id()), eq(32 * 1024), anyChannelPromise());\n        assertTrue(flushSniffer.checkFlush());\n    }\n\n    private static void verifyFramesMultiplexedToCorrectChannel(Http2StreamChannel streamChannel,\n                                                                LastInboundHandler inboundHandler,\n                                                                int numFrames) {\n        for (int i = 0; i < numFrames; i++) {\n            Http2StreamFrame frame = inboundHandler.readInbound();\n            assertNotNull(i + \" out of \" + numFrames + \" received\", frame);\n            assertEquals(streamChannel.stream(), frame.stream());\n            release(frame);\n        }\n        assertNull(inboundHandler.readInbound());\n    }\n\n    private static int eqStreamId(Http2StreamChannel channel) {\n        return eq(channel.stream().id());\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at:\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage io.netty.handler.codec.http2;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpStatusClass;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http2.Http2Connection.Endpoint;\nimport io.netty.util.internal.SystemPropertyUtil;\nimport io.netty.util.internal.UnstableApi;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.util.List;\n\nimport static io.netty.handler.codec.http.HttpStatusClass.INFORMATIONAL;\nimport static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;\nimport static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;\nimport static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;\nimport static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;\nimport static io.netty.handler.codec.http2.Http2Exception.connectionError;\nimport static io.netty.handler.codec.http2.Http2Exception.streamError;\nimport static io.netty.handler.codec.http2.Http2PromisedRequestVerifier.ALWAYS_VERIFY;\nimport static io.netty.handler.codec.http2.Http2Stream.State.CLOSED;\nimport static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_REMOTE;\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\nimport static java.lang.Integer.MAX_VALUE;\nimport static java.lang.Math.min;\n\n/**\n * Provides the default implementation for processing inbound frame events and delegates to a\n * {@link Http2FrameListener}\n * <p>\n * This class will read HTTP/2 frames and delegate the events to a {@link Http2FrameListener}\n * <p>\n * This interface enforces inbound flow control functionality through\n * {@link Http2LocalFlowController}\n */\n@UnstableApi\npublic class DefaultHttp2ConnectionDecoder implements Http2ConnectionDecoder {\n    private static final boolean VALIDATE_CONTENT_LENGTH =\n            SystemPropertyUtil.getBoolean(\"io.netty.http2.validateContentLength\", true);\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultHttp2ConnectionDecoder.class);\n    private Http2FrameListener internalFrameListener = new PrefaceFrameListener();\n    private final Http2Connection connection;\n    private Http2LifecycleManager lifecycleManager;\n    private final Http2ConnectionEncoder encoder;\n    private final Http2FrameReader frameReader;\n    private Http2FrameListener listener;\n    private final Http2PromisedRequestVerifier requestVerifier;\n    private final Http2SettingsReceivedConsumer settingsReceivedConsumer;\n    private final boolean autoAckPing;\n    private final Http2Connection.PropertyKey contentLengthKey;\n\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader) {\n        this(connection, encoder, frameReader, ALWAYS_VERIFY);\n    }\n\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader,\n                                         Http2PromisedRequestVerifier requestVerifier) {\n        this(connection, encoder, frameReader, requestVerifier, true);\n    }\n\n    /**\n     * Create a new instance.\n     * @param connection The {@link Http2Connection} associated with this decoder.\n     * @param encoder The {@link Http2ConnectionEncoder} associated with this decoder.\n     * @param frameReader Responsible for reading/parsing the raw frames. As opposed to this object which applies\n     *                    h2 semantics on top of the frames.\n     * @param requestVerifier Determines if push promised streams are valid.\n     * @param autoAckSettings {@code false} to disable automatically applying and sending settings acknowledge frame.\n     *  The {@code Http2ConnectionEncoder} is expected to be an instance of {@link Http2SettingsReceivedConsumer} and\n     *  will apply the earliest received but not yet ACKed SETTINGS when writing the SETTINGS ACKs.\n     * {@code true} to enable automatically applying and sending settings acknowledge frame.\n     */\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader,\n                                         Http2PromisedRequestVerifier requestVerifier,\n                                         boolean autoAckSettings) {\n        this(connection, encoder, frameReader, requestVerifier, autoAckSettings, true);\n    }\n\n    /**\n     * Create a new instance.\n     * @param connection The {@link Http2Connection} associated with this decoder.\n     * @param encoder The {@link Http2ConnectionEncoder} associated with this decoder.\n     * @param frameReader Responsible for reading/parsing the raw frames. As opposed to this object which applies\n     *                    h2 semantics on top of the frames.\n     * @param requestVerifier Determines if push promised streams are valid.\n     * @param autoAckSettings {@code false} to disable automatically applying and sending settings acknowledge frame.\n     *                        The {@code Http2ConnectionEncoder} is expected to be an instance of\n     *                        {@link Http2SettingsReceivedConsumer} and will apply the earliest received but not yet\n     *                        ACKed SETTINGS when writing the SETTINGS ACKs. {@code true} to enable automatically\n     *                        applying and sending settings acknowledge frame.\n     * @param autoAckPing {@code false} to disable automatically sending ping acknowledge frame. {@code true} to enable\n     *                    automatically sending ping ack frame.\n     */\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader,\n                                         Http2PromisedRequestVerifier requestVerifier,\n                                         boolean autoAckSettings,\n                                         boolean autoAckPing) {\n        this.autoAckPing = autoAckPing;\n        if (autoAckSettings) {\n            settingsReceivedConsumer = null;\n        } else {\n            if (!(encoder instanceof Http2SettingsReceivedConsumer)) {\n                throw new IllegalArgumentException(\"disabling autoAckSettings requires the encoder to be a \" +\n                        Http2SettingsReceivedConsumer.class);\n            }\n            settingsReceivedConsumer = (Http2SettingsReceivedConsumer) encoder;\n        }\n        this.connection = checkNotNull(connection, \"connection\");\n        contentLengthKey = this.connection.newKey();\n        this.frameReader = checkNotNull(frameReader, \"frameReader\");\n        this.encoder = checkNotNull(encoder, \"encoder\");\n        this.requestVerifier = checkNotNull(requestVerifier, \"requestVerifier\");\n        if (connection.local().flowController() == null) {\n            connection.local().flowController(new DefaultHttp2LocalFlowController(connection));\n        }\n        connection.local().flowController().frameWriter(encoder.frameWriter());\n    }\n\n    @Override\n    public void lifecycleManager(Http2LifecycleManager lifecycleManager) {\n        this.lifecycleManager = checkNotNull(lifecycleManager, \"lifecycleManager\");\n    }\n\n    @Override\n    public Http2Connection connection() {\n        return connection;\n    }\n\n    @Override\n    public final Http2LocalFlowController flowController() {\n        return connection.local().flowController();\n    }\n\n    @Override\n    public void frameListener(Http2FrameListener listener) {\n        this.listener = checkNotNull(listener, \"listener\");\n    }\n\n    @Override\n    public Http2FrameListener frameListener() {\n        return listener;\n    }\n\n    // Visible for testing\n    Http2FrameListener internalFrameListener() {\n        return internalFrameListener;\n    }\n\n    @Override\n    public boolean prefaceReceived() {\n        return FrameReadListener.class == internalFrameListener.getClass();\n    }\n\n    @Override\n    public void decodeFrame(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Http2Exception {\n        frameReader.readFrame(ctx, in, internalFrameListener);\n    }\n\n    @Override\n    public Http2Settings localSettings() {\n        Http2Settings settings = new Http2Settings();\n        Http2FrameReader.Configuration config = frameReader.configuration();\n        Http2HeadersDecoder.Configuration headersConfig = config.headersConfiguration();\n        Http2FrameSizePolicy frameSizePolicy = config.frameSizePolicy();\n        settings.initialWindowSize(flowController().initialWindowSize());\n        settings.maxConcurrentStreams(connection.remote().maxActiveStreams());\n        settings.headerTableSize(headersConfig.maxHeaderTableSize());\n        settings.maxFrameSize(frameSizePolicy.maxFrameSize());\n        settings.maxHeaderListSize(headersConfig.maxHeaderListSize());\n        if (!connection.isServer()) {\n            // Only set the pushEnabled flag if this is a client endpoint.\n            settings.pushEnabled(connection.local().allowPushTo());\n        }\n        return settings;\n    }\n\n    @Override\n    public void close() {\n        frameReader.close();\n    }\n\n    /**\n     * Calculate the threshold in bytes which should trigger a {@code GO_AWAY} if a set of headers exceeds this amount.\n     * @param maxHeaderListSize\n     *      <a href=\"https://tools.ietf.org/html/rfc7540#section-6.5.2\">SETTINGS_MAX_HEADER_LIST_SIZE</a> for the local\n     *      endpoint.\n     * @return the threshold in bytes which should trigger a {@code GO_AWAY} if a set of headers exceeds this amount.\n     */\n    protected long calculateMaxHeaderListSizeGoAway(long maxHeaderListSize) {\n        return Http2CodecUtil.calculateMaxHeaderListSizeGoAway(maxHeaderListSize);\n    }\n\n    private int unconsumedBytes(Http2Stream stream) {\n        return flowController().unconsumedBytes(stream);\n    }\n\n    void onGoAwayRead0(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)\n            throws Http2Exception {\n        listener.onGoAwayRead(ctx, lastStreamId, errorCode, debugData);\n        connection.goAwayReceived(lastStreamId, errorCode, debugData);\n    }\n\n    void onUnknownFrame0(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,\n            ByteBuf payload) throws Http2Exception {\n        listener.onUnknownFrame(ctx, frameType, streamId, flags, payload);\n    }\n\n    // See https://tools.ietf.org/html/rfc7540#section-8.1.2.6\n    private void verifyContentLength(Http2Stream stream, int data, boolean isEnd) throws Http2Exception {\n        if (!VALIDATE_CONTENT_LENGTH) {\n            return;\n        }\n        ContentLength contentLength = stream.getProperty(contentLengthKey);\n        if (contentLength != null) {\n            try {\n                contentLength.increaseReceivedBytes(connection.isServer(), stream.id(), data, isEnd);\n            } finally {\n                if (isEnd) {\n                    stream.removeProperty(contentLengthKey);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handles all inbound frames from the network.\n     */\n    private final class FrameReadListener implements Http2FrameListener {\n        @Override\n        public int onDataRead(final ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,\n                              boolean endOfStream) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            Http2LocalFlowController flowController = flowController();\n            int readable = data.readableBytes();\n            int bytesToReturn = readable + padding;\n\n            final boolean shouldIgnore;\n            try {\n                shouldIgnore = shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"DATA\");\n            } catch (Http2Exception e) {\n                // Ignoring this frame. We still need to count the frame towards the connection flow control\n                // window, but we immediately mark all bytes as consumed.\n                flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);\n                flowController.consumeBytes(stream, bytesToReturn);\n                throw e;\n            } catch (Throwable t) {\n                throw connectionError(INTERNAL_ERROR, t, \"Unhandled error on data stream id %d\", streamId);\n            }\n\n            if (shouldIgnore) {\n                // Ignoring this frame. We still need to count the frame towards the connection flow control\n                // window, but we immediately mark all bytes as consumed.\n                flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);\n                flowController.consumeBytes(stream, bytesToReturn);\n\n                // Verify that the stream may have existed after we apply flow control.\n                verifyStreamMayHaveExisted(streamId);\n\n                // All bytes have been consumed.\n                return bytesToReturn;\n            }\n            Http2Exception error = null;\n            switch (stream.state()) {\n                case OPEN:\n                case HALF_CLOSED_LOCAL:\n                    break;\n                case HALF_CLOSED_REMOTE:\n                case CLOSED:\n                    error = streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                        stream.id(), stream.state());\n                    break;\n                default:\n                    error = streamError(stream.id(), PROTOCOL_ERROR,\n                        \"Stream %d in unexpected state: %s\", stream.id(), stream.state());\n                    break;\n            }\n\n            int unconsumedBytes = unconsumedBytes(stream);\n            try {\n                flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);\n                // Update the unconsumed bytes after flow control is applied.\n                unconsumedBytes = unconsumedBytes(stream);\n\n                // If the stream is in an invalid state to receive the frame, throw the error.\n                if (error != null) {\n                    throw error;\n                }\n\n                verifyContentLength(stream, readable, endOfStream);\n\n                // Call back the application and retrieve the number of bytes that have been\n                // immediately processed.\n                bytesToReturn = listener.onDataRead(ctx, streamId, data, padding, endOfStream);\n\n                if (endOfStream) {\n                    lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());\n                }\n\n                return bytesToReturn;\n            } catch (Http2Exception e) {\n                // If an exception happened during delivery, the listener may have returned part\n                // of the bytes before the error occurred. If that's the case, subtract that from\n                // the total processed bytes so that we don't return too many bytes.\n                int delta = unconsumedBytes - unconsumedBytes(stream);\n                bytesToReturn -= delta;\n                throw e;\n            } catch (RuntimeException e) {\n                // If an exception happened during delivery, the listener may have returned part\n                // of the bytes before the error occurred. If that's the case, subtract that from\n                // the total processed bytes so that we don't return too many bytes.\n                int delta = unconsumedBytes - unconsumedBytes(stream);\n                bytesToReturn -= delta;\n                throw e;\n            } finally {\n                // If appropriate, return the processed bytes to the flow controller.\n                flowController.consumeBytes(stream, bytesToReturn);\n            }\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int padding,\n                boolean endOfStream) throws Http2Exception {\n            onHeadersRead(ctx, streamId, headers, 0, DEFAULT_PRIORITY_WEIGHT, false, padding, endOfStream);\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n                short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            boolean allowHalfClosedRemote = false;\n            boolean isTrailers = false;\n            if (stream == null && !connection.streamMayHaveExisted(streamId)) {\n                stream = connection.remote().createStream(streamId, endOfStream);\n                // Allow the state to be HALF_CLOSE_REMOTE if we're creating it in that state.\n                allowHalfClosedRemote = stream.state() == HALF_CLOSED_REMOTE;\n            } else if (stream != null) {\n                isTrailers = stream.isHeadersReceived();\n            }\n\n            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"HEADERS\")) {\n                return;\n            }\n\n            boolean isInformational = !connection.isServer() &&\n                    HttpStatusClass.valueOf(headers.status()) == INFORMATIONAL;\n            if ((isInformational || !endOfStream) && stream.isHeadersReceived() || stream.isTrailersReceived()) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                                  \"Stream %d received too many headers EOS: %s state: %s\",\n                                  streamId, endOfStream, stream.state());\n            }\n\n            switch (stream.state()) {\n                case RESERVED_REMOTE:\n                    stream.open(endOfStream);\n                    break;\n                case OPEN:\n                case HALF_CLOSED_LOCAL:\n                    // Allowed to receive headers in these states.\n                    break;\n                case HALF_CLOSED_REMOTE:\n                    if (!allowHalfClosedRemote) {\n                        throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                                stream.id(), stream.state());\n                    }\n                    break;\n                case CLOSED:\n                    throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                            stream.id(), stream.state());\n                default:\n                    // Connection error.\n                    throw connectionError(PROTOCOL_ERROR, \"Stream %d in unexpected state: %s\", stream.id(),\n                            stream.state());\n            }\n\n            if (!isTrailers) {\n                // extract the content-length header\n                List<? extends CharSequence> contentLength = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n                if (contentLength != null && !contentLength.isEmpty()) {\n                    try {\n                        long cLength = HttpUtil.normalizeAndGetContentLength(contentLength, false, true);\n                        if (cLength != -1) {\n                            headers.setLong(HttpHeaderNames.CONTENT_LENGTH, cLength);\n                            stream.setProperty(contentLengthKey, new ContentLength(cLength));\n                        }\n                    } catch (IllegalArgumentException e) {\n                        throw streamError(stream.id(), PROTOCOL_ERROR, e,\n                                \"Multiple content-length headers received\");\n                    }\n                }\n            }\n\n            stream.headersReceived(isInformational);\n            verifyContentLength(stream, 0, endOfStream);\n            encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive);\n            listener.onHeadersRead(ctx, streamId, headers, streamDependency,\n                    weight, exclusive, padding, endOfStream);\n            // If the headers completes this stream, close it.\n            if (endOfStream) {\n                lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());\n            }\n        }\n\n        @Override\n        public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDependency, short weight,\n                boolean exclusive) throws Http2Exception {\n            encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive);\n\n            listener.onPriorityRead(ctx, streamId, streamDependency, weight, exclusive);\n        }\n\n        @Override\n        public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            if (stream == null) {\n                verifyStreamMayHaveExisted(streamId);\n                return;\n            }\n\n            switch(stream.state()) {\n            case IDLE:\n                throw connectionError(PROTOCOL_ERROR, \"RST_STREAM received for IDLE stream %d\", streamId);\n            case CLOSED:\n                return; // RST_STREAM frames must be ignored for closed streams.\n            default:\n                break;\n            }\n\n            listener.onRstStreamRead(ctx, streamId, errorCode);\n\n            lifecycleManager.closeStream(stream, ctx.newSucceededFuture());\n        }\n\n        @Override\n        public void onSettingsAckRead(ChannelHandlerContext ctx) throws Http2Exception {\n            // Apply oldest outstanding local settings here. This is a synchronization point between endpoints.\n            Http2Settings settings = encoder.pollSentSettings();\n\n            if (settings != null) {\n                applyLocalSettings(settings);\n            }\n\n            listener.onSettingsAckRead(ctx);\n        }\n\n        /**\n         * Applies settings sent from the local endpoint.\n         * <p>\n         * This method is only called after the local settings have been acknowledged from the remote endpoint.\n         */\n        private void applyLocalSettings(Http2Settings settings) throws Http2Exception {\n            Boolean pushEnabled = settings.pushEnabled();\n            final Http2FrameReader.Configuration config = frameReader.configuration();\n            final Http2HeadersDecoder.Configuration headerConfig = config.headersConfiguration();\n            final Http2FrameSizePolicy frameSizePolicy = config.frameSizePolicy();\n            if (pushEnabled != null) {\n                if (connection.isServer()) {\n                    throw connectionError(PROTOCOL_ERROR, \"Server sending SETTINGS frame with ENABLE_PUSH specified\");\n                }\n                connection.local().allowPushTo(pushEnabled);\n            }\n\n            Long maxConcurrentStreams = settings.maxConcurrentStreams();\n            if (maxConcurrentStreams != null) {\n                connection.remote().maxActiveStreams((int) min(maxConcurrentStreams, MAX_VALUE));\n            }\n\n            Long headerTableSize = settings.headerTableSize();\n            if (headerTableSize != null) {\n                headerConfig.maxHeaderTableSize(headerTableSize);\n            }\n\n            Long maxHeaderListSize = settings.maxHeaderListSize();\n            if (maxHeaderListSize != null) {\n                headerConfig.maxHeaderListSize(maxHeaderListSize, calculateMaxHeaderListSizeGoAway(maxHeaderListSize));\n            }\n\n            Integer maxFrameSize = settings.maxFrameSize();\n            if (maxFrameSize != null) {\n                frameSizePolicy.maxFrameSize(maxFrameSize);\n            }\n\n            Integer initialWindowSize = settings.initialWindowSize();\n            if (initialWindowSize != null) {\n                flowController().initialWindowSize(initialWindowSize);\n            }\n        }\n\n        @Override\n        public void onSettingsRead(final ChannelHandlerContext ctx, Http2Settings settings) throws Http2Exception {\n            if (settingsReceivedConsumer == null) {\n                // Acknowledge receipt of the settings. We should do this before we process the settings to ensure our\n                // remote peer applies these settings before any subsequent frames that we may send which depend upon\n                // these new settings. See https://github.com/netty/netty/issues/6520.\n                encoder.writeSettingsAck(ctx, ctx.newPromise());\n\n                encoder.remoteSettings(settings);\n            } else {\n                settingsReceivedConsumer.consumeReceivedSettings(settings);\n            }\n\n            listener.onSettingsRead(ctx, settings);\n        }\n\n        @Override\n        public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            if (autoAckPing) {\n                // Send an ack back to the remote client.\n                encoder.writePing(ctx, true, data, ctx.newPromise());\n            }\n            listener.onPingRead(ctx, data);\n        }\n\n        @Override\n        public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            listener.onPingAckRead(ctx, data);\n        }\n\n        @Override\n        public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId,\n                Http2Headers headers, int padding) throws Http2Exception {\n            // A client cannot push.\n            if (connection().isServer()) {\n                throw connectionError(PROTOCOL_ERROR, \"A client cannot push.\");\n            }\n\n            Http2Stream parentStream = connection.stream(streamId);\n\n            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, parentStream, \"PUSH_PROMISE\")) {\n                return;\n            }\n\n            switch (parentStream.state()) {\n              case OPEN:\n              case HALF_CLOSED_LOCAL:\n                  // Allowed to receive push promise in these states.\n                  break;\n              default:\n                  // Connection error.\n                  throw connectionError(PROTOCOL_ERROR,\n                      \"Stream %d in unexpected state for receiving push promise: %s\",\n                      parentStream.id(), parentStream.state());\n            }\n\n            if (!requestVerifier.isAuthoritative(ctx, headers)) {\n                throw streamError(promisedStreamId, PROTOCOL_ERROR,\n                        \"Promised request on stream %d for promised stream %d is not authoritative\",\n                        streamId, promisedStreamId);\n            }\n            if (!requestVerifier.isCacheable(headers)) {\n                throw streamError(promisedStreamId, PROTOCOL_ERROR,\n                        \"Promised request on stream %d for promised stream %d is not known to be cacheable\",\n                        streamId, promisedStreamId);\n            }\n            if (!requestVerifier.isSafe(headers)) {\n                throw streamError(promisedStreamId, PROTOCOL_ERROR,\n                        \"Promised request on stream %d for promised stream %d is not known to be safe\",\n                        streamId, promisedStreamId);\n            }\n\n            // Reserve the push stream based with a priority based on the current stream's priority.\n            connection.remote().reservePushStream(promisedStreamId, parentStream);\n\n            listener.onPushPromiseRead(ctx, streamId, promisedStreamId, headers, padding);\n        }\n\n        @Override\n        public void onGoAwayRead(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)\n                throws Http2Exception {\n            onGoAwayRead0(ctx, lastStreamId, errorCode, debugData);\n        }\n\n        @Override\n        public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeIncrement)\n                throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            if (stream == null || stream.state() == CLOSED || streamCreatedAfterGoAwaySent(streamId)) {\n                // Ignore this frame.\n                verifyStreamMayHaveExisted(streamId);\n                return;\n            }\n\n            // Update the outbound flow control window.\n            encoder.flowController().incrementWindowSize(stream, windowSizeIncrement);\n\n            listener.onWindowUpdateRead(ctx, streamId, windowSizeIncrement);\n        }\n\n        @Override\n        public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,\n                ByteBuf payload) throws Http2Exception {\n            onUnknownFrame0(ctx, frameType, streamId, flags, payload);\n        }\n\n        /**\n         * Helper method to determine if a frame that has the semantics of headers or data should be ignored for the\n         * {@code stream} (which may be {@code null}) associated with {@code streamId}.\n         */\n        private boolean shouldIgnoreHeadersOrDataFrame(ChannelHandlerContext ctx, int streamId, Http2Stream stream,\n                String frameName) throws Http2Exception {\n            if (stream == null) {\n                if (streamCreatedAfterGoAwaySent(streamId)) {\n                    logger.info(\"{} ignoring {} frame for stream {}. Stream sent after GOAWAY sent\",\n                            ctx.channel(), frameName, streamId);\n                    return true;\n                }\n\n                // Make sure it's not an out-of-order frame, like a rogue DATA frame, for a stream that could\n                // never have existed.\n                verifyStreamMayHaveExisted(streamId);\n\n                // Its possible that this frame would result in stream ID out of order creation (PROTOCOL ERROR) and its\n                // also possible that this frame is received on a CLOSED stream (STREAM_CLOSED after a RST_STREAM is\n                // sent). We don't have enough information to know for sure, so we choose the lesser of the two errors.\n                throw streamError(streamId, STREAM_CLOSED, \"Received %s frame for an unknown stream %d\",\n                                  frameName, streamId);\n            } else if (stream.isResetSent() || streamCreatedAfterGoAwaySent(streamId)) {\n                // If we have sent a reset stream it is assumed the stream will be closed after the write completes.\n                // If we have not sent a reset, but the stream was created after a GoAway this is not supported by\n                // DefaultHttp2Connection and if a custom Http2Connection is used it is assumed the lifetime is managed\n                // elsewhere so we don't close the stream or otherwise modify the stream's state.\n\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"{} ignoring {} frame for stream {}\", ctx.channel(), frameName,\n                            stream.isResetSent() ? \"RST_STREAM sent.\" :\n                                (\"Stream created after GOAWAY sent. Last known stream by peer \" +\n                                 connection.remote().lastStreamKnownByPeer()));\n                }\n\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * Helper method for determining whether or not to ignore inbound frames. A stream is considered to be created\n         * after a {@code GOAWAY} is sent if the following conditions hold:\n         * <p/>\n         * <ul>\n         *     <li>A {@code GOAWAY} must have been sent by the local endpoint</li>\n         *     <li>The {@code streamId} must identify a legitimate stream id for the remote endpoint to be creating</li>\n         *     <li>{@code streamId} is greater than the Last Known Stream ID which was sent by the local endpoint\n         *     in the last {@code GOAWAY} frame</li>\n         * </ul>\n         * <p/>\n         */\n        private boolean streamCreatedAfterGoAwaySent(int streamId) {\n            Endpoint<?> remote = connection.remote();\n            return connection.goAwaySent() && remote.isValidStreamId(streamId) &&\n                    streamId > remote.lastStreamKnownByPeer();\n        }\n\n        private void verifyStreamMayHaveExisted(int streamId) throws Http2Exception {\n            if (!connection.streamMayHaveExisted(streamId)) {\n                throw connectionError(PROTOCOL_ERROR, \"Stream %d does not exist\", streamId);\n            }\n        }\n    }\n\n    private final class PrefaceFrameListener implements Http2FrameListener {\n        /**\n         * Verifies that the HTTP/2 connection preface has been received from the remote endpoint.\n         * It is possible that the current call to\n         * {@link Http2FrameReader#readFrame(ChannelHandlerContext, ByteBuf, Http2FrameListener)} will have multiple\n         * frames to dispatch. So it may be OK for this class to get legitimate frames for the first readFrame.\n         */\n        private void verifyPrefaceReceived() throws Http2Exception {\n            if (!prefaceReceived()) {\n                throw connectionError(PROTOCOL_ERROR, \"Received non-SETTINGS as first frame.\");\n            }\n        }\n\n        @Override\n        public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream)\n                throws Http2Exception {\n            verifyPrefaceReceived();\n            return internalFrameListener.onDataRead(ctx, streamId, data, padding, endOfStream);\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int padding,\n                boolean endOfStream) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onHeadersRead(ctx, streamId, headers, padding, endOfStream);\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n                short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onHeadersRead(ctx, streamId, headers, streamDependency, weight,\n                    exclusive, padding, endOfStream);\n        }\n\n        @Override\n        public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDependency, short weight,\n                boolean exclusive) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPriorityRead(ctx, streamId, streamDependency, weight, exclusive);\n        }\n\n        @Override\n        public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onRstStreamRead(ctx, streamId, errorCode);\n        }\n\n        @Override\n        public void onSettingsAckRead(ChannelHandlerContext ctx) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onSettingsAckRead(ctx);\n        }\n\n        @Override\n        public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) throws Http2Exception {\n            // The first settings should change the internalFrameListener to the \"real\" listener\n            // that expects the preface to be verified.\n            if (!prefaceReceived()) {\n                internalFrameListener = new FrameReadListener();\n            }\n            internalFrameListener.onSettingsRead(ctx, settings);\n        }\n\n        @Override\n        public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPingRead(ctx, data);\n        }\n\n        @Override\n        public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPingAckRead(ctx, data);\n        }\n\n        @Override\n        public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId,\n                Http2Headers headers, int padding) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPushPromiseRead(ctx, streamId, promisedStreamId, headers, padding);\n        }\n\n        @Override\n        public void onGoAwayRead(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)\n                throws Http2Exception {\n            onGoAwayRead0(ctx, lastStreamId, errorCode, debugData);\n        }\n\n        @Override\n        public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeIncrement)\n                throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onWindowUpdateRead(ctx, streamId, windowSizeIncrement);\n        }\n\n        @Override\n        public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,\n                ByteBuf payload) throws Http2Exception {\n            onUnknownFrame0(ctx, frameType, streamId, flags, payload);\n        }\n    }\n\n    private static final class ContentLength {\n        private final long expected;\n        private long seen;\n\n        ContentLength(long expected) {\n            this.expected = expected;\n        }\n\n        void increaseReceivedBytes(boolean server, int streamId, int bytes, boolean isEnd) throws Http2Exception {\n            seen += bytes;\n            // Check for overflow\n            if (seen < 0) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                        \"Received amount of data did overflow and so not match content-length header %d\", expected);\n            }\n            // Check if we received more data then what was advertised via the content-length header.\n            if (seen > expected) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                        \"Received amount of data %d does not match content-length header %d\", seen, expected);\n            }\n\n            if (isEnd) {\n                if (seen == 0 && !server) {\n                    // This may be a response to a HEAD request, let's just allow it.\n                    return;\n                }\n\n                // Check that we really saw what was told via the content-length header.\n                if (expected > seen) {\n                    throw streamError(streamId, PROTOCOL_ERROR,\n                            \"Received amount of data %d does not match content-length header %d\", seen, expected);\n                }\n            }\n        }\n    }\n}\n", "/*\n * Copyright 2016 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at:\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage io.netty.handler.codec.http2;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.channel.ChannelOutboundHandlerAdapter;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.WriteBufferWaterMark;\nimport io.netty.channel.embedded.EmbeddedChannel;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpScheme;\nimport io.netty.handler.codec.http2.Http2Exception.StreamException;\nimport io.netty.handler.codec.http2.LastInboundHandler.Consumer;\nimport io.netty.util.AsciiString;\nimport io.netty.util.AttributeKey;\nimport org.hamcrest.CoreMatchers;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.ArgumentMatcher;\nimport org.mockito.Mockito;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\nimport java.net.InetSocketAddress;\nimport java.nio.channels.ClosedChannelException;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static io.netty.handler.codec.http2.Http2TestUtil.anyChannelPromise;\nimport static io.netty.handler.codec.http2.Http2TestUtil.anyHttp2Settings;\nimport static io.netty.handler.codec.http2.Http2TestUtil.assertEqualsAndRelease;\nimport static io.netty.handler.codec.http2.Http2TestUtil.bb;\nimport static io.netty.util.ReferenceCountUtil.release;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.anyBoolean;\nimport static org.mockito.ArgumentMatchers.anyInt;\nimport static org.mockito.ArgumentMatchers.anyLong;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic abstract class Http2MultiplexTest<C extends Http2FrameCodec> {\n    private final Http2Headers request = new DefaultHttp2Headers()\n            .method(HttpMethod.GET.asciiName()).scheme(HttpScheme.HTTPS.name())\n            .authority(new AsciiString(\"example.org\")).path(new AsciiString(\"/foo\"));\n\n    private EmbeddedChannel parentChannel;\n    private Http2FrameWriter frameWriter;\n    private Http2FrameInboundWriter frameInboundWriter;\n    private TestChannelInitializer childChannelInitializer;\n    private C codec;\n\n    private static final int initialRemoteStreamWindow = 1024;\n\n    protected abstract C newCodec(TestChannelInitializer childChannelInitializer,  Http2FrameWriter frameWriter);\n    protected abstract ChannelHandler newMultiplexer(TestChannelInitializer childChannelInitializer);\n\n    @Before\n    public void setUp() {\n        childChannelInitializer = new TestChannelInitializer();\n        parentChannel = new EmbeddedChannel();\n        frameInboundWriter = new Http2FrameInboundWriter(parentChannel);\n        parentChannel.connect(new InetSocketAddress(0));\n        frameWriter = Http2TestUtil.mockedFrameWriter();\n        codec = newCodec(childChannelInitializer, frameWriter);\n        parentChannel.pipeline().addLast(codec);\n        ChannelHandler multiplexer = newMultiplexer(childChannelInitializer);\n        if (multiplexer != null) {\n            parentChannel.pipeline().addLast(multiplexer);\n        }\n\n        parentChannel.runPendingTasks();\n        parentChannel.pipeline().fireChannelActive();\n\n        parentChannel.writeInbound(Http2CodecUtil.connectionPrefaceBuf());\n\n        Http2Settings settings = new Http2Settings().initialWindowSize(initialRemoteStreamWindow);\n        frameInboundWriter.writeInboundSettings(settings);\n\n        verify(frameWriter).writeSettingsAck(eqCodecCtx(), anyChannelPromise());\n\n        frameInboundWriter.writeInboundSettingsAck();\n\n        Http2SettingsFrame settingsFrame = parentChannel.readInbound();\n        assertNotNull(settingsFrame);\n        Http2SettingsAckFrame settingsAckFrame = parentChannel.readInbound();\n        assertNotNull(settingsAckFrame);\n\n        // Handshake\n        verify(frameWriter).writeSettings(eqCodecCtx(),\n                anyHttp2Settings(), anyChannelPromise());\n    }\n\n    private ChannelHandlerContext eqCodecCtx() {\n        return eq(codec.ctx);\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        if (childChannelInitializer.handler instanceof LastInboundHandler) {\n            ((LastInboundHandler) childChannelInitializer.handler).finishAndReleaseAll();\n        }\n        parentChannel.finishAndReleaseAll();\n        codec = null;\n    }\n\n    // TODO(buchgr): Flush from child channel\n    // TODO(buchgr): ChildChannel.childReadComplete()\n    // TODO(buchgr): GOAWAY Logic\n    // TODO(buchgr): Test ChannelConfig.setMaxMessagesPerRead\n\n    @Test\n    public void writeUnknownFrame() {\n        Http2StreamChannel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelActive(ChannelHandlerContext ctx) {\n                ctx.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));\n                ctx.writeAndFlush(new DefaultHttp2UnknownFrame((byte) 99, new Http2Flags()));\n                ctx.fireChannelActive();\n            }\n        });\n        assertTrue(childChannel.isActive());\n\n        parentChannel.runPendingTasks();\n\n        verify(frameWriter).writeFrame(eq(codec.ctx), eq((byte) 99), eqStreamId(childChannel), any(Http2Flags.class),\n                any(ByteBuf.class), any(ChannelPromise.class));\n    }\n\n    private Http2StreamChannel newInboundStream(int streamId, boolean endStream, final ChannelHandler childHandler) {\n        return newInboundStream(streamId, endStream, null, childHandler);\n    }\n\n    private Http2StreamChannel newInboundStream(int streamId, boolean endStream,\n                                                AtomicInteger maxReads, final ChannelHandler childHandler) {\n        final AtomicReference<Http2StreamChannel> streamChannelRef = new AtomicReference<Http2StreamChannel>();\n        childChannelInitializer.maxReads = maxReads;\n        childChannelInitializer.handler = new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelRegistered(ChannelHandlerContext ctx) {\n                assertNull(streamChannelRef.get());\n                streamChannelRef.set((Http2StreamChannel) ctx.channel());\n                ctx.pipeline().addLast(childHandler);\n                ctx.fireChannelRegistered();\n            }\n        };\n\n        frameInboundWriter.writeInboundHeaders(streamId, request, 0, endStream);\n        parentChannel.runPendingTasks();\n        Http2StreamChannel channel = streamChannelRef.get();\n        assertEquals(streamId, channel.stream().id());\n        return channel;\n    }\n\n    @Test\n    public void readUnkownFrame() {\n        LastInboundHandler handler = new LastInboundHandler();\n\n        Http2StreamChannel channel = newInboundStream(3, true, handler);\n        frameInboundWriter.writeInboundFrame((byte) 99, channel.stream().id(), new Http2Flags(), Unpooled.EMPTY_BUFFER);\n\n        // header frame and unknown frame\n        verifyFramesMultiplexedToCorrectChannel(channel, handler, 2);\n\n        Channel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter());\n        assertTrue(childChannel.isActive());\n    }\n\n    @Test\n    public void headerAndDataFramesShouldBeDelivered() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n\n        Http2StreamChannel channel = newInboundStream(3, false, inboundHandler);\n        Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(request).stream(channel.stream());\n        Http2DataFrame dataFrame1 = new DefaultHttp2DataFrame(bb(\"hello\")).stream(channel.stream());\n        Http2DataFrame dataFrame2 = new DefaultHttp2DataFrame(bb(\"world\")).stream(channel.stream());\n\n        assertTrue(inboundHandler.isChannelActive());\n        frameInboundWriter.writeInboundData(channel.stream().id(), bb(\"hello\"), 0, false);\n        frameInboundWriter.writeInboundData(channel.stream().id(), bb(\"world\"), 0, false);\n\n        assertEquals(headersFrame, inboundHandler.readInbound());\n\n        assertEqualsAndRelease(dataFrame1, inboundHandler.<Http2Frame>readInbound());\n        assertEqualsAndRelease(dataFrame2, inboundHandler.<Http2Frame>readInbound());\n\n        assertNull(inboundHandler.readInbound());\n    }\n\n    @Test\n    public void headerMultipleContentLengthValidationShouldPropagate() {\n        headerMultipleContentLengthValidationShouldPropagate(false);\n    }\n\n    @Test\n    public void headerMultipleContentLengthValidationShouldPropagateWithEndStream() {\n        headerMultipleContentLengthValidationShouldPropagate(true);\n    }\n\n    private void headerMultipleContentLengthValidationShouldPropagate(boolean endStream) {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        request.addLong(HttpHeaderNames.CONTENT_LENGTH, 0);\n        request.addLong(HttpHeaderNames.CONTENT_LENGTH, 1);\n        Http2StreamChannel channel = newInboundStream(3, endStream, inboundHandler);\n        try {\n            inboundHandler.checkException();\n            fail();\n        } catch (Exception e) {\n            assertThat(e, CoreMatchers.<Exception>instanceOf(StreamException.class));\n        }\n        assertNull(inboundHandler.readInbound());\n        assertFalse(channel.isActive());\n    }\n\n    @Test\n    public void headerPlusSignContentLengthValidationShouldPropagate() {\n        headerSignContentLengthValidationShouldPropagateWithEndStream(false, false);\n    }\n\n    @Test\n    public void headerPlusSignContentLengthValidationShouldPropagateWithEndStream() {\n        headerSignContentLengthValidationShouldPropagateWithEndStream(false, true);\n    }\n\n    @Test\n    public void headerMinusSignContentLengthValidationShouldPropagate() {\n        headerSignContentLengthValidationShouldPropagateWithEndStream(true, false);\n    }\n\n    @Test\n    public void headerMinusSignContentLengthValidationShouldPropagateWithEndStream() {\n        headerSignContentLengthValidationShouldPropagateWithEndStream(true, true);\n    }\n\n    private void headerSignContentLengthValidationShouldPropagateWithEndStream(boolean minus, boolean endStream) {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        request.add(HttpHeaderNames.CONTENT_LENGTH, (minus ? \"-\" : \"+\") + 1);\n        Http2StreamChannel channel = newInboundStream(3, endStream, inboundHandler);\n        try {\n            inboundHandler.checkException();\n            fail();\n        } catch (Exception e) {\n            assertThat(e, CoreMatchers.<Exception>instanceOf(StreamException.class));\n        }\n        assertNull(inboundHandler.readInbound());\n        assertFalse(channel.isActive());\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagate() {\n        headerContentLengthNotMatchValidationShouldPropagate(false, false, false);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateWithEndStream() {\n        headerContentLengthNotMatchValidationShouldPropagate(false, true, false);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateCloseLocal() {\n        headerContentLengthNotMatchValidationShouldPropagate(true, false, false);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateWithEndStreamCloseLocal() {\n        headerContentLengthNotMatchValidationShouldPropagate(true, true, false);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateTrailers() {\n        headerContentLengthNotMatchValidationShouldPropagate(false, false, true);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateWithEndStreamTrailers() {\n        headerContentLengthNotMatchValidationShouldPropagate(false, true, true);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateCloseLocalTrailers() {\n        headerContentLengthNotMatchValidationShouldPropagate(true, false, true);\n    }\n\n    @Test\n    public void headerContentLengthNotMatchValidationShouldPropagateWithEndStreamCloseLocalTrailers() {\n        headerContentLengthNotMatchValidationShouldPropagate(true, true, true);\n    }\n\n    private void headerContentLengthNotMatchValidationShouldPropagate(\n            boolean closeLocal, boolean endStream, boolean trailer) {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        request.addLong(HttpHeaderNames.CONTENT_LENGTH, 1);\n        Http2StreamChannel channel = newInboundStream(3, false, inboundHandler);\n        assertTrue(channel.isActive());\n\n        if (closeLocal) {\n            channel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers(), true))\n                    .syncUninterruptibly();\n            assertEquals(Http2Stream.State.HALF_CLOSED_LOCAL, channel.stream().state());\n        } else {\n            assertEquals(Http2Stream.State.OPEN, channel.stream().state());\n        }\n\n        if (trailer) {\n            frameInboundWriter.writeInboundHeaders(channel.stream().id(), new DefaultHttp2Headers(), 0, endStream);\n        } else {\n            frameInboundWriter.writeInboundData(channel.stream().id(), bb(\"foo\"), 0, endStream);\n        }\n        try {\n            inboundHandler.checkException();\n            fail();\n        } catch (Exception e) {\n            assertThat(e, CoreMatchers.<Exception>instanceOf(StreamException.class));\n        }\n        Http2HeadersFrame headersFrame = new DefaultHttp2HeadersFrame(request).stream(channel.stream());\n        assertEquals(headersFrame, inboundHandler.readInbound());\n        assertNull(inboundHandler.readInbound());\n        assertFalse(channel.isActive());\n    }\n\n    @Test\n    public void framesShouldBeMultiplexed() {\n        LastInboundHandler handler1 = new LastInboundHandler();\n        Http2StreamChannel channel1 = newInboundStream(3, false, handler1);\n        LastInboundHandler handler2 = new LastInboundHandler();\n        Http2StreamChannel channel2 = newInboundStream(5, false, handler2);\n        LastInboundHandler handler3 = new LastInboundHandler();\n        Http2StreamChannel channel3 = newInboundStream(11, false, handler3);\n\n        verifyFramesMultiplexedToCorrectChannel(channel1, handler1, 1);\n        verifyFramesMultiplexedToCorrectChannel(channel2, handler2, 1);\n        verifyFramesMultiplexedToCorrectChannel(channel3, handler3, 1);\n\n        frameInboundWriter.writeInboundData(channel2.stream().id(), bb(\"hello\"), 0, false);\n        frameInboundWriter.writeInboundData(channel1.stream().id(), bb(\"foo\"), 0, true);\n        frameInboundWriter.writeInboundData(channel2.stream().id(), bb(\"world\"), 0, true);\n        frameInboundWriter.writeInboundData(channel3.stream().id(), bb(\"bar\"), 0, true);\n\n        verifyFramesMultiplexedToCorrectChannel(channel1, handler1, 1);\n        verifyFramesMultiplexedToCorrectChannel(channel2, handler2, 2);\n        verifyFramesMultiplexedToCorrectChannel(channel3, handler3, 1);\n    }\n\n    @Test\n    public void inboundDataFrameShouldUpdateLocalFlowController() throws Http2Exception {\n        Http2LocalFlowController flowController = Mockito.mock(Http2LocalFlowController.class);\n        codec.connection().local().flowController(flowController);\n\n        LastInboundHandler handler = new LastInboundHandler();\n        final Http2StreamChannel channel = newInboundStream(3, false, handler);\n\n        ByteBuf tenBytes = bb(\"0123456789\");\n\n        frameInboundWriter.writeInboundData(channel.stream().id(), tenBytes, 0, true);\n\n        // Verify we marked the bytes as consumed\n        verify(flowController).consumeBytes(argThat(new ArgumentMatcher<Http2Stream>() {\n            @Override\n            public boolean matches(Http2Stream http2Stream) {\n                return http2Stream.id() == channel.stream().id();\n            }\n        }), eq(10));\n\n        // headers and data frame\n        verifyFramesMultiplexedToCorrectChannel(channel, handler, 2);\n    }\n\n    @Test\n    public void unhandledHttp2FramesShouldBePropagated() {\n        Http2PingFrame pingFrame = new DefaultHttp2PingFrame(0);\n        frameInboundWriter.writeInboundPing(false, 0);\n        assertEquals(parentChannel.readInbound(), pingFrame);\n\n        DefaultHttp2GoAwayFrame goAwayFrame = new DefaultHttp2GoAwayFrame(1,\n                parentChannel.alloc().buffer().writeLong(8));\n        frameInboundWriter.writeInboundGoAway(0, goAwayFrame.errorCode(), goAwayFrame.content().retainedDuplicate());\n\n        Http2GoAwayFrame frame = parentChannel.readInbound();\n        assertEqualsAndRelease(frame, goAwayFrame);\n    }\n\n    @Test\n    public void channelReadShouldRespectAutoRead() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n        assertTrue(childChannel.config().isAutoRead());\n        Http2HeadersFrame headersFrame = inboundHandler.readInbound();\n        assertNotNull(headersFrame);\n\n        childChannel.config().setAutoRead(false);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"hello world\"), 0, false);\n        Http2DataFrame dataFrame0 = inboundHandler.readInbound();\n        assertNotNull(dataFrame0);\n        release(dataFrame0);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"foo\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar\"), 0, false);\n\n        assertNull(inboundHandler.readInbound());\n\n        childChannel.config().setAutoRead(true);\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 2);\n    }\n\n    @Test\n    public void channelReadShouldRespectAutoReadAndNotProduceNPE() throws Exception {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n        assertTrue(childChannel.config().isAutoRead());\n        Http2HeadersFrame headersFrame = inboundHandler.readInbound();\n        assertNotNull(headersFrame);\n\n        childChannel.config().setAutoRead(false);\n        childChannel.pipeline().addFirst(new ChannelInboundHandlerAdapter() {\n            private int count;\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n                ctx.fireChannelRead(msg);\n                // Close channel after 2 reads so there is still something in the inboundBuffer when the close happens.\n                if (++count == 2) {\n                    ctx.close();\n                }\n            }\n        });\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"hello world\"), 0, false);\n        Http2DataFrame dataFrame0 = inboundHandler.readInbound();\n        assertNotNull(dataFrame0);\n        release(dataFrame0);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"foo\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar\"), 0, false);\n\n        assertNull(inboundHandler.readInbound());\n\n        childChannel.config().setAutoRead(true);\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 3);\n        inboundHandler.checkException();\n    }\n\n    @Test\n    public void readInChannelReadWithoutAutoRead() {\n        useReadWithoutAutoRead(false);\n    }\n\n    @Test\n    public void readInChannelReadCompleteWithoutAutoRead() {\n        useReadWithoutAutoRead(true);\n    }\n\n    private void useReadWithoutAutoRead(final boolean readComplete) {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n        assertTrue(childChannel.config().isAutoRead());\n        childChannel.config().setAutoRead(false);\n        assertFalse(childChannel.config().isAutoRead());\n\n        Http2HeadersFrame headersFrame = inboundHandler.readInbound();\n        assertNotNull(headersFrame);\n\n        // Add a handler which will request reads.\n        childChannel.pipeline().addFirst(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                ctx.fireChannelRead(msg);\n                if (!readComplete) {\n                    ctx.read();\n                }\n            }\n\n            @Override\n            public void channelReadComplete(ChannelHandlerContext ctx) {\n                ctx.fireChannelReadComplete();\n                if (readComplete) {\n                    ctx.read();\n                }\n            }\n        });\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"hello world\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"foo\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"hello world\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"foo\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar\"), 0, true);\n\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 6);\n    }\n\n    private Http2StreamChannel newOutboundStream(ChannelHandler handler) {\n        return new Http2StreamChannelBootstrap(parentChannel).handler(handler)\n                .open().syncUninterruptibly().getNow();\n    }\n\n    /**\n     * A child channel for an HTTP/2 stream in IDLE state (that is no headers sent or received),\n     * should not emit a RST_STREAM frame on close, as this is a connection error of type protocol error.\n     */\n    @Test\n    public void idleOutboundStreamShouldNotWriteResetFrameOnClose() {\n        LastInboundHandler handler = new LastInboundHandler();\n\n        Channel childChannel = newOutboundStream(handler);\n        assertTrue(childChannel.isActive());\n\n        childChannel.close();\n        parentChannel.runPendingTasks();\n\n        assertFalse(childChannel.isOpen());\n        assertFalse(childChannel.isActive());\n        assertNull(parentChannel.readOutbound());\n    }\n\n    @Test\n    public void outboundStreamShouldWriteResetFrameOnClose_headersSent() {\n        ChannelHandler handler = new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelActive(ChannelHandlerContext ctx) {\n                ctx.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));\n                ctx.fireChannelActive();\n            }\n        };\n\n        Http2StreamChannel childChannel = newOutboundStream(handler);\n        assertTrue(childChannel.isActive());\n\n        childChannel.close();\n        verify(frameWriter).writeRstStream(eqCodecCtx(),\n                eqStreamId(childChannel), eq(Http2Error.CANCEL.code()), anyChannelPromise());\n    }\n\n    @Test\n    public void outboundStreamShouldNotWriteResetFrameOnClose_IfStreamDidntExist() {\n        when(frameWriter.writeHeaders(eqCodecCtx(), anyInt(),\n                any(Http2Headers.class), anyInt(), anyBoolean(),\n                any(ChannelPromise.class))).thenAnswer(new Answer<ChannelFuture>() {\n\n            private boolean headersWritten;\n            @Override\n            public ChannelFuture answer(InvocationOnMock invocationOnMock) {\n                // We want to fail to write the first headers frame. This is what happens if the connection\n                // refuses to allocate a new stream due to having received a GOAWAY.\n                if (!headersWritten) {\n                    headersWritten = true;\n                    return ((ChannelPromise) invocationOnMock.getArgument(5)).setFailure(new Exception(\"boom\"));\n                }\n                return ((ChannelPromise) invocationOnMock.getArgument(5)).setSuccess();\n            }\n        });\n\n        Http2StreamChannel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelActive(ChannelHandlerContext ctx) {\n                ctx.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));\n                ctx.fireChannelActive();\n            }\n        });\n\n        assertFalse(childChannel.isActive());\n\n        childChannel.close();\n        parentChannel.runPendingTasks();\n        // The channel was never active so we should not generate a RST frame.\n        verify(frameWriter, never()).writeRstStream(eqCodecCtx(), eqStreamId(childChannel), anyLong(),\n                anyChannelPromise());\n\n        assertTrue(parentChannel.outboundMessages().isEmpty());\n    }\n\n    @Test\n    public void inboundRstStreamFireChannelInactive() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel channel = newInboundStream(3, false, inboundHandler);\n        assertTrue(inboundHandler.isChannelActive());\n        frameInboundWriter.writeInboundRstStream(channel.stream().id(), Http2Error.INTERNAL_ERROR.code());\n\n        assertFalse(inboundHandler.isChannelActive());\n\n        // A RST_STREAM frame should NOT be emitted, as we received a RST_STREAM.\n        verify(frameWriter, Mockito.never()).writeRstStream(eqCodecCtx(), eqStreamId(channel),\n                anyLong(), anyChannelPromise());\n    }\n\n    @Test(expected = StreamException.class)\n    public void streamExceptionTriggersChildChannelExceptionAndClose() throws Exception {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel channel = newInboundStream(3, false, inboundHandler);\n        assertTrue(channel.isActive());\n        StreamException cause = new StreamException(channel.stream().id(), Http2Error.PROTOCOL_ERROR, \"baaam!\");\n        parentChannel.pipeline().fireExceptionCaught(cause);\n\n        assertFalse(channel.isActive());\n        inboundHandler.checkException();\n    }\n\n    @Test(expected = ClosedChannelException.class)\n    public void streamClosedErrorTranslatedToClosedChannelExceptionOnWrites() throws Exception {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n\n        final Http2StreamChannel childChannel = newOutboundStream(inboundHandler);\n        assertTrue(childChannel.isActive());\n\n        Http2Headers headers = new DefaultHttp2Headers();\n        when(frameWriter.writeHeaders(eqCodecCtx(), anyInt(),\n                eq(headers), anyInt(), anyBoolean(),\n                any(ChannelPromise.class))).thenAnswer(new Answer<ChannelFuture>() {\n            @Override\n            public ChannelFuture answer(InvocationOnMock invocationOnMock) {\n                return ((ChannelPromise) invocationOnMock.getArgument(5)).setFailure(\n                        new StreamException(childChannel.stream().id(), Http2Error.STREAM_CLOSED, \"Stream Closed\"));\n            }\n        });\n        ChannelFuture future = childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));\n\n        parentChannel.flush();\n\n        assertFalse(childChannel.isActive());\n        assertFalse(childChannel.isOpen());\n\n        inboundHandler.checkException();\n\n        future.syncUninterruptibly();\n    }\n\n    @Test\n    public void creatingWritingReadingAndClosingOutboundStreamShouldWork() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newOutboundStream(inboundHandler);\n        assertTrue(childChannel.isActive());\n        assertTrue(inboundHandler.isChannelActive());\n\n        // Write to the child channel\n        Http2Headers headers = new DefaultHttp2Headers().scheme(\"https\").method(\"GET\").path(\"/foo.txt\");\n        childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(headers));\n\n        // Read from the child channel\n        frameInboundWriter.writeInboundHeaders(childChannel.stream().id(), headers, 0, false);\n\n        Http2HeadersFrame headersFrame = inboundHandler.readInbound();\n        assertNotNull(headersFrame);\n        assertEquals(headers, headersFrame.headers());\n\n        // Close the child channel.\n        childChannel.close();\n\n        parentChannel.runPendingTasks();\n        // An active outbound stream should emit a RST_STREAM frame.\n        verify(frameWriter).writeRstStream(eqCodecCtx(), eqStreamId(childChannel),\n                anyLong(), anyChannelPromise());\n\n        assertFalse(childChannel.isOpen());\n        assertFalse(childChannel.isActive());\n        assertFalse(inboundHandler.isChannelActive());\n    }\n\n    // Test failing the promise of the first headers frame of an outbound stream. In practice this error case would most\n    // likely happen due to the max concurrent streams limit being hit or the channel running out of stream identifiers.\n    //\n    @Test(expected = Http2NoMoreStreamIdsException.class)\n    public void failedOutboundStreamCreationThrowsAndClosesChannel() throws Exception {\n        LastInboundHandler handler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newOutboundStream(handler);\n        assertTrue(childChannel.isActive());\n\n        Http2Headers headers = new DefaultHttp2Headers();\n        when(frameWriter.writeHeaders(eqCodecCtx(), anyInt(),\n               eq(headers), anyInt(), anyBoolean(),\n               any(ChannelPromise.class))).thenAnswer(new Answer<ChannelFuture>() {\n           @Override\n           public ChannelFuture answer(InvocationOnMock invocationOnMock) {\n               return ((ChannelPromise) invocationOnMock.getArgument(5)).setFailure(\n                       new Http2NoMoreStreamIdsException());\n            }\n        });\n\n        ChannelFuture future = childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(headers));\n        parentChannel.flush();\n\n        assertFalse(childChannel.isActive());\n        assertFalse(childChannel.isOpen());\n\n        handler.checkException();\n\n        future.syncUninterruptibly();\n    }\n\n    @Test\n    public void channelClosedWhenCloseListenerCompletes() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n\n        assertTrue(childChannel.isOpen());\n        assertTrue(childChannel.isActive());\n\n        final AtomicBoolean channelOpen = new AtomicBoolean(true);\n        final AtomicBoolean channelActive = new AtomicBoolean(true);\n\n        // Create a promise before actually doing the close, because otherwise we would be adding a listener to a future\n        // that is already completed because we are using EmbeddedChannel which executes code in the JUnit thread.\n        ChannelPromise p = childChannel.newPromise();\n        p.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) {\n                channelOpen.set(future.channel().isOpen());\n                channelActive.set(future.channel().isActive());\n            }\n        });\n        childChannel.close(p).syncUninterruptibly();\n\n        assertFalse(channelOpen.get());\n        assertFalse(channelActive.get());\n        assertFalse(childChannel.isActive());\n    }\n\n    @Test\n    public void channelClosedWhenChannelClosePromiseCompletes() {\n         LastInboundHandler inboundHandler = new LastInboundHandler();\n         Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n\n         assertTrue(childChannel.isOpen());\n         assertTrue(childChannel.isActive());\n\n         final AtomicBoolean channelOpen = new AtomicBoolean(true);\n         final AtomicBoolean channelActive = new AtomicBoolean(true);\n\n         childChannel.closeFuture().addListener(new ChannelFutureListener() {\n             @Override\n             public void operationComplete(ChannelFuture future) {\n                 channelOpen.set(future.channel().isOpen());\n                 channelActive.set(future.channel().isActive());\n             }\n         });\n         childChannel.close().syncUninterruptibly();\n\n         assertFalse(channelOpen.get());\n         assertFalse(channelActive.get());\n         assertFalse(childChannel.isActive());\n    }\n\n    @Test\n    public void channelClosedWhenWriteFutureFails() {\n        final Queue<ChannelPromise> writePromises = new ArrayDeque<ChannelPromise>();\n\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n\n        assertTrue(childChannel.isOpen());\n        assertTrue(childChannel.isActive());\n\n        final AtomicBoolean channelOpen = new AtomicBoolean(true);\n        final AtomicBoolean channelActive = new AtomicBoolean(true);\n\n        Http2Headers headers = new DefaultHttp2Headers();\n        when(frameWriter.writeHeaders(eqCodecCtx(), anyInt(),\n                eq(headers), anyInt(), anyBoolean(),\n                any(ChannelPromise.class))).thenAnswer(new Answer<ChannelFuture>() {\n            @Override\n            public ChannelFuture answer(InvocationOnMock invocationOnMock) {\n                ChannelPromise promise = invocationOnMock.getArgument(5);\n                writePromises.offer(promise);\n                return promise;\n            }\n        });\n\n        ChannelFuture f = childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(headers));\n        assertFalse(f.isDone());\n        f.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                channelOpen.set(future.channel().isOpen());\n                channelActive.set(future.channel().isActive());\n            }\n        });\n\n        ChannelPromise first = writePromises.poll();\n        first.setFailure(new ClosedChannelException());\n        f.awaitUninterruptibly();\n\n        assertFalse(channelOpen.get());\n        assertFalse(channelActive.get());\n        assertFalse(childChannel.isActive());\n    }\n\n    @Test\n    public void channelClosedTwiceMarksPromiseAsSuccessful() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n\n        assertTrue(childChannel.isOpen());\n        assertTrue(childChannel.isActive());\n        childChannel.close().syncUninterruptibly();\n        childChannel.close().syncUninterruptibly();\n\n        assertFalse(childChannel.isOpen());\n        assertFalse(childChannel.isActive());\n    }\n\n    @Test\n    public void settingChannelOptsAndAttrs() {\n        AttributeKey<String> key = AttributeKey.newInstance(UUID.randomUUID().toString());\n\n        Channel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter());\n        childChannel.config().setAutoRead(false).setWriteSpinCount(1000);\n        childChannel.attr(key).set(\"bar\");\n        assertFalse(childChannel.config().isAutoRead());\n        assertEquals(1000, childChannel.config().getWriteSpinCount());\n        assertEquals(\"bar\", childChannel.attr(key).get());\n    }\n\n    @Test\n    public void outboundFlowControlWritability() {\n        Http2StreamChannel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter());\n        assertTrue(childChannel.isActive());\n\n        assertTrue(childChannel.isWritable());\n        childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));\n        parentChannel.flush();\n\n        // Test for initial window size\n        assertTrue(initialRemoteStreamWindow < childChannel.config().getWriteBufferHighWaterMark());\n\n        assertTrue(childChannel.isWritable());\n        childChannel.write(new DefaultHttp2DataFrame(Unpooled.buffer().writeZero(16 * 1024 * 1024)));\n        assertEquals(0, childChannel.bytesBeforeUnwritable());\n        assertFalse(childChannel.isWritable());\n    }\n\n    @Test\n    public void writabilityOfParentIsRespected() {\n        Http2StreamChannel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter());\n        childChannel.config().setWriteBufferWaterMark(new WriteBufferWaterMark(2048, 4096));\n        parentChannel.config().setWriteBufferWaterMark(new WriteBufferWaterMark(256, 512));\n        assertTrue(childChannel.isWritable());\n        assertTrue(parentChannel.isActive());\n\n        childChannel.writeAndFlush(new DefaultHttp2HeadersFrame(new DefaultHttp2Headers()));\n        parentChannel.flush();\n\n        assertTrue(childChannel.isWritable());\n        childChannel.write(new DefaultHttp2DataFrame(Unpooled.buffer().writeZero(256)));\n        assertTrue(childChannel.isWritable());\n        childChannel.writeAndFlush(new DefaultHttp2DataFrame(Unpooled.buffer().writeZero(512)));\n\n        long bytesBeforeUnwritable = childChannel.bytesBeforeUnwritable();\n        assertNotEquals(0, bytesBeforeUnwritable);\n        // Add something to the ChannelOutboundBuffer of the parent to simulate queuing in the parents channel buffer\n        // and verify that this only affect the writability of the parent channel while the child stays writable\n        // until it used all of its credits.\n        parentChannel.unsafe().outboundBuffer().addMessage(\n                Unpooled.buffer().writeZero(800), 800, parentChannel.voidPromise());\n        assertFalse(parentChannel.isWritable());\n\n        assertTrue(childChannel.isWritable());\n        assertEquals(4096, childChannel.bytesBeforeUnwritable());\n\n        // Flush everything which simulate writing everything to the socket.\n        parentChannel.flush();\n        assertTrue(parentChannel.isWritable());\n        assertTrue(childChannel.isWritable());\n        assertEquals(bytesBeforeUnwritable, childChannel.bytesBeforeUnwritable());\n\n        ChannelFuture future = childChannel.writeAndFlush(new DefaultHttp2DataFrame(\n                Unpooled.buffer().writeZero((int) bytesBeforeUnwritable)));\n        assertFalse(childChannel.isWritable());\n        assertTrue(parentChannel.isWritable());\n\n        parentChannel.flush();\n        assertFalse(future.isDone());\n        assertTrue(parentChannel.isWritable());\n        assertFalse(childChannel.isWritable());\n\n        // Now write an window update frame for the stream which then should ensure we will flush the bytes that were\n        // queued in the RemoteFlowController before for the stream.\n        frameInboundWriter.writeInboundWindowUpdate(childChannel.stream().id(), (int) bytesBeforeUnwritable);\n        assertTrue(childChannel.isWritable());\n        assertTrue(future.isDone());\n    }\n\n    @Test\n    public void channelClosedWhenInactiveFired() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n\n        final AtomicBoolean channelOpen = new AtomicBoolean(false);\n        final AtomicBoolean channelActive = new AtomicBoolean(false);\n        assertTrue(childChannel.isOpen());\n        assertTrue(childChannel.isActive());\n\n        childChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                channelOpen.set(ctx.channel().isOpen());\n                channelActive.set(ctx.channel().isActive());\n\n                super.channelInactive(ctx);\n            }\n        });\n\n        childChannel.close().syncUninterruptibly();\n        assertFalse(channelOpen.get());\n        assertFalse(channelActive.get());\n    }\n\n    @Test\n    public void channelInactiveHappensAfterExceptionCaughtEvents() throws Exception {\n        final AtomicInteger count = new AtomicInteger(0);\n        final AtomicInteger exceptionCaught = new AtomicInteger(-1);\n        final AtomicInteger channelInactive = new AtomicInteger(-1);\n        final AtomicInteger channelUnregistered = new AtomicInteger(-1);\n        Http2StreamChannel childChannel = newOutboundStream(new ChannelInboundHandlerAdapter() {\n\n            @Override\n            public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n                ctx.close();\n                throw new Exception(\"exception\");\n            }\n        });\n\n        childChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n\n            @Override\n            public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n                channelInactive.set(count.getAndIncrement());\n                super.channelInactive(ctx);\n            }\n\n            @Override\n            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n                exceptionCaught.set(count.getAndIncrement());\n                super.exceptionCaught(ctx, cause);\n            }\n\n            @Override\n            public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n                channelUnregistered.set(count.getAndIncrement());\n                super.channelUnregistered(ctx);\n            }\n        });\n\n        childChannel.pipeline().fireUserEventTriggered(new Object());\n        parentChannel.runPendingTasks();\n\n        // The events should have happened in this order because the inactive and deregistration events\n        // get deferred as they do in the AbstractChannel.\n        assertEquals(0, exceptionCaught.get());\n        assertEquals(1, channelInactive.get());\n        assertEquals(2, channelUnregistered.get());\n    }\n\n    @Test\n    public void callUnsafeCloseMultipleTimes() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n        childChannel.unsafe().close(childChannel.voidPromise());\n\n        ChannelPromise promise = childChannel.newPromise();\n        childChannel.unsafe().close(promise);\n        promise.syncUninterruptibly();\n        childChannel.closeFuture().syncUninterruptibly();\n    }\n\n    @Test\n    public void endOfStreamDoesNotDiscardData() {\n        AtomicInteger numReads = new AtomicInteger(1);\n        final AtomicBoolean shouldDisableAutoRead = new AtomicBoolean();\n        Consumer<ChannelHandlerContext> ctxConsumer = new Consumer<ChannelHandlerContext>() {\n            @Override\n            public void accept(ChannelHandlerContext obj) {\n                if (shouldDisableAutoRead.get()) {\n                    obj.channel().config().setAutoRead(false);\n                }\n            }\n        };\n        LastInboundHandler inboundHandler = new LastInboundHandler(ctxConsumer);\n        Http2StreamChannel childChannel = newInboundStream(3, false, numReads, inboundHandler);\n        childChannel.config().setAutoRead(false);\n\n        Http2DataFrame dataFrame1 = new DefaultHttp2DataFrame(bb(\"1\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame2 = new DefaultHttp2DataFrame(bb(\"2\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame3 = new DefaultHttp2DataFrame(bb(\"3\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame4 = new DefaultHttp2DataFrame(bb(\"4\")).stream(childChannel.stream());\n\n        assertEquals(new DefaultHttp2HeadersFrame(request).stream(childChannel.stream()), inboundHandler.readInbound());\n\n        ChannelHandler readCompleteSupressHandler = new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelReadComplete(ChannelHandlerContext ctx) {\n                // We want to simulate the parent channel calling channelRead and delay calling channelReadComplete.\n            }\n        };\n\n        parentChannel.pipeline().addFirst(readCompleteSupressHandler);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"1\"), 0, false);\n\n        assertEqualsAndRelease(dataFrame1, inboundHandler.<Http2DataFrame>readInbound());\n\n        // Deliver frames, and then a stream closed while read is inactive.\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"2\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"3\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"4\"), 0, false);\n\n        shouldDisableAutoRead.set(true);\n        childChannel.config().setAutoRead(true);\n        numReads.set(1);\n\n        frameInboundWriter.writeInboundRstStream(childChannel.stream().id(), Http2Error.NO_ERROR.code());\n\n        // Detecting EOS should flush all pending data regardless of read calls.\n        assertEqualsAndRelease(dataFrame2, inboundHandler.<Http2DataFrame>readInbound());\n        assertNull(inboundHandler.readInbound());\n\n        // As we limited the number to 1 we also need to call read() again.\n        childChannel.read();\n\n        assertEqualsAndRelease(dataFrame3, inboundHandler.<Http2DataFrame>readInbound());\n        assertEqualsAndRelease(dataFrame4, inboundHandler.<Http2DataFrame>readInbound());\n\n        Http2ResetFrame resetFrame = useUserEventForResetFrame() ? inboundHandler.<Http2ResetFrame>readUserEvent() :\n                inboundHandler.<Http2ResetFrame>readInbound();\n\n        assertEquals(childChannel.stream(), resetFrame.stream());\n        assertEquals(Http2Error.NO_ERROR.code(), resetFrame.errorCode());\n\n        assertNull(inboundHandler.readInbound());\n\n        // Now we want to call channelReadComplete and simulate the end of the read loop.\n        parentChannel.pipeline().remove(readCompleteSupressHandler);\n        parentChannel.flushInbound();\n\n        childChannel.closeFuture().syncUninterruptibly();\n    }\n\n    protected abstract boolean useUserEventForResetFrame();\n\n    protected abstract boolean ignoreWindowUpdateFrames();\n\n    @Test\n    public void windowUpdateFrames() {\n        AtomicInteger numReads = new AtomicInteger(1);\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, numReads, inboundHandler);\n\n        assertEquals(new DefaultHttp2HeadersFrame(request).stream(childChannel.stream()), inboundHandler.readInbound());\n\n        frameInboundWriter.writeInboundWindowUpdate(childChannel.stream().id(), 4);\n\n        Http2WindowUpdateFrame updateFrame = inboundHandler.readInbound();\n        if (ignoreWindowUpdateFrames()) {\n            assertNull(updateFrame);\n        } else {\n            assertEquals(new DefaultHttp2WindowUpdateFrame(4).stream(childChannel.stream()), updateFrame);\n        }\n\n        frameInboundWriter.writeInboundWindowUpdate(Http2CodecUtil.CONNECTION_STREAM_ID, 6);\n\n        assertNull(parentChannel.readInbound());\n        childChannel.close().syncUninterruptibly();\n    }\n\n    @Test\n    public void childQueueIsDrainedAndNewDataIsDispatchedInParentReadLoopAutoRead() {\n        AtomicInteger numReads = new AtomicInteger(1);\n        final AtomicInteger channelReadCompleteCount = new AtomicInteger(0);\n        final AtomicBoolean shouldDisableAutoRead = new AtomicBoolean();\n        Consumer<ChannelHandlerContext> ctxConsumer = new Consumer<ChannelHandlerContext>() {\n            @Override\n            public void accept(ChannelHandlerContext obj) {\n                channelReadCompleteCount.incrementAndGet();\n                if (shouldDisableAutoRead.get()) {\n                    obj.channel().config().setAutoRead(false);\n                }\n            }\n        };\n        LastInboundHandler inboundHandler = new LastInboundHandler(ctxConsumer);\n        Http2StreamChannel childChannel = newInboundStream(3, false, numReads, inboundHandler);\n        childChannel.config().setAutoRead(false);\n\n        Http2DataFrame dataFrame1 = new DefaultHttp2DataFrame(bb(\"1\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame2 = new DefaultHttp2DataFrame(bb(\"2\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame3 = new DefaultHttp2DataFrame(bb(\"3\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame4 = new DefaultHttp2DataFrame(bb(\"4\")).stream(childChannel.stream());\n\n        assertEquals(new DefaultHttp2HeadersFrame(request).stream(childChannel.stream()), inboundHandler.readInbound());\n\n        ChannelHandler readCompleteSupressHandler = new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelReadComplete(ChannelHandlerContext ctx) {\n                // We want to simulate the parent channel calling channelRead and delay calling channelReadComplete.\n            }\n        };\n        parentChannel.pipeline().addFirst(readCompleteSupressHandler);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"1\"), 0, false);\n\n        assertEqualsAndRelease(dataFrame1, inboundHandler.<Http2DataFrame>readInbound());\n\n        // We want one item to be in the queue, and allow the numReads to be larger than 1. This will ensure that\n        // when beginRead() is called the child channel is added to the readPending queue of the parent channel.\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"2\"), 0, false);\n\n        numReads.set(10);\n        shouldDisableAutoRead.set(true);\n        childChannel.config().setAutoRead(true);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"3\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"4\"), 0, false);\n\n        // Detecting EOS should flush all pending data regardless of read calls.\n        assertEqualsAndRelease(dataFrame2, inboundHandler.<Http2DataFrame>readInbound());\n        assertEqualsAndRelease(dataFrame3, inboundHandler.<Http2DataFrame>readInbound());\n        assertEqualsAndRelease(dataFrame4, inboundHandler.<Http2DataFrame>readInbound());\n\n        assertNull(inboundHandler.readInbound());\n\n        // Now we want to call channelReadComplete and simulate the end of the read loop.\n        parentChannel.pipeline().remove(readCompleteSupressHandler);\n        parentChannel.flushInbound();\n\n        // 3 = 1 for initialization + 1 for read when auto read was off + 1 for when auto read was back on\n        assertEquals(3, channelReadCompleteCount.get());\n    }\n\n    @Test\n    public void childQueueIsDrainedAndNewDataIsDispatchedInParentReadLoopNoAutoRead() {\n        final AtomicInteger numReads = new AtomicInteger(1);\n        final AtomicInteger channelReadCompleteCount = new AtomicInteger(0);\n        final AtomicBoolean shouldDisableAutoRead = new AtomicBoolean();\n        Consumer<ChannelHandlerContext> ctxConsumer = new Consumer<ChannelHandlerContext>() {\n            @Override\n            public void accept(ChannelHandlerContext obj) {\n                channelReadCompleteCount.incrementAndGet();\n                if (shouldDisableAutoRead.get()) {\n                    obj.channel().config().setAutoRead(false);\n                }\n            }\n        };\n        final LastInboundHandler inboundHandler = new LastInboundHandler(ctxConsumer);\n        Http2StreamChannel childChannel = newInboundStream(3, false, numReads, inboundHandler);\n        childChannel.config().setAutoRead(false);\n\n        Http2DataFrame dataFrame1 = new DefaultHttp2DataFrame(bb(\"1\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame2 = new DefaultHttp2DataFrame(bb(\"2\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame3 = new DefaultHttp2DataFrame(bb(\"3\")).stream(childChannel.stream());\n        Http2DataFrame dataFrame4 = new DefaultHttp2DataFrame(bb(\"4\")).stream(childChannel.stream());\n\n        assertEquals(new DefaultHttp2HeadersFrame(request).stream(childChannel.stream()), inboundHandler.readInbound());\n\n        ChannelHandler readCompleteSupressHandler = new ChannelInboundHandlerAdapter() {\n            @Override\n            public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n                // We want to simulate the parent channel calling channelRead and delay calling channelReadComplete.\n            }\n        };\n        parentChannel.pipeline().addFirst(readCompleteSupressHandler);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"1\"), 0, false);\n\n        assertEqualsAndRelease(dataFrame1, inboundHandler.<Http2Frame>readInbound());\n\n        // We want one item to be in the queue, and allow the numReads to be larger than 1. This will ensure that\n        // when beginRead() is called the child channel is added to the readPending queue of the parent channel.\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"2\"), 0, false);\n\n        numReads.set(2);\n        childChannel.read();\n\n        assertEqualsAndRelease(dataFrame2, inboundHandler.<Http2Frame>readInbound());\n\n        assertNull(inboundHandler.readInbound());\n\n        // This is the second item that was read, this should be the last until we call read() again. This should also\n        // notify of readComplete().\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"3\"), 0, false);\n\n        assertEqualsAndRelease(dataFrame3, inboundHandler.<Http2Frame>readInbound());\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"4\"), 0, false);\n        assertNull(inboundHandler.readInbound());\n\n        childChannel.read();\n\n        assertEqualsAndRelease(dataFrame4, inboundHandler.<Http2Frame>readInbound());\n\n        assertNull(inboundHandler.readInbound());\n\n        // Now we want to call channelReadComplete and simulate the end of the read loop.\n        parentChannel.pipeline().remove(readCompleteSupressHandler);\n        parentChannel.flushInbound();\n\n        // 3 = 1 for initialization + 1 for first read of 2 items + 1 for second read of 2 items +\n        // 1 for parent channel readComplete\n        assertEquals(4, channelReadCompleteCount.get());\n    }\n\n    @Test\n    public void useReadWithoutAutoReadInRead() {\n        useReadWithoutAutoReadBuffered(false);\n    }\n\n    @Test\n    public void useReadWithoutAutoReadInReadComplete() {\n        useReadWithoutAutoReadBuffered(true);\n    }\n\n    private void useReadWithoutAutoReadBuffered(final boolean triggerOnReadComplete) {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n        assertTrue(childChannel.config().isAutoRead());\n        childChannel.config().setAutoRead(false);\n        assertFalse(childChannel.config().isAutoRead());\n\n        Http2HeadersFrame headersFrame = inboundHandler.readInbound();\n        assertNotNull(headersFrame);\n\n        // Write some bytes to get the channel into the idle state with buffered data and also verify we\n        // do not dispatch it until we receive a read() call.\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"hello world\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"foo\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar\"), 0, false);\n\n        // Add a handler which will request reads.\n        childChannel.pipeline().addFirst(new ChannelInboundHandlerAdapter() {\n\n            @Override\n            public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n                super.channelReadComplete(ctx);\n                if (triggerOnReadComplete) {\n                    ctx.read();\n                    ctx.read();\n                }\n            }\n\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) {\n                ctx.fireChannelRead(msg);\n                if (!triggerOnReadComplete) {\n                    ctx.read();\n                    ctx.read();\n                }\n            }\n        });\n\n        inboundHandler.channel().read();\n\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 3);\n\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"hello world2\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"foo2\"), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(\"bar2\"), 0, true);\n\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 3);\n    }\n\n    private static final class FlushSniffer extends ChannelOutboundHandlerAdapter {\n\n        private boolean didFlush;\n\n        public boolean checkFlush() {\n            boolean r = didFlush;\n            didFlush = false;\n            return r;\n        }\n\n        @Override\n        public void flush(ChannelHandlerContext ctx) throws Exception {\n            didFlush = true;\n            super.flush(ctx);\n        }\n    }\n\n    @Test\n    public void windowUpdatesAreFlushed() {\n        LastInboundHandler inboundHandler = new LastInboundHandler();\n        FlushSniffer flushSniffer = new FlushSniffer();\n        parentChannel.pipeline().addFirst(flushSniffer);\n\n        Http2StreamChannel childChannel = newInboundStream(3, false, inboundHandler);\n        assertTrue(childChannel.config().isAutoRead());\n        childChannel.config().setAutoRead(false);\n        assertFalse(childChannel.config().isAutoRead());\n\n        Http2HeadersFrame headersFrame = inboundHandler.readInbound();\n        assertNotNull(headersFrame);\n\n        assertTrue(flushSniffer.checkFlush());\n\n        // Write some bytes to get the channel into the idle state with buffered data and also verify we\n        // do not dispatch it until we receive a read() call.\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(16 * 1024), 0, false);\n        frameInboundWriter.writeInboundData(childChannel.stream().id(), bb(16 * 1024), 0, false);\n        assertTrue(flushSniffer.checkFlush());\n\n        verify(frameWriter, never()).writeWindowUpdate(eqCodecCtx(), anyInt(), anyInt(), anyChannelPromise());\n        // only the first one was read because it was legacy auto-read behavior.\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 1);\n        assertFalse(flushSniffer.checkFlush());\n\n        // Trigger a read of the second frame.\n        childChannel.read();\n        verifyFramesMultiplexedToCorrectChannel(childChannel, inboundHandler, 1);\n        // We expect a flush here because the StreamChannel will flush the smaller increment but the\n        // connection will collect the bytes and decide not to send a wire level frame until more are consumed.\n        assertTrue(flushSniffer.checkFlush());\n        verify(frameWriter, never()).writeWindowUpdate(eqCodecCtx(), anyInt(), anyInt(), anyChannelPromise());\n\n        // Call read one more time which should trigger the writing of the flow control update.\n        childChannel.read();\n        verify(frameWriter).writeWindowUpdate(eqCodecCtx(), eq(0), eq(32 * 1024), anyChannelPromise());\n        verify(frameWriter).writeWindowUpdate(\n            eqCodecCtx(), eq(childChannel.stream().id()), eq(32 * 1024), anyChannelPromise());\n        assertTrue(flushSniffer.checkFlush());\n    }\n\n    private static void verifyFramesMultiplexedToCorrectChannel(Http2StreamChannel streamChannel,\n                                                                LastInboundHandler inboundHandler,\n                                                                int numFrames) {\n        for (int i = 0; i < numFrames; i++) {\n            Http2StreamFrame frame = inboundHandler.readInbound();\n            assertNotNull(i + \" out of \" + numFrames + \" received\", frame);\n            assertEquals(streamChannel.stream(), frame.stream());\n            release(frame);\n        }\n        assertNull(inboundHandler.readInbound());\n    }\n\n    private static int eqStreamId(Http2StreamChannel channel) {\n        return eq(channel.stream().id());\n    }\n}\n"], "filenames": ["codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java", "codec-http2/src/test/java/io/netty/handler/codec/http2/Http2MultiplexTest.java"], "buggy_code_start_loc": [355, 226], "buggy_code_end_loc": [398, 231], "fixing_code_start_loc": [356, 227], "fixing_code_end_loc": [401, 274], "type": "CWE-444", "message": "Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. In Netty (io.netty:netty-codec-http2) before version 4.1.61.Final there is a vulnerability that enables request smuggling. The content-length header is not correctly validated if the request only uses a single Http2HeaderFrame with the endStream set to to true. This could lead to request smuggling if the request is proxied to a remote peer and translated to HTTP/1.1. This is a followup of GHSA-wm47-8v5p-wjpj/CVE-2021-21295 which did miss to fix this one case. This was fixed as part of 4.1.61.Final.", "other": {"cve": {"id": "CVE-2021-21409", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-30T15:15:14.573", "lastModified": "2022-05-12T14:35:58.710", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. In Netty (io.netty:netty-codec-http2) before version 4.1.61.Final there is a vulnerability that enables request smuggling. The content-length header is not correctly validated if the request only uses a single Http2HeaderFrame with the endStream set to to true. This could lead to request smuggling if the request is proxied to a remote peer and translated to HTTP/1.1. This is a followup of GHSA-wm47-8v5p-wjpj/CVE-2021-21295 which did miss to fix this one case. This was fixed as part of 4.1.61.Final."}, {"lang": "es", "value": "Netty es un framework de aplicaci\u00f3n de red de c\u00f3digo abierto y as\u00edncrono event-driven para el desarrollo r\u00e1pido de servidores y clientes de protocolo de alto rendimiento mantenibles.&#xa0;En Netty (io.netty:netty-codec-http2) versiones anteriores a 4.1.61.Final se presenta una vulnerabilidad que permite el trafico no autorizado de peticiones.&#xa0;El encabezado content-length no es comprobado correctamente si la petici\u00f3n solo usa un \u00fanico Http2HeaderFrame con endStream establecido en verdadero.&#xa0;Esto podr\u00eda conllevar al trafico no autorizado de peticiones si la petici\u00f3n se env\u00eda a un peer remoto y se traduce a HTTP/1.1.&#xa0;Este es un seguimiento de GHSA-wm47-8v5p-wjpj/CVE-2021-21295 que no pudo solucionar este caso.&#xa0;Esto se corrigi\u00f3 como parte de la versi\u00f3n 4.1.61.Final."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netty:netty:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.61", "matchCriteriaId": "BC283248-0EB5-46CA-A68C-4FF004D606F8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_api_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "5EC98B22-FFAA-4B59-8E63-EBAA4336AD13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_workflow_automation:-:*:*:*:*:*:*:*", "matchCriteriaId": "5735E553-9731-4AAC-BCFF-989377F817B3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_corporate_lending_process_management:14.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "0CF9A061-2421-426D-9854-0A4E55B2961D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_corporate_lending_process_management:14.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "F95EDC3D-54BB-48F9-82F2-7CCF335FCA78"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_corporate_lending_process_management:14.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "B72B735F-4E52-484A-9C2C-23E6E2070385"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_credit_facilities_process_management:14.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "8B36A1D4-F391-4EE3-9A65-0A10568795BA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_credit_facilities_process_management:14.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "55116032-AAD1-4FEA-9DA8-2C4CBD3D3F61"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_credit_facilities_process_management:14.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "0275F820-40BE-47B8-B167-815A55DF578E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_trade_finance_process_management:14.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "9E14324D-B9EE-4C06-ACC7-255189ED6300"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_trade_finance_process_management:14.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "CBEBB60F-6EAB-4AE5-B777-5044C657FBA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_trade_finance_process_management:14.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "B185C1EA-71E6-4972-8637-08A33CC00841"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:coherence:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "2FF57C7A-92C9-4D71-A7B1-CC9DEFAA8193"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:coherence:14.1.1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "5FA64A1D-34F9-4441-857A-25C165E6DBB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_brm_-_elastic_charging_engine:12.0.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "06594847-96ED-4541-B2F4-C7331B603603"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_console:1.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "BC12B43F-30F6-4B05-AB3A-E91D8404D5A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_policy:1.14.0:*:*:*:*:*:*:*", "matchCriteriaId": "4479F76A-4B67-41CC-98C7-C76B81050F8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_design_studio:7.4.2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "040DA31B-2A0C-46F6-8EDF-9B88F9FB0F48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_messaging_server:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "E1214FDF-357A-4BB9-BADE-50FB2BD16D10"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:helidon:1.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "4E7626D2-D9FF-416A-9581-852CED0D8C24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:helidon:2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "99344A5D-F4B7-49B4-9AE6-0E2FB3874EA5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jd_edwards_enterpriseone_tools:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.2.6.3", "matchCriteriaId": "BE34D4F7-5C18-4578-8D0A-722FDF931333"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:nosql_database:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.1.12", "matchCriteriaId": "7167D144-C4AE-487F-B59A-888E10EA59DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_gateway:*:*:*:*:*:*:*:*", "versionStartIncluding": "17.12.0", "versionEndIncluding": "17.12.11", "matchCriteriaId": "8B1C88FD-C2EC-4C96-AC7E-6F95C8763B48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_gateway:*:*:*:*:*:*:*:*", "versionStartIncluding": "18.8.0", "versionEndIncluding": "18.8.11", "matchCriteriaId": "53E2276C-9515-46F6-A621-213A3047B9A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_gateway:*:*:*:*:*:*:*:*", "versionStartIncluding": "19.12.0", "versionEndIncluding": "19.12.10", "matchCriteriaId": "3EF7E2B4-B741-41E9-8EF6-6C415AB9EF54"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:quarkus:quarkus:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.13.7", "matchCriteriaId": "64839EBF-078E-492A-897C-9AFFB7678ED8"}]}]}], "references": [{"url": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-21295", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/netty/netty/commit/b0fa4d5aab4215f3c22ce6123dd8dd5f38dc0432", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/netty/netty/security/advisories/GHSA-f256-j965-7f32", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/netty/netty/security/advisories/GHSA-wm47-8v5p-wjpj", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r0b09f3e31e004fe583f677f7afa46bd30110904576c13c5ac818ac2c@%3Cissues.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r0ca82fec33334e571fe5b388272260778883e307e15415d7b1443de2@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r101f82d8f3b5af0bf79aecbd5b2dd3b404f6bb51d1a54c2c3d29bed9@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r1b3cb056364794f919aaf26ceaf7423de64e7fdd05a914066e7d5219@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r2732aa3884cacfecac4c54cfaa77c279ba815cad44b464a567216f83@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r31044fb995e894749cb821c6fe56f487c16a97028e6e360e59f09d58@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r4a98827bb4a7edbd69ef862f2351391845697c40711820d10df52ca5@%3Ccommits.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r4b8be87acf5b9c098a2ee350b5ca5716fe7afeaf0a21a4ee45a90687@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r4ea2f1a9d79d4fc1896e085f31fb60a21b1770d0a26a5250f849372d@%3Cissues.kudu.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r584cf871f188c406d8bd447ff4e2fd9817fca862436c064d0951a071@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5baac01f9e06c40ff7aab209d5751b3b58802c63734e33324b70a06a@%3Cissues.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5cbea8614812289a9b98d0cfc54b47f54cef424ac98d5e315b791795@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5f2f120b2b8d099226473db1832ffb4d7c1d6dc2d228a164bf293a8e@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r602e98daacc98934f097f07f2eed6eb07c18bfc1949c8489dc7bfcf5@%3Cissues.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r61564d86a75403b854cdafee67fc69c8b88c5f6802c2c838f4282cc8@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r69efd8ef003f612c43e4154e788ca3b1f837feaacd16d97854402355@%3Ccommits.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r6dac9bd799ceac499c7a7e152a9b0dc7f2fe7f89ec5605d129bb047b@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r70c3a7bfa904f06a1902f4df20ee26e4f09a46b8fd3eb304dc57a2de@%3Cdev.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r7879ddcb990c835c6b246654770d836f9d031dee982be836744e50ed@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r7b54563abebe3dbbe421e1ba075c2030d8d460372f8c79b7789684b6@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r823d4b27fcba8dad5fe945bdefce3ca5a0031187966eb6ef3cc22ba9@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r855b4b6814ac829ce2d48dd9d8138d07f33387e710de798ee92c011e@%3Cissues.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r967002f0939e69bdec58f070735a19dd57c1f2b8f817949ca17cddae@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r9ec78dc409f3f1edff88f21cab53737f36aad46f582a9825389092e0@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r9fe840c36b74f92b8d4a089ada1f9fd1d6293742efa18b10e06b66d2@%3Ccommits.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/ra64d56a8a331ffd7bdcd24a9aaaeeedeacd5d639f5a683389123f898@%3Cdev.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/ra655e5cec74d1ddf62adacb71d398abd96f3ea2c588f6bbf048348eb@%3Cissues.kudu.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/ra66e93703e3f4bd31bdfd0b6fb0c32ae96b528259bb1aa2b6d38e401@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/raa413040db6d2197593cc03edecfd168732e697119e6447b0a25d525@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rac8cf45a1bab9ead5c9a860cbadd6faaeb7792203617b6ec3874736d@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rafc77f9f03031297394f3d372ccea751b23576f8a2ae9b6b053894c5@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rba2a9ef1d0af882ab58fadb336a58818495245dda43d32a7d7837187@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rbde2f13daf4911504f0eaea43eee4f42555241b5f6d9d71564b6c5fa@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rca0978b634a0c3ebee4126ec29c7f570b165fae3f8f3658754c1cbd3@%3Cissues.kudu.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rcae42fba06979934208bbd515584b241d3ad01d1bb8b063512644362@%3Cdev.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rd4a6b7dec38ea6cd28b6f94bd4b312629a52b80be3786d5fb0e474bc@%3Cissues.kudu.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rd8f72411fb75b98d366400ae789966373b5c3eb3f511e717caf3e49e@%3Cissues.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rdd206d9dd7eb894cc089b37fe6edde2932de88d63a6d8368b44f5101@%3Ccommits.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rdd5715f3ee5e3216d5e0083a07994f67da6dbb9731ce9e7a6389b18e@%3Ccommits.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/re1911e05c08f3ec2bab85744d788773519a0afb27272a31ac2a0b4e8@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/re39391adcb863f0e9f3f15e7986255948f263f02e4700b82453e7102@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/re4b0141939370304d676fe23774d0c6fbc584b648919825402d0cb39@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/re7c69756a102bebce8b8681882844a53e2f23975a189363e68ad0324@%3Cissues.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/re9e6ed60941da831675de2f8f733c026757fb4fa28a7b6c9f3dfb575@%3Cdev.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/redef0fb5474fd686781007de9ddb852b24f1b04131a248d9a4789183@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf148b2bf6c2754153a8629bc7495e216bd0bd4c915695486542a10b4@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf38e4dcdefc7c59f7ba0799a399d6d6e37b555d406a1dfc2fcbf0b35@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf521ff2be2e2dd38984174d3451e6ee935c845948845c8fccd86371d@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf934292a4a1c189827f625d567838d2c1001e4739b158638d844105b@%3Cissues.kudu.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210604-0003/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4885", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2021.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/netty/netty/commit/b0fa4d5aab4215f3c22ce6123dd8dd5f38dc0432"}}