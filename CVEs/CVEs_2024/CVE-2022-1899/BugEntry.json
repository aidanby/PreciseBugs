{"buggy_code": ["/* radare2 - LGPL - Copyright 2009-2022 - pancake, nibble, dso */\n\n#include <r_bin.h>\n#include <r_hash.h>\n#include \"i/private.h\"\n\n// maybe too big sometimes? 2KB of stack eaten here..\n#define R_STRING_SCAN_BUFFER_SIZE 2048\n#define R_STRING_MAX_UNI_BLOCKS 4\n\nstatic RBinClass *__getClass(RBinFile *bf, const char *name) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->classes_ht && name, NULL);\n\treturn ht_pp_find (bf->o->classes_ht, name, NULL);\n}\n\nstatic RBinSymbol *__getMethod(RBinFile *bf, const char *klass, const char *method) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->methods_ht && klass && method, NULL);\n\tr_strf_var (name, 128, \"%s::%s\", klass, method);\n\treturn ht_pp_find (bf->o->methods_ht, name, NULL);\n}\n\nstatic RBinString *__stringAt(RBinFile *bf, RList *ret, ut64 addr) {\n\tif (addr != 0 && addr != UT64_MAX) {\n\t\treturn ht_up_find (bf->o->strings_db, addr, NULL);\n\t}\n\treturn NULL;\n}\n\nstatic ut64 binobj_a2b(RBinObject *bo, ut64 addr) {\n\treturn addr + (bo ? bo->baddr_shift : 0);\n}\n\nstatic void print_string(RBinFile *bf, RBinString *string, int raw, PJ *pj) {\n\tr_return_if_fail (bf && string);\n\n\tint mode = bf->strmode;\n\tRBin *bin = bf->rbin;\n\tif (!bin) {\n\t\treturn;\n\t}\n\tRIO *io = bin->iob.io;\n\tif (!io) {\n\t\treturn;\n\t}\n\tRBinSection *s = r_bin_get_section_at (bf->o, string->paddr, false);\n\tif (s) {\n\t\tstring->vaddr = s->vaddr + (string->paddr - s->paddr);\n\t}\n\tconst char *section_name = s ? s->name : \"\";\n\tconst char *type_string = r_bin_string_type (string->type);\n\tut64 vaddr = r_bin_get_vaddr (bin, string->paddr, string->vaddr);\n\tut64 addr = vaddr;\n\n\t// If raw string dump mode, use printf to dump directly to stdout.\n\t//  PrintfCallback temp = io->cb_printf;\n\tswitch (mode) {\n\tcase R_MODE_JSON:\n\t\t{\n\t\t\tif (pj) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"vaddr\", vaddr);\n\t\t\t\tpj_kn (pj, \"paddr\", string->paddr);\n\t\t\t\tpj_kn (pj, \"ordinal\", string->ordinal);\n\t\t\t\tpj_kn (pj, \"size\", string->size);\n\t\t\t\tpj_kn (pj, \"length\", string->length);\n\t\t\t\tpj_ks (pj, \"section\", section_name);\n\t\t\t\tpj_ks (pj, \"type\", type_string);\n\t\t\t\tpj_ks (pj, \"string\", string->string);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase R_MODE_SIMPLEST:\n\t\tio->cb_printf (\"%s\\n\", string->string);\n\t\tbreak;\n\tcase R_MODE_SIMPLE:\n\t\tif (raw == 2) {\n\t\t\tio->cb_printf (\"0x%08\"PFMT64x\" %s\\n\", addr, string->string);\n\t\t} else {\n\t\t\tio->cb_printf (\"%s\\n\", string->string);\n\t\t}\n\t\tbreak;\n\tcase R_MODE_RADARE: {\n\t\tchar *f_name = strdup (string->string);\n\t\tr_name_filter (f_name, -1);\n\t\tif (bin->prefix) {\n\t\t\tio->cb_printf (\"f %s.str.%s %u @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %u @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tbin->prefix, f_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t} else {\n\t\t\tio->cb_printf (\"f str.%s %u @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %u @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tf_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t}\n\t\tfree (f_name);\n\t\tbreak;\n\t\t}\n\tcase R_MODE_PRINT:\n\t\tio->cb_printf (\"%03u 0x%08\" PFMT64x \" 0x%08\" PFMT64x \" %3u %3u \"\n\t\t\t       \"(%s) %5s %s\\n\",\n\t\t\tstring->ordinal, string->paddr, vaddr,\n\t\t\tstring->length, string->size,\n\t\t\tsection_name, type_string, string->string);\n\t\tbreak;\n\t}\n}\n\nstatic int string_scan_range(RList *list, RBinFile *bf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type, int raw, RBinSection *section) {\n\tRBin *bin = bf->rbin;\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\t// if list is null it means its gonna dump\n\tr_return_val_if_fail (bf, -1);\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (from == to) {\n\t\treturn 0;\n\t}\n\tif (from > to) {\n\t\teprintf (\"Invalid range to find strings 0x%\"PFMT64x\" .. 0x%\"PFMT64x\"\\n\", from, to);\n\t\treturn -1;\n\t}\n\tst64 len = (st64)(to - from);\n\tif (len < 1 || len > ST32_MAX) {\n\t\teprintf (\"String scan range is invalid (%\"PFMT64d\" bytes)\\n\", len);\n\t\treturn -1;\n\t}\n\tut8 *buf = calloc (len, 1);\n\tif (!buf || !min) {\n\t\tfree (buf);\n\t\treturn -1;\n\t}\n\tst64 vdelta = 0, pdelta = 0;\n\tRBinSection *s = NULL;\n\tbool ascii_only = false;\n\tPJ *pj = NULL;\n\tif (bf->strmode == R_MODE_JSON && !list) {\n\t\tpj = pj_new ();\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t}\n\tr_buf_read_at (bf->buf, from, buf, len);\n\tchar *charset = r_sys_getenv (\"RABIN2_CHARSET\");\n\tif (!R_STR_ISEMPTY (charset)) {\n\t\tRCharset *ch = r_charset_new ();\n\t\tif (r_charset_use (ch, charset)) {\n\t\t\tint outlen = len * 4;\n\t\t\tut8 *out = calloc (len, 4);\n\t\t\tif (out) {\n\t\t\t\tint res = r_charset_encode_str (ch, out, outlen, buf, len);\n\t\t\t\tint i;\n\t\t\t\t// TODO unknown chars should be translated to null bytes\n\t\t\t\tfor (i = 0; i < res; i++) {\n\t\t\t\t\tif (out[i] == '?') {\n\t\t\t\t\t\tout[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen = res;\n\t\t\t\tfree (buf);\n\t\t\t\tbuf = out;\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot allocate\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid value for RABIN2_CHARSET.\\n\");\n\t\t}\n\t\tr_charset_free (ch);\n\t}\n\tfree (charset);\n\tRConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;\n\t// may oobread\n\twhile (needle < to) {\n\t\tif (is_breaked && is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// smol optimization\n\t\tif (needle + 4 < to) {\n\t\t\tut32 n1 = r_read_le32 (buf + needle - from);\n\t\t\tif (!n1) {\n\t\t\t\tneedle += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trc = r_utf8_decode (buf + needle - from, to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\t\tbool addr_aligned = !(needle % 4);\n\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + needle + rc - from;\n\t\t\tif (((to - needle) > 8 + rc)) {\n\t\t\t\t// TODO: support le and be\n\t\t\t\tbool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n\t\t\t\t// reduce false positives\n\t\t\t\tif (is_wide32le) {\n\t\t\t\t\tif (!w[5] && !w[6] && w[7] && w[8]) {\n\t\t\t\t\t\tis_wide32le = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!addr_aligned) {\n\t\t\t\t\tis_wide32le = false;\n\t\t\t\t}\n\t\t\t\t///is_wide32be &= (n1 < 0xff && n11 < 0xff); // false; // n11 < 0xff;\n\t\t\t\tif (is_wide32le  && addr_aligned) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32; // asume big endian,is there little endian w32?\n\t\t\t\t} else {\n\t\t\t\t\t// bool is_wide = (n1 && n2 && n1 < 0xff && (!n2 || n2 < 0xff));\n\t\t\t\t\tbool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8; // could be charset if set :?\n\t\t\t\t} else {\n\t\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (type == R_STRING_TYPE_UTF8) {\n\t\t\tstr_type = R_STRING_TYPE_ASCII; // initial assumption\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc || (ascii_only && r > 0x7f)) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r) && r != '\\\\') {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (tmp + i, r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 93) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e  \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"  \\\\\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) {\n\t\t\t// back up past the \\0 to the last char just in case it starts a wide string\n\t\t\tneedle -= 2;\n\t\t}\n\t\tif (runes >= min) {\n\t\t\t// reduce false positives\n\t\t\tint j, num_blocks, *block_list;\n\t\t\tint *freq_list = NULL, expected_ascii, actual_ascii, num_chars;\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tnum_blocks = 0;\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)tmp, i - 1,\n\t\t\t\t\t\tstr_type == R_STRING_TYPE_WIDE? &freq_list: NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tfor (j = 0; block_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_blocks++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (freq_list) {\n\t\t\t\t\tnum_chars = 0;\n\t\t\t\t\tactual_ascii = 0;\n\t\t\t\t\tfor (j = 0; freq_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_chars += freq_list[j];\n\t\t\t\t\t\tif (!block_list[j]) { // ASCII\n\t\t\t\t\t\t\tactual_ascii = freq_list[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (freq_list);\n\t\t\t\t\texpected_ascii = num_blocks ? num_chars / num_blocks : 0;\n\t\t\t\t\tif (actual_ascii > expected_ascii) {\n\t\t\t\t\t\tascii_only = true;\n\t\t\t\t\t\tneedle = str_start;\n\t\t\t\t\t\tfree (block_list);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (block_list);\n\t\t\t\tif (num_blocks > R_STRING_MAX_UNI_BLOCKS) {\n\t\t\t\t\tneedle++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\tif (!bs) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbs->type = str_type;\n\t\t\tbs->length = runes;\n\t\t\tbs->size = needle - str_start;\n\t\t\tbs->ordinal = count++;\n\t\t\t// TODO: move into adjust_offset\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\tif (str_start - from > 1) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 2 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tif (str_start - from > 3) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 4 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!s) {\n\t\t\t\tif (section) {\n\t\t\t\t\ts = section;\n\t\t\t\t} else if (bf->o) {\n\t\t\t\t\ts = r_bin_get_section_at (bf->o, str_start, false);\n\t\t\t\t}\n\t\t\t\tif (s) {\n\t\t\t\t\tvdelta = s->vaddr;\n\t\t\t\t\tpdelta = s->paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr;\n\t\t\tbs->paddr = str_start + baddr;\n\t\t\tbs->vaddr = str_start - pdelta + vdelta + baddr;\n\t\t\tbs->string = r_str_ndup ((const char *)tmp, i);\n\t\t\tif (list) {\n\t\t\t\tr_list_append (list, bs);\n\t\t\t\tif (bf->o) {\n\t\t\t\t\tht_up_insert (bf->o->strings_db, bs->vaddr, bs);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint_string (bf, bs, raw, pj);\n\t\t\t\tr_bin_string_free (bs);\n\t\t\t}\n\t\t\tif (from == 0 && to == bf->size) {\n\t\t\t\t/* force lookup section at the next one */\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t\tascii_only = false;\n\t}\n\tfree (buf);\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tif (bin) {\n\t\t\tRIO *io = bin->iob.io;\n\t\t\tif (io) {\n\t\t\t\tio->cb_printf (\"%s\", pj_string (pj));\n\t\t\t}\n\t\t}\n\t\tpj_free (pj);\n\t}\n\treturn count;\n}\n\nstatic bool __isDataSection(RBinFile *a, RBinSection *s) {\n\tif (s->has_strings || s->is_data) {\n\t\treturn true;\n\t}\n \t// Rust\n\treturn strstr (s->name, \"_const\");\n}\n\nstatic void get_strings_range(RBinFile *bf, RList *list, int min, int raw, ut64 from, ut64 to, RBinSection *section) {\n\tr_return_if_fail (bf && bf->buf);\n\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (bf);\n\n\tif (!raw && (!plugin || !plugin->info)) {\n\t\treturn;\n\t}\n\tif (!min) {\n\t\tmin = plugin? plugin->minstrlen: 4;\n\t}\n\t/* Some plugins return zero, fix it up */\n\tif (min < 0) {\n\t\treturn;\n\t}\n\tif (!min) {\n\t\tmin = 4;\n\t}\n\t{\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tRCoreBind *cb = &io->coreb;\n\t\tif (cb && cb->cfgGet) {\n\t\t\tconst bool cfg_debug = cb->cfgGet (cb->core, \"cfg.debug\");\n\t\t\tif (!cfg_debug) {\n\t\t\t\tif (!to || to > r_buf_size (bf->buf)) {\n\t\t\t\t\tto = r_buf_size (bf->buf);\n\t\t\t\t}\n\t\t\t\tif (!to) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (raw != 2) {\n\t\tut64 size = to - from;\n\t\t// in case of dump ignore here\n\t\tif (bf->rbin->maxstrbuf && size && size > bf->rbin->maxstrbuf) {\n\t\t\tif (bf->rbin->verbose) {\n\t\t\t\tR_LOG_WARN (\"bin_strings buffer is too big (0x%08\" PFMT64x \"). Use -zzz or set bin.maxstrbuf (RABIN2_MAXSTRBUF) in r2 (rabin2)\", size);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tint type;\n\tconst char *enc = bf->rbin->strenc;\n\tif (!enc) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t} else if (!strcmp (enc, \"latin1\")) {\n\t\ttype = R_STRING_TYPE_ASCII;\n\t} else if (!strcmp (enc, \"utf8\")) {\n\t\ttype = R_STRING_TYPE_UTF8;\n\t} else if (!strcmp (enc, \"utf16le\")) {\n\t\ttype = R_STRING_TYPE_WIDE;\n\t} else if (!strcmp (enc, \"utf32le\")) {\n\t\ttype = R_STRING_TYPE_WIDE32;\n\t} else { // TODO utf16be, utf32be\n\t\teprintf (\"ERROR: encoding %s not supported\\n\", enc);\n\t\treturn;\n\t}\n\tstring_scan_range (list, bf, min, from, to, type, raw, section);\n}\n\nR_IPI RBinFile *r_bin_file_new(RBin *bin, const char *file, ut64 file_sz, int rawstr, int fd, const char *xtrname, Sdb *sdb, bool steal_ptr) {\n\tut32 bf_id;\n\tif (!r_id_pool_grab_id (bin->ids->pool, &bf_id)) {\n\t\treturn NULL;\n\t}\n\tRBinFile *bf = R_NEW0 (RBinFile);\n\tif (bf) {\n\t\tbf->id = bf_id;\n\t\tbf->rbin = bin;\n\t\tbf->file = file ? strdup (file) : NULL;\n\t\tbf->rawstr = rawstr;\n\t\tbf->fd = fd;\n\t\tbf->curxtr = xtrname ? r_bin_get_xtrplugin_by_name (bin, xtrname) : NULL;\n\t\tbf->sdb = sdb;\n\t\tbf->size = file_sz;\n\t\tbf->xtr_data = r_list_newf ((RListFree)r_bin_xtrdata_free);\n\t\tbf->xtr_obj = NULL;\n\t\tbf->sdb = sdb_new0 ();\n\t\tbf->sdb_addrinfo = sdb_new0 (); //ns (bf->sdb, \"addrinfo\", 1);\n\t\t// bf->sdb_addrinfo->refs++;\n\t}\n\treturn bf;\n}\n\nstatic RBinPlugin *get_plugin_from_buffer(RBin *bin, RBinFile *bf, const char *pluginname, RBuffer *buf) {\n\tRBinPlugin *plugin = bin->force? r_bin_get_binplugin_by_name (bin, bin->force): NULL;\n\tif (plugin) {\n\t\treturn plugin;\n\t}\n\tplugin = pluginname? r_bin_get_binplugin_by_name (bin, pluginname): NULL;\n\tif (plugin) {\n\t\treturn plugin;\n\t}\n\tplugin = r_bin_get_binplugin_by_buffer (bin, bf, buf);\n\tif (plugin) {\n\t\treturn plugin;\n\t}\n\treturn r_bin_get_binplugin_by_name (bin, \"any\");\n}\n\nR_API bool r_bin_file_object_new_from_xtr_data(RBin *bin, RBinFile *bf, ut64 baseaddr, ut64 loadaddr, RBinXtrData *data) {\n\tr_return_val_if_fail (bin && bf && data, false);\n\n\tut64 offset = data->offset;\n\tut64 sz = data->size;\n\n\tRBinPlugin *plugin = get_plugin_from_buffer (bin, bf, NULL, data->buf);\n\tbf->buf = r_buf_ref (data->buf);\n\n\tRBinObject *o = r_bin_object_new (bf, plugin, baseaddr, loadaddr, offset, sz);\n\tif (!o) {\n\t\treturn false;\n\t}\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (!o->size) {\n\t\to->size = sz;\n\t}\n\tbf->narch = data->file_count;\n\tif (!o->info) {\n\t\to->info = R_NEW0 (RBinInfo);\n\t}\n\tR_FREE (o->info->file);\n\tR_FREE (o->info->arch);\n\tR_FREE (o->info->machine);\n\tR_FREE (o->info->type);\n\to->info->file = strdup (bf->file);\n\tif (data->metadata) {\n\t\tif (data->metadata->arch) {\n\t\t\to->info->arch = strdup (data->metadata->arch);\n\t\t}\n\t\tif (data->metadata->machine) {\n\t\t\to->info->machine = strdup (data->metadata->machine);\n\t\t}\n\t\tif (data->metadata->type) {\n\t\t\to->info->type = strdup (data->metadata->type);\n\t\t}\n\t\to->info->bits = data->metadata->bits;\n\t}\n\to->info->has_crypto = bf->o->info->has_crypto;\n\tdata->loaded = true;\n\treturn true;\n}\n\nstatic bool xtr_metadata_match(RBinXtrData *xtr_data, const char *arch, int bits) {\n\tif (!xtr_data->metadata || !xtr_data->metadata->arch) {\n\t\treturn false;\n\t}\n\tconst char *iter_arch = xtr_data->metadata->arch;\n\tint iter_bits = xtr_data->metadata->bits;\n\treturn bits == iter_bits && !strcmp (iter_arch, arch) && !xtr_data->loaded;\n}\n\nR_IPI RBinFile *r_bin_file_new_from_buffer(RBin *bin, const char *file, RBuffer *buf, int rawstr, ut64 baseaddr, ut64 loadaddr, int fd, const char *pluginname) {\n\tr_return_val_if_fail (bin && file && buf, NULL);\n\n\tRBinFile *bf = r_bin_file_new (bin, file, r_buf_size (buf), rawstr, fd, pluginname, NULL, false);\n\tif (bf) {\n\t\tRListIter *item = r_list_append (bin->binfiles, bf);\n\t\tbf->buf = r_buf_ref (buf);\n\t\tRBinPlugin *plugin = get_plugin_from_buffer (bin, bf, pluginname, bf->buf);\n\t\tRBinObject *o = r_bin_object_new (bf, plugin, baseaddr, loadaddr, 0, r_buf_size (bf->buf));\n\t\tif (!o) {\n\t\t\tr_list_delete (bin->binfiles, item);\n\t\t\treturn NULL;\n\t\t}\n\t\t// size is set here because the reported size of the object depends on\n\t\t// if loaded from xtr plugin or partially read\n\t\tif (!o->size) {\n\t\t\to->size = r_buf_size (buf);\n\t\t}\n\t}\n\treturn bf;\n}\n\nR_API RBinFile *r_bin_file_find_by_arch_bits(RBin *bin, const char *arch, int bits) {\n\tRListIter *iter;\n\tRBinFile *binfile = NULL;\n\tRBinXtrData *xtr_data;\n\n\tr_return_val_if_fail (bin && arch, NULL);\n\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tRListIter *iter_xtr;\n\t\tif (!binfile->xtr_data) {\n\t\t\tcontinue;\n\t\t}\n\t\t// look for sub-bins in Xtr Data and Load if we need to\n\t\tr_list_foreach (binfile->xtr_data, iter_xtr, xtr_data) {\n\t\t\tif (xtr_metadata_match (xtr_data, arch, bits)) {\n\t\t\t\tif (!r_bin_file_object_new_from_xtr_data (bin, binfile, xtr_data->baddr,\n\t\t\t\t\t    xtr_data->laddr, xtr_data)) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn binfile;\n\t\t\t}\n\t\t}\n\t}\n\treturn binfile;\n}\n\nR_IPI RBinFile *r_bin_file_find_by_id(RBin *bin, ut32 bf_id) {\n\tRBinFile *bf;\n\tRListIter *iter;\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf->id == bf_id) {\n\t\t\treturn bf;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API ut64 r_bin_file_delete_all(RBin *bin) {\n\tif (bin) {\n\t\tut64 counter = r_list_length (bin->binfiles);\n\t\tr_list_purge (bin->binfiles);\n\t\tbin->cur = NULL;\n\t\treturn counter;\n\t}\n\treturn 0;\n}\n\nR_API bool r_bin_file_delete(RBin *bin, ut32 bin_id) {\n\tr_return_val_if_fail (bin, false);\n\n\tRListIter *iter;\n\tRBinFile *bf, *cur = r_bin_cur (bin);\n\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf && bf->id == bin_id) {\n\t\t\tif (cur && cur->id == bin_id) {\n\t\t\t\t// avoiding UaF due to dead reference\n\t\t\t\tbin->cur = NULL;\n\t\t\t}\n\t\t\tr_list_delete (bin->binfiles, iter);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nR_API RBinFile *r_bin_file_find_by_fd(RBin *bin, ut32 bin_fd) {\n\tRListIter *iter;\n\tRBinFile *bf;\n\n\tr_return_val_if_fail (bin, NULL);\n\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf->fd == bin_fd) {\n\t\t\treturn bf;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinFile *r_bin_file_find_by_name(RBin *bin, const char *name) {\n\tRListIter *iter;\n\tRBinFile *bf;\n\n\tr_return_val_if_fail (bin && name, NULL);\n\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf->file && !strcmp (bf->file, name)) {\n\t\t\treturn bf;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API bool r_bin_file_set_cur_by_id(RBin *bin, ut32 bin_id) {\n\tRBinFile *bf = r_bin_file_find_by_id (bin, bin_id);\n\treturn bf? r_bin_file_set_cur_binfile (bin, bf): false;\n}\n\nR_API bool r_bin_file_set_cur_by_fd(RBin *bin, ut32 bin_fd) {\n\tRBinFile *bf = r_bin_file_find_by_fd (bin, bin_fd);\n\treturn bf? r_bin_file_set_cur_binfile (bin, bf): false;\n}\n\nR_IPI bool r_bin_file_set_obj(RBin *bin, RBinFile *bf, RBinObject *obj) {\n\tr_return_val_if_fail (bin && bf, false);\n\tbin->file = bf->file;\n\tbin->cur = bf;\n\tbin->narch = bf->narch;\n\tif (obj) {\n\t\tbf->o = obj;\n\t} else {\n\t\tobj = bf->o;\n\t}\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (bf);\n\tif (bin->minstrlen < 1) {\n\t\tbin->minstrlen = plugin? plugin->minstrlen: bin->minstrlen;\n\t}\n\tif (obj) {\n\t\tif (!obj->info) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!obj->info->lang) {\n\t\t\tobj->info->lang = r_bin_lang_tostring (obj->lang);\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API bool r_bin_file_set_cur_binfile(RBin *bin, RBinFile *bf) {\n\tr_return_val_if_fail (bin && bf, false);\n\treturn r_bin_file_set_obj (bin, bf, bf->o);\n}\n\nR_API bool r_bin_file_set_cur_by_name(RBin *bin, const char *name) {\n\tr_return_val_if_fail (bin && name, false);\n\tRBinFile *bf = r_bin_file_find_by_name (bin, name);\n\treturn r_bin_file_set_cur_binfile (bin, bf);\n}\n\nR_API bool r_bin_file_deref(RBin *bin, RBinFile *a) {\n\tr_return_val_if_fail (bin && a, false);\n\tif (!r_bin_cur_object (bin)) {\n\t\treturn false;\n\t}\n\tbin->cur = NULL;\n\treturn true;\n}\n\nR_API void r_bin_file_free(void /*RBinFile*/ *_bf) {\n\tif (!_bf) {\n\t\treturn;\n\t}\n\tRBinFile *bf = _bf;\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (bf);\n\t// Binary format objects are connected to the\n\t// RBinObject, so the plugin must destroy the\n\t// format data first\n\tif (plugin && plugin->destroy) {\n\t\tplugin->destroy (bf);\n\t}\n\tr_buf_free (bf->buf);\n\tif (bf->curxtr && bf->curxtr->destroy && bf->xtr_obj) {\n\t\tbf->curxtr->free_xtr ((void *)(bf->xtr_obj));\n\t}\n\t// TODO: unset related sdb namespaces\n\tif (bf->sdb_addrinfo) {\n\t\tsdb_free (bf->sdb_addrinfo);\n\t\tbf->sdb_addrinfo = NULL;\n\t}\n\tfree (bf->file);\n\tr_bin_object_free (bf->o);\n\tr_list_free (bf->xtr_data);\n\tif (bf->id != -1) {\n\t\t// TODO: use r_storage api\n\t\tr_id_pool_kick_id (bf->rbin->ids->pool, bf->id);\n\t}\n\t(void) r_bin_object_delete (bf->rbin, bf->id);\n\tfree (bf);\n}\n\nR_IPI RBinFile *r_bin_file_xtr_load_buffer(RBin *bin, RBinXtrPlugin *xtr, const char *filename, RBuffer *buf, ut64 baseaddr, ut64 loadaddr, int idx, int fd, int rawstr) {\n\tr_return_val_if_fail (bin && xtr && buf, NULL);\n\n\tRBinFile *bf = r_bin_file_find_by_name (bin, filename);\n\tif (!bf) {\n\t\tbf = r_bin_file_new (bin, filename, r_buf_size (buf), rawstr, fd, xtr->name, bin->sdb, false);\n\t\tif (!bf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_list_append (bin->binfiles, bf);\n\t\tif (!bin->cur) {\n\t\t\tbin->cur = bf;\n\t\t}\n\t}\n\tr_list_free (bf->xtr_data);\n\tbf->xtr_data = NULL;\n\tif (xtr->extractall_from_buffer) {\n\t\tbf->xtr_data = xtr->extractall_from_buffer (bin, buf);\n\t} else if (xtr->extractall_from_bytes) {\n\t\tut64 sz = 0;\n\t\tconst ut8 *bytes = r_buf_data (buf, &sz);\n\t\teprintf (\"TODO: Implement extractall_from_buffer in '%s' xtr.bin plugin\\n\", xtr->name);\n\t\tbf->xtr_data = xtr->extractall_from_bytes (bin, bytes, sz);\n\t}\n\tif (bf->xtr_data) {\n\t\tRListIter *iter;\n\t\tRBinXtrData *x;\n\t\t//populate xtr_data with baddr and laddr that will be used later on\n\t\t//r_bin_file_object_new_from_xtr_data\n\t\tr_list_foreach (bf->xtr_data, iter, x) {\n\t\t\tx->baddr = baseaddr? baseaddr : UT64_MAX;\n\t\t\tx->laddr = loadaddr? loadaddr : UT64_MAX;\n\t\t}\n\t}\n\tbf->loadaddr = loadaddr;\n\treturn bf;\n}\n\n// XXX deprecate this function imho.. wee can just access bf->buf directly\nR_IPI bool r_bin_file_set_bytes(RBinFile *bf, const ut8 *bytes, ut64 sz, bool steal_ptr) {\n\tr_return_val_if_fail (bf && bytes, false);\n\tr_buf_free (bf->buf);\n\tif (steal_ptr) {\n\t\tbf->buf = r_buf_new_with_pointers (bytes, sz, true);\n\t} else {\n\t\tbf->buf = r_buf_new_with_bytes (bytes, sz);\n\t}\n\treturn bf->buf;\n}\n\nR_API RBinPlugin *r_bin_file_cur_plugin(RBinFile *bf) {\n\treturn (bf && bf->o)? bf->o->plugin: NULL;\n}\n\n// TODO: searchStrings() instead\nR_IPI RList *r_bin_file_get_strings(RBinFile *bf, int min, int dump, int raw) {\n\tr_return_val_if_fail (bf, NULL);\n\tRListIter *iter;\n\tRBinSection *section;\n\tRList *ret = dump? NULL: r_list_newf (r_bin_string_free);\n\n\tif (!raw && bf && bf->o && bf->o->sections && !r_list_empty (bf->o->sections)) {\n\t\tRBinObject *o = bf->o;\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (__isDataSection (bf, section)) {\n\t\t\t\tget_strings_range (bf, ret, min, raw, section->paddr,\n\t\t\t\t\t\tsection->paddr + section->size, section);\n\t\t\t}\n\t\t}\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\t/* load objc/swift strings */\n\t\t\tconst int bits = (bf->o && bf->o->info) ? bf->o->info->bits : 32;\n\t\t\tconst int cfstr_size = (bits == 64) ? 32 : 16;\n\t\t\tconst int cfstr_offs = (bits == 64) ? 16 :  8;\n\t\t\tif (strstr (section->name, \"__cfstring\")) {\n\t\t\t\tint i;\n\t\t\t\t// XXX do not walk if bin.strings == 0\n\t\t\t\tut8 *p;\n\t\t\t\tif (section->size > bf->size) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut8 *sbuf = malloc (section->size);\n\t\t\t\tif (!sbuf) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_buf_read_at (bf->buf, section->paddr + cfstr_offs, sbuf, section->size);\n\t\t\t\tfor (i = 0; i < section->size; i += cfstr_size) {\n\t\t\t\t\tut8 *buf = sbuf;\n\t\t\t\t\tp = buf + i;\n\t\t\t\t\tif ((i + ((bits == 64)? 8: 4)) >= section->size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 cfstr_vaddr = section->vaddr + i;\n\t\t\t\t\tut64 cstr_vaddr = (bits == 64) ? r_read_le64 (p) : r_read_le32 (p);\n\t\t\t\t\tRBinString *s = __stringAt (bf, ret, cstr_vaddr);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\t\t\t\tif (bs) {\n\t\t\t\t\t\t\tbs->type = s->type;\n\t\t\t\t\t\t\tbs->length = s->length;\n\t\t\t\t\t\t\tbs->size = s->size;\n\t\t\t\t\t\t\tbs->ordinal = s->ordinal;\n\t\t\t\t\t\t\tbs->vaddr = cfstr_vaddr;\n\t\t\t\t\t\t\tbs->paddr = cfstr_vaddr; // XXX should be paddr instead\n\t\t\t\t\t\t\tbs->string = r_str_newf (\"cstr.%s\", s->string);\n\t\t\t\t\t\t\tr_list_append (ret, bs);\n\t\t\t\t\t\t\tht_up_insert (o->strings_db, bs->vaddr, bs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (sbuf);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tget_strings_range (bf, ret, min, raw, 0, bf->size, NULL);\n\t}\n\treturn ret;\n}\n\nR_API ut64 r_bin_file_get_baddr(RBinFile *bf) {\n\tif (bf && bf->o) {\n\t\treturn bf->o->baddr;\n\t}\n\treturn UT64_MAX;\n}\n\nR_API bool r_bin_file_close(RBin *bin, int bd) {\n\tr_return_val_if_fail (bin, false);\n\tRBinFile *bf = r_id_storage_take (bin->ids, bd);\n\tif (bf) {\n\t\t// file_free removes the fd already.. maybe its unnecessary\n\t\tr_id_storage_delete (bin->ids, bd);\n\t\tr_bin_file_free (bf);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API RList *r_bin_file_compute_hashes(RBin *bin, ut64 limit) {\n\tr_return_val_if_fail (bin && bin->cur && bin->cur->o, NULL);\n\tut64 buf_len = 0, r = 0;\n\tRBinFile *bf = bin->cur;\n\tRBinObject *o = bf->o;\n\n\tRIODesc *iod = r_io_desc_get (bin->iob.io, bf->fd);\n\tif (!iod) {\n\t\treturn NULL;\n\t}\n\n\tbuf_len = r_io_desc_size (iod);\n\t// By SLURP_LIMIT normally cannot compute ...\n\tif (buf_len > limit) {\n\t\tif (bin->verbose) {\n\t\t\teprintf (\"Warning: r_bin_file_hash: file exceeds bin.hashlimit\\n\");\n\t\t}\n\t\treturn NULL;\n\t}\n\tconst size_t blocksize = 64000;\n\tut8 *buf = malloc (blocksize);\n\tif (!buf) {\n\t\teprintf (\"Cannot allocate computation buffer\\n\");\n\t\treturn NULL;\n\t}\n\n\tchar hash[128];\n\tRHash *ctx = r_hash_new (false, R_HASH_MD5 | R_HASH_SHA1 | R_HASH_SHA256);\n\twhile (r + blocksize < buf_len) {\n\t\tr_io_desc_seek (iod, r, R_IO_SEEK_SET);\n\t\tint b = r_io_desc_read (iod, buf, blocksize);\n\t\t(void)r_hash_do_md5 (ctx, buf, blocksize);\n\t\t(void)r_hash_do_sha1 (ctx, buf, blocksize);\n\t\t(void)r_hash_do_sha256 (ctx, buf, blocksize);\n\t\tr += b;\n\t}\n\tif (r < buf_len) {\n\t\tr_io_desc_seek (iod, r, R_IO_SEEK_SET);\n\t\tconst size_t rem_len = buf_len-r;\n\t\tint b = r_io_desc_read (iod, buf, rem_len);\n\t\tif (b < 1) {\n\t\t\teprintf (\"r_io_desc_read: error\\n\");\n\t\t} else {\n\t\t\t(void)r_hash_do_md5 (ctx, buf, b);\n\t\t\t(void)r_hash_do_sha1 (ctx, buf, b);\n\t\t\t(void)r_hash_do_sha256 (ctx, buf, b);\n\t\t}\n\t}\n\tr_hash_do_end (ctx, R_HASH_MD5);\n\tr_hex_bin2str (ctx->digest, R_HASH_SIZE_MD5, hash);\n\n\tRList *file_hashes = r_list_newf ((RListFree) r_bin_file_hash_free);\n\tRBinFileHash *md5h = R_NEW0 (RBinFileHash);\n\tif (md5h) {\n\t\tmd5h->type = strdup (\"md5\");\n\t\tmd5h->hex = strdup (hash);\n\t\tr_list_push (file_hashes, md5h);\n\t}\n\tr_hash_do_end (ctx, R_HASH_SHA1);\n\tr_hex_bin2str (ctx->digest, R_HASH_SIZE_SHA1, hash);\n\n\tRBinFileHash *sha1h = R_NEW0 (RBinFileHash);\n\tif (sha1h) {\n\t\tsha1h->type = strdup (\"sha1\");\n\t\tsha1h->hex = strdup (hash);\n\t\tr_list_push (file_hashes, sha1h);\n\t}\n\tr_hash_do_end (ctx, R_HASH_SHA256);\n\tr_hex_bin2str (ctx->digest, R_HASH_SIZE_SHA256, hash);\n\n\tRBinFileHash *sha256h = R_NEW0 (RBinFileHash);\n\tif (sha256h) {\n\t\tsha256h->type = strdup (\"sha256\");\n\t\tsha256h->hex = strdup (hash);\n\t\tr_list_push (file_hashes, sha256h);\n\t}\n\n\tif (o->plugin && o->plugin->hashes) {\n\t\tRList *plugin_hashes = o->plugin->hashes (bf);\n\t\tr_list_join (file_hashes, plugin_hashes);\n\t\tfree (plugin_hashes);\n\t}\n\t// TODO: add here more rows\n\n\tfree (buf);\n\tr_hash_free (ctx);\n\treturn file_hashes;\n}\n\n// Set new hashes to current RBinInfo, caller should free the returned RList\nR_API RList *r_bin_file_set_hashes(RBin *bin, RList/*<RBinFileHash*/ *new_hashes) {\n\tr_return_val_if_fail (bin && bin->cur && bin->cur->o && bin->cur->o->info, NULL);\n\tRBinFile *bf = bin->cur;\n\tRBinInfo *info = bf->o->info;\n\n\tRList *prev_hashes = info->file_hashes;\n\tinfo->file_hashes = new_hashes;\n\n\treturn prev_hashes;\n}\n\nR_IPI RBinClass *r_bin_class_new(const char *name, const char *super, int view) {\n\tr_return_val_if_fail (name, NULL);\n\tRBinClass *c = R_NEW0 (RBinClass);\n\tif (c) {\n\t\tc->name = strdup (name);\n\t\tc->super = super? strdup (super): NULL;\n\t\tc->methods = r_list_new ();\n\t\tc->fields = r_list_new ();\n\t\tc->visibility = view;\n\t}\n\treturn c;\n}\n\nR_IPI void r_bin_class_free(RBinClass *k) {\n\tif (k) {\n\t\tfree (k->name);\n\t\tfree (k->super);\n\t\tfree (k->visibility_str);\n\t\tr_list_free (k->methods);\n\t\tr_list_free (k->fields);\n\t\tfree (k);\n\t}\n}\n\nR_API RBinClass *r_bin_file_add_class(RBinFile *bf, const char *name, const char *super, int view) {\n\tr_return_val_if_fail (name && bf && bf->o, NULL);\n\tRBinClass *c = __getClass (bf, name);\n\tif (c) {\n\t\tif (super) {\n\t\t\tfree (c->super);\n\t\t\tc->super = strdup (super);\n\t\t}\n\t\treturn c;\n\t}\n\tc = r_bin_class_new (name, super, view);\n\tif (c) {\n\t\t// XXX. no need for a list, the ht is iterable too\n\t\tc->index = r_list_length (bf->o->classes);\n\t\tr_list_append (bf->o->classes, c);\n\t\tht_pp_insert (bf->o->classes_ht, name, c);\n\t}\n\treturn c;\n}\n\nR_API RBinSymbol *r_bin_file_add_method(RBinFile *bf, const char *klass, const char *method, int nargs) {\n\tr_return_val_if_fail (bf, NULL);\n\n\tRBinClass *c = r_bin_file_add_class (bf, klass, NULL, 0);\n\tif (!c) {\n\t\teprintf (\"Cannot allocate class %s\\n\", klass);\n\t\treturn NULL;\n\t}\n\tRBinSymbol *sym = __getMethod (bf, klass, method);\n\tif (!sym) {\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (sym) {\n\t\t\tsym->name = strdup (method);\n\t\t\tr_list_append (c->methods, sym);\n\t\t\tchar *name = r_str_newf (\"%s::%s\", klass, method);\n\t\t\tht_pp_insert (bf->o->methods_ht, name, sym);\n\t\t\tfree (name);\n\t\t}\n\t}\n\treturn sym;\n}\n\nR_API RBinField *r_bin_file_add_field(RBinFile *binfile, const char *classname, const char *name) {\n\t//TODO: add_field into class\n\t//eprintf (\"TODO add field: %s \\n\", name);\n\treturn NULL;\n}\n\n// XXX this api name makes no sense\n/* returns vaddr, rebased with the baseaddr of binfile, if va is enabled for\n * bin, paddr otherwise */\nR_API ut64 r_bin_file_get_vaddr(RBinFile *bf, ut64 paddr, ut64 vaddr) {\n\tr_return_val_if_fail (bf && bf->o, paddr);\n\tif (bf->o->info && bf->o->info->has_va) {\n\t\treturn binobj_a2b (bf->o, vaddr);\n\t}\n\treturn paddr;\n}\n\nR_API RList *r_bin_file_get_trycatch(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->plugin, NULL);\n\tif (bf->o->plugin->trycatch) {\n\t\treturn bf->o->plugin->trycatch (bf);\n\t}\n\treturn NULL;\n}\n\nR_API RList *r_bin_file_get_symbols(RBinFile *bf) {\n\tr_return_val_if_fail (bf, NULL);\n\tRBinObject *o = bf->o;\n\treturn o? o->symbols: NULL;\n}\n"], "fixing_code": ["/* radare2 - LGPL - Copyright 2009-2022 - pancake, nibble, dso */\n\n#include <r_bin.h>\n#include <r_hash.h>\n#include \"i/private.h\"\n\n// maybe too big sometimes? 2KB of stack eaten here..\n#define R_STRING_SCAN_BUFFER_SIZE 2048\n#define R_STRING_MAX_UNI_BLOCKS 4\n\nstatic RBinClass *__getClass(RBinFile *bf, const char *name) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->classes_ht && name, NULL);\n\treturn ht_pp_find (bf->o->classes_ht, name, NULL);\n}\n\nstatic RBinSymbol *__getMethod(RBinFile *bf, const char *klass, const char *method) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->methods_ht && klass && method, NULL);\n\tr_strf_var (name, 128, \"%s::%s\", klass, method);\n\treturn ht_pp_find (bf->o->methods_ht, name, NULL);\n}\n\nstatic RBinString *__stringAt(RBinFile *bf, RList *ret, ut64 addr) {\n\tif (addr != 0 && addr != UT64_MAX) {\n\t\treturn ht_up_find (bf->o->strings_db, addr, NULL);\n\t}\n\treturn NULL;\n}\n\nstatic ut64 binobj_a2b(RBinObject *bo, ut64 addr) {\n\treturn addr + (bo ? bo->baddr_shift : 0);\n}\n\nstatic void print_string(RBinFile *bf, RBinString *string, int raw, PJ *pj) {\n\tr_return_if_fail (bf && string);\n\n\tint mode = bf->strmode;\n\tRBin *bin = bf->rbin;\n\tif (!bin) {\n\t\treturn;\n\t}\n\tRIO *io = bin->iob.io;\n\tif (!io) {\n\t\treturn;\n\t}\n\tRBinSection *s = r_bin_get_section_at (bf->o, string->paddr, false);\n\tif (s) {\n\t\tstring->vaddr = s->vaddr + (string->paddr - s->paddr);\n\t}\n\tconst char *section_name = s ? s->name : \"\";\n\tconst char *type_string = r_bin_string_type (string->type);\n\tut64 vaddr = r_bin_get_vaddr (bin, string->paddr, string->vaddr);\n\tut64 addr = vaddr;\n\n\t// If raw string dump mode, use printf to dump directly to stdout.\n\t//  PrintfCallback temp = io->cb_printf;\n\tswitch (mode) {\n\tcase R_MODE_JSON:\n\t\t{\n\t\t\tif (pj) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"vaddr\", vaddr);\n\t\t\t\tpj_kn (pj, \"paddr\", string->paddr);\n\t\t\t\tpj_kn (pj, \"ordinal\", string->ordinal);\n\t\t\t\tpj_kn (pj, \"size\", string->size);\n\t\t\t\tpj_kn (pj, \"length\", string->length);\n\t\t\t\tpj_ks (pj, \"section\", section_name);\n\t\t\t\tpj_ks (pj, \"type\", type_string);\n\t\t\t\tpj_ks (pj, \"string\", string->string);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase R_MODE_SIMPLEST:\n\t\tio->cb_printf (\"%s\\n\", string->string);\n\t\tbreak;\n\tcase R_MODE_SIMPLE:\n\t\tif (raw == 2) {\n\t\t\tio->cb_printf (\"0x%08\"PFMT64x\" %s\\n\", addr, string->string);\n\t\t} else {\n\t\t\tio->cb_printf (\"%s\\n\", string->string);\n\t\t}\n\t\tbreak;\n\tcase R_MODE_RADARE: {\n\t\tchar *f_name = strdup (string->string);\n\t\tr_name_filter (f_name, -1);\n\t\tif (bin->prefix) {\n\t\t\tio->cb_printf (\"f %s.str.%s %u @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %u @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tbin->prefix, f_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t} else {\n\t\t\tio->cb_printf (\"f str.%s %u @ 0x%08\"PFMT64x\"\\n\"\n\t\t\t\t\t\"Cs %u @ 0x%08\"PFMT64x\"\\n\",\n\t\t\t\t\tf_name, string->size, addr,\n\t\t\t\t\tstring->size, addr);\n\t\t}\n\t\tfree (f_name);\n\t\tbreak;\n\t\t}\n\tcase R_MODE_PRINT:\n\t\tio->cb_printf (\"%03u 0x%08\" PFMT64x \" 0x%08\" PFMT64x \" %3u %3u \"\n\t\t\t       \"(%s) %5s %s\\n\",\n\t\t\tstring->ordinal, string->paddr, vaddr,\n\t\t\tstring->length, string->size,\n\t\t\tsection_name, type_string, string->string);\n\t\tbreak;\n\t}\n}\n\nstatic int string_scan_range(RList *list, RBinFile *bf, int min,\n\t\t\t      const ut64 from, const ut64 to, int type, int raw, RBinSection *section) {\n\tRBin *bin = bf->rbin;\n\tut8 tmp[R_STRING_SCAN_BUFFER_SIZE];\n\tut64 str_start, needle = from;\n\tint count = 0, i, rc, runes;\n\tint str_type = R_STRING_TYPE_DETECT;\n\n\t// if list is null it means its gonna dump\n\tr_return_val_if_fail (bf, -1);\n\n\tif (type == -1) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t}\n\tif (from == to) {\n\t\treturn 0;\n\t}\n\tif (from > to) {\n\t\teprintf (\"Invalid range to find strings 0x%\"PFMT64x\" .. 0x%\"PFMT64x\"\\n\", from, to);\n\t\treturn -1;\n\t}\n\tst64 len = (st64)(to - from);\n\tif (len < 1 || len > ST32_MAX) {\n\t\teprintf (\"String scan range is invalid (%\"PFMT64d\" bytes)\\n\", len);\n\t\treturn -1;\n\t}\n\tut8 *buf = calloc (len, 1);\n\tif (!buf || !min) {\n\t\tfree (buf);\n\t\treturn -1;\n\t}\n\tst64 vdelta = 0, pdelta = 0;\n\tRBinSection *s = NULL;\n\tbool ascii_only = false;\n\tPJ *pj = NULL;\n\tif (bf->strmode == R_MODE_JSON && !list) {\n\t\tpj = pj_new ();\n\t\tif (pj) {\n\t\t\tpj_a (pj);\n\t\t}\n\t}\n\tr_buf_read_at (bf->buf, from, buf, len);\n\tchar *charset = r_sys_getenv (\"RABIN2_CHARSET\");\n\tif (!R_STR_ISEMPTY (charset)) {\n\t\tRCharset *ch = r_charset_new ();\n\t\tif (r_charset_use (ch, charset)) {\n\t\t\tint outlen = len * 4;\n\t\t\tut8 *out = calloc (len, 4);\n\t\t\tif (out) {\n\t\t\t\tint res = r_charset_encode_str (ch, out, outlen, buf, len);\n\t\t\t\tint i;\n\t\t\t\t// TODO unknown chars should be translated to null bytes\n\t\t\t\tfor (i = 0; i < res; i++) {\n\t\t\t\t\tif (out[i] == '?') {\n\t\t\t\t\t\tout[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlen = res;\n\t\t\t\tfree (buf);\n\t\t\t\tbuf = out;\n\t\t\t} else {\n\t\t\t\teprintf (\"Cannot allocate\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid value for RABIN2_CHARSET.\\n\");\n\t\t}\n\t\tr_charset_free (ch);\n\t}\n\tfree (charset);\n\tRConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL;\n\t// may oobread\n\twhile (needle < to && needle < UT64_MAX - 4) {\n\t\tif (is_breaked && is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\t// smol optimization\n\t\tif (needle < to - 4) {\n\t\t\tut32 n1 = r_read_le32 (buf + (needle - from));\n\t\t\tif (!n1) {\n\t\t\t\tneedle += 4;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\trc = r_utf8_decode (buf + (needle - from), to - needle, NULL);\n\t\tif (!rc) {\n\t\t\tneedle++;\n\t\t\tcontinue;\n\t\t}\n\t\tbool addr_aligned = !(needle % 4);\n\n\t\tif (type == R_STRING_TYPE_DETECT) {\n\t\t\tchar *w = (char *)buf + (needle + rc - from);\n\t\t\tif (((to - needle) > 8 + rc)) {\n\t\t\t\t// TODO: support le and be\n\t\t\t\tbool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n\t\t\t\t// reduce false positives\n\t\t\t\tif (is_wide32le) {\n\t\t\t\t\tif (!w[5] && !w[6] && w[7] && w[8]) {\n\t\t\t\t\t\tis_wide32le = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!addr_aligned) {\n\t\t\t\t\tis_wide32le = false;\n\t\t\t\t}\n\t\t\t\t///is_wide32be &= (n1 < 0xff && n11 < 0xff); // false; // n11 < 0xff;\n\t\t\t\tif (is_wide32le  && addr_aligned) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32; // asume big endian,is there little endian w32?\n\t\t\t\t} else {\n\t\t\t\t\t// bool is_wide = (n1 && n2 && n1 < 0xff && (!n2 || n2 < 0xff));\n\t\t\t\t\tbool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4];\n\t\t\t\t\tstr_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8; // could be charset if set :?\n\t\t\t\t} else {\n\t\t\t\t\tstr_type = R_STRING_TYPE_ASCII;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (type == R_STRING_TYPE_UTF8) {\n\t\t\tstr_type = R_STRING_TYPE_ASCII; // initial assumption\n\t\t} else {\n\t\t\tstr_type = type;\n\t\t}\n\t\trunes = 0;\n\t\tstr_start = needle;\n\n\t\t/* Eat a whole C string */\n\t\tfor (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) {\n\t\t\tRRune r = {0};\n\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\trc = r_utf32le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc) {\n\t\t\t\t\trc = 4;\n\t\t\t\t}\n\t\t\t} else if (str_type == R_STRING_TYPE_WIDE) {\n\t\t\t\trc = r_utf16le_decode (buf + needle - from, to - needle, &r);\n\t\t\t\tif (rc == 1) {\n\t\t\t\t\trc = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trc = r_utf8_decode (buf + (needle - from), to - needle, &r);\n\t\t\t\tif (rc > 1) {\n\t\t\t\t\tstr_type = R_STRING_TYPE_UTF8;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Invalid sequence detected */\n\t\t\tif (!rc || (ascii_only && r > 0x7f)) {\n\t\t\t\tneedle++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tneedle += rc;\n\n\t\t\tif (r_isprint (r) && r != '\\\\') {\n\t\t\t\tif (str_type == R_STRING_TYPE_WIDE32) {\n\t\t\t\t\tif (r == 0xff) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc = r_utf8_encode (tmp + i, r);\n\t\t\t\trunes++;\n\t\t\t\t/* Print the escape code */\n\t\t\t} else if (r && r < 0x100 && strchr (\"\\b\\v\\f\\n\\r\\t\\a\\033\\\\\", (char)r)) {\n\t\t\t\tif ((i + 32) < sizeof (tmp) && r < 93) {\n\t\t\t\t\ttmp[i + 0] = '\\\\';\n\t\t\t\t\ttmp[i + 1] = \"       abtnvfr             e  \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"                              \"\n\t\t\t\t\t             \"  \\\\\"[r];\n\t\t\t\t} else {\n\t\t\t\t\t// string too long\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc = 2;\n\t\t\t\trunes++;\n\t\t\t} else {\n\t\t\t\t/* \\0 marks the end of C-strings */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttmp[i++] = '\\0';\n\n\t\tif (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) {\n\t\t\t// back up past the \\0 to the last char just in case it starts a wide string\n\t\t\tneedle -= 2;\n\t\t}\n\t\tif (runes >= min) {\n\t\t\t// reduce false positives\n\t\t\tint j, num_blocks, *block_list;\n\t\t\tint *freq_list = NULL, expected_ascii, actual_ascii, num_chars;\n\t\t\tif (str_type == R_STRING_TYPE_ASCII) {\n\t\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t\tchar ch = tmp[j];\n\t\t\t\t\tif (ch != '\\n' && ch != '\\r' && ch != '\\t') {\n\t\t\t\t\t\tif (!IS_PRINTABLE (tmp[j])) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_UTF8:\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tnum_blocks = 0;\n\t\t\t\tblock_list = r_utf_block_list ((const ut8*)tmp, i - 1,\n\t\t\t\t\t\tstr_type == R_STRING_TYPE_WIDE? &freq_list: NULL);\n\t\t\t\tif (block_list) {\n\t\t\t\t\tfor (j = 0; block_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_blocks++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (freq_list) {\n\t\t\t\t\tnum_chars = 0;\n\t\t\t\t\tactual_ascii = 0;\n\t\t\t\t\tfor (j = 0; freq_list[j] != -1; j++) {\n\t\t\t\t\t\tnum_chars += freq_list[j];\n\t\t\t\t\t\tif (!block_list[j]) { // ASCII\n\t\t\t\t\t\t\tactual_ascii = freq_list[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfree (freq_list);\n\t\t\t\t\texpected_ascii = num_blocks ? num_chars / num_blocks : 0;\n\t\t\t\t\tif (actual_ascii > expected_ascii) {\n\t\t\t\t\t\tascii_only = true;\n\t\t\t\t\t\tneedle = str_start;\n\t\t\t\t\t\tfree (block_list);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (block_list);\n\t\t\t\tif (num_blocks > R_STRING_MAX_UNI_BLOCKS) {\n\t\t\t\t\tneedle++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\tif (!bs) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbs->type = str_type;\n\t\t\tbs->length = runes;\n\t\t\tbs->size = needle - str_start;\n\t\t\tbs->ordinal = count++;\n\t\t\t// TODO: move into adjust_offset\n\t\t\tswitch (str_type) {\n\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\tif (str_start - from > 1) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 2 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\tif (str_start - from > 3) {\n\t\t\t\t\tconst ut8 *p = buf + str_start - 4 - from;\n\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!s) {\n\t\t\t\tif (section) {\n\t\t\t\t\ts = section;\n\t\t\t\t} else if (bf->o) {\n\t\t\t\t\ts = r_bin_get_section_at (bf->o, str_start, false);\n\t\t\t\t}\n\t\t\t\tif (s) {\n\t\t\t\t\tvdelta = s->vaddr;\n\t\t\t\t\tpdelta = s->paddr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr;\n\t\t\tbs->paddr = str_start + baddr;\n\t\t\tbs->vaddr = str_start - pdelta + vdelta + baddr;\n\t\t\tbs->string = r_str_ndup ((const char *)tmp, i);\n\t\t\tif (list) {\n\t\t\t\tr_list_append (list, bs);\n\t\t\t\tif (bf->o) {\n\t\t\t\t\tht_up_insert (bf->o->strings_db, bs->vaddr, bs);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint_string (bf, bs, raw, pj);\n\t\t\t\tr_bin_string_free (bs);\n\t\t\t}\n\t\t\tif (from == 0 && to == bf->size) {\n\t\t\t\t/* force lookup section at the next one */\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t}\n\t\tascii_only = false;\n\t}\n\tfree (buf);\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tif (bin) {\n\t\t\tRIO *io = bin->iob.io;\n\t\t\tif (io) {\n\t\t\t\tio->cb_printf (\"%s\", pj_string (pj));\n\t\t\t}\n\t\t}\n\t\tpj_free (pj);\n\t}\n\treturn count;\n}\n\nstatic bool __isDataSection(RBinFile *a, RBinSection *s) {\n\tif (s->has_strings || s->is_data) {\n\t\treturn true;\n\t}\n \t// Rust\n\treturn strstr (s->name, \"_const\");\n}\n\nstatic void get_strings_range(RBinFile *bf, RList *list, int min, int raw, ut64 from, ut64 to, RBinSection *section) {\n\tr_return_if_fail (bf && bf->buf);\n\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (bf);\n\n\tif (!raw && (!plugin || !plugin->info)) {\n\t\treturn;\n\t}\n\tif (!min) {\n\t\tmin = plugin? plugin->minstrlen: 4;\n\t}\n\t/* Some plugins return zero, fix it up */\n\tif (min < 0) {\n\t\treturn;\n\t}\n\tif (!min) {\n\t\tmin = 4;\n\t}\n\t{\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tRCoreBind *cb = &io->coreb;\n\t\tif (cb && cb->cfgGet) {\n\t\t\tconst bool cfg_debug = cb->cfgGet (cb->core, \"cfg.debug\");\n\t\t\tif (!cfg_debug) {\n\t\t\t\tif (!to || to > r_buf_size (bf->buf)) {\n\t\t\t\t\tto = r_buf_size (bf->buf);\n\t\t\t\t}\n\t\t\t\tif (!to) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (raw != 2) {\n\t\tut64 size = to - from;\n\t\t// in case of dump ignore here\n\t\tif (bf->rbin->maxstrbuf && size && size > bf->rbin->maxstrbuf) {\n\t\t\tif (bf->rbin->verbose) {\n\t\t\t\tR_LOG_WARN (\"bin_strings buffer is too big (0x%08\" PFMT64x \"). Use -zzz or set bin.maxstrbuf (RABIN2_MAXSTRBUF) in r2 (rabin2)\", size);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tint type;\n\tconst char *enc = bf->rbin->strenc;\n\tif (!enc) {\n\t\ttype = R_STRING_TYPE_DETECT;\n\t} else if (!strcmp (enc, \"latin1\")) {\n\t\ttype = R_STRING_TYPE_ASCII;\n\t} else if (!strcmp (enc, \"utf8\")) {\n\t\ttype = R_STRING_TYPE_UTF8;\n\t} else if (!strcmp (enc, \"utf16le\")) {\n\t\ttype = R_STRING_TYPE_WIDE;\n\t} else if (!strcmp (enc, \"utf32le\")) {\n\t\ttype = R_STRING_TYPE_WIDE32;\n\t} else { // TODO utf16be, utf32be\n\t\teprintf (\"ERROR: encoding %s not supported\\n\", enc);\n\t\treturn;\n\t}\n\tstring_scan_range (list, bf, min, from, to, type, raw, section);\n}\n\nR_IPI RBinFile *r_bin_file_new(RBin *bin, const char *file, ut64 file_sz, int rawstr, int fd, const char *xtrname, Sdb *sdb, bool steal_ptr) {\n\tut32 bf_id;\n\tif (!r_id_pool_grab_id (bin->ids->pool, &bf_id)) {\n\t\treturn NULL;\n\t}\n\tRBinFile *bf = R_NEW0 (RBinFile);\n\tif (bf) {\n\t\tbf->id = bf_id;\n\t\tbf->rbin = bin;\n\t\tbf->file = file ? strdup (file) : NULL;\n\t\tbf->rawstr = rawstr;\n\t\tbf->fd = fd;\n\t\tbf->curxtr = xtrname ? r_bin_get_xtrplugin_by_name (bin, xtrname) : NULL;\n\t\tbf->sdb = sdb;\n\t\tbf->size = file_sz;\n\t\tbf->xtr_data = r_list_newf ((RListFree)r_bin_xtrdata_free);\n\t\tbf->xtr_obj = NULL;\n\t\tbf->sdb = sdb_new0 ();\n\t\tbf->sdb_addrinfo = sdb_new0 (); //ns (bf->sdb, \"addrinfo\", 1);\n\t\t// bf->sdb_addrinfo->refs++;\n\t}\n\treturn bf;\n}\n\nstatic RBinPlugin *get_plugin_from_buffer(RBin *bin, RBinFile *bf, const char *pluginname, RBuffer *buf) {\n\tRBinPlugin *plugin = bin->force? r_bin_get_binplugin_by_name (bin, bin->force): NULL;\n\tif (plugin) {\n\t\treturn plugin;\n\t}\n\tplugin = pluginname? r_bin_get_binplugin_by_name (bin, pluginname): NULL;\n\tif (plugin) {\n\t\treturn plugin;\n\t}\n\tplugin = r_bin_get_binplugin_by_buffer (bin, bf, buf);\n\tif (plugin) {\n\t\treturn plugin;\n\t}\n\treturn r_bin_get_binplugin_by_name (bin, \"any\");\n}\n\nR_API bool r_bin_file_object_new_from_xtr_data(RBin *bin, RBinFile *bf, ut64 baseaddr, ut64 loadaddr, RBinXtrData *data) {\n\tr_return_val_if_fail (bin && bf && data, false);\n\n\tut64 offset = data->offset;\n\tut64 sz = data->size;\n\n\tRBinPlugin *plugin = get_plugin_from_buffer (bin, bf, NULL, data->buf);\n\tbf->buf = r_buf_ref (data->buf);\n\n\tRBinObject *o = r_bin_object_new (bf, plugin, baseaddr, loadaddr, offset, sz);\n\tif (!o) {\n\t\treturn false;\n\t}\n\t// size is set here because the reported size of the object depends on\n\t// if loaded from xtr plugin or partially read\n\tif (!o->size) {\n\t\to->size = sz;\n\t}\n\tbf->narch = data->file_count;\n\tif (!o->info) {\n\t\to->info = R_NEW0 (RBinInfo);\n\t}\n\tR_FREE (o->info->file);\n\tR_FREE (o->info->arch);\n\tR_FREE (o->info->machine);\n\tR_FREE (o->info->type);\n\to->info->file = strdup (bf->file);\n\tif (data->metadata) {\n\t\tif (data->metadata->arch) {\n\t\t\to->info->arch = strdup (data->metadata->arch);\n\t\t}\n\t\tif (data->metadata->machine) {\n\t\t\to->info->machine = strdup (data->metadata->machine);\n\t\t}\n\t\tif (data->metadata->type) {\n\t\t\to->info->type = strdup (data->metadata->type);\n\t\t}\n\t\to->info->bits = data->metadata->bits;\n\t}\n\to->info->has_crypto = bf->o->info->has_crypto;\n\tdata->loaded = true;\n\treturn true;\n}\n\nstatic bool xtr_metadata_match(RBinXtrData *xtr_data, const char *arch, int bits) {\n\tif (!xtr_data->metadata || !xtr_data->metadata->arch) {\n\t\treturn false;\n\t}\n\tconst char *iter_arch = xtr_data->metadata->arch;\n\tint iter_bits = xtr_data->metadata->bits;\n\treturn bits == iter_bits && !strcmp (iter_arch, arch) && !xtr_data->loaded;\n}\n\nR_IPI RBinFile *r_bin_file_new_from_buffer(RBin *bin, const char *file, RBuffer *buf, int rawstr, ut64 baseaddr, ut64 loadaddr, int fd, const char *pluginname) {\n\tr_return_val_if_fail (bin && file && buf, NULL);\n\n\tRBinFile *bf = r_bin_file_new (bin, file, r_buf_size (buf), rawstr, fd, pluginname, NULL, false);\n\tif (bf) {\n\t\tRListIter *item = r_list_append (bin->binfiles, bf);\n\t\tbf->buf = r_buf_ref (buf);\n\t\tRBinPlugin *plugin = get_plugin_from_buffer (bin, bf, pluginname, bf->buf);\n\t\tRBinObject *o = r_bin_object_new (bf, plugin, baseaddr, loadaddr, 0, r_buf_size (bf->buf));\n\t\tif (!o) {\n\t\t\tr_list_delete (bin->binfiles, item);\n\t\t\treturn NULL;\n\t\t}\n\t\t// size is set here because the reported size of the object depends on\n\t\t// if loaded from xtr plugin or partially read\n\t\tif (!o->size) {\n\t\t\to->size = r_buf_size (buf);\n\t\t}\n\t}\n\treturn bf;\n}\n\nR_API RBinFile *r_bin_file_find_by_arch_bits(RBin *bin, const char *arch, int bits) {\n\tRListIter *iter;\n\tRBinFile *binfile = NULL;\n\tRBinXtrData *xtr_data;\n\n\tr_return_val_if_fail (bin && arch, NULL);\n\n\tr_list_foreach (bin->binfiles, iter, binfile) {\n\t\tRListIter *iter_xtr;\n\t\tif (!binfile->xtr_data) {\n\t\t\tcontinue;\n\t\t}\n\t\t// look for sub-bins in Xtr Data and Load if we need to\n\t\tr_list_foreach (binfile->xtr_data, iter_xtr, xtr_data) {\n\t\t\tif (xtr_metadata_match (xtr_data, arch, bits)) {\n\t\t\t\tif (!r_bin_file_object_new_from_xtr_data (bin, binfile, xtr_data->baddr,\n\t\t\t\t\t    xtr_data->laddr, xtr_data)) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn binfile;\n\t\t\t}\n\t\t}\n\t}\n\treturn binfile;\n}\n\nR_IPI RBinFile *r_bin_file_find_by_id(RBin *bin, ut32 bf_id) {\n\tRBinFile *bf;\n\tRListIter *iter;\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf->id == bf_id) {\n\t\t\treturn bf;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API ut64 r_bin_file_delete_all(RBin *bin) {\n\tif (bin) {\n\t\tut64 counter = r_list_length (bin->binfiles);\n\t\tr_list_purge (bin->binfiles);\n\t\tbin->cur = NULL;\n\t\treturn counter;\n\t}\n\treturn 0;\n}\n\nR_API bool r_bin_file_delete(RBin *bin, ut32 bin_id) {\n\tr_return_val_if_fail (bin, false);\n\n\tRListIter *iter;\n\tRBinFile *bf, *cur = r_bin_cur (bin);\n\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf && bf->id == bin_id) {\n\t\t\tif (cur && cur->id == bin_id) {\n\t\t\t\t// avoiding UaF due to dead reference\n\t\t\t\tbin->cur = NULL;\n\t\t\t}\n\t\t\tr_list_delete (bin->binfiles, iter);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nR_API RBinFile *r_bin_file_find_by_fd(RBin *bin, ut32 bin_fd) {\n\tRListIter *iter;\n\tRBinFile *bf;\n\n\tr_return_val_if_fail (bin, NULL);\n\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf->fd == bin_fd) {\n\t\t\treturn bf;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API RBinFile *r_bin_file_find_by_name(RBin *bin, const char *name) {\n\tRListIter *iter;\n\tRBinFile *bf;\n\n\tr_return_val_if_fail (bin && name, NULL);\n\n\tr_list_foreach (bin->binfiles, iter, bf) {\n\t\tif (bf->file && !strcmp (bf->file, name)) {\n\t\t\treturn bf;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nR_API bool r_bin_file_set_cur_by_id(RBin *bin, ut32 bin_id) {\n\tRBinFile *bf = r_bin_file_find_by_id (bin, bin_id);\n\treturn bf? r_bin_file_set_cur_binfile (bin, bf): false;\n}\n\nR_API bool r_bin_file_set_cur_by_fd(RBin *bin, ut32 bin_fd) {\n\tRBinFile *bf = r_bin_file_find_by_fd (bin, bin_fd);\n\treturn bf? r_bin_file_set_cur_binfile (bin, bf): false;\n}\n\nR_IPI bool r_bin_file_set_obj(RBin *bin, RBinFile *bf, RBinObject *obj) {\n\tr_return_val_if_fail (bin && bf, false);\n\tbin->file = bf->file;\n\tbin->cur = bf;\n\tbin->narch = bf->narch;\n\tif (obj) {\n\t\tbf->o = obj;\n\t} else {\n\t\tobj = bf->o;\n\t}\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (bf);\n\tif (bin->minstrlen < 1) {\n\t\tbin->minstrlen = plugin? plugin->minstrlen: bin->minstrlen;\n\t}\n\tif (obj) {\n\t\tif (!obj->info) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!obj->info->lang) {\n\t\t\tobj->info->lang = r_bin_lang_tostring (obj->lang);\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API bool r_bin_file_set_cur_binfile(RBin *bin, RBinFile *bf) {\n\tr_return_val_if_fail (bin && bf, false);\n\treturn r_bin_file_set_obj (bin, bf, bf->o);\n}\n\nR_API bool r_bin_file_set_cur_by_name(RBin *bin, const char *name) {\n\tr_return_val_if_fail (bin && name, false);\n\tRBinFile *bf = r_bin_file_find_by_name (bin, name);\n\treturn r_bin_file_set_cur_binfile (bin, bf);\n}\n\nR_API bool r_bin_file_deref(RBin *bin, RBinFile *a) {\n\tr_return_val_if_fail (bin && a, false);\n\tif (!r_bin_cur_object (bin)) {\n\t\treturn false;\n\t}\n\tbin->cur = NULL;\n\treturn true;\n}\n\nR_API void r_bin_file_free(void /*RBinFile*/ *_bf) {\n\tif (!_bf) {\n\t\treturn;\n\t}\n\tRBinFile *bf = _bf;\n\tRBinPlugin *plugin = r_bin_file_cur_plugin (bf);\n\t// Binary format objects are connected to the\n\t// RBinObject, so the plugin must destroy the\n\t// format data first\n\tif (plugin && plugin->destroy) {\n\t\tplugin->destroy (bf);\n\t}\n\tr_buf_free (bf->buf);\n\tif (bf->curxtr && bf->curxtr->destroy && bf->xtr_obj) {\n\t\tbf->curxtr->free_xtr ((void *)(bf->xtr_obj));\n\t}\n\t// TODO: unset related sdb namespaces\n\tif (bf->sdb_addrinfo) {\n\t\tsdb_free (bf->sdb_addrinfo);\n\t\tbf->sdb_addrinfo = NULL;\n\t}\n\tfree (bf->file);\n\tr_bin_object_free (bf->o);\n\tr_list_free (bf->xtr_data);\n\tif (bf->id != -1) {\n\t\t// TODO: use r_storage api\n\t\tr_id_pool_kick_id (bf->rbin->ids->pool, bf->id);\n\t}\n\t(void) r_bin_object_delete (bf->rbin, bf->id);\n\tfree (bf);\n}\n\nR_IPI RBinFile *r_bin_file_xtr_load_buffer(RBin *bin, RBinXtrPlugin *xtr, const char *filename, RBuffer *buf, ut64 baseaddr, ut64 loadaddr, int idx, int fd, int rawstr) {\n\tr_return_val_if_fail (bin && xtr && buf, NULL);\n\n\tRBinFile *bf = r_bin_file_find_by_name (bin, filename);\n\tif (!bf) {\n\t\tbf = r_bin_file_new (bin, filename, r_buf_size (buf), rawstr, fd, xtr->name, bin->sdb, false);\n\t\tif (!bf) {\n\t\t\treturn NULL;\n\t\t}\n\t\tr_list_append (bin->binfiles, bf);\n\t\tif (!bin->cur) {\n\t\t\tbin->cur = bf;\n\t\t}\n\t}\n\tr_list_free (bf->xtr_data);\n\tbf->xtr_data = NULL;\n\tif (xtr->extractall_from_buffer) {\n\t\tbf->xtr_data = xtr->extractall_from_buffer (bin, buf);\n\t} else if (xtr->extractall_from_bytes) {\n\t\tut64 sz = 0;\n\t\tconst ut8 *bytes = r_buf_data (buf, &sz);\n\t\teprintf (\"TODO: Implement extractall_from_buffer in '%s' xtr.bin plugin\\n\", xtr->name);\n\t\tbf->xtr_data = xtr->extractall_from_bytes (bin, bytes, sz);\n\t}\n\tif (bf->xtr_data) {\n\t\tRListIter *iter;\n\t\tRBinXtrData *x;\n\t\t//populate xtr_data with baddr and laddr that will be used later on\n\t\t//r_bin_file_object_new_from_xtr_data\n\t\tr_list_foreach (bf->xtr_data, iter, x) {\n\t\t\tx->baddr = baseaddr? baseaddr : UT64_MAX;\n\t\t\tx->laddr = loadaddr? loadaddr : UT64_MAX;\n\t\t}\n\t}\n\tbf->loadaddr = loadaddr;\n\treturn bf;\n}\n\n// XXX deprecate this function imho.. wee can just access bf->buf directly\nR_IPI bool r_bin_file_set_bytes(RBinFile *bf, const ut8 *bytes, ut64 sz, bool steal_ptr) {\n\tr_return_val_if_fail (bf && bytes, false);\n\tr_buf_free (bf->buf);\n\tif (steal_ptr) {\n\t\tbf->buf = r_buf_new_with_pointers (bytes, sz, true);\n\t} else {\n\t\tbf->buf = r_buf_new_with_bytes (bytes, sz);\n\t}\n\treturn bf->buf;\n}\n\nR_API RBinPlugin *r_bin_file_cur_plugin(RBinFile *bf) {\n\treturn (bf && bf->o)? bf->o->plugin: NULL;\n}\n\n// TODO: searchStrings() instead\nR_IPI RList *r_bin_file_get_strings(RBinFile *bf, int min, int dump, int raw) {\n\tr_return_val_if_fail (bf, NULL);\n\tRListIter *iter;\n\tRBinSection *section;\n\tRList *ret = dump? NULL: r_list_newf (r_bin_string_free);\n\n\tif (!raw && bf && bf->o && bf->o->sections && !r_list_empty (bf->o->sections)) {\n\t\tRBinObject *o = bf->o;\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\tif (__isDataSection (bf, section)) {\n\t\t\t\tget_strings_range (bf, ret, min, raw, section->paddr,\n\t\t\t\t\t\tsection->paddr + section->size, section);\n\t\t\t}\n\t\t}\n\t\tr_list_foreach (o->sections, iter, section) {\n\t\t\t/* load objc/swift strings */\n\t\t\tconst int bits = (bf->o && bf->o->info) ? bf->o->info->bits : 32;\n\t\t\tconst int cfstr_size = (bits == 64) ? 32 : 16;\n\t\t\tconst int cfstr_offs = (bits == 64) ? 16 :  8;\n\t\t\tif (strstr (section->name, \"__cfstring\")) {\n\t\t\t\tint i;\n\t\t\t\t// XXX do not walk if bin.strings == 0\n\t\t\t\tut8 *p;\n\t\t\t\tif (section->size > bf->size) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut8 *sbuf = malloc (section->size);\n\t\t\t\tif (!sbuf) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tr_buf_read_at (bf->buf, section->paddr + cfstr_offs, sbuf, section->size);\n\t\t\t\tfor (i = 0; i < section->size; i += cfstr_size) {\n\t\t\t\t\tut8 *buf = sbuf;\n\t\t\t\t\tp = buf + i;\n\t\t\t\t\tif ((i + ((bits == 64)? 8: 4)) >= section->size) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 cfstr_vaddr = section->vaddr + i;\n\t\t\t\t\tut64 cstr_vaddr = (bits == 64) ? r_read_le64 (p) : r_read_le32 (p);\n\t\t\t\t\tRBinString *s = __stringAt (bf, ret, cstr_vaddr);\n\t\t\t\t\tif (s) {\n\t\t\t\t\t\tRBinString *bs = R_NEW0 (RBinString);\n\t\t\t\t\t\tif (bs) {\n\t\t\t\t\t\t\tbs->type = s->type;\n\t\t\t\t\t\t\tbs->length = s->length;\n\t\t\t\t\t\t\tbs->size = s->size;\n\t\t\t\t\t\t\tbs->ordinal = s->ordinal;\n\t\t\t\t\t\t\tbs->vaddr = cfstr_vaddr;\n\t\t\t\t\t\t\tbs->paddr = cfstr_vaddr; // XXX should be paddr instead\n\t\t\t\t\t\t\tbs->string = r_str_newf (\"cstr.%s\", s->string);\n\t\t\t\t\t\t\tr_list_append (ret, bs);\n\t\t\t\t\t\t\tht_up_insert (o->strings_db, bs->vaddr, bs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (sbuf);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tget_strings_range (bf, ret, min, raw, 0, bf->size, NULL);\n\t}\n\treturn ret;\n}\n\nR_API ut64 r_bin_file_get_baddr(RBinFile *bf) {\n\tif (bf && bf->o) {\n\t\treturn bf->o->baddr;\n\t}\n\treturn UT64_MAX;\n}\n\nR_API bool r_bin_file_close(RBin *bin, int bd) {\n\tr_return_val_if_fail (bin, false);\n\tRBinFile *bf = r_id_storage_take (bin->ids, bd);\n\tif (bf) {\n\t\t// file_free removes the fd already.. maybe its unnecessary\n\t\tr_id_storage_delete (bin->ids, bd);\n\t\tr_bin_file_free (bf);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API RList *r_bin_file_compute_hashes(RBin *bin, ut64 limit) {\n\tr_return_val_if_fail (bin && bin->cur && bin->cur->o, NULL);\n\tut64 buf_len = 0, r = 0;\n\tRBinFile *bf = bin->cur;\n\tRBinObject *o = bf->o;\n\n\tRIODesc *iod = r_io_desc_get (bin->iob.io, bf->fd);\n\tif (!iod) {\n\t\treturn NULL;\n\t}\n\n\tbuf_len = r_io_desc_size (iod);\n\t// By SLURP_LIMIT normally cannot compute ...\n\tif (buf_len > limit) {\n\t\tif (bin->verbose) {\n\t\t\teprintf (\"Warning: r_bin_file_hash: file exceeds bin.hashlimit\\n\");\n\t\t}\n\t\treturn NULL;\n\t}\n\tconst size_t blocksize = 64000;\n\tut8 *buf = malloc (blocksize);\n\tif (!buf) {\n\t\teprintf (\"Cannot allocate computation buffer\\n\");\n\t\treturn NULL;\n\t}\n\n\tchar hash[128];\n\tRHash *ctx = r_hash_new (false, R_HASH_MD5 | R_HASH_SHA1 | R_HASH_SHA256);\n\twhile (r + blocksize < buf_len) {\n\t\tr_io_desc_seek (iod, r, R_IO_SEEK_SET);\n\t\tint b = r_io_desc_read (iod, buf, blocksize);\n\t\t(void)r_hash_do_md5 (ctx, buf, blocksize);\n\t\t(void)r_hash_do_sha1 (ctx, buf, blocksize);\n\t\t(void)r_hash_do_sha256 (ctx, buf, blocksize);\n\t\tr += b;\n\t}\n\tif (r < buf_len) {\n\t\tr_io_desc_seek (iod, r, R_IO_SEEK_SET);\n\t\tconst size_t rem_len = buf_len-r;\n\t\tint b = r_io_desc_read (iod, buf, rem_len);\n\t\tif (b < 1) {\n\t\t\teprintf (\"r_io_desc_read: error\\n\");\n\t\t} else {\n\t\t\t(void)r_hash_do_md5 (ctx, buf, b);\n\t\t\t(void)r_hash_do_sha1 (ctx, buf, b);\n\t\t\t(void)r_hash_do_sha256 (ctx, buf, b);\n\t\t}\n\t}\n\tr_hash_do_end (ctx, R_HASH_MD5);\n\tr_hex_bin2str (ctx->digest, R_HASH_SIZE_MD5, hash);\n\n\tRList *file_hashes = r_list_newf ((RListFree) r_bin_file_hash_free);\n\tRBinFileHash *md5h = R_NEW0 (RBinFileHash);\n\tif (md5h) {\n\t\tmd5h->type = strdup (\"md5\");\n\t\tmd5h->hex = strdup (hash);\n\t\tr_list_push (file_hashes, md5h);\n\t}\n\tr_hash_do_end (ctx, R_HASH_SHA1);\n\tr_hex_bin2str (ctx->digest, R_HASH_SIZE_SHA1, hash);\n\n\tRBinFileHash *sha1h = R_NEW0 (RBinFileHash);\n\tif (sha1h) {\n\t\tsha1h->type = strdup (\"sha1\");\n\t\tsha1h->hex = strdup (hash);\n\t\tr_list_push (file_hashes, sha1h);\n\t}\n\tr_hash_do_end (ctx, R_HASH_SHA256);\n\tr_hex_bin2str (ctx->digest, R_HASH_SIZE_SHA256, hash);\n\n\tRBinFileHash *sha256h = R_NEW0 (RBinFileHash);\n\tif (sha256h) {\n\t\tsha256h->type = strdup (\"sha256\");\n\t\tsha256h->hex = strdup (hash);\n\t\tr_list_push (file_hashes, sha256h);\n\t}\n\n\tif (o->plugin && o->plugin->hashes) {\n\t\tRList *plugin_hashes = o->plugin->hashes (bf);\n\t\tr_list_join (file_hashes, plugin_hashes);\n\t\tfree (plugin_hashes);\n\t}\n\t// TODO: add here more rows\n\n\tfree (buf);\n\tr_hash_free (ctx);\n\treturn file_hashes;\n}\n\n// Set new hashes to current RBinInfo, caller should free the returned RList\nR_API RList *r_bin_file_set_hashes(RBin *bin, RList/*<RBinFileHash*/ *new_hashes) {\n\tr_return_val_if_fail (bin && bin->cur && bin->cur->o && bin->cur->o->info, NULL);\n\tRBinFile *bf = bin->cur;\n\tRBinInfo *info = bf->o->info;\n\n\tRList *prev_hashes = info->file_hashes;\n\tinfo->file_hashes = new_hashes;\n\n\treturn prev_hashes;\n}\n\nR_IPI RBinClass *r_bin_class_new(const char *name, const char *super, int view) {\n\tr_return_val_if_fail (name, NULL);\n\tRBinClass *c = R_NEW0 (RBinClass);\n\tif (c) {\n\t\tc->name = strdup (name);\n\t\tc->super = super? strdup (super): NULL;\n\t\tc->methods = r_list_new ();\n\t\tc->fields = r_list_new ();\n\t\tc->visibility = view;\n\t}\n\treturn c;\n}\n\nR_IPI void r_bin_class_free(RBinClass *k) {\n\tif (k) {\n\t\tfree (k->name);\n\t\tfree (k->super);\n\t\tfree (k->visibility_str);\n\t\tr_list_free (k->methods);\n\t\tr_list_free (k->fields);\n\t\tfree (k);\n\t}\n}\n\nR_API RBinClass *r_bin_file_add_class(RBinFile *bf, const char *name, const char *super, int view) {\n\tr_return_val_if_fail (name && bf && bf->o, NULL);\n\tRBinClass *c = __getClass (bf, name);\n\tif (c) {\n\t\tif (super) {\n\t\t\tfree (c->super);\n\t\t\tc->super = strdup (super);\n\t\t}\n\t\treturn c;\n\t}\n\tc = r_bin_class_new (name, super, view);\n\tif (c) {\n\t\t// XXX. no need for a list, the ht is iterable too\n\t\tc->index = r_list_length (bf->o->classes);\n\t\tr_list_append (bf->o->classes, c);\n\t\tht_pp_insert (bf->o->classes_ht, name, c);\n\t}\n\treturn c;\n}\n\nR_API RBinSymbol *r_bin_file_add_method(RBinFile *bf, const char *klass, const char *method, int nargs) {\n\tr_return_val_if_fail (bf, NULL);\n\n\tRBinClass *c = r_bin_file_add_class (bf, klass, NULL, 0);\n\tif (!c) {\n\t\teprintf (\"Cannot allocate class %s\\n\", klass);\n\t\treturn NULL;\n\t}\n\tRBinSymbol *sym = __getMethod (bf, klass, method);\n\tif (!sym) {\n\t\tsym = R_NEW0 (RBinSymbol);\n\t\tif (sym) {\n\t\t\tsym->name = strdup (method);\n\t\t\tr_list_append (c->methods, sym);\n\t\t\tchar *name = r_str_newf (\"%s::%s\", klass, method);\n\t\t\tht_pp_insert (bf->o->methods_ht, name, sym);\n\t\t\tfree (name);\n\t\t}\n\t}\n\treturn sym;\n}\n\nR_API RBinField *r_bin_file_add_field(RBinFile *binfile, const char *classname, const char *name) {\n\t//TODO: add_field into class\n\t//eprintf (\"TODO add field: %s \\n\", name);\n\treturn NULL;\n}\n\n// XXX this api name makes no sense\n/* returns vaddr, rebased with the baseaddr of binfile, if va is enabled for\n * bin, paddr otherwise */\nR_API ut64 r_bin_file_get_vaddr(RBinFile *bf, ut64 paddr, ut64 vaddr) {\n\tr_return_val_if_fail (bf && bf->o, paddr);\n\tif (bf->o->info && bf->o->info->has_va) {\n\t\treturn binobj_a2b (bf->o, vaddr);\n\t}\n\treturn paddr;\n}\n\nR_API RList *r_bin_file_get_trycatch(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->plugin, NULL);\n\tif (bf->o->plugin->trycatch) {\n\t\treturn bf->o->plugin->trycatch (bf);\n\t}\n\treturn NULL;\n}\n\nR_API RList *r_bin_file_get_symbols(RBinFile *bf) {\n\tr_return_val_if_fail (bf, NULL);\n\tRBinObject *o = bf->o;\n\treturn o? o->symbols: NULL;\n}\n"], "filenames": ["libr/bin/bfile.c"], "buggy_code_start_loc": [181], "buggy_code_end_loc": [252], "fixing_code_start_loc": [181], "fixing_code_end_loc": [252], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository radareorg/radare2 prior to 5.7.0.", "other": {"cve": {"id": "CVE-2022-1899", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-26T17:15:08.893", "lastModified": "2022-06-03T12:43:48.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository radareorg/radare2 prior to 5.7.0."}, {"lang": "es", "value": "Una Lectura Fuera de L\u00edmites en el repositorio GitHub radareorg/radare2 versiones anteriores a 5.7.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.7.0", "matchCriteriaId": "A79BEA4D-5D5F-4593-B2CA-0CA4C22C1C0A"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/193f4fe01d7f626e2ea937450f2e0c4604420e9d", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8a3dc5cb-08b3-4807-82b2-77f08c137a04", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/193f4fe01d7f626e2ea937450f2e0c4604420e9d"}}