{"buggy_code": ["/*\n *  SSLv3/TLSv1 client-side functions\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_SSL_CLI_C)\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdlib.h>\n#define mbedtls_calloc    calloc\n#define mbedtls_free      free\n#endif\n\n#include \"mbedtls/debug.h\"\n#include \"mbedtls/ssl.h\"\n#include \"mbedtls/ssl_internal.h\"\n\n#include <string.h>\n\n#include <stdint.h>\n\n#if defined(MBEDTLS_HAVE_TIME)\n#include \"mbedtls/platform_time.h\"\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n/* Implementation that should never be optimized out by the compiler */\nstatic void mbedtls_zeroize( void *v, size_t n ) {\n    volatile unsigned char *p = v; while( n-- ) *p++ = 0;\n}\n#endif\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\nstatic void ssl_write_hostname_ext( mbedtls_ssl_context *ssl,\n                                    unsigned char *buf,\n                                    size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    size_t hostname_len;\n\n    *olen = 0;\n\n    if( ssl->hostname == NULL )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding server name extension: %s\",\n                   ssl->hostname ) );\n\n    hostname_len = strlen( ssl->hostname );\n\n    if( end < p || (size_t)( end - p ) < hostname_len + 9 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    /*\n     * Sect. 3, RFC 6066 (TLS Extensions Definitions)\n     *\n     * In order to provide any of the server names, clients MAY include an\n     * extension of type \"server_name\" in the (extended) client hello. The\n     * \"extension_data\" field of this extension SHALL contain\n     * \"ServerNameList\" where:\n     *\n     * struct {\n     *     NameType name_type;\n     *     select (name_type) {\n     *         case host_name: HostName;\n     *     } name;\n     * } ServerName;\n     *\n     * enum {\n     *     host_name(0), (255)\n     * } NameType;\n     *\n     * opaque HostName<1..2^16-1>;\n     *\n     * struct {\n     *     ServerName server_name_list<1..2^16-1>\n     * } ServerNameList;\n     *\n     */\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SERVERNAME >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SERVERNAME      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( (hostname_len + 5) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( (hostname_len + 5)      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( (hostname_len + 3) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( (hostname_len + 3)      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME ) & 0xFF );\n    *p++ = (unsigned char)( ( hostname_len >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( hostname_len      ) & 0xFF );\n\n    memcpy( p, ssl->hostname, hostname_len );\n\n    *olen = hostname_len + 9;\n}\n#endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\nstatic void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    /* We're always including an TLS_EMPTY_RENEGOTIATION_INFO_SCSV in the\n     * initial ClientHello, in which case also adding the renegotiation\n     * info extension is NOT RECOMMENDED as per RFC 5746 Section 3.4. */\n    if( ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding renegotiation extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 5 + ssl->verify_data_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    /*\n     * Secure renegotiation\n     */\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = ( ssl->verify_data_len + 1 ) & 0xFF;\n    *p++ = ssl->verify_data_len & 0xFF;\n\n    memcpy( p, ssl->own_verify_data, ssl->verify_data_len );\n\n    *olen = 5 + ssl->verify_data_len;\n}\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n/*\n * Only if we handle at least one key exchange that needs signatures.\n */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\nstatic void ssl_write_signature_algorithms_ext( mbedtls_ssl_context *ssl,\n                                                unsigned char *buf,\n                                                size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    size_t sig_alg_len = 0;\n    const int *md;\n#if defined(MBEDTLS_RSA_C) || defined(MBEDTLS_ECDSA_C)\n    unsigned char *sig_alg_list = buf + 6;\n#endif\n\n    *olen = 0;\n\n    if( ssl->conf->max_minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding signature_algorithms extension\" ) );\n\n    for( md = ssl->conf->sig_hashes; *md != MBEDTLS_MD_NONE; md++ )\n    {\n#if defined(MBEDTLS_ECDSA_C)\n        sig_alg_len += 2;\n#endif\n#if defined(MBEDTLS_RSA_C)\n        sig_alg_len += 2;\n#endif\n    }\n\n    if( end < p || (size_t)( end - p ) < sig_alg_len + 6 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    /*\n     * Prepare signature_algorithms extension (TLS 1.2)\n     */\n    sig_alg_len = 0;\n\n    for( md = ssl->conf->sig_hashes; *md != MBEDTLS_MD_NONE; md++ )\n    {\n#if defined(MBEDTLS_ECDSA_C)\n        sig_alg_list[sig_alg_len++] = mbedtls_ssl_hash_from_md_alg( *md );\n        sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_ECDSA;\n#endif\n#if defined(MBEDTLS_RSA_C)\n        sig_alg_list[sig_alg_len++] = mbedtls_ssl_hash_from_md_alg( *md );\n        sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_RSA;\n#endif\n    }\n\n    /*\n     * enum {\n     *     none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),\n     *     sha512(6), (255)\n     * } HashAlgorithm;\n     *\n     * enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }\n     *   SignatureAlgorithm;\n     *\n     * struct {\n     *     HashAlgorithm hash;\n     *     SignatureAlgorithm signature;\n     * } SignatureAndHashAlgorithm;\n     *\n     * SignatureAndHashAlgorithm\n     *   supported_signature_algorithms<2..2^16-2>;\n     */\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SIG_ALG >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SIG_ALG      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( ( sig_alg_len + 2 ) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( ( sig_alg_len + 2 )      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( sig_alg_len >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( sig_alg_len      ) & 0xFF );\n\n    *olen = 6 + sig_alg_len;\n}\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&\n          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic void ssl_write_supported_elliptic_curves_ext( mbedtls_ssl_context *ssl,\n                                                     unsigned char *buf,\n                                                     size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    unsigned char *elliptic_curve_list = p + 6;\n    size_t elliptic_curve_len = 0;\n    const mbedtls_ecp_curve_info *info;\n#if defined(MBEDTLS_ECP_C)\n    const mbedtls_ecp_group_id *grp_id;\n#else\n    ((void) ssl);\n#endif\n\n    *olen = 0;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding supported_elliptic_curves extension\" ) );\n\n#if defined(MBEDTLS_ECP_C)\n    for( grp_id = ssl->conf->curve_list; *grp_id != MBEDTLS_ECP_DP_NONE; grp_id++ )\n#else\n    for( info = mbedtls_ecp_curve_list(); info->grp_id != MBEDTLS_ECP_DP_NONE; info++ )\n#endif\n    {\n#if defined(MBEDTLS_ECP_C)\n        info = mbedtls_ecp_curve_info_from_grp_id( *grp_id );\n#endif\n        if( info == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"invalid curve in ssl configuration\" ) );\n            return;\n        }\n\n        elliptic_curve_len += 2;\n    }\n\n    if( end < p || (size_t)( end - p ) < 6 + elliptic_curve_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    elliptic_curve_len = 0;\n\n#if defined(MBEDTLS_ECP_C)\n    for( grp_id = ssl->conf->curve_list; *grp_id != MBEDTLS_ECP_DP_NONE; grp_id++ )\n#else\n    for( info = mbedtls_ecp_curve_list(); info->grp_id != MBEDTLS_ECP_DP_NONE; info++ )\n#endif\n    {\n#if defined(MBEDTLS_ECP_C)\n        info = mbedtls_ecp_curve_info_from_grp_id( *grp_id );\n#endif\n        elliptic_curve_list[elliptic_curve_len++] = info->tls_id >> 8;\n        elliptic_curve_list[elliptic_curve_len++] = info->tls_id & 0xFF;\n    }\n\n    if( elliptic_curve_len == 0 )\n        return;\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( ( elliptic_curve_len + 2 ) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( ( elliptic_curve_len + 2 )      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( ( elliptic_curve_len     ) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( ( elliptic_curve_len     )      ) & 0xFF );\n\n    *olen = 6 + elliptic_curve_len;\n}\n\nstatic void ssl_write_supported_point_formats_ext( mbedtls_ssl_context *ssl,\n                                                   unsigned char *buf,\n                                                   size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding supported_point_formats extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 6 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 2;\n\n    *p++ = 1;\n    *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;\n\n    *olen = 6;\n}\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C || \n          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic void ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,\n                                        unsigned char *buf,\n                                        size_t *olen )\n{\n    int ret;\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    size_t kkpp_len;\n\n    *olen = 0;\n\n    /* Skip costly extension if we can't use EC J-PAKE anyway */\n    if( mbedtls_ecjpake_check( &ssl->handshake->ecjpake_ctx ) != 0 )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding ecjpake_kkpp extension\" ) );\n\n    if( end - p < 4 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP      ) & 0xFF );\n\n    /*\n     * We may need to send ClientHello multiple times for Hello verification.\n     * We don't want to compute fresh values every time (both for performance\n     * and consistency reasons), so cache the extension content.\n     */\n    if( ssl->handshake->ecjpake_cache == NULL ||\n        ssl->handshake->ecjpake_cache_len == 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"generating new ecjpake parameters\" ) );\n\n        ret = mbedtls_ecjpake_write_round_one( &ssl->handshake->ecjpake_ctx,\n                                        p + 2, end - p - 2, &kkpp_len,\n                                        ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1 , \"mbedtls_ecjpake_write_round_one\", ret );\n            return;\n        }\n\n        ssl->handshake->ecjpake_cache = mbedtls_calloc( 1, kkpp_len );\n        if( ssl->handshake->ecjpake_cache == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"allocation failed\" ) );\n            return;\n        }\n\n        memcpy( ssl->handshake->ecjpake_cache, p + 2, kkpp_len );\n        ssl->handshake->ecjpake_cache_len = kkpp_len;\n    }\n    else\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"re-using cached ecjpake parameters\" ) );\n\n        kkpp_len = ssl->handshake->ecjpake_cache_len;\n\n        if( (size_t)( end - p - 2 ) < kkpp_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n            return;\n        }\n\n        memcpy( p + 2, ssl->handshake->ecjpake_cache, kkpp_len );\n    }\n\n    *p++ = (unsigned char)( ( kkpp_len >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( kkpp_len      ) & 0xFF );\n\n    *olen = kkpp_len + 4;\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\nstatic void ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,\n                                               unsigned char *buf,\n                                               size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl->conf->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE ) {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding max_fragment_length extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 5 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 1;\n\n    *p++ = ssl->conf->mfl_code;\n\n    *olen = 5;\n}\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\nstatic void ssl_write_truncated_hmac_ext( mbedtls_ssl_context *ssl,\n                                          unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding truncated_hmac extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 4 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\nstatic void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,\n                                       unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED ||\n        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding encrypt_then_mac \"\n                        \"extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 4 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\nstatic void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,\n                                       unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||\n        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding extended_master_secret \"\n                        \"extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 4 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\nstatic void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,\n                                          unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    size_t tlen = ssl->session_negotiate->ticket_len;\n\n    *olen = 0;\n\n    if( ssl->conf->session_tickets == MBEDTLS_SSL_SESSION_TICKETS_DISABLED )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding session ticket extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 4 + tlen )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( tlen >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( tlen      ) & 0xFF );\n\n    *olen = 4;\n\n    if( ssl->session_negotiate->ticket == NULL || tlen == 0 )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"sending session ticket of length %d\", tlen ) );\n\n    memcpy( p, ssl->session_negotiate->ticket, tlen );\n\n    *olen += tlen;\n}\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n#if defined(MBEDTLS_SSL_ALPN)\nstatic void ssl_write_alpn_ext( mbedtls_ssl_context *ssl,\n                                unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    size_t alpnlen = 0;\n    const char **cur;\n\n    *olen = 0;\n\n    if( ssl->conf->alpn_list == NULL )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding alpn extension\" ) );\n\n    for( cur = ssl->conf->alpn_list; *cur != NULL; cur++ )\n        alpnlen += (unsigned char)( strlen( *cur ) & 0xFF ) + 1;\n\n    if( end < p || (size_t)( end - p ) < 6 + alpnlen )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN      ) & 0xFF );\n\n    /*\n     * opaque ProtocolName<1..2^8-1>;\n     *\n     * struct {\n     *     ProtocolName protocol_name_list<2..2^16-1>\n     * } ProtocolNameList;\n     */\n\n    /* Skip writing extension and list length for now */\n    p += 4;\n\n    for( cur = ssl->conf->alpn_list; *cur != NULL; cur++ )\n    {\n        *p = (unsigned char)( strlen( *cur ) & 0xFF );\n        memcpy( p + 1, *cur, *p );\n        p += 1 + *p;\n    }\n\n    *olen = p - buf;\n\n    /* List length = olen - 2 (ext_type) - 2 (ext_len) - 2 (list_len) */\n    buf[4] = (unsigned char)( ( ( *olen - 6 ) >> 8 ) & 0xFF );\n    buf[5] = (unsigned char)( ( ( *olen - 6 )      ) & 0xFF );\n\n    /* Extension length = olen - 2 (ext_type) - 2 (ext_len) */\n    buf[2] = (unsigned char)( ( ( *olen - 4 ) >> 8 ) & 0xFF );\n    buf[3] = (unsigned char)( ( ( *olen - 4 )      ) & 0xFF );\n}\n#endif /* MBEDTLS_SSL_ALPN */\n\n/*\n * Generate random bytes for ClientHello\n */\nstatic int ssl_generate_random( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    unsigned char *p = ssl->handshake->randbytes;\n#if defined(MBEDTLS_HAVE_TIME)\n    mbedtls_time_t t;\n#endif\n\n    /*\n     * When responding to a verify request, MUST reuse random (RFC 6347 4.2.1)\n     */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n        ssl->handshake->verify_cookie != NULL )\n    {\n        return( 0 );\n    }\n#endif\n\n#if defined(MBEDTLS_HAVE_TIME)\n    t = mbedtls_time( NULL );\n    *p++ = (unsigned char)( t >> 24 );\n    *p++ = (unsigned char)( t >> 16 );\n    *p++ = (unsigned char)( t >>  8 );\n    *p++ = (unsigned char)( t       );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, current time: %lu\", t ) );\n#else\n    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 4 ) ) != 0 )\n        return( ret );\n\n    p += 4;\n#endif /* MBEDTLS_HAVE_TIME */\n\n    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 28 ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}\n\nstatic int ssl_write_client_hello( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    size_t i, n, olen, ext_len = 0;\n    unsigned char *buf;\n    unsigned char *p, *q;\n    unsigned char offer_compress;\n    const int *ciphersuites;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write client hello\" ) );\n\n    if( ssl->conf->f_rng == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"no RNG provided\") );\n        return( MBEDTLS_ERR_SSL_NO_RNG );\n    }\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )\n#endif\n    {\n        ssl->major_ver = ssl->conf->min_major_ver;\n        ssl->minor_ver = ssl->conf->min_minor_ver;\n    }\n\n    if( ssl->conf->max_major_ver == 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"configured max major version is invalid, \"\n                            \"consider using mbedtls_ssl_config_defaults()\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    /*\n     *     0  .   0   handshake type\n     *     1  .   3   handshake length\n     *     4  .   5   highest version supported\n     *     6  .   9   current UNIX time\n     *    10  .  37   random bytes\n     */\n    buf = ssl->out_msg;\n    p = buf + 4;\n\n    mbedtls_ssl_write_version( ssl->conf->max_major_ver, ssl->conf->max_minor_ver,\n                       ssl->conf->transport, p );\n    p += 2;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, max version: [%d:%d]\",\n                   buf[4], buf[5] ) );\n\n    if( ( ret = ssl_generate_random( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_generate_random\", ret );\n        return( ret );\n    }\n\n    memcpy( p, ssl->handshake->randbytes, 32 );\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, random bytes\", p, 32 );\n    p += 32;\n\n    /*\n     *    38  .  38   session id length\n     *    39  . 39+n  session id\n     *   39+n . 39+n  DTLS only: cookie length (1 byte)\n     *   40+n .  ..   DTSL only: cookie\n     *   ..   . ..    ciphersuitelist length (2 bytes)\n     *   ..   . ..    ciphersuitelist\n     *   ..   . ..    compression methods length (1 byte)\n     *   ..   . ..    compression methods\n     *   ..   . ..    extensions length (2 bytes)\n     *   ..   . ..    extensions\n     */\n    n = ssl->session_negotiate->id_len;\n\n    if( n < 16 || n > 32 ||\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE ||\n#endif\n        ssl->handshake->resume == 0 )\n    {\n        n = 0;\n    }\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n    /*\n     * RFC 5077 section 3.4: \"When presenting a ticket, the client MAY\n     * generate and include a Session ID in the TLS ClientHello.\"\n     */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )\n#endif\n    {\n        if( ssl->session_negotiate->ticket != NULL &&\n                ssl->session_negotiate->ticket_len != 0 )\n        {\n            ret = ssl->conf->f_rng( ssl->conf->p_rng, ssl->session_negotiate->id, 32 );\n\n            if( ret != 0 )\n                return( ret );\n\n            ssl->session_negotiate->id_len = n = 32;\n        }\n    }\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n    *p++ = (unsigned char) n;\n\n    for( i = 0; i < n; i++ )\n        *p++ = ssl->session_negotiate->id[i];\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, session id len.: %d\", n ) );\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"client hello, session id\", buf + 39, n );\n\n    /*\n     * DTLS cookie\n     */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        if( ssl->handshake->verify_cookie == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"no verify cookie to send\" ) );\n            *p++ = 0;\n        }\n        else\n        {\n            MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, cookie\",\n                              ssl->handshake->verify_cookie,\n                              ssl->handshake->verify_cookie_len );\n\n            *p++ = ssl->handshake->verify_cookie_len;\n            memcpy( p, ssl->handshake->verify_cookie,\n                       ssl->handshake->verify_cookie_len );\n            p += ssl->handshake->verify_cookie_len;\n        }\n    }\n#endif\n\n    /*\n     * Ciphersuite list\n     */\n    ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];\n\n    /* Skip writing ciphersuite length for now */\n    n = 0;\n    q = p;\n    p += 2;\n\n    for( i = 0; ciphersuites[i] != 0; i++ )\n    {\n        ciphersuite_info = mbedtls_ssl_ciphersuite_from_id( ciphersuites[i] );\n\n        if( ciphersuite_info == NULL )\n            continue;\n\n        if( ciphersuite_info->min_minor_ver > ssl->conf->max_minor_ver ||\n            ciphersuite_info->max_minor_ver < ssl->conf->min_minor_ver )\n            continue;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n            ( ciphersuite_info->flags & MBEDTLS_CIPHERSUITE_NODTLS ) )\n            continue;\n#endif\n\n#if defined(MBEDTLS_ARC4_C)\n        if( ssl->conf->arc4_disabled == MBEDTLS_SSL_ARC4_DISABLED &&\n            ciphersuite_info->cipher == MBEDTLS_CIPHER_ARC4_128 )\n            continue;\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE &&\n            mbedtls_ecjpake_check( &ssl->handshake->ecjpake_ctx ) != 0 )\n            continue;\n#endif\n\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, add ciphersuite: %04x\",\n                                    ciphersuites[i] ) );\n\n        n++;\n        *p++ = (unsigned char)( ciphersuites[i] >> 8 );\n        *p++ = (unsigned char)( ciphersuites[i]      );\n    }\n\n    /*\n     * Add TLS_EMPTY_RENEGOTIATION_INFO_SCSV\n     */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )\n#endif\n    {\n        *p++ = (unsigned char)( MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO >> 8 );\n        *p++ = (unsigned char)( MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO      );\n        n++;\n    }\n\n    /* Some versions of OpenSSL don't handle it correctly if not at end */\n#if defined(MBEDTLS_SSL_FALLBACK_SCSV)\n    if( ssl->conf->fallback == MBEDTLS_SSL_IS_FALLBACK )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"adding FALLBACK_SCSV\" ) );\n        *p++ = (unsigned char)( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 );\n        *p++ = (unsigned char)( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      );\n        n++;\n    }\n#endif\n\n    *q++ = (unsigned char)( n >> 7 );\n    *q++ = (unsigned char)( n << 1 );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, got %d ciphersuites\", n ) );\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    offer_compress = 1;\n#else\n    offer_compress = 0;\n#endif\n\n    /*\n     * We don't support compression with DTLS right now: is many records come\n     * in the same datagram, uncompressing one could overwrite the next one.\n     * We don't want to add complexity for handling that case unless there is\n     * an actual need for it.\n     */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        offer_compress = 0;\n#endif\n\n    if( offer_compress )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, compress len.: %d\", 2 ) );\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, compress alg.: %d %d\",\n                            MBEDTLS_SSL_COMPRESS_DEFLATE, MBEDTLS_SSL_COMPRESS_NULL ) );\n\n        *p++ = 2;\n        *p++ = MBEDTLS_SSL_COMPRESS_DEFLATE;\n        *p++ = MBEDTLS_SSL_COMPRESS_NULL;\n    }\n    else\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, compress len.: %d\", 1 ) );\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, compress alg.: %d\",\n                            MBEDTLS_SSL_COMPRESS_NULL ) );\n\n        *p++ = 1;\n        *p++ = MBEDTLS_SSL_COMPRESS_NULL;\n    }\n\n    // First write extensions, then the total length\n    //\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    ssl_write_hostname_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n    /* Note that TLS_EMPTY_RENEGOTIATION_INFO_SCSV is always added\n     * even if MBEDTLS_SSL_RENEGOTIATION is not defined. */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n    ssl_write_signature_algorithms_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    ssl_write_supported_elliptic_curves_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n\n    ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    ssl_write_ecjpake_kkpp_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n    ssl_write_max_fragment_length_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n    ssl_write_truncated_hmac_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n    ssl_write_encrypt_then_mac_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n    ssl_write_extended_ms_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_ALPN)\n    ssl_write_alpn_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n    ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n    /* olen unused if all extensions are disabled */\n    ((void) olen);\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, total extension length: %d\",\n                   ext_len ) );\n\n    if( ext_len > 0 )\n    {\n        *p++ = (unsigned char)( ( ext_len >> 8 ) & 0xFF );\n        *p++ = (unsigned char)( ( ext_len      ) & 0xFF );\n        p += ext_len;\n    }\n\n    ssl->out_msglen  = p - buf;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CLIENT_HELLO;\n\n    ssl->state++;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        mbedtls_ssl_send_flight_completed( ssl );\n#endif\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write client hello\" ) );\n\n    return( 0 );\n}\n\nstatic int ssl_parse_renegotiation_info( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        /* Check verify-data in constant-time. The length OTOH is no secret */\n        if( len    != 1 + ssl->verify_data_len * 2 ||\n            buf[0] !=     ssl->verify_data_len * 2 ||\n            mbedtls_ssl_safer_memcmp( buf + 1,\n                          ssl->own_verify_data, ssl->verify_data_len ) != 0 ||\n            mbedtls_ssl_safer_memcmp( buf + 1 + ssl->verify_data_len,\n                          ssl->peer_verify_data, ssl->verify_data_len ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching renegotiation info\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n    }\n    else\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n    {\n        if( len != 1 || buf[0] != 0x00 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-zero length renegotiation info\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n\n        ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;\n    }\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\nstatic int ssl_parse_max_fragment_length_ext( mbedtls_ssl_context *ssl,\n                                              const unsigned char *buf,\n                                              size_t len )\n{\n    /*\n     * server should use the extension only if we did,\n     * and if so the server's value should match ours (and len is always 1)\n     */\n    if( ssl->conf->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE ||\n        len != 1 ||\n        buf[0] != ssl->conf->mfl_code )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching max fragment length extension\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\nstatic int ssl_parse_truncated_hmac_ext( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED ||\n        len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching truncated HMAC extension\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    ((void) buf);\n\n    ssl->session_negotiate->trunc_hmac = MBEDTLS_SSL_TRUNC_HMAC_ENABLED;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\nstatic int ssl_parse_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED ||\n        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ||\n        len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching encrypt-then-MAC extension\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    ((void) buf);\n\n    ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\nstatic int ssl_parse_extended_ms_ext( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||\n        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ||\n        len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching extended master secret extension\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    ((void) buf);\n\n    ssl->handshake->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\nstatic int ssl_parse_session_ticket_ext( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( ssl->conf->session_tickets == MBEDTLS_SSL_SESSION_TICKETS_DISABLED ||\n        len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching session ticket extension\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    ((void) buf);\n\n    ssl->handshake->new_session_ticket = 1;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic int ssl_parse_supported_point_formats_ext( mbedtls_ssl_context *ssl,\n                                                  const unsigned char *buf,\n                                                  size_t len )\n{\n    size_t list_size;\n    const unsigned char *p;\n\n    list_size = buf[0];\n    if( list_size + 1 != len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    p = buf + 1;\n    while( list_size > 0 )\n    {\n        if( p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||\n            p[0] == MBEDTLS_ECP_PF_COMPRESSED )\n        {\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)\n            ssl->handshake->ecdh_ctx.point_format = p[0];\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n            ssl->handshake->ecjpake_ctx.point_format = p[0];\n#endif\n            MBEDTLS_SSL_DEBUG_MSG( 4, ( \"point format selected: %d\", p[0] ) );\n            return( 0 );\n        }\n\n        list_size--;\n        p++;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"no point format in common\" ) );\n    mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                    MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n    return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n}\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C || \n          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic int ssl_parse_ecjpake_kkpp( mbedtls_ssl_context *ssl,\n                                   const unsigned char *buf,\n                                   size_t len )\n{\n    int ret;\n\n    if( ssl->transform_negotiate->ciphersuite_info->key_exchange !=\n        MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"skip ecjpake kkpp extension\" ) );\n        return( 0 );\n    }\n\n    /* If we got here, we no longer need our cached extension */\n    mbedtls_free( ssl->handshake->ecjpake_cache );\n    ssl->handshake->ecjpake_cache = NULL;\n    ssl->handshake->ecjpake_cache_len = 0;\n\n    if( ( ret = mbedtls_ecjpake_read_round_one( &ssl->handshake->ecjpake_ctx,\n                                                buf, len ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_one\", ret );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( ret );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_ALPN)\nstatic int ssl_parse_alpn_ext( mbedtls_ssl_context *ssl,\n                               const unsigned char *buf, size_t len )\n{\n    size_t list_len, name_len;\n    const char **p;\n\n    /* If we didn't send it, the server shouldn't send it */\n    if( ssl->conf->alpn_list == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching ALPN extension\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    /*\n     * opaque ProtocolName<1..2^8-1>;\n     *\n     * struct {\n     *     ProtocolName protocol_name_list<2..2^16-1>\n     * } ProtocolNameList;\n     *\n     * the \"ProtocolNameList\" MUST contain exactly one \"ProtocolName\"\n     */\n\n    /* Min length is 2 (list_len) + 1 (name_len) + 1 (name) */\n    if( len < 4 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    list_len = ( buf[0] << 8 ) | buf[1];\n    if( list_len != len - 2 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    name_len = buf[2];\n    if( name_len != list_len - 1 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    /* Check that the server chosen protocol was in our list and save it */\n    for( p = ssl->conf->alpn_list; *p != NULL; p++ )\n    {\n        if( name_len == strlen( *p ) &&\n            memcmp( buf + 3, *p, name_len ) == 0 )\n        {\n            ssl->alpn_chosen = *p;\n            return( 0 );\n        }\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"ALPN extension: no matching protocol\" ) );\n    mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                    MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n    return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n}\n#endif /* MBEDTLS_SSL_ALPN */\n\n/*\n * Parse HelloVerifyRequest.  Only called after verifying the HS type.\n */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\nstatic int ssl_parse_hello_verify_request( mbedtls_ssl_context *ssl )\n{\n    const unsigned char *p = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n    int major_ver, minor_ver;\n    unsigned char cookie_len;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse hello verify request\" ) );\n\n    /*\n     * struct {\n     *   ProtocolVersion server_version;\n     *   opaque cookie<0..2^8-1>;\n     * } HelloVerifyRequest;\n     */\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"server version\", p, 2 );\n    mbedtls_ssl_read_version( &major_ver, &minor_ver, ssl->conf->transport, p );\n    p += 2;\n\n    /*\n     * Since the RFC is not clear on this point, accept DTLS 1.0 (TLS 1.1)\n     * even is lower than our min version.\n     */\n    if( major_ver < MBEDTLS_SSL_MAJOR_VERSION_3 ||\n        minor_ver < MBEDTLS_SSL_MINOR_VERSION_2 ||\n        major_ver > ssl->conf->max_major_ver  ||\n        minor_ver > ssl->conf->max_minor_ver  )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server version\" ) );\n\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                     MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );\n\n        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );\n    }\n\n    cookie_len = *p++;\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"cookie\", p, cookie_len );\n\n    if( ( ssl->in_msg + ssl->in_msglen ) - p < cookie_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1,\n            ( \"cookie length does not match incoming message size\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                    MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    mbedtls_free( ssl->handshake->verify_cookie );\n\n    ssl->handshake->verify_cookie = mbedtls_calloc( 1, cookie_len );\n    if( ssl->handshake->verify_cookie  == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc failed (%d bytes)\", cookie_len ) );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n\n    memcpy( ssl->handshake->verify_cookie, p, cookie_len );\n    ssl->handshake->verify_cookie_len = cookie_len;\n\n    /* Start over at ClientHello */\n    ssl->state = MBEDTLS_SSL_CLIENT_HELLO;\n    mbedtls_ssl_reset_checksum( ssl );\n\n    mbedtls_ssl_recv_flight_completed( ssl );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse hello verify request\" ) );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\nstatic int ssl_parse_server_hello( mbedtls_ssl_context *ssl )\n{\n    int ret, i;\n    size_t n;\n    size_t ext_len;\n    unsigned char *buf, *ext;\n    unsigned char comp;\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    int accept_comp;\n#endif\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    int renegotiation_info_seen = 0;\n#endif\n    int handshake_failure = 0;\n    const mbedtls_ssl_ciphersuite_t *suite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server hello\" ) );\n\n    buf = ssl->in_msg;\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        /* No alert on a read error. */\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n        {\n            ssl->renego_records_seen++;\n\n            if( ssl->conf->renego_max_records >= 0 &&\n                ssl->renego_records_seen > ssl->conf->renego_max_records )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"renegotiation requested, \"\n                                    \"but not honored by server\" ) );\n                return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n            }\n\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-handshake message during renego\" ) );\n\n            ssl->keep_current_message = 1;\n            return( MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO );\n        }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        if( buf[0] == MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"received hello verify request\" ) );\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server hello\" ) );\n            return( ssl_parse_hello_verify_request( ssl ) );\n        }\n        else\n        {\n            /* We made it through the verification process */\n            mbedtls_free( ssl->handshake->verify_cookie );\n            ssl->handshake->verify_cookie = NULL;\n            ssl->handshake->verify_cookie_len = 0;\n        }\n    }\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\n    if( ssl->in_hslen < 38 + mbedtls_ssl_hs_hdr_len( ssl ) ||\n        buf[0] != MBEDTLS_SSL_HS_SERVER_HELLO )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    /*\n     *  0   .  1    server_version\n     *  2   . 33    random (maybe including 4 bytes of Unix time)\n     * 34   . 34    session_id length = n\n     * 35   . 34+n  session_id\n     * 35+n . 36+n  cipher_suite\n     * 37+n . 37+n  compression_method\n     *\n     * 38+n . 39+n  extensions length (optional)\n     * 40+n .  ..   extensions\n     */\n    buf += mbedtls_ssl_hs_hdr_len( ssl );\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"server hello, version\", buf + 0, 2 );\n    mbedtls_ssl_read_version( &ssl->major_ver, &ssl->minor_ver,\n                      ssl->conf->transport, buf + 0 );\n\n    if( ssl->major_ver < ssl->conf->min_major_ver ||\n        ssl->minor_ver < ssl->conf->min_minor_ver ||\n        ssl->major_ver > ssl->conf->max_major_ver ||\n        ssl->minor_ver > ssl->conf->max_minor_ver )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server version out of bounds - \"\n                            \" min: [%d:%d], server: [%d:%d], max: [%d:%d]\",\n                            ssl->conf->min_major_ver, ssl->conf->min_minor_ver,\n                            ssl->major_ver, ssl->minor_ver,\n                            ssl->conf->max_major_ver, ssl->conf->max_minor_ver ) );\n\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                     MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );\n\n        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, current time: %lu\",\n                           ( (uint32_t) buf[2] << 24 ) |\n                           ( (uint32_t) buf[3] << 16 ) |\n                           ( (uint32_t) buf[4] <<  8 ) |\n                           ( (uint32_t) buf[5]       ) ) );\n\n    memcpy( ssl->handshake->randbytes + 32, buf + 2, 32 );\n\n    n = buf[34];\n\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"server hello, random bytes\", buf + 2, 32 );\n\n    if( n > 32 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    if( ssl->in_hslen > mbedtls_ssl_hs_hdr_len( ssl ) + 39 + n )\n    {\n        ext_len = ( ( buf[38 + n] <<  8 )\n                  | ( buf[39 + n]       ) );\n\n        if( ( ext_len > 0 && ext_len < 4 ) ||\n            ssl->in_hslen != mbedtls_ssl_hs_hdr_len( ssl ) + 40 + n + ext_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n    }\n    else if( ssl->in_hslen == mbedtls_ssl_hs_hdr_len( ssl ) + 38 + n )\n    {\n        ext_len = 0;\n    }\n    else\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    /* ciphersuite (used later) */\n    i = ( buf[35 + n] << 8 ) | buf[36 + n];\n\n    /*\n     * Read and check compression\n     */\n    comp = buf[37 + n];\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    /* See comments in ssl_write_client_hello() */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        accept_comp = 0;\n    else\n#endif\n        accept_comp = 1;\n\n    if( comp != MBEDTLS_SSL_COMPRESS_NULL &&\n        ( comp != MBEDTLS_SSL_COMPRESS_DEFLATE || accept_comp == 0 ) )\n#else /* MBEDTLS_ZLIB_SUPPORT */\n    if( comp != MBEDTLS_SSL_COMPRESS_NULL )\n#endif/* MBEDTLS_ZLIB_SUPPORT */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server hello, bad compression: %d\", comp ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );\n    }\n\n    /*\n     * Initialize update checksum functions\n     */\n    ssl->transform_negotiate->ciphersuite_info = mbedtls_ssl_ciphersuite_from_id( i );\n\n    if( ssl->transform_negotiate->ciphersuite_info == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"ciphersuite info for %04x not found\", i ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    mbedtls_ssl_optimize_checksum( ssl, ssl->transform_negotiate->ciphersuite_info );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, session id len.: %d\", n ) );\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"server hello, session id\", buf + 35, n );\n\n    /*\n     * Check if the session can be resumed\n     */\n    if( ssl->handshake->resume == 0 || n == 0 ||\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE ||\n#endif\n        ssl->session_negotiate->ciphersuite != i ||\n        ssl->session_negotiate->compression != comp ||\n        ssl->session_negotiate->id_len != n ||\n        memcmp( ssl->session_negotiate->id, buf + 35, n ) != 0 )\n    {\n        ssl->state++;\n        ssl->handshake->resume = 0;\n#if defined(MBEDTLS_HAVE_TIME)\n        ssl->session_negotiate->start = mbedtls_time( NULL );\n#endif\n        ssl->session_negotiate->ciphersuite = i;\n        ssl->session_negotiate->compression = comp;\n        ssl->session_negotiate->id_len = n;\n        memcpy( ssl->session_negotiate->id, buf + 35, n );\n    }\n    else\n    {\n        ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;\n\n        if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );\n            return( ret );\n        }\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"%s session has been resumed\",\n                   ssl->handshake->resume ? \"a\" : \"no\" ) );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, chosen ciphersuite: %04x\", i ) );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, compress alg.: %d\", buf[37 + n] ) );\n\n    suite_info = mbedtls_ssl_ciphersuite_from_id( ssl->session_negotiate->ciphersuite );\n    if( suite_info == NULL\n#if defined(MBEDTLS_ARC4_C)\n            || ( ssl->conf->arc4_disabled &&\n                suite_info->cipher == MBEDTLS_CIPHER_ARC4_128 )\n#endif\n        )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, chosen ciphersuite: %s\", suite_info->name ) );\n\n    i = 0;\n    while( 1 )\n    {\n        if( ssl->conf->ciphersuite_list[ssl->minor_ver][i] == 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n\n        if( ssl->conf->ciphersuite_list[ssl->minor_ver][i++] ==\n            ssl->session_negotiate->ciphersuite )\n        {\n            break;\n        }\n    }\n\n    if( comp != MBEDTLS_SSL_COMPRESS_NULL\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n        && comp != MBEDTLS_SSL_COMPRESS_DEFLATE\n#endif\n      )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n    ssl->session_negotiate->compression = comp;\n\n    ext = buf + 40 + n;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"server hello, total extension length: %d\", ext_len ) );\n\n    while( ext_len )\n    {\n        unsigned int ext_id   = ( ( ext[0] <<  8 )\n                                | ( ext[1]       ) );\n        unsigned int ext_size = ( ( ext[2] <<  8 )\n                                | ( ext[3]       ) );\n\n        if( ext_size + 4 > ext_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n\n        switch( ext_id )\n        {\n        case MBEDTLS_TLS_EXT_RENEGOTIATION_INFO:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found renegotiation extension\" ) );\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n            renegotiation_info_seen = 1;\n#endif\n\n            if( ( ret = ssl_parse_renegotiation_info( ssl, ext + 4,\n                                                      ext_size ) ) != 0 )\n                return( ret );\n\n            break;\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n        case MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found max_fragment_length extension\" ) );\n\n            if( ( ret = ssl_parse_max_fragment_length_ext( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n        case MBEDTLS_TLS_EXT_TRUNCATED_HMAC:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found truncated_hmac extension\" ) );\n\n            if( ( ret = ssl_parse_truncated_hmac_ext( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n        case MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found encrypt_then_mac extension\" ) );\n\n            if( ( ret = ssl_parse_encrypt_then_mac_ext( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n        case MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found extended_master_secret extension\" ) );\n\n            if( ( ret = ssl_parse_extended_ms_ext( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n        case MBEDTLS_TLS_EXT_SESSION_TICKET:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found session_ticket extension\" ) );\n\n            if( ( ret = ssl_parse_session_ticket_ext( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n        case MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found supported_point_formats extension\" ) );\n\n            if( ( ret = ssl_parse_supported_point_formats_ext( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||\n          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n        case MBEDTLS_TLS_EXT_ECJPAKE_KKPP:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found ecjpake_kkpp extension\" ) );\n\n            if( ( ret = ssl_parse_ecjpake_kkpp( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_ALPN)\n        case MBEDTLS_TLS_EXT_ALPN:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found alpn extension\" ) );\n\n            if( ( ret = ssl_parse_alpn_ext( ssl, ext + 4, ext_size ) ) != 0 )\n                return( ret );\n\n            break;\n#endif /* MBEDTLS_SSL_ALPN */\n\n        default:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"unknown extension found: %d (ignoring)\",\n                           ext_id ) );\n        }\n\n        ext_len -= 4 + ext_size;\n        ext += 4 + ext_size;\n\n        if( ext_len > 0 && ext_len < 4 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n    }\n\n    /*\n     * Renegotiation security checks\n     */\n    if( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&\n        ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"legacy renegotiation, breaking off handshake\" ) );\n        handshake_failure = 1;\n    }\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&\n             ssl->secure_renegotiation == MBEDTLS_SSL_SECURE_RENEGOTIATION &&\n             renegotiation_info_seen == 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"renegotiation_info extension missing (secure)\" ) );\n        handshake_failure = 1;\n    }\n    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&\n             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&\n             ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"legacy renegotiation not allowed\" ) );\n        handshake_failure = 1;\n    }\n    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&\n             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&\n             renegotiation_info_seen == 1 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"renegotiation_info extension present (legacy)\" ) );\n        handshake_failure = 1;\n    }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n    if( handshake_failure == 1 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server hello\" ) );\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\nstatic int ssl_parse_server_dh_params( mbedtls_ssl_context *ssl, unsigned char **p,\n                                       unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n\n    /*\n     * Ephemeral DH parameters:\n     *\n     * struct {\n     *     opaque dh_p<1..2^16-1>;\n     *     opaque dh_g<1..2^16-1>;\n     *     opaque dh_Ys<1..2^16-1>;\n     * } ServerDHParams;\n     */\n    if( ( ret = mbedtls_dhm_read_params( &ssl->handshake->dhm_ctx, p, end ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 2, ( \"mbedtls_dhm_read_params\" ), ret );\n        return( ret );\n    }\n\n    if( ssl->handshake->dhm_ctx.len * 8 < ssl->conf->dhm_min_bitlen )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"DHM prime too short: %d < %d\",\n                                    ssl->handshake->dhm_ctx.len * 8,\n                                    ssl->conf->dhm_min_bitlen ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: P \", &ssl->handshake->dhm_ctx.P  );\n    MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: G \", &ssl->handshake->dhm_ctx.G  );\n    MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: GY\", &ssl->handshake->dhm_ctx.GY );\n\n    return( ret );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\nstatic int ssl_check_server_ecdh_params( const mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ecp_curve_info *curve_info;\n\n    curve_info = mbedtls_ecp_curve_info_from_grp_id( ssl->handshake->ecdh_ctx.grp.id );\n    if( curve_info == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"ECDH curve: %s\", curve_info->name ) );\n\n#if defined(MBEDTLS_ECP_C)\n    if( mbedtls_ssl_check_curve( ssl, ssl->handshake->ecdh_ctx.grp.id ) != 0 )\n#else\n    if( ssl->handshake->ecdh_ctx.grp.nbits < 163 ||\n        ssl->handshake->ecdh_ctx.grp.nbits > 521 )\n#endif\n        return( -1 );\n\n    MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Qp\", &ssl->handshake->ecdh_ctx.Qp );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)\nstatic int ssl_parse_server_ecdh_params( mbedtls_ssl_context *ssl,\n                                         unsigned char **p,\n                                         unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n\n    /*\n     * Ephemeral ECDH parameters:\n     *\n     * struct {\n     *     ECParameters curve_params;\n     *     ECPoint      public;\n     * } ServerECDHParams;\n     */\n    if( ( ret = mbedtls_ecdh_read_params( &ssl->handshake->ecdh_ctx,\n                                  (const unsigned char **) p, end ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, ( \"mbedtls_ecdh_read_params\" ), ret );\n        return( ret );\n    }\n\n    if( ssl_check_server_ecdh_params( ssl ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message (ECDHE curve)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    return( ret );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\nstatic int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n\n    /*\n     * PSK parameters:\n     *\n     * opaque psk_identity_hint<0..2^16-1>;\n     */\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n\n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    /*\n     * Note: we currently ignore the PKS identity hint, as we only allow one\n     * PSK to be provisionned on the client. This could be changed later if\n     * someone needs that feature.\n     */\n    *p += len;\n    ret = 0;\n\n    return( ret );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                           \\\n    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n/*\n * Generate a pre-master secret and encrypt it with the server's RSA key\n */\nstatic int ssl_write_encrypted_pms( mbedtls_ssl_context *ssl,\n                                    size_t offset, size_t *olen,\n                                    size_t pms_offset )\n{\n    int ret;\n    size_t len_bytes = ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ? 0 : 2;\n    unsigned char *p = ssl->handshake->premaster + pms_offset;\n\n    if( offset + len_bytes > MBEDTLS_SSL_MAX_CONTENT_LEN )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small for encrypted pms\" ) );\n        return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );\n    }\n\n    /*\n     * Generate (part of) the pre-master as\n     *  struct {\n     *      ProtocolVersion client_version;\n     *      opaque random[46];\n     *  } PreMasterSecret;\n     */\n    mbedtls_ssl_write_version( ssl->conf->max_major_ver, ssl->conf->max_minor_ver,\n                       ssl->conf->transport, p );\n\n    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p + 2, 46 ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"f_rng\", ret );\n        return( ret );\n    }\n\n    ssl->handshake->pmslen = 48;\n\n    if( ssl->session_negotiate->peer_cert == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /*\n     * Now write it out, encrypted\n     */\n    if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk,\n                MBEDTLS_PK_RSA ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"certificate key type mismatch\" ) );\n        return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n    }\n\n    if( ( ret = mbedtls_pk_encrypt( &ssl->session_negotiate->peer_cert->pk,\n                            p, ssl->handshake->pmslen,\n                            ssl->out_msg + offset + len_bytes, olen,\n                            MBEDTLS_SSL_MAX_CONTENT_LEN - offset - len_bytes,\n                            ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_rsa_pkcs1_encrypt\", ret );\n        return( ret );\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( len_bytes == 2 )\n    {\n        ssl->out_msg[offset+0] = (unsigned char)( *olen >> 8 );\n        ssl->out_msg[offset+1] = (unsigned char)( *olen      );\n        *olen += 2;\n    }\n#endif\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\nstatic int ssl_parse_signature_algorithm( mbedtls_ssl_context *ssl,\n                                          unsigned char **p,\n                                          unsigned char *end,\n                                          mbedtls_md_type_t *md_alg,\n                                          mbedtls_pk_type_t *pk_alg )\n{\n    ((void) ssl);\n    *md_alg = MBEDTLS_MD_NONE;\n    *pk_alg = MBEDTLS_PK_NONE;\n\n    /* Only in TLS 1.2 */\n    if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        return( 0 );\n    }\n\n    if( (*p) + 2 > end )\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n\n    /*\n     * Get hash algorithm\n     */\n    if( ( *md_alg = mbedtls_ssl_md_alg_from_hash( (*p)[0] ) ) == MBEDTLS_MD_NONE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"Server used unsupported \"\n                            \"HashAlgorithm %d\", *(p)[0] ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    /*\n     * Get signature algorithm\n     */\n    if( ( *pk_alg = mbedtls_ssl_pk_alg_from_sig( (*p)[1] ) ) == MBEDTLS_PK_NONE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server used unsupported \"\n                            \"SignatureAlgorithm %d\", (*p)[1] ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    /*\n     * Check if the hash is acceptable\n     */\n    if( mbedtls_ssl_check_sig_hash( ssl, *md_alg ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server used HashAlgorithm %d that was not offered\",\n                                    *(p)[0] ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"Server used SignatureAlgorithm %d\", (*p)[1] ) );\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"Server used HashAlgorithm %d\", (*p)[0] ) );\n    *p += 2;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\nstatic int ssl_get_ecdh_params_from_cert( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const mbedtls_ecp_keypair *peer_key;\n\n    if( ssl->session_negotiate->peer_cert == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk,\n                     MBEDTLS_PK_ECKEY ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key not ECDH capable\" ) );\n        return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n    }\n\n    peer_key = mbedtls_pk_ec( ssl->session_negotiate->peer_cert->pk );\n\n    if( ( ret = mbedtls_ecdh_get_params( &ssl->handshake->ecdh_ctx, peer_key,\n                                 MBEDTLS_ECDH_THEIRS ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, ( \"mbedtls_ecdh_get_params\" ), ret );\n        return( ret );\n    }\n\n    if( ssl_check_server_ecdh_params( ssl ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server certificate (ECDH curve)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    return( ret );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n\nstatic int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    unsigned char *p = NULL, *end = NULL;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server key exchange\" ) );\n\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    ((void) p);\n    ((void) end);\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )\n    {\n        if( ( ret = ssl_get_ecdh_params_from_cert( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_get_ecdh_params_from_cert\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    ((void) p);\n    ((void) end);\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /*\n     * ServerKeyExchange may be skipped with PSK and RSA-PSK when the server\n     * doesn't use a psk_identity_hint\n     */\n    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )\n    {\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n            ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        {\n            /* Current message is probably either\n             * CertificateRequest or ServerHelloDone */\n            ssl->keep_current_message = 1;\n            goto exit;\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key exchange message must \"\n                                    \"not be skipped\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n    end = ssl->in_msg + ssl->in_hslen;\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"server key exchange\", p, end - p );\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n    {\n        if( ssl_parse_server_psk_hint( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    } /* FALLTROUGH */\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        ; /* nothing more to do */\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )\n    {\n        if( ssl_parse_server_dh_params( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )\n    {\n        if( ssl_parse_server_ecdh_params( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,\n                                              p, end - p );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_two\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )\n    {\n        size_t sig_len, hashlen;\n        unsigned char hash[64];\n        mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;\n        mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;\n        unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n        size_t params_len = p - params;\n\n        /*\n         * Handle the digitally-signed structure\n         */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            if( ssl_parse_signature_algorithm( ssl, &p, end,\n                                               &md_alg, &pk_alg ) != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n            }\n\n            if( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n            }\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            pk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );\n\n            /* Default hash for ECDSA is SHA-1 */\n            if( pk_alg == MBEDTLS_PK_ECDSA && md_alg == MBEDTLS_MD_NONE )\n                md_alg = MBEDTLS_MD_SHA1;\n        }\n        else\n#endif\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        /*\n         * Read signature\n         */\n\n        if( p > end - 2 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n        sig_len = ( p[0] << 8 ) | p[1];\n        p += 2;\n\n        if( end != p + sig_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"signature\", p, sig_len );\n\n        /*\n         * Compute the hash that has been signed\n         */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( md_alg == MBEDTLS_MD_NONE )\n        {\n            hashlen = 36;\n            ret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash, params,\n                                                           params_len );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( md_alg != MBEDTLS_MD_NONE )\n        {\n            /* Info from md_alg will be used instead */\n            hashlen = 0;\n            ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, params,\n                                                          params_len, md_alg );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_2 */\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"parameters hash\", hash, hashlen != 0 ? hashlen :\n            (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );\n\n        if( ssl->session_negotiate->peer_cert == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n        }\n\n        /*\n         * Verify signature\n         */\n        if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n        }\n\n        if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,\n                               md_alg, hash, hashlen, p, sig_len ) ) != 0 )\n        {\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR );\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_verify\", ret );\n            return( ret );\n        }\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */\n\nexit:\n    ssl->state++;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server key exchange\" ) );\n\n    return( 0 );\n}\n\n#if ! defined(MBEDTLS_KEY_EXCHANGE__CERT_REQ_ALLOWED__ENABLED)\nstatic int ssl_parse_certificate_request( mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse certificate request\" ) );\n\n    if( ! mbedtls_ssl_ciphersuite_cert_req_allowed( ciphersuite_info ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate request\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\n#else /* MBEDTLS_KEY_EXCHANGE__CERT_REQ_ALLOWED__ENABLED */\nstatic int ssl_parse_certificate_request( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    unsigned char *buf;\n    size_t n = 0;\n    size_t cert_type_len = 0, dn_len = 0;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse certificate request\" ) );\n\n    if( ! mbedtls_ssl_ciphersuite_cert_req_allowed( ciphersuite_info ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate request\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    ssl->state++;\n    ssl->client_auth = ( ssl->in_msg[0] == MBEDTLS_SSL_HS_CERTIFICATE_REQUEST );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"got %s certificate request\",\n                        ssl->client_auth ? \"a\" : \"no\" ) );\n\n    if( ssl->client_auth == 0 )\n    {\n        /* Current message is probably the ServerHelloDone */\n        ssl->keep_current_message = 1;\n        goto exit;\n    }\n\n    /*\n     *  struct {\n     *      ClientCertificateType certificate_types<1..2^8-1>;\n     *      SignatureAndHashAlgorithm\n     *        supported_signature_algorithms<2^16-1>; -- TLS 1.2 only\n     *      DistinguishedName certificate_authorities<0..2^16-1>;\n     *  } CertificateRequest;\n     *\n     *  Since we only support a single certificate on clients, let's just\n     *  ignore all the information that's supposed to help us pick a\n     *  certificate.\n     *\n     *  We could check that our certificate matches the request, and bail out\n     *  if it doesn't, but it's simpler to just send the certificate anyway,\n     *  and give the server the opportunity to decide if it should terminate\n     *  the connection when it doesn't like our certificate.\n     *\n     *  Same goes for the hash in TLS 1.2's signature_algorithms: at this\n     *  point we only have one hash available (see comments in\n     *  write_certificate_verify), so let's just use what we have.\n     *\n     *  However, we still minimally parse the message to check it is at least\n     *  superficially sane.\n     */\n    buf = ssl->in_msg;\n\n    /* certificate_types */\n    cert_type_len = buf[mbedtls_ssl_hs_hdr_len( ssl )];\n    n = cert_type_len;\n\n    if( ssl->in_hslen < mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n    }\n\n    /* supported_signature_algorithms */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        size_t sig_alg_len = ( ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 1 + n] <<  8 )\n                             | ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n]       ) );\n#if defined(MBEDTLS_DEBUG_C)\n        unsigned char* sig_alg = buf + mbedtls_ssl_hs_hdr_len( ssl ) + 3 + n;\n        size_t i;\n\n        for( i = 0; i < sig_alg_len; i += 2 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"Supported Signature Algorithm found: %d\"\n                                        \",%d\", sig_alg[i], sig_alg[i + 1]  ) );\n        }\n#endif\n\n        n += 2 + sig_alg_len;\n\n        if( ssl->in_hslen < mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n        }\n    }\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n\n    /* certificate_authorities */\n    dn_len = ( ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 1 + n] <<  8 )\n             | ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n]       ) );\n\n    n += dn_len;\n    if( ssl->in_hslen != mbedtls_ssl_hs_hdr_len( ssl ) + 3 + n )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n    }\n\nexit:\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse certificate request\" ) );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE__CERT_REQ_ALLOWED__ENABLED */\n\nstatic int ssl_parse_server_hello_done( mbedtls_ssl_context *ssl )\n{\n    int ret;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server hello done\" ) );\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello done message\" ) );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl->in_hslen  != mbedtls_ssl_hs_hdr_len( ssl ) ||\n        ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_HELLO_DONE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello done message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE );\n    }\n\n    ssl->state++;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        mbedtls_ssl_recv_flight_completed( ssl );\n#endif\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server hello done\" ) );\n\n    return( 0 );\n}\n\nstatic int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write client key exchange\" ) );\n\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA )\n    {\n        /*\n         * DHM key exchange -- send G^X mod P\n         */\n        n = ssl->handshake->dhm_ctx.len;\n\n        ssl->out_msg[4] = (unsigned char)( n >> 8 );\n        ssl->out_msg[5] = (unsigned char)( n      );\n        i = 6;\n\n        ret = mbedtls_dhm_make_public( &ssl->handshake->dhm_ctx,\n                                (int) mbedtls_mpi_size( &ssl->handshake->dhm_ctx.P ),\n                               &ssl->out_msg[i], n,\n                                ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_dhm_make_public\", ret );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: X \", &ssl->handshake->dhm_ctx.X  );\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: GX\", &ssl->handshake->dhm_ctx.GX );\n\n        if( ( ret = mbedtls_dhm_calc_secret( &ssl->handshake->dhm_ctx,\n                                      ssl->handshake->premaster,\n                                      MBEDTLS_PREMASTER_SIZE,\n                                     &ssl->handshake->pmslen,\n                                      ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_dhm_calc_secret\", ret );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: K \", &ssl->handshake->dhm_ctx.K  );\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )\n    {\n        /*\n         * ECDH key exchange -- send client public value\n         */\n        i = 4;\n\n        ret = mbedtls_ecdh_make_public( &ssl->handshake->ecdh_ctx,\n                                &n,\n                                &ssl->out_msg[i], 1000,\n                                ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_make_public\", ret );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Q\", &ssl->handshake->ecdh_ctx.Q );\n\n        if( ( ret = mbedtls_ecdh_calc_secret( &ssl->handshake->ecdh_ctx,\n                                      &ssl->handshake->pmslen,\n                                       ssl->handshake->premaster,\n                                       MBEDTLS_MPI_MAX_SIZE,\n                                       ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_calc_secret\", ret );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"ECDH: z\", &ssl->handshake->ecdh_ctx.z );\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_psk( ciphersuite_info ) )\n    {\n        /*\n         * opaque psk_identity<0..2^16-1>;\n         */\n        if( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no private key for PSK\" ) );\n            return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n        }\n\n        i = 4;\n        n = ssl->conf->psk_identity_len;\n\n        if( i + 2 + n > MBEDTLS_SSL_MAX_CONTENT_LEN )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"psk identity too long or \"\n                                        \"SSL buffer too short\" ) );\n            return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );\n        }\n\n        ssl->out_msg[i++] = (unsigned char)( n >> 8 );\n        ssl->out_msg[i++] = (unsigned char)( n      );\n\n        memcpy( ssl->out_msg + i, ssl->conf->psk_identity, ssl->conf->psk_identity_len );\n        i += ssl->conf->psk_identity_len;\n\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK )\n        {\n            n = 0;\n        }\n        else\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        {\n            if( ( ret = ssl_write_encrypted_pms( ssl, i, &n, 2 ) ) != 0 )\n                return( ret );\n        }\n        else\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )\n        {\n            /*\n             * ClientDiffieHellmanPublic public (DHM send G^X mod P)\n             */\n            n = ssl->handshake->dhm_ctx.len;\n\n            if( i + 2 + n > MBEDTLS_SSL_MAX_CONTENT_LEN )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"psk identity or DHM size too long\"\n                                            \" or SSL buffer too short\" ) );\n                return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );\n            }\n\n            ssl->out_msg[i++] = (unsigned char)( n >> 8 );\n            ssl->out_msg[i++] = (unsigned char)( n      );\n\n            ret = mbedtls_dhm_make_public( &ssl->handshake->dhm_ctx,\n                    (int) mbedtls_mpi_size( &ssl->handshake->dhm_ctx.P ),\n                    &ssl->out_msg[i], n,\n                    ssl->conf->f_rng, ssl->conf->p_rng );\n            if( ret != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_dhm_make_public\", ret );\n                return( ret );\n            }\n        }\n        else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n        {\n            /*\n             * ClientECDiffieHellmanPublic public;\n             */\n            ret = mbedtls_ecdh_make_public( &ssl->handshake->ecdh_ctx, &n,\n                    &ssl->out_msg[i], MBEDTLS_SSL_MAX_CONTENT_LEN - i,\n                    ssl->conf->f_rng, ssl->conf->p_rng );\n            if( ret != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_make_public\", ret );\n                return( ret );\n            }\n\n            MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Q\", &ssl->handshake->ecdh_ctx.Q );\n        }\n        else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,\n                        ciphersuite_info->key_exchange ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_psk_derive_premaster\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )\n    {\n        i = 4;\n        if( ( ret = ssl_write_encrypted_pms( ssl, i, &n, 0 ) ) != 0 )\n            return( ret );\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        i = 4;\n\n        ret = mbedtls_ecjpake_write_round_two( &ssl->handshake->ecjpake_ctx,\n                ssl->out_msg + i, MBEDTLS_SSL_MAX_CONTENT_LEN - i, &n,\n                ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_write_round_two\", ret );\n            return( ret );\n        }\n\n        ret = mbedtls_ecjpake_derive_secret( &ssl->handshake->ecjpake_ctx,\n                ssl->handshake->premaster, 32, &ssl->handshake->pmslen,\n                ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_derive_secret\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */\n    {\n        ((void) ciphersuite_info);\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    ssl->out_msglen  = i + n;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE;\n\n    ssl->state++;\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write client key exchange\" ) );\n\n    return( 0 );\n}\n\n#if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)  && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)&& \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\nstatic int ssl_write_certificate_verify( mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    int ret;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write certificate verify\" ) );\n\n    if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n        return( ret );\n    }\n\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\n#else\nstatic int ssl_write_certificate_verify( mbedtls_ssl_context *ssl )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    size_t n = 0, offset = 0;\n    unsigned char hash[48];\n    unsigned char *hash_start = hash;\n    mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;\n    unsigned int hashlen;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write certificate verify\" ) );\n\n    if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n        return( ret );\n    }\n\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( ssl->client_auth == 0 || mbedtls_ssl_own_cert( ssl ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( mbedtls_ssl_own_key( ssl ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no private key for certificate\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Make an RSA signature of the handshake digests\n     */\n    ssl->handshake->calc_verify( ssl, hash );\n\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n    if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        /*\n         * digitally-signed struct {\n         *     opaque md5_hash[16];\n         *     opaque sha_hash[20];\n         * };\n         *\n         * md5_hash\n         *     MD5(handshake_messages);\n         *\n         * sha_hash\n         *     SHA(handshake_messages);\n         */\n        hashlen = 36;\n        md_alg = MBEDTLS_MD_NONE;\n\n        /*\n         * For ECDSA, default hash is SHA-1 only\n         */\n        if( mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_ECDSA ) )\n        {\n            hash_start += 16;\n            hashlen -= 16;\n            md_alg = MBEDTLS_MD_SHA1;\n        }\n    }\n    else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        /*\n         * digitally-signed struct {\n         *     opaque handshake_messages[handshake_messages_length];\n         * };\n         *\n         * Taking shortcut here. We assume that the server always allows the\n         * PRF Hash function and has sent it in the allowed signature\n         * algorithms list received in the Certificate Request message.\n         *\n         * Until we encounter a server that does not, we will take this\n         * shortcut.\n         *\n         * Reason: Otherwise we should have running hashes for SHA512 and SHA224\n         *         in order to satisfy 'weird' needs from the server side.\n         */\n        if( ssl->transform_negotiate->ciphersuite_info->mac ==\n            MBEDTLS_MD_SHA384 )\n        {\n            md_alg = MBEDTLS_MD_SHA384;\n            ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA384;\n        }\n        else\n        {\n            md_alg = MBEDTLS_MD_SHA256;\n            ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA256;\n        }\n        ssl->out_msg[5] = mbedtls_ssl_sig_from_pk( mbedtls_ssl_own_key( ssl ) );\n\n        /* Info from md_alg will be used instead */\n        hashlen = 0;\n        offset = 2;\n    }\n    else\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash_start, hashlen,\n                         ssl->out_msg + 6 + offset, &n,\n                         ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_sign\", ret );\n        return( ret );\n    }\n\n    ssl->out_msg[4 + offset] = (unsigned char)( n >> 8 );\n    ssl->out_msg[5 + offset] = (unsigned char)( n      );\n\n    ssl->out_msglen  = 6 + n + offset;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_VERIFY;\n\n    ssl->state++;\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write certificate verify\" ) );\n\n    return( ret );\n}\n#endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\nstatic int ssl_parse_new_session_ticket( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    uint32_t lifetime;\n    size_t ticket_len;\n    unsigned char *ticket;\n    const unsigned char *msg;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse new session ticket\" ) );\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad new session ticket message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /*\n     * struct {\n     *     uint32 ticket_lifetime_hint;\n     *     opaque ticket<0..2^16-1>;\n     * } NewSessionTicket;\n     *\n     * 0  .  3   ticket_lifetime_hint\n     * 4  .  5   ticket_len (n)\n     * 6  .  5+n ticket content\n     */\n    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_NEW_SESSION_TICKET ||\n        ssl->in_hslen < 6 + mbedtls_ssl_hs_hdr_len( ssl ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad new session ticket message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET );\n    }\n\n    msg = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n\n    lifetime = ( msg[0] << 24 ) | ( msg[1] << 16 ) |\n               ( msg[2] <<  8 ) | ( msg[3]       );\n\n    ticket_len = ( msg[4] << 8 ) | ( msg[5] );\n\n    if( ticket_len + 6 + mbedtls_ssl_hs_hdr_len( ssl ) != ssl->in_hslen )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad new session ticket message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ticket length: %d\", ticket_len ) );\n\n    /* We're not waiting for a NewSessionTicket message any more */\n    ssl->handshake->new_session_ticket = 0;\n    ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;\n\n    /*\n     * Zero-length ticket means the server changed his mind and doesn't want\n     * to send a ticket after all, so just forget it\n     */\n    if( ticket_len == 0 )\n        return( 0 );\n\n    mbedtls_zeroize( ssl->session_negotiate->ticket,\n                      ssl->session_negotiate->ticket_len );\n    mbedtls_free( ssl->session_negotiate->ticket );\n    ssl->session_negotiate->ticket = NULL;\n    ssl->session_negotiate->ticket_len = 0;\n\n    if( ( ticket = mbedtls_calloc( 1, ticket_len ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"ticket alloc failed\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n\n    memcpy( ticket, msg + 6, ticket_len );\n\n    ssl->session_negotiate->ticket = ticket;\n    ssl->session_negotiate->ticket_len = ticket_len;\n    ssl->session_negotiate->ticket_lifetime = lifetime;\n\n    /*\n     * RFC 5077 section 3.4:\n     * \"If the client receives a session ticket from the server, then it\n     * discards any Session ID that was sent in the ServerHello.\"\n     */\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ticket in use, discarding session id\" ) );\n    ssl->session_negotiate->id_len = 0;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse new session ticket\" ) );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n/*\n * SSL handshake -- client side -- single step\n */\nint mbedtls_ssl_handshake_client_step( mbedtls_ssl_context *ssl )\n{\n    int ret = 0;\n\n    if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER || ssl->handshake == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"client state: %d\", ssl->state ) );\n\n    if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )\n        return( ret );\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n        ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING )\n    {\n        if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )\n            return( ret );\n    }\n#endif\n\n    /* Change state now, so that it is right in mbedtls_ssl_read_record(), used\n     * by DTLS for dropping out-of-sequence ChangeCipherSpec records */\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n    if( ssl->state == MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC &&\n        ssl->handshake->new_session_ticket != 0 )\n    {\n        ssl->state = MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET;\n    }\n#endif\n\n    switch( ssl->state )\n    {\n        case MBEDTLS_SSL_HELLO_REQUEST:\n            ssl->state = MBEDTLS_SSL_CLIENT_HELLO;\n            break;\n\n       /*\n        *  ==>   ClientHello\n        */\n       case MBEDTLS_SSL_CLIENT_HELLO:\n           ret = ssl_write_client_hello( ssl );\n           break;\n\n       /*\n        *  <==   ServerHello\n        *        Certificate\n        *      ( ServerKeyExchange  )\n        *      ( CertificateRequest )\n        *        ServerHelloDone\n        */\n       case MBEDTLS_SSL_SERVER_HELLO:\n           ret = ssl_parse_server_hello( ssl );\n           break;\n\n       case MBEDTLS_SSL_SERVER_CERTIFICATE:\n           ret = mbedtls_ssl_parse_certificate( ssl );\n           break;\n\n       case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:\n           ret = ssl_parse_server_key_exchange( ssl );\n           break;\n\n       case MBEDTLS_SSL_CERTIFICATE_REQUEST:\n           ret = ssl_parse_certificate_request( ssl );\n           break;\n\n       case MBEDTLS_SSL_SERVER_HELLO_DONE:\n           ret = ssl_parse_server_hello_done( ssl );\n           break;\n\n       /*\n        *  ==> ( Certificate/Alert  )\n        *        ClientKeyExchange\n        *      ( CertificateVerify  )\n        *        ChangeCipherSpec\n        *        Finished\n        */\n       case MBEDTLS_SSL_CLIENT_CERTIFICATE:\n           ret = mbedtls_ssl_write_certificate( ssl );\n           break;\n\n       case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:\n           ret = ssl_write_client_key_exchange( ssl );\n           break;\n\n       case MBEDTLS_SSL_CERTIFICATE_VERIFY:\n           ret = ssl_write_certificate_verify( ssl );\n           break;\n\n       case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:\n           ret = mbedtls_ssl_write_change_cipher_spec( ssl );\n           break;\n\n       case MBEDTLS_SSL_CLIENT_FINISHED:\n           ret = mbedtls_ssl_write_finished( ssl );\n           break;\n\n       /*\n        *  <==   ( NewSessionTicket )\n        *        ChangeCipherSpec\n        *        Finished\n        */\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n       case MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET:\n           ret = ssl_parse_new_session_ticket( ssl );\n           break;\n#endif\n\n       case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:\n           ret = mbedtls_ssl_parse_change_cipher_spec( ssl );\n           break;\n\n       case MBEDTLS_SSL_SERVER_FINISHED:\n           ret = mbedtls_ssl_parse_finished( ssl );\n           break;\n\n       case MBEDTLS_SSL_FLUSH_BUFFERS:\n           MBEDTLS_SSL_DEBUG_MSG( 2, ( \"handshake: done\" ) );\n           ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;\n           break;\n\n       case MBEDTLS_SSL_HANDSHAKE_WRAPUP:\n           mbedtls_ssl_handshake_wrapup( ssl );\n           break;\n\n       default:\n           MBEDTLS_SSL_DEBUG_MSG( 1, ( \"invalid state %d\", ssl->state ) );\n           return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n   }\n\n    return( ret );\n}\n#endif /* MBEDTLS_SSL_CLI_C */\n"], "fixing_code": ["/*\n *  SSLv3/TLSv1 client-side functions\n *\n *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  This file is part of mbed TLS (https://tls.mbed.org)\n */\n\n#if !defined(MBEDTLS_CONFIG_FILE)\n#include \"mbedtls/config.h\"\n#else\n#include MBEDTLS_CONFIG_FILE\n#endif\n\n#if defined(MBEDTLS_SSL_CLI_C)\n\n#if defined(MBEDTLS_PLATFORM_C)\n#include \"mbedtls/platform.h\"\n#else\n#include <stdlib.h>\n#define mbedtls_calloc    calloc\n#define mbedtls_free      free\n#endif\n\n#include \"mbedtls/debug.h\"\n#include \"mbedtls/ssl.h\"\n#include \"mbedtls/ssl_internal.h\"\n\n#include <string.h>\n\n#include <stdint.h>\n\n#if defined(MBEDTLS_HAVE_TIME)\n#include \"mbedtls/platform_time.h\"\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n/* Implementation that should never be optimized out by the compiler */\nstatic void mbedtls_zeroize( void *v, size_t n ) {\n    volatile unsigned char *p = v; while( n-- ) *p++ = 0;\n}\n#endif\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\nstatic void ssl_write_hostname_ext( mbedtls_ssl_context *ssl,\n                                    unsigned char *buf,\n                                    size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    size_t hostname_len;\n\n    *olen = 0;\n\n    if( ssl->hostname == NULL )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding server name extension: %s\",\n                   ssl->hostname ) );\n\n    hostname_len = strlen( ssl->hostname );\n\n    if( end < p || (size_t)( end - p ) < hostname_len + 9 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    /*\n     * Sect. 3, RFC 6066 (TLS Extensions Definitions)\n     *\n     * In order to provide any of the server names, clients MAY include an\n     * extension of type \"server_name\" in the (extended) client hello. The\n     * \"extension_data\" field of this extension SHALL contain\n     * \"ServerNameList\" where:\n     *\n     * struct {\n     *     NameType name_type;\n     *     select (name_type) {\n     *         case host_name: HostName;\n     *     } name;\n     * } ServerName;\n     *\n     * enum {\n     *     host_name(0), (255)\n     * } NameType;\n     *\n     * opaque HostName<1..2^16-1>;\n     *\n     * struct {\n     *     ServerName server_name_list<1..2^16-1>\n     * } ServerNameList;\n     *\n     */\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SERVERNAME >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SERVERNAME      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( (hostname_len + 5) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( (hostname_len + 5)      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( (hostname_len + 3) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( (hostname_len + 3)      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME ) & 0xFF );\n    *p++ = (unsigned char)( ( hostname_len >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( hostname_len      ) & 0xFF );\n\n    memcpy( p, ssl->hostname, hostname_len );\n\n    *olen = hostname_len + 9;\n}\n#endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\nstatic void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,\n                                         unsigned char *buf,\n                                         size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    /* We're always including an TLS_EMPTY_RENEGOTIATION_INFO_SCSV in the\n     * initial ClientHello, in which case also adding the renegotiation\n     * info extension is NOT RECOMMENDED as per RFC 5746 Section 3.4. */\n    if( ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding renegotiation extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 5 + ssl->verify_data_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    /*\n     * Secure renegotiation\n     */\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = ( ssl->verify_data_len + 1 ) & 0xFF;\n    *p++ = ssl->verify_data_len & 0xFF;\n\n    memcpy( p, ssl->own_verify_data, ssl->verify_data_len );\n\n    *olen = 5 + ssl->verify_data_len;\n}\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n/*\n * Only if we handle at least one key exchange that needs signatures.\n */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\nstatic void ssl_write_signature_algorithms_ext( mbedtls_ssl_context *ssl,\n                                                unsigned char *buf,\n                                                size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    size_t sig_alg_len = 0;\n    const int *md;\n#if defined(MBEDTLS_RSA_C) || defined(MBEDTLS_ECDSA_C)\n    unsigned char *sig_alg_list = buf + 6;\n#endif\n\n    *olen = 0;\n\n    if( ssl->conf->max_minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding signature_algorithms extension\" ) );\n\n    for( md = ssl->conf->sig_hashes; *md != MBEDTLS_MD_NONE; md++ )\n    {\n#if defined(MBEDTLS_ECDSA_C)\n        sig_alg_len += 2;\n#endif\n#if defined(MBEDTLS_RSA_C)\n        sig_alg_len += 2;\n#endif\n    }\n\n    if( end < p || (size_t)( end - p ) < sig_alg_len + 6 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    /*\n     * Prepare signature_algorithms extension (TLS 1.2)\n     */\n    sig_alg_len = 0;\n\n    for( md = ssl->conf->sig_hashes; *md != MBEDTLS_MD_NONE; md++ )\n    {\n#if defined(MBEDTLS_ECDSA_C)\n        sig_alg_list[sig_alg_len++] = mbedtls_ssl_hash_from_md_alg( *md );\n        sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_ECDSA;\n#endif\n#if defined(MBEDTLS_RSA_C)\n        sig_alg_list[sig_alg_len++] = mbedtls_ssl_hash_from_md_alg( *md );\n        sig_alg_list[sig_alg_len++] = MBEDTLS_SSL_SIG_RSA;\n#endif\n    }\n\n    /*\n     * enum {\n     *     none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),\n     *     sha512(6), (255)\n     * } HashAlgorithm;\n     *\n     * enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }\n     *   SignatureAlgorithm;\n     *\n     * struct {\n     *     HashAlgorithm hash;\n     *     SignatureAlgorithm signature;\n     * } SignatureAndHashAlgorithm;\n     *\n     * SignatureAndHashAlgorithm\n     *   supported_signature_algorithms<2..2^16-2>;\n     */\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SIG_ALG >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SIG_ALG      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( ( sig_alg_len + 2 ) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( ( sig_alg_len + 2 )      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( sig_alg_len >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( sig_alg_len      ) & 0xFF );\n\n    *olen = 6 + sig_alg_len;\n}\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&\n          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic void ssl_write_supported_elliptic_curves_ext( mbedtls_ssl_context *ssl,\n                                                     unsigned char *buf,\n                                                     size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    unsigned char *elliptic_curve_list = p + 6;\n    size_t elliptic_curve_len = 0;\n    const mbedtls_ecp_curve_info *info;\n#if defined(MBEDTLS_ECP_C)\n    const mbedtls_ecp_group_id *grp_id;\n#else\n    ((void) ssl);\n#endif\n\n    *olen = 0;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding supported_elliptic_curves extension\" ) );\n\n#if defined(MBEDTLS_ECP_C)\n    for( grp_id = ssl->conf->curve_list; *grp_id != MBEDTLS_ECP_DP_NONE; grp_id++ )\n#else\n    for( info = mbedtls_ecp_curve_list(); info->grp_id != MBEDTLS_ECP_DP_NONE; info++ )\n#endif\n    {\n#if defined(MBEDTLS_ECP_C)\n        info = mbedtls_ecp_curve_info_from_grp_id( *grp_id );\n#endif\n        if( info == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"invalid curve in ssl configuration\" ) );\n            return;\n        }\n\n        elliptic_curve_len += 2;\n    }\n\n    if( end < p || (size_t)( end - p ) < 6 + elliptic_curve_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    elliptic_curve_len = 0;\n\n#if defined(MBEDTLS_ECP_C)\n    for( grp_id = ssl->conf->curve_list; *grp_id != MBEDTLS_ECP_DP_NONE; grp_id++ )\n#else\n    for( info = mbedtls_ecp_curve_list(); info->grp_id != MBEDTLS_ECP_DP_NONE; info++ )\n#endif\n    {\n#if defined(MBEDTLS_ECP_C)\n        info = mbedtls_ecp_curve_info_from_grp_id( *grp_id );\n#endif\n        elliptic_curve_list[elliptic_curve_len++] = info->tls_id >> 8;\n        elliptic_curve_list[elliptic_curve_len++] = info->tls_id & 0xFF;\n    }\n\n    if( elliptic_curve_len == 0 )\n        return;\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( ( elliptic_curve_len + 2 ) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( ( elliptic_curve_len + 2 )      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( ( elliptic_curve_len     ) >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( ( elliptic_curve_len     )      ) & 0xFF );\n\n    *olen = 6 + elliptic_curve_len;\n}\n\nstatic void ssl_write_supported_point_formats_ext( mbedtls_ssl_context *ssl,\n                                                   unsigned char *buf,\n                                                   size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding supported_point_formats extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 6 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 2;\n\n    *p++ = 1;\n    *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;\n\n    *olen = 6;\n}\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C || \n          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic void ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,\n                                        unsigned char *buf,\n                                        size_t *olen )\n{\n    int ret;\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    size_t kkpp_len;\n\n    *olen = 0;\n\n    /* Skip costly extension if we can't use EC J-PAKE anyway */\n    if( mbedtls_ecjpake_check( &ssl->handshake->ecjpake_ctx ) != 0 )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding ecjpake_kkpp extension\" ) );\n\n    if( end - p < 4 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP      ) & 0xFF );\n\n    /*\n     * We may need to send ClientHello multiple times for Hello verification.\n     * We don't want to compute fresh values every time (both for performance\n     * and consistency reasons), so cache the extension content.\n     */\n    if( ssl->handshake->ecjpake_cache == NULL ||\n        ssl->handshake->ecjpake_cache_len == 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"generating new ecjpake parameters\" ) );\n\n        ret = mbedtls_ecjpake_write_round_one( &ssl->handshake->ecjpake_ctx,\n                                        p + 2, end - p - 2, &kkpp_len,\n                                        ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1 , \"mbedtls_ecjpake_write_round_one\", ret );\n            return;\n        }\n\n        ssl->handshake->ecjpake_cache = mbedtls_calloc( 1, kkpp_len );\n        if( ssl->handshake->ecjpake_cache == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"allocation failed\" ) );\n            return;\n        }\n\n        memcpy( ssl->handshake->ecjpake_cache, p + 2, kkpp_len );\n        ssl->handshake->ecjpake_cache_len = kkpp_len;\n    }\n    else\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"re-using cached ecjpake parameters\" ) );\n\n        kkpp_len = ssl->handshake->ecjpake_cache_len;\n\n        if( (size_t)( end - p - 2 ) < kkpp_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n            return;\n        }\n\n        memcpy( p + 2, ssl->handshake->ecjpake_cache, kkpp_len );\n    }\n\n    *p++ = (unsigned char)( ( kkpp_len >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( kkpp_len      ) & 0xFF );\n\n    *olen = kkpp_len + 4;\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\nstatic void ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,\n                                               unsigned char *buf,\n                                               size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl->conf->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE ) {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding max_fragment_length extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 5 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 1;\n\n    *p++ = ssl->conf->mfl_code;\n\n    *olen = 5;\n}\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\nstatic void ssl_write_truncated_hmac_ext( mbedtls_ssl_context *ssl,\n                                          unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding truncated_hmac extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 4 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\nstatic void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,\n                                       unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED ||\n        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding encrypt_then_mac \"\n                        \"extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 4 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\nstatic void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,\n                                       unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||\n        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding extended_master_secret \"\n                        \"extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 4 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\nstatic void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,\n                                          unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    size_t tlen = ssl->session_negotiate->ticket_len;\n\n    *olen = 0;\n\n    if( ssl->conf->session_tickets == MBEDTLS_SSL_SESSION_TICKETS_DISABLED )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding session ticket extension\" ) );\n\n    if( end < p || (size_t)( end - p ) < 4 + tlen )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET      ) & 0xFF );\n\n    *p++ = (unsigned char)( ( tlen >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( tlen      ) & 0xFF );\n\n    *olen = 4;\n\n    if( ssl->session_negotiate->ticket == NULL || tlen == 0 )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"sending session ticket of length %d\", tlen ) );\n\n    memcpy( p, ssl->session_negotiate->ticket, tlen );\n\n    *olen += tlen;\n}\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n#if defined(MBEDTLS_SSL_ALPN)\nstatic void ssl_write_alpn_ext( mbedtls_ssl_context *ssl,\n                                unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;\n    size_t alpnlen = 0;\n    const char **cur;\n\n    *olen = 0;\n\n    if( ssl->conf->alpn_list == NULL )\n    {\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, adding alpn extension\" ) );\n\n    for( cur = ssl->conf->alpn_list; *cur != NULL; cur++ )\n        alpnlen += (unsigned char)( strlen( *cur ) & 0xFF ) + 1;\n\n    if( end < p || (size_t)( end - p ) < 6 + alpnlen )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN >> 8 ) & 0xFF );\n    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN      ) & 0xFF );\n\n    /*\n     * opaque ProtocolName<1..2^8-1>;\n     *\n     * struct {\n     *     ProtocolName protocol_name_list<2..2^16-1>\n     * } ProtocolNameList;\n     */\n\n    /* Skip writing extension and list length for now */\n    p += 4;\n\n    for( cur = ssl->conf->alpn_list; *cur != NULL; cur++ )\n    {\n        *p = (unsigned char)( strlen( *cur ) & 0xFF );\n        memcpy( p + 1, *cur, *p );\n        p += 1 + *p;\n    }\n\n    *olen = p - buf;\n\n    /* List length = olen - 2 (ext_type) - 2 (ext_len) - 2 (list_len) */\n    buf[4] = (unsigned char)( ( ( *olen - 6 ) >> 8 ) & 0xFF );\n    buf[5] = (unsigned char)( ( ( *olen - 6 )      ) & 0xFF );\n\n    /* Extension length = olen - 2 (ext_type) - 2 (ext_len) */\n    buf[2] = (unsigned char)( ( ( *olen - 4 ) >> 8 ) & 0xFF );\n    buf[3] = (unsigned char)( ( ( *olen - 4 )      ) & 0xFF );\n}\n#endif /* MBEDTLS_SSL_ALPN */\n\n/*\n * Generate random bytes for ClientHello\n */\nstatic int ssl_generate_random( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    unsigned char *p = ssl->handshake->randbytes;\n#if defined(MBEDTLS_HAVE_TIME)\n    mbedtls_time_t t;\n#endif\n\n    /*\n     * When responding to a verify request, MUST reuse random (RFC 6347 4.2.1)\n     */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n        ssl->handshake->verify_cookie != NULL )\n    {\n        return( 0 );\n    }\n#endif\n\n#if defined(MBEDTLS_HAVE_TIME)\n    t = mbedtls_time( NULL );\n    *p++ = (unsigned char)( t >> 24 );\n    *p++ = (unsigned char)( t >> 16 );\n    *p++ = (unsigned char)( t >>  8 );\n    *p++ = (unsigned char)( t       );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, current time: %lu\", t ) );\n#else\n    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 4 ) ) != 0 )\n        return( ret );\n\n    p += 4;\n#endif /* MBEDTLS_HAVE_TIME */\n\n    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 28 ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}\n\nstatic int ssl_write_client_hello( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    size_t i, n, olen, ext_len = 0;\n    unsigned char *buf;\n    unsigned char *p, *q;\n    unsigned char offer_compress;\n    const int *ciphersuites;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write client hello\" ) );\n\n    if( ssl->conf->f_rng == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"no RNG provided\") );\n        return( MBEDTLS_ERR_SSL_NO_RNG );\n    }\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )\n#endif\n    {\n        ssl->major_ver = ssl->conf->min_major_ver;\n        ssl->minor_ver = ssl->conf->min_minor_ver;\n    }\n\n    if( ssl->conf->max_major_ver == 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"configured max major version is invalid, \"\n                            \"consider using mbedtls_ssl_config_defaults()\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    /*\n     *     0  .   0   handshake type\n     *     1  .   3   handshake length\n     *     4  .   5   highest version supported\n     *     6  .   9   current UNIX time\n     *    10  .  37   random bytes\n     */\n    buf = ssl->out_msg;\n    p = buf + 4;\n\n    mbedtls_ssl_write_version( ssl->conf->max_major_ver, ssl->conf->max_minor_ver,\n                       ssl->conf->transport, p );\n    p += 2;\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, max version: [%d:%d]\",\n                   buf[4], buf[5] ) );\n\n    if( ( ret = ssl_generate_random( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_generate_random\", ret );\n        return( ret );\n    }\n\n    memcpy( p, ssl->handshake->randbytes, 32 );\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, random bytes\", p, 32 );\n    p += 32;\n\n    /*\n     *    38  .  38   session id length\n     *    39  . 39+n  session id\n     *   39+n . 39+n  DTLS only: cookie length (1 byte)\n     *   40+n .  ..   DTSL only: cookie\n     *   ..   . ..    ciphersuitelist length (2 bytes)\n     *   ..   . ..    ciphersuitelist\n     *   ..   . ..    compression methods length (1 byte)\n     *   ..   . ..    compression methods\n     *   ..   . ..    extensions length (2 bytes)\n     *   ..   . ..    extensions\n     */\n    n = ssl->session_negotiate->id_len;\n\n    if( n < 16 || n > 32 ||\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE ||\n#endif\n        ssl->handshake->resume == 0 )\n    {\n        n = 0;\n    }\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n    /*\n     * RFC 5077 section 3.4: \"When presenting a ticket, the client MAY\n     * generate and include a Session ID in the TLS ClientHello.\"\n     */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )\n#endif\n    {\n        if( ssl->session_negotiate->ticket != NULL &&\n                ssl->session_negotiate->ticket_len != 0 )\n        {\n            ret = ssl->conf->f_rng( ssl->conf->p_rng, ssl->session_negotiate->id, 32 );\n\n            if( ret != 0 )\n                return( ret );\n\n            ssl->session_negotiate->id_len = n = 32;\n        }\n    }\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n    *p++ = (unsigned char) n;\n\n    for( i = 0; i < n; i++ )\n        *p++ = ssl->session_negotiate->id[i];\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, session id len.: %d\", n ) );\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"client hello, session id\", buf + 39, n );\n\n    /*\n     * DTLS cookie\n     */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        if( ssl->handshake->verify_cookie == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"no verify cookie to send\" ) );\n            *p++ = 0;\n        }\n        else\n        {\n            MBEDTLS_SSL_DEBUG_BUF( 3, \"client hello, cookie\",\n                              ssl->handshake->verify_cookie,\n                              ssl->handshake->verify_cookie_len );\n\n            *p++ = ssl->handshake->verify_cookie_len;\n            memcpy( p, ssl->handshake->verify_cookie,\n                       ssl->handshake->verify_cookie_len );\n            p += ssl->handshake->verify_cookie_len;\n        }\n    }\n#endif\n\n    /*\n     * Ciphersuite list\n     */\n    ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];\n\n    /* Skip writing ciphersuite length for now */\n    n = 0;\n    q = p;\n    p += 2;\n\n    for( i = 0; ciphersuites[i] != 0; i++ )\n    {\n        ciphersuite_info = mbedtls_ssl_ciphersuite_from_id( ciphersuites[i] );\n\n        if( ciphersuite_info == NULL )\n            continue;\n\n        if( ciphersuite_info->min_minor_ver > ssl->conf->max_minor_ver ||\n            ciphersuite_info->max_minor_ver < ssl->conf->min_minor_ver )\n            continue;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n            ( ciphersuite_info->flags & MBEDTLS_CIPHERSUITE_NODTLS ) )\n            continue;\n#endif\n\n#if defined(MBEDTLS_ARC4_C)\n        if( ssl->conf->arc4_disabled == MBEDTLS_SSL_ARC4_DISABLED &&\n            ciphersuite_info->cipher == MBEDTLS_CIPHER_ARC4_128 )\n            continue;\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE &&\n            mbedtls_ecjpake_check( &ssl->handshake->ecjpake_ctx ) != 0 )\n            continue;\n#endif\n\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, add ciphersuite: %04x\",\n                                    ciphersuites[i] ) );\n\n        n++;\n        *p++ = (unsigned char)( ciphersuites[i] >> 8 );\n        *p++ = (unsigned char)( ciphersuites[i]      );\n    }\n\n    /*\n     * Add TLS_EMPTY_RENEGOTIATION_INFO_SCSV\n     */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )\n#endif\n    {\n        *p++ = (unsigned char)( MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO >> 8 );\n        *p++ = (unsigned char)( MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO      );\n        n++;\n    }\n\n    /* Some versions of OpenSSL don't handle it correctly if not at end */\n#if defined(MBEDTLS_SSL_FALLBACK_SCSV)\n    if( ssl->conf->fallback == MBEDTLS_SSL_IS_FALLBACK )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"adding FALLBACK_SCSV\" ) );\n        *p++ = (unsigned char)( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 );\n        *p++ = (unsigned char)( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      );\n        n++;\n    }\n#endif\n\n    *q++ = (unsigned char)( n >> 7 );\n    *q++ = (unsigned char)( n << 1 );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, got %d ciphersuites\", n ) );\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    offer_compress = 1;\n#else\n    offer_compress = 0;\n#endif\n\n    /*\n     * We don't support compression with DTLS right now: is many records come\n     * in the same datagram, uncompressing one could overwrite the next one.\n     * We don't want to add complexity for handling that case unless there is\n     * an actual need for it.\n     */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        offer_compress = 0;\n#endif\n\n    if( offer_compress )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, compress len.: %d\", 2 ) );\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, compress alg.: %d %d\",\n                            MBEDTLS_SSL_COMPRESS_DEFLATE, MBEDTLS_SSL_COMPRESS_NULL ) );\n\n        *p++ = 2;\n        *p++ = MBEDTLS_SSL_COMPRESS_DEFLATE;\n        *p++ = MBEDTLS_SSL_COMPRESS_NULL;\n    }\n    else\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, compress len.: %d\", 1 ) );\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, compress alg.: %d\",\n                            MBEDTLS_SSL_COMPRESS_NULL ) );\n\n        *p++ = 1;\n        *p++ = MBEDTLS_SSL_COMPRESS_NULL;\n    }\n\n    // First write extensions, then the total length\n    //\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    ssl_write_hostname_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n    /* Note that TLS_EMPTY_RENEGOTIATION_INFO_SCSV is always added\n     * even if MBEDTLS_SSL_RENEGOTIATION is not defined. */\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n    ssl_write_signature_algorithms_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    ssl_write_supported_elliptic_curves_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n\n    ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    ssl_write_ecjpake_kkpp_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n    ssl_write_max_fragment_length_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n    ssl_write_truncated_hmac_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n    ssl_write_encrypt_then_mac_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n    ssl_write_extended_ms_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_ALPN)\n    ssl_write_alpn_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n    ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );\n    ext_len += olen;\n#endif\n\n    /* olen unused if all extensions are disabled */\n    ((void) olen);\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, total extension length: %d\",\n                   ext_len ) );\n\n    if( ext_len > 0 )\n    {\n        *p++ = (unsigned char)( ( ext_len >> 8 ) & 0xFF );\n        *p++ = (unsigned char)( ( ext_len      ) & 0xFF );\n        p += ext_len;\n    }\n\n    ssl->out_msglen  = p - buf;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CLIENT_HELLO;\n\n    ssl->state++;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        mbedtls_ssl_send_flight_completed( ssl );\n#endif\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write client hello\" ) );\n\n    return( 0 );\n}\n\nstatic int ssl_parse_renegotiation_info( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        /* Check verify-data in constant-time. The length OTOH is no secret */\n        if( len    != 1 + ssl->verify_data_len * 2 ||\n            buf[0] !=     ssl->verify_data_len * 2 ||\n            mbedtls_ssl_safer_memcmp( buf + 1,\n                          ssl->own_verify_data, ssl->verify_data_len ) != 0 ||\n            mbedtls_ssl_safer_memcmp( buf + 1 + ssl->verify_data_len,\n                          ssl->peer_verify_data, ssl->verify_data_len ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching renegotiation info\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n    }\n    else\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n    {\n        if( len != 1 || buf[0] != 0x00 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-zero length renegotiation info\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n\n        ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;\n    }\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\nstatic int ssl_parse_max_fragment_length_ext( mbedtls_ssl_context *ssl,\n                                              const unsigned char *buf,\n                                              size_t len )\n{\n    /*\n     * server should use the extension only if we did,\n     * and if so the server's value should match ours (and len is always 1)\n     */\n    if( ssl->conf->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE ||\n        len != 1 ||\n        buf[0] != ssl->conf->mfl_code )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching max fragment length extension\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\nstatic int ssl_parse_truncated_hmac_ext( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED ||\n        len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching truncated HMAC extension\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    ((void) buf);\n\n    ssl->session_negotiate->trunc_hmac = MBEDTLS_SSL_TRUNC_HMAC_ENABLED;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\nstatic int ssl_parse_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED ||\n        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ||\n        len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching encrypt-then-MAC extension\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    ((void) buf);\n\n    ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\nstatic int ssl_parse_extended_ms_ext( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||\n        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ||\n        len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching extended master secret extension\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    ((void) buf);\n\n    ssl->handshake->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\nstatic int ssl_parse_session_ticket_ext( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( ssl->conf->session_tickets == MBEDTLS_SSL_SESSION_TICKETS_DISABLED ||\n        len != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching session ticket extension\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    ((void) buf);\n\n    ssl->handshake->new_session_ticket = 1;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic int ssl_parse_supported_point_formats_ext( mbedtls_ssl_context *ssl,\n                                                  const unsigned char *buf,\n                                                  size_t len )\n{\n    size_t list_size;\n    const unsigned char *p;\n\n    list_size = buf[0];\n    if( list_size + 1 != len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    p = buf + 1;\n    while( list_size > 0 )\n    {\n        if( p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||\n            p[0] == MBEDTLS_ECP_PF_COMPRESSED )\n        {\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)\n            ssl->handshake->ecdh_ctx.point_format = p[0];\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n            ssl->handshake->ecjpake_ctx.point_format = p[0];\n#endif\n            MBEDTLS_SSL_DEBUG_MSG( 4, ( \"point format selected: %d\", p[0] ) );\n            return( 0 );\n        }\n\n        list_size--;\n        p++;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"no point format in common\" ) );\n    mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                    MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n    return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n}\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C || \n          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\nstatic int ssl_parse_ecjpake_kkpp( mbedtls_ssl_context *ssl,\n                                   const unsigned char *buf,\n                                   size_t len )\n{\n    int ret;\n\n    if( ssl->transform_negotiate->ciphersuite_info->key_exchange !=\n        MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"skip ecjpake kkpp extension\" ) );\n        return( 0 );\n    }\n\n    /* If we got here, we no longer need our cached extension */\n    mbedtls_free( ssl->handshake->ecjpake_cache );\n    ssl->handshake->ecjpake_cache = NULL;\n    ssl->handshake->ecjpake_cache_len = 0;\n\n    if( ( ret = mbedtls_ecjpake_read_round_one( &ssl->handshake->ecjpake_ctx,\n                                                buf, len ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_one\", ret );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( ret );\n    }\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_ALPN)\nstatic int ssl_parse_alpn_ext( mbedtls_ssl_context *ssl,\n                               const unsigned char *buf, size_t len )\n{\n    size_t list_len, name_len;\n    const char **p;\n\n    /* If we didn't send it, the server shouldn't send it */\n    if( ssl->conf->alpn_list == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching ALPN extension\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    /*\n     * opaque ProtocolName<1..2^8-1>;\n     *\n     * struct {\n     *     ProtocolName protocol_name_list<2..2^16-1>\n     * } ProtocolNameList;\n     *\n     * the \"ProtocolNameList\" MUST contain exactly one \"ProtocolName\"\n     */\n\n    /* Min length is 2 (list_len) + 1 (name_len) + 1 (name) */\n    if( len < 4 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    list_len = ( buf[0] << 8 ) | buf[1];\n    if( list_len != len - 2 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    name_len = buf[2];\n    if( name_len != list_len - 1 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    /* Check that the server chosen protocol was in our list and save it */\n    for( p = ssl->conf->alpn_list; *p != NULL; p++ )\n    {\n        if( name_len == strlen( *p ) &&\n            memcmp( buf + 3, *p, name_len ) == 0 )\n        {\n            ssl->alpn_chosen = *p;\n            return( 0 );\n        }\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"ALPN extension: no matching protocol\" ) );\n    mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                    MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n    return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n}\n#endif /* MBEDTLS_SSL_ALPN */\n\n/*\n * Parse HelloVerifyRequest.  Only called after verifying the HS type.\n */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\nstatic int ssl_parse_hello_verify_request( mbedtls_ssl_context *ssl )\n{\n    const unsigned char *p = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n    int major_ver, minor_ver;\n    unsigned char cookie_len;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse hello verify request\" ) );\n\n    /*\n     * struct {\n     *   ProtocolVersion server_version;\n     *   opaque cookie<0..2^8-1>;\n     * } HelloVerifyRequest;\n     */\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"server version\", p, 2 );\n    mbedtls_ssl_read_version( &major_ver, &minor_ver, ssl->conf->transport, p );\n    p += 2;\n\n    /*\n     * Since the RFC is not clear on this point, accept DTLS 1.0 (TLS 1.1)\n     * even is lower than our min version.\n     */\n    if( major_ver < MBEDTLS_SSL_MAJOR_VERSION_3 ||\n        minor_ver < MBEDTLS_SSL_MINOR_VERSION_2 ||\n        major_ver > ssl->conf->max_major_ver  ||\n        minor_ver > ssl->conf->max_minor_ver  )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server version\" ) );\n\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                     MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );\n\n        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );\n    }\n\n    cookie_len = *p++;\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"cookie\", p, cookie_len );\n\n    if( ( ssl->in_msg + ssl->in_msglen ) - p < cookie_len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1,\n            ( \"cookie length does not match incoming message size\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                    MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    mbedtls_free( ssl->handshake->verify_cookie );\n\n    ssl->handshake->verify_cookie = mbedtls_calloc( 1, cookie_len );\n    if( ssl->handshake->verify_cookie  == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc failed (%d bytes)\", cookie_len ) );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n\n    memcpy( ssl->handshake->verify_cookie, p, cookie_len );\n    ssl->handshake->verify_cookie_len = cookie_len;\n\n    /* Start over at ClientHello */\n    ssl->state = MBEDTLS_SSL_CLIENT_HELLO;\n    mbedtls_ssl_reset_checksum( ssl );\n\n    mbedtls_ssl_recv_flight_completed( ssl );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse hello verify request\" ) );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\nstatic int ssl_parse_server_hello( mbedtls_ssl_context *ssl )\n{\n    int ret, i;\n    size_t n;\n    size_t ext_len;\n    unsigned char *buf, *ext;\n    unsigned char comp;\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    int accept_comp;\n#endif\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    int renegotiation_info_seen = 0;\n#endif\n    int handshake_failure = 0;\n    const mbedtls_ssl_ciphersuite_t *suite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server hello\" ) );\n\n    buf = ssl->in_msg;\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        /* No alert on a read error. */\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n        {\n            ssl->renego_records_seen++;\n\n            if( ssl->conf->renego_max_records >= 0 &&\n                ssl->renego_records_seen > ssl->conf->renego_max_records )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"renegotiation requested, \"\n                                    \"but not honored by server\" ) );\n                return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n            }\n\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-handshake message during renego\" ) );\n\n            ssl->keep_current_message = 1;\n            return( MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO );\n        }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        if( buf[0] == MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"received hello verify request\" ) );\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server hello\" ) );\n            return( ssl_parse_hello_verify_request( ssl ) );\n        }\n        else\n        {\n            /* We made it through the verification process */\n            mbedtls_free( ssl->handshake->verify_cookie );\n            ssl->handshake->verify_cookie = NULL;\n            ssl->handshake->verify_cookie_len = 0;\n        }\n    }\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n\n    if( ssl->in_hslen < 38 + mbedtls_ssl_hs_hdr_len( ssl ) ||\n        buf[0] != MBEDTLS_SSL_HS_SERVER_HELLO )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    /*\n     *  0   .  1    server_version\n     *  2   . 33    random (maybe including 4 bytes of Unix time)\n     * 34   . 34    session_id length = n\n     * 35   . 34+n  session_id\n     * 35+n . 36+n  cipher_suite\n     * 37+n . 37+n  compression_method\n     *\n     * 38+n . 39+n  extensions length (optional)\n     * 40+n .  ..   extensions\n     */\n    buf += mbedtls_ssl_hs_hdr_len( ssl );\n\n    MBEDTLS_SSL_DEBUG_BUF( 3, \"server hello, version\", buf + 0, 2 );\n    mbedtls_ssl_read_version( &ssl->major_ver, &ssl->minor_ver,\n                      ssl->conf->transport, buf + 0 );\n\n    if( ssl->major_ver < ssl->conf->min_major_ver ||\n        ssl->minor_ver < ssl->conf->min_minor_ver ||\n        ssl->major_ver > ssl->conf->max_major_ver ||\n        ssl->minor_ver > ssl->conf->max_minor_ver )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server version out of bounds - \"\n                            \" min: [%d:%d], server: [%d:%d], max: [%d:%d]\",\n                            ssl->conf->min_major_ver, ssl->conf->min_minor_ver,\n                            ssl->major_ver, ssl->minor_ver,\n                            ssl->conf->max_major_ver, ssl->conf->max_minor_ver ) );\n\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                     MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );\n\n        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, current time: %lu\",\n                           ( (uint32_t) buf[2] << 24 ) |\n                           ( (uint32_t) buf[3] << 16 ) |\n                           ( (uint32_t) buf[4] <<  8 ) |\n                           ( (uint32_t) buf[5]       ) ) );\n\n    memcpy( ssl->handshake->randbytes + 32, buf + 2, 32 );\n\n    n = buf[34];\n\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"server hello, random bytes\", buf + 2, 32 );\n\n    if( n > 32 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    if( ssl->in_hslen > mbedtls_ssl_hs_hdr_len( ssl ) + 39 + n )\n    {\n        ext_len = ( ( buf[38 + n] <<  8 )\n                  | ( buf[39 + n]       ) );\n\n        if( ( ext_len > 0 && ext_len < 4 ) ||\n            ssl->in_hslen != mbedtls_ssl_hs_hdr_len( ssl ) + 40 + n + ext_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n    }\n    else if( ssl->in_hslen == mbedtls_ssl_hs_hdr_len( ssl ) + 38 + n )\n    {\n        ext_len = 0;\n    }\n    else\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    /* ciphersuite (used later) */\n    i = ( buf[35 + n] << 8 ) | buf[36 + n];\n\n    /*\n     * Read and check compression\n     */\n    comp = buf[37 + n];\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    /* See comments in ssl_write_client_hello() */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        accept_comp = 0;\n    else\n#endif\n        accept_comp = 1;\n\n    if( comp != MBEDTLS_SSL_COMPRESS_NULL &&\n        ( comp != MBEDTLS_SSL_COMPRESS_DEFLATE || accept_comp == 0 ) )\n#else /* MBEDTLS_ZLIB_SUPPORT */\n    if( comp != MBEDTLS_SSL_COMPRESS_NULL )\n#endif/* MBEDTLS_ZLIB_SUPPORT */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server hello, bad compression: %d\", comp ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );\n    }\n\n    /*\n     * Initialize update checksum functions\n     */\n    ssl->transform_negotiate->ciphersuite_info = mbedtls_ssl_ciphersuite_from_id( i );\n\n    if( ssl->transform_negotiate->ciphersuite_info == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"ciphersuite info for %04x not found\", i ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    mbedtls_ssl_optimize_checksum( ssl, ssl->transform_negotiate->ciphersuite_info );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, session id len.: %d\", n ) );\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"server hello, session id\", buf + 35, n );\n\n    /*\n     * Check if the session can be resumed\n     */\n    if( ssl->handshake->resume == 0 || n == 0 ||\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n        ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE ||\n#endif\n        ssl->session_negotiate->ciphersuite != i ||\n        ssl->session_negotiate->compression != comp ||\n        ssl->session_negotiate->id_len != n ||\n        memcmp( ssl->session_negotiate->id, buf + 35, n ) != 0 )\n    {\n        ssl->state++;\n        ssl->handshake->resume = 0;\n#if defined(MBEDTLS_HAVE_TIME)\n        ssl->session_negotiate->start = mbedtls_time( NULL );\n#endif\n        ssl->session_negotiate->ciphersuite = i;\n        ssl->session_negotiate->compression = comp;\n        ssl->session_negotiate->id_len = n;\n        memcpy( ssl->session_negotiate->id, buf + 35, n );\n    }\n    else\n    {\n        ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;\n\n        if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );\n            return( ret );\n        }\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"%s session has been resumed\",\n                   ssl->handshake->resume ? \"a\" : \"no\" ) );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, chosen ciphersuite: %04x\", i ) );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, compress alg.: %d\", buf[37 + n] ) );\n\n    suite_info = mbedtls_ssl_ciphersuite_from_id( ssl->session_negotiate->ciphersuite );\n    if( suite_info == NULL\n#if defined(MBEDTLS_ARC4_C)\n            || ( ssl->conf->arc4_disabled &&\n                suite_info->cipher == MBEDTLS_CIPHER_ARC4_128 )\n#endif\n        )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, chosen ciphersuite: %s\", suite_info->name ) );\n\n    i = 0;\n    while( 1 )\n    {\n        if( ssl->conf->ciphersuite_list[ssl->minor_ver][i] == 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n\n        if( ssl->conf->ciphersuite_list[ssl->minor_ver][i++] ==\n            ssl->session_negotiate->ciphersuite )\n        {\n            break;\n        }\n    }\n\n    if( comp != MBEDTLS_SSL_COMPRESS_NULL\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n        && comp != MBEDTLS_SSL_COMPRESS_DEFLATE\n#endif\n      )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n    ssl->session_negotiate->compression = comp;\n\n    ext = buf + 40 + n;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"server hello, total extension length: %d\", ext_len ) );\n\n    while( ext_len )\n    {\n        unsigned int ext_id   = ( ( ext[0] <<  8 )\n                                | ( ext[1]       ) );\n        unsigned int ext_size = ( ( ext[2] <<  8 )\n                                | ( ext[3]       ) );\n\n        if( ext_size + 4 > ext_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n\n        switch( ext_id )\n        {\n        case MBEDTLS_TLS_EXT_RENEGOTIATION_INFO:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found renegotiation extension\" ) );\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n            renegotiation_info_seen = 1;\n#endif\n\n            if( ( ret = ssl_parse_renegotiation_info( ssl, ext + 4,\n                                                      ext_size ) ) != 0 )\n                return( ret );\n\n            break;\n\n#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)\n        case MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found max_fragment_length extension\" ) );\n\n            if( ( ret = ssl_parse_max_fragment_length_ext( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */\n\n#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)\n        case MBEDTLS_TLS_EXT_TRUNCATED_HMAC:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found truncated_hmac extension\" ) );\n\n            if( ( ret = ssl_parse_truncated_hmac_ext( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */\n\n#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)\n        case MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found encrypt_then_mac extension\" ) );\n\n            if( ( ret = ssl_parse_encrypt_then_mac_ext( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */\n\n#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)\n        case MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found extended_master_secret extension\" ) );\n\n            if( ( ret = ssl_parse_extended_ms_ext( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n        case MBEDTLS_TLS_EXT_SESSION_TICKET:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found session_ticket extension\" ) );\n\n            if( ( ret = ssl_parse_session_ticket_ext( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n        case MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found supported_point_formats extension\" ) );\n\n            if( ( ret = ssl_parse_supported_point_formats_ext( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||\n          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n        case MBEDTLS_TLS_EXT_ECJPAKE_KKPP:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found ecjpake_kkpp extension\" ) );\n\n            if( ( ret = ssl_parse_ecjpake_kkpp( ssl,\n                            ext + 4, ext_size ) ) != 0 )\n            {\n                return( ret );\n            }\n\n            break;\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n\n#if defined(MBEDTLS_SSL_ALPN)\n        case MBEDTLS_TLS_EXT_ALPN:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"found alpn extension\" ) );\n\n            if( ( ret = ssl_parse_alpn_ext( ssl, ext + 4, ext_size ) ) != 0 )\n                return( ret );\n\n            break;\n#endif /* MBEDTLS_SSL_ALPN */\n\n        default:\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"unknown extension found: %d (ignoring)\",\n                           ext_id ) );\n        }\n\n        ext_len -= 4 + ext_size;\n        ext += 4 + ext_size;\n\n        if( ext_len > 0 && ext_len < 4 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n    }\n\n    /*\n     * Renegotiation security checks\n     */\n    if( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&\n        ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"legacy renegotiation, breaking off handshake\" ) );\n        handshake_failure = 1;\n    }\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&\n             ssl->secure_renegotiation == MBEDTLS_SSL_SECURE_RENEGOTIATION &&\n             renegotiation_info_seen == 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"renegotiation_info extension missing (secure)\" ) );\n        handshake_failure = 1;\n    }\n    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&\n             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&\n             ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"legacy renegotiation not allowed\" ) );\n        handshake_failure = 1;\n    }\n    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&\n             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&\n             renegotiation_info_seen == 1 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"renegotiation_info extension present (legacy)\" ) );\n        handshake_failure = 1;\n    }\n#endif /* MBEDTLS_SSL_RENEGOTIATION */\n\n    if( handshake_failure == 1 )\n    {\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server hello\" ) );\n\n    return( 0 );\n}\n\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\nstatic int ssl_parse_server_dh_params( mbedtls_ssl_context *ssl, unsigned char **p,\n                                       unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n\n    /*\n     * Ephemeral DH parameters:\n     *\n     * struct {\n     *     opaque dh_p<1..2^16-1>;\n     *     opaque dh_g<1..2^16-1>;\n     *     opaque dh_Ys<1..2^16-1>;\n     * } ServerDHParams;\n     */\n    if( ( ret = mbedtls_dhm_read_params( &ssl->handshake->dhm_ctx, p, end ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 2, ( \"mbedtls_dhm_read_params\" ), ret );\n        return( ret );\n    }\n\n    if( ssl->handshake->dhm_ctx.len * 8 < ssl->conf->dhm_min_bitlen )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"DHM prime too short: %d < %d\",\n                                    ssl->handshake->dhm_ctx.len * 8,\n                                    ssl->conf->dhm_min_bitlen ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: P \", &ssl->handshake->dhm_ctx.P  );\n    MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: G \", &ssl->handshake->dhm_ctx.G  );\n    MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: GY\", &ssl->handshake->dhm_ctx.GY );\n\n    return( ret );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\nstatic int ssl_check_server_ecdh_params( const mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ecp_curve_info *curve_info;\n\n    curve_info = mbedtls_ecp_curve_info_from_grp_id( ssl->handshake->ecdh_ctx.grp.id );\n    if( curve_info == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"ECDH curve: %s\", curve_info->name ) );\n\n#if defined(MBEDTLS_ECP_C)\n    if( mbedtls_ssl_check_curve( ssl, ssl->handshake->ecdh_ctx.grp.id ) != 0 )\n#else\n    if( ssl->handshake->ecdh_ctx.grp.nbits < 163 ||\n        ssl->handshake->ecdh_ctx.grp.nbits > 521 )\n#endif\n        return( -1 );\n\n    MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Qp\", &ssl->handshake->ecdh_ctx.Qp );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)\nstatic int ssl_parse_server_ecdh_params( mbedtls_ssl_context *ssl,\n                                         unsigned char **p,\n                                         unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n\n    /*\n     * Ephemeral ECDH parameters:\n     *\n     * struct {\n     *     ECParameters curve_params;\n     *     ECPoint      public;\n     * } ServerECDHParams;\n     */\n    if( ( ret = mbedtls_ecdh_read_params( &ssl->handshake->ecdh_ctx,\n                                  (const unsigned char **) p, end ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, ( \"mbedtls_ecdh_read_params\" ), ret );\n        return( ret );\n    }\n\n    if( ssl_check_server_ecdh_params( ssl ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message (ECDHE curve)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    return( ret );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\nstatic int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n\n    /*\n     * PSK parameters:\n     *\n     * opaque psk_identity_hint<0..2^16-1>;\n     */\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n\n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    /*\n     * Note: we currently ignore the PKS identity hint, as we only allow one\n     * PSK to be provisionned on the client. This could be changed later if\n     * someone needs that feature.\n     */\n    *p += len;\n    ret = 0;\n\n    return( ret );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                           \\\n    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n/*\n * Generate a pre-master secret and encrypt it with the server's RSA key\n */\nstatic int ssl_write_encrypted_pms( mbedtls_ssl_context *ssl,\n                                    size_t offset, size_t *olen,\n                                    size_t pms_offset )\n{\n    int ret;\n    size_t len_bytes = ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ? 0 : 2;\n    unsigned char *p = ssl->handshake->premaster + pms_offset;\n\n    if( offset + len_bytes > MBEDTLS_SSL_MAX_CONTENT_LEN )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"buffer too small for encrypted pms\" ) );\n        return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );\n    }\n\n    /*\n     * Generate (part of) the pre-master as\n     *  struct {\n     *      ProtocolVersion client_version;\n     *      opaque random[46];\n     *  } PreMasterSecret;\n     */\n    mbedtls_ssl_write_version( ssl->conf->max_major_ver, ssl->conf->max_minor_ver,\n                       ssl->conf->transport, p );\n\n    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p + 2, 46 ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"f_rng\", ret );\n        return( ret );\n    }\n\n    ssl->handshake->pmslen = 48;\n\n    if( ssl->session_negotiate->peer_cert == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /*\n     * Now write it out, encrypted\n     */\n    if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk,\n                MBEDTLS_PK_RSA ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"certificate key type mismatch\" ) );\n        return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n    }\n\n    if( ( ret = mbedtls_pk_encrypt( &ssl->session_negotiate->peer_cert->pk,\n                            p, ssl->handshake->pmslen,\n                            ssl->out_msg + offset + len_bytes, olen,\n                            MBEDTLS_SSL_MAX_CONTENT_LEN - offset - len_bytes,\n                            ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_rsa_pkcs1_encrypt\", ret );\n        return( ret );\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( len_bytes == 2 )\n    {\n        ssl->out_msg[offset+0] = (unsigned char)( *olen >> 8 );\n        ssl->out_msg[offset+1] = (unsigned char)( *olen      );\n        *olen += 2;\n    }\n#endif\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\nstatic int ssl_parse_signature_algorithm( mbedtls_ssl_context *ssl,\n                                          unsigned char **p,\n                                          unsigned char *end,\n                                          mbedtls_md_type_t *md_alg,\n                                          mbedtls_pk_type_t *pk_alg )\n{\n    ((void) ssl);\n    *md_alg = MBEDTLS_MD_NONE;\n    *pk_alg = MBEDTLS_PK_NONE;\n\n    /* Only in TLS 1.2 */\n    if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        return( 0 );\n    }\n\n    if( (*p) + 2 > end )\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n\n    /*\n     * Get hash algorithm\n     */\n    if( ( *md_alg = mbedtls_ssl_md_alg_from_hash( (*p)[0] ) ) == MBEDTLS_MD_NONE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"Server used unsupported \"\n                            \"HashAlgorithm %d\", *(p)[0] ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    /*\n     * Get signature algorithm\n     */\n    if( ( *pk_alg = mbedtls_ssl_pk_alg_from_sig( (*p)[1] ) ) == MBEDTLS_PK_NONE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server used unsupported \"\n                            \"SignatureAlgorithm %d\", (*p)[1] ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    /*\n     * Check if the hash is acceptable\n     */\n    if( mbedtls_ssl_check_sig_hash( ssl, *md_alg ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server used HashAlgorithm %d that was not offered\",\n                                    *(p)[0] ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"Server used SignatureAlgorithm %d\", (*p)[1] ) );\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"Server used HashAlgorithm %d\", (*p)[0] ) );\n    *p += 2;\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\nstatic int ssl_get_ecdh_params_from_cert( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const mbedtls_ecp_keypair *peer_key;\n\n    if( ssl->session_negotiate->peer_cert == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk,\n                     MBEDTLS_PK_ECKEY ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key not ECDH capable\" ) );\n        return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n    }\n\n    peer_key = mbedtls_pk_ec( ssl->session_negotiate->peer_cert->pk );\n\n    if( ( ret = mbedtls_ecdh_get_params( &ssl->handshake->ecdh_ctx, peer_key,\n                                 MBEDTLS_ECDH_THEIRS ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, ( \"mbedtls_ecdh_get_params\" ), ret );\n        return( ret );\n    }\n\n    if( ssl_check_server_ecdh_params( ssl ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server certificate (ECDH curve)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    return( ret );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n\nstatic int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    unsigned char *p = NULL, *end = NULL;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server key exchange\" ) );\n\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    ((void) p);\n    ((void) end);\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )\n    {\n        if( ( ret = ssl_get_ecdh_params_from_cert( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_get_ecdh_params_from_cert\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse server key exchange\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n    ((void) p);\n    ((void) end);\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /*\n     * ServerKeyExchange may be skipped with PSK and RSA-PSK when the server\n     * doesn't use a psk_identity_hint\n     */\n    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE )\n    {\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n            ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        {\n            /* Current message is probably either\n             * CertificateRequest or ServerHelloDone */\n            ssl->keep_current_message = 1;\n            goto exit;\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server key exchange message must \"\n                                    \"not be skipped\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n    end = ssl->in_msg + ssl->in_hslen;\n    MBEDTLS_SSL_DEBUG_BUF( 3,   \"server key exchange\", p, end - p );\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n    {\n        if( ssl_parse_server_psk_hint( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    } /* FALLTROUGH */\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        ; /* nothing more to do */\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \\\n    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )\n    {\n        if( ssl_parse_server_dh_params( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )\n    {\n        if( ssl_parse_server_ecdh_params( ssl, &p, end ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,\n                                              p, end - p );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_read_round_two\", ret );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )\n    {\n        size_t sig_len, hashlen;\n        unsigned char hash[64];\n        mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;\n        mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;\n        unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n        size_t params_len = p - params;\n\n        /*\n         * Handle the digitally-signed structure\n         */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            if( ssl_parse_signature_algorithm( ssl, &p, end,\n                                               &md_alg, &pk_alg ) != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n            }\n\n            if( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                                MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );\n                return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n            }\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )\n        {\n            pk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );\n\n            /* Default hash for ECDSA is SHA-1 */\n            if( pk_alg == MBEDTLS_PK_ECDSA && md_alg == MBEDTLS_MD_NONE )\n                md_alg = MBEDTLS_MD_SHA1;\n        }\n        else\n#endif\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        /*\n         * Read signature\n         */\n\n        if( p > end - 2 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n        sig_len = ( p[0] << 8 ) | p[1];\n        p += 2;\n\n        if( p != end - sig_len )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"signature\", p, sig_len );\n\n        /*\n         * Compute the hash that has been signed\n         */\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n        if( md_alg == MBEDTLS_MD_NONE )\n        {\n            hashlen = 36;\n            ret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash, params,\n                                                           params_len );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n        if( md_alg != MBEDTLS_MD_NONE )\n        {\n            /* Info from md_alg will be used instead */\n            hashlen = 0;\n            ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, params,\n                                                          params_len, md_alg );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_2 */\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"parameters hash\", hash, hashlen != 0 ? hashlen :\n            (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );\n\n        if( ssl->session_negotiate->peer_cert == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n        }\n\n        /*\n         * Verify signature\n         */\n        if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );\n        }\n\n        if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,\n                               md_alg, hash, hashlen, p, sig_len ) ) != 0 )\n        {\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR );\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_verify\", ret );\n            return( ret );\n        }\n    }\n#endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */\n\nexit:\n    ssl->state++;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server key exchange\" ) );\n\n    return( 0 );\n}\n\n#if ! defined(MBEDTLS_KEY_EXCHANGE__CERT_REQ_ALLOWED__ENABLED)\nstatic int ssl_parse_certificate_request( mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse certificate request\" ) );\n\n    if( ! mbedtls_ssl_ciphersuite_cert_req_allowed( ciphersuite_info ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate request\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\n#else /* MBEDTLS_KEY_EXCHANGE__CERT_REQ_ALLOWED__ENABLED */\nstatic int ssl_parse_certificate_request( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    unsigned char *buf;\n    size_t n = 0;\n    size_t cert_type_len = 0, dn_len = 0;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse certificate request\" ) );\n\n    if( ! mbedtls_ssl_ciphersuite_cert_req_allowed( ciphersuite_info ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip parse certificate request\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    ssl->state++;\n    ssl->client_auth = ( ssl->in_msg[0] == MBEDTLS_SSL_HS_CERTIFICATE_REQUEST );\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"got %s certificate request\",\n                        ssl->client_auth ? \"a\" : \"no\" ) );\n\n    if( ssl->client_auth == 0 )\n    {\n        /* Current message is probably the ServerHelloDone */\n        ssl->keep_current_message = 1;\n        goto exit;\n    }\n\n    /*\n     *  struct {\n     *      ClientCertificateType certificate_types<1..2^8-1>;\n     *      SignatureAndHashAlgorithm\n     *        supported_signature_algorithms<2^16-1>; -- TLS 1.2 only\n     *      DistinguishedName certificate_authorities<0..2^16-1>;\n     *  } CertificateRequest;\n     *\n     *  Since we only support a single certificate on clients, let's just\n     *  ignore all the information that's supposed to help us pick a\n     *  certificate.\n     *\n     *  We could check that our certificate matches the request, and bail out\n     *  if it doesn't, but it's simpler to just send the certificate anyway,\n     *  and give the server the opportunity to decide if it should terminate\n     *  the connection when it doesn't like our certificate.\n     *\n     *  Same goes for the hash in TLS 1.2's signature_algorithms: at this\n     *  point we only have one hash available (see comments in\n     *  write_certificate_verify), so let's just use what we have.\n     *\n     *  However, we still minimally parse the message to check it is at least\n     *  superficially sane.\n     */\n    buf = ssl->in_msg;\n\n    /* certificate_types */\n    cert_type_len = buf[mbedtls_ssl_hs_hdr_len( ssl )];\n    n = cert_type_len;\n\n    if( ssl->in_hslen < mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n    }\n\n    /* supported_signature_algorithms */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        size_t sig_alg_len = ( ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 1 + n] <<  8 )\n                             | ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n]       ) );\n#if defined(MBEDTLS_DEBUG_C)\n        unsigned char* sig_alg = buf + mbedtls_ssl_hs_hdr_len( ssl ) + 3 + n;\n        size_t i;\n\n        for( i = 0; i < sig_alg_len; i += 2 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"Supported Signature Algorithm found: %d\"\n                                        \",%d\", sig_alg[i], sig_alg[i + 1]  ) );\n        }\n#endif\n\n        n += 2 + sig_alg_len;\n\n        if( ssl->in_hslen < mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n        }\n    }\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n\n    /* certificate_authorities */\n    dn_len = ( ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 1 + n] <<  8 )\n             | ( buf[mbedtls_ssl_hs_hdr_len( ssl ) + 2 + n]       ) );\n\n    n += dn_len;\n    if( ssl->in_hslen != mbedtls_ssl_hs_hdr_len( ssl ) + 3 + n )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n    }\n\nexit:\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse certificate request\" ) );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_KEY_EXCHANGE__CERT_REQ_ALLOWED__ENABLED */\n\nstatic int ssl_parse_server_hello_done( mbedtls_ssl_context *ssl )\n{\n    int ret;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse server hello done\" ) );\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello done message\" ) );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl->in_hslen  != mbedtls_ssl_hs_hdr_len( ssl ) ||\n        ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_HELLO_DONE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server hello done message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO_DONE );\n    }\n\n    ssl->state++;\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n        mbedtls_ssl_recv_flight_completed( ssl );\n#endif\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse server hello done\" ) );\n\n    return( 0 );\n}\n\nstatic int ssl_write_client_key_exchange( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write client key exchange\" ) );\n\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA )\n    {\n        /*\n         * DHM key exchange -- send G^X mod P\n         */\n        n = ssl->handshake->dhm_ctx.len;\n\n        ssl->out_msg[4] = (unsigned char)( n >> 8 );\n        ssl->out_msg[5] = (unsigned char)( n      );\n        i = 6;\n\n        ret = mbedtls_dhm_make_public( &ssl->handshake->dhm_ctx,\n                                (int) mbedtls_mpi_size( &ssl->handshake->dhm_ctx.P ),\n                               &ssl->out_msg[i], n,\n                                ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_dhm_make_public\", ret );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: X \", &ssl->handshake->dhm_ctx.X  );\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: GX\", &ssl->handshake->dhm_ctx.GX );\n\n        if( ( ret = mbedtls_dhm_calc_secret( &ssl->handshake->dhm_ctx,\n                                      ssl->handshake->premaster,\n                                      MBEDTLS_PREMASTER_SIZE,\n                                     &ssl->handshake->pmslen,\n                                      ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_dhm_calc_secret\", ret );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"DHM: K \", &ssl->handshake->dhm_ctx.K  );\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )\n    {\n        /*\n         * ECDH key exchange -- send client public value\n         */\n        i = 4;\n\n        ret = mbedtls_ecdh_make_public( &ssl->handshake->ecdh_ctx,\n                                &n,\n                                &ssl->out_msg[i], 1000,\n                                ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_make_public\", ret );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Q\", &ssl->handshake->ecdh_ctx.Q );\n\n        if( ( ret = mbedtls_ecdh_calc_secret( &ssl->handshake->ecdh_ctx,\n                                      &ssl->handshake->pmslen,\n                                       ssl->handshake->premaster,\n                                       MBEDTLS_MPI_MAX_SIZE,\n                                       ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_calc_secret\", ret );\n            return( ret );\n        }\n\n        MBEDTLS_SSL_DEBUG_MPI( 3, \"ECDH: z\", &ssl->handshake->ecdh_ctx.z );\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||\n          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    if( mbedtls_ssl_ciphersuite_uses_psk( ciphersuite_info ) )\n    {\n        /*\n         * opaque psk_identity<0..2^16-1>;\n         */\n        if( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no private key for PSK\" ) );\n            return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n        }\n\n        i = 4;\n        n = ssl->conf->psk_identity_len;\n\n        if( i + 2 + n > MBEDTLS_SSL_MAX_CONTENT_LEN )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"psk identity too long or \"\n                                        \"SSL buffer too short\" ) );\n            return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );\n        }\n\n        ssl->out_msg[i++] = (unsigned char)( n >> 8 );\n        ssl->out_msg[i++] = (unsigned char)( n      );\n\n        memcpy( ssl->out_msg + i, ssl->conf->psk_identity, ssl->conf->psk_identity_len );\n        i += ssl->conf->psk_identity_len;\n\n#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK )\n        {\n            n = 0;\n        }\n        else\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n        {\n            if( ( ret = ssl_write_encrypted_pms( ssl, i, &n, 2 ) ) != 0 )\n                return( ret );\n        }\n        else\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )\n        {\n            /*\n             * ClientDiffieHellmanPublic public (DHM send G^X mod P)\n             */\n            n = ssl->handshake->dhm_ctx.len;\n\n            if( i + 2 + n > MBEDTLS_SSL_MAX_CONTENT_LEN )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"psk identity or DHM size too long\"\n                                            \" or SSL buffer too short\" ) );\n                return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );\n            }\n\n            ssl->out_msg[i++] = (unsigned char)( n >> 8 );\n            ssl->out_msg[i++] = (unsigned char)( n      );\n\n            ret = mbedtls_dhm_make_public( &ssl->handshake->dhm_ctx,\n                    (int) mbedtls_mpi_size( &ssl->handshake->dhm_ctx.P ),\n                    &ssl->out_msg[i], n,\n                    ssl->conf->f_rng, ssl->conf->p_rng );\n            if( ret != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_dhm_make_public\", ret );\n                return( ret );\n            }\n        }\n        else\n#endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)\n        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )\n        {\n            /*\n             * ClientECDiffieHellmanPublic public;\n             */\n            ret = mbedtls_ecdh_make_public( &ssl->handshake->ecdh_ctx, &n,\n                    &ssl->out_msg[i], MBEDTLS_SSL_MAX_CONTENT_LEN - i,\n                    ssl->conf->f_rng, ssl->conf->p_rng );\n            if( ret != 0 )\n            {\n                MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecdh_make_public\", ret );\n                return( ret );\n            }\n\n            MBEDTLS_SSL_DEBUG_ECP( 3, \"ECDH: Q\", &ssl->handshake->ecdh_ctx.Q );\n        }\n        else\n#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,\n                        ciphersuite_info->key_exchange ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_psk_derive_premaster\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )\n    {\n        i = 4;\n        if( ( ret = ssl_write_encrypted_pms( ssl, i, &n, 0 ) ) != 0 )\n            return( ret );\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        i = 4;\n\n        ret = mbedtls_ecjpake_write_round_two( &ssl->handshake->ecjpake_ctx,\n                ssl->out_msg + i, MBEDTLS_SSL_MAX_CONTENT_LEN - i, &n,\n                ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_write_round_two\", ret );\n            return( ret );\n        }\n\n        ret = mbedtls_ecjpake_derive_secret( &ssl->handshake->ecjpake_ctx,\n                ssl->handshake->premaster, 32, &ssl->handshake->pmslen,\n                ssl->conf->f_rng, ssl->conf->p_rng );\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ecjpake_derive_secret\", ret );\n            return( ret );\n        }\n    }\n    else\n#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */\n    {\n        ((void) ciphersuite_info);\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    ssl->out_msglen  = i + n;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE;\n\n    ssl->state++;\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write client key exchange\" ) );\n\n    return( 0 );\n}\n\n#if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)  && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)&& \\\n    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)\nstatic int ssl_write_certificate_verify( mbedtls_ssl_context *ssl )\n{\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    int ret;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write certificate verify\" ) );\n\n    if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n        return( ret );\n    }\n\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n}\n#else\nstatic int ssl_write_certificate_verify( mbedtls_ssl_context *ssl )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =\n        ssl->transform_negotiate->ciphersuite_info;\n    size_t n = 0, offset = 0;\n    unsigned char hash[48];\n    unsigned char *hash_start = hash;\n    mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;\n    unsigned int hashlen;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> write certificate verify\" ) );\n\n    if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_derive_keys\", ret );\n        return( ret );\n    }\n\n    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( ssl->client_auth == 0 || mbedtls_ssl_own_cert( ssl ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= skip write certificate verify\" ) );\n        ssl->state++;\n        return( 0 );\n    }\n\n    if( mbedtls_ssl_own_key( ssl ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no private key for certificate\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n\n    /*\n     * Make an RSA signature of the handshake digests\n     */\n    ssl->handshake->calc_verify( ssl, hash );\n\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n    if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        /*\n         * digitally-signed struct {\n         *     opaque md5_hash[16];\n         *     opaque sha_hash[20];\n         * };\n         *\n         * md5_hash\n         *     MD5(handshake_messages);\n         *\n         * sha_hash\n         *     SHA(handshake_messages);\n         */\n        hashlen = 36;\n        md_alg = MBEDTLS_MD_NONE;\n\n        /*\n         * For ECDSA, default hash is SHA-1 only\n         */\n        if( mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_ECDSA ) )\n        {\n            hash_start += 16;\n            hashlen -= 16;\n            md_alg = MBEDTLS_MD_SHA1;\n        }\n    }\n    else\n#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )\n    {\n        /*\n         * digitally-signed struct {\n         *     opaque handshake_messages[handshake_messages_length];\n         * };\n         *\n         * Taking shortcut here. We assume that the server always allows the\n         * PRF Hash function and has sent it in the allowed signature\n         * algorithms list received in the Certificate Request message.\n         *\n         * Until we encounter a server that does not, we will take this\n         * shortcut.\n         *\n         * Reason: Otherwise we should have running hashes for SHA512 and SHA224\n         *         in order to satisfy 'weird' needs from the server side.\n         */\n        if( ssl->transform_negotiate->ciphersuite_info->mac ==\n            MBEDTLS_MD_SHA384 )\n        {\n            md_alg = MBEDTLS_MD_SHA384;\n            ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA384;\n        }\n        else\n        {\n            md_alg = MBEDTLS_MD_SHA256;\n            ssl->out_msg[4] = MBEDTLS_SSL_HASH_SHA256;\n        }\n        ssl->out_msg[5] = mbedtls_ssl_sig_from_pk( mbedtls_ssl_own_key( ssl ) );\n\n        /* Info from md_alg will be used instead */\n        hashlen = 0;\n        offset = 2;\n    }\n    else\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash_start, hashlen,\n                         ssl->out_msg + 6 + offset, &n,\n                         ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_pk_sign\", ret );\n        return( ret );\n    }\n\n    ssl->out_msg[4 + offset] = (unsigned char)( n >> 8 );\n    ssl->out_msg[5 + offset] = (unsigned char)( n      );\n\n    ssl->out_msglen  = 6 + n + offset;\n    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;\n    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_VERIFY;\n\n    ssl->state++;\n\n    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= write certificate verify\" ) );\n\n    return( ret );\n}\n#endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED &&\n          !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\nstatic int ssl_parse_new_session_ticket( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    uint32_t lifetime;\n    size_t ticket_len;\n    unsigned char *ticket;\n    const unsigned char *msg;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> parse new session ticket\" ) );\n\n    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad new session ticket message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /*\n     * struct {\n     *     uint32 ticket_lifetime_hint;\n     *     opaque ticket<0..2^16-1>;\n     * } NewSessionTicket;\n     *\n     * 0  .  3   ticket_lifetime_hint\n     * 4  .  5   ticket_len (n)\n     * 6  .  5+n ticket content\n     */\n    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_NEW_SESSION_TICKET ||\n        ssl->in_hslen < 6 + mbedtls_ssl_hs_hdr_len( ssl ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad new session ticket message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET );\n    }\n\n    msg = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );\n\n    lifetime = ( msg[0] << 24 ) | ( msg[1] << 16 ) |\n               ( msg[2] <<  8 ) | ( msg[3]       );\n\n    ticket_len = ( msg[4] << 8 ) | ( msg[5] );\n\n    if( ticket_len + 6 + mbedtls_ssl_hs_hdr_len( ssl ) != ssl->in_hslen )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad new session ticket message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_NEW_SESSION_TICKET );\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ticket length: %d\", ticket_len ) );\n\n    /* We're not waiting for a NewSessionTicket message any more */\n    ssl->handshake->new_session_ticket = 0;\n    ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;\n\n    /*\n     * Zero-length ticket means the server changed his mind and doesn't want\n     * to send a ticket after all, so just forget it\n     */\n    if( ticket_len == 0 )\n        return( 0 );\n\n    mbedtls_zeroize( ssl->session_negotiate->ticket,\n                      ssl->session_negotiate->ticket_len );\n    mbedtls_free( ssl->session_negotiate->ticket );\n    ssl->session_negotiate->ticket = NULL;\n    ssl->session_negotiate->ticket_len = 0;\n\n    if( ( ticket = mbedtls_calloc( 1, ticket_len ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"ticket alloc failed\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n\n    memcpy( ticket, msg + 6, ticket_len );\n\n    ssl->session_negotiate->ticket = ticket;\n    ssl->session_negotiate->ticket_len = ticket_len;\n    ssl->session_negotiate->ticket_lifetime = lifetime;\n\n    /*\n     * RFC 5077 section 3.4:\n     * \"If the client receives a session ticket from the server, then it\n     * discards any Session ID that was sent in the ServerHello.\"\n     */\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"ticket in use, discarding session id\" ) );\n    ssl->session_negotiate->id_len = 0;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= parse new session ticket\" ) );\n\n    return( 0 );\n}\n#endif /* MBEDTLS_SSL_SESSION_TICKETS */\n\n/*\n * SSL handshake -- client side -- single step\n */\nint mbedtls_ssl_handshake_client_step( mbedtls_ssl_context *ssl )\n{\n    int ret = 0;\n\n    if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER || ssl->handshake == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"client state: %d\", ssl->state ) );\n\n    if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )\n        return( ret );\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n        ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING )\n    {\n        if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )\n            return( ret );\n    }\n#endif\n\n    /* Change state now, so that it is right in mbedtls_ssl_read_record(), used\n     * by DTLS for dropping out-of-sequence ChangeCipherSpec records */\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n    if( ssl->state == MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC &&\n        ssl->handshake->new_session_ticket != 0 )\n    {\n        ssl->state = MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET;\n    }\n#endif\n\n    switch( ssl->state )\n    {\n        case MBEDTLS_SSL_HELLO_REQUEST:\n            ssl->state = MBEDTLS_SSL_CLIENT_HELLO;\n            break;\n\n       /*\n        *  ==>   ClientHello\n        */\n       case MBEDTLS_SSL_CLIENT_HELLO:\n           ret = ssl_write_client_hello( ssl );\n           break;\n\n       /*\n        *  <==   ServerHello\n        *        Certificate\n        *      ( ServerKeyExchange  )\n        *      ( CertificateRequest )\n        *        ServerHelloDone\n        */\n       case MBEDTLS_SSL_SERVER_HELLO:\n           ret = ssl_parse_server_hello( ssl );\n           break;\n\n       case MBEDTLS_SSL_SERVER_CERTIFICATE:\n           ret = mbedtls_ssl_parse_certificate( ssl );\n           break;\n\n       case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:\n           ret = ssl_parse_server_key_exchange( ssl );\n           break;\n\n       case MBEDTLS_SSL_CERTIFICATE_REQUEST:\n           ret = ssl_parse_certificate_request( ssl );\n           break;\n\n       case MBEDTLS_SSL_SERVER_HELLO_DONE:\n           ret = ssl_parse_server_hello_done( ssl );\n           break;\n\n       /*\n        *  ==> ( Certificate/Alert  )\n        *        ClientKeyExchange\n        *      ( CertificateVerify  )\n        *        ChangeCipherSpec\n        *        Finished\n        */\n       case MBEDTLS_SSL_CLIENT_CERTIFICATE:\n           ret = mbedtls_ssl_write_certificate( ssl );\n           break;\n\n       case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:\n           ret = ssl_write_client_key_exchange( ssl );\n           break;\n\n       case MBEDTLS_SSL_CERTIFICATE_VERIFY:\n           ret = ssl_write_certificate_verify( ssl );\n           break;\n\n       case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:\n           ret = mbedtls_ssl_write_change_cipher_spec( ssl );\n           break;\n\n       case MBEDTLS_SSL_CLIENT_FINISHED:\n           ret = mbedtls_ssl_write_finished( ssl );\n           break;\n\n       /*\n        *  <==   ( NewSessionTicket )\n        *        ChangeCipherSpec\n        *        Finished\n        */\n#if defined(MBEDTLS_SSL_SESSION_TICKETS)\n       case MBEDTLS_SSL_SERVER_NEW_SESSION_TICKET:\n           ret = ssl_parse_new_session_ticket( ssl );\n           break;\n#endif\n\n       case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:\n           ret = mbedtls_ssl_parse_change_cipher_spec( ssl );\n           break;\n\n       case MBEDTLS_SSL_SERVER_FINISHED:\n           ret = mbedtls_ssl_parse_finished( ssl );\n           break;\n\n       case MBEDTLS_SSL_FLUSH_BUFFERS:\n           MBEDTLS_SSL_DEBUG_MSG( 2, ( \"handshake: done\" ) );\n           ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;\n           break;\n\n       case MBEDTLS_SSL_HANDSHAKE_WRAPUP:\n           mbedtls_ssl_handshake_wrapup( ssl );\n           break;\n\n       default:\n           MBEDTLS_SSL_DEBUG_MSG( 1, ( \"invalid state %d\", ssl->state ) );\n           return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n   }\n\n    return( ret );\n}\n#endif /* MBEDTLS_SSL_CLI_C */\n"], "filenames": ["library/ssl_cli.c"], "buggy_code_start_loc": [2492], "buggy_code_end_loc": [2493], "fixing_code_start_loc": [2492], "fixing_code_end_loc": [2493], "type": "CWE-125", "message": "ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_key_exchange() that could cause a crash on invalid input.", "other": {"cve": {"id": "CVE-2018-9988", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-10T19:29:00.260", "lastModified": "2021-11-30T21:43:16.500", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ARM mbed TLS before 2.1.11, before 2.7.2, and before 2.8.0 has a buffer over-read in ssl_parse_server_key_exchange() that could cause a crash on invalid input."}, {"lang": "es", "value": "ARM mbed TLS, en versiones anteriores a la 2.1.11, anteriores a la 2.7.2 y anteriores a la 2.8.0, tiene una sobrelectura de b\u00fafer en ssl_parse_server_key_exchange() que podr\u00eda provocar un cierre inesperado o una entrada no v\u00e1lida."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.11", "matchCriteriaId": "5161AD5D-26C1-4F4A-9917-9811AE0186BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.7.2", "matchCriteriaId": "5BE974ED-6285-49A0-8518-D5094100344B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:arm:mbed_tls:2.8.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "01B42981-982E-4A9C-8733-8194E01C957E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/ARMmbed/mbedtls/commit/027f84c69f4ef30c0693832a6c396ef19e563ca1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ARMmbed/mbedtls/commit/a1098f81c252b317ad34ea978aea2bc47760b215", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/09/msg00029.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/11/msg00021.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://tls.mbed.org/tech-updates/releases/mbedtls-2.8.0-2.7.2-and-2.1.11-released", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ARMmbed/mbedtls/commit/027f84c69f4ef30c0693832a6c396ef19e563ca1"}}