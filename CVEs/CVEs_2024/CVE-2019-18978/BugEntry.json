{"buggy_code": ["# Change Log\nAll notable changes to this project will be documented in this file.\n\n## 1.0.3 - 2019-03-24\n### Changed\n- Don't send 'Content-Type' header with pre-flight requests\n- Allow ruby array for  vary header config\n\n## 1.0.2 - 2017-10-22\n### Fixed\n- Automatically allow simple headers when headers are set\n\n## 1.0.1 - 2017-07-18\n### Fixed\n- Allow lambda origin configuration\n\n## 1.0.0 - 2017-07-15\n### Security\n- Don't implicitly accept 'null' origins when 'file://' is specified\n(https://github.com/cyu/rack-cors/pull/134)\n- Ignore '' origins (https://github.com/cyu/rack-cors/issues/139)\n- Default credentials option on resources to false\n(https://github.com/cyu/rack-cors/issues/95)\n- Don't allow credentials option to be true if '*' is specified is origin\n(https://github.com/cyu/rack-cors/pull/142)\n- Don't reflect Origin header when '*' is specified as origin\n(https://github.com/cyu/rack-cors/pull/142)\n\n### Fixed\n- Don't respond immediately on non-matching preflight requests instead of\nsending them through the app (https://github.com/cyu/rack-cors/pull/106)\n\n## 0.4.1 - 2017-02-01\n### Fixed\n- Return miss result in X-Rack-CORS instead of incorrectly returning\npreflight-hit\n\n## 0.4.0 - 2015-04-15\n### Changed\n- Don't set HTTP_ORIGIN with HTTP_X_ORIGIN if nil\n\n### Added\n- Calculate vary headers for non-CORS resources\n- Support custom vary headers for resource\n- Support :if option for resource\n- Support :any as a possible value for :methods option\n\n### Fixed\n- Don't symbolize incoming HTTP request methods\n\n## 0.3.1 - 2014-12-27\n### Changed\n- Changed the env key to rack.cors to avoid Rack::Lint warnings\n\n## 0.3.0 - 2014-10-19\n### Added\n- Added support for defining a logger with a Proc\n- Return a X-Rack-CORS header when in debug mode detailing how Rack::Cors\nprocessed a request\n- Added support for non HTTP/HTTPS origins when just a domain is specified\n\n### Changed\n- Changed the log level of the fallback logger to DEBUG\n- Print warning when attempting to use :any as an allowed method\n- Treat incoming `Origin: null` headers as file://\n", "require 'logger'\n\nmodule Rack\n  class Cors\n    HTTP_ORIGIN   = 'HTTP_ORIGIN'.freeze\n    HTTP_X_ORIGIN = 'HTTP_X_ORIGIN'.freeze\n\n    HTTP_ACCESS_CONTROL_REQUEST_METHOD  = 'HTTP_ACCESS_CONTROL_REQUEST_METHOD'.freeze\n    HTTP_ACCESS_CONTROL_REQUEST_HEADERS = 'HTTP_ACCESS_CONTROL_REQUEST_HEADERS'.freeze\n\n    PATH_INFO      = 'PATH_INFO'.freeze\n    REQUEST_METHOD = 'REQUEST_METHOD'.freeze\n\n    RACK_LOGGER = 'rack.logger'.freeze\n    RACK_CORS   =\n    # retaining the old key for backwards compatibility\n    ENV_KEY     = 'rack.cors'.freeze\n\n    OPTIONS     = 'OPTIONS'.freeze\n    VARY        = 'Vary'.freeze\n\n    DEFAULT_VARY_HEADERS = ['Origin'].freeze\n\n    # All CORS routes need to accept CORS simple headers at all times\n    # {https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers}\n    CORS_SIMPLE_HEADERS = ['accept', 'accept-language', 'content-language', 'content-type'].freeze\n\n    def initialize(app, opts={}, &block)\n      @app = app\n      @debug_mode = !!opts[:debug]\n      @logger = @logger_proc = nil\n\n      if logger = opts[:logger]\n        if logger.respond_to? :call\n          @logger_proc = opts[:logger]\n        else\n          @logger = logger\n        end\n      end\n\n      if block_given?\n        if block.arity == 1\n          block.call(self)\n        else\n          instance_eval(&block)\n        end\n      end\n    end\n\n    def debug?\n      @debug_mode\n    end\n\n    def allow(&block)\n      all_resources << (resources = Resources.new)\n\n      if block.arity == 1\n        block.call(resources)\n      else\n        resources.instance_eval(&block)\n      end\n    end\n\n    def call(env)\n      env[HTTP_ORIGIN] ||= env[HTTP_X_ORIGIN] if env[HTTP_X_ORIGIN]\n\n      add_headers = nil\n      if env[HTTP_ORIGIN]\n        debug(env) do\n          [ 'Incoming Headers:',\n            \"  Origin: #{env[HTTP_ORIGIN]}\",\n            \"  Access-Control-Request-Method: #{env[HTTP_ACCESS_CONTROL_REQUEST_METHOD]}\",\n            \"  Access-Control-Request-Headers: #{env[HTTP_ACCESS_CONTROL_REQUEST_HEADERS]}\"\n            ].join(\"\\n\")\n        end\n        if env[REQUEST_METHOD] == OPTIONS and env[HTTP_ACCESS_CONTROL_REQUEST_METHOD]\n          headers = process_preflight(env)\n          debug(env) do\n            \"Preflight Headers:\\n\" +\n                headers.collect{|kv| \"  #{kv.join(': ')}\"}.join(\"\\n\")\n          end\n          return [200, headers, []]\n        else\n          add_headers = process_cors(env)\n        end\n      else\n        Result.miss(env, Result::MISS_NO_ORIGIN)\n      end\n\n      # This call must be done BEFORE calling the app because for some reason\n      # env[PATH_INFO] gets changed after that and it won't match. (At least\n      # in rails 4.1.6)\n      vary_resource = resource_for_path(env[PATH_INFO])\n\n      status, headers, body = @app.call env\n\n      if add_headers\n        headers = add_headers.merge(headers)\n        debug(env) do\n          add_headers.each_pair do |key, value|\n            if headers.has_key?(key)\n              headers[\"X-Rack-CORS-Original-#{key}\"] = value\n            end\n          end\n        end\n      end\n\n      # Vary header should ALWAYS mention Origin if there's ANY chance for the\n      # response to be different depending on the Origin header value.\n      # Better explained here: http://www.fastly.com/blog/best-practices-for-using-the-vary-header/\n      if vary_resource\n        vary = headers[VARY]\n        cors_vary_headers = if vary_resource.vary_headers && vary_resource.vary_headers.any?\n          vary_resource.vary_headers\n        else\n          DEFAULT_VARY_HEADERS\n        end\n        headers[VARY] = ((vary ? ([vary].flatten.map { |v| v.split(/,\\s*/) }.flatten) : []) + cors_vary_headers).uniq.join(', ')\n      end\n\n      if debug? && result = env[RACK_CORS]\n        result.append_header(headers)\n      end\n\n      [status, headers, body]\n    end\n\n    protected\n      def debug(env, message = nil, &block)\n        (@logger || select_logger(env)).debug(message, &block) if debug?\n      end\n\n      def select_logger(env)\n        @logger = if @logger_proc\n          logger_proc = @logger_proc\n          @logger_proc = nil\n          logger_proc.call\n\n        elsif defined?(Rails) && Rails.respond_to?(:logger) && Rails.logger\n          Rails.logger\n\n        elsif env[RACK_LOGGER]\n          env[RACK_LOGGER]\n\n        else\n          ::Logger.new(STDOUT).tap { |logger| logger.level = ::Logger::Severity::DEBUG }\n        end\n      end\n\n      def all_resources\n        @all_resources ||= []\n      end\n\n      def process_preflight(env)\n        result = Result.preflight(env)\n\n        resource, error = match_resource(env)\n        unless resource\n          result.miss(error)\n          return {}\n        end\n\n        return resource.process_preflight(env, result)\n      end\n\n      def process_cors(env)\n        resource, error = match_resource(env)\n        if resource\n          Result.hit(env)\n          cors = resource.to_headers(env)\n          cors\n\n        else\n          Result.miss(env, error)\n          nil\n        end\n      end\n\n      def resource_for_path(path_info)\n        all_resources.each do |r|\n          if found = r.resource_for_path(path_info)\n            return found\n          end\n        end\n        nil\n      end\n\n      def match_resource(env)\n        path   = env[PATH_INFO]\n        origin = env[HTTP_ORIGIN]\n\n        origin_matched = false\n        all_resources.each do |r|\n          if r.allow_origin?(origin, env)\n            origin_matched = true\n            if found = r.match_resource(path, env)\n              return [found, nil]\n            end\n          end\n        end\n\n        [nil, origin_matched ? Result::MISS_NO_PATH : Result::MISS_NO_ORIGIN]\n      end\n\n      class Result\n        HEADER_KEY = 'X-Rack-CORS'.freeze\n\n        MISS_NO_ORIGIN = 'no-origin'.freeze\n        MISS_NO_PATH   = 'no-path'.freeze\n\n        MISS_NO_METHOD   = 'no-method'.freeze\n        MISS_DENY_METHOD = 'deny-method'.freeze\n        MISS_DENY_HEADER = 'deny-header'.freeze\n\n        attr_accessor :preflight, :hit, :miss_reason\n\n        def hit?\n          !!hit\n        end\n\n        def preflight?\n          !!preflight\n        end\n\n        def miss(reason)\n          self.hit = false\n          self.miss_reason = reason\n        end\n\n        def self.hit(env)\n          r = Result.new\n          r.preflight = false\n          r.hit = true\n          env[RACK_CORS] = r\n        end\n\n        def self.miss(env, reason)\n          r = Result.new\n          r.preflight = false\n          r.hit = false\n          r.miss_reason = reason\n          env[RACK_CORS] = r\n        end\n\n        def self.preflight(env)\n          r = Result.new\n          r.preflight = true\n          env[RACK_CORS] = r\n        end\n\n\n        def append_header(headers)\n          headers[HEADER_KEY] = if hit?\n            preflight? ? 'preflight-hit' : 'hit'\n          else\n            [\n              (preflight? ? 'preflight-miss' : 'miss'),\n              miss_reason\n            ].join('; ')\n          end\n        end\n      end\n\n      class Resources\n\n        attr_reader :resources\n\n        def initialize\n          @origins = []\n          @resources = []\n          @public_resources = false\n        end\n\n        def origins(*args, &blk)\n          @origins = args.flatten.reject{ |s| s == '' }.map do |n|\n            case n\n            when Proc,\n                 Regexp,\n                 /^https?:\\/\\//,\n                 'file://'        then n\n            when '*'              then @public_resources = true; n\n            else                  Regexp.compile(\"^[a-z][a-z0-9.+-]*:\\\\\\/\\\\\\/#{Regexp.quote(n)}$\")\n            end\n          end.flatten\n          @origins.push(blk) if blk\n        end\n\n        def resource(path, opts={})\n          @resources << Resource.new(public_resources?, path, opts)\n        end\n\n        def public_resources?\n          @public_resources\n        end\n\n        def allow_origin?(source,env = {})\n          return true if public_resources?\n\n          return !! @origins.detect do |origin|\n            if origin.is_a?(Proc)\n              origin.call(source,env)\n            else\n              origin === source\n            end\n          end\n        end\n\n        def match_resource(path, env)\n          @resources.detect { |r| r.match?(path, env) }\n        end\n\n        def resource_for_path(path)\n          @resources.detect { |r| r.matches_path?(path) }\n        end\n\n      end\n\n      class Resource\n        class CorsMisconfigurationError < StandardError\n          def message\n            \"Allowing credentials for wildcard origins is insecure.\"\\\n            \" Please specify more restrictive origins or set 'credentials' to false in your CORS configuration.\"\n          end\n        end\n\n        attr_accessor :path, :methods, :headers, :expose, :max_age, :credentials, :pattern, :if_proc, :vary_headers\n\n        def initialize(public_resource, path, opts={})\n          raise CorsMisconfigurationError if public_resource && opts[:credentials] == true\n\n          self.path         = path\n          self.credentials  = public_resource ? false : (opts[:credentials] == true)\n          self.max_age      = opts[:max_age] || 1728000\n          self.pattern      = compile(path)\n          self.if_proc      = opts[:if]\n          self.vary_headers = opts[:vary] && [opts[:vary]].flatten\n          @public_resource  = public_resource\n\n          self.headers = case opts[:headers]\n          when :any then :any\n          when nil then nil\n          else\n            [opts[:headers]].flatten.collect{|h| h.downcase}\n          end\n\n          self.methods = case opts[:methods]\n          when :any then [:get, :head, :post, :put, :patch, :delete, :options]\n          else\n            ensure_enum(opts[:methods]) || [:get]\n          end.map{|e| e.to_s }\n\n          self.expose = opts[:expose] ? [opts[:expose]].flatten : nil\n        end\n\n        def matches_path?(path)\n          pattern =~ path\n        end\n\n        def match?(path, env)\n          matches_path?(path) && (if_proc.nil? || if_proc.call(env))\n        end\n\n        def process_preflight(env, result)\n          headers = {}\n\n          request_method = env[HTTP_ACCESS_CONTROL_REQUEST_METHOD]\n          if request_method.nil?\n            result.miss(Result::MISS_NO_METHOD) and return headers\n          end\n          if !methods.include?(request_method.downcase)\n            result.miss(Result::MISS_DENY_METHOD) and return headers\n          end\n\n          request_headers = env[HTTP_ACCESS_CONTROL_REQUEST_HEADERS]\n          if request_headers && !allow_headers?(request_headers)\n            result.miss(Result::MISS_DENY_HEADER) and return headers\n          end\n\n          result.hit = true\n          headers.merge(to_preflight_headers(env))\n        end\n\n        def to_headers(env)\n          h = {\n            'Access-Control-Allow-Origin'     => origin_for_response_header(env[HTTP_ORIGIN]),\n            'Access-Control-Allow-Methods'    => methods.collect{|m| m.to_s.upcase}.join(', '),\n            'Access-Control-Expose-Headers'   => expose.nil? ? '' : expose.join(', '),\n            'Access-Control-Max-Age'          => max_age.to_s }\n          h['Access-Control-Allow-Credentials'] = 'true' if credentials\n          h\n        end\n\n        protected\n          def public_resource?\n            @public_resource\n          end\n\n          def origin_for_response_header(origin)\n            return '*' if public_resource?\n            origin\n          end\n\n          def to_preflight_headers(env)\n            h = to_headers(env)\n            if env[HTTP_ACCESS_CONTROL_REQUEST_HEADERS]\n              h.merge!('Access-Control-Allow-Headers' => env[HTTP_ACCESS_CONTROL_REQUEST_HEADERS])\n            end\n            h\n          end\n\n          def allow_headers?(request_headers)\n            headers = self.headers || []\n            if headers == :any\n              return true\n            end\n            request_headers = request_headers.split(/,\\s*/) if request_headers.kind_of?(String)\n            request_headers.all? do |header|\n              header = header.downcase\n              CORS_SIMPLE_HEADERS.include?(header) || headers.include?(header)\n            end\n          end\n\n          def ensure_enum(v)\n            return nil if v.nil?\n            [v].flatten\n          end\n\n          def compile(path)\n            if path.respond_to? :to_str\n              special_chars = %w{. + ( )}\n              pattern =\n                path.to_str.gsub(/((:\\w+)|[\\*#{special_chars.join}])/) do |match|\n                  case match\n                  when \"*\"\n                    \"(.*?)\"\n                  when *special_chars\n                    Regexp.escape(match)\n                  else\n                    \"([^/?&#]+)\"\n                  end\n                end\n              /^#{pattern}$/\n            elsif path.respond_to? :match\n              path\n            else\n              raise TypeError, path\n            end\n          end\n      end\n\n  end\nend\n", "module Rack\n  class Cors\n    VERSION = \"1.0.3\"\n  end\nend\n", "require 'minitest/autorun'\nrequire 'rack/test'\nrequire 'mocha/setup'\nrequire 'rack/cors'\nrequire 'ostruct'\n\nRack::Test::Session.class_eval do\n  unless defined? :options\n    def options(uri, params = {}, env = {}, &block)\n      env = env_for(uri, env.merge(:method => \"OPTIONS\", :params => params))\n      process_request(uri, env, &block)\n    end\n  end\nend\n\nRack::Test::Methods.class_eval do\n  def_delegator :current_session, :options\nend\n\nmodule MiniTest::Assertions\n  def assert_cors_success(response)\n    assert !response.headers['Access-Control-Allow-Origin'].nil?, \"Expected a successful CORS response\"\n  end\n\n  def assert_not_cors_success(response)\n    assert response.headers['Access-Control-Allow-Origin'].nil?, \"Expected a failed CORS response\"\n  end\nend\n\nclass CaptureResult\n  def initialize(app, options =  {})\n    @app = app\n    @result_holder = options[:holder]\n  end\n\n  def call(env)\n    response = @app.call(env)\n    @result_holder.cors_result = env[Rack::Cors::RACK_CORS]\n    return response\n  end\nend\n\nclass FakeProxy\n  def initialize(app, options =  {})\n    @app = app\n  end\n\n  def call(env)\n    status, headers, body = @app.call(env)\n    headers['Vary'] = %w(Origin User-Agent)\n    [status, headers, body]\n  end\nend\n\nRack::MockResponse.infect_an_assertion :assert_cors_success, :must_render_cors_success, :only_one_argument\nRack::MockResponse.infect_an_assertion :assert_not_cors_success, :wont_render_cors_success, :only_one_argument\n\ndescribe Rack::Cors do\n  include Rack::Test::Methods\n\n  attr_accessor :cors_result\n\n  def load_app(name, options = {})\n    test = self\n    Rack::Builder.new do\n      use CaptureResult, :holder => test\n      eval File.read(File.dirname(__FILE__) + \"/#{name}.ru\")\n      use FakeProxy if options[:proxy]\n      map('/') do\n        run proc { |env|\n          [200, {'Content-Type' => 'text/html'}, ['success']]\n        }\n      end\n    end\n  end\n\n  let(:app) { load_app('test') }\n\n  it 'should support simple CORS request' do\n    successful_cors_request\n    cors_result.must_be :hit\n  end\n\n  it \"should not return CORS headers if Origin header isn't present\" do\n    get '/'\n    last_response.wont_render_cors_success\n    cors_result.wont_be :hit\n  end\n\n  it 'should support OPTIONS CORS request' do\n    successful_cors_request '/options', :method => :options\n  end\n\n  it 'should support regex origins configuration' do\n    successful_cors_request :origin => 'http://192.168.0.1:1234'\n  end\n\n  it 'should support subdomain example' do\n    successful_cors_request :origin => 'http://subdomain.example.com'\n  end\n\n  it 'should support proc origins configuration' do\n    successful_cors_request '/proc-origin', :origin => 'http://10.10.10.10:3000'\n  end\n\n  it 'should support lambda origin configuration' do\n    successful_cors_request '/lambda-origin', :origin => 'http://10.10.10.10:3000'\n  end\n\n  it 'should support proc origins configuration (inverse)' do\n    cors_request '/proc-origin', :origin => 'http://bad.guy'\n    last_response.wont_render_cors_success\n  end\n\n  it 'should not mix up path rules across origins' do\n    header 'Origin', 'http://10.10.10.10:3000'\n    get '/' # / is configured in a separate rule block\n    last_response.wont_render_cors_success\n  end\n\n  it 'should support alternative X-Origin header' do\n    header 'X-Origin', 'http://localhost:3000'\n    get '/'\n    last_response.must_render_cors_success\n  end\n\n  it 'should support expose header configuration' do\n    successful_cors_request '/expose_single_header'\n    last_response.headers['Access-Control-Expose-Headers'].must_equal 'expose-test'\n  end\n\n  it 'should support expose multiple header configuration' do\n    successful_cors_request '/expose_multiple_headers'\n    last_response.headers['Access-Control-Expose-Headers'].must_equal 'expose-test-1, expose-test-2'\n  end\n\n  # Explanation: http://www.fastly.com/blog/best-practices-for-using-the-vary-header/\n  it \"should add Vary header if resource matches even if Origin header isn't present\" do\n    get '/'\n    last_response.wont_render_cors_success\n    last_response.headers['Vary'].must_equal 'Origin'\n  end\n\n  it \"should add Vary header based on :vary option\" do\n    successful_cors_request '/vary_test'\n    last_response.headers['Vary'].must_equal 'Origin, Host'\n  end\n\n  describe 'with array of upstream Vary headers' do\n    let(:app) { load_app('test', { proxy: true }) }\n\n    it 'should add to them' do\n      successful_cors_request '/vary_test'\n      last_response.headers['Vary'].must_equal 'Origin, User-Agent, Host'\n    end\n  end\n\n  it 'should add Vary header if Access-Control-Allow-Origin header was added and if it is specific' do\n    successful_cors_request '/', :origin => \"http://192.168.0.3:8080\"\n    last_response.headers['Access-Control-Allow-Origin'].must_equal 'http://192.168.0.3:8080'\n    last_response.headers['Vary'].wont_be_nil\n  end\n\n  it 'should add Vary header even if Access-Control-Allow-Origin header was added and it is generic (*)' do\n    successful_cors_request '/public_without_credentials', :origin => \"http://192.168.1.3:8080\"\n    last_response.headers['Access-Control-Allow-Origin'].must_equal '*'\n    last_response.headers['Vary'].must_equal 'Origin'\n  end\n\n  it 'should support multi allow configurations for the same resource' do\n    successful_cors_request '/multi-allow-config', :origin => \"http://mucho-grande.com\"\n    last_response.headers['Access-Control-Allow-Origin'].must_equal 'http://mucho-grande.com'\n    last_response.headers['Vary'].must_equal 'Origin'\n\n    successful_cors_request '/multi-allow-config', :origin => \"http://192.168.1.3:8080\"\n    last_response.headers['Access-Control-Allow-Origin'].must_equal '*'\n    last_response.headers['Vary'].must_equal 'Origin'\n  end\n\n  it \"should not return CORS headers on OPTIONS request if Access-Control-Allow-Origin is not present\" do\n    options '/get-only'\n    last_response.headers['Access-Control-Allow-Origin'].must_be_nil\n  end\n\n  it \"should not apply CORS headers if it does not match conditional on resource\" do\n    header 'Origin', 'http://192.168.0.1:1234'\n    get '/conditional'\n    last_response.wont_render_cors_success\n  end\n\n  it \"should apply CORS headers if it does match conditional on resource\" do\n    header 'X-OK', '1'\n    successful_cors_request '/conditional', :origin => 'http://192.168.0.1:1234'\n  end\n\n  it \"should not allow everything if Origin is configured as blank string\" do\n    cors_request '/blank-origin', origin: \"http://example.net\"\n    last_response.wont_render_cors_success\n  end\n\n  it \"should not allow credentials for public resources\" do\n    successful_cors_request '/public'\n    last_response.headers['Access-Control-Allow-Credentials'].must_be_nil\n  end\n\n  describe 'logging' do\n    it 'should not log debug messages if debug option is false' do\n      app = mock\n      app.stubs(:call).returns(200, {}, [''])\n\n      logger = mock\n      logger.expects(:debug).never\n\n      cors = Rack::Cors.new(app, :debug => false, :logger => logger) {}\n      cors.send(:debug, {}, 'testing')\n    end\n\n    it 'should log debug messages if debug option is true' do\n      app = mock\n      app.stubs(:call).returns(200, {}, [''])\n\n      logger = mock\n      logger.expects(:debug)\n\n      cors = Rack::Cors.new(app, :debug => true, :logger => logger) {}\n      cors.send(:debug, {}, 'testing')\n    end\n\n    it 'should use rack.logger if available' do\n      app = mock\n      app.stubs(:call).returns([200, {}, ['']])\n\n      logger = mock\n      logger.expects(:debug).at_least_once\n\n      cors = Rack::Cors.new(app, :debug => true) {}\n      cors.call({'rack.logger' => logger, 'HTTP_ORIGIN' => 'test.com'})\n    end\n\n    it 'should use logger proc' do\n      app = mock\n      app.stubs(:call).returns([200, {}, ['']])\n\n      logger = mock\n      logger.expects(:debug)\n\n      cors = Rack::Cors.new(app, :debug => true, :logger => proc { logger }) {}\n      cors.call({'HTTP_ORIGIN' => 'test.com'})\n    end\n\n    describe 'with Rails setup' do\n      after do\n        ::Rails.logger = nil if defined?(::Rails)\n      end\n\n      it 'should use Rails.logger if available' do\n        app = mock\n        app.stubs(:call).returns([200, {}, ['']])\n\n        logger = mock\n        logger.expects(:debug)\n\n        ::Rails = OpenStruct.new(:logger => logger)\n\n        cors = Rack::Cors.new(app, :debug => true) {}\n        cors.call({'HTTP_ORIGIN' => 'test.com'})\n      end\n    end\n\n    it 'should use Logger if none is set' do\n      app = mock\n      app.stubs(:call).returns([200, {}, ['']])\n\n      logger = mock\n      Logger.expects(:new).returns(logger)\n      logger.expects(:tap).returns(logger)\n      logger.expects(:debug)\n\n      cors = Rack::Cors.new(app, :debug => true) {}\n      cors.call({'HTTP_ORIGIN' => 'test.com'})\n    end\n  end\n\n  describe 'preflight requests' do\n    it 'should fail if origin is invalid' do\n      preflight_request('http://allyourdataarebelongtous.com', '/')\n      last_response.wont_render_cors_success\n      cors_result.wont_be :hit\n      cors_result.must_be :preflight\n    end\n\n    it 'should fail if Access-Control-Request-Method is not allowed' do\n      preflight_request('http://localhost:3000', '/get-only', :method => :post)\n      last_response.wont_render_cors_success\n      cors_result.miss_reason.must_equal Rack::Cors::Result::MISS_DENY_METHOD\n      cors_result.wont_be :hit\n      cors_result.must_be :preflight\n    end\n\n    it 'should fail if header is not allowed' do\n      preflight_request('http://localhost:3000', '/single_header', :headers => 'Fooey')\n      last_response.wont_render_cors_success\n      cors_result.miss_reason.must_equal Rack::Cors::Result::MISS_DENY_HEADER\n      cors_result.wont_be :hit\n      cors_result.must_be :preflight\n    end\n\n    it 'should allow any header if headers = :any' do\n      preflight_request('http://localhost:3000', '/', :headers => 'Fooey')\n      last_response.must_render_cors_success\n    end\n\n    it 'should allow any method if methods = :any' do\n      preflight_request('http://localhost:3000', '/', :methods => :any)\n      last_response.must_render_cors_success\n    end\n\n    it 'allows PATCH method' do\n      preflight_request('http://localhost:3000', '/', :methods => [ :patch ])\n      last_response.must_render_cors_success\n    end\n\n    it 'should allow header case insensitive match' do\n      preflight_request('http://localhost:3000', '/single_header', :headers => 'X-Domain-Token')\n      last_response.must_render_cors_success\n    end\n\n    it 'should allow multiple headers match' do\n      # Webkit style\n      preflight_request('http://localhost:3000', '/two_headers', :headers => 'X-Requested-With, X-Domain-Token')\n      last_response.must_render_cors_success\n\n      # Gecko style\n      preflight_request('http://localhost:3000', '/two_headers', :headers => 'x-requested-with,x-domain-token')\n      last_response.must_render_cors_success\n    end\n\n    it 'should * origin should allow any origin' do\n      preflight_request('http://locohost:3000', '/public')\n      last_response.must_render_cors_success\n      last_response.headers['Access-Control-Allow-Origin'].must_equal '*'\n    end\n\n    it 'should * origin should allow any origin, and set * if no credentials required' do\n      preflight_request('http://locohost:3000', '/public_without_credentials')\n      last_response.must_render_cors_success\n      last_response.headers['Access-Control-Allow-Origin'].must_equal '*'\n    end\n\n    it 'should return \"file://\" as header with \"file://\" as origin' do\n      preflight_request('file://', '/')\n      last_response.must_render_cors_success\n      last_response.headers['Access-Control-Allow-Origin'].must_equal 'file://'\n    end\n\n    describe '' do\n\n      let(:app) do\n        test = self\n        Rack::Builder.new do\n          use CaptureResult, holder: test\n          use Rack::Cors, debug: true, logger: Logger.new(StringIO.new) do\n            allow do\n              origins '*'\n              resource '/', :methods => :post\n            end\n          end\n          map('/') do\n            run ->(env) { [500, {}, ['FAIL!']] }\n          end\n        end\n      end\n\n      it \"should not send failed preflight requests thru the app\" do\n        preflight_request('http://localhost', '/', :method => :unsupported)\n        last_response.wont_render_cors_success\n        last_response.status.must_equal 200\n        cors_result.must_be :preflight\n        cors_result.wont_be :hit\n        cors_result.miss_reason.must_equal Rack::Cors::Result::MISS_DENY_METHOD\n      end\n    end\n  end\n\n  describe \"with insecure configuration\" do\n    let(:app) { load_app('insecure') }\n\n    it \"should raise an error\" do\n      proc { cors_request '/public' }.must_raise Rack::Cors::Resource::CorsMisconfigurationError\n    end\n  end\n\n  describe \"with non HTTP config\" do\n    let(:app) { load_app(\"non_http\") }\n\n    it 'should support non http/https origins' do\n      successful_cors_request '/public', origin: 'content://com.company.app'\n    end\n  end\n\n  describe 'Rack::Lint' do\n    def app\n      @app ||= Rack::Builder.new do\n        use Rack::Cors\n        use Rack::Lint\n        run ->(env) { [200, {'Content-Type' => 'text/html'}, ['hello']] }\n      end\n    end\n\n    it 'is lint-compliant with non-CORS request' do\n      get '/'\n      last_response.status.must_equal 200\n    end\n  end\n\n  describe 'with app overriding CORS header' do\n    let(:app) do\n      Rack::Builder.new do\n        use Rack::Cors, debug: true, logger: Logger.new(StringIO.new) do\n          allow do\n            origins '*'\n            resource '/'\n          end\n        end\n        map('/') do\n          run ->(env) { [200, {'Access-Control-Allow-Origin' => 'http://foo.net'}, ['success']] }\n        end\n      end\n    end\n\n    it \"should return app header\" do\n      successful_cors_request origin: \"http://example.net\"\n      last_response.headers['Access-Control-Allow-Origin'].must_equal \"http://foo.net\"\n    end\n\n    it \"should return original headers if in debug\" do\n      successful_cors_request origin: \"http://example.net\"\n      last_response.headers['X-Rack-CORS-Original-Access-Control-Allow-Origin'].must_equal \"*\"\n    end\n  end\n\n  describe 'with headers set to nil' do\n    let(:app) do\n      Rack::Builder.new do\n        use Rack::Cors do\n          allow do\n            origins '*'\n            resource '/', headers: nil\n          end\n        end\n        map('/') do\n          run ->(env) { [200, {'Content-Type' => 'text/html'}, ['hello']] }\n        end\n      end\n    end\n\n    it 'should succeed with CORS simple headers' do\n      preflight_request('http://localhost:3000', '/', :headers => 'Accept')\n      last_response.must_render_cors_success\n    end\n  end\n\n  describe 'with custom allowed headers' do\n    let(:app) do\n      Rack::Builder.new do\n        use Rack::Cors do\n          allow do\n            origins '*'\n            resource '/', headers: []\n          end\n        end\n        map('/') do\n          run ->(env) { [200, {'Content-Type' => 'text/html'}, ['hello']] }\n        end\n      end\n    end\n\n    it 'should succeed with CORS simple headers' do\n      preflight_request('http://localhost:3000', '/', :headers => 'Accept')\n      last_response.must_render_cors_success\n      preflight_request('http://localhost:3000', '/', :headers => 'Accept-Language')\n      last_response.must_render_cors_success\n      preflight_request('http://localhost:3000', '/', :headers => 'Content-Type')\n      last_response.must_render_cors_success\n      preflight_request('http://localhost:3000', '/', :headers => 'Content-Language')\n      last_response.must_render_cors_success\n    end\n  end\n\n  protected\n    def cors_request(*args)\n      path = args.first.is_a?(String) ? args.first : '/'\n\n      opts = { :method => :get, :origin => 'http://localhost:3000' }\n      opts.merge! args.last if args.last.is_a?(Hash)\n\n      header 'Origin', opts[:origin]\n      current_session.__send__ opts[:method], path, {}, test: self\n    end\n\n    def successful_cors_request(*args)\n      cors_request(*args)\n      last_response.must_render_cors_success\n    end\n\n    def preflight_request(origin, path, opts = {})\n      header 'Origin', origin\n      unless opts.key?(:method) && opts[:method].nil?\n        header 'Access-Control-Request-Method', opts[:method] ? opts[:method].to_s.upcase : 'GET'\n      end\n      if opts[:headers]\n        header 'Access-Control-Request-Headers', opts[:headers]\n      end\n      options path\n    end\nend\n", "require 'rack/cors'\n\n#use Rack::Cors, :debug => true, :logger => ::Logger.new(STDOUT) do\nuse Rack::Lint\nuse Rack::Cors do\n  allow do\n    origins 'localhost:3000',\n            '127.0.0.1:3000',\n            /http:\\/\\/192\\.168\\.0\\.\\d{1,3}(:\\d+)?/,\n            'file://',\n            /http:\\/\\/(.*?)\\.example\\.com/\n\n    resource '/get-only', :methods => :get\n    resource '/', :headers => :any, :methods => :any\n    resource '/options', :methods => :options\n    resource '/single_header', :headers => 'x-domain-token'\n    resource '/two_headers', :headers => %w{x-domain-token x-requested-with}\n    resource '/expose_single_header', :expose => 'expose-test'\n    resource '/expose_multiple_headers', :expose => %w{expose-test-1 expose-test-2}\n    resource '/conditional', :methods => :get, :if => proc { |env| !!env['HTTP_X_OK'] }\n    resource '/vary_test', :methods => :get, :vary => %w{ Origin Host }\n    resource '/patch_test', :methods => :patch\n    # resource '/file/at/*',\n    #     :methods => [:get, :post, :put, :delete],\n    #     :headers => :any,\n    #     :max_age => 0\n  end\n\n  allow do\n    origins do |source,env|\n      source.end_with?(\"10.10.10.10:3000\")\n    end\n    resource '/proc-origin'\n  end\n\n  allow do\n    origins -> (source, env) { source.end_with?(\"10.10.10.10:3000\") }\n    resource '/lambda-origin'\n  end\n\n  allow do\n    origins '*'\n    resource '/public'\n    resource '/public_without_credentials', :credentials => false\n  end\n\n  allow do\n    origins 'mucho-grande.com'\n    resource '/multi-allow-config', :max_age => 600\n  end\n\n  allow do\n    origins '*'\n    resource '/multi-allow-config', :max_age => 300, :credentials => false\n  end\n\n  allow do\n    origins ''\n    resource '/blank-origin'\n  end\nend\n"], "fixing_code": ["# Change Log\nAll notable changes to this project will be documented in this file.\n\n## 1.0.4 - 2019-11-13\n### Security\n- Escape and resolve path before evaluating resource rules (thanks to Colby Morgan)\n\n## 1.0.3 - 2019-03-24\n### Changed\n- Don't send 'Content-Type' header with pre-flight requests\n- Allow ruby array for  vary header config\n\n## 1.0.2 - 2017-10-22\n### Fixed\n- Automatically allow simple headers when headers are set\n\n## 1.0.1 - 2017-07-18\n### Fixed\n- Allow lambda origin configuration\n\n## 1.0.0 - 2017-07-15\n### Security\n- Don't implicitly accept 'null' origins when 'file://' is specified\n(https://github.com/cyu/rack-cors/pull/134)\n- Ignore '' origins (https://github.com/cyu/rack-cors/issues/139)\n- Default credentials option on resources to false\n(https://github.com/cyu/rack-cors/issues/95)\n- Don't allow credentials option to be true if '*' is specified is origin\n(https://github.com/cyu/rack-cors/pull/142)\n- Don't reflect Origin header when '*' is specified as origin\n(https://github.com/cyu/rack-cors/pull/142)\n\n### Fixed\n- Don't respond immediately on non-matching preflight requests instead of\nsending them through the app (https://github.com/cyu/rack-cors/pull/106)\n\n## 0.4.1 - 2017-02-01\n### Fixed\n- Return miss result in X-Rack-CORS instead of incorrectly returning\npreflight-hit\n\n## 0.4.0 - 2015-04-15\n### Changed\n- Don't set HTTP_ORIGIN with HTTP_X_ORIGIN if nil\n\n### Added\n- Calculate vary headers for non-CORS resources\n- Support custom vary headers for resource\n- Support :if option for resource\n- Support :any as a possible value for :methods option\n\n### Fixed\n- Don't symbolize incoming HTTP request methods\n\n## 0.3.1 - 2014-12-27\n### Changed\n- Changed the env key to rack.cors to avoid Rack::Lint warnings\n\n## 0.3.0 - 2014-10-19\n### Added\n- Added support for defining a logger with a Proc\n- Return a X-Rack-CORS header when in debug mode detailing how Rack::Cors\nprocessed a request\n- Added support for non HTTP/HTTPS origins when just a domain is specified\n\n### Changed\n- Changed the log level of the fallback logger to DEBUG\n- Print warning when attempting to use :any as an allowed method\n- Treat incoming `Origin: null` headers as file://\n", "require 'logger'\n\nmodule Rack\n  class Cors\n    HTTP_ORIGIN   = 'HTTP_ORIGIN'.freeze\n    HTTP_X_ORIGIN = 'HTTP_X_ORIGIN'.freeze\n\n    HTTP_ACCESS_CONTROL_REQUEST_METHOD  = 'HTTP_ACCESS_CONTROL_REQUEST_METHOD'.freeze\n    HTTP_ACCESS_CONTROL_REQUEST_HEADERS = 'HTTP_ACCESS_CONTROL_REQUEST_HEADERS'.freeze\n\n    PATH_INFO      = 'PATH_INFO'.freeze\n    REQUEST_METHOD = 'REQUEST_METHOD'.freeze\n\n    RACK_LOGGER = 'rack.logger'.freeze\n    RACK_CORS   =\n    # retaining the old key for backwards compatibility\n    ENV_KEY     = 'rack.cors'.freeze\n\n    OPTIONS     = 'OPTIONS'.freeze\n    VARY        = 'Vary'.freeze\n\n    DEFAULT_VARY_HEADERS = ['Origin'].freeze\n\n    # All CORS routes need to accept CORS simple headers at all times\n    # {https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers}\n    CORS_SIMPLE_HEADERS = ['accept', 'accept-language', 'content-language', 'content-type'].freeze\n\n    def initialize(app, opts={}, &block)\n      @app = app\n      @debug_mode = !!opts[:debug]\n      @logger = @logger_proc = nil\n\n      if logger = opts[:logger]\n        if logger.respond_to? :call\n          @logger_proc = opts[:logger]\n        else\n          @logger = logger\n        end\n      end\n\n      if block_given?\n        if block.arity == 1\n          block.call(self)\n        else\n          instance_eval(&block)\n        end\n      end\n    end\n\n    def debug?\n      @debug_mode\n    end\n\n    def allow(&block)\n      all_resources << (resources = Resources.new)\n\n      if block.arity == 1\n        block.call(resources)\n      else\n        resources.instance_eval(&block)\n      end\n    end\n\n    def call(env)\n      env[HTTP_ORIGIN] ||= env[HTTP_X_ORIGIN] if env[HTTP_X_ORIGIN]\n\n      path = evaluate_path(env)\n\n      add_headers = nil\n      if env[HTTP_ORIGIN]\n        debug(env) do\n          [ 'Incoming Headers:',\n            \"  Origin: #{env[HTTP_ORIGIN]}\",\n            \"  Path-Info: #{path}\",\n            \"  Access-Control-Request-Method: #{env[HTTP_ACCESS_CONTROL_REQUEST_METHOD]}\",\n            \"  Access-Control-Request-Headers: #{env[HTTP_ACCESS_CONTROL_REQUEST_HEADERS]}\"\n            ].join(\"\\n\")\n        end\n        if env[REQUEST_METHOD] == OPTIONS and env[HTTP_ACCESS_CONTROL_REQUEST_METHOD]\n          headers = process_preflight(env, path)\n          debug(env) do\n            \"Preflight Headers:\\n\" +\n                headers.collect{|kv| \"  #{kv.join(': ')}\"}.join(\"\\n\")\n          end\n          return [200, headers, []]\n        else\n          add_headers = process_cors(env, path)\n        end\n      else\n        Result.miss(env, Result::MISS_NO_ORIGIN)\n      end\n\n      # This call must be done BEFORE calling the app because for some reason\n      # env[PATH_INFO] gets changed after that and it won't match. (At least\n      # in rails 4.1.6)\n      vary_resource = resource_for_path(path)\n\n      status, headers, body = @app.call env\n\n      if add_headers\n        headers = add_headers.merge(headers)\n        debug(env) do\n          add_headers.each_pair do |key, value|\n            if headers.has_key?(key)\n              headers[\"X-Rack-CORS-Original-#{key}\"] = value\n            end\n          end\n        end\n      end\n\n      # Vary header should ALWAYS mention Origin if there's ANY chance for the\n      # response to be different depending on the Origin header value.\n      # Better explained here: http://www.fastly.com/blog/best-practices-for-using-the-vary-header/\n      if vary_resource\n        vary = headers[VARY]\n        cors_vary_headers = if vary_resource.vary_headers && vary_resource.vary_headers.any?\n          vary_resource.vary_headers\n        else\n          DEFAULT_VARY_HEADERS\n        end\n        headers[VARY] = ((vary ? ([vary].flatten.map { |v| v.split(/,\\s*/) }.flatten) : []) + cors_vary_headers).uniq.join(', ')\n      end\n\n      if debug? && result = env[RACK_CORS]\n        result.append_header(headers)\n      end\n\n      [status, headers, body]\n    end\n\n    protected\n      def debug(env, message = nil, &block)\n        (@logger || select_logger(env)).debug(message, &block) if debug?\n      end\n\n      def select_logger(env)\n        @logger = if @logger_proc\n          logger_proc = @logger_proc\n          @logger_proc = nil\n          logger_proc.call\n\n        elsif defined?(Rails) && Rails.respond_to?(:logger) && Rails.logger\n          Rails.logger\n\n        elsif env[RACK_LOGGER]\n          env[RACK_LOGGER]\n\n        else\n          ::Logger.new(STDOUT).tap { |logger| logger.level = ::Logger::Severity::DEBUG }\n        end\n      end\n\n      def evaluate_path(env)\n        path = env[PATH_INFO]\n        path = Rack::Utils.clean_path_info(Rack::Utils.unescape_path(path)) if path\n        path\n      end\n\n      def all_resources\n        @all_resources ||= []\n      end\n\n      def process_preflight(env, path)\n        result = Result.preflight(env)\n\n        resource, error = match_resource(path, env)\n        unless resource\n          result.miss(error)\n          return {}\n        end\n\n        return resource.process_preflight(env, result)\n      end\n\n      def process_cors(env, path)\n        resource, error = match_resource(path, env)\n        if resource\n          Result.hit(env)\n          cors = resource.to_headers(env)\n          cors\n\n        else\n          Result.miss(env, error)\n          nil\n        end\n      end\n\n      def resource_for_path(path_info)\n        all_resources.each do |r|\n          if found = r.resource_for_path(path_info)\n            return found\n          end\n        end\n        nil\n      end\n\n      def match_resource(path, env)\n        origin = env[HTTP_ORIGIN]\n\n        origin_matched = false\n        all_resources.each do |r|\n          if r.allow_origin?(origin, env)\n            origin_matched = true\n            if found = r.match_resource(path, env)\n              return [found, nil]\n            end\n          end\n        end\n\n        [nil, origin_matched ? Result::MISS_NO_PATH : Result::MISS_NO_ORIGIN]\n      end\n\n      class Result\n        HEADER_KEY = 'X-Rack-CORS'.freeze\n\n        MISS_NO_ORIGIN = 'no-origin'.freeze\n        MISS_NO_PATH   = 'no-path'.freeze\n\n        MISS_NO_METHOD   = 'no-method'.freeze\n        MISS_DENY_METHOD = 'deny-method'.freeze\n        MISS_DENY_HEADER = 'deny-header'.freeze\n\n        attr_accessor :preflight, :hit, :miss_reason\n\n        def hit?\n          !!hit\n        end\n\n        def preflight?\n          !!preflight\n        end\n\n        def miss(reason)\n          self.hit = false\n          self.miss_reason = reason\n        end\n\n        def self.hit(env)\n          r = Result.new\n          r.preflight = false\n          r.hit = true\n          env[RACK_CORS] = r\n        end\n\n        def self.miss(env, reason)\n          r = Result.new\n          r.preflight = false\n          r.hit = false\n          r.miss_reason = reason\n          env[RACK_CORS] = r\n        end\n\n        def self.preflight(env)\n          r = Result.new\n          r.preflight = true\n          env[RACK_CORS] = r\n        end\n\n\n        def append_header(headers)\n          headers[HEADER_KEY] = if hit?\n            preflight? ? 'preflight-hit' : 'hit'\n          else\n            [\n              (preflight? ? 'preflight-miss' : 'miss'),\n              miss_reason\n            ].join('; ')\n          end\n        end\n      end\n\n      class Resources\n\n        attr_reader :resources\n\n        def initialize\n          @origins = []\n          @resources = []\n          @public_resources = false\n        end\n\n        def origins(*args, &blk)\n          @origins = args.flatten.reject{ |s| s == '' }.map do |n|\n            case n\n            when Proc,\n                 Regexp,\n                 /^https?:\\/\\//,\n                 'file://'        then n\n            when '*'              then @public_resources = true; n\n            else                  Regexp.compile(\"^[a-z][a-z0-9.+-]*:\\\\\\/\\\\\\/#{Regexp.quote(n)}$\")\n            end\n          end.flatten\n          @origins.push(blk) if blk\n        end\n\n        def resource(path, opts={})\n          @resources << Resource.new(public_resources?, path, opts)\n        end\n\n        def public_resources?\n          @public_resources\n        end\n\n        def allow_origin?(source,env = {})\n          return true if public_resources?\n\n          return !! @origins.detect do |origin|\n            if origin.is_a?(Proc)\n              origin.call(source,env)\n            else\n              origin === source\n            end\n          end\n        end\n\n        def match_resource(path, env)\n          @resources.detect { |r| r.match?(path, env) }\n        end\n\n        def resource_for_path(path)\n          @resources.detect { |r| r.matches_path?(path) }\n        end\n\n      end\n\n      class Resource\n        class CorsMisconfigurationError < StandardError\n          def message\n            \"Allowing credentials for wildcard origins is insecure.\"\\\n            \" Please specify more restrictive origins or set 'credentials' to false in your CORS configuration.\"\n          end\n        end\n\n        attr_accessor :path, :methods, :headers, :expose, :max_age, :credentials, :pattern, :if_proc, :vary_headers\n\n        def initialize(public_resource, path, opts={})\n          raise CorsMisconfigurationError if public_resource && opts[:credentials] == true\n\n          self.path         = path\n          self.credentials  = public_resource ? false : (opts[:credentials] == true)\n          self.max_age      = opts[:max_age] || 1728000\n          self.pattern      = compile(path)\n          self.if_proc      = opts[:if]\n          self.vary_headers = opts[:vary] && [opts[:vary]].flatten\n          @public_resource  = public_resource\n\n          self.headers = case opts[:headers]\n          when :any then :any\n          when nil then nil\n          else\n            [opts[:headers]].flatten.collect{|h| h.downcase}\n          end\n\n          self.methods = case opts[:methods]\n          when :any then [:get, :head, :post, :put, :patch, :delete, :options]\n          else\n            ensure_enum(opts[:methods]) || [:get]\n          end.map{|e| e.to_s }\n\n          self.expose = opts[:expose] ? [opts[:expose]].flatten : nil\n        end\n\n        def matches_path?(path)\n          pattern =~ path\n        end\n\n        def match?(path, env)\n          matches_path?(path) && (if_proc.nil? || if_proc.call(env))\n        end\n\n        def process_preflight(env, result)\n          headers = {}\n\n          request_method = env[HTTP_ACCESS_CONTROL_REQUEST_METHOD]\n          if request_method.nil?\n            result.miss(Result::MISS_NO_METHOD) and return headers\n          end\n          if !methods.include?(request_method.downcase)\n            result.miss(Result::MISS_DENY_METHOD) and return headers\n          end\n\n          request_headers = env[HTTP_ACCESS_CONTROL_REQUEST_HEADERS]\n          if request_headers && !allow_headers?(request_headers)\n            result.miss(Result::MISS_DENY_HEADER) and return headers\n          end\n\n          result.hit = true\n          headers.merge(to_preflight_headers(env))\n        end\n\n        def to_headers(env)\n          h = {\n            'Access-Control-Allow-Origin'     => origin_for_response_header(env[HTTP_ORIGIN]),\n            'Access-Control-Allow-Methods'    => methods.collect{|m| m.to_s.upcase}.join(', '),\n            'Access-Control-Expose-Headers'   => expose.nil? ? '' : expose.join(', '),\n            'Access-Control-Max-Age'          => max_age.to_s }\n          h['Access-Control-Allow-Credentials'] = 'true' if credentials\n          h\n        end\n\n        protected\n          def public_resource?\n            @public_resource\n          end\n\n          def origin_for_response_header(origin)\n            return '*' if public_resource?\n            origin\n          end\n\n          def to_preflight_headers(env)\n            h = to_headers(env)\n            if env[HTTP_ACCESS_CONTROL_REQUEST_HEADERS]\n              h.merge!('Access-Control-Allow-Headers' => env[HTTP_ACCESS_CONTROL_REQUEST_HEADERS])\n            end\n            h\n          end\n\n          def allow_headers?(request_headers)\n            headers = self.headers || []\n            if headers == :any\n              return true\n            end\n            request_headers = request_headers.split(/,\\s*/) if request_headers.kind_of?(String)\n            request_headers.all? do |header|\n              header = header.downcase\n              CORS_SIMPLE_HEADERS.include?(header) || headers.include?(header)\n            end\n          end\n\n          def ensure_enum(v)\n            return nil if v.nil?\n            [v].flatten\n          end\n\n          def compile(path)\n            if path.respond_to? :to_str\n              special_chars = %w{. + ( )}\n              pattern =\n                path.to_str.gsub(/((:\\w+)|[\\*#{special_chars.join}])/) do |match|\n                  case match\n                  when \"*\"\n                    \"(.*?)\"\n                  when *special_chars\n                    Regexp.escape(match)\n                  else\n                    \"([^/?&#]+)\"\n                  end\n                end\n              /^#{pattern}$/\n            elsif path.respond_to? :match\n              path\n            else\n              raise TypeError, path\n            end\n          end\n      end\n\n  end\nend\n", "module Rack\n  class Cors\n    VERSION = \"1.0.4\"\n  end\nend\n", "require 'minitest/autorun'\nrequire 'rack/test'\nrequire 'mocha/setup'\nrequire 'rack/cors'\nrequire 'ostruct'\n\nRack::Test::Session.class_eval do\n  unless defined? :options\n    def options(uri, params = {}, env = {}, &block)\n      env = env_for(uri, env.merge(:method => \"OPTIONS\", :params => params))\n      process_request(uri, env, &block)\n    end\n  end\nend\n\nRack::Test::Methods.class_eval do\n  def_delegator :current_session, :options\nend\n\nmodule MiniTest::Assertions\n  def assert_cors_success(response)\n    assert !response.headers['Access-Control-Allow-Origin'].nil?, \"Expected a successful CORS response\"\n  end\n\n  def assert_not_cors_success(response)\n    assert response.headers['Access-Control-Allow-Origin'].nil?, \"Expected a failed CORS response\"\n  end\nend\n\nclass CaptureResult\n  def initialize(app, options =  {})\n    @app = app\n    @result_holder = options[:holder]\n  end\n\n  def call(env)\n    response = @app.call(env)\n    @result_holder.cors_result = env[Rack::Cors::RACK_CORS]\n    return response\n  end\nend\n\nclass FakeProxy\n  def initialize(app, options =  {})\n    @app = app\n  end\n\n  def call(env)\n    status, headers, body = @app.call(env)\n    headers['Vary'] = %w(Origin User-Agent)\n    [status, headers, body]\n  end\nend\n\nRack::MockResponse.infect_an_assertion :assert_cors_success, :must_render_cors_success, :only_one_argument\nRack::MockResponse.infect_an_assertion :assert_not_cors_success, :wont_render_cors_success, :only_one_argument\n\ndescribe Rack::Cors do\n  include Rack::Test::Methods\n\n  attr_accessor :cors_result\n\n  def load_app(name, options = {})\n    test = self\n    Rack::Builder.new do\n      use CaptureResult, :holder => test\n      eval File.read(File.dirname(__FILE__) + \"/#{name}.ru\")\n      use FakeProxy if options[:proxy]\n      map('/') do\n        run proc { |env|\n          [200, {'Content-Type' => 'text/html'}, ['success']]\n        }\n      end\n    end\n  end\n\n  let(:app) { load_app('test') }\n\n  it 'should support simple CORS request' do\n    successful_cors_request\n    cors_result.must_be :hit\n  end\n\n  it \"should not return CORS headers if Origin header isn't present\" do\n    get '/'\n    last_response.wont_render_cors_success\n    cors_result.wont_be :hit\n  end\n\n  it 'should support OPTIONS CORS request' do\n    successful_cors_request '/options', :method => :options\n  end\n\n  it 'should support regex origins configuration' do\n    successful_cors_request :origin => 'http://192.168.0.1:1234'\n  end\n\n  it 'should support subdomain example' do\n    successful_cors_request :origin => 'http://subdomain.example.com'\n  end\n\n  it 'should support proc origins configuration' do\n    successful_cors_request '/proc-origin', :origin => 'http://10.10.10.10:3000'\n  end\n\n  it 'should support lambda origin configuration' do\n    successful_cors_request '/lambda-origin', :origin => 'http://10.10.10.10:3000'\n  end\n\n  it 'should support proc origins configuration (inverse)' do\n    cors_request '/proc-origin', :origin => 'http://bad.guy'\n    last_response.wont_render_cors_success\n  end\n\n  it 'should not mix up path rules across origins' do\n    header 'Origin', 'http://10.10.10.10:3000'\n    get '/' # / is configured in a separate rule block\n    last_response.wont_render_cors_success\n  end\n\n  it 'should support alternative X-Origin header' do\n    header 'X-Origin', 'http://localhost:3000'\n    get '/'\n    last_response.must_render_cors_success\n  end\n\n  it 'should support expose header configuration' do\n    successful_cors_request '/expose_single_header'\n    last_response.headers['Access-Control-Expose-Headers'].must_equal 'expose-test'\n  end\n\n  it 'should support expose multiple header configuration' do\n    successful_cors_request '/expose_multiple_headers'\n    last_response.headers['Access-Control-Expose-Headers'].must_equal 'expose-test-1, expose-test-2'\n  end\n\n  # Explanation: http://www.fastly.com/blog/best-practices-for-using-the-vary-header/\n  it \"should add Vary header if resource matches even if Origin header isn't present\" do\n    get '/'\n    last_response.wont_render_cors_success\n    last_response.headers['Vary'].must_equal 'Origin'\n  end\n\n  it \"should add Vary header based on :vary option\" do\n    successful_cors_request '/vary_test'\n    last_response.headers['Vary'].must_equal 'Origin, Host'\n  end\n\n  it \"decode URL and resolve paths before resource matching\" do\n    header 'Origin', 'http://localhost:3000'\n    get '/public/a/..%2F..%2Fprivate/stuff'\n    last_response.wont_render_cors_success\n  end\n\n  describe 'with array of upstream Vary headers' do\n    let(:app) { load_app('test', { proxy: true }) }\n\n    it 'should add to them' do\n      successful_cors_request '/vary_test'\n      last_response.headers['Vary'].must_equal 'Origin, User-Agent, Host'\n    end\n  end\n\n  it 'should add Vary header if Access-Control-Allow-Origin header was added and if it is specific' do\n    successful_cors_request '/', :origin => \"http://192.168.0.3:8080\"\n    last_response.headers['Access-Control-Allow-Origin'].must_equal 'http://192.168.0.3:8080'\n    last_response.headers['Vary'].wont_be_nil\n  end\n\n  it 'should add Vary header even if Access-Control-Allow-Origin header was added and it is generic (*)' do\n    successful_cors_request '/public_without_credentials', :origin => \"http://192.168.1.3:8080\"\n    last_response.headers['Access-Control-Allow-Origin'].must_equal '*'\n    last_response.headers['Vary'].must_equal 'Origin'\n  end\n\n  it 'should support multi allow configurations for the same resource' do\n    successful_cors_request '/multi-allow-config', :origin => \"http://mucho-grande.com\"\n    last_response.headers['Access-Control-Allow-Origin'].must_equal 'http://mucho-grande.com'\n    last_response.headers['Vary'].must_equal 'Origin'\n\n    successful_cors_request '/multi-allow-config', :origin => \"http://192.168.1.3:8080\"\n    last_response.headers['Access-Control-Allow-Origin'].must_equal '*'\n    last_response.headers['Vary'].must_equal 'Origin'\n  end\n\n  it \"should not return CORS headers on OPTIONS request if Access-Control-Allow-Origin is not present\" do\n    options '/get-only'\n    last_response.headers['Access-Control-Allow-Origin'].must_be_nil\n  end\n\n  it \"should not apply CORS headers if it does not match conditional on resource\" do\n    header 'Origin', 'http://192.168.0.1:1234'\n    get '/conditional'\n    last_response.wont_render_cors_success\n  end\n\n  it \"should apply CORS headers if it does match conditional on resource\" do\n    header 'X-OK', '1'\n    successful_cors_request '/conditional', :origin => 'http://192.168.0.1:1234'\n  end\n\n  it \"should not allow everything if Origin is configured as blank string\" do\n    cors_request '/blank-origin', origin: \"http://example.net\"\n    last_response.wont_render_cors_success\n  end\n\n  it \"should not allow credentials for public resources\" do\n    successful_cors_request '/public'\n    last_response.headers['Access-Control-Allow-Credentials'].must_be_nil\n  end\n\n  describe 'logging' do\n    it 'should not log debug messages if debug option is false' do\n      app = mock\n      app.stubs(:call).returns(200, {}, [''])\n\n      logger = mock\n      logger.expects(:debug).never\n\n      cors = Rack::Cors.new(app, :debug => false, :logger => logger) {}\n      cors.send(:debug, {}, 'testing')\n    end\n\n    it 'should log debug messages if debug option is true' do\n      app = mock\n      app.stubs(:call).returns(200, {}, [''])\n\n      logger = mock\n      logger.expects(:debug)\n\n      cors = Rack::Cors.new(app, :debug => true, :logger => logger) {}\n      cors.send(:debug, {}, 'testing')\n    end\n\n    it 'should use rack.logger if available' do\n      app = mock\n      app.stubs(:call).returns([200, {}, ['']])\n\n      logger = mock\n      logger.expects(:debug).at_least_once\n\n      cors = Rack::Cors.new(app, :debug => true) {}\n      cors.call({'rack.logger' => logger, 'HTTP_ORIGIN' => 'test.com'})\n    end\n\n    it 'should use logger proc' do\n      app = mock\n      app.stubs(:call).returns([200, {}, ['']])\n\n      logger = mock\n      logger.expects(:debug)\n\n      cors = Rack::Cors.new(app, :debug => true, :logger => proc { logger }) {}\n      cors.call({'HTTP_ORIGIN' => 'test.com'})\n    end\n\n    describe 'with Rails setup' do\n      after do\n        ::Rails.logger = nil if defined?(::Rails)\n      end\n\n      it 'should use Rails.logger if available' do\n        app = mock\n        app.stubs(:call).returns([200, {}, ['']])\n\n        logger = mock\n        logger.expects(:debug)\n\n        ::Rails = OpenStruct.new(:logger => logger)\n\n        cors = Rack::Cors.new(app, :debug => true) {}\n        cors.call({'HTTP_ORIGIN' => 'test.com'})\n      end\n    end\n\n    it 'should use Logger if none is set' do\n      app = mock\n      app.stubs(:call).returns([200, {}, ['']])\n\n      logger = mock\n      Logger.expects(:new).returns(logger)\n      logger.expects(:tap).returns(logger)\n      logger.expects(:debug)\n\n      cors = Rack::Cors.new(app, :debug => true) {}\n      cors.call({'HTTP_ORIGIN' => 'test.com'})\n    end\n  end\n\n  describe 'preflight requests' do\n    it 'should fail if origin is invalid' do\n      preflight_request('http://allyourdataarebelongtous.com', '/')\n      last_response.wont_render_cors_success\n      cors_result.wont_be :hit\n      cors_result.must_be :preflight\n    end\n\n    it 'should fail if Access-Control-Request-Method is not allowed' do\n      preflight_request('http://localhost:3000', '/get-only', :method => :post)\n      last_response.wont_render_cors_success\n      cors_result.miss_reason.must_equal Rack::Cors::Result::MISS_DENY_METHOD\n      cors_result.wont_be :hit\n      cors_result.must_be :preflight\n    end\n\n    it 'should fail if header is not allowed' do\n      preflight_request('http://localhost:3000', '/single_header', :headers => 'Fooey')\n      last_response.wont_render_cors_success\n      cors_result.miss_reason.must_equal Rack::Cors::Result::MISS_DENY_HEADER\n      cors_result.wont_be :hit\n      cors_result.must_be :preflight\n    end\n\n    it 'should allow any header if headers = :any' do\n      preflight_request('http://localhost:3000', '/', :headers => 'Fooey')\n      last_response.must_render_cors_success\n    end\n\n    it 'should allow any method if methods = :any' do\n      preflight_request('http://localhost:3000', '/', :methods => :any)\n      last_response.must_render_cors_success\n    end\n\n    it 'allows PATCH method' do\n      preflight_request('http://localhost:3000', '/', :methods => [ :patch ])\n      last_response.must_render_cors_success\n    end\n\n    it 'should allow header case insensitive match' do\n      preflight_request('http://localhost:3000', '/single_header', :headers => 'X-Domain-Token')\n      last_response.must_render_cors_success\n    end\n\n    it 'should allow multiple headers match' do\n      # Webkit style\n      preflight_request('http://localhost:3000', '/two_headers', :headers => 'X-Requested-With, X-Domain-Token')\n      last_response.must_render_cors_success\n\n      # Gecko style\n      preflight_request('http://localhost:3000', '/two_headers', :headers => 'x-requested-with,x-domain-token')\n      last_response.must_render_cors_success\n    end\n\n    it 'should * origin should allow any origin' do\n      preflight_request('http://locohost:3000', '/public')\n      last_response.must_render_cors_success\n      last_response.headers['Access-Control-Allow-Origin'].must_equal '*'\n    end\n\n    it 'should * origin should allow any origin, and set * if no credentials required' do\n      preflight_request('http://locohost:3000', '/public_without_credentials')\n      last_response.must_render_cors_success\n      last_response.headers['Access-Control-Allow-Origin'].must_equal '*'\n    end\n\n    it 'should return \"file://\" as header with \"file://\" as origin' do\n      preflight_request('file://', '/')\n      last_response.must_render_cors_success\n      last_response.headers['Access-Control-Allow-Origin'].must_equal 'file://'\n    end\n\n    describe '' do\n\n      let(:app) do\n        test = self\n        Rack::Builder.new do\n          use CaptureResult, holder: test\n          use Rack::Cors, debug: true, logger: Logger.new(StringIO.new) do\n            allow do\n              origins '*'\n              resource '/', :methods => :post\n            end\n          end\n          map('/') do\n            run ->(env) { [500, {}, ['FAIL!']] }\n          end\n        end\n      end\n\n      it \"should not send failed preflight requests thru the app\" do\n        preflight_request('http://localhost', '/', :method => :unsupported)\n        last_response.wont_render_cors_success\n        last_response.status.must_equal 200\n        cors_result.must_be :preflight\n        cors_result.wont_be :hit\n        cors_result.miss_reason.must_equal Rack::Cors::Result::MISS_DENY_METHOD\n      end\n    end\n  end\n\n  describe \"with insecure configuration\" do\n    let(:app) { load_app('insecure') }\n\n    it \"should raise an error\" do\n      proc { cors_request '/public' }.must_raise Rack::Cors::Resource::CorsMisconfigurationError\n    end\n  end\n\n  describe \"with non HTTP config\" do\n    let(:app) { load_app(\"non_http\") }\n\n    it 'should support non http/https origins' do\n      successful_cors_request '/public', origin: 'content://com.company.app'\n    end\n  end\n\n  describe 'Rack::Lint' do\n    def app\n      @app ||= Rack::Builder.new do\n        use Rack::Cors\n        use Rack::Lint\n        run ->(env) { [200, {'Content-Type' => 'text/html'}, ['hello']] }\n      end\n    end\n\n    it 'is lint-compliant with non-CORS request' do\n      get '/'\n      last_response.status.must_equal 200\n    end\n  end\n\n  describe 'with app overriding CORS header' do\n    let(:app) do\n      Rack::Builder.new do\n        use Rack::Cors, debug: true, logger: Logger.new(StringIO.new) do\n          allow do\n            origins '*'\n            resource '/'\n          end\n        end\n        map('/') do\n          run ->(env) { [200, {'Access-Control-Allow-Origin' => 'http://foo.net'}, ['success']] }\n        end\n      end\n    end\n\n    it \"should return app header\" do\n      successful_cors_request origin: \"http://example.net\"\n      last_response.headers['Access-Control-Allow-Origin'].must_equal \"http://foo.net\"\n    end\n\n    it \"should return original headers if in debug\" do\n      successful_cors_request origin: \"http://example.net\"\n      last_response.headers['X-Rack-CORS-Original-Access-Control-Allow-Origin'].must_equal \"*\"\n    end\n  end\n\n  describe 'with headers set to nil' do\n    let(:app) do\n      Rack::Builder.new do\n        use Rack::Cors do\n          allow do\n            origins '*'\n            resource '/', headers: nil\n          end\n        end\n        map('/') do\n          run ->(env) { [200, {'Content-Type' => 'text/html'}, ['hello']] }\n        end\n      end\n    end\n\n    it 'should succeed with CORS simple headers' do\n      preflight_request('http://localhost:3000', '/', :headers => 'Accept')\n      last_response.must_render_cors_success\n    end\n  end\n\n  describe 'with custom allowed headers' do\n    let(:app) do\n      Rack::Builder.new do\n        use Rack::Cors do\n          allow do\n            origins '*'\n            resource '/', headers: []\n          end\n        end\n        map('/') do\n          run ->(env) { [200, {'Content-Type' => 'text/html'}, ['hello']] }\n        end\n      end\n    end\n\n    it 'should succeed with CORS simple headers' do\n      preflight_request('http://localhost:3000', '/', :headers => 'Accept')\n      last_response.must_render_cors_success\n      preflight_request('http://localhost:3000', '/', :headers => 'Accept-Language')\n      last_response.must_render_cors_success\n      preflight_request('http://localhost:3000', '/', :headers => 'Content-Type')\n      last_response.must_render_cors_success\n      preflight_request('http://localhost:3000', '/', :headers => 'Content-Language')\n      last_response.must_render_cors_success\n    end\n  end\n\n  protected\n    def cors_request(*args)\n      path = args.first.is_a?(String) ? args.first : '/'\n\n      opts = { :method => :get, :origin => 'http://localhost:3000' }\n      opts.merge! args.last if args.last.is_a?(Hash)\n\n      header 'Origin', opts[:origin]\n      current_session.__send__ opts[:method], path, {}, test: self\n    end\n\n    def successful_cors_request(*args)\n      cors_request(*args)\n      last_response.must_render_cors_success\n    end\n\n    def preflight_request(origin, path, opts = {})\n      header 'Origin', origin\n      unless opts.key?(:method) && opts[:method].nil?\n        header 'Access-Control-Request-Method', opts[:method] ? opts[:method].to_s.upcase : 'GET'\n      end\n      if opts[:headers]\n        header 'Access-Control-Request-Headers', opts[:headers]\n      end\n      options path\n    end\nend\n", "require 'rack/cors'\n\n#use Rack::Cors, :debug => true, :logger => ::Logger.new(STDOUT) do\nuse Rack::Lint\nuse Rack::Cors do\n  allow do\n    origins 'localhost:3000',\n            '127.0.0.1:3000',\n            /http:\\/\\/192\\.168\\.0\\.\\d{1,3}(:\\d+)?/,\n            'file://',\n            /http:\\/\\/(.*?)\\.example\\.com/\n\n    resource '/get-only', :methods => :get\n    resource '/', :headers => :any, :methods => :any\n    resource '/options', :methods => :options\n    resource '/single_header', :headers => 'x-domain-token'\n    resource '/two_headers', :headers => %w{x-domain-token x-requested-with}\n    resource '/expose_single_header', :expose => 'expose-test'\n    resource '/expose_multiple_headers', :expose => %w{expose-test-1 expose-test-2}\n    resource '/conditional', :methods => :get, :if => proc { |env| !!env['HTTP_X_OK'] }\n    resource '/vary_test', :methods => :get, :vary => %w{ Origin Host }\n    resource '/patch_test', :methods => :patch\n    # resource '/file/at/*',\n    #     :methods => [:get, :post, :put, :delete],\n    #     :headers => :any,\n    #     :max_age => 0\n  end\n\n  allow do\n    origins do |source,env|\n      source.end_with?(\"10.10.10.10:3000\")\n    end\n    resource '/proc-origin'\n  end\n\n  allow do\n    origins -> (source, env) { source.end_with?(\"10.10.10.10:3000\") }\n    resource '/lambda-origin'\n  end\n\n  allow do\n    origins '*'\n    resource '/public'\n    resource '/public/*'\n    resource '/public_without_credentials', :credentials => false\n  end\n\n  allow do\n    origins 'mucho-grande.com'\n    resource '/multi-allow-config', :max_age => 600\n  end\n\n  allow do\n    origins '*'\n    resource '/multi-allow-config', :max_age => 300, :credentials => false\n  end\n\n  allow do\n    origins ''\n    resource '/blank-origin'\n  end\nend\n"], "filenames": ["CHANGELOG.md", "lib/rack/cors.rb", "lib/rack/cors/version.rb", "test/unit/cors_test.rb", "test/unit/test.ru"], "buggy_code_start_loc": [2, 65, 3, 146, 43], "buggy_code_end_loc": [2, 190, 4, 146, 43], "fixing_code_start_loc": [3, 66, 3, 147, 44], "fixing_code_end_loc": [7, 198, 4, 153, 45], "type": "CWE-22", "message": "An issue was discovered in the rack-cors (aka Rack CORS Middleware) gem before 1.0.4 for Ruby. It allows ../ directory traversal to access private resources because resource matching does not ensure that pathnames are in a canonical format.", "other": {"cve": {"id": "CVE-2019-18978", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-14T21:15:12.170", "lastModified": "2021-05-21T16:47:13.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the rack-cors (aka Rack CORS Middleware) gem before 1.0.4 for Ruby. It allows ../ directory traversal to access private resources because resource matching does not ensure that pathnames are in a canonical format."}, {"lang": "es", "value": "Se descubri\u00f3 un problema en la gema rack-cors (tambi\u00e9n se conoce como Rack CORS Middleware) versiones anteriores a la versi\u00f3n 1.0.4 para Ruby. Permite que un salto de directorio ../  acceda a recursos privados porque la coincidencia de recursos no garantiza que los nombres de ruta est\u00e9n en formato can\u00f3nico."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rack-cors_project:rack-cors:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "1.0.4", "matchCriteriaId": "443062DB-B559-4E14-89C5-F74B6FCDE313"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}]}]}], "references": [{"url": "https://github.com/cyu/rack-cors/commit/e4d4fc362a4315808927011cbe5afcfe5486f17d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/cyu/rack-cors/compare/v1.0.3...v1.0.4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/02/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/10/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4571-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4918", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cyu/rack-cors/commit/e4d4fc362a4315808927011cbe5afcfe5486f17d"}}