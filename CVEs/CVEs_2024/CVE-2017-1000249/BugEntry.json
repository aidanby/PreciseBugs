{"buggy_code": ["/*\n * Copyright (c) Christos Zoulas 2003.\n * All Rights Reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  \n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#include \"file.h\"\n\n#ifndef lint\nFILE_RCSID(\"@(#)$File: readelf.c,v 1.137 2017/08/13 00:21:47 christos Exp $\")\n#endif\n\n#ifdef BUILTIN_ELF\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"readelf.h\"\n#include \"magic.h\"\n\n#ifdef\tELFCORE\nprivate int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t,\n    off_t, int *, uint16_t *);\n#endif\nprivate int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t,\n    off_t, int, int *, uint16_t *);\nprivate int doshn(struct magic_set *, int, int, int, off_t, int, size_t,\n    off_t, int, int, int *, uint16_t *);\nprivate size_t donote(struct magic_set *, void *, size_t, size_t, int,\n    int, size_t, int *, uint16_t *, int, off_t, int, off_t);\n\n#define\tELF_ALIGN(a)\t((((a) + align - 1) / align) * align)\n\n#define isquote(c) (strchr(\"'\\\"`\", (c)) != NULL)\n\nprivate uint16_t getu16(int, uint16_t);\nprivate uint32_t getu32(int, uint32_t);\nprivate uint64_t getu64(int, uint64_t);\n\n#define MAX_PHNUM\t128\n#define\tMAX_SHNUM\t32768\n#define SIZE_UNKNOWN\t((off_t)-1)\n\nprivate int\ntoomany(struct magic_set *ms, const char *name, uint16_t num)\n{\n\tif (file_printf(ms, \", too many %s (%u)\", name, num\n\t    ) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nprivate uint16_t\ngetu16(int swap, uint16_t value)\n{\n\tunion {\n\t\tuint16_t ui;\n\t\tchar c[2];\n\t} retval, tmpval;\n\n\tif (swap) {\n\t\ttmpval.ui = value;\n\n\t\tretval.c[0] = tmpval.c[1];\n\t\tretval.c[1] = tmpval.c[0];\n\t\t\n\t\treturn retval.ui;\n\t} else\n\t\treturn value;\n}\n\nprivate uint32_t\ngetu32(int swap, uint32_t value)\n{\n\tunion {\n\t\tuint32_t ui;\n\t\tchar c[4];\n\t} retval, tmpval;\n\n\tif (swap) {\n\t\ttmpval.ui = value;\n\n\t\tretval.c[0] = tmpval.c[3];\n\t\tretval.c[1] = tmpval.c[2];\n\t\tretval.c[2] = tmpval.c[1];\n\t\tretval.c[3] = tmpval.c[0];\n\t\t\n\t\treturn retval.ui;\n\t} else\n\t\treturn value;\n}\n\nprivate uint64_t\ngetu64(int swap, uint64_t value)\n{\n\tunion {\n\t\tuint64_t ui;\n\t\tchar c[8];\n\t} retval, tmpval;\n\n\tif (swap) {\n\t\ttmpval.ui = value;\n\n\t\tretval.c[0] = tmpval.c[7];\n\t\tretval.c[1] = tmpval.c[6];\n\t\tretval.c[2] = tmpval.c[5];\n\t\tretval.c[3] = tmpval.c[4];\n\t\tretval.c[4] = tmpval.c[3];\n\t\tretval.c[5] = tmpval.c[2];\n\t\tretval.c[6] = tmpval.c[1];\n\t\tretval.c[7] = tmpval.c[0];\n\t\t\n\t\treturn retval.ui;\n\t} else\n\t\treturn value;\n}\n\n#define elf_getu16(swap, value) getu16(swap, value)\n#define elf_getu32(swap, value) getu32(swap, value)\n#define elf_getu64(swap, value) getu64(swap, value)\n\n#define xsh_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? (void *)&sh32\t\t\t\\\n\t\t\t : (void *)&sh64)\n#define xsh_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(sh32)\t\t\t\t\\\n\t\t\t : sizeof(sh64))\n#define xsh_size\t(size_t)(clazz == ELFCLASS32\t\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_size)\t\\\n\t\t\t : elf_getu64(swap, sh64.sh_size))\n#define xsh_offset\t(off_t)(clazz == ELFCLASS32\t\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_offset)\t\\\n\t\t\t : elf_getu64(swap, sh64.sh_offset))\n#define xsh_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_type)\t\\\n\t\t\t : elf_getu32(swap, sh64.sh_type))\n#define xsh_name    \t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_name)\t\\\n\t\t\t : elf_getu32(swap, sh64.sh_name))\n#define xph_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? (void *) &ph32\t\t\t\\\n\t\t\t : (void *) &ph64)\n#define xph_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(ph32)\t\t\t\t\\\n\t\t\t : sizeof(ph64))\n#define xph_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_type)\t\\\n\t\t\t : elf_getu32(swap, ph64.p_type))\n#define xph_offset\t(off_t)(clazz == ELFCLASS32\t\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_offset)\t\\\n\t\t\t : elf_getu64(swap, ph64.p_offset))\n#define xph_align\t(size_t)((clazz == ELFCLASS32\t\t\\\n\t\t\t ? (off_t) (ph32.p_align ? \t\t\\\n\t\t\t    elf_getu32(swap, ph32.p_align) : 4) \\\n\t\t\t : (off_t) (ph64.p_align ?\t\t\\\n\t\t\t    elf_getu64(swap, ph64.p_align) : 4)))\n#define xph_vaddr\t(size_t)((clazz == ELFCLASS32\t\t\\\n\t\t\t ? (off_t) (ph32.p_vaddr ? \t\t\\\n\t\t\t    elf_getu32(swap, ph32.p_vaddr) : 4) \\\n\t\t\t : (off_t) (ph64.p_vaddr ?\t\t\\\n\t\t\t    elf_getu64(swap, ph64.p_vaddr) : 4)))\n#define xph_filesz\t(size_t)((clazz == ELFCLASS32\t\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_filesz)\t\\\n\t\t\t : elf_getu64(swap, ph64.p_filesz)))\n#define xnh_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? (void *)&nh32\t\t\t\\\n\t\t\t : (void *)&nh64)\n#define xph_memsz\t(size_t)((clazz == ELFCLASS32\t\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_memsz)\t\\\n\t\t\t : elf_getu64(swap, ph64.p_memsz)))\n#define xnh_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(nh32)\t\t\t\t\\\n\t\t\t : sizeof(nh64))\n#define xnh_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, nh32.n_type)\t\\\n\t\t\t : elf_getu32(swap, nh64.n_type))\n#define xnh_namesz\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, nh32.n_namesz)\t\\\n\t\t\t : elf_getu32(swap, nh64.n_namesz))\n#define xnh_descsz\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, nh32.n_descsz)\t\\\n\t\t\t : elf_getu32(swap, nh64.n_descsz))\n#define prpsoffsets(i)\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? prpsoffsets32[i]\t\t\t\\\n\t\t\t : prpsoffsets64[i])\n#define xcap_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? (void *)&cap32\t\t\t\\\n\t\t\t : (void *)&cap64)\n#define xcap_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof cap32\t\t\t\t\\\n\t\t\t : sizeof cap64)\n#define xcap_tag\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, cap32.c_tag)\t\\\n\t\t\t : elf_getu64(swap, cap64.c_tag))\n#define xcap_val\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, cap32.c_un.c_val)\t\\\n\t\t\t : elf_getu64(swap, cap64.c_un.c_val))\n#define xauxv_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? (void *)&auxv32\t\t\t\\\n\t\t\t : (void *)&auxv64)\n#define xauxv_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(auxv32)\t\t\t\\\n\t\t\t : sizeof(auxv64))\n#define xauxv_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, auxv32.a_type)\t\\\n\t\t\t : elf_getu64(swap, auxv64.a_type))\n#define xauxv_val\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, auxv32.a_v)\t\t\\\n\t\t\t : elf_getu64(swap, auxv64.a_v))\n\n#ifdef ELFCORE\n/*\n * Try larger offsets first to avoid false matches\n * from earlier data that happen to look like strings.\n */\nstatic const size_t\tprpsoffsets32[] = {\n#ifdef USE_NT_PSINFO\n\t104,\t\t/* SunOS 5.x (command line) */\n\t88,\t\t/* SunOS 5.x (short name) */\n#endif /* USE_NT_PSINFO */\n\n\t100,\t\t/* SunOS 5.x (command line) */\n\t84,\t\t/* SunOS 5.x (short name) */\n\n\t44,\t\t/* Linux (command line) */\n\t28,\t\t/* Linux 2.0.36 (short name) */\n\n\t8,\t\t/* FreeBSD */\n};\n\nstatic const size_t\tprpsoffsets64[] = {\n#ifdef USE_NT_PSINFO\n\t152,\t\t/* SunOS 5.x (command line) */\n\t136,\t\t/* SunOS 5.x (short name) */\n#endif /* USE_NT_PSINFO */\n\n\t136,\t\t/* SunOS 5.x, 64-bit (command line) */\n\t120,\t\t/* SunOS 5.x, 64-bit (short name) */\n\n\t56,\t\t/* Linux (command line) */\n\t40,             /* Linux (tested on core from 2.4.x, short name) */\n\n\t16,\t\t/* FreeBSD, 64-bit */\n};\n\n#define\tNOFFSETS32\t(sizeof prpsoffsets32 / sizeof prpsoffsets32[0])\n#define NOFFSETS64\t(sizeof prpsoffsets64 / sizeof prpsoffsets64[0])\n\n#define NOFFSETS\t(clazz == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)\n\n/*\n * Look through the program headers of an executable image, searching\n * for a PT_NOTE section of type NT_PRPSINFO, with a name \"CORE\" or\n * \"FreeBSD\"; if one is found, try looking in various places in its\n * contents for a 16-character string containing only printable\n * characters - if found, that string should be the name of the program\n * that dropped core.  Note: right after that 16-character string is,\n * at least in SunOS 5.x (and possibly other SVR4-flavored systems) and\n * Linux, a longer string (80 characters, in 5.x, probably other\n * SVR4-flavored systems, and Linux) containing the start of the\n * command line for that program.\n *\n * SunOS 5.x core files contain two PT_NOTE sections, with the types\n * NT_PRPSINFO (old) and NT_PSINFO (new).  These structs contain the\n * same info about the command name and command line, so it probably\n * isn't worthwhile to look for NT_PSINFO, but the offsets are provided\n * above (see USE_NT_PSINFO), in case we ever decide to do so.  The\n * NT_PRPSINFO and NT_PSINFO sections are always in order and adjacent;\n * the SunOS 5.x file command relies on this (and prefers the latter).\n *\n * The signal number probably appears in a section of type NT_PRSTATUS,\n * but that's also rather OS-dependent, in ways that are harder to\n * dissect with heuristics, so I'm not bothering with the signal number.\n * (I suppose the signal number could be of interest in situations where\n * you don't have the binary of the program that dropped core; if you\n * *do* have that binary, the debugger will probably tell you what\n * signal it was.)\n */\n\n#define\tOS_STYLE_SVR4\t\t0\n#define\tOS_STYLE_FREEBSD\t1\n#define\tOS_STYLE_NETBSD\t\t2\n\nprivate const char os_style_names[][8] = {\n\t\"SVR4\",\n\t\"FreeBSD\",\n\t\"NetBSD\",\n};\n\n#define FLAGS_CORE_STYLE\t\t0x003\n\n#define FLAGS_DID_CORE\t\t\t0x004\n#define FLAGS_DID_OS_NOTE\t\t0x008\n#define FLAGS_DID_BUILD_ID\t\t0x010\n#define FLAGS_DID_CORE_STYLE\t\t0x020\n#define FLAGS_DID_NETBSD_PAX\t\t0x040\n#define FLAGS_DID_NETBSD_MARCH\t\t0x080\n#define FLAGS_DID_NETBSD_CMODEL\t\t0x100\n#define FLAGS_DID_NETBSD_UNKNOWN\t0x200\n#define FLAGS_IS_CORE\t\t\t0x400\n#define FLAGS_DID_AUXV\t\t\t0x800\n\nprivate int\ndophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int *flags, uint16_t *notecount)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tsize_t offset, len;\n\tunsigned char nbuf[BUFSIZ];\n\tssize_t bufsize;\n\toff_t ph_off = off;\n\tint ph_num = num;\n\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop through all the program headers.\n\t */\n\tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\n\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t/* Perhaps warn here */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (xph_type != PT_NOTE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t * in the section.\n\t\t */\n\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz : sizeof(nbuf);\n\t\tif ((bufsize = pread(fd, nbuf, len, xph_offset)) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = 0;\n\t\tfor (;;) {\n\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\tbreak;\n\t\t\toffset = donote(ms, nbuf, offset, (size_t)bufsize,\n\t\t\t    clazz, swap, 4, flags, notecount, fd, ph_off,\n\t\t\t    ph_num, fsize);\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\nstatic void\ndo_note_netbsd_version(struct magic_set *ms, int swap, void *v)\n{\n\tuint32_t desc;\n\t(void)memcpy(&desc, v, sizeof(desc));\n\tdesc = elf_getu32(swap, desc);\n\n\tif (file_printf(ms, \", for NetBSD\") == -1)\n\t\treturn;\n\t/*\n\t * The version number used to be stuck as 199905, and was thus\n\t * basically content-free.  Newer versions of NetBSD have fixed\n\t * this and now use the encoding of __NetBSD_Version__:\n\t *\n\t *\tMMmmrrpp00\n\t *\n\t * M = major version\n\t * m = minor version\n\t * r = release [\"\",A-Z,Z[A-Z] but numeric]\n\t * p = patchlevel\n\t */\n\tif (desc > 100000000U) {\n\t\tuint32_t ver_patch = (desc / 100) % 100;\n\t\tuint32_t ver_rel = (desc / 10000) % 100;\n\t\tuint32_t ver_min = (desc / 1000000) % 100;\n\t\tuint32_t ver_maj = desc / 100000000;\n\n\t\tif (file_printf(ms, \" %u.%u\", ver_maj, ver_min) == -1)\n\t\t\treturn;\n\t\tif (ver_rel == 0 && ver_patch != 0) {\n\t\t\tif (file_printf(ms, \".%u\", ver_patch) == -1)\n\t\t\t\treturn;\n\t\t} else if (ver_rel != 0) {\n\t\t\twhile (ver_rel > 26) {\n\t\t\t\tif (file_printf(ms, \"Z\") == -1)\n\t\t\t\t\treturn;\n\t\t\t\tver_rel -= 26;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%c\", 'A' + ver_rel - 1)\n\t\t\t    == -1)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void\ndo_note_freebsd_version(struct magic_set *ms, int swap, void *v)\n{\n\tuint32_t desc;\n\n\t(void)memcpy(&desc, v, sizeof(desc));\n\tdesc = elf_getu32(swap, desc);\n\tif (file_printf(ms, \", for FreeBSD\") == -1)\n\t\treturn;\n\n\t/*\n\t * Contents is __FreeBSD_version, whose relation to OS\n\t * versions is defined by a huge table in the Porter's\n\t * Handbook.  This is the general scheme:\n\t * \n\t * Releases:\n\t * \tMmp000 (before 4.10)\n\t * \tMmi0p0 (before 5.0)\n\t * \tMmm0p0\n\t * \n\t * Development branches:\n\t * \tMmpxxx (before 4.6)\n\t * \tMmp1xx (before 4.10)\n\t * \tMmi1xx (before 5.0)\n\t * \tM000xx (pre-M.0)\n\t * \tMmm1xx\n\t * \n\t * M = major version\n\t * m = minor version\n\t * i = minor version increment (491000 -> 4.10)\n\t * p = patchlevel\n\t * x = revision\n\t * \n\t * The first release of FreeBSD to use ELF by default\n\t * was version 3.0.\n\t */\n\tif (desc == 460002) {\n\t\tif (file_printf(ms, \" 4.6.2\") == -1)\n\t\t\treturn;\n\t} else if (desc < 460100) {\n\t\tif (file_printf(ms, \" %d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10) == -1)\n\t\t\treturn;\n\t\tif (desc / 1000 % 10 > 0)\n\t\t\tif (file_printf(ms, \".%d\", desc / 1000 % 10) == -1)\n\t\t\t\treturn;\n\t\tif ((desc % 1000 > 0) || (desc % 100000 == 0))\n\t\t\tif (file_printf(ms, \" (%d)\", desc) == -1)\n\t\t\t\treturn;\n\t} else if (desc < 500000) {\n\t\tif (file_printf(ms, \" %d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10 + desc / 1000 % 10) == -1)\n\t\t\treturn;\n\t\tif (desc / 100 % 10 > 0) {\n\t\t\tif (file_printf(ms, \" (%d)\", desc) == -1)\n\t\t\t\treturn;\n\t\t} else if (desc / 10 % 10 > 0) {\n\t\t\tif (file_printf(ms, \".%d\", desc / 10 % 10) == -1)\n\t\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (file_printf(ms, \" %d.%d\", desc / 100000,\n\t\t    desc / 1000 % 100) == -1)\n\t\t\treturn;\n\t\tif ((desc / 100 % 10 > 0) ||\n\t\t    (desc % 100000 / 100 == 0)) {\n\t\t\tif (file_printf(ms, \" (%d)\", desc) == -1)\n\t\t\t\treturn;\n\t\t} else if (desc / 10 % 10 > 0) {\n\t\t\tif (file_printf(ms, \".%d\", desc / 10 % 10) == -1)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nprivate int\n/*ARGSUSED*/\ndo_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) {\n\t\tuint8_t desc[20];\n\t\tconst char *btype;\n\t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\ndo_os_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 5 && strcmp((char *)&nbuf[noff], \"SuSE\") == 0 &&\n\t    type == NT_GNU_VERSION && descsz == 2) {\n\t    *flags |= FLAGS_DID_OS_NOTE;\n\t    file_printf(ms, \", for SuSE %d.%d\", nbuf[doff], nbuf[doff + 1]);\n\t    return 1;\n\t}\n\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_VERSION && descsz == 16) {\n\t\tuint32_t desc[4];\n\t\t(void)memcpy(desc, &nbuf[doff], sizeof(desc));\n\n\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\tif (file_printf(ms, \", for GNU/\") == -1)\n\t\t\treturn 1;\n\t\tswitch (elf_getu32(swap, desc[0])) {\n\t\tcase GNU_OS_LINUX:\n\t\t\tif (file_printf(ms, \"Linux\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_HURD:\n\t\t\tif (file_printf(ms, \"Hurd\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_SOLARIS:\n\t\t\tif (file_printf(ms, \"Solaris\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_KFREEBSD:\n\t\t\tif (file_printf(ms, \"kFreeBSD\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_KNETBSD:\n\t\t\tif (file_printf(ms, \"kNetBSD\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, \"<unknown>\") == -1)\n\t\t\t\treturn 1; \n\t\t}\n\t\tif (file_printf(ms, \" %d.%d.%d\", elf_getu32(swap, desc[1]),\n\t\t    elf_getu32(swap, desc[2]), elf_getu32(swap, desc[3])) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\n\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n\t    \tif (type == NT_NETBSD_VERSION && descsz == 4) {\n\t\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\t\tdo_note_netbsd_version(ms, swap, &nbuf[doff]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0) {\n\t    \tif (type == NT_FREEBSD_VERSION && descsz == 4) {\n\t\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\t\tdo_note_freebsd_version(ms, swap, &nbuf[doff]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"OpenBSD\") == 0 &&\n\t    type == NT_OPENBSD_VERSION && descsz == 4) {\n\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\tif (file_printf(ms, \", for OpenBSD\") == -1)\n\t\t\treturn 1;\n\t\t/* Content of note is always 0 */\n\t\treturn 1;\n\t}\n\n\tif (namesz == 10 && strcmp((char *)&nbuf[noff], \"DragonFly\") == 0 &&\n\t    type == NT_DRAGONFLY_VERSION && descsz == 4) {\n\t\tuint32_t desc;\n\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\tif (file_printf(ms, \", for DragonFly\") == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n\t\tdesc = elf_getu32(swap, desc);\n\t\tif (file_printf(ms, \" %d.%d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10, desc % 10000) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\ndo_pax_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"PaX\") == 0 &&\n\t    type == NT_NETBSD_PAX && descsz == 4) {\n\t\tstatic const char *pax[] = {\n\t\t    \"+mprotect\",\n\t\t    \"-mprotect\",\n\t\t    \"+segvguard\",\n\t\t    \"-segvguard\",\n\t\t    \"+ASLR\",\n\t\t    \"-ASLR\",\n\t\t};\n\t\tuint32_t desc;\n\t\tsize_t i;\n\t\tint did = 0;\n\n\t\t*flags |= FLAGS_DID_NETBSD_PAX;\n\t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n\t\tdesc = elf_getu32(swap, desc);\n\n\t\tif (desc && file_printf(ms, \", PaX: \") == -1)\n\t\t\treturn 1;\n\n\t\tfor (i = 0; i < __arraycount(pax); i++) {\n\t\t\tif (((1 << (int)i) & desc) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (file_printf(ms, \"%s%s\", did++ ? \",\" : \"\",\n\t\t\t    pax[i]) == -1)\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\ndo_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags, size_t size, int clazz)\n{\n#ifdef ELFCORE\n\tint os_style = -1;\n\t/*\n\t * Sigh.  The 2.0.36 kernel in Debian 2.1, at\n\t * least, doesn't correctly implement name\n\t * sections, in core dumps, as specified by\n\t * the \"Program Linking\" section of \"UNIX(R) System\n\t * V Release 4 Programmer's Guide: ANSI C and\n\t * Programming Support Tools\", because my copy\n\t * clearly says \"The first 'namesz' bytes in 'name'\n\t * contain a *null-terminated* [emphasis mine]\n\t * character representation of the entry's owner\n\t * or originator\", but the 2.0.36 kernel code\n\t * doesn't include the terminating null in the\n\t * name....\n\t */\n\tif ((namesz == 4 && strncmp((char *)&nbuf[noff], \"CORE\", 4) == 0) ||\n\t    (namesz == 5 && strcmp((char *)&nbuf[noff], \"CORE\") == 0)) {\n\t\tos_style = OS_STYLE_SVR4;\n\t} \n\n\tif ((namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0)) {\n\t\tos_style = OS_STYLE_FREEBSD;\n\t}\n\n\tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], \"NetBSD-CORE\", 11)\n\t    == 0)) {\n\t\tos_style = OS_STYLE_NETBSD;\n\t}\n\n\tif (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {\n\t\tif (file_printf(ms, \", %s-style\", os_style_names[os_style])\n\t\t    == -1)\n\t\t\treturn 1;\n\t\t*flags |= FLAGS_DID_CORE_STYLE;\n\t\t*flags |= os_style;\n\t}\n\n\tswitch (os_style) {\n\tcase OS_STYLE_NETBSD:\n\t\tif (type == NT_NETBSD_CORE_PROCINFO) {\n\t\t\tchar sbuf[512];\n\t\t\tstruct NetBSD_elfcore_procinfo pi;\n\t\t\tmemset(&pi, 0, sizeof(pi));\n\t\t\tmemcpy(&pi, nbuf + doff, descsz);\n\n\t\t\tif (file_printf(ms, \", from '%.31s', pid=%u, uid=%u, \"\n\t\t\t    \"gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)\",\n\t\t\t    file_printable(sbuf, sizeof(sbuf),\n\t\t\t    CAST(char *, pi.cpi_name)),\n\t\t\t    elf_getu32(swap, pi.cpi_pid),\n\t\t\t    elf_getu32(swap, pi.cpi_euid),\n\t\t\t    elf_getu32(swap, pi.cpi_egid),\n\t\t\t    elf_getu32(swap, pi.cpi_nlwps),\n\t\t\t    elf_getu32(swap, pi.cpi_siglwp),\n\t\t\t    elf_getu32(swap, pi.cpi_signo),\n\t\t\t    elf_getu32(swap, pi.cpi_sigcode)) == -1)\n\t\t\t\treturn 1;\n\n\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n\t\t\tsize_t i, j;\n\t\t\tunsigned char c;\n\t\t\t/*\n\t\t\t * Extract the program name.  We assume\n\t\t\t * it to be 16 characters (that's what it\n\t\t\t * is in SunOS 5.x and Linux).\n\t\t\t *\n\t\t\t * Unfortunately, it's at a different offset\n\t\t\t * in various OSes, so try multiple offsets.\n\t\t\t * If the characters aren't all printable,\n\t\t\t * reject it.\n\t\t\t */\n\t\t\tfor (i = 0; i < NOFFSETS; i++) {\n\t\t\t\tunsigned char *cname, *cp;\n\t\t\t\tsize_t reloffset = prpsoffsets(i);\n\t\t\t\tsize_t noffset = doff + reloffset;\n\t\t\t\tsize_t k;\n\t\t\t\tfor (j = 0; j < 16; j++, noffset++,\n\t\t\t\t    reloffset++) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the buffer; if\n\t\t\t\t\t * we are, just give up.\n\t\t\t\t\t */\n\t\t\t\t\tif (noffset >= size)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the contents;\n\t\t\t\t\t * if we are, this obviously\n\t\t\t\t\t * isn't the right offset.\n\t\t\t\t\t */\n\t\t\t\t\tif (reloffset >= descsz)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\tc = nbuf[noffset];\n\t\t\t\t\tif (c == '\\0') {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A '\\0' at the\n\t\t\t\t\t\t * beginning is\n\t\t\t\t\t\t * obviously wrong.\n\t\t\t\t\t\t * Any other '\\0'\n\t\t\t\t\t\t * means we're done.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A nonprintable\n\t\t\t\t\t\t * character is also\n\t\t\t\t\t\t * wrong.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!isprint(c) || isquote(c))\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Well, that worked.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Try next offsets, in case this match is\n\t\t\t\t * in the middle of a string.\n\t\t\t\t */\n\t\t\t\tfor (k = i + 1 ; k < NOFFSETS; k++) {\n\t\t\t\t\tsize_t no;\n\t\t\t\t\tint adjust = 1;\n\t\t\t\t\tif (prpsoffsets(k) >= prpsoffsets(i))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (no = doff + prpsoffsets(k);\n\t\t\t\t\t     no < doff + prpsoffsets(i); no++)\n\t\t\t\t\t\tadjust = adjust\n\t\t\t\t\t\t         && isprint(nbuf[no]);\n\t\t\t\t\tif (adjust)\n\t\t\t\t\t\ti = k;\n\t\t\t\t}\n\n\t\t\t\tcname = (unsigned char *)\n\t\t\t\t    &nbuf[doff + prpsoffsets(i)];\n\t\t\t\tfor (cp = cname; *cp && isprint(*cp); cp++)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*\n\t\t\t\t * Linux apparently appends a space at the end\n\t\t\t\t * of the command line: remove it.\n\t\t\t\t */\n\t\t\t\twhile (cp > cname && isspace(cp[-1]))\n\t\t\t\t\tcp--;\n\t\t\t\tif (file_printf(ms, \", from '%.*s'\",\n\t\t\t\t    (int)(cp - cname), cname) == -1)\n\t\t\t\t\treturn 1;\n\t\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\t\treturn 1;\n\n\t\t\ttryanother:\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\treturn 0;\n}\n\nprivate off_t\nget_offset_from_virtaddr(struct magic_set *ms, int swap, int clazz, int fd,\n    off_t off, int num, off_t fsize, uint64_t virtaddr)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\n\t/*\n\t * Loop through all the program headers and find the header with\n\t * virtual address in which the \"virtaddr\" belongs to.\n\t */\n\tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += xph_sizeof;\n\n\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t/* Perhaps warn here */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (virtaddr >= xph_vaddr && virtaddr < xph_vaddr + xph_filesz)\n\t\t\treturn xph_offset + (virtaddr - xph_vaddr);\n\t}\n\treturn 0;\n}\n\nprivate size_t\nget_string_on_virtaddr(struct magic_set *ms,\n    int swap, int clazz, int fd, off_t ph_off, int ph_num,\n    off_t fsize, uint64_t virtaddr, char *buf, ssize_t buflen)\n{\n\tchar *bptr;\n\toff_t offset;\n\n\tif (buflen == 0)\n\t\treturn 0;\n\n\toffset = get_offset_from_virtaddr(ms, swap, clazz, fd, ph_off, ph_num,\n\t    fsize, virtaddr);\n\tif ((buflen = pread(fd, buf, CAST(size_t, buflen), offset)) <= 0) {\n\t\tfile_badread(ms);\n\t\treturn 0;\n\t}\n\n\tbuf[buflen - 1] = '\\0';\n\n\t/* We expect only printable characters, so return if buffer contains\n\t * non-printable character before the '\\0' or just '\\0'. */\n\tfor (bptr = buf; *bptr && isprint((unsigned char)*bptr); bptr++)\n\t\tcontinue;\n\tif (*bptr != '\\0')\n\t\treturn 0;\n\n\treturn bptr - buf;\n}\n\n\nprivate int\ndo_auxv_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz __attribute__((__unused__)),\n    uint32_t descsz __attribute__((__unused__)),\n    size_t noff __attribute__((__unused__)), size_t doff,\n    int *flags, size_t size __attribute__((__unused__)), int clazz,\n    int fd, off_t ph_off, int ph_num, off_t fsize)\n{\n#ifdef ELFCORE\n\tAux32Info auxv32;\n\tAux64Info auxv64;\n\tsize_t elsize = xauxv_sizeof;\n\tconst char *tag;\n\tint is_string;\n\tsize_t nval;\n\n\tif ((*flags & (FLAGS_IS_CORE|FLAGS_DID_CORE_STYLE)) !=\n\t    (FLAGS_IS_CORE|FLAGS_DID_CORE_STYLE))\n\t\treturn 0;\n\n\tswitch (*flags & FLAGS_CORE_STYLE) {\n\tcase OS_STYLE_SVR4:\n\t\tif (type != NT_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n#ifdef notyet\n\tcase OS_STYLE_NETBSD:\n\t\tif (type != NT_NETBSD_CORE_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase OS_STYLE_FREEBSD:\n\t\tif (type != NT_FREEBSD_PROCSTAT_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t*flags |= FLAGS_DID_AUXV;\n\n\tnval = 0;\n\tfor (size_t off = 0; off + elsize <= descsz; off += elsize) {\n\t\t(void)memcpy(xauxv_addr, &nbuf[doff + off], xauxv_sizeof);\n\t\t/* Limit processing to 50 vector entries to prevent DoS */\n\t\tif (nval++ >= 50) {\n\t\t\tfile_error(ms, 0, \"Too many ELF Auxv elements\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tswitch(xauxv_type) {\n\t\tcase AT_LINUX_EXECFN:\n\t\t\tis_string = 1;\n\t\t\ttag = \"execfn\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_PLATFORM:\n\t\t\tis_string = 1;\n\t\t\ttag = \"platform\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_UID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"real uid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_GID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"real gid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_EUID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"effective uid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_EGID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"effective gid\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tis_string = 0;\n\t\t\ttag = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tag == NULL)\n\t\t\tcontinue;\n\n\t\tif (is_string) {\n\t\t\tchar buf[256];\n\t\t\tssize_t buflen;\n\t\t\tbuflen = get_string_on_virtaddr(ms, swap, clazz, fd,\n\t\t\t    ph_off, ph_num, fsize, xauxv_val, buf, sizeof(buf));\n\n\t\t\tif (buflen == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (file_printf(ms, \", %s: '%s'\", tag, buf) == -1)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (file_printf(ms, \", %s: %d\", tag, (int) xauxv_val)\n\t\t\t    == -1)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nprivate size_t\ndonote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap, size_t align, int *flags, uint16_t *notecount,\n    int fd, off_t ph_off, int ph_num, off_t fsize)\n{\n\tElf32_Nhdr nh32;\n\tElf64_Nhdr nh64;\n\tsize_t noff, doff;\n\tuint32_t namesz, descsz;\n\tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n\n\tif (*notecount == 0)\n\t\treturn 0;\n\t--*notecount;\n\n\tif (xnh_sizeof + offset > size) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn xnh_sizeof + offset;\n\t}\n\n\t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n\toffset += xnh_sizeof;\n\n\tnamesz = xnh_namesz;\n\tdescsz = xnh_descsz;\n\n\tif ((namesz == 0) && (descsz == 0)) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\n\tif (namesz & 0x80000000) {\n\t    (void)file_printf(ms, \", bad note name size %#lx\",\n\t\t(unsigned long)namesz);\n\t    return 0;\n\t}\n\n\tif (descsz & 0x80000000) {\n\t    (void)file_printf(ms, \", bad note description size %#lx\",\n\t\t(unsigned long)descsz);\n\t    return 0;\n\t}\n\n\tnoff = offset;\n\tdoff = ELF_ALIGN(offset + namesz);\n\n\tif (offset + namesz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn doff;\n\t}\n\n\toffset = ELF_ALIGN(doff + descsz);\n\tif (doff + descsz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\n\n\tif ((*flags & FLAGS_DID_OS_NOTE) == 0) {\n\t\tif (do_os_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn offset;\n\t}\n\n\tif ((*flags & FLAGS_DID_BUILD_ID) == 0) {\n\t\tif (do_bid_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn offset;\n\t}\n\t\t\n\tif ((*flags & FLAGS_DID_NETBSD_PAX) == 0) {\n\t\tif (do_pax_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn offset;\n\t}\n\n\tif ((*flags & FLAGS_DID_CORE) == 0) {\n\t\tif (do_core_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags, size, clazz))\n\t\t\treturn offset;\n\t}\n\n\tif ((*flags & FLAGS_DID_AUXV) == 0) {\n\t\tif (do_auxv_note(ms, nbuf, xnh_type, swap,\n\t\t\tnamesz, descsz, noff, doff, flags, size, clazz,\n\t\t\tfd, ph_off, ph_num, fsize))\n\t\t\treturn offset;\n\t}\n\n\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n\t\tif (descsz > 100)\n\t\t\tdescsz = 100;\n\t\tswitch (xnh_type) {\n\t    \tcase NT_NETBSD_VERSION:\n\t\t\treturn offset;\n\t\tcase NT_NETBSD_MARCH:\n\t\t\tif (*flags & FLAGS_DID_NETBSD_MARCH)\n\t\t\t\treturn offset;\n\t\t\t*flags |= FLAGS_DID_NETBSD_MARCH;\n\t\t\tif (file_printf(ms, \", compiled for: %.*s\",\n\t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tcase NT_NETBSD_CMODEL:\n\t\t\tif (*flags & FLAGS_DID_NETBSD_CMODEL)\n\t\t\t\treturn offset;\n\t\t\t*flags |= FLAGS_DID_NETBSD_CMODEL;\n\t\t\tif (file_printf(ms, \", compiler model: %.*s\",\n\t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*flags & FLAGS_DID_NETBSD_UNKNOWN)\n\t\t\t\treturn offset;\n\t\t\t*flags |= FLAGS_DID_NETBSD_UNKNOWN;\n\t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\t}\n\t\treturn offset;\n\t}\n\n\treturn offset;\n}\n\n/* SunOS 5.x hardware capability descriptions */\ntypedef struct cap_desc {\n\tuint64_t cd_mask;\n\tconst char *cd_name;\n} cap_desc_t;\n\nstatic const cap_desc_t cap_desc_sparc[] = {\n\t{ AV_SPARC_MUL32,\t\t\"MUL32\" },\n\t{ AV_SPARC_DIV32,\t\t\"DIV32\" },\n\t{ AV_SPARC_FSMULD,\t\t\"FSMULD\" },\n\t{ AV_SPARC_V8PLUS,\t\t\"V8PLUS\" },\n\t{ AV_SPARC_POPC,\t\t\"POPC\" },\n\t{ AV_SPARC_VIS,\t\t\t\"VIS\" },\n\t{ AV_SPARC_VIS2,\t\t\"VIS2\" },\n\t{ AV_SPARC_ASI_BLK_INIT,\t\"ASI_BLK_INIT\" },\n\t{ AV_SPARC_FMAF,\t\t\"FMAF\" },\n\t{ AV_SPARC_FJFMAU,\t\t\"FJFMAU\" },\n\t{ AV_SPARC_IMA,\t\t\t\"IMA\" },\n\t{ 0, NULL }\n};\n\nstatic const cap_desc_t cap_desc_386[] = {\n\t{ AV_386_FPU,\t\t\t\"FPU\" },\n\t{ AV_386_TSC,\t\t\t\"TSC\" },\n\t{ AV_386_CX8,\t\t\t\"CX8\" },\n\t{ AV_386_SEP,\t\t\t\"SEP\" },\n\t{ AV_386_AMD_SYSC,\t\t\"AMD_SYSC\" },\n\t{ AV_386_CMOV,\t\t\t\"CMOV\" },\n\t{ AV_386_MMX,\t\t\t\"MMX\" },\n\t{ AV_386_AMD_MMX,\t\t\"AMD_MMX\" },\n\t{ AV_386_AMD_3DNow,\t\t\"AMD_3DNow\" },\n\t{ AV_386_AMD_3DNowx,\t\t\"AMD_3DNowx\" },\n\t{ AV_386_FXSR,\t\t\t\"FXSR\" },\n\t{ AV_386_SSE,\t\t\t\"SSE\" },\n\t{ AV_386_SSE2,\t\t\t\"SSE2\" },\n\t{ AV_386_PAUSE,\t\t\t\"PAUSE\" },\n\t{ AV_386_SSE3,\t\t\t\"SSE3\" },\n\t{ AV_386_MON,\t\t\t\"MON\" },\n\t{ AV_386_CX16,\t\t\t\"CX16\" },\n\t{ AV_386_AHF,\t\t\t\"AHF\" },\n\t{ AV_386_TSCP,\t\t\t\"TSCP\" },\n\t{ AV_386_AMD_SSE4A,\t\t\"AMD_SSE4A\" },\n\t{ AV_386_POPCNT,\t\t\"POPCNT\" },\n\t{ AV_386_AMD_LZCNT,\t\t\"AMD_LZCNT\" },\n\t{ AV_386_SSSE3,\t\t\t\"SSSE3\" },\n\t{ AV_386_SSE4_1,\t\t\"SSE4.1\" },\n\t{ AV_386_SSE4_2,\t\t\"SSE4.2\" },\n\t{ 0, NULL }\n};\n\nprivate int\ndoshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n    size_t size, off_t fsize, int mach, int strtab, int *flags,\n    uint16_t *notecount)\n{\n\tElf32_Shdr sh32;\n\tElf64_Shdr sh64;\n\tint stripped = 1, has_debug_info = 0;\n\tsize_t nbadcap = 0;\n\tvoid *nbuf;\n\toff_t noff, coff, name_off;\n\tuint64_t cap_hw1 = 0;\t/* SunOS 5.x hardware capabilities */\n\tuint64_t cap_sf1 = 0;\t/* SunOS 5.x software capabilities */\n\tchar name[50];\n\tssize_t namesize;\n\n\tif (size != xsh_sizeof) {\n\t\tif (file_printf(ms, \", corrupted section header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/* Read offset of name section to be able to read section names later */\n\tif (pread(fd, xsh_addr, xsh_sizeof, CAST(off_t, (off + size * strtab)))\n\t    < (ssize_t)xsh_sizeof) {\n\t\tif (file_printf(ms, \", missing section headers\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tname_off = xsh_offset;\n\n\tfor ( ; num; num--) {\n\t\t/* Read the name of this section. */\n\t\tif ((namesize = pread(fd, name, sizeof(name) - 1, name_off + xsh_name)) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\tname[namesize] = '\\0';\n\t\tif (strcmp(name, \".debug_info\") == 0) {\n\t\t\thas_debug_info = 1;\n\t\t\tstripped = 0;\n\t\t}\n\n\t\tif (pread(fd, xsh_addr, xsh_sizeof, off) < (ssize_t)xsh_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xsh_type) {\n\t\tcase SHT_SYMTAB:\n#if 0\n\t\tcase SHT_DYNSYM:\n#endif\n\t\t\tstripped = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fsize != SIZE_UNKNOWN && xsh_offset > fsize) {\n\t\t\t\t/* Perhaps warn here */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xsh_type) {\n\t\tcase SHT_NOTE:\n\t\t\tif ((uintmax_t)(xsh_size + xsh_offset) >\n\t\t\t    (uintmax_t)fsize) {\n\t\t\t\tif (file_printf(ms,\n\t\t\t\t    \", note offset/size %#\" INTMAX_T_FORMAT\n\t\t\t\t    \"x+%#\" INTMAX_T_FORMAT \"x exceeds\"\n\t\t\t\t    \" file size %#\" INTMAX_T_FORMAT \"x\",\n\t\t\t\t    (uintmax_t)xsh_offset, (uintmax_t)xsh_size,\n\t\t\t\t    (uintmax_t)fsize) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\treturn 0; \n\t\t\t}\n\t\t\tif ((nbuf = malloc(xsh_size)) == NULL) {\n\t\t\t\tfile_error(ms, errno, \"Cannot allocate memory\"\n\t\t\t\t    \" for note\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (pread(fd, nbuf, xsh_size, xsh_offset) <\n\t\t\t    (ssize_t)xsh_size) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\tfree(nbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnoff = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (noff >= (off_t)xsh_size)\n\t\t\t\t\tbreak;\n\t\t\t\tnoff = donote(ms, nbuf, (size_t)noff,\n\t\t\t\t    xsh_size, clazz, swap, 4, flags, notecount,\n\t\t\t\t    fd, 0, 0, 0);\n\t\t\t\tif (noff == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(nbuf);\n\t\t\tbreak;\n\t\tcase SHT_SUNW_cap:\n\t\t\tswitch (mach) {\n\t\t\tcase EM_SPARC:\n\t\t\tcase EM_SPARCV9:\n\t\t\tcase EM_IA_64:\n\t\t\tcase EM_386:\n\t\t\tcase EM_AMD64:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\tif (nbadcap > 5)\n\t\t\t\tbreak;\n\t\t\tif (lseek(fd, xsh_offset, SEEK_SET) == (off_t)-1) {\n\t\t\t\tfile_badseek(ms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcoff = 0;\n\t\t\tfor (;;) {\n\t\t\t\tElf32_Cap cap32;\n\t\t\t\tElf64_Cap cap64;\n\t\t\t\tchar cbuf[/*CONSTCOND*/\n\t\t\t\t    MAX(sizeof cap32, sizeof cap64)];\n\t\t\t\tif ((coff += xcap_sizeof) > (off_t)xsh_size)\n\t\t\t\t\tbreak;\n\t\t\t\tif (read(fd, cbuf, (size_t)xcap_sizeof) !=\n\t\t\t\t    (ssize_t)xcap_sizeof) {\n\t\t\t\t\tfile_badread(ms);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (cbuf[0] == 'A') {\n#ifdef notyet\n\t\t\t\t\tchar *p = cbuf + 1;\n\t\t\t\t\tuint32_t len, tag;\n\t\t\t\t\tmemcpy(&len, p, sizeof(len));\n\t\t\t\t\tp += 4;\n\t\t\t\t\tlen = getu32(swap, len);\n\t\t\t\t\tif (memcmp(\"gnu\", p, 3) != 0) {\n\t\t\t\t\t    if (file_printf(ms,\n\t\t\t\t\t\t\", unknown capability %.3s\", p)\n\t\t\t\t\t\t== -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\tp += strlen(p) + 1;\n\t\t\t\t\ttag = *p++;\n\t\t\t\t\tmemcpy(&len, p, sizeof(len));\n\t\t\t\t\tp += 4;\n\t\t\t\t\tlen = getu32(swap, len);\n\t\t\t\t\tif (tag != 1) {\n\t\t\t\t\t    if (file_printf(ms, \", unknown gnu\"\n\t\t\t\t\t\t\" capability tag %d\", tag)\n\t\t\t\t\t\t== -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\t// gnu attributes \n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t(void)memcpy(xcap_addr, cbuf, xcap_sizeof);\n\t\t\t\tswitch (xcap_tag) {\n\t\t\t\tcase CA_SUNW_NULL:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CA_SUNW_HW_1:\n\t\t\t\t\tcap_hw1 |= xcap_val;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CA_SUNW_SF_1:\n\t\t\t\t\tcap_sf1 |= xcap_val;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (file_printf(ms,\n\t\t\t\t\t    \", with unknown capability \"\n\t\t\t\t\t    \"%#\" INT64_T_FORMAT \"x = %#\"\n\t\t\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t\t\t    (unsigned long long)xcap_tag,\n\t\t\t\t\t    (unsigned long long)xcap_val) == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tif (nbadcap++ > 2)\n\t\t\t\t\t\tcoff = xsh_size;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tskip:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_debug_info) {\n\t\tif (file_printf(ms, \", with debug_info\") == -1)\n\t\t\treturn -1;\n\t}\n\tif (file_printf(ms, \", %sstripped\", stripped ? \"\" : \"not \") == -1)\n\t\treturn -1;\n\tif (cap_hw1) {\n\t\tconst cap_desc_t *cdp;\n\t\tswitch (mach) {\n\t\tcase EM_SPARC:\n\t\tcase EM_SPARC32PLUS:\n\t\tcase EM_SPARCV9:\n\t\t\tcdp = cap_desc_sparc;\n\t\t\tbreak;\n\t\tcase EM_386:\n\t\tcase EM_IA_64:\n\t\tcase EM_AMD64:\n\t\t\tcdp = cap_desc_386;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcdp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (file_printf(ms, \", uses\") == -1)\n\t\t\treturn -1;\n\t\tif (cdp) {\n\t\t\twhile (cdp->cd_name) {\n\t\t\t\tif (cap_hw1 & cdp->cd_mask) {\n\t\t\t\t\tif (file_printf(ms,\n\t\t\t\t\t    \" %s\", cdp->cd_name) == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tcap_hw1 &= ~cdp->cd_mask;\n\t\t\t\t}\n\t\t\t\t++cdp;\n\t\t\t}\n\t\t\tif (cap_hw1)\n\t\t\t\tif (file_printf(ms,\n\t\t\t\t    \" unknown hardware capability %#\"\n\t\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t\t    (unsigned long long)cap_hw1) == -1)\n\t\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (file_printf(ms,\n\t\t\t    \" hardware capability %#\" INT64_T_FORMAT \"x\",\n\t\t\t    (unsigned long long)cap_hw1) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tif (cap_sf1) {\n\t\tif (cap_sf1 & SF1_SUNW_FPUSED) {\n\t\t\tif (file_printf(ms,\n\t\t\t    (cap_sf1 & SF1_SUNW_FPKNWN)\n\t\t\t    ? \", uses frame pointer\"\n\t\t\t    : \", not known to use frame pointer\") == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t\tcap_sf1 &= ~SF1_SUNW_MASK;\n\t\tif (cap_sf1)\n\t\t\tif (file_printf(ms,\n\t\t\t    \", with unknown software capability %#\"\n\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t    (unsigned long long)cap_sf1) == -1)\n\t\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Look through the program headers of an executable image, searching\n * for a PT_INTERP section; if one is found, it's dynamically linked,\n * otherwise it's statically linked.\n */\nprivate int\ndophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int sh_num, int *flags,\n    uint16_t *notecount)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tconst char *linking_style = \"statically\";\n\tconst char *interp = \"\";\n\tunsigned char nbuf[BUFSIZ];\n\tchar ibuf[BUFSIZ];\n\tssize_t bufsize;\n\tsize_t offset, align, len;\n\t\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n  \tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff += size;\n\t\tbufsize = 0;\n\t\talign = 4;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_DYNAMIC:\n\t\t\tlinking_style = \"dynamically\";\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\tif (sh_num)\t/* Did this through section headers */\n\t\t\t\tcontinue;\n\t\t\tif (((align = xph_align) & 0x80000000UL) != 0 ||\n\t\t\t    align < 4) {\n\t\t\t\tif (file_printf(ms, \n\t\t\t\t    \", invalid note alignment %#lx\",\n\t\t\t\t    (unsigned long)align) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\talign = 4;\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tcase PT_INTERP:\n\t\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz\n\t\t\t    : sizeof(nbuf);\n\t\t\tbufsize = pread(fd, nbuf, len, xph_offset);\n\t\t\tif (bufsize == -1) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t\t/* Maybe warn here? */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_INTERP:\n\t\t\tif (bufsize && nbuf[0]) {\n\t\t\t\tnbuf[bufsize - 1] = '\\0';\n\t\t\t\tinterp = (const char *)nbuf;\n\t\t\t} else\n\t\t\t\tinterp = \"*empty*\";\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\t/*\n\t\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t\t * in the section.\n\t\t\t */\n\t\t\toffset = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\t\tbreak;\n\t\t\t\toffset = donote(ms, nbuf, offset,\n\t\t\t\t    (size_t)bufsize, clazz, swap, align,\n\t\t\t\t    flags, notecount, fd, 0, 0, 0);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (file_printf(ms, \", %s linked\", linking_style)\n\t    == -1)\n\t\treturn -1;\n\tif (interp[0])\n\t\tif (file_printf(ms, \", interpreter %s\",\n\t\t    file_printable(ibuf, sizeof(ibuf), interp)) == -1)\n\t\t\treturn -1;\n\treturn 0;\n}\n\n\nprotected int\nfile_tryelf(struct magic_set *ms, int fd, const unsigned char *buf,\n    size_t nbytes)\n{\n\tunion {\n\t\tint32_t l;\n\t\tchar c[sizeof (int32_t)];\n\t} u;\n\tint clazz;\n\tint swap;\n\tstruct stat st;\n\toff_t fsize;\n\tint flags = 0;\n\tElf32_Ehdr elf32hdr;\n\tElf64_Ehdr elf64hdr;\n\tuint16_t type, phnum, shnum, notecount;\n\n\tif (ms->flags & (MAGIC_MIME|MAGIC_APPLE|MAGIC_EXTENSION))\n\t\treturn 0;\n\t/*\n\t * ELF executables have multiple section headers in arbitrary\n\t * file locations and thus file(1) cannot determine it from easily.\n\t * Instead we traverse thru all section headers until a symbol table\n\t * one is found or else the binary is stripped.\n\t * Return immediately if it's not ELF (so we avoid pipe2file unless needed).\n\t */\n\tif (buf[EI_MAG0] != ELFMAG0\n\t    || (buf[EI_MAG1] != ELFMAG1 && buf[EI_MAG1] != OLFMAG1)\n\t    || buf[EI_MAG2] != ELFMAG2 || buf[EI_MAG3] != ELFMAG3)\n\t\treturn 0;\n\n\t/*\n\t * If we cannot seek, it must be a pipe, socket or fifo.\n\t */\n\tif((lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) && (errno == ESPIPE))\n\t\tfd = file_pipe2file(ms, fd, buf, nbytes);\n\n\tif (fstat(fd, &st) == -1) {\n  \t\tfile_badread(ms);\n\t\treturn -1;\n\t}\n\tif (S_ISREG(st.st_mode) || st.st_size != 0)\n\t\tfsize = st.st_size;\n\telse\n\t\tfsize = SIZE_UNKNOWN;\n\n\tclazz = buf[EI_CLASS];\n\n\tswitch (clazz) {\n\tcase ELFCLASS32:\n#undef elf_getu\n#define elf_getu(a, b)\telf_getu32(a, b)\n#undef elfhdr\n#define elfhdr elf32hdr\n#include \"elfclass.h\"\n\tcase ELFCLASS64:\n#undef elf_getu\n#define elf_getu(a, b)\telf_getu64(a, b)\n#undef elfhdr\n#define elfhdr elf64hdr\n#include \"elfclass.h\"\n\tdefault:\n\t    if (file_printf(ms, \", unknown class %d\", clazz) == -1)\n\t\t    return -1;\n\t    break;\n\t}\n\treturn 0;\n}\n#endif\n"], "fixing_code": ["/*\n * Copyright (c) Christos Zoulas 2003.\n * All Rights Reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice immediately at the beginning of the file, without modification,\n *    this list of conditions, and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  \n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#include \"file.h\"\n\n#ifndef lint\nFILE_RCSID(\"@(#)$File: readelf.c,v 1.138 2017/08/27 07:55:02 christos Exp $\")\n#endif\n\n#ifdef BUILTIN_ELF\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"readelf.h\"\n#include \"magic.h\"\n\n#ifdef\tELFCORE\nprivate int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t,\n    off_t, int *, uint16_t *);\n#endif\nprivate int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t,\n    off_t, int, int *, uint16_t *);\nprivate int doshn(struct magic_set *, int, int, int, off_t, int, size_t,\n    off_t, int, int, int *, uint16_t *);\nprivate size_t donote(struct magic_set *, void *, size_t, size_t, int,\n    int, size_t, int *, uint16_t *, int, off_t, int, off_t);\n\n#define\tELF_ALIGN(a)\t((((a) + align - 1) / align) * align)\n\n#define isquote(c) (strchr(\"'\\\"`\", (c)) != NULL)\n\nprivate uint16_t getu16(int, uint16_t);\nprivate uint32_t getu32(int, uint32_t);\nprivate uint64_t getu64(int, uint64_t);\n\n#define MAX_PHNUM\t128\n#define\tMAX_SHNUM\t32768\n#define SIZE_UNKNOWN\t((off_t)-1)\n\nprivate int\ntoomany(struct magic_set *ms, const char *name, uint16_t num)\n{\n\tif (file_printf(ms, \", too many %s (%u)\", name, num\n\t    ) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\nprivate uint16_t\ngetu16(int swap, uint16_t value)\n{\n\tunion {\n\t\tuint16_t ui;\n\t\tchar c[2];\n\t} retval, tmpval;\n\n\tif (swap) {\n\t\ttmpval.ui = value;\n\n\t\tretval.c[0] = tmpval.c[1];\n\t\tretval.c[1] = tmpval.c[0];\n\t\t\n\t\treturn retval.ui;\n\t} else\n\t\treturn value;\n}\n\nprivate uint32_t\ngetu32(int swap, uint32_t value)\n{\n\tunion {\n\t\tuint32_t ui;\n\t\tchar c[4];\n\t} retval, tmpval;\n\n\tif (swap) {\n\t\ttmpval.ui = value;\n\n\t\tretval.c[0] = tmpval.c[3];\n\t\tretval.c[1] = tmpval.c[2];\n\t\tretval.c[2] = tmpval.c[1];\n\t\tretval.c[3] = tmpval.c[0];\n\t\t\n\t\treturn retval.ui;\n\t} else\n\t\treturn value;\n}\n\nprivate uint64_t\ngetu64(int swap, uint64_t value)\n{\n\tunion {\n\t\tuint64_t ui;\n\t\tchar c[8];\n\t} retval, tmpval;\n\n\tif (swap) {\n\t\ttmpval.ui = value;\n\n\t\tretval.c[0] = tmpval.c[7];\n\t\tretval.c[1] = tmpval.c[6];\n\t\tretval.c[2] = tmpval.c[5];\n\t\tretval.c[3] = tmpval.c[4];\n\t\tretval.c[4] = tmpval.c[3];\n\t\tretval.c[5] = tmpval.c[2];\n\t\tretval.c[6] = tmpval.c[1];\n\t\tretval.c[7] = tmpval.c[0];\n\t\t\n\t\treturn retval.ui;\n\t} else\n\t\treturn value;\n}\n\n#define elf_getu16(swap, value) getu16(swap, value)\n#define elf_getu32(swap, value) getu32(swap, value)\n#define elf_getu64(swap, value) getu64(swap, value)\n\n#define xsh_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? (void *)&sh32\t\t\t\\\n\t\t\t : (void *)&sh64)\n#define xsh_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(sh32)\t\t\t\t\\\n\t\t\t : sizeof(sh64))\n#define xsh_size\t(size_t)(clazz == ELFCLASS32\t\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_size)\t\\\n\t\t\t : elf_getu64(swap, sh64.sh_size))\n#define xsh_offset\t(off_t)(clazz == ELFCLASS32\t\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_offset)\t\\\n\t\t\t : elf_getu64(swap, sh64.sh_offset))\n#define xsh_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_type)\t\\\n\t\t\t : elf_getu32(swap, sh64.sh_type))\n#define xsh_name    \t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, sh32.sh_name)\t\\\n\t\t\t : elf_getu32(swap, sh64.sh_name))\n#define xph_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? (void *) &ph32\t\t\t\\\n\t\t\t : (void *) &ph64)\n#define xph_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(ph32)\t\t\t\t\\\n\t\t\t : sizeof(ph64))\n#define xph_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_type)\t\\\n\t\t\t : elf_getu32(swap, ph64.p_type))\n#define xph_offset\t(off_t)(clazz == ELFCLASS32\t\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_offset)\t\\\n\t\t\t : elf_getu64(swap, ph64.p_offset))\n#define xph_align\t(size_t)((clazz == ELFCLASS32\t\t\\\n\t\t\t ? (off_t) (ph32.p_align ? \t\t\\\n\t\t\t    elf_getu32(swap, ph32.p_align) : 4) \\\n\t\t\t : (off_t) (ph64.p_align ?\t\t\\\n\t\t\t    elf_getu64(swap, ph64.p_align) : 4)))\n#define xph_vaddr\t(size_t)((clazz == ELFCLASS32\t\t\\\n\t\t\t ? (off_t) (ph32.p_vaddr ? \t\t\\\n\t\t\t    elf_getu32(swap, ph32.p_vaddr) : 4) \\\n\t\t\t : (off_t) (ph64.p_vaddr ?\t\t\\\n\t\t\t    elf_getu64(swap, ph64.p_vaddr) : 4)))\n#define xph_filesz\t(size_t)((clazz == ELFCLASS32\t\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_filesz)\t\\\n\t\t\t : elf_getu64(swap, ph64.p_filesz)))\n#define xnh_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? (void *)&nh32\t\t\t\\\n\t\t\t : (void *)&nh64)\n#define xph_memsz\t(size_t)((clazz == ELFCLASS32\t\t\\\n\t\t\t ? elf_getu32(swap, ph32.p_memsz)\t\\\n\t\t\t : elf_getu64(swap, ph64.p_memsz)))\n#define xnh_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(nh32)\t\t\t\t\\\n\t\t\t : sizeof(nh64))\n#define xnh_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, nh32.n_type)\t\\\n\t\t\t : elf_getu32(swap, nh64.n_type))\n#define xnh_namesz\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, nh32.n_namesz)\t\\\n\t\t\t : elf_getu32(swap, nh64.n_namesz))\n#define xnh_descsz\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, nh32.n_descsz)\t\\\n\t\t\t : elf_getu32(swap, nh64.n_descsz))\n#define prpsoffsets(i)\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? prpsoffsets32[i]\t\t\t\\\n\t\t\t : prpsoffsets64[i])\n#define xcap_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? (void *)&cap32\t\t\t\\\n\t\t\t : (void *)&cap64)\n#define xcap_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof cap32\t\t\t\t\\\n\t\t\t : sizeof cap64)\n#define xcap_tag\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, cap32.c_tag)\t\\\n\t\t\t : elf_getu64(swap, cap64.c_tag))\n#define xcap_val\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, cap32.c_un.c_val)\t\\\n\t\t\t : elf_getu64(swap, cap64.c_un.c_val))\n#define xauxv_addr\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? (void *)&auxv32\t\t\t\\\n\t\t\t : (void *)&auxv64)\n#define xauxv_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? sizeof(auxv32)\t\t\t\\\n\t\t\t : sizeof(auxv64))\n#define xauxv_type\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, auxv32.a_type)\t\\\n\t\t\t : elf_getu64(swap, auxv64.a_type))\n#define xauxv_val\t(clazz == ELFCLASS32\t\t\t\\\n\t\t\t ? elf_getu32(swap, auxv32.a_v)\t\t\\\n\t\t\t : elf_getu64(swap, auxv64.a_v))\n\n#ifdef ELFCORE\n/*\n * Try larger offsets first to avoid false matches\n * from earlier data that happen to look like strings.\n */\nstatic const size_t\tprpsoffsets32[] = {\n#ifdef USE_NT_PSINFO\n\t104,\t\t/* SunOS 5.x (command line) */\n\t88,\t\t/* SunOS 5.x (short name) */\n#endif /* USE_NT_PSINFO */\n\n\t100,\t\t/* SunOS 5.x (command line) */\n\t84,\t\t/* SunOS 5.x (short name) */\n\n\t44,\t\t/* Linux (command line) */\n\t28,\t\t/* Linux 2.0.36 (short name) */\n\n\t8,\t\t/* FreeBSD */\n};\n\nstatic const size_t\tprpsoffsets64[] = {\n#ifdef USE_NT_PSINFO\n\t152,\t\t/* SunOS 5.x (command line) */\n\t136,\t\t/* SunOS 5.x (short name) */\n#endif /* USE_NT_PSINFO */\n\n\t136,\t\t/* SunOS 5.x, 64-bit (command line) */\n\t120,\t\t/* SunOS 5.x, 64-bit (short name) */\n\n\t56,\t\t/* Linux (command line) */\n\t40,             /* Linux (tested on core from 2.4.x, short name) */\n\n\t16,\t\t/* FreeBSD, 64-bit */\n};\n\n#define\tNOFFSETS32\t(sizeof prpsoffsets32 / sizeof prpsoffsets32[0])\n#define NOFFSETS64\t(sizeof prpsoffsets64 / sizeof prpsoffsets64[0])\n\n#define NOFFSETS\t(clazz == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)\n\n/*\n * Look through the program headers of an executable image, searching\n * for a PT_NOTE section of type NT_PRPSINFO, with a name \"CORE\" or\n * \"FreeBSD\"; if one is found, try looking in various places in its\n * contents for a 16-character string containing only printable\n * characters - if found, that string should be the name of the program\n * that dropped core.  Note: right after that 16-character string is,\n * at least in SunOS 5.x (and possibly other SVR4-flavored systems) and\n * Linux, a longer string (80 characters, in 5.x, probably other\n * SVR4-flavored systems, and Linux) containing the start of the\n * command line for that program.\n *\n * SunOS 5.x core files contain two PT_NOTE sections, with the types\n * NT_PRPSINFO (old) and NT_PSINFO (new).  These structs contain the\n * same info about the command name and command line, so it probably\n * isn't worthwhile to look for NT_PSINFO, but the offsets are provided\n * above (see USE_NT_PSINFO), in case we ever decide to do so.  The\n * NT_PRPSINFO and NT_PSINFO sections are always in order and adjacent;\n * the SunOS 5.x file command relies on this (and prefers the latter).\n *\n * The signal number probably appears in a section of type NT_PRSTATUS,\n * but that's also rather OS-dependent, in ways that are harder to\n * dissect with heuristics, so I'm not bothering with the signal number.\n * (I suppose the signal number could be of interest in situations where\n * you don't have the binary of the program that dropped core; if you\n * *do* have that binary, the debugger will probably tell you what\n * signal it was.)\n */\n\n#define\tOS_STYLE_SVR4\t\t0\n#define\tOS_STYLE_FREEBSD\t1\n#define\tOS_STYLE_NETBSD\t\t2\n\nprivate const char os_style_names[][8] = {\n\t\"SVR4\",\n\t\"FreeBSD\",\n\t\"NetBSD\",\n};\n\n#define FLAGS_CORE_STYLE\t\t0x003\n\n#define FLAGS_DID_CORE\t\t\t0x004\n#define FLAGS_DID_OS_NOTE\t\t0x008\n#define FLAGS_DID_BUILD_ID\t\t0x010\n#define FLAGS_DID_CORE_STYLE\t\t0x020\n#define FLAGS_DID_NETBSD_PAX\t\t0x040\n#define FLAGS_DID_NETBSD_MARCH\t\t0x080\n#define FLAGS_DID_NETBSD_CMODEL\t\t0x100\n#define FLAGS_DID_NETBSD_UNKNOWN\t0x200\n#define FLAGS_IS_CORE\t\t\t0x400\n#define FLAGS_DID_AUXV\t\t\t0x800\n\nprivate int\ndophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int *flags, uint16_t *notecount)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tsize_t offset, len;\n\tunsigned char nbuf[BUFSIZ];\n\tssize_t bufsize;\n\toff_t ph_off = off;\n\tint ph_num = num;\n\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Loop through all the program headers.\n\t */\n\tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\n\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t/* Perhaps warn here */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (xph_type != PT_NOTE)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t * in the section.\n\t\t */\n\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz : sizeof(nbuf);\n\t\tif ((bufsize = pread(fd, nbuf, len, xph_offset)) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toffset = 0;\n\t\tfor (;;) {\n\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\tbreak;\n\t\t\toffset = donote(ms, nbuf, offset, (size_t)bufsize,\n\t\t\t    clazz, swap, 4, flags, notecount, fd, ph_off,\n\t\t\t    ph_num, fsize);\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\nstatic void\ndo_note_netbsd_version(struct magic_set *ms, int swap, void *v)\n{\n\tuint32_t desc;\n\t(void)memcpy(&desc, v, sizeof(desc));\n\tdesc = elf_getu32(swap, desc);\n\n\tif (file_printf(ms, \", for NetBSD\") == -1)\n\t\treturn;\n\t/*\n\t * The version number used to be stuck as 199905, and was thus\n\t * basically content-free.  Newer versions of NetBSD have fixed\n\t * this and now use the encoding of __NetBSD_Version__:\n\t *\n\t *\tMMmmrrpp00\n\t *\n\t * M = major version\n\t * m = minor version\n\t * r = release [\"\",A-Z,Z[A-Z] but numeric]\n\t * p = patchlevel\n\t */\n\tif (desc > 100000000U) {\n\t\tuint32_t ver_patch = (desc / 100) % 100;\n\t\tuint32_t ver_rel = (desc / 10000) % 100;\n\t\tuint32_t ver_min = (desc / 1000000) % 100;\n\t\tuint32_t ver_maj = desc / 100000000;\n\n\t\tif (file_printf(ms, \" %u.%u\", ver_maj, ver_min) == -1)\n\t\t\treturn;\n\t\tif (ver_rel == 0 && ver_patch != 0) {\n\t\t\tif (file_printf(ms, \".%u\", ver_patch) == -1)\n\t\t\t\treturn;\n\t\t} else if (ver_rel != 0) {\n\t\t\twhile (ver_rel > 26) {\n\t\t\t\tif (file_printf(ms, \"Z\") == -1)\n\t\t\t\t\treturn;\n\t\t\t\tver_rel -= 26;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%c\", 'A' + ver_rel - 1)\n\t\t\t    == -1)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void\ndo_note_freebsd_version(struct magic_set *ms, int swap, void *v)\n{\n\tuint32_t desc;\n\n\t(void)memcpy(&desc, v, sizeof(desc));\n\tdesc = elf_getu32(swap, desc);\n\tif (file_printf(ms, \", for FreeBSD\") == -1)\n\t\treturn;\n\n\t/*\n\t * Contents is __FreeBSD_version, whose relation to OS\n\t * versions is defined by a huge table in the Porter's\n\t * Handbook.  This is the general scheme:\n\t * \n\t * Releases:\n\t * \tMmp000 (before 4.10)\n\t * \tMmi0p0 (before 5.0)\n\t * \tMmm0p0\n\t * \n\t * Development branches:\n\t * \tMmpxxx (before 4.6)\n\t * \tMmp1xx (before 4.10)\n\t * \tMmi1xx (before 5.0)\n\t * \tM000xx (pre-M.0)\n\t * \tMmm1xx\n\t * \n\t * M = major version\n\t * m = minor version\n\t * i = minor version increment (491000 -> 4.10)\n\t * p = patchlevel\n\t * x = revision\n\t * \n\t * The first release of FreeBSD to use ELF by default\n\t * was version 3.0.\n\t */\n\tif (desc == 460002) {\n\t\tif (file_printf(ms, \" 4.6.2\") == -1)\n\t\t\treturn;\n\t} else if (desc < 460100) {\n\t\tif (file_printf(ms, \" %d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10) == -1)\n\t\t\treturn;\n\t\tif (desc / 1000 % 10 > 0)\n\t\t\tif (file_printf(ms, \".%d\", desc / 1000 % 10) == -1)\n\t\t\t\treturn;\n\t\tif ((desc % 1000 > 0) || (desc % 100000 == 0))\n\t\t\tif (file_printf(ms, \" (%d)\", desc) == -1)\n\t\t\t\treturn;\n\t} else if (desc < 500000) {\n\t\tif (file_printf(ms, \" %d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10 + desc / 1000 % 10) == -1)\n\t\t\treturn;\n\t\tif (desc / 100 % 10 > 0) {\n\t\t\tif (file_printf(ms, \" (%d)\", desc) == -1)\n\t\t\t\treturn;\n\t\t} else if (desc / 10 % 10 > 0) {\n\t\t\tif (file_printf(ms, \".%d\", desc / 10 % 10) == -1)\n\t\t\t\treturn;\n\t\t}\n\t} else {\n\t\tif (file_printf(ms, \" %d.%d\", desc / 100000,\n\t\t    desc / 1000 % 100) == -1)\n\t\t\treturn;\n\t\tif ((desc / 100 % 10 > 0) ||\n\t\t    (desc % 100000 / 100 == 0)) {\n\t\t\tif (file_printf(ms, \" (%d)\", desc) == -1)\n\t\t\t\treturn;\n\t\t} else if (desc / 10 % 10 > 0) {\n\t\t\tif (file_printf(ms, \".%d\", desc / 10 % 10) == -1)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\nprivate int\n/*ARGSUSED*/\ndo_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 && descsz <= 20)) {\n\t\tuint8_t desc[20];\n\t\tconst char *btype;\n\t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\ndo_os_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 5 && strcmp((char *)&nbuf[noff], \"SuSE\") == 0 &&\n\t    type == NT_GNU_VERSION && descsz == 2) {\n\t    *flags |= FLAGS_DID_OS_NOTE;\n\t    file_printf(ms, \", for SuSE %d.%d\", nbuf[doff], nbuf[doff + 1]);\n\t    return 1;\n\t}\n\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_VERSION && descsz == 16) {\n\t\tuint32_t desc[4];\n\t\t(void)memcpy(desc, &nbuf[doff], sizeof(desc));\n\n\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\tif (file_printf(ms, \", for GNU/\") == -1)\n\t\t\treturn 1;\n\t\tswitch (elf_getu32(swap, desc[0])) {\n\t\tcase GNU_OS_LINUX:\n\t\t\tif (file_printf(ms, \"Linux\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_HURD:\n\t\t\tif (file_printf(ms, \"Hurd\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_SOLARIS:\n\t\t\tif (file_printf(ms, \"Solaris\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_KFREEBSD:\n\t\t\tif (file_printf(ms, \"kFreeBSD\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tcase GNU_OS_KNETBSD:\n\t\t\tif (file_printf(ms, \"kNetBSD\") == -1)\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (file_printf(ms, \"<unknown>\") == -1)\n\t\t\t\treturn 1; \n\t\t}\n\t\tif (file_printf(ms, \" %d.%d.%d\", elf_getu32(swap, desc[1]),\n\t\t    elf_getu32(swap, desc[2]), elf_getu32(swap, desc[3])) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\n\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n\t    \tif (type == NT_NETBSD_VERSION && descsz == 4) {\n\t\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\t\tdo_note_netbsd_version(ms, swap, &nbuf[doff]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0) {\n\t    \tif (type == NT_FREEBSD_VERSION && descsz == 4) {\n\t\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\t\tdo_note_freebsd_version(ms, swap, &nbuf[doff]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"OpenBSD\") == 0 &&\n\t    type == NT_OPENBSD_VERSION && descsz == 4) {\n\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\tif (file_printf(ms, \", for OpenBSD\") == -1)\n\t\t\treturn 1;\n\t\t/* Content of note is always 0 */\n\t\treturn 1;\n\t}\n\n\tif (namesz == 10 && strcmp((char *)&nbuf[noff], \"DragonFly\") == 0 &&\n\t    type == NT_DRAGONFLY_VERSION && descsz == 4) {\n\t\tuint32_t desc;\n\t\t*flags |= FLAGS_DID_OS_NOTE;\n\t\tif (file_printf(ms, \", for DragonFly\") == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n\t\tdesc = elf_getu32(swap, desc);\n\t\tif (file_printf(ms, \" %d.%d.%d\", desc / 100000,\n\t\t    desc / 10000 % 10, desc % 10000) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\ndo_pax_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"PaX\") == 0 &&\n\t    type == NT_NETBSD_PAX && descsz == 4) {\n\t\tstatic const char *pax[] = {\n\t\t    \"+mprotect\",\n\t\t    \"-mprotect\",\n\t\t    \"+segvguard\",\n\t\t    \"-segvguard\",\n\t\t    \"+ASLR\",\n\t\t    \"-ASLR\",\n\t\t};\n\t\tuint32_t desc;\n\t\tsize_t i;\n\t\tint did = 0;\n\n\t\t*flags |= FLAGS_DID_NETBSD_PAX;\n\t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n\t\tdesc = elf_getu32(swap, desc);\n\n\t\tif (desc && file_printf(ms, \", PaX: \") == -1)\n\t\t\treturn 1;\n\n\t\tfor (i = 0; i < __arraycount(pax); i++) {\n\t\t\tif (((1 << (int)i) & desc) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (file_printf(ms, \"%s%s\", did++ ? \",\" : \"\",\n\t\t\t    pax[i]) == -1)\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nprivate int\ndo_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags, size_t size, int clazz)\n{\n#ifdef ELFCORE\n\tint os_style = -1;\n\t/*\n\t * Sigh.  The 2.0.36 kernel in Debian 2.1, at\n\t * least, doesn't correctly implement name\n\t * sections, in core dumps, as specified by\n\t * the \"Program Linking\" section of \"UNIX(R) System\n\t * V Release 4 Programmer's Guide: ANSI C and\n\t * Programming Support Tools\", because my copy\n\t * clearly says \"The first 'namesz' bytes in 'name'\n\t * contain a *null-terminated* [emphasis mine]\n\t * character representation of the entry's owner\n\t * or originator\", but the 2.0.36 kernel code\n\t * doesn't include the terminating null in the\n\t * name....\n\t */\n\tif ((namesz == 4 && strncmp((char *)&nbuf[noff], \"CORE\", 4) == 0) ||\n\t    (namesz == 5 && strcmp((char *)&nbuf[noff], \"CORE\") == 0)) {\n\t\tos_style = OS_STYLE_SVR4;\n\t} \n\n\tif ((namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0)) {\n\t\tos_style = OS_STYLE_FREEBSD;\n\t}\n\n\tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], \"NetBSD-CORE\", 11)\n\t    == 0)) {\n\t\tos_style = OS_STYLE_NETBSD;\n\t}\n\n\tif (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {\n\t\tif (file_printf(ms, \", %s-style\", os_style_names[os_style])\n\t\t    == -1)\n\t\t\treturn 1;\n\t\t*flags |= FLAGS_DID_CORE_STYLE;\n\t\t*flags |= os_style;\n\t}\n\n\tswitch (os_style) {\n\tcase OS_STYLE_NETBSD:\n\t\tif (type == NT_NETBSD_CORE_PROCINFO) {\n\t\t\tchar sbuf[512];\n\t\t\tstruct NetBSD_elfcore_procinfo pi;\n\t\t\tmemset(&pi, 0, sizeof(pi));\n\t\t\tmemcpy(&pi, nbuf + doff, descsz);\n\n\t\t\tif (file_printf(ms, \", from '%.31s', pid=%u, uid=%u, \"\n\t\t\t    \"gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)\",\n\t\t\t    file_printable(sbuf, sizeof(sbuf),\n\t\t\t    CAST(char *, pi.cpi_name)),\n\t\t\t    elf_getu32(swap, pi.cpi_pid),\n\t\t\t    elf_getu32(swap, pi.cpi_euid),\n\t\t\t    elf_getu32(swap, pi.cpi_egid),\n\t\t\t    elf_getu32(swap, pi.cpi_nlwps),\n\t\t\t    elf_getu32(swap, pi.cpi_siglwp),\n\t\t\t    elf_getu32(swap, pi.cpi_signo),\n\t\t\t    elf_getu32(swap, pi.cpi_sigcode)) == -1)\n\t\t\t\treturn 1;\n\n\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n\t\t\tsize_t i, j;\n\t\t\tunsigned char c;\n\t\t\t/*\n\t\t\t * Extract the program name.  We assume\n\t\t\t * it to be 16 characters (that's what it\n\t\t\t * is in SunOS 5.x and Linux).\n\t\t\t *\n\t\t\t * Unfortunately, it's at a different offset\n\t\t\t * in various OSes, so try multiple offsets.\n\t\t\t * If the characters aren't all printable,\n\t\t\t * reject it.\n\t\t\t */\n\t\t\tfor (i = 0; i < NOFFSETS; i++) {\n\t\t\t\tunsigned char *cname, *cp;\n\t\t\t\tsize_t reloffset = prpsoffsets(i);\n\t\t\t\tsize_t noffset = doff + reloffset;\n\t\t\t\tsize_t k;\n\t\t\t\tfor (j = 0; j < 16; j++, noffset++,\n\t\t\t\t    reloffset++) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the buffer; if\n\t\t\t\t\t * we are, just give up.\n\t\t\t\t\t */\n\t\t\t\t\tif (noffset >= size)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Make sure we're not past\n\t\t\t\t\t * the end of the contents;\n\t\t\t\t\t * if we are, this obviously\n\t\t\t\t\t * isn't the right offset.\n\t\t\t\t\t */\n\t\t\t\t\tif (reloffset >= descsz)\n\t\t\t\t\t\tgoto tryanother;\n\n\t\t\t\t\tc = nbuf[noffset];\n\t\t\t\t\tif (c == '\\0') {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A '\\0' at the\n\t\t\t\t\t\t * beginning is\n\t\t\t\t\t\t * obviously wrong.\n\t\t\t\t\t\t * Any other '\\0'\n\t\t\t\t\t\t * means we're done.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * A nonprintable\n\t\t\t\t\t\t * character is also\n\t\t\t\t\t\t * wrong.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (!isprint(c) || isquote(c))\n\t\t\t\t\t\t\tgoto tryanother;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Well, that worked.\n\t\t\t\t */\n\n\t\t\t\t/*\n\t\t\t\t * Try next offsets, in case this match is\n\t\t\t\t * in the middle of a string.\n\t\t\t\t */\n\t\t\t\tfor (k = i + 1 ; k < NOFFSETS; k++) {\n\t\t\t\t\tsize_t no;\n\t\t\t\t\tint adjust = 1;\n\t\t\t\t\tif (prpsoffsets(k) >= prpsoffsets(i))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (no = doff + prpsoffsets(k);\n\t\t\t\t\t     no < doff + prpsoffsets(i); no++)\n\t\t\t\t\t\tadjust = adjust\n\t\t\t\t\t\t         && isprint(nbuf[no]);\n\t\t\t\t\tif (adjust)\n\t\t\t\t\t\ti = k;\n\t\t\t\t}\n\n\t\t\t\tcname = (unsigned char *)\n\t\t\t\t    &nbuf[doff + prpsoffsets(i)];\n\t\t\t\tfor (cp = cname; *cp && isprint(*cp); cp++)\n\t\t\t\t\tcontinue;\n\t\t\t\t/*\n\t\t\t\t * Linux apparently appends a space at the end\n\t\t\t\t * of the command line: remove it.\n\t\t\t\t */\n\t\t\t\twhile (cp > cname && isspace(cp[-1]))\n\t\t\t\t\tcp--;\n\t\t\t\tif (file_printf(ms, \", from '%.*s'\",\n\t\t\t\t    (int)(cp - cname), cname) == -1)\n\t\t\t\t\treturn 1;\n\t\t\t\t*flags |= FLAGS_DID_CORE;\n\t\t\t\treturn 1;\n\n\t\t\ttryanother:\n\t\t\t\t;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\treturn 0;\n}\n\nprivate off_t\nget_offset_from_virtaddr(struct magic_set *ms, int swap, int clazz, int fd,\n    off_t off, int num, off_t fsize, uint64_t virtaddr)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\n\t/*\n\t * Loop through all the program headers and find the header with\n\t * virtual address in which the \"virtaddr\" belongs to.\n\t */\n\tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += xph_sizeof;\n\n\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t/* Perhaps warn here */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (virtaddr >= xph_vaddr && virtaddr < xph_vaddr + xph_filesz)\n\t\t\treturn xph_offset + (virtaddr - xph_vaddr);\n\t}\n\treturn 0;\n}\n\nprivate size_t\nget_string_on_virtaddr(struct magic_set *ms,\n    int swap, int clazz, int fd, off_t ph_off, int ph_num,\n    off_t fsize, uint64_t virtaddr, char *buf, ssize_t buflen)\n{\n\tchar *bptr;\n\toff_t offset;\n\n\tif (buflen == 0)\n\t\treturn 0;\n\n\toffset = get_offset_from_virtaddr(ms, swap, clazz, fd, ph_off, ph_num,\n\t    fsize, virtaddr);\n\tif ((buflen = pread(fd, buf, CAST(size_t, buflen), offset)) <= 0) {\n\t\tfile_badread(ms);\n\t\treturn 0;\n\t}\n\n\tbuf[buflen - 1] = '\\0';\n\n\t/* We expect only printable characters, so return if buffer contains\n\t * non-printable character before the '\\0' or just '\\0'. */\n\tfor (bptr = buf; *bptr && isprint((unsigned char)*bptr); bptr++)\n\t\tcontinue;\n\tif (*bptr != '\\0')\n\t\treturn 0;\n\n\treturn bptr - buf;\n}\n\n\nprivate int\ndo_auxv_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz __attribute__((__unused__)),\n    uint32_t descsz __attribute__((__unused__)),\n    size_t noff __attribute__((__unused__)), size_t doff,\n    int *flags, size_t size __attribute__((__unused__)), int clazz,\n    int fd, off_t ph_off, int ph_num, off_t fsize)\n{\n#ifdef ELFCORE\n\tAux32Info auxv32;\n\tAux64Info auxv64;\n\tsize_t elsize = xauxv_sizeof;\n\tconst char *tag;\n\tint is_string;\n\tsize_t nval;\n\n\tif ((*flags & (FLAGS_IS_CORE|FLAGS_DID_CORE_STYLE)) !=\n\t    (FLAGS_IS_CORE|FLAGS_DID_CORE_STYLE))\n\t\treturn 0;\n\n\tswitch (*flags & FLAGS_CORE_STYLE) {\n\tcase OS_STYLE_SVR4:\n\t\tif (type != NT_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n#ifdef notyet\n\tcase OS_STYLE_NETBSD:\n\t\tif (type != NT_NETBSD_CORE_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase OS_STYLE_FREEBSD:\n\t\tif (type != NT_FREEBSD_PROCSTAT_AUXV)\n\t\t\treturn 0;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t*flags |= FLAGS_DID_AUXV;\n\n\tnval = 0;\n\tfor (size_t off = 0; off + elsize <= descsz; off += elsize) {\n\t\t(void)memcpy(xauxv_addr, &nbuf[doff + off], xauxv_sizeof);\n\t\t/* Limit processing to 50 vector entries to prevent DoS */\n\t\tif (nval++ >= 50) {\n\t\t\tfile_error(ms, 0, \"Too many ELF Auxv elements\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tswitch(xauxv_type) {\n\t\tcase AT_LINUX_EXECFN:\n\t\t\tis_string = 1;\n\t\t\ttag = \"execfn\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_PLATFORM:\n\t\t\tis_string = 1;\n\t\t\ttag = \"platform\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_UID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"real uid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_GID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"real gid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_EUID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"effective uid\";\n\t\t\tbreak;\n\t\tcase AT_LINUX_EGID:\n\t\t\tis_string = 0;\n\t\t\ttag = \"effective gid\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tis_string = 0;\n\t\t\ttag = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tag == NULL)\n\t\t\tcontinue;\n\n\t\tif (is_string) {\n\t\t\tchar buf[256];\n\t\t\tssize_t buflen;\n\t\t\tbuflen = get_string_on_virtaddr(ms, swap, clazz, fd,\n\t\t\t    ph_off, ph_num, fsize, xauxv_val, buf, sizeof(buf));\n\n\t\t\tif (buflen == 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (file_printf(ms, \", %s: '%s'\", tag, buf) == -1)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (file_printf(ms, \", %s: %d\", tag, (int) xauxv_val)\n\t\t\t    == -1)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n#else\n\treturn 0;\n#endif\n}\n\nprivate size_t\ndonote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n    int clazz, int swap, size_t align, int *flags, uint16_t *notecount,\n    int fd, off_t ph_off, int ph_num, off_t fsize)\n{\n\tElf32_Nhdr nh32;\n\tElf64_Nhdr nh64;\n\tsize_t noff, doff;\n\tuint32_t namesz, descsz;\n\tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n\n\tif (*notecount == 0)\n\t\treturn 0;\n\t--*notecount;\n\n\tif (xnh_sizeof + offset > size) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn xnh_sizeof + offset;\n\t}\n\n\t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n\toffset += xnh_sizeof;\n\n\tnamesz = xnh_namesz;\n\tdescsz = xnh_descsz;\n\n\tif ((namesz == 0) && (descsz == 0)) {\n\t\t/*\n\t\t * We're out of note headers.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\n\tif (namesz & 0x80000000) {\n\t    (void)file_printf(ms, \", bad note name size %#lx\",\n\t\t(unsigned long)namesz);\n\t    return 0;\n\t}\n\n\tif (descsz & 0x80000000) {\n\t    (void)file_printf(ms, \", bad note description size %#lx\",\n\t\t(unsigned long)descsz);\n\t    return 0;\n\t}\n\n\tnoff = offset;\n\tdoff = ELF_ALIGN(offset + namesz);\n\n\tif (offset + namesz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn doff;\n\t}\n\n\toffset = ELF_ALIGN(doff + descsz);\n\tif (doff + descsz > size) {\n\t\t/*\n\t\t * We're past the end of the buffer.\n\t\t */\n\t\treturn (offset >= size) ? offset : size;\n\t}\n\n\n\tif ((*flags & FLAGS_DID_OS_NOTE) == 0) {\n\t\tif (do_os_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn offset;\n\t}\n\n\tif ((*flags & FLAGS_DID_BUILD_ID) == 0) {\n\t\tif (do_bid_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn offset;\n\t}\n\t\t\n\tif ((*flags & FLAGS_DID_NETBSD_PAX) == 0) {\n\t\tif (do_pax_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags))\n\t\t\treturn offset;\n\t}\n\n\tif ((*flags & FLAGS_DID_CORE) == 0) {\n\t\tif (do_core_note(ms, nbuf, xnh_type, swap,\n\t\t    namesz, descsz, noff, doff, flags, size, clazz))\n\t\t\treturn offset;\n\t}\n\n\tif ((*flags & FLAGS_DID_AUXV) == 0) {\n\t\tif (do_auxv_note(ms, nbuf, xnh_type, swap,\n\t\t\tnamesz, descsz, noff, doff, flags, size, clazz,\n\t\t\tfd, ph_off, ph_num, fsize))\n\t\t\treturn offset;\n\t}\n\n\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n\t\tif (descsz > 100)\n\t\t\tdescsz = 100;\n\t\tswitch (xnh_type) {\n\t    \tcase NT_NETBSD_VERSION:\n\t\t\treturn offset;\n\t\tcase NT_NETBSD_MARCH:\n\t\t\tif (*flags & FLAGS_DID_NETBSD_MARCH)\n\t\t\t\treturn offset;\n\t\t\t*flags |= FLAGS_DID_NETBSD_MARCH;\n\t\t\tif (file_printf(ms, \", compiled for: %.*s\",\n\t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tcase NT_NETBSD_CMODEL:\n\t\t\tif (*flags & FLAGS_DID_NETBSD_CMODEL)\n\t\t\t\treturn offset;\n\t\t\t*flags |= FLAGS_DID_NETBSD_CMODEL;\n\t\t\tif (file_printf(ms, \", compiler model: %.*s\",\n\t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (*flags & FLAGS_DID_NETBSD_UNKNOWN)\n\t\t\t\treturn offset;\n\t\t\t*flags |= FLAGS_DID_NETBSD_UNKNOWN;\n\t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\t}\n\t\treturn offset;\n\t}\n\n\treturn offset;\n}\n\n/* SunOS 5.x hardware capability descriptions */\ntypedef struct cap_desc {\n\tuint64_t cd_mask;\n\tconst char *cd_name;\n} cap_desc_t;\n\nstatic const cap_desc_t cap_desc_sparc[] = {\n\t{ AV_SPARC_MUL32,\t\t\"MUL32\" },\n\t{ AV_SPARC_DIV32,\t\t\"DIV32\" },\n\t{ AV_SPARC_FSMULD,\t\t\"FSMULD\" },\n\t{ AV_SPARC_V8PLUS,\t\t\"V8PLUS\" },\n\t{ AV_SPARC_POPC,\t\t\"POPC\" },\n\t{ AV_SPARC_VIS,\t\t\t\"VIS\" },\n\t{ AV_SPARC_VIS2,\t\t\"VIS2\" },\n\t{ AV_SPARC_ASI_BLK_INIT,\t\"ASI_BLK_INIT\" },\n\t{ AV_SPARC_FMAF,\t\t\"FMAF\" },\n\t{ AV_SPARC_FJFMAU,\t\t\"FJFMAU\" },\n\t{ AV_SPARC_IMA,\t\t\t\"IMA\" },\n\t{ 0, NULL }\n};\n\nstatic const cap_desc_t cap_desc_386[] = {\n\t{ AV_386_FPU,\t\t\t\"FPU\" },\n\t{ AV_386_TSC,\t\t\t\"TSC\" },\n\t{ AV_386_CX8,\t\t\t\"CX8\" },\n\t{ AV_386_SEP,\t\t\t\"SEP\" },\n\t{ AV_386_AMD_SYSC,\t\t\"AMD_SYSC\" },\n\t{ AV_386_CMOV,\t\t\t\"CMOV\" },\n\t{ AV_386_MMX,\t\t\t\"MMX\" },\n\t{ AV_386_AMD_MMX,\t\t\"AMD_MMX\" },\n\t{ AV_386_AMD_3DNow,\t\t\"AMD_3DNow\" },\n\t{ AV_386_AMD_3DNowx,\t\t\"AMD_3DNowx\" },\n\t{ AV_386_FXSR,\t\t\t\"FXSR\" },\n\t{ AV_386_SSE,\t\t\t\"SSE\" },\n\t{ AV_386_SSE2,\t\t\t\"SSE2\" },\n\t{ AV_386_PAUSE,\t\t\t\"PAUSE\" },\n\t{ AV_386_SSE3,\t\t\t\"SSE3\" },\n\t{ AV_386_MON,\t\t\t\"MON\" },\n\t{ AV_386_CX16,\t\t\t\"CX16\" },\n\t{ AV_386_AHF,\t\t\t\"AHF\" },\n\t{ AV_386_TSCP,\t\t\t\"TSCP\" },\n\t{ AV_386_AMD_SSE4A,\t\t\"AMD_SSE4A\" },\n\t{ AV_386_POPCNT,\t\t\"POPCNT\" },\n\t{ AV_386_AMD_LZCNT,\t\t\"AMD_LZCNT\" },\n\t{ AV_386_SSSE3,\t\t\t\"SSSE3\" },\n\t{ AV_386_SSE4_1,\t\t\"SSE4.1\" },\n\t{ AV_386_SSE4_2,\t\t\"SSE4.2\" },\n\t{ 0, NULL }\n};\n\nprivate int\ndoshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n    size_t size, off_t fsize, int mach, int strtab, int *flags,\n    uint16_t *notecount)\n{\n\tElf32_Shdr sh32;\n\tElf64_Shdr sh64;\n\tint stripped = 1, has_debug_info = 0;\n\tsize_t nbadcap = 0;\n\tvoid *nbuf;\n\toff_t noff, coff, name_off;\n\tuint64_t cap_hw1 = 0;\t/* SunOS 5.x hardware capabilities */\n\tuint64_t cap_sf1 = 0;\t/* SunOS 5.x software capabilities */\n\tchar name[50];\n\tssize_t namesize;\n\n\tif (size != xsh_sizeof) {\n\t\tif (file_printf(ms, \", corrupted section header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n\t/* Read offset of name section to be able to read section names later */\n\tif (pread(fd, xsh_addr, xsh_sizeof, CAST(off_t, (off + size * strtab)))\n\t    < (ssize_t)xsh_sizeof) {\n\t\tif (file_printf(ms, \", missing section headers\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\tname_off = xsh_offset;\n\n\tfor ( ; num; num--) {\n\t\t/* Read the name of this section. */\n\t\tif ((namesize = pread(fd, name, sizeof(name) - 1, name_off + xsh_name)) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\tname[namesize] = '\\0';\n\t\tif (strcmp(name, \".debug_info\") == 0) {\n\t\t\thas_debug_info = 1;\n\t\t\tstripped = 0;\n\t\t}\n\n\t\tif (pread(fd, xsh_addr, xsh_sizeof, off) < (ssize_t)xsh_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\t\toff += size;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xsh_type) {\n\t\tcase SHT_SYMTAB:\n#if 0\n\t\tcase SHT_DYNSYM:\n#endif\n\t\t\tstripped = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fsize != SIZE_UNKNOWN && xsh_offset > fsize) {\n\t\t\t\t/* Perhaps warn here */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xsh_type) {\n\t\tcase SHT_NOTE:\n\t\t\tif ((uintmax_t)(xsh_size + xsh_offset) >\n\t\t\t    (uintmax_t)fsize) {\n\t\t\t\tif (file_printf(ms,\n\t\t\t\t    \", note offset/size %#\" INTMAX_T_FORMAT\n\t\t\t\t    \"x+%#\" INTMAX_T_FORMAT \"x exceeds\"\n\t\t\t\t    \" file size %#\" INTMAX_T_FORMAT \"x\",\n\t\t\t\t    (uintmax_t)xsh_offset, (uintmax_t)xsh_size,\n\t\t\t\t    (uintmax_t)fsize) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\treturn 0; \n\t\t\t}\n\t\t\tif ((nbuf = malloc(xsh_size)) == NULL) {\n\t\t\t\tfile_error(ms, errno, \"Cannot allocate memory\"\n\t\t\t\t    \" for note\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (pread(fd, nbuf, xsh_size, xsh_offset) <\n\t\t\t    (ssize_t)xsh_size) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\tfree(nbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tnoff = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (noff >= (off_t)xsh_size)\n\t\t\t\t\tbreak;\n\t\t\t\tnoff = donote(ms, nbuf, (size_t)noff,\n\t\t\t\t    xsh_size, clazz, swap, 4, flags, notecount,\n\t\t\t\t    fd, 0, 0, 0);\n\t\t\t\tif (noff == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfree(nbuf);\n\t\t\tbreak;\n\t\tcase SHT_SUNW_cap:\n\t\t\tswitch (mach) {\n\t\t\tcase EM_SPARC:\n\t\t\tcase EM_SPARCV9:\n\t\t\tcase EM_IA_64:\n\t\t\tcase EM_386:\n\t\t\tcase EM_AMD64:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\tif (nbadcap > 5)\n\t\t\t\tbreak;\n\t\t\tif (lseek(fd, xsh_offset, SEEK_SET) == (off_t)-1) {\n\t\t\t\tfile_badseek(ms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcoff = 0;\n\t\t\tfor (;;) {\n\t\t\t\tElf32_Cap cap32;\n\t\t\t\tElf64_Cap cap64;\n\t\t\t\tchar cbuf[/*CONSTCOND*/\n\t\t\t\t    MAX(sizeof cap32, sizeof cap64)];\n\t\t\t\tif ((coff += xcap_sizeof) > (off_t)xsh_size)\n\t\t\t\t\tbreak;\n\t\t\t\tif (read(fd, cbuf, (size_t)xcap_sizeof) !=\n\t\t\t\t    (ssize_t)xcap_sizeof) {\n\t\t\t\t\tfile_badread(ms);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (cbuf[0] == 'A') {\n#ifdef notyet\n\t\t\t\t\tchar *p = cbuf + 1;\n\t\t\t\t\tuint32_t len, tag;\n\t\t\t\t\tmemcpy(&len, p, sizeof(len));\n\t\t\t\t\tp += 4;\n\t\t\t\t\tlen = getu32(swap, len);\n\t\t\t\t\tif (memcmp(\"gnu\", p, 3) != 0) {\n\t\t\t\t\t    if (file_printf(ms,\n\t\t\t\t\t\t\", unknown capability %.3s\", p)\n\t\t\t\t\t\t== -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\tp += strlen(p) + 1;\n\t\t\t\t\ttag = *p++;\n\t\t\t\t\tmemcpy(&len, p, sizeof(len));\n\t\t\t\t\tp += 4;\n\t\t\t\t\tlen = getu32(swap, len);\n\t\t\t\t\tif (tag != 1) {\n\t\t\t\t\t    if (file_printf(ms, \", unknown gnu\"\n\t\t\t\t\t\t\" capability tag %d\", tag)\n\t\t\t\t\t\t== -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t\t// gnu attributes \n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t(void)memcpy(xcap_addr, cbuf, xcap_sizeof);\n\t\t\t\tswitch (xcap_tag) {\n\t\t\t\tcase CA_SUNW_NULL:\n\t\t\t\t\tbreak;\n\t\t\t\tcase CA_SUNW_HW_1:\n\t\t\t\t\tcap_hw1 |= xcap_val;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CA_SUNW_SF_1:\n\t\t\t\t\tcap_sf1 |= xcap_val;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (file_printf(ms,\n\t\t\t\t\t    \", with unknown capability \"\n\t\t\t\t\t    \"%#\" INT64_T_FORMAT \"x = %#\"\n\t\t\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t\t\t    (unsigned long long)xcap_tag,\n\t\t\t\t\t    (unsigned long long)xcap_val) == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tif (nbadcap++ > 2)\n\t\t\t\t\t\tcoff = xsh_size;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tskip:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (has_debug_info) {\n\t\tif (file_printf(ms, \", with debug_info\") == -1)\n\t\t\treturn -1;\n\t}\n\tif (file_printf(ms, \", %sstripped\", stripped ? \"\" : \"not \") == -1)\n\t\treturn -1;\n\tif (cap_hw1) {\n\t\tconst cap_desc_t *cdp;\n\t\tswitch (mach) {\n\t\tcase EM_SPARC:\n\t\tcase EM_SPARC32PLUS:\n\t\tcase EM_SPARCV9:\n\t\t\tcdp = cap_desc_sparc;\n\t\t\tbreak;\n\t\tcase EM_386:\n\t\tcase EM_IA_64:\n\t\tcase EM_AMD64:\n\t\t\tcdp = cap_desc_386;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcdp = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (file_printf(ms, \", uses\") == -1)\n\t\t\treturn -1;\n\t\tif (cdp) {\n\t\t\twhile (cdp->cd_name) {\n\t\t\t\tif (cap_hw1 & cdp->cd_mask) {\n\t\t\t\t\tif (file_printf(ms,\n\t\t\t\t\t    \" %s\", cdp->cd_name) == -1)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tcap_hw1 &= ~cdp->cd_mask;\n\t\t\t\t}\n\t\t\t\t++cdp;\n\t\t\t}\n\t\t\tif (cap_hw1)\n\t\t\t\tif (file_printf(ms,\n\t\t\t\t    \" unknown hardware capability %#\"\n\t\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t\t    (unsigned long long)cap_hw1) == -1)\n\t\t\t\t\treturn -1;\n\t\t} else {\n\t\t\tif (file_printf(ms,\n\t\t\t    \" hardware capability %#\" INT64_T_FORMAT \"x\",\n\t\t\t    (unsigned long long)cap_hw1) == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tif (cap_sf1) {\n\t\tif (cap_sf1 & SF1_SUNW_FPUSED) {\n\t\t\tif (file_printf(ms,\n\t\t\t    (cap_sf1 & SF1_SUNW_FPKNWN)\n\t\t\t    ? \", uses frame pointer\"\n\t\t\t    : \", not known to use frame pointer\") == -1)\n\t\t\t\treturn -1;\n\t\t}\n\t\tcap_sf1 &= ~SF1_SUNW_MASK;\n\t\tif (cap_sf1)\n\t\t\tif (file_printf(ms,\n\t\t\t    \", with unknown software capability %#\"\n\t\t\t    INT64_T_FORMAT \"x\",\n\t\t\t    (unsigned long long)cap_sf1) == -1)\n\t\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Look through the program headers of an executable image, searching\n * for a PT_INTERP section; if one is found, it's dynamically linked,\n * otherwise it's statically linked.\n */\nprivate int\ndophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n    int num, size_t size, off_t fsize, int sh_num, int *flags,\n    uint16_t *notecount)\n{\n\tElf32_Phdr ph32;\n\tElf64_Phdr ph64;\n\tconst char *linking_style = \"statically\";\n\tconst char *interp = \"\";\n\tunsigned char nbuf[BUFSIZ];\n\tchar ibuf[BUFSIZ];\n\tssize_t bufsize;\n\tsize_t offset, align, len;\n\t\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n  \tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff += size;\n\t\tbufsize = 0;\n\t\talign = 4;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_DYNAMIC:\n\t\t\tlinking_style = \"dynamically\";\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\tif (sh_num)\t/* Did this through section headers */\n\t\t\t\tcontinue;\n\t\t\tif (((align = xph_align) & 0x80000000UL) != 0 ||\n\t\t\t    align < 4) {\n\t\t\t\tif (file_printf(ms, \n\t\t\t\t    \", invalid note alignment %#lx\",\n\t\t\t\t    (unsigned long)align) == -1)\n\t\t\t\t\treturn -1;\n\t\t\t\talign = 4;\n\t\t\t}\n\t\t\t/*FALLTHROUGH*/\n\t\tcase PT_INTERP:\n\t\t\tlen = xph_filesz < sizeof(nbuf) ? xph_filesz\n\t\t\t    : sizeof(nbuf);\n\t\t\tbufsize = pread(fd, nbuf, len, xph_offset);\n\t\t\tif (bufsize == -1) {\n\t\t\t\tfile_badread(ms);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fsize != SIZE_UNKNOWN && xph_offset > fsize) {\n\t\t\t\t/* Maybe warn here? */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Things we can determine when we seek */\n\t\tswitch (xph_type) {\n\t\tcase PT_INTERP:\n\t\t\tif (bufsize && nbuf[0]) {\n\t\t\t\tnbuf[bufsize - 1] = '\\0';\n\t\t\t\tinterp = (const char *)nbuf;\n\t\t\t} else\n\t\t\t\tinterp = \"*empty*\";\n\t\t\tbreak;\n\t\tcase PT_NOTE:\n\t\t\t/*\n\t\t\t * This is a PT_NOTE section; loop through all the notes\n\t\t\t * in the section.\n\t\t\t */\n\t\t\toffset = 0;\n\t\t\tfor (;;) {\n\t\t\t\tif (offset >= (size_t)bufsize)\n\t\t\t\t\tbreak;\n\t\t\t\toffset = donote(ms, nbuf, offset,\n\t\t\t\t    (size_t)bufsize, clazz, swap, align,\n\t\t\t\t    flags, notecount, fd, 0, 0, 0);\n\t\t\t\tif (offset == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (file_printf(ms, \", %s linked\", linking_style)\n\t    == -1)\n\t\treturn -1;\n\tif (interp[0])\n\t\tif (file_printf(ms, \", interpreter %s\",\n\t\t    file_printable(ibuf, sizeof(ibuf), interp)) == -1)\n\t\t\treturn -1;\n\treturn 0;\n}\n\n\nprotected int\nfile_tryelf(struct magic_set *ms, int fd, const unsigned char *buf,\n    size_t nbytes)\n{\n\tunion {\n\t\tint32_t l;\n\t\tchar c[sizeof (int32_t)];\n\t} u;\n\tint clazz;\n\tint swap;\n\tstruct stat st;\n\toff_t fsize;\n\tint flags = 0;\n\tElf32_Ehdr elf32hdr;\n\tElf64_Ehdr elf64hdr;\n\tuint16_t type, phnum, shnum, notecount;\n\n\tif (ms->flags & (MAGIC_MIME|MAGIC_APPLE|MAGIC_EXTENSION))\n\t\treturn 0;\n\t/*\n\t * ELF executables have multiple section headers in arbitrary\n\t * file locations and thus file(1) cannot determine it from easily.\n\t * Instead we traverse thru all section headers until a symbol table\n\t * one is found or else the binary is stripped.\n\t * Return immediately if it's not ELF (so we avoid pipe2file unless needed).\n\t */\n\tif (buf[EI_MAG0] != ELFMAG0\n\t    || (buf[EI_MAG1] != ELFMAG1 && buf[EI_MAG1] != OLFMAG1)\n\t    || buf[EI_MAG2] != ELFMAG2 || buf[EI_MAG3] != ELFMAG3)\n\t\treturn 0;\n\n\t/*\n\t * If we cannot seek, it must be a pipe, socket or fifo.\n\t */\n\tif((lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1) && (errno == ESPIPE))\n\t\tfd = file_pipe2file(ms, fd, buf, nbytes);\n\n\tif (fstat(fd, &st) == -1) {\n  \t\tfile_badread(ms);\n\t\treturn -1;\n\t}\n\tif (S_ISREG(st.st_mode) || st.st_size != 0)\n\t\tfsize = st.st_size;\n\telse\n\t\tfsize = SIZE_UNKNOWN;\n\n\tclazz = buf[EI_CLASS];\n\n\tswitch (clazz) {\n\tcase ELFCLASS32:\n#undef elf_getu\n#define elf_getu(a, b)\telf_getu32(a, b)\n#undef elfhdr\n#define elfhdr elf32hdr\n#include \"elfclass.h\"\n\tcase ELFCLASS64:\n#undef elf_getu\n#define elf_getu(a, b)\telf_getu64(a, b)\n#undef elfhdr\n#define elfhdr elf64hdr\n#include \"elfclass.h\"\n\tdefault:\n\t    if (file_printf(ms, \", unknown class %d\", clazz) == -1)\n\t\t    return -1;\n\t    break;\n\t}\n\treturn 0;\n}\n#endif\n"], "filenames": ["src/readelf.c"], "buggy_code_start_loc": [30], "buggy_code_end_loc": [515], "fixing_code_start_loc": [30], "fixing_code_end_loc": [515], "type": "CWE-119", "message": "An issue in file() was introduced in commit 9611f31313a93aa036389c5f3b15eea53510d4d1 (Oct 2016) lets an attacker overwrite a fixed 20 bytes stack buffer with a specially crafted .notes section in an ELF binary. This was fixed in commit 35c94dc6acc418f1ad7f6241a6680e5327495793 (Aug 2017).", "other": {"cve": {"id": "CVE-2017-1000249", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-11T19:29:00.200", "lastModified": "2017-11-08T02:29:02.333", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "An issue in file() was introduced in commit 9611f31313a93aa036389c5f3b15eea53510d4d1 (Oct 2016) lets an attacker overwrite a fixed 20 bytes stack buffer with a specially crafted .notes section in an ELF binary. This was fixed in commit 35c94dc6acc418f1ad7f6241a6680e5327495793 (Aug 2017)."}, {"lang": "es", "value": "Se introdujo un fallo en la funci\u00f3n file() en un commit con ID 9611f31313a93aa036389c5f3b15eea53510d4d1 (octubre 2016) que permite a un atacante sobrescribir un b\u00fafer de pila fijo de 20 bytes con una secci\u00f3n .notes especialmente manipulada en un archivo binario ELF. Esto se solucion\u00f3 en el commit con ID 35c94dc6acc418f1ad7f6241a6680e5327495793 (agosto 2017)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:file_project:file:5.29:*:*:*:*:*:*:*", "matchCriteriaId": "AA05566A-1567-4115-B62B-7B268A84050A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3965", "source": "cve@mitre.org"}, {"url": "https://github.com/file/file/commit/35c94dc6acc418f1ad7f6241a6680e5327495793", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/file/file/commit/9611f31313a93aa036389c5f3b15eea53510d4d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201710-02", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/file/file/commit/35c94dc6acc418f1ad7f6241a6680e5327495793"}}