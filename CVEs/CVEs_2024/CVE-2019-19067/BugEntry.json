{"buggy_code": ["/*\n * Copyright 2015 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/irqdomain.h>\n#include <linux/pci.h>\n#include <linux/pm_domain.h>\n#include <linux/platform_device.h>\n#include <sound/designware_i2s.h>\n#include <sound/pcm.h>\n\n#include \"amdgpu.h\"\n#include \"atom.h\"\n#include \"amdgpu_acp.h\"\n\n#include \"acp_gfx_if.h\"\n\n#define ACP_TILE_ON_MASK                \t0x03\n#define ACP_TILE_OFF_MASK               \t0x02\n#define ACP_TILE_ON_RETAIN_REG_MASK     \t0x1f\n#define ACP_TILE_OFF_RETAIN_REG_MASK    \t0x20\n\n#define ACP_TILE_P1_MASK                \t0x3e\n#define ACP_TILE_P2_MASK                \t0x3d\n#define ACP_TILE_DSP0_MASK              \t0x3b\n#define ACP_TILE_DSP1_MASK              \t0x37\n\n#define ACP_TILE_DSP2_MASK              \t0x2f\n\n#define ACP_DMA_REGS_END\t\t\t0x146c0\n#define ACP_I2S_PLAY_REGS_START\t\t\t0x14840\n#define ACP_I2S_PLAY_REGS_END\t\t\t0x148b4\n#define ACP_I2S_CAP_REGS_START\t\t\t0x148b8\n#define ACP_I2S_CAP_REGS_END\t\t\t0x1496c\n\n#define ACP_I2S_COMP1_CAP_REG_OFFSET\t\t0xac\n#define ACP_I2S_COMP2_CAP_REG_OFFSET\t\t0xa8\n#define ACP_I2S_COMP1_PLAY_REG_OFFSET\t\t0x6c\n#define ACP_I2S_COMP2_PLAY_REG_OFFSET\t\t0x68\n#define ACP_BT_PLAY_REGS_START\t\t\t0x14970\n#define ACP_BT_PLAY_REGS_END\t\t\t0x14a24\n#define ACP_BT_COMP1_REG_OFFSET\t\t\t0xac\n#define ACP_BT_COMP2_REG_OFFSET\t\t\t0xa8\n\n#define mmACP_PGFSM_RETAIN_REG\t\t\t0x51c9\n#define mmACP_PGFSM_CONFIG_REG\t\t\t0x51ca\n#define mmACP_PGFSM_READ_REG_0\t\t\t0x51cc\n\n#define mmACP_MEM_SHUT_DOWN_REQ_LO\t\t0x51f8\n#define mmACP_MEM_SHUT_DOWN_REQ_HI\t\t0x51f9\n#define mmACP_MEM_SHUT_DOWN_STS_LO\t\t0x51fa\n#define mmACP_MEM_SHUT_DOWN_STS_HI\t\t0x51fb\n\n#define mmACP_CONTROL\t\t\t\t0x5131\n#define mmACP_STATUS\t\t\t\t0x5133\n#define mmACP_SOFT_RESET\t\t\t0x5134\n#define ACP_CONTROL__ClkEn_MASK \t\t0x1\n#define ACP_SOFT_RESET__SoftResetAud_MASK \t0x100\n#define ACP_SOFT_RESET__SoftResetAudDone_MASK\t0x1000000\n#define ACP_CLOCK_EN_TIME_OUT_VALUE\t\t0x000000FF\n#define ACP_SOFT_RESET_DONE_TIME_OUT_VALUE\t0x000000FF\n\n#define ACP_TIMEOUT_LOOP\t\t\t0x000000FF\n#define ACP_DEVS\t\t\t\t4\n#define ACP_SRC_ID\t\t\t\t162\n\nenum {\n\tACP_TILE_P1 = 0,\n\tACP_TILE_P2,\n\tACP_TILE_DSP0,\n\tACP_TILE_DSP1,\n\tACP_TILE_DSP2,\n};\n\nstatic int acp_sw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tadev->acp.parent = adev->dev;\n\n\tadev->acp.cgs_device =\n\t\tamdgpu_cgs_create_device(adev);\n\tif (!adev->acp.cgs_device)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int acp_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (adev->acp.cgs_device)\n\t\tamdgpu_cgs_destroy_device(adev->acp.cgs_device);\n\n\treturn 0;\n}\n\nstruct acp_pm_domain {\n\tvoid *adev;\n\tstruct generic_pm_domain gpd;\n};\n\nstatic int acp_poweroff(struct generic_pm_domain *genpd)\n{\n\tstruct acp_pm_domain *apd;\n\tstruct amdgpu_device *adev;\n\n\tapd = container_of(genpd, struct acp_pm_domain, gpd);\n\tif (apd != NULL) {\n\t\tadev = apd->adev;\n\t/* call smu to POWER GATE ACP block\n\t * smu will\n\t * 1. turn off the acp clock\n\t * 2. power off the acp tiles\n\t * 3. check and enter ulv state\n\t */\n\t\tif (adev->powerplay.pp_funcs &&\n\t\t\tadev->powerplay.pp_funcs->set_powergating_by_smu)\n\t\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);\n\t}\n\treturn 0;\n}\n\nstatic int acp_poweron(struct generic_pm_domain *genpd)\n{\n\tstruct acp_pm_domain *apd;\n\tstruct amdgpu_device *adev;\n\n\tapd = container_of(genpd, struct acp_pm_domain, gpd);\n\tif (apd != NULL) {\n\t\tadev = apd->adev;\n\t/* call smu to UNGATE ACP block\n\t * smu will\n\t * 1. exit ulv\n\t * 2. turn on acp clock\n\t * 3. power on acp tiles\n\t */\n\t\tif (adev->powerplay.pp_funcs->set_powergating_by_smu)\n\t\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, false);\n\t}\n\treturn 0;\n}\n\nstatic struct device *get_mfd_cell_dev(const char *device_name, int r)\n{\n\tchar auto_dev_name[25];\n\tstruct device *dev;\n\n\tsnprintf(auto_dev_name, sizeof(auto_dev_name),\n\t\t \"%s.%d.auto\", device_name, r);\n\tdev = bus_find_device_by_name(&platform_bus_type, NULL, auto_dev_name);\n\tdev_info(dev, \"device %s added to pm domain\\n\", auto_dev_name);\n\n\treturn dev;\n}\n\n/**\n * acp_hw_init - start and test ACP block\n *\n * @adev: amdgpu_device pointer\n *\n */\nstatic int acp_hw_init(void *handle)\n{\n\tint r, i;\n\tuint64_t acp_base;\n\tu32 val = 0;\n\tu32 count = 0;\n\tstruct device *dev;\n\tstruct i2s_platform_data *i2s_pdata;\n\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tconst struct amdgpu_ip_block *ip_block =\n\t\tamdgpu_device_ip_get_ip_block(adev, AMD_IP_BLOCK_TYPE_ACP);\n\n\tif (!ip_block)\n\t\treturn -EINVAL;\n\n\tr = amd_acp_hw_init(adev->acp.cgs_device,\n\t\t\t    ip_block->version->major, ip_block->version->minor);\n\t/* -ENODEV means board uses AZ rather than ACP */\n\tif (r == -ENODEV) {\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);\n\t\treturn 0;\n\t} else if (r) {\n\t\treturn r;\n\t}\n\n\tif (adev->rmmio_size == 0 || adev->rmmio_size < 0x5289)\n\t\treturn -EINVAL;\n\n\tacp_base = adev->rmmio_base;\n\n\n\tadev->acp.acp_genpd = kzalloc(sizeof(struct acp_pm_domain), GFP_KERNEL);\n\tif (adev->acp.acp_genpd == NULL)\n\t\treturn -ENOMEM;\n\n\tadev->acp.acp_genpd->gpd.name = \"ACP_AUDIO\";\n\tadev->acp.acp_genpd->gpd.power_off = acp_poweroff;\n\tadev->acp.acp_genpd->gpd.power_on = acp_poweron;\n\n\n\tadev->acp.acp_genpd->adev = adev;\n\n\tpm_genpd_init(&adev->acp.acp_genpd->gpd, NULL, false);\n\n\tadev->acp.acp_cell = kcalloc(ACP_DEVS, sizeof(struct mfd_cell),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (adev->acp.acp_cell == NULL)\n\t\treturn -ENOMEM;\n\n\tadev->acp.acp_res = kcalloc(5, sizeof(struct resource), GFP_KERNEL);\n\tif (adev->acp.acp_res == NULL) {\n\t\tkfree(adev->acp.acp_cell);\n\t\treturn -ENOMEM;\n\t}\n\n\ti2s_pdata = kcalloc(3, sizeof(struct i2s_platform_data), GFP_KERNEL);\n\tif (i2s_pdata == NULL) {\n\t\tkfree(adev->acp.acp_res);\n\t\tkfree(adev->acp.acp_cell);\n\t\treturn -ENOMEM;\n\t}\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_STONEY:\n\t\ti2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\tDW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\ti2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;\n\t}\n\ti2s_pdata[0].cap = DWC_I2S_PLAY;\n\ti2s_pdata[0].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\ti2s_pdata[0].i2s_reg_comp1 = ACP_I2S_COMP1_PLAY_REG_OFFSET;\n\ti2s_pdata[0].i2s_reg_comp2 = ACP_I2S_COMP2_PLAY_REG_OFFSET;\n\tswitch (adev->asic_type) {\n\tcase CHIP_STONEY:\n\t\ti2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\tDW_I2S_QUIRK_COMP_PARAM1 |\n\t\t\tDW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\ti2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\tDW_I2S_QUIRK_COMP_PARAM1;\n\t}\n\n\ti2s_pdata[1].cap = DWC_I2S_RECORD;\n\ti2s_pdata[1].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\ti2s_pdata[1].i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET;\n\ti2s_pdata[1].i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET;\n\n\ti2s_pdata[2].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;\n\tswitch (adev->asic_type) {\n\tcase CHIP_STONEY:\n\t\ti2s_pdata[2].quirks |= DW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ti2s_pdata[2].cap = DWC_I2S_PLAY | DWC_I2S_RECORD;\n\ti2s_pdata[2].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\ti2s_pdata[2].i2s_reg_comp1 = ACP_BT_COMP1_REG_OFFSET;\n\ti2s_pdata[2].i2s_reg_comp2 = ACP_BT_COMP2_REG_OFFSET;\n\n\tadev->acp.acp_res[0].name = \"acp2x_dma\";\n\tadev->acp.acp_res[0].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[0].start = acp_base;\n\tadev->acp.acp_res[0].end = acp_base + ACP_DMA_REGS_END;\n\n\tadev->acp.acp_res[1].name = \"acp2x_dw_i2s_play\";\n\tadev->acp.acp_res[1].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[1].start = acp_base + ACP_I2S_PLAY_REGS_START;\n\tadev->acp.acp_res[1].end = acp_base + ACP_I2S_PLAY_REGS_END;\n\n\tadev->acp.acp_res[2].name = \"acp2x_dw_i2s_cap\";\n\tadev->acp.acp_res[2].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[2].start = acp_base + ACP_I2S_CAP_REGS_START;\n\tadev->acp.acp_res[2].end = acp_base + ACP_I2S_CAP_REGS_END;\n\n\tadev->acp.acp_res[3].name = \"acp2x_dw_bt_i2s_play_cap\";\n\tadev->acp.acp_res[3].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[3].start = acp_base + ACP_BT_PLAY_REGS_START;\n\tadev->acp.acp_res[3].end = acp_base + ACP_BT_PLAY_REGS_END;\n\n\tadev->acp.acp_res[4].name = \"acp2x_dma_irq\";\n\tadev->acp.acp_res[4].flags = IORESOURCE_IRQ;\n\tadev->acp.acp_res[4].start = amdgpu_irq_create_mapping(adev, 162);\n\tadev->acp.acp_res[4].end = adev->acp.acp_res[4].start;\n\n\tadev->acp.acp_cell[0].name = \"acp_audio_dma\";\n\tadev->acp.acp_cell[0].num_resources = 5;\n\tadev->acp.acp_cell[0].resources = &adev->acp.acp_res[0];\n\tadev->acp.acp_cell[0].platform_data = &adev->asic_type;\n\tadev->acp.acp_cell[0].pdata_size = sizeof(adev->asic_type);\n\n\tadev->acp.acp_cell[1].name = \"designware-i2s\";\n\tadev->acp.acp_cell[1].num_resources = 1;\n\tadev->acp.acp_cell[1].resources = &adev->acp.acp_res[1];\n\tadev->acp.acp_cell[1].platform_data = &i2s_pdata[0];\n\tadev->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data);\n\n\tadev->acp.acp_cell[2].name = \"designware-i2s\";\n\tadev->acp.acp_cell[2].num_resources = 1;\n\tadev->acp.acp_cell[2].resources = &adev->acp.acp_res[2];\n\tadev->acp.acp_cell[2].platform_data = &i2s_pdata[1];\n\tadev->acp.acp_cell[2].pdata_size = sizeof(struct i2s_platform_data);\n\n\tadev->acp.acp_cell[3].name = \"designware-i2s\";\n\tadev->acp.acp_cell[3].num_resources = 1;\n\tadev->acp.acp_cell[3].resources = &adev->acp.acp_res[3];\n\tadev->acp.acp_cell[3].platform_data = &i2s_pdata[2];\n\tadev->acp.acp_cell[3].pdata_size = sizeof(struct i2s_platform_data);\n\n\tr = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell,\n\t\t\t\t\t\t\t\tACP_DEVS);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < ACP_DEVS ; i++) {\n\t\tdev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);\n\t\tr = pm_genpd_add_device(&adev->acp.acp_genpd->gpd, dev);\n\t\tif (r) {\n\t\t\tdev_err(dev, \"Failed to add dev to genpd\\n\");\n\t\t\treturn r;\n\t\t}\n\t}\n\n\n\t/* Assert Soft reset of ACP */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\n\tval |= ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\n\tcount = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\t\tif (ACP_SOFT_RESET__SoftResetAudDone_MASK ==\n\t\t    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\t/* Enable clock to ACP and wait until the clock is enabled */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_CONTROL);\n\tval = val | ACP_CONTROL__ClkEn_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_CONTROL, val);\n\n\tcount = ACP_CLOCK_EN_TIME_OUT_VALUE;\n\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_STATUS);\n\t\tif (val & (u32) 0x1)\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\t/* Deassert the SOFT RESET flags */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\tval &= ~ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\treturn 0;\n}\n\n/**\n * acp_hw_fini - stop the hardware block\n *\n * @adev: amdgpu_device pointer\n *\n */\nstatic int acp_hw_fini(void *handle)\n{\n\tint i, ret;\n\tu32 val = 0;\n\tu32 count = 0;\n\tstruct device *dev;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t/* return early if no ACP */\n\tif (!adev->acp.acp_genpd) {\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, false);\n\t\treturn 0;\n\t}\n\n\t/* Assert Soft reset of ACP */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\n\tval |= ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\n\tcount = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\t\tif (ACP_SOFT_RESET__SoftResetAudDone_MASK ==\n\t\t    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\t/* Disable ACP clock */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_CONTROL);\n\tval &= ~ACP_CONTROL__ClkEn_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_CONTROL, val);\n\n\tcount = ACP_CLOCK_EN_TIME_OUT_VALUE;\n\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_STATUS);\n\t\tif (val & (u32) 0x1)\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\n\tfor (i = 0; i < ACP_DEVS ; i++) {\n\t\tdev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);\n\t\tret = pm_genpd_remove_device(dev);\n\t\t/* If removal fails, dont giveup and try rest */\n\t\tif (ret)\n\t\t\tdev_err(dev, \"remove dev from genpd failed\\n\");\n\t}\n\n\tmfd_remove_devices(adev->acp.parent);\n\tkfree(adev->acp.acp_res);\n\tkfree(adev->acp.acp_genpd);\n\tkfree(adev->acp.acp_cell);\n\n\treturn 0;\n}\n\nstatic int acp_suspend(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t/* power up on suspend */\n\tif (!adev->acp.acp_cell)\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, false);\n\treturn 0;\n}\n\nstatic int acp_resume(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t/* power down again on resume */\n\tif (!adev->acp.acp_cell)\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);\n\treturn 0;\n}\n\nstatic int acp_early_init(void *handle)\n{\n\treturn 0;\n}\n\nstatic bool acp_is_idle(void *handle)\n{\n\treturn true;\n}\n\nstatic int acp_wait_for_idle(void *handle)\n{\n\treturn 0;\n}\n\nstatic int acp_soft_reset(void *handle)\n{\n\treturn 0;\n}\n\nstatic int acp_set_clockgating_state(void *handle,\n\t\t\t\t     enum amd_clockgating_state state)\n{\n\treturn 0;\n}\n\nstatic int acp_set_powergating_state(void *handle,\n\t\t\t\t     enum amd_powergating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tbool enable = state == AMD_PG_STATE_GATE ? true : false;\n\n\tif (adev->powerplay.pp_funcs &&\n\t\tadev->powerplay.pp_funcs->set_powergating_by_smu)\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, enable);\n\n\treturn 0;\n}\n\nstatic const struct amd_ip_funcs acp_ip_funcs = {\n\t.name = \"acp_ip\",\n\t.early_init = acp_early_init,\n\t.late_init = NULL,\n\t.sw_init = acp_sw_init,\n\t.sw_fini = acp_sw_fini,\n\t.hw_init = acp_hw_init,\n\t.hw_fini = acp_hw_fini,\n\t.suspend = acp_suspend,\n\t.resume = acp_resume,\n\t.is_idle = acp_is_idle,\n\t.wait_for_idle = acp_wait_for_idle,\n\t.soft_reset = acp_soft_reset,\n\t.set_clockgating_state = acp_set_clockgating_state,\n\t.set_powergating_state = acp_set_powergating_state,\n};\n\nconst struct amdgpu_ip_block_version acp_ip_block =\n{\n\t.type = AMD_IP_BLOCK_TYPE_ACP,\n\t.major = 2,\n\t.minor = 2,\n\t.rev = 0,\n\t.funcs = &acp_ip_funcs,\n};\n"], "fixing_code": ["/*\n * Copyright 2015 Advanced Micro Devices, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * Authors: AMD\n *\n */\n\n#include <linux/irqdomain.h>\n#include <linux/pci.h>\n#include <linux/pm_domain.h>\n#include <linux/platform_device.h>\n#include <sound/designware_i2s.h>\n#include <sound/pcm.h>\n\n#include \"amdgpu.h\"\n#include \"atom.h\"\n#include \"amdgpu_acp.h\"\n\n#include \"acp_gfx_if.h\"\n\n#define ACP_TILE_ON_MASK                \t0x03\n#define ACP_TILE_OFF_MASK               \t0x02\n#define ACP_TILE_ON_RETAIN_REG_MASK     \t0x1f\n#define ACP_TILE_OFF_RETAIN_REG_MASK    \t0x20\n\n#define ACP_TILE_P1_MASK                \t0x3e\n#define ACP_TILE_P2_MASK                \t0x3d\n#define ACP_TILE_DSP0_MASK              \t0x3b\n#define ACP_TILE_DSP1_MASK              \t0x37\n\n#define ACP_TILE_DSP2_MASK              \t0x2f\n\n#define ACP_DMA_REGS_END\t\t\t0x146c0\n#define ACP_I2S_PLAY_REGS_START\t\t\t0x14840\n#define ACP_I2S_PLAY_REGS_END\t\t\t0x148b4\n#define ACP_I2S_CAP_REGS_START\t\t\t0x148b8\n#define ACP_I2S_CAP_REGS_END\t\t\t0x1496c\n\n#define ACP_I2S_COMP1_CAP_REG_OFFSET\t\t0xac\n#define ACP_I2S_COMP2_CAP_REG_OFFSET\t\t0xa8\n#define ACP_I2S_COMP1_PLAY_REG_OFFSET\t\t0x6c\n#define ACP_I2S_COMP2_PLAY_REG_OFFSET\t\t0x68\n#define ACP_BT_PLAY_REGS_START\t\t\t0x14970\n#define ACP_BT_PLAY_REGS_END\t\t\t0x14a24\n#define ACP_BT_COMP1_REG_OFFSET\t\t\t0xac\n#define ACP_BT_COMP2_REG_OFFSET\t\t\t0xa8\n\n#define mmACP_PGFSM_RETAIN_REG\t\t\t0x51c9\n#define mmACP_PGFSM_CONFIG_REG\t\t\t0x51ca\n#define mmACP_PGFSM_READ_REG_0\t\t\t0x51cc\n\n#define mmACP_MEM_SHUT_DOWN_REQ_LO\t\t0x51f8\n#define mmACP_MEM_SHUT_DOWN_REQ_HI\t\t0x51f9\n#define mmACP_MEM_SHUT_DOWN_STS_LO\t\t0x51fa\n#define mmACP_MEM_SHUT_DOWN_STS_HI\t\t0x51fb\n\n#define mmACP_CONTROL\t\t\t\t0x5131\n#define mmACP_STATUS\t\t\t\t0x5133\n#define mmACP_SOFT_RESET\t\t\t0x5134\n#define ACP_CONTROL__ClkEn_MASK \t\t0x1\n#define ACP_SOFT_RESET__SoftResetAud_MASK \t0x100\n#define ACP_SOFT_RESET__SoftResetAudDone_MASK\t0x1000000\n#define ACP_CLOCK_EN_TIME_OUT_VALUE\t\t0x000000FF\n#define ACP_SOFT_RESET_DONE_TIME_OUT_VALUE\t0x000000FF\n\n#define ACP_TIMEOUT_LOOP\t\t\t0x000000FF\n#define ACP_DEVS\t\t\t\t4\n#define ACP_SRC_ID\t\t\t\t162\n\nenum {\n\tACP_TILE_P1 = 0,\n\tACP_TILE_P2,\n\tACP_TILE_DSP0,\n\tACP_TILE_DSP1,\n\tACP_TILE_DSP2,\n};\n\nstatic int acp_sw_init(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tadev->acp.parent = adev->dev;\n\n\tadev->acp.cgs_device =\n\t\tamdgpu_cgs_create_device(adev);\n\tif (!adev->acp.cgs_device)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int acp_sw_fini(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tif (adev->acp.cgs_device)\n\t\tamdgpu_cgs_destroy_device(adev->acp.cgs_device);\n\n\treturn 0;\n}\n\nstruct acp_pm_domain {\n\tvoid *adev;\n\tstruct generic_pm_domain gpd;\n};\n\nstatic int acp_poweroff(struct generic_pm_domain *genpd)\n{\n\tstruct acp_pm_domain *apd;\n\tstruct amdgpu_device *adev;\n\n\tapd = container_of(genpd, struct acp_pm_domain, gpd);\n\tif (apd != NULL) {\n\t\tadev = apd->adev;\n\t/* call smu to POWER GATE ACP block\n\t * smu will\n\t * 1. turn off the acp clock\n\t * 2. power off the acp tiles\n\t * 3. check and enter ulv state\n\t */\n\t\tif (adev->powerplay.pp_funcs &&\n\t\t\tadev->powerplay.pp_funcs->set_powergating_by_smu)\n\t\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);\n\t}\n\treturn 0;\n}\n\nstatic int acp_poweron(struct generic_pm_domain *genpd)\n{\n\tstruct acp_pm_domain *apd;\n\tstruct amdgpu_device *adev;\n\n\tapd = container_of(genpd, struct acp_pm_domain, gpd);\n\tif (apd != NULL) {\n\t\tadev = apd->adev;\n\t/* call smu to UNGATE ACP block\n\t * smu will\n\t * 1. exit ulv\n\t * 2. turn on acp clock\n\t * 3. power on acp tiles\n\t */\n\t\tif (adev->powerplay.pp_funcs->set_powergating_by_smu)\n\t\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, false);\n\t}\n\treturn 0;\n}\n\nstatic struct device *get_mfd_cell_dev(const char *device_name, int r)\n{\n\tchar auto_dev_name[25];\n\tstruct device *dev;\n\n\tsnprintf(auto_dev_name, sizeof(auto_dev_name),\n\t\t \"%s.%d.auto\", device_name, r);\n\tdev = bus_find_device_by_name(&platform_bus_type, NULL, auto_dev_name);\n\tdev_info(dev, \"device %s added to pm domain\\n\", auto_dev_name);\n\n\treturn dev;\n}\n\n/**\n * acp_hw_init - start and test ACP block\n *\n * @adev: amdgpu_device pointer\n *\n */\nstatic int acp_hw_init(void *handle)\n{\n\tint r, i;\n\tuint64_t acp_base;\n\tu32 val = 0;\n\tu32 count = 0;\n\tstruct device *dev;\n\tstruct i2s_platform_data *i2s_pdata = NULL;\n\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\tconst struct amdgpu_ip_block *ip_block =\n\t\tamdgpu_device_ip_get_ip_block(adev, AMD_IP_BLOCK_TYPE_ACP);\n\n\tif (!ip_block)\n\t\treturn -EINVAL;\n\n\tr = amd_acp_hw_init(adev->acp.cgs_device,\n\t\t\t    ip_block->version->major, ip_block->version->minor);\n\t/* -ENODEV means board uses AZ rather than ACP */\n\tif (r == -ENODEV) {\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);\n\t\treturn 0;\n\t} else if (r) {\n\t\treturn r;\n\t}\n\n\tif (adev->rmmio_size == 0 || adev->rmmio_size < 0x5289)\n\t\treturn -EINVAL;\n\n\tacp_base = adev->rmmio_base;\n\n\n\tadev->acp.acp_genpd = kzalloc(sizeof(struct acp_pm_domain), GFP_KERNEL);\n\tif (adev->acp.acp_genpd == NULL)\n\t\treturn -ENOMEM;\n\n\tadev->acp.acp_genpd->gpd.name = \"ACP_AUDIO\";\n\tadev->acp.acp_genpd->gpd.power_off = acp_poweroff;\n\tadev->acp.acp_genpd->gpd.power_on = acp_poweron;\n\n\n\tadev->acp.acp_genpd->adev = adev;\n\n\tpm_genpd_init(&adev->acp.acp_genpd->gpd, NULL, false);\n\n\tadev->acp.acp_cell = kcalloc(ACP_DEVS, sizeof(struct mfd_cell),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\n\tif (adev->acp.acp_cell == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\tadev->acp.acp_res = kcalloc(5, sizeof(struct resource), GFP_KERNEL);\n\tif (adev->acp.acp_res == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\ti2s_pdata = kcalloc(3, sizeof(struct i2s_platform_data), GFP_KERNEL);\n\tif (i2s_pdata == NULL) {\n\t\tr = -ENOMEM;\n\t\tgoto failure;\n\t}\n\n\tswitch (adev->asic_type) {\n\tcase CHIP_STONEY:\n\t\ti2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\tDW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\ti2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;\n\t}\n\ti2s_pdata[0].cap = DWC_I2S_PLAY;\n\ti2s_pdata[0].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\ti2s_pdata[0].i2s_reg_comp1 = ACP_I2S_COMP1_PLAY_REG_OFFSET;\n\ti2s_pdata[0].i2s_reg_comp2 = ACP_I2S_COMP2_PLAY_REG_OFFSET;\n\tswitch (adev->asic_type) {\n\tcase CHIP_STONEY:\n\t\ti2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\tDW_I2S_QUIRK_COMP_PARAM1 |\n\t\t\tDW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\ti2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET |\n\t\t\tDW_I2S_QUIRK_COMP_PARAM1;\n\t}\n\n\ti2s_pdata[1].cap = DWC_I2S_RECORD;\n\ti2s_pdata[1].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\ti2s_pdata[1].i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET;\n\ti2s_pdata[1].i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET;\n\n\ti2s_pdata[2].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET;\n\tswitch (adev->asic_type) {\n\tcase CHIP_STONEY:\n\t\ti2s_pdata[2].quirks |= DW_I2S_QUIRK_16BIT_IDX_OVERRIDE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ti2s_pdata[2].cap = DWC_I2S_PLAY | DWC_I2S_RECORD;\n\ti2s_pdata[2].snd_rates = SNDRV_PCM_RATE_8000_96000;\n\ti2s_pdata[2].i2s_reg_comp1 = ACP_BT_COMP1_REG_OFFSET;\n\ti2s_pdata[2].i2s_reg_comp2 = ACP_BT_COMP2_REG_OFFSET;\n\n\tadev->acp.acp_res[0].name = \"acp2x_dma\";\n\tadev->acp.acp_res[0].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[0].start = acp_base;\n\tadev->acp.acp_res[0].end = acp_base + ACP_DMA_REGS_END;\n\n\tadev->acp.acp_res[1].name = \"acp2x_dw_i2s_play\";\n\tadev->acp.acp_res[1].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[1].start = acp_base + ACP_I2S_PLAY_REGS_START;\n\tadev->acp.acp_res[1].end = acp_base + ACP_I2S_PLAY_REGS_END;\n\n\tadev->acp.acp_res[2].name = \"acp2x_dw_i2s_cap\";\n\tadev->acp.acp_res[2].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[2].start = acp_base + ACP_I2S_CAP_REGS_START;\n\tadev->acp.acp_res[2].end = acp_base + ACP_I2S_CAP_REGS_END;\n\n\tadev->acp.acp_res[3].name = \"acp2x_dw_bt_i2s_play_cap\";\n\tadev->acp.acp_res[3].flags = IORESOURCE_MEM;\n\tadev->acp.acp_res[3].start = acp_base + ACP_BT_PLAY_REGS_START;\n\tadev->acp.acp_res[3].end = acp_base + ACP_BT_PLAY_REGS_END;\n\n\tadev->acp.acp_res[4].name = \"acp2x_dma_irq\";\n\tadev->acp.acp_res[4].flags = IORESOURCE_IRQ;\n\tadev->acp.acp_res[4].start = amdgpu_irq_create_mapping(adev, 162);\n\tadev->acp.acp_res[4].end = adev->acp.acp_res[4].start;\n\n\tadev->acp.acp_cell[0].name = \"acp_audio_dma\";\n\tadev->acp.acp_cell[0].num_resources = 5;\n\tadev->acp.acp_cell[0].resources = &adev->acp.acp_res[0];\n\tadev->acp.acp_cell[0].platform_data = &adev->asic_type;\n\tadev->acp.acp_cell[0].pdata_size = sizeof(adev->asic_type);\n\n\tadev->acp.acp_cell[1].name = \"designware-i2s\";\n\tadev->acp.acp_cell[1].num_resources = 1;\n\tadev->acp.acp_cell[1].resources = &adev->acp.acp_res[1];\n\tadev->acp.acp_cell[1].platform_data = &i2s_pdata[0];\n\tadev->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data);\n\n\tadev->acp.acp_cell[2].name = \"designware-i2s\";\n\tadev->acp.acp_cell[2].num_resources = 1;\n\tadev->acp.acp_cell[2].resources = &adev->acp.acp_res[2];\n\tadev->acp.acp_cell[2].platform_data = &i2s_pdata[1];\n\tadev->acp.acp_cell[2].pdata_size = sizeof(struct i2s_platform_data);\n\n\tadev->acp.acp_cell[3].name = \"designware-i2s\";\n\tadev->acp.acp_cell[3].num_resources = 1;\n\tadev->acp.acp_cell[3].resources = &adev->acp.acp_res[3];\n\tadev->acp.acp_cell[3].platform_data = &i2s_pdata[2];\n\tadev->acp.acp_cell[3].pdata_size = sizeof(struct i2s_platform_data);\n\n\tr = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell,\n\t\t\t\t\t\t\t\tACP_DEVS);\n\tif (r)\n\t\tgoto failure;\n\n\tfor (i = 0; i < ACP_DEVS ; i++) {\n\t\tdev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);\n\t\tr = pm_genpd_add_device(&adev->acp.acp_genpd->gpd, dev);\n\t\tif (r) {\n\t\t\tdev_err(dev, \"Failed to add dev to genpd\\n\");\n\t\t\tgoto failure;\n\t\t}\n\t}\n\n\n\t/* Assert Soft reset of ACP */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\n\tval |= ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\n\tcount = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\t\tif (ACP_SOFT_RESET__SoftResetAudDone_MASK ==\n\t\t    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\tr = -ETIMEDOUT;\n\t\t\tgoto failure;\n\t\t}\n\t\tudelay(100);\n\t}\n\t/* Enable clock to ACP and wait until the clock is enabled */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_CONTROL);\n\tval = val | ACP_CONTROL__ClkEn_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_CONTROL, val);\n\n\tcount = ACP_CLOCK_EN_TIME_OUT_VALUE;\n\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_STATUS);\n\t\tif (val & (u32) 0x1)\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\tr = -ETIMEDOUT;\n\t\t\tgoto failure;\n\t\t}\n\t\tudelay(100);\n\t}\n\t/* Deassert the SOFT RESET flags */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\tval &= ~ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\treturn 0;\n\nfailure:\n\tkfree(i2s_pdata);\n\tkfree(adev->acp.acp_res);\n\tkfree(adev->acp.acp_cell);\n\tkfree(adev->acp.acp_genpd);\n\treturn r;\n}\n\n/**\n * acp_hw_fini - stop the hardware block\n *\n * @adev: amdgpu_device pointer\n *\n */\nstatic int acp_hw_fini(void *handle)\n{\n\tint i, ret;\n\tu32 val = 0;\n\tu32 count = 0;\n\tstruct device *dev;\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t/* return early if no ACP */\n\tif (!adev->acp.acp_genpd) {\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, false);\n\t\treturn 0;\n\t}\n\n\t/* Assert Soft reset of ACP */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\n\tval |= ACP_SOFT_RESET__SoftResetAud_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val);\n\n\tcount = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE;\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET);\n\t\tif (ACP_SOFT_RESET__SoftResetAudDone_MASK ==\n\t\t    (val & ACP_SOFT_RESET__SoftResetAudDone_MASK))\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\t/* Disable ACP clock */\n\tval = cgs_read_register(adev->acp.cgs_device, mmACP_CONTROL);\n\tval &= ~ACP_CONTROL__ClkEn_MASK;\n\tcgs_write_register(adev->acp.cgs_device, mmACP_CONTROL, val);\n\n\tcount = ACP_CLOCK_EN_TIME_OUT_VALUE;\n\n\twhile (true) {\n\t\tval = cgs_read_register(adev->acp.cgs_device, mmACP_STATUS);\n\t\tif (val & (u32) 0x1)\n\t\t\tbreak;\n\t\tif (--count == 0) {\n\t\t\tdev_err(&adev->pdev->dev, \"Failed to reset ACP\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\n\tfor (i = 0; i < ACP_DEVS ; i++) {\n\t\tdev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i);\n\t\tret = pm_genpd_remove_device(dev);\n\t\t/* If removal fails, dont giveup and try rest */\n\t\tif (ret)\n\t\t\tdev_err(dev, \"remove dev from genpd failed\\n\");\n\t}\n\n\tmfd_remove_devices(adev->acp.parent);\n\tkfree(adev->acp.acp_res);\n\tkfree(adev->acp.acp_genpd);\n\tkfree(adev->acp.acp_cell);\n\n\treturn 0;\n}\n\nstatic int acp_suspend(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t/* power up on suspend */\n\tif (!adev->acp.acp_cell)\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, false);\n\treturn 0;\n}\n\nstatic int acp_resume(void *handle)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\n\t/* power down again on resume */\n\tif (!adev->acp.acp_cell)\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true);\n\treturn 0;\n}\n\nstatic int acp_early_init(void *handle)\n{\n\treturn 0;\n}\n\nstatic bool acp_is_idle(void *handle)\n{\n\treturn true;\n}\n\nstatic int acp_wait_for_idle(void *handle)\n{\n\treturn 0;\n}\n\nstatic int acp_soft_reset(void *handle)\n{\n\treturn 0;\n}\n\nstatic int acp_set_clockgating_state(void *handle,\n\t\t\t\t     enum amd_clockgating_state state)\n{\n\treturn 0;\n}\n\nstatic int acp_set_powergating_state(void *handle,\n\t\t\t\t     enum amd_powergating_state state)\n{\n\tstruct amdgpu_device *adev = (struct amdgpu_device *)handle;\n\tbool enable = state == AMD_PG_STATE_GATE ? true : false;\n\n\tif (adev->powerplay.pp_funcs &&\n\t\tadev->powerplay.pp_funcs->set_powergating_by_smu)\n\t\tamdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, enable);\n\n\treturn 0;\n}\n\nstatic const struct amd_ip_funcs acp_ip_funcs = {\n\t.name = \"acp_ip\",\n\t.early_init = acp_early_init,\n\t.late_init = NULL,\n\t.sw_init = acp_sw_init,\n\t.sw_fini = acp_sw_fini,\n\t.hw_init = acp_hw_init,\n\t.hw_fini = acp_hw_fini,\n\t.suspend = acp_suspend,\n\t.resume = acp_resume,\n\t.is_idle = acp_is_idle,\n\t.wait_for_idle = acp_wait_for_idle,\n\t.soft_reset = acp_soft_reset,\n\t.set_clockgating_state = acp_set_clockgating_state,\n\t.set_powergating_state = acp_set_powergating_state,\n};\n\nconst struct amdgpu_ip_block_version acp_ip_block =\n{\n\t.type = AMD_IP_BLOCK_TYPE_ACP,\n\t.major = 2,\n\t.minor = 2,\n\t.rev = 0,\n\t.funcs = &acp_ip_funcs,\n};\n"], "filenames": ["drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c"], "buggy_code_start_loc": [192], "buggy_code_end_loc": [395], "fixing_code_start_loc": [192], "fixing_code_end_loc": [406], "type": "CWE-401", "message": "** DISPUTED ** Four memory leaks in the acp_hw_init() function in drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption) by triggering mfd_add_hotplug_devices() or pm_genpd_add_device() failures, aka CID-57be09c6e874. NOTE: third parties dispute the relevance of this because the attacker must already have privileges for module loading.", "other": {"cve": {"id": "CVE-2019-19067", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-18T06:15:12.797", "lastModified": "2020-09-25T18:15:14.050", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "** DISPUTED ** Four memory leaks in the acp_hw_init() function in drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption) by triggering mfd_add_hotplug_devices() or pm_genpd_add_device() failures, aka CID-57be09c6e874. NOTE: third parties dispute the relevance of this because the attacker must already have privileges for module loading."}, {"lang": "es", "value": "** EN DISPUTA ** Cuatro p\u00e9rdidas de memoria en la funci\u00f3n acp_hw_init() en el archivo drivers/gpu/drm/amd/amdgpu/amdgpu_acp.c en el kernel de Linux versiones anteriores a la versi\u00f3n 5.3.8, permiten a atacantes causar una denegaci\u00f3n de servicio (consumo de memoria) al desencadenar fallos de la funci\u00f3n mfd_add_hotplug_devices() o pm_genpd_add_device(), tambi\u00e9n se conoce como CID-57be09c6e874. NOTA: terceros discuten la relevancia de esto porque el atacante ya debe tener privilegios para cargar el m\u00f3dulo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-401"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.3.8", "matchCriteriaId": "AEC4B6C4-7934-4B29-A754-F6B88C80CF6E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-12/msg00029.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1157180", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.3.8", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/57be09c6e8747bf48704136d9e3f92bfb93f5725", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4208-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4226-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4526-1/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/57be09c6e8747bf48704136d9e3f92bfb93f5725"}}