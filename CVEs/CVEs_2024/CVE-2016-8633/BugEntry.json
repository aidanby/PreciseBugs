{"buggy_code": ["/*\n * IPv4 over IEEE 1394, per RFC 2734\n * IPv6 over IEEE 1394, per RFC 3146\n *\n * Copyright (C) 2009 Jay Fenlason <fenlason@redhat.com>\n *\n * based on eth1394 by Ben Collins et al\n */\n\n#include <linux/bug.h>\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/ethtool.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/highmem.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/jiffies.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <asm/unaligned.h>\n#include <net/arp.h>\n#include <net/firewire.h>\n\n/* rx limits */\n#define FWNET_MAX_FRAGMENTS\t\t30 /* arbitrary, > TX queue depth */\n#define FWNET_ISO_PAGE_COUNT\t\t(PAGE_SIZE < 16*1024 ? 4 : 2)\n\n/* tx limits */\n#define FWNET_MAX_QUEUED_DATAGRAMS\t20 /* < 64 = number of tlabels */\n#define FWNET_MIN_QUEUED_DATAGRAMS\t10 /* should keep AT DMA busy enough */\n#define FWNET_TX_QUEUE_LEN\t\tFWNET_MAX_QUEUED_DATAGRAMS /* ? */\n\n#define IEEE1394_BROADCAST_CHANNEL\t31\n#define IEEE1394_ALL_NODES\t\t(0xffc0 | 0x003f)\n#define IEEE1394_MAX_PAYLOAD_S100\t512\n#define FWNET_NO_FIFO_ADDR\t\t(~0ULL)\n\n#define IANA_SPECIFIER_ID\t\t0x00005eU\n#define RFC2734_SW_VERSION\t\t0x000001U\n#define RFC3146_SW_VERSION\t\t0x000002U\n\n#define IEEE1394_GASP_HDR_SIZE\t8\n\n#define RFC2374_UNFRAG_HDR_SIZE\t4\n#define RFC2374_FRAG_HDR_SIZE\t8\n#define RFC2374_FRAG_OVERHEAD\t4\n\n#define RFC2374_HDR_UNFRAG\t0\t/* unfragmented\t\t*/\n#define RFC2374_HDR_FIRSTFRAG\t1\t/* first fragment\t*/\n#define RFC2374_HDR_LASTFRAG\t2\t/* last fragment\t*/\n#define RFC2374_HDR_INTFRAG\t3\t/* interior fragment\t*/\n\nstatic bool fwnet_hwaddr_is_multicast(u8 *ha)\n{\n\treturn !!(*ha & 1);\n}\n\n/* IPv4 and IPv6 encapsulation header */\nstruct rfc2734_header {\n\tu32 w0;\n\tu32 w1;\n};\n\n#define fwnet_get_hdr_lf(h)\t\t(((h)->w0 & 0xc0000000) >> 30)\n#define fwnet_get_hdr_ether_type(h)\t(((h)->w0 & 0x0000ffff))\n#define fwnet_get_hdr_dg_size(h)\t(((h)->w0 & 0x0fff0000) >> 16)\n#define fwnet_get_hdr_fg_off(h)\t\t(((h)->w0 & 0x00000fff))\n#define fwnet_get_hdr_dgl(h)\t\t(((h)->w1 & 0xffff0000) >> 16)\n\n#define fwnet_set_hdr_lf(lf)\t\t((lf)  << 30)\n#define fwnet_set_hdr_ether_type(et)\t(et)\n#define fwnet_set_hdr_dg_size(dgs)\t((dgs) << 16)\n#define fwnet_set_hdr_fg_off(fgo)\t(fgo)\n\n#define fwnet_set_hdr_dgl(dgl)\t\t((dgl) << 16)\n\nstatic inline void fwnet_make_uf_hdr(struct rfc2734_header *hdr,\n\t\tunsigned ether_type)\n{\n\thdr->w0 = fwnet_set_hdr_lf(RFC2374_HDR_UNFRAG)\n\t\t  | fwnet_set_hdr_ether_type(ether_type);\n}\n\nstatic inline void fwnet_make_ff_hdr(struct rfc2734_header *hdr,\n\t\tunsigned ether_type, unsigned dg_size, unsigned dgl)\n{\n\thdr->w0 = fwnet_set_hdr_lf(RFC2374_HDR_FIRSTFRAG)\n\t\t  | fwnet_set_hdr_dg_size(dg_size)\n\t\t  | fwnet_set_hdr_ether_type(ether_type);\n\thdr->w1 = fwnet_set_hdr_dgl(dgl);\n}\n\nstatic inline void fwnet_make_sf_hdr(struct rfc2734_header *hdr,\n\t\tunsigned lf, unsigned dg_size, unsigned fg_off, unsigned dgl)\n{\n\thdr->w0 = fwnet_set_hdr_lf(lf)\n\t\t  | fwnet_set_hdr_dg_size(dg_size)\n\t\t  | fwnet_set_hdr_fg_off(fg_off);\n\thdr->w1 = fwnet_set_hdr_dgl(dgl);\n}\n\n/* This list keeps track of what parts of the datagram have been filled in */\nstruct fwnet_fragment_info {\n\tstruct list_head fi_link;\n\tu16 offset;\n\tu16 len;\n};\n\nstruct fwnet_partial_datagram {\n\tstruct list_head pd_link;\n\tstruct list_head fi_list;\n\tstruct sk_buff *skb;\n\t/* FIXME Why not use skb->data? */\n\tchar *pbuf;\n\tu16 datagram_label;\n\tu16 ether_type;\n\tu16 datagram_size;\n};\n\nstatic DEFINE_MUTEX(fwnet_device_mutex);\nstatic LIST_HEAD(fwnet_device_list);\n\nstruct fwnet_device {\n\tstruct list_head dev_link;\n\tspinlock_t lock;\n\tenum {\n\t\tFWNET_BROADCAST_ERROR,\n\t\tFWNET_BROADCAST_RUNNING,\n\t\tFWNET_BROADCAST_STOPPED,\n\t} broadcast_state;\n\tstruct fw_iso_context *broadcast_rcv_context;\n\tstruct fw_iso_buffer broadcast_rcv_buffer;\n\tvoid **broadcast_rcv_buffer_ptrs;\n\tunsigned broadcast_rcv_next_ptr;\n\tunsigned num_broadcast_rcv_ptrs;\n\tunsigned rcv_buffer_size;\n\t/*\n\t * This value is the maximum unfragmented datagram size that can be\n\t * sent by the hardware.  It already has the GASP overhead and the\n\t * unfragmented datagram header overhead calculated into it.\n\t */\n\tunsigned broadcast_xmt_max_payload;\n\tu16 broadcast_xmt_datagramlabel;\n\n\t/*\n\t * The CSR address that remote nodes must send datagrams to for us to\n\t * receive them.\n\t */\n\tstruct fw_address_handler handler;\n\tu64 local_fifo;\n\n\t/* Number of tx datagrams that have been queued but not yet acked */\n\tint queued_datagrams;\n\n\tint peer_count;\n\tstruct list_head peer_list;\n\tstruct fw_card *card;\n\tstruct net_device *netdev;\n};\n\nstruct fwnet_peer {\n\tstruct list_head peer_link;\n\tstruct fwnet_device *dev;\n\tu64 guid;\n\n\t/* guarded by dev->lock */\n\tstruct list_head pd_list; /* received partial datagrams */\n\tunsigned pdg_size;        /* pd_list size */\n\n\tu16 datagram_label;       /* outgoing datagram label */\n\tu16 max_payload;          /* includes RFC2374_FRAG_HDR_SIZE overhead */\n\tint node_id;\n\tint generation;\n\tunsigned speed;\n};\n\n/* This is our task struct. It's used for the packet complete callback.  */\nstruct fwnet_packet_task {\n\tstruct fw_transaction transaction;\n\tstruct rfc2734_header hdr;\n\tstruct sk_buff *skb;\n\tstruct fwnet_device *dev;\n\n\tint outstanding_pkts;\n\tu64 fifo_addr;\n\tu16 dest_node;\n\tu16 max_payload;\n\tu8 generation;\n\tu8 speed;\n\tu8 enqueued;\n};\n\n/*\n * Get fifo address embedded in hwaddr\n */\nstatic __u64 fwnet_hwaddr_fifo(union fwnet_hwaddr *ha)\n{\n\treturn (u64)get_unaligned_be16(&ha->uc.fifo_hi) << 32\n\t       | get_unaligned_be32(&ha->uc.fifo_lo);\n}\n\n/*\n * saddr == NULL means use device source address.\n * daddr == NULL means leave destination address (eg unresolved arp).\n */\nstatic int fwnet_header_create(struct sk_buff *skb, struct net_device *net,\n\t\t\tunsigned short type, const void *daddr,\n\t\t\tconst void *saddr, unsigned len)\n{\n\tstruct fwnet_header *h;\n\n\th = (struct fwnet_header *)skb_push(skb, sizeof(*h));\n\tput_unaligned_be16(type, &h->h_proto);\n\n\tif (net->flags & (IFF_LOOPBACK | IFF_NOARP)) {\n\t\tmemset(h->h_dest, 0, net->addr_len);\n\n\t\treturn net->hard_header_len;\n\t}\n\n\tif (daddr) {\n\t\tmemcpy(h->h_dest, daddr, net->addr_len);\n\n\t\treturn net->hard_header_len;\n\t}\n\n\treturn -net->hard_header_len;\n}\n\nstatic int fwnet_header_cache(const struct neighbour *neigh,\n\t\t\t      struct hh_cache *hh, __be16 type)\n{\n\tstruct net_device *net;\n\tstruct fwnet_header *h;\n\n\tif (type == cpu_to_be16(ETH_P_802_3))\n\t\treturn -1;\n\tnet = neigh->dev;\n\th = (struct fwnet_header *)((u8 *)hh->hh_data + HH_DATA_OFF(sizeof(*h)));\n\th->h_proto = type;\n\tmemcpy(h->h_dest, neigh->ha, net->addr_len);\n\thh->hh_len = FWNET_HLEN;\n\n\treturn 0;\n}\n\n/* Called by Address Resolution module to notify changes in address. */\nstatic void fwnet_header_cache_update(struct hh_cache *hh,\n\t\tconst struct net_device *net, const unsigned char *haddr)\n{\n\tmemcpy((u8 *)hh->hh_data + HH_DATA_OFF(FWNET_HLEN), haddr, net->addr_len);\n}\n\nstatic int fwnet_header_parse(const struct sk_buff *skb, unsigned char *haddr)\n{\n\tmemcpy(haddr, skb->dev->dev_addr, FWNET_ALEN);\n\n\treturn FWNET_ALEN;\n}\n\nstatic const struct header_ops fwnet_header_ops = {\n\t.create         = fwnet_header_create,\n\t.cache\t\t= fwnet_header_cache,\n\t.cache_update\t= fwnet_header_cache_update,\n\t.parse          = fwnet_header_parse,\n};\n\n/* FIXME: is this correct for all cases? */\nstatic bool fwnet_frag_overlap(struct fwnet_partial_datagram *pd,\n\t\t\t       unsigned offset, unsigned len)\n{\n\tstruct fwnet_fragment_info *fi;\n\tunsigned end = offset + len;\n\n\tlist_for_each_entry(fi, &pd->fi_list, fi_link)\n\t\tif (offset < fi->offset + fi->len && end > fi->offset)\n\t\t\treturn true;\n\n\treturn false;\n}\n\n/* Assumes that new fragment does not overlap any existing fragments */\nstatic struct fwnet_fragment_info *fwnet_frag_new(\n\tstruct fwnet_partial_datagram *pd, unsigned offset, unsigned len)\n{\n\tstruct fwnet_fragment_info *fi, *fi2, *new;\n\tstruct list_head *list;\n\n\tlist = &pd->fi_list;\n\tlist_for_each_entry(fi, &pd->fi_list, fi_link) {\n\t\tif (fi->offset + fi->len == offset) {\n\t\t\t/* The new fragment can be tacked on to the end */\n\t\t\t/* Did the new fragment plug a hole? */\n\t\t\tfi2 = list_entry(fi->fi_link.next,\n\t\t\t\t\t struct fwnet_fragment_info, fi_link);\n\t\t\tif (fi->offset + fi->len == fi2->offset) {\n\t\t\t\t/* glue fragments together */\n\t\t\t\tfi->len += len + fi2->len;\n\t\t\t\tlist_del(&fi2->fi_link);\n\t\t\t\tkfree(fi2);\n\t\t\t} else {\n\t\t\t\tfi->len += len;\n\t\t\t}\n\n\t\t\treturn fi;\n\t\t}\n\t\tif (offset + len == fi->offset) {\n\t\t\t/* The new fragment can be tacked on to the beginning */\n\t\t\t/* Did the new fragment plug a hole? */\n\t\t\tfi2 = list_entry(fi->fi_link.prev,\n\t\t\t\t\t struct fwnet_fragment_info, fi_link);\n\t\t\tif (fi2->offset + fi2->len == fi->offset) {\n\t\t\t\t/* glue fragments together */\n\t\t\t\tfi2->len += fi->len + len;\n\t\t\t\tlist_del(&fi->fi_link);\n\t\t\t\tkfree(fi);\n\n\t\t\t\treturn fi2;\n\t\t\t}\n\t\t\tfi->offset = offset;\n\t\t\tfi->len += len;\n\n\t\t\treturn fi;\n\t\t}\n\t\tif (offset > fi->offset + fi->len) {\n\t\t\tlist = &fi->fi_link;\n\t\t\tbreak;\n\t\t}\n\t\tif (offset + len < fi->offset) {\n\t\t\tlist = fi->fi_link.prev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnew = kmalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\treturn NULL;\n\n\tnew->offset = offset;\n\tnew->len = len;\n\tlist_add(&new->fi_link, list);\n\n\treturn new;\n}\n\nstatic struct fwnet_partial_datagram *fwnet_pd_new(struct net_device *net,\n\t\tstruct fwnet_peer *peer, u16 datagram_label, unsigned dg_size,\n\t\tvoid *frag_buf, unsigned frag_off, unsigned frag_len)\n{\n\tstruct fwnet_partial_datagram *new;\n\tstruct fwnet_fragment_info *fi;\n\n\tnew = kmalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\tgoto fail;\n\n\tINIT_LIST_HEAD(&new->fi_list);\n\tfi = fwnet_frag_new(new, frag_off, frag_len);\n\tif (fi == NULL)\n\t\tgoto fail_w_new;\n\n\tnew->datagram_label = datagram_label;\n\tnew->datagram_size = dg_size;\n\tnew->skb = dev_alloc_skb(dg_size + LL_RESERVED_SPACE(net));\n\tif (new->skb == NULL)\n\t\tgoto fail_w_fi;\n\n\tskb_reserve(new->skb, LL_RESERVED_SPACE(net));\n\tnew->pbuf = skb_put(new->skb, dg_size);\n\tmemcpy(new->pbuf + frag_off, frag_buf, frag_len);\n\tlist_add_tail(&new->pd_link, &peer->pd_list);\n\n\treturn new;\n\nfail_w_fi:\n\tkfree(fi);\nfail_w_new:\n\tkfree(new);\nfail:\n\treturn NULL;\n}\n\nstatic struct fwnet_partial_datagram *fwnet_pd_find(struct fwnet_peer *peer,\n\t\t\t\t\t\t    u16 datagram_label)\n{\n\tstruct fwnet_partial_datagram *pd;\n\n\tlist_for_each_entry(pd, &peer->pd_list, pd_link)\n\t\tif (pd->datagram_label == datagram_label)\n\t\t\treturn pd;\n\n\treturn NULL;\n}\n\n\nstatic void fwnet_pd_delete(struct fwnet_partial_datagram *old)\n{\n\tstruct fwnet_fragment_info *fi, *n;\n\n\tlist_for_each_entry_safe(fi, n, &old->fi_list, fi_link)\n\t\tkfree(fi);\n\n\tlist_del(&old->pd_link);\n\tdev_kfree_skb_any(old->skb);\n\tkfree(old);\n}\n\nstatic bool fwnet_pd_update(struct fwnet_peer *peer,\n\t\tstruct fwnet_partial_datagram *pd, void *frag_buf,\n\t\tunsigned frag_off, unsigned frag_len)\n{\n\tif (fwnet_frag_new(pd, frag_off, frag_len) == NULL)\n\t\treturn false;\n\n\tmemcpy(pd->pbuf + frag_off, frag_buf, frag_len);\n\n\t/*\n\t * Move list entry to beginning of list so that oldest partial\n\t * datagrams percolate to the end of the list\n\t */\n\tlist_move_tail(&pd->pd_link, &peer->pd_list);\n\n\treturn true;\n}\n\nstatic bool fwnet_pd_is_complete(struct fwnet_partial_datagram *pd)\n{\n\tstruct fwnet_fragment_info *fi;\n\n\tfi = list_entry(pd->fi_list.next, struct fwnet_fragment_info, fi_link);\n\n\treturn fi->len == pd->datagram_size;\n}\n\n/* caller must hold dev->lock */\nstatic struct fwnet_peer *fwnet_peer_find_by_guid(struct fwnet_device *dev,\n\t\t\t\t\t\t  u64 guid)\n{\n\tstruct fwnet_peer *peer;\n\n\tlist_for_each_entry(peer, &dev->peer_list, peer_link)\n\t\tif (peer->guid == guid)\n\t\t\treturn peer;\n\n\treturn NULL;\n}\n\n/* caller must hold dev->lock */\nstatic struct fwnet_peer *fwnet_peer_find_by_node_id(struct fwnet_device *dev,\n\t\t\t\t\t\tint node_id, int generation)\n{\n\tstruct fwnet_peer *peer;\n\n\tlist_for_each_entry(peer, &dev->peer_list, peer_link)\n\t\tif (peer->node_id    == node_id &&\n\t\t    peer->generation == generation)\n\t\t\treturn peer;\n\n\treturn NULL;\n}\n\n/* See IEEE 1394-2008 table 6-4, table 8-8, table 16-18. */\nstatic unsigned fwnet_max_payload(unsigned max_rec, unsigned speed)\n{\n\tmax_rec = min(max_rec, speed + 8);\n\tmax_rec = clamp(max_rec, 8U, 11U); /* 512...4096 */\n\n\treturn (1 << (max_rec + 1)) - RFC2374_FRAG_HDR_SIZE;\n}\n\n\nstatic int fwnet_finish_incoming_packet(struct net_device *net,\n\t\t\t\t\tstruct sk_buff *skb, u16 source_node_id,\n\t\t\t\t\tbool is_broadcast, u16 ether_type)\n{\n\tstruct fwnet_device *dev;\n\tint status;\n\t__be64 guid;\n\n\tswitch (ether_type) {\n\tcase ETH_P_ARP:\n\tcase ETH_P_IP:\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase ETH_P_IPV6:\n#endif\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\tdev = netdev_priv(net);\n\t/* Write metadata, and then pass to the receive level */\n\tskb->dev = net;\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t/*\n\t * Parse the encapsulation header. This actually does the job of\n\t * converting to an ethernet-like pseudo frame header.\n\t */\n\tguid = cpu_to_be64(dev->card->guid);\n\tif (dev_hard_header(skb, net, ether_type,\n\t\t\t   is_broadcast ? net->broadcast : net->dev_addr,\n\t\t\t   NULL, skb->len) >= 0) {\n\t\tstruct fwnet_header *eth;\n\t\tu16 *rawp;\n\t\t__be16 protocol;\n\n\t\tskb_reset_mac_header(skb);\n\t\tskb_pull(skb, sizeof(*eth));\n\t\teth = (struct fwnet_header *)skb_mac_header(skb);\n\t\tif (fwnet_hwaddr_is_multicast(eth->h_dest)) {\n\t\t\tif (memcmp(eth->h_dest, net->broadcast,\n\t\t\t\t   net->addr_len) == 0)\n\t\t\t\tskb->pkt_type = PACKET_BROADCAST;\n#if 0\n\t\t\telse\n\t\t\t\tskb->pkt_type = PACKET_MULTICAST;\n#endif\n\t\t} else {\n\t\t\tif (memcmp(eth->h_dest, net->dev_addr, net->addr_len))\n\t\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t}\n\t\tif (ntohs(eth->h_proto) >= ETH_P_802_3_MIN) {\n\t\t\tprotocol = eth->h_proto;\n\t\t} else {\n\t\t\trawp = (u16 *)skb->data;\n\t\t\tif (*rawp == 0xffff)\n\t\t\t\tprotocol = htons(ETH_P_802_3);\n\t\t\telse\n\t\t\t\tprotocol = htons(ETH_P_802_2);\n\t\t}\n\t\tskb->protocol = protocol;\n\t}\n\tstatus = netif_rx(skb);\n\tif (status == NET_RX_DROP) {\n\t\tnet->stats.rx_errors++;\n\t\tnet->stats.rx_dropped++;\n\t} else {\n\t\tnet->stats.rx_packets++;\n\t\tnet->stats.rx_bytes += skb->len;\n\t}\n\n\treturn 0;\n\n err:\n\tnet->stats.rx_errors++;\n\tnet->stats.rx_dropped++;\n\n\tdev_kfree_skb_any(skb);\n\n\treturn -ENOENT;\n}\n\nstatic int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\t/* A datagram fragment has been received, now the fun begins. */\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}\n\nstatic void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,\n\t\tint tcode, int destination, int source, int generation,\n\t\tunsigned long long offset, void *payload, size_t length,\n\t\tvoid *callback_data)\n{\n\tstruct fwnet_device *dev = callback_data;\n\tint rcode;\n\n\tif (destination == IEEE1394_ALL_NODES) {\n\t\tkfree(r);\n\n\t\treturn;\n\t}\n\n\tif (offset != dev->handler.offset)\n\t\trcode = RCODE_ADDRESS_ERROR;\n\telse if (tcode != TCODE_WRITE_BLOCK_REQUEST)\n\t\trcode = RCODE_TYPE_ERROR;\n\telse if (fwnet_incoming_packet(dev, payload, length,\n\t\t\t\t       source, generation, false) != 0) {\n\t\tdev_err(&dev->netdev->dev, \"incoming packet failure\\n\");\n\t\trcode = RCODE_CONFLICT_ERROR;\n\t} else\n\t\trcode = RCODE_COMPLETE;\n\n\tfw_send_response(card, r, rcode);\n}\n\nstatic void fwnet_receive_broadcast(struct fw_iso_context *context,\n\t\tu32 cycle, size_t header_length, void *header, void *data)\n{\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n\t__be32 *buf_ptr;\n\tint retval;\n\tu32 length;\n\tu16 source_node_id;\n\tu32 specifier_id;\n\tu32 ver;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8\n\t\t\t| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;\n\tver = be32_to_cpu(buf_ptr[1]) & 0xffffff;\n\tsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;\n\n\tif (specifier_id == IANA_SPECIFIER_ID &&\n\t    (ver == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n\t     || ver == RFC3146_SW_VERSION\n#endif\n\t    )) {\n\t\tbuf_ptr += 2;\n\t\tlength -= IEEE1394_GASP_HDR_SIZE;\n\t\tfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,\n\t\t\t\t      context->card->generation, true);\n\t}\n\n\tpacket.payload_length = dev->rcv_buffer_size;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}\n\nstatic struct kmem_cache *fwnet_packet_task_cache;\n\nstatic void fwnet_free_ptask(struct fwnet_packet_task *ptask)\n{\n\tdev_kfree_skb_any(ptask->skb);\n\tkmem_cache_free(fwnet_packet_task_cache, ptask);\n}\n\n/* Caller must hold dev->lock. */\nstatic void dec_queued_datagrams(struct fwnet_device *dev)\n{\n\tif (--dev->queued_datagrams == FWNET_MIN_QUEUED_DATAGRAMS)\n\t\tnetif_wake_queue(dev->netdev);\n}\n\nstatic int fwnet_send_packet(struct fwnet_packet_task *ptask);\n\nstatic void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)\n{\n\tstruct fwnet_device *dev = ptask->dev;\n\tstruct sk_buff *skb = ptask->skb;\n\tunsigned long flags;\n\tbool free;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tptask->outstanding_pkts--;\n\n\t/* Check whether we or the networking TX soft-IRQ is last user. */\n\tfree = (ptask->outstanding_pkts == 0 && ptask->enqueued);\n\tif (free)\n\t\tdec_queued_datagrams(dev);\n\n\tif (ptask->outstanding_pkts == 0) {\n\t\tdev->netdev->stats.tx_packets++;\n\t\tdev->netdev->stats.tx_bytes += skb->len;\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (ptask->outstanding_pkts > 0) {\n\t\tu16 dg_size;\n\t\tu16 fg_off;\n\t\tu16 datagram_label;\n\t\tu16 lf;\n\n\t\t/* Update the ptask to point to the next fragment and send it */\n\t\tlf = fwnet_get_hdr_lf(&ptask->hdr);\n\t\tswitch (lf) {\n\t\tcase RFC2374_HDR_LASTFRAG:\n\t\tcase RFC2374_HDR_UNFRAG:\n\t\tdefault:\n\t\t\tdev_err(&dev->netdev->dev,\n\t\t\t\t\"outstanding packet %x lf %x, header %x,%x\\n\",\n\t\t\t\tptask->outstanding_pkts, lf, ptask->hdr.w0,\n\t\t\t\tptask->hdr.w1);\n\t\t\tBUG();\n\n\t\tcase RFC2374_HDR_FIRSTFRAG:\n\t\t\t/* Set frag type here for future interior fragments */\n\t\t\tdg_size = fwnet_get_hdr_dg_size(&ptask->hdr);\n\t\t\tfg_off = ptask->max_payload - RFC2374_FRAG_HDR_SIZE;\n\t\t\tdatagram_label = fwnet_get_hdr_dgl(&ptask->hdr);\n\t\t\tbreak;\n\n\t\tcase RFC2374_HDR_INTFRAG:\n\t\t\tdg_size = fwnet_get_hdr_dg_size(&ptask->hdr);\n\t\t\tfg_off = fwnet_get_hdr_fg_off(&ptask->hdr)\n\t\t\t\t  + ptask->max_payload - RFC2374_FRAG_HDR_SIZE;\n\t\t\tdatagram_label = fwnet_get_hdr_dgl(&ptask->hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ptask->dest_node == IEEE1394_ALL_NODES) {\n\t\t\tskb_pull(skb,\n\t\t\t\t ptask->max_payload + IEEE1394_GASP_HDR_SIZE);\n\t\t} else {\n\t\t\tskb_pull(skb, ptask->max_payload);\n\t\t}\n\t\tif (ptask->outstanding_pkts > 1) {\n\t\t\tfwnet_make_sf_hdr(&ptask->hdr, RFC2374_HDR_INTFRAG,\n\t\t\t\t\t  dg_size, fg_off, datagram_label);\n\t\t} else {\n\t\t\tfwnet_make_sf_hdr(&ptask->hdr, RFC2374_HDR_LASTFRAG,\n\t\t\t\t\t  dg_size, fg_off, datagram_label);\n\t\t\tptask->max_payload = skb->len + RFC2374_FRAG_HDR_SIZE;\n\t\t}\n\t\tfwnet_send_packet(ptask);\n\t}\n\n\tif (free)\n\t\tfwnet_free_ptask(ptask);\n}\n\nstatic void fwnet_transmit_packet_failed(struct fwnet_packet_task *ptask)\n{\n\tstruct fwnet_device *dev = ptask->dev;\n\tunsigned long flags;\n\tbool free;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t/* One fragment failed; don't try to send remaining fragments. */\n\tptask->outstanding_pkts = 0;\n\n\t/* Check whether we or the networking TX soft-IRQ is last user. */\n\tfree = ptask->enqueued;\n\tif (free)\n\t\tdec_queued_datagrams(dev);\n\n\tdev->netdev->stats.tx_dropped++;\n\tdev->netdev->stats.tx_errors++;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (free)\n\t\tfwnet_free_ptask(ptask);\n}\n\nstatic void fwnet_write_complete(struct fw_card *card, int rcode,\n\t\t\t\t void *payload, size_t length, void *data)\n{\n\tstruct fwnet_packet_task *ptask = data;\n\tstatic unsigned long j;\n\tstatic int last_rcode, errors_skipped;\n\n\tif (rcode == RCODE_COMPLETE) {\n\t\tfwnet_transmit_packet_done(ptask);\n\t} else {\n\t\tif (printk_timed_ratelimit(&j,  1000) || rcode != last_rcode) {\n\t\t\tdev_err(&ptask->dev->netdev->dev,\n\t\t\t\t\"fwnet_write_complete failed: %x (skipped %d)\\n\",\n\t\t\t\trcode, errors_skipped);\n\n\t\t\terrors_skipped = 0;\n\t\t\tlast_rcode = rcode;\n\t\t} else {\n\t\t\terrors_skipped++;\n\t\t}\n\t\tfwnet_transmit_packet_failed(ptask);\n\t}\n}\n\nstatic int fwnet_send_packet(struct fwnet_packet_task *ptask)\n{\n\tstruct fwnet_device *dev;\n\tunsigned tx_len;\n\tstruct rfc2734_header *bufhdr;\n\tunsigned long flags;\n\tbool free;\n\n\tdev = ptask->dev;\n\ttx_len = ptask->max_payload;\n\tswitch (fwnet_get_hdr_lf(&ptask->hdr)) {\n\tcase RFC2374_HDR_UNFRAG:\n\t\tbufhdr = (struct rfc2734_header *)\n\t\t\t\tskb_push(ptask->skb, RFC2374_UNFRAG_HDR_SIZE);\n\t\tput_unaligned_be32(ptask->hdr.w0, &bufhdr->w0);\n\t\tbreak;\n\n\tcase RFC2374_HDR_FIRSTFRAG:\n\tcase RFC2374_HDR_INTFRAG:\n\tcase RFC2374_HDR_LASTFRAG:\n\t\tbufhdr = (struct rfc2734_header *)\n\t\t\t\tskb_push(ptask->skb, RFC2374_FRAG_HDR_SIZE);\n\t\tput_unaligned_be32(ptask->hdr.w0, &bufhdr->w0);\n\t\tput_unaligned_be32(ptask->hdr.w1, &bufhdr->w1);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\tif (ptask->dest_node == IEEE1394_ALL_NODES) {\n\t\tu8 *p;\n\t\tint generation;\n\t\tint node_id;\n\t\tunsigned int sw_version;\n\n\t\t/* ptask->generation may not have been set yet */\n\t\tgeneration = dev->card->generation;\n\t\tsmp_rmb();\n\t\tnode_id = dev->card->node_id;\n\n\t\tswitch (ptask->skb->protocol) {\n\t\tdefault:\n\t\t\tsw_version = RFC2734_SW_VERSION;\n\t\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tsw_version = RFC3146_SW_VERSION;\n#endif\n\t\t}\n\n\t\tp = skb_push(ptask->skb, IEEE1394_GASP_HDR_SIZE);\n\t\tput_unaligned_be32(node_id << 16 | IANA_SPECIFIER_ID >> 8, p);\n\t\tput_unaligned_be32((IANA_SPECIFIER_ID & 0xff) << 24\n\t\t\t\t\t\t| sw_version, &p[4]);\n\n\t\t/* We should not transmit if broadcast_channel.valid == 0. */\n\t\tfw_send_request(dev->card, &ptask->transaction,\n\t\t\t\tTCODE_STREAM_DATA,\n\t\t\t\tfw_stream_packet_destination_id(3,\n\t\t\t\t\t\tIEEE1394_BROADCAST_CHANNEL, 0),\n\t\t\t\tgeneration, SCODE_100, 0ULL, ptask->skb->data,\n\t\t\t\ttx_len + 8, fwnet_write_complete, ptask);\n\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\n\t\t/* If the AT tasklet already ran, we may be last user. */\n\t\tfree = (ptask->outstanding_pkts == 0 && !ptask->enqueued);\n\t\tif (!free)\n\t\t\tptask->enqueued = true;\n\t\telse\n\t\t\tdec_queued_datagrams(dev);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\tgoto out;\n\t}\n\n\tfw_send_request(dev->card, &ptask->transaction,\n\t\t\tTCODE_WRITE_BLOCK_REQUEST, ptask->dest_node,\n\t\t\tptask->generation, ptask->speed, ptask->fifo_addr,\n\t\t\tptask->skb->data, tx_len, fwnet_write_complete, ptask);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t/* If the AT tasklet already ran, we may be last user. */\n\tfree = (ptask->outstanding_pkts == 0 && !ptask->enqueued);\n\tif (!free)\n\t\tptask->enqueued = true;\n\telse\n\t\tdec_queued_datagrams(dev);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tnetif_trans_update(dev->netdev);\n out:\n\tif (free)\n\t\tfwnet_free_ptask(ptask);\n\n\treturn 0;\n}\n\nstatic void fwnet_fifo_stop(struct fwnet_device *dev)\n{\n\tif (dev->local_fifo == FWNET_NO_FIFO_ADDR)\n\t\treturn;\n\n\tfw_core_remove_address_handler(&dev->handler);\n\tdev->local_fifo = FWNET_NO_FIFO_ADDR;\n}\n\nstatic int fwnet_fifo_start(struct fwnet_device *dev)\n{\n\tint retval;\n\n\tif (dev->local_fifo != FWNET_NO_FIFO_ADDR)\n\t\treturn 0;\n\n\tdev->handler.length = 4096;\n\tdev->handler.address_callback = fwnet_receive_packet;\n\tdev->handler.callback_data = dev;\n\n\tretval = fw_core_add_address_handler(&dev->handler,\n\t\t\t\t\t     &fw_high_memory_region);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tdev->local_fifo = dev->handler.offset;\n\n\treturn 0;\n}\n\nstatic void __fwnet_broadcast_stop(struct fwnet_device *dev)\n{\n\tunsigned u;\n\n\tif (dev->broadcast_state != FWNET_BROADCAST_ERROR) {\n\t\tfor (u = 0; u < FWNET_ISO_PAGE_COUNT; u++)\n\t\t\tkunmap(dev->broadcast_rcv_buffer.pages[u]);\n\t\tfw_iso_buffer_destroy(&dev->broadcast_rcv_buffer, dev->card);\n\t}\n\tif (dev->broadcast_rcv_context) {\n\t\tfw_iso_context_destroy(dev->broadcast_rcv_context);\n\t\tdev->broadcast_rcv_context = NULL;\n\t}\n\tkfree(dev->broadcast_rcv_buffer_ptrs);\n\tdev->broadcast_rcv_buffer_ptrs = NULL;\n\tdev->broadcast_state = FWNET_BROADCAST_ERROR;\n}\n\nstatic void fwnet_broadcast_stop(struct fwnet_device *dev)\n{\n\tif (dev->broadcast_state == FWNET_BROADCAST_ERROR)\n\t\treturn;\n\tfw_iso_context_stop(dev->broadcast_rcv_context);\n\t__fwnet_broadcast_stop(dev);\n}\n\nstatic int fwnet_broadcast_start(struct fwnet_device *dev)\n{\n\tstruct fw_iso_context *context;\n\tint retval;\n\tunsigned num_packets;\n\tunsigned max_receive;\n\tstruct fw_iso_packet packet;\n\tunsigned long offset;\n\tvoid **ptrptr;\n\tunsigned u;\n\n\tif (dev->broadcast_state != FWNET_BROADCAST_ERROR)\n\t\treturn 0;\n\n\tmax_receive = 1U << (dev->card->max_receive + 1);\n\tnum_packets = (FWNET_ISO_PAGE_COUNT * PAGE_SIZE) / max_receive;\n\n\tptrptr = kmalloc(sizeof(void *) * num_packets, GFP_KERNEL);\n\tif (!ptrptr) {\n\t\tretval = -ENOMEM;\n\t\tgoto failed;\n\t}\n\tdev->broadcast_rcv_buffer_ptrs = ptrptr;\n\n\tcontext = fw_iso_context_create(dev->card, FW_ISO_CONTEXT_RECEIVE,\n\t\t\t\t\tIEEE1394_BROADCAST_CHANNEL,\n\t\t\t\t\tdev->card->link_speed, 8,\n\t\t\t\t\tfwnet_receive_broadcast, dev);\n\tif (IS_ERR(context)) {\n\t\tretval = PTR_ERR(context);\n\t\tgoto failed;\n\t}\n\n\tretval = fw_iso_buffer_init(&dev->broadcast_rcv_buffer, dev->card,\n\t\t\t\t    FWNET_ISO_PAGE_COUNT, DMA_FROM_DEVICE);\n\tif (retval < 0)\n\t\tgoto failed;\n\n\tdev->broadcast_state = FWNET_BROADCAST_STOPPED;\n\n\tfor (u = 0; u < FWNET_ISO_PAGE_COUNT; u++) {\n\t\tvoid *ptr;\n\t\tunsigned v;\n\n\t\tptr = kmap(dev->broadcast_rcv_buffer.pages[u]);\n\t\tfor (v = 0; v < num_packets / FWNET_ISO_PAGE_COUNT; v++)\n\t\t\t*ptrptr++ = (void *) ((char *)ptr + v * max_receive);\n\t}\n\tdev->broadcast_rcv_context = context;\n\n\tpacket.payload_length = max_receive;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\toffset = 0;\n\n\tfor (u = 0; u < num_packets; u++) {\n\t\tretval = fw_iso_context_queue(context, &packet,\n\t\t\t\t&dev->broadcast_rcv_buffer, offset);\n\t\tif (retval < 0)\n\t\t\tgoto failed;\n\n\t\toffset += max_receive;\n\t}\n\tdev->num_broadcast_rcv_ptrs = num_packets;\n\tdev->rcv_buffer_size = max_receive;\n\tdev->broadcast_rcv_next_ptr = 0U;\n\tretval = fw_iso_context_start(context, -1, 0,\n\t\t\tFW_ISO_CONTEXT_MATCH_ALL_TAGS); /* ??? sync */\n\tif (retval < 0)\n\t\tgoto failed;\n\n\t/* FIXME: adjust it according to the min. speed of all known peers? */\n\tdev->broadcast_xmt_max_payload = IEEE1394_MAX_PAYLOAD_S100\n\t\t\t- IEEE1394_GASP_HDR_SIZE - RFC2374_UNFRAG_HDR_SIZE;\n\tdev->broadcast_state = FWNET_BROADCAST_RUNNING;\n\n\treturn 0;\n\n failed:\n\t__fwnet_broadcast_stop(dev);\n\treturn retval;\n}\n\nstatic void set_carrier_state(struct fwnet_device *dev)\n{\n\tif (dev->peer_count > 1)\n\t\tnetif_carrier_on(dev->netdev);\n\telse\n\t\tnetif_carrier_off(dev->netdev);\n}\n\n/* ifup */\nstatic int fwnet_open(struct net_device *net)\n{\n\tstruct fwnet_device *dev = netdev_priv(net);\n\tint ret;\n\n\tret = fwnet_broadcast_start(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tnetif_start_queue(net);\n\n\tspin_lock_irq(&dev->lock);\n\tset_carrier_state(dev);\n\tspin_unlock_irq(&dev->lock);\n\n\treturn 0;\n}\n\n/* ifdown */\nstatic int fwnet_stop(struct net_device *net)\n{\n\tstruct fwnet_device *dev = netdev_priv(net);\n\n\tnetif_stop_queue(net);\n\tfwnet_broadcast_stop(dev);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)\n{\n\tstruct fwnet_header hdr_buf;\n\tstruct fwnet_device *dev = netdev_priv(net);\n\t__be16 proto;\n\tu16 dest_node;\n\tunsigned max_payload;\n\tu16 dg_size;\n\tu16 *datagram_label_ptr;\n\tstruct fwnet_packet_task *ptask;\n\tstruct fwnet_peer *peer;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t/* Can this happen? */\n\tif (netif_queue_stopped(dev->netdev)) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tptask = kmem_cache_alloc(fwnet_packet_task_cache, GFP_ATOMIC);\n\tif (ptask == NULL)\n\t\tgoto fail;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto fail;\n\n\t/*\n\t * Make a copy of the driver-specific header.\n\t * We might need to rebuild the header on tx failure.\n\t */\n\tmemcpy(&hdr_buf, skb->data, sizeof(hdr_buf));\n\tproto = hdr_buf.h_proto;\n\n\tswitch (proto) {\n\tcase htons(ETH_P_ARP):\n\tcase htons(ETH_P_IP):\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n#endif\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\n\tskb_pull(skb, sizeof(hdr_buf));\n\tdg_size = skb->len;\n\n\t/*\n\t * Set the transmission type for the packet.  ARP packets and IP\n\t * broadcast packets are sent via GASP.\n\t */\n\tif (fwnet_hwaddr_is_multicast(hdr_buf.h_dest)) {\n\t\tmax_payload        = dev->broadcast_xmt_max_payload;\n\t\tdatagram_label_ptr = &dev->broadcast_xmt_datagramlabel;\n\n\t\tptask->fifo_addr   = FWNET_NO_FIFO_ADDR;\n\t\tptask->generation  = 0;\n\t\tptask->dest_node   = IEEE1394_ALL_NODES;\n\t\tptask->speed       = SCODE_100;\n\t} else {\n\t\tunion fwnet_hwaddr *ha = (union fwnet_hwaddr *)hdr_buf.h_dest;\n\t\t__be64 guid = get_unaligned(&ha->uc.uniq_id);\n\t\tu8 generation;\n\n\t\tpeer = fwnet_peer_find_by_guid(dev, be64_to_cpu(guid));\n\t\tif (!peer)\n\t\t\tgoto fail;\n\n\t\tgeneration         = peer->generation;\n\t\tdest_node          = peer->node_id;\n\t\tmax_payload        = peer->max_payload;\n\t\tdatagram_label_ptr = &peer->datagram_label;\n\n\t\tptask->fifo_addr   = fwnet_hwaddr_fifo(ha);\n\t\tptask->generation  = generation;\n\t\tptask->dest_node   = dest_node;\n\t\tptask->speed       = peer->speed;\n\t}\n\n\tptask->hdr.w0 = 0;\n\tptask->hdr.w1 = 0;\n\tptask->skb = skb;\n\tptask->dev = dev;\n\n\t/* Does it all fit in one packet? */\n\tif (dg_size <= max_payload) {\n\t\tfwnet_make_uf_hdr(&ptask->hdr, ntohs(proto));\n\t\tptask->outstanding_pkts = 1;\n\t\tmax_payload = dg_size + RFC2374_UNFRAG_HDR_SIZE;\n\t} else {\n\t\tu16 datagram_label;\n\n\t\tmax_payload -= RFC2374_FRAG_OVERHEAD;\n\t\tdatagram_label = (*datagram_label_ptr)++;\n\t\tfwnet_make_ff_hdr(&ptask->hdr, ntohs(proto), dg_size,\n\t\t\t\t  datagram_label);\n\t\tptask->outstanding_pkts = DIV_ROUND_UP(dg_size, max_payload);\n\t\tmax_payload += RFC2374_FRAG_HDR_SIZE;\n\t}\n\n\tif (++dev->queued_datagrams == FWNET_MAX_QUEUED_DATAGRAMS)\n\t\tnetif_stop_queue(dev->netdev);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tptask->max_payload = max_payload;\n\tptask->enqueued    = 0;\n\n\tfwnet_send_packet(ptask);\n\n\treturn NETDEV_TX_OK;\n\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (ptask)\n\t\tkmem_cache_free(fwnet_packet_task_cache, ptask);\n\n\tif (skb != NULL)\n\t\tdev_kfree_skb(skb);\n\n\tnet->stats.tx_dropped++;\n\tnet->stats.tx_errors++;\n\n\t/*\n\t * FIXME: According to a patch from 2003-02-26, \"returning non-zero\n\t * causes serious problems\" here, allegedly.  Before that patch,\n\t * -ERRNO was returned which is not appropriate under Linux 2.6.\n\t * Perhaps more needs to be done?  Stop the queue in serious\n\t * conditions and restart it elsewhere?\n\t */\n\treturn NETDEV_TX_OK;\n}\n\nstatic int fwnet_change_mtu(struct net_device *net, int new_mtu)\n{\n\tif (new_mtu < 68)\n\t\treturn -EINVAL;\n\n\tnet->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic const struct ethtool_ops fwnet_ethtool_ops = {\n\t.get_link\t= ethtool_op_get_link,\n};\n\nstatic const struct net_device_ops fwnet_netdev_ops = {\n\t.ndo_open       = fwnet_open,\n\t.ndo_stop\t= fwnet_stop,\n\t.ndo_start_xmit = fwnet_tx,\n\t.ndo_change_mtu = fwnet_change_mtu,\n};\n\nstatic void fwnet_init_dev(struct net_device *net)\n{\n\tnet->header_ops\t\t= &fwnet_header_ops;\n\tnet->netdev_ops\t\t= &fwnet_netdev_ops;\n\tnet->watchdog_timeo\t= 2 * HZ;\n\tnet->flags\t\t= IFF_BROADCAST | IFF_MULTICAST;\n\tnet->features\t\t= NETIF_F_HIGHDMA;\n\tnet->addr_len\t\t= FWNET_ALEN;\n\tnet->hard_header_len\t= FWNET_HLEN;\n\tnet->type\t\t= ARPHRD_IEEE1394;\n\tnet->tx_queue_len\t= FWNET_TX_QUEUE_LEN;\n\tnet->ethtool_ops\t= &fwnet_ethtool_ops;\n}\n\n/* caller must hold fwnet_device_mutex */\nstatic struct fwnet_device *fwnet_dev_find(struct fw_card *card)\n{\n\tstruct fwnet_device *dev;\n\n\tlist_for_each_entry(dev, &fwnet_device_list, dev_link)\n\t\tif (dev->card == card)\n\t\t\treturn dev;\n\n\treturn NULL;\n}\n\nstatic int fwnet_add_peer(struct fwnet_device *dev,\n\t\t\t  struct fw_unit *unit, struct fw_device *device)\n{\n\tstruct fwnet_peer *peer;\n\n\tpeer = kmalloc(sizeof(*peer), GFP_KERNEL);\n\tif (!peer)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&unit->device, peer);\n\n\tpeer->dev = dev;\n\tpeer->guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];\n\tINIT_LIST_HEAD(&peer->pd_list);\n\tpeer->pdg_size = 0;\n\tpeer->datagram_label = 0;\n\tpeer->speed = device->max_speed;\n\tpeer->max_payload = fwnet_max_payload(device->max_rec, peer->speed);\n\n\tpeer->generation = device->generation;\n\tsmp_rmb();\n\tpeer->node_id = device->node_id;\n\n\tspin_lock_irq(&dev->lock);\n\tlist_add_tail(&peer->peer_link, &dev->peer_list);\n\tdev->peer_count++;\n\tset_carrier_state(dev);\n\tspin_unlock_irq(&dev->lock);\n\n\treturn 0;\n}\n\nstatic int fwnet_probe(struct fw_unit *unit,\n\t\t       const struct ieee1394_device_id *id)\n{\n\tstruct fw_device *device = fw_parent_device(unit);\n\tstruct fw_card *card = device->card;\n\tstruct net_device *net;\n\tbool allocated_netdev = false;\n\tstruct fwnet_device *dev;\n\tunsigned max_mtu;\n\tint ret;\n\tunion fwnet_hwaddr *ha;\n\n\tmutex_lock(&fwnet_device_mutex);\n\n\tdev = fwnet_dev_find(card);\n\tif (dev) {\n\t\tnet = dev->netdev;\n\t\tgoto have_dev;\n\t}\n\n\tnet = alloc_netdev(sizeof(*dev), \"firewire%d\", NET_NAME_UNKNOWN,\n\t\t\t   fwnet_init_dev);\n\tif (net == NULL) {\n\t\tmutex_unlock(&fwnet_device_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tallocated_netdev = true;\n\tSET_NETDEV_DEV(net, card->device);\n\tdev = netdev_priv(net);\n\n\tspin_lock_init(&dev->lock);\n\tdev->broadcast_state = FWNET_BROADCAST_ERROR;\n\tdev->broadcast_rcv_context = NULL;\n\tdev->broadcast_xmt_max_payload = 0;\n\tdev->broadcast_xmt_datagramlabel = 0;\n\tdev->local_fifo = FWNET_NO_FIFO_ADDR;\n\tdev->queued_datagrams = 0;\n\tINIT_LIST_HEAD(&dev->peer_list);\n\tdev->card = card;\n\tdev->netdev = net;\n\n\tret = fwnet_fifo_start(dev);\n\tif (ret < 0)\n\t\tgoto out;\n\tdev->local_fifo = dev->handler.offset;\n\n\t/*\n\t * Use the RFC 2734 default 1500 octets or the maximum payload\n\t * as initial MTU\n\t */\n\tmax_mtu = (1 << (card->max_receive + 1))\n\t\t  - sizeof(struct rfc2734_header) - IEEE1394_GASP_HDR_SIZE;\n\tnet->mtu = min(1500U, max_mtu);\n\n\t/* Set our hardware address while we're at it */\n\tha = (union fwnet_hwaddr *)net->dev_addr;\n\tput_unaligned_be64(card->guid, &ha->uc.uniq_id);\n\tha->uc.max_rec = dev->card->max_receive;\n\tha->uc.sspd = dev->card->link_speed;\n\tput_unaligned_be16(dev->local_fifo >> 32, &ha->uc.fifo_hi);\n\tput_unaligned_be32(dev->local_fifo & 0xffffffff, &ha->uc.fifo_lo);\n\n\tmemset(net->broadcast, -1, net->addr_len);\n\n\tret = register_netdev(net);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_add_tail(&dev->dev_link, &fwnet_device_list);\n\tdev_notice(&net->dev, \"IP over IEEE 1394 on card %s\\n\",\n\t\t   dev_name(card->device));\n have_dev:\n\tret = fwnet_add_peer(dev, unit, device);\n\tif (ret && allocated_netdev) {\n\t\tunregister_netdev(net);\n\t\tlist_del(&dev->dev_link);\n out:\n\t\tfwnet_fifo_stop(dev);\n\t\tfree_netdev(net);\n\t}\n\n\tmutex_unlock(&fwnet_device_mutex);\n\n\treturn ret;\n}\n\n/*\n * FIXME abort partially sent fragmented datagrams,\n * discard partially received fragmented datagrams\n */\nstatic void fwnet_update(struct fw_unit *unit)\n{\n\tstruct fw_device *device = fw_parent_device(unit);\n\tstruct fwnet_peer *peer = dev_get_drvdata(&unit->device);\n\tint generation;\n\n\tgeneration = device->generation;\n\n\tspin_lock_irq(&peer->dev->lock);\n\tpeer->node_id    = device->node_id;\n\tpeer->generation = generation;\n\tspin_unlock_irq(&peer->dev->lock);\n}\n\nstatic void fwnet_remove_peer(struct fwnet_peer *peer, struct fwnet_device *dev)\n{\n\tstruct fwnet_partial_datagram *pd, *pd_next;\n\n\tspin_lock_irq(&dev->lock);\n\tlist_del(&peer->peer_link);\n\tdev->peer_count--;\n\tset_carrier_state(dev);\n\tspin_unlock_irq(&dev->lock);\n\n\tlist_for_each_entry_safe(pd, pd_next, &peer->pd_list, pd_link)\n\t\tfwnet_pd_delete(pd);\n\n\tkfree(peer);\n}\n\nstatic void fwnet_remove(struct fw_unit *unit)\n{\n\tstruct fwnet_peer *peer = dev_get_drvdata(&unit->device);\n\tstruct fwnet_device *dev = peer->dev;\n\tstruct net_device *net;\n\tint i;\n\n\tmutex_lock(&fwnet_device_mutex);\n\n\tnet = dev->netdev;\n\n\tfwnet_remove_peer(peer, dev);\n\n\tif (list_empty(&dev->peer_list)) {\n\t\tunregister_netdev(net);\n\n\t\tfwnet_fifo_stop(dev);\n\n\t\tfor (i = 0; dev->queued_datagrams && i < 5; i++)\n\t\t\tssleep(1);\n\t\tWARN_ON(dev->queued_datagrams);\n\t\tlist_del(&dev->dev_link);\n\n\t\tfree_netdev(net);\n\t}\n\n\tmutex_unlock(&fwnet_device_mutex);\n}\n\nstatic const struct ieee1394_device_id fwnet_id_table[] = {\n\t{\n\t\t.match_flags  = IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t\tIEEE1394_MATCH_VERSION,\n\t\t.specifier_id = IANA_SPECIFIER_ID,\n\t\t.version      = RFC2734_SW_VERSION,\n\t},\n#if IS_ENABLED(CONFIG_IPV6)\n\t{\n\t\t.match_flags  = IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t\tIEEE1394_MATCH_VERSION,\n\t\t.specifier_id = IANA_SPECIFIER_ID,\n\t\t.version      = RFC3146_SW_VERSION,\n\t},\n#endif\n\t{ }\n};\n\nstatic struct fw_driver fwnet_driver = {\n\t.driver = {\n\t\t.owner  = THIS_MODULE,\n\t\t.name   = KBUILD_MODNAME,\n\t\t.bus    = &fw_bus_type,\n\t},\n\t.probe    = fwnet_probe,\n\t.update   = fwnet_update,\n\t.remove   = fwnet_remove,\n\t.id_table = fwnet_id_table,\n};\n\nstatic const u32 rfc2374_unit_directory_data[] = {\n\t0x00040000,\t/* directory_length\t\t*/\n\t0x1200005e,\t/* unit_specifier_id: IANA\t*/\n\t0x81000003,\t/* textual descriptor offset\t*/\n\t0x13000001,\t/* unit_sw_version: RFC 2734\t*/\n\t0x81000005,\t/* textual descriptor offset\t*/\n\t0x00030000,\t/* descriptor_length\t\t*/\n\t0x00000000,\t/* text\t\t\t\t*/\n\t0x00000000,\t/* minimal ASCII, en\t\t*/\n\t0x49414e41,\t/* I A N A\t\t\t*/\n\t0x00030000,\t/* descriptor_length\t\t*/\n\t0x00000000,\t/* text\t\t\t\t*/\n\t0x00000000,\t/* minimal ASCII, en\t\t*/\n\t0x49507634,\t/* I P v 4\t\t\t*/\n};\n\nstatic struct fw_descriptor rfc2374_unit_directory = {\n\t.length = ARRAY_SIZE(rfc2374_unit_directory_data),\n\t.key    = (CSR_DIRECTORY | CSR_UNIT) << 24,\n\t.data   = rfc2374_unit_directory_data\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic const u32 rfc3146_unit_directory_data[] = {\n\t0x00040000,\t/* directory_length\t\t*/\n\t0x1200005e,\t/* unit_specifier_id: IANA\t*/\n\t0x81000003,\t/* textual descriptor offset\t*/\n\t0x13000002,\t/* unit_sw_version: RFC 3146\t*/\n\t0x81000005,\t/* textual descriptor offset\t*/\n\t0x00030000,\t/* descriptor_length\t\t*/\n\t0x00000000,\t/* text\t\t\t\t*/\n\t0x00000000,\t/* minimal ASCII, en\t\t*/\n\t0x49414e41,\t/* I A N A\t\t\t*/\n\t0x00030000,\t/* descriptor_length\t\t*/\n\t0x00000000,\t/* text\t\t\t\t*/\n\t0x00000000,\t/* minimal ASCII, en\t\t*/\n\t0x49507636,\t/* I P v 6\t\t\t*/\n};\n\nstatic struct fw_descriptor rfc3146_unit_directory = {\n\t.length = ARRAY_SIZE(rfc3146_unit_directory_data),\n\t.key    = (CSR_DIRECTORY | CSR_UNIT) << 24,\n\t.data   = rfc3146_unit_directory_data\n};\n#endif\n\nstatic int __init fwnet_init(void)\n{\n\tint err;\n\n\terr = fw_core_add_descriptor(&rfc2374_unit_directory);\n\tif (err)\n\t\treturn err;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\terr = fw_core_add_descriptor(&rfc3146_unit_directory);\n\tif (err)\n\t\tgoto out;\n#endif\n\n\tfwnet_packet_task_cache = kmem_cache_create(\"packet_task\",\n\t\t\tsizeof(struct fwnet_packet_task), 0, 0, NULL);\n\tif (!fwnet_packet_task_cache) {\n\t\terr = -ENOMEM;\n\t\tgoto out2;\n\t}\n\n\terr = driver_register(&fwnet_driver.driver);\n\tif (!err)\n\t\treturn 0;\n\n\tkmem_cache_destroy(fwnet_packet_task_cache);\nout2:\n#if IS_ENABLED(CONFIG_IPV6)\n\tfw_core_remove_descriptor(&rfc3146_unit_directory);\nout:\n#endif\n\tfw_core_remove_descriptor(&rfc2374_unit_directory);\n\n\treturn err;\n}\nmodule_init(fwnet_init);\n\nstatic void __exit fwnet_cleanup(void)\n{\n\tdriver_unregister(&fwnet_driver.driver);\n\tkmem_cache_destroy(fwnet_packet_task_cache);\n#if IS_ENABLED(CONFIG_IPV6)\n\tfw_core_remove_descriptor(&rfc3146_unit_directory);\n#endif\n\tfw_core_remove_descriptor(&rfc2374_unit_directory);\n}\nmodule_exit(fwnet_cleanup);\n\nMODULE_AUTHOR(\"Jay Fenlason <fenlason@redhat.com>\");\nMODULE_DESCRIPTION(\"IP over IEEE1394 as per RFC 2734/3146\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(ieee1394, fwnet_id_table);\n"], "fixing_code": ["/*\n * IPv4 over IEEE 1394, per RFC 2734\n * IPv6 over IEEE 1394, per RFC 3146\n *\n * Copyright (C) 2009 Jay Fenlason <fenlason@redhat.com>\n *\n * based on eth1394 by Ben Collins et al\n */\n\n#include <linux/bug.h>\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/ethtool.h>\n#include <linux/firewire.h>\n#include <linux/firewire-constants.h>\n#include <linux/highmem.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/jiffies.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <asm/unaligned.h>\n#include <net/arp.h>\n#include <net/firewire.h>\n\n/* rx limits */\n#define FWNET_MAX_FRAGMENTS\t\t30 /* arbitrary, > TX queue depth */\n#define FWNET_ISO_PAGE_COUNT\t\t(PAGE_SIZE < 16*1024 ? 4 : 2)\n\n/* tx limits */\n#define FWNET_MAX_QUEUED_DATAGRAMS\t20 /* < 64 = number of tlabels */\n#define FWNET_MIN_QUEUED_DATAGRAMS\t10 /* should keep AT DMA busy enough */\n#define FWNET_TX_QUEUE_LEN\t\tFWNET_MAX_QUEUED_DATAGRAMS /* ? */\n\n#define IEEE1394_BROADCAST_CHANNEL\t31\n#define IEEE1394_ALL_NODES\t\t(0xffc0 | 0x003f)\n#define IEEE1394_MAX_PAYLOAD_S100\t512\n#define FWNET_NO_FIFO_ADDR\t\t(~0ULL)\n\n#define IANA_SPECIFIER_ID\t\t0x00005eU\n#define RFC2734_SW_VERSION\t\t0x000001U\n#define RFC3146_SW_VERSION\t\t0x000002U\n\n#define IEEE1394_GASP_HDR_SIZE\t8\n\n#define RFC2374_UNFRAG_HDR_SIZE\t4\n#define RFC2374_FRAG_HDR_SIZE\t8\n#define RFC2374_FRAG_OVERHEAD\t4\n\n#define RFC2374_HDR_UNFRAG\t0\t/* unfragmented\t\t*/\n#define RFC2374_HDR_FIRSTFRAG\t1\t/* first fragment\t*/\n#define RFC2374_HDR_LASTFRAG\t2\t/* last fragment\t*/\n#define RFC2374_HDR_INTFRAG\t3\t/* interior fragment\t*/\n\nstatic bool fwnet_hwaddr_is_multicast(u8 *ha)\n{\n\treturn !!(*ha & 1);\n}\n\n/* IPv4 and IPv6 encapsulation header */\nstruct rfc2734_header {\n\tu32 w0;\n\tu32 w1;\n};\n\n#define fwnet_get_hdr_lf(h)\t\t(((h)->w0 & 0xc0000000) >> 30)\n#define fwnet_get_hdr_ether_type(h)\t(((h)->w0 & 0x0000ffff))\n#define fwnet_get_hdr_dg_size(h)\t(((h)->w0 & 0x0fff0000) >> 16)\n#define fwnet_get_hdr_fg_off(h)\t\t(((h)->w0 & 0x00000fff))\n#define fwnet_get_hdr_dgl(h)\t\t(((h)->w1 & 0xffff0000) >> 16)\n\n#define fwnet_set_hdr_lf(lf)\t\t((lf)  << 30)\n#define fwnet_set_hdr_ether_type(et)\t(et)\n#define fwnet_set_hdr_dg_size(dgs)\t((dgs) << 16)\n#define fwnet_set_hdr_fg_off(fgo)\t(fgo)\n\n#define fwnet_set_hdr_dgl(dgl)\t\t((dgl) << 16)\n\nstatic inline void fwnet_make_uf_hdr(struct rfc2734_header *hdr,\n\t\tunsigned ether_type)\n{\n\thdr->w0 = fwnet_set_hdr_lf(RFC2374_HDR_UNFRAG)\n\t\t  | fwnet_set_hdr_ether_type(ether_type);\n}\n\nstatic inline void fwnet_make_ff_hdr(struct rfc2734_header *hdr,\n\t\tunsigned ether_type, unsigned dg_size, unsigned dgl)\n{\n\thdr->w0 = fwnet_set_hdr_lf(RFC2374_HDR_FIRSTFRAG)\n\t\t  | fwnet_set_hdr_dg_size(dg_size)\n\t\t  | fwnet_set_hdr_ether_type(ether_type);\n\thdr->w1 = fwnet_set_hdr_dgl(dgl);\n}\n\nstatic inline void fwnet_make_sf_hdr(struct rfc2734_header *hdr,\n\t\tunsigned lf, unsigned dg_size, unsigned fg_off, unsigned dgl)\n{\n\thdr->w0 = fwnet_set_hdr_lf(lf)\n\t\t  | fwnet_set_hdr_dg_size(dg_size)\n\t\t  | fwnet_set_hdr_fg_off(fg_off);\n\thdr->w1 = fwnet_set_hdr_dgl(dgl);\n}\n\n/* This list keeps track of what parts of the datagram have been filled in */\nstruct fwnet_fragment_info {\n\tstruct list_head fi_link;\n\tu16 offset;\n\tu16 len;\n};\n\nstruct fwnet_partial_datagram {\n\tstruct list_head pd_link;\n\tstruct list_head fi_list;\n\tstruct sk_buff *skb;\n\t/* FIXME Why not use skb->data? */\n\tchar *pbuf;\n\tu16 datagram_label;\n\tu16 ether_type;\n\tu16 datagram_size;\n};\n\nstatic DEFINE_MUTEX(fwnet_device_mutex);\nstatic LIST_HEAD(fwnet_device_list);\n\nstruct fwnet_device {\n\tstruct list_head dev_link;\n\tspinlock_t lock;\n\tenum {\n\t\tFWNET_BROADCAST_ERROR,\n\t\tFWNET_BROADCAST_RUNNING,\n\t\tFWNET_BROADCAST_STOPPED,\n\t} broadcast_state;\n\tstruct fw_iso_context *broadcast_rcv_context;\n\tstruct fw_iso_buffer broadcast_rcv_buffer;\n\tvoid **broadcast_rcv_buffer_ptrs;\n\tunsigned broadcast_rcv_next_ptr;\n\tunsigned num_broadcast_rcv_ptrs;\n\tunsigned rcv_buffer_size;\n\t/*\n\t * This value is the maximum unfragmented datagram size that can be\n\t * sent by the hardware.  It already has the GASP overhead and the\n\t * unfragmented datagram header overhead calculated into it.\n\t */\n\tunsigned broadcast_xmt_max_payload;\n\tu16 broadcast_xmt_datagramlabel;\n\n\t/*\n\t * The CSR address that remote nodes must send datagrams to for us to\n\t * receive them.\n\t */\n\tstruct fw_address_handler handler;\n\tu64 local_fifo;\n\n\t/* Number of tx datagrams that have been queued but not yet acked */\n\tint queued_datagrams;\n\n\tint peer_count;\n\tstruct list_head peer_list;\n\tstruct fw_card *card;\n\tstruct net_device *netdev;\n};\n\nstruct fwnet_peer {\n\tstruct list_head peer_link;\n\tstruct fwnet_device *dev;\n\tu64 guid;\n\n\t/* guarded by dev->lock */\n\tstruct list_head pd_list; /* received partial datagrams */\n\tunsigned pdg_size;        /* pd_list size */\n\n\tu16 datagram_label;       /* outgoing datagram label */\n\tu16 max_payload;          /* includes RFC2374_FRAG_HDR_SIZE overhead */\n\tint node_id;\n\tint generation;\n\tunsigned speed;\n};\n\n/* This is our task struct. It's used for the packet complete callback.  */\nstruct fwnet_packet_task {\n\tstruct fw_transaction transaction;\n\tstruct rfc2734_header hdr;\n\tstruct sk_buff *skb;\n\tstruct fwnet_device *dev;\n\n\tint outstanding_pkts;\n\tu64 fifo_addr;\n\tu16 dest_node;\n\tu16 max_payload;\n\tu8 generation;\n\tu8 speed;\n\tu8 enqueued;\n};\n\n/*\n * Get fifo address embedded in hwaddr\n */\nstatic __u64 fwnet_hwaddr_fifo(union fwnet_hwaddr *ha)\n{\n\treturn (u64)get_unaligned_be16(&ha->uc.fifo_hi) << 32\n\t       | get_unaligned_be32(&ha->uc.fifo_lo);\n}\n\n/*\n * saddr == NULL means use device source address.\n * daddr == NULL means leave destination address (eg unresolved arp).\n */\nstatic int fwnet_header_create(struct sk_buff *skb, struct net_device *net,\n\t\t\tunsigned short type, const void *daddr,\n\t\t\tconst void *saddr, unsigned len)\n{\n\tstruct fwnet_header *h;\n\n\th = (struct fwnet_header *)skb_push(skb, sizeof(*h));\n\tput_unaligned_be16(type, &h->h_proto);\n\n\tif (net->flags & (IFF_LOOPBACK | IFF_NOARP)) {\n\t\tmemset(h->h_dest, 0, net->addr_len);\n\n\t\treturn net->hard_header_len;\n\t}\n\n\tif (daddr) {\n\t\tmemcpy(h->h_dest, daddr, net->addr_len);\n\n\t\treturn net->hard_header_len;\n\t}\n\n\treturn -net->hard_header_len;\n}\n\nstatic int fwnet_header_cache(const struct neighbour *neigh,\n\t\t\t      struct hh_cache *hh, __be16 type)\n{\n\tstruct net_device *net;\n\tstruct fwnet_header *h;\n\n\tif (type == cpu_to_be16(ETH_P_802_3))\n\t\treturn -1;\n\tnet = neigh->dev;\n\th = (struct fwnet_header *)((u8 *)hh->hh_data + HH_DATA_OFF(sizeof(*h)));\n\th->h_proto = type;\n\tmemcpy(h->h_dest, neigh->ha, net->addr_len);\n\thh->hh_len = FWNET_HLEN;\n\n\treturn 0;\n}\n\n/* Called by Address Resolution module to notify changes in address. */\nstatic void fwnet_header_cache_update(struct hh_cache *hh,\n\t\tconst struct net_device *net, const unsigned char *haddr)\n{\n\tmemcpy((u8 *)hh->hh_data + HH_DATA_OFF(FWNET_HLEN), haddr, net->addr_len);\n}\n\nstatic int fwnet_header_parse(const struct sk_buff *skb, unsigned char *haddr)\n{\n\tmemcpy(haddr, skb->dev->dev_addr, FWNET_ALEN);\n\n\treturn FWNET_ALEN;\n}\n\nstatic const struct header_ops fwnet_header_ops = {\n\t.create         = fwnet_header_create,\n\t.cache\t\t= fwnet_header_cache,\n\t.cache_update\t= fwnet_header_cache_update,\n\t.parse          = fwnet_header_parse,\n};\n\n/* FIXME: is this correct for all cases? */\nstatic bool fwnet_frag_overlap(struct fwnet_partial_datagram *pd,\n\t\t\t       unsigned offset, unsigned len)\n{\n\tstruct fwnet_fragment_info *fi;\n\tunsigned end = offset + len;\n\n\tlist_for_each_entry(fi, &pd->fi_list, fi_link)\n\t\tif (offset < fi->offset + fi->len && end > fi->offset)\n\t\t\treturn true;\n\n\treturn false;\n}\n\n/* Assumes that new fragment does not overlap any existing fragments */\nstatic struct fwnet_fragment_info *fwnet_frag_new(\n\tstruct fwnet_partial_datagram *pd, unsigned offset, unsigned len)\n{\n\tstruct fwnet_fragment_info *fi, *fi2, *new;\n\tstruct list_head *list;\n\n\tlist = &pd->fi_list;\n\tlist_for_each_entry(fi, &pd->fi_list, fi_link) {\n\t\tif (fi->offset + fi->len == offset) {\n\t\t\t/* The new fragment can be tacked on to the end */\n\t\t\t/* Did the new fragment plug a hole? */\n\t\t\tfi2 = list_entry(fi->fi_link.next,\n\t\t\t\t\t struct fwnet_fragment_info, fi_link);\n\t\t\tif (fi->offset + fi->len == fi2->offset) {\n\t\t\t\t/* glue fragments together */\n\t\t\t\tfi->len += len + fi2->len;\n\t\t\t\tlist_del(&fi2->fi_link);\n\t\t\t\tkfree(fi2);\n\t\t\t} else {\n\t\t\t\tfi->len += len;\n\t\t\t}\n\n\t\t\treturn fi;\n\t\t}\n\t\tif (offset + len == fi->offset) {\n\t\t\t/* The new fragment can be tacked on to the beginning */\n\t\t\t/* Did the new fragment plug a hole? */\n\t\t\tfi2 = list_entry(fi->fi_link.prev,\n\t\t\t\t\t struct fwnet_fragment_info, fi_link);\n\t\t\tif (fi2->offset + fi2->len == fi->offset) {\n\t\t\t\t/* glue fragments together */\n\t\t\t\tfi2->len += fi->len + len;\n\t\t\t\tlist_del(&fi->fi_link);\n\t\t\t\tkfree(fi);\n\n\t\t\t\treturn fi2;\n\t\t\t}\n\t\t\tfi->offset = offset;\n\t\t\tfi->len += len;\n\n\t\t\treturn fi;\n\t\t}\n\t\tif (offset > fi->offset + fi->len) {\n\t\t\tlist = &fi->fi_link;\n\t\t\tbreak;\n\t\t}\n\t\tif (offset + len < fi->offset) {\n\t\t\tlist = fi->fi_link.prev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tnew = kmalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\treturn NULL;\n\n\tnew->offset = offset;\n\tnew->len = len;\n\tlist_add(&new->fi_link, list);\n\n\treturn new;\n}\n\nstatic struct fwnet_partial_datagram *fwnet_pd_new(struct net_device *net,\n\t\tstruct fwnet_peer *peer, u16 datagram_label, unsigned dg_size,\n\t\tvoid *frag_buf, unsigned frag_off, unsigned frag_len)\n{\n\tstruct fwnet_partial_datagram *new;\n\tstruct fwnet_fragment_info *fi;\n\n\tnew = kmalloc(sizeof(*new), GFP_ATOMIC);\n\tif (!new)\n\t\tgoto fail;\n\n\tINIT_LIST_HEAD(&new->fi_list);\n\tfi = fwnet_frag_new(new, frag_off, frag_len);\n\tif (fi == NULL)\n\t\tgoto fail_w_new;\n\n\tnew->datagram_label = datagram_label;\n\tnew->datagram_size = dg_size;\n\tnew->skb = dev_alloc_skb(dg_size + LL_RESERVED_SPACE(net));\n\tif (new->skb == NULL)\n\t\tgoto fail_w_fi;\n\n\tskb_reserve(new->skb, LL_RESERVED_SPACE(net));\n\tnew->pbuf = skb_put(new->skb, dg_size);\n\tmemcpy(new->pbuf + frag_off, frag_buf, frag_len);\n\tlist_add_tail(&new->pd_link, &peer->pd_list);\n\n\treturn new;\n\nfail_w_fi:\n\tkfree(fi);\nfail_w_new:\n\tkfree(new);\nfail:\n\treturn NULL;\n}\n\nstatic struct fwnet_partial_datagram *fwnet_pd_find(struct fwnet_peer *peer,\n\t\t\t\t\t\t    u16 datagram_label)\n{\n\tstruct fwnet_partial_datagram *pd;\n\n\tlist_for_each_entry(pd, &peer->pd_list, pd_link)\n\t\tif (pd->datagram_label == datagram_label)\n\t\t\treturn pd;\n\n\treturn NULL;\n}\n\n\nstatic void fwnet_pd_delete(struct fwnet_partial_datagram *old)\n{\n\tstruct fwnet_fragment_info *fi, *n;\n\n\tlist_for_each_entry_safe(fi, n, &old->fi_list, fi_link)\n\t\tkfree(fi);\n\n\tlist_del(&old->pd_link);\n\tdev_kfree_skb_any(old->skb);\n\tkfree(old);\n}\n\nstatic bool fwnet_pd_update(struct fwnet_peer *peer,\n\t\tstruct fwnet_partial_datagram *pd, void *frag_buf,\n\t\tunsigned frag_off, unsigned frag_len)\n{\n\tif (fwnet_frag_new(pd, frag_off, frag_len) == NULL)\n\t\treturn false;\n\n\tmemcpy(pd->pbuf + frag_off, frag_buf, frag_len);\n\n\t/*\n\t * Move list entry to beginning of list so that oldest partial\n\t * datagrams percolate to the end of the list\n\t */\n\tlist_move_tail(&pd->pd_link, &peer->pd_list);\n\n\treturn true;\n}\n\nstatic bool fwnet_pd_is_complete(struct fwnet_partial_datagram *pd)\n{\n\tstruct fwnet_fragment_info *fi;\n\n\tfi = list_entry(pd->fi_list.next, struct fwnet_fragment_info, fi_link);\n\n\treturn fi->len == pd->datagram_size;\n}\n\n/* caller must hold dev->lock */\nstatic struct fwnet_peer *fwnet_peer_find_by_guid(struct fwnet_device *dev,\n\t\t\t\t\t\t  u64 guid)\n{\n\tstruct fwnet_peer *peer;\n\n\tlist_for_each_entry(peer, &dev->peer_list, peer_link)\n\t\tif (peer->guid == guid)\n\t\t\treturn peer;\n\n\treturn NULL;\n}\n\n/* caller must hold dev->lock */\nstatic struct fwnet_peer *fwnet_peer_find_by_node_id(struct fwnet_device *dev,\n\t\t\t\t\t\tint node_id, int generation)\n{\n\tstruct fwnet_peer *peer;\n\n\tlist_for_each_entry(peer, &dev->peer_list, peer_link)\n\t\tif (peer->node_id    == node_id &&\n\t\t    peer->generation == generation)\n\t\t\treturn peer;\n\n\treturn NULL;\n}\n\n/* See IEEE 1394-2008 table 6-4, table 8-8, table 16-18. */\nstatic unsigned fwnet_max_payload(unsigned max_rec, unsigned speed)\n{\n\tmax_rec = min(max_rec, speed + 8);\n\tmax_rec = clamp(max_rec, 8U, 11U); /* 512...4096 */\n\n\treturn (1 << (max_rec + 1)) - RFC2374_FRAG_HDR_SIZE;\n}\n\n\nstatic int fwnet_finish_incoming_packet(struct net_device *net,\n\t\t\t\t\tstruct sk_buff *skb, u16 source_node_id,\n\t\t\t\t\tbool is_broadcast, u16 ether_type)\n{\n\tstruct fwnet_device *dev;\n\tint status;\n\t__be64 guid;\n\n\tswitch (ether_type) {\n\tcase ETH_P_ARP:\n\tcase ETH_P_IP:\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase ETH_P_IPV6:\n#endif\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\tdev = netdev_priv(net);\n\t/* Write metadata, and then pass to the receive level */\n\tskb->dev = net;\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t/*\n\t * Parse the encapsulation header. This actually does the job of\n\t * converting to an ethernet-like pseudo frame header.\n\t */\n\tguid = cpu_to_be64(dev->card->guid);\n\tif (dev_hard_header(skb, net, ether_type,\n\t\t\t   is_broadcast ? net->broadcast : net->dev_addr,\n\t\t\t   NULL, skb->len) >= 0) {\n\t\tstruct fwnet_header *eth;\n\t\tu16 *rawp;\n\t\t__be16 protocol;\n\n\t\tskb_reset_mac_header(skb);\n\t\tskb_pull(skb, sizeof(*eth));\n\t\teth = (struct fwnet_header *)skb_mac_header(skb);\n\t\tif (fwnet_hwaddr_is_multicast(eth->h_dest)) {\n\t\t\tif (memcmp(eth->h_dest, net->broadcast,\n\t\t\t\t   net->addr_len) == 0)\n\t\t\t\tskb->pkt_type = PACKET_BROADCAST;\n#if 0\n\t\t\telse\n\t\t\t\tskb->pkt_type = PACKET_MULTICAST;\n#endif\n\t\t} else {\n\t\t\tif (memcmp(eth->h_dest, net->dev_addr, net->addr_len))\n\t\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t}\n\t\tif (ntohs(eth->h_proto) >= ETH_P_802_3_MIN) {\n\t\t\tprotocol = eth->h_proto;\n\t\t} else {\n\t\t\trawp = (u16 *)skb->data;\n\t\t\tif (*rawp == 0xffff)\n\t\t\t\tprotocol = htons(ETH_P_802_3);\n\t\t\telse\n\t\t\t\tprotocol = htons(ETH_P_802_2);\n\t\t}\n\t\tskb->protocol = protocol;\n\t}\n\tstatus = netif_rx(skb);\n\tif (status == NET_RX_DROP) {\n\t\tnet->stats.rx_errors++;\n\t\tnet->stats.rx_dropped++;\n\t} else {\n\t\tnet->stats.rx_packets++;\n\t\tnet->stats.rx_bytes += skb->len;\n\t}\n\n\treturn 0;\n\n err:\n\tnet->stats.rx_errors++;\n\tnet->stats.rx_dropped++;\n\n\tdev_kfree_skb_any(skb);\n\n\treturn -ENOENT;\n}\n\nstatic int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\tif (len <= RFC2374_UNFRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\n\t/* A datagram fragment has been received, now the fun begins. */\n\n\tif (len <= RFC2374_FRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tif (fg_off + len > dg_size)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}\n\nstatic void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,\n\t\tint tcode, int destination, int source, int generation,\n\t\tunsigned long long offset, void *payload, size_t length,\n\t\tvoid *callback_data)\n{\n\tstruct fwnet_device *dev = callback_data;\n\tint rcode;\n\n\tif (destination == IEEE1394_ALL_NODES) {\n\t\tkfree(r);\n\n\t\treturn;\n\t}\n\n\tif (offset != dev->handler.offset)\n\t\trcode = RCODE_ADDRESS_ERROR;\n\telse if (tcode != TCODE_WRITE_BLOCK_REQUEST)\n\t\trcode = RCODE_TYPE_ERROR;\n\telse if (fwnet_incoming_packet(dev, payload, length,\n\t\t\t\t       source, generation, false) != 0) {\n\t\tdev_err(&dev->netdev->dev, \"incoming packet failure\\n\");\n\t\trcode = RCODE_CONFLICT_ERROR;\n\t} else\n\t\trcode = RCODE_COMPLETE;\n\n\tfw_send_response(card, r, rcode);\n}\n\nstatic int gasp_source_id(__be32 *p)\n{\n\treturn be32_to_cpu(p[0]) >> 16;\n}\n\nstatic u32 gasp_specifier_id(__be32 *p)\n{\n\treturn (be32_to_cpu(p[0]) & 0xffff) << 8 |\n\t       (be32_to_cpu(p[1]) & 0xff000000) >> 24;\n}\n\nstatic u32 gasp_version(__be32 *p)\n{\n\treturn be32_to_cpu(p[1]) & 0xffffff;\n}\n\nstatic void fwnet_receive_broadcast(struct fw_iso_context *context,\n\t\tu32 cycle, size_t header_length, void *header, void *data)\n{\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n\t__be32 *buf_ptr;\n\tint retval;\n\tu32 length;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (length > IEEE1394_GASP_HDR_SIZE &&\n\t    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&\n\t    (gasp_version(buf_ptr) == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n\t     || gasp_version(buf_ptr) == RFC3146_SW_VERSION\n#endif\n\t    ))\n\t\tfwnet_incoming_packet(dev, buf_ptr + 2,\n\t\t\t\t      length - IEEE1394_GASP_HDR_SIZE,\n\t\t\t\t      gasp_source_id(buf_ptr),\n\t\t\t\t      context->card->generation, true);\n\n\tpacket.payload_length = dev->rcv_buffer_size;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}\n\nstatic struct kmem_cache *fwnet_packet_task_cache;\n\nstatic void fwnet_free_ptask(struct fwnet_packet_task *ptask)\n{\n\tdev_kfree_skb_any(ptask->skb);\n\tkmem_cache_free(fwnet_packet_task_cache, ptask);\n}\n\n/* Caller must hold dev->lock. */\nstatic void dec_queued_datagrams(struct fwnet_device *dev)\n{\n\tif (--dev->queued_datagrams == FWNET_MIN_QUEUED_DATAGRAMS)\n\t\tnetif_wake_queue(dev->netdev);\n}\n\nstatic int fwnet_send_packet(struct fwnet_packet_task *ptask);\n\nstatic void fwnet_transmit_packet_done(struct fwnet_packet_task *ptask)\n{\n\tstruct fwnet_device *dev = ptask->dev;\n\tstruct sk_buff *skb = ptask->skb;\n\tunsigned long flags;\n\tbool free;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tptask->outstanding_pkts--;\n\n\t/* Check whether we or the networking TX soft-IRQ is last user. */\n\tfree = (ptask->outstanding_pkts == 0 && ptask->enqueued);\n\tif (free)\n\t\tdec_queued_datagrams(dev);\n\n\tif (ptask->outstanding_pkts == 0) {\n\t\tdev->netdev->stats.tx_packets++;\n\t\tdev->netdev->stats.tx_bytes += skb->len;\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (ptask->outstanding_pkts > 0) {\n\t\tu16 dg_size;\n\t\tu16 fg_off;\n\t\tu16 datagram_label;\n\t\tu16 lf;\n\n\t\t/* Update the ptask to point to the next fragment and send it */\n\t\tlf = fwnet_get_hdr_lf(&ptask->hdr);\n\t\tswitch (lf) {\n\t\tcase RFC2374_HDR_LASTFRAG:\n\t\tcase RFC2374_HDR_UNFRAG:\n\t\tdefault:\n\t\t\tdev_err(&dev->netdev->dev,\n\t\t\t\t\"outstanding packet %x lf %x, header %x,%x\\n\",\n\t\t\t\tptask->outstanding_pkts, lf, ptask->hdr.w0,\n\t\t\t\tptask->hdr.w1);\n\t\t\tBUG();\n\n\t\tcase RFC2374_HDR_FIRSTFRAG:\n\t\t\t/* Set frag type here for future interior fragments */\n\t\t\tdg_size = fwnet_get_hdr_dg_size(&ptask->hdr);\n\t\t\tfg_off = ptask->max_payload - RFC2374_FRAG_HDR_SIZE;\n\t\t\tdatagram_label = fwnet_get_hdr_dgl(&ptask->hdr);\n\t\t\tbreak;\n\n\t\tcase RFC2374_HDR_INTFRAG:\n\t\t\tdg_size = fwnet_get_hdr_dg_size(&ptask->hdr);\n\t\t\tfg_off = fwnet_get_hdr_fg_off(&ptask->hdr)\n\t\t\t\t  + ptask->max_payload - RFC2374_FRAG_HDR_SIZE;\n\t\t\tdatagram_label = fwnet_get_hdr_dgl(&ptask->hdr);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ptask->dest_node == IEEE1394_ALL_NODES) {\n\t\t\tskb_pull(skb,\n\t\t\t\t ptask->max_payload + IEEE1394_GASP_HDR_SIZE);\n\t\t} else {\n\t\t\tskb_pull(skb, ptask->max_payload);\n\t\t}\n\t\tif (ptask->outstanding_pkts > 1) {\n\t\t\tfwnet_make_sf_hdr(&ptask->hdr, RFC2374_HDR_INTFRAG,\n\t\t\t\t\t  dg_size, fg_off, datagram_label);\n\t\t} else {\n\t\t\tfwnet_make_sf_hdr(&ptask->hdr, RFC2374_HDR_LASTFRAG,\n\t\t\t\t\t  dg_size, fg_off, datagram_label);\n\t\t\tptask->max_payload = skb->len + RFC2374_FRAG_HDR_SIZE;\n\t\t}\n\t\tfwnet_send_packet(ptask);\n\t}\n\n\tif (free)\n\t\tfwnet_free_ptask(ptask);\n}\n\nstatic void fwnet_transmit_packet_failed(struct fwnet_packet_task *ptask)\n{\n\tstruct fwnet_device *dev = ptask->dev;\n\tunsigned long flags;\n\tbool free;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t/* One fragment failed; don't try to send remaining fragments. */\n\tptask->outstanding_pkts = 0;\n\n\t/* Check whether we or the networking TX soft-IRQ is last user. */\n\tfree = ptask->enqueued;\n\tif (free)\n\t\tdec_queued_datagrams(dev);\n\n\tdev->netdev->stats.tx_dropped++;\n\tdev->netdev->stats.tx_errors++;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (free)\n\t\tfwnet_free_ptask(ptask);\n}\n\nstatic void fwnet_write_complete(struct fw_card *card, int rcode,\n\t\t\t\t void *payload, size_t length, void *data)\n{\n\tstruct fwnet_packet_task *ptask = data;\n\tstatic unsigned long j;\n\tstatic int last_rcode, errors_skipped;\n\n\tif (rcode == RCODE_COMPLETE) {\n\t\tfwnet_transmit_packet_done(ptask);\n\t} else {\n\t\tif (printk_timed_ratelimit(&j,  1000) || rcode != last_rcode) {\n\t\t\tdev_err(&ptask->dev->netdev->dev,\n\t\t\t\t\"fwnet_write_complete failed: %x (skipped %d)\\n\",\n\t\t\t\trcode, errors_skipped);\n\n\t\t\terrors_skipped = 0;\n\t\t\tlast_rcode = rcode;\n\t\t} else {\n\t\t\terrors_skipped++;\n\t\t}\n\t\tfwnet_transmit_packet_failed(ptask);\n\t}\n}\n\nstatic int fwnet_send_packet(struct fwnet_packet_task *ptask)\n{\n\tstruct fwnet_device *dev;\n\tunsigned tx_len;\n\tstruct rfc2734_header *bufhdr;\n\tunsigned long flags;\n\tbool free;\n\n\tdev = ptask->dev;\n\ttx_len = ptask->max_payload;\n\tswitch (fwnet_get_hdr_lf(&ptask->hdr)) {\n\tcase RFC2374_HDR_UNFRAG:\n\t\tbufhdr = (struct rfc2734_header *)\n\t\t\t\tskb_push(ptask->skb, RFC2374_UNFRAG_HDR_SIZE);\n\t\tput_unaligned_be32(ptask->hdr.w0, &bufhdr->w0);\n\t\tbreak;\n\n\tcase RFC2374_HDR_FIRSTFRAG:\n\tcase RFC2374_HDR_INTFRAG:\n\tcase RFC2374_HDR_LASTFRAG:\n\t\tbufhdr = (struct rfc2734_header *)\n\t\t\t\tskb_push(ptask->skb, RFC2374_FRAG_HDR_SIZE);\n\t\tput_unaligned_be32(ptask->hdr.w0, &bufhdr->w0);\n\t\tput_unaligned_be32(ptask->hdr.w1, &bufhdr->w1);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\tif (ptask->dest_node == IEEE1394_ALL_NODES) {\n\t\tu8 *p;\n\t\tint generation;\n\t\tint node_id;\n\t\tunsigned int sw_version;\n\n\t\t/* ptask->generation may not have been set yet */\n\t\tgeneration = dev->card->generation;\n\t\tsmp_rmb();\n\t\tnode_id = dev->card->node_id;\n\n\t\tswitch (ptask->skb->protocol) {\n\t\tdefault:\n\t\t\tsw_version = RFC2734_SW_VERSION;\n\t\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tsw_version = RFC3146_SW_VERSION;\n#endif\n\t\t}\n\n\t\tp = skb_push(ptask->skb, IEEE1394_GASP_HDR_SIZE);\n\t\tput_unaligned_be32(node_id << 16 | IANA_SPECIFIER_ID >> 8, p);\n\t\tput_unaligned_be32((IANA_SPECIFIER_ID & 0xff) << 24\n\t\t\t\t\t\t| sw_version, &p[4]);\n\n\t\t/* We should not transmit if broadcast_channel.valid == 0. */\n\t\tfw_send_request(dev->card, &ptask->transaction,\n\t\t\t\tTCODE_STREAM_DATA,\n\t\t\t\tfw_stream_packet_destination_id(3,\n\t\t\t\t\t\tIEEE1394_BROADCAST_CHANNEL, 0),\n\t\t\t\tgeneration, SCODE_100, 0ULL, ptask->skb->data,\n\t\t\t\ttx_len + 8, fwnet_write_complete, ptask);\n\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\n\t\t/* If the AT tasklet already ran, we may be last user. */\n\t\tfree = (ptask->outstanding_pkts == 0 && !ptask->enqueued);\n\t\tif (!free)\n\t\t\tptask->enqueued = true;\n\t\telse\n\t\t\tdec_queued_datagrams(dev);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\tgoto out;\n\t}\n\n\tfw_send_request(dev->card, &ptask->transaction,\n\t\t\tTCODE_WRITE_BLOCK_REQUEST, ptask->dest_node,\n\t\t\tptask->generation, ptask->speed, ptask->fifo_addr,\n\t\t\tptask->skb->data, tx_len, fwnet_write_complete, ptask);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t/* If the AT tasklet already ran, we may be last user. */\n\tfree = (ptask->outstanding_pkts == 0 && !ptask->enqueued);\n\tif (!free)\n\t\tptask->enqueued = true;\n\telse\n\t\tdec_queued_datagrams(dev);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tnetif_trans_update(dev->netdev);\n out:\n\tif (free)\n\t\tfwnet_free_ptask(ptask);\n\n\treturn 0;\n}\n\nstatic void fwnet_fifo_stop(struct fwnet_device *dev)\n{\n\tif (dev->local_fifo == FWNET_NO_FIFO_ADDR)\n\t\treturn;\n\n\tfw_core_remove_address_handler(&dev->handler);\n\tdev->local_fifo = FWNET_NO_FIFO_ADDR;\n}\n\nstatic int fwnet_fifo_start(struct fwnet_device *dev)\n{\n\tint retval;\n\n\tif (dev->local_fifo != FWNET_NO_FIFO_ADDR)\n\t\treturn 0;\n\n\tdev->handler.length = 4096;\n\tdev->handler.address_callback = fwnet_receive_packet;\n\tdev->handler.callback_data = dev;\n\n\tretval = fw_core_add_address_handler(&dev->handler,\n\t\t\t\t\t     &fw_high_memory_region);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tdev->local_fifo = dev->handler.offset;\n\n\treturn 0;\n}\n\nstatic void __fwnet_broadcast_stop(struct fwnet_device *dev)\n{\n\tunsigned u;\n\n\tif (dev->broadcast_state != FWNET_BROADCAST_ERROR) {\n\t\tfor (u = 0; u < FWNET_ISO_PAGE_COUNT; u++)\n\t\t\tkunmap(dev->broadcast_rcv_buffer.pages[u]);\n\t\tfw_iso_buffer_destroy(&dev->broadcast_rcv_buffer, dev->card);\n\t}\n\tif (dev->broadcast_rcv_context) {\n\t\tfw_iso_context_destroy(dev->broadcast_rcv_context);\n\t\tdev->broadcast_rcv_context = NULL;\n\t}\n\tkfree(dev->broadcast_rcv_buffer_ptrs);\n\tdev->broadcast_rcv_buffer_ptrs = NULL;\n\tdev->broadcast_state = FWNET_BROADCAST_ERROR;\n}\n\nstatic void fwnet_broadcast_stop(struct fwnet_device *dev)\n{\n\tif (dev->broadcast_state == FWNET_BROADCAST_ERROR)\n\t\treturn;\n\tfw_iso_context_stop(dev->broadcast_rcv_context);\n\t__fwnet_broadcast_stop(dev);\n}\n\nstatic int fwnet_broadcast_start(struct fwnet_device *dev)\n{\n\tstruct fw_iso_context *context;\n\tint retval;\n\tunsigned num_packets;\n\tunsigned max_receive;\n\tstruct fw_iso_packet packet;\n\tunsigned long offset;\n\tvoid **ptrptr;\n\tunsigned u;\n\n\tif (dev->broadcast_state != FWNET_BROADCAST_ERROR)\n\t\treturn 0;\n\n\tmax_receive = 1U << (dev->card->max_receive + 1);\n\tnum_packets = (FWNET_ISO_PAGE_COUNT * PAGE_SIZE) / max_receive;\n\n\tptrptr = kmalloc(sizeof(void *) * num_packets, GFP_KERNEL);\n\tif (!ptrptr) {\n\t\tretval = -ENOMEM;\n\t\tgoto failed;\n\t}\n\tdev->broadcast_rcv_buffer_ptrs = ptrptr;\n\n\tcontext = fw_iso_context_create(dev->card, FW_ISO_CONTEXT_RECEIVE,\n\t\t\t\t\tIEEE1394_BROADCAST_CHANNEL,\n\t\t\t\t\tdev->card->link_speed, 8,\n\t\t\t\t\tfwnet_receive_broadcast, dev);\n\tif (IS_ERR(context)) {\n\t\tretval = PTR_ERR(context);\n\t\tgoto failed;\n\t}\n\n\tretval = fw_iso_buffer_init(&dev->broadcast_rcv_buffer, dev->card,\n\t\t\t\t    FWNET_ISO_PAGE_COUNT, DMA_FROM_DEVICE);\n\tif (retval < 0)\n\t\tgoto failed;\n\n\tdev->broadcast_state = FWNET_BROADCAST_STOPPED;\n\n\tfor (u = 0; u < FWNET_ISO_PAGE_COUNT; u++) {\n\t\tvoid *ptr;\n\t\tunsigned v;\n\n\t\tptr = kmap(dev->broadcast_rcv_buffer.pages[u]);\n\t\tfor (v = 0; v < num_packets / FWNET_ISO_PAGE_COUNT; v++)\n\t\t\t*ptrptr++ = (void *) ((char *)ptr + v * max_receive);\n\t}\n\tdev->broadcast_rcv_context = context;\n\n\tpacket.payload_length = max_receive;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\toffset = 0;\n\n\tfor (u = 0; u < num_packets; u++) {\n\t\tretval = fw_iso_context_queue(context, &packet,\n\t\t\t\t&dev->broadcast_rcv_buffer, offset);\n\t\tif (retval < 0)\n\t\t\tgoto failed;\n\n\t\toffset += max_receive;\n\t}\n\tdev->num_broadcast_rcv_ptrs = num_packets;\n\tdev->rcv_buffer_size = max_receive;\n\tdev->broadcast_rcv_next_ptr = 0U;\n\tretval = fw_iso_context_start(context, -1, 0,\n\t\t\tFW_ISO_CONTEXT_MATCH_ALL_TAGS); /* ??? sync */\n\tif (retval < 0)\n\t\tgoto failed;\n\n\t/* FIXME: adjust it according to the min. speed of all known peers? */\n\tdev->broadcast_xmt_max_payload = IEEE1394_MAX_PAYLOAD_S100\n\t\t\t- IEEE1394_GASP_HDR_SIZE - RFC2374_UNFRAG_HDR_SIZE;\n\tdev->broadcast_state = FWNET_BROADCAST_RUNNING;\n\n\treturn 0;\n\n failed:\n\t__fwnet_broadcast_stop(dev);\n\treturn retval;\n}\n\nstatic void set_carrier_state(struct fwnet_device *dev)\n{\n\tif (dev->peer_count > 1)\n\t\tnetif_carrier_on(dev->netdev);\n\telse\n\t\tnetif_carrier_off(dev->netdev);\n}\n\n/* ifup */\nstatic int fwnet_open(struct net_device *net)\n{\n\tstruct fwnet_device *dev = netdev_priv(net);\n\tint ret;\n\n\tret = fwnet_broadcast_start(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tnetif_start_queue(net);\n\n\tspin_lock_irq(&dev->lock);\n\tset_carrier_state(dev);\n\tspin_unlock_irq(&dev->lock);\n\n\treturn 0;\n}\n\n/* ifdown */\nstatic int fwnet_stop(struct net_device *net)\n{\n\tstruct fwnet_device *dev = netdev_priv(net);\n\n\tnetif_stop_queue(net);\n\tfwnet_broadcast_stop(dev);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t fwnet_tx(struct sk_buff *skb, struct net_device *net)\n{\n\tstruct fwnet_header hdr_buf;\n\tstruct fwnet_device *dev = netdev_priv(net);\n\t__be16 proto;\n\tu16 dest_node;\n\tunsigned max_payload;\n\tu16 dg_size;\n\tu16 *datagram_label_ptr;\n\tstruct fwnet_packet_task *ptask;\n\tstruct fwnet_peer *peer;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t/* Can this happen? */\n\tif (netif_queue_stopped(dev->netdev)) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tptask = kmem_cache_alloc(fwnet_packet_task_cache, GFP_ATOMIC);\n\tif (ptask == NULL)\n\t\tgoto fail;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto fail;\n\n\t/*\n\t * Make a copy of the driver-specific header.\n\t * We might need to rebuild the header on tx failure.\n\t */\n\tmemcpy(&hdr_buf, skb->data, sizeof(hdr_buf));\n\tproto = hdr_buf.h_proto;\n\n\tswitch (proto) {\n\tcase htons(ETH_P_ARP):\n\tcase htons(ETH_P_IP):\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n#endif\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\n\tskb_pull(skb, sizeof(hdr_buf));\n\tdg_size = skb->len;\n\n\t/*\n\t * Set the transmission type for the packet.  ARP packets and IP\n\t * broadcast packets are sent via GASP.\n\t */\n\tif (fwnet_hwaddr_is_multicast(hdr_buf.h_dest)) {\n\t\tmax_payload        = dev->broadcast_xmt_max_payload;\n\t\tdatagram_label_ptr = &dev->broadcast_xmt_datagramlabel;\n\n\t\tptask->fifo_addr   = FWNET_NO_FIFO_ADDR;\n\t\tptask->generation  = 0;\n\t\tptask->dest_node   = IEEE1394_ALL_NODES;\n\t\tptask->speed       = SCODE_100;\n\t} else {\n\t\tunion fwnet_hwaddr *ha = (union fwnet_hwaddr *)hdr_buf.h_dest;\n\t\t__be64 guid = get_unaligned(&ha->uc.uniq_id);\n\t\tu8 generation;\n\n\t\tpeer = fwnet_peer_find_by_guid(dev, be64_to_cpu(guid));\n\t\tif (!peer)\n\t\t\tgoto fail;\n\n\t\tgeneration         = peer->generation;\n\t\tdest_node          = peer->node_id;\n\t\tmax_payload        = peer->max_payload;\n\t\tdatagram_label_ptr = &peer->datagram_label;\n\n\t\tptask->fifo_addr   = fwnet_hwaddr_fifo(ha);\n\t\tptask->generation  = generation;\n\t\tptask->dest_node   = dest_node;\n\t\tptask->speed       = peer->speed;\n\t}\n\n\tptask->hdr.w0 = 0;\n\tptask->hdr.w1 = 0;\n\tptask->skb = skb;\n\tptask->dev = dev;\n\n\t/* Does it all fit in one packet? */\n\tif (dg_size <= max_payload) {\n\t\tfwnet_make_uf_hdr(&ptask->hdr, ntohs(proto));\n\t\tptask->outstanding_pkts = 1;\n\t\tmax_payload = dg_size + RFC2374_UNFRAG_HDR_SIZE;\n\t} else {\n\t\tu16 datagram_label;\n\n\t\tmax_payload -= RFC2374_FRAG_OVERHEAD;\n\t\tdatagram_label = (*datagram_label_ptr)++;\n\t\tfwnet_make_ff_hdr(&ptask->hdr, ntohs(proto), dg_size,\n\t\t\t\t  datagram_label);\n\t\tptask->outstanding_pkts = DIV_ROUND_UP(dg_size, max_payload);\n\t\tmax_payload += RFC2374_FRAG_HDR_SIZE;\n\t}\n\n\tif (++dev->queued_datagrams == FWNET_MAX_QUEUED_DATAGRAMS)\n\t\tnetif_stop_queue(dev->netdev);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tptask->max_payload = max_payload;\n\tptask->enqueued    = 0;\n\n\tfwnet_send_packet(ptask);\n\n\treturn NETDEV_TX_OK;\n\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (ptask)\n\t\tkmem_cache_free(fwnet_packet_task_cache, ptask);\n\n\tif (skb != NULL)\n\t\tdev_kfree_skb(skb);\n\n\tnet->stats.tx_dropped++;\n\tnet->stats.tx_errors++;\n\n\t/*\n\t * FIXME: According to a patch from 2003-02-26, \"returning non-zero\n\t * causes serious problems\" here, allegedly.  Before that patch,\n\t * -ERRNO was returned which is not appropriate under Linux 2.6.\n\t * Perhaps more needs to be done?  Stop the queue in serious\n\t * conditions and restart it elsewhere?\n\t */\n\treturn NETDEV_TX_OK;\n}\n\nstatic int fwnet_change_mtu(struct net_device *net, int new_mtu)\n{\n\tif (new_mtu < 68)\n\t\treturn -EINVAL;\n\n\tnet->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic const struct ethtool_ops fwnet_ethtool_ops = {\n\t.get_link\t= ethtool_op_get_link,\n};\n\nstatic const struct net_device_ops fwnet_netdev_ops = {\n\t.ndo_open       = fwnet_open,\n\t.ndo_stop\t= fwnet_stop,\n\t.ndo_start_xmit = fwnet_tx,\n\t.ndo_change_mtu = fwnet_change_mtu,\n};\n\nstatic void fwnet_init_dev(struct net_device *net)\n{\n\tnet->header_ops\t\t= &fwnet_header_ops;\n\tnet->netdev_ops\t\t= &fwnet_netdev_ops;\n\tnet->watchdog_timeo\t= 2 * HZ;\n\tnet->flags\t\t= IFF_BROADCAST | IFF_MULTICAST;\n\tnet->features\t\t= NETIF_F_HIGHDMA;\n\tnet->addr_len\t\t= FWNET_ALEN;\n\tnet->hard_header_len\t= FWNET_HLEN;\n\tnet->type\t\t= ARPHRD_IEEE1394;\n\tnet->tx_queue_len\t= FWNET_TX_QUEUE_LEN;\n\tnet->ethtool_ops\t= &fwnet_ethtool_ops;\n}\n\n/* caller must hold fwnet_device_mutex */\nstatic struct fwnet_device *fwnet_dev_find(struct fw_card *card)\n{\n\tstruct fwnet_device *dev;\n\n\tlist_for_each_entry(dev, &fwnet_device_list, dev_link)\n\t\tif (dev->card == card)\n\t\t\treturn dev;\n\n\treturn NULL;\n}\n\nstatic int fwnet_add_peer(struct fwnet_device *dev,\n\t\t\t  struct fw_unit *unit, struct fw_device *device)\n{\n\tstruct fwnet_peer *peer;\n\n\tpeer = kmalloc(sizeof(*peer), GFP_KERNEL);\n\tif (!peer)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&unit->device, peer);\n\n\tpeer->dev = dev;\n\tpeer->guid = (u64)device->config_rom[3] << 32 | device->config_rom[4];\n\tINIT_LIST_HEAD(&peer->pd_list);\n\tpeer->pdg_size = 0;\n\tpeer->datagram_label = 0;\n\tpeer->speed = device->max_speed;\n\tpeer->max_payload = fwnet_max_payload(device->max_rec, peer->speed);\n\n\tpeer->generation = device->generation;\n\tsmp_rmb();\n\tpeer->node_id = device->node_id;\n\n\tspin_lock_irq(&dev->lock);\n\tlist_add_tail(&peer->peer_link, &dev->peer_list);\n\tdev->peer_count++;\n\tset_carrier_state(dev);\n\tspin_unlock_irq(&dev->lock);\n\n\treturn 0;\n}\n\nstatic int fwnet_probe(struct fw_unit *unit,\n\t\t       const struct ieee1394_device_id *id)\n{\n\tstruct fw_device *device = fw_parent_device(unit);\n\tstruct fw_card *card = device->card;\n\tstruct net_device *net;\n\tbool allocated_netdev = false;\n\tstruct fwnet_device *dev;\n\tunsigned max_mtu;\n\tint ret;\n\tunion fwnet_hwaddr *ha;\n\n\tmutex_lock(&fwnet_device_mutex);\n\n\tdev = fwnet_dev_find(card);\n\tif (dev) {\n\t\tnet = dev->netdev;\n\t\tgoto have_dev;\n\t}\n\n\tnet = alloc_netdev(sizeof(*dev), \"firewire%d\", NET_NAME_UNKNOWN,\n\t\t\t   fwnet_init_dev);\n\tif (net == NULL) {\n\t\tmutex_unlock(&fwnet_device_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tallocated_netdev = true;\n\tSET_NETDEV_DEV(net, card->device);\n\tdev = netdev_priv(net);\n\n\tspin_lock_init(&dev->lock);\n\tdev->broadcast_state = FWNET_BROADCAST_ERROR;\n\tdev->broadcast_rcv_context = NULL;\n\tdev->broadcast_xmt_max_payload = 0;\n\tdev->broadcast_xmt_datagramlabel = 0;\n\tdev->local_fifo = FWNET_NO_FIFO_ADDR;\n\tdev->queued_datagrams = 0;\n\tINIT_LIST_HEAD(&dev->peer_list);\n\tdev->card = card;\n\tdev->netdev = net;\n\n\tret = fwnet_fifo_start(dev);\n\tif (ret < 0)\n\t\tgoto out;\n\tdev->local_fifo = dev->handler.offset;\n\n\t/*\n\t * Use the RFC 2734 default 1500 octets or the maximum payload\n\t * as initial MTU\n\t */\n\tmax_mtu = (1 << (card->max_receive + 1))\n\t\t  - sizeof(struct rfc2734_header) - IEEE1394_GASP_HDR_SIZE;\n\tnet->mtu = min(1500U, max_mtu);\n\n\t/* Set our hardware address while we're at it */\n\tha = (union fwnet_hwaddr *)net->dev_addr;\n\tput_unaligned_be64(card->guid, &ha->uc.uniq_id);\n\tha->uc.max_rec = dev->card->max_receive;\n\tha->uc.sspd = dev->card->link_speed;\n\tput_unaligned_be16(dev->local_fifo >> 32, &ha->uc.fifo_hi);\n\tput_unaligned_be32(dev->local_fifo & 0xffffffff, &ha->uc.fifo_lo);\n\n\tmemset(net->broadcast, -1, net->addr_len);\n\n\tret = register_netdev(net);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_add_tail(&dev->dev_link, &fwnet_device_list);\n\tdev_notice(&net->dev, \"IP over IEEE 1394 on card %s\\n\",\n\t\t   dev_name(card->device));\n have_dev:\n\tret = fwnet_add_peer(dev, unit, device);\n\tif (ret && allocated_netdev) {\n\t\tunregister_netdev(net);\n\t\tlist_del(&dev->dev_link);\n out:\n\t\tfwnet_fifo_stop(dev);\n\t\tfree_netdev(net);\n\t}\n\n\tmutex_unlock(&fwnet_device_mutex);\n\n\treturn ret;\n}\n\n/*\n * FIXME abort partially sent fragmented datagrams,\n * discard partially received fragmented datagrams\n */\nstatic void fwnet_update(struct fw_unit *unit)\n{\n\tstruct fw_device *device = fw_parent_device(unit);\n\tstruct fwnet_peer *peer = dev_get_drvdata(&unit->device);\n\tint generation;\n\n\tgeneration = device->generation;\n\n\tspin_lock_irq(&peer->dev->lock);\n\tpeer->node_id    = device->node_id;\n\tpeer->generation = generation;\n\tspin_unlock_irq(&peer->dev->lock);\n}\n\nstatic void fwnet_remove_peer(struct fwnet_peer *peer, struct fwnet_device *dev)\n{\n\tstruct fwnet_partial_datagram *pd, *pd_next;\n\n\tspin_lock_irq(&dev->lock);\n\tlist_del(&peer->peer_link);\n\tdev->peer_count--;\n\tset_carrier_state(dev);\n\tspin_unlock_irq(&dev->lock);\n\n\tlist_for_each_entry_safe(pd, pd_next, &peer->pd_list, pd_link)\n\t\tfwnet_pd_delete(pd);\n\n\tkfree(peer);\n}\n\nstatic void fwnet_remove(struct fw_unit *unit)\n{\n\tstruct fwnet_peer *peer = dev_get_drvdata(&unit->device);\n\tstruct fwnet_device *dev = peer->dev;\n\tstruct net_device *net;\n\tint i;\n\n\tmutex_lock(&fwnet_device_mutex);\n\n\tnet = dev->netdev;\n\n\tfwnet_remove_peer(peer, dev);\n\n\tif (list_empty(&dev->peer_list)) {\n\t\tunregister_netdev(net);\n\n\t\tfwnet_fifo_stop(dev);\n\n\t\tfor (i = 0; dev->queued_datagrams && i < 5; i++)\n\t\t\tssleep(1);\n\t\tWARN_ON(dev->queued_datagrams);\n\t\tlist_del(&dev->dev_link);\n\n\t\tfree_netdev(net);\n\t}\n\n\tmutex_unlock(&fwnet_device_mutex);\n}\n\nstatic const struct ieee1394_device_id fwnet_id_table[] = {\n\t{\n\t\t.match_flags  = IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t\tIEEE1394_MATCH_VERSION,\n\t\t.specifier_id = IANA_SPECIFIER_ID,\n\t\t.version      = RFC2734_SW_VERSION,\n\t},\n#if IS_ENABLED(CONFIG_IPV6)\n\t{\n\t\t.match_flags  = IEEE1394_MATCH_SPECIFIER_ID |\n\t\t\t\tIEEE1394_MATCH_VERSION,\n\t\t.specifier_id = IANA_SPECIFIER_ID,\n\t\t.version      = RFC3146_SW_VERSION,\n\t},\n#endif\n\t{ }\n};\n\nstatic struct fw_driver fwnet_driver = {\n\t.driver = {\n\t\t.owner  = THIS_MODULE,\n\t\t.name   = KBUILD_MODNAME,\n\t\t.bus    = &fw_bus_type,\n\t},\n\t.probe    = fwnet_probe,\n\t.update   = fwnet_update,\n\t.remove   = fwnet_remove,\n\t.id_table = fwnet_id_table,\n};\n\nstatic const u32 rfc2374_unit_directory_data[] = {\n\t0x00040000,\t/* directory_length\t\t*/\n\t0x1200005e,\t/* unit_specifier_id: IANA\t*/\n\t0x81000003,\t/* textual descriptor offset\t*/\n\t0x13000001,\t/* unit_sw_version: RFC 2734\t*/\n\t0x81000005,\t/* textual descriptor offset\t*/\n\t0x00030000,\t/* descriptor_length\t\t*/\n\t0x00000000,\t/* text\t\t\t\t*/\n\t0x00000000,\t/* minimal ASCII, en\t\t*/\n\t0x49414e41,\t/* I A N A\t\t\t*/\n\t0x00030000,\t/* descriptor_length\t\t*/\n\t0x00000000,\t/* text\t\t\t\t*/\n\t0x00000000,\t/* minimal ASCII, en\t\t*/\n\t0x49507634,\t/* I P v 4\t\t\t*/\n};\n\nstatic struct fw_descriptor rfc2374_unit_directory = {\n\t.length = ARRAY_SIZE(rfc2374_unit_directory_data),\n\t.key    = (CSR_DIRECTORY | CSR_UNIT) << 24,\n\t.data   = rfc2374_unit_directory_data\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic const u32 rfc3146_unit_directory_data[] = {\n\t0x00040000,\t/* directory_length\t\t*/\n\t0x1200005e,\t/* unit_specifier_id: IANA\t*/\n\t0x81000003,\t/* textual descriptor offset\t*/\n\t0x13000002,\t/* unit_sw_version: RFC 3146\t*/\n\t0x81000005,\t/* textual descriptor offset\t*/\n\t0x00030000,\t/* descriptor_length\t\t*/\n\t0x00000000,\t/* text\t\t\t\t*/\n\t0x00000000,\t/* minimal ASCII, en\t\t*/\n\t0x49414e41,\t/* I A N A\t\t\t*/\n\t0x00030000,\t/* descriptor_length\t\t*/\n\t0x00000000,\t/* text\t\t\t\t*/\n\t0x00000000,\t/* minimal ASCII, en\t\t*/\n\t0x49507636,\t/* I P v 6\t\t\t*/\n};\n\nstatic struct fw_descriptor rfc3146_unit_directory = {\n\t.length = ARRAY_SIZE(rfc3146_unit_directory_data),\n\t.key    = (CSR_DIRECTORY | CSR_UNIT) << 24,\n\t.data   = rfc3146_unit_directory_data\n};\n#endif\n\nstatic int __init fwnet_init(void)\n{\n\tint err;\n\n\terr = fw_core_add_descriptor(&rfc2374_unit_directory);\n\tif (err)\n\t\treturn err;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\terr = fw_core_add_descriptor(&rfc3146_unit_directory);\n\tif (err)\n\t\tgoto out;\n#endif\n\n\tfwnet_packet_task_cache = kmem_cache_create(\"packet_task\",\n\t\t\tsizeof(struct fwnet_packet_task), 0, 0, NULL);\n\tif (!fwnet_packet_task_cache) {\n\t\terr = -ENOMEM;\n\t\tgoto out2;\n\t}\n\n\terr = driver_register(&fwnet_driver.driver);\n\tif (!err)\n\t\treturn 0;\n\n\tkmem_cache_destroy(fwnet_packet_task_cache);\nout2:\n#if IS_ENABLED(CONFIG_IPV6)\n\tfw_core_remove_descriptor(&rfc3146_unit_directory);\nout:\n#endif\n\tfw_core_remove_descriptor(&rfc2374_unit_directory);\n\n\treturn err;\n}\nmodule_init(fwnet_init);\n\nstatic void __exit fwnet_cleanup(void)\n{\n\tdriver_unregister(&fwnet_driver.driver);\n\tkmem_cache_destroy(fwnet_packet_task_cache);\n#if IS_ENABLED(CONFIG_IPV6)\n\tfw_core_remove_descriptor(&rfc3146_unit_directory);\n#endif\n\tfw_core_remove_descriptor(&rfc2374_unit_directory);\n}\nmodule_exit(fwnet_cleanup);\n\nMODULE_AUTHOR(\"Jay Fenlason <fenlason@redhat.com>\");\nMODULE_DESCRIPTION(\"IP over IEEE1394 as per RFC 2734/3146\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(ieee1394, fwnet_id_table);\n"], "filenames": ["drivers/firewire/net.c"], "buggy_code_start_loc": [580], "buggy_code_end_loc": [769], "fixing_code_start_loc": [581], "fixing_code_end_loc": [787], "type": "CWE-119", "message": "drivers/firewire/net.c in the Linux kernel before 4.8.7, in certain unusual hardware configurations, allows remote attackers to execute arbitrary code via crafted fragmented packets.", "other": {"cve": {"id": "CVE-2016-8633", "sourceIdentifier": "secalert@redhat.com", "published": "2016-11-28T03:59:06.063", "lastModified": "2023-02-12T23:26:13.447", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "drivers/firewire/net.c in the Linux kernel before 4.8.7, in certain unusual hardware configurations, allows remote attackers to execute arbitrary code via crafted fragmented packets."}, {"lang": "es", "value": "drivers/firewire/net.c en el kernel Linux en versiones anteriores a 4.8.7, en ciertas configuraciones de hardware no usuales, permite a atacantes remotos ejecutar un c\u00f3digo arbitrario a trav\u00e9s de paquetes fragmentados manipulados."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:H/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 1.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}, {"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.8.6", "matchCriteriaId": "2DB1181C-8236-47EF-AB6F-1042AFCE5F54"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=667121ace9dbafb368618dbabcf07901c962ddac", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.8.7", "source": "secalert@redhat.com", "tags": ["Release Notes"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/11/06/1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/94149", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2018:0676", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2018:1062", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1170", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/errata/RHSA-2019:1190", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1391490", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://eyalitkin.wordpress.com/2016/11/06/cve-publication-cve-2016-8633/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/667121ace9dbafb368618dbabcf07901c962ddac", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/667121ace9dbafb368618dbabcf07901c962ddac"}}