{"buggy_code": ["use strict;\nuse vars qw($VERSION %IRSSI);\n\nuse Irssi qw(command signal_add signal_add_first active_win\n             settings_get_str settings_get_bool channels windows\n\t     settings_add_str settings_add_bool get_irssi_dir\n\t     window_find_refnum signal_stop);\n$VERSION = '2.13';\n%IRSSI = (\n    authors\t=> 'Juerd',\n    contact\t=> 'juerd@juerd.nl',\n    name\t=> 'Scroll buffer restorer',\n    description\t=> 'Saves the buffer for /upgrade, so that no information is lost',\n    license\t=> 'Public Domain',\n    url\t\t=> 'http://juerd.nl/irssi/',\n    changed\t=> 'Mon May 13 19:41 CET 2002',\n    changes\t=> 'Severe formatting bug removed * oops, I ' .\n                   'exposed Irssi to ircII foolishness * sorry ' .\n\t\t   '** removed logging stuff (this is a fix)',\n    note1\t=> 'This script HAS TO BE in your scripts/autorun!',\n    note2\t=> 'Perl support must be static or in startup',\n);\n\n# Q: How can I get a very smooth and clean upgrade?\n#\n# A: /set -clear upgrade_separator\n#    /set upgrade_suppress_join ON (default)\n#    /set channel_sync OFF\n\n# Q: Can I use color in the upgrade_separator?\n# Q: Is it possible to save my command history?\n# Q: Can I prevent the screen from blinking?\n# Q: Can you make it faster?\n#\n# A: Probably not, but if you can do it, tell me how.\n\nuse Irssi::TextUI;\nuse Data::Dumper;\n\nmy %suppress;\n\nsub upgrade {\n    open BUF, q{>}, sprintf('%s/scrollbuffer', get_irssi_dir) or die $!;\n    print BUF join(\"\\0\", map $_->{server}->{address} . $_->{name}, channels), \"\\n\";\n    for my $window (windows) {\n\tnext unless defined $window;\n\tnext if $window->{name} eq 'status';\n\tmy $view = $window->view;\n\tmy $line = $view->get_lines;\n\tmy $lines  = 0;\n\tmy $buf = '';\n\tif (defined $line){\n\t    {\n\t\t$buf .= $line->get_text(1) . \"\\n\";\n\t\t$line = $line->next;\n\t\t$lines++;\n\t\tredo if defined $line;\n\t    }\n\t}\n\tprintf BUF \"%s:%s\\n%s\", $window->{refnum}, $lines, $buf;\n    }\n    close BUF;\n    unlink sprintf(\"%s/sessionconfig\", get_irssi_dir);\n    command 'layout save';\n    command 'save';\n}\n\nsub restore {\n    open BUF, q{<}, sprintf('%s/scrollbuffer', get_irssi_dir) or die $!;\n    my @suppress = split /\\0/, <BUF>;\n    if (settings_get_bool 'upgrade_suppress_join') {\n\tchomp $suppress[-1];\n\t@suppress{@suppress} = (2) x @suppress;\n    }\n    active_win->command('^window scroll off');\n    while (my $bla = <BUF>){\n\tchomp $bla;\n\tmy ($refnum, $lines) = split /:/, $bla;\n\tnext unless $lines;\n\tmy $window = window_find_refnum $refnum;\n\tunless (defined $window){\n\t    <BUF> for 1..$lines;\n\t    next;\n\t}\n\tmy $view = $window->view;\n\t$view->remove_all_lines();\n\t$view->redraw();\n\tmy $buf = '';\n\t$buf .= <BUF> for 1..$lines;\n\tmy $sep = settings_get_str 'upgrade_separator';\n\t$sep .= \"\\n\" if $sep ne '';\n\t$window->gui_printtext_after(undef, MSGLEVEL_CLIENTNOTICE, \"$buf\\cO$sep\");\n\t$view->redraw();\n    }\n    active_win->command('^window scroll on');\n    active_win->command('^scrollback end');\n}\n\nsub suppress {\n    my ($first, $second) = @_;\n    return unless scalar keys %suppress and settings_get_bool 'upgrade_suppress_join';\n    my $key_part = (grep { /^:?[#!+&]/ } split ' ', $second)[0];\n    $key_part =~ s/^://;\n    my $key = $first->{address} . $key_part;\n    if (exists $suppress{$key} and $suppress{$key}--) {\n    \tsignal_stop();\n        delete $suppress{$key} unless $suppress{$key};\n    }\n}\n\nsettings_add_str  'buffer', 'upgrade_separator'     => '=Upgrade=';\nsettings_add_bool 'buffer', 'upgrade_suppress_join' => 1;\n\nsignal_add_first 'session save'    => 'upgrade';\nsignal_add_first 'session restore' => 'restore';\nsignal_add       'event 366'       => 'suppress';\nsignal_add       'event join'      => 'suppress';\n\nunless (-f sprintf('%s/scripts/autorun/buf.pl', get_irssi_dir)) {\n    Irssi::print('PUT THIS SCRIPT IN ~/.irssi/scripts/autorun/ BEFORE /UPGRADING!!');\n}\n"], "fixing_code": ["use strict;\nuse vars qw($VERSION %IRSSI);\n\nuse Irssi qw(command signal_add signal_add_first active_win\n             settings_get_str settings_get_bool channels windows\n\t     settings_add_str settings_add_bool get_irssi_dir\n\t     window_find_refnum signal_stop);\n$VERSION = '2.20';\n%IRSSI = (\n    authors\t=> 'Juerd',\n    contact\t=> 'juerd@juerd.nl',\n    name\t=> 'Scroll buffer restorer',\n    description\t=> 'Saves the buffer for /upgrade, so that no information is lost',\n    license\t=> 'Public Domain',\n    url\t\t=> 'http://juerd.nl/irssi/',\n    changed\t=> 'Thu Sep 22 01:37 CEST 2016',\n    changes\t=> 'Fixed file permissions (leaked everything via filesystem)',\n    note1\t=> 'This script HAS TO BE in your scripts/autorun!',\n    note2\t=> 'Perl support must be static or in startup',\n);\n\n# Q: How can I get a very smooth and clean upgrade?\n#\n# A: /set -clear upgrade_separator\n#    /set upgrade_suppress_join ON (default)\n#    /set channel_sync OFF\n\n# Q: Can I use color in the upgrade_separator?\n# Q: Is it possible to save my command history?\n# Q: Can I prevent the screen from blinking?\n# Q: Can you make it faster?\n#\n# A: Probably not, but if you can do it, tell me how.\n\nuse Irssi::TextUI;\nuse Data::Dumper;\n\nmy %suppress;\n\nsub _filename { sprintf '%s/scrollbuffer', get_irssi_dir }\n\nsub upgrade {\n    my $fn = _filename;\n    my $old_umask = umask 0077;\n    open my $fh, q{>}, $fn or die \"open $fn: $!\";\n    umask $old_umask;\n\n    print $fh join(\"\\0\", map $_->{server}->{address} . $_->{name}, channels), \"\\n\";\n    for my $window (windows) {\n\tnext unless defined $window;\n\tnext if $window->{name} eq 'status';\n\tmy $view = $window->view;\n\tmy $line = $view->get_lines;\n\tmy $lines  = 0;\n\tmy $buf = '';\n\tif (defined $line){\n\t    {\n\t\t$buf .= $line->get_text(1) . \"\\n\";\n\t\t$line = $line->next;\n\t\t$lines++;\n\t\tredo if defined $line;\n\t    }\n\t}\n\tprintf $fh \"%s:%s\\n%s\", $window->{refnum}, $lines, $buf;\n    }\n    close $fh;\n    unlink sprintf(\"%s/sessionconfig\", get_irssi_dir);\n    command 'layout save';\n    command 'save';\n}\n\nsub restore {\n    my $fn = _filename;\n    open my $fh, q{<}, $fn or die \"open $fn: $!\";\n    unlink $fn or warn \"unlink $fn: $!\";\n\n    my @suppress = split /\\0/, readline $fh;\n    if (settings_get_bool 'upgrade_suppress_join') {\n\tchomp $suppress[-1];\n\t@suppress{@suppress} = (2) x @suppress;\n    }\n    active_win->command('^window scroll off');\n    while (my $bla = readline $fh){\n\tchomp $bla;\n\tmy ($refnum, $lines) = split /:/, $bla;\n\tnext unless $lines;\n\tmy $window = window_find_refnum $refnum;\n\tunless (defined $window){\n\t    readline $fh for 1..$lines;\n\t    next;\n\t}\n\tmy $view = $window->view;\n\t$view->remove_all_lines();\n\t$view->redraw();\n\tmy $buf = '';\n\t$buf .= readline $fh for 1..$lines;\n\tmy $sep = settings_get_str 'upgrade_separator';\n\t$sep .= \"\\n\" if $sep ne '';\n\t$window->gui_printtext_after(undef, MSGLEVEL_CLIENTNOTICE, \"$buf\\cO$sep\");\n\t$view->redraw();\n    }\n    active_win->command('^window scroll on');\n    active_win->command('^scrollback end');\n}\n\nsub suppress {\n    my ($first, $second) = @_;\n    return unless scalar keys %suppress and settings_get_bool 'upgrade_suppress_join';\n    my $key_part = (grep { /^:?[#!+&]/ } split ' ', $second)[0];\n    $key_part =~ s/^://;\n    my $key = $first->{address} . $key_part;\n    if (exists $suppress{$key} and $suppress{$key}--) {\n    \tsignal_stop();\n        delete $suppress{$key} unless $suppress{$key};\n    }\n}\n\nsettings_add_str  'buffer', 'upgrade_separator'     => '=Upgrade=';\nsettings_add_bool 'buffer', 'upgrade_suppress_join' => 1;\n\nsignal_add_first 'session save'    => 'upgrade';\nsignal_add_first 'session restore' => 'restore';\nsignal_add       'event 366'       => 'suppress';\nsignal_add       'event join'      => 'suppress';\n\nunless (-f sprintf('%s/scripts/autorun/buf.pl', get_irssi_dir)) {\n    Irssi::print('PUT THIS SCRIPT IN ~/.irssi/scripts/autorun/ BEFORE /UPGRADING!!');\n}\n\n# Remove any left-over file. If 'session' doesn't exist (created by irssi\n# during /UPGRADE), neither should our file.\nunless (-e sprintf('%s/session', get_irssi_dir)) {\n    my $fn = _filename;\n    unlink $fn or warn \"unlink $fn: $!\" if -e $fn;\n}\n"], "filenames": ["scripts/buf.pl"], "buggy_code_start_loc": [8], "buggy_code_end_loc": [121], "fixing_code_start_loc": [8], "fixing_code_end_loc": [136], "type": "CWE-275", "message": "The buf.pl script before 2.20 in Irssi before 0.8.20 uses weak permissions for the scrollbuffer dump file created between upgrades, which might allow local users to obtain sensitive information from private chat conversations by reading the file.", "other": {"cve": {"id": "CVE-2016-7553", "sourceIdentifier": "security@debian.org", "published": "2017-02-27T22:59:00.480", "lastModified": "2017-03-15T17:31:34.340", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The buf.pl script before 2.20 in Irssi before 0.8.20 uses weak permissions for the scrollbuffer dump file created between upgrades, which might allow local users to obtain sensitive information from private chat conversations by reading the file."}, {"lang": "es", "value": "La secuencia de comandos buf.pl en versiones anteriores a 2.20 en Irssi en versiones anteriores a 0.8.20 utiliza permiso d\u00e9biles para el archivo de volcado scrollbuffer creado entre actualizaciones, lo que podr\u00edan permitir a a usuarios locales obtener informaci\u00f3n sensible de conversaciones de chat privados leyendo el archivo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-275"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:irssi:buf.pl:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.13", "matchCriteriaId": "0446A04A-F652-4096-A349-59A1594FE077"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/24/1", "source": "security@debian.org", "tags": ["Mailing List", "Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/26/4", "source": "security@debian.org", "tags": ["Mailing List", "Patch"]}, {"url": "http://www.securityfocus.com/bid/93155", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/irssi/scripts.irssi.org/commit/f1b1eb154baa684fad5d65bf4dff79c8ded8b65a", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://irssi.org/security/buf_pl_sa_2016.txt", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/7OM3WHWQ7RIAOZSOZZUM4CUYGKSIAGJJ/", "source": "security@debian.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/irssi/scripts.irssi.org/commit/f1b1eb154baa684fad5d65bf4dff79c8ded8b65a"}}