{"buggy_code": ["// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # Ethereum pallet\n//!\n//! The Ethereum pallet works together with EVM pallet to provide full emulation\n//! for Ethereum block processing.\n\n// Ensure we're `no_std` when compiling for Wasm.\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(clippy::comparison_chain, clippy::large_enum_variant)]\n\n#[cfg(all(feature = \"std\", test))]\nmod mock;\n#[cfg(all(feature = \"std\", test))]\nmod tests;\n\nuse ethereum_types::{Bloom, BloomInput, H160, H256, H64, U256};\nuse evm::ExitReason;\nuse fp_consensus::{PostLog, PreLog, FRONTIER_ENGINE_ID};\nuse fp_evm::CallOrCreateInfo;\nuse fp_storage::{EthereumStorageSchema, PALLET_ETHEREUM_SCHEMA};\n#[cfg(feature = \"try-runtime\")]\nuse frame_support::traits::OnRuntimeUpgradeHelpersExt;\nuse frame_support::{\n\tcodec::{Decode, Encode},\n\tdispatch::DispatchResultWithPostInfo,\n\tscale_info::TypeInfo,\n\ttraits::{EnsureOrigin, Get, PalletInfoAccess},\n\tweights::{DispatchInfo, Pays, PostDispatchInfo, Weight},\n};\nuse frame_system::{pallet_prelude::OriginFor, CheckWeight, WeightInfo};\nuse pallet_evm::{BlockHashMapping, FeeCalculator, GasWeightMapping, Runner};\nuse sha3::{Digest, Keccak256};\nuse sp_runtime::{\n\tgeneric::DigestItem,\n\ttraits::{DispatchInfoOf, Dispatchable, One, Saturating, UniqueSaturatedInto, Zero},\n\ttransaction_validity::{\n\t\tInvalidTransaction, TransactionValidity, TransactionValidityError, ValidTransactionBuilder,\n\t},\n\tDispatchErrorWithPostInfo, RuntimeDebug,\n};\nuse sp_std::{marker::PhantomData, prelude::*};\n\npub use ethereum::{\n\tAccessListItem, BlockV2 as Block, LegacyTransactionMessage, Log, ReceiptV3 as Receipt,\n\tTransactionAction, TransactionV2 as Transaction,\n};\npub use fp_rpc::TransactionStatus;\n\n#[derive(PartialEq, Eq, Clone, Encode, Decode, RuntimeDebug, TypeInfo)]\npub enum RawOrigin {\n\tEthereumTransaction(H160),\n}\n\npub fn ensure_ethereum_transaction<OuterOrigin>(o: OuterOrigin) -> Result<H160, &'static str>\nwhere\n\tOuterOrigin: Into<Result<RawOrigin, OuterOrigin>>,\n{\n\tmatch o.into() {\n\t\tOk(RawOrigin::EthereumTransaction(n)) => Ok(n),\n\t\t_ => Err(\"bad origin: expected to be an Ethereum transaction\"),\n\t}\n}\n\n#[derive(Clone, Debug, Encode, Decode, PartialEq, Eq)]\nstruct TransactionData {\n\taction: TransactionAction,\n\tinput: Vec<u8>,\n\tnonce: U256,\n\tgas_limit: U256,\n\tgas_price: Option<U256>,\n\tmax_fee_per_gas: Option<U256>,\n\tmax_priority_fee_per_gas: Option<U256>,\n\tvalue: U256,\n\tchain_id: Option<u64>,\n\taccess_list: Vec<(H160, Vec<H256>)>,\n}\n\npub struct EnsureEthereumTransaction;\nimpl<O: Into<Result<RawOrigin, O>> + From<RawOrigin>> EnsureOrigin<O>\n\tfor EnsureEthereumTransaction\n{\n\ttype Success = H160;\n\tfn try_origin(o: O) -> Result<Self::Success, O> {\n\t\to.into().map(|o| match o {\n\t\t\tRawOrigin::EthereumTransaction(id) => id,\n\t\t})\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\tfn successful_origin() -> O {\n\t\tO::from(RawOrigin::EthereumTransaction(Default::default()))\n\t}\n}\n\nimpl<T> Call<T>\nwhere\n\tOriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,\n\tT: Send + Sync + Config,\n\tT::Call: Dispatchable<Info = DispatchInfo, PostInfo = PostDispatchInfo>,\n{\n\tpub fn is_self_contained(&self) -> bool {\n\t\tmatches!(self, Call::transact { .. })\n\t}\n\n\tpub fn check_self_contained(&self) -> Option<Result<H160, TransactionValidityError>> {\n\t\tif let Call::transact { transaction } = self {\n\t\t\tlet check = || {\n\t\t\t\tlet origin = Pallet::<T>::recover_signer(transaction).ok_or(\n\t\t\t\t\tInvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8),\n\t\t\t\t)?;\n\n\t\t\t\tOk(origin)\n\t\t\t};\n\n\t\t\tSome(check())\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\n\tpub fn pre_dispatch_self_contained(\n\t\t&self,\n\t\torigin: &H160,\n\t) -> Option<Result<(), TransactionValidityError>> {\n\t\tif let Call::transact { transaction } = self {\n\t\t\tSome(Pallet::<T>::validate_transaction_in_block(\n\t\t\t\t*origin,\n\t\t\t\ttransaction,\n\t\t\t))\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\n\tpub fn validate_self_contained(\n\t\t&self,\n\t\torigin: &H160,\n\t\tdispatch_info: &DispatchInfoOf<T::Call>,\n\t\tlen: usize,\n\t) -> Option<TransactionValidity> {\n\t\tif let Call::transact { transaction } = self {\n\t\t\tif let Err(e) = CheckWeight::<T>::do_validate(dispatch_info, len) {\n\t\t\t\treturn Some(Err(e));\n\t\t\t}\n\n\t\t\tSome(Pallet::<T>::validate_transaction_in_pool(\n\t\t\t\t*origin,\n\t\t\t\ttransaction,\n\t\t\t))\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n}\n\npub use self::pallet::*;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config + pallet_timestamp::Config + pallet_evm::Config {\n\t\t/// The overarching event type.\n\t\ttype Event: From<Event> + IsType<<Self as frame_system::Config>::Event>;\n\t\t/// How Ethereum state root is calculated.\n\t\ttype StateRoot: Get<H256>;\n\t}\n\n\t#[pallet::pallet]\n\t#[pallet::generate_store(pub(super) trait Store)]\n\t#[pallet::without_storage_info]\n\tpub struct Pallet<T>(PhantomData<T>);\n\n\t#[pallet::origin]\n\tpub type Origin = RawOrigin;\n\n\t#[pallet::hooks]\n\timpl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {\n\t\tfn on_finalize(n: T::BlockNumber) {\n\t\t\t<Pallet<T>>::store_block(\n\t\t\t\tfp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),\n\t\t\t\tU256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(\n\t\t\t\t\tframe_system::Pallet::<T>::block_number(),\n\t\t\t\t)),\n\t\t\t);\n\t\t\t// move block hash pruning window by one block\n\t\t\tlet block_hash_count = T::BlockHashCount::get();\n\t\t\tlet to_remove = n\n\t\t\t\t.saturating_sub(block_hash_count)\n\t\t\t\t.saturating_sub(One::one());\n\t\t\t// keep genesis hash\n\t\t\tif !to_remove.is_zero() {\n\t\t\t\t<BlockHash<T>>::remove(U256::from(\n\t\t\t\t\tUniqueSaturatedInto::<u32>::unique_saturated_into(to_remove),\n\t\t\t\t));\n\t\t\t}\n\t\t\tPending::<T>::kill();\n\t\t}\n\n\t\tfn on_initialize(_: T::BlockNumber) -> Weight {\n\t\t\tlet mut weight = T::SystemWeightInfo::kill_storage(1);\n\n\t\t\t// If the digest contain an existing ethereum block(encoded as PreLog), If contains,\n\t\t\t// execute the imported block firstly and disable transact dispatch function.\n\t\t\tif let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {\n\t\t\t\tlet PreLog::Block(block) = log;\n\n\t\t\t\tfor transaction in block.transactions {\n\t\t\t\t\tlet source = Self::recover_signer(&transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction signature invalid; the block cannot be built\",\n\t\t\t\t\t);\n\n\t\t\t\t\tSelf::validate_transaction_in_block(source, &transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction verification failed; the block cannot be built\",\n\t\t\t\t\t);\n\t\t\t\t\tlet r = Self::apply_validated_transaction(source, transaction)\n\t\t\t\t\t\t.expect(\"pre-block apply transaction failed; the block cannot be built\");\n\n\t\t\t\t\tweight = weight.saturating_add(r.actual_weight.unwrap_or(0));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Account for `on_finalize` weight:\n\t\t\t//\t- read: frame_system::Pallet::<T>::digest()\n\t\t\t//\t- read: frame_system::Pallet::<T>::block_number()\n\t\t\t//\t- write: <Pallet<T>>::store_block()\n\t\t\t//\t- write: <BlockHash<T>>::remove()\n\t\t\tweight.saturating_add(T::DbWeight::get().reads_writes(2, 2))\n\t\t}\n\n\t\tfn on_runtime_upgrade() -> Weight {\n\t\t\tframe_support::storage::unhashed::put::<EthereumStorageSchema>(\n\t\t\t\tPALLET_ETHEREUM_SCHEMA,\n\t\t\t\t&EthereumStorageSchema::V3,\n\t\t\t);\n\n\t\t\tT::DbWeight::get().write\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T>\n\twhere\n\t\tOriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,\n\t{\n\t\t/// Transact an Ethereum transaction.\n\t\t#[pallet::weight(<T as pallet_evm::Config>::GasWeightMapping::gas_to_weight(\n\t\t\tPallet::<T>::transaction_data(transaction).gas_limit.unique_saturated_into()\n\t\t))]\n\t\tpub fn transact(\n\t\t\torigin: OriginFor<T>,\n\t\t\ttransaction: Transaction,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tlet source = ensure_ethereum_transaction(origin)?;\n\t\t\t// Disable transact functionality if PreLog exist.\n\t\t\tassert!(\n\t\t\t\tfp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),\n\t\t\t\t\"pre log already exists; block is invalid\",\n\t\t\t);\n\n\t\t\tSelf::apply_validated_transaction(source, transaction)\n\t\t}\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event {\n\t\t/// An ethereum transaction was successfully executed. [from, to/contract_address, transaction_hash, exit_reason]\n\t\tExecuted(H160, H160, H256, ExitReason),\n\t}\n\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\t/// Signature is invalid.\n\t\tInvalidSignature,\n\t\t/// Pre-log is present, therefore transact is not allowed.\n\t\tPreLogExists,\n\t}\n\n\t/// Current building block's transactions and receipts.\n\t#[pallet::storage]\n\tpub(super) type Pending<T: Config> =\n\t\tStorageValue<_, Vec<(Transaction, TransactionStatus, Receipt)>, ValueQuery>;\n\n\t/// The current Ethereum block.\n\t#[pallet::storage]\n\tpub(super) type CurrentBlock<T: Config> = StorageValue<_, ethereum::BlockV2>;\n\n\t/// The current Ethereum receipts.\n\t#[pallet::storage]\n\tpub(super) type CurrentReceipts<T: Config> = StorageValue<_, Vec<Receipt>>;\n\n\t/// The current transaction statuses.\n\t#[pallet::storage]\n\tpub(super) type CurrentTransactionStatuses<T: Config> = StorageValue<_, Vec<TransactionStatus>>;\n\n\t// Mapping for block number and hashes.\n\t#[pallet::storage]\n\tpub(super) type BlockHash<T: Config> = StorageMap<_, Twox64Concat, U256, H256, ValueQuery>;\n\n\t#[pallet::genesis_config]\n\t#[derive(Default)]\n\tpub struct GenesisConfig {}\n\n\t#[pallet::genesis_build]\n\timpl<T: Config> GenesisBuild<T> for GenesisConfig {\n\t\tfn build(&self) {\n\t\t\t<Pallet<T>>::store_block(false, U256::zero());\n\t\t\tframe_support::storage::unhashed::put::<EthereumStorageSchema>(\n\t\t\t\tPALLET_ETHEREUM_SCHEMA,\n\t\t\t\t&EthereumStorageSchema::V3,\n\t\t\t);\n\t\t}\n\t}\n}\n\nimpl<T: Config> Pallet<T> {\n\tfn transaction_data(transaction: &Transaction) -> TransactionData {\n\t\tmatch transaction {\n\t\t\tTransaction::Legacy(t) => TransactionData {\n\t\t\t\taction: t.action,\n\t\t\t\tinput: t.input.clone(),\n\t\t\t\tnonce: t.nonce,\n\t\t\t\tgas_limit: t.gas_limit,\n\t\t\t\tgas_price: Some(t.gas_price),\n\t\t\t\tmax_fee_per_gas: None,\n\t\t\t\tmax_priority_fee_per_gas: None,\n\t\t\t\tvalue: t.value,\n\t\t\t\tchain_id: t.signature.chain_id(),\n\t\t\t\taccess_list: Vec::new(),\n\t\t\t},\n\t\t\tTransaction::EIP2930(t) => TransactionData {\n\t\t\t\taction: t.action,\n\t\t\t\tinput: t.input.clone(),\n\t\t\t\tnonce: t.nonce,\n\t\t\t\tgas_limit: t.gas_limit,\n\t\t\t\tgas_price: Some(t.gas_price),\n\t\t\t\tmax_fee_per_gas: None,\n\t\t\t\tmax_priority_fee_per_gas: None,\n\t\t\t\tvalue: t.value,\n\t\t\t\tchain_id: Some(t.chain_id),\n\t\t\t\taccess_list: t\n\t\t\t\t\t.access_list\n\t\t\t\t\t.iter()\n\t\t\t\t\t.map(|d| (d.address, d.storage_keys.clone()))\n\t\t\t\t\t.collect(),\n\t\t\t},\n\t\t\tTransaction::EIP1559(t) => TransactionData {\n\t\t\t\taction: t.action,\n\t\t\t\tinput: t.input.clone(),\n\t\t\t\tnonce: t.nonce,\n\t\t\t\tgas_limit: t.gas_limit,\n\t\t\t\tgas_price: None,\n\t\t\t\tmax_fee_per_gas: Some(t.max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas: Some(t.max_priority_fee_per_gas),\n\t\t\t\tvalue: t.value,\n\t\t\t\tchain_id: Some(t.chain_id),\n\t\t\t\taccess_list: t\n\t\t\t\t\t.access_list\n\t\t\t\t\t.iter()\n\t\t\t\t\t.map(|d| (d.address, d.storage_keys.clone()))\n\t\t\t\t\t.collect(),\n\t\t\t},\n\t\t}\n\t}\n\n\tfn recover_signer(transaction: &Transaction) -> Option<H160> {\n\t\tlet mut sig = [0u8; 65];\n\t\tlet mut msg = [0u8; 32];\n\t\tmatch transaction {\n\t\t\tTransaction::Legacy(t) => {\n\t\t\t\tsig[0..32].copy_from_slice(&t.signature.r()[..]);\n\t\t\t\tsig[32..64].copy_from_slice(&t.signature.s()[..]);\n\t\t\t\tsig[64] = t.signature.standard_v();\n\t\t\t\tmsg.copy_from_slice(\n\t\t\t\t\t&ethereum::LegacyTransactionMessage::from(t.clone()).hash()[..],\n\t\t\t\t);\n\t\t\t}\n\t\t\tTransaction::EIP2930(t) => {\n\t\t\t\tsig[0..32].copy_from_slice(&t.r[..]);\n\t\t\t\tsig[32..64].copy_from_slice(&t.s[..]);\n\t\t\t\tsig[64] = t.odd_y_parity as u8;\n\t\t\t\tmsg.copy_from_slice(\n\t\t\t\t\t&ethereum::EIP2930TransactionMessage::from(t.clone()).hash()[..],\n\t\t\t\t);\n\t\t\t}\n\t\t\tTransaction::EIP1559(t) => {\n\t\t\t\tsig[0..32].copy_from_slice(&t.r[..]);\n\t\t\t\tsig[32..64].copy_from_slice(&t.s[..]);\n\t\t\t\tsig[64] = t.odd_y_parity as u8;\n\t\t\t\tmsg.copy_from_slice(\n\t\t\t\t\t&ethereum::EIP1559TransactionMessage::from(t.clone()).hash()[..],\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tlet pubkey = sp_io::crypto::secp256k1_ecdsa_recover(&sig, &msg).ok()?;\n\t\tSome(H160::from(H256::from_slice(\n\t\t\tKeccak256::digest(&pubkey).as_slice(),\n\t\t)))\n\t}\n\n\tfn store_block(post_log: bool, block_number: U256) {\n\t\tlet mut transactions = Vec::new();\n\t\tlet mut statuses = Vec::new();\n\t\tlet mut receipts = Vec::new();\n\t\tlet mut logs_bloom = Bloom::default();\n\t\tlet mut cumulative_gas_used = U256::zero();\n\t\tfor (transaction, status, receipt) in Pending::<T>::get() {\n\t\t\ttransactions.push(transaction);\n\t\t\tstatuses.push(status);\n\t\t\treceipts.push(receipt.clone());\n\t\t\tlet (logs, used_gas) = match receipt {\n\t\t\t\tReceipt::Legacy(d) | Receipt::EIP2930(d) | Receipt::EIP1559(d) => {\n\t\t\t\t\t(d.logs.clone(), d.used_gas)\n\t\t\t\t}\n\t\t\t};\n\t\t\tcumulative_gas_used = used_gas;\n\t\t\tSelf::logs_bloom(logs, &mut logs_bloom);\n\t\t}\n\n\t\tlet ommers = Vec::<ethereum::Header>::new();\n\t\tlet receipts_root = ethereum::util::ordered_trie_root(receipts.iter().map(rlp::encode));\n\t\tlet partial_header = ethereum::PartialHeader {\n\t\t\tparent_hash: if block_number > U256::zero() {\n\t\t\t\tBlockHash::<T>::get(block_number - 1)\n\t\t\t} else {\n\t\t\t\tH256::default()\n\t\t\t},\n\t\t\tbeneficiary: pallet_evm::Pallet::<T>::find_author(),\n\t\t\tstate_root: T::StateRoot::get(),\n\t\t\treceipts_root,\n\t\t\tlogs_bloom,\n\t\t\tdifficulty: U256::zero(),\n\t\t\tnumber: block_number,\n\t\t\tgas_limit: T::BlockGasLimit::get(),\n\t\t\tgas_used: cumulative_gas_used,\n\t\t\ttimestamp: UniqueSaturatedInto::<u64>::unique_saturated_into(\n\t\t\t\tpallet_timestamp::Pallet::<T>::get(),\n\t\t\t),\n\t\t\textra_data: Vec::new(),\n\t\t\tmix_hash: H256::default(),\n\t\t\tnonce: H64::default(),\n\t\t};\n\t\tlet block = ethereum::Block::new(partial_header, transactions.clone(), ommers);\n\n\t\tCurrentBlock::<T>::put(block.clone());\n\t\tCurrentReceipts::<T>::put(receipts.clone());\n\t\tCurrentTransactionStatuses::<T>::put(statuses.clone());\n\t\tBlockHash::<T>::insert(block_number, block.header.hash());\n\n\t\tif post_log {\n\t\t\tlet digest = DigestItem::Consensus(\n\t\t\t\tFRONTIER_ENGINE_ID,\n\t\t\t\tPostLog::Hashes(fp_consensus::Hashes::from_block(block)).encode(),\n\t\t\t);\n\t\t\tframe_system::Pallet::<T>::deposit_log(digest);\n\t\t}\n\t}\n\n\tfn logs_bloom(logs: Vec<Log>, bloom: &mut Bloom) {\n\t\tfor log in logs {\n\t\t\tbloom.accrue(BloomInput::Raw(&log.address[..]));\n\t\t\tfor topic in log.topics {\n\t\t\t\tbloom.accrue(BloomInput::Raw(&topic[..]));\n\t\t\t}\n\t\t}\n\t}\n\n\t// Common controls to be performed in the same way by the pool and the\n\t// State Transition Function (STF).\n\t// This is the case for all controls except those concerning the nonce.\n\tfn validate_transaction_common(\n\t\torigin: H160,\n\t\ttransaction_data: &TransactionData,\n\t) -> Result<(U256, u64), TransactionValidityError> {\n\t\tlet gas_limit = transaction_data.gas_limit;\n\n\t\t// We must ensure a transaction can pay the cost of its data bytes.\n\t\t// If it can't it should not be included in a block.\n\t\tlet mut gasometer = evm::gasometer::Gasometer::new(\n\t\t\tgas_limit.low_u64(),\n\t\t\t<T as pallet_evm::Config>::config(),\n\t\t);\n\t\tlet transaction_cost = match transaction_data.action {\n\t\t\tTransactionAction::Call(_) => evm::gasometer::call_transaction_cost(\n\t\t\t\t&transaction_data.input,\n\t\t\t\t&transaction_data.access_list,\n\t\t\t),\n\t\t\tTransactionAction::Create => evm::gasometer::create_transaction_cost(\n\t\t\t\t&transaction_data.input,\n\t\t\t\t&transaction_data.access_list,\n\t\t\t),\n\t\t};\n\t\tif gasometer.record_transaction(transaction_cost).is_err() {\n\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t)\n\t\t\t.into());\n\t\t}\n\n\t\tif let Some(chain_id) = transaction_data.chain_id {\n\t\t\tif chain_id != T::ChainId::get() {\n\t\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\t\tTransactionValidationError::InvalidChainId as u8,\n\t\t\t\t)\n\t\t\t\t.into());\n\t\t\t}\n\t\t}\n\n\t\tif gas_limit >= T::BlockGasLimit::get() {\n\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t)\n\t\t\t.into());\n\t\t}\n\n\t\tlet (base_fee, _) = T::FeeCalculator::min_gas_price();\n\t\tlet mut priority = 0;\n\n\t\tlet max_fee_per_gas = match (\n\t\t\ttransaction_data.gas_price,\n\t\t\ttransaction_data.max_fee_per_gas,\n\t\t\ttransaction_data.max_priority_fee_per_gas,\n\t\t) {\n\t\t\t// Legacy or EIP-2930 transaction.\n\t\t\t// Handle priority here. On legacy transaction everything in gas_price except\n\t\t\t// the current base_fee is considered a tip to the miner and thus the priority.\n\t\t\t(Some(gas_price), None, None) => {\n\t\t\t\tpriority = gas_price.saturating_sub(base_fee).unique_saturated_into();\n\t\t\t\tgas_price\n\t\t\t}\n\t\t\t// EIP-1559 transaction without tip.\n\t\t\t(None, Some(max_fee_per_gas), None) => max_fee_per_gas,\n\t\t\t// EIP-1559 transaction with tip.\n\t\t\t(None, Some(max_fee_per_gas), Some(max_priority_fee_per_gas)) => {\n\t\t\t\tif max_priority_fee_per_gas > max_fee_per_gas {\n\t\t\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\t\t\tTransactionValidationError::MaxFeePerGasTooLow as u8,\n\t\t\t\t\t)\n\t\t\t\t\t.into());\n\t\t\t\t}\n\t\t\t\tpriority = max_fee_per_gas\n\t\t\t\t\t.saturating_sub(base_fee)\n\t\t\t\t\t.min(max_priority_fee_per_gas)\n\t\t\t\t\t.unique_saturated_into();\n\t\t\t\tmax_fee_per_gas\n\t\t\t}\n\t\t\t_ => return Err(InvalidTransaction::Payment.into()),\n\t\t};\n\n\t\tif max_fee_per_gas < base_fee {\n\t\t\treturn Err(InvalidTransaction::Payment.into());\n\t\t}\n\n\t\tlet fee = max_fee_per_gas.saturating_mul(gas_limit);\n\t\tlet (account_data, _) = pallet_evm::Pallet::<T>::account_basic(&origin);\n\t\tlet total_payment = transaction_data.value.saturating_add(fee);\n\t\tif account_data.balance < total_payment {\n\t\t\treturn Err(InvalidTransaction::Payment.into());\n\t\t}\n\n\t\tOk((account_data.nonce, priority))\n\t}\n\n\t// Controls that must be performed by the pool.\n\t// The controls common with the State Transition Function (STF) are in\n\t// the function `validate_transaction_common`.\n\tfn validate_transaction_in_pool(\n\t\torigin: H160,\n\t\ttransaction: &Transaction,\n\t) -> TransactionValidity {\n\t\tlet transaction_data = Pallet::<T>::transaction_data(transaction);\n\t\tlet transaction_nonce = transaction_data.nonce;\n\n\t\tlet (account_nonce, priority) =\n\t\t\tSelf::validate_transaction_common(origin, &transaction_data)?;\n\n\t\tif transaction_nonce < account_nonce {\n\t\t\treturn Err(InvalidTransaction::Stale.into());\n\t\t}\n\n\t\t// The tag provides and requires must be filled correctly according to the nonce.\n\t\tlet mut builder = ValidTransactionBuilder::default()\n\t\t\t.and_provides((origin, transaction_nonce))\n\t\t\t.priority(priority);\n\n\t\t// In the context of the pool, a transaction with\n\t\t// too high a nonce is still considered valid\n\t\tif transaction_nonce > account_nonce {\n\t\t\tif let Some(prev_nonce) = transaction_nonce.checked_sub(1.into()) {\n\t\t\t\tbuilder = builder.and_requires((origin, prev_nonce))\n\t\t\t}\n\t\t}\n\n\t\tbuilder.build()\n\t}\n\n\tfn apply_validated_transaction(\n\t\tsource: H160,\n\t\ttransaction: Transaction,\n\t) -> DispatchResultWithPostInfo {\n\t\tlet (to, _, info) = Self::execute(source, &transaction, None)?;\n\n\t\tlet pending = Pending::<T>::get();\n\t\tlet transaction_hash = transaction.hash();\n\t\tlet transaction_index = pending.len() as u32;\n\n\t\tlet (reason, status, used_gas, dest) = match info {\n\t\t\tCallOrCreateInfo::Call(info) => (\n\t\t\t\tinfo.exit_reason,\n\t\t\t\tTransactionStatus {\n\t\t\t\t\ttransaction_hash,\n\t\t\t\t\ttransaction_index,\n\t\t\t\t\tfrom: source,\n\t\t\t\t\tto,\n\t\t\t\t\tcontract_address: None,\n\t\t\t\t\tlogs: info.logs.clone(),\n\t\t\t\t\tlogs_bloom: {\n\t\t\t\t\t\tlet mut bloom: Bloom = Bloom::default();\n\t\t\t\t\t\tSelf::logs_bloom(info.logs, &mut bloom);\n\t\t\t\t\t\tbloom\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinfo.used_gas,\n\t\t\t\tto,\n\t\t\t),\n\t\t\tCallOrCreateInfo::Create(info) => (\n\t\t\t\tinfo.exit_reason,\n\t\t\t\tTransactionStatus {\n\t\t\t\t\ttransaction_hash,\n\t\t\t\t\ttransaction_index,\n\t\t\t\t\tfrom: source,\n\t\t\t\t\tto,\n\t\t\t\t\tcontract_address: Some(info.value),\n\t\t\t\t\tlogs: info.logs.clone(),\n\t\t\t\t\tlogs_bloom: {\n\t\t\t\t\t\tlet mut bloom: Bloom = Bloom::default();\n\t\t\t\t\t\tSelf::logs_bloom(info.logs, &mut bloom);\n\t\t\t\t\t\tbloom\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinfo.used_gas,\n\t\t\t\tSome(info.value),\n\t\t\t),\n\t\t};\n\n\t\tlet receipt = {\n\t\t\tlet status_code: u8 = match reason {\n\t\t\t\tExitReason::Succeed(_) => 1,\n\t\t\t\t_ => 0,\n\t\t\t};\n\t\t\tlet logs_bloom = status.logs_bloom;\n\t\t\tlet logs = status.clone().logs;\n\t\t\tlet cumulative_gas_used = if let Some((_, _, receipt)) = pending.last() {\n\t\t\t\tmatch receipt {\n\t\t\t\t\tReceipt::Legacy(d) | Receipt::EIP2930(d) | Receipt::EIP1559(d) => {\n\t\t\t\t\t\td.used_gas.saturating_add(used_gas)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tused_gas\n\t\t\t};\n\t\t\tmatch &transaction {\n\t\t\t\tTransaction::Legacy(_) => Receipt::Legacy(ethereum::EIP658ReceiptData {\n\t\t\t\t\tstatus_code,\n\t\t\t\t\tused_gas: cumulative_gas_used,\n\t\t\t\t\tlogs_bloom,\n\t\t\t\t\tlogs,\n\t\t\t\t}),\n\t\t\t\tTransaction::EIP2930(_) => Receipt::EIP2930(ethereum::EIP2930ReceiptData {\n\t\t\t\t\tstatus_code,\n\t\t\t\t\tused_gas: cumulative_gas_used,\n\t\t\t\t\tlogs_bloom,\n\t\t\t\t\tlogs,\n\t\t\t\t}),\n\t\t\t\tTransaction::EIP1559(_) => Receipt::EIP1559(ethereum::EIP2930ReceiptData {\n\t\t\t\t\tstatus_code,\n\t\t\t\t\tused_gas: cumulative_gas_used,\n\t\t\t\t\tlogs_bloom,\n\t\t\t\t\tlogs,\n\t\t\t\t}),\n\t\t\t}\n\t\t};\n\n\t\tPending::<T>::append((transaction, status, receipt));\n\n\t\tSelf::deposit_event(Event::Executed(\n\t\t\tsource,\n\t\t\tdest.unwrap_or_default(),\n\t\t\ttransaction_hash,\n\t\t\treason,\n\t\t));\n\n\t\tOk(PostDispatchInfo {\n\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\tused_gas.unique_saturated_into(),\n\t\t\t)),\n\t\t\tpays_fee: Pays::No,\n\t\t})\n\t}\n\n\t/// Get the transaction status with given index.\n\tpub fn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {\n\t\tCurrentTransactionStatuses::<T>::get()\n\t}\n\n\t/// Get current block.\n\tpub fn current_block() -> Option<ethereum::BlockV2> {\n\t\tCurrentBlock::<T>::get()\n\t}\n\n\t/// Get current block hash\n\tpub fn current_block_hash() -> Option<H256> {\n\t\tSelf::current_block().map(|block| block.header.hash())\n\t}\n\n\t/// Get receipts by number.\n\tpub fn current_receipts() -> Option<Vec<Receipt>> {\n\t\tCurrentReceipts::<T>::get()\n\t}\n\n\t/// Execute an Ethereum transaction.\n\tpub fn execute(\n\t\tfrom: H160,\n\t\ttransaction: &Transaction,\n\t\tconfig: Option<evm::Config>,\n\t) -> Result<\n\t\t(Option<H160>, Option<H160>, CallOrCreateInfo),\n\t\tDispatchErrorWithPostInfo<PostDispatchInfo>,\n\t> {\n\t\tlet (\n\t\t\tinput,\n\t\t\tvalue,\n\t\t\tgas_limit,\n\t\t\tmax_fee_per_gas,\n\t\t\tmax_priority_fee_per_gas,\n\t\t\tnonce,\n\t\t\taction,\n\t\t\taccess_list,\n\t\t) = {\n\t\t\tmatch transaction {\n\t\t\t\t// max_fee_per_gas and max_priority_fee_per_gas in legacy and 2930 transactions is\n\t\t\t\t// the provided gas_price.\n\t\t\t\tTransaction::Legacy(t) => (\n\t\t\t\t\tt.input.clone(),\n\t\t\t\t\tt.value,\n\t\t\t\t\tt.gas_limit,\n\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\tSome(t.nonce),\n\t\t\t\t\tt.action,\n\t\t\t\t\tVec::new(),\n\t\t\t\t),\n\t\t\t\tTransaction::EIP2930(t) => {\n\t\t\t\t\tlet access_list: Vec<(H160, Vec<H256>)> = t\n\t\t\t\t\t\t.access_list\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys.clone()))\n\t\t\t\t\t\t.collect();\n\t\t\t\t\t(\n\t\t\t\t\t\tt.input.clone(),\n\t\t\t\t\t\tt.value,\n\t\t\t\t\t\tt.gas_limit,\n\t\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\t\tSome(t.nonce),\n\t\t\t\t\t\tt.action,\n\t\t\t\t\t\taccess_list,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tTransaction::EIP1559(t) => {\n\t\t\t\t\tlet access_list: Vec<(H160, Vec<H256>)> = t\n\t\t\t\t\t\t.access_list\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys.clone()))\n\t\t\t\t\t\t.collect();\n\t\t\t\t\t(\n\t\t\t\t\t\tt.input.clone(),\n\t\t\t\t\t\tt.value,\n\t\t\t\t\t\tt.gas_limit,\n\t\t\t\t\t\tSome(t.max_fee_per_gas),\n\t\t\t\t\t\tSome(t.max_priority_fee_per_gas),\n\t\t\t\t\t\tSome(t.nonce),\n\t\t\t\t\t\tt.action,\n\t\t\t\t\t\taccess_list,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet is_transactional = true;\n\t\tmatch action {\n\t\t\tethereum::TransactionAction::Call(target) => {\n\t\t\t\tlet res = match T::Runner::call(\n\t\t\t\t\tfrom,\n\t\t\t\t\ttarget,\n\t\t\t\t\tinput,\n\t\t\t\t\tvalue,\n\t\t\t\t\tgas_limit.low_u64(),\n\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\tnonce,\n\t\t\t\t\taccess_list,\n\t\t\t\t\tis_transactional,\n\t\t\t\t\tconfig.as_ref().unwrap_or_else(|| T::config()),\n\t\t\t\t) {\n\t\t\t\t\tOk(res) => res,\n\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tOk((Some(target), None, CallOrCreateInfo::Call(res)))\n\t\t\t}\n\t\t\tethereum::TransactionAction::Create => {\n\t\t\t\tlet res = match T::Runner::create(\n\t\t\t\t\tfrom,\n\t\t\t\t\tinput,\n\t\t\t\t\tvalue,\n\t\t\t\t\tgas_limit.low_u64(),\n\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\tnonce,\n\t\t\t\t\taccess_list,\n\t\t\t\t\tis_transactional,\n\t\t\t\t\tconfig.as_ref().unwrap_or_else(|| T::config()),\n\t\t\t\t) {\n\t\t\t\t\tOk(res) => res,\n\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tOk((None, Some(res.value), CallOrCreateInfo::Create(res)))\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Validate an Ethereum transaction already in block\n\t///\n\t/// This function must be called during the pre-dispatch phase\n\t/// (just before applying the extrinsic).\n\tpub fn validate_transaction_in_block(\n\t\torigin: H160,\n\t\ttransaction: &Transaction,\n\t) -> Result<(), TransactionValidityError> {\n\t\tlet transaction_data = Pallet::<T>::transaction_data(transaction);\n\t\tlet transaction_nonce = transaction_data.nonce;\n\t\tlet (account_nonce, _) = Self::validate_transaction_common(origin, &transaction_data)?;\n\n\t\t// In the context of the block, a transaction with a nonce that is\n\t\t// too high should be considered invalid and make the whole block invalid.\n\t\tif transaction_nonce > account_nonce {\n\t\t\tErr(TransactionValidityError::Invalid(\n\t\t\t\tInvalidTransaction::Future,\n\t\t\t))\n\t\t} else if transaction_nonce < account_nonce {\n\t\t\tErr(TransactionValidityError::Invalid(InvalidTransaction::Stale))\n\t\t} else {\n\t\t\tOk(())\n\t\t}\n\t}\n\n\tpub fn migrate_block_v0_to_v2() -> Weight {\n\t\tlet db_weights = T::DbWeight::get();\n\t\tlet mut weight: Weight = db_weights.read;\n\t\tlet item = b\"CurrentBlock\";\n\t\tlet block_v0 = frame_support::storage::migration::get_storage_value::<ethereum::BlockV0>(\n\t\t\tSelf::name().as_bytes(),\n\t\t\titem,\n\t\t\t&[],\n\t\t);\n\t\tif let Some(block_v0) = block_v0 {\n\t\t\tweight = weight.saturating_add(db_weights.write);\n\t\t\tlet block_v2: ethereum::BlockV2 = block_v0.into();\n\t\t\tframe_support::storage::migration::put_storage_value::<ethereum::BlockV2>(\n\t\t\t\tSelf::name().as_bytes(),\n\t\t\t\titem,\n\t\t\t\t&[],\n\t\t\t\tblock_v2,\n\t\t\t);\n\t\t}\n\t\tweight\n\t}\n\n\t#[cfg(feature = \"try-runtime\")]\n\tpub fn pre_migrate_block_v2() -> Result<(), &'static str> {\n\t\tlet item = b\"CurrentBlock\";\n\t\tlet block_v0 = frame_support::storage::migration::get_storage_value::<ethereum::BlockV0>(\n\t\t\tSelf::name().as_bytes(),\n\t\t\titem,\n\t\t\t&[],\n\t\t);\n\t\tif let Some(block_v0) = block_v0 {\n\t\t\tSelf::set_temp_storage(block_v0.header.number, \"number\");\n\t\t\tSelf::set_temp_storage(block_v0.header.parent_hash, \"parent_hash\");\n\t\t\tSelf::set_temp_storage(block_v0.transactions.len() as u64, \"transaction_len\");\n\t\t}\n\t\tOk(())\n\t}\n\n\t#[cfg(feature = \"try-runtime\")]\n\tpub fn post_migrate_block_v2() -> Result<(), &'static str> {\n\t\tlet v0_number =\n\t\t\tSelf::get_temp_storage(\"number\").expect(\"We stored a number; it should be there; qed\");\n\t\tlet v0_parent_hash = Self::get_temp_storage(\"parent_hash\")\n\t\t\t.expect(\"We stored a parent hash; it should be there; qed\");\n\t\tlet v0_transaction_len: u64 = Self::get_temp_storage(\"transaction_len\")\n\t\t\t.expect(\"We stored a transaction count; it should be there; qed\");\n\n\t\tlet item = b\"CurrentBlock\";\n\t\tlet block_v2 = frame_support::storage::migration::get_storage_value::<ethereum::BlockV2>(\n\t\t\tSelf::name().as_bytes(),\n\t\t\titem,\n\t\t\t&[],\n\t\t);\n\n\t\tassert!(block_v2.is_some());\n\n\t\tlet block_v2 = block_v2.unwrap();\n\t\tassert_eq!(block_v2.header.number, v0_number);\n\t\tassert_eq!(block_v2.header.parent_hash, v0_parent_hash);\n\t\tassert_eq!(block_v2.transactions.len() as u64, v0_transaction_len);\n\t\tOk(())\n\t}\n}\n\n#[derive(Eq, PartialEq, Clone, RuntimeDebug)]\npub enum ReturnValue {\n\tBytes(Vec<u8>),\n\tHash(H160),\n}\n\npub struct IntermediateStateRoot<T>(PhantomData<T>);\nimpl<T: Config> Get<H256> for IntermediateStateRoot<T> {\n\tfn get() -> H256 {\n\t\tlet version = T::Version::get().state_version();\n\t\tH256::decode(&mut &sp_io::storage::root(version)[..])\n\t\t\t.expect(\"Node is configured to use the same hash; qed\")\n\t}\n}\n\n/// Returns the Ethereum block hash by number.\npub struct EthereumBlockHashMapping<T>(PhantomData<T>);\nimpl<T: Config> BlockHashMapping for EthereumBlockHashMapping<T> {\n\tfn block_hash(number: u32) -> H256 {\n\t\tBlockHash::<T>::get(U256::from(number))\n\t}\n}\n\n#[repr(u8)]\nenum TransactionValidationError {\n\t#[allow(dead_code)]\n\tUnknownError,\n\tInvalidChainId,\n\tInvalidSignature,\n\tInvalidGasLimit,\n\tMaxFeePerGasTooLow,\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # EVM Pallet\n//!\n//! The EVM pallet allows unmodified EVM code to be executed in a Substrate-based blockchain.\n//! - [`evm::Config`]\n//!\n//! ## EVM Engine\n//!\n//! The EVM pallet uses [`SputnikVM`](https://github.com/rust-blockchain/evm) as the underlying EVM engine.\n//! The engine is overhauled so that it's [`modular`](https://github.com/corepaper/evm).\n//!\n//! ## Execution Lifecycle\n//!\n//! There are a separate set of accounts managed by the EVM pallet. Substrate based accounts can call the EVM Pallet\n//! to deposit or withdraw balance from the Substrate base-currency into a different balance managed and used by\n//! the EVM pallet. Once a user has populated their balance, they can create and call smart contracts using this pallet.\n//!\n//! There's one-to-one mapping from Substrate accounts and EVM external accounts that is defined by a conversion function.\n//!\n//! ## EVM Pallet vs Ethereum Network\n//!\n//! The EVM pallet should be able to produce nearly identical results compared to the Ethereum mainnet,\n//! including gas cost and balance changes.\n//!\n//! Observable differences include:\n//!\n//! - The available length of block hashes may not be 256 depending on the configuration of the System pallet\n//! in the Substrate runtime.\n//! - Difficulty and coinbase, which do not make sense in this pallet and is currently hard coded to zero.\n//!\n//! We currently do not aim to make unobservable behaviors, such as state root, to be the same. We also don't aim to follow\n//! the exact same transaction / receipt format. However, given one Ethereum transaction and one Substrate account's\n//! private key, one should be able to convert any Ethereum transaction into a transaction compatible with this pallet.\n//!\n//! The gas configurations are configurable. Right now, a pre-defined London hard fork configuration option is provided.\n\n// Ensure we're `no_std` when compiling for Wasm.\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(clippy::too_many_arguments)]\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub mod benchmarking;\n\n#[cfg(test)]\nmod mock;\npub mod runner;\n#[cfg(test)]\nmod tests;\n\nuse frame_support::{\n\tdispatch::DispatchResultWithPostInfo,\n\ttraits::{\n\t\ttokens::fungible::Inspect, Currency, ExistenceRequirement, FindAuthor, Get, Imbalance,\n\t\tOnUnbalanced, SignedImbalance, WithdrawReasons,\n\t},\n\tweights::{Pays, PostDispatchInfo, Weight},\n};\nuse frame_system::RawOrigin;\nuse sp_core::{Hasher, H160, H256, U256};\nuse sp_runtime::{\n\ttraits::{BadOrigin, Saturating, UniqueSaturatedInto, Zero},\n\tAccountId32, DispatchErrorWithPostInfo,\n};\nuse sp_std::vec::Vec;\n\npub use evm::{\n\tConfig as EvmConfig, Context, ExitError, ExitFatal, ExitReason, ExitRevert, ExitSucceed,\n};\n#[cfg(feature = \"std\")]\nuse fp_evm::GenesisAccount;\npub use fp_evm::{\n\tAccount, CallInfo, CreateInfo, ExecutionInfo, FeeCalculator, LinearCostPrecompile, Log,\n\tPrecompile, PrecompileFailure, PrecompileHandle, PrecompileOutput, PrecompileResult,\n\tPrecompileSet, Vicinity,\n};\n\npub use self::{\n\tpallet::*,\n\trunner::{Runner, RunnerError},\n};\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\n\t#[pallet::pallet]\n\t#[pallet::generate_store(pub(super) trait Store)]\n\t#[pallet::without_storage_info]\n\tpub struct Pallet<T>(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config + pallet_timestamp::Config {\n\t\t/// Calculator for current gas price.\n\t\ttype FeeCalculator: FeeCalculator;\n\n\t\t/// Maps Ethereum gas to Substrate weight.\n\t\ttype GasWeightMapping: GasWeightMapping;\n\n\t\t/// Block number to block hash.\n\t\ttype BlockHashMapping: BlockHashMapping;\n\n\t\t/// Allow the origin to call on behalf of given address.\n\t\ttype CallOrigin: EnsureAddressOrigin<Self::Origin>;\n\t\t/// Allow the origin to withdraw on behalf of given address.\n\t\ttype WithdrawOrigin: EnsureAddressOrigin<Self::Origin, Success = Self::AccountId>;\n\n\t\t/// Mapping from address to account id.\n\t\ttype AddressMapping: AddressMapping<Self::AccountId>;\n\t\t/// Currency type for withdraw and balance storage.\n\t\ttype Currency: Currency<Self::AccountId> + Inspect<Self::AccountId>;\n\n\t\t/// The overarching event type.\n\t\ttype Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;\n\t\t/// Precompiles associated with this EVM engine.\n\t\ttype PrecompilesType: PrecompileSet;\n\t\ttype PrecompilesValue: Get<Self::PrecompilesType>;\n\t\t/// Chain ID of EVM.\n\t\ttype ChainId: Get<u64>;\n\t\t/// The block gas limit. Can be a simple constant, or an adjustment algorithm in another pallet.\n\t\ttype BlockGasLimit: Get<U256>;\n\t\t/// EVM execution runner.\n\t\ttype Runner: Runner<Self>;\n\n\t\t/// To handle fee deduction for EVM transactions. An example is this pallet being used by `pallet_ethereum`\n\t\t/// where the chain implementing `pallet_ethereum` should be able to configure what happens to the fees\n\t\t/// Similar to `OnChargeTransaction` of `pallet_transaction_payment`\n\t\ttype OnChargeTransaction: OnChargeEVMTransaction<Self>;\n\n\t\t/// Find author for the current block.\n\t\ttype FindAuthor: FindAuthor<H160>;\n\n\t\t/// EVM config used in the module.\n\t\tfn config() -> &'static EvmConfig {\n\t\t\t&LONDON_CONFIG\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t/// Withdraw balance from EVM into currency/balances pallet.\n\t\t#[pallet::weight(0)]\n\t\tpub fn withdraw(\n\t\t\torigin: OriginFor<T>,\n\t\t\taddress: H160,\n\t\t\tvalue: BalanceOf<T>,\n\t\t) -> DispatchResult {\n\t\t\tlet destination = T::WithdrawOrigin::ensure_address_origin(&address, origin)?;\n\t\t\tlet address_account_id = T::AddressMapping::into_account_id(address);\n\n\t\t\tT::Currency::transfer(\n\t\t\t\t&address_account_id,\n\t\t\t\t&destination,\n\t\t\t\tvalue,\n\t\t\t\tExistenceRequirement::AllowDeath,\n\t\t\t)?;\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Issue an EVM call operation. This is similar to a message call transaction in Ethereum.\n\t\t#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]\n\t\tpub fn call(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\ttarget: H160,\n\t\t\tinput: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\n\t\t\tlet is_transactional = true;\n\t\t\tlet info = match T::Runner::call(\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t\tinput,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch info.exit_reason {\n\t\t\t\tExitReason::Succeed(_) => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Executed(target));\n\t\t\t\t}\n\t\t\t\t_ => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::ExecutedFailed(target));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\tinfo.used_gas.unique_saturated_into(),\n\t\t\t\t)),\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\n\t\t/// Issue an EVM create operation. This is similar to a contract creation transaction in\n\t\t/// Ethereum.\n\t\t#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]\n\t\tpub fn create(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\tinit: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\n\t\t\tlet is_transactional = true;\n\t\t\tlet info = match T::Runner::create(\n\t\t\t\tsource,\n\t\t\t\tinit,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch info {\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: ExitReason::Succeed(_),\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Created(create_address));\n\t\t\t\t}\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: _,\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::CreatedFailed(create_address));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\tinfo.used_gas.unique_saturated_into(),\n\t\t\t\t)),\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\n\t\t/// Issue an EVM create2 operation.\n\t\t#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]\n\t\tpub fn create2(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\tinit: Vec<u8>,\n\t\t\tsalt: H256,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\n\t\t\tlet is_transactional = true;\n\t\t\tlet info = match T::Runner::create2(\n\t\t\t\tsource,\n\t\t\t\tinit,\n\t\t\t\tsalt,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch info {\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: ExitReason::Succeed(_),\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Created(create_address));\n\t\t\t\t}\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: _,\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::CreatedFailed(create_address));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\tinfo.used_gas.unique_saturated_into(),\n\t\t\t\t)),\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\t/// Ethereum events from contracts.\n\t\tLog(Log),\n\t\t/// A contract has been created at given \\[address\\].\n\t\tCreated(H160),\n\t\t/// A \\[contract\\] was attempted to be created, but the execution failed.\n\t\tCreatedFailed(H160),\n\t\t/// A \\[contract\\] has been executed successfully with states applied.\n\t\tExecuted(H160),\n\t\t/// A \\[contract\\] has been executed with errors. States are reverted with only gas fees applied.\n\t\tExecutedFailed(H160),\n\t\t/// A deposit has been made at a given address. \\[sender, address, value\\]\n\t\tBalanceDeposit(T::AccountId, H160, U256),\n\t\t/// A withdrawal has been made from a given address. \\[sender, address, value\\]\n\t\tBalanceWithdraw(T::AccountId, H160, U256),\n\t}\n\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\t/// Not enough balance to perform action\n\t\tBalanceLow,\n\t\t/// Calculating total fee overflowed\n\t\tFeeOverflow,\n\t\t/// Calculating total payment overflowed\n\t\tPaymentOverflow,\n\t\t/// Withdraw fee failed\n\t\tWithdrawFailed,\n\t\t/// Gas price is too low.\n\t\tGasPriceTooLow,\n\t\t/// Nonce is invalid\n\t\tInvalidNonce,\n\t}\n\n\t#[pallet::genesis_config]\n\t#[cfg_attr(feature = \"std\", derive(Default))]\n\tpub struct GenesisConfig {\n\t\tpub accounts: std::collections::BTreeMap<H160, GenesisAccount>,\n\t}\n\n\t#[pallet::genesis_build]\n\timpl<T: Config> GenesisBuild<T> for GenesisConfig {\n\t\tfn build(&self) {\n\t\t\tfor (address, account) in &self.accounts {\n\t\t\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\n\t\t\t\t// ASSUME: in one single EVM transaction, the nonce will not increase more than\n\t\t\t\t// `u128::max_value()`.\n\t\t\t\tfor _ in 0..account.nonce.low_u128() {\n\t\t\t\t\tframe_system::Pallet::<T>::inc_account_nonce(&account_id);\n\t\t\t\t}\n\n\t\t\t\tT::Currency::deposit_creating(\n\t\t\t\t\t&account_id,\n\t\t\t\t\taccount.balance.low_u128().unique_saturated_into(),\n\t\t\t\t);\n\n\t\t\t\tPallet::<T>::create_account(*address, account.code.clone());\n\n\t\t\t\tfor (index, value) in &account.storage {\n\t\t\t\t\t<AccountStorages<T>>::insert(address, index, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::storage]\n\t#[pallet::getter(fn account_codes)]\n\tpub type AccountCodes<T: Config> = StorageMap<_, Blake2_128Concat, H160, Vec<u8>, ValueQuery>;\n\n\t#[pallet::storage]\n\t#[pallet::getter(fn account_storages)]\n\tpub type AccountStorages<T: Config> =\n\t\tStorageDoubleMap<_, Blake2_128Concat, H160, Blake2_128Concat, H256, H256, ValueQuery>;\n}\n\n/// Type alias for currency balance.\npub type BalanceOf<T> =\n\t<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;\n\n/// Type alias for negative imbalance during fees\ntype NegativeImbalanceOf<C, T> =\n\t<C as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance;\n\npub trait EnsureAddressOrigin<OuterOrigin> {\n\t/// Success return type.\n\ttype Success;\n\n\t/// Perform the origin check.\n\tfn ensure_address_origin(\n\t\taddress: &H160,\n\t\torigin: OuterOrigin,\n\t) -> Result<Self::Success, BadOrigin> {\n\t\tSelf::try_address_origin(address, origin).map_err(|_| BadOrigin)\n\t}\n\n\t/// Try with origin.\n\tfn try_address_origin(\n\t\taddress: &H160,\n\t\torigin: OuterOrigin,\n\t) -> Result<Self::Success, OuterOrigin>;\n}\n\n/// Ensure that the EVM address is the same as the Substrate address. This only works if the account\n/// ID is `H160`.\npub struct EnsureAddressSame;\n\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressSame\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<H160>, OuterOrigin>> + From<RawOrigin<H160>>,\n{\n\ttype Success = H160;\n\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<H160, OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if &who == address => Ok(who),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\n/// Ensure that the origin is root.\npub struct EnsureAddressRoot<AccountId>(sp_std::marker::PhantomData<AccountId>);\n\nimpl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressRoot<AccountId>\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId>, OuterOrigin>> + From<RawOrigin<AccountId>>,\n{\n\ttype Success = ();\n\n\tfn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<(), OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Root => Ok(()),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\n/// Ensure that the origin never happens.\npub struct EnsureAddressNever<AccountId>(sp_std::marker::PhantomData<AccountId>);\n\nimpl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressNever<AccountId> {\n\ttype Success = AccountId;\n\n\tfn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<AccountId, OuterOrigin> {\n\t\tErr(origin)\n\t}\n}\n\n/// Ensure that the address is truncated hash of the origin. Only works if the account id is\n/// `AccountId32`.\npub struct EnsureAddressTruncated;\n\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressTruncated\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId32>, OuterOrigin>> + From<RawOrigin<AccountId32>>,\n{\n\ttype Success = AccountId32;\n\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<AccountId32, OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if AsRef::<[u8; 32]>::as_ref(&who)[0..20] == address[0..20] => {\n\t\t\t\tOk(who)\n\t\t\t}\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\npub trait AddressMapping<A> {\n\tfn into_account_id(address: H160) -> A;\n}\n\n/// Identity address mapping.\npub struct IdentityAddressMapping;\n\nimpl AddressMapping<H160> for IdentityAddressMapping {\n\tfn into_account_id(address: H160) -> H160 {\n\t\taddress\n\t}\n}\n\n/// Hashed address mapping.\npub struct HashedAddressMapping<H>(sp_std::marker::PhantomData<H>);\n\nimpl<H: Hasher<Out = H256>> AddressMapping<AccountId32> for HashedAddressMapping<H> {\n\tfn into_account_id(address: H160) -> AccountId32 {\n\t\tlet mut data = [0u8; 24];\n\t\tdata[0..4].copy_from_slice(b\"evm:\");\n\t\tdata[4..24].copy_from_slice(&address[..]);\n\t\tlet hash = H::hash(&data);\n\n\t\tAccountId32::from(Into::<[u8; 32]>::into(hash))\n\t}\n}\n\n/// A trait for getting a block hash by number.\npub trait BlockHashMapping {\n\tfn block_hash(number: u32) -> H256;\n}\n\n/// Returns the Substrate block hash by number.\npub struct SubstrateBlockHashMapping<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> BlockHashMapping for SubstrateBlockHashMapping<T> {\n\tfn block_hash(number: u32) -> H256 {\n\t\tlet number = T::BlockNumber::from(number);\n\t\tH256::from_slice(frame_system::Pallet::<T>::block_hash(number).as_ref())\n\t}\n}\n\n/// A mapping function that converts Ethereum gas to Substrate weight\npub trait GasWeightMapping {\n\tfn gas_to_weight(gas: u64) -> Weight;\n\tfn weight_to_gas(weight: Weight) -> u64;\n}\n\nimpl GasWeightMapping for () {\n\tfn gas_to_weight(gas: u64) -> Weight {\n\t\tgas as Weight\n\t}\n\tfn weight_to_gas(weight: Weight) -> u64 {\n\t\tweight as u64\n\t}\n}\n\nstatic LONDON_CONFIG: EvmConfig = EvmConfig::london();\n\nimpl<T: Config> Pallet<T> {\n\t/// Check whether an account is empty.\n\tpub fn is_account_empty(address: &H160) -> bool {\n\t\tlet (account, _) = Self::account_basic(address);\n\t\tlet code_len = <AccountCodes<T>>::decode_len(address).unwrap_or(0);\n\n\t\taccount.nonce == U256::zero() && account.balance == U256::zero() && code_len == 0\n\t}\n\n\t/// Remove an account if its empty.\n\tpub fn remove_account_if_empty(address: &H160) {\n\t\tif Self::is_account_empty(address) {\n\t\t\tSelf::remove_account(address);\n\t\t}\n\t}\n\n\t/// Remove an account.\n\tpub fn remove_account(address: &H160) {\n\t\tif <AccountCodes<T>>::contains_key(address) {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\t\t\tlet _ = frame_system::Pallet::<T>::dec_sufficients(&account_id);\n\t\t}\n\n\t\t<AccountCodes<T>>::remove(address);\n\t\tlet _ = <AccountStorages<T>>::remove_prefix(address, None);\n\t}\n\n\t/// Create an account.\n\tpub fn create_account(address: H160, code: Vec<u8>) {\n\t\tif code.is_empty() {\n\t\t\treturn;\n\t\t}\n\n\t\tif !<AccountCodes<T>>::contains_key(&address) {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(address);\n\t\t\tlet _ = frame_system::Pallet::<T>::inc_sufficients(&account_id);\n\t\t}\n\n\t\t<AccountCodes<T>>::insert(address, code);\n\t}\n\n\t/// Get the account basic in EVM format.\n\tpub fn account_basic(address: &H160) -> (Account, frame_support::weights::Weight) {\n\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\n\t\tlet nonce = frame_system::Pallet::<T>::account_nonce(&account_id);\n\t\t// keepalive `true` takes into account ExistentialDeposit as part of what's considered liquid balance.\n\t\tlet balance = T::Currency::reducible_balance(&account_id, true);\n\n\t\t(\n\t\t\tAccount {\n\t\t\t\tnonce: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(nonce)),\n\t\t\t\tbalance: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(balance)),\n\t\t\t},\n\t\t\tT::DbWeight::get().reads(2),\n\t\t)\n\t}\n\n\t/// Get the author using the FindAuthor trait.\n\tpub fn find_author() -> H160 {\n\t\tlet digest = <frame_system::Pallet<T>>::digest();\n\t\tlet pre_runtime_digests = digest.logs.iter().filter_map(|d| d.as_pre_runtime());\n\n\t\tT::FindAuthor::find_author(pre_runtime_digests).unwrap_or_default()\n\t}\n}\n\n/// Handle withdrawing, refunding and depositing of transaction fees.\n/// Similar to `OnChargeTransaction` of `pallet_transaction_payment`\npub trait OnChargeEVMTransaction<T: Config> {\n\ttype LiquidityInfo: Default;\n\n\t/// Before the transaction is executed the payment of the transaction fees\n\t/// need to be secured.\n\tfn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>>;\n\n\t/// After the transaction was executed the actual fee can be calculated.\n\t/// This function should refund any overpaid fees and optionally deposit\n\t/// the corrected amount, and handles the base fee rationing using the provided\n\t/// `OnUnbalanced` implementation.\n\t/// Returns the `NegativeImbalance` - if any - produced by the priority fee.\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo;\n\n\t/// Introduced in EIP1559 to handle the priority tip.\n\tfn pay_priority_fee(tip: Self::LiquidityInfo);\n}\n\n/// Implements the transaction payment for a pallet implementing the `Currency`\n/// trait (eg. the pallet_balances) using an unbalance handler (implementing\n/// `OnUnbalanced`).\n/// Similar to `CurrencyAdapter` of `pallet_transaction_payment`\npub struct EVMCurrencyAdapter<C, OU>(sp_std::marker::PhantomData<(C, OU)>);\n\nimpl<T, C, OU> OnChargeEVMTransaction<T> for EVMCurrencyAdapter<C, OU>\nwhere\n\tT: Config,\n\tC: Currency<<T as frame_system::Config>::AccountId>,\n\tC::PositiveImbalance: Imbalance<\n\t\t<C as Currency<<T as frame_system::Config>::AccountId>>::Balance,\n\t\tOpposite = C::NegativeImbalance,\n\t>,\n\tC::NegativeImbalance: Imbalance<\n\t\t<C as Currency<<T as frame_system::Config>::AccountId>>::Balance,\n\t\tOpposite = C::PositiveImbalance,\n\t>,\n\tOU: OnUnbalanced<NegativeImbalanceOf<C, T>>,\n{\n\t// Kept type as Option to satisfy bound of Default\n\ttype LiquidityInfo = Option<NegativeImbalanceOf<C, T>>;\n\n\tfn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>> {\n\t\tif fee.is_zero() {\n\t\t\treturn Ok(None);\n\t\t}\n\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\t\tlet imbalance = C::withdraw(\n\t\t\t&account_id,\n\t\t\tfee.low_u128().unique_saturated_into(),\n\t\t\tWithdrawReasons::FEE,\n\t\t\tExistenceRequirement::AllowDeath,\n\t\t)\n\t\t.map_err(|_| Error::<T>::BalanceLow)?;\n\t\tOk(Some(imbalance))\n\t}\n\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo {\n\t\tif let Some(paid) = already_withdrawn {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\n\t\t\t// Calculate how much refund we should return\n\t\t\tlet refund_amount = paid\n\t\t\t\t.peek()\n\t\t\t\t.saturating_sub(corrected_fee.low_u128().unique_saturated_into());\n\t\t\t// refund to the account that paid the fees. If this fails, the\n\t\t\t// account might have dropped below the existential balance. In\n\t\t\t// that case we don't refund anything.\n\t\t\tlet refund_imbalance = C::deposit_into_existing(&account_id, refund_amount)\n\t\t\t\t.unwrap_or_else(|_| C::PositiveImbalance::zero());\n\n\t\t\t// Make sure this works with 0 ExistentialDeposit\n\t\t\t// https://github.com/paritytech/substrate/issues/10117\n\t\t\t// If we tried to refund something, the account still empty and the ED is set to 0,\n\t\t\t// we call `make_free_balance_be` with the refunded amount.\n\t\t\tlet refund_imbalance = if C::minimum_balance().is_zero()\n\t\t\t\t&& refund_amount > C::Balance::zero()\n\t\t\t\t&& C::total_balance(&account_id).is_zero()\n\t\t\t{\n\t\t\t\t// Known bug: Substrate tried to refund to a zeroed AccountData, but\n\t\t\t\t// interpreted the account to not exist.\n\t\t\t\tmatch C::make_free_balance_be(&account_id, refund_amount) {\n\t\t\t\t\tSignedImbalance::Positive(p) => p,\n\t\t\t\t\t_ => C::PositiveImbalance::zero(),\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trefund_imbalance\n\t\t\t};\n\n\t\t\t// merge the imbalance caused by paying the fees and refunding parts of it again.\n\t\t\tlet adjusted_paid = paid\n\t\t\t\t.offset(refund_imbalance)\n\t\t\t\t.same()\n\t\t\t\t.unwrap_or_else(|_| C::NegativeImbalance::zero());\n\n\t\t\tlet (base_fee, tip) = adjusted_paid.split(base_fee.low_u128().unique_saturated_into());\n\t\t\t// Handle base fee. Can be either burned, rationed, etc ...\n\t\t\tOU::on_unbalanced(base_fee);\n\t\t\treturn Some(tip);\n\t\t}\n\t\tNone\n\t}\n\n\tfn pay_priority_fee(tip: Self::LiquidityInfo) {\n\t\t// Default Ethereum behaviour: issue the tip to the block author.\n\t\tif let Some(tip) = tip {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(<Pallet<T>>::find_author());\n\t\t\tlet _ = C::deposit_into_existing(&account_id, tip.peek());\n\t\t}\n\t}\n}\n\n/// Implementation for () does not specify what to do with imbalance\nimpl<T> OnChargeEVMTransaction<T> for ()\n\twhere\n\tT: Config,\n\t<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::PositiveImbalance:\n\t\tImbalance<<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance, Opposite = <T::Currency as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance>,\n\t<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance:\n\t\tImbalance<<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance, Opposite = <T::Currency as Currency<<T as frame_system::Config>::AccountId>>::PositiveImbalance>, {\n\t// Kept type as Option to satisfy bound of Default\n\ttype LiquidityInfo = Option<NegativeImbalanceOf<T::Currency, T>>;\n\n\tfn withdraw_fee(\n\t\twho: &H160,\n\t\tfee: U256,\n\t) -> Result<Self::LiquidityInfo, Error<T>> {\n\t\tEVMCurrencyAdapter::<<T as Config>::Currency, ()>::withdraw_fee(who, fee)\n\t}\n\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo {\n\t\t<EVMCurrencyAdapter::<<T as Config>::Currency, ()> as OnChargeEVMTransaction<T>>::correct_and_deposit_fee(who, corrected_fee, base_fee, already_withdrawn)\n\t}\n\n\tfn pay_priority_fee(tip: Self::LiquidityInfo) {\n\t\t<EVMCurrencyAdapter::<<T as Config>::Currency, ()> as OnChargeEVMTransaction<T>>::pay_priority_fee(tip);\n\t}\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! EVM stack-based runner.\n\nuse crate::{\n\trunner::Runner as RunnerT, AccountCodes, AccountStorages, AddressMapping, BlockHashMapping,\n\tConfig, Error, Event, FeeCalculator, OnChargeEVMTransaction, Pallet, RunnerError,\n};\nuse evm::{\n\tbackend::Backend as BackendT,\n\texecutor::stack::{Accessed, StackExecutor, StackState as StackStateT, StackSubstateMetadata},\n\tExitError, ExitReason, Transfer,\n};\nuse fp_evm::{CallInfo, CreateInfo, ExecutionInfo, Log, Vicinity};\nuse frame_support::{\n\tensure,\n\ttraits::{Currency, ExistenceRequirement, Get},\n};\nuse sha3::{Digest, Keccak256};\nuse sp_core::{H160, H256, U256};\nuse sp_runtime::traits::UniqueSaturatedInto;\nuse sp_std::{boxed::Box, collections::btree_set::BTreeSet, marker::PhantomData, mem, vec::Vec};\n\n#[derive(Default)]\npub struct Runner<T: Config> {\n\t_marker: PhantomData<T>,\n}\n\nimpl<T: Config> Runner<T> {\n\t/// Execute an EVM operation.\n\tpub fn execute<'config, 'precompiles, F, R>(\n\t\tsource: H160,\n\t\tvalue: U256,\n\t\tgas_limit: u64,\n\t\tmax_fee_per_gas: Option<U256>,\n\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\tnonce: Option<U256>,\n\t\tconfig: &'config evm::Config,\n\t\tprecompiles: &'precompiles T::PrecompilesType,\n\t\tis_transactional: bool,\n\t\tf: F,\n\t) -> Result<ExecutionInfo<R>, RunnerError<Error<T>>>\n\twhere\n\t\tF: FnOnce(\n\t\t\t&mut StackExecutor<\n\t\t\t\t'config,\n\t\t\t\t'precompiles,\n\t\t\t\tSubstrateStackState<'_, 'config, T>,\n\t\t\t\tT::PrecompilesType,\n\t\t\t>,\n\t\t) -> (ExitReason, R),\n\t{\n\t\tlet (base_fee, mut weight) = T::FeeCalculator::min_gas_price();\n\t\tlet max_fee_per_gas = match (max_fee_per_gas, is_transactional) {\n\t\t\t(Some(max_fee_per_gas), _) => {\n\t\t\t\tensure!(\n\t\t\t\t\tmax_fee_per_gas >= base_fee,\n\t\t\t\t\tRunnerError {\n\t\t\t\t\t\terror: Error::<T>::GasPriceTooLow,\n\t\t\t\t\t\tweight,\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tmax_fee_per_gas\n\t\t\t}\n\t\t\t// Gas price check is skipped for non-transactional calls that don't\n\t\t\t// define a `max_fee_per_gas` input.\n\t\t\t(None, false) => Default::default(),\n\t\t\t_ => {\n\t\t\t\treturn Err(RunnerError {\n\t\t\t\t\terror: Error::<T>::GasPriceTooLow,\n\t\t\t\t\tweight,\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\n\t\tif let Some(max_priority_fee) = max_priority_fee_per_gas {\n\t\t\tensure!(\n\t\t\t\tmax_fee_per_gas >= max_priority_fee,\n\t\t\t\tRunnerError {\n\t\t\t\t\terror: Error::<T>::GasPriceTooLow,\n\t\t\t\t\tweight,\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t// After eip-1559 we make sure the account can pay both the evm execution and priority fees.\n\t\tlet total_fee = max_fee_per_gas\n\t\t\t.checked_mul(U256::from(gas_limit))\n\t\t\t.ok_or(RunnerError {\n\t\t\t\terror: Error::<T>::FeeOverflow,\n\t\t\t\tweight,\n\t\t\t})?;\n\n\t\tlet total_payment = value.checked_add(total_fee).ok_or(RunnerError {\n\t\t\terror: Error::<T>::PaymentOverflow,\n\t\t\tweight,\n\t\t})?;\n\t\tlet (source_account, inner_weight) = Pallet::<T>::account_basic(&source);\n\t\tweight = weight.saturating_add(inner_weight);\n\t\t// Account balance check is skipped if fee is Zero.\n\t\t// This case is previously verified to only happen on either:\n\t\t// \t- Non-transactional calls.\n\t\t//\t- BaseFee is configured to be Zero.\n\t\tif total_fee > U256::zero() {\n\t\t\tensure!(\n\t\t\t\tsource_account.balance >= total_payment,\n\t\t\t\tRunnerError {\n\t\t\t\t\terror: Error::<T>::BalanceLow,\n\t\t\t\t\tweight,\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif let Some(nonce) = nonce {\n\t\t\tensure!(\n\t\t\t\tsource_account.nonce == nonce,\n\t\t\t\tRunnerError {\n\t\t\t\t\terror: Error::<T>::InvalidNonce,\n\t\t\t\t\tweight,\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t// Deduct fee from the `source` account. Returns `None` if `total_fee` is Zero.\n\t\tlet fee = T::OnChargeTransaction::withdraw_fee(&source, total_fee)\n\t\t\t.map_err(|e| RunnerError { error: e, weight })?;\n\n\t\t// Execute the EVM call.\n\t\tlet vicinity = Vicinity {\n\t\t\tgas_price: base_fee,\n\t\t\torigin: source,\n\t\t};\n\n\t\tlet metadata = StackSubstateMetadata::new(gas_limit, config);\n\t\tlet state = SubstrateStackState::new(&vicinity, metadata);\n\t\tlet mut executor = StackExecutor::new_with_precompiles(state, config, precompiles);\n\n\t\tlet (reason, retv) = f(&mut executor);\n\n\t\t// Post execution.\n\t\tlet used_gas = U256::from(executor.used_gas());\n\t\tlet actual_fee = if let Some(max_priority_fee) = max_priority_fee_per_gas {\n\t\t\tlet actual_priority_fee = max_fee_per_gas\n\t\t\t\t.saturating_sub(base_fee)\n\t\t\t\t.min(max_priority_fee)\n\t\t\t\t.saturating_mul(used_gas);\n\t\t\texecutor\n\t\t\t\t.fee(base_fee)\n\t\t\t\t.checked_add(actual_priority_fee)\n\t\t\t\t.unwrap_or_else(U256::max_value)\n\t\t} else {\n\t\t\texecutor.fee(base_fee)\n\t\t};\n\t\tlog::debug!(\n\t\t\ttarget: \"evm\",\n\t\t\t\"Execution {:?} [source: {:?}, value: {}, gas_limit: {}, actual_fee: {}, is_transactional: {}]\",\n\t\t\treason,\n\t\t\tsource,\n\t\t\tvalue,\n\t\t\tgas_limit,\n\t\t\tactual_fee,\n\t\t\tis_transactional\n\t\t);\n\t\t// The difference between initially withdrawn and the actual cost is refunded.\n\t\t//\n\t\t// Considered the following request:\n\t\t// +-----------+---------+--------------+\n\t\t// | Gas_limit | Max_Fee | Max_Priority |\n\t\t// +-----------+---------+--------------+\n\t\t// |        20 |      10 |            6 |\n\t\t// +-----------+---------+--------------+\n\t\t//\n\t\t// And execution:\n\t\t// +----------+----------+\n\t\t// | Gas_used | Base_Fee |\n\t\t// +----------+----------+\n\t\t// |        5 |        2 |\n\t\t// +----------+----------+\n\t\t//\n\t\t// Initially withdrawn 10 * 20 = 200.\n\t\t// Actual cost (2 + 6) * 5 = 40.\n\t\t// Refunded 200 - 40 = 160.\n\t\t// Tip 5 * 6 = 30.\n\t\t// Burned 200 - (160 + 30) = 10. Which is equivalent to gas_used * base_fee.\n\t\tlet actual_priority_fee = T::OnChargeTransaction::correct_and_deposit_fee(\n\t\t\t&source,\n\t\t\t// Actual fee after evm execution, including tip.\n\t\t\tactual_fee,\n\t\t\t// Base fee.\n\t\t\texecutor.fee(base_fee),\n\t\t\t// Fee initially withdrawn.\n\t\t\tfee,\n\t\t);\n\t\tT::OnChargeTransaction::pay_priority_fee(actual_priority_fee);\n\n\t\tlet state = executor.into_state();\n\n\t\tfor address in state.substate.deletes {\n\t\t\tlog::debug!(\n\t\t\t\ttarget: \"evm\",\n\t\t\t\t\"Deleting account at {:?}\",\n\t\t\t\taddress\n\t\t\t);\n\t\t\tPallet::<T>::remove_account(&address)\n\t\t}\n\n\t\tfor log in &state.substate.logs {\n\t\t\tlog::trace!(\n\t\t\t\ttarget: \"evm\",\n\t\t\t\t\"Inserting log for {:?}, topics ({}) {:?}, data ({}): {:?}]\",\n\t\t\t\tlog.address,\n\t\t\t\tlog.topics.len(),\n\t\t\t\tlog.topics,\n\t\t\t\tlog.data.len(),\n\t\t\t\tlog.data\n\t\t\t);\n\t\t\tPallet::<T>::deposit_event(Event::<T>::Log(Log {\n\t\t\t\taddress: log.address,\n\t\t\t\ttopics: log.topics.clone(),\n\t\t\t\tdata: log.data.clone(),\n\t\t\t}));\n\t\t}\n\n\t\tOk(ExecutionInfo {\n\t\t\tvalue: retv,\n\t\t\texit_reason: reason,\n\t\t\tused_gas,\n\t\t\tlogs: state.substate.logs,\n\t\t})\n\t}\n}\n\nimpl<T: Config> RunnerT<T> for Runner<T> {\n\ttype Error = Error<T>;\n\n\tfn call(\n\t\tsource: H160,\n\t\ttarget: H160,\n\t\tinput: Vec<u8>,\n\t\tvalue: U256,\n\t\tgas_limit: u64,\n\t\tmax_fee_per_gas: Option<U256>,\n\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\tnonce: Option<U256>,\n\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\tis_transactional: bool,\n\t\tconfig: &evm::Config,\n\t) -> Result<CallInfo, RunnerError<Self::Error>> {\n\t\tlet precompiles = T::PrecompilesValue::get();\n\t\tSelf::execute(\n\t\t\tsource,\n\t\t\tvalue,\n\t\t\tgas_limit,\n\t\t\tmax_fee_per_gas,\n\t\t\tmax_priority_fee_per_gas,\n\t\t\tnonce,\n\t\t\tconfig,\n\t\t\t&precompiles,\n\t\t\tis_transactional,\n\t\t\t|executor| executor.transact_call(source, target, value, input, gas_limit, access_list),\n\t\t)\n\t}\n\n\tfn create(\n\t\tsource: H160,\n\t\tinit: Vec<u8>,\n\t\tvalue: U256,\n\t\tgas_limit: u64,\n\t\tmax_fee_per_gas: Option<U256>,\n\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\tnonce: Option<U256>,\n\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\tis_transactional: bool,\n\t\tconfig: &evm::Config,\n\t) -> Result<CreateInfo, RunnerError<Self::Error>> {\n\t\tlet precompiles = T::PrecompilesValue::get();\n\t\tSelf::execute(\n\t\t\tsource,\n\t\t\tvalue,\n\t\t\tgas_limit,\n\t\t\tmax_fee_per_gas,\n\t\t\tmax_priority_fee_per_gas,\n\t\t\tnonce,\n\t\t\tconfig,\n\t\t\t&precompiles,\n\t\t\tis_transactional,\n\t\t\t|executor| {\n\t\t\t\tlet address = executor.create_address(evm::CreateScheme::Legacy { caller: source });\n\t\t\t\tlet (reason, _) =\n\t\t\t\t\texecutor.transact_create(source, value, init, gas_limit, access_list);\n\t\t\t\t(reason, address)\n\t\t\t},\n\t\t)\n\t}\n\n\tfn create2(\n\t\tsource: H160,\n\t\tinit: Vec<u8>,\n\t\tsalt: H256,\n\t\tvalue: U256,\n\t\tgas_limit: u64,\n\t\tmax_fee_per_gas: Option<U256>,\n\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\tnonce: Option<U256>,\n\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\tis_transactional: bool,\n\t\tconfig: &evm::Config,\n\t) -> Result<CreateInfo, RunnerError<Self::Error>> {\n\t\tlet precompiles = T::PrecompilesValue::get();\n\t\tlet code_hash = H256::from_slice(Keccak256::digest(&init).as_slice());\n\t\tSelf::execute(\n\t\t\tsource,\n\t\t\tvalue,\n\t\t\tgas_limit,\n\t\t\tmax_fee_per_gas,\n\t\t\tmax_priority_fee_per_gas,\n\t\t\tnonce,\n\t\t\tconfig,\n\t\t\t&precompiles,\n\t\t\tis_transactional,\n\t\t\t|executor| {\n\t\t\t\tlet address = executor.create_address(evm::CreateScheme::Create2 {\n\t\t\t\t\tcaller: source,\n\t\t\t\t\tcode_hash,\n\t\t\t\t\tsalt,\n\t\t\t\t});\n\t\t\t\tlet (reason, _) =\n\t\t\t\t\texecutor.transact_create2(source, value, init, salt, gas_limit, access_list);\n\t\t\t\t(reason, address)\n\t\t\t},\n\t\t)\n\t}\n}\n\nstruct SubstrateStackSubstate<'config> {\n\tmetadata: StackSubstateMetadata<'config>,\n\tdeletes: BTreeSet<H160>,\n\tlogs: Vec<Log>,\n\tparent: Option<Box<SubstrateStackSubstate<'config>>>,\n}\n\nimpl<'config> SubstrateStackSubstate<'config> {\n\tpub fn metadata(&self) -> &StackSubstateMetadata<'config> {\n\t\t&self.metadata\n\t}\n\n\tpub fn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {\n\t\t&mut self.metadata\n\t}\n\n\tpub fn enter(&mut self, gas_limit: u64, is_static: bool) {\n\t\tlet mut entering = Self {\n\t\t\tmetadata: self.metadata.spit_child(gas_limit, is_static),\n\t\t\tparent: None,\n\t\t\tdeletes: BTreeSet::new(),\n\t\t\tlogs: Vec::new(),\n\t\t};\n\t\tmem::swap(&mut entering, self);\n\n\t\tself.parent = Some(Box::new(entering));\n\n\t\tsp_io::storage::start_transaction();\n\t}\n\n\tpub fn exit_commit(&mut self) -> Result<(), ExitError> {\n\t\tlet mut exited = *self.parent.take().expect(\"Cannot commit on root substate\");\n\t\tmem::swap(&mut exited, self);\n\n\t\tself.metadata.swallow_commit(exited.metadata)?;\n\t\tself.logs.append(&mut exited.logs);\n\t\tself.deletes.append(&mut exited.deletes);\n\n\t\tsp_io::storage::commit_transaction();\n\t\tOk(())\n\t}\n\n\tpub fn exit_revert(&mut self) -> Result<(), ExitError> {\n\t\tlet mut exited = *self.parent.take().expect(\"Cannot discard on root substate\");\n\t\tmem::swap(&mut exited, self);\n\t\tself.metadata.swallow_revert(exited.metadata)?;\n\n\t\tsp_io::storage::rollback_transaction();\n\t\tOk(())\n\t}\n\n\tpub fn exit_discard(&mut self) -> Result<(), ExitError> {\n\t\tlet mut exited = *self.parent.take().expect(\"Cannot discard on root substate\");\n\t\tmem::swap(&mut exited, self);\n\t\tself.metadata.swallow_discard(exited.metadata)?;\n\n\t\tsp_io::storage::rollback_transaction();\n\t\tOk(())\n\t}\n\n\tpub fn deleted(&self, address: H160) -> bool {\n\t\tif self.deletes.contains(&address) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif let Some(parent) = self.parent.as_ref() {\n\t\t\treturn parent.deleted(address);\n\t\t}\n\n\t\tfalse\n\t}\n\n\tpub fn set_deleted(&mut self, address: H160) {\n\t\tself.deletes.insert(address);\n\t}\n\n\tpub fn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {\n\t\tself.logs.push(Log {\n\t\t\taddress,\n\t\t\ttopics,\n\t\t\tdata,\n\t\t});\n\t}\n\n\tfn recursive_is_cold<F: Fn(&Accessed) -> bool>(&self, f: &F) -> bool {\n\t\tlet local_is_accessed = self.metadata.accessed().as_ref().map(f).unwrap_or(false);\n\t\tif local_is_accessed {\n\t\t\tfalse\n\t\t} else {\n\t\t\tself.parent\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|p| p.recursive_is_cold(f))\n\t\t\t\t.unwrap_or(true)\n\t\t}\n\t}\n}\n\n/// Substrate backend for EVM.\npub struct SubstrateStackState<'vicinity, 'config, T> {\n\tvicinity: &'vicinity Vicinity,\n\tsubstate: SubstrateStackSubstate<'config>,\n\t_marker: PhantomData<T>,\n}\n\nimpl<'vicinity, 'config, T: Config> SubstrateStackState<'vicinity, 'config, T> {\n\t/// Create a new backend with given vicinity.\n\tpub fn new(vicinity: &'vicinity Vicinity, metadata: StackSubstateMetadata<'config>) -> Self {\n\t\tSelf {\n\t\t\tvicinity,\n\t\t\tsubstate: SubstrateStackSubstate {\n\t\t\t\tmetadata,\n\t\t\t\tdeletes: BTreeSet::new(),\n\t\t\t\tlogs: Vec::new(),\n\t\t\t\tparent: None,\n\t\t\t},\n\t\t\t_marker: PhantomData,\n\t\t}\n\t}\n}\n\nimpl<'vicinity, 'config, T: Config> BackendT for SubstrateStackState<'vicinity, 'config, T> {\n\tfn gas_price(&self) -> U256 {\n\t\tself.vicinity.gas_price\n\t}\n\tfn origin(&self) -> H160 {\n\t\tself.vicinity.origin\n\t}\n\n\tfn block_hash(&self, number: U256) -> H256 {\n\t\tif number > U256::from(u32::max_value()) {\n\t\t\tH256::default()\n\t\t} else {\n\t\t\tT::BlockHashMapping::block_hash(number.as_u32())\n\t\t}\n\t}\n\n\tfn block_number(&self) -> U256 {\n\t\tlet number: u128 = frame_system::Pallet::<T>::block_number().unique_saturated_into();\n\t\tU256::from(number)\n\t}\n\n\tfn block_coinbase(&self) -> H160 {\n\t\tPallet::<T>::find_author()\n\t}\n\n\tfn block_timestamp(&self) -> U256 {\n\t\tlet now: u128 = pallet_timestamp::Pallet::<T>::get().unique_saturated_into();\n\t\tU256::from(now / 1000)\n\t}\n\n\tfn block_difficulty(&self) -> U256 {\n\t\tU256::zero()\n\t}\n\n\tfn block_gas_limit(&self) -> U256 {\n\t\tT::BlockGasLimit::get()\n\t}\n\n\tfn chain_id(&self) -> U256 {\n\t\tU256::from(T::ChainId::get())\n\t}\n\n\tfn exists(&self, _address: H160) -> bool {\n\t\ttrue\n\t}\n\n\tfn basic(&self, address: H160) -> evm::backend::Basic {\n\t\tlet (account, _) = Pallet::<T>::account_basic(&address);\n\n\t\tevm::backend::Basic {\n\t\t\tbalance: account.balance,\n\t\t\tnonce: account.nonce,\n\t\t}\n\t}\n\n\tfn code(&self, address: H160) -> Vec<u8> {\n\t\t<AccountCodes<T>>::get(&address)\n\t}\n\n\tfn storage(&self, address: H160, index: H256) -> H256 {\n\t\t<AccountStorages<T>>::get(address, index)\n\t}\n\n\tfn original_storage(&self, _address: H160, _index: H256) -> Option<H256> {\n\t\tNone\n\t}\n\n\tfn block_base_fee_per_gas(&self) -> sp_core::U256 {\n\t\tlet (base_fee, _) = T::FeeCalculator::min_gas_price();\n\t\tbase_fee\n\t}\n}\n\nimpl<'vicinity, 'config, T: Config> StackStateT<'config>\n\tfor SubstrateStackState<'vicinity, 'config, T>\n{\n\tfn metadata(&self) -> &StackSubstateMetadata<'config> {\n\t\tself.substate.metadata()\n\t}\n\n\tfn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {\n\t\tself.substate.metadata_mut()\n\t}\n\n\tfn enter(&mut self, gas_limit: u64, is_static: bool) {\n\t\tself.substate.enter(gas_limit, is_static)\n\t}\n\n\tfn exit_commit(&mut self) -> Result<(), ExitError> {\n\t\tself.substate.exit_commit()\n\t}\n\n\tfn exit_revert(&mut self) -> Result<(), ExitError> {\n\t\tself.substate.exit_revert()\n\t}\n\n\tfn exit_discard(&mut self) -> Result<(), ExitError> {\n\t\tself.substate.exit_discard()\n\t}\n\n\tfn is_empty(&self, address: H160) -> bool {\n\t\tPallet::<T>::is_account_empty(&address)\n\t}\n\n\tfn deleted(&self, address: H160) -> bool {\n\t\tself.substate.deleted(address)\n\t}\n\n\tfn inc_nonce(&mut self, address: H160) {\n\t\tlet account_id = T::AddressMapping::into_account_id(address);\n\t\tframe_system::Pallet::<T>::inc_account_nonce(&account_id);\n\t}\n\n\tfn set_storage(&mut self, address: H160, index: H256, value: H256) {\n\t\tif value == H256::default() {\n\t\t\tlog::debug!(\n\t\t\t\ttarget: \"evm\",\n\t\t\t\t\"Removing storage for {:?} [index: {:?}]\",\n\t\t\t\taddress,\n\t\t\t\tindex,\n\t\t\t);\n\t\t\t<AccountStorages<T>>::remove(address, index);\n\t\t} else {\n\t\t\tlog::debug!(\n\t\t\t\ttarget: \"evm\",\n\t\t\t\t\"Updating storage for {:?} [index: {:?}, value: {:?}]\",\n\t\t\t\taddress,\n\t\t\t\tindex,\n\t\t\t\tvalue,\n\t\t\t);\n\t\t\t<AccountStorages<T>>::insert(address, index, value);\n\t\t}\n\t}\n\n\tfn reset_storage(&mut self, address: H160) {\n\t\tlet _ = <AccountStorages<T>>::remove_prefix(address, None);\n\t}\n\n\tfn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {\n\t\tself.substate.log(address, topics, data)\n\t}\n\n\tfn set_deleted(&mut self, address: H160) {\n\t\tself.substate.set_deleted(address)\n\t}\n\n\tfn set_code(&mut self, address: H160, code: Vec<u8>) {\n\t\tlog::debug!(\n\t\t\ttarget: \"evm\",\n\t\t\t\"Inserting code ({} bytes) at {:?}\",\n\t\t\tcode.len(),\n\t\t\taddress\n\t\t);\n\t\tPallet::<T>::create_account(address, code);\n\t}\n\n\tfn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError> {\n\t\tlet source = T::AddressMapping::into_account_id(transfer.source);\n\t\tlet target = T::AddressMapping::into_account_id(transfer.target);\n\n\t\tT::Currency::transfer(\n\t\t\t&source,\n\t\t\t&target,\n\t\t\ttransfer.value.low_u128().unique_saturated_into(),\n\t\t\tExistenceRequirement::AllowDeath,\n\t\t)\n\t\t.map_err(|_| ExitError::OutOfFund)\n\t}\n\n\tfn reset_balance(&mut self, _address: H160) {\n\t\t// Do nothing on reset balance in Substrate.\n\t\t//\n\t\t// This function exists in EVM because a design issue\n\t\t// (arguably a bug) in SELFDESTRUCT that can cause total\n\t\t// issurance to be reduced. We do not need to replicate this.\n\t}\n\n\tfn touch(&mut self, _address: H160) {\n\t\t// Do nothing on touch in Substrate.\n\t\t//\n\t\t// EVM pallet considers all accounts to exist, and distinguish\n\t\t// only empty and non-empty accounts. This avoids many of the\n\t\t// subtle issues in EIP-161.\n\t}\n\n\tfn is_cold(&self, address: H160) -> bool {\n\t\tself.substate\n\t\t\t.recursive_is_cold(&|a| a.accessed_addresses.contains(&address))\n\t}\n\n\tfn is_storage_cold(&self, address: H160, key: H256) -> bool {\n\t\tself.substate\n\t\t\t.recursive_is_cold(&|a: &Accessed| a.accessed_storage.contains(&(address, key)))\n\t}\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![cfg(test)]\n\nuse super::*;\nuse crate::mock::*;\n\nuse frame_support::{\n\tassert_ok,\n\ttraits::{GenesisBuild, LockIdentifier, LockableCurrency, WithdrawReasons},\n};\nuse std::{collections::BTreeMap, str::FromStr};\n\ntype Balances = pallet_balances::Pallet<Test>;\ntype EVM = Pallet<Test>;\n\npub fn new_test_ext() -> sp_io::TestExternalities {\n\tlet mut t = frame_system::GenesisConfig::default()\n\t\t.build_storage::<Test>()\n\t\t.unwrap();\n\n\tlet mut accounts = BTreeMap::new();\n\taccounts.insert(\n\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\tGenesisAccount {\n\t\t\tnonce: U256::from(1),\n\t\t\tbalance: U256::from(1000000),\n\t\t\tstorage: Default::default(),\n\t\t\tcode: vec![\n\t\t\t\t0x00, // STOP\n\t\t\t],\n\t\t},\n\t);\n\taccounts.insert(\n\t\tH160::from_str(\"1000000000000000000000000000000000000002\").unwrap(),\n\t\tGenesisAccount {\n\t\t\tnonce: U256::from(1),\n\t\t\tbalance: U256::from(1000000),\n\t\t\tstorage: Default::default(),\n\t\t\tcode: vec![\n\t\t\t\t0xff, // INVALID\n\t\t\t],\n\t\t},\n\t);\n\taccounts.insert(\n\t\tH160::default(), // root\n\t\tGenesisAccount {\n\t\t\tnonce: U256::from(1),\n\t\t\tbalance: U256::max_value(),\n\t\t\tstorage: Default::default(),\n\t\t\tcode: vec![],\n\t\t},\n\t);\n\n\tpallet_balances::GenesisConfig::<Test> {\n\t\t// Create the block author account with some balance.\n\t\tbalances: vec![(\n\t\t\tH160::from_str(\"0x1234500000000000000000000000000000000000\").unwrap(),\n\t\t\t12345,\n\t\t)],\n\t}\n\t.assimilate_storage(&mut t)\n\t.expect(\"Pallet balances storage can be assimilated\");\n\tGenesisBuild::<Test>::assimilate_storage(&crate::GenesisConfig { accounts }, &mut t).unwrap();\n\tt.into()\n}\n\n#[test]\nfn fail_call_return_ok() {\n\tnew_test_ext().execute_with(|| {\n\t\tassert_ok!(EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::default(),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t));\n\n\t\tassert_ok!(EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000002\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::default(),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t));\n\t});\n}\n\n#[test]\nfn fee_deduction() {\n\tnew_test_ext().execute_with(|| {\n\t\t// Create an EVM address and the corresponding Substrate address that will be charged fees and refunded\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000003\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\n\t\t// Seed account\n\t\tlet _ = <Test as Config>::Currency::deposit_creating(&substrate_addr, 100);\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 100);\n\n\t\t// Deduct fees as 10 units\n\t\tlet imbalance = <<Test as Config>::OnChargeTransaction as OnChargeEVMTransaction<Test>>::withdraw_fee(&evm_addr, U256::from(10)).unwrap();\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 90);\n\n\t\t// Refund fees as 5 units\n\t\t<<Test as Config>::OnChargeTransaction as OnChargeEVMTransaction<Test>>::correct_and_deposit_fee(&evm_addr, U256::from(5), U256::from(5), imbalance);\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 95);\n\t});\n}\n\n#[test]\nfn ed_0_refund_patch_works() {\n\tnew_test_ext().execute_with(|| {\n\t\t// Verifies that the OnChargeEVMTransaction patch is applied and fixes a known bug in Substrate for evm transactions.\n\t\t// https://github.com/paritytech/substrate/issues/10117\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000003\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\n\t\tlet _ = <Test as Config>::Currency::deposit_creating(&substrate_addr, 21_777_000_000_000);\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 21_777_000_000_000);\n\n\t\tlet _ = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tevm_addr,\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1_000_000_000),\n\t\t\t21776,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tNone,\n\t\t\tSome(U256::from(0)),\n\t\t\tVec::new(),\n\t\t);\n\t\t// All that was due, was refunded.\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 776_000_000_000);\n\t});\n}\n\n#[test]\nfn ed_0_refund_patch_is_required() {\n\tnew_test_ext().execute_with(|| {\n\t\t// This test proves that the patch is required, verifying that the current Substrate behaviour is incorrect\n\t\t// for ED 0 configured chains.\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000003\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\n\t\tlet _ = <Test as Config>::Currency::deposit_creating(&substrate_addr, 100);\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 100);\n\n\t\t// Drain funds\n\t\tlet _ =\n\t\t\t<<Test as Config>::OnChargeTransaction as OnChargeEVMTransaction<Test>>::withdraw_fee(\n\t\t\t\t&evm_addr,\n\t\t\t\tU256::from(100),\n\t\t\t)\n\t\t\t.unwrap();\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 0);\n\n\t\t// Try to refund. With ED 0, although the balance is now 0, the account still exists.\n\t\t// So its expected that calling `deposit_into_existing` results in the AccountData to increase the Balance.\n\t\t//\n\t\t// Is not the case, and this proves that the refund logic needs to be handled taking this into account.\n\t\tassert_eq!(\n\t\t\t<Test as Config>::Currency::deposit_into_existing(&substrate_addr, 5u32.into())\n\t\t\t\t.is_err(),\n\t\t\ttrue\n\t\t);\n\t\t// Balance didn't change, and should be 5.\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 0);\n\t});\n}\n\n#[test]\nfn find_author() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tassert_eq!(\n\t\t\tauthor,\n\t\t\tH160::from_str(\"1234500000000000000000000000000000000000\").unwrap()\n\t\t);\n\t});\n}\n\n#[test]\nfn reducible_balance() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000001\").unwrap();\n\t\tlet account_id = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\t\tlet existential = ExistentialDeposit::get();\n\n\t\t// Genesis Balance.\n\t\tlet genesis_balance = EVM::account_basic(&evm_addr).0.balance;\n\n\t\t// Lock identifier.\n\t\tlet lock_id: LockIdentifier = *b\"te/stlok\";\n\t\t// Reserve some funds.\n\t\tlet to_lock = 1000;\n\t\tBalances::set_lock(lock_id, &account_id, to_lock, WithdrawReasons::RESERVE);\n\t\t// Reducible is, as currently configured in `account_basic`, (balance - lock - existential).\n\t\tlet reducible_balance = EVM::account_basic(&evm_addr).0.balance;\n\t\tassert_eq!(reducible_balance, (genesis_balance - to_lock - existential));\n\t});\n}\n\n#[test]\nfn author_should_get_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet result = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tSome(U256::from(1)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tresult.expect(\"EVM can be called\");\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, (before_tip + 21000));\n\t});\n}\n\n#[test]\nfn issuance_after_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet before_tip = <Test as Config>::Currency::total_issuance();\n\t\tlet result = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tSome(U256::from(1)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tresult.expect(\"EVM can be called\");\n\t\tlet after_tip = <Test as Config>::Currency::total_issuance();\n\t\t// Only base fee is burned\n\t\tlet (base_fee, _) = <Test as Config>::FeeCalculator::min_gas_price();\n\t\tassert_eq!(after_tip, (before_tip - (base_fee.low_u64() * 21_000)));\n\t});\n}\n\n#[test]\nfn author_same_balance_without_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet _ = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::default(),\n\t\t\t1000000,\n\t\t\tU256::default(),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, before_tip);\n\t});\n}\n\n#[test]\nfn refunds_should_work() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet before_call = EVM::account_basic(&H160::default()).0.balance;\n\t\t// Gas price is not part of the actual fee calculations anymore, only the base fee.\n\t\t//\n\t\t// Because we first deduct max_fee_per_gas * gas_limit (2_000_000_000 * 1000000) we need\n\t\t// to ensure that the difference (max fee VS base fee) is refunded.\n\t\tlet _ = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet (base_fee, _) = <Test as Config>::FeeCalculator::min_gas_price();\n\t\tlet total_cost = (U256::from(21_000) * base_fee) + U256::from(1);\n\t\tlet after_call = EVM::account_basic(&H160::default()).0.balance;\n\t\tassert_eq!(after_call, before_call - total_cost);\n\t});\n}\n\n#[test]\nfn refunds_and_priority_should_work() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet before_call = EVM::account_basic(&H160::default()).0.balance;\n\t\t// We deliberately set a base fee + max tip > max fee.\n\t\t// The effective priority tip will be 1GWEI instead 1.5GWEI:\n\t\t// \t\t(max_fee_per_gas - base_fee).min(max_priority_fee)\n\t\t//\t\t(2 - 1).min(1.5)\n\t\tlet tip = U256::from(1_500_000_000);\n\t\tlet max_fee_per_gas = U256::from(2_000_000_000);\n\t\tlet used_gas = U256::from(21_000);\n\t\tlet _ = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tmax_fee_per_gas,\n\t\t\tSome(tip),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet (base_fee, _) = <Test as Config>::FeeCalculator::min_gas_price();\n\t\tlet actual_tip = (max_fee_per_gas - base_fee).min(tip) * used_gas;\n\t\tlet total_cost = (used_gas * base_fee) + U256::from(actual_tip) + U256::from(1);\n\t\tlet after_call = EVM::account_basic(&H160::default()).0.balance;\n\t\t// The tip is deducted but never refunded to the caller.\n\t\tassert_eq!(after_call, before_call - total_cost);\n\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, (before_tip + actual_tip.low_u128()));\n\t});\n}\n\n#[test]\nfn call_should_fail_with_priority_greater_than_max_fee() {\n\tnew_test_ext().execute_with(|| {\n\t\t// Max priority greater than max fee should fail.\n\t\tlet tip: u128 = 1_100_000_000;\n\t\tlet result = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tSome(U256::from(tip)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tassert!(result.is_err());\n\t\t// Some used weight is returned as part of the error.\n\t\tassert_eq!(result.unwrap_err().post_info.actual_weight, Some(7));\n\t});\n}\n\n#[test]\nfn call_should_succeed_with_priority_equal_to_max_fee() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet tip: u128 = 1_000_000_000;\n\t\t// Mimics the input for pre-eip-1559 transaction types where `gas_price`\n\t\t// is used for both `max_fee_per_gas` and `max_priority_fee_per_gas`.\n\t\tlet result = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tSome(U256::from(tip)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tassert!(result.is_ok());\n\t});\n}\n\n#[test]\nfn handle_sufficient_reference() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet addr = H160::from_str(\"1230000000000000000000000000000000000001\").unwrap();\n\t\tlet addr_2 = H160::from_str(\"1234000000000000000000000000000000000001\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(addr);\n\t\tlet substrate_addr_2 = <Test as Config>::AddressMapping::into_account_id(addr_2);\n\n\t\t// Sufficients should increase when creating EVM accounts.\n\t\tlet _ = <crate::AccountCodes<Test>>::insert(addr, &vec![0]);\n\t\tlet account = frame_system::Account::<Test>::get(substrate_addr);\n\t\t// Using storage is not correct as it leads to a sufficient reference mismatch.\n\t\tassert_eq!(account.sufficients, 0);\n\n\t\t// Using the create / remove account functions is the correct way to handle it.\n\t\tEVM::create_account(addr_2, vec![1, 2, 3]);\n\t\tlet account_2 = frame_system::Account::<Test>::get(substrate_addr_2);\n\t\t// We increased the sufficient reference by 1.\n\t\tassert_eq!(account_2.sufficients, 1);\n\t\tEVM::remove_account(&addr_2);\n\t\tlet account_2 = frame_system::Account::<Test>::get(substrate_addr_2);\n\t\t// We decreased the sufficient reference by 1 on removing the account.\n\t\tassert_eq!(account_2.sufficients, 0);\n\t});\n}\n\n#[test]\nfn runner_non_transactional_calls_with_non_balance_accounts_is_ok_without_gas_price() {\n\t// Expect to skip checks for gas price and account balance when both:\n\t//\t- The call is non transactional (`is_transactional == false`).\n\t//\t- The `max_fee_per_gas` is None.\n\tnew_test_ext().execute_with(|| {\n\t\tlet non_balance_account =\n\t\t\tH160::from_str(\"7700000000000000000000000000000000000001\").unwrap();\n\t\tassert_eq!(\n\t\t\tEVM::account_basic(&non_balance_account).0.balance,\n\t\t\tU256::zero()\n\t\t);\n\t\tlet _ = <Test as Config>::Runner::call(\n\t\t\tnon_balance_account,\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t)\n\t\t.expect(\"Non transactional call succeeds\");\n\t\tassert_eq!(\n\t\t\tEVM::account_basic(&non_balance_account).0.balance,\n\t\t\tU256::zero()\n\t\t);\n\t});\n}\n\n#[test]\nfn runner_non_transactional_calls_with_non_balance_accounts_is_err_with_gas_price() {\n\t// In non transactional calls where `Some(gas_price)` is defined, expect it to be\n\t// checked against the `BaseFee`, and expect the account to have enough balance\n\t// to pay for the call.\n\tnew_test_ext().execute_with(|| {\n\t\tlet non_balance_account =\n\t\t\tH160::from_str(\"7700000000000000000000000000000000000001\").unwrap();\n\t\tassert_eq!(\n\t\t\tEVM::account_basic(&non_balance_account).0.balance,\n\t\t\tU256::zero()\n\t\t);\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tnon_balance_account,\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tSome(U256::from(1_000_000_000)),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t});\n}\n\n#[test]\nfn runner_transactional_call_with_zero_gas_price_fails() {\n\t// Transactional calls are rejected when `max_fee_per_gas == None`.\n\tnew_test_ext().execute_with(|| {\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t});\n}\n\n#[test]\nfn runner_max_fee_per_gas_gte_max_priority_fee_per_gas() {\n\t// Transactional and non transactional calls enforce `max_fee_per_gas >= max_priority_fee_per_gas`.\n\tnew_test_ext().execute_with(|| {\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tSome(U256::from(1_000_000_000)),\n\t\t\tSome(U256::from(2_000_000_000)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tSome(U256::from(1_000_000_000)),\n\t\t\tSome(U256::from(2_000_000_000)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t});\n}\n", "//! The Substrate Node Template runtime. This can be compiled with `#[no_std]`, ready for Wasm.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit = \"256\"]\n#![allow(clippy::new_without_default, clippy::or_fun_call)]\n\n// Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n\nuse codec::{Decode, Encode};\nuse pallet_evm::FeeCalculator;\nuse pallet_grandpa::{\n\tfg_primitives, AuthorityId as GrandpaId, AuthorityList as GrandpaAuthorityList,\n};\nuse sp_api::impl_runtime_apis;\nuse sp_consensus_aura::sr25519::AuthorityId as AuraId;\nuse sp_core::{\n\tcrypto::{ByteArray, KeyTypeId},\n\tOpaqueMetadata, H160, H256, U256,\n};\nuse sp_runtime::{\n\tcreate_runtime_str, generic, impl_opaque_keys,\n\ttraits::{\n\t\tAccountIdLookup, BlakeTwo256, Block as BlockT, DispatchInfoOf, Dispatchable,\n\t\tIdentifyAccount, NumberFor, PostDispatchInfoOf, Verify,\n\t},\n\ttransaction_validity::{TransactionSource, TransactionValidity, TransactionValidityError},\n\tApplyExtrinsicResult, MultiSignature,\n};\nuse sp_std::{marker::PhantomData, prelude::*};\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\nuse sp_version::RuntimeVersion;\n\n// A few exports that help ease life for downstream crates.\nuse fp_rpc::TransactionStatus;\npub use frame_support::{\n\tconstruct_runtime, parameter_types,\n\ttraits::{ConstU32, ConstU8, FindAuthor, KeyOwnerProofSystem, Randomness},\n\tweights::{\n\t\tconstants::{BlockExecutionWeight, ExtrinsicBaseWeight, WEIGHT_PER_SECOND},\n\t\tConstantMultiplier, IdentityFee, Weight,\n\t},\n\tConsensusEngineId, StorageValue,\n};\n\n#[cfg(feature = \"with-paritydb-weights\")]\nuse frame_support::weights::constants::ParityDbWeight as RuntimeDbWeight;\n#[cfg(feature = \"with-rocksdb-weights\")]\nuse frame_support::weights::constants::RocksDbWeight as RuntimeDbWeight;\n\npub use pallet_balances::Call as BalancesCall;\nuse pallet_ethereum::{Call::transact, Transaction as EthereumTransaction};\nuse pallet_evm::{\n\tAccount as EVMAccount, EnsureAddressTruncated, GasWeightMapping, HashedAddressMapping, Runner,\n};\npub use pallet_timestamp::Call as TimestampCall;\nuse pallet_transaction_payment::CurrencyAdapter;\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\npub use sp_runtime::{Perbill, Permill};\n\nmod precompiles;\nuse precompiles::FrontierPrecompiles;\n\n/// Type of block number.\npub type BlockNumber = u32;\n\n/// Alias to 512-bit hash when used in the context of a transaction signature on the chain.\npub type Signature = MultiSignature;\n\n/// Some way of identifying an account on the chain. We intentionally make it equivalent\n/// to the public key of our transaction signing scheme.\npub type AccountId = <<Signature as Verify>::Signer as IdentifyAccount>::AccountId;\n\n/// The type for looking up accounts. We don't expect more than 4 billion of them, but you\n/// never know...\npub type AccountIndex = u32;\n\n/// Balance of an account.\npub type Balance = u128;\n\n/// Index of a transaction in the chain.\npub type Index = u32;\n\n/// A hash of some data used by the chain.\npub type Hash = sp_core::H256;\n\n/// Digest item type.\npub type DigestItem = generic::DigestItem;\n\n/// Opaque types. These are used by the CLI to instantiate machinery that don't need to know\n/// the specifics of the runtime. They can then be made to be agnostic over specific formats\n/// of data like extrinsics, allowing for them to continue syncing the network through upgrades\n/// to even the core data structures.\npub mod opaque {\n\tuse super::*;\n\n\tpub use sp_runtime::OpaqueExtrinsic as UncheckedExtrinsic;\n\n\t/// Opaque block header type.\n\tpub type Header = generic::Header<BlockNumber, BlakeTwo256>;\n\t/// Opaque block type.\n\tpub type Block = generic::Block<Header, UncheckedExtrinsic>;\n\t/// Opaque block identifier type.\n\tpub type BlockId = generic::BlockId<Block>;\n\n\timpl_opaque_keys! {\n\t\tpub struct SessionKeys {\n\t\t\tpub aura: Aura,\n\t\t\tpub grandpa: Grandpa,\n\t\t}\n\t}\n}\n\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"node-frontier-template\"),\n\timpl_name: create_runtime_str!(\"node-frontier-template\"),\n\tauthoring_version: 1,\n\tspec_version: 1,\n\timpl_version: 1,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 1,\n\tstate_version: 1,\n};\n\npub const MILLISECS_PER_BLOCK: u64 = 6000;\n\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n// Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\n\n/// The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -> NativeVersion {\n\tNativeVersion {\n\t\truntime_version: VERSION,\n\t\tcan_author_with: Default::default(),\n\t}\n}\n\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n/// We allow for 2 seconds of compute with a 6 second average block time.\npub const MAXIMUM_BLOCK_WEIGHT: Weight = 2 * WEIGHT_PER_SECOND;\nconst WEIGHT_PER_GAS: u64 = 20_000;\n\nparameter_types! {\n\tpub const Version: RuntimeVersion = VERSION;\n\tpub const BlockHashCount: BlockNumber = 256;\n\tpub BlockWeights: frame_system::limits::BlockWeights = frame_system::limits::BlockWeights\n\t\t::with_sensible_defaults(MAXIMUM_BLOCK_WEIGHT, NORMAL_DISPATCH_RATIO);\n\tpub BlockLength: frame_system::limits::BlockLength = frame_system::limits::BlockLength\n\t\t::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n\tpub const SS58Prefix: u8 = 42;\n}\n\n// Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Config for Runtime {\n\t/// The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = frame_support::traits::Everything;\n\t/// Block & extrinsics weights: base values and limits.\n\ttype BlockWeights = BlockWeights;\n\t/// The maximum length of a block (in bytes).\n\ttype BlockLength = BlockLength;\n\t/// The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t/// The aggregated dispatch type that is available for extrinsics.\n\ttype Call = Call;\n\t/// The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = AccountIdLookup<AccountId, ()>;\n\t/// The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t/// The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t/// The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t/// The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t/// The header type.\n\ttype Header = generic::Header<BlockNumber, BlakeTwo256>;\n\t/// The ubiquitous event type.\n\ttype Event = Event;\n\t/// The ubiquitous origin type.\n\ttype Origin = Origin;\n\t/// Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t/// The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RuntimeDbWeight;\n\t/// Version of the runtime.\n\ttype Version = Version;\n\t/// Converts a module to the index of the module in `construct_runtime!`.\n\t///\n\t/// This type is being generated by `construct_runtime!`.\n\ttype PalletInfo = PalletInfo;\n\t/// What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t/// What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t/// The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData<Balance>;\n\t/// Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n\t/// This is used as an identifier of the chain. 42 is the generic substrate prefix.\n\ttype SS58Prefix = SS58Prefix;\n\t/// The set code logic, just the default since we're not a parachain.\n\ttype OnSetCode = ();\n\ttype MaxConsumers = ConstU32<16>;\n}\n\nparameter_types! {\n\tpub const MaxAuthorities: u32 = 100;\n}\n\nimpl pallet_aura::Config for Runtime {\n\ttype AuthorityId = AuraId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxAuthorities;\n}\n\nimpl pallet_grandpa::Config for Runtime {\n\ttype Event = Event;\n\ttype Call = Call;\n\n\ttype KeyOwnerProofSystem = ();\n\n\ttype KeyOwnerProof =\n\t\t<Self::KeyOwnerProofSystem as KeyOwnerProofSystem<(KeyTypeId, GrandpaId)>>::Proof;\n\n\ttype KeyOwnerIdentification = <Self::KeyOwnerProofSystem as KeyOwnerProofSystem<(\n\t\tKeyTypeId,\n\t\tGrandpaId,\n\t)>>::IdentificationTuple;\n\n\ttype HandleEquivocation = ();\n\n\ttype WeightInfo = ();\n\ttype MaxAuthorities = ConstU32<32>;\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION / 2;\n}\n\nimpl pallet_timestamp::Config for Runtime {\n\t/// A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = ();\n\t#[cfg(feature = \"aura\")]\n\ttype OnTimestampSet = Aura;\n\t#[cfg(feature = \"manual-seal\")]\n\ttype OnTimestampSet = ();\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: u128 = 500;\n\t// For weight estimation, we assume that the most locks on an individual account will be 50.\n\t// This number may need to be adjusted in the future if this assumption no longer holds true.\n\tpub const MaxLocks: u32 = 50;\n}\n\nimpl pallet_balances::Config for Runtime {\n\ttype MaxLocks = MaxLocks;\n\ttype MaxReserves = ();\n\ttype ReserveIdentifier = [u8; 8];\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype Event = Event;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: Balance = 1;\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n\ttype OnChargeTransaction = CurrencyAdapter<Balances, ()>;\n\ttype OperationalFeeMultiplier = ConstU8<5>;\n\ttype WeightToFee = IdentityFee<Balance>;\n\ttype LengthToFee = ConstantMultiplier<Balance, TransactionByteFee>;\n\ttype FeeMultiplierUpdate = ();\n}\n\nimpl pallet_sudo::Config for Runtime {\n\ttype Event = Event;\n\ttype Call = Call;\n}\n\npub struct FindAuthorTruncated<F>(PhantomData<F>);\nimpl<F: FindAuthor<u32>> FindAuthor<H160> for FindAuthorTruncated<F> {\n\tfn find_author<'a, I>(digests: I) -> Option<H160>\n\twhere\n\t\tI: 'a + IntoIterator<Item = (ConsensusEngineId, &'a [u8])>,\n\t{\n\t\tif let Some(author_index) = F::find_author(digests) {\n\t\t\tlet authority_id = Aura::authorities()[author_index as usize].clone();\n\t\t\treturn Some(H160::from_slice(&authority_id.to_raw_vec()[4..24]));\n\t\t}\n\t\tNone\n\t}\n}\n\npub struct FixedGasWeightMapping;\nimpl GasWeightMapping for FixedGasWeightMapping {\n\tfn gas_to_weight(gas: u64) -> Weight {\n\t\tgas.saturating_mul(WEIGHT_PER_GAS)\n\t}\n\tfn weight_to_gas(weight: Weight) -> u64 {\n\t\tweight.wrapping_div(WEIGHT_PER_GAS)\n\t}\n}\n\nparameter_types! {\n\tpub const ChainId: u64 = 42;\n\tpub BlockGasLimit: U256 = U256::from(NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT / WEIGHT_PER_GAS);\n\tpub PrecompilesValue: FrontierPrecompiles<Runtime> = FrontierPrecompiles::<_>::new();\n}\n\nimpl pallet_evm::Config for Runtime {\n\ttype FeeCalculator = BaseFee;\n\ttype GasWeightMapping = FixedGasWeightMapping;\n\ttype BlockHashMapping = pallet_ethereum::EthereumBlockHashMapping<Self>;\n\ttype CallOrigin = EnsureAddressTruncated;\n\ttype WithdrawOrigin = EnsureAddressTruncated;\n\ttype AddressMapping = HashedAddressMapping<BlakeTwo256>;\n\ttype Currency = Balances;\n\ttype Event = Event;\n\ttype Runner = pallet_evm::runner::stack::Runner<Self>;\n\ttype PrecompilesType = FrontierPrecompiles<Self>;\n\ttype PrecompilesValue = PrecompilesValue;\n\ttype ChainId = ChainId;\n\ttype BlockGasLimit = BlockGasLimit;\n\ttype OnChargeTransaction = ();\n\ttype FindAuthor = FindAuthorTruncated<Aura>;\n}\n\nimpl pallet_ethereum::Config for Runtime {\n\ttype Event = Event;\n\ttype StateRoot = pallet_ethereum::IntermediateStateRoot<Self>;\n}\n\nframe_support::parameter_types! {\n\tpub BoundDivision: U256 = U256::from(1024);\n}\n\nimpl pallet_dynamic_fee::Config for Runtime {\n\ttype MinGasPriceBoundDivisor = BoundDivision;\n}\n\nframe_support::parameter_types! {\n\tpub IsActive: bool = true;\n\tpub DefaultBaseFeePerGas: U256 = U256::from(1_000_000_000);\n}\n\npub struct BaseFeeThreshold;\nimpl pallet_base_fee::BaseFeeThreshold for BaseFeeThreshold {\n\tfn lower() -> Permill {\n\t\tPermill::zero()\n\t}\n\tfn ideal() -> Permill {\n\t\tPermill::from_parts(500_000)\n\t}\n\tfn upper() -> Permill {\n\t\tPermill::from_parts(1_000_000)\n\t}\n}\n\nimpl pallet_base_fee::Config for Runtime {\n\ttype Event = Event;\n\ttype Threshold = BaseFeeThreshold;\n\ttype IsActive = IsActive;\n\ttype DefaultBaseFeePerGas = DefaultBaseFeePerGas;\n}\n\nimpl pallet_randomness_collective_flip::Config for Runtime {}\n\nimpl pallet_hotfix_sufficients::Config for Runtime {\n\ttype AddressMapping = HashedAddressMapping<BlakeTwo256>;\n\ttype WeightInfo = pallet_hotfix_sufficients::weights::SubstrateWeight<Runtime>;\n}\n\n// Create the runtime by composing the FRAME pallets that were previously configured.\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic\n\t{\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event<T>},\n\t\tRandomnessCollectiveFlip: pallet_randomness_collective_flip::{Pallet, Storage},\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent},\n\t\tAura: pallet_aura::{Pallet, Config<T>},\n\t\tGrandpa: pallet_grandpa::{Pallet, Call, Storage, Config, Event},\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config<T>, Event<T>},\n\t\tTransactionPayment: pallet_transaction_payment::{Pallet, Storage},\n\t\tSudo: pallet_sudo::{Pallet, Call, Config<T>, Storage, Event<T>},\n\t\tEthereum: pallet_ethereum::{Pallet, Call, Storage, Event, Config, Origin},\n\t\tEVM: pallet_evm::{Pallet, Config, Call, Storage, Event<T>},\n\t\tDynamicFee: pallet_dynamic_fee::{Pallet, Call, Storage, Config, Inherent},\n\t\tBaseFee: pallet_base_fee::{Pallet, Call, Storage, Config<T>, Event},\n\t\tHotfixSufficients: pallet_hotfix_sufficients::{Pallet, Call},\n\t}\n);\n\npub struct TransactionConverter;\n\nimpl fp_rpc::ConvertTransaction<UncheckedExtrinsic> for TransactionConverter {\n\tfn convert_transaction(&self, transaction: pallet_ethereum::Transaction) -> UncheckedExtrinsic {\n\t\tUncheckedExtrinsic::new_unsigned(\n\t\t\tpallet_ethereum::Call::<Runtime>::transact { transaction }.into(),\n\t\t)\n\t}\n}\n\nimpl fp_rpc::ConvertTransaction<opaque::UncheckedExtrinsic> for TransactionConverter {\n\tfn convert_transaction(\n\t\t&self,\n\t\ttransaction: pallet_ethereum::Transaction,\n\t) -> opaque::UncheckedExtrinsic {\n\t\tlet extrinsic = UncheckedExtrinsic::new_unsigned(\n\t\t\tpallet_ethereum::Call::<Runtime>::transact { transaction }.into(),\n\t\t);\n\t\tlet encoded = extrinsic.encode();\n\t\topaque::UncheckedExtrinsic::decode(&mut &encoded[..])\n\t\t\t.expect(\"Encoded extrinsic is always valid\")\n\t}\n}\n\n/// The address format for describing accounts.\npub type Address = sp_runtime::MultiAddress<AccountId, ()>;\n/// Block header type as expected by this runtime.\npub type Header = generic::Header<BlockNumber, BlakeTwo256>;\n/// Block type as expected by this runtime.\npub type Block = generic::Block<Header, UncheckedExtrinsic>;\n/// A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock<Block>;\n/// BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId<Block>;\n/// The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckNonZeroSender<Runtime>,\n\tframe_system::CheckSpecVersion<Runtime>,\n\tframe_system::CheckTxVersion<Runtime>,\n\tframe_system::CheckGenesis<Runtime>,\n\tframe_system::CheckEra<Runtime>,\n\tframe_system::CheckNonce<Runtime>,\n\tframe_system::CheckWeight<Runtime>,\n\tpallet_transaction_payment::ChargeTransactionPayment<Runtime>,\n);\n/// Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic =\n\tfp_self_contained::UncheckedExtrinsic<Address, Call, Signature, SignedExtra>;\n/// Extrinsic type that has already been checked.\npub type CheckedExtrinsic = fp_self_contained::CheckedExtrinsic<AccountId, Call, SignedExtra, H160>;\n/// The payload being signed in transactions.\npub type SignedPayload = generic::SignedPayload<Call, SignedExtra>;\n/// Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive<\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext<Runtime>,\n\tRuntime,\n\tAllPalletsWithSystem,\n>;\n\nimpl fp_self_contained::SelfContainedCall for Call {\n\ttype SignedInfo = H160;\n\n\tfn is_self_contained(&self) -> bool {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.is_self_contained(),\n\t\t\t_ => false,\n\t\t}\n\t}\n\n\tfn check_self_contained(&self) -> Option<Result<Self::SignedInfo, TransactionValidityError>> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.check_self_contained(),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn validate_self_contained(\n\t\t&self,\n\t\tinfo: &Self::SignedInfo,\n\t\tdispatch_info: &DispatchInfoOf<Call>,\n\t\tlen: usize,\n\t) -> Option<TransactionValidity> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.validate_self_contained(info, dispatch_info, len),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn pre_dispatch_self_contained(\n\t\t&self,\n\t\tinfo: &Self::SignedInfo,\n\t) -> Option<Result<(), TransactionValidityError>> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.pre_dispatch_self_contained(info),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn apply_self_contained(\n\t\tself,\n\t\tinfo: Self::SignedInfo,\n\t) -> Option<sp_runtime::DispatchResultWithInfo<PostDispatchInfoOf<Self>>> {\n\t\tmatch self {\n\t\t\tcall @ Call::Ethereum(pallet_ethereum::Call::transact { .. }) => Some(call.dispatch(\n\t\t\t\tOrigin::from(pallet_ethereum::RawOrigin::EthereumTransaction(info)),\n\t\t\t)),\n\t\t\t_ => None,\n\t\t}\n\t}\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\n#[macro_use]\nextern crate frame_benchmarking;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benches {\n\tdefine_benchmarks!([pallet_evm, EVM]);\n}\n\nimpl_runtime_apis! {\n\timpl sp_api::Core<Block> for Runtime {\n\t\tfn version() -> RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: &<Block as BlockT>::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata<Block> for Runtime {\n\t\tfn metadata() -> OpaqueMetadata {\n\t\t\tOpaqueMetadata::new(Runtime::metadata().into())\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder<Block> for Runtime {\n\t\tfn apply_extrinsic(extrinsic: <Block as BlockT>::Extrinsic) -> ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -> <Block as BlockT>::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -> Vec<<Block as BlockT>::Extrinsic> {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -> sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(&block)\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue<Block> for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: <Block as BlockT>::Extrinsic,\n\t\t\tblock_hash: <Block as BlockT>::Hash,\n\t\t) -> TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx, block_hash)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi<Block> for Runtime {\n\t\tfn offchain_worker(header: &<Block as BlockT>::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_consensus_aura::AuraApi<Block, AuraId> for Runtime {\n\t\tfn slot_duration() -> sp_consensus_aura::SlotDuration {\n\t\t\tsp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())\n\t\t}\n\n\t\tfn authorities() -> Vec<AuraId> {\n\t\t\tAura::authorities().to_vec()\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi<Block, AccountId, Index> for Runtime {\n\t\tfn account_nonce(account: AccountId) -> Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl fp_rpc::EthereumRuntimeRPCApi<Block> for Runtime {\n\t\tfn chain_id() -> u64 {\n\t\t\t<Runtime as pallet_evm::Config>::ChainId::get()\n\t\t}\n\n\t\tfn account_basic(address: H160) -> EVMAccount {\n\t\t\tlet (account, _) = EVM::account_basic(&address);\n\t\t\taccount\n\t\t}\n\n\t\tfn gas_price() -> U256 {\n\t\t\tlet (gas_price, _) = <Runtime as pallet_evm::Config>::FeeCalculator::min_gas_price();\n\t\t\tgas_price\n\t\t}\n\n\t\tfn account_code_at(address: H160) -> Vec<u8> {\n\t\t\tEVM::account_codes(address)\n\t\t}\n\n\t\tfn author() -> H160 {\n\t\t\t<pallet_evm::Pallet<Runtime>>::find_author()\n\t\t}\n\n\t\tfn storage_at(address: H160, index: U256) -> H256 {\n\t\t\tlet mut tmp = [0u8; 32];\n\t\t\tindex.to_big_endian(&mut tmp);\n\t\t\tEVM::account_storages(address, H256::from_slice(&tmp[..]))\n\t\t}\n\n\t\tfn call(\n\t\t\tfrom: H160,\n\t\t\tto: H160,\n\t\t\tdata: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: U256,\n\t\t\tmax_fee_per_gas: Option<U256>,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\testimate: bool,\n\t\t\taccess_list: Option<Vec<(H160, Vec<H256>)>>,\n\t\t) -> Result<pallet_evm::CallInfo, sp_runtime::DispatchError> {\n\t\t\tlet config = if estimate {\n\t\t\t\tlet mut config = <Runtime as pallet_evm::Config>::config().clone();\n\t\t\t\tconfig.estimate = true;\n\t\t\t\tSome(config)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t};\n\n\t\t\tlet is_transactional = false;\n\t\t\t<Runtime as pallet_evm::Config>::Runner::call(\n\t\t\t\tfrom,\n\t\t\t\tto,\n\t\t\t\tdata,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit.low_u64(),\n\t\t\t\tmax_fee_per_gas,\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list.unwrap_or_default(),\n\t\t\t\tis_transactional,\n\t\t\t\tconfig.as_ref().unwrap_or(<Runtime as pallet_evm::Config>::config()),\n\t\t\t).map_err(|err| err.error.into())\n\t\t}\n\n\t\tfn create(\n\t\t\tfrom: H160,\n\t\t\tdata: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: U256,\n\t\t\tmax_fee_per_gas: Option<U256>,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\testimate: bool,\n\t\t\taccess_list: Option<Vec<(H160, Vec<H256>)>>,\n\t\t) -> Result<pallet_evm::CreateInfo, sp_runtime::DispatchError> {\n\t\t\tlet config = if estimate {\n\t\t\t\tlet mut config = <Runtime as pallet_evm::Config>::config().clone();\n\t\t\t\tconfig.estimate = true;\n\t\t\t\tSome(config)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t};\n\n\t\t\tlet is_transactional = false;\n\t\t\t<Runtime as pallet_evm::Config>::Runner::create(\n\t\t\t\tfrom,\n\t\t\t\tdata,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit.low_u64(),\n\t\t\t\tmax_fee_per_gas,\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list.unwrap_or_default(),\n\t\t\t\tis_transactional,\n\t\t\t\tconfig.as_ref().unwrap_or(<Runtime as pallet_evm::Config>::config()),\n\t\t\t).map_err(|err| err.error.into())\n\t\t}\n\n\t\tfn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {\n\t\t\tEthereum::current_transaction_statuses()\n\t\t}\n\n\t\tfn current_block() -> Option<pallet_ethereum::Block> {\n\t\t\tEthereum::current_block()\n\t\t}\n\n\t\tfn current_receipts() -> Option<Vec<pallet_ethereum::Receipt>> {\n\t\t\tEthereum::current_receipts()\n\t\t}\n\n\t\tfn current_all() -> (\n\t\t\tOption<pallet_ethereum::Block>,\n\t\t\tOption<Vec<pallet_ethereum::Receipt>>,\n\t\t\tOption<Vec<TransactionStatus>>\n\t\t) {\n\t\t\t(\n\t\t\t\tEthereum::current_block(),\n\t\t\t\tEthereum::current_receipts(),\n\t\t\t\tEthereum::current_transaction_statuses()\n\t\t\t)\n\t\t}\n\n\t\tfn extrinsic_filter(\n\t\t\txts: Vec<<Block as BlockT>::Extrinsic>,\n\t\t) -> Vec<EthereumTransaction> {\n\t\t\txts.into_iter().filter_map(|xt| match xt.0.function {\n\t\t\t\tCall::Ethereum(transact { transaction }) => Some(transaction),\n\t\t\t\t_ => None\n\t\t\t}).collect::<Vec<EthereumTransaction>>()\n\t\t}\n\n\t\tfn elasticity() -> Option<Permill> {\n\t\t\tSome(BaseFee::elasticity())\n\t\t}\n\t}\n\n\timpl fp_rpc::ConvertTransactionRuntimeApi<Block> for Runtime {\n\t\tfn convert_transaction(transaction: EthereumTransaction) -> <Block as BlockT>::Extrinsic {\n\t\t\tUncheckedExtrinsic::new_unsigned(\n\t\t\t\tpallet_ethereum::Call::<Runtime>::transact { transaction }.into(),\n\t\t\t)\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi<\n\t\tBlock,\n\t\tBalance,\n\t> for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: <Block as BlockT>::Extrinsic,\n\t\t\tlen: u32\n\t\t) -> pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo<Balance> {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\n\t\tfn query_fee_details(\n\t\t\tuxt: <Block as BlockT>::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -> pallet_transaction_payment::FeeDetails<Balance> {\n\t\t\tTransactionPayment::query_fee_details(uxt, len)\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys<Block> for Runtime {\n\t\tfn generate_session_keys(seed: Option<Vec<u8>>) -> Vec<u8> {\n\t\t\topaque::SessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec<u8>,\n\t\t) -> Option<Vec<(Vec<u8>, KeyTypeId)>> {\n\t\t\topaque::SessionKeys::decode_into_raw_public_keys(&encoded)\n\t\t}\n\t}\n\n\timpl fg_primitives::GrandpaApi<Block> for Runtime {\n\t\tfn grandpa_authorities() -> GrandpaAuthorityList {\n\t\t\tGrandpa::grandpa_authorities()\n\t\t}\n\n\t\tfn current_set_id() -> fg_primitives::SetId {\n\t\t\tGrandpa::current_set_id()\n\t\t}\n\n\t\tfn submit_report_equivocation_unsigned_extrinsic(\n\t\t\t_equivocation_proof: fg_primitives::EquivocationProof<\n\t\t\t\t<Block as BlockT>::Hash,\n\t\t\t\tNumberFor<Block>,\n\t\t\t>,\n\t\t\t_key_owner_proof: fg_primitives::OpaqueKeyOwnershipProof,\n\t\t) -> Option<()> {\n\t\t\tNone\n\t\t}\n\n\t\tfn generate_key_ownership_proof(\n\t\t\t_set_id: fg_primitives::SetId,\n\t\t\t_authority_id: GrandpaId,\n\t\t) -> Option<fg_primitives::OpaqueKeyOwnershipProof> {\n\t\t\t// NOTE: this is the only implementation possible since we've\n\t\t\t// defined our key owner proof type as a bottom type (i.e. a type\n\t\t\t// with no values).\n\t\t\tNone\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark<Block> for Runtime {\n\t\tfn benchmark_metadata(extra: bool) -> (\n\t\t\tVec<frame_benchmarking::BenchmarkList>,\n\t\t\tVec<frame_support::traits::StorageInfo>,\n\t\t) {\n\t\t\tuse frame_benchmarking::{Benchmarking, BenchmarkList};\n\t\t\tuse frame_support::traits::StorageInfoTrait;\n\t\t\tuse pallet_hotfix_sufficients::Pallet as PalletHotfixSufficients;\n\n\t\t\tlet mut list = Vec::<BenchmarkList>::new();\n\t\t\tlist_benchmarks!(list, extra);\n\t\t\tlist_benchmark!(list, extra, pallet_hotfix_sufficients, PalletHotfixSufficients::<Runtime>);\n\n\t\t\tlet storage_info = AllPalletsWithSystem::storage_info();\n\t\t\treturn (list, storage_info)\n\t\t}\n\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -> Result<Vec<frame_benchmarking::BenchmarkBatch>, sp_runtime::RuntimeString> {\n\t\t\tuse frame_benchmarking::{Benchmarking, BenchmarkBatch, add_benchmark, TrackedStorageKey};\n\t\t\tuse pallet_evm::Pallet as PalletEvmBench;\n\t\t\tuse pallet_hotfix_sufficients::Pallet as PalletHotfixSufficients;\n\t\t\timpl frame_system_benchmarking::Config for Runtime {}\n\n\t\t\tlet whitelist: Vec<TrackedStorageKey> = vec![];\n\n\t\t\tlet mut batches = Vec::<BenchmarkBatch>::new();\n\t\t\tlet params = (&config, &whitelist);\n\n\t\t\tadd_benchmark!(params, batches, pallet_evm, PalletEvmBench::<Runtime>);\n\t\t\tadd_benchmark!(params, batches, pallet_hotfix_sufficients, PalletHotfixSufficients::<Runtime>);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n}\n"], "fixing_code": ["// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # Ethereum pallet\n//!\n//! The Ethereum pallet works together with EVM pallet to provide full emulation\n//! for Ethereum block processing.\n\n// Ensure we're `no_std` when compiling for Wasm.\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(clippy::comparison_chain, clippy::large_enum_variant)]\n\n#[cfg(all(feature = \"std\", test))]\nmod mock;\n#[cfg(all(feature = \"std\", test))]\nmod tests;\n\nuse ethereum_types::{Bloom, BloomInput, H160, H256, H64, U256};\nuse evm::ExitReason;\nuse fp_consensus::{PostLog, PreLog, FRONTIER_ENGINE_ID};\nuse fp_evm::CallOrCreateInfo;\nuse fp_storage::{EthereumStorageSchema, PALLET_ETHEREUM_SCHEMA};\n#[cfg(feature = \"try-runtime\")]\nuse frame_support::traits::OnRuntimeUpgradeHelpersExt;\nuse frame_support::{\n\tcodec::{Decode, Encode},\n\tdispatch::DispatchResultWithPostInfo,\n\tscale_info::TypeInfo,\n\ttraits::{EnsureOrigin, Get, PalletInfoAccess},\n\tweights::{DispatchInfo, Pays, PostDispatchInfo, Weight},\n};\nuse frame_system::{pallet_prelude::OriginFor, CheckWeight, WeightInfo};\nuse pallet_evm::{BlockHashMapping, FeeCalculator, GasWeightMapping, Runner};\nuse sha3::{Digest, Keccak256};\nuse sp_runtime::{\n\tgeneric::DigestItem,\n\ttraits::{DispatchInfoOf, Dispatchable, One, Saturating, UniqueSaturatedInto, Zero},\n\ttransaction_validity::{\n\t\tInvalidTransaction, TransactionValidity, TransactionValidityError, ValidTransactionBuilder,\n\t},\n\tDispatchErrorWithPostInfo, RuntimeDebug,\n};\nuse sp_std::{marker::PhantomData, prelude::*};\n\npub use ethereum::{\n\tAccessListItem, BlockV2 as Block, LegacyTransactionMessage, Log, ReceiptV3 as Receipt,\n\tTransactionAction, TransactionV2 as Transaction,\n};\npub use fp_rpc::TransactionStatus;\n\n#[derive(PartialEq, Eq, Clone, Encode, Decode, RuntimeDebug, TypeInfo)]\npub enum RawOrigin {\n\tEthereumTransaction(H160),\n}\n\npub fn ensure_ethereum_transaction<OuterOrigin>(o: OuterOrigin) -> Result<H160, &'static str>\nwhere\n\tOuterOrigin: Into<Result<RawOrigin, OuterOrigin>>,\n{\n\tmatch o.into() {\n\t\tOk(RawOrigin::EthereumTransaction(n)) => Ok(n),\n\t\t_ => Err(\"bad origin: expected to be an Ethereum transaction\"),\n\t}\n}\n\n#[derive(Clone, Debug, Encode, Decode, PartialEq, Eq)]\nstruct TransactionData {\n\taction: TransactionAction,\n\tinput: Vec<u8>,\n\tnonce: U256,\n\tgas_limit: U256,\n\tgas_price: Option<U256>,\n\tmax_fee_per_gas: Option<U256>,\n\tmax_priority_fee_per_gas: Option<U256>,\n\tvalue: U256,\n\tchain_id: Option<u64>,\n\taccess_list: Vec<(H160, Vec<H256>)>,\n}\n\npub struct EnsureEthereumTransaction;\nimpl<O: Into<Result<RawOrigin, O>> + From<RawOrigin>> EnsureOrigin<O>\n\tfor EnsureEthereumTransaction\n{\n\ttype Success = H160;\n\tfn try_origin(o: O) -> Result<Self::Success, O> {\n\t\to.into().map(|o| match o {\n\t\t\tRawOrigin::EthereumTransaction(id) => id,\n\t\t})\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\tfn successful_origin() -> O {\n\t\tO::from(RawOrigin::EthereumTransaction(Default::default()))\n\t}\n}\n\nimpl<T> Call<T>\nwhere\n\tOriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,\n\tT: Send + Sync + Config,\n\tT::Call: Dispatchable<Info = DispatchInfo, PostInfo = PostDispatchInfo>,\n{\n\tpub fn is_self_contained(&self) -> bool {\n\t\tmatches!(self, Call::transact { .. })\n\t}\n\n\tpub fn check_self_contained(&self) -> Option<Result<H160, TransactionValidityError>> {\n\t\tif let Call::transact { transaction } = self {\n\t\t\tlet check = || {\n\t\t\t\tlet origin = Pallet::<T>::recover_signer(transaction).ok_or(\n\t\t\t\t\tInvalidTransaction::Custom(TransactionValidationError::InvalidSignature as u8),\n\t\t\t\t)?;\n\n\t\t\t\tOk(origin)\n\t\t\t};\n\n\t\t\tSome(check())\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\n\tpub fn pre_dispatch_self_contained(\n\t\t&self,\n\t\torigin: &H160,\n\t) -> Option<Result<(), TransactionValidityError>> {\n\t\tif let Call::transact { transaction } = self {\n\t\t\tSome(Pallet::<T>::validate_transaction_in_block(\n\t\t\t\t*origin,\n\t\t\t\ttransaction,\n\t\t\t))\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n\n\tpub fn validate_self_contained(\n\t\t&self,\n\t\torigin: &H160,\n\t\tdispatch_info: &DispatchInfoOf<T::Call>,\n\t\tlen: usize,\n\t) -> Option<TransactionValidity> {\n\t\tif let Call::transact { transaction } = self {\n\t\t\tif let Err(e) = CheckWeight::<T>::do_validate(dispatch_info, len) {\n\t\t\t\treturn Some(Err(e));\n\t\t\t}\n\n\t\t\tSome(Pallet::<T>::validate_transaction_in_pool(\n\t\t\t\t*origin,\n\t\t\t\ttransaction,\n\t\t\t))\n\t\t} else {\n\t\t\tNone\n\t\t}\n\t}\n}\n\npub use self::pallet::*;\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config + pallet_timestamp::Config + pallet_evm::Config {\n\t\t/// The overarching event type.\n\t\ttype Event: From<Event> + IsType<<Self as frame_system::Config>::Event>;\n\t\t/// How Ethereum state root is calculated.\n\t\ttype StateRoot: Get<H256>;\n\t}\n\n\t#[pallet::pallet]\n\t#[pallet::generate_store(pub(super) trait Store)]\n\t#[pallet::without_storage_info]\n\tpub struct Pallet<T>(PhantomData<T>);\n\n\t#[pallet::origin]\n\tpub type Origin = RawOrigin;\n\n\t#[pallet::hooks]\n\timpl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {\n\t\tfn on_finalize(n: T::BlockNumber) {\n\t\t\t<Pallet<T>>::store_block(\n\t\t\t\tfp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),\n\t\t\t\tU256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(\n\t\t\t\t\tframe_system::Pallet::<T>::block_number(),\n\t\t\t\t)),\n\t\t\t);\n\t\t\t// move block hash pruning window by one block\n\t\t\tlet block_hash_count = T::BlockHashCount::get();\n\t\t\tlet to_remove = n\n\t\t\t\t.saturating_sub(block_hash_count)\n\t\t\t\t.saturating_sub(One::one());\n\t\t\t// keep genesis hash\n\t\t\tif !to_remove.is_zero() {\n\t\t\t\t<BlockHash<T>>::remove(U256::from(\n\t\t\t\t\tUniqueSaturatedInto::<u32>::unique_saturated_into(to_remove),\n\t\t\t\t));\n\t\t\t}\n\t\t\tPending::<T>::kill();\n\t\t}\n\n\t\tfn on_initialize(_: T::BlockNumber) -> Weight {\n\t\t\tlet mut weight = T::SystemWeightInfo::kill_storage(1);\n\n\t\t\t// If the digest contain an existing ethereum block(encoded as PreLog), If contains,\n\t\t\t// execute the imported block firstly and disable transact dispatch function.\n\t\t\tif let Ok(log) = fp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()) {\n\t\t\t\tlet PreLog::Block(block) = log;\n\n\t\t\t\tfor transaction in block.transactions {\n\t\t\t\t\tlet source = Self::recover_signer(&transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction signature invalid; the block cannot be built\",\n\t\t\t\t\t);\n\n\t\t\t\t\tSelf::validate_transaction_in_block(source, &transaction).expect(\n\t\t\t\t\t\t\"pre-block transaction verification failed; the block cannot be built\",\n\t\t\t\t\t);\n\t\t\t\t\tlet r = Self::apply_validated_transaction(source, transaction)\n\t\t\t\t\t\t.expect(\"pre-block apply transaction failed; the block cannot be built\");\n\n\t\t\t\t\tweight = weight.saturating_add(r.actual_weight.unwrap_or(0));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Account for `on_finalize` weight:\n\t\t\t//\t- read: frame_system::Pallet::<T>::digest()\n\t\t\t//\t- read: frame_system::Pallet::<T>::block_number()\n\t\t\t//\t- write: <Pallet<T>>::store_block()\n\t\t\t//\t- write: <BlockHash<T>>::remove()\n\t\t\tweight.saturating_add(T::DbWeight::get().reads_writes(2, 2))\n\t\t}\n\n\t\tfn on_runtime_upgrade() -> Weight {\n\t\t\tframe_support::storage::unhashed::put::<EthereumStorageSchema>(\n\t\t\t\tPALLET_ETHEREUM_SCHEMA,\n\t\t\t\t&EthereumStorageSchema::V3,\n\t\t\t);\n\n\t\t\tT::DbWeight::get().write\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T>\n\twhere\n\t\tOriginFor<T>: Into<Result<RawOrigin, OriginFor<T>>>,\n\t{\n\t\t/// Transact an Ethereum transaction.\n\t\t#[pallet::weight(<T as pallet_evm::Config>::GasWeightMapping::gas_to_weight(\n\t\t\tPallet::<T>::transaction_data(transaction).gas_limit.unique_saturated_into()\n\t\t))]\n\t\tpub fn transact(\n\t\t\torigin: OriginFor<T>,\n\t\t\ttransaction: Transaction,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tlet source = ensure_ethereum_transaction(origin)?;\n\t\t\t// Disable transact functionality if PreLog exist.\n\t\t\tassert!(\n\t\t\t\tfp_consensus::find_pre_log(&frame_system::Pallet::<T>::digest()).is_err(),\n\t\t\t\t\"pre log already exists; block is invalid\",\n\t\t\t);\n\n\t\t\tSelf::apply_validated_transaction(source, transaction)\n\t\t}\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event {\n\t\t/// An ethereum transaction was successfully executed. [from, to/contract_address, transaction_hash, exit_reason]\n\t\tExecuted(H160, H160, H256, ExitReason),\n\t}\n\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\t/// Signature is invalid.\n\t\tInvalidSignature,\n\t\t/// Pre-log is present, therefore transact is not allowed.\n\t\tPreLogExists,\n\t}\n\n\t/// Current building block's transactions and receipts.\n\t#[pallet::storage]\n\tpub(super) type Pending<T: Config> =\n\t\tStorageValue<_, Vec<(Transaction, TransactionStatus, Receipt)>, ValueQuery>;\n\n\t/// The current Ethereum block.\n\t#[pallet::storage]\n\tpub(super) type CurrentBlock<T: Config> = StorageValue<_, ethereum::BlockV2>;\n\n\t/// The current Ethereum receipts.\n\t#[pallet::storage]\n\tpub(super) type CurrentReceipts<T: Config> = StorageValue<_, Vec<Receipt>>;\n\n\t/// The current transaction statuses.\n\t#[pallet::storage]\n\tpub(super) type CurrentTransactionStatuses<T: Config> = StorageValue<_, Vec<TransactionStatus>>;\n\n\t// Mapping for block number and hashes.\n\t#[pallet::storage]\n\tpub(super) type BlockHash<T: Config> = StorageMap<_, Twox64Concat, U256, H256, ValueQuery>;\n\n\t#[pallet::genesis_config]\n\t#[derive(Default)]\n\tpub struct GenesisConfig {}\n\n\t#[pallet::genesis_build]\n\timpl<T: Config> GenesisBuild<T> for GenesisConfig {\n\t\tfn build(&self) {\n\t\t\t<Pallet<T>>::store_block(false, U256::zero());\n\t\t\tframe_support::storage::unhashed::put::<EthereumStorageSchema>(\n\t\t\t\tPALLET_ETHEREUM_SCHEMA,\n\t\t\t\t&EthereumStorageSchema::V3,\n\t\t\t);\n\t\t}\n\t}\n}\n\nimpl<T: Config> Pallet<T> {\n\tfn transaction_data(transaction: &Transaction) -> TransactionData {\n\t\tmatch transaction {\n\t\t\tTransaction::Legacy(t) => TransactionData {\n\t\t\t\taction: t.action,\n\t\t\t\tinput: t.input.clone(),\n\t\t\t\tnonce: t.nonce,\n\t\t\t\tgas_limit: t.gas_limit,\n\t\t\t\tgas_price: Some(t.gas_price),\n\t\t\t\tmax_fee_per_gas: None,\n\t\t\t\tmax_priority_fee_per_gas: None,\n\t\t\t\tvalue: t.value,\n\t\t\t\tchain_id: t.signature.chain_id(),\n\t\t\t\taccess_list: Vec::new(),\n\t\t\t},\n\t\t\tTransaction::EIP2930(t) => TransactionData {\n\t\t\t\taction: t.action,\n\t\t\t\tinput: t.input.clone(),\n\t\t\t\tnonce: t.nonce,\n\t\t\t\tgas_limit: t.gas_limit,\n\t\t\t\tgas_price: Some(t.gas_price),\n\t\t\t\tmax_fee_per_gas: None,\n\t\t\t\tmax_priority_fee_per_gas: None,\n\t\t\t\tvalue: t.value,\n\t\t\t\tchain_id: Some(t.chain_id),\n\t\t\t\taccess_list: t\n\t\t\t\t\t.access_list\n\t\t\t\t\t.iter()\n\t\t\t\t\t.map(|d| (d.address, d.storage_keys.clone()))\n\t\t\t\t\t.collect(),\n\t\t\t},\n\t\t\tTransaction::EIP1559(t) => TransactionData {\n\t\t\t\taction: t.action,\n\t\t\t\tinput: t.input.clone(),\n\t\t\t\tnonce: t.nonce,\n\t\t\t\tgas_limit: t.gas_limit,\n\t\t\t\tgas_price: None,\n\t\t\t\tmax_fee_per_gas: Some(t.max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas: Some(t.max_priority_fee_per_gas),\n\t\t\t\tvalue: t.value,\n\t\t\t\tchain_id: Some(t.chain_id),\n\t\t\t\taccess_list: t\n\t\t\t\t\t.access_list\n\t\t\t\t\t.iter()\n\t\t\t\t\t.map(|d| (d.address, d.storage_keys.clone()))\n\t\t\t\t\t.collect(),\n\t\t\t},\n\t\t}\n\t}\n\n\tfn recover_signer(transaction: &Transaction) -> Option<H160> {\n\t\tlet mut sig = [0u8; 65];\n\t\tlet mut msg = [0u8; 32];\n\t\tmatch transaction {\n\t\t\tTransaction::Legacy(t) => {\n\t\t\t\tsig[0..32].copy_from_slice(&t.signature.r()[..]);\n\t\t\t\tsig[32..64].copy_from_slice(&t.signature.s()[..]);\n\t\t\t\tsig[64] = t.signature.standard_v();\n\t\t\t\tmsg.copy_from_slice(\n\t\t\t\t\t&ethereum::LegacyTransactionMessage::from(t.clone()).hash()[..],\n\t\t\t\t);\n\t\t\t}\n\t\t\tTransaction::EIP2930(t) => {\n\t\t\t\tsig[0..32].copy_from_slice(&t.r[..]);\n\t\t\t\tsig[32..64].copy_from_slice(&t.s[..]);\n\t\t\t\tsig[64] = t.odd_y_parity as u8;\n\t\t\t\tmsg.copy_from_slice(\n\t\t\t\t\t&ethereum::EIP2930TransactionMessage::from(t.clone()).hash()[..],\n\t\t\t\t);\n\t\t\t}\n\t\t\tTransaction::EIP1559(t) => {\n\t\t\t\tsig[0..32].copy_from_slice(&t.r[..]);\n\t\t\t\tsig[32..64].copy_from_slice(&t.s[..]);\n\t\t\t\tsig[64] = t.odd_y_parity as u8;\n\t\t\t\tmsg.copy_from_slice(\n\t\t\t\t\t&ethereum::EIP1559TransactionMessage::from(t.clone()).hash()[..],\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tlet pubkey = sp_io::crypto::secp256k1_ecdsa_recover(&sig, &msg).ok()?;\n\t\tSome(H160::from(H256::from_slice(\n\t\t\tKeccak256::digest(&pubkey).as_slice(),\n\t\t)))\n\t}\n\n\tfn store_block(post_log: bool, block_number: U256) {\n\t\tlet mut transactions = Vec::new();\n\t\tlet mut statuses = Vec::new();\n\t\tlet mut receipts = Vec::new();\n\t\tlet mut logs_bloom = Bloom::default();\n\t\tlet mut cumulative_gas_used = U256::zero();\n\t\tfor (transaction, status, receipt) in Pending::<T>::get() {\n\t\t\ttransactions.push(transaction);\n\t\t\tstatuses.push(status);\n\t\t\treceipts.push(receipt.clone());\n\t\t\tlet (logs, used_gas) = match receipt {\n\t\t\t\tReceipt::Legacy(d) | Receipt::EIP2930(d) | Receipt::EIP1559(d) => {\n\t\t\t\t\t(d.logs.clone(), d.used_gas)\n\t\t\t\t}\n\t\t\t};\n\t\t\tcumulative_gas_used = used_gas;\n\t\t\tSelf::logs_bloom(logs, &mut logs_bloom);\n\t\t}\n\n\t\tlet ommers = Vec::<ethereum::Header>::new();\n\t\tlet receipts_root = ethereum::util::ordered_trie_root(receipts.iter().map(rlp::encode));\n\t\tlet partial_header = ethereum::PartialHeader {\n\t\t\tparent_hash: if block_number > U256::zero() {\n\t\t\t\tBlockHash::<T>::get(block_number - 1)\n\t\t\t} else {\n\t\t\t\tH256::default()\n\t\t\t},\n\t\t\tbeneficiary: pallet_evm::Pallet::<T>::find_author(),\n\t\t\tstate_root: T::StateRoot::get(),\n\t\t\treceipts_root,\n\t\t\tlogs_bloom,\n\t\t\tdifficulty: U256::zero(),\n\t\t\tnumber: block_number,\n\t\t\tgas_limit: T::BlockGasLimit::get(),\n\t\t\tgas_used: cumulative_gas_used,\n\t\t\ttimestamp: UniqueSaturatedInto::<u64>::unique_saturated_into(\n\t\t\t\tpallet_timestamp::Pallet::<T>::get(),\n\t\t\t),\n\t\t\textra_data: Vec::new(),\n\t\t\tmix_hash: H256::default(),\n\t\t\tnonce: H64::default(),\n\t\t};\n\t\tlet block = ethereum::Block::new(partial_header, transactions.clone(), ommers);\n\n\t\tCurrentBlock::<T>::put(block.clone());\n\t\tCurrentReceipts::<T>::put(receipts.clone());\n\t\tCurrentTransactionStatuses::<T>::put(statuses.clone());\n\t\tBlockHash::<T>::insert(block_number, block.header.hash());\n\n\t\tif post_log {\n\t\t\tlet digest = DigestItem::Consensus(\n\t\t\t\tFRONTIER_ENGINE_ID,\n\t\t\t\tPostLog::Hashes(fp_consensus::Hashes::from_block(block)).encode(),\n\t\t\t);\n\t\t\tframe_system::Pallet::<T>::deposit_log(digest);\n\t\t}\n\t}\n\n\tfn logs_bloom(logs: Vec<Log>, bloom: &mut Bloom) {\n\t\tfor log in logs {\n\t\t\tbloom.accrue(BloomInput::Raw(&log.address[..]));\n\t\t\tfor topic in log.topics {\n\t\t\t\tbloom.accrue(BloomInput::Raw(&topic[..]));\n\t\t\t}\n\t\t}\n\t}\n\n\t// Common controls to be performed in the same way by the pool and the\n\t// State Transition Function (STF).\n\t// This is the case for all controls except those concerning the nonce.\n\tfn validate_transaction_common(\n\t\torigin: H160,\n\t\ttransaction_data: &TransactionData,\n\t) -> Result<(U256, u64), TransactionValidityError> {\n\t\tlet gas_limit = transaction_data.gas_limit;\n\n\t\t// We must ensure a transaction can pay the cost of its data bytes.\n\t\t// If it can't it should not be included in a block.\n\t\tlet mut gasometer = evm::gasometer::Gasometer::new(\n\t\t\tgas_limit.low_u64(),\n\t\t\t<T as pallet_evm::Config>::config(),\n\t\t);\n\t\tlet transaction_cost = match transaction_data.action {\n\t\t\tTransactionAction::Call(_) => evm::gasometer::call_transaction_cost(\n\t\t\t\t&transaction_data.input,\n\t\t\t\t&transaction_data.access_list,\n\t\t\t),\n\t\t\tTransactionAction::Create => evm::gasometer::create_transaction_cost(\n\t\t\t\t&transaction_data.input,\n\t\t\t\t&transaction_data.access_list,\n\t\t\t),\n\t\t};\n\t\tif gasometer.record_transaction(transaction_cost).is_err() {\n\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t)\n\t\t\t.into());\n\t\t}\n\n\t\tif let Some(chain_id) = transaction_data.chain_id {\n\t\t\tif chain_id != T::ChainId::get() {\n\t\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\t\tTransactionValidationError::InvalidChainId as u8,\n\t\t\t\t)\n\t\t\t\t.into());\n\t\t\t}\n\t\t}\n\n\t\tif gas_limit >= T::BlockGasLimit::get() {\n\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\tTransactionValidationError::InvalidGasLimit as u8,\n\t\t\t)\n\t\t\t.into());\n\t\t}\n\n\t\tlet (base_fee, _) = T::FeeCalculator::min_gas_price();\n\t\tlet mut priority = 0;\n\n\t\tlet max_fee_per_gas = match (\n\t\t\ttransaction_data.gas_price,\n\t\t\ttransaction_data.max_fee_per_gas,\n\t\t\ttransaction_data.max_priority_fee_per_gas,\n\t\t) {\n\t\t\t// Legacy or EIP-2930 transaction.\n\t\t\t// Handle priority here. On legacy transaction everything in gas_price except\n\t\t\t// the current base_fee is considered a tip to the miner and thus the priority.\n\t\t\t(Some(gas_price), None, None) => {\n\t\t\t\tpriority = gas_price.saturating_sub(base_fee).unique_saturated_into();\n\t\t\t\tgas_price\n\t\t\t}\n\t\t\t// EIP-1559 transaction without tip.\n\t\t\t(None, Some(max_fee_per_gas), None) => max_fee_per_gas,\n\t\t\t// EIP-1559 transaction with tip.\n\t\t\t(None, Some(max_fee_per_gas), Some(max_priority_fee_per_gas)) => {\n\t\t\t\tif max_priority_fee_per_gas > max_fee_per_gas {\n\t\t\t\t\treturn Err(InvalidTransaction::Custom(\n\t\t\t\t\t\tTransactionValidationError::MaxFeePerGasTooLow as u8,\n\t\t\t\t\t)\n\t\t\t\t\t.into());\n\t\t\t\t}\n\t\t\t\tpriority = max_fee_per_gas\n\t\t\t\t\t.saturating_sub(base_fee)\n\t\t\t\t\t.min(max_priority_fee_per_gas)\n\t\t\t\t\t.unique_saturated_into();\n\t\t\t\tmax_fee_per_gas\n\t\t\t}\n\t\t\t_ => return Err(InvalidTransaction::Payment.into()),\n\t\t};\n\n\t\tif max_fee_per_gas < base_fee {\n\t\t\treturn Err(InvalidTransaction::Payment.into());\n\t\t}\n\n\t\tlet fee = max_fee_per_gas.saturating_mul(gas_limit);\n\t\tlet (account_data, _) = pallet_evm::Pallet::<T>::account_basic(&origin);\n\t\tlet total_payment = transaction_data.value.saturating_add(fee);\n\t\tif account_data.balance < total_payment {\n\t\t\treturn Err(InvalidTransaction::Payment.into());\n\t\t}\n\n\t\tOk((account_data.nonce, priority))\n\t}\n\n\t// Controls that must be performed by the pool.\n\t// The controls common with the State Transition Function (STF) are in\n\t// the function `validate_transaction_common`.\n\tfn validate_transaction_in_pool(\n\t\torigin: H160,\n\t\ttransaction: &Transaction,\n\t) -> TransactionValidity {\n\t\tlet transaction_data = Pallet::<T>::transaction_data(transaction);\n\t\tlet transaction_nonce = transaction_data.nonce;\n\n\t\tlet (account_nonce, priority) =\n\t\t\tSelf::validate_transaction_common(origin, &transaction_data)?;\n\n\t\tif transaction_nonce < account_nonce {\n\t\t\treturn Err(InvalidTransaction::Stale.into());\n\t\t}\n\n\t\t// The tag provides and requires must be filled correctly according to the nonce.\n\t\tlet mut builder = ValidTransactionBuilder::default()\n\t\t\t.and_provides((origin, transaction_nonce))\n\t\t\t.priority(priority);\n\n\t\t// In the context of the pool, a transaction with\n\t\t// too high a nonce is still considered valid\n\t\tif transaction_nonce > account_nonce {\n\t\t\tif let Some(prev_nonce) = transaction_nonce.checked_sub(1.into()) {\n\t\t\t\tbuilder = builder.and_requires((origin, prev_nonce))\n\t\t\t}\n\t\t}\n\n\t\tbuilder.build()\n\t}\n\n\tfn apply_validated_transaction(\n\t\tsource: H160,\n\t\ttransaction: Transaction,\n\t) -> DispatchResultWithPostInfo {\n\t\tlet (to, _, info) = Self::execute(source, &transaction, None)?;\n\n\t\tlet pending = Pending::<T>::get();\n\t\tlet transaction_hash = transaction.hash();\n\t\tlet transaction_index = pending.len() as u32;\n\n\t\tlet (reason, status, used_gas, dest) = match info {\n\t\t\tCallOrCreateInfo::Call(info) => (\n\t\t\t\tinfo.exit_reason,\n\t\t\t\tTransactionStatus {\n\t\t\t\t\ttransaction_hash,\n\t\t\t\t\ttransaction_index,\n\t\t\t\t\tfrom: source,\n\t\t\t\t\tto,\n\t\t\t\t\tcontract_address: None,\n\t\t\t\t\tlogs: info.logs.clone(),\n\t\t\t\t\tlogs_bloom: {\n\t\t\t\t\t\tlet mut bloom: Bloom = Bloom::default();\n\t\t\t\t\t\tSelf::logs_bloom(info.logs, &mut bloom);\n\t\t\t\t\t\tbloom\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinfo.used_gas,\n\t\t\t\tto,\n\t\t\t),\n\t\t\tCallOrCreateInfo::Create(info) => (\n\t\t\t\tinfo.exit_reason,\n\t\t\t\tTransactionStatus {\n\t\t\t\t\ttransaction_hash,\n\t\t\t\t\ttransaction_index,\n\t\t\t\t\tfrom: source,\n\t\t\t\t\tto,\n\t\t\t\t\tcontract_address: Some(info.value),\n\t\t\t\t\tlogs: info.logs.clone(),\n\t\t\t\t\tlogs_bloom: {\n\t\t\t\t\t\tlet mut bloom: Bloom = Bloom::default();\n\t\t\t\t\t\tSelf::logs_bloom(info.logs, &mut bloom);\n\t\t\t\t\t\tbloom\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tinfo.used_gas,\n\t\t\t\tSome(info.value),\n\t\t\t),\n\t\t};\n\n\t\tlet receipt = {\n\t\t\tlet status_code: u8 = match reason {\n\t\t\t\tExitReason::Succeed(_) => 1,\n\t\t\t\t_ => 0,\n\t\t\t};\n\t\t\tlet logs_bloom = status.logs_bloom;\n\t\t\tlet logs = status.clone().logs;\n\t\t\tlet cumulative_gas_used = if let Some((_, _, receipt)) = pending.last() {\n\t\t\t\tmatch receipt {\n\t\t\t\t\tReceipt::Legacy(d) | Receipt::EIP2930(d) | Receipt::EIP1559(d) => {\n\t\t\t\t\t\td.used_gas.saturating_add(used_gas)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tused_gas\n\t\t\t};\n\t\t\tmatch &transaction {\n\t\t\t\tTransaction::Legacy(_) => Receipt::Legacy(ethereum::EIP658ReceiptData {\n\t\t\t\t\tstatus_code,\n\t\t\t\t\tused_gas: cumulative_gas_used,\n\t\t\t\t\tlogs_bloom,\n\t\t\t\t\tlogs,\n\t\t\t\t}),\n\t\t\t\tTransaction::EIP2930(_) => Receipt::EIP2930(ethereum::EIP2930ReceiptData {\n\t\t\t\t\tstatus_code,\n\t\t\t\t\tused_gas: cumulative_gas_used,\n\t\t\t\t\tlogs_bloom,\n\t\t\t\t\tlogs,\n\t\t\t\t}),\n\t\t\t\tTransaction::EIP1559(_) => Receipt::EIP1559(ethereum::EIP2930ReceiptData {\n\t\t\t\t\tstatus_code,\n\t\t\t\t\tused_gas: cumulative_gas_used,\n\t\t\t\t\tlogs_bloom,\n\t\t\t\t\tlogs,\n\t\t\t\t}),\n\t\t\t}\n\t\t};\n\n\t\tPending::<T>::append((transaction, status, receipt));\n\n\t\tSelf::deposit_event(Event::Executed(\n\t\t\tsource,\n\t\t\tdest.unwrap_or_default(),\n\t\t\ttransaction_hash,\n\t\t\treason,\n\t\t));\n\n\t\tOk(PostDispatchInfo {\n\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\tused_gas.unique_saturated_into(),\n\t\t\t)),\n\t\t\tpays_fee: Pays::No,\n\t\t})\n\t}\n\n\t/// Get the transaction status with given index.\n\tpub fn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {\n\t\tCurrentTransactionStatuses::<T>::get()\n\t}\n\n\t/// Get current block.\n\tpub fn current_block() -> Option<ethereum::BlockV2> {\n\t\tCurrentBlock::<T>::get()\n\t}\n\n\t/// Get current block hash\n\tpub fn current_block_hash() -> Option<H256> {\n\t\tSelf::current_block().map(|block| block.header.hash())\n\t}\n\n\t/// Get receipts by number.\n\tpub fn current_receipts() -> Option<Vec<Receipt>> {\n\t\tCurrentReceipts::<T>::get()\n\t}\n\n\t/// Execute an Ethereum transaction.\n\tpub fn execute(\n\t\tfrom: H160,\n\t\ttransaction: &Transaction,\n\t\tconfig: Option<evm::Config>,\n\t) -> Result<\n\t\t(Option<H160>, Option<H160>, CallOrCreateInfo),\n\t\tDispatchErrorWithPostInfo<PostDispatchInfo>,\n\t> {\n\t\tlet (\n\t\t\tinput,\n\t\t\tvalue,\n\t\t\tgas_limit,\n\t\t\tmax_fee_per_gas,\n\t\t\tmax_priority_fee_per_gas,\n\t\t\tnonce,\n\t\t\taction,\n\t\t\taccess_list,\n\t\t) = {\n\t\t\tmatch transaction {\n\t\t\t\t// max_fee_per_gas and max_priority_fee_per_gas in legacy and 2930 transactions is\n\t\t\t\t// the provided gas_price.\n\t\t\t\tTransaction::Legacy(t) => (\n\t\t\t\t\tt.input.clone(),\n\t\t\t\t\tt.value,\n\t\t\t\t\tt.gas_limit,\n\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\tSome(t.nonce),\n\t\t\t\t\tt.action,\n\t\t\t\t\tVec::new(),\n\t\t\t\t),\n\t\t\t\tTransaction::EIP2930(t) => {\n\t\t\t\t\tlet access_list: Vec<(H160, Vec<H256>)> = t\n\t\t\t\t\t\t.access_list\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys.clone()))\n\t\t\t\t\t\t.collect();\n\t\t\t\t\t(\n\t\t\t\t\t\tt.input.clone(),\n\t\t\t\t\t\tt.value,\n\t\t\t\t\t\tt.gas_limit,\n\t\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\t\tSome(t.gas_price),\n\t\t\t\t\t\tSome(t.nonce),\n\t\t\t\t\t\tt.action,\n\t\t\t\t\t\taccess_list,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tTransaction::EIP1559(t) => {\n\t\t\t\t\tlet access_list: Vec<(H160, Vec<H256>)> = t\n\t\t\t\t\t\t.access_list\n\t\t\t\t\t\t.iter()\n\t\t\t\t\t\t.map(|item| (item.address, item.storage_keys.clone()))\n\t\t\t\t\t\t.collect();\n\t\t\t\t\t(\n\t\t\t\t\t\tt.input.clone(),\n\t\t\t\t\t\tt.value,\n\t\t\t\t\t\tt.gas_limit,\n\t\t\t\t\t\tSome(t.max_fee_per_gas),\n\t\t\t\t\t\tSome(t.max_priority_fee_per_gas),\n\t\t\t\t\t\tSome(t.nonce),\n\t\t\t\t\t\tt.action,\n\t\t\t\t\t\taccess_list,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tlet is_transactional = true;\n\t\tmatch action {\n\t\t\tethereum::TransactionAction::Call(target) => {\n\t\t\t\tlet res = match T::Runner::call(\n\t\t\t\t\tfrom,\n\t\t\t\t\ttarget,\n\t\t\t\t\tinput,\n\t\t\t\t\tvalue,\n\t\t\t\t\tgas_limit.unique_saturated_into(),\n\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\tnonce,\n\t\t\t\t\taccess_list,\n\t\t\t\t\tis_transactional,\n\t\t\t\t\tconfig.as_ref().unwrap_or_else(|| T::config()),\n\t\t\t\t) {\n\t\t\t\t\tOk(res) => res,\n\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tOk((Some(target), None, CallOrCreateInfo::Call(res)))\n\t\t\t}\n\t\t\tethereum::TransactionAction::Create => {\n\t\t\t\tlet res = match T::Runner::create(\n\t\t\t\t\tfrom,\n\t\t\t\t\tinput,\n\t\t\t\t\tvalue,\n\t\t\t\t\tgas_limit.unique_saturated_into(),\n\t\t\t\t\tmax_fee_per_gas,\n\t\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\t\tnonce,\n\t\t\t\t\taccess_list,\n\t\t\t\t\tis_transactional,\n\t\t\t\t\tconfig.as_ref().unwrap_or_else(|| T::config()),\n\t\t\t\t) {\n\t\t\t\t\tOk(res) => res,\n\t\t\t\t\tErr(e) => {\n\t\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tOk((None, Some(res.value), CallOrCreateInfo::Create(res)))\n\t\t\t}\n\t\t}\n\t}\n\n\t/// Validate an Ethereum transaction already in block\n\t///\n\t/// This function must be called during the pre-dispatch phase\n\t/// (just before applying the extrinsic).\n\tpub fn validate_transaction_in_block(\n\t\torigin: H160,\n\t\ttransaction: &Transaction,\n\t) -> Result<(), TransactionValidityError> {\n\t\tlet transaction_data = Pallet::<T>::transaction_data(transaction);\n\t\tlet transaction_nonce = transaction_data.nonce;\n\t\tlet (account_nonce, _) = Self::validate_transaction_common(origin, &transaction_data)?;\n\n\t\t// In the context of the block, a transaction with a nonce that is\n\t\t// too high should be considered invalid and make the whole block invalid.\n\t\tif transaction_nonce > account_nonce {\n\t\t\tErr(TransactionValidityError::Invalid(\n\t\t\t\tInvalidTransaction::Future,\n\t\t\t))\n\t\t} else if transaction_nonce < account_nonce {\n\t\t\tErr(TransactionValidityError::Invalid(InvalidTransaction::Stale))\n\t\t} else {\n\t\t\tOk(())\n\t\t}\n\t}\n\n\tpub fn migrate_block_v0_to_v2() -> Weight {\n\t\tlet db_weights = T::DbWeight::get();\n\t\tlet mut weight: Weight = db_weights.read;\n\t\tlet item = b\"CurrentBlock\";\n\t\tlet block_v0 = frame_support::storage::migration::get_storage_value::<ethereum::BlockV0>(\n\t\t\tSelf::name().as_bytes(),\n\t\t\titem,\n\t\t\t&[],\n\t\t);\n\t\tif let Some(block_v0) = block_v0 {\n\t\t\tweight = weight.saturating_add(db_weights.write);\n\t\t\tlet block_v2: ethereum::BlockV2 = block_v0.into();\n\t\t\tframe_support::storage::migration::put_storage_value::<ethereum::BlockV2>(\n\t\t\t\tSelf::name().as_bytes(),\n\t\t\t\titem,\n\t\t\t\t&[],\n\t\t\t\tblock_v2,\n\t\t\t);\n\t\t}\n\t\tweight\n\t}\n\n\t#[cfg(feature = \"try-runtime\")]\n\tpub fn pre_migrate_block_v2() -> Result<(), &'static str> {\n\t\tlet item = b\"CurrentBlock\";\n\t\tlet block_v0 = frame_support::storage::migration::get_storage_value::<ethereum::BlockV0>(\n\t\t\tSelf::name().as_bytes(),\n\t\t\titem,\n\t\t\t&[],\n\t\t);\n\t\tif let Some(block_v0) = block_v0 {\n\t\t\tSelf::set_temp_storage(block_v0.header.number, \"number\");\n\t\t\tSelf::set_temp_storage(block_v0.header.parent_hash, \"parent_hash\");\n\t\t\tSelf::set_temp_storage(block_v0.transactions.len() as u64, \"transaction_len\");\n\t\t}\n\t\tOk(())\n\t}\n\n\t#[cfg(feature = \"try-runtime\")]\n\tpub fn post_migrate_block_v2() -> Result<(), &'static str> {\n\t\tlet v0_number =\n\t\t\tSelf::get_temp_storage(\"number\").expect(\"We stored a number; it should be there; qed\");\n\t\tlet v0_parent_hash = Self::get_temp_storage(\"parent_hash\")\n\t\t\t.expect(\"We stored a parent hash; it should be there; qed\");\n\t\tlet v0_transaction_len: u64 = Self::get_temp_storage(\"transaction_len\")\n\t\t\t.expect(\"We stored a transaction count; it should be there; qed\");\n\n\t\tlet item = b\"CurrentBlock\";\n\t\tlet block_v2 = frame_support::storage::migration::get_storage_value::<ethereum::BlockV2>(\n\t\t\tSelf::name().as_bytes(),\n\t\t\titem,\n\t\t\t&[],\n\t\t);\n\n\t\tassert!(block_v2.is_some());\n\n\t\tlet block_v2 = block_v2.unwrap();\n\t\tassert_eq!(block_v2.header.number, v0_number);\n\t\tassert_eq!(block_v2.header.parent_hash, v0_parent_hash);\n\t\tassert_eq!(block_v2.transactions.len() as u64, v0_transaction_len);\n\t\tOk(())\n\t}\n}\n\n#[derive(Eq, PartialEq, Clone, RuntimeDebug)]\npub enum ReturnValue {\n\tBytes(Vec<u8>),\n\tHash(H160),\n}\n\npub struct IntermediateStateRoot<T>(PhantomData<T>);\nimpl<T: Config> Get<H256> for IntermediateStateRoot<T> {\n\tfn get() -> H256 {\n\t\tlet version = T::Version::get().state_version();\n\t\tH256::decode(&mut &sp_io::storage::root(version)[..])\n\t\t\t.expect(\"Node is configured to use the same hash; qed\")\n\t}\n}\n\n/// Returns the Ethereum block hash by number.\npub struct EthereumBlockHashMapping<T>(PhantomData<T>);\nimpl<T: Config> BlockHashMapping for EthereumBlockHashMapping<T> {\n\tfn block_hash(number: u32) -> H256 {\n\t\tBlockHash::<T>::get(U256::from(number))\n\t}\n}\n\n#[repr(u8)]\nenum TransactionValidationError {\n\t#[allow(dead_code)]\n\tUnknownError,\n\tInvalidChainId,\n\tInvalidSignature,\n\tInvalidGasLimit,\n\tMaxFeePerGasTooLow,\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! # EVM Pallet\n//!\n//! The EVM pallet allows unmodified EVM code to be executed in a Substrate-based blockchain.\n//! - [`evm::Config`]\n//!\n//! ## EVM Engine\n//!\n//! The EVM pallet uses [`SputnikVM`](https://github.com/rust-blockchain/evm) as the underlying EVM engine.\n//! The engine is overhauled so that it's [`modular`](https://github.com/corepaper/evm).\n//!\n//! ## Execution Lifecycle\n//!\n//! There are a separate set of accounts managed by the EVM pallet. Substrate based accounts can call the EVM Pallet\n//! to deposit or withdraw balance from the Substrate base-currency into a different balance managed and used by\n//! the EVM pallet. Once a user has populated their balance, they can create and call smart contracts using this pallet.\n//!\n//! There's one-to-one mapping from Substrate accounts and EVM external accounts that is defined by a conversion function.\n//!\n//! ## EVM Pallet vs Ethereum Network\n//!\n//! The EVM pallet should be able to produce nearly identical results compared to the Ethereum mainnet,\n//! including gas cost and balance changes.\n//!\n//! Observable differences include:\n//!\n//! - The available length of block hashes may not be 256 depending on the configuration of the System pallet\n//! in the Substrate runtime.\n//! - Difficulty and coinbase, which do not make sense in this pallet and is currently hard coded to zero.\n//!\n//! We currently do not aim to make unobservable behaviors, such as state root, to be the same. We also don't aim to follow\n//! the exact same transaction / receipt format. However, given one Ethereum transaction and one Substrate account's\n//! private key, one should be able to convert any Ethereum transaction into a transaction compatible with this pallet.\n//!\n//! The gas configurations are configurable. Right now, a pre-defined London hard fork configuration option is provided.\n\n// Ensure we're `no_std` when compiling for Wasm.\n#![cfg_attr(not(feature = \"std\"), no_std)]\n#![allow(clippy::too_many_arguments)]\n\n#[cfg(feature = \"runtime-benchmarks\")]\npub mod benchmarking;\n\n#[cfg(test)]\nmod mock;\npub mod runner;\n#[cfg(test)]\nmod tests;\n\nuse frame_support::{\n\tdispatch::DispatchResultWithPostInfo,\n\ttraits::{\n\t\ttokens::fungible::Inspect, Currency, ExistenceRequirement, FindAuthor, Get, Imbalance,\n\t\tOnUnbalanced, SignedImbalance, WithdrawReasons,\n\t},\n\tweights::{Pays, PostDispatchInfo, Weight},\n};\nuse frame_system::RawOrigin;\nuse sp_core::{Hasher, H160, H256, U256};\nuse sp_runtime::{\n\ttraits::{BadOrigin, Saturating, UniqueSaturatedInto, Zero},\n\tAccountId32, DispatchErrorWithPostInfo,\n};\nuse sp_std::{cmp::min, vec::Vec};\n\npub use evm::{\n\tConfig as EvmConfig, Context, ExitError, ExitFatal, ExitReason, ExitRevert, ExitSucceed,\n};\n#[cfg(feature = \"std\")]\nuse fp_evm::GenesisAccount;\npub use fp_evm::{\n\tAccount, CallInfo, CreateInfo, ExecutionInfo, FeeCalculator, LinearCostPrecompile, Log,\n\tPrecompile, PrecompileFailure, PrecompileHandle, PrecompileOutput, PrecompileResult,\n\tPrecompileSet, Vicinity,\n};\n\npub use self::{\n\tpallet::*,\n\trunner::{Runner, RunnerError},\n};\n\n#[frame_support::pallet]\npub mod pallet {\n\tuse super::*;\n\tuse frame_support::pallet_prelude::*;\n\tuse frame_system::pallet_prelude::*;\n\n\t#[pallet::pallet]\n\t#[pallet::generate_store(pub(super) trait Store)]\n\t#[pallet::without_storage_info]\n\tpub struct Pallet<T>(_);\n\n\t#[pallet::config]\n\tpub trait Config: frame_system::Config + pallet_timestamp::Config {\n\t\t/// Calculator for current gas price.\n\t\ttype FeeCalculator: FeeCalculator;\n\n\t\t/// Maps Ethereum gas to Substrate weight.\n\t\ttype GasWeightMapping: GasWeightMapping;\n\n\t\t/// Block number to block hash.\n\t\ttype BlockHashMapping: BlockHashMapping;\n\n\t\t/// Allow the origin to call on behalf of given address.\n\t\ttype CallOrigin: EnsureAddressOrigin<Self::Origin>;\n\t\t/// Allow the origin to withdraw on behalf of given address.\n\t\ttype WithdrawOrigin: EnsureAddressOrigin<Self::Origin, Success = Self::AccountId>;\n\n\t\t/// Mapping from address to account id.\n\t\ttype AddressMapping: AddressMapping<Self::AccountId>;\n\t\t/// Currency type for withdraw and balance storage.\n\t\ttype Currency: Currency<Self::AccountId> + Inspect<Self::AccountId>;\n\n\t\t/// The overarching event type.\n\t\ttype Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;\n\t\t/// Precompiles associated with this EVM engine.\n\t\ttype PrecompilesType: PrecompileSet;\n\t\ttype PrecompilesValue: Get<Self::PrecompilesType>;\n\t\t/// Chain ID of EVM.\n\t\ttype ChainId: Get<u64>;\n\t\t/// The block gas limit. Can be a simple constant, or an adjustment algorithm in another pallet.\n\t\ttype BlockGasLimit: Get<U256>;\n\t\t/// EVM execution runner.\n\t\ttype Runner: Runner<Self>;\n\n\t\t/// To handle fee deduction for EVM transactions. An example is this pallet being used by `pallet_ethereum`\n\t\t/// where the chain implementing `pallet_ethereum` should be able to configure what happens to the fees\n\t\t/// Similar to `OnChargeTransaction` of `pallet_transaction_payment`\n\t\ttype OnChargeTransaction: OnChargeEVMTransaction<Self>;\n\n\t\t/// Find author for the current block.\n\t\ttype FindAuthor: FindAuthor<H160>;\n\n\t\t/// EVM config used in the module.\n\t\tfn config() -> &'static EvmConfig {\n\t\t\t&LONDON_CONFIG\n\t\t}\n\t}\n\n\t#[pallet::call]\n\timpl<T: Config> Pallet<T> {\n\t\t/// Withdraw balance from EVM into currency/balances pallet.\n\t\t#[pallet::weight(0)]\n\t\tpub fn withdraw(\n\t\t\torigin: OriginFor<T>,\n\t\t\taddress: H160,\n\t\t\tvalue: BalanceOf<T>,\n\t\t) -> DispatchResult {\n\t\t\tlet destination = T::WithdrawOrigin::ensure_address_origin(&address, origin)?;\n\t\t\tlet address_account_id = T::AddressMapping::into_account_id(address);\n\n\t\t\tT::Currency::transfer(\n\t\t\t\t&address_account_id,\n\t\t\t\t&destination,\n\t\t\t\tvalue,\n\t\t\t\tExistenceRequirement::AllowDeath,\n\t\t\t)?;\n\n\t\t\tOk(())\n\t\t}\n\n\t\t/// Issue an EVM call operation. This is similar to a message call transaction in Ethereum.\n\t\t#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]\n\t\tpub fn call(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\ttarget: H160,\n\t\t\tinput: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\n\t\t\tlet is_transactional = true;\n\t\t\tlet info = match T::Runner::call(\n\t\t\t\tsource,\n\t\t\t\ttarget,\n\t\t\t\tinput,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch info.exit_reason {\n\t\t\t\tExitReason::Succeed(_) => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Executed(target));\n\t\t\t\t}\n\t\t\t\t_ => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::ExecutedFailed(target));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\tinfo.used_gas.unique_saturated_into(),\n\t\t\t\t)),\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\n\t\t/// Issue an EVM create operation. This is similar to a contract creation transaction in\n\t\t/// Ethereum.\n\t\t#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]\n\t\tpub fn create(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\tinit: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\n\t\t\tlet is_transactional = true;\n\t\t\tlet info = match T::Runner::create(\n\t\t\t\tsource,\n\t\t\t\tinit,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch info {\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: ExitReason::Succeed(_),\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Created(create_address));\n\t\t\t\t}\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: _,\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::CreatedFailed(create_address));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\tinfo.used_gas.unique_saturated_into(),\n\t\t\t\t)),\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\n\t\t/// Issue an EVM create2 operation.\n\t\t#[pallet::weight(T::GasWeightMapping::gas_to_weight(*gas_limit))]\n\t\tpub fn create2(\n\t\t\torigin: OriginFor<T>,\n\t\t\tsource: H160,\n\t\t\tinit: Vec<u8>,\n\t\t\tsalt: H256,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: u64,\n\t\t\tmax_fee_per_gas: U256,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\t) -> DispatchResultWithPostInfo {\n\t\t\tT::CallOrigin::ensure_address_origin(&source, origin)?;\n\n\t\t\tlet is_transactional = true;\n\t\t\tlet info = match T::Runner::create2(\n\t\t\t\tsource,\n\t\t\t\tinit,\n\t\t\t\tsalt,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit,\n\t\t\t\tSome(max_fee_per_gas),\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list,\n\t\t\t\tis_transactional,\n\t\t\t\tT::config(),\n\t\t\t) {\n\t\t\t\tOk(info) => info,\n\t\t\t\tErr(e) => {\n\t\t\t\t\treturn Err(DispatchErrorWithPostInfo {\n\t\t\t\t\t\tpost_info: PostDispatchInfo {\n\t\t\t\t\t\t\tactual_weight: Some(e.weight),\n\t\t\t\t\t\t\tpays_fee: Pays::Yes,\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: e.error.into(),\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmatch info {\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: ExitReason::Succeed(_),\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::Created(create_address));\n\t\t\t\t}\n\t\t\t\tCreateInfo {\n\t\t\t\t\texit_reason: _,\n\t\t\t\t\tvalue: create_address,\n\t\t\t\t\t..\n\t\t\t\t} => {\n\t\t\t\t\tPallet::<T>::deposit_event(Event::<T>::CreatedFailed(create_address));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tOk(PostDispatchInfo {\n\t\t\t\tactual_weight: Some(T::GasWeightMapping::gas_to_weight(\n\t\t\t\t\tinfo.used_gas.unique_saturated_into(),\n\t\t\t\t)),\n\t\t\t\tpays_fee: Pays::No,\n\t\t\t})\n\t\t}\n\t}\n\n\t#[pallet::event]\n\t#[pallet::generate_deposit(pub(super) fn deposit_event)]\n\tpub enum Event<T: Config> {\n\t\t/// Ethereum events from contracts.\n\t\tLog(Log),\n\t\t/// A contract has been created at given \\[address\\].\n\t\tCreated(H160),\n\t\t/// A \\[contract\\] was attempted to be created, but the execution failed.\n\t\tCreatedFailed(H160),\n\t\t/// A \\[contract\\] has been executed successfully with states applied.\n\t\tExecuted(H160),\n\t\t/// A \\[contract\\] has been executed with errors. States are reverted with only gas fees applied.\n\t\tExecutedFailed(H160),\n\t\t/// A deposit has been made at a given address. \\[sender, address, value\\]\n\t\tBalanceDeposit(T::AccountId, H160, U256),\n\t\t/// A withdrawal has been made from a given address. \\[sender, address, value\\]\n\t\tBalanceWithdraw(T::AccountId, H160, U256),\n\t}\n\n\t#[pallet::error]\n\tpub enum Error<T> {\n\t\t/// Not enough balance to perform action\n\t\tBalanceLow,\n\t\t/// Calculating total fee overflowed\n\t\tFeeOverflow,\n\t\t/// Calculating total payment overflowed\n\t\tPaymentOverflow,\n\t\t/// Withdraw fee failed\n\t\tWithdrawFailed,\n\t\t/// Gas price is too low.\n\t\tGasPriceTooLow,\n\t\t/// Nonce is invalid\n\t\tInvalidNonce,\n\t}\n\n\t#[pallet::genesis_config]\n\t#[cfg_attr(feature = \"std\", derive(Default))]\n\tpub struct GenesisConfig {\n\t\tpub accounts: std::collections::BTreeMap<H160, GenesisAccount>,\n\t}\n\n\t#[pallet::genesis_build]\n\timpl<T: Config> GenesisBuild<T> for GenesisConfig\n\twhere\n\t\tU256: UniqueSaturatedInto<BalanceOf<T>>,\n\t{\n\t\tfn build(&self) {\n\t\t\tconst MAX_ACCOUNT_NONCE: usize = 100;\n\n\t\t\tfor (address, account) in &self.accounts {\n\t\t\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\n\t\t\t\t// ASSUME: in one single EVM transaction, the nonce will not increase more than\n\t\t\t\t// `u128::max_value()`.\n\t\t\t\tfor _ in 0..min(\n\t\t\t\t\tMAX_ACCOUNT_NONCE,\n\t\t\t\t\tUniqueSaturatedInto::<usize>::unique_saturated_into(account.nonce),\n\t\t\t\t) {\n\t\t\t\t\tframe_system::Pallet::<T>::inc_account_nonce(&account_id);\n\t\t\t\t}\n\n\t\t\t\tT::Currency::deposit_creating(&account_id, account.balance.unique_saturated_into());\n\n\t\t\t\tPallet::<T>::create_account(*address, account.code.clone());\n\n\t\t\t\tfor (index, value) in &account.storage {\n\t\t\t\t\t<AccountStorages<T>>::insert(address, index, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t#[pallet::storage]\n\t#[pallet::getter(fn account_codes)]\n\tpub type AccountCodes<T: Config> = StorageMap<_, Blake2_128Concat, H160, Vec<u8>, ValueQuery>;\n\n\t#[pallet::storage]\n\t#[pallet::getter(fn account_storages)]\n\tpub type AccountStorages<T: Config> =\n\t\tStorageDoubleMap<_, Blake2_128Concat, H160, Blake2_128Concat, H256, H256, ValueQuery>;\n}\n\n/// Type alias for currency balance.\npub type BalanceOf<T> =\n\t<<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;\n\n/// Type alias for negative imbalance during fees\ntype NegativeImbalanceOf<C, T> =\n\t<C as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance;\n\npub trait EnsureAddressOrigin<OuterOrigin> {\n\t/// Success return type.\n\ttype Success;\n\n\t/// Perform the origin check.\n\tfn ensure_address_origin(\n\t\taddress: &H160,\n\t\torigin: OuterOrigin,\n\t) -> Result<Self::Success, BadOrigin> {\n\t\tSelf::try_address_origin(address, origin).map_err(|_| BadOrigin)\n\t}\n\n\t/// Try with origin.\n\tfn try_address_origin(\n\t\taddress: &H160,\n\t\torigin: OuterOrigin,\n\t) -> Result<Self::Success, OuterOrigin>;\n}\n\n/// Ensure that the EVM address is the same as the Substrate address. This only works if the account\n/// ID is `H160`.\npub struct EnsureAddressSame;\n\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressSame\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<H160>, OuterOrigin>> + From<RawOrigin<H160>>,\n{\n\ttype Success = H160;\n\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<H160, OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if &who == address => Ok(who),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\n/// Ensure that the origin is root.\npub struct EnsureAddressRoot<AccountId>(sp_std::marker::PhantomData<AccountId>);\n\nimpl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressRoot<AccountId>\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId>, OuterOrigin>> + From<RawOrigin<AccountId>>,\n{\n\ttype Success = ();\n\n\tfn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<(), OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Root => Ok(()),\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\n/// Ensure that the origin never happens.\npub struct EnsureAddressNever<AccountId>(sp_std::marker::PhantomData<AccountId>);\n\nimpl<OuterOrigin, AccountId> EnsureAddressOrigin<OuterOrigin> for EnsureAddressNever<AccountId> {\n\ttype Success = AccountId;\n\n\tfn try_address_origin(_address: &H160, origin: OuterOrigin) -> Result<AccountId, OuterOrigin> {\n\t\tErr(origin)\n\t}\n}\n\n/// Ensure that the address is truncated hash of the origin. Only works if the account id is\n/// `AccountId32`.\npub struct EnsureAddressTruncated;\n\nimpl<OuterOrigin> EnsureAddressOrigin<OuterOrigin> for EnsureAddressTruncated\nwhere\n\tOuterOrigin: Into<Result<RawOrigin<AccountId32>, OuterOrigin>> + From<RawOrigin<AccountId32>>,\n{\n\ttype Success = AccountId32;\n\n\tfn try_address_origin(address: &H160, origin: OuterOrigin) -> Result<AccountId32, OuterOrigin> {\n\t\torigin.into().and_then(|o| match o {\n\t\t\tRawOrigin::Signed(who) if AsRef::<[u8; 32]>::as_ref(&who)[0..20] == address[0..20] => {\n\t\t\t\tOk(who)\n\t\t\t}\n\t\t\tr => Err(OuterOrigin::from(r)),\n\t\t})\n\t}\n}\n\npub trait AddressMapping<A> {\n\tfn into_account_id(address: H160) -> A;\n}\n\n/// Identity address mapping.\npub struct IdentityAddressMapping;\n\nimpl AddressMapping<H160> for IdentityAddressMapping {\n\tfn into_account_id(address: H160) -> H160 {\n\t\taddress\n\t}\n}\n\n/// Hashed address mapping.\npub struct HashedAddressMapping<H>(sp_std::marker::PhantomData<H>);\n\nimpl<H: Hasher<Out = H256>> AddressMapping<AccountId32> for HashedAddressMapping<H> {\n\tfn into_account_id(address: H160) -> AccountId32 {\n\t\tlet mut data = [0u8; 24];\n\t\tdata[0..4].copy_from_slice(b\"evm:\");\n\t\tdata[4..24].copy_from_slice(&address[..]);\n\t\tlet hash = H::hash(&data);\n\n\t\tAccountId32::from(Into::<[u8; 32]>::into(hash))\n\t}\n}\n\n/// A trait for getting a block hash by number.\npub trait BlockHashMapping {\n\tfn block_hash(number: u32) -> H256;\n}\n\n/// Returns the Substrate block hash by number.\npub struct SubstrateBlockHashMapping<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Config> BlockHashMapping for SubstrateBlockHashMapping<T> {\n\tfn block_hash(number: u32) -> H256 {\n\t\tlet number = T::BlockNumber::from(number);\n\t\tH256::from_slice(frame_system::Pallet::<T>::block_hash(number).as_ref())\n\t}\n}\n\n/// A mapping function that converts Ethereum gas to Substrate weight\npub trait GasWeightMapping {\n\tfn gas_to_weight(gas: u64) -> Weight;\n\tfn weight_to_gas(weight: Weight) -> u64;\n}\n\nimpl GasWeightMapping for () {\n\tfn gas_to_weight(gas: u64) -> Weight {\n\t\tgas as Weight\n\t}\n\tfn weight_to_gas(weight: Weight) -> u64 {\n\t\tweight as u64\n\t}\n}\n\nstatic LONDON_CONFIG: EvmConfig = EvmConfig::london();\n\nimpl<T: Config> Pallet<T> {\n\t/// Check whether an account is empty.\n\tpub fn is_account_empty(address: &H160) -> bool {\n\t\tlet (account, _) = Self::account_basic(address);\n\t\tlet code_len = <AccountCodes<T>>::decode_len(address).unwrap_or(0);\n\n\t\taccount.nonce == U256::zero() && account.balance == U256::zero() && code_len == 0\n\t}\n\n\t/// Remove an account if its empty.\n\tpub fn remove_account_if_empty(address: &H160) {\n\t\tif Self::is_account_empty(address) {\n\t\t\tSelf::remove_account(address);\n\t\t}\n\t}\n\n\t/// Remove an account.\n\tpub fn remove_account(address: &H160) {\n\t\tif <AccountCodes<T>>::contains_key(address) {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\t\t\tlet _ = frame_system::Pallet::<T>::dec_sufficients(&account_id);\n\t\t}\n\n\t\t<AccountCodes<T>>::remove(address);\n\t\tlet _ = <AccountStorages<T>>::remove_prefix(address, None);\n\t}\n\n\t/// Create an account.\n\tpub fn create_account(address: H160, code: Vec<u8>) {\n\t\tif code.is_empty() {\n\t\t\treturn;\n\t\t}\n\n\t\tif !<AccountCodes<T>>::contains_key(&address) {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(address);\n\t\t\tlet _ = frame_system::Pallet::<T>::inc_sufficients(&account_id);\n\t\t}\n\n\t\t<AccountCodes<T>>::insert(address, code);\n\t}\n\n\t/// Get the account basic in EVM format.\n\tpub fn account_basic(address: &H160) -> (Account, frame_support::weights::Weight) {\n\t\tlet account_id = T::AddressMapping::into_account_id(*address);\n\n\t\tlet nonce = frame_system::Pallet::<T>::account_nonce(&account_id);\n\t\t// keepalive `true` takes into account ExistentialDeposit as part of what's considered liquid balance.\n\t\tlet balance = T::Currency::reducible_balance(&account_id, true);\n\n\t\t(\n\t\t\tAccount {\n\t\t\t\tnonce: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(nonce)),\n\t\t\t\tbalance: U256::from(UniqueSaturatedInto::<u128>::unique_saturated_into(balance)),\n\t\t\t},\n\t\t\tT::DbWeight::get().reads(2),\n\t\t)\n\t}\n\n\t/// Get the author using the FindAuthor trait.\n\tpub fn find_author() -> H160 {\n\t\tlet digest = <frame_system::Pallet<T>>::digest();\n\t\tlet pre_runtime_digests = digest.logs.iter().filter_map(|d| d.as_pre_runtime());\n\n\t\tT::FindAuthor::find_author(pre_runtime_digests).unwrap_or_default()\n\t}\n}\n\n/// Handle withdrawing, refunding and depositing of transaction fees.\n/// Similar to `OnChargeTransaction` of `pallet_transaction_payment`\npub trait OnChargeEVMTransaction<T: Config> {\n\ttype LiquidityInfo: Default;\n\n\t/// Before the transaction is executed the payment of the transaction fees\n\t/// need to be secured.\n\tfn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>>;\n\n\t/// After the transaction was executed the actual fee can be calculated.\n\t/// This function should refund any overpaid fees and optionally deposit\n\t/// the corrected amount, and handles the base fee rationing using the provided\n\t/// `OnUnbalanced` implementation.\n\t/// Returns the `NegativeImbalance` - if any - produced by the priority fee.\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo;\n\n\t/// Introduced in EIP1559 to handle the priority tip.\n\tfn pay_priority_fee(tip: Self::LiquidityInfo);\n}\n\n/// Implements the transaction payment for a pallet implementing the `Currency`\n/// trait (eg. the pallet_balances) using an unbalance handler (implementing\n/// `OnUnbalanced`).\n/// Similar to `CurrencyAdapter` of `pallet_transaction_payment`\npub struct EVMCurrencyAdapter<C, OU>(sp_std::marker::PhantomData<(C, OU)>);\n\nimpl<T, C, OU> OnChargeEVMTransaction<T> for EVMCurrencyAdapter<C, OU>\nwhere\n\tT: Config,\n\tC: Currency<<T as frame_system::Config>::AccountId>,\n\tC::PositiveImbalance: Imbalance<\n\t\t<C as Currency<<T as frame_system::Config>::AccountId>>::Balance,\n\t\tOpposite = C::NegativeImbalance,\n\t>,\n\tC::NegativeImbalance: Imbalance<\n\t\t<C as Currency<<T as frame_system::Config>::AccountId>>::Balance,\n\t\tOpposite = C::PositiveImbalance,\n\t>,\n\tOU: OnUnbalanced<NegativeImbalanceOf<C, T>>,\n\tU256: UniqueSaturatedInto<<C as Currency<<T as frame_system::Config>::AccountId>>::Balance>,\n{\n\t// Kept type as Option to satisfy bound of Default\n\ttype LiquidityInfo = Option<NegativeImbalanceOf<C, T>>;\n\n\tfn withdraw_fee(who: &H160, fee: U256) -> Result<Self::LiquidityInfo, Error<T>> {\n\t\tif fee.is_zero() {\n\t\t\treturn Ok(None);\n\t\t}\n\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\t\tlet imbalance = C::withdraw(\n\t\t\t&account_id,\n\t\t\tfee.unique_saturated_into(),\n\t\t\tWithdrawReasons::FEE,\n\t\t\tExistenceRequirement::AllowDeath,\n\t\t)\n\t\t.map_err(|_| Error::<T>::BalanceLow)?;\n\t\tOk(Some(imbalance))\n\t}\n\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo {\n\t\tif let Some(paid) = already_withdrawn {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(*who);\n\n\t\t\t// Calculate how much refund we should return\n\t\t\tlet refund_amount = paid\n\t\t\t\t.peek()\n\t\t\t\t.saturating_sub(corrected_fee.unique_saturated_into());\n\t\t\t// refund to the account that paid the fees. If this fails, the\n\t\t\t// account might have dropped below the existential balance. In\n\t\t\t// that case we don't refund anything.\n\t\t\tlet refund_imbalance = C::deposit_into_existing(&account_id, refund_amount)\n\t\t\t\t.unwrap_or_else(|_| C::PositiveImbalance::zero());\n\n\t\t\t// Make sure this works with 0 ExistentialDeposit\n\t\t\t// https://github.com/paritytech/substrate/issues/10117\n\t\t\t// If we tried to refund something, the account still empty and the ED is set to 0,\n\t\t\t// we call `make_free_balance_be` with the refunded amount.\n\t\t\tlet refund_imbalance = if C::minimum_balance().is_zero()\n\t\t\t\t&& refund_amount > C::Balance::zero()\n\t\t\t\t&& C::total_balance(&account_id).is_zero()\n\t\t\t{\n\t\t\t\t// Known bug: Substrate tried to refund to a zeroed AccountData, but\n\t\t\t\t// interpreted the account to not exist.\n\t\t\t\tmatch C::make_free_balance_be(&account_id, refund_amount) {\n\t\t\t\t\tSignedImbalance::Positive(p) => p,\n\t\t\t\t\t_ => C::PositiveImbalance::zero(),\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trefund_imbalance\n\t\t\t};\n\n\t\t\t// merge the imbalance caused by paying the fees and refunding parts of it again.\n\t\t\tlet adjusted_paid = paid\n\t\t\t\t.offset(refund_imbalance)\n\t\t\t\t.same()\n\t\t\t\t.unwrap_or_else(|_| C::NegativeImbalance::zero());\n\n\t\t\tlet (base_fee, tip) = adjusted_paid.split(base_fee.unique_saturated_into());\n\t\t\t// Handle base fee. Can be either burned, rationed, etc ...\n\t\t\tOU::on_unbalanced(base_fee);\n\t\t\treturn Some(tip);\n\t\t}\n\t\tNone\n\t}\n\n\tfn pay_priority_fee(tip: Self::LiquidityInfo) {\n\t\t// Default Ethereum behaviour: issue the tip to the block author.\n\t\tif let Some(tip) = tip {\n\t\t\tlet account_id = T::AddressMapping::into_account_id(<Pallet<T>>::find_author());\n\t\t\tlet _ = C::deposit_into_existing(&account_id, tip.peek());\n\t\t}\n\t}\n}\n\n/// Implementation for () does not specify what to do with imbalance\nimpl<T> OnChargeEVMTransaction<T> for ()\n\twhere\n\tT: Config,\n\t<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::PositiveImbalance:\n\t\tImbalance<<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance, Opposite = <T::Currency as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance>,\n\t<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::NegativeImbalance:\nImbalance<<T::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance, Opposite = <T::Currency as Currency<<T as frame_system::Config>::AccountId>>::PositiveImbalance>,\nU256: UniqueSaturatedInto<BalanceOf<T>>,\n\n{\n\t// Kept type as Option to satisfy bound of Default\n\ttype LiquidityInfo = Option<NegativeImbalanceOf<T::Currency, T>>;\n\n\tfn withdraw_fee(\n\t\twho: &H160,\n\t\tfee: U256,\n\t) -> Result<Self::LiquidityInfo, Error<T>> {\n\t\tEVMCurrencyAdapter::<<T as Config>::Currency, ()>::withdraw_fee(who, fee)\n\t}\n\n\tfn correct_and_deposit_fee(\n\t\twho: &H160,\n\t\tcorrected_fee: U256,\n\t\tbase_fee: U256,\n\t\talready_withdrawn: Self::LiquidityInfo,\n\t) -> Self::LiquidityInfo {\n\t\t<EVMCurrencyAdapter::<<T as Config>::Currency, ()> as OnChargeEVMTransaction<T>>::correct_and_deposit_fee(who, corrected_fee, base_fee, already_withdrawn)\n\t}\n\n\tfn pay_priority_fee(tip: Self::LiquidityInfo) {\n\t\t<EVMCurrencyAdapter::<<T as Config>::Currency, ()> as OnChargeEVMTransaction<T>>::pay_priority_fee(tip);\n\t}\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//! EVM stack-based runner.\n\nuse crate::{\n\trunner::Runner as RunnerT, AccountCodes, AccountStorages, AddressMapping, BalanceOf,\n\tBlockHashMapping, Config, Error, Event, FeeCalculator, OnChargeEVMTransaction, Pallet,\n\tRunnerError,\n};\nuse evm::{\n\tbackend::Backend as BackendT,\n\texecutor::stack::{Accessed, StackExecutor, StackState as StackStateT, StackSubstateMetadata},\n\tExitError, ExitReason, Transfer,\n};\nuse fp_evm::{CallInfo, CreateInfo, ExecutionInfo, Log, Vicinity};\nuse frame_support::{\n\tensure,\n\ttraits::{Currency, ExistenceRequirement, Get},\n};\nuse sha3::{Digest, Keccak256};\nuse sp_core::{H160, H256, U256};\nuse sp_runtime::traits::UniqueSaturatedInto;\nuse sp_std::{boxed::Box, collections::btree_set::BTreeSet, marker::PhantomData, mem, vec::Vec};\n\n#[derive(Default)]\npub struct Runner<T: Config> {\n\t_marker: PhantomData<T>,\n}\n\nimpl<T: Config> Runner<T>\nwhere\n\tBalanceOf<T>: TryFrom<U256> + Into<U256>,\n{\n\t/// Execute an already validated EVM operation.\n\tpub fn execute<'config, 'precompiles, F, R>(\n\t\tsource: H160,\n\t\tvalue: U256,\n\t\tgas_limit: u64,\n\t\tmax_fee_per_gas: Option<U256>,\n\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\tnonce: Option<U256>,\n\t\tconfig: &'config evm::Config,\n\t\tprecompiles: &'precompiles T::PrecompilesType,\n\t\tis_transactional: bool,\n\t\tf: F,\n\t) -> Result<ExecutionInfo<R>, RunnerError<Error<T>>>\n\twhere\n\t\tF: FnOnce(\n\t\t\t&mut StackExecutor<\n\t\t\t\t'config,\n\t\t\t\t'precompiles,\n\t\t\t\tSubstrateStackState<'_, 'config, T>,\n\t\t\t\tT::PrecompilesType,\n\t\t\t>,\n\t\t) -> (ExitReason, R),\n\t{\n\t\tlet (base_fee, mut weight) = T::FeeCalculator::min_gas_price();\n\t\tlet max_fee_per_gas = match (max_fee_per_gas, is_transactional) {\n\t\t\t(Some(max_fee_per_gas), _) => {\n\t\t\t\tensure!(\n\t\t\t\t\tmax_fee_per_gas >= base_fee,\n\t\t\t\t\tRunnerError {\n\t\t\t\t\t\terror: Error::<T>::GasPriceTooLow,\n\t\t\t\t\t\tweight,\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tmax_fee_per_gas\n\t\t\t}\n\t\t\t// Gas price check is skipped for non-transactional calls that don't\n\t\t\t// define a `max_fee_per_gas` input.\n\t\t\t(None, false) => Default::default(),\n\t\t\t_ => {\n\t\t\t\treturn Err(RunnerError {\n\t\t\t\t\terror: Error::<T>::GasPriceTooLow,\n\t\t\t\t\tweight,\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\n\t\tif let Some(max_priority_fee) = max_priority_fee_per_gas {\n\t\t\tensure!(\n\t\t\t\tmax_fee_per_gas >= max_priority_fee,\n\t\t\t\tRunnerError {\n\t\t\t\t\terror: Error::<T>::GasPriceTooLow,\n\t\t\t\t\tweight,\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t// After eip-1559 we make sure the account can pay both the evm execution and priority fees.\n\t\tlet total_fee = max_fee_per_gas\n\t\t\t.checked_mul(U256::from(gas_limit))\n\t\t\t.ok_or(RunnerError {\n\t\t\t\terror: Error::<T>::FeeOverflow,\n\t\t\t\tweight,\n\t\t\t})?;\n\n\t\tlet total_payment = value.checked_add(total_fee).ok_or(RunnerError {\n\t\t\terror: Error::<T>::PaymentOverflow,\n\t\t\tweight,\n\t\t})?;\n\t\tlet (source_account, inner_weight) = Pallet::<T>::account_basic(&source);\n\t\tweight = weight.saturating_add(inner_weight);\n\t\t// Account balance check is skipped if fee is Zero.\n\t\t// This case is previously verified to only happen on either:\n\t\t// \t- Non-transactional calls.\n\t\t//\t- BaseFee is configured to be Zero.\n\t\tif total_fee > U256::zero() {\n\t\t\tensure!(\n\t\t\t\tsource_account.balance >= total_payment,\n\t\t\t\tRunnerError {\n\t\t\t\t\terror: Error::<T>::BalanceLow,\n\t\t\t\t\tweight,\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif let Some(nonce) = nonce {\n\t\t\tensure!(\n\t\t\t\tsource_account.nonce == nonce,\n\t\t\t\tRunnerError {\n\t\t\t\t\terror: Error::<T>::InvalidNonce,\n\t\t\t\t\tweight,\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t// Deduct fee from the `source` account. Returns `None` if `total_fee` is Zero.\n\t\tlet fee = T::OnChargeTransaction::withdraw_fee(&source, total_fee)\n\t\t\t.map_err(|e| RunnerError { error: e, weight })?;\n\n\t\t// Execute the EVM call.\n\t\tlet vicinity = Vicinity {\n\t\t\tgas_price: base_fee,\n\t\t\torigin: source,\n\t\t};\n\n\t\tlet metadata = StackSubstateMetadata::new(gas_limit, config);\n\t\tlet state = SubstrateStackState::new(&vicinity, metadata);\n\t\tlet mut executor = StackExecutor::new_with_precompiles(state, config, precompiles);\n\n\t\tlet (reason, retv) = f(&mut executor);\n\n\t\t// Post execution.\n\t\tlet used_gas = U256::from(executor.used_gas());\n\t\tlet actual_fee = if let Some(max_priority_fee) = max_priority_fee_per_gas {\n\t\t\tlet actual_priority_fee = max_fee_per_gas\n\t\t\t\t.saturating_sub(base_fee)\n\t\t\t\t.min(max_priority_fee)\n\t\t\t\t.saturating_mul(used_gas);\n\t\t\texecutor\n\t\t\t\t.fee(base_fee)\n\t\t\t\t.checked_add(actual_priority_fee)\n\t\t\t\t.unwrap_or_else(U256::max_value)\n\t\t} else {\n\t\t\texecutor.fee(base_fee)\n\t\t};\n\t\tlog::debug!(\n\t\t\ttarget: \"evm\",\n\t\t\t\"Execution {:?} [source: {:?}, value: {}, gas_limit: {}, actual_fee: {}, is_transactional: {}]\",\n\t\t\treason,\n\t\t\tsource,\n\t\t\tvalue,\n\t\t\tgas_limit,\n\t\t\tactual_fee,\n\t\t\tis_transactional\n\t\t);\n\t\t// The difference between initially withdrawn and the actual cost is refunded.\n\t\t//\n\t\t// Considered the following request:\n\t\t// +-----------+---------+--------------+\n\t\t// | Gas_limit | Max_Fee | Max_Priority |\n\t\t// +-----------+---------+--------------+\n\t\t// |        20 |      10 |            6 |\n\t\t// +-----------+---------+--------------+\n\t\t//\n\t\t// And execution:\n\t\t// +----------+----------+\n\t\t// | Gas_used | Base_Fee |\n\t\t// +----------+----------+\n\t\t// |        5 |        2 |\n\t\t// +----------+----------+\n\t\t//\n\t\t// Initially withdrawn 10 * 20 = 200.\n\t\t// Actual cost (2 + 6) * 5 = 40.\n\t\t// Refunded 200 - 40 = 160.\n\t\t// Tip 5 * 6 = 30.\n\t\t// Burned 200 - (160 + 30) = 10. Which is equivalent to gas_used * base_fee.\n\t\tlet actual_priority_fee = T::OnChargeTransaction::correct_and_deposit_fee(\n\t\t\t&source,\n\t\t\t// Actual fee after evm execution, including tip.\n\t\t\tactual_fee,\n\t\t\t// Base fee.\n\t\t\texecutor.fee(base_fee),\n\t\t\t// Fee initially withdrawn.\n\t\t\tfee,\n\t\t);\n\t\tT::OnChargeTransaction::pay_priority_fee(actual_priority_fee);\n\n\t\tlet state = executor.into_state();\n\n\t\tfor address in state.substate.deletes {\n\t\t\tlog::debug!(\n\t\t\t\ttarget: \"evm\",\n\t\t\t\t\"Deleting account at {:?}\",\n\t\t\t\taddress\n\t\t\t);\n\t\t\tPallet::<T>::remove_account(&address)\n\t\t}\n\n\t\tfor log in &state.substate.logs {\n\t\t\tlog::trace!(\n\t\t\t\ttarget: \"evm\",\n\t\t\t\t\"Inserting log for {:?}, topics ({}) {:?}, data ({}): {:?}]\",\n\t\t\t\tlog.address,\n\t\t\t\tlog.topics.len(),\n\t\t\t\tlog.topics,\n\t\t\t\tlog.data.len(),\n\t\t\t\tlog.data\n\t\t\t);\n\t\t\tPallet::<T>::deposit_event(Event::<T>::Log(Log {\n\t\t\t\taddress: log.address,\n\t\t\t\ttopics: log.topics.clone(),\n\t\t\t\tdata: log.data.clone(),\n\t\t\t}));\n\t\t}\n\n\t\tOk(ExecutionInfo {\n\t\t\tvalue: retv,\n\t\t\texit_reason: reason,\n\t\t\tused_gas,\n\t\t\tlogs: state.substate.logs,\n\t\t})\n\t}\n}\n\nimpl<T: Config> RunnerT<T> for Runner<T>\nwhere\n\tBalanceOf<T>: TryFrom<U256> + Into<U256>,\n{\n\ttype Error = Error<T>;\n\n\tfn call(\n\t\tsource: H160,\n\t\ttarget: H160,\n\t\tinput: Vec<u8>,\n\t\tvalue: U256,\n\t\tgas_limit: u64,\n\t\tmax_fee_per_gas: Option<U256>,\n\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\tnonce: Option<U256>,\n\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\tis_transactional: bool,\n\t\tconfig: &evm::Config,\n\t) -> Result<CallInfo, RunnerError<Self::Error>> {\n\t\tlet precompiles = T::PrecompilesValue::get();\n\t\tSelf::execute(\n\t\t\tsource,\n\t\t\tvalue,\n\t\t\tgas_limit,\n\t\t\tmax_fee_per_gas,\n\t\t\tmax_priority_fee_per_gas,\n\t\t\tnonce,\n\t\t\tconfig,\n\t\t\t&precompiles,\n\t\t\tis_transactional,\n\t\t\t|executor| executor.transact_call(source, target, value, input, gas_limit, access_list),\n\t\t)\n\t}\n\n\tfn create(\n\t\tsource: H160,\n\t\tinit: Vec<u8>,\n\t\tvalue: U256,\n\t\tgas_limit: u64,\n\t\tmax_fee_per_gas: Option<U256>,\n\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\tnonce: Option<U256>,\n\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\tis_transactional: bool,\n\t\tconfig: &evm::Config,\n\t) -> Result<CreateInfo, RunnerError<Self::Error>> {\n\t\tlet precompiles = T::PrecompilesValue::get();\n\t\tSelf::execute(\n\t\t\tsource,\n\t\t\tvalue,\n\t\t\tgas_limit,\n\t\t\tmax_fee_per_gas,\n\t\t\tmax_priority_fee_per_gas,\n\t\t\tnonce,\n\t\t\tconfig,\n\t\t\t&precompiles,\n\t\t\tis_transactional,\n\t\t\t|executor| {\n\t\t\t\tlet address = executor.create_address(evm::CreateScheme::Legacy { caller: source });\n\t\t\t\tlet (reason, _) =\n\t\t\t\t\texecutor.transact_create(source, value, init, gas_limit, access_list);\n\t\t\t\t(reason, address)\n\t\t\t},\n\t\t)\n\t}\n\n\tfn create2(\n\t\tsource: H160,\n\t\tinit: Vec<u8>,\n\t\tsalt: H256,\n\t\tvalue: U256,\n\t\tgas_limit: u64,\n\t\tmax_fee_per_gas: Option<U256>,\n\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\tnonce: Option<U256>,\n\t\taccess_list: Vec<(H160, Vec<H256>)>,\n\t\tis_transactional: bool,\n\t\tconfig: &evm::Config,\n\t) -> Result<CreateInfo, RunnerError<Self::Error>> {\n\t\tlet precompiles = T::PrecompilesValue::get();\n\t\tlet code_hash = H256::from_slice(Keccak256::digest(&init).as_slice());\n\t\tSelf::execute(\n\t\t\tsource,\n\t\t\tvalue,\n\t\t\tgas_limit,\n\t\t\tmax_fee_per_gas,\n\t\t\tmax_priority_fee_per_gas,\n\t\t\tnonce,\n\t\t\tconfig,\n\t\t\t&precompiles,\n\t\t\tis_transactional,\n\t\t\t|executor| {\n\t\t\t\tlet address = executor.create_address(evm::CreateScheme::Create2 {\n\t\t\t\t\tcaller: source,\n\t\t\t\t\tcode_hash,\n\t\t\t\t\tsalt,\n\t\t\t\t});\n\t\t\t\tlet (reason, _) =\n\t\t\t\t\texecutor.transact_create2(source, value, init, salt, gas_limit, access_list);\n\t\t\t\t(reason, address)\n\t\t\t},\n\t\t)\n\t}\n}\n\nstruct SubstrateStackSubstate<'config> {\n\tmetadata: StackSubstateMetadata<'config>,\n\tdeletes: BTreeSet<H160>,\n\tlogs: Vec<Log>,\n\tparent: Option<Box<SubstrateStackSubstate<'config>>>,\n}\n\nimpl<'config> SubstrateStackSubstate<'config> {\n\tpub fn metadata(&self) -> &StackSubstateMetadata<'config> {\n\t\t&self.metadata\n\t}\n\n\tpub fn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {\n\t\t&mut self.metadata\n\t}\n\n\tpub fn enter(&mut self, gas_limit: u64, is_static: bool) {\n\t\tlet mut entering = Self {\n\t\t\tmetadata: self.metadata.spit_child(gas_limit, is_static),\n\t\t\tparent: None,\n\t\t\tdeletes: BTreeSet::new(),\n\t\t\tlogs: Vec::new(),\n\t\t};\n\t\tmem::swap(&mut entering, self);\n\n\t\tself.parent = Some(Box::new(entering));\n\n\t\tsp_io::storage::start_transaction();\n\t}\n\n\tpub fn exit_commit(&mut self) -> Result<(), ExitError> {\n\t\tlet mut exited = *self.parent.take().expect(\"Cannot commit on root substate\");\n\t\tmem::swap(&mut exited, self);\n\n\t\tself.metadata.swallow_commit(exited.metadata)?;\n\t\tself.logs.append(&mut exited.logs);\n\t\tself.deletes.append(&mut exited.deletes);\n\n\t\tsp_io::storage::commit_transaction();\n\t\tOk(())\n\t}\n\n\tpub fn exit_revert(&mut self) -> Result<(), ExitError> {\n\t\tlet mut exited = *self.parent.take().expect(\"Cannot discard on root substate\");\n\t\tmem::swap(&mut exited, self);\n\t\tself.metadata.swallow_revert(exited.metadata)?;\n\n\t\tsp_io::storage::rollback_transaction();\n\t\tOk(())\n\t}\n\n\tpub fn exit_discard(&mut self) -> Result<(), ExitError> {\n\t\tlet mut exited = *self.parent.take().expect(\"Cannot discard on root substate\");\n\t\tmem::swap(&mut exited, self);\n\t\tself.metadata.swallow_discard(exited.metadata)?;\n\n\t\tsp_io::storage::rollback_transaction();\n\t\tOk(())\n\t}\n\n\tpub fn deleted(&self, address: H160) -> bool {\n\t\tif self.deletes.contains(&address) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif let Some(parent) = self.parent.as_ref() {\n\t\t\treturn parent.deleted(address);\n\t\t}\n\n\t\tfalse\n\t}\n\n\tpub fn set_deleted(&mut self, address: H160) {\n\t\tself.deletes.insert(address);\n\t}\n\n\tpub fn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {\n\t\tself.logs.push(Log {\n\t\t\taddress,\n\t\t\ttopics,\n\t\t\tdata,\n\t\t});\n\t}\n\n\tfn recursive_is_cold<F: Fn(&Accessed) -> bool>(&self, f: &F) -> bool {\n\t\tlet local_is_accessed = self.metadata.accessed().as_ref().map(f).unwrap_or(false);\n\t\tif local_is_accessed {\n\t\t\tfalse\n\t\t} else {\n\t\t\tself.parent\n\t\t\t\t.as_ref()\n\t\t\t\t.map(|p| p.recursive_is_cold(f))\n\t\t\t\t.unwrap_or(true)\n\t\t}\n\t}\n}\n\n/// Substrate backend for EVM.\npub struct SubstrateStackState<'vicinity, 'config, T> {\n\tvicinity: &'vicinity Vicinity,\n\tsubstate: SubstrateStackSubstate<'config>,\n\t_marker: PhantomData<T>,\n}\n\nimpl<'vicinity, 'config, T: Config> SubstrateStackState<'vicinity, 'config, T> {\n\t/// Create a new backend with given vicinity.\n\tpub fn new(vicinity: &'vicinity Vicinity, metadata: StackSubstateMetadata<'config>) -> Self {\n\t\tSelf {\n\t\t\tvicinity,\n\t\t\tsubstate: SubstrateStackSubstate {\n\t\t\t\tmetadata,\n\t\t\t\tdeletes: BTreeSet::new(),\n\t\t\t\tlogs: Vec::new(),\n\t\t\t\tparent: None,\n\t\t\t},\n\t\t\t_marker: PhantomData,\n\t\t}\n\t}\n}\n\nimpl<'vicinity, 'config, T: Config> BackendT for SubstrateStackState<'vicinity, 'config, T> {\n\tfn gas_price(&self) -> U256 {\n\t\tself.vicinity.gas_price\n\t}\n\tfn origin(&self) -> H160 {\n\t\tself.vicinity.origin\n\t}\n\n\tfn block_hash(&self, number: U256) -> H256 {\n\t\tif number > U256::from(u32::max_value()) {\n\t\t\tH256::default()\n\t\t} else {\n\t\t\tT::BlockHashMapping::block_hash(number.as_u32())\n\t\t}\n\t}\n\n\tfn block_number(&self) -> U256 {\n\t\tlet number: u128 = frame_system::Pallet::<T>::block_number().unique_saturated_into();\n\t\tU256::from(number)\n\t}\n\n\tfn block_coinbase(&self) -> H160 {\n\t\tPallet::<T>::find_author()\n\t}\n\n\tfn block_timestamp(&self) -> U256 {\n\t\tlet now: u128 = pallet_timestamp::Pallet::<T>::get().unique_saturated_into();\n\t\tU256::from(now / 1000)\n\t}\n\n\tfn block_difficulty(&self) -> U256 {\n\t\tU256::zero()\n\t}\n\n\tfn block_gas_limit(&self) -> U256 {\n\t\tT::BlockGasLimit::get()\n\t}\n\n\tfn chain_id(&self) -> U256 {\n\t\tU256::from(T::ChainId::get())\n\t}\n\n\tfn exists(&self, _address: H160) -> bool {\n\t\ttrue\n\t}\n\n\tfn basic(&self, address: H160) -> evm::backend::Basic {\n\t\tlet (account, _) = Pallet::<T>::account_basic(&address);\n\n\t\tevm::backend::Basic {\n\t\t\tbalance: account.balance,\n\t\t\tnonce: account.nonce,\n\t\t}\n\t}\n\n\tfn code(&self, address: H160) -> Vec<u8> {\n\t\t<AccountCodes<T>>::get(&address)\n\t}\n\n\tfn storage(&self, address: H160, index: H256) -> H256 {\n\t\t<AccountStorages<T>>::get(address, index)\n\t}\n\n\tfn original_storage(&self, _address: H160, _index: H256) -> Option<H256> {\n\t\tNone\n\t}\n\n\tfn block_base_fee_per_gas(&self) -> sp_core::U256 {\n\t\tlet (base_fee, _) = T::FeeCalculator::min_gas_price();\n\t\tbase_fee\n\t}\n}\n\nimpl<'vicinity, 'config, T: Config> StackStateT<'config>\n\tfor SubstrateStackState<'vicinity, 'config, T>\nwhere\n\tBalanceOf<T>: TryFrom<U256> + Into<U256>,\n{\n\tfn metadata(&self) -> &StackSubstateMetadata<'config> {\n\t\tself.substate.metadata()\n\t}\n\n\tfn metadata_mut(&mut self) -> &mut StackSubstateMetadata<'config> {\n\t\tself.substate.metadata_mut()\n\t}\n\n\tfn enter(&mut self, gas_limit: u64, is_static: bool) {\n\t\tself.substate.enter(gas_limit, is_static)\n\t}\n\n\tfn exit_commit(&mut self) -> Result<(), ExitError> {\n\t\tself.substate.exit_commit()\n\t}\n\n\tfn exit_revert(&mut self) -> Result<(), ExitError> {\n\t\tself.substate.exit_revert()\n\t}\n\n\tfn exit_discard(&mut self) -> Result<(), ExitError> {\n\t\tself.substate.exit_discard()\n\t}\n\n\tfn is_empty(&self, address: H160) -> bool {\n\t\tPallet::<T>::is_account_empty(&address)\n\t}\n\n\tfn deleted(&self, address: H160) -> bool {\n\t\tself.substate.deleted(address)\n\t}\n\n\tfn inc_nonce(&mut self, address: H160) {\n\t\tlet account_id = T::AddressMapping::into_account_id(address);\n\t\tframe_system::Pallet::<T>::inc_account_nonce(&account_id);\n\t}\n\n\tfn set_storage(&mut self, address: H160, index: H256, value: H256) {\n\t\tif value == H256::default() {\n\t\t\tlog::debug!(\n\t\t\t\ttarget: \"evm\",\n\t\t\t\t\"Removing storage for {:?} [index: {:?}]\",\n\t\t\t\taddress,\n\t\t\t\tindex,\n\t\t\t);\n\t\t\t<AccountStorages<T>>::remove(address, index);\n\t\t} else {\n\t\t\tlog::debug!(\n\t\t\t\ttarget: \"evm\",\n\t\t\t\t\"Updating storage for {:?} [index: {:?}, value: {:?}]\",\n\t\t\t\taddress,\n\t\t\t\tindex,\n\t\t\t\tvalue,\n\t\t\t);\n\t\t\t<AccountStorages<T>>::insert(address, index, value);\n\t\t}\n\t}\n\n\tfn reset_storage(&mut self, address: H160) {\n\t\tlet _ = <AccountStorages<T>>::remove_prefix(address, None);\n\t}\n\n\tfn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) {\n\t\tself.substate.log(address, topics, data)\n\t}\n\n\tfn set_deleted(&mut self, address: H160) {\n\t\tself.substate.set_deleted(address)\n\t}\n\n\tfn set_code(&mut self, address: H160, code: Vec<u8>) {\n\t\tlog::debug!(\n\t\t\ttarget: \"evm\",\n\t\t\t\"Inserting code ({} bytes) at {:?}\",\n\t\t\tcode.len(),\n\t\t\taddress\n\t\t);\n\t\tPallet::<T>::create_account(address, code);\n\t}\n\n\tfn transfer(&mut self, transfer: Transfer) -> Result<(), ExitError> {\n\t\tlet source = T::AddressMapping::into_account_id(transfer.source);\n\t\tlet target = T::AddressMapping::into_account_id(transfer.target);\n\n\t\tT::Currency::transfer(\n\t\t\t&source,\n\t\t\t&target,\n\t\t\ttransfer\n\t\t\t\t.value\n\t\t\t\t.try_into()\n\t\t\t\t.map_err(|_| ExitError::OutOfFund)?,\n\t\t\tExistenceRequirement::AllowDeath,\n\t\t)\n\t\t.map_err(|_| ExitError::OutOfFund)\n\t}\n\n\tfn reset_balance(&mut self, _address: H160) {\n\t\t// Do nothing on reset balance in Substrate.\n\t\t//\n\t\t// This function exists in EVM because a design issue\n\t\t// (arguably a bug) in SELFDESTRUCT that can cause total\n\t\t// issurance to be reduced. We do not need to replicate this.\n\t}\n\n\tfn touch(&mut self, _address: H160) {\n\t\t// Do nothing on touch in Substrate.\n\t\t//\n\t\t// EVM pallet considers all accounts to exist, and distinguish\n\t\t// only empty and non-empty accounts. This avoids many of the\n\t\t// subtle issues in EIP-161.\n\t}\n\n\tfn is_cold(&self, address: H160) -> bool {\n\t\tself.substate\n\t\t\t.recursive_is_cold(&|a| a.accessed_addresses.contains(&address))\n\t}\n\n\tfn is_storage_cold(&self, address: H160, key: H256) -> bool {\n\t\tself.substate\n\t\t\t.recursive_is_cold(&|a: &Accessed| a.accessed_storage.contains(&(address, key)))\n\t}\n}\n", "// SPDX-License-Identifier: Apache-2.0\n// This file is part of Frontier.\n//\n// Copyright (c) 2020-2022 Parity Technologies (UK) Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// \thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#![cfg(test)]\n\nuse super::*;\nuse crate::mock::*;\n\nuse frame_support::{\n\tassert_ok,\n\ttraits::{GenesisBuild, LockIdentifier, LockableCurrency, WithdrawReasons},\n};\nuse std::{collections::BTreeMap, str::FromStr};\n\ntype Balances = pallet_balances::Pallet<Test>;\ntype EVM = Pallet<Test>;\n\npub fn new_test_ext() -> sp_io::TestExternalities {\n\tlet mut t = frame_system::GenesisConfig::default()\n\t\t.build_storage::<Test>()\n\t\t.unwrap();\n\n\tlet mut accounts = BTreeMap::new();\n\taccounts.insert(\n\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\tGenesisAccount {\n\t\t\tnonce: U256::from(1),\n\t\t\tbalance: U256::from(1000000),\n\t\t\tstorage: Default::default(),\n\t\t\tcode: vec![\n\t\t\t\t0x00, // STOP\n\t\t\t],\n\t\t},\n\t);\n\taccounts.insert(\n\t\tH160::from_str(\"1000000000000000000000000000000000000002\").unwrap(),\n\t\tGenesisAccount {\n\t\t\tnonce: U256::from(1),\n\t\t\tbalance: U256::from(1000000),\n\t\t\tstorage: Default::default(),\n\t\t\tcode: vec![\n\t\t\t\t0xff, // INVALID\n\t\t\t],\n\t\t},\n\t);\n\taccounts.insert(\n\t\tH160::default(), // root\n\t\tGenesisAccount {\n\t\t\tnonce: U256::from(1),\n\t\t\tbalance: U256::max_value(),\n\t\t\tstorage: Default::default(),\n\t\t\tcode: vec![],\n\t\t},\n\t);\n\n\tpallet_balances::GenesisConfig::<Test> {\n\t\t// Create the block author account with some balance.\n\t\tbalances: vec![(\n\t\t\tH160::from_str(\"0x1234500000000000000000000000000000000000\").unwrap(),\n\t\t\t12345,\n\t\t)],\n\t}\n\t.assimilate_storage(&mut t)\n\t.expect(\"Pallet balances storage can be assimilated\");\n\tGenesisBuild::<Test>::assimilate_storage(&crate::GenesisConfig { accounts }, &mut t).unwrap();\n\tt.into()\n}\n\n#[test]\nfn fail_call_return_ok() {\n\tnew_test_ext().execute_with(|| {\n\t\tassert_ok!(EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::default(),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t));\n\n\t\tassert_ok!(EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000002\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::default(),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t));\n\t});\n}\n\n#[test]\nfn fee_deduction() {\n\tnew_test_ext().execute_with(|| {\n\t\t// Create an EVM address and the corresponding Substrate address that will be charged fees and refunded\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000003\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\n\t\t// Seed account\n\t\tlet _ = <Test as Config>::Currency::deposit_creating(&substrate_addr, 100);\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 100);\n\n\t\t// Deduct fees as 10 units\n\t\tlet imbalance = <<Test as Config>::OnChargeTransaction as OnChargeEVMTransaction<Test>>::withdraw_fee(&evm_addr, U256::from(10)).unwrap();\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 90);\n\n\t\t// Refund fees as 5 units\n\t\t<<Test as Config>::OnChargeTransaction as OnChargeEVMTransaction<Test>>::correct_and_deposit_fee(&evm_addr, U256::from(5), U256::from(5), imbalance);\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 95);\n\t});\n}\n\n#[test]\nfn ed_0_refund_patch_works() {\n\tnew_test_ext().execute_with(|| {\n\t\t// Verifies that the OnChargeEVMTransaction patch is applied and fixes a known bug in Substrate for evm transactions.\n\t\t// https://github.com/paritytech/substrate/issues/10117\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000003\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\n\t\tlet _ = <Test as Config>::Currency::deposit_creating(&substrate_addr, 21_777_000_000_000);\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 21_777_000_000_000);\n\n\t\tlet _ = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tevm_addr,\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1_000_000_000),\n\t\t\t21776,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tNone,\n\t\t\tSome(U256::from(0)),\n\t\t\tVec::new(),\n\t\t);\n\t\t// All that was due, was refunded.\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 776_000_000_000);\n\t});\n}\n\n#[test]\nfn ed_0_refund_patch_is_required() {\n\tnew_test_ext().execute_with(|| {\n\t\t// This test proves that the patch is required, verifying that the current Substrate behaviour is incorrect\n\t\t// for ED 0 configured chains.\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000003\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\n\t\tlet _ = <Test as Config>::Currency::deposit_creating(&substrate_addr, 100);\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 100);\n\n\t\t// Drain funds\n\t\tlet _ =\n\t\t\t<<Test as Config>::OnChargeTransaction as OnChargeEVMTransaction<Test>>::withdraw_fee(\n\t\t\t\t&evm_addr,\n\t\t\t\tU256::from(100),\n\t\t\t)\n\t\t\t.unwrap();\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 0);\n\n\t\t// Try to refund. With ED 0, although the balance is now 0, the account still exists.\n\t\t// So its expected that calling `deposit_into_existing` results in the AccountData to increase the Balance.\n\t\t//\n\t\t// Is not the case, and this proves that the refund logic needs to be handled taking this into account.\n\t\tassert_eq!(\n\t\t\t<Test as Config>::Currency::deposit_into_existing(&substrate_addr, 5u32.into())\n\t\t\t\t.is_err(),\n\t\t\ttrue\n\t\t);\n\t\t// Balance didn't change, and should be 5.\n\t\tassert_eq!(Balances::free_balance(&substrate_addr), 0);\n\t});\n}\n\n#[test]\nfn find_author() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tassert_eq!(\n\t\t\tauthor,\n\t\t\tH160::from_str(\"1234500000000000000000000000000000000000\").unwrap()\n\t\t);\n\t});\n}\n\n#[test]\nfn reducible_balance() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet evm_addr = H160::from_str(\"1000000000000000000000000000000000000001\").unwrap();\n\t\tlet account_id = <Test as Config>::AddressMapping::into_account_id(evm_addr);\n\t\tlet existential = ExistentialDeposit::get();\n\n\t\t// Genesis Balance.\n\t\tlet genesis_balance = EVM::account_basic(&evm_addr).0.balance;\n\n\t\t// Lock identifier.\n\t\tlet lock_id: LockIdentifier = *b\"te/stlok\";\n\t\t// Reserve some funds.\n\t\tlet to_lock = 1000;\n\t\tBalances::set_lock(lock_id, &account_id, to_lock, WithdrawReasons::RESERVE);\n\t\t// Reducible is, as currently configured in `account_basic`, (balance - lock - existential).\n\t\tlet reducible_balance = EVM::account_basic(&evm_addr).0.balance;\n\t\tassert_eq!(reducible_balance, (genesis_balance - to_lock - existential));\n\t});\n}\n\n#[test]\nfn author_should_get_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet result = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tSome(U256::from(1)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tresult.expect(\"EVM can be called\");\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, (before_tip + 21000));\n\t});\n}\n\n#[test]\nfn issuance_after_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet before_tip = <Test as Config>::Currency::total_issuance();\n\t\tlet result = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tSome(U256::from(1)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tresult.expect(\"EVM can be called\");\n\t\tlet after_tip = <Test as Config>::Currency::total_issuance();\n\t\t// Only base fee is burned\n\t\tlet base_fee: u64 = <Test as Config>::FeeCalculator::min_gas_price()\n\t\t\t.0\n\t\t\t.unique_saturated_into();\n\t\tassert_eq!(after_tip, (before_tip - (base_fee * 21_000)));\n\t});\n}\n\n#[test]\nfn author_same_balance_without_tip() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet _ = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::default(),\n\t\t\t1000000,\n\t\t\tU256::default(),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, before_tip);\n\t});\n}\n\n#[test]\nfn refunds_should_work() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet before_call = EVM::account_basic(&H160::default()).0.balance;\n\t\t// Gas price is not part of the actual fee calculations anymore, only the base fee.\n\t\t//\n\t\t// Because we first deduct max_fee_per_gas * gas_limit (2_000_000_000 * 1000000) we need\n\t\t// to ensure that the difference (max fee VS base fee) is refunded.\n\t\tlet _ = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(2_000_000_000),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet (base_fee, _) = <Test as Config>::FeeCalculator::min_gas_price();\n\t\tlet total_cost = (U256::from(21_000) * base_fee) + U256::from(1);\n\t\tlet after_call = EVM::account_basic(&H160::default()).0.balance;\n\t\tassert_eq!(after_call, before_call - total_cost);\n\t});\n}\n\n#[test]\nfn refunds_and_priority_should_work() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet author = EVM::find_author();\n\t\tlet before_tip = EVM::account_basic(&author).0.balance;\n\t\tlet before_call = EVM::account_basic(&H160::default()).0.balance;\n\t\t// We deliberately set a base fee + max tip > max fee.\n\t\t// The effective priority tip will be 1GWEI instead 1.5GWEI:\n\t\t// \t\t(max_fee_per_gas - base_fee).min(max_priority_fee)\n\t\t//\t\t(2 - 1).min(1.5)\n\t\tlet tip = U256::from(1_500_000_000);\n\t\tlet max_fee_per_gas = U256::from(2_000_000_000);\n\t\tlet used_gas = U256::from(21_000);\n\t\tlet _ = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tmax_fee_per_gas,\n\t\t\tSome(tip),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tlet (base_fee, _) = <Test as Config>::FeeCalculator::min_gas_price();\n\t\tlet actual_tip = (max_fee_per_gas - base_fee).min(tip) * used_gas;\n\t\tlet total_cost = (used_gas * base_fee) + U256::from(actual_tip) + U256::from(1);\n\t\tlet after_call = EVM::account_basic(&H160::default()).0.balance;\n\t\t// The tip is deducted but never refunded to the caller.\n\t\tassert_eq!(after_call, before_call - total_cost);\n\n\t\tlet after_tip = EVM::account_basic(&author).0.balance;\n\t\tassert_eq!(after_tip, (before_tip + actual_tip));\n\t});\n}\n\n#[test]\nfn call_should_fail_with_priority_greater_than_max_fee() {\n\tnew_test_ext().execute_with(|| {\n\t\t// Max priority greater than max fee should fail.\n\t\tlet tip: u128 = 1_100_000_000;\n\t\tlet result = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tSome(U256::from(tip)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tassert!(result.is_err());\n\t\t// Some used weight is returned as part of the error.\n\t\tassert_eq!(result.unwrap_err().post_info.actual_weight, Some(7));\n\t});\n}\n\n#[test]\nfn call_should_succeed_with_priority_equal_to_max_fee() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet tip: u128 = 1_000_000_000;\n\t\t// Mimics the input for pre-eip-1559 transaction types where `gas_price`\n\t\t// is used for both `max_fee_per_gas` and `max_priority_fee_per_gas`.\n\t\tlet result = EVM::call(\n\t\t\tOrigin::root(),\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1),\n\t\t\t1000000,\n\t\t\tU256::from(1_000_000_000),\n\t\t\tSome(U256::from(tip)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t);\n\t\tassert!(result.is_ok());\n\t});\n}\n\n#[test]\nfn handle_sufficient_reference() {\n\tnew_test_ext().execute_with(|| {\n\t\tlet addr = H160::from_str(\"1230000000000000000000000000000000000001\").unwrap();\n\t\tlet addr_2 = H160::from_str(\"1234000000000000000000000000000000000001\").unwrap();\n\t\tlet substrate_addr = <Test as Config>::AddressMapping::into_account_id(addr);\n\t\tlet substrate_addr_2 = <Test as Config>::AddressMapping::into_account_id(addr_2);\n\n\t\t// Sufficients should increase when creating EVM accounts.\n\t\tlet _ = <crate::AccountCodes<Test>>::insert(addr, &vec![0]);\n\t\tlet account = frame_system::Account::<Test>::get(substrate_addr);\n\t\t// Using storage is not correct as it leads to a sufficient reference mismatch.\n\t\tassert_eq!(account.sufficients, 0);\n\n\t\t// Using the create / remove account functions is the correct way to handle it.\n\t\tEVM::create_account(addr_2, vec![1, 2, 3]);\n\t\tlet account_2 = frame_system::Account::<Test>::get(substrate_addr_2);\n\t\t// We increased the sufficient reference by 1.\n\t\tassert_eq!(account_2.sufficients, 1);\n\t\tEVM::remove_account(&addr_2);\n\t\tlet account_2 = frame_system::Account::<Test>::get(substrate_addr_2);\n\t\t// We decreased the sufficient reference by 1 on removing the account.\n\t\tassert_eq!(account_2.sufficients, 0);\n\t});\n}\n\n#[test]\nfn runner_non_transactional_calls_with_non_balance_accounts_is_ok_without_gas_price() {\n\t// Expect to skip checks for gas price and account balance when both:\n\t//\t- The call is non transactional (`is_transactional == false`).\n\t//\t- The `max_fee_per_gas` is None.\n\tnew_test_ext().execute_with(|| {\n\t\tlet non_balance_account =\n\t\t\tH160::from_str(\"7700000000000000000000000000000000000001\").unwrap();\n\t\tassert_eq!(\n\t\t\tEVM::account_basic(&non_balance_account).0.balance,\n\t\t\tU256::zero()\n\t\t);\n\t\tlet _ = <Test as Config>::Runner::call(\n\t\t\tnon_balance_account,\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t)\n\t\t.expect(\"Non transactional call succeeds\");\n\t\tassert_eq!(\n\t\t\tEVM::account_basic(&non_balance_account).0.balance,\n\t\t\tU256::zero()\n\t\t);\n\t});\n}\n\n#[test]\nfn runner_non_transactional_calls_with_non_balance_accounts_is_err_with_gas_price() {\n\t// In non transactional calls where `Some(gas_price)` is defined, expect it to be\n\t// checked against the `BaseFee`, and expect the account to have enough balance\n\t// to pay for the call.\n\tnew_test_ext().execute_with(|| {\n\t\tlet non_balance_account =\n\t\t\tH160::from_str(\"7700000000000000000000000000000000000001\").unwrap();\n\t\tassert_eq!(\n\t\t\tEVM::account_basic(&non_balance_account).0.balance,\n\t\t\tU256::zero()\n\t\t);\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tnon_balance_account,\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tSome(U256::from(1_000_000_000)),\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t});\n}\n\n#[test]\nfn runner_transactional_call_with_zero_gas_price_fails() {\n\t// Transactional calls are rejected when `max_fee_per_gas == None`.\n\tnew_test_ext().execute_with(|| {\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t});\n}\n\n#[test]\nfn runner_max_fee_per_gas_gte_max_priority_fee_per_gas() {\n\t// Transactional and non transactional calls enforce `max_fee_per_gas >= max_priority_fee_per_gas`.\n\tnew_test_ext().execute_with(|| {\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tSome(U256::from(1_000_000_000)),\n\t\t\tSome(U256::from(2_000_000_000)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\ttrue,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t\tlet res = <Test as Config>::Runner::call(\n\t\t\tH160::default(),\n\t\t\tH160::from_str(\"1000000000000000000000000000000000000001\").unwrap(),\n\t\t\tVec::new(),\n\t\t\tU256::from(1u32),\n\t\t\t1000000,\n\t\t\tSome(U256::from(1_000_000_000)),\n\t\t\tSome(U256::from(2_000_000_000)),\n\t\t\tNone,\n\t\t\tVec::new(),\n\t\t\tfalse,\n\t\t\t&<Test as Config>::config().clone(),\n\t\t);\n\t\tassert!(res.is_err());\n\t});\n}\n", "//! The Substrate Node Template runtime. This can be compiled with `#[no_std]`, ready for Wasm.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n// `construct_runtime!` does a lot of recursion and requires us to increase the limit to 256.\n#![recursion_limit = \"256\"]\n#![allow(clippy::new_without_default, clippy::or_fun_call)]\n\n// Make the WASM binary available.\n#[cfg(feature = \"std\")]\ninclude!(concat!(env!(\"OUT_DIR\"), \"/wasm_binary.rs\"));\n\nuse codec::{Decode, Encode};\nuse pallet_evm::FeeCalculator;\nuse pallet_grandpa::{\n\tfg_primitives, AuthorityId as GrandpaId, AuthorityList as GrandpaAuthorityList,\n};\nuse sp_api::impl_runtime_apis;\nuse sp_consensus_aura::sr25519::AuthorityId as AuraId;\nuse sp_core::{\n\tcrypto::{ByteArray, KeyTypeId},\n\tOpaqueMetadata, H160, H256, U256,\n};\nuse sp_runtime::{\n\tcreate_runtime_str, generic, impl_opaque_keys,\n\ttraits::{\n\t\tAccountIdLookup, BlakeTwo256, Block as BlockT, DispatchInfoOf, Dispatchable,\n\t\tIdentifyAccount, NumberFor, PostDispatchInfoOf, UniqueSaturatedInto, Verify,\n\t},\n\ttransaction_validity::{TransactionSource, TransactionValidity, TransactionValidityError},\n\tApplyExtrinsicResult, MultiSignature,\n};\nuse sp_std::{marker::PhantomData, prelude::*};\n#[cfg(feature = \"std\")]\nuse sp_version::NativeVersion;\nuse sp_version::RuntimeVersion;\n\n// A few exports that help ease life for downstream crates.\nuse fp_rpc::TransactionStatus;\npub use frame_support::{\n\tconstruct_runtime, parameter_types,\n\ttraits::{ConstU32, ConstU8, FindAuthor, KeyOwnerProofSystem, Randomness},\n\tweights::{\n\t\tconstants::{BlockExecutionWeight, ExtrinsicBaseWeight, WEIGHT_PER_SECOND},\n\t\tConstantMultiplier, IdentityFee, Weight,\n\t},\n\tConsensusEngineId, StorageValue,\n};\n\n#[cfg(feature = \"with-paritydb-weights\")]\nuse frame_support::weights::constants::ParityDbWeight as RuntimeDbWeight;\n#[cfg(feature = \"with-rocksdb-weights\")]\nuse frame_support::weights::constants::RocksDbWeight as RuntimeDbWeight;\n\npub use pallet_balances::Call as BalancesCall;\nuse pallet_ethereum::{Call::transact, Transaction as EthereumTransaction};\nuse pallet_evm::{\n\tAccount as EVMAccount, EnsureAddressTruncated, GasWeightMapping, HashedAddressMapping, Runner,\n};\npub use pallet_timestamp::Call as TimestampCall;\nuse pallet_transaction_payment::CurrencyAdapter;\n#[cfg(any(feature = \"std\", test))]\npub use sp_runtime::BuildStorage;\npub use sp_runtime::{Perbill, Permill};\n\nmod precompiles;\nuse precompiles::FrontierPrecompiles;\n\n/// Type of block number.\npub type BlockNumber = u32;\n\n/// Alias to 512-bit hash when used in the context of a transaction signature on the chain.\npub type Signature = MultiSignature;\n\n/// Some way of identifying an account on the chain. We intentionally make it equivalent\n/// to the public key of our transaction signing scheme.\npub type AccountId = <<Signature as Verify>::Signer as IdentifyAccount>::AccountId;\n\n/// The type for looking up accounts. We don't expect more than 4 billion of them, but you\n/// never know...\npub type AccountIndex = u32;\n\n/// Balance of an account.\npub type Balance = u128;\n\n/// Index of a transaction in the chain.\npub type Index = u32;\n\n/// A hash of some data used by the chain.\npub type Hash = sp_core::H256;\n\n/// Digest item type.\npub type DigestItem = generic::DigestItem;\n\n/// Opaque types. These are used by the CLI to instantiate machinery that don't need to know\n/// the specifics of the runtime. They can then be made to be agnostic over specific formats\n/// of data like extrinsics, allowing for them to continue syncing the network through upgrades\n/// to even the core data structures.\npub mod opaque {\n\tuse super::*;\n\n\tpub use sp_runtime::OpaqueExtrinsic as UncheckedExtrinsic;\n\n\t/// Opaque block header type.\n\tpub type Header = generic::Header<BlockNumber, BlakeTwo256>;\n\t/// Opaque block type.\n\tpub type Block = generic::Block<Header, UncheckedExtrinsic>;\n\t/// Opaque block identifier type.\n\tpub type BlockId = generic::BlockId<Block>;\n\n\timpl_opaque_keys! {\n\t\tpub struct SessionKeys {\n\t\t\tpub aura: Aura,\n\t\t\tpub grandpa: Grandpa,\n\t\t}\n\t}\n}\n\npub const VERSION: RuntimeVersion = RuntimeVersion {\n\tspec_name: create_runtime_str!(\"node-frontier-template\"),\n\timpl_name: create_runtime_str!(\"node-frontier-template\"),\n\tauthoring_version: 1,\n\tspec_version: 1,\n\timpl_version: 1,\n\tapis: RUNTIME_API_VERSIONS,\n\ttransaction_version: 1,\n\tstate_version: 1,\n};\n\npub const MILLISECS_PER_BLOCK: u64 = 6000;\n\npub const SLOT_DURATION: u64 = MILLISECS_PER_BLOCK;\n\n// Time is measured by number of blocks.\npub const MINUTES: BlockNumber = 60_000 / (MILLISECS_PER_BLOCK as BlockNumber);\npub const HOURS: BlockNumber = MINUTES * 60;\npub const DAYS: BlockNumber = HOURS * 24;\n\n/// The version information used to identify this runtime when compiled natively.\n#[cfg(feature = \"std\")]\npub fn native_version() -> NativeVersion {\n\tNativeVersion {\n\t\truntime_version: VERSION,\n\t\tcan_author_with: Default::default(),\n\t}\n}\n\nconst NORMAL_DISPATCH_RATIO: Perbill = Perbill::from_percent(75);\n/// We allow for 2 seconds of compute with a 6 second average block time.\npub const MAXIMUM_BLOCK_WEIGHT: Weight = 2 * WEIGHT_PER_SECOND;\nconst WEIGHT_PER_GAS: u64 = 20_000;\n\nparameter_types! {\n\tpub const Version: RuntimeVersion = VERSION;\n\tpub const BlockHashCount: BlockNumber = 256;\n\tpub BlockWeights: frame_system::limits::BlockWeights = frame_system::limits::BlockWeights\n\t\t::with_sensible_defaults(MAXIMUM_BLOCK_WEIGHT, NORMAL_DISPATCH_RATIO);\n\tpub BlockLength: frame_system::limits::BlockLength = frame_system::limits::BlockLength\n\t\t::max_with_normal_ratio(5 * 1024 * 1024, NORMAL_DISPATCH_RATIO);\n\tpub const SS58Prefix: u8 = 42;\n}\n\n// Configure FRAME pallets to include in runtime.\n\nimpl frame_system::Config for Runtime {\n\t/// The basic call filter to use in dispatchable.\n\ttype BaseCallFilter = frame_support::traits::Everything;\n\t/// Block & extrinsics weights: base values and limits.\n\ttype BlockWeights = BlockWeights;\n\t/// The maximum length of a block (in bytes).\n\ttype BlockLength = BlockLength;\n\t/// The identifier used to distinguish between accounts.\n\ttype AccountId = AccountId;\n\t/// The aggregated dispatch type that is available for extrinsics.\n\ttype Call = Call;\n\t/// The lookup mechanism to get account ID from whatever is passed in dispatchers.\n\ttype Lookup = AccountIdLookup<AccountId, ()>;\n\t/// The index type for storing how many extrinsics an account has signed.\n\ttype Index = Index;\n\t/// The index type for blocks.\n\ttype BlockNumber = BlockNumber;\n\t/// The type for hashing blocks and tries.\n\ttype Hash = Hash;\n\t/// The hashing algorithm used.\n\ttype Hashing = BlakeTwo256;\n\t/// The header type.\n\ttype Header = generic::Header<BlockNumber, BlakeTwo256>;\n\t/// The ubiquitous event type.\n\ttype Event = Event;\n\t/// The ubiquitous origin type.\n\ttype Origin = Origin;\n\t/// Maximum number of block number to block hash mappings to keep (oldest pruned first).\n\ttype BlockHashCount = BlockHashCount;\n\t/// The weight of database operations that the runtime can invoke.\n\ttype DbWeight = RuntimeDbWeight;\n\t/// Version of the runtime.\n\ttype Version = Version;\n\t/// Converts a module to the index of the module in `construct_runtime!`.\n\t///\n\t/// This type is being generated by `construct_runtime!`.\n\ttype PalletInfo = PalletInfo;\n\t/// What to do if a new account is created.\n\ttype OnNewAccount = ();\n\t/// What to do if an account is fully reaped from the system.\n\ttype OnKilledAccount = ();\n\t/// The data to be stored in an account.\n\ttype AccountData = pallet_balances::AccountData<Balance>;\n\t/// Weight information for the extrinsics of this pallet.\n\ttype SystemWeightInfo = ();\n\t/// This is used as an identifier of the chain. 42 is the generic substrate prefix.\n\ttype SS58Prefix = SS58Prefix;\n\t/// The set code logic, just the default since we're not a parachain.\n\ttype OnSetCode = ();\n\ttype MaxConsumers = ConstU32<16>;\n}\n\nparameter_types! {\n\tpub const MaxAuthorities: u32 = 100;\n}\n\nimpl pallet_aura::Config for Runtime {\n\ttype AuthorityId = AuraId;\n\ttype DisabledValidators = ();\n\ttype MaxAuthorities = MaxAuthorities;\n}\n\nimpl pallet_grandpa::Config for Runtime {\n\ttype Event = Event;\n\ttype Call = Call;\n\n\ttype KeyOwnerProofSystem = ();\n\n\ttype KeyOwnerProof =\n\t\t<Self::KeyOwnerProofSystem as KeyOwnerProofSystem<(KeyTypeId, GrandpaId)>>::Proof;\n\n\ttype KeyOwnerIdentification = <Self::KeyOwnerProofSystem as KeyOwnerProofSystem<(\n\t\tKeyTypeId,\n\t\tGrandpaId,\n\t)>>::IdentificationTuple;\n\n\ttype HandleEquivocation = ();\n\n\ttype WeightInfo = ();\n\ttype MaxAuthorities = ConstU32<32>;\n}\n\nparameter_types! {\n\tpub const MinimumPeriod: u64 = SLOT_DURATION / 2;\n}\n\nimpl pallet_timestamp::Config for Runtime {\n\t/// A timestamp: milliseconds since the unix epoch.\n\ttype Moment = u64;\n\ttype MinimumPeriod = MinimumPeriod;\n\ttype WeightInfo = ();\n\t#[cfg(feature = \"aura\")]\n\ttype OnTimestampSet = Aura;\n\t#[cfg(feature = \"manual-seal\")]\n\ttype OnTimestampSet = ();\n}\n\nparameter_types! {\n\tpub const ExistentialDeposit: u128 = 500;\n\t// For weight estimation, we assume that the most locks on an individual account will be 50.\n\t// This number may need to be adjusted in the future if this assumption no longer holds true.\n\tpub const MaxLocks: u32 = 50;\n}\n\nimpl pallet_balances::Config for Runtime {\n\ttype MaxLocks = MaxLocks;\n\ttype MaxReserves = ();\n\ttype ReserveIdentifier = [u8; 8];\n\t/// The type for recording an account's balance.\n\ttype Balance = Balance;\n\t/// The ubiquitous event type.\n\ttype Event = Event;\n\ttype DustRemoval = ();\n\ttype ExistentialDeposit = ExistentialDeposit;\n\ttype AccountStore = System;\n\ttype WeightInfo = ();\n}\n\nparameter_types! {\n\tpub const TransactionByteFee: Balance = 1;\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n\ttype OnChargeTransaction = CurrencyAdapter<Balances, ()>;\n\ttype OperationalFeeMultiplier = ConstU8<5>;\n\ttype WeightToFee = IdentityFee<Balance>;\n\ttype LengthToFee = ConstantMultiplier<Balance, TransactionByteFee>;\n\ttype FeeMultiplierUpdate = ();\n}\n\nimpl pallet_sudo::Config for Runtime {\n\ttype Event = Event;\n\ttype Call = Call;\n}\n\npub struct FindAuthorTruncated<F>(PhantomData<F>);\nimpl<F: FindAuthor<u32>> FindAuthor<H160> for FindAuthorTruncated<F> {\n\tfn find_author<'a, I>(digests: I) -> Option<H160>\n\twhere\n\t\tI: 'a + IntoIterator<Item = (ConsensusEngineId, &'a [u8])>,\n\t{\n\t\tif let Some(author_index) = F::find_author(digests) {\n\t\t\tlet authority_id = Aura::authorities()[author_index as usize].clone();\n\t\t\treturn Some(H160::from_slice(&authority_id.to_raw_vec()[4..24]));\n\t\t}\n\t\tNone\n\t}\n}\n\npub struct FixedGasWeightMapping;\nimpl GasWeightMapping for FixedGasWeightMapping {\n\tfn gas_to_weight(gas: u64) -> Weight {\n\t\tgas.saturating_mul(WEIGHT_PER_GAS)\n\t}\n\tfn weight_to_gas(weight: Weight) -> u64 {\n\t\tweight.wrapping_div(WEIGHT_PER_GAS)\n\t}\n}\n\nparameter_types! {\n\tpub const ChainId: u64 = 42;\n\tpub BlockGasLimit: U256 = U256::from(NORMAL_DISPATCH_RATIO * MAXIMUM_BLOCK_WEIGHT / WEIGHT_PER_GAS);\n\tpub PrecompilesValue: FrontierPrecompiles<Runtime> = FrontierPrecompiles::<_>::new();\n}\n\nimpl pallet_evm::Config for Runtime {\n\ttype FeeCalculator = BaseFee;\n\ttype GasWeightMapping = FixedGasWeightMapping;\n\ttype BlockHashMapping = pallet_ethereum::EthereumBlockHashMapping<Self>;\n\ttype CallOrigin = EnsureAddressTruncated;\n\ttype WithdrawOrigin = EnsureAddressTruncated;\n\ttype AddressMapping = HashedAddressMapping<BlakeTwo256>;\n\ttype Currency = Balances;\n\ttype Event = Event;\n\ttype Runner = pallet_evm::runner::stack::Runner<Self>;\n\ttype PrecompilesType = FrontierPrecompiles<Self>;\n\ttype PrecompilesValue = PrecompilesValue;\n\ttype ChainId = ChainId;\n\ttype BlockGasLimit = BlockGasLimit;\n\ttype OnChargeTransaction = ();\n\ttype FindAuthor = FindAuthorTruncated<Aura>;\n}\n\nimpl pallet_ethereum::Config for Runtime {\n\ttype Event = Event;\n\ttype StateRoot = pallet_ethereum::IntermediateStateRoot<Self>;\n}\n\nframe_support::parameter_types! {\n\tpub BoundDivision: U256 = U256::from(1024);\n}\n\nimpl pallet_dynamic_fee::Config for Runtime {\n\ttype MinGasPriceBoundDivisor = BoundDivision;\n}\n\nframe_support::parameter_types! {\n\tpub IsActive: bool = true;\n\tpub DefaultBaseFeePerGas: U256 = U256::from(1_000_000_000);\n}\n\npub struct BaseFeeThreshold;\nimpl pallet_base_fee::BaseFeeThreshold for BaseFeeThreshold {\n\tfn lower() -> Permill {\n\t\tPermill::zero()\n\t}\n\tfn ideal() -> Permill {\n\t\tPermill::from_parts(500_000)\n\t}\n\tfn upper() -> Permill {\n\t\tPermill::from_parts(1_000_000)\n\t}\n}\n\nimpl pallet_base_fee::Config for Runtime {\n\ttype Event = Event;\n\ttype Threshold = BaseFeeThreshold;\n\ttype IsActive = IsActive;\n\ttype DefaultBaseFeePerGas = DefaultBaseFeePerGas;\n}\n\nimpl pallet_randomness_collective_flip::Config for Runtime {}\n\nimpl pallet_hotfix_sufficients::Config for Runtime {\n\ttype AddressMapping = HashedAddressMapping<BlakeTwo256>;\n\ttype WeightInfo = pallet_hotfix_sufficients::weights::SubstrateWeight<Runtime>;\n}\n\n// Create the runtime by composing the FRAME pallets that were previously configured.\nconstruct_runtime!(\n\tpub enum Runtime where\n\t\tBlock = Block,\n\t\tNodeBlock = opaque::Block,\n\t\tUncheckedExtrinsic = UncheckedExtrinsic\n\t{\n\t\tSystem: frame_system::{Pallet, Call, Config, Storage, Event<T>},\n\t\tRandomnessCollectiveFlip: pallet_randomness_collective_flip::{Pallet, Storage},\n\t\tTimestamp: pallet_timestamp::{Pallet, Call, Storage, Inherent},\n\t\tAura: pallet_aura::{Pallet, Config<T>},\n\t\tGrandpa: pallet_grandpa::{Pallet, Call, Storage, Config, Event},\n\t\tBalances: pallet_balances::{Pallet, Call, Storage, Config<T>, Event<T>},\n\t\tTransactionPayment: pallet_transaction_payment::{Pallet, Storage},\n\t\tSudo: pallet_sudo::{Pallet, Call, Config<T>, Storage, Event<T>},\n\t\tEthereum: pallet_ethereum::{Pallet, Call, Storage, Event, Config, Origin},\n\t\tEVM: pallet_evm::{Pallet, Config, Call, Storage, Event<T>},\n\t\tDynamicFee: pallet_dynamic_fee::{Pallet, Call, Storage, Config, Inherent},\n\t\tBaseFee: pallet_base_fee::{Pallet, Call, Storage, Config<T>, Event},\n\t\tHotfixSufficients: pallet_hotfix_sufficients::{Pallet, Call},\n\t}\n);\n\npub struct TransactionConverter;\n\nimpl fp_rpc::ConvertTransaction<UncheckedExtrinsic> for TransactionConverter {\n\tfn convert_transaction(&self, transaction: pallet_ethereum::Transaction) -> UncheckedExtrinsic {\n\t\tUncheckedExtrinsic::new_unsigned(\n\t\t\tpallet_ethereum::Call::<Runtime>::transact { transaction }.into(),\n\t\t)\n\t}\n}\n\nimpl fp_rpc::ConvertTransaction<opaque::UncheckedExtrinsic> for TransactionConverter {\n\tfn convert_transaction(\n\t\t&self,\n\t\ttransaction: pallet_ethereum::Transaction,\n\t) -> opaque::UncheckedExtrinsic {\n\t\tlet extrinsic = UncheckedExtrinsic::new_unsigned(\n\t\t\tpallet_ethereum::Call::<Runtime>::transact { transaction }.into(),\n\t\t);\n\t\tlet encoded = extrinsic.encode();\n\t\topaque::UncheckedExtrinsic::decode(&mut &encoded[..])\n\t\t\t.expect(\"Encoded extrinsic is always valid\")\n\t}\n}\n\n/// The address format for describing accounts.\npub type Address = sp_runtime::MultiAddress<AccountId, ()>;\n/// Block header type as expected by this runtime.\npub type Header = generic::Header<BlockNumber, BlakeTwo256>;\n/// Block type as expected by this runtime.\npub type Block = generic::Block<Header, UncheckedExtrinsic>;\n/// A Block signed with a Justification\npub type SignedBlock = generic::SignedBlock<Block>;\n/// BlockId type as expected by this runtime.\npub type BlockId = generic::BlockId<Block>;\n/// The SignedExtension to the basic transaction logic.\npub type SignedExtra = (\n\tframe_system::CheckNonZeroSender<Runtime>,\n\tframe_system::CheckSpecVersion<Runtime>,\n\tframe_system::CheckTxVersion<Runtime>,\n\tframe_system::CheckGenesis<Runtime>,\n\tframe_system::CheckEra<Runtime>,\n\tframe_system::CheckNonce<Runtime>,\n\tframe_system::CheckWeight<Runtime>,\n\tpallet_transaction_payment::ChargeTransactionPayment<Runtime>,\n);\n/// Unchecked extrinsic type as expected by this runtime.\npub type UncheckedExtrinsic =\n\tfp_self_contained::UncheckedExtrinsic<Address, Call, Signature, SignedExtra>;\n/// Extrinsic type that has already been checked.\npub type CheckedExtrinsic = fp_self_contained::CheckedExtrinsic<AccountId, Call, SignedExtra, H160>;\n/// The payload being signed in transactions.\npub type SignedPayload = generic::SignedPayload<Call, SignedExtra>;\n/// Executive: handles dispatch to the various modules.\npub type Executive = frame_executive::Executive<\n\tRuntime,\n\tBlock,\n\tframe_system::ChainContext<Runtime>,\n\tRuntime,\n\tAllPalletsWithSystem,\n>;\n\nimpl fp_self_contained::SelfContainedCall for Call {\n\ttype SignedInfo = H160;\n\n\tfn is_self_contained(&self) -> bool {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.is_self_contained(),\n\t\t\t_ => false,\n\t\t}\n\t}\n\n\tfn check_self_contained(&self) -> Option<Result<Self::SignedInfo, TransactionValidityError>> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.check_self_contained(),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn validate_self_contained(\n\t\t&self,\n\t\tinfo: &Self::SignedInfo,\n\t\tdispatch_info: &DispatchInfoOf<Call>,\n\t\tlen: usize,\n\t) -> Option<TransactionValidity> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.validate_self_contained(info, dispatch_info, len),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn pre_dispatch_self_contained(\n\t\t&self,\n\t\tinfo: &Self::SignedInfo,\n\t) -> Option<Result<(), TransactionValidityError>> {\n\t\tmatch self {\n\t\t\tCall::Ethereum(call) => call.pre_dispatch_self_contained(info),\n\t\t\t_ => None,\n\t\t}\n\t}\n\n\tfn apply_self_contained(\n\t\tself,\n\t\tinfo: Self::SignedInfo,\n\t) -> Option<sp_runtime::DispatchResultWithInfo<PostDispatchInfoOf<Self>>> {\n\t\tmatch self {\n\t\t\tcall @ Call::Ethereum(pallet_ethereum::Call::transact { .. }) => Some(call.dispatch(\n\t\t\t\tOrigin::from(pallet_ethereum::RawOrigin::EthereumTransaction(info)),\n\t\t\t)),\n\t\t\t_ => None,\n\t\t}\n\t}\n}\n\n#[cfg(feature = \"runtime-benchmarks\")]\n#[macro_use]\nextern crate frame_benchmarking;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benches {\n\tdefine_benchmarks!([pallet_evm, EVM]);\n}\n\nimpl_runtime_apis! {\n\timpl sp_api::Core<Block> for Runtime {\n\t\tfn version() -> RuntimeVersion {\n\t\t\tVERSION\n\t\t}\n\n\t\tfn execute_block(block: Block) {\n\t\t\tExecutive::execute_block(block)\n\t\t}\n\n\t\tfn initialize_block(header: &<Block as BlockT>::Header) {\n\t\t\tExecutive::initialize_block(header)\n\t\t}\n\t}\n\n\timpl sp_api::Metadata<Block> for Runtime {\n\t\tfn metadata() -> OpaqueMetadata {\n\t\t\tOpaqueMetadata::new(Runtime::metadata().into())\n\t\t}\n\t}\n\n\timpl sp_block_builder::BlockBuilder<Block> for Runtime {\n\t\tfn apply_extrinsic(extrinsic: <Block as BlockT>::Extrinsic) -> ApplyExtrinsicResult {\n\t\t\tExecutive::apply_extrinsic(extrinsic)\n\t\t}\n\n\t\tfn finalize_block() -> <Block as BlockT>::Header {\n\t\t\tExecutive::finalize_block()\n\t\t}\n\n\t\tfn inherent_extrinsics(data: sp_inherents::InherentData) -> Vec<<Block as BlockT>::Extrinsic> {\n\t\t\tdata.create_extrinsics()\n\t\t}\n\n\t\tfn check_inherents(\n\t\t\tblock: Block,\n\t\t\tdata: sp_inherents::InherentData,\n\t\t) -> sp_inherents::CheckInherentsResult {\n\t\t\tdata.check_extrinsics(&block)\n\t\t}\n\t}\n\n\timpl sp_transaction_pool::runtime_api::TaggedTransactionQueue<Block> for Runtime {\n\t\tfn validate_transaction(\n\t\t\tsource: TransactionSource,\n\t\t\ttx: <Block as BlockT>::Extrinsic,\n\t\t\tblock_hash: <Block as BlockT>::Hash,\n\t\t) -> TransactionValidity {\n\t\t\tExecutive::validate_transaction(source, tx, block_hash)\n\t\t}\n\t}\n\n\timpl sp_offchain::OffchainWorkerApi<Block> for Runtime {\n\t\tfn offchain_worker(header: &<Block as BlockT>::Header) {\n\t\t\tExecutive::offchain_worker(header)\n\t\t}\n\t}\n\n\timpl sp_consensus_aura::AuraApi<Block, AuraId> for Runtime {\n\t\tfn slot_duration() -> sp_consensus_aura::SlotDuration {\n\t\t\tsp_consensus_aura::SlotDuration::from_millis(Aura::slot_duration())\n\t\t}\n\n\t\tfn authorities() -> Vec<AuraId> {\n\t\t\tAura::authorities().to_vec()\n\t\t}\n\t}\n\n\timpl frame_system_rpc_runtime_api::AccountNonceApi<Block, AccountId, Index> for Runtime {\n\t\tfn account_nonce(account: AccountId) -> Index {\n\t\t\tSystem::account_nonce(account)\n\t\t}\n\t}\n\n\timpl fp_rpc::EthereumRuntimeRPCApi<Block> for Runtime {\n\t\tfn chain_id() -> u64 {\n\t\t\t<Runtime as pallet_evm::Config>::ChainId::get()\n\t\t}\n\n\t\tfn account_basic(address: H160) -> EVMAccount {\n\t\t\tlet (account, _) = EVM::account_basic(&address);\n\t\t\taccount\n\t\t}\n\n\t\tfn gas_price() -> U256 {\n\t\t\tlet (gas_price, _) = <Runtime as pallet_evm::Config>::FeeCalculator::min_gas_price();\n\t\t\tgas_price\n\t\t}\n\n\t\tfn account_code_at(address: H160) -> Vec<u8> {\n\t\t\tEVM::account_codes(address)\n\t\t}\n\n\t\tfn author() -> H160 {\n\t\t\t<pallet_evm::Pallet<Runtime>>::find_author()\n\t\t}\n\n\t\tfn storage_at(address: H160, index: U256) -> H256 {\n\t\t\tlet mut tmp = [0u8; 32];\n\t\t\tindex.to_big_endian(&mut tmp);\n\t\t\tEVM::account_storages(address, H256::from_slice(&tmp[..]))\n\t\t}\n\n\t\tfn call(\n\t\t\tfrom: H160,\n\t\t\tto: H160,\n\t\t\tdata: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: U256,\n\t\t\tmax_fee_per_gas: Option<U256>,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\testimate: bool,\n\t\t\taccess_list: Option<Vec<(H160, Vec<H256>)>>,\n\t\t) -> Result<pallet_evm::CallInfo, sp_runtime::DispatchError> {\n\t\t\tlet config = if estimate {\n\t\t\t\tlet mut config = <Runtime as pallet_evm::Config>::config().clone();\n\t\t\t\tconfig.estimate = true;\n\t\t\t\tSome(config)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t};\n\n\t\t\tlet is_transactional = false;\n\t\t\t<Runtime as pallet_evm::Config>::Runner::call(\n\t\t\t\tfrom,\n\t\t\t\tto,\n\t\t\t\tdata,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit.unique_saturated_into(),\n\t\t\t\tmax_fee_per_gas,\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list.unwrap_or_default(),\n\t\t\t\tis_transactional,\n\t\t\t\tconfig.as_ref().unwrap_or(<Runtime as pallet_evm::Config>::config()),\n\t\t\t).map_err(|err| err.error.into())\n\t\t}\n\n\t\tfn create(\n\t\t\tfrom: H160,\n\t\t\tdata: Vec<u8>,\n\t\t\tvalue: U256,\n\t\t\tgas_limit: U256,\n\t\t\tmax_fee_per_gas: Option<U256>,\n\t\t\tmax_priority_fee_per_gas: Option<U256>,\n\t\t\tnonce: Option<U256>,\n\t\t\testimate: bool,\n\t\t\taccess_list: Option<Vec<(H160, Vec<H256>)>>,\n\t\t) -> Result<pallet_evm::CreateInfo, sp_runtime::DispatchError> {\n\t\t\tlet config = if estimate {\n\t\t\t\tlet mut config = <Runtime as pallet_evm::Config>::config().clone();\n\t\t\t\tconfig.estimate = true;\n\t\t\t\tSome(config)\n\t\t\t} else {\n\t\t\t\tNone\n\t\t\t};\n\n\t\t\tlet is_transactional = false;\n\t\t\t<Runtime as pallet_evm::Config>::Runner::create(\n\t\t\t\tfrom,\n\t\t\t\tdata,\n\t\t\t\tvalue,\n\t\t\t\tgas_limit.unique_saturated_into(),\n\t\t\t\tmax_fee_per_gas,\n\t\t\t\tmax_priority_fee_per_gas,\n\t\t\t\tnonce,\n\t\t\t\taccess_list.unwrap_or_default(),\n\t\t\t\tis_transactional,\n\t\t\t\tconfig.as_ref().unwrap_or(<Runtime as pallet_evm::Config>::config()),\n\t\t\t).map_err(|err| err.error.into())\n\t\t}\n\n\t\tfn current_transaction_statuses() -> Option<Vec<TransactionStatus>> {\n\t\t\tEthereum::current_transaction_statuses()\n\t\t}\n\n\t\tfn current_block() -> Option<pallet_ethereum::Block> {\n\t\t\tEthereum::current_block()\n\t\t}\n\n\t\tfn current_receipts() -> Option<Vec<pallet_ethereum::Receipt>> {\n\t\t\tEthereum::current_receipts()\n\t\t}\n\n\t\tfn current_all() -> (\n\t\t\tOption<pallet_ethereum::Block>,\n\t\t\tOption<Vec<pallet_ethereum::Receipt>>,\n\t\t\tOption<Vec<TransactionStatus>>\n\t\t) {\n\t\t\t(\n\t\t\t\tEthereum::current_block(),\n\t\t\t\tEthereum::current_receipts(),\n\t\t\t\tEthereum::current_transaction_statuses()\n\t\t\t)\n\t\t}\n\n\t\tfn extrinsic_filter(\n\t\t\txts: Vec<<Block as BlockT>::Extrinsic>,\n\t\t) -> Vec<EthereumTransaction> {\n\t\t\txts.into_iter().filter_map(|xt| match xt.0.function {\n\t\t\t\tCall::Ethereum(transact { transaction }) => Some(transaction),\n\t\t\t\t_ => None\n\t\t\t}).collect::<Vec<EthereumTransaction>>()\n\t\t}\n\n\t\tfn elasticity() -> Option<Permill> {\n\t\t\tSome(BaseFee::elasticity())\n\t\t}\n\t}\n\n\timpl fp_rpc::ConvertTransactionRuntimeApi<Block> for Runtime {\n\t\tfn convert_transaction(transaction: EthereumTransaction) -> <Block as BlockT>::Extrinsic {\n\t\t\tUncheckedExtrinsic::new_unsigned(\n\t\t\t\tpallet_ethereum::Call::<Runtime>::transact { transaction }.into(),\n\t\t\t)\n\t\t}\n\t}\n\n\timpl pallet_transaction_payment_rpc_runtime_api::TransactionPaymentApi<\n\t\tBlock,\n\t\tBalance,\n\t> for Runtime {\n\t\tfn query_info(\n\t\t\tuxt: <Block as BlockT>::Extrinsic,\n\t\t\tlen: u32\n\t\t) -> pallet_transaction_payment_rpc_runtime_api::RuntimeDispatchInfo<Balance> {\n\t\t\tTransactionPayment::query_info(uxt, len)\n\t\t}\n\n\t\tfn query_fee_details(\n\t\t\tuxt: <Block as BlockT>::Extrinsic,\n\t\t\tlen: u32,\n\t\t) -> pallet_transaction_payment::FeeDetails<Balance> {\n\t\t\tTransactionPayment::query_fee_details(uxt, len)\n\t\t}\n\t}\n\n\timpl sp_session::SessionKeys<Block> for Runtime {\n\t\tfn generate_session_keys(seed: Option<Vec<u8>>) -> Vec<u8> {\n\t\t\topaque::SessionKeys::generate(seed)\n\t\t}\n\n\t\tfn decode_session_keys(\n\t\t\tencoded: Vec<u8>,\n\t\t) -> Option<Vec<(Vec<u8>, KeyTypeId)>> {\n\t\t\topaque::SessionKeys::decode_into_raw_public_keys(&encoded)\n\t\t}\n\t}\n\n\timpl fg_primitives::GrandpaApi<Block> for Runtime {\n\t\tfn grandpa_authorities() -> GrandpaAuthorityList {\n\t\t\tGrandpa::grandpa_authorities()\n\t\t}\n\n\t\tfn current_set_id() -> fg_primitives::SetId {\n\t\t\tGrandpa::current_set_id()\n\t\t}\n\n\t\tfn submit_report_equivocation_unsigned_extrinsic(\n\t\t\t_equivocation_proof: fg_primitives::EquivocationProof<\n\t\t\t\t<Block as BlockT>::Hash,\n\t\t\t\tNumberFor<Block>,\n\t\t\t>,\n\t\t\t_key_owner_proof: fg_primitives::OpaqueKeyOwnershipProof,\n\t\t) -> Option<()> {\n\t\t\tNone\n\t\t}\n\n\t\tfn generate_key_ownership_proof(\n\t\t\t_set_id: fg_primitives::SetId,\n\t\t\t_authority_id: GrandpaId,\n\t\t) -> Option<fg_primitives::OpaqueKeyOwnershipProof> {\n\t\t\t// NOTE: this is the only implementation possible since we've\n\t\t\t// defined our key owner proof type as a bottom type (i.e. a type\n\t\t\t// with no values).\n\t\t\tNone\n\t\t}\n\t}\n\n\t#[cfg(feature = \"runtime-benchmarks\")]\n\timpl frame_benchmarking::Benchmark<Block> for Runtime {\n\t\tfn benchmark_metadata(extra: bool) -> (\n\t\t\tVec<frame_benchmarking::BenchmarkList>,\n\t\t\tVec<frame_support::traits::StorageInfo>,\n\t\t) {\n\t\t\tuse frame_benchmarking::{Benchmarking, BenchmarkList};\n\t\t\tuse frame_support::traits::StorageInfoTrait;\n\t\t\tuse pallet_hotfix_sufficients::Pallet as PalletHotfixSufficients;\n\n\t\t\tlet mut list = Vec::<BenchmarkList>::new();\n\t\t\tlist_benchmarks!(list, extra);\n\t\t\tlist_benchmark!(list, extra, pallet_hotfix_sufficients, PalletHotfixSufficients::<Runtime>);\n\n\t\t\tlet storage_info = AllPalletsWithSystem::storage_info();\n\t\t\treturn (list, storage_info)\n\t\t}\n\n\t\tfn dispatch_benchmark(\n\t\t\tconfig: frame_benchmarking::BenchmarkConfig\n\t\t) -> Result<Vec<frame_benchmarking::BenchmarkBatch>, sp_runtime::RuntimeString> {\n\t\t\tuse frame_benchmarking::{Benchmarking, BenchmarkBatch, add_benchmark, TrackedStorageKey};\n\t\t\tuse pallet_evm::Pallet as PalletEvmBench;\n\t\t\tuse pallet_hotfix_sufficients::Pallet as PalletHotfixSufficients;\n\t\t\timpl frame_system_benchmarking::Config for Runtime {}\n\n\t\t\tlet whitelist: Vec<TrackedStorageKey> = vec![];\n\n\t\t\tlet mut batches = Vec::<BenchmarkBatch>::new();\n\t\t\tlet params = (&config, &whitelist);\n\n\t\t\tadd_benchmark!(params, batches, pallet_evm, PalletEvmBench::<Runtime>);\n\t\t\tadd_benchmark!(params, batches, pallet_hotfix_sufficients, PalletHotfixSufficients::<Runtime>);\n\n\t\t\tif batches.is_empty() { return Err(\"Benchmark not found for this pallet.\".into()) }\n\t\t\tOk(batches)\n\t\t}\n\t}\n}\n"], "filenames": ["frame/ethereum/src/lib.rs", "frame/evm/src/lib.rs", "frame/evm/src/runner/stack.rs", "frame/evm/src/tests.rs", "template/runtime/src/lib.rs"], "buggy_code_start_loc": [817, 80, 21, 271, 27], "buggy_code_end_loc": [845, 797, 634, 359, 701], "fixing_code_start_loc": [817, 80, 21, 271, 27], "fixing_code_end_loc": [845, 806, 646, 361, 701], "type": "CWE-670", "message": "Frontier is Substrate's Ethereum compatibility layer. In affected versions the truncation done when converting between EVM balance type and Substrate balance type was incorrectly implemented. This leads to possible discrepancy between appeared EVM transfer value and actual Substrate value transferred. It is recommended that an emergency upgrade to be planned and EVM execution temporarily paused in the mean time. The issue is patched in Frontier master branch commit fed5e0a9577c10bea021721e8c2c5c378e16bf66 and polkadot-v0.9.22 branch commit e3e427fa2e5d1200a784679f8015d4774cedc934. This vulnerability affects only EVM internal states, but not Substrate balance states or node. You can temporarily pause EVM execution (by setting up a Substrate `CallFilter` that disables `pallet-evm` and `pallet-ethereum` calls before the patch can be applied.", "other": {"cve": {"id": "CVE-2022-31111", "sourceIdentifier": "security-advisories@github.com", "published": "2022-07-06T18:15:19.217", "lastModified": "2022-07-14T14:18:51.873", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Frontier is Substrate's Ethereum compatibility layer. In affected versions the truncation done when converting between EVM balance type and Substrate balance type was incorrectly implemented. This leads to possible discrepancy between appeared EVM transfer value and actual Substrate value transferred. It is recommended that an emergency upgrade to be planned and EVM execution temporarily paused in the mean time. The issue is patched in Frontier master branch commit fed5e0a9577c10bea021721e8c2c5c378e16bf66 and polkadot-v0.9.22 branch commit e3e427fa2e5d1200a784679f8015d4774cedc934. This vulnerability affects only EVM internal states, but not Substrate balance states or node. You can temporarily pause EVM execution (by setting up a Substrate `CallFilter` that disables `pallet-evm` and `pallet-ethereum` calls before the patch can be applied."}, {"lang": "es", "value": "Frontier es la capa de compatibilidad con Ethereum de Substrate. En las versiones afectadas, el truncamiento realizado cuando es convertido entre el tipo de saldo de EVM y el tipo de saldo de Substrate fue implementado de forma incorrecta. Esto conlleva a una posible discrepancia entre el valor de transferencia de EVM aparecido y el valor real de Substrate transferido. Es recomendado planificar una actualizaci\u00f3n de emergencia y detener temporalmente la ejecuci\u00f3n de EVM mientras tanto. El problema est\u00e1 parcheado en el commit de la rama master de Frontier fed5e0a9577c10bea021721e8c2c5c378e16bf66 y en el commit de la rama polkadot-v0.9.22 e3e427fa2e5d1200a784679f8015d4774cedc934. Esta vulnerabilidad afecta s\u00f3lo a estados internos de EVM, pero no a estados de equilibrio del sustrato ni al nodo. Puede detenerse temporalmente la ejecuci\u00f3n de EVM (al configurar un \"CallFilter\" de Substrate que deshabilite las llamadas \"pallet-evm\" y \"pallet-ethereum\" antes de aplicar el parche"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-670"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parity:frontier:-:*:*:*:*:*:*:*", "matchCriteriaId": "B181234B-73EA-4932-916B-326F848CE8C6"}]}]}], "references": [{"url": "https://github.com/paritytech/frontier/commit/e3e427fa2e5d1200a784679f8015d4774cedc934", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/paritytech/frontier/commit/fed5e0a9577c10bea021721e8c2c5c378e16bf66", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/paritytech/frontier/pull/753", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/paritytech/frontier/security/advisories/GHSA-hc8w-mx86-9fcj", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/paritytech/frontier/commit/e3e427fa2e5d1200a784679f8015d4774cedc934"}}