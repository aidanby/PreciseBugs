{"buggy_code": ["/* Copyright (C) 2001-2019 Artifex Software, Inc.\n   All Rights Reserved.\n\n   This software is provided AS-IS with no warranty, either express or\n   implied.\n\n   This software is distributed under license and may not be copied,\n   modified or distributed except as expressly authorized under the terms\n   of the license contained in the file LICENSE in this distribution.\n\n   Refer to licensing information at http://www.artifex.com or contact\n   Artifex Software, Inc.,  1305 Grant Avenue - Suite 200, Novato,\n   CA 94945, U.S.A., +1(415)492-9861, for further information.\n*/\n\n/*\n    jbig2dec\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include \"os_types.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>             /* memcpy() */\n\n#include \"jbig2.h\"\n#include \"jbig2_priv.h\"\n#include \"jbig2_image.h\"\n\n#if !defined (INT32_MAX)\n#define INT32_MAX  0x7fffffff\n#endif\n\n/* allocate a Jbig2Image structure and its associated bitmap */\nJbig2Image *\njbig2_image_new(Jbig2Ctx *ctx, uint32_t width, uint32_t height)\n{\n    Jbig2Image *image;\n    uint32_t stride;\n\n    if (width == 0 || height == 0) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to create zero sized image\");\n        return NULL;\n    }\n\n    image = jbig2_new(ctx, Jbig2Image, 1);\n    if (image == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to allocate image\");\n        return NULL;\n    }\n\n    stride = ((width - 1) >> 3) + 1;    /* generate a byte-aligned stride */\n\n    /* check for integer multiplication overflow */\n    if (height > (INT32_MAX / stride)) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"integer multiplication overflow (stride=%u, height=%u)\", stride, height);\n        jbig2_free(ctx->allocator, image);\n        return NULL;\n    }\n    image->data = jbig2_new(ctx, uint8_t, (size_t) height * stride);\n    if (image->data == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to allocate image data buffer (stride=%u, height=%u)\", stride, height);\n        jbig2_free(ctx->allocator, image);\n        return NULL;\n    }\n\n    image->width = width;\n    image->height = height;\n    image->stride = stride;\n    image->refcount = 1;\n\n    return image;\n}\n\n/* bump the reference count for an image pointer */\nJbig2Image *\njbig2_image_reference(Jbig2Ctx *ctx, Jbig2Image *image)\n{\n    if (image)\n        image->refcount++;\n    return image;\n}\n\n/* release an image pointer, freeing it it appropriate */\nvoid\njbig2_image_release(Jbig2Ctx *ctx, Jbig2Image *image)\n{\n    if (image == NULL)\n        return;\n    image->refcount--;\n    if (image->refcount == 0)\n        jbig2_image_free(ctx, image);\n}\n\n/* free a Jbig2Image structure and its associated memory */\nvoid\njbig2_image_free(Jbig2Ctx *ctx, Jbig2Image *image)\n{\n    if (image != NULL) {\n        jbig2_free(ctx->allocator, image->data);\n        jbig2_free(ctx->allocator, image);\n    }\n}\n\n/* resize a Jbig2Image */\nJbig2Image *\njbig2_image_resize(Jbig2Ctx *ctx, Jbig2Image *image, uint32_t width, uint32_t height, int value)\n{\n    if (width == image->width) {\n        uint8_t *data;\n\n        /* check for integer multiplication overflow */\n        if (image->height > (INT32_MAX / image->stride)) {\n            jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"integer multiplication overflow during resize (stride=%u, height=%u)\", image->stride, height);\n            return NULL;\n        }\n        /* use the same stride, just change the length */\n        data = jbig2_renew(ctx, image->data, uint8_t, (size_t) height * image->stride);\n        if (data == NULL) {\n            jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to reallocate image\");\n            return NULL;\n        }\n        image->data = data;\n        if (height > image->height) {\n            const uint8_t fill = value ? 0xFF : 0x00;\n            memset(image->data + (size_t) image->height * image->stride, fill, ((size_t) height - image->height) * image->stride);\n        }\n        image->height = height;\n\n    } else {\n        Jbig2Image *newimage;\n        int code;\n\n        /* Unoptimized implementation, but it works. */\n\n        newimage = jbig2_image_new(ctx, width, height);\n        if (newimage == NULL) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, -1, \"failed to allocate resized image\");\n            return NULL;\n        }\n        jbig2_image_clear(ctx, newimage, value);\n\n        code = jbig2_image_compose(ctx, newimage, image, 0, 0, JBIG2_COMPOSE_REPLACE);\n        if (code < 0) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, -1, \"failed to compose image buffers when resizing\");\n            jbig2_image_release(ctx, newimage);\n            return NULL;\n        }\n\n        /* if refcount > 1 the original image, its pointer must\n        be kept, so simply replaces its innards, and throw away\n        the empty new image shell. */\n        jbig2_free(ctx->allocator, image->data);\n        image->width = newimage->width;\n        image->height = newimage->height;\n        image->stride = newimage->stride;\n        image->data = newimage->data;\n        jbig2_free(ctx->allocator, newimage);\n    }\n\n    return image;\n}\n\nstatic inline void\ntemplate_image_compose_opt(const uint8_t * JBIG2_RESTRICT ss, uint8_t * JBIG2_RESTRICT dd, int early, int late, uint8_t leftmask, uint8_t rightmask, uint32_t bytewidth_, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride, Jbig2ComposeOp op)\n{\n    int i;\n    uint32_t j;\n    int bytewidth = (int)bytewidth_;\n\n    if (bytewidth == 1) {\n        for (j = 0; j < h; j++) {\n            /* Only 1 byte! */\n            uint8_t v = (((early ? 0 : ss[0]<<8) | (late ? 0 : ss[1]))>>shift);\n            if (op == JBIG2_COMPOSE_OR)\n                *dd |= v & leftmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *dd &= (v & leftmask) | ~leftmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *dd ^= v & leftmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *dd ^= (~v) & leftmask;\n            else /* Replace */\n                *dd = (v & leftmask) | (*dd & ~leftmask);\n            dd += dstride;\n            ss += sstride;\n        }\n        return;\n    }\n    bytewidth -= 2;\n    if (shift == 0) {\n        ss++;\n        for (j = 0; j < h; j++) {\n            /* Left byte */\n            const uint8_t * JBIG2_RESTRICT s = ss;\n            uint8_t * JBIG2_RESTRICT d = dd;\n            if (op == JBIG2_COMPOSE_OR)\n                *d++ |= *s++ & leftmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *d++ &= (*s++ & leftmask) | ~leftmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *d++ ^= *s++ & leftmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *d++ ^= (~*s++) & leftmask;\n            else /* Replace */\n                *d = (*s++ & leftmask) | (*d & ~leftmask), d++;\n            /* Central run */\n            for (i = bytewidth; i != 0; i--) {\n                if (op == JBIG2_COMPOSE_OR)\n                    *d++ |= *s++;\n                else if (op == JBIG2_COMPOSE_AND)\n                    *d++ &= *s++;\n                else if (op == JBIG2_COMPOSE_XOR)\n                    *d++ ^= *s++;\n                else if (op == JBIG2_COMPOSE_XNOR)\n                    *d++ ^= ~*s++;\n                else /* Replace */\n                    *d++ = *s++;\n            }\n            /* Right byte */\n            if (op == JBIG2_COMPOSE_OR)\n                *d |= *s & rightmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *d &= (*s & rightmask) | ~rightmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *d ^= *s & rightmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *d ^= (~*s) & rightmask;\n            else /* Replace */\n                *d = (*s & rightmask) | (*d & ~rightmask);\n            dd += dstride;\n            ss += sstride;\n        }\n    } else {\n        for (j = 0; j < h; j++) {\n            /* Left byte */\n            const uint8_t * JBIG2_RESTRICT s = ss;\n            uint8_t * JBIG2_RESTRICT d = dd;\n            uint8_t s0, s1, v;\n            s0 = early ? 0 : *s;\n            s++;\n            s1 = *s++;\n            v = ((s0<<8) | s1)>>shift;\n            if (op == JBIG2_COMPOSE_OR)\n                *d++ |= v & leftmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *d++ &= (v & leftmask) | ~leftmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *d++ ^= v & leftmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *d++ ^= (~v) & leftmask;\n            else /* Replace */\n                *d = (v & leftmask) | (*d & ~leftmask), d++;\n            /* Central run */\n            for (i = bytewidth; i > 0; i--) {\n                s0 = s1; s1 = *s++;\n                v = ((s0<<8) | s1)>>shift;\n                if (op == JBIG2_COMPOSE_OR)\n                    *d++ |= v;\n                else if (op == JBIG2_COMPOSE_AND)\n                    *d++ &= v;\n                else if (op == JBIG2_COMPOSE_XOR)\n                    *d++ ^= v;\n                else if (op == JBIG2_COMPOSE_XNOR)\n                    *d++ ^= ~v;\n                else /* Replace */\n                    *d++ = v;\n            }\n            /* Right byte */\n            s0 = s1; s1 = (late ? 0 : *s);\n            v = (((s0<<8) | s1)>>shift);\n            if (op == JBIG2_COMPOSE_OR)\n                *d |= v & rightmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *d &= (v & rightmask) | ~rightmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *d ^= v & rightmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *d ^= ~v & rightmask;\n            else /* Replace */\n                *d = (v & rightmask) | (*d & ~rightmask);\n            dd += dstride;\n            ss += sstride;\n        }\n    }\n}\n\nstatic void\njbig2_image_compose_opt_OR(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_OR);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_OR);\n}\n\nstatic void\njbig2_image_compose_opt_AND(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_AND);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_AND);\n}\n\nstatic void\njbig2_image_compose_opt_XOR(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_XOR);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_XOR);\n}\n\nstatic void\njbig2_image_compose_opt_XNOR(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_XNOR);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_XNOR);\n}\n\nstatic void\njbig2_image_compose_opt_REPLACE(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_REPLACE);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_REPLACE);\n}\n\n/* composite one jbig2_image onto another */\nint\njbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)\n{\n    uint32_t w, h;\n    uint32_t shift;\n    uint32_t leftbyte;\n    uint8_t *ss;\n    uint8_t *dd;\n    uint8_t leftmask, rightmask;\n    int early = x >= 0;\n    int late;\n    uint32_t bytewidth;\n    uint32_t syoffset = 0;\n\n    if (src == NULL)\n        return 0;\n\n    /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */\n\n    /* Data is packed msb first within a byte, so with bits numbered: 01234567.\n     * Second byte is: 89abcdef. So to combine into a run, we use:\n     *       (s[0]<<8) | s[1] == 0123456789abcdef.\n     * To read from src into dst at offset 3, we need to read:\n     *    read:      0123456789abcdef...\n     *    write:  0123456798abcdef...\n     * In general, to read from src and write into dst at offset x, we need to shift\n     * down by (x&7) bits to allow for bit alignment. So shift = x&7.\n     * So the 'central' part of our runs will see us doing:\n     *   *d++ op= ((s[0]<<8)|s[1])>>shift;\n     * with special cases on the left and right edges of the run to mask.\n     * With the left hand edge, we have to be careful not to 'underread' the start of\n     * the src image; this is what the early flag is about. Similarly we have to be\n     * careful not to read off the right hand edge; this is what the late flag is for.\n     */\n\n    /* clip */\n    w = src->width;\n    h = src->height;\n    shift = (x & 7);\n    ss = src->data - early;\n\n    if (x < 0) {\n        if (w < (uint32_t) -x)\n            w = 0;\n        else\n            w += x;\n        ss += (-x-1)>>3;\n        x = 0;\n    }\n    if (y < 0) {\n        if (h < (uint32_t) -y)\n            h = 0;\n        else\n            h += y;\n        syoffset = -y * src->stride;\n        y = 0;\n    }\n    if ((uint32_t)x + w > dst->width)\n    {\n        if (dst->width < (uint32_t)x)\n            w = 0;\n        else\n            w = dst->width - x;\n    }\n    if ((uint32_t)y + h > dst->height)\n    {\n        if (dst->height < (uint32_t)y)\n            h = 0;\n        else\n            h = dst->height - y;\n    }\n#ifdef JBIG2_DEBUG\n    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"compositing %dx%d at (%d, %d) after clipping\", w, h, x, y);\n#endif\n\n    /* check for zero clipping region */\n    if ((w <= 0) || (h <= 0)) {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"zero clipping region\");\n#endif\n        return 0;\n    }\n\n    leftbyte = (uint32_t) x >> 3;\n    dd = dst->data + y * dst->stride + leftbyte;\n    bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;\n    leftmask = 255>>(x&7);\n    rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));\n    if (bytewidth == 1)\n        leftmask &= rightmask;\n    late = (ss + bytewidth >= src->data + ((src->width+7)>>3));\n    ss += syoffset;\n\n    switch(op)\n    {\n    case JBIG2_COMPOSE_OR:\n        jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_AND:\n        jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XOR:\n        jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XNOR:\n        jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_REPLACE:\n        jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    }\n\n    return 0;\n}\n\n/* initialize an image bitmap to a constant value */\nvoid\njbig2_image_clear(Jbig2Ctx *ctx, Jbig2Image *image, int value)\n{\n    const uint8_t fill = value ? 0xFF : 0x00;\n\n    memset(image->data, fill, image->stride * image->height);\n}\n\n/* look up a pixel value in an image.\n   returns 0 outside the image frame for the convenience of\n   the template code\n*/\nint\njbig2_image_get_pixel(Jbig2Image *image, int x, int y)\n{\n    const int w = image->width;\n    const int h = image->height;\n    const int byte = (x >> 3) + y * image->stride;\n    const int bit = 7 - (x & 7);\n\n    if ((x < 0) || (x >= w))\n        return 0;\n    if ((y < 0) || (y >= h))\n        return 0;\n\n    return ((image->data[byte] >> bit) & 1);\n}\n\n/* set an individual pixel value in an image */\nvoid\njbig2_image_set_pixel(Jbig2Image *image, int x, int y, bool value)\n{\n    const int w = image->width;\n    const int h = image->height;\n    int scratch, mask;\n    int bit, byte;\n\n    if ((x < 0) || (x >= w))\n        return;\n    if ((y < 0) || (y >= h))\n        return;\n\n    byte = (x >> 3) + y * image->stride;\n    bit = 7 - (x & 7);\n    mask = (1 << bit) ^ 0xff;\n\n    scratch = image->data[byte] & mask;\n    image->data[byte] = scratch | (value << bit);\n}\n"], "fixing_code": ["/* Copyright (C) 2001-2019 Artifex Software, Inc.\n   All Rights Reserved.\n\n   This software is provided AS-IS with no warranty, either express or\n   implied.\n\n   This software is distributed under license and may not be copied,\n   modified or distributed except as expressly authorized under the terms\n   of the license contained in the file LICENSE in this distribution.\n\n   Refer to licensing information at http://www.artifex.com or contact\n   Artifex Software, Inc.,  1305 Grant Avenue - Suite 200, Novato,\n   CA 94945, U.S.A., +1(415)492-9861, for further information.\n*/\n\n/*\n    jbig2dec\n*/\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n#include \"os_types.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>             /* memcpy() */\n\n#include \"jbig2.h\"\n#include \"jbig2_priv.h\"\n#include \"jbig2_image.h\"\n\n#if !defined (INT32_MAX)\n#define INT32_MAX  0x7fffffff\n#endif\n#if !defined (UINT32_MAX)\n#define UINT32_MAX  0xffffffffu\n#endif\n\n/* allocate a Jbig2Image structure and its associated bitmap */\nJbig2Image *\njbig2_image_new(Jbig2Ctx *ctx, uint32_t width, uint32_t height)\n{\n    Jbig2Image *image;\n    uint32_t stride;\n\n    if (width == 0 || height == 0) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to create zero sized image\");\n        return NULL;\n    }\n\n    image = jbig2_new(ctx, Jbig2Image, 1);\n    if (image == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to allocate image\");\n        return NULL;\n    }\n\n    stride = ((width - 1) >> 3) + 1;    /* generate a byte-aligned stride */\n\n    /* check for integer multiplication overflow */\n    if (height > (INT32_MAX / stride)) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"integer multiplication overflow (stride=%u, height=%u)\", stride, height);\n        jbig2_free(ctx->allocator, image);\n        return NULL;\n    }\n    image->data = jbig2_new(ctx, uint8_t, (size_t) height * stride);\n    if (image->data == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to allocate image data buffer (stride=%u, height=%u)\", stride, height);\n        jbig2_free(ctx->allocator, image);\n        return NULL;\n    }\n\n    image->width = width;\n    image->height = height;\n    image->stride = stride;\n    image->refcount = 1;\n\n    return image;\n}\n\n/* bump the reference count for an image pointer */\nJbig2Image *\njbig2_image_reference(Jbig2Ctx *ctx, Jbig2Image *image)\n{\n    if (image)\n        image->refcount++;\n    return image;\n}\n\n/* release an image pointer, freeing it it appropriate */\nvoid\njbig2_image_release(Jbig2Ctx *ctx, Jbig2Image *image)\n{\n    if (image == NULL)\n        return;\n    image->refcount--;\n    if (image->refcount == 0)\n        jbig2_image_free(ctx, image);\n}\n\n/* free a Jbig2Image structure and its associated memory */\nvoid\njbig2_image_free(Jbig2Ctx *ctx, Jbig2Image *image)\n{\n    if (image != NULL) {\n        jbig2_free(ctx->allocator, image->data);\n        jbig2_free(ctx->allocator, image);\n    }\n}\n\n/* resize a Jbig2Image */\nJbig2Image *\njbig2_image_resize(Jbig2Ctx *ctx, Jbig2Image *image, uint32_t width, uint32_t height, int value)\n{\n    if (width == image->width) {\n        uint8_t *data;\n\n        /* check for integer multiplication overflow */\n        if (image->height > (INT32_MAX / image->stride)) {\n            jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"integer multiplication overflow during resize (stride=%u, height=%u)\", image->stride, height);\n            return NULL;\n        }\n        /* use the same stride, just change the length */\n        data = jbig2_renew(ctx, image->data, uint8_t, (size_t) height * image->stride);\n        if (data == NULL) {\n            jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to reallocate image\");\n            return NULL;\n        }\n        image->data = data;\n        if (height > image->height) {\n            const uint8_t fill = value ? 0xFF : 0x00;\n            memset(image->data + (size_t) image->height * image->stride, fill, ((size_t) height - image->height) * image->stride);\n        }\n        image->height = height;\n\n    } else {\n        Jbig2Image *newimage;\n        int code;\n\n        /* Unoptimized implementation, but it works. */\n\n        newimage = jbig2_image_new(ctx, width, height);\n        if (newimage == NULL) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, -1, \"failed to allocate resized image\");\n            return NULL;\n        }\n        jbig2_image_clear(ctx, newimage, value);\n\n        code = jbig2_image_compose(ctx, newimage, image, 0, 0, JBIG2_COMPOSE_REPLACE);\n        if (code < 0) {\n            jbig2_error(ctx, JBIG2_SEVERITY_WARNING, -1, \"failed to compose image buffers when resizing\");\n            jbig2_image_release(ctx, newimage);\n            return NULL;\n        }\n\n        /* if refcount > 1 the original image, its pointer must\n        be kept, so simply replaces its innards, and throw away\n        the empty new image shell. */\n        jbig2_free(ctx->allocator, image->data);\n        image->width = newimage->width;\n        image->height = newimage->height;\n        image->stride = newimage->stride;\n        image->data = newimage->data;\n        jbig2_free(ctx->allocator, newimage);\n    }\n\n    return image;\n}\n\nstatic inline void\ntemplate_image_compose_opt(const uint8_t * JBIG2_RESTRICT ss, uint8_t * JBIG2_RESTRICT dd, int early, int late, uint8_t leftmask, uint8_t rightmask, uint32_t bytewidth_, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride, Jbig2ComposeOp op)\n{\n    int i;\n    uint32_t j;\n    int bytewidth = (int)bytewidth_;\n\n    if (bytewidth == 1) {\n        for (j = 0; j < h; j++) {\n            /* Only 1 byte! */\n            uint8_t v = (((early ? 0 : ss[0]<<8) | (late ? 0 : ss[1]))>>shift);\n            if (op == JBIG2_COMPOSE_OR)\n                *dd |= v & leftmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *dd &= (v & leftmask) | ~leftmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *dd ^= v & leftmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *dd ^= (~v) & leftmask;\n            else /* Replace */\n                *dd = (v & leftmask) | (*dd & ~leftmask);\n            dd += dstride;\n            ss += sstride;\n        }\n        return;\n    }\n    bytewidth -= 2;\n    if (shift == 0) {\n        ss++;\n        for (j = 0; j < h; j++) {\n            /* Left byte */\n            const uint8_t * JBIG2_RESTRICT s = ss;\n            uint8_t * JBIG2_RESTRICT d = dd;\n            if (op == JBIG2_COMPOSE_OR)\n                *d++ |= *s++ & leftmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *d++ &= (*s++ & leftmask) | ~leftmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *d++ ^= *s++ & leftmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *d++ ^= (~*s++) & leftmask;\n            else /* Replace */\n                *d = (*s++ & leftmask) | (*d & ~leftmask), d++;\n            /* Central run */\n            for (i = bytewidth; i != 0; i--) {\n                if (op == JBIG2_COMPOSE_OR)\n                    *d++ |= *s++;\n                else if (op == JBIG2_COMPOSE_AND)\n                    *d++ &= *s++;\n                else if (op == JBIG2_COMPOSE_XOR)\n                    *d++ ^= *s++;\n                else if (op == JBIG2_COMPOSE_XNOR)\n                    *d++ ^= ~*s++;\n                else /* Replace */\n                    *d++ = *s++;\n            }\n            /* Right byte */\n            if (op == JBIG2_COMPOSE_OR)\n                *d |= *s & rightmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *d &= (*s & rightmask) | ~rightmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *d ^= *s & rightmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *d ^= (~*s) & rightmask;\n            else /* Replace */\n                *d = (*s & rightmask) | (*d & ~rightmask);\n            dd += dstride;\n            ss += sstride;\n        }\n    } else {\n        for (j = 0; j < h; j++) {\n            /* Left byte */\n            const uint8_t * JBIG2_RESTRICT s = ss;\n            uint8_t * JBIG2_RESTRICT d = dd;\n            uint8_t s0, s1, v;\n            s0 = early ? 0 : *s;\n            s++;\n            s1 = *s++;\n            v = ((s0<<8) | s1)>>shift;\n            if (op == JBIG2_COMPOSE_OR)\n                *d++ |= v & leftmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *d++ &= (v & leftmask) | ~leftmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *d++ ^= v & leftmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *d++ ^= (~v) & leftmask;\n            else /* Replace */\n                *d = (v & leftmask) | (*d & ~leftmask), d++;\n            /* Central run */\n            for (i = bytewidth; i > 0; i--) {\n                s0 = s1; s1 = *s++;\n                v = ((s0<<8) | s1)>>shift;\n                if (op == JBIG2_COMPOSE_OR)\n                    *d++ |= v;\n                else if (op == JBIG2_COMPOSE_AND)\n                    *d++ &= v;\n                else if (op == JBIG2_COMPOSE_XOR)\n                    *d++ ^= v;\n                else if (op == JBIG2_COMPOSE_XNOR)\n                    *d++ ^= ~v;\n                else /* Replace */\n                    *d++ = v;\n            }\n            /* Right byte */\n            s0 = s1; s1 = (late ? 0 : *s);\n            v = (((s0<<8) | s1)>>shift);\n            if (op == JBIG2_COMPOSE_OR)\n                *d |= v & rightmask;\n            else if (op == JBIG2_COMPOSE_AND)\n                *d &= (v & rightmask) | ~rightmask;\n            else if (op == JBIG2_COMPOSE_XOR)\n                *d ^= v & rightmask;\n            else if (op == JBIG2_COMPOSE_XNOR)\n                *d ^= ~v & rightmask;\n            else /* Replace */\n                *d = (v & rightmask) | (*d & ~rightmask);\n            dd += dstride;\n            ss += sstride;\n        }\n    }\n}\n\nstatic void\njbig2_image_compose_opt_OR(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_OR);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_OR);\n}\n\nstatic void\njbig2_image_compose_opt_AND(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_AND);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_AND);\n}\n\nstatic void\njbig2_image_compose_opt_XOR(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_XOR);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_XOR);\n}\n\nstatic void\njbig2_image_compose_opt_XNOR(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_XNOR);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_XNOR);\n}\n\nstatic void\njbig2_image_compose_opt_REPLACE(const uint8_t *s, uint8_t *d, int early, int late, uint8_t mask, uint8_t rightmask, uint32_t bytewidth, uint32_t h, uint32_t shift, uint32_t dstride, uint32_t sstride)\n{\n    if (early || late)\n        template_image_compose_opt(s, d, early, late, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_REPLACE);\n    else\n        template_image_compose_opt(s, d, 0, 0, mask, rightmask, bytewidth, h, shift, dstride, sstride, JBIG2_COMPOSE_REPLACE);\n}\n\n/* composite one jbig2_image onto another */\nint\njbig2_image_compose(Jbig2Ctx *ctx, Jbig2Image *dst, Jbig2Image *src, int x, int y, Jbig2ComposeOp op)\n{\n    uint32_t w, h;\n    uint32_t shift;\n    uint32_t leftbyte;\n    uint8_t *ss;\n    uint8_t *dd;\n    uint8_t leftmask, rightmask;\n    int early = x >= 0;\n    int late;\n    uint32_t bytewidth;\n    uint32_t syoffset = 0;\n\n    if (src == NULL)\n        return 0;\n\n    if ((UINT32_MAX - src->width  < (x > 0 ? x : -x)) ||\n        (UINT32_MAX - src->height < (y > 0 ? y : -y)))\n    {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"overflow in compose_image\");\n#endif\n        return 0;\n    }\n\n    /* This code takes a src image and combines it onto dst at offset (x,y), with operation op. */\n\n    /* Data is packed msb first within a byte, so with bits numbered: 01234567.\n     * Second byte is: 89abcdef. So to combine into a run, we use:\n     *       (s[0]<<8) | s[1] == 0123456789abcdef.\n     * To read from src into dst at offset 3, we need to read:\n     *    read:      0123456789abcdef...\n     *    write:  0123456798abcdef...\n     * In general, to read from src and write into dst at offset x, we need to shift\n     * down by (x&7) bits to allow for bit alignment. So shift = x&7.\n     * So the 'central' part of our runs will see us doing:\n     *   *d++ op= ((s[0]<<8)|s[1])>>shift;\n     * with special cases on the left and right edges of the run to mask.\n     * With the left hand edge, we have to be careful not to 'underread' the start of\n     * the src image; this is what the early flag is about. Similarly we have to be\n     * careful not to read off the right hand edge; this is what the late flag is for.\n     */\n\n    /* clip */\n    w = src->width;\n    h = src->height;\n    shift = (x & 7);\n    ss = src->data - early;\n\n    if (x < 0) {\n        if (w < (uint32_t) -x)\n            w = 0;\n        else\n            w += x;\n        ss += (-x-1)>>3;\n        x = 0;\n    }\n    if (y < 0) {\n        if (h < (uint32_t) -y)\n            h = 0;\n        else\n            h += y;\n        syoffset = -y * src->stride;\n        y = 0;\n    }\n    if ((uint32_t)x + w > dst->width)\n    {\n        if (dst->width < (uint32_t)x)\n            w = 0;\n        else\n            w = dst->width - x;\n    }\n    if ((uint32_t)y + h > dst->height)\n    {\n        if (dst->height < (uint32_t)y)\n            h = 0;\n        else\n            h = dst->height - y;\n    }\n#ifdef JBIG2_DEBUG\n    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"compositing %dx%d at (%d, %d) after clipping\", w, h, x, y);\n#endif\n\n    /* check for zero clipping region */\n    if ((w <= 0) || (h <= 0)) {\n#ifdef JBIG2_DEBUG\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, -1, \"zero clipping region\");\n#endif\n        return 0;\n    }\n\n    leftbyte = (uint32_t) x >> 3;\n    dd = dst->data + y * dst->stride + leftbyte;\n    bytewidth = (((uint32_t) x + w - 1) >> 3) - leftbyte + 1;\n    leftmask = 255>>(x&7);\n    rightmask = (((x+w)&7) == 0) ? 255 : ~(255>>((x+w)&7));\n    if (bytewidth == 1)\n        leftmask &= rightmask;\n    late = (ss + bytewidth >= src->data + ((src->width+7)>>3));\n    ss += syoffset;\n\n    switch(op)\n    {\n    case JBIG2_COMPOSE_OR:\n        jbig2_image_compose_opt_OR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_AND:\n        jbig2_image_compose_opt_AND(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XOR:\n        jbig2_image_compose_opt_XOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_XNOR:\n        jbig2_image_compose_opt_XNOR(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    case JBIG2_COMPOSE_REPLACE:\n        jbig2_image_compose_opt_REPLACE(ss, dd, early, late, leftmask, rightmask, bytewidth, h, shift, dst->stride, src->stride);\n        break;\n    }\n\n    return 0;\n}\n\n/* initialize an image bitmap to a constant value */\nvoid\njbig2_image_clear(Jbig2Ctx *ctx, Jbig2Image *image, int value)\n{\n    const uint8_t fill = value ? 0xFF : 0x00;\n\n    memset(image->data, fill, image->stride * image->height);\n}\n\n/* look up a pixel value in an image.\n   returns 0 outside the image frame for the convenience of\n   the template code\n*/\nint\njbig2_image_get_pixel(Jbig2Image *image, int x, int y)\n{\n    const int w = image->width;\n    const int h = image->height;\n    const int byte = (x >> 3) + y * image->stride;\n    const int bit = 7 - (x & 7);\n\n    if ((x < 0) || (x >= w))\n        return 0;\n    if ((y < 0) || (y >= h))\n        return 0;\n\n    return ((image->data[byte] >> bit) & 1);\n}\n\n/* set an individual pixel value in an image */\nvoid\njbig2_image_set_pixel(Jbig2Image *image, int x, int y, bool value)\n{\n    const int w = image->width;\n    const int h = image->height;\n    int scratch, mask;\n    int bit, byte;\n\n    if ((x < 0) || (x >= w))\n        return;\n    if ((y < 0) || (y >= h))\n        return;\n\n    byte = (x >> 3) + y * image->stride;\n    bit = 7 - (x & 7);\n    mask = (1 << bit) ^ 0xff;\n\n    scratch = image->data[byte] & mask;\n    image->data[byte] = scratch | (value << bit);\n}\n"], "filenames": ["jbig2_image.c"], "buggy_code_start_loc": [34], "buggy_code_end_loc": [353], "fixing_code_start_loc": [35], "fixing_code_end_loc": [366], "type": "CWE-787", "message": "jbig2_image_compose in jbig2_image.c in Artifex jbig2dec before 0.18 has a heap-based buffer overflow.", "other": {"cve": {"id": "CVE-2020-12268", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-27T02:15:12.617", "lastModified": "2021-11-02T14:25:46.040", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "jbig2_image_compose in jbig2_image.c in Artifex jbig2dec before 0.18 has a heap-based buffer overflow."}, {"lang": "es", "value": "La funci\u00f3n jbig2_image_compose en el archivo jbig2_image.c en Artifex jbig2dec versiones anteriores a la versi\u00f3n  0.18, tiene un desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:artifex:jbig2dec:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.18", "matchCriteriaId": "1C6E732E-B69A-4034-8EF3-E2342860AB38"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00034.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=20332", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/ArtifexSoftware/jbig2dec/commit/0726320a4b55078e9d8deb590e477d598b3da66e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ArtifexSoftware/jbig2dec/compare/0.17...0.18", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/10/msg00023.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ArtifexSoftware/jbig2dec/commit/0726320a4b55078e9d8deb590e477d598b3da66e"}}